void DocStore::do_cool_hot_shard(DocStore *this)
{
  int v2;
  NSObject *v3;
  os_log_type_t v4;
  int v5;
  uint8_t buf[16];
  uint64_t v7;

  v7 = *MEMORY[0x1E4F143B8];
  v2 = *__error();
  v3 = _SILogForLogForCategory(8);
  v4 = 2 * (dword_1E9FC90C4 < 4);
  if (os_log_type_enabled(v3, v4))
  {
    v5 = *((_DWORD *)this + 1);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v5;
    _os_log_impl(&dword_1BD672000, v3, v4, "do_cool_hot_shard called with hotfd %d", buf, 8u);
  }
  *__error() = v2;
  operator new();
}

uint64_t DocStore::add_cold_shard_to_bloom_filter(DocStore *this, int a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)this + 2) + 32 * a2;
  if (*(char *)(v4 + 23) < 0) {
    uint64_t v4 = *(void *)v4;
  }
  *(void *)v24 = 0;
  memset(&__p, 0, sizeof(__p));
  uint64_t v5 = openat(*(_DWORD *)this, (const char *)v4, 0);
  int v6 = v5;
  if ((v5 & 0x80000000) != 0)
  {
    int v13 = *__error();
    uint64_t v8 = -v13;
    int v9 = *__error();
    v10 = _SILogForLogForCategory(8);
    os_log_type_t v11 = dword_1E9FC90C4 < 3;
    if (os_log_type_enabled(v10, (os_log_type_t)(dword_1E9FC90C4 < 3)))
    {
      *(_DWORD *)buf = 136315394;
      uint64_t v26 = v4;
      __int16 v27 = 2080;
      v28 = strerror(v13);
      v12 = "*warn* add_cold_shard_to_bloom_filter:  open(%s): %s";
      goto LABEL_21;
    }
LABEL_22:
    *__error() = v9;
    uint64_t v14 = *(void *)v24;
    goto LABEL_23;
  }
  uint64_t search_context_for_fd = cold_shard_create_search_context_for_fd(v5);
  if (search_context_for_fd)
  {
    uint64_t v8 = search_context_for_fd;
    int v9 = *__error();
    v10 = _SILogForLogForCategory(8);
    os_log_type_t v11 = dword_1E9FC90C4 < 3;
    if (os_log_type_enabled(v10, (os_log_type_t)(dword_1E9FC90C4 < 3)))
    {
      *(_DWORD *)buf = 136315394;
      uint64_t v26 = v4;
      __int16 v27 = 2080;
      v28 = strerror(-(int)v8);
      v12 = "*warn* add_cold_shard_to_bloom_filter:  create_search_context_for_fd(%s): %s";
LABEL_21:
      _os_log_impl(&dword_1BD672000, v10, v11, v12, buf, 0x16u);
      goto LABEL_22;
    }
    goto LABEL_22;
  }
  uint64_t v14 = *(void *)v24;
  uint64_t document_index = cold_shard_get_document_index(*(uint64_t *)v24, &__p);
  if (document_index)
  {
    uint64_t v8 = document_index;
    int v9 = *__error();
    v10 = _SILogForLogForCategory(8);
    os_log_type_t v11 = dword_1E9FC90C4 < 3;
    if (os_log_type_enabled(v10, (os_log_type_t)(dword_1E9FC90C4 < 3)))
    {
      v16 = strerror(-(int)v8);
      *(_DWORD *)buf = 136315394;
      uint64_t v26 = v4;
      __int16 v27 = 2080;
      v28 = v16;
      v12 = "*warn* add_cold_shard_to_bloom_filter:  get_document_index(%s): %s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  v21[0] = MEMORY[0x1E4F143A8];
  v21[1] = 0x40000000;
  v21[2] = ___ZN8DocStore30add_cold_shard_to_bloom_filterEi_block_invoke;
  v21[3] = &__block_descriptor_tmp_32;
  v21[4] = this;
  int v22 = a2;
  uint64_t v8 = cold_shard_document_index_iterate((unsigned __int8 *)p_p, size, (uint64_t)v21);
  if (v8)
  {
    int v9 = *__error();
    v10 = _SILogForLogForCategory(8);
    os_log_type_t v11 = dword_1E9FC90C4 < 3;
    if (os_log_type_enabled(v10, (os_log_type_t)(dword_1E9FC90C4 < 3)))
    {
      v19 = strerror(-(int)v8);
      *(_DWORD *)buf = 136315394;
      uint64_t v26 = v4;
      __int16 v27 = 2080;
      v28 = v19;
      v12 = "*warn* add_cold_shard_to_bloom_filter:  document_index_iterate(%s): %s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
LABEL_23:
  if (v14) {
    MEMORY[0x1C1881000](v14, 0x1000C4034A301B9);
  }
  if ((v6 & 0x80000000) == 0) {
    close(v6);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v8;
}

uint64_t DocStore::create(DocStore *this)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  int v2 = *__error();
  v3 = _SILogForLogForCategory(8);
  os_log_type_t v4 = 2 * (dword_1E9FC90C4 < 4);
  if (os_log_type_enabled(v3, v4))
  {
    int v5 = *(_DWORD *)this;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v5;
    _os_log_impl(&dword_1BD672000, v3, v4, "Calling create for fd %d", buf, 8u);
  }
  *__error() = v2;
  DocStore::init_file_backed_bloom_map((int *)this);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v25 = 0;
  int v6 = *(_DWORD *)this;
  std::string::basic_string[abi:nn180100]<0>(buf, "hot.");
  *((_DWORD *)this + 1) = shard_file;
  if ((buf[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    uint64_t shard_file = *((unsigned int *)this + 1);
    if ((shard_file & 0x80000000) == 0)
    {
LABEL_5:
      uint64_t v26 = 8;
      *(void *)buf = &v26;
      *(void *)&buf[8] = 8;
      int v8 = pwritevall(shard_file, buf, 1, 0);
      if (v8)
      {
        int v9 = v8;
        int v10 = *__error();
        os_log_type_t v11 = _SILogForLogForCategory(8);
        os_log_type_t v12 = 2 * (dword_1E9FC90C4 < 4);
        if (os_log_type_enabled(v11, v12))
        {
          int v13 = *(_DWORD *)this;
          int v14 = *((_DWORD *)this + 1);
          v15 = __p;
          if (v25 < 0) {
            v15 = (void **)__p[0];
          }
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v13;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v14;
          *(_WORD *)&buf[14] = 2080;
          *(void *)&buf[16] = v15;
          __int16 v28 = 1024;
          int v29 = v9;
          _os_log_impl(&dword_1BD672000, v11, v12, "Error calling hot_shard_init for fd %d, hotfd %d, filename '%s': %d", buf, 0x1Eu);
        }
        *__error() = v10;
      }
      caching_hot_shard_alloc();
    }
  }
  else if ((shard_file & 0x80000000) == 0)
  {
    goto LABEL_5;
  }
  int v16 = *__error();
  v17 = _SILogForLogForCategory(8);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    int v21 = *(_DWORD *)this;
    int v20 = *((_DWORD *)this + 1);
    if (v25 >= 0) {
      int v22 = __p;
    }
    else {
      int v22 = (void **)__p[0];
    }
    int v23 = *__error();
    *(_DWORD *)buf = 136316418;
    *(void *)&uint8_t buf[4] = "create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 333;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v21;
    __int16 v28 = 1024;
    int v29 = v20;
    __int16 v30 = 2080;
    v31 = v22;
    __int16 v32 = 1024;
    int v33 = v23;
    _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Error calling mkstempsat_np for fd %d, hotfd %d, filename '%s': %d", buf, 0x2Eu);
  }
  *__error() = v16;
  uint64_t v18 = -*__error();
  if (SHIBYTE(v25) < 0) {
    operator delete(__p[0]);
  }
  return v18;
}

uint64_t anonymous namespace'::create_shard_file(int a1, uint64_t a2, uint64_t a3)
{
  v3 = (char *)a3;
  if (v3[23] < 0) {
    v3 = *(char **)v3;
  }
  return mkstempsat_np(a1, v3, 0);
}

void anonymous namespace'::create_shard_filename(uint64_t a1, uint64_t a2)
{
  v16[2] = *MEMORY[0x1E4F143B8];
  v4.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  std::to_string(&v14, v4.__d_.__rep_);
  int v5 = *(char *)(a1 + 23);
  if (v5 >= 0) {
    int v6 = (const std::string::value_type *)a1;
  }
  else {
    int v6 = *(const std::string::value_type **)a1;
  }
  if (v5 >= 0) {
    std::string::size_type v7 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    std::string::size_type v7 = *(void *)(a1 + 8);
  }
  int v8 = std::string::insert(&v14, 0, v6, v7);
  std::string::size_type v9 = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v15.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v15.__r_.__value_.__r.__words[2] = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  int v10 = std::string::append(&v15, ".XXXXXX");
  std::string::size_type v11 = v10->__r_.__value_.__r.__words[0];
  v16[0] = v10->__r_.__value_.__l.__size_;
  *(void *)((char *)v16 + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
  char v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  uint64_t v13 = v16[0];
  *(void *)a2 = v11;
  *(void *)(a2 + 8) = v13;
  *(void *)(a2 + 15) = *(void *)((char *)v16 + 7);
  *(unsigned char *)(a2 + 23) = v12;
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
}

uint64_t ___ZN8DocStore30add_cold_shard_to_bloom_filterEi_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (*(void *)(*(void *)(a1 + 32) + 184))
  {
    uint64_t v2 = FileBackedBloomMap::Update(*(FileBackedBloomMap **)(*(void *)(a1 + 32) + 184), a2, *(int *)(a1 + 40));
    if (!v2) {
      return v2;
    }
  }
  else
  {
    uint64_t v2 = 4294967282;
  }
  int v3 = *__error();
  std::chrono::system_clock::time_point v4 = _SILogForLogForCategory(8);
  os_log_type_t v5 = dword_1E9FC90C4 < 3;
  if (os_log_type_enabled(v4, (os_log_type_t)(dword_1E9FC90C4 < 3)))
  {
    int v7 = 136315138;
    int v8 = strerror(-(int)v2);
    _os_log_impl(&dword_1BD672000, v4, v5, "*warn* add_cold_shard_to_bloom_filter:  file_backed_bloom_map_update: %s", (uint8_t *)&v7, 0xCu);
  }
  *__error() = v3;
  return v2;
}

uint64_t ___ZN8DocStore17do_cool_hot_shardEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, size_t a5)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  ++**(void **)(a1 + 32);
  int v8 = *(void **)(a1 + 40);
  v8[1] += a5;
  int v10 = (char *)v8[3];
  unint64_t v9 = v8[4];
  if ((unint64_t)v10 >= v9)
  {
    char v12 = (char *)v8[2];
    uint64_t v13 = (v10 - v12) >> 5;
    unint64_t v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 59) {
      goto LABEL_41;
    }
    uint64_t v15 = v9 - (void)v12;
    if (v15 >> 4 > v14) {
      unint64_t v14 = v15 >> 4;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v16 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v16 = v14;
    }
    if (v16)
    {
      if (v16 >> 59) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      v17 = (char *)operator new(32 * v16);
    }
    else
    {
      v17 = 0;
    }
    uint64_t v18 = &v17[32 * v13];
    *((void *)v18 + 1) = 0;
    *((void *)v18 + 2) = 0;
    *(void *)uint64_t v18 = a2;
    *((_WORD *)v18 + 12) = 0;
    std::string::size_type v11 = v18 + 32;
    if (v10 != v12)
    {
      do
      {
        long long v19 = *((_OWORD *)v10 - 2);
        *(_OWORD *)(v18 - 22) = *(_OWORD *)(v10 - 22);
        *((_OWORD *)v18 - 2) = v19;
        v18 -= 32;
        v10 -= 32;
      }
      while (v10 != v12);
      int v10 = (char *)v8[2];
    }
    v8[2] = v18;
    v8[3] = v11;
    v8[4] = &v17[32 * v16];
    if (v10) {
      operator delete(v10);
    }
  }
  else
  {
    *((void *)v10 + 1) = 0;
    *((void *)v10 + 2) = 0;
    *(void *)int v10 = a2;
    std::string::size_type v11 = v10 + 32;
    *((_WORD *)v10 + 12) = 0;
  }
  v8[3] = v11;
  if (*v8 > 4uLL)
  {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "logic error:  unknown compression type %llx\n", *v8);
    abort();
  }
  if (*v8 != 2) {
    return 0;
  }
  int v22 = (void *)v8[12];
  v22[1] += a5;
  v24 = (char *)v22[4];
  unint64_t v23 = v22[5];
  if ((unint64_t)v24 >= v23)
  {
    uint64_t v26 = (char *)v22[3];
    uint64_t v27 = (v24 - v26) >> 3;
    unint64_t v28 = v27 + 1;
    if (!((unint64_t)(v27 + 1) >> 61))
    {
      uint64_t v29 = v23 - (void)v26;
      if (v29 >> 2 > v28) {
        unint64_t v28 = v29 >> 2;
      }
      BOOL v30 = (unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8;
      unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v30) {
        unint64_t v31 = v28;
      }
      if (v31)
      {
        unint64_t v31 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v31);
        uint64_t v26 = (char *)v22[3];
        v24 = (char *)v22[4];
      }
      else
      {
        uint64_t v32 = 0;
      }
      int v33 = (size_t *)(v31 + 8 * v27);
      unint64_t v34 = v31 + 8 * v32;
      *int v33 = a5;
      uint64_t v25 = v33 + 1;
      while (v24 != v26)
      {
        size_t v35 = *((void *)v24 - 1);
        v24 -= 8;
        *--int v33 = v35;
      }
      v22[3] = v33;
      v22[4] = v25;
      v22[5] = v34;
      if (v26) {
        operator delete(v26);
      }
      goto LABEL_37;
    }
LABEL_41:
    abort();
  }
  *(void *)v24 = a5;
  uint64_t v25 = v24 + 8;
LABEL_37:
  v22[4] = v25;
  buf.iov_base = a4;
  buf.iov_len = a5;
  uint64_t v20 = writevall(*(unsigned int *)v22, &buf, 1);
  if (v20)
  {
    int v36 = *__error();
    v37 = _SILogForLogForCategory(8);
    os_log_type_t v38 = dword_1E9FC90C4 < 3;
    if (os_log_type_enabled(v37, (os_log_type_t)(dword_1E9FC90C4 < 3)))
    {
      v39 = strerror(-(int)v20);
      LODWORD(buf.iov_base) = 136315138;
      *(void **)((char *)&buf.iov_base + 4) = v39;
      _os_log_impl(&dword_1BD672000, v37, v38, "*warn* do_cool_hot_shard: cold_shard_first_pass_update_for_document: %s", (uint8_t *)&buf, 0xCu);
    }
    *__error() = v36;
  }
  return v20;
}

uint64_t ___ZN8DocStore17do_cool_hot_shardEv_block_invoke_27(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v5 = v4;
  uint64_t v6 = v3;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  ++**(void **)(v1 + 32);
  uint64_t v7 = *(void *)(v1 + 40);
  uint64_t v9 = *(void *)(v7 + 16);
  uint64_t v8 = *(void *)(v7 + 24);
  if (v8 != v9)
  {
    unint64_t v10 = (v8 - v9) >> 5;
    do
    {
      unint64_t v11 = v10 >> 1;
      uint64_t v12 = v9 + 32 * (v10 >> 1);
      BOOL v13 = *(void *)v12 < v2;
      if (*(void *)v12 == v2) {
        BOOL v13 = *(unsigned char *)(v12 + 24) != 0;
      }
      uint64_t v14 = v12 + 32;
      v10 += ~(v10 >> 1);
      if (v13) {
        uint64_t v9 = v14;
      }
      else {
        unint64_t v10 = v11;
      }
    }
    while (v10);
  }
  if (v9 == v8) {
    __assert_rtn("cold_shard_second_pass_update_for_document", "ColdShard.cc", 200, "doc_meta != ctx->doc_metas.end()");
  }
  uint64_t v15 = *(unsigned int *)(v1 + 48);
  *(unsigned char *)(v9 + 24) = 1;
  if (v9 + 32 != v8 && *(void *)(v9 + 32) == v2) {
    return 0;
  }
  v17 = (void *)(v7 + 72);
  uint64_t v16 = 4294967194;
  switch(*(void *)v7)
  {
    case 0:
      MEMORY[0x1C1880C00](v7 + 72, v3, v4);
      goto LABEL_15;
    case 1:
      if (*(char *)(v7 + 95) < 0)
      {
        **(unsigned char **)(v7 + 72) = 0;
        *(void *)(v7 + 80) = 0;
      }
      else
      {
        *(unsigned char *)(v7 + 72) = 0;
        *(unsigned char *)(v7 + 95) = 0;
      }
      uint64_t v21 = cctx;
      if (!cctx)
      {
        zstd_compress_init();
        uint64_t v21 = cctx;
      }
      bzero(__s, 0x10000uLL);
      *(void *)&long long v44 = v6;
      *((void *)&v44 + 1) = v5;
      uint64_t v45 = 0;
      v42 = __s;
      *(_OWORD *)__n = xmmword_1BDA82310;
      ZSTD_CCtx_reset(v21, 1);
      unint64_t v23 = v22;
      if (ZDICT_isError(v22))
      {
        v24 = "ZSTD_CCtx_reset: %s\n";
      }
      else
      {
        ZSTD_initCStream(cctx, 9);
        unint64_t v23 = v27;
        if (ZDICT_isError(v27))
        {
          v24 = "ZSTD_initCStream: %s\n";
        }
        else
        {
          v24 = "ZSTD_compressStream2: %s\n";
          while (1)
          {
            unint64_t v23 = ZSTD_compressStream2(cctx, (uint64_t *)&v42, &v44, 2u);
            if (ZDICT_isError(v23)) {
              break;
            }
            if (__n[1])
            {
              std::string::append((std::string *)(v7 + 72), (const std::string::value_type *)__s, __n[1]);
              __n[1] = 0;
            }
            if (!v23 && v45 == *((void *)&v44 + 1)) {
              goto LABEL_15;
            }
          }
        }
      }
      unint64_t v28 = (FILE *)*MEMORY[0x1E4F143C8];
      ErrorName = ZDICT_getErrorName(v23);
      fprintf(v28, v24, ErrorName);
      uint64_t v16 = 4294967284;
      goto LABEL_60;
    case 2:
      if (*(char *)(v7 + 95) < 0)
      {
        **(unsigned char **)(v7 + 72) = 0;
        *(void *)(v7 + 80) = 0;
      }
      else
      {
        *(unsigned char *)(v7 + 72) = 0;
        *(unsigned char *)(v7 + 95) = 0;
      }
      uint64_t v25 = *(void *)(v7 + 96);
      uint64_t v26 = (FILE **)MEMORY[0x1E4F143C8];
      if (*(unsigned char *)(v25 + 16))
      {
        uint64_t v16 = 4294967274;
LABEL_59:
        size_t v35 = *v26;
        int v36 = strerror(-(int)v16);
        fprintf(v35, "zstd_dict_compress_do: %s\n", v36);
        goto LABEL_60;
      }
      bzero(__s, 0x10000uLL);
      *(void *)&long long v44 = v6;
      *((void *)&v44 + 1) = v5;
      uint64_t v45 = 0;
      v42 = __s;
      *(_OWORD *)__n = xmmword_1BDA82310;
      ZSTD_CCtx_reset(*(void *)(v25 + 80), 1);
      unint64_t v31 = v30;
      if (ZDICT_isError(v30))
      {
        uint64_t v16 = 4294967284;
        uint64_t v32 = "ZSTD_CCtx_reset: %s\n";
LABEL_58:
        int v33 = *v26;
        unint64_t v34 = ZDICT_getErrorName(v31);
        fprintf(v33, v32, v34);
        goto LABEL_59;
      }
      uint64_t v32 = "ZSTD_compressStream2: %s\n";
      do
      {
        unint64_t v31 = ZSTD_compressStream2(*(void *)(v25 + 80), (uint64_t *)&v42, &v44, 2u);
        if (ZDICT_isError(v31))
        {
          uint64_t v16 = 4294967274;
          goto LABEL_58;
        }
        if (__n[1])
        {
          std::string::append((std::string *)(v7 + 72), (const std::string::value_type *)__s, __n[1]);
          __n[1] = 0;
        }
      }
      while (v31 || v45 != *((void *)&v44 + 1));
LABEL_15:
      if (*(char *)(v7 + 95) < 0) {
        uint64_t v18 = *(void *)(v7 + 80);
      }
      else {
        uint64_t v18 = *(unsigned __int8 *)(v7 + 95);
      }
      *(void *)(v9 + 16) = v18;
      *(unsigned char *)(v9 + 25) = 1;
      uint64_t v19 = *(void *)(v7 + 40);
      *(void *)(v9 + 8) = v19;
      if (*(char *)(v7 + 95) < 0)
      {
        v17 = *(void **)(v7 + 72);
        size_t v20 = *(void *)(v7 + 80);
      }
      else
      {
        size_t v20 = *(unsigned __int8 *)(v7 + 95);
      }
      *(void *)(v7 + 40) = v19 + v20;
      __s[0].iov_base = v17;
      __s[0].iov_len = v20;
      uint64_t v16 = writevall(v15, __s, 1);
      if (v16)
      {
LABEL_60:
        int v37 = *__error();
        os_log_type_t v38 = _SILogForLogForCategory(8);
        os_log_type_t v39 = dword_1E9FC90C4 < 3;
        if (os_log_type_enabled(v38, (os_log_type_t)(dword_1E9FC90C4 < 3)))
        {
          v40 = strerror(-(int)v16);
          LODWORD(__s[0].iov_base) = 136315138;
          *(void **)((char *)&__s[0].iov_base + 4) = v40;
          _os_log_impl(&dword_1BD672000, v38, v39, "*warn* do_cool_hot_shard: cold_shard_second_pass_update_for_document: %s", (uint8_t *)__s, 0xCu);
        }
        *__error() = v37;
      }
      return v16;
    case 3:
      if (*(char *)(v7 + 95) < 0)
      {
        **(unsigned char **)(v7 + 72) = 0;
        *(void *)(v7 + 80) = 0;
      }
      else
      {
        *(unsigned char *)(v7 + 72) = 0;
        *(unsigned char *)(v7 + 95) = 0;
      }
      goto LABEL_60;
    case 4:
      goto LABEL_60;
    default:
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "logic error:  unknown compression type %llx\n", *(void *)v7);
      abort();
  }
}

void *std::vector<DocStore::ColdShardDescriptor>::push_back[abi:nn180100](void *result, long long *a2)
{
  uint64_t v3 = (char **)result;
  uint64_t v4 = result + 2;
  unint64_t v5 = result[2];
  unint64_t v6 = result[1];
  if (v6 >= v5)
  {
    uint64_t v9 = (uint64_t)(v6 - *result) >> 5;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 59) {
      abort();
    }
    uint64_t v11 = v5 - *result;
    if (v11 >> 4 > v10) {
      unint64_t v10 = v11 >> 4;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    uint64_t v26 = v4;
    BOOL v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<std::string,_freeTextCandidate *>>>(v12);
    uint64_t v15 = &v13[32 * v9];
    uint64_t v16 = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v15 = *a2;
    *((void *)v15 + 2) = v16;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    *((_WORD *)v15 + 12) = *((_WORD *)a2 + 12);
    uint64_t v18 = *v3;
    unint64_t v17 = (unint64_t)v3[1];
    if ((char *)v17 == *v3)
    {
      int64x2_t v21 = vdupq_n_s64(v17);
      uint64_t v19 = &v13[32 * v9];
    }
    else
    {
      uint64_t v19 = &v13[32 * v9];
      do
      {
        long long v20 = *(_OWORD *)(v17 - 32);
        *((void *)v19 - 2) = *(void *)(v17 - 16);
        *((_OWORD *)v19 - 2) = v20;
        *(void *)(v17 - 24) = 0;
        *(void *)(v17 - 16) = 0;
        *(void *)(v17 - 32) = 0;
        *((_WORD *)v19 - 4) = *(_WORD *)(v17 - 8);
        v19 -= 32;
        v17 -= 32;
      }
      while ((char *)v17 != v18);
      int64x2_t v21 = *(int64x2_t *)v3;
    }
    uint64_t v8 = v15 + 32;
    char *v3 = v19;
    v3[1] = v15 + 32;
    int64x2_t v24 = v21;
    unint64_t v22 = v3[2];
    v3[2] = &v13[32 * v14];
    uint64_t v25 = v22;
    uint64_t v23 = v21.i64[0];
    result = (void *)std::__split_buffer<std::pair<std::string,_freeTextCandidate *>>::~__split_buffer((uint64_t)&v23);
  }
  else
  {
    long long v7 = *a2;
    *(void *)(v6 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v6 = v7;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    *(_WORD *)(v6 + 24) = *((_WORD *)a2 + 12);
    uint64_t v8 = (char *)(v6 + 32);
  }
  v3[1] = v8;
  return result;
}

uint64_t DocStore::MarkDocPurgeableTillN(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 24) - *(void *)(this + 16);
  if (v1 >= 1)
  {
    uint64_t v2 = this;
    int v3 = 0;
    unint64_t v4 = (unint64_t)v1 >> 5;
    unint64_t v5 = *(void *)(this + 104);
    unint64_t v6 = v4 + 1;
    uint64_t v7 = 32 * v4 - 32;
    uint64_t v8 = MEMORY[0x1E4F14500];
    do
    {
      uint64_t v9 = *(void *)(v2 + 16) + v7;
      if (*(char *)(v9 + 23) < 0) {
        uint64_t v9 = *(void *)v9;
      }
      this = openat(*(_DWORD *)v2, (const char *)v9, 0);
      if ((this & 0x80000000) == 0)
      {
        int v10 = this;
        uint64_t v13 = 0;
        if (!cold_shard_create_search_context_for_fd(this)) {
          v5 += *(void *)(v13 + 48);
        }
        v3 |= v5 > 0x5005;
        if (v3)
        {
          uint64_t v12 = 65541;
          if (ffsctl(v10, 0xC0084A44uLL, &v12, 0))
          {
            if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint64_t v11 = 0;
              _os_log_error_impl(&dword_1BD672000, v8, OS_LOG_TYPE_ERROR, "TextStore - error: could not mark resource directory purgeable", v11, 2u);
            }
          }
          else if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)uint64_t v11 = 0;
            _os_log_impl(&dword_1BD672000, v8, OS_LOG_TYPE_INFO, "TextStore - marked resources purgeable", v11, 2u);
          }
        }
        close(v10);
        this = v13;
        if (v13) {
          this = MEMORY[0x1C1881000](v13, 0x1000C4034A301B9);
        }
      }
      --v6;
      v7 -= 32;
    }
    while (v6 > 1);
  }
  return this;
}

void std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *(void *)uint64_t v7 = a1[1];
  *(void *)&v7[7] = *(uint64_t *)((char *)a1 + 15);
  char v4 = *((unsigned char *)a1 + 23);
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  __int16 v5 = *((_WORD *)a1 + 12);
  uint64_t v6 = *(void *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  a1[2] = v6;
  *(unsigned char *)(a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  *((_WORD *)a1 + 12) = *(_WORD *)(a2 + 24);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(void *)a2 = v3;
  *(void *)(a2 + 8) = *(void *)v7;
  *(void *)(a2 + 15) = *(void *)&v7[7];
  *(unsigned char *)(a2 + 23) = v4;
  *(_WORD *)(a2 + 24) = v5;
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(const void **a1, uint64_t a2, uint64_t a3)
{
  int v6 = *((char *)a1 + 23);
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    size_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v8 = *(void *)(a2 + 8);
  }
  if (v7 >= 0) {
    uint64_t v9 = (const void *)a2;
  }
  else {
    uint64_t v9 = *(const void **)a2;
  }
  if (v6 >= 0) {
    size_t v10 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v10 = (size_t)a1[1];
  }
  if (v6 >= 0) {
    uint64_t v11 = a1;
  }
  else {
    uint64_t v11 = *a1;
  }
  if (v10 >= v8) {
    size_t v12 = v8;
  }
  else {
    size_t v12 = v10;
  }
  int v13 = memcmp(v9, v11, v12);
  if (v13) {
    BOOL v14 = v13 < 0;
  }
  else {
    BOOL v14 = v8 < v10;
  }
  int v15 = *(char *)(a3 + 23);
  if (v15 >= 0) {
    size_t v16 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    size_t v16 = *(void *)(a3 + 8);
  }
  if (v15 >= 0) {
    unint64_t v17 = (const void *)a3;
  }
  else {
    unint64_t v17 = *(const void **)a3;
  }
  if (v8 >= v16) {
    size_t v18 = v16;
  }
  else {
    size_t v18 = v8;
  }
  int v19 = memcmp(v17, v9, v18);
  BOOL v20 = v16 < v8;
  if (v19) {
    BOOL v20 = v19 < 0;
  }
  if (v14)
  {
    int64x2_t v21 = (uint64_t *)a1;
    if (v20)
    {
LABEL_51:
      uint64_t v31 = a3;
LABEL_72:
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>(v21, v31);
      return;
    }
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a1, a2);
    int v22 = *(char *)(a2 + 23);
    int v23 = *(char *)(a3 + 23);
    if (v23 >= 0) {
      size_t v24 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      size_t v24 = *(void *)(a3 + 8);
    }
    if (v23 >= 0) {
      uint64_t v25 = (const void *)a3;
    }
    else {
      uint64_t v25 = *(const void **)a3;
    }
    if (v22 >= 0) {
      size_t v26 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      size_t v26 = *(void *)(a2 + 8);
    }
    if (v22 >= 0) {
      unint64_t v27 = (const void *)a2;
    }
    else {
      unint64_t v27 = *(const void **)a2;
    }
    if (v26 >= v24) {
      size_t v28 = v24;
    }
    else {
      size_t v28 = v26;
    }
    int v29 = memcmp(v25, v27, v28);
    BOOL v30 = v24 < v26;
    if (v29) {
      BOOL v30 = v29 < 0;
    }
    if (v30)
    {
      int64x2_t v21 = (uint64_t *)a2;
      goto LABEL_51;
    }
  }
  else if (v20)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a2, a3);
    int v32 = *((char *)a1 + 23);
    int v33 = *(char *)(a2 + 23);
    if (v33 >= 0) {
      size_t v34 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      size_t v34 = *(void *)(a2 + 8);
    }
    if (v33 >= 0) {
      size_t v35 = (const void *)a2;
    }
    else {
      size_t v35 = *(const void **)a2;
    }
    if (v32 >= 0) {
      size_t v36 = *((unsigned __int8 *)a1 + 23);
    }
    else {
      size_t v36 = (size_t)a1[1];
    }
    if (v32 >= 0) {
      int v37 = a1;
    }
    else {
      int v37 = *a1;
    }
    if (v36 >= v34) {
      size_t v38 = v34;
    }
    else {
      size_t v38 = v36;
    }
    int v39 = memcmp(v35, v37, v38);
    BOOL v40 = v34 < v36;
    if (v39) {
      BOOL v40 = v39 < 0;
    }
    if (v40)
    {
      int64x2_t v21 = (uint64_t *)a1;
      uint64_t v31 = a2;
      goto LABEL_72;
    }
  }
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>((const void **)a1, a2, a3);
  int v8 = *(char *)(a3 + 23);
  int v9 = *(char *)(a4 + 23);
  if (v9 >= 0) {
    size_t v10 = *(unsigned __int8 *)(a4 + 23);
  }
  else {
    size_t v10 = *(void *)(a4 + 8);
  }
  if (v9 >= 0) {
    uint64_t v11 = (const void *)a4;
  }
  else {
    uint64_t v11 = *(const void **)a4;
  }
  if (v8 >= 0) {
    size_t v12 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    size_t v12 = *(void *)(a3 + 8);
  }
  if (v8 >= 0) {
    int v13 = (const void *)a3;
  }
  else {
    int v13 = *(const void **)a3;
  }
  if (v12 >= v10) {
    size_t v14 = v10;
  }
  else {
    size_t v14 = v12;
  }
  int v15 = memcmp(v11, v13, v14);
  BOOL v16 = v10 < v12;
  if (v15) {
    BOOL v16 = v15 < 0;
  }
  if (v16)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a3, a4);
    int v17 = *(char *)(a2 + 23);
    int v18 = *(char *)(a3 + 23);
    if (v18 >= 0) {
      size_t v19 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      size_t v19 = *(void *)(a3 + 8);
    }
    if (v18 >= 0) {
      BOOL v20 = (const void *)a3;
    }
    else {
      BOOL v20 = *(const void **)a3;
    }
    if (v17 >= 0) {
      size_t v21 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      size_t v21 = *(void *)(a2 + 8);
    }
    if (v17 >= 0) {
      int v22 = (const void *)a2;
    }
    else {
      int v22 = *(const void **)a2;
    }
    if (v21 >= v19) {
      size_t v23 = v19;
    }
    else {
      size_t v23 = v21;
    }
    int v24 = memcmp(v20, v22, v23);
    BOOL v25 = v19 < v21;
    if (v24) {
      BOOL v25 = v24 < 0;
    }
    if (v25)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a2, a3);
      int v26 = *(char *)(a1 + 23);
      int v27 = *(char *)(a2 + 23);
      if (v27 >= 0) {
        size_t v28 = *(unsigned __int8 *)(a2 + 23);
      }
      else {
        size_t v28 = *(void *)(a2 + 8);
      }
      if (v27 >= 0) {
        int v29 = (const void *)a2;
      }
      else {
        int v29 = *(const void **)a2;
      }
      if (v26 >= 0) {
        size_t v30 = *(unsigned __int8 *)(a1 + 23);
      }
      else {
        size_t v30 = *(void *)(a1 + 8);
      }
      if (v26 >= 0) {
        uint64_t v31 = (const void *)a1;
      }
      else {
        uint64_t v31 = *(const void **)a1;
      }
      if (v30 >= v28) {
        size_t v32 = v28;
      }
      else {
        size_t v32 = v30;
      }
      int v33 = memcmp(v29, v31, v32);
      BOOL v34 = v28 < v30;
      if (v33) {
        BOOL v34 = v33 < 0;
      }
      if (v34)
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a1, a2);
      }
    }
  }
}

void std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(a1, a2, a3, a4);
  int v10 = *(char *)(a4 + 23);
  int v11 = *(char *)(a5 + 23);
  if (v11 >= 0) {
    size_t v12 = *(unsigned __int8 *)(a5 + 23);
  }
  else {
    size_t v12 = *(void *)(a5 + 8);
  }
  if (v11 >= 0) {
    int v13 = (const void *)a5;
  }
  else {
    int v13 = *(const void **)a5;
  }
  if (v10 >= 0) {
    size_t v14 = *(unsigned __int8 *)(a4 + 23);
  }
  else {
    size_t v14 = *(void *)(a4 + 8);
  }
  if (v10 >= 0) {
    int v15 = (const void *)a4;
  }
  else {
    int v15 = *(const void **)a4;
  }
  if (v14 >= v12) {
    size_t v16 = v12;
  }
  else {
    size_t v16 = v14;
  }
  int v17 = memcmp(v13, v15, v16);
  BOOL v18 = v12 < v14;
  if (v17) {
    BOOL v18 = v17 < 0;
  }
  if (v18)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a4, a5);
    int v19 = *(char *)(a3 + 23);
    int v20 = *(char *)(a4 + 23);
    if (v20 >= 0) {
      size_t v21 = *(unsigned __int8 *)(a4 + 23);
    }
    else {
      size_t v21 = *(void *)(a4 + 8);
    }
    if (v20 >= 0) {
      int v22 = (const void *)a4;
    }
    else {
      int v22 = *(const void **)a4;
    }
    if (v19 >= 0) {
      size_t v23 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      size_t v23 = *(void *)(a3 + 8);
    }
    if (v19 >= 0) {
      int v24 = (const void *)a3;
    }
    else {
      int v24 = *(const void **)a3;
    }
    if (v23 >= v21) {
      size_t v25 = v21;
    }
    else {
      size_t v25 = v23;
    }
    int v26 = memcmp(v22, v24, v25);
    BOOL v27 = v21 < v23;
    if (v26) {
      BOOL v27 = v26 < 0;
    }
    if (v27)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a3, a4);
      int v28 = *(char *)(a2 + 23);
      int v29 = *(char *)(a3 + 23);
      if (v29 >= 0) {
        size_t v30 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        size_t v30 = *(void *)(a3 + 8);
      }
      if (v29 >= 0) {
        uint64_t v31 = (const void *)a3;
      }
      else {
        uint64_t v31 = *(const void **)a3;
      }
      if (v28 >= 0) {
        size_t v32 = *(unsigned __int8 *)(a2 + 23);
      }
      else {
        size_t v32 = *(void *)(a2 + 8);
      }
      if (v28 >= 0) {
        int v33 = (const void *)a2;
      }
      else {
        int v33 = *(const void **)a2;
      }
      if (v32 >= v30) {
        size_t v34 = v30;
      }
      else {
        size_t v34 = v32;
      }
      int v35 = memcmp(v31, v33, v34);
      BOOL v36 = v30 < v32;
      if (v35) {
        BOOL v36 = v35 < 0;
      }
      if (v36)
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a2, a3);
        int v37 = *(char *)(a1 + 23);
        int v38 = *(char *)(a2 + 23);
        if (v38 >= 0) {
          size_t v39 = *(unsigned __int8 *)(a2 + 23);
        }
        else {
          size_t v39 = *(void *)(a2 + 8);
        }
        if (v38 >= 0) {
          BOOL v40 = (const void *)a2;
        }
        else {
          BOOL v40 = *(const void **)a2;
        }
        if (v37 >= 0) {
          size_t v41 = *(unsigned __int8 *)(a1 + 23);
        }
        else {
          size_t v41 = *(void *)(a1 + 8);
        }
        if (v37 >= 0) {
          v42 = (const void *)a1;
        }
        else {
          v42 = *(const void **)a1;
        }
        if (v41 >= v39) {
          size_t v43 = v39;
        }
        else {
          size_t v43 = v41;
        }
        int v44 = memcmp(v40, v42, v43);
        BOOL v45 = v39 < v41;
        if (v44) {
          BOOL v45 = v44 < 0;
        }
        if (v45)
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a1, a2);
        }
      }
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(uint64_t a1, const void **a2)
{
  uint64_t v4 = ((uint64_t)a2 - a1) >> 5;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = (uint64_t)(a2 - 4);
      int v7 = *(char *)(a1 + 23);
      int v8 = *((char *)a2 - 9);
      if (v8 >= 0) {
        size_t v9 = *((unsigned __int8 *)a2 - 9);
      }
      else {
        size_t v9 = (size_t)*(a2 - 3);
      }
      if (v8 >= 0) {
        int v10 = a2 - 4;
      }
      else {
        int v10 = (const void **)*(a2 - 4);
      }
      if (v7 >= 0) {
        size_t v11 = *(unsigned __int8 *)(a1 + 23);
      }
      else {
        size_t v11 = *(void *)(a1 + 8);
      }
      if (v7 >= 0) {
        size_t v12 = (const void *)a1;
      }
      else {
        size_t v12 = *(const void **)a1;
      }
      if (v11 >= v9) {
        size_t v13 = v9;
      }
      else {
        size_t v13 = v11;
      }
      int v14 = memcmp(v10, v12, v13);
      BOOL v15 = v9 < v11;
      if (v14) {
        BOOL v15 = v14 < 0;
      }
      if (v15) {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a1, v6);
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>((const void **)a1, a1 + 32, (uint64_t)(a2 - 4));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(a1, a1 + 32, a1 + 64, (uint64_t)(a2 - 4));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(a1, a1 + 32, a1 + 64, a1 + 96, (uint64_t)(a2 - 4));
      return 1;
    default:
      size_t v16 = (const void **)(a1 + 64);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>((const void **)a1, a1 + 32, a1 + 64);
      int v17 = (const void **)(a1 + 96);
      if ((const void **)(a1 + 96) == a2) {
        return 1;
      }
      uint64_t v18 = 0;
      int v19 = 0;
      break;
  }
  while (1)
  {
    int v20 = *((char *)v16 + 23);
    int v21 = *((char *)v17 + 23);
    if (v21 >= 0) {
      size_t v22 = *((unsigned __int8 *)v17 + 23);
    }
    else {
      size_t v22 = (size_t)v17[1];
    }
    if (v21 >= 0) {
      size_t v23 = v17;
    }
    else {
      size_t v23 = *v17;
    }
    if (v20 >= 0) {
      size_t v24 = *((unsigned __int8 *)v16 + 23);
    }
    else {
      size_t v24 = (size_t)v16[1];
    }
    if (v20 >= 0) {
      size_t v25 = v16;
    }
    else {
      size_t v25 = *v16;
    }
    if (v24 >= v22) {
      size_t v26 = v22;
    }
    else {
      size_t v26 = v24;
    }
    int v27 = memcmp(v23, v25, v26);
    BOOL v28 = v22 < v24;
    if (v27) {
      BOOL v28 = v27 < 0;
    }
    if (v28)
    {
      long long v41 = *(_OWORD *)v17;
      v42 = v17[2];
      uint64_t v43 = 0;
      const void *v17 = 0;
      v17[1] = 0;
      v17[2] = 0;
      LOWORD(v43) = *((_WORD *)v17 + 12);
      uint64_t v29 = v18;
      while (1)
      {
        uint64_t v30 = a1 + v29;
        uint64_t v31 = (void **)(a1 + v29 + 96);
        if (*(char *)(a1 + v29 + 119) < 0) {
          operator delete(*v31);
        }
        *(_OWORD *)uint64_t v31 = *(_OWORD *)(v30 + 64);
        *(void *)(a1 + v29 + 112) = *(void *)(v30 + 80);
        *(unsigned char *)(v30 + 87) = 0;
        *(unsigned char *)(v30 + 64) = 0;
        *(_WORD *)(v30 + 120) = *(_WORD *)(v30 + 88);
        if (v29 == -64) {
          break;
        }
        int v32 = *(char *)(a1 + v29 + 55);
        if (SHIBYTE(v42) >= 0) {
          size_t v33 = HIBYTE(v42);
        }
        else {
          size_t v33 = *((void *)&v41 + 1);
        }
        if (SHIBYTE(v42) >= 0) {
          size_t v34 = &v41;
        }
        else {
          size_t v34 = (long long *)v41;
        }
        if (v32 >= 0) {
          size_t v35 = *(unsigned __int8 *)(a1 + v29 + 55);
        }
        else {
          size_t v35 = *(void *)(a1 + v29 + 40);
        }
        if (v32 >= 0) {
          BOOL v36 = (const void *)(a1 + v29 + 32);
        }
        else {
          BOOL v36 = *(const void **)(a1 + v29 + 32);
        }
        if (v35 >= v33) {
          size_t v37 = v33;
        }
        else {
          size_t v37 = v35;
        }
        int v38 = memcmp(v34, v36, v37);
        BOOL v39 = v33 < v35;
        if (v38) {
          BOOL v39 = v38 < 0;
        }
        v29 -= 32;
        if (!v39)
        {
          uint64_t v40 = a1 + v29 + 96;
          goto LABEL_65;
        }
      }
      uint64_t v40 = a1;
LABEL_65:
      if (*(char *)(v40 + 23) < 0) {
        operator delete(*(void **)v40);
      }
      *(_OWORD *)uint64_t v40 = v41;
      *(void *)(v40 + 16) = v42;
      *(_WORD *)(v40 + 24) = v43;
      if (++v19 == 8) {
        return v17 + 4 == a2;
      }
    }
    size_t v16 = v17;
    v18 += 32;
    v17 += 4;
    if (v17 == a2) {
      return 1;
    }
  }
}

BOOL std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(void *a1, void *a2, void *a3)
{
  BOOL v6 = std::less<std::string>::operator()[abi:nn180100](a2, a1);
  BOOL result = std::less<std::string>::operator()[abi:nn180100](a3, a2);
  if (v6)
  {
    if (result)
    {
      uint64_t v8 = a1[2];
      long long v9 = *(_OWORD *)a1;
      uint64_t v10 = a3[2];
      *(_OWORD *)a1 = *(_OWORD *)a3;
      a1[2] = v10;
    }
    else
    {
      uint64_t v17 = a1[2];
      long long v18 = *(_OWORD *)a1;
      uint64_t v19 = a2[2];
      *(_OWORD *)a1 = *(_OWORD *)a2;
      a1[2] = v19;
      *(_OWORD *)a2 = v18;
      a2[2] = v17;
      BOOL result = std::less<std::string>::operator()[abi:nn180100](a3, a2);
      if (!result) {
        return result;
      }
      uint64_t v8 = a2[2];
      long long v9 = *(_OWORD *)a2;
      uint64_t v20 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v20;
    }
    *(_OWORD *)a3 = v9;
    a3[2] = v8;
  }
  else if (result)
  {
    uint64_t v11 = a2[2];
    long long v12 = *(_OWORD *)a2;
    uint64_t v13 = a3[2];
    *(_OWORD *)a2 = *(_OWORD *)a3;
    a2[2] = v13;
    *(_OWORD *)a3 = v12;
    a3[2] = v11;
    BOOL result = std::less<std::string>::operator()[abi:nn180100](a2, a1);
    if (result)
    {
      uint64_t v14 = a1[2];
      long long v15 = *(_OWORD *)a1;
      uint64_t v16 = a2[2];
      *(_OWORD *)a1 = *(_OWORD *)a2;
      a1[2] = v16;
      *(_OWORD *)a2 = v15;
      a2[2] = v14;
    }
  }
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(__n128 *a1, void *a2, void *a3, void *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, a2, a3);
  if (std::less<std::string>::operator()[abi:nn180100](a4, a3))
  {
    uint64_t v9 = a3[2];
    long long v10 = *(_OWORD *)a3;
    uint64_t v11 = a4[2];
    *(_OWORD *)a3 = *(_OWORD *)a4;
    a3[2] = v11;
    *(_OWORD *)a4 = v10;
    a4[2] = v9;
    if (std::less<std::string>::operator()[abi:nn180100](a3, a2))
    {
      uint64_t v12 = a2[2];
      long long v13 = *(_OWORD *)a2;
      uint64_t v14 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v14;
      *(_OWORD *)a3 = v13;
      a3[2] = v12;
      if (std::less<std::string>::operator()[abi:nn180100](a2, a1))
      {
        unint64_t v15 = a1[1].n128_u64[0];
        __n128 result = *a1;
        unint64_t v16 = a2[2];
        *a1 = *(__n128 *)a2;
        a1[1].n128_u64[0] = v16;
        *(__n128 *)a2 = result;
        a2[2] = v15;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(__n128 *a1, void *a2, void *a3, void *a4, void *a5)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, a2, a3, a4);
  if (std::less<std::string>::operator()[abi:nn180100](a5, a4))
  {
    uint64_t v11 = a4[2];
    long long v12 = *(_OWORD *)a4;
    uint64_t v13 = a5[2];
    *(_OWORD *)a4 = *(_OWORD *)a5;
    a4[2] = v13;
    *(_OWORD *)a5 = v12;
    a5[2] = v11;
    if (std::less<std::string>::operator()[abi:nn180100](a4, a3))
    {
      uint64_t v14 = a3[2];
      long long v15 = *(_OWORD *)a3;
      uint64_t v16 = a4[2];
      *(_OWORD *)a3 = *(_OWORD *)a4;
      a3[2] = v16;
      *(_OWORD *)a4 = v15;
      a4[2] = v14;
      if (std::less<std::string>::operator()[abi:nn180100](a3, a2))
      {
        uint64_t v17 = a2[2];
        long long v18 = *(_OWORD *)a2;
        uint64_t v19 = a3[2];
        *(_OWORD *)a2 = *(_OWORD *)a3;
        a2[2] = v19;
        *(_OWORD *)a3 = v18;
        a3[2] = v17;
        if (std::less<std::string>::operator()[abi:nn180100](a2, a1))
        {
          unint64_t v20 = a1[1].n128_u64[0];
          __n128 result = *a1;
          unint64_t v21 = a2[2];
          *a1 = *(__n128 *)a2;
          a1[1].n128_u64[0] = v21;
          *(__n128 *)a2 = result;
          a2[2] = v20;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(__n128 *a1, __n128 *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      BOOL v6 = (__n128 *)((char *)a2 - 24);
      if (std::less<std::string>::operator()[abi:nn180100](&a2[-2].n128_u64[1], a1))
      {
        unint64_t v7 = a1[1].n128_u64[0];
        __n128 v8 = *a1;
        unint64_t v9 = v6[1].n128_u64[0];
        *a1 = *v6;
        a1[1].n128_u64[0] = v9;
        *BOOL v6 = v8;
        v6[1].n128_u64[0] = v7;
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, &a1[1].n128_u64[1], &a2[-2].n128_u64[1]);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, &a1[1].n128_u64[1], (__n128 *)a1[3].n128_u64, &a2[-2].n128_u64[1]);
      return 1;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, &a1[1].n128_u64[1], (__n128 *)a1[3].n128_u64, &a1[4].n128_u64[1], &a2[-2].n128_u64[1]);
      return 1;
    default:
      long long v10 = a1 + 3;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, &a1[1].n128_u64[1], (__n128 *)a1[3].n128_u64);
      uint64_t v11 = &a1[4].n128_u64[1];
      if (&a1[4].n128_i8[8] == (__int8 *)a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    if (std::less<std::string>::operator()[abi:nn180100](v11, v10))
    {
      long long v17 = *(_OWORD *)v11;
      unint64_t v18 = v11[2];
      v11[1] = 0;
      v11[2] = 0;
      *uint64_t v11 = 0;
      uint64_t v14 = v12;
      while (1)
      {
        long long v15 = (char *)a1 + v14;
        *(__n128 *)(v15 + 72) = *(__n128 *)((char *)a1 + v14 + 48);
        *((void *)v15 + 11) = *(unint64_t *)((char *)a1[4].n128_u64 + v14);
        v15[71] = 0;
        v15[48] = 0;
        if (v14 == -48) {
          break;
        }
        v14 -= 24;
        if (!std::less<std::string>::operator()[abi:nn180100](&v17, (void *)v15 + 3))
        {
          uint64_t v16 = (uint64_t)&a1[4].n128_i64[1] + v14;
          goto LABEL_12;
        }
      }
      uint64_t v16 = (uint64_t)a1;
LABEL_12:
      *(_OWORD *)uint64_t v16 = v17;
      *(void *)(v16 + 16) = v18;
      if (++v13 == 8) {
        return v11 + 3 == (unint64_t *)a2;
      }
    }
    long long v10 = (__n128 *)v11;
    v12 += 24;
    v11 += 3;
    if (v11 == (unint64_t *)a2) {
      return 1;
    }
  }
}

uint64_t std::__shared_ptr_pointer<analytics::SampledLogger<analytics::DeleteEvent> *,std::shared_ptr<analytics::SampledLogger<analytics::DeleteEvent>>::__shared_ptr_default_delete<analytics::SampledLogger<analytics::DeleteEvent>,analytics::SampledLogger<analytics::DeleteEvent>>,std::allocator<analytics::SampledLogger<analytics::DeleteEvent>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<analytics::SampledLogger<analytics::DeleteEvent> *,std::shared_ptr<analytics::SampledLogger<analytics::DeleteEvent>>::__shared_ptr_default_delete<analytics::SampledLogger<analytics::DeleteEvent>,analytics::SampledLogger<analytics::DeleteEvent>>,std::allocator<analytics::SampledLogger<analytics::DeleteEvent>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

uint64_t std::__shared_ptr_pointer<analytics::SampledLogger<analytics::PutEvent> *,std::shared_ptr<analytics::SampledLogger<analytics::PutEvent>>::__shared_ptr_default_delete<analytics::SampledLogger<analytics::PutEvent>,analytics::SampledLogger<analytics::PutEvent>>,std::allocator<analytics::SampledLogger<analytics::PutEvent>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<analytics::SampledLogger<analytics::PutEvent> *,std::shared_ptr<analytics::SampledLogger<analytics::PutEvent>>::__shared_ptr_default_delete<analytics::SampledLogger<analytics::PutEvent>,analytics::SampledLogger<analytics::PutEvent>>,std::allocator<analytics::SampledLogger<analytics::PutEvent>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

uint64_t std::__shared_ptr_pointer<analytics::SampledLogger<analytics::GetEvent> *,std::shared_ptr<analytics::SampledLogger<analytics::GetEvent>>::__shared_ptr_default_delete<analytics::SampledLogger<analytics::GetEvent>,analytics::SampledLogger<analytics::GetEvent>>,std::allocator<analytics::SampledLogger<analytics::GetEvent>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<analytics::SampledLogger<analytics::GetEvent> *,std::shared_ptr<analytics::SampledLogger<analytics::GetEvent>>::__shared_ptr_default_delete<analytics::SampledLogger<analytics::GetEvent>,analytics::SampledLogger<analytics::GetEvent>>,std::allocator<analytics::SampledLogger<analytics::GetEvent>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void doc_store_close(DocStore *a1)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v5 = 0u;
  long long v6 = 0u;
  *(_OWORD *)__str = 0u;
  long long v4 = 0u;
  snprintf(__str, 0x200uLL, "doc_store_close(%p)", a1);
  v2[0] = 0;
  v2[1] = 0;
  ScopeLogger::ScopeLogger((ScopeLogger *)v2, __str);
  if (a1)
  {
    DocStore::~DocStore(a1);
    MEMORY[0x1C1881000]();
  }
  ScopeLogger::~ScopeLogger((ScopeLogger *)v2);
}

uint64_t doc_store_get_document(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  *(_OWORD *)__str = 0u;
  long long v13 = 0u;
  snprintf(__str, 0x200uLL, "doc_store_get_document(%p, %lld, %zd)", a1, a2, 0x3E8uLL);
  v9[0] = 0;
  v9[1] = 0;
  ScopeLogger::ScopeLogger((ScopeLogger *)v9, __str);
  if (a1)
  {
    uint64_t v11 = a2;
    int v10 = 0;
    *(void *)iovec buf = MEMORY[0x1E4F143A8];
    uint64_t v45 = 0x40000000;
    v46 = ___ZN8DocStore11GetDocumentExmPcPm_block_invoke;
    uint64_t v47 = &__block_descriptor_tmp_34;
    uint64_t v48 = 1000;
    uint64_t v49 = a3;
    uint64_t v50 = a4;
    v51 = &v10;
    DocStore::GetDocumentsBulk((uint64_t)a1);
  }
  ScopeLogger::~ScopeLogger((ScopeLogger *)v9);
  return 4294967282;
}

uint64_t ___ZN8DocStore11GetDocumentExmPcPm_block_invoke(uint64_t a1, int a2, void *__src, size_t a4)
{
  size_t v6 = *(void *)(a1 + 32);
  long long v5 = *(void **)(a1 + 40);
  if (v6 >= a4) {
    size_t v7 = a4;
  }
  else {
    size_t v7 = v6;
  }
  memcpy(v5, __src, v7);
  long long v8 = *(_DWORD **)(a1 + 56);
  **(void **)(a1 + 48) = v7;
  *long long v8 = 1;
  return 0;
}

void DocStore::GetDocumentsBulk(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v5 = v2;
  uint64_t v3 = v1;
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  std::mutex::lock((std::mutex *)(v1 + 40));
  uint64_t v4 = *(void *)(v3 + 136);
  uint64_t v6 = v3;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  operator new();
}

uint64_t ___ZN8DocStore16GetDocumentsBulkEiPKxU13block_pointerFixPKcmE_block_invoke(void *a1, unint64_t a2)
{
  uint64_t v3 = (uint64_t *)a1[5];
  int8x8_t v4 = (int8x8_t)v3[1];
  if (v4)
  {
    uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
    v5.i16[0] = vaddlv_u8(v5);
    if (v5.u32[0] > 1uLL)
    {
      unint64_t v6 = a2;
      if (*(void *)&v4 <= a2) {
        unint64_t v6 = a2 % *(void *)&v4;
      }
    }
    else
    {
      unint64_t v6 = (*(void *)&v4 - 1) & a2;
    }
    uint64_t v7 = *v3;
    long long v8 = *(uint64_t ***)(*v3 + 8 * v6);
    if (v8)
    {
      long long v9 = *v8;
      if (*v8)
      {
        uint64_t v10 = *(void *)&v4 - 1;
        do
        {
          unint64_t v11 = v9[1];
          if (v11 == a2)
          {
            if (v9[2] == a2)
            {
              if (v5.u32[0] > 1uLL)
              {
                unint64_t v12 = a2;
                if (*(void *)&v4 <= a2) {
                  unint64_t v12 = a2 % *(void *)&v4;
                }
              }
              else
              {
                unint64_t v12 = v10 & a2;
              }
              long long v13 = *(uint64_t **)(v7 + 8 * v12);
              do
              {
                long long v14 = v13;
                long long v13 = (uint64_t *)*v13;
              }
              while (v13 != v9);
              if (v14 == v3 + 2) {
                goto LABEL_36;
              }
              unint64_t v15 = v14[1];
              if (v5.u32[0] > 1uLL)
              {
                if (v15 >= *(void *)&v4) {
                  v15 %= *(void *)&v4;
                }
              }
              else
              {
                v15 &= v10;
              }
              if (v15 != v12)
              {
LABEL_36:
                if (!*v9) {
                  goto LABEL_37;
                }
                unint64_t v16 = *(void *)(*v9 + 8);
                if (v5.u32[0] > 1uLL)
                {
                  if (v16 >= *(void *)&v4) {
                    v16 %= *(void *)&v4;
                  }
                }
                else
                {
                  v16 &= v10;
                }
                if (v16 != v12) {
LABEL_37:
                }
                  *(void *)(v7 + 8 * v12) = 0;
              }
              uint64_t v17 = *v9;
              if (*v9)
              {
                unint64_t v18 = *(void *)(v17 + 8);
                if (v5.u32[0] > 1uLL)
                {
                  if (v18 >= *(void *)&v4) {
                    v18 %= *(void *)&v4;
                  }
                }
                else
                {
                  v18 &= v10;
                }
                if (v18 != v12)
                {
                  *(void *)(*v3 + 8 * v18) = v14;
                  uint64_t v17 = *v9;
                }
              }
              *long long v14 = v17;
              *long long v9 = 0;
              --v3[3];
              operator delete(v9);
              break;
            }
          }
          else
          {
            if (v5.u32[0] > 1uLL)
            {
              if (v11 >= *(void *)&v4) {
                v11 %= *(void *)&v4;
              }
            }
            else
            {
              v11 &= v10;
            }
            if (v11 != v6) {
              break;
            }
          }
          long long v9 = (uint64_t *)*v9;
        }
        while (v9);
      }
    }
  }
  (*(void (**)(void))(a1[4] + 16))();
  uint64_t v19 = a1[6];
  if (!*(unsigned char *)(v19 + 56))
  {
    uint64_t v21 = std::__throw_bad_optional_access[abi:nn180100]();
    DocStore::PutDocument(v21, v22, v23);
  }
  ++*(void *)(v19 + 48);
  return 0;
}

void DocStore::PutDocument(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3;
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  *(void *)&v8[1] = a2;
  v8[0] = 0;
  uint64_t v7 = a1 + 40;
  std::mutex::lock((std::mutex *)(a1 + 40));
  uint64_t v4 = *(void *)(a1 + 152);
  uint64_t v6 = *(void *)(a1 + 144);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  operator new();
}

void DocStore::DeleteDocumentsBulk(DocStore *this, int a2, const uint64_t *a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  std::mutex::lock((std::mutex *)((char *)this + 40));
  long long v5 = 0u;
  long long v6 = 0u;
  uint64_t v4 = *((void *)this + 21);
  *(void *)iovec buf = *((void *)this + 20);
  uint64_t v8 = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
    analytics::ScopedLogger<analytics::DeleteEvent>::ScopedLogger();
  }
  analytics::ScopedLogger<analytics::DeleteEvent>::ScopedLogger();
}

uint64_t DocStore::do_delete_bulk(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a1;
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(CachingHotShard **)(a1 + 8);
  if (v8)
  {
    int v9 = *(_DWORD *)v8;
    uint64_t v79 = 1065353216;
    memset(v78, 0, sizeof(v78));
    uint64_t v77 = 0;
    if ((int)a3 >= 1)
    {
      uint64_t v10 = a3;
      unint64_t v11 = a2;
      do
      {
        unint64_t v12 = *v11++;
        std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__emplace_unique_key_args<long long,long long const&>((uint64_t)v78, v12, v12);
        --v10;
      }
      while (v10);
    }
    *(void *)iovec buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 1174405120;
    *(void *)&buf[16] = __hot_shard_delete_docs_block_invoke;
    v81 = &__block_descriptor_tmp_3_8034;
    std::unordered_set<long long>::unordered_set((uint64_t)v82, (uint64_t)v78);
    int v83 = v9;
    v82[5] = &v77;
    uint64_t v13 = hot_shard_for_each_region(v9);
    std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table((uint64_t)v82);
    a1 = std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table((uint64_t)v78);
    if (v13)
    {
      int v14 = *(_DWORD *)v8;
      *((void *)v8 + 2) = *((void *)v8 + 1);
      *((void *)v8 + 5) = *((void *)v8 + 4);
      *((void *)v8 + 8) = *((void *)v8 + 7);
      *(_DWORD *)uint64_t v8 = -1;
      a1 = CachingHotShard::Bind(v8, v14);
    }
    else
    {
      if ((int)a3 >= 1)
      {
        uint64_t v15 = 0;
        uint64_t v16 = *((void *)v8 + 1);
        uint64_t v17 = *((void *)v8 + 2);
        do
        {
          if ((int)((unint64_t)(v17 - v16) >> 3) >= 1)
          {
            uint64_t v18 = 0;
            while (*(void *)(v16 + 8 * v18) != a2[v15])
            {
              if (((unint64_t)(v17 - v16) >> 3) == ++v18) {
                goto LABEL_16;
              }
            }
            uint64_t v19 = *(void *)(v17 - 8);
            v17 -= 8;
            *(void *)(v16 + 8 * v18) = v19;
            *((void *)v8 + 2) = v17;
            uint64_t v20 = *((void *)v8 + 5);
            *(void *)(*((void *)v8 + 4) + 8 * v18) = *(void *)(v20 - 8);
            *((void *)v8 + 5) = v20 - 8;
            uint64_t v21 = *((void *)v8 + 8);
            *(void *)(*((void *)v8 + 7) + 8 * v18) = *(void *)(v21 - 8);
            *((void *)v8 + 8) = v21 - 8;
          }
LABEL_16:
          ++v15;
        }
        while (v15 != a3);
      }
      uint64_t v13 = 0;
    }
  }
  else
  {
    uint64_t v13 = 4294967282;
  }
  uint64_t v22 = *(void *)(v7 + 24) - *(void *)(v7 + 16);
  if (v22)
  {
    unsigned int v74 = v13;
    uint64_t v73 = a4;
    v70 = &v68;
    unint64_t v23 = (v22 >> 5) + 7;
    unint64_t v24 = v23 >> 3;
    uint64_t v25 = MEMORY[0x1F4188790](a1);
    long long v26 = (char *)&v68 - (((v23 >> 3) + 15) & 0x3FFFFFFFFFFFFFF0);
    MEMORY[0x1F4188790](v25);
    long long v28 = (char *)&v68 - v27;
    bzero((char *)&v68 - v27, v23 >> 3);
    bzero(v26, v23 >> 3);
    *(void *)&long long v72 = a3;
    if ((int)a3 >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = (v23 >> 3);
      uint64_t v32 = v72;
      do
      {
        uint64_t v33 = a2[v30];
        unint64_t v34 = (unint64_t)(((uint64_t)(*(void *)(v7 + 24) - *(void *)(v7 + 16)) >> 5) + 7) >> 3;
        memset(v28, 255, v34);
        long long v35 = *(FileBackedBloomMap **)(v7 + 184);
        if (v35) {
          FileBackedBloomMap::CalcMayContainBitset(v35, v33, (unsigned __int8 *)v28, v34);
        }
        long long v36 = v28;
        long long v37 = v26;
        uint64_t v38 = v31;
        if ((int)v24 >= 1)
        {
          do
          {
            char v39 = *v36++;
            *v37++ |= v39;
            --v38;
          }
          while (v38);
        }
        ++v30;
      }
      while (v30 != v32);
    }
    uint64_t v40 = *(void *)(v7 + 24) - *(void *)(v7 + 16);
    if (v40 >= 1)
    {
      unint64_t v41 = (unint64_t)v40 >> 5;
      unint64_t v69 = (int)v72;
      uint64_t v42 = 32 * v41 - 32;
      *(void *)&long long v29 = 136315394;
      long long v68 = v29;
      *(void *)&long long v29 = 136315138;
      long long v72 = v29;
      while (1)
      {
        unint64_t v43 = v41 - 1;
        uint64_t v44 = *(void *)(v7 + 16);
        uint64_t v45 = (const char *)(v44 + v42);
        if (!*(unsigned char *)(v44 + v42 + 25) && (!v45[24] || ((v26[v43 >> 3] >> ((v41 - 1) & 7)) & 1) != 0)) {
          break;
        }
LABEL_53:
        v42 -= 32;
        unint64_t v41 = v43;
        if (v43 + 1 <= 1) {
          goto LABEL_58;
        }
      }
      uint64_t v46 = v44 + v42;
      uint64_t v47 = (const char *)(v44 + v42);
      if (*(char *)(v44 + v42 + 23) < 0) {
        uint64_t v47 = *(const char **)v45;
      }
      uint64_t v48 = openat(*(_DWORD *)v7, v47, 2, (void)v68, *((void *)&v68 + 1));
      if ((v48 & 0x80000000) != 0)
      {
        int v57 = *__error();
        if (v57 != 2)
        {
          int v71 = *__error();
          v58 = _SILogForLogForCategory(8);
          os_log_type_t v59 = dword_1E9FC90C4 < 3;
          if (os_log_type_enabled(v58, (os_log_type_t)(dword_1E9FC90C4 < 3)))
          {
            if (*(char *)(v46 + 23) < 0) {
              uint64_t v45 = *(const char **)v45;
            }
            v60 = strerror(v57);
            *(_DWORD *)iovec buf = v68;
            *(void *)&uint8_t buf[4] = v45;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = v60;
            _os_log_impl(&dword_1BD672000, v58, v59, "*warn* open(%s, RDWR): %s\n", buf, 0x16u);
          }
          *__error() = v71;
        }
        goto LABEL_53;
      }
      int v49 = v48;
      *(void *)&v78[0] = 0;
      int search_context_for_fd = cold_shard_create_search_context_for_fd(v48);
      if (search_context_for_fd)
      {
        int v51 = search_context_for_fd;
        int v52 = *__error();
        v53 = _SILogForLogForCategory(8);
        os_log_type_t v54 = dword_1E9FC90C4 < 3;
        if (os_log_type_enabled(v53, (os_log_type_t)(dword_1E9FC90C4 < 3)))
        {
          v55 = strerror(-v51);
          *(_DWORD *)iovec buf = v72;
          *(void *)&uint8_t buf[4] = v55;
          _os_log_impl(&dword_1BD672000, v53, v54, "*warn* cold_shard_create_search_context_for_fd: %s\n", buf, 0xCu);
        }
        *__error() = v52;
        uint64_t v56 = *(void *)&v78[0];
        if (!*(void *)&v78[0]) {
          goto LABEL_50;
        }
      }
      else
      {
        long long v76 = 0u;
        int64x2_t v75 = 0u;
        uint64_t v56 = *(void *)&v78[0];
        int v61 = cold_shard_delete_docs(*(uint64_t **)&v78[0], v69, a2, &v75);
        if (v61)
        {
          int v51 = v61;
          int v71 = *__error();
          v62 = _SILogForLogForCategory(8);
          os_log_type_t v63 = dword_1E9FC90C4 < 3;
          if (os_log_type_enabled(v62, (os_log_type_t)(dword_1E9FC90C4 < 3)))
          {
            v64 = strerror(-v51);
            *(_DWORD *)iovec buf = v72;
            *(void *)&uint8_t buf[4] = v64;
            _os_log_impl(&dword_1BD672000, v62, v63, "*warn* cold_shard_delete_docs: %s\n", buf, 0xCu);
          }
          *__error() = v71;
          if (!v56) {
            goto LABEL_50;
          }
        }
        else
        {
          if (!*(unsigned char *)(v73 + 56)) {
            goto LABEL_65;
          }
          uint64_t v66 = *((void *)&v76 + 1);
          *(void *)(v73 + 48) += v76;
          DocStore::doColdShardCompaction((int *)v7, v43, v66);
          int v51 = 0;
          if (!v56) {
            goto LABEL_50;
          }
        }
      }
      MEMORY[0x1C1881000](v56, 0x1000C4034A301B9);
LABEL_50:
      close(v49);
      int v65 = v74;
      if (v51) {
        int v65 = v51;
      }
      unsigned int v74 = v65;
      goto LABEL_53;
    }
LABEL_58:
    a4 = v73;
    uint64_t v13 = v74;
  }
  if (!*(unsigned char *)(a4 + 24)) {
    goto LABEL_65;
  }
  if (*(_DWORD *)(a4 + 16) == -1)
  {
    if (*(unsigned char *)(a4 + 40) && *(unsigned char *)(a4 + 56))
    {
      *(void *)(a4 + 16) = *(void *)(a4 + 48) + *(void *)(a4 + 32);
      return v13;
    }
LABEL_65:
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return v13;
}

int *DocStore::doColdShardCompaction(int *result, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    uint64_t v3 = *((void *)result + 2) + 32 * a2;
    *(unsigned char *)(v3 + 25) = 1;
    if (*(char *)(v3 + 23) < 0) {
      uint64_t v3 = *(void *)v3;
    }
    uint64_t result = (int *)unlink((const char *)v3);
    if (result)
    {
      uint64_t result = __error();
      int v4 = *result;
      if (*result != 2)
      {
        int v5 = *__error();
        long long v6 = _SILogForLogForCategory(8);
        os_log_type_t v7 = dword_1E9FC90C4 < 3;
        if (os_log_type_enabled(v6, (os_log_type_t)(dword_1E9FC90C4 < 3)))
        {
          int v8 = 136315394;
          uint64_t v9 = v3;
          __int16 v10 = 2080;
          unint64_t v11 = strerror(v4);
          _os_log_impl(&dword_1BD672000, v6, v7, "*warn* unlink(%s): %s", (uint8_t *)&v8, 0x16u);
        }
        uint64_t result = __error();
        *uint64_t result = v5;
      }
    }
  }
  return result;
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    uint64_t v9 = *(void **)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      for (i = (void *)*v9; i; i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  uint64_t v12 = operator new(0x18uLL);
  void *v12 = 0;
  v12[1] = a2;
  v12[2] = a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    BOOL v15 = 1;
    if (v6 >= 3) {
      BOOL v15 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v6);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__rehash<true>(a1, v18);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
      else {
        unint64_t v8 = a2;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v8);
  if (v20)
  {
    void *v12 = *v20;
LABEL_38:
    *uint64_t v20 = v12;
    goto LABEL_39;
  }
  void *v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v19 + 8 * v8) = a1 + 16;
  if (*v12)
  {
    unint64_t v21 = *(void *)(*v12 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v21 >= v6) {
        v21 %= v6;
      }
    }
    else
    {
      v21 &= v6 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
}

void sub_1BD82411C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a3;
    if (a3 >= a2) {
      unint64_t v4 = a3 % a2;
    }
  }
  else
  {
    unint64_t v4 = (a2 - 1) & a3;
  }
  int v5 = *(void **)(a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  uint64_t result = (void *)*v5;
  if (*v5)
  {
    do
    {
      unint64_t v7 = result[1];
      if (v7 == a3)
      {
        if (result[2] == a3) {
          return result;
        }
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= a2) {
            v7 %= a2;
          }
        }
        else
        {
          v7 &= a2 - 1;
        }
        if (v7 != v4) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t tt_transition_for_state(void *a1, uint64_t a2, unsigned __int16 a3, void *a4, unsigned char *a5)
{
  int8x8_t v5 = (int8x8_t)a1[1];
  if (v5)
  {
    unint64_t v6 = 196613 * a3 + HIBYTE(a3) + 6291469 * a2;
    uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      uint64_t v8 = 196613 * a3 + HIBYTE(a3) + 6291469 * a2;
      if (v6 >= *(void *)&v5) {
        uint64_t v8 = v6 % *(void *)&v5;
      }
    }
    else
    {
      uint64_t v8 = v6 & (*(void *)&v5 - 1);
    }
    uint64_t v9 = *(uint64_t ***)(*a1 + 8 * v8);
    if (v9)
    {
      for (i = *v9; i; i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v6)
        {
          unsigned int v12 = *((unsigned __int16 *)i + 12);
          if (HIBYTE(a3) == v12 >> 8 && (~(-1 << SHIBYTE(a3)) & (v12 ^ a3)) == 0 && i[2] == a2)
          {
            char v14 = *((unsigned char *)i + 40);
            *a4 = i[4];
            *a5 = v14;
            return 1;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= *(void *)&v5) {
              v11 %= *(void *)&v5;
            }
          }
          else
          {
            v11 &= *(void *)&v5 - 1;
          }
          if (v11 != v8) {
            return 0;
          }
        }
      }
    }
  }
  return 0;
}

void cStringReleaseCallback(int a1, void *a2)
{
}

char *cStringRetainCallback(int a1, char *__s1)
{
  return strdup(__s1);
}

BOOL hasTrailingAsterisk(BOOL result)
{
  if (result)
  {
    CFStringRef v1 = (const __CFString *)result;
    CFIndex Length = CFStringGetLength((CFStringRef)result);
    CFIndex v3 = Length - 1;
    if (CFStringGetCharacterAtIndex(v1, Length - 1) == 42
      && (Length == 1 || CFStringGetCharacterAtIndex(v1, Length - 2) != 92))
    {
      return 1;
    }
    else if (Length < 1)
    {
      return 0;
    }
    else
    {
      for (CFIndex i = 0; i < Length; ++i)
      {
        int CharacterAtIndex = CFStringGetCharacterAtIndex(v1, i);
        if (i < v3 && CharacterAtIndex == 92)
        {
          uint64_t result = 0;
          ++i;
        }
        else
        {
          int v6 = CFStringGetCharacterAtIndex(v1, i);
          uint64_t result = i == v3 && v6 == 42;
        }
      }
    }
  }
  return result;
}

void utf8QueryString(const __CFString **a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7 = 0;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v8 = a3 - 1;
  if (a4) {
    uint64_t v9 = ", ";
  }
  else {
    uint64_t v9 = " ";
  }
  do
  {
    CFIndex Length = CFStringGetLength(*(CFStringRef *)(a2 + 8 * v7));
    CFIndex v11 = Length;
    if (*((char *)a1 + 23) >= 0) {
      CFStringRef v12 = (const __CFString *)*((unsigned __int8 *)a1 + 23);
    }
    else {
      CFStringRef v12 = a1[1];
    }
    CFIndex v13 = 3 * Length + 1;
    std::string::resize((std::string *)a1, (std::string::size_type)v12 + v13, 0);
    CFStringRef v14 = *(const __CFString **)(a2 + 8 * v7);
    if (*((char *)a1 + 23) >= 0) {
      BOOL v15 = a1;
    }
    else {
      BOOL v15 = (const __CFString **)*a1;
    }
    CFIndex usedBufLen = 0;
    v17.location = 0;
    v17.length = v11;
    CFStringGetBytes(v14, v17, 0x8000100u, 0, 0, (UInt8 *)v12 + (void)v15, v13, &usedBufLen);
    std::string::resize((std::string *)a1, (std::string::size_type)v12 + usedBufLen, 0);
    if (usedBufLen)
    {
      if (v7 < v8) {
        std::string::append((std::string *)a1, v9);
      }
    }
    ++v7;
  }
  while (a3 != v7);
}

_WORD *makeFalseNode(void)
{
  if (*MEMORY[0x1E4F14B00] <= 0x4FuLL) {
    ++sTotal;
  }
  v0 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x50uLL, 0x31F9A007uLL);
  if (!v0) {
    _log_fault_for_malloc_failure();
  }
  v0[24] = 16;
  return v0;
}

void *makeOrNode(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)a2;
  if (a1)
  {
    if (!a2) {
      return (void *)a1;
    }
    int v4 = *(unsigned __int16 *)(a1 + 48);
    if (v4 == 16)
    {
LABEL_6:
      uint64_t v8 = MEMORY[0x1E4F143A8];
      uint64_t v9 = 0x40000000;
      __int16 v10 = __db_query_tree_apply_block_block_invoke;
      CFIndex v11 = &unk_1E6348598;
      CFStringRef v12 = &__block_literal_global_161;
      db_query_tree_apply_block_with_meta((void *)a1, (uint64_t)&v8, 0);
      return v2;
    }
    int v5 = *(unsigned __int16 *)(a2 + 48);
    if (v5 == 16) {
      goto LABEL_8;
    }
    if (v5 == 32) {
      goto LABEL_6;
    }
    if (v4 == 32)
    {
LABEL_8:
      uint64_t v8 = MEMORY[0x1E4F143A8];
      uint64_t v9 = 0x40000000;
      __int16 v10 = __db_query_tree_apply_block_block_invoke;
      CFIndex v11 = &unk_1E6348598;
      CFStringRef v12 = &__block_literal_global_161;
      db_query_tree_apply_block_with_meta((void *)a2, (uint64_t)&v8, 0);
      return (void *)a1;
    }
    if (*MEMORY[0x1E4F14B00] <= 0x4FuLL) {
      ++sTotal;
    }
    uint64_t v7 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x50uLL, 0x31F9A007uLL);
    if (!v7) {
      _log_fault_for_malloc_failure();
    }
    *uint64_t v7 = a1;
    v7[1] = v2;
    uint64_t v2 = v7;
    *((_WORD *)v7 + 24) = 1;
  }
  return v2;
}

void *makeAndNode(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (a1)
  {
    if (!a2) {
      return (void *)a1;
    }
    int v4 = *(unsigned __int16 *)(a1 + 48);
    if (v4 == 32)
    {
LABEL_6:
      uint64_t v8 = MEMORY[0x1E4F143A8];
      uint64_t v9 = 0x40000000;
      __int16 v10 = __db_query_tree_apply_block_block_invoke;
      CFIndex v11 = &unk_1E6348598;
      CFStringRef v12 = &__block_literal_global_161;
      db_query_tree_apply_block_with_meta((void *)a1, (uint64_t)&v8, 0);
      return (void *)v2;
    }
    int v5 = *(unsigned __int16 *)(a2 + 48);
    if (v5 == 32) {
      goto LABEL_8;
    }
    if (v5 == 16) {
      goto LABEL_6;
    }
    if (v4 == 16)
    {
LABEL_8:
      uint64_t v8 = MEMORY[0x1E4F143A8];
      uint64_t v9 = 0x40000000;
      __int16 v10 = __db_query_tree_apply_block_block_invoke;
      CFIndex v11 = &unk_1E6348598;
      CFStringRef v12 = &__block_literal_global_161;
      db_query_tree_apply_block_with_meta((void *)a2, (uint64_t)&v8, 0);
      return (void *)a1;
    }
    if (*MEMORY[0x1E4F14B00] <= 0x4FuLL) {
      ++sTotal;
    }
    uint64_t v7 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x50uLL, 0x31F9A007uLL);
    if (!v7) {
      _log_fault_for_malloc_failure();
    }
    *uint64_t v7 = a1;
    v7[1] = v2;
    *((_WORD *)v7 + 24) = 2;
    return v7;
  }
  return (void *)v2;
}

_WORD *createQueryNode(const char *a1, char *__s, uint64_t a3, int a4, int a5, float a6, float a7)
{
  if (!a1) {
    return 0;
  }
  if (__s) {
    strlen(__s);
  }
  BOOL v15 = (void *)MEMORY[0x1E4F14B00];
  if (*MEMORY[0x1E4F14B00] <= 0x12FuLL) {
    ++sTotal;
  }
  unint64_t v16 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x130uLL, 0x31F9A007uLL);
  if (!v16) {
    _log_fault_for_malloc_failure();
  }
  *(void *)unint64_t v16 = strdup(a1);
  v16[6] = a4;
  *((void *)v16 + 4) = a3;
  if (a5 >= 1) {
    operator new[]();
  }
  if (a5 == -1) {
    operator new[]();
  }
  *((void *)v16 + 9) = strdup(__s);
  if ((*((unsigned char *)v16 + 34) & 0x80) != 0) {
    *((unsigned char *)v16 + 28) = 70;
  }
  *((float *)v16 + 13) = a6;
  *((float *)v16 + 14) = a7;
  if (*v15 <= 0x4FuLL) {
    ++sTotal;
  }
  CFStringRef v14 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x50uLL, 0x31F9A007uLL);
  if (!v14) {
    _log_fault_for_malloc_failure();
  }
  v14[24] = 4;
  *((void *)v14 + 2) = v16;
  return v14;
}

_WORD *createFieldMatchQueryNode(void *a1)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  int v1 = -1431655765 * ((uint64_t)(a1[1] - *a1) >> 3);
  if (v1 < 1) {
    return 0;
  }
  CFIndex v3 = (void *)MEMORY[0x1E4F14B00];
  if (*MEMORY[0x1E4F14B00] <= 0x12FuLL) {
    ++sTotal;
  }
  int v4 = (unsigned int *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x130uLL, 0x31F9A007uLL);
  if (!v4) {
    _log_fault_for_malloc_failure();
  }
  int v5 = strdup("_kMDItemBundleID");
  *(void *)int v4 = v5;
  v4[6] = 13;
  if (v1 >= 1024) {
    int v6 = 1024;
  }
  else {
    int v6 = v1;
  }
  v4[10] = v6;
  MEMORY[0x1F4188790](v5);
  uint64_t v8 = (char **)((char *)v20 - v7);
  bzero((char *)v20 - v7, v9);
  uint64_t v10 = v4[10];
  if ((int)v10 >= 1)
  {
    CFStringRef v12 = a1;
    uint64_t v11 = *a1;
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v12[1] - v11) >> 3);
    CFStringRef v14 = v8;
    do
    {
      if (!v13) {
        abort();
      }
      BOOL v15 = (const char *)v11;
      if (*(char *)(v11 + 23) < 0) {
        BOOL v15 = *(const char **)v11;
      }
      *v14++ = strdup(v15);
      v11 += 24;
      --v13;
      --v10;
    }
    while (v10);
  }
  size_t v16 = 8 * v1;
  CFRange v17 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v16, 0x6085D6BuLL);
  if (!v17) {
    _log_fault_for_malloc_failure();
  }
  *((void *)v4 + 21) = v17;
  memcpy(v17, v8, v16);
  if (*v3 <= 0x4FuLL) {
    ++sTotal;
  }
  size_t v18 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x50uLL, 0x31F9A007uLL);
  if (!v18) {
    _log_fault_for_malloc_failure();
  }
  v18[24] = 4;
  *((void *)v18 + 2) = v4;
  return v18;
}

_WORD *createQueryNodeForPhotosMediaType(int a1, int a2)
{
  if (a2)
  {
    float v2 = 1.1755e-38;
    if (a1) {
      int v3 = 1;
    }
    else {
      int v3 = 5;
    }
  }
  else
  {
    if (a1) {
      int v3 = 1;
    }
    else {
      int v3 = 5;
    }
    float v2 = 0.0;
  }
  return createQueryNode("kMDItemPhotosMediaTypes", "*", 0, v3, 0, v2, 0.0);
}

void *makeRetrievalNodeFromQueryString(char *a1)
{
  query_node_with_ann = db_make_query_node_with_ann(a1, 0);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = __db_query_tree_apply_block_block_invoke;
  v3[3] = &unk_1E6348598;
  v3[4] = &__block_literal_global_889;
  db_query_tree_apply_block_with_meta(query_node_with_ann, (uint64_t)v3, 0);
  return query_node_with_ann;
}

uint64_t ___Z32makeRetrievalNodeFromQueryStringPKc_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = a2;
  if (a2)
  {
    uint64_t v3 = *(void *)(a2 + 16);
    if (v3)
    {
      *(_DWORD *)(v3 + 52) = 0;
      *(_DWORD *)(v3 + 56) = 0;
    }
  }
  return result;
}

void *makeNonMatchRetrievalNodeFromQueryString(char *a1)
{
  query_node_with_ann = db_make_query_node_with_ann(a1, 0);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = __db_query_tree_apply_block_block_invoke;
  v3[3] = &unk_1E6348598;
  v3[4] = &__block_literal_global_7_893;
  db_query_tree_apply_block_with_meta(query_node_with_ann, (uint64_t)v3, 0);
  return query_node_with_ann;
}

uint64_t ___Z40makeNonMatchRetrievalNodeFromQueryStringPKc_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 16);
    if (v2)
    {
      *(_DWORD *)(v2 + 24) = 5;
      uint64_t v3 = *(void **)(v2 + 72);
      if (v3) {
        free(v3);
      }
      operator new[]();
    }
  }
  return a2;
}

_WORD *queryNodeForToken(char *a1, void *a2, uint64_t a3, unsigned char *a4)
{
  if (!a1) {
    return 0;
  }
  size_t v8 = strlen(a1);
  uint64_t v9 = 0;
  if (!a4 || !v8) {
    return (_WORD *)v9;
  }
  int v10 = *(_DWORD *)(a3 + 40);
  if (v10 <= 0 && v8 >= 4 && !*(unsigned char *)(a3 + 45) && !a4[17] && !a4[12] && a4[13]) {
    int v10 = 2;
  }
  uint64_t v11 = *(void *)(a3 + 16);
  if (*(char *)(v11 + 23) < 0)
  {
    if (!*(void *)(v11 + 8)) {
      goto LABEL_23;
    }
    CFStringRef v12 = *(char **)v11;
    goto LABEL_16;
  }
  CFStringRef v12 = *(char **)(a3 + 16);
  if (*(unsigned char *)(v11 + 23))
  {
LABEL_16:
    if (!a4[12])
    {
      float v15 = 0.0;
LABEL_48:
      if (v10 == -1)
      {
        int v10 = 1;
      }
      else if (v10 < 1)
      {
        int v10 = 0;
      }
      else
      {
        uint64_t v25 = *(void **)(a3 + 32);
        std::string::basic_string[abi:nn180100]<0>(__p, v12);
        if (!std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(v25, (uint64_t)__p))int v10 = 0; {
        if (v38 < 0)
        }
          operator delete(__p[0]);
      }
      return createQueryNode(v12, a1, *(void *)a3, *(_DWORD *)(a3 + 24), v10, v15 * *(float *)(a3 + 8), v15 * *(float *)(a3 + 12));
    }
    if (!*(unsigned char *)(a3 + 46) || strcmp(v12, "kMDItemTextContent"))
    {
      unint64_t v13 = std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(a2, v11);
      CFStringRef v14 = (float *)(v13 + 40);
      if (!v13) {
        CFStringRef v14 = (float *)&defaultAttributeScore;
      }
      float v15 = *v14 + *v14;
      goto LABEL_48;
    }
    return 0;
  }
LABEL_23:
  long long v36 = a2;
  size_t v16 = (uint64_t *)a2[2];
  if (v16)
  {
    uint64_t v9 = 0;
    do
    {
      CFRange v17 = (char *)(v16 + 2);
      if (*((char *)v16 + 39) < 0) {
        CFRange v17 = *(char **)v17;
      }
      if (!a4[12] || !*(unsigned char *)(a3 + 46) || strcmp(v17, "kMDItemTextContent"))
      {
        int v18 = v10 == -1;
        if (v10 >= 1)
        {
          uint64_t v19 = *(void **)(a3 + 32);
          std::string::basic_string[abi:nn180100]<0>(__p, v17);
          int v18 = std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(v19, (uint64_t)__p)? v10: 0;
          if (v38 < 0) {
            operator delete(__p[0]);
          }
        }
        QueryNode = createQueryNode(v17, a1, *(void *)a3, *(_DWORD *)(a3 + 24), v18, *((float *)v16 + 10) * *(float *)(a3 + 8), *((float *)v16 + 10) * *(float *)(a3 + 12));
        if (a4[20] && !strcmp(v17, "kMDItemTextContent"))
        {
          if (a4[12])
          {
            float v21 = 1.1755e-38;
            int v22 = 1;
          }
          else
          {
            float v21 = 0.0;
            int v22 = 5;
          }
          unint64_t v23 = createQueryNode("_kMDItemBundleID", "com.apple.mobilesafari", 0, v22, 0, 0.0, v21);
          QueryNode = makeAndNode((uint64_t)QueryNode, (uint64_t)v23);
        }
        unint64_t v24 = makeAndNode;
        if (!*(unsigned char *)(a3 + 28)) {
          unint64_t v24 = makeOrNode;
        }
        uint64_t v9 = (uint64_t)v24(v9, (uint64_t)QueryNode);
      }
      size_t v16 = (uint64_t *)*v16;
    }
    while (v16);
  }
  else
  {
    uint64_t v9 = 0;
  }
  if (!a4[12] && v10 > 0)
  {
    long long v26 = *(uint64_t **)(*(void *)(a3 + 32) + 16);
    if (v26)
    {
      uint64_t v27 = 0;
      uint64_t v35 = *(void *)a3;
      int v28 = *(_DWORD *)(a3 + 24);
      do
      {
        long long v29 = (char *)(v26 + 2);
        if (*((char *)v26 + 39) < 0) {
          long long v29 = *(char **)v29;
        }
        if (*((_DWORD *)v26 + 10)) {
          int v30 = *((_DWORD *)v26 + 10);
        }
        else {
          int v30 = v10;
        }
        if (strcmp(v29, "kMDItemTextContent"))
        {
          std::string::basic_string[abi:nn180100]<0>(__p, v29);
          uint64_t v31 = std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(v36, (uint64_t)__p);
          if (v38 < 0) {
            operator delete(__p[0]);
          }
          if (!v31 && v30 >= 1)
          {
            uint64_t v32 = createQueryNode(v29, a1, v35, v28, v30, 0.0, 0.0);
            uint64_t v27 = makeOrNode((uint64_t)v27, (uint64_t)v32);
          }
        }
        long long v26 = (uint64_t *)*v26;
      }
      while (v26);
    }
    else
    {
      uint64_t v27 = 0;
    }
    return makeOrNode(v9, (uint64_t)v27);
  }
  return (_WORD *)v9;
}

uint64_t normalizeQueryNode(uint64_t a1)
{
  uint64_t v6 = MEMORY[0x1E4F143A8];
  uint64_t v7 = 0x40000000;
  size_t v8 = __db_query_tree_apply_block_block_invoke;
  uint64_t v9 = &unk_1E6348598;
  int v10 = &__block_literal_global_13;
  db_query_tree_apply_block_with_meta((void *)a1, (uint64_t)&v6, (uint64_t)&__block_literal_global_17_900);
  int v2 = *(_DWORD *)(a1 + 72);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = ___Z18normalizeQueryNodeP10query_node_block_invoke_3;
  v4[3] = &__block_descriptor_tmp_18_901;
  int v5 = v2;
  uint64_t v6 = MEMORY[0x1E4F143A8];
  uint64_t v7 = 0x40000000;
  size_t v8 = __db_query_tree_apply_block_block_invoke;
  uint64_t v9 = &unk_1E6348598;
  int v10 = v4;
  return db_query_tree_apply_block_with_meta((void *)a1, (uint64_t)&v6, 0);
}

uint64_t ___Z18normalizeQueryNodeP10query_node_block_invoke_3(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 16);
    if (v2)
    {
      float v3 = *(float *)(v2 + 52);
      if (v3 > 1.1755e-38) {
        *(float *)(v2 + 52) = v3 / *(float *)(a1 + 32);
      }
      float v4 = *(float *)(v2 + 56);
      if (v4 > 1.1755e-38) {
        *(float *)(v2 + 56) = v4 / *(float *)(a1 + 32);
      }
    }
  }
  *(_DWORD *)(a2 + 72) = 0;
  return a2;
}

uint64_t ___Z18normalizeQueryNodeP10query_node_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = a2;
  if (a2 && a3 && a4)
  {
    *(void *)a2 = a3;
    *(void *)(a2 + 8) = a4;
    int v5 = *(unsigned __int16 *)(a2 + 48);
    if (v5 == 2)
    {
      float v7 = *(float *)(a3 + 72);
      float v6 = 0.0;
      if (v7 != 0.0)
      {
        float v8 = *(float *)(a4 + 72);
        if (v8 != 0.0) {
          float v6 = v7 + v8;
        }
      }
    }
    else
    {
      if (v5 != 1) {
        return result;
      }
      float v6 = *(float *)(a3 + 72);
      if (v6 <= *(float *)(a4 + 72)) {
        float v6 = *(float *)(a4 + 72);
      }
    }
    *(float *)(a2 + 72) = v6;
  }
  else if (a2)
  {
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    void v9[2] = __db_query_tree_apply_block_block_invoke;
    v9[3] = &unk_1E6348598;
    v9[4] = &__block_literal_global_161;
    db_query_tree_apply_block_with_meta((void *)a2, (uint64_t)v9, 0);
    return 0;
  }
  return result;
}

uint64_t ___Z18normalizeQueryNodeP10query_node_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = a2;
  if (a2)
  {
    uint64_t v3 = *(void *)(a2 + 16);
    if (v3)
    {
      float v4 = *(float *)(v3 + 52);
      if (v4 <= *(float *)(v3 + 56)) {
        float v4 = *(float *)(v3 + 56);
      }
      *(float *)(a2 + 72) = v4;
    }
  }
  return result;
}

BOOL isOptionalSpecialChar(UniChar a1)
{
  CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespaceAndNewline);
  BOOL v3 = 1;
  if (!CFCharacterSetIsCharacterMember(Predefined, a1))
  {
    CFCharacterSetRef v4 = CFCharacterSetGetPredefined(kCFCharacterSetControl);
    if (!CFCharacterSetIsCharacterMember(v4, a1))
    {
      CFCharacterSetRef v5 = CFCharacterSetCreateWithCharactersInString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @",;:.!_");
      BOOL v3 = CFCharacterSetIsCharacterMember(v5, a1) != 0;
      CFRelease(v5);
    }
  }
  return v3;
}

BOOL hasTrailingOptionalSpecialChar(const __CFString *a1)
{
  if (!a1 || !CFStringGetLength(a1)) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(a1);
  UniChar CharacterAtIndex = CFStringGetCharacterAtIndex(a1, Length - 1);
  return isOptionalSpecialChar(CharacterAtIndex);
}

BOOL hasOnlyOptionalSpecialChar(const __CFString *a1)
{
  if (!a1) {
    return 1;
  }
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v3 = Length - 1;
  if (Length < 1) {
    return 1;
  }
  CFIndex v4 = 0;
  do
  {
    UniChar CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v4);
    BOOL result = isOptionalSpecialChar(CharacterAtIndex);
    if (!result) {
      break;
    }
  }
  while (v3 != v4++);
  return result;
}

BOOL hasOnlySpecialChar(const __CFString *a1)
{
  if (!a1) {
    return 1;
  }
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v4 = Length - 1;
  if (Length < 1)
  {
    BOOL v8 = 1;
  }
  else
  {
    CFIndex v5 = 0;
    do
    {
      UniChar CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v5);
      int IsCharacterMember = CFCharacterSetIsCharacterMember(v2, CharacterAtIndex);
      BOOL v8 = IsCharacterMember != 0;
      if (!IsCharacterMember) {
        break;
      }
    }
    while (v4 != v5++);
  }
  CFRelease(v2);
  return v8;
}

BOOL isOptionalWord(char *a1)
{
  {
    OptionalWords(void)::optionalWords = 0u;
    unk_1E9FDA170 = 0u;
    dword_1E9FDA180 = 1065353216;
  }
  if (OptionalWords(void)::onceToken != -1) {
    dispatch_once(&OptionalWords(void)::onceToken, &__block_literal_global_28);
  }
  if (!qword_1E9FDA178) {
    return 0;
  }
  if (isLowerStr(a1)) {
    return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(OptionalWords(void)::optionalWords, *((unint64_t *)&OptionalWords(void)::optionalWords + 1), (uint64_t)a1) != 0;
  }
  toLowerCase(&__p, a1);
  BOOL v2 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(OptionalWords(void)::optionalWords, *((unint64_t *)&OptionalWords(void)::optionalWords + 1), (uint64_t)&__p) != 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v2;
}

BOOL isLowerStr(char *a1)
{
  uint64_t v1 = a1[23];
  if ((v1 & 0x80u) == 0) {
    BOOL v2 = a1;
  }
  else {
    BOOL v2 = *(char **)a1;
  }
  if ((v1 & 0x80u) != 0) {
    uint64_t v1 = *((void *)a1 + 1);
  }
  if (!v1) {
    return 1;
  }
  uint64_t v3 = v1 - 1;
  uint64_t v4 = MEMORY[0x1E4F14390];
  do
  {
    unsigned int v5 = *v2;
    if ((v5 & 0x80000000) != 0) {
      int v6 = __maskrune(v5, 0x1000uLL);
    }
    else {
      int v6 = *(_DWORD *)(v4 + 4 * v5 + 60) & 0x1000;
    }
    BOOL result = v6 != 0;
    ++v2;
    if (v6) {
      BOOL v8 = v3 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    --v3;
  }
  while (!v8);
  return result;
}

unsigned __int8 *std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  int v6 = *(char *)(a3 + 23);
  if (v6 >= 0) {
    float v7 = (uint64_t *)a3;
  }
  else {
    float v7 = *(uint64_t **)a3;
  }
  if (v6 >= 0) {
    unint64_t v8 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    unint64_t v8 = *(void *)(a3 + 8);
  }
  unint64_t v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v7, v8);
  if (!a2) {
    return 0;
  }
  unint64_t v10 = v9;
  uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v11.i16[0] = vaddlv_u8(v11);
  unint64_t v12 = v11.u32[0];
  if (v11.u32[0] > 1uLL)
  {
    unint64_t v13 = v9;
    if (v9 >= a2) {
      unint64_t v13 = v9 % a2;
    }
  }
  else
  {
    unint64_t v13 = (a2 - 1) & v9;
  }
  CFStringRef v14 = *(unsigned __int8 ***)(a1 + 8 * v13);
  if (!v14) {
    return 0;
  }
  for (CFIndex i = *v14; i; CFIndex i = *(unsigned __int8 **)i)
  {
    unint64_t v16 = *((void *)i + 1);
    if (v10 == v16)
    {
      if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a3)) {
        return i;
      }
    }
    else
    {
      if (v12 > 1)
      {
        if (v16 >= a2) {
          v16 %= a2;
        }
      }
      else
      {
        v16 &= a2 - 1;
      }
      if (v16 != v13) {
        return 0;
      }
    }
  }
  return i;
}

void toLowerCase(std::string *a1, char *a2)
{
  BOOL v2 = a2;
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  if (a2[23] >= 0) {
    std::string::size_type v4 = a2[23];
  }
  else {
    std::string::size_type v4 = *((void *)a2 + 1);
  }
  std::string::reserve(a1, v4);
  uint64_t v5 = *((void *)v2 + 1);
  if (v2[23] >= 0)
  {
    uint64_t v6 = v2[23];
  }
  else
  {
    BOOL v2 = *(char **)v2;
    uint64_t v6 = v5;
  }
  for (; v6; --v6)
  {
    __darwin_ct_rune_t v7 = *v2++;
    std::string::value_type v8 = __tolower(v7);
    std::string::push_back(a1, v8);
  }
}

void ___ZL13OptionalWordsv_block_invoke()
{
  v36.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4F143B8];
  CFLocaleRef v0 = CFLocaleCopyCurrent();
  if (v0)
  {
    CFLocaleRef v1 = v0;
    CFStringRef v2 = (const __CFString *)MEMORY[0x1C187FC90]();
    if (CFStringHasPrefix(v2, @"en"))
    {
      std::string::basic_string[abi:nn180100]<0>(__str, "to");
      std::string::basic_string[abi:nn180100]<0>(v11, "with");
      std::string::basic_string[abi:nn180100]<0>(v12, "in");
      std::string::basic_string[abi:nn180100]<0>(v13, "and");
      std::string::basic_string[abi:nn180100]<0>(v14, "or");
      std::string::basic_string[abi:nn180100]<0>(v15, "on");
      std::string::basic_string[abi:nn180100]<0>(&v16, "of");
      std::string::basic_string[abi:nn180100]<0>(v17, "at");
      std::string::basic_string[abi:nn180100]<0>(v18, "am");
      std::string::basic_string[abi:nn180100]<0>(&v19, "is");
      std::string::basic_string[abi:nn180100]<0>(v20, "are");
      std::string::basic_string[abi:nn180100]<0>(v21, "was");
      std::string::basic_string[abi:nn180100]<0>(&v22, "were");
      std::string::basic_string[abi:nn180100]<0>(v23, "be");
      std::string::basic_string[abi:nn180100]<0>(v24, "a");
      std::string::basic_string[abi:nn180100]<0>(v25, "an");
      std::string::basic_string[abi:nn180100]<0>(v26, "the");
      std::string::basic_string[abi:nn180100]<0>(v27, "by");
      std::string::basic_string[abi:nn180100]<0>(v28, "for");
      std::string::basic_string[abi:nn180100]<0>(v29, "from");
      std::string::basic_string[abi:nn180100]<0>(v30, "off");
      std::string::basic_string[abi:nn180100]<0>(v31, "so");
      std::string::basic_string[abi:nn180100]<0>(v32, "as");
      std::string::basic_string[abi:nn180100]<0>(v33, "during");
      std::string::basic_string[abi:nn180100]<0>(v34, "under");
      std::string::basic_string[abi:nn180100]<0>(v35, "saved");
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&OptionalWords(void)::optionalWords, __str, &v36);
      uint64_t v3 = 26;
      do
      {
        if (SHIBYTE(__str[v3 - 1].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str[v3 - 1].__r_.__value_.__l.__data_);
        }
        --v3;
      }
      while (v3 * 24);
    }
    else if (CFStringHasPrefix(v2, @"fr"))
    {
      std::string::basic_string[abi:nn180100]<0>(__str, "");
      std::string::basic_string[abi:nn180100]<0>(v11, "avec");
      std::string::basic_string[abi:nn180100]<0>(v12, "en");
      std::string::basic_string[abi:nn180100]<0>(v13, "dans");
      std::string::basic_string[abi:nn180100]<0>(v14, "a");
      std::string::basic_string[abi:nn180100]<0>(v15, "et");
      std::string::basic_string[abi:nn180100]<0>(&v16, "de");
      std::string::basic_string[abi:nn180100]<0>(v17, "au");
      std::string::basic_string[abi:nn180100]<0>(v18, "un");
      std::string::basic_string[abi:nn180100]<0>(&v19, "le");
      std::string::basic_string[abi:nn180100]<0>(v20, "la");
      std::string::basic_string[abi:nn180100]<0>(v21, "pendant");
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&OptionalWords(void)::optionalWords, __str, &v22);
      uint64_t v4 = 12;
      do
      {
        if (SHIBYTE(__str[v4 - 1].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str[v4 - 1].__r_.__value_.__l.__data_);
        }
        --v4;
      }
      while (v4 * 24);
    }
    else if (CFStringHasPrefix(v2, @"ja"))
    {
      std::string::basic_string[abi:nn180100]<0>(__str, "");
      std::string::basic_string[abi:nn180100]<0>(v11, "");
      std::string::basic_string[abi:nn180100]<0>(v12, "");
      std::string::basic_string[abi:nn180100]<0>(v13, "");
      std::string::basic_string[abi:nn180100]<0>(v14, "");
      std::string::basic_string[abi:nn180100]<0>(v15, "");
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&OptionalWords(void)::optionalWords, __str, &v16);
      for (uint64_t i = 0; i != -18; i -= 3)
      {
        if (SHIBYTE(v15[i + 2]) < 0) {
          operator delete((void *)v15[i]);
        }
      }
    }
    else if (CFStringHasPrefix(v2, @"zh"))
    {
      std::string::basic_string[abi:nn180100]<0>(__str, "");
      std::string::basic_string[abi:nn180100]<0>(v11, "");
      std::string::basic_string[abi:nn180100]<0>(v12, "");
      std::string::basic_string[abi:nn180100]<0>(v13, "");
      std::string::basic_string[abi:nn180100]<0>(v14, "");
      std::string::basic_string[abi:nn180100]<0>(v15, "");
      std::string::basic_string[abi:nn180100]<0>(&v16, "");
      std::string::basic_string[abi:nn180100]<0>(v17, "");
      std::string::basic_string[abi:nn180100]<0>(v18, "");
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&OptionalWords(void)::optionalWords, __str, &v19);
      for (uint64_t j = 0; j != -27; j -= 3)
      {
        if (SHIBYTE(v18[j + 2]) < 0) {
          operator delete((void *)v18[j]);
        }
      }
    }
    else if (CFStringHasPrefix(v2, @"de"))
    {
      std::string::basic_string[abi:nn180100]<0>(__str, "an");
      std::string::basic_string[abi:nn180100]<0>(v11, "in");
      std::string::basic_string[abi:nn180100]<0>(v12, "von");
      std::string::basic_string[abi:nn180100]<0>(v13, "nach");
      std::string::basic_string[abi:nn180100]<0>(v14, "mit");
      std::string::basic_string[abi:nn180100]<0>(v15, "und");
      std::string::basic_string[abi:nn180100]<0>(&v16, "oder");
      std::string::basic_string[abi:nn180100]<0>(v17, "bin");
      std::string::basic_string[abi:nn180100]<0>(v18, "bist");
      std::string::basic_string[abi:nn180100]<0>(&v19, "seit");
      std::string::basic_string[abi:nn180100]<0>(v20, "ist");
      std::string::basic_string[abi:nn180100]<0>(v21, "sind");
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&OptionalWords(void)::optionalWords, __str, &v22);
      uint64_t v7 = 12;
      do
      {
        if (SHIBYTE(__str[v7 - 1].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str[v7 - 1].__r_.__value_.__l.__data_);
        }
        --v7;
      }
      while (v7 * 24);
    }
    else
    {
      CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@", @"com.apple.metadata.SpotlightLinguistics");
      if (v8)
      {
        CFStringRef v9 = v8;
        if (CFBundleGetBundleWithIdentifier(v8)) {
          populateStopWords(v2);
        }
        CFRelease(v9);
      }
    }
    CFRelease(v1);
  }
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>(uint64_t a1, std::string *__str, std::string *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = __str;
  uint64_t v6 = *(void *)(a1 + 8);
  if (!v6) {
    goto LABEL_60;
  }
  for (uint64_t i = 0; i != v6; ++i)
    *(void *)(*(void *)a1 + 8 * i) = 0;
  CFStringRef v8 = *(void ***)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  if (v8) {
    BOOL v9 = __str == a3;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    unint64_t v10 = v8;
    goto LABEL_58;
  }
  uint64_t v32 = a1 + 16;
  while (1)
  {
    std::string::operator=((std::string *)(v8 + 2), v4);
    std::string __p = (void **)*v8;
    int v11 = *((char *)v8 + 39);
    if (v11 >= 0) {
      unint64_t v12 = (uint64_t *)(v8 + 2);
    }
    else {
      unint64_t v12 = (uint64_t *)v8[2];
    }
    if (v11 >= 0) {
      unint64_t v13 = *((unsigned __int8 *)v8 + 39);
    }
    else {
      unint64_t v13 = (unint64_t)v8[3];
    }
    unint64_t v14 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v12, v13);
    unint64_t v15 = v14;
    v8[1] = (void *)v14;
    unint64_t v16 = *(void *)(a1 + 8);
    if (v16)
    {
      uint8x8_t v17 = (uint8x8_t)vcnt_s8((int8x8_t)v16);
      v17.i16[0] = vaddlv_u8(v17);
      unint64_t v18 = v17.u32[0];
      if (v17.u32[0] > 1uLL)
      {
        unint64_t v19 = v14;
        if (v16 <= v14) {
          unint64_t v19 = v14 % v16;
        }
      }
      else
      {
        unint64_t v19 = (v16 - 1) & v14;
      }
      uint64_t v20 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v19);
      if (v20)
      {
        for (uint64_t j = *v20; j; uint64_t j = *(unsigned __int8 **)j)
        {
          unint64_t v22 = *((void *)j + 1);
          if (v22 == v15)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100](j + 16, (unsigned __int8 *)v8 + 16)) {
              goto LABEL_54;
            }
          }
          else
          {
            if (v18 > 1)
            {
              if (v22 >= v16) {
                v22 %= v16;
              }
            }
            else
            {
              v22 &= v16 - 1;
            }
            if (v22 != v19) {
              break;
            }
          }
        }
      }
    }
    float v23 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
    float v24 = *(float *)(a1 + 32);
    if (!v16 || (float)(v24 * (float)v16) < v23)
    {
      BOOL v25 = (v16 & (v16 - 1)) != 0;
      if (v16 < 3) {
        BOOL v25 = 1;
      }
      unint64_t v26 = v25 | (2 * v16);
      unint64_t v27 = vcvtps_u32_f32(v23 / v24);
      if (v26 <= v27) {
        size_t v28 = v27;
      }
      else {
        size_t v28 = v26;
      }
      std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__rehash<true>(a1, v28);
      unint64_t v16 = *(void *)(a1 + 8);
      unint64_t v15 = (unint64_t)v8[1];
    }
    uint8x8_t v29 = (uint8x8_t)vcnt_s8((int8x8_t)v16);
    v29.i16[0] = vaddlv_u8(v29);
    if (v29.u32[0] > 1uLL)
    {
      if (v15 >= v16) {
        v15 %= v16;
      }
    }
    else
    {
      v15 &= v16 - 1;
    }
    int v30 = *(void ***)(*(void *)a1 + 8 * v15);
    if (v30)
    {
      *CFStringRef v8 = *v30;
LABEL_52:
      *int v30 = v8;
      goto LABEL_53;
    }
    *CFStringRef v8 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = v8;
    *(void *)(*(void *)a1 + 8 * v15) = v32;
    if (*v8)
    {
      unint64_t v31 = *((void *)*v8 + 1);
      if (v29.u32[0] > 1uLL)
      {
        if (v31 >= v16) {
          v31 %= v16;
        }
      }
      else
      {
        v31 &= v16 - 1;
      }
      int v30 = (void **)(*(void *)a1 + 8 * v31);
      goto LABEL_52;
    }
LABEL_53:
    ++*(void *)(a1 + 24);
LABEL_54:
    ++v4;
    unint64_t v10 = __p;
    if (!__p) {
      break;
    }
    CFStringRef v8 = __p;
    uint64_t v3 = a3;
    if (v4 == a3) {
      goto LABEL_58;
    }
  }
  uint64_t v3 = a3;
LABEL_58:
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node(v10);
LABEL_60:
  while (v4 != v3)
  {
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(a1, (uint64_t)v4, (uint64_t)v4);
    ++v4;
  }
}

void populateStopWords(const __CFString *a1)
{
  int v19 = -1;
  int v20 = -1;
  int v17 = 0;
  int v18 = -1;
  if (CFBundleGetLocalizationInfoForLocalization())
  {
    uint64_t v2 = CFBundleCopyLocalizationForLocalizationInfo();
    if (v2)
    {
      uint64_t v3 = (const void *)v2;
      CFDictionaryRef v4 = (const __CFDictionary *)CFBundleCopyLocalizedStringTableForLocalization();
      if (v4)
      {
        CFDictionaryRef v5 = v4;
        if (CFDictionaryGetCount(v4)
          || (v21.location = 0,
              v21.length = 2,
              CFStringRef v6 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, v21),
              CFRelease(v5),
              CFDictionaryRef v5 = (const __CFDictionary *)CFBundleCopyLocalizedStringTableForLocalization(),
              CFRelease(v6),
              v5))
        {
          CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v5, @"STOPWORDS_SHORT");
          if (Value)
          {
            CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Value, @" | ");
            if (ArrayBySeparatingStrings)
            {
              CFArrayRef v9 = ArrayBySeparatingStrings;
              CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
              if (Count >= 1)
              {
                CFIndex v11 = Count;
                for (CFIndex i = 0; i != v11; ++i)
                {
                  CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v9, i);
                  CStringPtr = (char *)CFStringGetCStringPtr(ValueAtIndex, 0x8000100u);
                  if (CStringPtr)
                  {
                    std::string::basic_string[abi:nn180100]<0>(__p, CStringPtr);
                    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>((uint64_t)&OptionalWords(void)::optionalWords, (uint64_t)__p, (uint64_t)__p);
                    if (v16 < 0) {
                      operator delete(__p[0]);
                    }
                  }
                }
              }
              CFRelease(v9);
            }
          }
          CFRelease(v5);
        }
      }
      CFRelease(v3);
    }
  }
}

CFStringRef isOptionalToken(const __CFString *a1, int a2)
{
  CFStringRef v2 = a1;
  CFStringRef v10 = a1;
  if (!a2 || !hasTrailingAsterisk((BOOL)a1) || (CFIndex Length = CFStringGetLength(v2), Length < 1))
  {
    CFDictionaryRef v4 = 0;
    if (!v2) {
      goto LABEL_12;
    }
LABEL_7:
    std::string __p = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    utf8QueryString((const __CFString **)&__p, (uint64_t)&v10, 1, 0);
    uint64_t v5 = HIBYTE(v9);
    if (v9 < 0) {
      uint64_t v5 = v8;
    }
    if (v5)
    {
      CFStringRef v2 = (const __CFString *)isOptionalWord((char *)&__p);
      if ((v9 & 0x8000000000000000) == 0) {
        goto LABEL_12;
      }
    }
    else
    {
      CFStringRef v2 = 0;
      if ((v9 & 0x8000000000000000) == 0) {
        goto LABEL_12;
      }
    }
    operator delete(__p);
    goto LABEL_12;
  }
  v11.location = 0;
  v11.length = Length - 1;
  CFStringRef v2 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2, v11);
  CFStringRef v10 = v2;
  CFDictionaryRef v4 = v2;
  if (v2) {
    goto LABEL_7;
  }
LABEL_12:
  if (v4) {
    CFRelease(v4);
  }
  return v2;
}

BOOL isRelationWord(char *a1)
{
  {
    RelationWords(void)::relationWords = 0u;
    *(_OWORD *)algn_1E9FDABE8 = 0u;
    dword_1E9FDABF8 = 1065353216;
  }
  if (RelationWords(void)::onceToken[0] != -1) {
    dispatch_once(RelationWords(void)::onceToken, &__block_literal_global_124);
  }
  if (!qword_1E9FDABF0) {
    return 0;
  }
  if (isLowerStr(a1)) {
    return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(RelationWords(void)::relationWords, *((unint64_t *)&RelationWords(void)::relationWords + 1), (uint64_t)a1) != 0;
  }
  toLowerCase(&__p, a1);
  BOOL v2 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(RelationWords(void)::relationWords, *((unint64_t *)&RelationWords(void)::relationWords + 1), (uint64_t)&__p) != 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v2;
}

void ___ZL13RelationWordsv_block_invoke()
{
  v46.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4F143B8];
  CFLocaleRef v0 = CFLocaleCopyCurrent();
  if (v0)
  {
    CFLocaleRef v1 = v0;
    CFStringRef v2 = (const __CFString *)MEMORY[0x1C187FC90]();
    if (CFStringHasPrefix(v2, @"en"))
    {
      std::string::basic_string[abi:nn180100]<0>(&__str, "mother");
      std::string::basic_string[abi:nn180100]<0>(v5, "mothers");
      std::string::basic_string[abi:nn180100]<0>(v6, "mom");
      std::string::basic_string[abi:nn180100]<0>(v7, "moms");
      std::string::basic_string[abi:nn180100]<0>(v8, "mama");
      std::string::basic_string[abi:nn180100]<0>(v9, "mommy");
      std::string::basic_string[abi:nn180100]<0>(v10, "mommies");
      std::string::basic_string[abi:nn180100]<0>(v11, "mum");
      std::string::basic_string[abi:nn180100]<0>(v12, "father");
      std::string::basic_string[abi:nn180100]<0>(v13, "fathers");
      std::string::basic_string[abi:nn180100]<0>(v14, "dad");
      std::string::basic_string[abi:nn180100]<0>(v15, "dads");
      std::string::basic_string[abi:nn180100]<0>(v16, "papa");
      std::string::basic_string[abi:nn180100]<0>(v17, "daddy");
      std::string::basic_string[abi:nn180100]<0>(v18, "daddies");
      std::string::basic_string[abi:nn180100]<0>(v19, "brother");
      std::string::basic_string[abi:nn180100]<0>(v20, "brothers");
      std::string::basic_string[abi:nn180100]<0>(v21, "sister");
      std::string::basic_string[abi:nn180100]<0>(v22, "sisters");
      std::string::basic_string[abi:nn180100]<0>(v23, "sibling");
      std::string::basic_string[abi:nn180100]<0>(v24, "siblings");
      std::string::basic_string[abi:nn180100]<0>(v25, "parent");
      std::string::basic_string[abi:nn180100]<0>(v26, "parents");
      std::string::basic_string[abi:nn180100]<0>(v27, "family");
      std::string::basic_string[abi:nn180100]<0>(v28, "relatives");
      std::string::basic_string[abi:nn180100]<0>(v29, "kin");
      std::string::basic_string[abi:nn180100]<0>(v30, "friend");
      std::string::basic_string[abi:nn180100]<0>(v31, "friends");
      std::string::basic_string[abi:nn180100]<0>(v32, "partner");
      std::string::basic_string[abi:nn180100]<0>(v33, "partners");
      std::string::basic_string[abi:nn180100]<0>(v34, "spouse");
      std::string::basic_string[abi:nn180100]<0>(v35, "spouses");
      std::string::basic_string[abi:nn180100]<0>(v36, "coworker");
      std::string::basic_string[abi:nn180100]<0>(v37, "coworkers");
      std::string::basic_string[abi:nn180100]<0>(v38, "colleague");
      std::string::basic_string[abi:nn180100]<0>(v39, "colleagues");
      std::string::basic_string[abi:nn180100]<0>(v40, "alumni");
      std::string::basic_string[abi:nn180100]<0>(v41, "alum");
      std::string::basic_string[abi:nn180100]<0>(v42, "son");
      std::string::basic_string[abi:nn180100]<0>(v43, "sons");
      std::string::basic_string[abi:nn180100]<0>(v44, "daughter");
      std::string::basic_string[abi:nn180100]<0>(v45, "daughters");
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&RelationWords(void)::relationWords, &__str, &v46);
      uint64_t v3 = 1008;
      do
      {
        if (__str.__r_.__value_.__s.__data_[v3 - 1] < 0) {
          operator delete(*(void **)((char *)&__str.__r_.__value_.__l + v3 - 24));
        }
        v3 -= 24;
      }
      while (v3);
    }
    CFRelease(v1);
  }
}

BOOL isPhotosAttribute(uint64_t a1)
{
  {
    PhotosAttributes(void)::_photosAttributes = 0u;
    unk_1E9FDAC40 = 0u;
    dword_1E9FDAC50 = 1065353216;
  }
  if (PhotosAttributes(void)::onceToken != -1) {
    dispatch_once(&PhotosAttributes(void)::onceToken, &__block_literal_global_169);
  }
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(PhotosAttributes(void)::_photosAttributes, *((unint64_t *)&PhotosAttributes(void)::_photosAttributes + 1), a1) != 0;
}

void ___ZL16PhotosAttributesv_block_invoke()
{
  v16.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4F143B8];
  std::string::basic_string[abi:nn180100]<0>(&v1, "kMDItemPhotosBusinessCategories");
  std::string::basic_string[abi:nn180100]<0>(v2, "kMDItemPhotosBusinessNames");
  std::string::basic_string[abi:nn180100]<0>(v3, "kMDItemPhotosEventCategories");
  std::string::basic_string[abi:nn180100]<0>(v4, "kMDItemPhotosEventNames");
  std::string::basic_string[abi:nn180100]<0>(v5, "kMDItemPhotosEventPerformers");
  std::string::basic_string[abi:nn180100]<0>(v6, "kMDItemPhotosHolidays");
  std::string::basic_string[abi:nn180100]<0>(v7, "kMDItemPhotosKeywords");
  std::string::basic_string[abi:nn180100]<0>(v8, "kMDItemPhotosLocationKeywords");
  std::string::basic_string[abi:nn180100]<0>(v9, "kMDItemPhotosMeanings");
  std::string::basic_string[abi:nn180100]<0>(v10, "kMDItemPhotosMediaTypes");
  std::string::basic_string[abi:nn180100]<0>(v11, "kMDItemPhotosMemoryTitle");
  std::string::basic_string[abi:nn180100]<0>(v12, "kMDItemPhotosPeopleNames");
  std::string::basic_string[abi:nn180100]<0>(v13, "kMDItemPhotosSceneClassificationLabels");
  std::string::basic_string[abi:nn180100]<0>(v14, "kMDItemPhotosSceneClassificationSynonyms");
  std::string::basic_string[abi:nn180100]<0>(v15, "kMDItemPhotosSeasons");
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&PhotosAttributes(void)::_photosAttributes, &v1, &v16);
  uint64_t v0 = 360;
  do
  {
    if (v1.__r_.__value_.__s.__data_[v0 - 1] < 0) {
      operator delete(*(void **)((char *)&v1.__r_.__value_.__l + v0 - 24));
    }
    v0 -= 24;
  }
  while (v0);
}

uint64_t is_tokenizable_searchable_string_field(const char *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t result = gDefaultSchema;
  if (gDefaultSchema)
  {
    long long v6 = 0uLL;
    uint64_t v7 = 0;
    _MDPlistContainerGetPlistObjectAtKeyArray();
    long long v8 = 0uLL;
    uint64_t v9 = 0;
    long long v4 = 0uLL;
    uint64_t v5 = 0;
    uint64_t result = _MDPlistDictionaryGetPlistObjectForKey();
    if (result)
    {
      long long v2 = v8;
      uint64_t v3 = v9;
      uint64_t result = attrsKeyValueMatchesString((uint64_t)&v2, (uint64_t)"type", 4, "CFString", 8);
      if (result)
      {
        if (attrsKeyValueEnabled() & 1) != 0 || (attrsKeyValueEnabled()) {
          return 0;
        }
        else {
          return attrsKeyValueEnabled() ^ 1;
        }
      }
    }
  }
  return result;
}

void *CreateQueryTokens(const __CFString *a1, int a2)
{
  if (*MEMORY[0x1E4F14B00] <= 0x1FuLL) {
    ++sTotal;
  }
  long long v4 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x20uLL, 0x31F9A007uLL);
  if (!v4) {
    _log_fault_for_malloc_failure();
  }
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  long long v6 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  *(void *)long long v4 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  *((void *)v4 + 1) = CFArrayCreateMutable(v5, 0, v6);
  *((void *)v4 + 2) = CFArrayCreateMutable(v5, 0, v6);
  if (a2)
  {
    CFLocaleRef v7 = CFLocaleCopyCurrent();
    MEMORY[0x1C187FC90]();
    long long v8 = CITokenizerCreate(3);
    *((void *)v4 + 3) = v8;
    CITokenizerGetQueryTokensWithOptions((uint64_t)v8);
    CFRelease(v7);
    CITokenizerDispose(v8);
    *((void *)v4 + 3) = 0;
  }
  else
  {
    uint64_t v12 = 0;
    CFIndex Length = CFStringGetLength(a1);
    CFNumberRef v9 = CFNumberCreate(v5, kCFNumberCFIndexType, &v12);
    CFArrayAppendValue(*((CFMutableArrayRef *)v4 + 1), v9);
    CFRelease(v9);
    CFNumberRef v10 = CFNumberCreate(v5, kCFNumberCFIndexType, &Length);
    CFArrayAppendValue(*((CFMutableArrayRef *)v4 + 2), v10);
    CFRelease(v10);
    CFArrayAppendValue(*(CFMutableArrayRef *)v4, a1);
  }
  return v4;
}

void QueryTokensCallback(unsigned __int16 *a1, uint64_t a2, void *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    bzero(bytes, 0x414uLL);
    numBytes[0] = 0;
    if (!utf8_encodestr(a1, 2 * a2, bytes, numBytes, 1043))
    {
      CFIndex v6 = numBytes[0];
      if (numBytes[0])
      {
        bytes[numBytes[0]] = 0;
        CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFStringRef v8 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, v6, 0x8000100u, 0);
        *(_OWORD *)numBytes = *(_OWORD *)(*((void *)a3 + 3) + 88);
        CFNumberRef v9 = CFNumberCreate(v7, kCFNumberCFIndexType, numBytes);
        CFArrayAppendValue(*((CFMutableArrayRef *)a3 + 1), v9);
        CFRelease(v9);
        CFNumberRef v10 = CFNumberCreate(v7, kCFNumberCFIndexType, &numBytes[1]);
        CFArrayAppendValue(*((CFMutableArrayRef *)a3 + 2), v10);
        CFRelease(v10);
        CFArrayAppendValue(*(CFMutableArrayRef *)a3, v8);
        CFRelease(v8);
      }
    }
  }
}

void freeQueryTokensContext(CFTypeRef *a1)
{
  if (a1)
  {
    CFRelease(*a1);
    CFRelease(a1[1]);
    CFRelease(a1[2]);
    free(a1);
  }
}

uint64_t getRangeAtIndex(const __CFArray *a1, const __CFArray *a2, CFIndex idx)
{
  CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(a1, idx);
  CFTypeID v6 = CFGetTypeID(ValueAtIndex);
  if (v6 != CFNumberGetTypeID()) {
    return -1;
  }
  CFAllocatorRef v7 = CFArrayGetValueAtIndex(a2, idx);
  CFTypeID v8 = CFGetTypeID(v7);
  if (v8 != CFNumberGetTypeID()) {
    return -1;
  }
  uint64_t valuePtr = 0;
  if (!CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberCFIndexType, &valuePtr)) {
    return -1;
  }
  uint64_t v10 = 0;
  if (CFNumberGetValue((CFNumberRef)v7, kCFNumberCFIndexType, &v10)) {
    return valuePtr;
  }
  else {
    return -1;
  }
}

uint64_t store_stream_init(uint64_t a1, _DWORD *a2, char a3)
{
  uint64_t v11 = 0;
  uint64_t v6 = _fd_acquire_fd((uint64_t)a2, &v11);
  int v7 = v6;
  uint64_t v8 = v11;
  uint64_t inited = store_stream_init_fd(a1, v6, v11, 0, a3);
  if (inited) {
    *(void *)(a1 + 56) = a2;
  }
  else {
    _fd_release_fd(a2, v7, 0, v8);
  }
  return inited;
}

uint64_t store_stream_init_fd(uint64_t a1, uint64_t a2, uint64_t a3, off_t a4, char a5)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  memset(&v17, 0, sizeof(v17));
  *(_OWORD *)(a1 + 4) = 0u;
  *(_OWORD *)(a1 + 20) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)a1 = -1;
  int v10 = fstat(a2, &v17);
  *(_DWORD *)(a1 + 16) = v10;
  if (!v10)
  {
    st_std::string::size_type size = 0x100000;
    *(void *)(a1 + 32) = 0x100000;
    if ((a5 & 1) == 0)
    {
      st_std::string::size_type size = v17.st_size;
      if (v17.st_size >= 0x100000) {
        st_std::string::size_type size = 0x100000;
      }
      else {
        *(void *)(a1 + 32) = v17.st_size;
      }
    }
    unint64_t v15 = malloc_type_malloc(st_size, 0x96E29757uLL);
    *(void *)(a1 + 48) = v15;
    if (v15)
    {
      *(void *)(a1 + 24) = a4;
      if (a5)
      {
LABEL_13:
        *(_DWORD *)a1 = a2;
        *(void *)(a1 + 8) = a3;
        return 1;
      }
      ssize_t v16 = prot_pread(a2, v15, *(void *)(a1 + 32), a4);
      if (v16 != -1)
      {
        *(void *)(a1 + 24) += v16;
        *(void *)(a1 + 32) = v16;
        goto LABEL_13;
      }
    }
  }
  uint64_t v11 = __error();
  int v12 = *v11;
  *(_DWORD *)(a1 + 16) = *v11;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    v17.st_dev = 67109120;
    *(_DWORD *)&v17.st_mode = v12;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "store_stream_init err:%d", (uint8_t *)&v17, 8u);
  }
  store_stream_destroy(a1);
  return 0;
}

void store_stream_destroy(uint64_t a1)
{
  long long v2 = *(void **)(a1 + 48);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 32) = 0;
    if (*(_DWORD *)a1 != -1)
    {
      uint64_t v3 = *(_DWORD **)(a1 + 56);
      if (v3)
      {
        _fd_release_fd(v3, *(_DWORD *)a1, 0, *(void *)(a1 + 8));
        *(_DWORD *)a1 = -1;
      }
    }
    *(void *)(a1 + 56) = 0;
  }
}

uint64_t store_stream_flush(unsigned int *a1, int a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1[4];
  if (v2) {
    return v2;
  }
  uint64_t v6 = (uint64_t)(a1 + 2);
  uint64_t v7 = *((void *)a1 + 1);
  uint64_t v8 = *a1;
  if (v7) {
    uint64_t v9 = prot_pwrite_guarded(v8, v6, *((void *)a1 + 6), *((void *)a1 + 5), *((void *)a1 + 3));
  }
  else {
    uint64_t v9 = prot_pwrite(v8, *((char **)a1 + 6), *((void *)a1 + 5), *((void *)a1 + 3));
  }
  if (*((void *)a1 + 5) == v9)
  {
    *((void *)a1 + 3) += v9;
  }
  else
  {
    uint64_t v2 = *__error();
    a1[4] = v2;
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_10;
    }
    int v11 = 67109120;
    int v12 = v2;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "store_stream_flush write err:%d", (uint8_t *)&v11, 8u);
  }
  uint64_t v2 = a1[4];
LABEL_10:
  *((void *)a1 + 5) = 0;
  if (a2 && !v2)
  {
    int v10 = fsync(*a1);
    a1[4] = v10;
    if (v10)
    {
      uint64_t v2 = *__error();
      a1[4] = v2;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        int v11 = 67109120;
        int v12 = v2;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "store_stream_flush sync err:%d", (uint8_t *)&v11, 8u);
        return a1[4];
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t quick_check_suspension(uint64_t a1)
{
  uint64_t v7 = 0;
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 8));
  if (((*(_DWORD *)(a1 + 112) || *(void *)(a1 + 136)) && *(_DWORD *)(a1 + 128) == 1 || *(_DWORD *)(a1 + 108))
    && !*(unsigned char *)(a1 + 59))
  {
    ++*(_DWORD *)(a1 + 116);
    *(_DWORD *)(a1 + 192) = 0;
    si_scheduler_do_suspend(a1, &v7);
    uint64_t v3 = v7;
    if (v7)
    {
      pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 8));
      si_scheduler_trigger_tokens(v3);
      pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 8));
      if (*(_DWORD *)(a1 + 108))
      {
        if (!*(unsigned char *)(a1 + 59)) {
          pthread_cond_broadcast(*(pthread_cond_t **)(a1 + 16));
        }
      }
    }
    while (*(_DWORD *)(a1 + 108) && !*(unsigned char *)(a1 + 59))
    {
      v6.tv_sec = 0;
      *(void *)&v6.tv_usec = 0;
      v5.tv_sec = 0;
      v5.tv_nsec = 0;
      gettimeofday(&v6, 0);
      v5.tv_sec = v6.tv_sec + 1;
      v5.tv_nsec = 0;
      pthread_cond_timedwait(*(pthread_cond_t **)(a1 + 16), *(pthread_mutex_t **)(a1 + 8), &v5);
    }
    --*(_DWORD *)(a1 + 116);
    uint64_t v2 = 1;
  }
  else
  {
    uint64_t v2 = 0;
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 8));
  return v2;
}

void __work_fun_inner_block_invoke_2(void *a1)
{
  uint64_t v2 = a1[5];
  BOOL v3 = !*(_DWORD *)(v2 + 96) && !*(unsigned char *)(v2 + 56) && *(_DWORD *)(a1[6] + 36) == 0;
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = v3;
  if (!*(unsigned char *)(*(void *)(a1[4] + 8) + 24))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v2 + 120));
    --*(_DWORD *)(v2 + 104);
    os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 120));
    uint64_t v4 = a1[7];
    if (v4) {
      *(void *)(v4 + 24) = 0;
    }
    timespec v5 = (os_unfair_lock_s *)a1[8];
    os_unfair_lock_lock(v5 + 30);
    --v5[26]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v5 + 30);
  }
}

void __work_fun_inner_block_invoke_53(void *a1)
{
  if (*(unsigned char *)(*(void *)(a1[4] + 8) + 24))
  {
    uint64_t v2 = (os_unfair_lock_s **)a1[5];
    BOOL v3 = (os_unfair_lock_s *)a1[6];
    v2[8] = (os_unfair_lock_s *)((char *)v2[8] - 1);
    if (v3 == *v2)
    {
      os_unfair_lock_lock(v3 + 30);
      --v3[26]._os_unfair_lock_opaque;
      os_unfair_lock_unlock(v3 + 30);
      uint64_t v4 = a1[6];
      if (!*(_DWORD *)(v4 + 104))
      {
        uint64_t v5 = *(void *)(v4 + 40);
        if (v5)
        {
          (*(void (**)(void))(v5 + 16))();
          _Block_release(*(const void **)(a1[6] + 40));
          *(void *)(a1[6] + 40) = 0;
        }
      }
    }
    timeval v6 = (os_unfair_lock_s *)a1[7];
    os_unfair_lock_lock(v6 + 30);
    --v6[26]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v6 + 30);
    uint64_t v7 = a1[8];
    if (v7) {
      *(void *)(v7 + 24) = 0;
    }
    uint64_t v8 = a1[7];
    if (!*(_DWORD *)(v8 + 104))
    {
      uint64_t v9 = *(void *)(v8 + 40);
      if (v9)
      {
        (*(void (**)(void))(v9 + 16))();
        _Block_release(*(const void **)(a1[7] + 40));
        *(void *)(a1[7] + 40) = 0;
      }
    }
  }
}

void __work_fun_inner_block_invoke_2_55(uint64_t a1)
{
  dispatch_resume(*(dispatch_object_t *)(a1 + 32));
  uint64_t v2 = *(NSObject **)(a1 + 32);
  dispatch_release(v2);
}

void si_enqueue_barrier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 32)) {
    si_enqueue_barrier_with_qos(a1, *(unsigned __int8 *)(a1 + 24), a2, a3);
  }
  else {
    si_enqueue_barrier_for_job(a1, a2, a3, 0);
  }
}

void __enqueue_work_block_invoke(uint64_t a1)
{
}

void si_enqueue_block(uint64_t a1, void *aBlock)
{
  if (*(unsigned char *)(a1 + 32))
  {
    int v3 = *(unsigned __int8 *)(a1 + 24);
    uint64_t v4 = _Block_copy(aBlock);
    si_enqueue_work_with_qos(a1, v3, (uint64_t)_si_run_block, (uint64_t)v4);
  }
  else
  {
    uint64_t v5 = _Block_copy(aBlock);
    si_enqueue_work_for_job(a1, (uint64_t)_si_run_block, (uint64_t)v5, 0);
  }
}

void _si_run_block(void (**a1)(void))
{
  a1[2]();
  _Block_release(a1);
}

void si_workqueue_drain(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  if (v2) {
    si_scheduler_remove_workqueue(v2, (void *)a1);
  }
  dispatch_block_t v3 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, QOS_CLASS_UTILITY, 0, &__block_literal_global_1077);
  dispatch_async(*(dispatch_queue_t *)(a1 + 16), v3);
  _Block_release(v3);
}

void si_scheduler_remove_workqueue(uint64_t a1, void *a2)
{
  if (*a2 == a1)
  {
    dispatch_block_t v3 = *(NSObject **)(a1 + 32);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __si_scheduler_remove_workqueue_block_invoke;
    block[3] = &__block_descriptor_tmp_13_1079;
    block[4] = a1;
    dispatch_sync(v3, block);
    *a2 = 0;
  }
}

uint64_t __si_scheduler_remove_workqueue_block_invoke(uint64_t result)
{
  return result;
}

void si_scheduler_drain_locked(uint64_t a1, dispatch_group_t group)
{
  if (a1)
  {
    uint64_t v4 = *(int **)a1;
    if (v4) {
      si_scheduler_remove_scheduler(v4, (int **)a1);
    }
    atomic_fetch_add((atomic_uint *volatile)(a1 + 88), 1u);
    if (group)
    {
      dispatch_group_enter(group);
      dispatch_retain(group);
    }
    uint64_t v5 = *(NSObject **)(a1 + 152);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = __si_scheduler_drain_locked_block_invoke;
    void v6[3] = &__block_descriptor_tmp_7_1082;
    v6[4] = a1;
    v6[5] = group;
    dispatch_barrier_async(v5, v6);
  }
}

int *si_scheduler_remove_scheduler(int *result, int **a2)
{
  dispatch_block_t v3 = result;
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (dword_1E9FC90B0 >= 5)
  {
    int v4 = *__error();
    uint64_t v5 = _SILogForLogForCategory(3);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      timeval v6 = a2[9];
      uint64_t v7 = *((void *)v3 + 9);
      *(_DWORD *)iovec buf = 136315394;
      uint64_t v13 = v6;
      __int16 v14 = 2080;
      uint64_t v15 = v7;
      _os_log_impl(&dword_1BD672000, v5, OS_LOG_TYPE_DEFAULT, "Remove scheduler %s from %s", buf, 0x16u);
    }
    uint64_t result = __error();
    *uint64_t result = v4;
  }
  if (*a2 != v3)
  {
    uint64_t v8 = __si_assert_copy_extra_625(-1);
    uint64_t v9 = v8;
    int v10 = "";
    if (v8) {
      int v10 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIScheduler.c", 968, "child->parent==scheduler", v10);
    free(v9);
    if (__valid_fs(-1)) {
      uint64_t v11 = 2989;
    }
    else {
      uint64_t v11 = 3072;
    }
    *(_DWORD *)uint64_t v11 = -559038737;
    abort();
  }
  atomic_fetch_add(v3 + 23, 0xFFFFFFFF);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (atomic_fetch_add(v3 + 22, 0xFFFFFFFF) == 1) {
    return (int *)_si_scheduler_destroy(v3);
  }
  return result;
}

void __si_scheduler_drain_locked_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && atomic_fetch_add((atomic_uint *volatile)(v2 + 88), 0xFFFFFFFF) == 1) {
    _si_scheduler_destroy(v2);
  }
  dispatch_block_t v3 = *(NSObject **)(a1 + 40);
  if (v3)
  {
    dispatch_group_leave(v3);
    int v4 = *(NSObject **)(a1 + 40);
    dispatch_release(v4);
  }
}

void _si_scheduler_destroy(uint64_t a1)
{
  uint64_t v2 = *(int **)a1;
  if (v2) {
    si_scheduler_remove_scheduler(v2, (int **)a1);
  }
  free(*(void **)(a1 + 72));
  dispatch_activate(*(dispatch_object_t *)(a1 + 152));
  dispatch_release(*(dispatch_object_t *)(a1 + 152));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 57))
  {
    dispatch_block_t v3 = *(pthread_mutex_t **)(a1 + 8);
    if (v3)
    {
      pthread_mutex_destroy(v3);
      free(*(void **)(a1 + 8));
    }
    int v4 = *(pthread_cond_t **)(a1 + 16);
    if (v4)
    {
      pthread_cond_destroy(v4);
      free(*(void **)(a1 + 16));
    }
  }
  uint64_t v5 = *(void *)(a1 + 136);
  if (v5)
  {
    do
    {
      *(unsigned char *)(v5 + 4) = 0;
      uint64_t v6 = *(void *)(v5 + 16);
      *(void *)(v5 + 8) = 0;
      release_token((void *)v5);
      uint64_t v5 = v6;
    }
    while (v6);
  }
  free((void *)a1);
}

void __si_scheduler_drain_block_invoke(uint64_t a1)
{
}

uint64_t __si_scheduler_remove_and_destroy_block_invoke(uint64_t result)
{
  return result;
}

void __si_scheduler_remove_and_destroy_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (*v2 == *(void *)(a1 + 40))
  {
    *uint64_t v2 = 0;
    si_workqueue_destroy(*(void *)(a1 + 32));
  }
  else
  {
    si_workqueue_destroy((uint64_t)v2);
  }
}

void si_workqueue_destroy(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(const void **)(a1 + 72);
    if (v2) {
      CFRelease(v2);
    }
    dispatch_barrier_async(*(dispatch_queue_t *)(a1 + 16), &__block_literal_global_35);
    dispatch_release(*(dispatch_object_t *)(a1 + 16));
    dispatch_assert_queue_not_V2(*(dispatch_queue_t *)(a1 + 8));
    dispatch_barrier_sync(*(dispatch_queue_t *)(a1 + 8), &__block_literal_global_38);
    dispatch_release(*(dispatch_object_t *)(a1 + 8));
    free(*(void **)(a1 + 48));
    free((void *)a1);
  }
}

_DWORD *si_create_scheduler(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  dispatch_block_t v3 = v2;
  int v5 = v4;
  uint64_t v7 = v6;
  unsigned int v9 = v8;
  uint64_t v11 = v10;
  int v12 = v1;
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = malloc_type_calloc(1uLL, 0xD8uLL, 0x10B00405734E74BuLL);
  v13[32] = v9;
  bzero(__str, 0x1000uLL);
  snprintf(__str, 0x1000uLL, "MQ: %s", v11);
  *((unsigned char *)v13 + 58) = v5;
  if (v12) {
    initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
  }
  else {
    initially_inactive = makeAttrFromPolicy(v7, v5, 0);
  }
  *((void *)v13 + 4) = dispatch_queue_create_with_target_V2(__str, initially_inactive, v12);
  if (!v3)
  {
    AttrFromPolicy = makeAttrFromPolicy(v7, v5, v9 > 1);
    *((void *)v13 + 19) = dispatch_queue_create_with_target_V2(v11, AttrFromPolicy, 0);
    *((void *)v13 + 10) = v7;
    if (v9 < 2) {
      goto LABEL_10;
    }
    goto LABEL_8;
  }
  if (v9 >= 2)
  {
    uint64_t v15 = dispatch_queue_attr_make_initially_inactive(MEMORY[0x1E4F14430]);
    *((void *)v13 + 19) = dispatch_queue_create_with_target_V2(v11, v15, v3);
    *((void *)v13 + 10) = v7;
LABEL_8:
    dispatch_queue_set_width();
    goto LABEL_10;
  }
  stat v17 = dispatch_queue_attr_make_initially_inactive(0);
  *((void *)v13 + 19) = dispatch_queue_create_with_target_V2(v11, v17, v3);
  *((void *)v13 + 10) = v7;
LABEL_10:
  *((void *)v13 + 9) = strdup(v11);
  atomic_store(1u, v13 + 22);
  v13[53] = si_pc_priority_from_string(v11);
  int v18 = *__error();
  int v19 = _SILogForLogForCategory(3);
  os_log_type_t v20 = 2 * (dword_1E9FC90B0 < 4);
  if (os_log_type_enabled(v19, v20))
  {
    uint64_t v21 = *((void *)v13 + 4);
    uint64_t v22 = *((void *)v13 + 19);
    *(_DWORD *)iovec buf = 67109890;
    int v25 = v7;
    __int16 v26 = 1024;
    unsigned int v27 = (v7 >> 8) & 0xF;
    __int16 v28 = 2112;
    uint64_t v29 = v21;
    __int16 v30 = 2112;
    uint64_t v31 = v22;
    _os_log_impl(&dword_1BD672000, v19, v20, "Scheduler qos: 0x%x relative_priority: %d %@ %@", buf, 0x22u);
  }
  *__error() = v18;
  return v13;
}

void __si_create_child_scheduler_block_invoke(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = atomic_load((unsigned int *)(*(void *)(a1 + 32) + 92));
  atomic_fetch_add((atomic_uint *volatile)(*(void *)(a1 + 32) + 92), 1u);
  **(void **)(a1 + 40) = *(void *)(a1 + 32);
  dispatch_activate(*(dispatch_object_t *)(*(void *)(a1 + 40) + 152));
  unsigned int v3 = v2 + 1;
  unsigned int v4 = atomic_load((unsigned int *)(*(void *)(a1 + 32) + 92));
  if (v2 + 1 != v4)
  {
    int v5 = *__error();
    uint64_t v6 = _SILogForLogForCategory(3);
    os_log_type_t v7 = 2 * (dword_1E9FC90B0 < 4);
    if (os_log_type_enabled(v6, v7))
    {
      unsigned int v8 = atomic_load((unsigned int *)(*(void *)(a1 + 32) + 92));
      v9[0] = 67109376;
      v9[1] = v3;
      __int16 v10 = 1024;
      unsigned int v11 = v8;
      _os_log_impl(&dword_1BD672000, v6, v7, "%d != %d\n", (uint8_t *)v9, 0xEu);
    }
    *__error() = v5;
  }
}

dispatch_queue_attr_t makeAttrFromPolicy(unsigned int a1, int a2, int a3)
{
  if (a3) {
    int v5 = MEMORY[0x1E4F14430];
  }
  else {
    int v5 = 0;
  }
  dispatch_queue_attr_t result = dispatch_queue_attr_make_initially_inactive(v5);
  if (a2 && (_BYTE)a1)
  {
    os_log_type_t v7 = dispatch_queue_attr_make_with_overcommit();
    return dispatch_queue_attr_make_with_qos_class(v7, (dispatch_qos_class_t)a1, -((a1 >> 8) & 0xF));
  }
  return result;
}

uint64_t si_pc_priority_from_string(char *a1)
{
  if (strstr(a1, "Priority/")) {
    return 7;
  }
  if (strstr(a1, "NSFileProtectionComplete/")) {
    return 2;
  }
  if (strstr(a1, "NSFileProtectionCompleteUnlessOpen/")) {
    return 4;
  }
  if (strstr(a1, "NSFileProtectionCompleteWhenUserInactive/")) {
    return 14;
  }
  if (strstr(a1, "NSFileProtectionCompleteUntilFirstUserAuthentication/")) {
    return 6;
  }
  return 4294967294;
}

void *si_create_child_queue(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  char v3 = v2;
  uint64_t v4 = v1;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x1000uLL);
  int v5 = malloc_type_malloc(0x50uLL, 0x103004026821411uLL);
  *(_OWORD *)int v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  *((_DWORD *)v5 + 10) = -1;
  *((void *)v5 + 3) = *(void *)(v4 + 80);
  *((unsigned char *)v5 + 32) = *(unsigned char *)(v4 + 58);
  *((unsigned char *)v5 + 33) = (v3 & 0x10) != 0;
  snprintf(__str, 0x1000uLL, "com.apple.metadata.spotlightindex.mq.%s", *(const char **)(v4 + 72));
  *((void *)v5 + 1) = dispatch_queue_create_with_target_V2(__str, 0, *(dispatch_queue_t *)(v4 + 32));
  if (*(_DWORD *)(v4 + 128) < 2u) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = MEMORY[0x1E4F14430];
  }
  initially_inactive = dispatch_queue_attr_make_initially_inactive(v6);
  snprintf(__str, 0x1000uLL, "com.apple.metadata.spotlightindex.%s", *(const char **)(v4 + 72));
  *((void *)v5 + 2) = dispatch_queue_create_with_target_V2(__str, initially_inactive, *(dispatch_queue_t *)(v4 + 152));
  if (*(_DWORD *)(v4 + 128) >= 2u) {
    dispatch_queue_set_width();
  }
  int v8 = *__error();
  unsigned int v9 = _SILogForLogForCategory(3);
  os_log_type_t v10 = 2 * (dword_1E9FC90B0 < 4);
  if (os_log_type_enabled(v9, v10))
  {
    int v11 = *(_DWORD *)(v4 + 80);
    int v12 = (*(_DWORD *)(v4 + 80) >> 8) & 0xF;
    uint64_t v13 = *((void *)v5 + 1);
    uint64_t v14 = *((void *)v5 + 2);
    *(_DWORD *)iovec buf = 67109890;
    int v19 = v11;
    __int16 v20 = 1024;
    int v21 = v12;
    __int16 v22 = 2112;
    uint64_t v23 = v13;
    __int16 v24 = 2112;
    uint64_t v25 = v14;
    _os_log_impl(&dword_1BD672000, v9, v10, "Workqueue qos: 0x%x relative_priority: %d %@ %@", buf, 0x22u);
  }
  *__error() = v8;
  if ((v3 & 2) != 0) {
    dispatch_suspend(*((dispatch_object_t *)v5 + 2));
  }
  uint64_t v15 = *(NSObject **)(v4 + 32);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __si_create_child_queue_block_invoke;
  block[3] = &__block_descriptor_tmp_19_1119;
  block[4] = v4;
  void block[5] = 2;
  block[6] = v5;
  dispatch_sync(v15, block);
  return v5;
}

void __si_create_child_queue_block_invoke(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = atomic_load((unsigned int *)(*(void *)(a1 + 32) + 92));
  atomic_fetch_add((atomic_uint *volatile)(*(void *)(a1 + 32) + 92), 1u);
  **(void **)(a1 + 48) = *(void *)(a1 + 32);
  dispatch_activate(*(dispatch_object_t *)(*(void *)(a1 + 48) + 16));
  unsigned int v3 = v2 + 1;
  unsigned int v4 = atomic_load((unsigned int *)(*(void *)(a1 + 32) + 92));
  if (v2 + 1 != v4)
  {
    int v5 = *__error();
    uint64_t v6 = _SILogForLogForCategory(3);
    os_log_type_t v7 = 2 * (dword_1E9FC90B0 < 4);
    if (os_log_type_enabled(v6, v7))
    {
      unsigned int v8 = atomic_load((unsigned int *)(*(void *)(a1 + 32) + 92));
      v9[0] = 67109376;
      v9[1] = v3;
      __int16 v10 = 1024;
      unsigned int v11 = v8;
      _os_log_impl(&dword_1BD672000, v6, v7, "%d != %d\n", (uint8_t *)v9, 0xEu);
    }
    *__error() = v5;
  }
}

void *si_create_root_scheduler(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  int v5 = v4;
  uint64_t v7 = v6;
  unsigned int v9 = v8;
  __int16 v10 = (char *)v1;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (v8 < 2)
  {
    scheduler = malloc_type_calloc(1uLL, 0xD8uLL, 0x10B00405734E74BuLL);
    *((_DWORD *)scheduler + 32) = v9;
    bzero(__str, 0x1000uLL);
    snprintf(__str, 0x1000uLL, "MQ: %s", v10);
    *((unsigned char *)scheduler + 58) = v5;
    AttrFromPolicy = makeAttrFromPolicy(v7, v5, 0);
    *((void *)scheduler + 4) = dispatch_queue_create_with_target_V2(__str, AttrFromPolicy, 0);
    inactive = dispatch_workloop_create_inactive(v10);
    *((void *)scheduler + 19) = inactive;
    dispatch_workloop_set_autorelease_frequency(inactive, DISPATCH_AUTORELEASE_FREQUENCY_NEVER);
    *((void *)scheduler + 10) = v7;
    *((void *)scheduler + 9) = strdup(v10);
    atomic_store(1u, (unsigned int *)scheduler + 22);
    *((_DWORD *)scheduler + 53) = si_pc_priority_from_string(v10);
    int v14 = *__error();
    uint64_t v15 = _SILogForLogForCategory(3);
    os_log_type_t v16 = 2 * (dword_1E9FC90B0 < 4);
    if (os_log_type_enabled(v15, v16))
    {
      uint64_t v17 = *((void *)scheduler + 4);
      uint64_t v18 = *((void *)scheduler + 19);
      *(_DWORD *)iovec buf = 67109890;
      int v21 = v7;
      __int16 v22 = 1024;
      unsigned int v23 = (v7 >> 8) & 0xF;
      __int16 v24 = 2112;
      uint64_t v25 = v17;
      __int16 v26 = 2112;
      uint64_t v27 = v18;
      _os_log_impl(&dword_1BD672000, v15, v16, "Scheduler qos: 0x%x relative_priority: %d %@ %@", buf, 0x22u);
    }
    *__error() = v14;
  }
  else
  {
    scheduler = si_create_scheduler(0);
  }
  *((_DWORD *)scheduler + 32) = v9;
  *((void *)scheduler + 10) = v7;
  *((void *)scheduler + 1) = malloc_type_calloc(1uLL, 0x40uLL, 0x1000040FA0F61DDuLL);
  *((void *)scheduler + 2) = malloc_type_calloc(1uLL, 0x30uLL, 0x1000040EED21634uLL);
  pthread_mutex_init(*((pthread_mutex_t **)scheduler + 1), 0);
  pthread_cond_init(*((pthread_cond_t **)scheduler + 2), 0);
  *((unsigned char *)scheduler + 57) = 1;
  dispatch_queue_set_specific(*((dispatch_queue_t *)scheduler + 19), "kSISchedulerQOSClass", (void *)v7, 0);
  *((void *)scheduler + 18) = v3;
  dispatch_activate(*((dispatch_object_t *)scheduler + 4));
  dispatch_activate(*((dispatch_object_t *)scheduler + 19));
  return scheduler;
}

uint64_t si_scheduler_wait_on_suspend_token(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  BOOL v2 = 1;
  if (*(void *)(a1 + 8))
  {
    atomic_fetch_add((atomic_uint *volatile)a1, 1u);
    uint64_t v3 = *(void *)(a1 + 8);
    pthread_mutex_lock(*(pthread_mutex_t **)(v3 + 8));
    while (!*(unsigned char *)(a1 + 4) && !*(unsigned char *)(a1 + 5))
      pthread_cond_wait(*(pthread_cond_t **)(v3 + 16), *(pthread_mutex_t **)(v3 + 8));
    BOOL v2 = *(unsigned char *)(a1 + 5) == 0;
    pthread_mutex_unlock(*(pthread_mutex_t **)(v3 + 8));
    release_token((void *)a1);
  }
  return v2;
}

void si_scheduler_async_suspend_and_enqueue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int **a5)
{
  *a5 = 0;
  if (a1 && !*(_DWORD *)(a1 + 96))
  {
    uint64_t v13 = 0;
    __int16 v10 = (unsigned int *)malloc_type_calloc(1uLL, 0x30uLL, 0x10A0040B618E767uLL);
    atomic_store(2u, v10);
    *((void *)v10 + 1) = a1;
    *((void *)v10 + 4) = a3;
    *((void *)v10 + 5) = a4;
    *((void *)v10 + 3) = a2;
    *a5 = v10;
    pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 8));
    int v11 = *(_DWORD *)(a1 + 108);
    if (v11)
    {
      *(_DWORD *)(a1 + 108) = v11 + 1;
      *((unsigned char *)v10 + 4) = 1;
      uint64_t v13 = v10;
    }
    else if (quick_suspend(a1, &v13))
    {
      *((void *)v10 + 2) = v13;
      *((unsigned char *)v10 + 4) = 1;
      uint64_t v13 = v10;
      pthread_cond_broadcast(*(pthread_cond_t **)(a1 + 16));
    }
    else
    {
      uint64_t v12 = *(void *)(a1 + 136);
      *((void *)v10 + 2) = v12;
      *(void *)(a1 + 136) = v10;
      if (!v12 && !*(_DWORD *)(a1 + 112)) {
        _scheduler_suspension_locked(a1);
      }
    }
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 8));
    si_scheduler_trigger_tokens(v13);
  }
}

BOOL quick_suspend(uint64_t a1, void *a2)
{
  int v4 = (os_unfair_lock_s *)(a1 + 120);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 120));
  int v5 = *(_DWORD *)(a1 + 104);
  if (v5)
  {
    os_unfair_lock_unlock(v4);
LABEL_3:
    uint64_t v6 = 0;
    goto LABEL_10;
  }
  *(void *)(a1 + 108) = (*(_DWORD *)(a1 + 112) + 1);
  uint64_t v7 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0;
  dispatch_suspend(*(dispatch_object_t *)(a1 + 152));
  os_unfair_lock_unlock(v4);
  if (!v7) {
    goto LABEL_3;
  }
  uint64_t v6 = 0;
  do
  {
    *(unsigned char *)(v7 + 4) = 1;
    ++*(_DWORD *)(a1 + 108);
    uint64_t v8 = *(void *)(v7 + 16);
    if (*(void *)(v7 + 32))
    {
      *(void *)(v7 + 16) = v6;
      uint64_t v6 = v7;
    }
    else
    {
      release_token((void *)v7);
    }
    uint64_t v7 = v8;
  }
  while (v8);
LABEL_10:
  BOOL result = v5 == 0;
  *a2 = v6;
  return result;
}

uint64_t __si_scheduler_voluntary_check_for_suspend_inline_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 40);
  if (*(_DWORD *)(v1 + 104) == 1)
  {
    *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(v1 + 48);
    *(void *)(*(void *)(result + 40) + 48) = 0;
  }
  return result;
}

uint64_t __si_scheduler_set_stopped_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 56) = 1;
  return result;
}

void si_scheduler_stop(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = (atomic_uint *)(a1 + 88);
    atomic_fetch_add((atomic_uint *volatile)(a1 + 88), 1u);
    *(unsigned char *)(a1 + 56) = 1;
    int v4 = *(NSObject **)(a1 + 32);
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    v5[2] = __si_scheduler_stop_block_invoke;
    void v5[3] = &__block_descriptor_tmp_28_1144;
    v5[4] = a1;
    v5[5] = a2;
    dispatch_sync(v4, v5);
    if (atomic_fetch_add(v3, 0xFFFFFFFF) == 1) {
      _si_scheduler_destroy(a1);
    }
  }
}

pthread_mutex_t *__si_scheduler_stop_block_invoke(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  *(unsigned char *)(v2 + 56) = 1;
  BOOL result = *(pthread_mutex_t **)(v2 + 8);
  if (result)
  {
    pthread_mutex_lock(result);
    uint64_t v4 = *(void *)(a1 + 32);
    if (*(_DWORD *)(v4 + 108) && !*(unsigned char *)(v4 + 59))
    {
      *(unsigned char *)(v4 + 59) = 1;
      *(_DWORD *)(v4 + 108) = 0x7FFFFFFF;
      *(void *)(v4 + 184) = 0;
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v6 = *(pthread_override_s **)(v5 + 200);
      if (v6)
      {
        pthread_override_qos_class_end_np(v6);
        uint64_t v5 = *(void *)(a1 + 32);
      }
      *(void *)(v5 + 200) = 0;
      uint64_t v7 = *(void *)(a1 + 32);
      *(_DWORD *)(v7 + 208) = 0;
      dispatch_resume(*(dispatch_object_t *)(v7 + 152));
      pthread_cond_broadcast(*(pthread_cond_t **)(*(void *)(a1 + 32) + 16));
      uint64_t v4 = *(void *)(a1 + 32);
    }
    if (*(_DWORD *)(v4 + 116) && !*(unsigned char *)(v4 + 59))
    {
      *(unsigned char *)(v4 + 59) = 1;
      *(_DWORD *)(v4 + 108) = 0x7FFFFFFF;
      *(void *)(v4 + 184) = 0;
      uint64_t v8 = *(void *)(a1 + 32);
      unsigned int v9 = *(pthread_override_s **)(v8 + 200);
      if (v9)
      {
        pthread_override_qos_class_end_np(v9);
        uint64_t v8 = *(void *)(a1 + 32);
      }
      *(void *)(v8 + 200) = 0;
      uint64_t v10 = *(void *)(a1 + 32);
      *(_DWORD *)(v10 + 208) = 0;
      pthread_cond_broadcast(*(pthread_cond_t **)(v10 + 16));
      uint64_t v4 = *(void *)(a1 + 32);
    }
    BOOL result = (pthread_mutex_t *)pthread_mutex_unlock(*(pthread_mutex_t **)(v4 + 8));
    uint64_t v2 = *(void *)(a1 + 32);
  }
  else if (!*(unsigned char *)(v2 + 59) && *(_DWORD *)(v2 + 108))
  {
    int v14 = __si_assert_copy_extra_625(-1);
    uint64_t v15 = v14;
    os_log_type_t v16 = "";
    if (v14) {
      os_log_type_t v16 = v14;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIScheduler.c", 1771, "scheduler->force_resumed == 1 || scheduler->suspended==0", v16);
    free(v15);
    if (__valid_fs(-1)) {
      uint64_t v17 = 2989;
    }
    else {
      uint64_t v17 = 3072;
    }
    *(_DWORD *)uint64_t v17 = -559038737;
    abort();
  }
  if (*(_DWORD *)(v2 + 104))
  {
    int v11 = *__error();
    uint64_t v12 = _SILogForLogForCategory(3);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 72);
      *(_DWORD *)iovec buf = 136315138;
      uint64_t v21 = v13;
      _os_log_impl(&dword_1BD672000, v12, OS_LOG_TYPE_DEFAULT, "Issue stop for %s\n", buf, 0xCu);
    }
    *__error() = v11;
    dispatch_group_enter(*(dispatch_group_t *)(a1 + 40));
    dispatch_retain(*(dispatch_object_t *)(a1 + 40));
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 0x40000000;
    aBlock[2] = __si_scheduler_stop_block_invoke_26;
    aBlock[3] = &__block_descriptor_tmp_27;
    long long v19 = *(_OWORD *)(a1 + 32);
    BOOL result = (pthread_mutex_t *)_Block_copy(aBlock);
    *(void *)(*(void *)(a1 + 32) + 40) = result;
  }
  return result;
}

int *__si_scheduler_stop_block_invoke_26(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(*(void *)(a1 + 32) + 96) = 1;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
  int v2 = *__error();
  uint64_t v3 = _SILogForLogForCategory(3);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 72);
    int v6 = 136315138;
    uint64_t v7 = v4;
    _os_log_impl(&dword_1BD672000, v3, OS_LOG_TYPE_DEFAULT, "Stopped %s\n", (uint8_t *)&v6, 0xCu);
  }
  BOOL result = __error();
  *BOOL result = v2;
  return result;
}

void si_scheduler_boost_and_forget(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (dword_1E9FC90B0 >= 5)
    {
      int v3 = *__error();
      uint64_t v4 = _SILogForLogForCategory(3);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = *(void *)(a1 + 152);
        int v6 = 138412290;
        uint64_t v7 = v5;
        _os_log_impl(&dword_1BD672000, v4, OS_LOG_TYPE_DEFAULT, "boosting %@", (uint8_t *)&v6, 0xCu);
      }
      *__error() = v3;
    }
    dispatch_block_t v2 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, QOS_CLASS_USER_INITIATED, 0, &__block_literal_global_32);
    dispatch_async(*(dispatch_queue_t *)(a1 + 152), v2);
    _Block_release(v2);
  }
}

uint64_t __si_scheduler_dump_block_invoke(uint64_t a1)
{
  return _si_scheduler_dump(*(uint64_t **)(a1 + 32), 0, *(__CFString **)(a1 + 40));
}

uint64_t _si_scheduler_dump(uint64_t *a1, int a2, __CFString *a3)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  size_t v6 = (a2 + 1);
  MEMORY[0x1F4188790](a1);
  bzero((char *)v12 - ((v6 + 15) & 0x1FFFFFFF0), v6);
  memset((char *)v12 - ((v6 + 15) & 0x1FFFFFFF0), 9, a2);
  *((unsigned char *)v12 + a2 - ((v6 + 15) & 0x1FFFFFFF0)) = 0;
  uint64_t v7 = "Yes";
  uint64_t v8 = a1;
  while (!*((_DWORD *)v8 + 27))
  {
    uint64_t v8 = (uint64_t *)*v8;
    if (!v8)
    {
      uint64_t v7 = "No";
      break;
    }
  }
  unsigned int v9 = "YES";
  if (*((unsigned char *)a1 + 56)) {
    uint64_t v10 = "YES";
  }
  else {
    uint64_t v10 = "NO";
  }
  if (!*((_DWORD *)a1 + 24)) {
    unsigned int v9 = "NO";
  }
  CFStringAppendFormat(a3, 0, @"%sScheduler %p %s dq:%p parent:%p; %d suspensions suspended:%s (stop waiting: %s stopped: %s)\n",
    (char *)v12 - ((v6 + 15) & 0x1FFFFFFF0),
    a1,
    a1[9],
    a1[19],
    *a1,
    *((unsigned int *)a1 + 27),
    v7,
    v10,
    v9);
  uint64_t result = *a1;
  if (*a1) {
    return _si_scheduler_dump(result, v6, a3);
  }
  return result;
}

uint64_t *si_workqueue_dump(uint64_t *result, __CFString *a2)
{
  if (result)
  {
    int v3 = (uint64_t **)result;
    uint64_t v4 = MEMORY[0x1F4188790](result);
    v6[0] = 0;
    CFStringAppendFormat(v5, 0, @"%sWork queue %p; dq: %p %ld items enqueued\n",
      v6,
      v4,
      *(void *)(v4 + 16),
      *(void *)(v4 + 64));
    uint64_t result = *v3;
    if (*v3) {
      return (uint64_t *)_si_scheduler_dump(result, 1, a2);
    }
  }
  return result;
}

void __si_push_queue_block_invoke(uint64_t a1)
{
}

uint64_t si_peek_queue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = 0;
  unsigned int v9 = &v8;
  uint64_t v10 = 0x2000000000;
  char v11 = 0;
  uint64_t v4 = *(NSObject **)(a1 + 8);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __si_peek_queue_block_invoke;
  block[3] = &unk_1E6343060;
  block[6] = a1;
  void block[7] = a4;
  block[4] = &v8;
  void block[5] = a2;
  block[8] = a3;
  dispatch_sync(v4, block);
  uint64_t v5 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v5;
}

CFDictionaryRef __si_peek_queue_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (dword_1E9FC90B4 >= 5)
  {
    int v5 = *__error();
    size_t v6 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 40);
      uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 72);
      int v9 = 134218240;
      uint64_t v10 = v7;
      __int16 v11 = 2048;
      uint64_t v12 = v8;
      _os_log_impl(&dword_1BD672000, v6, OS_LOG_TYPE_DEFAULT, "Peek for %p to %p", (uint8_t *)&v9, 0x16u);
    }
    *__error() = v5;
  }
  CFDictionaryRef result = *(const __CFDictionary **)(*(void *)(a1 + 48) + 72);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, *(const void **)(a1 + 40));
    if (result)
    {
      if (*(void *)(a1 + 56))
      {
        CFBagRef v3 = result;
        uint64_t v4 = 0;
        while (1)
        {
          CFDictionaryRef result = (const __CFDictionary *)CFBagContainsValue(v3, *(const void **)(*(void *)(a1 + 64) + 8 * v4));
          if (result) {
            break;
          }
          if ((unint64_t)++v4 >= *(void *)(a1 + 56)) {
            return result;
          }
        }
      }
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    }
  }
  return result;
}

uint64_t si_dequeue_wait_locked(uint64_t a1, float a2)
{
  int v2 = *(_DWORD *)(a1 + 120);
  if ((-v2 & *(_DWORD *)(a1 + 128)) != 0
    || (int v4 = v2 - 1, v5 = *(unsigned int *)(a1 + 124), (v5 & ~v4) != 0))
  {
    uint64_t v12 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v12, v13, v14, v15, v16, v17, v18, v19, (char)"SISimpleQueue.c");
    free(v12);
    if (__valid_fs(-1)) {
      uint64_t v20 = 2989;
    }
    else {
      uint64_t v20 = 3072;
    }
    *(_DWORD *)uint64_t v20 = -559038737;
    abort();
  }
  v31.tv_sec = 0;
  v31.tv_nsec = 0;
  uint64_t v6 = *(void *)(a1 + 136);
  uint64_t result = *(void *)(v6 + 8 * v5);
  if (!result)
  {
    unsigned int v9 = (a2 * 1000000000.0);
    v30.tv_sec = 0;
    *(void *)&v30.tv_usec = 0;
    gettimeofday(&v30, 0);
    uint64_t v10 = v9 % 0x3B9ACA00 + 1000 * v30.tv_usec;
    v31.tv_sec = v30.tv_sec + v9 / 0x3B9ACA00uLL;
    v31.tv_nsec = v10;
    if (v10 >= 1000000000)
    {
      v31.tv_sec = v30.tv_sec + v9 / 0x3B9ACA00uLL + 1;
      v31.tv_nsec = v10 - 1000000000;
    }
    while (1)
    {
      uint64_t v6 = *(void *)(a1 + 136);
      uint64_t v5 = *(unsigned int *)(a1 + 124);
      uint64_t result = *(void *)(v6 + 8 * v5);
      if (result) {
        break;
      }
      ++*(_DWORD *)(a1 + 132);
      int v11 = pthread_cond_timedwait((pthread_cond_t *)(a1 + 72), (pthread_mutex_t *)(a1 + 8), &v31);
      --*(_DWORD *)(a1 + 132);
      if (v11)
      {
        uint64_t v6 = *(void *)(a1 + 136);
        uint64_t v5 = *(unsigned int *)(a1 + 124);
        uint64_t result = *(void *)(v6 + 8 * v5);
        if (result) {
          break;
        }
        return result;
      }
    }
  }
  *(void *)(v6 + 8 * v5) = 0;
  int v8 = *(_DWORD *)(a1 + 120);
  *(_DWORD *)(a1 + 124) = (v8 - 1) & (v5 + 1);
  if ((-v8 & *(_DWORD *)(a1 + 128)) != 0)
  {
    uint64_t v21 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v21, v22, v23, v24, v25, v26, v27, v28, (char)"SISimpleQueue.c");
    free(v21);
    if (__valid_fs(-1)) {
      uint64_t v29 = 2989;
    }
    else {
      uint64_t v29 = 3072;
    }
    *(_DWORD *)uint64_t v29 = -559038737;
    abort();
  }
  return result;
}

uint64_t getkQPQUOutputTokenArgIdsKey()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenArgIdsKey");
    getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  CFBagRef v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenArgIdsKey()"), @"PRQueryLLMProcessor.mm", 26, @"%s", dlerror());
  __break(1u);
  return result;
}

{
  uint64_t v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenArgIdsKey");
    getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  CFBagRef v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenArgIdsKey()"), @"PRQueryLLMPhotosProcessor.mm", 31, @"%s", dlerror());
  __break(1u);
  return result;
}

{
  uint64_t v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenArgIdsKey");
    getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  CFBagRef v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenArgIdsKey()"), @"PRQueryPhotosProcessor.mm", 25, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD829B30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL37getkQPQUOutputTokenArgIdsKeySymbolLocv_block_invoke_1229(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenArgIdsKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *QueryParserLibrary()
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
  {
    v4[1] = (void *)MEMORY[0x1E4F143A8];
    v4[2] = (void *)3221225472;
    void v4[3] = ___ZL22QueryParserLibraryCorePPc_block_invoke_1238;
    void v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E6343248;
    uint64_t v6 = 0;
    QueryParserLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  uint64_t v0 = (void *)QueryParserLibraryCore(char **)::frameworkLibrary;
  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
  {
    uint64_t v0 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"void *QueryParserLibrary()"];
    uint64_t v1 = objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v3, @"PRQueryLLMProcessor.mm", 22, @"%s", v4[0]);
    __break(1u);
    goto LABEL_7;
  }
  uint64_t v1 = v4[0];
  if (v4[0]) {
LABEL_7:
  }
    free(v1);
  return v0;
}

{
  void *v0;
  void *v1;
  uint64_t v3;
  void *v4[6];
  long long v5;
  uint64_t v6;
  uint64_t v7;

  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
  {
    v4[1] = (void *)MEMORY[0x1E4F143A8];
    v4[2] = (void *)3221225472;
    void v4[3] = ___ZL22QueryParserLibraryCorePPc_block_invoke_6117;
    void v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E6344968;
    uint64_t v6 = 0;
    QueryParserLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  uint64_t v0 = (void *)QueryParserLibraryCore(char **)::frameworkLibrary;
  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
  {
    uint64_t v0 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"void *QueryParserLibrary()"];
    uint64_t v1 = objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v3, @"PRQueryLLMPhotosProcessor.mm", 25, @"%s", v4[0]);
    __break(1u);
    goto LABEL_7;
  }
  uint64_t v1 = v4[0];
  if (v4[0]) {
LABEL_7:
  }
    free(v1);
  return v0;
}

{
  void *v0;
  void *v1;
  uint64_t v3;
  void *v4[6];
  long long v5;
  uint64_t v6;
  uint64_t v7;

  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
  {
    v4[1] = (void *)MEMORY[0x1E4F143A8];
    v4[2] = (void *)3221225472;
    void v4[3] = ___ZL22QueryParserLibraryCorePPc_block_invoke_9141;
    void v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E6346C58;
    uint64_t v6 = 0;
    QueryParserLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  uint64_t v0 = (void *)QueryParserLibraryCore(char **)::frameworkLibrary;
  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
  {
    uint64_t v0 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"void *QueryParserLibrary()"];
    uint64_t v1 = objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v3, @"PRLLMParse.mm", 13, @"%s", v4[0]);
    __break(1u);
    goto LABEL_7;
  }
  uint64_t v1 = v4[0];
  if (v4[0]) {
LABEL_7:
  }
    free(v1);
  return v0;
}

{
  void *v0;
  void *v1;
  uint64_t v3;
  void *v4[6];
  long long v5;
  uint64_t v6;
  uint64_t v7;

  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
  {
    v4[1] = (void *)MEMORY[0x1E4F143A8];
    v4[2] = (void *)3221225472;
    void v4[3] = ___ZL22QueryParserLibraryCorePPc_block_invoke_10212;
    void v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E6346F70;
    uint64_t v6 = 0;
    QueryParserLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  uint64_t v0 = (void *)QueryParserLibraryCore(char **)::frameworkLibrary;
  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
  {
    uint64_t v0 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"void *QueryParserLibrary()"];
    uint64_t v1 = objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v3, @"PRQUUtils.mm", 15, @"%s", v4[0]);
    __break(1u);
    goto LABEL_7;
  }
  uint64_t v1 = v4[0];
  if (v4[0]) {
LABEL_7:
  }
    free(v1);
  return v0;
}

{
  void *v0;
  void *v1;
  uint64_t v3;
  void *v4[6];
  long long v5;
  uint64_t v6;
  uint64_t v7;

  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
  {
    v4[1] = (void *)MEMORY[0x1E4F143A8];
    v4[2] = (void *)3221225472;
    void v4[3] = ___ZL22QueryParserLibraryCorePPc_block_invoke_13501;
    void v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E6348CB0;
    uint64_t v6 = 0;
    QueryParserLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  uint64_t v0 = (void *)QueryParserLibraryCore(char **)::frameworkLibrary;
  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
  {
    uint64_t v0 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"void *QueryParserLibrary()"];
    uint64_t v1 = objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v3, @"PRQueryPhotosProcessor.mm", 23, @"%s", v4[0]);
    __break(1u);
    goto LABEL_7;
  }
  uint64_t v1 = v4[0];
  if (v4[0]) {
LABEL_7:
  }
    free(v1);
  return v0;
}

uint64_t ___ZL22QueryParserLibraryCorePPc_block_invoke_1238()
{
  uint64_t result = _sl_dlopen();
  QueryParserLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

uint64_t getkQPQUOutputTokenKey()
{
  uint64_t v4 = 0;
  long long v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputTokenKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputTokenKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenKey");
    getkQPQUOutputTokenKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenKey()"), @"PRQueryLLMProcessor.mm", 24, @"%s", dlerror());
  __break(1u);
  return result;
}

{
  uint64_t v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  uint64_t v4 = 0;
  long long v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputTokenKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputTokenKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenKey");
    getkQPQUOutputTokenKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenKey()"), @"PRQueryLLMPhotosProcessor.mm", 29, @"%s", dlerror());
  __break(1u);
  return result;
}

{
  uint64_t v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  uint64_t v4 = 0;
  long long v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputTokenKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputTokenKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenKey");
    getkQPQUOutputTokenKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenKey()"), @"PRQueryPhotosProcessor.mm", 24, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD829E7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_WORD *llmQURankingTree(const __CFDictionary *a1, uint64_t a2)
{
  uint64_t v118 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef TokensInfoFromQueryUnderstanding = getTokensInfoFromQueryUnderstanding(a1);
  if (!TokensInfoFromQueryUnderstanding)
  {
    int v73 = *__error();
    unsigned int v74 = _SILogForLogForCategory(18);
    if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v75 = *(void *)a2;
      uint64_t v76 = *(void *)(a2 + 24);
      *(_DWORD *)iovec buf = 134218498;
      *(void *)&uint8_t buf[4] = v75;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v76;
      *(_WORD *)&buf[22] = 2112;
      v115 = 0;
      _os_log_impl(&dword_1BD672000, v74, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM] Got no LLM parse (using ALWAYS_FALSE_NODE) with LLMParse:'%@'", buf, 0x20u);
    }
    *__error() = v73;
    return makeFalseNode();
  }
  CFArrayRef v5 = TokensInfoFromQueryUnderstanding;
  LLMParseFromQueryUnderstanding = (NSAttributedString *)getLLMParseFromQueryUnderstanding(a1);
  RankingAttributeScores = (void *)getRankingAttributeScores(a2);
  uint64_t v108 = 0;
  uint64_t WildCardAllowedFields = 0;
  uint64_t v110 = 0;
  uint64_t v105 = 112;
  uint64_t v106 = 1065353216;
  std::string::basic_string[abi:nn180100]<0>(__p, "");
  v107 = __p;
  LODWORD(v108) = 1;
  BYTE4(v108) = 0;
  uint64_t WildCardAllowedFields = getWildCardAllowedFields(*(unsigned __int16 *)(a2 + 10));
  LODWORD(v110) = 0;
  *(_DWORD *)((char *)&v110 + 3) = 0;
  CFIndex Count = CFArrayGetCount(v5);
  CFIndex v8 = Count;
  CFIndex v85 = Count - 1;
  if (Count < 1) {
    goto LABEL_83;
  }
  uint64_t v84 = 0;
  CFIndex v9 = 0;
  CFArrayRef v83 = v5;
  CFIndex v91 = Count;
  do
  {
    uint64_t v89 = v9;
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v5, v9);
    int v11 = (const void *)getkQPQUOutputTokenKey();
    CFStringRef Value = (void *)CFDictionaryGetValue(ValueAtIndex, v11);
    uint64_t v13 = (const void *)getkQPQUOutputLemmaKey();
    uint64_t v14 = (void *)CFDictionaryGetValue(ValueAtIndex, v13);
    int v102 = -1;
    LLMTokenDescription = fetchLLMTokenDescription(&v102, ValueAtIndex, LLMParseFromQueryUnderstanding);
    int v15 = v102;
    if (isLLMTopKRankingArgId(v102))
    {
      int v16 = *__error();
      uint64_t v17 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = *(void *)a2;
        uint64_t v19 = *(void *)(a2 + 24);
        *(_DWORD *)iovec buf = 134218754;
        *(void *)&uint8_t buf[4] = v18;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v19;
        *(_WORD *)&buf[22] = 2048;
        v115 = (void *)v89;
        *(_WORD *)v116 = 1024;
        *(_DWORD *)&v116[2] = v15;
        _os_log_impl(&dword_1BD672000, v17, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Skipping tokenID %d (it is for TopK ranking only)", buf, 0x26u);
      }
      *__error() = v16;
      goto LABEL_73;
    }
    memset(&v101, 0, sizeof(v101));
    std::string::basic_string[abi:nn180100]<0>(&v101, (char *)[Value UTF8String]);
    if (isLLMOptionalArgId(v15))
    {
      HIDWORD(v106) = 0x800000;
      int v20 = *__error();
      uint64_t v21 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v22 = *(void *)a2;
        uint64_t v23 = *(void *)(a2 + 24);
        *(_DWORD *)iovec buf = 134219010;
        *(void *)&uint8_t buf[4] = v22;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v23;
        *(_WORD *)&buf[22] = 2048;
        v115 = (void *)v89;
        *(_WORD *)v116 = 2048;
        *(void *)&v116[2] = 0x3810000000000000;
        *(_WORD *)&v116[10] = 1024;
        int v117 = v15;
        _os_log_impl(&dword_1BD672000, v21, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] noMatchScore=%lf for tokenID %d (it is optional)", buf, 0x30u);
      }
LABEL_23:
      *__error() = v20;
      int v33 = 0x800000;
      goto LABEL_24;
    }
    if (isLLMInferredAppEntityTypeArgId(v15))
    {
      HIDWORD(v106) = 0x800000;
      int v20 = *__error();
      uint64_t v24 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = *(void *)a2;
        uint64_t v26 = *(void *)(a2 + 24);
        *(_DWORD *)iovec buf = 134219010;
        *(void *)&uint8_t buf[4] = v25;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v26;
        *(_WORD *)&buf[22] = 2048;
        v115 = (void *)v89;
        *(_WORD *)v116 = 2048;
        *(void *)&v116[2] = 0x3810000000000000;
        *(_WORD *)&v116[10] = 1024;
        int v117 = v15;
        _os_log_impl(&dword_1BD672000, v24, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] noMatchScore=%lf for tokenID %d (it is an inferred app entity type)", buf, 0x30u);
      }
      goto LABEL_23;
    }
    if (isIgnoredAppEntityStatusArgId(v15))
    {
      HIDWORD(v106) = 0x800000;
      int v20 = *__error();
      uint64_t v27 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v28 = *(void *)a2;
        uint64_t v29 = *(void *)(a2 + 24);
        *(_DWORD *)iovec buf = 134219010;
        *(void *)&uint8_t buf[4] = v28;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v29;
        *(_WORD *)&buf[22] = 2048;
        v115 = (void *)v89;
        *(_WORD *)v116 = 2048;
        *(void *)&v116[2] = 0x3810000000000000;
        *(_WORD *)&v116[10] = 1024;
        int v117 = v15;
        _os_log_impl(&dword_1BD672000, v27, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] noMatchScore=%lf for tokenID %d (it is an ignored app entity status)", buf, 0x30u);
      }
      goto LABEL_23;
    }
    if (isOptionalSearchTerm(v15, &v101, v5, v89))
    {
      HIDWORD(v106) = 0x800000;
      int v20 = *__error();
      timeval v30 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = *(void *)a2;
        uint64_t v32 = *(void *)(a2 + 24);
        *(_DWORD *)iovec buf = 134219010;
        *(void *)&uint8_t buf[4] = v31;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v32;
        *(_WORD *)&buf[22] = 2048;
        v115 = (void *)v89;
        *(_WORD *)v116 = 2048;
        *(void *)&v116[2] = 0x3810000000000000;
        *(_WORD *)&v116[10] = 1024;
        int v117 = v15;
        _os_log_impl(&dword_1BD672000, v30, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] noMatchScore=%lf for tokenID %d (matched trailing optional search token)", buf, 0x30u);
      }
      goto LABEL_23;
    }
    HIDWORD(v106) = 0;
    int v69 = *__error();
    v70 = _SILogForLogForCategory(18);
    if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v71 = *(void *)a2;
      uint64_t v72 = *(void *)(a2 + 24);
      *(_DWORD *)iovec buf = 134219010;
      *(void *)&uint8_t buf[4] = v71;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v72;
      *(_WORD *)&buf[22] = 2048;
      v115 = (void *)v89;
      *(_WORD *)v116 = 2048;
      *(void *)&v116[2] = 0;
      *(_WORD *)&v116[10] = 1024;
      int v117 = v15;
      _os_log_impl(&dword_1BD672000, v70, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] noMatchScore=%lf for tokenID %d", buf, 0x30u);
    }
    *__error() = v69;
    int v33 = 0;
LABEL_24:
    BYTE5(v110) = v89 == v85;
    if (v89 == v85) {
      std::string::append(&v101, "*");
    }
    if (v15 == 104)
    {
      int v34 = *__error();
      uint64_t v35 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = *(void *)a2;
        uint64_t v37 = *(void *)(a2 + 24);
        *(_DWORD *)iovec buf = 134218754;
        *(void *)&uint8_t buf[4] = v36;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v37;
        *(_WORD *)&buf[22] = 2048;
        v115 = (void *)v89;
        *(_WORD *)v116 = 1024;
        *(_DWORD *)&v116[2] = 104;
        _os_log_impl(&dword_1BD672000, v35, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] skip creating raw match token node for tokenID: %d", buf, 0x26u);
      }
      v87 = 0;
      *__error() = v34;
    }
    else
    {
      if ((v101.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        char v38 = &v101;
      }
      else {
        char v38 = (std::string *)v101.__r_.__value_.__r.__words[0];
      }
      NodeForToken = queryNodeForToken((char *)v38, RankingAttributeScores, (uint64_t)&v105, (unsigned char *)a2);
      if ([v14 length]) {
        uint64_t v40 = queryNodeForToken((char *)[v14 UTF8String], RankingAttributeScores, (uint64_t)&v105, (unsigned char *)a2);
      }
      else {
        uint64_t v40 = 0;
      }
      v87 = makeOrNode((uint64_t)NodeForToken, (uint64_t)v40);
    }
    if (((v15 != 104) & ~isLLMPersonArgId(v15)) == 0)
    {
      CFDictionaryRef GroundedNamesTokenFromTokenInfo = getGroundedNamesTokenFromTokenInfo(ValueAtIndex);
      HIDWORD(v106) = 0x800000;
      long long v97 = 0u;
      long long v98 = 0u;
      long long v99 = 0u;
      long long v100 = 0u;
      uint64_t v42 = [(__CFDictionary *)GroundedNamesTokenFromTokenInfo countByEnumeratingWithState:&v97 objects:v113 count:16];
      if (v42)
      {
        obuint64_t j = GroundedNamesTokenFromTokenInfo;
        unint64_t v43 = 0;
        uint64_t v92 = *(void *)v98;
        do
        {
          for (uint64_t i = 0; i != v42; ++i)
          {
            if (*(void *)v98 != v92) {
              objc_enumerationMutation(obj);
            }
            uint64_t v45 = *(void **)(*((void *)&v97 + 1) + 8 * i);
            long long v93 = 0u;
            long long v94 = 0u;
            long long v95 = 0u;
            long long v96 = 0u;
            std::string v46 = 0;
            uint64_t v47 = [v45 countByEnumeratingWithState:&v93 objects:v112 count:16];
            if (v47)
            {
              uint64_t v48 = *(void *)v94;
              do
              {
                for (uint64_t j = 0; j != v47; ++j)
                {
                  if (*(void *)v94 != v48) {
                    objc_enumerationMutation(v45);
                  }
                  uint64_t v50 = queryNodeForToken((char *)[*(id *)(*((void *)&v93 + 1) + 8 * j) UTF8String], RankingAttributeScores, (uint64_t)&v105, (unsigned char *)a2);
                  std::string v46 = makeAndNode((uint64_t)v46, (uint64_t)v50);
                }
                uint64_t v47 = [v45 countByEnumeratingWithState:&v93 objects:v112 count:16];
              }
              while (v47);
            }
            unint64_t v43 = makeOrNode((uint64_t)v43, (uint64_t)v46);
            CFIndex v8 = v91;
          }
          uint64_t v42 = [(__CFDictionary *)obj countByEnumeratingWithState:&v97 objects:v113 count:16];
        }
        while (v42);
        int v15 = v102;
      }
      else
      {
        unint64_t v43 = 0;
      }
      v87 = makeOrNode((uint64_t)v87, (uint64_t)v43);
      HIDWORD(v106) = v33;
      CFArrayRef v5 = v83;
    }
    if (v15 == 1)
    {
      int v51 = *__error();
      int v52 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v53 = *(void *)a2;
        uint64_t v54 = *(void *)(a2 + 24);
        *(_DWORD *)iovec buf = 134218754;
        *(void *)&uint8_t buf[4] = v53;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v54;
        *(_WORD *)&buf[22] = 2048;
        v115 = (void *)v89;
        *(_WORD *)v116 = 1024;
        *(_DWORD *)&v116[2] = 1;
        _os_log_impl(&dword_1BD672000, v52, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Not adding parsed query tree for tokenID %d because it's a search term and we add token matching manually", buf, 0x26u);
      }
LABEL_65:
      os_log_type_t v59 = __error();
      query_node_with_ann = 0;
      goto LABEL_66;
    }
    if (![LLMTokenDescription length])
    {
      int v51 = *__error();
      v60 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v61 = *(void *)a2;
        uint64_t v62 = *(void *)(a2 + 24);
        *(_DWORD *)iovec buf = 134218754;
        *(void *)&uint8_t buf[4] = v61;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v62;
        *(_WORD *)&buf[22] = 2048;
        v115 = (void *)v89;
        *(_WORD *)v116 = 1024;
        *(_DWORD *)&v116[2] = v15;
        _os_log_impl(&dword_1BD672000, v60, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Not adding parsed query tree for tokenID %d because tokenDescription is empty", buf, 0x26u);
      }
      goto LABEL_65;
    }
    query_node_with_ann = db_make_query_node_with_ann((char *)[LLMTokenDescription UTF8String], 0);
    *(void *)iovec buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&buf[16] = ___ZL16llmQURankingNodePKcffRKNSt3__113unordered_mapINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEfNS1_4hashIS8_EENS1_8equal_toIS8_EENS6_INS1_4pairIKS8_fEEEEEE_block_invoke;
    v115 = &__block_descriptor_48_e87__v16__0__query_node___query_node___query_node___query_piece_____v___v__v_SIb8b1b1b1Qf_8l;
    *(void *)v116 = RankingAttributeScores;
    *(_DWORD *)&v116[8] = 1065353216;
    int v117 = v33;
    v111[0] = MEMORY[0x1E4F143A8];
    v111[1] = 0x40000000;
    v111[2] = __db_query_tree_apply_block_block_invoke;
    v111[3] = &unk_1E6348598;
    v111[4] = buf;
    db_query_tree_apply_block_with_meta(query_node_with_ann, (uint64_t)v111, 0);
    int v51 = *__error();
    uint64_t v56 = _SILogForLogForCategory(18);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v57 = *(void *)a2;
      uint64_t v58 = *(void *)(a2 + 24);
      *(_DWORD *)iovec buf = 134219010;
      *(void *)&uint8_t buf[4] = v57;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v58;
      *(_WORD *)&buf[22] = 2048;
      v115 = (void *)v89;
      *(_WORD *)v116 = 1024;
      *(_DWORD *)&v116[2] = v15;
      *(_WORD *)&v116[6] = 1024;
      *(_DWORD *)&v116[8] = query_node_with_ann == 0;
      _os_log_impl(&dword_1BD672000, v56, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Adding parsed query tree for tokenID %d (invalid: %d)", buf, 0x2Cu);
    }
    os_log_type_t v59 = __error();
LABEL_66:
    *os_log_type_t v59 = v51;
    os_log_type_t v63 = makeOrNode((uint64_t)v87, (uint64_t)query_node_with_ann);
    if (v63)
    {
      uint64_t v84 = makeAndNode((uint64_t)v84, (uint64_t)v63);
    }
    else
    {
      int v64 = *__error();
      int v65 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v66 = *(void *)a2;
        uint64_t v67 = *(void *)(a2 + 24);
        *(_DWORD *)iovec buf = 134218754;
        *(void *)&uint8_t buf[4] = v66;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v67;
        *(_WORD *)&buf[22] = 2048;
        v115 = (void *)v89;
        *(_WORD *)v116 = 1024;
        *(_DWORD *)&v116[2] = v102;
        _os_log_impl(&dword_1BD672000, v65, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Got an empty ranking tree for tokenID %d", buf, 0x26u);
      }
      *__error() = v64;
    }
    uint64_t v68 = v89;
    if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v101.__r_.__value_.__l.__data_);
LABEL_73:
      uint64_t v68 = v89;
    }
    CFIndex v9 = v68 + 1;
  }
  while (v9 != v8);
  FalseNode = v84;
  if (!v84)
  {
LABEL_83:
    int v78 = *__error();
    uint64_t v79 = _SILogForLogForCategory(18);
    if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v80 = *(void *)a2;
      uint64_t v81 = *(void *)(a2 + 24);
      *(_DWORD *)iovec buf = 134218242;
      *(void *)&uint8_t buf[4] = v80;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v81;
      _os_log_impl(&dword_1BD672000, v79, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM] Got an empty ranking query tree (using ALWAYS_FALSE_NODE)", buf, 0x16u);
    }
    *__error() = v78;
    FalseNode = makeFalseNode();
  }
  if (v104 < 0) {
    operator delete(__p[0]);
  }
  return FalseNode;
}

void sub_1BD82AB80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  if (a48 < 0) {
    operator delete(__p);
  }
  if (a55 < 0) {
    operator delete(a50);
  }
  _Unwind_Resume(exception_object);
}

_WORD *fetchQUDenseNode(CFDictionaryRef theDict, uint64_t *a2)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  if (isTextSemanticSearchEnabled_onceToken != -1) {
    dispatch_once(&isTextSemanticSearchEnabled_onceToken, &__block_literal_global_5_9391);
  }
  if (!isTextSemanticSearchEnabled_ffStatus)
  {
    int v10 = *__error();
    int v11 = _SILogForLogForCategory(17);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_32;
    }
    uint64_t v12 = *a2;
    uint64_t v13 = a2[3];
    int v64 = 134218242;
    uint64_t v65 = v12;
    __int16 v66 = 2080;
    uint64_t v67 = v13;
    uint64_t v14 = "[qid=%lld][%s][POMMES][QU][LLM] Skipping ANN node (ERROR: Text semantic search FF is disabled)";
LABEL_31:
    _os_log_impl(&dword_1BD672000, v11, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v64, 0x16u);
    goto LABEL_32;
  }
  if (!theDict)
  {
    int v10 = *__error();
    int v11 = _SILogForLogForCategory(17);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_32;
    }
    uint64_t v15 = *a2;
    uint64_t v16 = a2[3];
    int v64 = 134218242;
    uint64_t v65 = v15;
    __int16 v66 = 2080;
    uint64_t v67 = v16;
    uint64_t v14 = "[qid=%lld][%s][POMMES][QU][LLM] Skipping ANN node (ERROR: missing query understanding dictionary)";
    goto LABEL_31;
  }
  if (!CFDictionaryContainsKey(theDict, @"kQPQueryTextEmbeddingEncodedData"))
  {
    int v10 = *__error();
    int v11 = _SILogForLogForCategory(17);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_32;
    }
    uint64_t v17 = *a2;
    uint64_t v18 = a2[3];
    int v64 = 134218242;
    uint64_t v65 = v17;
    __int16 v66 = 2080;
    uint64_t v67 = v18;
    uint64_t v14 = "[qid=%lld][%s][POMMES][QU][LLM] Skipping ANN node (ERROR: missing query embedding key)";
    goto LABEL_31;
  }
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(theDict, @"kQPQueryTextEmbeddingEncodedData");
  if (!Value)
  {
    int v10 = *__error();
    int v11 = _SILogForLogForCategory(17);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_32;
    }
    uint64_t v19 = *a2;
    uint64_t v20 = a2[3];
    int v64 = 134218242;
    uint64_t v65 = v19;
    __int16 v66 = 2080;
    uint64_t v67 = v20;
    uint64_t v14 = "[qid=%lld][%s][POMMES][QU][LLM] Skipping ANN node (ERROR: encoded query embedding in null)";
    goto LABEL_31;
  }
  CFDictionaryRef v5 = decodeEmbeddingData(Value);
  if (v5)
  {
    CFDictionaryRef v6 = v5;
    CFDictionaryRef v7 = (const __CFDictionary *)a2[4];
    if (v7 && (CFIndex v8 = (void *)CFDictionaryGetValue(v7, @"vec_version")) != 0) {
      int v9 = [v8 intValue];
    }
    else {
      int v9 = -1;
    }
    if (isCleanSlateEnabled((BOOL)a2)) {
      int v21 = 200;
    }
    else {
      int v21 = 100;
    }
    if (isCleanSlateEnabled((BOOL)a2)) {
      float v22 = 1.2;
    }
    else {
      float v22 = 0.94;
    }
    unint64_t v23 = [(__CFDictionary *)v6 length];
    if (v23 > 1)
    {
      unint64_t v35 = v23;
      uint64_t v36 = [(__CFDictionary *)v6 bytes];
      if (v36)
      {
        uint64_t v37 = v36;
        char v38 = (void *)MEMORY[0x1E4F14B00];
        if (*MEMORY[0x1E4F14B00] <= 0x12FuLL) {
          ++sTotal;
        }
        unint64_t v39 = v35 >> 1;
        uint64_t v40 = (float *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x130uLL, 0x31F9A007uLL);
        if (!v40) {
          _log_fault_for_malloc_failure();
        }
        *(void *)uint64_t v40 = strdup("_kMDItemPrimaryTextEmbedding");
        *((_DWORD *)v40 + 6) = 15;
        unsigned int v41 = v40[15] & 0xFFFFFFF0;
        int v42 = v41 | 7;
        int v43 = v41 | 4;
        int v44 = v41 | 5;
        int v45 = v41 | 6;
        if (v39 != 768) {
          int v45 = v42;
        }
        if (v39 == 512) {
          int v45 = v44;
        }
        if (v39 == 256) {
          int v45 = v43;
        }
        unsigned int v46 = v45 & 0xFF00000F | (16 * v21);
        v40[16] = v22;
        unsigned int v47 = v46 & 0xFE000ECF;
        int v48 = v46 & 0xECF | (v9 << 25);
        if (v9 == -1) {
          int v48 = v47;
        }
        *((_DWORD *)v40 + 15) = v48;
        *((_DWORD *)v40 + 10) = 5;
        *((_DWORD *)v40 + 40) |= 0x10000u;
        int v49 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v35 & 0xFFFFFFFFFFFFFFFELL, 0x6085D6BuLL);
        if (!v49) {
          _log_fault_for_malloc_failure();
        }
        uint64_t v50 = 0;
        *((void *)v40 + 37) = v49;
        if (v39 <= 1) {
          uint64_t v51 = 1;
        }
        else {
          uint64_t v51 = v35 >> 1;
        }
        do
        {
          *(_WORD *)(*((void *)v40 + 37) + 2 * v50) = *(_WORD *)(v37 + 2 * v50);
          ++v50;
        }
        while (v51 != v50);
        if (*v38 <= 0x4FuLL) {
          ++sTotal;
        }
        int v52 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x50uLL, 0x31F9A007uLL);
        if (v52)
        {
          int v33 = v52;
          v52[24] = 4;
          *((void *)v52 + 2) = v40;
          unint64_t v53 = [(__CFDictionary *)v6 length];
          int v54 = *__error();
          v55 = _SILogForLogForCategory(17);
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v56 = *a2;
            uint64_t v57 = a2[3];
            int v64 = 134219010;
            uint64_t v65 = v56;
            __int16 v66 = 2080;
            uint64_t v67 = v57;
            __int16 v68 = 2048;
            uint64_t v69 = v53 >> 1;
            __int16 v70 = 2048;
            double v71 = v22;
            __int16 v72 = 1024;
            int v73 = v21;
            _os_log_impl(&dword_1BD672000, v55, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM] Created ANN node (dim: %lu, thresh: %f, maxCount: %u)", (uint8_t *)&v64, 0x30u);
          }
          goto LABEL_65;
        }
        _log_fault_for_malloc_failure();
        MEMORY[0x30] = 4;
        MEMORY[0x10] = v40;
LABEL_62:
        int v54 = *__error();
        uint64_t v61 = _SILogForLogForCategory(17);
        if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v62 = *a2;
          uint64_t v63 = a2[3];
          int v64 = 134218242;
          uint64_t v65 = v62;
          __int16 v66 = 2080;
          uint64_t v67 = v63;
          _os_log_impl(&dword_1BD672000, v61, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM] Failed to create an ANN node", (uint8_t *)&v64, 0x16u);
        }
        int v33 = 0;
LABEL_65:
        *__error() = v54;
        CFRelease(v6);
        return v33;
      }
      int v24 = *__error();
      uint64_t v58 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v59 = *a2;
        uint64_t v60 = a2[3];
        int v64 = 134218242;
        uint64_t v65 = v59;
        __int16 v66 = 2080;
        uint64_t v67 = v60;
        uint64_t v28 = "[qid=%lld][%s][POMMES][QU][LLM] Skipping ANN node (ERROR: Failed to get bytes from embedding)";
        uint64_t v29 = v58;
        uint32_t v30 = 22;
        goto LABEL_60;
      }
    }
    else
    {
      int v24 = *__error();
      uint64_t v25 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v26 = *a2;
        uint64_t v27 = a2[3];
        int v64 = 134218498;
        uint64_t v65 = v26;
        __int16 v66 = 2080;
        uint64_t v67 = v27;
        __int16 v68 = 2048;
        uint64_t v69 = [(__CFDictionary *)v6 length];
        uint64_t v28 = "[qid=%lld][%s][POMMES][QU][LLM] Skipping ANN node (ERROR: embedding has 0 dimensionality) [length: %lu]";
        uint64_t v29 = v25;
        uint32_t v30 = 32;
LABEL_60:
        _os_log_impl(&dword_1BD672000, v29, OS_LOG_TYPE_DEFAULT, v28, (uint8_t *)&v64, v30);
      }
    }
    *__error() = v24;
    goto LABEL_62;
  }
  int v10 = *__error();
  int v11 = _SILogForLogForCategory(17);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v31 = *a2;
    uint64_t v32 = a2[3];
    int v64 = 134218242;
    uint64_t v65 = v31;
    __int16 v66 = 2080;
    uint64_t v67 = v32;
    uint64_t v14 = "[qid=%lld][%s][POMMES][QU][LLM] Skipping ANN node (ERROR: decoded query embedding in null)";
    goto LABEL_31;
  }
LABEL_32:
  int v33 = 0;
  *__error() = v10;
  return v33;
}

_WORD *llmQURetrievalTree(const __CFDictionary *a1, uint64_t *a2)
{
  uint64_t v131 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef TokensInfoFromQueryUnderstanding = getTokensInfoFromQueryUnderstanding(a1);
  if (TokensInfoFromQueryUnderstanding)
  {
    CFArrayRef v5 = TokensInfoFromQueryUnderstanding;
    v119 = a2;
    CFDictionaryRef theDict = a1;
    LLMParseFromQueryUnderstanding = (NSAttributedString *)getLLMParseFromQueryUnderstanding(a1);
    IndexAttributeScores = getIndexAttributeScores(1024);
    v114 = getIndexAttributeScores(2048);
    CFIndex Count = CFArrayGetCount(v5);
    if (Count < 1)
    {
LABEL_26:
      int v23 = *__error();
      int v24 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = *a2;
        uint64_t v26 = a2[3];
        *(_DWORD *)iovec buf = 134218242;
        *(void *)&uint8_t buf[4] = v25;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v26;
        _os_log_impl(&dword_1BD672000, v24, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM] Skipping adding sparse nodes to retrieval tree as all tokens are temporal nodes", buf, 0x16u);
      }
      int v117 = 0;
      *__error() = v23;
      uint64_t v27 = a2;
      goto LABEL_109;
    }
    CFIndex v7 = Count;
    CFIndex v8 = 0;
    uint64_t v121 = 0;
    char v116 = 1;
    char v9 = 1;
    char v118 = 1;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v5, v8);
      int v11 = (const void *)getkQPQUOutputTokenArgIdsKey();
      CFDataRef Value = (void *)CFDictionaryGetValue(ValueAtIndex, v11);
      uint64_t v13 = (const void *)getkQPQUOutputTokenKey();
      uint64_t v14 = (void *)CFDictionaryGetValue(ValueAtIndex, v13);
      if ([Value count]) {
        break;
      }
LABEL_22:
      if (v7 == ++v8)
      {
        if (v9) {
          goto LABEL_26;
        }
        int v117 = 0;
        CFIndex v35 = 0;
        *(_DWORD *)&v111[8] = 0;
        v112 = 0;
        *(void *)v111 = BYTE4(v121) & 1;
        *(void *)&long long v15 = 134219266;
        long long v110 = v15;
        while (2)
        {
          CFDictionaryRef v36 = (const __CFDictionary *)CFArrayGetValueAtIndex(v5, v35);
          uint64_t v37 = (const void *)getkQPQUOutputTokenKey();
          char v38 = (void *)CFDictionaryGetValue(v36, v37);
          unint64_t v39 = (const void *)getkQPQUOutputLemmaKey();
          uint64_t v40 = (void *)CFDictionaryGetValue(v36, v39);
          LODWORD(__p[0]) = -1;
          LLMTokenDescription = fetchLLMTokenDescription((int *)__p, v36, LLMParseFromQueryUnderstanding);
          int v42 = (int)__p[0];
          if (isLLMTopKRankingArgId((int)__p[0]))
          {
            int v43 = *__error();
            int v44 = _SILogForLogForCategory(17);
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v45 = *v119;
              uint64_t v46 = v119[3];
              *(_DWORD *)iovec buf = 134218754;
              *(void *)&uint8_t buf[4] = v45;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = v46;
              *(_WORD *)&buf[22] = 2048;
              v126 = (void *)v35;
              LOWORD(v127) = 1024;
              *(_DWORD *)((char *)&v127 + 2) = v42;
              _os_log_impl(&dword_1BD672000, v44, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Skipping tokenID %d (it is for TopK ranking only)", buf, 0x26u);
            }
            goto LABEL_51;
          }
          if (isLLMInferredAppEntityTypeArgId(v42))
          {
            int v43 = *__error();
            unsigned int v47 = _SILogForLogForCategory(17);
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v48 = *v119;
              uint64_t v49 = v119[3];
              *(_DWORD *)iovec buf = 134218754;
              *(void *)&uint8_t buf[4] = v48;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = v49;
              *(_WORD *)&buf[22] = 2048;
              v126 = (void *)v35;
              LOWORD(v127) = 1024;
              *(_DWORD *)((char *)&v127 + 2) = v42;
              _os_log_impl(&dword_1BD672000, v47, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Skipping tokenID %d (it is inferred app entity)", buf, 0x26u);
            }
            goto LABEL_51;
          }
          if (isIgnoredAppEntityStatusArgId(v42))
          {
            int v43 = *__error();
            uint64_t v50 = _SILogForLogForCategory(17);
            if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v51 = *v119;
              uint64_t v52 = v119[3];
              *(_DWORD *)iovec buf = 134218754;
              *(void *)&uint8_t buf[4] = v51;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = v52;
              *(_WORD *)&buf[22] = 2048;
              v126 = (void *)v35;
              LOWORD(v127) = 1024;
              *(_DWORD *)((char *)&v127 + 2) = v42;
              _os_log_impl(&dword_1BD672000, v50, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Skipping tokenID %d (it is ignored app entity status)", buf, 0x26u);
            }
            goto LABEL_51;
          }
          if (((v42 == 104) & v121) == 1)
          {
            int v43 = *__error();
            unint64_t v53 = _SILogForLogForCategory(17);
            if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v54 = *v119;
              uint64_t v55 = v119[3];
              *(_DWORD *)iovec buf = v110;
              *(void *)&uint8_t buf[4] = v54;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = v55;
              *(_WORD *)&buf[22] = 2048;
              v126 = (void *)v35;
              uint64_t v127 = 0x400000000680400;
              int v128 = BYTE4(v121) & 1;
              __int16 v129 = 1024;
              int v130 = 1;
              _os_log_impl(&dword_1BD672000, v53, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Skipping tokenID %d (it is person self and hasContact=%d, skipSelf=%d)", buf, 0x32u);
            }
            goto LABEL_51;
          }
          if (((v42 == 1) & BYTE4(v121)) == 1)
          {
            int v43 = *__error();
            uint64_t v56 = _SILogForLogForCategory(17);
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v57 = *v119;
              uint64_t v58 = v119[3];
              *(_DWORD *)iovec buf = 134218754;
              *(void *)&uint8_t buf[4] = v57;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = v58;
              *(_WORD *)&buf[22] = 2048;
              v126 = (void *)v35;
              LOWORD(v127) = 1024;
              *(_DWORD *)((char *)&v127 + 2) = 1;
              _os_log_impl(&dword_1BD672000, v56, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Skipping tokenID %d (it is a search term and hasContact=1)", buf, 0x26u);
            }
            goto LABEL_51;
          }
          if (v42 == 104)
          {
            uint64_t v59 = groundedNamesRetrievalNode(v36, (uint64_t)v114, (uint64_t)v119);
            v112 = makeOrNode((uint64_t)v112, (uint64_t)v59);
            goto LABEL_52;
          }
          std::string::basic_string[abi:nn180100]<0>(buf, (char *)[v38 UTF8String]);
          char v60 = isOptionalSearchTerm(v42, buf, v5, v35);
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          if (v116 & 1 | ((v60 & 1) == 0))
          {
            if (v118 & 1 | !isLLMOptionalArgId(v42))
            {
              {
                llmRetrievalFilterArgIds(void)::_retrievalFilterArgIds = 0u;
                unk_1E9FE35F8 = 0u;
                dword_1E9FE3608 = 1065353216;
              }
              if (llmRetrievalFilterArgIds(void)::onceToken != -1) {
                dispatch_once(&llmRetrievalFilterArgIds(void)::onceToken, &__block_literal_global_5);
              }
              if (std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmRetrievalFilterArgIds(void)::_retrievalFilterArgIds, v42))
              {
                int v61 = *__error();
                uint64_t v62 = _SILogForLogForCategory(17);
                BOOL v63 = os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT);
                int v42 = (int)__p[0];
                if (v63)
                {
                  uint64_t v64 = *v119;
                  uint64_t v65 = v119[3];
                  *(_DWORD *)iovec buf = 134218754;
                  *(void *)&uint8_t buf[4] = v64;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v65;
                  *(_WORD *)&buf[22] = 2048;
                  v126 = (void *)v35;
                  LOWORD(v127) = 1024;
                  *(_DWORD *)((char *)&v127 + 2) = __p[0];
                  _os_log_impl(&dword_1BD672000, v62, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Skip adding token match node for tokenID %d (this is app entity filter)", buf, 0x26u);
                }
                goto LABEL_72;
              }
              int v42 = (int)__p[0];
              if (isLLMTemporalArgId((int)__p[0]))
              {
                __int16 v72 = 0;
              }
              else
              {
                int v87 = *__error();
                v88 = _SILogForLogForCategory(17);
                if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v89 = *v119;
                  uint64_t v90 = v119[3];
                  *(_DWORD *)iovec buf = 134218754;
                  *(void *)&uint8_t buf[4] = v89;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v90;
                  *(_WORD *)&buf[22] = 2048;
                  v126 = (void *)v35;
                  LOWORD(v127) = 1024;
                  *(_DWORD *)((char *)&v127 + 2) = v42;
                  _os_log_impl(&dword_1BD672000, v88, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] adding token match node for tokenID %d", buf, 0x26u);
                }
                *__error() = v87;
                matched = defaultMatchQueryNodeForLLMRetrieval((char *)[v38 UTF8String], *((uint64_t **)IndexAttributeScores + 2), (uint64_t)v119);
                if ([v40 length]) {
                  uint64_t v92 = defaultMatchQueryNodeForLLMRetrieval((char *)[v40 UTF8String], *((uint64_t **)IndexAttributeScores + 2), (uint64_t)v119);
                }
                else {
                  uint64_t v92 = 0;
                }
                __int16 v72 = makeOrNode((uint64_t)matched, (uint64_t)v92);
                if (isLLMPersonArgId(v42))
                {
                  int v93 = *__error();
                  long long v94 = _SILogForLogForCategory(17);
                  if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v95 = *v119;
                    uint64_t v96 = v119[3];
                    *(_DWORD *)iovec buf = 134218754;
                    *(void *)&uint8_t buf[4] = v95;
                    *(_WORD *)&buf[12] = 2080;
                    *(void *)&buf[14] = v96;
                    *(_WORD *)&buf[22] = 2048;
                    v126 = (void *)v35;
                    LOWORD(v127) = 1024;
                    *(_DWORD *)((char *)&v127 + 2) = v42;
                    _os_log_impl(&dword_1BD672000, v94, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] adding grounded name match node for tokenID %d", buf, 0x26u);
                  }
                  *__error() = v93;
                  long long v97 = groundedNamesRetrievalNode(v36, (uint64_t)IndexAttributeScores, (uint64_t)v119);
                  __int16 v72 = makeOrNode((uint64_t)v72, (uint64_t)v97);
                }
              }
            }
            else
            {
              int v61 = *__error();
              uint64_t v69 = _SILogForLogForCategory(17);
              if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v70 = *v119;
                uint64_t v71 = v119[3];
                *(_DWORD *)iovec buf = 134218754;
                *(void *)&uint8_t buf[4] = v70;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = v71;
                *(_WORD *)&buf[22] = 2048;
                v126 = (void *)v35;
                LOWORD(v127) = 1024;
                *(_DWORD *)((char *)&v127 + 2) = v42;
                _os_log_impl(&dword_1BD672000, v69, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Skip adding token match node for tokenID %d (it is optional and if there is any non-optional arg Id in the query)", buf, 0x26u);
              }
LABEL_72:
              __int16 v72 = 0;
              *__error() = v61;
            }
            if (v42 == 1)
            {
              int v73 = *__error();
              uint64_t v74 = _SILogForLogForCategory(17);
              if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v75 = *v119;
                uint64_t v76 = v119[3];
                *(_DWORD *)iovec buf = 134218754;
                *(void *)&uint8_t buf[4] = v75;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = v76;
                *(_WORD *)&buf[22] = 2048;
                v126 = (void *)v35;
                LOWORD(v127) = 1024;
                *(_DWORD *)((char *)&v127 + 2) = 1;
                _os_log_impl(&dword_1BD672000, v74, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Not adding parsed query tree for tokenID %d because it's a search term and we add token matching manually", buf, 0x26u);
              }
              goto LABEL_88;
            }
            BOOL v77 = [LLMTokenDescription length] == 0;
            int v73 = *__error();
            int v78 = _SILogForLogForCategory(17);
            BOOL v79 = os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT);
            if (v77)
            {
              if (v79)
              {
                uint64_t v84 = *v119;
                uint64_t v85 = v119[3];
                *(_DWORD *)iovec buf = 134218754;
                *(void *)&uint8_t buf[4] = v84;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = v85;
                *(_WORD *)&buf[22] = 2048;
                v126 = (void *)v35;
                LOWORD(v127) = 1024;
                *(_DWORD *)((char *)&v127 + 2) = v42;
                _os_log_impl(&dword_1BD672000, v78, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Not adding parsed query tree for tokenID %d because tokenDescription is empty", buf, 0x26u);
              }
LABEL_88:
              RetrievalNodeFromQueryString = 0;
              *__error() = v73;
            }
            else
            {
              if (v79)
              {
                uint64_t v80 = *v119;
                uint64_t v81 = v119[3];
                *(_DWORD *)iovec buf = 134218754;
                *(void *)&uint8_t buf[4] = v80;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = v81;
                *(_WORD *)&buf[22] = 2048;
                v126 = (void *)v35;
                LOWORD(v127) = 1024;
                *(_DWORD *)((char *)&v127 + 2) = v42;
                _os_log_impl(&dword_1BD672000, v78, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Adding parsed query tree for tokenID %d", buf, 0x26u);
              }
              *__error() = v73;
              RetrievalNodeFromQueryString = makeRetrievalNodeFromQueryString((char *)[LLMTokenDescription UTF8String]);
              if (isLLMTemporalArgId(v42) || !(v118 & 1 | !isLLMOptionalArgId(v42)))
              {
                NonMatchRetrievalNodeFromQueryString = makeNonMatchRetrievalNodeFromQueryString((char *)objc_msgSend(LLMTokenDescription, "UTF8String", v110));
                if (RetrievalNodeFromQueryString) {
                  RetrievalNodeFromQueryString = makeOrNode((uint64_t)RetrievalNodeFromQueryString, (uint64_t)NonMatchRetrievalNodeFromQueryString);
                }
              }
            }
            v86 = makeOrNode((uint64_t)v72, (uint64_t)RetrievalNodeFromQueryString);
            if (isLLMAppEntityTypeArgId((int)__p[0])) {
              *(void *)&v111[4] = makeOrNode(*(uint64_t *)&v111[4], (uint64_t)v86);
            }
            else {
              int v117 = makeAndNode((uint64_t)v117, (uint64_t)v86);
            }
          }
          else
          {
            int v43 = *__error();
            __int16 v66 = _SILogForLogForCategory(17);
            if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v67 = *v119;
              uint64_t v68 = v119[3];
              *(_DWORD *)iovec buf = 134218754;
              *(void *)&uint8_t buf[4] = v67;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = v68;
              *(_WORD *)&buf[22] = 2048;
              v126 = (void *)v35;
              LOWORD(v127) = 1024;
              *(_DWORD *)((char *)&v127 + 2) = v42;
              _os_log_impl(&dword_1BD672000, v66, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%lu] Skipping tokenID %d (matched trailing optional search token)", buf, 0x26u);
            }
LABEL_51:
            *__error() = v43;
          }
LABEL_52:
          if (v7 == ++v35)
          {
            if (v112)
            {
              std::string::basic_string[abi:nn180100]<0>(__p, "com.apple.MobileAddressBook");
              uint64_t v27 = v119;
              uint64_t v98 = *(void *)&v111[4];
              *(void *)iovec buf = operator new(0x18uLL);
              *(void *)&buf[16] = *(void *)buf + 24;
              *(void *)&uint8_t buf[8] = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)__p, (long long *)buf, *(std::string **)buf);
              FieldMatchQueryNode = createFieldMatchQueryNode(buf);
              v122 = (void **)buf;
              std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v122);
              if (v124 < 0) {
                operator delete(__p[0]);
              }
              if (FieldMatchQueryNode)
              {
                long long v100 = makeAndNode((uint64_t)v112, (uint64_t)FieldMatchQueryNode);
                int v117 = makeAndNode((uint64_t)v117, (uint64_t)v100);
                if (*(void *)&v111[4]) {
                  goto LABEL_108;
                }
LABEL_109:
                if (!isCleanSlateEnabled((BOOL)v27))
                {
                  QUDenseNode = fetchQUDenseNode(theDict, v27);
                  if (QUDenseNode)
                  {
                    int v102 = *__error();
                    v103 = _SILogForLogForCategory(17);
                    if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v104 = *v119;
                      uint64_t v105 = v119[3];
                      *(_DWORD *)iovec buf = 134218242;
                      *(void *)&uint8_t buf[4] = v104;
                      *(_WORD *)&buf[12] = 2080;
                      *(void *)&buf[14] = v105;
                      _os_log_impl(&dword_1BD672000, v103, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM] Adding dense node to retrieval tree", buf, 0x16u);
                    }
                    *__error() = v102;
                    int v117 = makeOrNode((uint64_t)v117, (uint64_t)QUDenseNode);
                  }
                }
                if (!v117)
                {
                  int v28 = *__error();
                  uint64_t v106 = _SILogForLogForCategory(17);
                  if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v107 = *v119;
                    uint64_t v108 = v119[3];
                    *(_DWORD *)iovec buf = 134218242;
                    *(void *)&uint8_t buf[4] = v107;
                    *(_WORD *)&buf[12] = 2080;
                    *(void *)&buf[14] = v108;
                    uint64_t v32 = "[qid=%lld][%s][POMMES][QU][LLM] Got an empty retrieval query tree (using ALWAYS_FALSE_NODE)";
                    int v33 = v106;
                    uint32_t v34 = 22;
LABEL_117:
                    _os_log_impl(&dword_1BD672000, v33, OS_LOG_TYPE_DEFAULT, v32, buf, v34);
                  }
                  goto LABEL_118;
                }
                return v117;
              }
              *(void *)iovec buf = MEMORY[0x1E4F143A8];
              *(void *)&uint8_t buf[8] = 0x40000000;
              *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
              v126 = &unk_1E6348598;
              uint64_t v127 = (uint64_t)&__block_literal_global_161;
              db_query_tree_apply_block_with_meta(v112, (uint64_t)buf, 0);
              if (!*(void *)&v111[4]) {
                goto LABEL_109;
              }
            }
            else
            {
              uint64_t v27 = v119;
              uint64_t v98 = *(void *)&v111[4];
              if (!*(void *)&v111[4]) {
                goto LABEL_109;
              }
            }
LABEL_108:
            int v117 = makeAndNode((uint64_t)v117, v98);
            goto LABEL_109;
          }
          continue;
        }
      }
    }
    uint64_t v16 = (void *)[Value objectAtIndex:0];
    if (objc_msgSend(v16, "isEqual:", objc_msgSend(NSNumber, "numberWithInt:", 35)))
    {
      int v17 = 1;
    }
    else
    {
      int v18 = objc_msgSend(v16, "isEqual:", objc_msgSend(NSNumber, "numberWithInt:", 122));
      if (((v18 | v121) & 1) == 0)
      {
        LODWORD(v121) = (objc_msgSend(v16, "isEqual:", objc_msgSend(NSNumber, "numberWithInt:", 104)) & 1) == 0
                     && (objc_msgSend(v16, "isEqual:", objc_msgSend(NSNumber, "numberWithInt:", 1)) & 1) == 0
                     && !isLLMTopKRankingArgId([v16 intValue])
                     && !isLLMTemporalArgId([v16 intValue]);
LABEL_14:
        if (!isLLMTopKRankingArgId([v16 intValue])
          && !isLLMInferredAppEntityTypeArgId([v16 intValue]))
        {
          BOOL v19 = isLLMOptionalArgId([v16 intValue]);
          BOOL v20 = isLLMTemporalArgId([v16 intValue]);
          int v21 = [v16 intValue];
          std::string::basic_string[abi:nn180100]<0>(buf, (char *)[v14 UTF8String]);
          v118 &= v19;
          v9 &= v20;
          if (isOptionalSearchTerm(v21, buf, v5, v8))
          {
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }
          else
          {
            BOOL v22 = isLLMOptionalArgId([v16 intValue]);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
            v116 &= v22;
          }
        }
        goto LABEL_22;
      }
      int v17 = v18 | HIDWORD(v121);
    }
    HIDWORD(v121) = v17;
    goto LABEL_14;
  }
  int v28 = *__error();
  uint64_t v29 = _SILogForLogForCategory(17);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v30 = *a2;
    uint64_t v31 = a2[3];
    *(_DWORD *)iovec buf = 134218498;
    *(void *)&uint8_t buf[4] = v30;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v31;
    *(_WORD *)&buf[22] = 2112;
    v126 = 0;
    uint64_t v32 = "[qid=%lld][%s][POMMES][QU][LLM] Got no LLM parse (using ALWAYS_FALSE_NODE) with LLMParse:'%@'";
    int v33 = v29;
    uint32_t v34 = 32;
    goto LABEL_117;
  }
LABEL_118:
  *__error() = v28;
  return makeFalseNode();
}

void sub_1BD82C364(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (*(char *)(v33 - 137) < 0) {
    operator delete(*(void **)(v33 - 160));
  }
  _Unwind_Resume(exception_object);
}

uint64_t getkQPQUOutputLemmaKey(void)
{
  uint64_t v4 = 0;
  CFArrayRef v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputLemmaKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputLemmaKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputLemmaKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputLemmaKey");
    getkQPQUOutputLemmaKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputLemmaKey()"), @"PRQueryLLMProcessor.mm", 25, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD82C4D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *groundedNamesRetrievalNode(const __CFDictionary *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v35 = 0;
  CFDictionaryRef v36 = &v35;
  uint64_t v37 = 0x2020000000;
  uint64_t v6 = (const void **)getkQPQUOutputECRGroundNamesTokenKeySymbolLoc(void)::ptr;
  uint64_t v38 = getkQPQUOutputECRGroundNamesTokenKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputECRGroundNamesTokenKeySymbolLoc(void)::ptr)
  {
    uint64_t v30 = MEMORY[0x1E4F143A8];
    uint64_t v31 = 3221225472;
    uint64_t v32 = ___ZL45getkQPQUOutputECRGroundNamesTokenKeySymbolLocv_block_invoke;
    uint64_t v33 = &unk_1E6348C90;
    uint32_t v34 = &v35;
    ParserLibrary = QueryParserLibrary();
    void v36[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputECRGroundNamesTokenKey");
    getkQPQUOutputECRGroundNamesTokenKeySymbolLoc(void)::ptr = *(void *)(v34[1] + 24);
    uint64_t v6 = (const void **)v36[3];
  }
  _Block_object_dispose(&v35, 8);
  if (!v6)
  {
    int v18 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v18, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputECRGroundNamesTokenKey()"), @"PRQueryLLMProcessor.mm", 23, @"%s", dlerror());
    __break(1u);
  }
  obuint64_t j = (id)CFDictionaryGetValue(a1, *v6);
  if (![obj count]) {
    return 0;
  }
  id v8 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  uint64_t v21 = [obj countByEnumeratingWithState:&v26 objects:v40 count:16];
  if (v21)
  {
    char v9 = 0;
    uint64_t v20 = *(void *)v27;
    do
    {
      for (uint64_t i = 0; i != v21; ++i)
      {
        if (*(void *)v27 != v20) {
          objc_enumerationMutation(obj);
        }
        int v11 = *(void **)(*((void *)&v26 + 1) + 8 * i);
        long long v22 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        uint64_t v12 = [v11 countByEnumeratingWithState:&v22 objects:v39 count:16];
        if (v12)
        {
          uint64_t v13 = *(void *)v23;
          do
          {
            for (uint64_t j = 0; j != v12; ++j)
            {
              if (*(void *)v23 != v13) {
                objc_enumerationMutation(v11);
              }
              long long v15 = *(void **)(*((void *)&v22 + 1) + 8 * j);
              if (([v8 containsObject:v15] & 1) == 0)
              {
                matched = defaultMatchQueryNodeForLLMRetrieval((char *)[v15 UTF8String], *(uint64_t **)(a2 + 16), a3);
                char v9 = makeOrNode((uint64_t)v9, (uint64_t)matched);
                [v8 addObject:v15];
              }
            }
            uint64_t v12 = [v11 countByEnumeratingWithState:&v22 objects:v39 count:16];
          }
          while (v12);
        }
      }
      uint64_t v21 = [obj countByEnumeratingWithState:&v26 objects:v40 count:16];
    }
    while (v21);
  }
  else
  {
    char v9 = 0;
  }

  return v9;
}

void sub_1BD82C808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
}

void *defaultMatchQueryNodeForLLMRetrieval(char *__s, uint64_t *a2, uint64_t a3)
{
  if (!a2) {
    return 0;
  }
  uint64_t v4 = a2;
  uint64_t v6 = 0;
  do
  {
    uint64_t v7 = (const char *)(v4 + 2);
    if (*((char *)v4 + 39) < 0) {
      uint64_t v7 = *(const char **)v7;
    }
    QueryNode = createQueryNode(v7, __s, 112, 1, 0, *((float *)v4 + 10), *((float *)v4 + 10));
    if (*(unsigned char *)(a3 + 20) && !strcmp(v7, "kMDItemTextContent"))
    {
      char v9 = createQueryNode("_kMDItemBundleID", "com.apple.mobilesafari", 0, 5, 0, 0.0, 0.0);
      QueryNode = makeAndNode((uint64_t)QueryNode, (uint64_t)v9);
    }
    uint64_t v6 = makeOrNode((uint64_t)v6, (uint64_t)QueryNode);
    uint64_t v4 = (uint64_t *)*v4;
  }
  while (v4);
  return v6;
}

void *___ZL45getkQPQUOutputECRGroundNamesTokenKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputECRGroundNamesTokenKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputECRGroundNamesTokenKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL31getkQPQUOutputLemmaKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputLemmaKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputLemmaKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t ___ZL16llmQURankingNodePKcffRKNSt3__113unordered_mapINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEfNS1_4hashIS8_EENS1_8equal_toIS8_EENS6_INS1_4pairIKS8_fEEEEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(char ***)(a2 + 16);
    if (v3)
    {
      CFArrayRef v5 = *(void **)(a1 + 32);
      std::string::basic_string[abi:nn180100]<0>(v14, *v3);
      if (std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(v5, (uint64_t)v14))
      {
        uint64_t v6 = *(void **)(a1 + 32);
        std::string::basic_string[abi:nn180100]<0>(__p, **(char ***)(a2 + 16));
        uint64_t v7 = std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(v6, (uint64_t)__p);
        if (!v7) {
          abort();
        }
        float v8 = *((float *)v7 + 10);
        if (v13 < 0) {
          operator delete(__p[0]);
        }
        float v9 = v8 + v8;
      }
      else
      {
        float v9 = 1.0;
      }
      if (v15 < 0) {
        operator delete(v14[0]);
      }
      uint64_t v10 = *(void *)(a2 + 16);
      *(float *)(v10 + 52) = (float)(v9 * *(float *)(a1 + 40)) + (float)(v9 * *(float *)(a1 + 40));
      *(float *)(v10 + 56) = v9 * *(float *)(a1 + 44);
    }
  }
  return a2;
}

void sub_1BD82CAB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void *___ZL31getkQPQUOutputTokenKeySymbolLocv_block_invoke_1332(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t SIResultQueueGetEnqueuedSize(void *a1)
{
  pthread_mutex_lock((pthread_mutex_t *)(*a1 + 8));
  uint64_t v2 = a1[9];
  pthread_mutex_unlock((pthread_mutex_t *)(*a1 + 8));
  return v2;
}

uint64_t SIResultQueueRetain(uint64_t result)
{
  return result;
}

BOOL SIResultQueueNoWakeupTrigger(uint64_t a1)
{
  return *(void *)(a1 + 48) == 0;
}

uint64_t SIWaitResults(uint64_t *a1, float a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (pthread_mutex_t *)(*a1 + 8);
  pthread_mutex_lock(v4);
  si_dequeue_wait_locked(v3, a2);
  return pthread_mutex_unlock(v4);
}

double SIResultQueueGetLastPollTime(uint64_t a1)
{
  return *(double *)(a1 + 64);
}

void *SISetQueryCSFieldNameCallback(void *result)
{
  sSIQueryCSFieldNameCallback = result;
  return result;
}

uint64_t ___ZL17pommesRankingTreeP10query_nodeP9PRContext_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v186 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return v2;
  }
  uint64_t v3 = *(void *)(a2 + 16);
  if (*(_WORD *)(a2 + 48) != 4)
  {
    if (!v3) {
      return v2;
    }
    int v4 = *(_DWORD *)(v3 + 24);
LABEL_17:
    if (v4 != 15) {
      return v2;
    }
    goto LABEL_18;
  }
  if (!v3) {
    return v2;
  }
  int v4 = *(_DWORD *)(v3 + 24);
  HIDWORD(v6) = v4 - 1;
  LODWORD(v6) = v4 - 1;
  unsigned int v5 = v6 >> 1;
  BOOL v129 = v5 > 6;
  int v7 = (1 << v5) & 0x65;
  BOOL v8 = v129 || v7 == 0;
  if (v8) {
    goto LABEL_17;
  }
  if (v4 == 15)
  {
LABEL_18:
    __int16 v11 = 16;
LABEL_19:
    *(_WORD *)(a2 + 48) = v11;
    return v2;
  }
  if ((*(unsigned char *)(v3 + 36) & 2) != 0)
  {
    *(_DWORD *)(v3 + 52) = 0;
    __int16 v11 = 32;
    goto LABEL_19;
  }
  long long v176 = 0uLL;
  v177 = 0;
  if (isQueryNodeMatchingAnyField(a2) & 1) != 0 || (query_node_is_double_star(v2))
  {
    char v10 = 1;
  }
  else if (*(void *)v3)
  {
    std::string::basic_string[abi:nn180100]<0>(&v170, *(char **)v3);
    if (SHIBYTE(v177) < 0) {
      operator delete((void *)v176);
    }
    char v10 = 0;
    long long v176 = v170;
    v177 = v171;
  }
  else
  {
    char v10 = 0;
  }
  if (isPhotosAttribute((uint64_t)&v176))
  {
    *(_WORD *)(v2 + 48) = 16;
    goto LABEL_50;
  }
  uint64_t v13 = *(void *)(v2 + 16);
  uint64_t v14 = *(unsigned char **)(v13 + 72);
  if (v14) {
    size_t v15 = strlen(*(const char **)(v13 + 72));
  }
  else {
    size_t v15 = 0;
  }
  uint64_t v16 = HIBYTE(v177);
  if (SHIBYTE(v177) < 0) {
    uint64_t v16 = *((void *)&v176 + 1);
  }
  float v17 = 1.0;
  if (v16)
  {
    int v18 = std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(*(void **)(a1 + 40), (uint64_t)&v176);
    if (v18) {
      float v17 = *((float *)v18 + 10);
    }
  }
  *(float *)(v13 + 52) = v17;
  *(_DWORD *)(v13 + 56) = 0;
  if ((v10 & 1) == 0 && *(void *)v13 && !is_tokenizable_searchable_string_field(*(const char **)v13)) {
    goto LABEL_50;
  }
  if (!v15 || v15 == 1 && *v14 == 42) {
    goto LABEL_50;
  }
  unint64_t v164 = *(void *)(*(void *)(v2 + 16) + 32);
  CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v15);
  CFStringAppendCString(Mutable, *(const char **)(*(void *)(v2 + 16) + 72), 0x8000100u);
  if (!Mutable) {
    goto LABEL_50;
  }
  CFLocaleRef v21 = CFLocaleCopyCurrent();
  CFStringLowercase(Mutable, v21);
  if (v21) {
    CFRelease(v21);
  }
  QueryTokens = (CFTypeRef *)CreateQueryTokens(Mutable, (v164 >> 2) & 1);
  v157 = QueryTokens;
  CFArrayRef v23 = (const __CFArray *)*QueryTokens;
  if (!*QueryTokens || (Count = CFArrayGetCount((CFArrayRef)*QueryTokens), (CFIndex v25 = Count) == 0))
  {
    CFRelease(Mutable);
    goto LABEL_49;
  }
  uint64_t v26 = *(void *)(v2 + 16);
  int v158 = *(_DWORD *)(v26 + 24);
  if (v158 != 5)
  {
    unint64_t v159 = v164 & 0xFFFFFFFEFFFFFFFBLL;
    unint64_t v151 = v164 & 0xFFFFFFFEFFFFFFBBLL;
    CFArrayRef v161 = v23;
    if (Count <= 2)
    {
      v149 = 0;
      goto LABEL_89;
    }
    MEMORY[0x1F4188790](Count);
    long long v28 = (char *)&v146 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v28, v27);
    v187.location = 0;
    v187.length = v25;
    CFArrayGetValues(v23, v187, (const void **)v28);
    CFIndex v29 = 0;
    do
    {
      CFIndex Length = CFStringGetLength(*(CFStringRef *)&v28[8 * v29]);
      if (hasTrailingAsterisk(*(void *)&v28[8 * v29])) {
        uint64_t v31 = 3;
      }
      else {
        uint64_t v31 = 2;
      }
      ++v29;
    }
    while (v25 > v29 && Length >= v31);
    if (Length < v31)
    {
      v149 = 0;
LABEL_89:
      CFMutableStringRef v148 = Mutable;
      CFIndex v48 = v25;
      BOOL v129 = v25 <= 1;
      CFIndex v49 = v25 - 1;
      uint64_t v153 = v48;
      CFAllocatorRef v152 = v19;
      if (v129) {
        goto LABEL_142;
      }
      CFIndex v50 = 0;
      uint64_t v51 = 0;
      unint64_t v156 = (v164 & 0x40) >> 6;
      BOOL v52 = (v164 & 0x100000000) == 0;
      BOOL v8 = v48 == 2;
      uint64_t v53 = v48 == 2;
      uint64_t NodeForToken = v159 | (v53 << 30) | 0x20000000;
      if (!v8) {
        BOOL v52 = 0;
      }
      LODWORD(v162) = v52;
      uint64_t v160 = v151 | (v53 << 30) | 0x20000000;
      float v54 = flt_1BDA81D78[(v164 & 0x40) == 0];
      while (1)
      {
        values[0] = 0;
        values[1] = 0;
        v188.location = v50;
        v188.length = 2;
        CFArrayGetValues(v161, v188, (const void **)values);
        BOOL v55 = hasTrailingAsterisk((BOOL)values[1]);
        CFIndex v56 = CFStringGetLength((CFStringRef)values[0]);
        uint64_t v57 = hasTrailingAsterisk((BOOL)values[0]) ? 3 : 2;
        if (v56 >= v57)
        {
          CFIndex v58 = CFStringGetLength((CFStringRef)values[1]);
          uint64_t v59 = v55 ? 3 : 2;
          if (v58 >= v59) {
            break;
          }
        }
LABEL_140:
        if (v49 == ++v50)
        {
          v149 = makeAndNode((uint64_t)v149, (uint64_t)v51);
LABEL_142:
          uint64_t v76 = v153;
          CFArrayRef v77 = v161;
          if (v153 < 1)
          {
            uint64_t v160 = 0;
LABEL_259:
            calloc = makeAndNode((uint64_t)v149, v160);
            CFRelease(v148);
            freeQueryTokensContext(v157);
            if (!calloc)
            {
              calloc = query_calloc();
              calloc[24] = 32;
            }
            if (calloc != (_WORD *)v2)
            {
              db_free_query_node((void *)v2);
              uint64_t v2 = (uint64_t)calloc;
            }
            goto LABEL_50;
          }
          uint64_t v78 = 1;
          do
          {
            CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v77, v78 - 1);
            BOOL v80 = hasOnlyOptionalSpecialChar(ValueAtIndex);
            if (!v80) {
              break;
            }
            BOOL v129 = v78++ < v76;
          }
          while (v129);
          CFIndex v82 = 0;
          uint64_t v160 = 0;
          uint64_t v83 = v76 == 1;
          unint64_t v150 = (v164 & 0x40) >> 6;
          LODWORD(v156) = v80 | BYTE4(v164) & 1;
          float v84 = flt_1BDA81D80[(v164 & 0x40) == 0];
          unint64_t v155 = v159 | (v83 << 30);
          v154 = &v172;
          v151 |= v83 << 30;
          uint64_t v147 = v159 | 0x80000000;
          *(void *)&long long v81 = 134219010;
          long long v146 = v81;
          while (2)
          {
            uint64_t v169 = 1065353216;
            long long v168 = 0u;
            long long v167 = 0u;
            CFStringRef v85 = (const __CFString *)CFArrayGetValueAtIndex(v77, v82);
            CFStringRef v166 = v85;
            CFIndex v86 = CFStringGetLength(v85);
            if (!v86) {
              goto LABEL_247;
            }
            BOOL v87 = hasTrailingAsterisk((BOOL)v85);
            values[0] = 0;
            values[1] = 0;
            uint64_t v185 = 0;
            utf8QueryString((const __CFString **)values, (uint64_t)&v166, 1, 0);
            CFStringRef v162 = 0;
            if (v87)
            {
              if (--v86)
              {
                v189.location = 0;
                v189.length = v86;
                CFStringRef v85 = CFStringCreateWithSubstring(v152, v85, v189);
                CFStringRef v166 = v85;
                CFStringRef v162 = v85;
                break;
              }
LABEL_245:
              if (SHIBYTE(v185) < 0) {
                operator delete(values[0]);
              }
LABEL_247:
              std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v167);
              if (++v82 == v76) {
                goto LABEL_259;
              }
              continue;
            }
            break;
          }
          float v88 = 0.0;
          if ((v156 & 1) == 0)
          {
            BOOL v89 = hasOnlyOptionalSpecialChar(v85);
            float v88 = 1.1755e-38;
            if (!v89) {
              float v88 = 0.0;
            }
          }
          if (v87) {
            float v90 = 1.0;
          }
          else {
            float v90 = v84;
          }
          CFIndex v91 = v154;
          *(void *)v154 = 0;
          *((void *)v91 + 1) = 0;
          *((void *)v91 + 2) = 0;
          *(void *)&long long v170 = v155;
          *((void *)&v170 + 1) = __PAIR64__(LODWORD(v88), LODWORD(v90));
          v171 = &v176;
          int v172 = v158;
          uint64_t v92 = *(void **)(a1 + 40);
          uint64_t v174 = *(void *)(a1 + 48);
          BYTE5(v175) = v87;
          if (v185 >= 0) {
            int v93 = (char *)values;
          }
          else {
            int v93 = (char *)values[0];
          }
          uint64_t NodeForToken = (uint64_t)queryNodeForToken(v93, v92, (uint64_t)&v170, *(unsigned char **)(a1 + 32));
          if (NodeForToken) {
            std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v167, (uint64_t)values, (uint64_t)values);
          }
          if (v87)
          {
            if (SHIBYTE(v185) < 0)
            {
              uint64_t v95 = (void **)values[0];
              uint64_t v94 = (uint64_t)--values[1];
            }
            else
            {
              uint64_t v94 = HIBYTE(v185) - 1;
              HIBYTE(v185) = v94 & 0x7F;
              uint64_t v95 = values;
            }
            *((unsigned char *)v95 + v94) = 0;
          }
          uint64_t v96 = (void *)HIBYTE(v185);
          char v97 = HIBYTE(v185);
          if (v185 < 0) {
            uint64_t v96 = values[1];
          }
          if (!v96) {
            goto LABEL_183;
          }
          if (v87 && (v164 & 0x40) != 0)
          {
            DWORD2(v170) = 1067534254;
            if (v185 >= 0) {
              uint64_t v98 = (char *)values;
            }
            else {
              uint64_t v98 = (char *)values[0];
            }
            long long v99 = queryNodeForToken(v98, *(void **)(a1 + 40), (uint64_t)&v170, *(unsigned char **)(a1 + 32));
            char v97 = HIBYTE(v185);
            goto LABEL_178;
          }
          if ((v150 | v87))
          {
            long long v99 = 0;
LABEL_178:
            *(void *)&long long v170 = v151;
            DWORD2(v170) = 1068792545;
            BYTE6(v175) = 1;
            if (v97 >= 0) {
              long long v100 = (char *)values;
            }
            else {
              long long v100 = (char *)values[0];
            }
            std::string v101 = queryNodeForToken(v100, *(void **)(a1 + 40), (uint64_t)&v170, *(unsigned char **)(a1 + 32));
            int v102 = makeOrNode((uint64_t)v99, (uint64_t)v101);
            BYTE6(v175) = 0;
            if (v102)
            {
              uint64_t v103 = (uint64_t)v102;
              std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v167, (uint64_t)values, (uint64_t)values);
              uint64_t NodeForToken = (uint64_t)makeOrNode(NodeForToken, v103);
            }
          }
          else
          {
LABEL_183:
            BYTE6(v175) = 0;
          }
          if ((v164 & 0x100000000) == 0)
          {
            if (hasTrailingOptionalSpecialChar(v85))
            {
              CFIndex v104 = v86;
              while (1)
              {
                BOOL v129 = v104-- < 1;
                if (v129) {
                  break;
                }
                UniChar CharacterAtIndex = CFStringGetCharacterAtIndex(v85, v104);
                if (!isOptionalSpecialChar(CharacterAtIndex))
                {
                  v190.length = v104 + 1;
                  v190.location = 0;
                  CFStringRef v106 = CFStringCreateWithSubstring(v152, v85, v190);
                  v165 = (__CFString *)v106;
                  memset(buf, 0, sizeof(buf));
                  utf8QueryString((const __CFString **)buf, (uint64_t)&v165, 1, 0);
                  CFRelease(v106);
                  if (!std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>(v167, *((unint64_t *)&v167 + 1), (uint64_t)buf))
                  {
                    *(void *)&long long v170 = v147;
                    DWORD2(v170) = 1061997773;
                    uint64_t v107 = (buf[23] & 0x80u) == 0 ? (char *)buf : *(char **)buf;
                    uint64_t v108 = queryNodeForToken(v107, *(void **)(a1 + 40), (uint64_t)&v170, *(unsigned char **)(a1 + 32));
                    if (v108)
                    {
                      uint64_t v109 = (uint64_t)v108;
                      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v167, (uint64_t)buf, (uint64_t)buf);
                      uint64_t NodeForToken = (uint64_t)makeOrNode(NodeForToken, v109);
                    }
                  }
                  if ((char)buf[23] < 0) {
                    operator delete(*(void **)buf);
                  }
                  break;
                }
              }
            }
            if (*(unsigned char *)(*(void *)(a1 + 32) + 18))
            {
              if (CFStringGetLength(v85) >= 2)
              {
                CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetLetter);
                v191.length = CFStringGetLength(v85) - v87;
                v191.location = 0;
                if (!CFStringFindCharacterFromSet(v85, Predefined, v191, 0, 0))
                {
                  v165 = convertCommaSeparatedNumberTokenWithNumberFormatter(v85);
                  if (CFStringGetLength(v165) >= 1)
                  {
                    memset(buf, 0, sizeof(buf));
                    utf8QueryString((const __CFString **)buf, (uint64_t)&v165, 1, 0);
                    if (!std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>(v167, *((unint64_t *)&v167 + 1), (uint64_t)buf))
                    {
                      *(void *)&long long v170 = v147;
                      DWORD2(v170) = 1065353216;
                      v142 = (buf[23] & 0x80u) == 0 ? (char *)buf : *(char **)buf;
                      v143 = queryNodeForToken(v142, *(void **)(a1 + 40), (uint64_t)&v170, *(unsigned char **)(a1 + 32));
                      if (v143)
                      {
                        uint64_t v144 = (uint64_t)v143;
                        std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v167, (uint64_t)buf, (uint64_t)buf);
                        uint64_t NodeForToken = (uint64_t)makeOrNode(NodeForToken, v144);
                      }
                    }
                    if ((char)buf[23] < 0) {
                      operator delete(*(void **)buf);
                    }
                  }
                }
              }
            }
            CFDictionaryRef v111 = *(const __CFDictionary **)(*(void *)(a1 + 32) + 40);
            if (v111)
            {
              CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v111, v166);
              CFArrayRef v113 = Value;
              if (Value)
              {
                CFIndex v114 = CFArrayGetCount(Value);
                if (v114 >= 1)
                {
                  for (CFIndex i = 0; i != v114; ++i)
                  {
                    char v116 = (void *)CFArrayGetValueAtIndex(v113, i);
                    CFStringRef v117 = (const __CFString *)[v116 variation];
                    v165 = (__CFString *)v117;
                    if (CFStringGetLength(v117))
                    {
                      memset(buf, 0, sizeof(buf));
                      utf8QueryString((const __CFString **)buf, (uint64_t)&v165, 1, 0);
                      if (!std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>(v167, *((unint64_t *)&v167 + 1), (uint64_t)buf)|| [v116 type] == 1)
                      {
                        uint64_t v118 = objc_msgSend(v116, "type", (void)v146, *((void *)&v146 + 1));
                        [v116 confidence];
                        float v120 = v119;
                        BOOL v121 = (v164 & 0x40) == 0;
                        uint64_t v122 = v118 == 1 ? 2155872256 : 0x80000000;
                        BOOL v123 = hasTrailingAsterisk((BOOL)v117);
                        float v124 = v123 ? 1.0 : v84;
                        *(void *)&long long v170 = v122 | v159;
                        *((float *)&v170 + 2) = v120 * v124;
                        BYTE6(v175) = v121 & ~v123;
                        v125 = (buf[23] & 0x80u) == 0 ? (char *)buf : *(char **)buf;
                        v126 = queryNodeForToken(v125, *(void **)(a1 + 40), (uint64_t)&v170, *(unsigned char **)(a1 + 32));
                        if (v126)
                        {
                          uint64_t v127 = (uint64_t)v126;
                          std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v167, (uint64_t)buf, (uint64_t)buf);
                          uint64_t NodeForToken = (uint64_t)makeOrNode(NodeForToken, v127);
                        }
                      }
                      if ((char)buf[23] < 0) {
                        operator delete(*(void **)buf);
                      }
                    }
                  }
                }
              }
            }
            int v128 = *(unsigned char **)(a1 + 32);
            if (v128[21])
            {
              CFArrayRef v77 = v161;
              uint64_t v76 = v153;
              if (!v128[17])
              {
                BOOL v129 = v128[13] || v86 < 7;
                if (!v129)
                {
                  int v130 = v185 >= 0 ? (const char *)values : (const char *)values[0];
                  uint64_t v131 = PRPommesStemWordWithCString(v130, 100, 0);
                  if (v131)
                  {
                    v132 = v131;
                    if (v185 >= 0) {
                      v133 = (char *)HIBYTE(v185);
                    }
                    else {
                      v133 = (char *)values[1];
                    }
                    if (&v133[-strlen(v131)] == (char *)1)
                    {
                      int v134 = *__error();
                      v135 = _SILogForLogForCategory(18);
                      if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
                      {
                        v136 = *(uint64_t **)(a1 + 32);
                        uint64_t v137 = *v136;
                        uint64_t v138 = v136[3];
                        v139 = values;
                        if (v185 < 0) {
                          v139 = (void **)values[0];
                        }
                        *(_DWORD *)iovec buf = v146;
                        *(void *)&uint8_t buf[4] = v137;
                        *(_WORD *)&buf[12] = 2080;
                        *(void *)&buf[14] = v138;
                        *(_WORD *)&buf[22] = 2080;
                        v179 = v132;
                        __int16 v180 = 2080;
                        v181 = v139;
                        __int16 v182 = 1024;
                        int v183 = 0;
                        _os_log_impl(&dword_1BD672000, v135, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][rewrite] First Pass Stemming (Top Hits) added stemmedToken = [%s] to Query Tree for token = [%s] with wildcard_limit = %u", buf, 0x30u);
                      }
                      *__error() = v134;
                      *(void *)&long long v170 = v147;
                      v140 = *(unsigned char **)(a1 + 32);
                      DWORD2(v170) = 1065353216;
                      LODWORD(v175) = 0;
                      v141 = queryNodeForToken(v132, *(void **)(a1 + 64), (uint64_t)&v170, v140);
                      uint64_t NodeForToken = (uint64_t)makeOrNode(NodeForToken, (uint64_t)v141);
                    }
                    free(v132);
                  }
                }
              }
            }
            else
            {
              CFArrayRef v77 = v161;
              uint64_t v76 = v153;
            }
          }
          if (v162) {
            CFRelease(v162);
          }
          uint64_t v160 = (uint64_t)makeAndNode(v160, NodeForToken);
          goto LABEL_245;
        }
      }
      if (v55) {
        float v60 = 3.3;
      }
      else {
        float v60 = v54;
      }
      int v173 = 0;
      uint64_t v174 = 0;
      uint64_t v175 = 0;
      *(void *)&long long v170 = NodeForToken;
      *((void *)&v170 + 1) = LODWORD(v60) | 0x80000000000000;
      v171 = &v176;
      int v172 = v158;
      uint64_t v174 = *(void *)(a1 + 48);
      BYTE5(v175) = v55;
      memset(buf, 0, sizeof(buf));
      utf8QueryString((const __CFString **)buf, (uint64_t)values, 2, 0);
      if ((buf[23] & 0x80u) == 0) {
        int v61 = (char *)buf;
      }
      else {
        int v61 = *(char **)buf;
      }
      uint64_t v62 = queryNodeForToken(v61, *(void **)(a1 + 40), (uint64_t)&v170, *(unsigned char **)(a1 + 32));
      if (v162 && *(_WORD *)(*(void *)(a1 + 32) + 8) == 2)
      {
        uint64_t v63 = HIBYTE(v177);
        if (SHIBYTE(v177) < 0) {
          uint64_t v63 = *((void *)&v176 + 1);
        }
        if (!v63
          || std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(*(void **)(a1 + 56), (uint64_t)&v176))
        {
          *(int8x16_t *)values = vextq_s8(*(int8x16_t *)values, *(int8x16_t *)values, 8uLL);
          long long v167 = 0uLL;
          *(void *)&long long v168 = 0;
          utf8QueryString((const __CFString **)&v167, (uint64_t)values, 2, 1);
          uint64_t v64 = (SBYTE7(v168) & 0x80u) == 0 ? (char *)&v167 : (char *)v167;
          uint64_t v65 = queryNodeForToken(v64, *(void **)(a1 + 56), (uint64_t)&v170, *(unsigned char **)(a1 + 32));
          uint64_t v62 = makeOrNode((uint64_t)v62, (uint64_t)v65);
          if (SBYTE7(v168) < 0) {
            operator delete((void *)v167);
          }
        }
      }
      if (v55)
      {
        if ((char)buf[23] < 0)
        {
          uint64_t v67 = *(uint8_t **)buf;
          uint64_t v66 = --*(void *)&buf[8];
        }
        else
        {
          uint64_t v66 = buf[23] - 1;
          buf[23] = v66 & 0x7F;
          uint64_t v67 = buf;
        }
        v67[v66] = 0;
      }
      uint64_t v68 = buf[23];
      signed __int8 v69 = buf[23];
      if ((buf[23] & 0x80u) != 0) {
        uint64_t v68 = *(void *)&buf[8];
      }
      if (!v68)
      {
        __int16 v72 = 0;
        goto LABEL_138;
      }
      if (v55 && (v164 & 0x40) != 0)
      {
        DWORD2(v170) = 1082461782;
        if ((buf[23] & 0x80u) == 0) {
          uint64_t v70 = (char *)buf;
        }
        else {
          uint64_t v70 = *(char **)buf;
        }
        uint64_t v71 = queryNodeForToken(v70, *(void **)(a1 + 40), (uint64_t)&v170, *(unsigned char **)(a1 + 32));
        signed __int8 v69 = buf[23];
      }
      else
      {
        uint64_t v71 = 0;
        __int16 v72 = 0;
        if (((v156 | v55) & 1) == 0) {
          goto LABEL_138;
        }
      }
      *(void *)&long long v170 = v160;
      DWORD2(v170) = 1083499872;
      BYTE6(v175) = 1;
      if (v69 >= 0) {
        int v73 = (char *)buf;
      }
      else {
        int v73 = *(char **)buf;
      }
      uint64_t v74 = queryNodeForToken(v73, *(void **)(a1 + 40), (uint64_t)&v170, *(unsigned char **)(a1 + 32));
      __int16 v72 = makeOrNode((uint64_t)v71, (uint64_t)v74);
LABEL_138:
      uint64_t v75 = makeOrNode((uint64_t)v62, (uint64_t)v72);
      uint64_t v51 = makeAndNode((uint64_t)v51, (uint64_t)v75);
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      goto LABEL_140;
    }
    BOOL v32 = (v164 & 0x40) == 0;
    memset(buf, 0, sizeof(buf));
    utf8QueryString((const __CFString **)buf, (uint64_t)v28, v25, 0);
    BOOL v33 = hasTrailingAsterisk(*(void *)&v28[8 * v25 - 8]);
    BOOL v34 = v33;
    float v35 = flt_1BDA81D70[v32];
    *(void *)&long long v170 = v159 | 0x40000000;
    if (v33) {
      float v35 = 7.8;
    }
    *((void *)&v170 + 1) = LODWORD(v35) | 0x80000000000000;
    int v173 = 0;
    v171 = &v176;
    int v172 = v158;
    CFDictionaryRef v36 = *(void **)(a1 + 40);
    uint64_t v174 = *(void *)(a1 + 48);
    uint64_t v175 = 0;
    BYTE5(v175) = v33;
    if ((buf[23] & 0x80u) == 0) {
      uint64_t v37 = (char *)buf;
    }
    else {
      uint64_t v37 = *(char **)buf;
    }
    uint64_t v38 = queryNodeForToken(v37, v36, (uint64_t)&v170, *(unsigned char **)(a1 + 32));
    if (v34)
    {
      if ((char)buf[23] < 0)
      {
        uint64_t v40 = *(uint8_t **)buf;
        uint64_t v39 = --*(void *)&buf[8];
      }
      else
      {
        uint64_t v39 = buf[23] - 1;
        buf[23] = v39 & 0x7F;
        uint64_t v40 = buf;
      }
      v40[v39] = 0;
    }
    uint64_t v41 = buf[23];
    signed __int8 v42 = buf[23];
    if ((buf[23] & 0x80u) != 0) {
      uint64_t v41 = *(void *)&buf[8];
    }
    if (!v41)
    {
      uint64_t v45 = 0;
      goto LABEL_87;
    }
    if (v34 && (v164 & 0x40) != 0)
    {
      DWORD2(v170) = 1092435837;
      if ((buf[23] & 0x80u) == 0) {
        int v43 = (char *)buf;
      }
      else {
        int v43 = *(char **)buf;
      }
      int v44 = queryNodeForToken(v43, *(void **)(a1 + 40), (uint64_t)&v170, *(unsigned char **)(a1 + 32));
      signed __int8 v42 = buf[23];
    }
    else
    {
      int v44 = 0;
      uint64_t v45 = 0;
      if (((v164 >> 6) & 1 | v34) != 1) {
        goto LABEL_87;
      }
    }
    *(void *)&long long v170 = v151 | 0x40000000;
    DWORD2(v170) = 1093662671;
    BYTE6(v175) = 1;
    if (v42 >= 0) {
      uint64_t v46 = (char *)buf;
    }
    else {
      uint64_t v46 = *(char **)buf;
    }
    unsigned int v47 = queryNodeForToken(v46, *(void **)(a1 + 40), (uint64_t)&v170, *(unsigned char **)(a1 + 32));
    uint64_t v45 = makeOrNode((uint64_t)v44, (uint64_t)v47);
LABEL_87:
    v149 = makeOrNode((uint64_t)v38, (uint64_t)v45);
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    goto LABEL_89;
  }
  *(_DWORD *)(v26 + 52) = 0;
  *(_WORD *)(v2 + 48) = 32;
  CFRelease(Mutable);
LABEL_49:
  freeQueryTokensContext(v157);
LABEL_50:
  if (SHIBYTE(v177) < 0) {
    operator delete((void *)v176);
  }
  return v2;
}

void sub_1BD82DFD4(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 137) < 0) {
    operator delete(*(void **)(v1 - 160));
  }
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v1 - 336);
  if (*(char *)(v1 - 217) < 0) {
    operator delete(*(void **)(v1 - 240));
  }
  _Unwind_Resume(a1);
}

uint64_t ___ZL19pommesRetrievalTreeP10query_nodeP9PRContext_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v127 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (*(_WORD *)(a2 + 48) == 4)
    {
      uint64_t v3 = *(void *)(a2 + 16);
      if (v3)
      {
        int v4 = *(_DWORD *)(v3 + 24);
        HIDWORD(v6) = v4 - 1;
        LODWORD(v6) = v4 - 1;
        unsigned int v5 = v6 >> 1;
        BOOL v56 = v5 > 6;
        int v7 = (1 << v5) & 0x65;
        BOOL v8 = v56 || v7 == 0;
        if (!v8 && v4 != 15)
        {
          long long v119 = 0uLL;
          float v120 = 0;
          char is_double_star = query_node_is_double_star(a2);
          char NodeMatchingAnyField = isQueryNodeMatchingAnyField(v2);
          if ((is_double_star & 1) == 0 && *(void *)v3)
          {
            std::string::basic_string[abi:nn180100]<0>(&v107, *(char **)v3);
            if (SHIBYTE(v120) < 0) {
              operator delete((void *)v119);
            }
            long long v119 = v107;
            float v120 = v108;
          }
          if (isPhotosAttribute((uint64_t)&v119))
          {
            *(_WORD *)(v2 + 48) = 16;
            goto LABEL_187;
          }
          uint64_t v13 = *(const char ***)(v2 + 16);
          uint64_t v14 = v13[9];
          if (v14)
          {
            size_t v15 = strlen(v13[9]);
            if (is_double_star) {
              goto LABEL_24;
            }
          }
          else
          {
            size_t v15 = 0;
            if (is_double_star) {
              goto LABEL_24;
            }
          }
          if (*v13 && (is_tokenizable_searchable_string_field(*v13) & 1) == 0)
          {
            if (v15) {
              char v90 = NodeMatchingAnyField;
            }
            else {
              char v90 = 0;
            }
            if ((v90 & 1) == 0) {
              goto LABEL_187;
            }
LABEL_25:
            if (v15 == 1 && *v14 == 42) {
              goto LABEL_187;
            }
            unint64_t v16 = *(void *)(*(void *)(v2 + 16) + 32);
            CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v15);
            CFStringAppendCString(Mutable, *(const char **)(*(void *)(v2 + 16) + 72), 0x8000100u);
            if (!Mutable) {
              goto LABEL_187;
            }
            CFLocaleRef v18 = CFLocaleCopyCurrent();
            CFStringLowercase(Mutable, v18);
            if (v18) {
              CFRelease(v18);
            }
            QueryTokens = (CFArrayRef *)CreateQueryTokens(Mutable, (v16 >> 2) & 1);
            uint64_t v20 = (CFTypeRef *)QueryTokens;
            CFArrayRef v21 = *QueryTokens;
            if (*QueryTokens)
            {
              CFIndex Count = CFArrayGetCount(*QueryTokens);
              CFIndex v23 = Count;
              if (Count)
              {
                int v99 = *(_DWORD *)(*(void *)(v2 + 16) + 24);
                uint64_t v118 = 1065353216;
                memset(v117, 0, sizeof(v117));
                uint64_t v94 = v20;
                CFMutableStringRef v95 = Mutable;
                if (Count < 1)
                {
                  *(void *)&v102[4] = 0;
LABEL_182:
                  CFRelease(v95);
                  cCFAllocatorRef alloc = *(_WORD **)&v102[4];
                  freeQueryTokensContext(v94);
                  if (!*(void *)&v102[4])
                  {
                    cCFAllocatorRef alloc = query_calloc();
                    calloc[24] = 32;
                  }
                  if (calloc != (_WORD *)v2)
                  {
                    db_free_query_node((void *)v2);
                    uint64_t v2 = (uint64_t)calloc;
                  }
                  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v117);
                  goto LABEL_187;
                }
                unint64_t v98 = v16;
                unint64_t v101 = v16 & 0xFFFFFFFEFFFFFFFBLL;
                uint64_t v24 = 1;
                do
                {
                  CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v21, v24 - 1);
                  BOOL v26 = hasOnlyOptionalSpecialChar(ValueAtIndex);
                  if (!v26) {
                    break;
                  }
                  BOOL v56 = v24++ < v23;
                }
                while (v56);
                CFIndex v28 = 0;
                *(_DWORD *)&v102[8] = 0;
                CFIndex v105 = v23;
                *(void *)int v102 = BYTE4(v16) & 1 | v26;
                unint64_t v97 = v101 | ((unint64_t)(v23 == 1) << 30);
                if (v99 == 5) {
                  char v29 = 1;
                }
                else {
                  char v29 = BYTE4(v16) & 1;
                }
                char v96 = v29;
                *(void *)&long long v27 = 134219010;
                long long v93 = v27;
                while (1)
                {
                  *(_OWORD *)std::string __p = 0u;
                  *(_OWORD *)v115 = 0u;
                  uint64_t v116 = 1065353216;
                  uint64_t v30 = (__CFString *)CFArrayGetValueAtIndex(v21, v28);
                  key = v30;
                  uint64_t Length = CFStringGetLength(v30);
                  if (Length) {
                    break;
                  }
LABEL_141:
                  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node((void **)v115[0]);
                  uint64_t v74 = __p[0];
                  __p[0] = 0;
                  if (v74) {
                    operator delete(v74);
                  }
                  if (++v28 == v105) {
                    goto LABEL_182;
                  }
                }
                BOOL v32 = hasTrailingAsterisk((BOOL)v30);
                memset(&__str, 0, sizeof(__str));
                utf8QueryString((const __CFString **)&__str, (uint64_t)&key, 1, 0);
                if (v32)
                {
                  if (!--Length)
                  {
LABEL_139:
                    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__str.__r_.__value_.__l.__data_);
                    }
                    goto LABEL_141;
                  }
                  v128.location = 0;
                  v128.length = Length;
                  uint64_t v30 = (__CFString *)CFStringCreateWithSubstring(alloc, v30, v128);
                  key = v30;
                  cf = v30;
                }
                else
                {
                  cf = 0;
                }
                BOOL v33 = (v102[0] & 1) == 0 && hasOnlyOptionalSpecialChar(v30);
                if (std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>(*(uint64_t *)&v117[0], *((unint64_t *)&v117[0] + 1), (uint64_t)&__str)|| v33)
                {
LABEL_137:
                  if (cf) {
                    CFRelease(cf);
                  }
                  goto LABEL_139;
                }
                *(_DWORD *)&v110[8] = 0;
                uint64_t v111 = 0;
                long long v107 = v97;
                uint64_t v108 = &v119;
                int v109 = v99;
                *(void *)long long v110 = v99 == 5;
                BOOL v34 = *(unsigned char **)(a1 + 40);
                *(void *)&v110[4] = *(void *)(a1 + 32);
                BYTE5(v111) = v32;
                if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  p_str = &__str;
                }
                else {
                  p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
                }
                uint64_t NodeForToken = queryNodeForToken((char *)p_str, *(void **)(a1 + 48), (uint64_t)&v107, v34);
                if (NodeForToken)
                {
                  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)v117, (uint64_t)&__str, (uint64_t)&__str);
                  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)__p, (uint64_t)&__str, (uint64_t)&__str);
                }
                if ((v98 & 0x100000000) == 0)
                {
                  if (hasTrailingOptionalSpecialChar(v30))
                  {
                    CFIndex v36 = Length - v32;
                    while (1)
                    {
                      BOOL v56 = v36-- < 1;
                      if (v56) {
                        break;
                      }
                      UniChar CharacterAtIndex = CFStringGetCharacterAtIndex(v30, v36);
                      if (!isOptionalSpecialChar(CharacterAtIndex))
                      {
                        v129.length = v36 + 1;
                        v129.location = 0;
                        CFStringRef v38 = CFStringCreateWithSubstring(alloc, v30, v129);
                        v106.__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
                        memset(buf, 0, sizeof(buf));
                        utf8QueryString((const __CFString **)buf, (uint64_t)&v106, 1, 0);
                        CFRelease(v38);
                        if (!std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>((uint64_t)__p[0], (unint64_t)__p[1], (uint64_t)buf))
                        {
                          *(void *)&long long v107 = v101 | 0x80000000;
                          uint64_t v39 = (buf[23] & 0x80u) == 0 ? (char *)buf : *(char **)buf;
                          uint64_t v40 = queryNodeForToken(v39, *(void **)(a1 + 48), (uint64_t)&v107, *(unsigned char **)(a1 + 40));
                          if (v40)
                          {
                            uint64_t v41 = (uint64_t)v40;
                            std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)__p, (uint64_t)buf, (uint64_t)buf);
                            uint64_t NodeForToken = makeOrNode((uint64_t)NodeForToken, v41);
                          }
                        }
                        if ((char)buf[23] < 0) {
                          operator delete(*(void **)buf);
                        }
                        break;
                      }
                    }
                  }
                  if (*(unsigned char *)(*(void *)(a1 + 40) + 18))
                  {
                    if (CFStringGetLength(v30) >= 2)
                    {
                      CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetLetter);
                      v130.length = CFStringGetLength(v30) - v32;
                      v130.location = 0;
                      if (!CFStringFindCharacterFromSet(v30, Predefined, v130, 0, 0))
                      {
                        v106.__r_.__value_.__r.__words[0] = (std::string::size_type)convertCommaSeparatedNumberTokenWithNumberFormatter(v30);
                        if (CFStringGetLength((CFStringRef)v106.__r_.__value_.__l.__data_) >= 1)
                        {
                          memset(buf, 0, sizeof(buf));
                          utf8QueryString((const __CFString **)buf, (uint64_t)&v106, 1, 0);
                          if (!std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>((uint64_t)__p[0], (unint64_t)__p[1], (uint64_t)buf))
                          {
                            std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)__p, (uint64_t)buf, (uint64_t)buf);
                            *(void *)&long long v107 = v101 | 0x80000000;
                            if ((buf[23] & 0x80u) == 0) {
                              CFIndex v58 = (char *)buf;
                            }
                            else {
                              CFIndex v58 = *(char **)buf;
                            }
                            uint64_t v59 = queryNodeForToken(v58, *(void **)(a1 + 48), (uint64_t)&v107, *(unsigned char **)(a1 + 40));
                            uint64_t NodeForToken = makeOrNode((uint64_t)NodeForToken, (uint64_t)v59);
                          }
                          if ((char)buf[23] < 0) {
                            operator delete(*(void **)buf);
                          }
                        }
                      }
                    }
                  }
                  CFDictionaryRef v43 = *(const __CFDictionary **)(*(void *)(a1 + 40) + 40);
                  if (v43)
                  {
                    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v43, key);
                    CFArrayRef v45 = Value;
                    if (Value)
                    {
                      CFIndex v46 = CFArrayGetCount(Value);
                      if (v46 >= 1)
                      {
                        for (CFIndex i = 0; i != v46; ++i)
                        {
                          CFIndex v48 = (void *)CFArrayGetValueAtIndex(v45, i);
                          v106.__r_.__value_.__r.__words[0] = [v48 variation];
                          if (CFStringGetLength((CFStringRef)v106.__r_.__value_.__l.__data_))
                          {
                            memset(buf, 0, sizeof(buf));
                            utf8QueryString((const __CFString **)buf, (uint64_t)&v106, 1, 0);
                            if (!std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>((uint64_t)__p[0], (unint64_t)__p[1], (uint64_t)buf)|| [v48 type] == 1)
                            {
                              uint64_t v49 = objc_msgSend(v48, "type", v93);
                              uint64_t v50 = 0x80000000;
                              if (v49 == 1) {
                                uint64_t v50 = 2155872256;
                              }
                              *(void *)&long long v107 = v50 | v101;
                              if ((buf[23] & 0x80u) == 0) {
                                uint64_t v51 = (char *)buf;
                              }
                              else {
                                uint64_t v51 = *(char **)buf;
                              }
                              BOOL v52 = queryNodeForToken(v51, *(void **)(a1 + 48), (uint64_t)&v107, *(unsigned char **)(a1 + 40));
                              if (v52)
                              {
                                uint64_t v53 = (uint64_t)v52;
                                std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)__p, (uint64_t)buf, (uint64_t)buf);
                                uint64_t NodeForToken = makeOrNode((uint64_t)NodeForToken, v53);
                              }
                            }
                            if ((char)buf[23] < 0) {
                              operator delete(*(void **)buf);
                            }
                          }
                        }
                      }
                    }
                  }
                }
                if ((v96 & 1) == 0)
                {
                  uint64_t v54 = *(void *)(a1 + 40);
                  int v55 = *(unsigned __int8 *)(v54 + 17);
                  if (!*(unsigned char *)(v54 + 17))
                  {
                    BOOL v56 = *(unsigned char *)(v54 + 13) || Length < 7;
                    if (!v56)
                    {
                      memset(&v106, 0, sizeof(v106));
                      std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
                      if (v32)
                      {
                        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                          std::string::size_type size = __str.__r_.__value_.__l.__size_;
                        }
                        std::string::basic_string(&v106, &__str, 0, size - 1, (std::allocator<char> *)buf);
                      }
                      else if ((*((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x80) != 0)
                      {
                        std::string::__init_copy_ctor_external(&v106, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
                      }
                      else
                      {
                        std::string v106 = __str;
                      }
                      if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                        float v60 = &v106;
                      }
                      else {
                        float v60 = (std::string *)v106.__r_.__value_.__r.__words[0];
                      }
                      int v61 = PRPommesStemWordWithCString((const char *)v60, 100, 0);
                      if (v61)
                      {
                        uint64_t v62 = v61;
                        std::string::basic_string[abi:nn180100]<0>(buf, v61);
                        uint64_t v63 = std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>((uint64_t)__p[0], (unint64_t)__p[1], (uint64_t)buf);
                        if ((char)buf[23] < 0) {
                          operator delete(*(void **)buf);
                        }
                        if (!v63)
                        {
                          if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                            std::string::size_type v64 = HIBYTE(v106.__r_.__value_.__r.__words[2]);
                          }
                          else {
                            std::string::size_type v64 = v106.__r_.__value_.__l.__size_;
                          }
                          if (v64 - strlen(v62) == 1)
                          {
                            int v65 = *__error();
                            uint64_t v66 = _SILogForLogForCategory(17);
                            if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
                            {
                              uint64_t v67 = *(uint64_t **)(a1 + 40);
                              uint64_t v68 = *v67;
                              uint64_t v69 = v67[3];
                              uint64_t v70 = &v106;
                              if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                                uint64_t v70 = (std::string *)v106.__r_.__value_.__r.__words[0];
                              }
                              *(_DWORD *)iovec buf = v93;
                              *(void *)&uint8_t buf[4] = v68;
                              *(_WORD *)&buf[12] = 2080;
                              *(void *)&buf[14] = v69;
                              *(_WORD *)&buf[22] = 2080;
                              uint64_t v122 = v62;
                              __int16 v123 = 2080;
                              float v124 = v70;
                              __int16 v125 = 1024;
                              int v126 = 0;
                              _os_log_impl(&dword_1BD672000, v66, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][rewrite] First Pass Stemming (Top Hits) added stemmedToken = [%s] to Query Tree for token = [%s] with wildcard_limit = %u", buf, 0x30u);
                            }
                            *__error() = v65;
                            *(void *)&long long v107 = v101 | 0x80000000;
                            uint64_t v71 = *(unsigned char **)(a1 + 40);
                            LODWORD(v111) = 0;
                            __int16 v72 = queryNodeForToken(v62, *(void **)(a1 + 56), (uint64_t)&v107, v71);
                            if (v72)
                            {
                              uint64_t v73 = (uint64_t)v72;
                              std::string::basic_string[abi:nn180100]<0>(buf, v62);
                              std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>((uint64_t)__p, (uint64_t)buf, (uint64_t)buf);
                              if ((char)buf[23] < 0) {
                                operator delete(*(void **)buf);
                              }
                              uint64_t NodeForToken = makeOrNode((uint64_t)NodeForToken, v73);
                            }
                          }
                          free(v62);
                        }
                      }
                      if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v106.__r_.__value_.__l.__data_);
                      }
                      uint64_t v54 = *(void *)(a1 + 40);
                      int v55 = *(unsigned __int8 *)(v54 + 17);
                      goto LABEL_135;
                    }
                  }
                  if (Length >= 5)
                  {
LABEL_135:
                    if (!v55 && *(unsigned char *)(v54 + 13))
                    {
                      memset(&v106, 0, sizeof(v106));
                      std::string::size_type v75 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
                      if (v32)
                      {
                        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                          std::string::size_type v75 = __str.__r_.__value_.__l.__size_;
                        }
                        std::string::basic_string(&v106, &__str, 0, v75 - 1, (std::allocator<char> *)buf);
                      }
                      else if ((*((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x80) != 0)
                      {
                        std::string::__init_copy_ctor_external(&v106, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
                      }
                      else
                      {
                        std::string v106 = __str;
                      }
                      if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                        uint64_t v76 = &v106;
                      }
                      else {
                        uint64_t v76 = (std::string *)v106.__r_.__value_.__r.__words[0];
                      }
                      CFArrayRef v77 = PRPommesStemWordWithCString((const char *)v76, 100, 0);
                      if (v77)
                      {
                        uint64_t v78 = v77;
                        std::string::basic_string[abi:nn180100]<0>(buf, v77);
                        BOOL v79 = std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>((uint64_t)__p[0], (unint64_t)__p[1], (uint64_t)buf);
                        if ((char)buf[23] < 0) {
                          operator delete(*(void **)buf);
                        }
                        if (!v79)
                        {
                          if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                            std::string::size_type v80 = HIBYTE(v106.__r_.__value_.__r.__words[2]);
                          }
                          else {
                            std::string::size_type v80 = v106.__r_.__value_.__l.__size_;
                          }
                          if (v80 != strlen(v78))
                          {
                            int v81 = *__error();
                            CFIndex v82 = _SILogForLogForCategory(17);
                            if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
                            {
                              uint64_t v83 = *(uint64_t **)(a1 + 40);
                              uint64_t v84 = *v83;
                              uint64_t v85 = v83[3];
                              CFIndex v86 = &v106;
                              if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                                CFIndex v86 = (std::string *)v106.__r_.__value_.__r.__words[0];
                              }
                              *(_DWORD *)iovec buf = v93;
                              *(void *)&uint8_t buf[4] = v84;
                              *(_WORD *)&buf[12] = 2080;
                              *(void *)&buf[14] = v85;
                              *(_WORD *)&buf[22] = 2080;
                              uint64_t v122 = v78;
                              __int16 v123 = 2080;
                              float v124 = v86;
                              __int16 v125 = 1024;
                              int v126 = 3;
                              _os_log_impl(&dword_1BD672000, v82, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][rewrite] First Pass Stemming (Committed Search) added stemmedToken = [%s] to Query Tree for token = [%s] with wildcard_limit = %u", buf, 0x30u);
                            }
                            *__error() = v81;
                            *(void *)&long long v107 = v101 | 0x80000000;
                            BOOL v87 = *(unsigned char **)(a1 + 40);
                            LODWORD(v111) = 3;
                            float v88 = queryNodeForToken(v78, *(void **)(a1 + 56), (uint64_t)&v107, v87);
                            if (v88)
                            {
                              uint64_t v89 = (uint64_t)v88;
                              std::string::basic_string[abi:nn180100]<0>(buf, v78);
                              std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>((uint64_t)__p, (uint64_t)buf, (uint64_t)buf);
                              if ((char)buf[23] < 0) {
                                operator delete(*(void **)buf);
                              }
                              uint64_t NodeForToken = makeOrNode((uint64_t)NodeForToken, v89);
                            }
                          }
                          free(v78);
                        }
                      }
                      if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v106.__r_.__value_.__l.__data_);
                      }
                    }
                  }
                }
                *(void *)&v102[4] = makeAndNode(*(uint64_t *)&v102[4], (uint64_t)NodeForToken);
                goto LABEL_137;
              }
            }
            CFRelease(Mutable);
            freeQueryTokensContext(v20);
LABEL_187:
            if (SHIBYTE(v120) < 0) {
              operator delete((void *)v119);
            }
            return v2;
          }
LABEL_24:
          if (!v15) {
            goto LABEL_187;
          }
          goto LABEL_25;
        }
      }
    }
  }
  return v2;
}

void sub_1BD82ECC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,char a47)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a47);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v47 - 240);
  if (*(char *)(v47 - 169) < 0) {
    operator delete(*(void **)(v47 - 192));
  }
  _Unwind_Resume(a1);
}

void *___ZL19pommesRetrievalTreeP10query_nodeP9PRContext_block_invoke_9(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = a2;
  if (a2 && a3 && a4)
  {
    *a2 = a3;
    a2[1] = a4;
  }
  else if (a2)
  {
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    v5[2] = __db_query_tree_apply_block_block_invoke;
    void v5[3] = &unk_1E6348598;
    v5[4] = &__block_literal_global_161;
    db_query_tree_apply_block_with_meta(a2, (uint64_t)v5, 0);
    return 0;
  }
  return result;
}

void *query_calloc()
{
  if (*MEMORY[0x1E4F14B00] <= 0x4FuLL) {
    ++sTotal;
  }
  uint64_t v0 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x50uLL, 0x31F9A007uLL);
  if (!v0) {
    _log_fault_for_malloc_failure();
  }
  return v0;
}

void *___ZL17pommesRankingTreeP10query_nodeP9PRContext_block_invoke_4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = a2;
  if (a2 && a3 && a4)
  {
    *a2 = a3;
    a2[1] = a4;
  }
  else if (a2)
  {
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    v5[2] = __db_query_tree_apply_block_block_invoke;
    void v5[3] = &unk_1E6348598;
    v5[4] = &__block_literal_global_161;
    db_query_tree_apply_block_with_meta(a2, (uint64_t)v5, 0);
    return 0;
  }
  return result;
}

void incompleteRomajiKanaData(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v533 = *MEMORY[0x1E4F143B8];
  {
    std::string::basic_string[abi:nn180100]<0>(v215, "b");
    std::string::basic_string[abi:nn180100]<0>(&v470, "");
    std::string::basic_string[abi:nn180100]<0>(v471, "");
    std::string::basic_string[abi:nn180100]<0>(v472, "");
    std::string::basic_string[abi:nn180100]<0>(v473, "");
    std::string::basic_string[abi:nn180100]<0>(v474, "");
    std::string::basic_string[abi:nn180100]<0>(v475, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v214, &v470, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v476, (long long *)v215, v214);
    std::string::basic_string[abi:nn180100]<0>(v212, "by");
    std::string::basic_string[abi:nn180100]<0>(&v465, "");
    std::string::basic_string[abi:nn180100]<0>(v466, "");
    std::string::basic_string[abi:nn180100]<0>(v467, "");
    std::string::basic_string[abi:nn180100]<0>(v468, "");
    std::string::basic_string[abi:nn180100]<0>(v469, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v211, &v465, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v477, (long long *)v212, v211);
    std::string::basic_string[abi:nn180100]<0>(v209, "c");
    std::string::basic_string[abi:nn180100]<0>(&v458, "");
    std::string::basic_string[abi:nn180100]<0>(v459, "");
    std::string::basic_string[abi:nn180100]<0>(v460, "");
    std::string::basic_string[abi:nn180100]<0>(v461, "");
    std::string::basic_string[abi:nn180100]<0>(v462, "");
    std::string::basic_string[abi:nn180100]<0>(v463, "");
    std::string::basic_string[abi:nn180100]<0>(v464, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v208, &v458, 7uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v478, (long long *)v209, v208);
    std::string::basic_string[abi:nn180100]<0>(v206, "ch");
    std::string::basic_string[abi:nn180100]<0>(v456, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v205, (long long *)v456, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v479, (long long *)v206, v205);
    std::string::basic_string[abi:nn180100]<0>(v203, "cy");
    std::string::basic_string[abi:nn180100]<0>(&v451, "");
    std::string::basic_string[abi:nn180100]<0>(v452, "");
    std::string::basic_string[abi:nn180100]<0>(v453, "");
    std::string::basic_string[abi:nn180100]<0>(v454, "");
    std::string::basic_string[abi:nn180100]<0>(v455, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v202, &v451, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v480, (long long *)v203, v202);
    std::string::basic_string[abi:nn180100]<0>(v200, "d");
    std::string::basic_string[abi:nn180100]<0>(&v445, "");
    std::string::basic_string[abi:nn180100]<0>(v446, "");
    std::string::basic_string[abi:nn180100]<0>(v447, "");
    std::string::basic_string[abi:nn180100]<0>(v448, "");
    std::string::basic_string[abi:nn180100]<0>(v449, "");
    std::string::basic_string[abi:nn180100]<0>(v450, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v199, &v445, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v481, (long long *)v200, v199);
    std::string::basic_string[abi:nn180100]<0>(v197, "dh");
    std::string::basic_string[abi:nn180100]<0>(&v440, "");
    std::string::basic_string[abi:nn180100]<0>(v441, "");
    std::string::basic_string[abi:nn180100]<0>(v442, "");
    std::string::basic_string[abi:nn180100]<0>(v443, "");
    std::string::basic_string[abi:nn180100]<0>(v444, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v196, &v440, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v482, (long long *)v197, v196);
    std::string::basic_string[abi:nn180100]<0>(v194, "dw");
    std::string::basic_string[abi:nn180100]<0>(v438, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v193, (long long *)v438, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v483, (long long *)v194, v193);
    std::string::basic_string[abi:nn180100]<0>(v191, "dy");
    std::string::basic_string[abi:nn180100]<0>(&v433, "");
    std::string::basic_string[abi:nn180100]<0>(v434, "");
    std::string::basic_string[abi:nn180100]<0>(v435, "");
    std::string::basic_string[abi:nn180100]<0>(v436, "");
    std::string::basic_string[abi:nn180100]<0>(v437, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v190, &v433, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v484, (long long *)v191, v190);
    std::string::basic_string[abi:nn180100]<0>(v188, "f");
    std::string::basic_string[abi:nn180100]<0>(v431, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v187, (long long *)v431, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v485, (long long *)v188, v187);
    std::string::basic_string[abi:nn180100]<0>(v185, "fy");
    std::string::basic_string[abi:nn180100]<0>(v429, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v184, (long long *)v429, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v486, (long long *)v185, v184);
    std::string::basic_string[abi:nn180100]<0>(v182, "g");
    std::string::basic_string[abi:nn180100]<0>(&v423, "");
    std::string::basic_string[abi:nn180100]<0>(v424, "");
    std::string::basic_string[abi:nn180100]<0>(v425, "");
    std::string::basic_string[abi:nn180100]<0>(v426, "");
    std::string::basic_string[abi:nn180100]<0>(v427, "");
    std::string::basic_string[abi:nn180100]<0>(v428, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v181, &v423, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v487, (long long *)v182, v181);
    std::string::basic_string[abi:nn180100]<0>(v179, "gw");
    std::string::basic_string[abi:nn180100]<0>(&v418, "");
    std::string::basic_string[abi:nn180100]<0>(v419, "");
    std::string::basic_string[abi:nn180100]<0>(v420, "");
    std::string::basic_string[abi:nn180100]<0>(v421, "");
    std::string::basic_string[abi:nn180100]<0>(v422, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v178, &v418, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v488, (long long *)v179, v178);
    std::string::basic_string[abi:nn180100]<0>(v176, "gy");
    std::string::basic_string[abi:nn180100]<0>(&v413, "");
    std::string::basic_string[abi:nn180100]<0>(v414, "");
    std::string::basic_string[abi:nn180100]<0>(v415, "");
    std::string::basic_string[abi:nn180100]<0>(v416, "");
    std::string::basic_string[abi:nn180100]<0>(v417, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v175, &v413, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v489, (long long *)v176, v175);
    std::string::basic_string[abi:nn180100]<0>(v173, "h");
    std::string::basic_string[abi:nn180100]<0>(&v407, "");
    std::string::basic_string[abi:nn180100]<0>(v408, "");
    std::string::basic_string[abi:nn180100]<0>(v409, "");
    std::string::basic_string[abi:nn180100]<0>(v410, "");
    std::string::basic_string[abi:nn180100]<0>(v411, "");
    std::string::basic_string[abi:nn180100]<0>(v412, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v172, &v407, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v490, (long long *)v173, v172);
    std::string::basic_string[abi:nn180100]<0>(v170, "hw");
    std::string::basic_string[abi:nn180100]<0>(&v402, "");
    std::string::basic_string[abi:nn180100]<0>(v403, "");
    std::string::basic_string[abi:nn180100]<0>(v404, "");
    std::string::basic_string[abi:nn180100]<0>(v405, "");
    std::string::basic_string[abi:nn180100]<0>(v406, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v169, &v402, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v491, (long long *)v170, v169);
    std::string::basic_string[abi:nn180100]<0>(v167, "hy");
    std::string::basic_string[abi:nn180100]<0>(&v397, "");
    std::string::basic_string[abi:nn180100]<0>(v398, "");
    std::string::basic_string[abi:nn180100]<0>(v399, "");
    std::string::basic_string[abi:nn180100]<0>(v400, "");
    std::string::basic_string[abi:nn180100]<0>(v401, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v166, &v397, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v492, (long long *)v167, v166);
    std::string::basic_string[abi:nn180100]<0>(v164, "j");
    std::string::basic_string[abi:nn180100]<0>(&v395, "");
    std::string::basic_string[abi:nn180100]<0>(v396, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v163, &v395, 2uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v493, (long long *)v164, v163);
    std::string::basic_string[abi:nn180100]<0>(v161, "jy");
    std::string::basic_string[abi:nn180100]<0>(&v390, "");
    std::string::basic_string[abi:nn180100]<0>(v391, "");
    std::string::basic_string[abi:nn180100]<0>(v392, "");
    std::string::basic_string[abi:nn180100]<0>(v393, "");
    std::string::basic_string[abi:nn180100]<0>(v394, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v160, &v390, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v494, (long long *)v161, v160);
    std::string::basic_string[abi:nn180100]<0>(v158, "k");
    std::string::basic_string[abi:nn180100]<0>(&v384, "");
    std::string::basic_string[abi:nn180100]<0>(v385, "");
    std::string::basic_string[abi:nn180100]<0>(v386, "");
    std::string::basic_string[abi:nn180100]<0>(v387, "");
    std::string::basic_string[abi:nn180100]<0>(v388, "");
    std::string::basic_string[abi:nn180100]<0>(v389, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v157, &v384, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v495, (long long *)v158, v157);
    std::string::basic_string[abi:nn180100]<0>(v155, "kw");
    std::string::basic_string[abi:nn180100]<0>(&v379, "");
    std::string::basic_string[abi:nn180100]<0>(v380, "");
    std::string::basic_string[abi:nn180100]<0>(v381, "");
    std::string::basic_string[abi:nn180100]<0>(v382, "");
    std::string::basic_string[abi:nn180100]<0>(v383, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v154, &v379, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v496, (long long *)v155, v154);
    std::string::basic_string[abi:nn180100]<0>(v152, "ky");
    std::string::basic_string[abi:nn180100]<0>(&v374, "");
    std::string::basic_string[abi:nn180100]<0>(v375, "");
    std::string::basic_string[abi:nn180100]<0>(v376, "");
    std::string::basic_string[abi:nn180100]<0>(v377, "");
    std::string::basic_string[abi:nn180100]<0>(v378, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v151, &v374, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v497, (long long *)v152, v151);
    std::string::basic_string[abi:nn180100]<0>(v149, "l");
    std::string::basic_string[abi:nn180100]<0>(&v364, "");
    std::string::basic_string[abi:nn180100]<0>(v365, "");
    std::string::basic_string[abi:nn180100]<0>(v366, "");
    std::string::basic_string[abi:nn180100]<0>(v367, "");
    std::string::basic_string[abi:nn180100]<0>(v368, "");
    std::string::basic_string[abi:nn180100]<0>(v369, "");
    std::string::basic_string[abi:nn180100]<0>(v370, "");
    std::string::basic_string[abi:nn180100]<0>(v371, "");
    std::string::basic_string[abi:nn180100]<0>(v372, "");
    std::string::basic_string[abi:nn180100]<0>(v373, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v148, &v364, 0xAuLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v498, (long long *)v149, v148);
    std::string::basic_string[abi:nn180100]<0>(v146, "lt");
    std::string::basic_string[abi:nn180100]<0>(v362, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v145, (long long *)v362, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v499, (long long *)v146, v145);
    std::string::basic_string[abi:nn180100]<0>(v143, "lw");
    std::string::basic_string[abi:nn180100]<0>(v360, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v142, (long long *)v360, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v500, (long long *)v143, v142);
    std::string::basic_string[abi:nn180100]<0>(v140, "ly");
    std::string::basic_string[abi:nn180100]<0>(&v355, "");
    std::string::basic_string[abi:nn180100]<0>(v356, "");
    std::string::basic_string[abi:nn180100]<0>(v357, "");
    std::string::basic_string[abi:nn180100]<0>(v358, "");
    std::string::basic_string[abi:nn180100]<0>(v359, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v139, &v355, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v501, (long long *)v140, v139);
    std::string::basic_string[abi:nn180100]<0>(v137, "m");
    std::string::basic_string[abi:nn180100]<0>(&v349, "");
    std::string::basic_string[abi:nn180100]<0>(v350, "");
    std::string::basic_string[abi:nn180100]<0>(v351, "");
    std::string::basic_string[abi:nn180100]<0>(v352, "");
    std::string::basic_string[abi:nn180100]<0>(v353, "");
    std::string::basic_string[abi:nn180100]<0>(v354, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v136, &v349, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v502, (long long *)v137, v136);
    std::string::basic_string[abi:nn180100]<0>(v134, "my");
    std::string::basic_string[abi:nn180100]<0>(&v344, "");
    std::string::basic_string[abi:nn180100]<0>(v345, "");
    std::string::basic_string[abi:nn180100]<0>(v346, "");
    std::string::basic_string[abi:nn180100]<0>(v347, "");
    std::string::basic_string[abi:nn180100]<0>(v348, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v133, &v344, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v503, (long long *)v134, v133);
    std::string::basic_string[abi:nn180100]<0>(v131, "n");
    std::string::basic_string[abi:nn180100]<0>(&v337, "");
    std::string::basic_string[abi:nn180100]<0>(v338, "");
    std::string::basic_string[abi:nn180100]<0>(v339, "");
    std::string::basic_string[abi:nn180100]<0>(v340, "");
    std::string::basic_string[abi:nn180100]<0>(v341, "");
    std::string::basic_string[abi:nn180100]<0>(v342, "");
    std::string::basic_string[abi:nn180100]<0>(v343, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v130, &v337, 7uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v504, (long long *)v131, v130);
    std::string::basic_string[abi:nn180100]<0>(v128, "ny");
    std::string::basic_string[abi:nn180100]<0>(&v332, "");
    std::string::basic_string[abi:nn180100]<0>(v333, "");
    std::string::basic_string[abi:nn180100]<0>(v334, "");
    std::string::basic_string[abi:nn180100]<0>(v335, "");
    std::string::basic_string[abi:nn180100]<0>(v336, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v127, &v332, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v505, (long long *)v128, v127);
    std::string::basic_string[abi:nn180100]<0>(v125, "p");
    std::string::basic_string[abi:nn180100]<0>(&v326, "");
    std::string::basic_string[abi:nn180100]<0>(v327, "");
    std::string::basic_string[abi:nn180100]<0>(v328, "");
    std::string::basic_string[abi:nn180100]<0>(v329, "");
    std::string::basic_string[abi:nn180100]<0>(v330, "");
    std::string::basic_string[abi:nn180100]<0>(v331, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v124, &v326, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v506, (long long *)v125, v124);
    std::string::basic_string[abi:nn180100]<0>(v122, "py");
    std::string::basic_string[abi:nn180100]<0>(&v321, "");
    std::string::basic_string[abi:nn180100]<0>(v322, "");
    std::string::basic_string[abi:nn180100]<0>(v323, "");
    std::string::basic_string[abi:nn180100]<0>(v324, "");
    std::string::basic_string[abi:nn180100]<0>(v325, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v121, &v321, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v507, (long long *)v122, v121);
    std::string::basic_string[abi:nn180100]<0>(v119, "q");
    std::string::basic_string[abi:nn180100]<0>(v319, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v118, (long long *)v319, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v508, (long long *)v119, v118);
    std::string::basic_string[abi:nn180100]<0>(v116, "qy");
    std::string::basic_string[abi:nn180100]<0>(&v314, "");
    std::string::basic_string[abi:nn180100]<0>(v315, "");
    std::string::basic_string[abi:nn180100]<0>(v316, "");
    std::string::basic_string[abi:nn180100]<0>(v317, "");
    std::string::basic_string[abi:nn180100]<0>(v318, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v115, &v314, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v509, (long long *)v116, v115);
    std::string::basic_string[abi:nn180100]<0>(v113, "r");
    std::string::basic_string[abi:nn180100]<0>(&v308, "");
    std::string::basic_string[abi:nn180100]<0>(v309, "");
    std::string::basic_string[abi:nn180100]<0>(v310, "");
    std::string::basic_string[abi:nn180100]<0>(v311, "");
    std::string::basic_string[abi:nn180100]<0>(v312, "");
    std::string::basic_string[abi:nn180100]<0>(v313, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v112, &v308, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v510, (long long *)v113, v112);
    std::string::basic_string[abi:nn180100]<0>(v110, "ry");
    std::string::basic_string[abi:nn180100]<0>(&v303, "");
    std::string::basic_string[abi:nn180100]<0>(v304, "");
    std::string::basic_string[abi:nn180100]<0>(v305, "");
    std::string::basic_string[abi:nn180100]<0>(v306, "");
    std::string::basic_string[abi:nn180100]<0>(v307, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v109, &v303, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v511, (long long *)v110, v109);
    std::string::basic_string[abi:nn180100]<0>(v107, "s");
    std::string::basic_string[abi:nn180100]<0>(&v297, "");
    std::string::basic_string[abi:nn180100]<0>(v298, "");
    std::string::basic_string[abi:nn180100]<0>(v299, "");
    std::string::basic_string[abi:nn180100]<0>(v300, "");
    std::string::basic_string[abi:nn180100]<0>(v301, "");
    std::string::basic_string[abi:nn180100]<0>(v302, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v106, &v297, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v512, (long long *)v107, v106);
    std::string::basic_string[abi:nn180100]<0>(v104, "sh");
    std::string::basic_string[abi:nn180100]<0>(v295, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v103, (long long *)v295, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v513, (long long *)v104, v103);
    std::string::basic_string[abi:nn180100]<0>(v101, "sy");
    std::string::basic_string[abi:nn180100]<0>(&v290, "");
    std::string::basic_string[abi:nn180100]<0>(v291, "");
    std::string::basic_string[abi:nn180100]<0>(v292, "");
    std::string::basic_string[abi:nn180100]<0>(v293, "");
    std::string::basic_string[abi:nn180100]<0>(v294, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v100, &v290, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v514, (long long *)v101, v100);
    std::string::basic_string[abi:nn180100]<0>(v98, "t");
    std::string::basic_string[abi:nn180100]<0>(&v284, "");
    std::string::basic_string[abi:nn180100]<0>(v285, "");
    std::string::basic_string[abi:nn180100]<0>(v286, "");
    std::string::basic_string[abi:nn180100]<0>(v287, "");
    std::string::basic_string[abi:nn180100]<0>(v288, "");
    std::string::basic_string[abi:nn180100]<0>(v289, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v97, &v284, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v515, (long long *)v98, v97);
    std::string::basic_string[abi:nn180100]<0>(v95, "th");
    std::string::basic_string[abi:nn180100]<0>(&v280, "");
    std::string::basic_string[abi:nn180100]<0>(v281, "");
    std::string::basic_string[abi:nn180100]<0>(v282, "");
    std::string::basic_string[abi:nn180100]<0>(v283, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v94, &v280, 4uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v516, (long long *)v95, v94);
    std::string::basic_string[abi:nn180100]<0>(v92, "ts");
    std::string::basic_string[abi:nn180100]<0>(v278, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v91, (long long *)v278, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v517, (long long *)v92, v91);
    std::string::basic_string[abi:nn180100]<0>(v89, "tw");
    std::string::basic_string[abi:nn180100]<0>(v276, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v88, (long long *)v276, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v518, (long long *)v89, v88);
    std::string::basic_string[abi:nn180100]<0>(v86, "ty");
    std::string::basic_string[abi:nn180100]<0>(&v271, "");
    std::string::basic_string[abi:nn180100]<0>(v272, "");
    std::string::basic_string[abi:nn180100]<0>(v273, "");
    std::string::basic_string[abi:nn180100]<0>(v274, "");
    std::string::basic_string[abi:nn180100]<0>(v275, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v85, &v271, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v519, (long long *)v86, v85);
    std::string::basic_string[abi:nn180100]<0>(v83, "v");
    std::string::basic_string[abi:nn180100]<0>(&v269, "");
    std::string::basic_string[abi:nn180100]<0>(v270, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v82, &v269, 2uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v520, (long long *)v83, v82);
    std::string::basic_string[abi:nn180100]<0>(v80, "vy");
    std::string::basic_string[abi:nn180100]<0>(v267, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v79, (long long *)v267, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v521, (long long *)v80, v79);
    std::string::basic_string[abi:nn180100]<0>(v77, "w");
    std::string::basic_string[abi:nn180100]<0>(&v261, "");
    std::string::basic_string[abi:nn180100]<0>(v262, "");
    std::string::basic_string[abi:nn180100]<0>(v263, "");
    std::string::basic_string[abi:nn180100]<0>(v264, "");
    std::string::basic_string[abi:nn180100]<0>(v265, "");
    std::string::basic_string[abi:nn180100]<0>(v266, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v76, &v261, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v522, (long long *)v77, v76);
    std::string::basic_string[abi:nn180100]<0>(v74, "wh");
    std::string::basic_string[abi:nn180100]<0>(&v258, "");
    std::string::basic_string[abi:nn180100]<0>(v259, "");
    std::string::basic_string[abi:nn180100]<0>(v260, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v73, &v258, 3uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v523, (long long *)v74, v73);
    std::string::basic_string[abi:nn180100]<0>(v71, "wy");
    std::string::basic_string[abi:nn180100]<0>(&v256, "");
    std::string::basic_string[abi:nn180100]<0>(v257, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v70, &v256, 2uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v524, (long long *)v71, v70);
    std::string::basic_string[abi:nn180100]<0>(v68, "x");
    std::string::basic_string[abi:nn180100]<0>(&v246, "");
    std::string::basic_string[abi:nn180100]<0>(v247, "");
    std::string::basic_string[abi:nn180100]<0>(v248, "");
    std::string::basic_string[abi:nn180100]<0>(v249, "");
    std::string::basic_string[abi:nn180100]<0>(v250, "");
    std::string::basic_string[abi:nn180100]<0>(v251, "");
    std::string::basic_string[abi:nn180100]<0>(v252, "");
    std::string::basic_string[abi:nn180100]<0>(v253, "");
    std::string::basic_string[abi:nn180100]<0>(v254, "");
    std::string::basic_string[abi:nn180100]<0>(v255, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v67, &v246, 0xAuLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v525, (long long *)v68, v67);
    std::string::basic_string[abi:nn180100]<0>(v65, "xt");
    std::string::basic_string[abi:nn180100]<0>(v244, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v64, (long long *)v244, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v526, (long long *)v65, v64);
    std::string::basic_string[abi:nn180100]<0>(v62, "xts");
    std::string::basic_string[abi:nn180100]<0>(v242, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v61, (long long *)v242, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v527, (long long *)v62, v61);
    std::string::basic_string[abi:nn180100]<0>(v59, "xw");
    std::string::basic_string[abi:nn180100]<0>(v240, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v58, (long long *)v240, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v528, (long long *)v59, v58);
    std::string::basic_string[abi:nn180100]<0>(v56, "xy");
    std::string::basic_string[abi:nn180100]<0>(&v235, "");
    std::string::basic_string[abi:nn180100]<0>(v236, "");
    std::string::basic_string[abi:nn180100]<0>(v237, "");
    std::string::basic_string[abi:nn180100]<0>(v238, "");
    std::string::basic_string[abi:nn180100]<0>(v239, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v55, &v235, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v529, (long long *)v56, v55);
    std::string::basic_string[abi:nn180100]<0>(v53, "y");
    std::string::basic_string[abi:nn180100]<0>(&v229, "");
    std::string::basic_string[abi:nn180100]<0>(v230, "");
    std::string::basic_string[abi:nn180100]<0>(v231, "");
    std::string::basic_string[abi:nn180100]<0>(v232, "");
    std::string::basic_string[abi:nn180100]<0>(v233, "");
    std::string::basic_string[abi:nn180100]<0>(v234, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v52, &v229, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v530, (long long *)v53, v52);
    std::string::basic_string[abi:nn180100]<0>(v50, "z");
    std::string::basic_string[abi:nn180100]<0>(&v223, "");
    std::string::basic_string[abi:nn180100]<0>(v224, "");
    std::string::basic_string[abi:nn180100]<0>(v225, "");
    std::string::basic_string[abi:nn180100]<0>(v226, "");
    std::string::basic_string[abi:nn180100]<0>(v227, "");
    std::string::basic_string[abi:nn180100]<0>(v228, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v49, &v223, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v531, (long long *)v50, v49);
    std::string::basic_string[abi:nn180100]<0>(__p, "zy");
    std::string::basic_string[abi:nn180100]<0>(&v218, "");
    std::string::basic_string[abi:nn180100]<0>(v219, "");
    std::string::basic_string[abi:nn180100]<0>(v220, "");
    std::string::basic_string[abi:nn180100]<0>(v221, "");
    std::string::basic_string[abi:nn180100]<0>(v222, "");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v46, &v218, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v532, (long long *)__p, v46);
    uint64_t v1 = 0;
    incompleteRomajiKanaData(void)::data = 0u;
    *(_OWORD *)&qword_1E9FE39D0 = 0u;
    dword_1E9FE39E0 = 1065353216;
    do
    {
      std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::vector<std::string>> const&>((uint64_t)&v476[v1], (uint64_t)&v476[v1]);
      v1 += 2;
    }
    while (v1 != 114);
    for (unint64_t i = 2688; i != -48; i -= 48)
      std::pair<std::string const,std::vector<std::string>>::~pair((uint64_t)&v476[i / 0x18]);
    v217 = v46;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v217);
    for (uint64_t j = 0; j != -15; j -= 3)
    {
      if (SHIBYTE(v222[j + 2]) < 0) {
        operator delete((void *)v222[j]);
      }
    }
    if (v48 < 0) {
      operator delete(__p[0]);
    }
    *(void *)&long long v218 = v49;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v218);
    for (uint64_t k = 0; k != -18; k -= 3)
    {
      if (SHIBYTE(v228[k + 2]) < 0) {
        operator delete((void *)v228[k]);
      }
    }
    if (v51 < 0) {
      operator delete(v50[0]);
    }
    *(void *)&long long v223 = v52;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v223);
    for (uint64_t m = 0; m != -18; m -= 3)
    {
      if (SHIBYTE(v234[m + 2]) < 0) {
        operator delete((void *)v234[m]);
      }
    }
    if (v54 < 0) {
      operator delete(v53[0]);
    }
    *(void *)&long long v229 = v55;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v229);
    for (uint64_t n = 0; n != -15; n -= 3)
    {
      if (SHIBYTE(v239[n + 2]) < 0) {
        operator delete(v239[n]);
      }
    }
    if (v57 < 0) {
      operator delete(v56[0]);
    }
    *(void *)&long long v229 = v58;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v229);
    if (v241 < 0) {
      operator delete(v240[0]);
    }
    if (v60 < 0) {
      operator delete(v59[0]);
    }
    *(void *)&long long v229 = v61;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v229);
    if (v243 < 0) {
      operator delete(v242[0]);
    }
    if (v63 < 0) {
      operator delete(v62[0]);
    }
    *(void *)&long long v229 = v64;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v229);
    if (v245 < 0) {
      operator delete(v244[0]);
    }
    if (v66 < 0) {
      operator delete(v65[0]);
    }
    *(void *)&long long v229 = v67;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v229);
    for (iunint64_t i = 0; ii != -30; ii -= 3)
    {
      if (SHIBYTE(v255[ii + 2]) < 0) {
        operator delete((void *)v255[ii]);
      }
    }
    if (v69 < 0) {
      operator delete(v68[0]);
    }
    *(void *)&long long v246 = v70;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (juint64_t j = 0; jj != -6; jj -= 3)
    {
      if (SHIBYTE(v257[jj + 2]) < 0) {
        operator delete((void *)v257[jj]);
      }
    }
    if (v72 < 0) {
      operator delete(v71[0]);
    }
    *(void *)&long long v246 = v73;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (kuint64_t k = 0; kk != -9; kk -= 3)
    {
      if (SHIBYTE(v260[kk + 2]) < 0) {
        operator delete((void *)v260[kk]);
      }
    }
    if (v75 < 0) {
      operator delete(v74[0]);
    }
    *(void *)&long long v246 = v76;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (muint64_t m = 0; mm != -18; mm -= 3)
    {
      if (SHIBYTE(v266[mm + 2]) < 0) {
        operator delete(v266[mm]);
      }
    }
    if (v78 < 0) {
      operator delete(v77[0]);
    }
    *(void *)&long long v246 = v79;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    if (v268 < 0) {
      operator delete(v267[0]);
    }
    if (v81 < 0) {
      operator delete(v80[0]);
    }
    *(void *)&long long v246 = v82;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (nuint64_t n = 0; nn != -6; nn -= 3)
    {
      if (SHIBYTE(v270[nn + 2]) < 0) {
        operator delete((void *)v270[nn]);
      }
    }
    if (v84 < 0) {
      operator delete(v83[0]);
    }
    *(void *)&long long v246 = v85;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i1 = 0; i1 != -15; i1 -= 3)
    {
      if (SHIBYTE(v275[i1 + 2]) < 0) {
        operator delete(v275[i1]);
      }
    }
    if (v87 < 0) {
      operator delete(v86[0]);
    }
    *(void *)&long long v246 = v88;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    if (v277 < 0) {
      operator delete(v276[0]);
    }
    if (v90 < 0) {
      operator delete(v89[0]);
    }
    *(void *)&long long v246 = v91;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    if (v279 < 0) {
      operator delete(v278[0]);
    }
    if (v93 < 0) {
      operator delete(v92[0]);
    }
    *(void *)&long long v246 = v94;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i2 = 0; i2 != -12; i2 -= 3)
    {
      if (SHIBYTE(v283[i2 + 2]) < 0) {
        operator delete((void *)v283[i2]);
      }
    }
    if (v96 < 0) {
      operator delete(v95[0]);
    }
    *(void *)&long long v246 = v97;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i3 = 0; i3 != -18; i3 -= 3)
    {
      if (SHIBYTE(v289[i3 + 2]) < 0) {
        operator delete((void *)v289[i3]);
      }
    }
    if (v99 < 0) {
      operator delete(v98[0]);
    }
    *(void *)&long long v246 = v100;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i4 = 0; i4 != -15; i4 -= 3)
    {
      if (SHIBYTE(v294[i4 + 2]) < 0) {
        operator delete(v294[i4]);
      }
    }
    if (v102 < 0) {
      operator delete(v101[0]);
    }
    *(void *)&long long v246 = v103;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    if (v296 < 0) {
      operator delete(v295[0]);
    }
    if (v105 < 0) {
      operator delete(v104[0]);
    }
    *(void *)&long long v246 = v106;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i5 = 0; i5 != -18; i5 -= 3)
    {
      if (SHIBYTE(v302[i5 + 2]) < 0) {
        operator delete((void *)v302[i5]);
      }
    }
    if (v108 < 0) {
      operator delete(v107[0]);
    }
    *(void *)&long long v246 = v109;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i6 = 0; i6 != -15; i6 -= 3)
    {
      if (SHIBYTE(v307[i6 + 2]) < 0) {
        operator delete((void *)v307[i6]);
      }
    }
    if (v111 < 0) {
      operator delete(v110[0]);
    }
    *(void *)&long long v246 = v112;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i7 = 0; i7 != -18; i7 -= 3)
    {
      if (SHIBYTE(v313[i7 + 2]) < 0) {
        operator delete((void *)v313[i7]);
      }
    }
    if (v114 < 0) {
      operator delete(v113[0]);
    }
    *(void *)&long long v246 = v115;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i8 = 0; i8 != -15; i8 -= 3)
    {
      if (SHIBYTE(v318[i8 + 2]) < 0) {
        operator delete(v318[i8]);
      }
    }
    if (v117 < 0) {
      operator delete(v116[0]);
    }
    *(void *)&long long v246 = v118;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    if (v320 < 0) {
      operator delete(v319[0]);
    }
    if (v120 < 0) {
      operator delete(v119[0]);
    }
    *(void *)&long long v246 = v121;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i9 = 0; i9 != -15; i9 -= 3)
    {
      if (SHIBYTE(v325[i9 + 2]) < 0) {
        operator delete((void *)v325[i9]);
      }
    }
    if (v123 < 0) {
      operator delete(v122[0]);
    }
    *(void *)&long long v246 = v124;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i10 = 0; i10 != -18; i10 -= 3)
    {
      if (SHIBYTE(v331[i10 + 2]) < 0) {
        operator delete((void *)v331[i10]);
      }
    }
    if (v126 < 0) {
      operator delete(v125[0]);
    }
    *(void *)&long long v246 = v127;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i11 = 0; i11 != -15; i11 -= 3)
    {
      if (SHIBYTE(v336[i11 + 2]) < 0) {
        operator delete((void *)v336[i11]);
      }
    }
    if (v129 < 0) {
      operator delete(v128[0]);
    }
    *(void *)&long long v246 = v130;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i12 = 0; i12 != -21; i12 -= 3)
    {
      if (SHIBYTE(v343[i12 + 2]) < 0) {
        operator delete((void *)v343[i12]);
      }
    }
    if (v132 < 0) {
      operator delete(v131[0]);
    }
    *(void *)&long long v246 = v133;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i13 = 0; i13 != -15; i13 -= 3)
    {
      if (SHIBYTE(v348[i13 + 2]) < 0) {
        operator delete((void *)v348[i13]);
      }
    }
    if (v135 < 0) {
      operator delete(v134[0]);
    }
    *(void *)&long long v246 = v136;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i14 = 0; i14 != -18; i14 -= 3)
    {
      if (SHIBYTE(v354[i14 + 2]) < 0) {
        operator delete((void *)v354[i14]);
      }
    }
    if (v138 < 0) {
      operator delete(v137[0]);
    }
    *(void *)&long long v246 = v139;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i15 = 0; i15 != -15; i15 -= 3)
    {
      if (SHIBYTE(v359[i15 + 2]) < 0) {
        operator delete(v359[i15]);
      }
    }
    if (v141 < 0) {
      operator delete(v140[0]);
    }
    *(void *)&long long v246 = v142;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    if (v361 < 0) {
      operator delete(v360[0]);
    }
    if (v144 < 0) {
      operator delete(v143[0]);
    }
    *(void *)&long long v246 = v145;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    if (v363 < 0) {
      operator delete(v362[0]);
    }
    if (v147 < 0) {
      operator delete(v146[0]);
    }
    *(void *)&long long v246 = v148;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v246);
    for (uint64_t i16 = 0; i16 != -30; i16 -= 3)
    {
      if (SHIBYTE(v373[i16 + 2]) < 0) {
        operator delete((void *)v373[i16]);
      }
    }
    if (v150 < 0) {
      operator delete(v149[0]);
    }
    *(void *)&long long v364 = v151;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i17 = 0; i17 != -15; i17 -= 3)
    {
      if (SHIBYTE(v378[i17 + 2]) < 0) {
        operator delete((void *)v378[i17]);
      }
    }
    if (v153 < 0) {
      operator delete(v152[0]);
    }
    *(void *)&long long v364 = v154;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i18 = 0; i18 != -15; i18 -= 3)
    {
      if (SHIBYTE(v383[i18 + 2]) < 0) {
        operator delete((void *)v383[i18]);
      }
    }
    if (v156 < 0) {
      operator delete(v155[0]);
    }
    *(void *)&long long v364 = v157;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i19 = 0; i19 != -18; i19 -= 3)
    {
      if (SHIBYTE(v389[i19 + 2]) < 0) {
        operator delete((void *)v389[i19]);
      }
    }
    if (v159 < 0) {
      operator delete(v158[0]);
    }
    *(void *)&long long v364 = v160;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i20 = 0; i20 != -15; i20 -= 3)
    {
      if (SHIBYTE(v394[i20 + 2]) < 0) {
        operator delete((void *)v394[i20]);
      }
    }
    if (v162 < 0) {
      operator delete(v161[0]);
    }
    *(void *)&long long v364 = v163;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i21 = 0; i21 != -6; i21 -= 3)
    {
      if (SHIBYTE(v396[i21 + 2]) < 0) {
        operator delete((void *)v396[i21]);
      }
    }
    if (v165 < 0) {
      operator delete(v164[0]);
    }
    *(void *)&long long v364 = v166;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i22 = 0; i22 != -15; i22 -= 3)
    {
      if (SHIBYTE(v401[i22 + 2]) < 0) {
        operator delete((void *)v401[i22]);
      }
    }
    if (v168 < 0) {
      operator delete(v167[0]);
    }
    *(void *)&long long v364 = v169;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i23 = 0; i23 != -15; i23 -= 3)
    {
      if (SHIBYTE(v406[i23 + 2]) < 0) {
        operator delete((void *)v406[i23]);
      }
    }
    if (v171 < 0) {
      operator delete(v170[0]);
    }
    *(void *)&long long v364 = v172;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i24 = 0; i24 != -18; i24 -= 3)
    {
      if (SHIBYTE(v412[i24 + 2]) < 0) {
        operator delete((void *)v412[i24]);
      }
    }
    if (v174 < 0) {
      operator delete(v173[0]);
    }
    *(void *)&long long v364 = v175;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i25 = 0; i25 != -15; i25 -= 3)
    {
      if (SHIBYTE(v417[i25 + 2]) < 0) {
        operator delete((void *)v417[i25]);
      }
    }
    if (v177 < 0) {
      operator delete(v176[0]);
    }
    *(void *)&long long v364 = v178;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i26 = 0; i26 != -15; i26 -= 3)
    {
      if (SHIBYTE(v422[i26 + 2]) < 0) {
        operator delete((void *)v422[i26]);
      }
    }
    if (v180 < 0) {
      operator delete(v179[0]);
    }
    *(void *)&long long v364 = v181;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i27 = 0; i27 != -18; i27 -= 3)
    {
      if (SHIBYTE(v428[i27 + 2]) < 0) {
        operator delete(v428[i27]);
      }
    }
    if (v183 < 0) {
      operator delete(v182[0]);
    }
    *(void *)&long long v364 = v184;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    if (v430 < 0) {
      operator delete(v429[0]);
    }
    if (v186 < 0) {
      operator delete(v185[0]);
    }
    *(void *)&long long v364 = v187;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    if (v432 < 0) {
      operator delete(v431[0]);
    }
    if (v189 < 0) {
      operator delete(v188[0]);
    }
    *(void *)&long long v364 = v190;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i28 = 0; i28 != -15; i28 -= 3)
    {
      if (SHIBYTE(v437[i28 + 2]) < 0) {
        operator delete(v437[i28]);
      }
    }
    if (v192 < 0) {
      operator delete(v191[0]);
    }
    *(void *)&long long v364 = v193;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    if (v439 < 0) {
      operator delete(v438[0]);
    }
    if (v195 < 0) {
      operator delete(v194[0]);
    }
    *(void *)&long long v364 = v196;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i29 = 0; i29 != -15; i29 -= 3)
    {
      if (SHIBYTE(v444[i29 + 2]) < 0) {
        operator delete((void *)v444[i29]);
      }
    }
    if (v198 < 0) {
      operator delete(v197[0]);
    }
    *(void *)&long long v364 = v199;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i30 = 0; i30 != -18; i30 -= 3)
    {
      if (SHIBYTE(v450[i30 + 2]) < 0) {
        operator delete((void *)v450[i30]);
      }
    }
    if (v201 < 0) {
      operator delete(v200[0]);
    }
    *(void *)&long long v364 = v202;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i31 = 0; i31 != -15; i31 -= 3)
    {
      if (SHIBYTE(v455[i31 + 2]) < 0) {
        operator delete(v455[i31]);
      }
    }
    if (v204 < 0) {
      operator delete(v203[0]);
    }
    *(void *)&long long v364 = v205;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    if (v457 < 0) {
      operator delete(v456[0]);
    }
    if (v207 < 0) {
      operator delete(v206[0]);
    }
    *(void *)&long long v364 = v208;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i32 = 0; i32 != -21; i32 -= 3)
    {
      if (SHIBYTE(v464[i32 + 2]) < 0) {
        operator delete((void *)v464[i32]);
      }
    }
    if (v210 < 0) {
      operator delete(v209[0]);
    }
    *(void *)&long long v364 = v211;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i33 = 0; i33 != -15; i33 -= 3)
    {
      if (SHIBYTE(v469[i33 + 2]) < 0) {
        operator delete((void *)v469[i33]);
      }
    }
    if (v213 < 0) {
      operator delete(v212[0]);
    }
    *(void *)&long long v364 = v214;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v364);
    for (uint64_t i34 = 0; i34 != -18; i34 -= 3)
    {
      if (SHIBYTE(v475[i34 + 2]) < 0) {
        operator delete((void *)v475[i34]);
      }
    }
    if (v216 < 0) {
      operator delete(v215[0]);
    }
  }
}

uint64_t std::vector<std::string>::vector[abi:nn180100](uint64_t a1, long long *a2, unint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (a3)
  {
    std::vector<std::string>::__vallocate[abi:nn180100]((void *)a1, a3);
    *(void *)(a1 + 8) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>(a2, (long long *)((char *)a2 + 24 * a3), *(std::string **)(a1 + 8));
  }
  return a1;
}

std::string *std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(std::string *this, long long *a2, long long **a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  this[1].__r_.__value_.__l.__size_ = 0;
  this[1].__r_.__value_.__r.__words[2] = 0;
  this[1].__r_.__value_.__r.__words[0] = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(this[1].__r_.__value_.__r.__words, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
  return this;
}

void std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::vector<std::string>> const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (unsigned __int8 *)a1;
  unint64_t v4 = *(void *)(a1 + 8);
  if (*(char *)(a1 + 23) >= 0)
  {
    unint64_t v5 = *(unsigned __int8 *)(a1 + 23);
  }
  else
  {
    a1 = *(void *)a1;
    unint64_t v5 = v4;
  }
  unint64_t v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)a1, v5);
  unint64_t v7 = v6;
  unint64_t v8 = *((void *)&incompleteRomajiKanaData(void)::data + 1);
  if (*((void *)&incompleteRomajiKanaData(void)::data + 1))
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&incompleteRomajiKanaData(void)::data + 8));
    v9.i16[0] = vaddlv_u8(v9);
    unint64_t v10 = v9.u32[0];
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v11 = v6;
      if (v6 >= *((void *)&incompleteRomajiKanaData(void)::data + 1)) {
        unint64_t v11 = v6 % *((void *)&incompleteRomajiKanaData(void)::data + 1);
      }
    }
    else
    {
      unint64_t v11 = (*((void *)&incompleteRomajiKanaData(void)::data + 1) - 1) & v6;
    }
    uint64_t v12 = *(unsigned __int8 ***)(incompleteRomajiKanaData(void)::data + 8 * v11);
    if (v12)
    {
      for (unint64_t i = *v12; i; unint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v14 = *((void *)i + 1);
        if (v14 == v7)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, v3)) {
            return;
          }
        }
        else
        {
          if (v10 > 1)
          {
            if (v14 >= v8) {
              v14 %= v8;
            }
          }
          else
          {
            v14 &= v8 - 1;
          }
          if (v14 != v11) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v11 = 0;
  }
  size_t v15 = operator new(0x40uLL);
  *size_t v15 = 0;
  v15[1] = v7;
  unint64_t v16 = (std::string *)(v15 + 2);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v16, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v16->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    v15[4] = *(void *)(a2 + 16);
  }
  v15[5] = 0;
  v15[6] = 0;
  v15[7] = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(v15 + 5, *(long long **)(a2 + 24), *(long long **)(a2 + 32), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 3));
  float v17 = (float)(unint64_t)(qword_1E9FE39D8 + 1);
  if (!v8 || (float)(*(float *)&dword_1E9FE39E0 * (float)v8) < v17)
  {
    BOOL v18 = 1;
    if (v8 >= 3) {
      BOOL v18 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v8);
    unint64_t v20 = vcvtps_u32_f32(v17 / *(float *)&dword_1E9FE39E0);
    if (v19 <= v20) {
      int8x8_t prime = (int8x8_t)v20;
    }
    else {
      int8x8_t prime = (int8x8_t)v19;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v8 = *((void *)&incompleteRomajiKanaData(void)::data + 1);
    if (*(void *)&prime > *((void *)&incompleteRomajiKanaData(void)::data + 1)) {
      goto LABEL_36;
    }
    if (*(void *)&prime < *((void *)&incompleteRomajiKanaData(void)::data + 1))
    {
      unint64_t v28 = vcvtps_u32_f32((float)(unint64_t)qword_1E9FE39D8 / *(float *)&dword_1E9FE39E0);
      if (*((void *)&incompleteRomajiKanaData(void)::data + 1) < 3uLL
        || (uint8x8_t v29 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&incompleteRomajiKanaData(void)::data + 8)),
            v29.i16[0] = vaddlv_u8(v29),
            v29.u32[0] > 1uLL))
      {
        unint64_t v28 = std::__next_prime(v28);
      }
      else
      {
        uint64_t v30 = 1 << -(char)__clz(v28 - 1);
        if (v28 >= 2) {
          unint64_t v28 = v30;
        }
      }
      if (*(void *)&prime <= v28) {
        int8x8_t prime = (int8x8_t)v28;
      }
      if (*(void *)&prime >= v8)
      {
        unint64_t v8 = *((void *)&incompleteRomajiKanaData(void)::data + 1);
      }
      else
      {
        if (prime)
        {
LABEL_36:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          long long v22 = operator new(8 * *(void *)&prime);
          CFIndex v23 = (void *)incompleteRomajiKanaData(void)::data;
          *(void *)&incompleteRomajiKanaData(void)::data = v22;
          if (v23) {
            operator delete(v23);
          }
          uint64_t v24 = 0;
          *((int8x8_t *)&incompleteRomajiKanaData(void)::data + 1) = prime;
          do
            *(void *)(incompleteRomajiKanaData(void)::data + 8 * v24++) = 0;
          while (*(void *)&prime != v24);
          CFIndex v25 = (void **)qword_1E9FE39D0;
          if (qword_1E9FE39D0)
          {
            unint64_t v26 = *(void *)(qword_1E9FE39D0 + 8);
            uint8x8_t v27 = (uint8x8_t)vcnt_s8(prime);
            v27.i16[0] = vaddlv_u8(v27);
            if (v27.u32[0] > 1uLL)
            {
              if (v26 >= *(void *)&prime) {
                v26 %= *(void *)&prime;
              }
            }
            else
            {
              v26 &= *(void *)&prime - 1;
            }
            *(void *)(incompleteRomajiKanaData(void)::data + 8 * v26) = &qword_1E9FE39D0;
            for (j = *v25; j; unint64_t v26 = v32)
            {
              unint64_t v32 = j[1];
              if (v27.u32[0] > 1uLL)
              {
                if (v32 >= *(void *)&prime) {
                  v32 %= *(void *)&prime;
                }
              }
              else
              {
                v32 &= *(void *)&prime - 1;
              }
              if (v32 != v26)
              {
                if (!*(void *)(incompleteRomajiKanaData(void)::data + 8 * v32))
                {
                  *(void *)(incompleteRomajiKanaData(void)::data + 8 * v32) = v25;
                  goto LABEL_61;
                }
                *CFIndex v25 = (void *)*j;
                *uint64_t j = **(void **)(incompleteRomajiKanaData(void)::data + 8 * v32);
                **(void **)(incompleteRomajiKanaData(void)::data + 8 * v32) = j;
                uint64_t j = v25;
              }
              unint64_t v32 = v26;
LABEL_61:
              CFIndex v25 = (void **)j;
              uint64_t j = (void *)*j;
            }
          }
          unint64_t v8 = (unint64_t)prime;
          goto LABEL_65;
        }
        uint64_t v37 = (void *)incompleteRomajiKanaData(void)::data;
        *(void *)&incompleteRomajiKanaData(void)::data = 0;
        if (v37) {
          operator delete(v37);
        }
        unint64_t v8 = 0;
        *((void *)&incompleteRomajiKanaData(void)::data + 1) = 0;
      }
    }
LABEL_65:
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v11 = v7 % v8;
      }
      else {
        unint64_t v11 = v7;
      }
    }
    else
    {
      unint64_t v11 = (v8 - 1) & v7;
    }
  }
  uint64_t v33 = incompleteRomajiKanaData(void)::data;
  BOOL v34 = *(void **)(incompleteRomajiKanaData(void)::data + 8 * v11);
  if (v34)
  {
    *size_t v15 = *v34;
LABEL_78:
    *BOOL v34 = v15;
    goto LABEL_79;
  }
  uint64_t v35 = qword_1E9FE39D0;
  *size_t v15 = qword_1E9FE39D0;
  qword_1E9FE39D0 = (uint64_t)v15;
  *(void *)(v33 + 8 * v11) = &qword_1E9FE39D0;
  if (v35)
  {
    unint64_t v36 = *(void *)(v35 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v36 >= v8) {
        v36 %= v8;
      }
    }
    else
    {
      v36 &= v8 - 1;
    }
    BOOL v34 = (void *)(incompleteRomajiKanaData(void)::data + 8 * v36);
    goto LABEL_78;
  }
LABEL_79:
  ++qword_1E9FE39D8;
}

uint64_t std::pair<std::string const,std::vector<std::string>>::~pair(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 24);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v3);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

__n128 SICompletionModelProcessUTF8String(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _OWORD *a6, uint64_t a7, UErrorCode a8, const char *a9, int a10, const char *a11, unsigned __int8 a12, uint64_t a13)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 4))
    {
      long long v18 = a6[3];
      v25[2] = a6[2];
      void v25[3] = v18;
      v25[4] = a6[4];
      long long v19 = a6[1];
      v25[0] = *a6;
      v25[1] = v19;
      insertLegacyNGramsFromUTF8StringWithPatternAndLock(a1, a2, a3, a4, a5, (uint64_t)v25, a13, a7, a10, a11, a12, (os_unfair_lock_s *)(a1 + 48));
    }
    else
    {
      long long v13 = a6[3];
      long long v22 = a6[2];
      long long v23 = v13;
      long long v24 = a6[4];
      long long v14 = a6[1];
      long long v20 = *a6;
      long long v21 = v14;
      generateCompletionsFromUTF8StringWithPatternAndLock(a1, a2, a3, a4, a5, (uint64_t)&v20, a13, a7, a8, a9, a10, a11, a12, (os_unfair_lock_s *)(a1 + 48));
    }
  }
  else
  {
    long long v16 = a6[3];
    long long v22 = a6[2];
    long long v23 = v16;
    long long v24 = a6[4];
    long long v17 = a6[1];
    long long v20 = *a6;
    long long v21 = v17;
    generateCompletionsFromUTF8StringWithPatternAndLock(0, a2, a3, a4, a5, (uint64_t)&v20, a13, a7, a8, a9, a10, a11, a12, 0);
  }
  return result;
}

void insertLegacyNGramsFromUTF8StringWithPatternAndLock(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, const char *a10, unsigned __int8 a11, os_unfair_lock_s *a12)
{
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v77 = v14;
  uint64_t v79 = v15;
  long long v17 = v16;
  unint64_t v19 = v18;
  long long v21 = v20;
  uint64_t v22 = (uint64_t)v13;
  uint64_t v75 = v23;
  uint64_t v24 = v12;
  CFIndex v25 = a10;
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  BOOL v26 = v13 && *v13 && strlen(*v13) > 3;
  uint64_t v78 = v24;
  unsigned int v27 = *(_DWORD *)(v24 + 4);
  int v28 = v26 | ((v27 & 0x20) >> 5);
  if ((v27 & 0x80) == 0) {
    int v28 = (v27 >> 5) & 1;
  }
  if (a9) {
    int v28 = 0;
  }
  unint64_t v82 = v19;
  if (v19 > 0x12C) {
    int v29 = 1;
  }
  else {
    int v29 = v28;
  }
  size_t v80 = strlen(*(const char **)v22);
  v86[1] = 0;
  uint64_t v87 = 0;
  int v30 = completionPossibleMatch((void *)v22, (uint64_t)a10, (uint64_t)v21, a11);
  LODWORD(v83) = v29;
  if (v30) {
    int v31 = 0;
  }
  else {
    int v31 = splitPossibleMatch(v22);
  }
  uint64_t v32 = 48;
  if (a11) {
    uint64_t v32 = 64;
  }
  uint64_t v33 = *(void *)(v22 + v32);
  v86[0] = v33;
  int v84 = a11;
  if (a10)
  {
    if (!strncmp("ja", a10, 2uLL))
    {
      BOOL v35 = 0;
      int v34 = 1;
    }
    else
    {
      int v34 = 0;
      BOOL v35 = strncmp("zh", a10, 2uLL) == 0;
    }
  }
  else
  {
    int v34 = 0;
    BOOL v35 = 0;
  }
  char v81 = v21;
  if (((v30 | v84) & 1) != 0 || *(void *)(v22 + 32) > 1uLL)
  {
    unsigned __int8 v36 = 0;
    if (!v33) {
      return;
    }
  }
  else
  {
    unsigned __int8 v36 = v34 | v35;
    if ((v34 | v35 | v31) != 1 || !v33) {
      return;
    }
  }
  uint64_t v76 = a10;
  if (dword_1E9FC90DC > 4)
  {
    int v72 = *__error();
    uint64_t v73 = _SILogForLogForCategory(14);
    if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(MaximumSizeForEncoding) = 67109378;
      HIDWORD(MaximumSizeForEncoding) = a9;
      __int16 v91 = 2080;
      *(void *)uint64_t v92 = v81;
      _os_log_impl(&dword_1BD672000, v73, OS_LOG_TYPE_DEFAULT, "extracting field id %d: '%s'", (uint8_t *)&MaximumSizeForEncoding, 0x12u);
    }
    *__error() = v72;
    CFIndex v25 = v76;
  }
  uint64_t v85 = v105;
  if ((int)v80 >= 4)
  {
    int32_t v38 = 300;
    int v37 = (int)v83;
    if (!v25) {
      goto LABEL_42;
    }
  }
  else
  {
    int v37 = (int)v83;
    if (v82 - v87 <= 0x14)
    {
      int32_t v38 = 300;
    }
    else
    {
      int v37 = 1;
      int32_t v38 = 20;
    }
    if (!v25) {
      goto LABEL_42;
    }
  }
  CFStringRef v39 = *(const __CFString **)(v22 + 88);
  if (v39)
  {
    LODWORD(v83) = v37;
    CFIndex Length = CFStringGetLength(v39);
    CFIndex MaximumSizeForEncoding = 0;
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    MEMORY[0x1F4188790](MaximumSizeForEncoding);
    signed __int8 v42 = (UInt8 *)&v75 - v41;
    bzero((char *)&v75 - v41, v43);
    v115.locatiouint64_t n = 0;
    v115.length = Length;
    CFStringGetBytes(*(CFStringRef *)(v22 + 88), v115, 0x8000100u, 0x2Du, 0, v42, MaximumSizeForEncoding, &MaximumSizeForEncoding);
    v42[MaximumSizeForEncoding] = 0;
    int v44 = (const char *)v42;
    CFIndex v25 = v76;
    if (strcmp(v76, v44))
    {
      CFRelease(*(CFTypeRef *)(v22 + 88));
      *(void *)(v22 + 88) = 0;
      *(void *)(v22 + 88) = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v25, 0x600u);
    }
    LOBYTE(v37) = (_BYTE)v83;
  }
  else
  {
    *(void *)(v22 + 88) = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v25, 0x600u);
  }
LABEL_42:
  bzero(&MaximumSizeForEncoding, 0x1BA0uLL);
  LOBYTE(MaximumSizeForEncoding) = v37;
  BYTE1(MaximumSizeForEncoding) = v84;
  long long v45 = v17[3];
  long long v94 = v17[2];
  long long v95 = v45;
  long long v96 = v17[4];
  long long v46 = v17[1];
  *(_OWORD *)&v92[6] = *v17;
  long long v93 = v46;
  int v97 = a9;
  uint64_t v98 = v79;
  uint64_t v99 = v78;
  CFStringRef v100 = *(const __CFString **)(v22 + 88);
  unint64_t v101 = v25;
  uint64_t v47 = v85;
  v85[1504] = v36;
  char v48 = v47;
  v47[1505] = v34;
  int v88 = 0;
  v102[0] = 0;
  if ((v34 & 1) == 0)
  {
    uint64_t v49 = v81;
    goto LABEL_54;
  }
  bzero(v107, 0x258uLL);
  LODWORD(v89[0]) = 0;
  uint64_t v49 = v81;
  u_strFromUTF8((UChar *)v107, v38, (int32_t *)v89, v81, v82, (UErrorCode *)&v88);
  if (v88 == 15)
  {
    int v88 = 0;
    LODWORD(v89[0]) = v38;
  }
  else if (!LODWORD(v89[0]))
  {
    goto LABEL_48;
  }
  unorm2_getNFCInstance();
  if (v88 > 0)
  {
LABEL_48:
    int32_t v50 = v102[0];
    if (!v102[0]) {
      goto LABEL_54;
    }
    goto LABEL_57;
  }
  int v88 = 0;
  int32_t v51 = unorm2_normalize();
  if (v88 == 15) {
    int32_t v50 = v38;
  }
  else {
    int32_t v50 = v51;
  }
  v102[0] = v50;
  int v88 = 0;
  if (!v50)
  {
LABEL_54:
    u_strFromUTF8(v104, v38, v102, v49, v82, (UErrorCode *)&v88);
    if (v88 == 15)
    {
      v102[0] = v38;
      int v88 = 0;
      int32_t v50 = v38;
    }
    else
    {
      int32_t v50 = v102[0];
      if (!v102[0]) {
        return;
      }
    }
  }
LABEL_57:
  CFStringRef v52 = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v104, v50, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  if (v52)
  {
    CFStringRef v53 = v52;
    long long v112 = 0u;
    long long v113 = 0u;
    uint64_t v54 = v75;
    v107[0] = v75;
    v107[1] = v104;
    v107[2] = &v104[v102[0]];
    uint64_t v108 = (unsigned __int16)v38;
    int v109 = &v103;
    long long v110 = 0;
    char v111 = 0;
    *(void *)&long long v112 = 0;
    DWORD2(v112) = 0;
    BYTE8(v113) = v34;
    if (v48[1504])
    {
      *(void *)&long long v112 = v105;
      char v111 = v105;
      long long v110 = v106;
      *(void *)&long long v113 = &v106[1];
      WORD4(v112) = 300;
    }
    CFStringRef v55 = v100;
    CITokenizerSetLocale(v75, v100, 0);
    v89[0] = tokenrangescallback;
    v89[1] = 0;
    v89[2] = v107;
    CITokenizerGetTokensNew(v54, (uint64_t)v53, (uint64_t)v55, *(_DWORD *)(v54 + 32) & 0x18, (uint64_t)getPreTokenizerCallback, (uint64_t)getTokensWrapper, (uint64_t)getSubTokensWrapper, 0, (uint64_t)v89);
    unsigned int v56 = WORD1(v108);
    int v57 = v48[1504];
    CFStringRef v83 = v53;
    if (v57)
    {
      v106[301] = WORD5(v112);
      *char v111 = 0;
      uint64_t v58 = v111 - (unsigned char *)&MaximumSizeForEncoding - 5560;
      int v59 = v84;
      uint64_t v60 = v77;
    }
    else
    {
      uint64_t v60 = v77;
      if (WORD1(v108))
      {
        unint64_t v61 = 0;
        CFIndex v62 = 0;
        unint64_t v82 = WORD1(v108);
        uint64_t v63 = 2 * WORD1(v108);
        unint64_t v64 = 901;
        do
        {
          int v65 = &MaximumSizeForEncoding + v61;
          CFIndex v66 = v65[18];
          if (v66 > v62)
          {
            uint64_t v67 = _utf16_to_utf8(&v104[v62], v66 - v62, v48, v64, v34);
            v64 -= v67;
            v48 += v67;
            CFIndex v66 = v65[18];
          }
          uint64_t v68 = _utf16_to_utf8(&v104[v66], v65[19], v48, v64, v34);
          v106[v61 / 2 + 1] = (_WORD)v48 - (_WORD)v85;
          CFIndex v62 = v65[19] + v65[18];
          v64 -= v68;
          v48 += v68;
          v61 += 2;
        }
        while (v63 != v61);
        uint64_t v60 = v77;
        char v69 = v85;
        unsigned int v56 = v82;
      }
      else
      {
        char v69 = v48;
      }
      *char v48 = 0;
      LODWORD(v58) = v48 - v69;
      int v59 = v84;
      char v48 = v69;
    }
    v102[1] = v58;
    CFRelease(v83);
    if (v56)
    {
      if (v59) {
        int v70 = 4;
      }
      else {
        int v70 = v48[1504] == 0;
      }
      if ((handlePatterns((unsigned __int8 *)&MaximumSizeForEncoding, v56, 1u, (uint64_t)v105, (uint64_t)v86, v70, v60, a12) & 1) == 0&& *(void *)(v22 + 32) >= 2uLL&& (v59 & 1) == 0&& (int)v80 >= 4)
      {
        uint64_t v71 = *(const char **)(v22 + 8);
        if (v71)
        {
          if (strcmp(*(const char **)v22, v71))
          {
            if (splitPossibleMatch(v22)) {
              handlePatterns((unsigned __int8 *)&MaximumSizeForEncoding, v56, *(unsigned __int16 *)(v22 + 32), *(void *)(v22 + 40), *(void *)(v22 + 80), 2, v60, a12);
            }
          }
        }
      }
    }
  }
}

void generateCompletionsFromUTF8StringWithPatternAndLock(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, UErrorCode a9, const char *a10, int a11, const char *a12, unsigned __int8 a13, os_unfair_lock_s *a14)
{
  uint64_t v14 = MEMORY[0x1F4188790](a1);
  double v17 = v16;
  uint64_t v19 = v18;
  uint64_t v98 = v20;
  CFStringRef v99 = v21;
  uint64_t v23 = v22;
  unint64_t v25 = v24;
  uint64_t v27 = v26;
  uint64_t v28 = (uint64_t)v15;
  uint64_t v29 = v14;
  uint64_t v128 = *MEMORY[0x1E4F143B8];
  BOOL v30 = v15 && *v15 && strlen(*v15) > 3;
  int v31 = strcmp(a10, "com.apple.mobileslideshow");
  if (!v29) {
    goto LABEL_8;
  }
  int v32 = *(_DWORD *)(v29 + 4);
  if ((v32 & 0x80) != 0)
  {
    if ((v32 & 0x1000) != 0)
    {
      if ((v32 & 0x2000) == 0) {
        goto LABEL_11;
      }
    }
    else if (!v30)
    {
LABEL_11:
      BOOL v34 = 0;
      BOOL v35 = 0;
      BOOL v36 = 0;
      BOOL v37 = 0;
      BOOL v38 = 0;
      BOOL v33 = a11 == 3;
      goto LABEL_24;
    }
    BOOL v34 = 0;
    BOOL v38 = a11 == 0;
    BOOL v33 = a11 == 5;
    BOOL v35 = a11 == 6;
    BOOL v36 = a11 == 1;
    BOOL v37 = a11 > 7;
    if (v31)
    {
      BOOL v36 = 0;
      BOOL v37 = 0;
    }
    goto LABEL_24;
  }
  if ((v32 & 0x1000) == 0)
  {
LABEL_8:
    BOOL v33 = 0;
    BOOL v34 = 0;
    BOOL v35 = 0;
    BOOL v36 = 0;
    BOOL v37 = 0;
    BOOL v38 = 0;
    goto LABEL_24;
  }
  if ((v32 & 0x2000) != 0) {
    BOOL v33 = a11 == 6;
  }
  else {
    BOOL v33 = a11 == 3;
  }
  if ((v32 & 0x2000) != 0) {
    BOOL v34 = a11 == 7;
  }
  else {
    BOOL v34 = a11 == 4;
  }
  BOOL v35 = 0;
  BOOL v36 = 0;
  BOOL v37 = 0;
  BOOL v38 = (v32 & 0x2000) != 0 && a11 == 0;
LABEL_24:
  if (v25 > 0x12C) {
    BOOL v38 = 1;
  }
  if (v36 || v31 || v37)
  {
    BOOL v92 = v37;
    BOOL v93 = v36;
    BOOL v87 = v38;
    BOOL v88 = v35;
    BOOL v89 = v33;
    BOOL v90 = v34;
    uint64_t v95 = v29;
    uint64_t v91 = v19;
    v100[1] = 0;
    v100[2] = 0;
    int v96 = completionPossibleMatch((void *)v28, (uint64_t)a12, v27, a13);
    int v97 = (const char *)v27;
    if (v96) {
      int v39 = 0;
    }
    else {
      int v39 = splitPossibleMatch(v28);
    }
    uint64_t v40 = 48;
    if (a13) {
      uint64_t v40 = 64;
    }
    v100[0] = *(void *)(v28 + v40);
    if (v100[0])
    {
      if (a12)
      {
        if (!strncmp("ja", a12, 2uLL))
        {
          BOOL v41 = 0;
          int v94 = 1;
        }
        else
        {
          int v94 = 0;
          BOOL v41 = strncmp("zh", a12, 2uLL) == 0;
        }
      }
      else
      {
        int v94 = 0;
        BOOL v41 = 0;
      }
      if (((v96 | a13) & 1) != 0 || *(void *)(v28 + 32) > 1uLL)
      {
        int v42 = 0;
      }
      else
      {
        int v42 = v94 | v41;
        if ((v94 | v41 | v39) != 1) {
          return;
        }
      }
      BOOL v86 = v41;
      if (dword_1E9FC90DC >= 5)
      {
        LODWORD(v85) = v42;
        int v82 = *__error();
        CFStringRef v83 = _SILogForLogForCategory(14);
        if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v104) = 67109378;
          HIDWORD(v104) = a11;
          __int16 v105 = 2080;
          *(void *)std::string v106 = v97;
          _os_log_impl(&dword_1BD672000, v83, OS_LOG_TYPE_DEFAULT, "extracting field id %d: '%s'", (uint8_t *)&v104, 0x12u);
        }
        *__error() = v82;
        int v42 = v85;
        if (!a12)
        {
LABEL_52:
          bzero(&v104, 0x4860uLL);
          LOBYTE(v104) = a13;
          long long v49 = v23[3];
          long long v108 = v23[2];
          long long v109 = v49;
          long long v110 = v23[4];
          long long v50 = v23[1];
          *(_OWORD *)&v106[6] = *v23;
          long long v107 = v50;
          int v111 = a11;
          CFStringRef v112 = v99;
          uint64_t v113 = v95;
          uint64_t v115 = *(void *)(v28 + 88);
          uint64_t v116 = a12;
          v123[5720] = v42;
          unsigned __int8 v124 = v94;
          if (normalizeSourceString(StringTokenizerPhrasesInfo *,unsigned char *,unsigned long,unsigned long,BOOL)::onceToken != -1) {
            dispatch_once(&normalizeSourceString(StringTokenizerPhrasesInfo *,unsigned char *,unsigned long,unsigned long,BOOL)::onceToken, &__block_literal_global_1591);
          }
          int32_t v51 = v97;
          int v103 = 0;
          int32_t v117 = 0;
          bzero(v125, 0x258uLL);
          int32_t v102 = 0;
          int32_t v52 = 300;
          u_strFromUTF8((UChar *)v125, 300, &v102, v51, v25, (UErrorCode *)&v103);
          if (v103 == 15)
          {
            int32_t v102 = 300;
            int v103 = 0;
          }
          else
          {
            int32_t v52 = v102;
            if (!v102)
            {
              int32_t v52 = v117;
              goto LABEL_66;
            }
          }
          int v101 = 0;
          if (normalizeSourceString(StringTokenizerPhrasesInfo *,unsigned char *,unsigned long,unsigned long,BOOL)::norm2
            && ((v94 & 1) != 0 || (v53 = unorm2_quickCheck(), int32_t v52 = v102, v53 != 1)))
          {
            int32_t v54 = unorm2_normalize();
            if (v103 == 15) {
              int32_t v52 = 300;
            }
            else {
              int32_t v52 = v54;
            }
          }
          else
          {
            memcpy(v122, v125, 2 * v52);
            v122[v52] = 0;
          }
          int32_t v117 = v52;
LABEL_66:
          if (!v52) {
            return;
          }
          CFStringRef v55 = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v122, v52, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
          if (!v55) {
            return;
          }
          CFStringRef v56 = v55;
          long long v126 = 0u;
          long long v127 = 0u;
          uint64_t v57 = v98;
          v125[0] = v98;
          v125[1] = v122;
          v125[2] = &v122[v117];
          v125[3] = &v120;
          LOWORD(v126) = 300;
          v125[4] = &v121;
          *(void *)&long long v127 = &v119;
          BOOL v58 = SIStringContainsNewlineCharacters((uint64_t)v122, v117);
          BOOL v59 = v58;
          if (v58) {
            uint64_t v60 = 0;
          }
          else {
            uint64_t v60 = GetTokenCallback;
          }
          if (v58) {
            unint64_t v61 = GetSentenceCallback;
          }
          else {
            unint64_t v61 = 0;
          }
          CFStringRef v99 = v56;
          CITokenizerGetTokensNew(v57, (uint64_t)v56, v115, 4, 0, (uint64_t)v60, 0, (uint64_t)v61, (uint64_t)v125);
          uint64_t v62 = WORD1(v126);
          if (v59)
          {
            uint64_t v63 = WORD4(v127);
          }
          else
          {
            uint64_t v63 = WORD4(v127);
            if (*((uint64_t *)&v126 + 1) < WORD1(v126))
            {
              uint64_t v65 = WORD2(v126);
              uint64_t v64 = (uint64_t)v97;
              if (WORD2(v126))
              {
                CFIndex v66 = (void *)(v127 + 16 * WORD4(v127));
                *CFIndex v66 = *((void *)&v126 + 1);
                v66[1] = v65;
                uint64_t v63 = (v63 + 1);
                WORD4(v127) = v63;
              }
              goto LABEL_80;
            }
          }
          uint64_t v64 = (uint64_t)v97;
LABEL_80:
          uint64_t v85 = v63;
          if (v62)
          {
            uint64_t v98 = v62;
            if (v120)
            {
              uint64_t v67 = _utf16_to_utf8(v122, v120, v123, 0x385uLL, v124);
              unint64_t v68 = 901 - v67;
              char v69 = &v123[v67];
            }
            else
            {
              unint64_t v68 = 901;
              char v69 = v123;
            }
            CFIndex v70 = 0;
            uint64_t v71 = &v104;
            uint64_t v72 = v98;
            do
            {
              if (v70)
              {
                CFIndex v73 = v71[621];
                if (v73 > v70)
                {
                  uint64_t v74 = _utf16_to_utf8(&v122[v70], v73 - v70, v69, v68, v124);
                  v68 -= v74;
                  v69 += v74;
                }
              }
              uint64_t v75 = _utf16_to_utf8(&v122[v71[621]], v71[622], v69, v68, v124);
              CFIndex v70 = v71[622] + v71[621];
              v71[1712] = v69 - v123;
              v71[1713] = v75;
              v68 -= v75;
              v69 += v75;
              v71 += 2;
              --v72;
            }
            while (v72);
            uint64_t v64 = (uint64_t)v97;
            LODWORD(v62) = v98;
          }
          else
          {
            char v69 = v123;
          }
          *char v69 = 0;
          unsigned int v118 = v69 - v123;
          CFRelease(v99);
          if (v62)
          {
            if (v93 || v92)
            {
              if ((unsigned __int16)v85 == 1)
              {
                uint64_t v76 = v95;
                if (v95) {
                  uint64_t v76 = *(void *)(v95 + 32);
                }
                uint64_t v114 = v76;
                insertPatternsForText((uint64_t)&v104, v62, (uint64_t)v123, (uint64_t)v100, a9, v91, a14);
              }
            }
            else
            {
              if (v88) {
                int v77 = 8;
              }
              else {
                int v77 = 7;
              }
              if (v89 || v90 || v88)
              {
                uint64_t v78 = v95;
                if (v95) {
                  uint64_t v78 = *(void *)(v95 + 24);
                }
                uint64_t v114 = v78;
                handlePatternsForTextWithScore((uint64_t)&v104, v62, (uint64_t)v123, (uint64_t)v100, v77, (UErrorCode)v17, v91, a14);
              }
              else
              {
                uint64_t v79 = v91;
                uint64_t v80 = v95;
                if (v95) {
                  uint64_t v81 = *(void *)(v95 + 24);
                }
                else {
                  uint64_t v81 = 0;
                }
                uint64_t v114 = v81;
                if (v96)
                {
                  if (tokenPossibleMatch(v28, (uint64_t)a12, v64, v94 | v86))addCrossFieldOidWithLock(v80, v79, a14); {
                  handlePatternsForPhrases((uint64_t)&v104, v62, (unsigned __int16)v85, (uint64_t)v123, (uint64_t)v100, v87, a9, v79, a14);
                  }
                }
                else
                {
                  handleCrossFieldPatterns((const char **)v28, (uint64_t)&v104, v62, (unsigned __int16)v85, a9, v91, a14);
                }
              }
            }
          }
          return;
        }
      }
      else if (!a12)
      {
        goto LABEL_52;
      }
      CFStringRef v43 = *(const __CFString **)(v28 + 88);
      if (v43)
      {
        LODWORD(v85) = v42;
        CFIndex Length = CFStringGetLength(v43);
        CFIndex v104 = 0;
        CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
        uint64_t v84 = (uint64_t)&v84;
        CFIndex v104 = MaximumSizeForEncoding;
        MEMORY[0x1F4188790](MaximumSizeForEncoding);
        uint64_t v47 = (UInt8 *)&v84 - v46;
        bzero((char *)&v84 - v46, v48);
        v129.locatiouint64_t n = 0;
        v129.length = Length;
        CFStringGetBytes(*(CFStringRef *)(v28 + 88), v129, 0x8000100u, 0x2Du, 0, v47, v104, &v104);
        v47[v104] = 0;
        if (strcmp(a12, (const char *)v47))
        {
          CFRelease(*(CFTypeRef *)(v28 + 88));
          *(void *)(v28 + 88) = 0;
          *(void *)(v28 + 88) = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a12, 0x600u);
        }
        LOBYTE(v42) = v85;
      }
      else
      {
        *(void *)(v28 + 88) = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a12, 0x600u);
      }
      goto LABEL_52;
    }
  }
}

uint64_t completionPossibleMatch(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4) {
    uint64_t v4 = 8;
  }
  else {
    uint64_t v4 = 6;
  }
  if (!*a1) {
    return 0;
  }
  if (!a1[v4])
  {
    os_unfair_lock_lock((os_unfair_lock_t)&s_search_context_unfair_lock);
    if (a1[v4])
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&s_search_context_unfair_lock);
      goto LABEL_9;
    }
    uint64_t v6 = icu_search_context_create();
    __dmb(0xBu);
    a1[v4] = v6;
    os_unfair_lock_unlock((os_unfair_lock_t)&s_search_context_unfair_lock);
    if (v6) {
      goto LABEL_9;
    }
    return 0;
  }
LABEL_9:
  return icu_search_match();
}

uint64_t splitPossibleMatch(uint64_t a1)
{
  if (!*(void *)(a1 + 8)) {
    return 0;
  }
  if (!*(void *)(a1 + 72))
  {
    os_unfair_lock_lock((os_unfair_lock_t)&s_search_context_unfair_lock);
    if (*(void *)(a1 + 72))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&s_search_context_unfair_lock);
      goto LABEL_6;
    }
    uint64_t v2 = icu_search_context_create();
    __dmb(0xBu);
    *(void *)(a1 + 72) = v2;
    os_unfair_lock_unlock((os_unfair_lock_t)&s_search_context_unfair_lock);
    if (v2) {
      goto LABEL_6;
    }
    return 0;
  }
LABEL_6:
  return icu_search_match();
}

uint64_t _utf16_to_utf8(unsigned __int16 *a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, int a5)
{
  if (a5)
  {
    uint64_t v20 = 0;
    if (utf8_encodestr(a1, 2 * a2, a3, &v20, a4)) {
      return 0;
    }
    else {
      return v20;
    }
  }
  else
  {
    uint64_t v6 = a3;
    if (a4 >= 4 * a2)
    {
      if (a2 >= 1)
      {
        uint64_t v6 = a3;
        uint64_t v14 = a1;
        uint64_t v15 = &a1[a2];
        do
        {
          unsigned int v17 = *v14++;
          unsigned int v16 = v17;
          if (v17 > 0x7F)
          {
            if (v16 > 0x7FF)
            {
              if ((v16 & 0xF800) == 0xD800)
              {
                if ((v16 & 0x400) == 0 && v14 < v15)
                {
                  int v18 = *v14;
                  if ((v18 & 0xFC00) == 0xDC00)
                  {
                    uint64_t v14 = a1 + 2;
                    unsigned int v19 = v18 + (v16 << 10) - 56613888;
                    *uint64_t v6 = (v19 >> 18) | 0xF0;
                    v6[1] = (v19 >> 12) & 0x3F | 0x80;
                    v6[2] = (v19 >> 6) & 0x3F | 0x80;
                    void v6[3] = v18 & 0x3F | 0x80;
                    v6 += 4;
                  }
                }
              }
              else
              {
                *uint64_t v6 = (v16 >> 12) | 0xE0;
                v6[1] = (v16 >> 6) & 0x3F | 0x80;
                v6[2] = v16 & 0x3F | 0x80;
                v6 += 3;
              }
            }
            else
            {
              *uint64_t v6 = (v16 >> 6) | 0xC0;
              v6[1] = v16 & 0x3F | 0x80;
              v6 += 2;
            }
          }
          else
          {
            *v6++ = v16;
          }
          a1 = (unsigned __int16 *)v14;
        }
        while (v14 < v15);
      }
    }
    else if (a2 >= 1)
    {
      unint64_t v7 = &a3[a4];
      uint64_t v6 = a3;
      unint64_t v8 = a1;
      uint8x8_t v9 = &a1[a2];
      do
      {
        unsigned int v11 = *v8++;
        unsigned int v10 = v11;
        if (v11 > 0x7F)
        {
          if (v10 > 0x7FF)
          {
            if ((v10 & 0xF800) == 0xD800)
            {
              if ((v10 & 0x400) == 0 && v8 < v9)
              {
                int v12 = *v8;
                if ((v12 & 0xFC00) == 0xDC00)
                {
                  if (v6 + 3 >= v7) {
                    return v6 - a3;
                  }
                  unint64_t v8 = a1 + 2;
                  unsigned int v13 = v12 + (v10 << 10) - 56613888;
                  *uint64_t v6 = (v13 >> 18) | 0xF0;
                  v6[1] = (v13 >> 12) & 0x3F | 0x80;
                  v6[2] = (v13 >> 6) & 0x3F | 0x80;
                  void v6[3] = v12 & 0x3F | 0x80;
                  v6 += 4;
                }
              }
            }
            else
            {
              if (v6 + 2 >= v7) {
                return v6 - a3;
              }
              *uint64_t v6 = (v10 >> 12) | 0xE0;
              v6[1] = (v10 >> 6) & 0x3F | 0x80;
              v6[2] = v10 & 0x3F | 0x80;
              v6 += 3;
            }
          }
          else
          {
            if (v6 + 1 >= v7) {
              return v6 - a3;
            }
            *uint64_t v6 = (v10 >> 6) | 0xC0;
            v6[1] = v10 & 0x3F | 0x80;
            v6 += 2;
          }
        }
        else
        {
          if (v6 >= v7) {
            return v6 - a3;
          }
          *v6++ = v10;
        }
        a1 = (unsigned __int16 *)v8;
      }
      while (v8 < v9);
    }
    return v6 - a3;
  }
}

void insertPatternsForText(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, UErrorCode a5, uint64_t a6, os_unfair_lock_s *a7)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (a4 && *(void *)(a1 + 120))
  {
    uint64_t v11 = a1 + 12192;
    int v12 = (void *)(a1 + 4976);
    uint64_t v13 = a2;
    while (1)
    {
      if (*v12 == 1)
      {
        unsigned int v14 = *(unsigned __int16 *)(v11 + 2 * *(v12 - 1)) - 38;
        BOOL v15 = v14 > 0x39;
        uint64_t v16 = (1 << v14) & 0x2000000000000A1;
        if (!v15 && v16 != 0) {
          break;
        }
      }
      v12 += 2;
      if (!--v13)
      {
        if (lazySearchContextAtIndex(a3, a4, *(void *)(a1 + 136), 0))
        {
          CFLocaleRef v18 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFLocaleIdentifier *)(a1 + 128));
          if (v18)
          {
            CFLocaleRef v19 = v18;
            CFTypeRef v20 = CFRetain(v18);
            if (v20)
            {
              uint64_t v21 = *(void *)(a1 + 160);
              uint64_t v47 = *(void *)(a1 + 152);
              CFTypeRef v48 = v20;
              uint64_t v51 = 0;
              uint64_t v52 = 0;
              uint64_t v22 = icu_search_match();
              if (v22
                && v21 <= 13
                && (uint64_t)(*(void *)(a1 + 4968 + 16 * (v47 + v21) - 16)
                           - *(void *)(a1 + 4968)
                           + *(void *)(a1 + 4968 + 16 * (v47 + v21) - 8)) <= 29)
              {
                uint64_t v46 = (uint64_t)&v46;
                MEMORY[0x1F4188790](v22);
                uint64_t v23 = &v46 - 4 * v21;
                bzero(v23, v24);
                if (v21 < 1)
                {
                  unint64_t v28 = 0;
                  unsigned __int8 v26 = 0;
                }
                else
                {
                  uint64_t v25 = 0;
                  unsigned __int8 v26 = 0;
                  char v27 = 0;
                  unint64_t v28 = 0;
                  uint64_t v29 = v47 - v21 + 1;
                  uint64_t v30 = a1 + 8 * v47 + 9784;
                  int v31 = (uint64_t *)(a1 + 16 * v47 + 4976);
                  do
                  {
                    uint64_t v32 = *(v31 - 1);
                    if (v25)
                    {
                      uint64_t v33 = *(v31 - 2) + *(v31 - 3);
                      if (v32 > v33)
                      {
                        BOOL v34 = &v23[2 * v28];
                        *BOOL v34 = v11 + 2 * v33;
                        *((_DWORD *)v34 + 2) = v32 - v33;
                        *((unsigned char *)v34 + 12) = 1;
                        ++v28;
                        ++v27;
                      }
                    }
                    uint64_t v35 = *(void *)(v30 + 8 * v25);
                    uint64_t v36 = v11 + 2 * v32;
                    BOOL v37 = &v23[2 * v28];
                    BOOL v38 = (v35 & 0x800) != 0 || v35 == 0;
                    uint64_t v39 = *v31;
                    v31 += 2;
                    uint64_t *v37 = v36;
                    *((_DWORD *)v37 + 2) = v39;
                    char v40 = !v38;
                    *((unsigned char *)v37 + 12) = v40;
                    ++v28;
                    if (!(v29 + v25)) {
                      unsigned __int8 v26 = v27 + v25;
                    }
                    ++v25;
                  }
                  while (v25 != v21);
                }
                int v50 = 0;
                __int16 v49 = 0;
                double v41 = (*(double (**)(void))(*(void *)(a1 + 104) + 16))();
                os_unfair_lock_lock(a7);
                if (v28)
                {
                  uint64_t v42 = *(void *)(a1 + 120);
                  int v43 = *(_DWORD *)(a1 + 96);
                  __n128 v44 = *(__n128 *)(a1 + 64);
                  v53[2] = *(_OWORD *)(a1 + 48);
                  v53[3] = (__int128)v44;
                  v53[4] = *(_OWORD *)(a1 + 80);
                  __n128 v45 = *(__n128 *)(a1 + 32);
                  v53[0] = *(_OWORD *)(a1 + 16);
                  v44.n128_u64[1] = *((void *)&v53[0] + 1);
                  v53[1] = (__int128)v45;
                  v44.n128_u64[0] = 1.0;
                  v45.n128_f64[0] = v41;
                  word_trie_s::insert((uint64_t *)(v42 + 16), (uint64_t)v23, v28, v53, a6, a5, v43, 3, v45, v44, v50, v49, HIBYTE(v49), 6, 0, v26, 0);
                }
                os_unfair_lock_unlock(a7);
              }
              CFRelease(v19);
              CFRelease(v48);
            }
          }
        }
        return;
      }
    }
  }
}

void handlePatternsForTextWithScore(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int a5, UErrorCode a6, uint64_t a7, os_unfair_lock_s *a8)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    if (*(void *)(a1 + 120))
    {
      if (lazySearchContextAtIndex(a3, a4, *(void *)(a1 + 136), 0))
      {
        uint64_t v14 = *(void *)(a1 + 152);
        uint64_t v45 = 0;
        uint64_t v46 = 0;
        uint64_t v15 = icu_search_match();
        if (a2 <= 0xD)
        {
          if (v15)
          {
            uint64_t v16 = a2;
            uint64_t v17 = a1 + 4968 + 16 * (a2 + v14);
            if ((uint64_t)(*(void *)(v17 - 16) - *(void *)(a1 + 4968) + *(void *)(v17 - 8)) <= 29)
            {
              uint64_t v41 = a7;
              uint64_t v42 = &v40;
              uint64_t v18 = a1 + 12192;
              MEMORY[0x1F4188790](v15);
              CFLocaleRef v19 = &v40 - 4 * a2;
              bzero(&v40 - 4 * v16, v20);
              uint64_t v21 = 0;
              unsigned __int8 v22 = 0;
              char v23 = 0;
              unint64_t v24 = 0;
              uint64_t v25 = (uint64_t *)(a1 + 16 * v14 + 4976);
              do
              {
                uint64_t v26 = *(v25 - 1);
                if (v21)
                {
                  uint64_t v27 = *(v25 - 2) + *(v25 - 3);
                  if (v26 > v27)
                  {
                    unint64_t v28 = &v19[2 * v24];
                    uint64_t *v28 = v18 + 2 * v27;
                    *((_DWORD *)v28 + 2) = v26 - v27;
                    *((unsigned char *)v28 + 12) = 1;
                    ++v24;
                    ++v23;
                  }
                }
                uint64_t v29 = *(void *)(a1 + 8 * v14 + 9784 + 8 * v21);
                uint64_t v30 = v18 + 2 * v26;
                int v31 = &v19[2 * v24];
                BOOL v32 = (v29 & 0x800) != 0 || v29 == 0;
                uint64_t v33 = *v25;
                v25 += 2;
                *int v31 = v30;
                *((_DWORD *)v31 + 2) = v33;
                char v34 = !v32;
                *((unsigned char *)v31 + 12) = v34;
                ++v24;
                if (v16 + ~v14 == v21) {
                  unsigned __int8 v22 = v23 + v21;
                }
                ++v21;
              }
              while (v16 != v21);
              int v44 = 0;
              __int16 v43 = 0;
              double v35 = (*(double (**)(void))(*(void *)(a1 + 104) + 16))();
              os_unfair_lock_lock(a8);
              if (v24)
              {
                uint64_t v36 = *(void *)(a1 + 120);
                int v37 = *(_DWORD *)(a1 + 96);
                __n128 v38 = *(__n128 *)(a1 + 64);
                v47[2] = *(_OWORD *)(a1 + 48);
                v47[3] = (__int128)v38;
                v47[4] = *(_OWORD *)(a1 + 80);
                __n128 v39 = *(__n128 *)(a1 + 32);
                v47[0] = *(_OWORD *)(a1 + 16);
                v38.n128_u64[1] = *((void *)&v47[0] + 1);
                v47[1] = (__int128)v39;
                v38.n128_u64[0] = 0;
                v39.n128_f64[0] = v35;
                word_trie_s::insert((uint64_t *)(v36 + 16), (uint64_t)(&v40 - 4 * v16), v24, v47, v41, a6, v37, 3, v39, v38, v44, v43, HIBYTE(v43), a5, 0, v22, 0);
              }
              os_unfair_lock_unlock(a8);
            }
          }
        }
      }
    }
  }
}

void handleCrossFieldPatterns(const char **a1, uint64_t a2, unsigned int a3, unsigned int a4, UErrorCode a5, uint64_t a6, os_unfair_lock_s *a7)
{
  uint64_t v100 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a2 + 120))
  {
    uint64_t v11 = a2 + 9784;
    uint64_t v12 = a2 + 13696;
    uint64_t v13 = *(void *)(a2 + 112);
    uint64_t v14 = a2 + 12794;
    UErrorCode v67 = a5;
    uint64_t v71 = a2 + 12192;
    uint64_t v72 = (uint64_t *)(a2 + 4968);
    unint64_t v68 = a1;
    unsigned int v70 = a4;
    if (v13) {
      uint64_t v15 = *(void *)(v13 + 8);
    }
    else {
      uint64_t v15 = 0;
    }
    CFLocaleRef v16 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFLocaleIdentifier *)(a2 + 128));
    uint64_t v92 = v14;
    uint64_t v93 = v12;
    uint64_t v94 = v71;
    uint64_t v95 = v72;
    uint64_t v17 = a3;
    CFLocaleRef v18 = v16;
    uint64_t v96 = v11;
    uint64_t v97 = v17;
    uint64_t v19 = SILanguageModelCopyLocale();
    size_t v20 = (const void *)v19;
    if (v19)
    {
      uint64_t v69 = a2;
      uint64_t v64 = a6;
      uint64_t v65 = a7;
      uint64_t v88 = 0;
      BOOL v89 = &v88;
      uint64_t v90 = 0x2000000000;
      uint64_t v91 = 0;
      uint64_t v82 = 0;
      CFStringRef v83 = &v82;
      uint64_t v84 = 0x3802000000;
      uint64_t v85 = __Block_byref_object_copy_;
      BOOL v86 = __Block_byref_object_dispose_;
      long long v87 = xmmword_1BDA82320;
      uint64_t v78 = 0;
      uint64_t v79 = &v78;
      uint64_t v80 = 0x2000000000;
      int v81 = 0;
      if (v70)
      {
        CFLocaleRef v66 = v18;
        uint64_t v21 = v70;
        uint64_t v22 = MEMORY[0x1E4F143A8];
        uint64_t v23 = v19;
        unint64_t v24 = (uint64_t *)(v69 + 160);
        do
        {
          uint64_t v25 = *(v24 - 1);
          uint64_t v26 = *v24;
          uint64_t v93 = v12 + 16 * v25;
          uint64_t v95 = &v72[2 * v25];
          uint64_t v96 = v11 + 8 * v25;
          uint64_t v97 = v26;
          v77[0] = v22;
          v77[1] = 0x40000000;
          v77[2] = ___ZL24handleCrossFieldPatternsP23si_completion_pattern_sP26StringTokenizerPhrasesInfotjbbjxP16os_unfair_lock_s_block_invoke;
          v77[3] = &unk_1E6343308;
          v77[4] = &v88;
          v77[5] = &v82;
          v77[7] = v25;
          v77[8] = v26;
          v77[6] = &v78;
          MEMORY[0x1C18803E0](v15, v23, &v92, v77);
          v24 += 2;
          --v21;
        }
        while (v21);
        CFLocaleRef v18 = v66;
        size_t v20 = (const void *)v23;
        if (v83[5] != -1 && (unint64_t)(v83[6] - 2) <= 0xB)
        {
          uint64_t v27 = (const void *)v23;
          unint64_t v28 = *v68;
          size_t v29 = strlen(*v68);
          if (v29) {
            uint64_t v30 = (int)(v29 - (v28[(int)v29 - 1] == 42));
          }
          else {
            uint64_t v30 = 0;
          }
          BOOL v32 = v28 - 1;
          uint64_t v33 = v65;
          uint64_t v34 = v69;
          do
          {
            uint64_t v35 = v30;
            if (!v30) {
              break;
            }
            --v30;
          }
          while (v32[v35] == 32);
          int v76 = v35 + 1;
          MEMORY[0x1F4188790](v29);
          int v37 = (char *)&v63 - v36;
          bzero((char *)&v63 - v36, v38);
          uint64_t v39 = UTF16FromUTF8();
          if (v39)
          {
            uint64_t v40 = (char *)v39;
            uint64_t v72 = &v63;
            MEMORY[0x1F4188790](v39);
            uint64_t v42 = (char **)((char *)&v63 - ((v41 + 47) & 0xFFFFFFFFFFFFFFE0));
            bzero(v42, v43);
            int v44 = v40;
            uint64_t *v42 = v40;
            *((_DWORD *)v42 + 2) = v76;
            *((unsigned char *)v42 + 12) = 0;
            __int16 v75 = 32;
            v42[2] = (char *)&v75;
            *((_DWORD *)v42 + 6) = 1;
            *((unsigned char *)v42 + 28) = 1;
            uint64_t v45 = v83[6];
            if (v45 < 1)
            {
              unint64_t v48 = 2;
            }
            else
            {
              uint64_t v46 = 0;
              uint64_t v47 = (uint64_t *)(v34 + 16 * v83[5] + 4976);
              unint64_t v48 = 2;
              uint64_t v49 = v71;
              do
              {
                uint64_t v50 = *(v47 - 1);
                if (v46)
                {
                  uint64_t v51 = *(v47 - 2) + *(v47 - 3);
                  if (v50 > v51)
                  {
                    uint64_t v52 = &v42[2 * v48];
                    *uint64_t v52 = (char *)(v49 + 2 * v51);
                    *((_DWORD *)v52 + 2) = v50 - v51;
                    *((unsigned char *)v52 + 12) = 1;
                    ++v48;
                  }
                }
                uint64_t v53 = *v47;
                v47 += 2;
                uint64_t v54 = &v42[2 * v48];
                *uint64_t v54 = (char *)(v49 + 2 * v50);
                *((_DWORD *)v54 + 2) = v53;
                *((unsigned char *)v54 + 12) = 1;
                ++v48;
                ++v46;
              }
              while (v45 != v46);
            }
            BYTE4(v42[2 * v48 - 1]) = 0;
            int v74 = 0;
            __int16 v73 = 0;
            uint64_t v55 = v69;
            double v56 = (*(double (**)(void))(*(void *)(v69 + 104) + 16))();
            os_unfair_lock_lock(v33);
            if (v48)
            {
              long long v57 = *(_OWORD *)(v55 + 16);
              v98[1] = *(_OWORD *)(v55 + 32);
              __n128 v58 = *(__n128 *)(v55 + 64);
              v98[2] = *(_OWORD *)(v55 + 48);
              v98[3] = (__int128)v58;
              long long v99 = *(_OWORD *)(v55 + 80);
              v59.n128_u64[1] = *((void *)&v99 + 1);
              v58.n128_u64[0] = v89[3];
              int v60 = *((_DWORD *)v79 + 6);
              int v61 = *(_DWORD *)(v55 + 96);
              uint64_t v62 = (uint64_t *)(*(void *)(v55 + 120) + 16);
              v98[0] = v57;
              v59.n128_f64[0] = v56;
              word_trie_s::insert(v62, (uint64_t)v42, v48, v98, v64, v67, v61, v60, v59, v58, v74, v73, HIBYTE(v73), 3, v76, 0, 0);
            }
            os_unfair_lock_unlock(v33);
            if (v44 != v37) {
              free(v44);
            }
          }
          size_t v20 = v27;
        }
      }
      _Block_object_dispose(&v78, 8);
      _Block_object_dispose(&v82, 8);
      _Block_object_dispose(&v88, 8);
      int v31 = v20;
      if (!v18) {
        goto LABEL_35;
      }
    }
    else
    {
      int v31 = 0;
      if (!v18)
      {
LABEL_35:
        if (v20) {
          CFRelease(v31);
        }
        return;
      }
    }
    CFRelease(v18);
    goto LABEL_35;
  }
}

uint64_t tokenPossibleMatch(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  v14[1] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(const char **)a1;
  size_t v7 = strlen(*(const char **)a1);
  unint64_t v8 = (char *)v14 - ((MEMORY[0x1F4188790](v7) + 17) & 0xFFFFFFFFFFFFFFF0);
  bzero(v8, v9);
  memcpy(v8, v6, v7);
  if (v7 && (uint64_t v10 = v7 - 1, v8[v7 - 1] == 42))
  {
    if ((a4 & 1) == 0)
    {
      if (v7 == 2)
      {
        uint64_t v10 = 1;
      }
      else if (v8[v7 - 2] != 32)
      {
        v8[v10] = 32;
        uint64_t v10 = v7;
      }
    }
    uint64_t v11 = &v8[v10];
  }
  else
  {
    uint64_t v11 = &v8[v7];
    if ((a4 & 1) == 0) {
      *v11++ = 32;
    }
  }
  *uint64_t v11 = 0;
  if (!*(void *)(a1 + 56))
  {
    os_unfair_lock_lock((os_unfair_lock_t)&s_search_context_unfair_lock);
    if (*(void *)(a1 + 56))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&s_search_context_unfair_lock);
    }
    else
    {
      uint64_t v12 = icu_search_context_create();
      __dmb(0xBu);
      *(void *)(a1 + 56) = v12;
      os_unfair_lock_unlock((os_unfair_lock_t)&s_search_context_unfair_lock);
      if (!v12) {
        return 0;
      }
    }
  }
  return icu_search_match();
}

void addCrossFieldOidWithLock(uint64_t a1, uint64_t a2, os_unfair_lock_s *a3)
{
  uint64_t valuePtr = a2;
  if (a1)
  {
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
    if (v6)
    {
      CFNumberRef v7 = v6;
      os_unfair_lock_lock(a3);
      CFMutableStringRef Mutable = *(__CFSet **)(a1 + 40);
      if (Mutable
        || (CFMutableStringRef Mutable = CFSetCreateMutable(v5, 0, MEMORY[0x1E4F1D548]), (*(void *)(a1 + 40) = Mutable) != 0))
      {
        CFSetAddValue(Mutable, v7);
      }
      os_unfair_lock_unlock(a3);
      CFRelease(v7);
    }
  }
}

void handlePatternsForPhrases(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, int a6, UErrorCode a7, uint64_t a8, os_unfair_lock_s *a9)
{
  uint64_t v117 = *MEMORY[0x1E4F143B8];
  if (a5)
  {
    if (*(void *)(a1 + 120))
    {
      int v98 = a6;
      if (lazySearchContextAtIndex(a4, a5, *(void *)(a1 + 136), 0))
      {
        uint64_t v83 = a8;
        os_unfair_lock_t v86 = a9;
        unint64_t v94 = a1 + 12192;
        unint64_t v91 = a1 + 4968;
        uint64_t v90 = a1 + 9784;
        uint64_t v14 = a1 + 13696;
        uint64_t v15 = *(void *)(a1 + 112);
        uint64_t v93 = a1 + 12794;
        UErrorCode v82 = a7;
        if (v15) {
          uint64_t v89 = *(void *)(v15 + 8);
        }
        else {
          uint64_t v89 = 0;
        }
        CFLocaleRef v92 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFLocaleIdentifier *)(a1 + 128));
        uint64_t v16 = 0;
        CFTypeRef v95 = 0;
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        uint64_t v84 = a1;
        uint64_t v19 = a1 + 160;
        uint64_t v20 = *(void *)(a1 + 160);
        uint64_t v21 = *(void *)(a1 + 152);
        int v81 = (long long *)(a1 + 16);
        uint64_t v85 = a1 + 13720;
        long long v87 = xmmword_1BDA82320;
        uint64_t v80 = a1 + 9784;
        uint64_t v79 = a1 + 4976;
        uint64_t v96 = a2;
        uint64_t v22 = a3;
        uint64_t v23 = v93;
        uint64_t v88 = v19;
        do
        {
          uint64_t v110 = 0;
          uint64_t v111 = 0;
          if (!icu_search_match() || v98 && v20 >= 2 && v20 + v21 >= v96) {
            break;
          }
          v16 += v111;
          if (v17 < v22)
          {
            uint64_t v24 = v110 + v16;
            uint64_t v25 = (uint64_t *)(v19 + 16 * v17);
            unint64_t v26 = v94;
            while (1)
            {
              uint64_t v21 = *(v25 - 1);
              if (v21 < v18) {
                ++v18;
              }
              else {
                uint64_t v18 = *(v25 - 1);
              }
              uint64_t v27 = *(void *)(v14 + 16 * v21);
              if (v16 >= v27)
              {
                uint64_t v20 = *v25;
                uint64_t v28 = *v25 + v21;
                if (v24 <= *(void *)(v14 + 16 * v28 - 8) + *(void *)(v14 + 16 * v28 - 16)) {
                  break;
                }
              }
              ++v17;
              v25 += 2;
              if (v22 == v17) {
                goto LABEL_87;
              }
            }
            uint64_t v29 = *(void *)(v14 + 16 * v21 + 8) + v27;
            if (v27 < v16 && v29 < v16)
            {
              uint64_t v31 = v96;
              if (v18 + 1 > v96) {
                uint64_t v31 = v18 + 1;
              }
              if (v18 == v31 - 1)
              {
LABEL_36:
                uint64_t v18 = v31;
              }
              else
              {
                BOOL v32 = (void *)(v85 + 16 * v18++);
                while (1)
                {
                  uint64_t v33 = *(v32 - 1);
                  uint64_t v29 = *v32 + v33;
                  if (v33 >= v16 || v29 >= v16) {
                    break;
                  }
                  v32 += 2;
                  if (v31 == ++v18) {
                    goto LABEL_36;
                  }
                }
              }
            }
            if (v29 >= v24) {
              uint64_t v35 = v18;
            }
            else {
              uint64_t v35 = v18 + 1;
            }
            if (v35 >= v28 || v18 >= v96 || v35 >= v96) {
              break;
            }
            CFTypeRef v38 = v95;
            if (!v95)
            {
              *(void *)&long long v112 = v23;
              *((void *)&v112 + 1) = v14;
              v113.n128_u64[0] = v94;
              v113.n128_u64[1] = v91;
              *(void *)&long long v114 = v90;
              *((void *)&v114 + 1) = v96;
              uint64_t v39 = SILanguageModelCopyLocale();
              unint64_t v26 = v94;
              CFTypeRef v38 = (CFTypeRef)v39;
              if (!v39)
              {
                CFTypeRef v95 = 0;
                break;
              }
            }
            unint64_t v109 = 0;
            long long v108 = v87;
            uint64_t v102 = v23;
            uint64_t v103 = v14 + 16 * v21;
            unint64_t v104 = v26;
            unint64_t v105 = v91 + 16 * v21;
            uint64_t v106 = v90 + 8 * v21;
            uint64_t v107 = v20;
            int v101 = 0;
            CFTypeRef v95 = v38;
            uint64_t KeyPhraseAtIndex = SILanguageModelGetKeyPhraseAtIndex();
            if (KeyPhraseAtIndex != -1)
            {
              uint64_t v42 = v41;
              if (v41 <= 13)
              {
                uint64_t v43 = KeyPhraseAtIndex + v21;
                uint64_t v44 = KeyPhraseAtIndex + v21 + v41;
                if (v35 < v44
                  && v18 >= v43
                  && (uint64_t)(*(void *)(v91 + 16 * v44 - 16)
                             - *(void *)(v91 + 16 * v43)
                             + *(void *)(v91 + 16 * v44 - 8)) <= 29)
                {
                  uint64_t v78 = v35;
                  v76[1] = v76;
                  MEMORY[0x1F4188790](KeyPhraseAtIndex);
                  int v77 = &v76[-4 * v42];
                  bzero(v77, v45);
                  if (v42 < 1)
                  {
                    unint64_t v50 = 0;
                    unsigned __int8 v47 = 0;
                  }
                  else
                  {
                    uint64_t v46 = 0;
                    unsigned __int8 v47 = 0;
                    char v48 = 0;
                    uint64_t v49 = v43;
                    unint64_t v50 = 0;
                    uint64_t v51 = v78 - v49;
                    uint64_t v52 = v80 + 8 * v49;
                    uint64_t v53 = (uint64_t *)(v79 + 16 * v49);
                    unint64_t v54 = v94;
                    uint64_t v55 = v77;
                    do
                    {
                      uint64_t v56 = *(v53 - 1);
                      if (v46)
                      {
                        uint64_t v57 = *(v53 - 2) + *(v53 - 3);
                        if (v56 > v57)
                        {
                          __n128 v58 = &v55[2 * v50];
                          void *v58 = v54 + 2 * v57;
                          *((_DWORD *)v58 + 2) = v56 - v57;
                          *((unsigned char *)v58 + 12) = 1;
                          ++v50;
                          ++v48;
                        }
                      }
                      uint64_t v59 = *v53;
                      uint64_t v60 = *(void *)(v52 + 8 * v46);
                      int v61 = (unsigned __int16 *)(v54 + 2 * v56);
                      uint64_t v62 = &v55[2 * v50];
                      void *v62 = v61;
                      *((_DWORD *)v62 + 2) = v59;
                      BOOL v64 = (v60 & 0x800) == 0 && v60 != 0;
                      *((unsigned char *)v62 + 12) = v64;
                      uint64_t v65 = (char *)v62 + 12;
                      if (v59 == 1)
                      {
                        int v66 = *v61;
                        if (v66 == 45 || v66 == 38) {
                          *uint64_t v65 = 1;
                        }
                      }
                      ++v50;
                      if (v51 == v46) {
                        unsigned __int8 v47 = v48 + v46;
                      }
                      ++v46;
                      v53 += 2;
                    }
                    while (v42 != v46);
                  }
                  int v100 = 0;
                  __int16 v99 = 0;
                  uint64_t v67 = v84;
                  double v68 = (*(double (**)(void))(*(void *)(v84 + 104) + 16))();
                  os_unfair_lock_lock(v86);
                  if (v50)
                  {
                    v69.n128_u64[0] = v109;
                    uint64_t v70 = *(void *)(v67 + 120);
                    int v71 = *(_DWORD *)(v67 + 96);
                    long long v72 = v81[3];
                    long long v114 = v81[2];
                    long long v115 = v72;
                    long long v116 = v81[4];
                    __n128 v73 = (__n128)v81[1];
                    long long v112 = *v81;
                    __n128 v113 = v73;
                    v73.n128_f64[0] = v68;
                    word_trie_s::insert((uint64_t *)(v70 + 16), (uint64_t)v77, v50, &v112, v83, v82, v71, v101, v73, v69, v100, v99, HIBYTE(v99), 1, 0, v47, 0);
                  }
                  os_unfair_lock_unlock(v86);
                  uint64_t v35 = v78;
                }
              }
            }
            if ((void)v108 == -1)
            {
              uint64_t v74 = v35 + 1;
              if (v35 + 1 >= v96) {
                uint64_t v75 = v35;
              }
              else {
                uint64_t v75 = v35 + 1;
              }
            }
            else
            {
              uint64_t v74 = v108 + v21 + *((void *)&v108 + 1);
              uint64_t v75 = v74 - (v74 == v96);
            }
            uint64_t v23 = v93;
            if (v74 >= v28) {
              ++v17;
            }
            uint64_t v16 = *(void *)(v14 + 16 * v75);
            uint64_t v19 = v88;
          }
        }
        while (v17 < v22);
LABEL_87:
        if (v92) {
          CFRelease(v92);
        }
        if (v95) {
          CFRelease(v95);
        }
      }
    }
  }
}

uint64_t lazySearchContextAtIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!*(void *)(a1 + 8 * a4)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 8 * a4);
  if (!v6)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&s_search_context_unfair_lock);
    uint64_t v6 = *(void *)(a2 + 8 * a4);
    if (!v6)
    {
      uint64_t v6 = icu_search_context_create();
      __dmb(0xBu);
      *(void *)(a2 + 8 * a4) = v6;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&s_search_context_unfair_lock);
  }
  return v6;
}

__n128 __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void *___ZL24handleCrossFieldPatternsP23si_completion_pattern_sP26StringTokenizerPhrasesInfotjbbjxP16os_unfair_lock_s_block_invoke(void *result, uint64_t a2, uint64_t a3, int a4, double a5)
{
  if (a3 >= 2)
  {
    uint64_t v5 = *(void *)(result[4] + 8);
    if (*(double *)(v5 + 24) < a5)
    {
      *(double *)(v5 + 24) = a5;
      *(void *)(*(void *)(result[5] + 8) + 40) = result[7] + a2;
      *(void *)(*(void *)(result[5] + 8) + 48) = a3;
      *(_DWORD *)(*(void *)(result[6] + 8) + 24) = a4;
    }
  }
  return result;
}

BOOL GetSentenceCallback(const unsigned __int16 *a1, CFRange *a2, unint64_t *a3, uint64_t a4, void *a5)
{
  if (a4 < 1)
  {
LABEL_24:
    if (!*((unsigned char *)a5 + 66))
    {
      uint64_t v35 = *((unsigned __int16 *)a5 + 22);
      if (*((_WORD *)a5 + 22))
      {
        uint64_t v36 = *((unsigned __int16 *)a5 + 32);
        int v37 = (void *)(a5[7] + 16 * v36);
        void *v37 = a5[6];
        v37[1] = v35;
        *((_WORD *)a5 + 32) = v36 + 1;
        a5[6] = *((unsigned __int16 *)a5 + 21);
        *((_WORD *)a5 + 22) = 0;
      }
    }
    if (*((unsigned __int16 *)a5 + 21) < *((unsigned __int16 *)a5 + 20)) {
      return *((unsigned __int16 *)a5 + 32) > 0x12Bu;
    }
  }
  else
  {
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = &a2[v10];
      locatiouint64_t n = v11->location;
      uint64_t length = v11->length;
      unint64_t v14 = a3[v10];
      if ((v14 & 0x10) != 0)
      {
        if (length >= 1)
        {
          uint64_t v19 = 0;
          CFIndex v20 = v11->location;
          do
          {
            CFIndex v21 = 0;
            while (a1[v19 + v21] != 45)
            {
              ++v21;
              if (!(v19 - length + v21))
              {
                unint64_t v18 = 0;
                uint64_t v17 = length - v19;
                uint64_t v15 = *((unsigned __int16 *)a5 + 21);
                uint64_t v16 = (CFIndex *)(a5[3] + 16 * v15);
                CFIndex *v16 = v20;
                goto LABEL_15;
              }
            }
            uint64_t v22 = *((unsigned __int16 *)a5 + 21);
            uint64_t v24 = a5[3];
            uint64_t v23 = a5[4];
            __int16 v25 = *((_WORD *)a5 + 22);
            if (v21)
            {
              unint64_t v26 = (CFIndex *)(v24 + 16 * v22);
              *unint64_t v26 = v20;
              v26[1] = v21;
              *(void *)(v23 + 8 * v22) = 0;
              LOWORD(v22) = v22 + 1;
              ++v25;
            }
            uint64_t v27 = v19 + v21;
            CFIndex v28 = v21 + v20;
            uint64_t v29 = (void *)(v24 + 16 * (unsigned __int16)v22);
            *uint64_t v29 = v28;
            v29[1] = 1;
            *(void *)(v23 + 8 * (unsigned __int16)v22) = 32;
            *((_WORD *)a5 + 21) = v22 + 1;
            *((_WORD *)a5 + 22) = v25 + 1;
            CFIndex v20 = v28 + 1;
            uint64_t v19 = v27 + 1;
          }
          while (v19 != length);
        }
      }
      else
      {
        uint64_t v15 = *((unsigned __int16 *)a5 + 21);
        uint64_t v16 = (CFIndex *)(a5[3] + 16 * v15);
        CFIndex *v16 = location;
        uint64_t v17 = length;
        unint64_t v18 = v14;
LABEL_15:
        v16[1] = v17;
        *(void *)(a5[4] + 8 * v15) = v18;
        *((_WORD *)a5 + 21) = v15 + 1;
        ++*((_WORD *)a5 + 22);
      }
      if (*((unsigned char *)a5 + 66))
      {
        LODWORD(v30) = *((unsigned __int16 *)a5 + 21);
      }
      else
      {
        IsValidPhraseTokeuint64_t n = SILanguageModelIsValidPhraseToken();
        uint64_t v32 = *((unsigned __int16 *)a5 + 22);
        uint64_t v30 = *((unsigned __int16 *)a5 + 21);
        if (!IsValidPhraseToken || v32 >= 0x7D)
        {
          uint64_t v33 = *((unsigned __int16 *)a5 + 32);
          uint64_t v34 = (void *)(a5[7] + 16 * v33);
          *uint64_t v34 = a5[6];
          v34[1] = v32;
          *((_WORD *)a5 + 32) = v33 + 1;
          a5[6] = v30;
          *((_WORD *)a5 + 22) = 0;
        }
      }
      if (v30 >= *((unsigned __int16 *)a5 + 20) || *((unsigned __int16 *)a5 + 32) >= 0x12Cu) {
        break;
      }
      if (++v10 == a4) {
        goto LABEL_24;
      }
    }
  }
  return 1;
}

BOOL GetTokenCallback(const unsigned __int16 *a1, uint64_t a2, uint64_t a3, void *a4)
{
  unint64_t v5 = a4[1];
  if (v5 <= (unint64_t)a1 && (unint64_t)&a1[a2] <= a4[2])
  {
    uint64_t v6 = (uint64_t)((uint64_t)a1 - v5) >> 1;
    if ((a3 & 0x10) != 0)
    {
      if (a2 >= 1)
      {
        for (uint64_t i = 0; i != a2; uint64_t i = v18 + 1)
        {
          uint64_t v12 = 0;
          while (a1[i + v12] != 45)
          {
            ++v12;
            if (!(i - a2 + v12))
            {
              uint64_t v10 = 0;
              uint64_t v9 = a2 - i;
              uint64_t v7 = *((unsigned __int16 *)a4 + 21);
              unint64_t v8 = (uint64_t *)(a4[3] + 16 * v7);
              *unint64_t v8 = v6;
              goto LABEL_15;
            }
          }
          uint64_t v13 = *((unsigned __int16 *)a4 + 21);
          uint64_t v15 = a4[3];
          uint64_t v14 = a4[4];
          __int16 v16 = *((_WORD *)a4 + 22);
          if (v12)
          {
            uint64_t v17 = (uint64_t *)(v15 + 16 * v13);
            uint64_t *v17 = v6;
            v17[1] = v12;
            *(void *)(v14 + 8 * v13) = 0;
            LOWORD(v13) = v13 + 1;
            ++v16;
          }
          uint64_t v18 = i + v12;
          uint64_t v19 = v6 + v12;
          CFIndex v20 = (uint64_t *)(v15 + 16 * (unsigned __int16)v13);
          *CFIndex v20 = v19;
          v20[1] = 1;
          *(void *)(v14 + 8 * (unsigned __int16)v13) = 32;
          *((_WORD *)a4 + 21) = v13 + 1;
          *((_WORD *)a4 + 22) = v16 + 1;
          uint64_t v6 = v19 + 1;
        }
      }
    }
    else
    {
      uint64_t v7 = *((unsigned __int16 *)a4 + 21);
      unint64_t v8 = (uint64_t *)(a4[3] + 16 * v7);
      *unint64_t v8 = v6;
      uint64_t v9 = a2;
      uint64_t v10 = a3;
LABEL_15:
      v8[1] = v9;
      *(void *)(a4[4] + 8 * v7) = v10;
      *((_WORD *)a4 + 21) = v7 + 1;
      ++*((_WORD *)a4 + 22);
    }
    if (!*((unsigned char *)a4 + 66))
    {
      IsValidPhraseTokeuint64_t n = SILanguageModelIsValidPhraseToken();
      uint64_t v22 = *((unsigned __int16 *)a4 + 22);
      if (IsValidPhraseToken)
      {
        if (v22 <= 0x7C) {
          return *((unsigned __int16 *)a4 + 21) >= *((unsigned __int16 *)a4 + 20)
        }
              || *((unsigned __int16 *)a4 + 32) > 0x12Bu;
      }
      else if (!*((_WORD *)a4 + 22))
      {
LABEL_22:
        a4[6] = *((unsigned __int16 *)a4 + 21);
        *((_WORD *)a4 + 22) = 0;
        return *((unsigned __int16 *)a4 + 21) >= *((unsigned __int16 *)a4 + 20)
            || *((unsigned __int16 *)a4 + 32) > 0x12Bu;
      }
      uint64_t v23 = *((unsigned __int16 *)a4 + 32);
      uint64_t v24 = (void *)(a4[7] + 16 * v23);
      void *v24 = a4[6];
      v24[1] = v22;
      *((_WORD *)a4 + 32) = v23 + 1;
      goto LABEL_22;
    }
  }
  return *((unsigned __int16 *)a4 + 21) >= *((unsigned __int16 *)a4 + 20)
      || *((unsigned __int16 *)a4 + 32) > 0x12Bu;
}

uint64_t ___ZL21normalizeSourceStringP26StringTokenizerPhrasesInfoPhmmb_block_invoke()
{
  uint64_t result = unorm2_getNFCInstance();
  normalizeSourceString(StringTokenizerPhrasesInfo *,unsigned char *,unsigned long,unsigned long,BOOL)::norm2 = result;
  return result;
}

uint64_t handlePatterns(unsigned __int8 *a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, os_unfair_lock_s *a8)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (a3 && (uint64_t v9 = *((void *)a1 + 14)) != 0 && (v10 = *(void *)(v9 + 16)) != 0)
  {
    char v47 = 0;
    uint64_t v11 = 0;
    unsigned __int16 v12 = 0;
    unsigned __int16 v13 = 0;
    char v49 = 0;
    uint64_t v14 = a1 + 6462;
    uint64_t v15 = a1 + 4960;
    int v16 = a2 - *a1;
    uint64_t v42 = (uint64_t *)(v10 + 16);
    uint64_t v43 = (long long *)(a1 + 16);
    uint64_t v46 = a1 + 152;
    unint64_t v48 = a3;
    while (a2 > v13)
    {
      uint64_t v17 = v13;
      unint64_t v18 = *(unsigned __int16 *)&v14[2 * v13];
      lazySearchContextAtIndex(a4, a5, *((void *)a1 + 16), v11);
      if (icu_search_match())
      {
        while (1)
        {
          unint64_t v19 = *(unsigned __int16 *)&v14[2 * v17];
          if (v18 <= v19) {
            break;
          }
          if (a2 == ++v17)
          {
            LOWORD(v17) = a2;
            goto LABEL_14;
          }
        }
        v49 |= v18 < v19;
LABEL_14:
        if (!v11) {
          unsigned __int16 v12 = v17;
        }
        if (v11 + 1 >= v48)
        {
          int v21 = v49 & 1;
          int v22 = v12 - v21;
          memset(v55, 0, sizeof(v55));
          if (v16 > (unsigned __int16)(v12 - v21))
          {
            unint64_t v23 = 0;
            int v24 = (unsigned __int16)(v12 - v21);
            __int16 v25 = &v46[16 * (unsigned __int16)v22];
            do
            {
              if (v22 == v24)
              {
                uint64_t v26 = *((void *)v25 - 1);
              }
              else
              {
                if (v23 - 13 < 0xFFFFFFFFFFFFFFF1) {
                  goto LABEL_34;
                }
                uint64_t v27 = *((void *)v25 - 3);
                uint64_t v28 = *((void *)v25 - 2);
                uint64_t v29 = &v55[v23];
                *(void *)uint64_t v29 = &v15[2 * v27 + 2 * v28];
                uint64_t v26 = *((void *)v25 - 1);
                *((_DWORD *)v29 + 2) = v26 - (v28 + v27);
                ++v23;
                *((unsigned char *)v29 + 12) = 1;
              }
              uint64_t v30 = &v55[v23];
              *(void *)uint64_t v30 = &v15[2 * v26];
              int v31 = *(_DWORD *)v25;
              *((_DWORD *)v30 + 2) = *(_DWORD *)v25;
              *((unsigned char *)v30 + 12) = 0;
              if (v23) {
                BOOL v32 = v31 <= 20;
              }
              else {
                BOOL v32 = 1;
              }
              char v33 = !v32;
              if (v31 > 40 || (v33 & 1) != 0) {
                goto LABEL_35;
              }
              ++v23;
              ++v24;
              v25 += 16;
            }
            while (v16 > v24);
            if (!v23) {
              goto LABEL_35;
            }
LABEL_34:
            double v34 = (*(double (**)(void))(*((void *)a1 + 13) + 16))();
            os_unfair_lock_lock(a8);
            __n128 v35 = (__n128)v43[3];
            v54[2] = v43[2];
            v54[3] = (__int128)v35;
            v54[4] = v43[4];
            __n128 v36 = (__n128)v43[1];
            v54[0] = *v43;
            v35.n128_u64[1] = *((void *)&v54[0] + 1);
            v54[1] = (__int128)v36;
            v35.n128_u64[0] = 0;
            v36.n128_f64[0] = v34;
            word_trie_s::insert(v42, (uint64_t)v55, v23, v54, a7, U_ZERO_ERROR, *((_DWORD *)a1 + 24), 0, v36, v35, 0, 0, 0, a6, 0, 0, 0);
            os_unfair_lock_unlock(a8);
            char v47 = 1;
          }
LABEL_35:
          unint64_t v37 = v11 + 2;
          if (a2 > (unsigned __int16)(v12 + 1)) {
            int v38 = 0;
          }
          else {
            int v38 = 2;
          }
          if (a2 > (unsigned __int16)(v12 + 1)) {
            uint64_t v39 = 0;
          }
          else {
            uint64_t v39 = v11 + 2;
          }
          if (a2 > (unsigned __int16)(v12 + 1)) {
            unsigned __int16 v40 = v12 + 2;
          }
          else {
            unsigned __int16 v40 = v17;
          }
          if (v37 >= v48) {
            int v20 = v38;
          }
          else {
            int v20 = 2;
          }
          if (v37 >= v48) {
            uint64_t v11 = v39;
          }
          else {
            v11 += 2;
          }
          if (v37 < v48)
          {
            unsigned __int16 v13 = v17;
          }
          else
          {
            ++v12;
            unsigned __int16 v13 = v40;
          }
        }
        else
        {
          unsigned __int16 v13 = v17 + 1;
          int v20 = 3;
          ++v11;
        }
      }
      else
      {
        if (a6 || v11) {
          return v47 & 1;
        }
        ++v13;
        int v20 = 3;
      }
      if (v20 == 2) {
        return v47 & 1;
      }
    }
  }
  else
  {
    char v47 = 0;
  }
  return v47 & 1;
}

uint64_t tokenrangescallback(unsigned __int16 *a1, uint64_t a2, char a3, void *a4)
{
  v29[1] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a4[9];
  if (a3)
  {
    if (v7)
    {
      if (*((unsigned __int16 *)a4 + 33) < *((unsigned __int16 *)a4 + 32))
      {
        MEMORY[0x1F4188790](a1);
        uint64_t v9 = (char *)v29 - ((v8 + 16) & 0xFFFFFFFFFFFFFFF0);
        bzero(v9, (6 * a2) | 1);
        uint64_t v10 = _utf16_to_utf8(a1, a2, (unsigned __int8 *)v9, (6 * a2) | 1, *((unsigned __int8 *)a4 + 80));
        if (v10)
        {
          size_t v11 = v10;
          v9[v10] = 0;
          uint64_t v13 = *(void *)(*a4 + 88);
          uint64_t v12 = *(void *)(*a4 + 96);
          printf("[%d,%d] %s\n", v13, v12, v9);
          uint64_t v14 = (void *)a4[6];
          if (v14)
          {
            if ((unint64_t)v14 + v11 < a4[5])
            {
              unsigned int v15 = *(unsigned __int16 *)(a4[1] + 2 * v13);
              if (v15 >> 8 >= 0x11 && ((v15 & 0xFF00) == 0x1100 || (v15 - 11904) >> 7 < 0x197 || v15 - 65376 <= 0x4F))
              {
                uint64_t v16 = a4[4];
                uint64_t v17 = *((unsigned __int16 *)a4 + 13);
                *((_WORD *)a4 + 13) = v17 + 1;
                v18.i64[0] = v13;
                v18.i64[1] = v12;
                v19.i64[0] = 0xFFFFFFFFLL;
                v19.i64[1] = 0xFFFFFFFFLL;
                *(int8x16_t *)(v16 + 16 * v17) = vandq_s8(v18, v19);
                memcpy(v14, v9, v11);
                uint64_t v20 = a4[6];
                int v21 = v20 - *((_DWORD *)a4 + 14);
                uint64_t v22 = a4[9];
                uint64_t v23 = *((unsigned __int16 *)a4 + 33);
                *((_WORD *)a4 + 33) = v23 + 1;
                *(_WORD *)(v22 + 2 * v23) = v21;
                a4[6] = v20 + v11;
              }
            }
          }
        }
      }
    }
  }
  else if (!v7)
  {
    uint64_t v25 = *((unsigned __int16 *)a4 + 13);
    unsigned int v26 = *((unsigned __int16 *)a4 + 12);
    if (v25 >= v26) {
      return 1;
    }
    unint64_t v27 = a4[1];
    if (v27 <= (unint64_t)a1 && (unint64_t)&a1[a2] <= a4[2])
    {
      uint64_t v28 = (uint64_t *)(a4[4] + 16 * v25);
      LODWORD(v25) = v25 + 1;
      *((_WORD *)a4 + 13) = v25;
      uint64_t *v28 = (uint64_t)((uint64_t)a1 - v27) >> 1;
      v28[1] = a2;
    }
    if (v25 >= v26) {
      return 1;
    }
  }
  return 0;
}

double pqinit_CompletionItem_s(uint64_t a1)
{
  *(_OWORD *)(a1 + 8) = xmmword_1BDA82330;
  uint64_t v2 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x1DC0uLL, 0x6085D6BuLL);
  if (!v2) {
    _log_fault_for_malloc_failure();
  }
  *(void *)a1 = v2;
  double result = 0.0;
  v2[12] = 0u;
  v2[13] = 0u;
  v2[10] = 0u;
  v2[11] = 0u;
  v2[8] = 0u;
  v2[9] = 0u;
  v2[6] = 0u;
  v2[7] = 0u;
  v2[4] = 0u;
  v2[5] = 0u;
  void v2[2] = 0u;
  void v2[3] = 0u;
  *uint64_t v2 = 0u;
  v2[1] = 0u;
  return result;
}

void pqdispose_CompletionItem_s(void **a1)
{
  if ((uint64_t)a1[2] >= 2)
  {
    uint64_t v2 = 1;
    uint64_t v3 = 368;
    do
    {
      CFRelease(*(CFTypeRef *)((char *)*a1 + v3));
      ++v2;
      v3 += 224;
    }
    while ((uint64_t)a1[2] > v2);
  }
  uint64_t v4 = *a1;
  free(v4);
}

void GetCompletionItemWeight(void *a1)
{
  if (a1)
  {
    unint64_t v3 = a1[8];
    unint64_t v2 = a1[9];
    if (a1[4] + 1 == a1[1]) {
      uint64_t v4 = 1;
    }
    else {
      uint64_t v4 = a1[4] + 1 - a1[1];
    }
    if (v2) {
      log((double)v2);
    }
    log((double)v3);
    double v5 = (double)(unint64_t)a1[3];
    double v6 = *(double *)&qword_1EC02E430;
    if (*(double *)&qword_1EC02E430 >= v5)
    {
      log((double)(unint64_t)a1[3]);
    }
    else
    {
      log(*(long double *)&qword_1EC02E430);
      log(v5 - v6);
    }
    double v7 = *(double *)&xmmword_1EC02E458;
    if (*(double *)&xmmword_1EC02E458 >= (double)v4)
    {
      if (v4 >= 0) {
        uint64_t v8 = v4;
      }
      else {
        uint64_t v8 = v4 + 1;
      }
      log((double)((v8 >> 1) + 1));
    }
    else
    {
      log(*(double *)&xmmword_1EC02E458 * 0.5 + 1.0);
      log(((double)v4 - v7) * 0.5 + 1.0);
    }
    long double v9 = 157680000.0;
    if (*((double *)a1 + 5) > 0.0) {
      long double v9 = *((double *)a1 + 5);
    }
    log(v9);
  }
}

void SICompletionModelEnumerateCompletions(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  *(void *)&long long v247 = v6;
  uint64_t v314 = *MEMORY[0x1E4F143B8];
  if (!v1 || !v5) {
    return;
  }
  unint64_t v7 = v4;
  uint64_t v8 = v2;
  uint64_t v9 = v1;
  uint64_t v245 = v5;
  uint64_t v10 = 200;
  if (v4 < 0xC8) {
    uint64_t v10 = v4;
  }
  uint64_t v241 = v10;
  char v11 = *(unsigned char *)(v1 + 4);
  *((void *)&v247 + 1) = v3;
  if (v11)
  {
    long long v257 = 0uLL;
    uint64_t v258 = 0;
    pqinit_CompletionItem_s((uint64_t)&v257);
    uint64_t v22 = *(void *)(v9 + 16);
    uint64_t v23 = strdup(v8);
    int v24 = v23;
    char v25 = 0;
    char v26 = 0;
    int v27 = 0;
    uint64_t v28 = v23;
    while (1)
    {
      char v29 = v25;
      int v31 = *v28++;
      int v30 = v31;
      if (v31 == 92)
      {
        char v25 = 1;
        if (v29) {
          goto LABEL_17;
        }
      }
      else
      {
        if (!v30)
        {
          if (!((v27 == 0) | v26 & 1))
          {
            uint64_t v55 = v27 - 1;
            if (v23[v55] == 42) {
              v23[v55] = 0;
            }
          }
          v23[v27] = 0;
          int v56 = *__error();
          uint64_t v57 = _SILogForLogForCategory(1);
          os_log_type_t v58 = 2 * (dword_1E9FC90A8 < 4);
          if (os_log_type_enabled(v57, v58))
          {
            LODWORD(v301[0]) = 134217984;
            *(void *)((char *)v301 + 4) = v7;
            _os_log_impl(&dword_1BD672000, v57, v58, "Completion v1 count:%llu", (uint8_t *)v301, 0xCu);
          }
          *__error() = v56;
          if (dword_1E9FC90A8 >= 5)
          {
            int v228 = *__error();
            long long v229 = _SILogForLogForCategory(1);
            if (os_log_type_enabled(v229, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(v301[0]) = 136315394;
              *(void *)((char *)v301 + 4) = v24;
              WORD6(v301[0]) = 2080;
              *(void *)((char *)v301 + 14) = v8;
              _os_log_impl(&dword_1BD672000, v229, OS_LOG_TYPE_DEFAULT, "Creating unescaped string %s with from %s", (uint8_t *)v301, 0x16u);
            }
            *__error() = v228;
          }
          CFAllocatorRef v59 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFStringRef v60 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v24, 0x8000100u);
          CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v59, 0, v60);
          CFRelease(v60);
          CFStringLowercase(MutableCopy, 0);
          CFIndex Length = CFStringGetLength(MutableCopy);
          CharactersPtr = CFStringGetCharactersPtr(MutableCopy);
          if (v22)
          {
            BOOL v64 = CharactersPtr;
            bzero(&v275, 0x1180uLL);
            uint64_t v65 = -4480;
            do
            {
              int v66 = (char *)&v275 + v65;
              *((void *)v66 + 584) = 0;
              *((_OWORD *)v66 + 291) = 0uLL;
              *((_OWORD *)v66 + 290) = 0uLL;
              *((_OWORD *)v66 + 289) = 0uLL;
              *((_OWORD *)v66 + 288) = 0uLL;
              *((_OWORD *)v66 + 287) = 0uLL;
              *((_OWORD *)v66 + 286) = 0uLL;
              *((_OWORD *)v66 + 285) = 0uLL;
              *((_OWORD *)v66 + 284) = 0uLL;
              *((_OWORD *)v66 + 283) = 0uLL;
              *((_OWORD *)v66 + 282) = 0uLL;
              *((_OWORD *)v66 + 281) = 0uLL;
              *((_OWORD *)v66 + 280) = 0uLL;
              *((void *)v66 + 585) = 0xFFEFFFFFFFFFFFFFLL;
              *((_OWORD *)v66 + 293) = 0uLL;
              v65 += 224;
            }
            while (v65);
            long long v265 = 0u;
            long long v266 = 0u;
            long long v263 = 0u;
            long long v264 = 0u;
            long long v262 = 0u;
            long long v249 = 0u;
            long long v250 = 0u;
            long long v248 = 0x3FF0000000000000uLL;
            *(void *)((char *)&v249 + 7) = 0;
            *(void *)&long long v250 = &v262;
            *(void *)&long long v251 = v247;
            *(void *)&long long v288 = MEMORY[0x1E4F143A8];
            *((void *)&v288 + 1) = 0x40000000;
            *(void *)&long long v289 = ___ZL24update_completions_queueP16_CompletionModelP13si_wordtrie_sPKcS4_myP23PQueue_CompletionItem_s_block_invoke;
            *((void *)&v289 + 1) = &__block_descriptor_tmp_14_1609;
            *(void *)&long long v290 = Length;
            *((void *)&v290 + 1) = v9;
            long long v291 = v247;
            *(void *)&long long v292 = v7;
            *((void *)&v292 + 1) = &v275;
            *(void *)&long long v293 = v64;
            *((void *)&v293 + 1) = &v257;
            *(void *)&long long v294 = v24;
            *((void *)&v294 + 1) = MutableCopy;
            bzero(v301, 0x1400uLL);
            word_trie_s::iterateFragments(v22 + 16, (uint64_t)v301, 0, 0, &v248, (uint64_t)&v288, 0, 0);
          }
          CFRelease(MutableCopy);
          free(v24);
          LOBYTE(v261) = 0;
LABEL_49:
          uint64_t v67 = v258;
          if (v258 == 1) {
            goto LABEL_72;
          }
          uint64_t v68 = v257;
          long long v69 = *(_OWORD *)(v257 + 400);
          long long v310 = *(_OWORD *)(v257 + 384);
          long long v311 = v69;
          long long v70 = *(_OWORD *)(v257 + 432);
          long long v312 = *(_OWORD *)(v257 + 416);
          long long v313 = v70;
          long long v71 = *(_OWORD *)(v257 + 336);
          long long v306 = *(_OWORD *)(v257 + 320);
          long long v307 = v71;
          long long v72 = *(_OWORD *)(v257 + 368);
          long long v308 = *(_OWORD *)(v257 + 352);
          long long v309 = v72;
          long long v73 = *(_OWORD *)(v257 + 272);
          long long v302 = *(_OWORD *)(v257 + 256);
          long long v303 = v73;
          long long v74 = *(_OWORD *)(v257 + 304);
          long long v304 = *(_OWORD *)(v257 + 288);
          long long v305 = v74;
          long long v75 = *(_OWORD *)(v257 + 240);
          v301[0] = *(_OWORD *)(v257 + 224);
          v301[1] = v75;
          int v76 = (const void *)(v257 + 224 * (v258 - 1));
          long long v271 = *((_OWORD *)v76 + 9);
          long long v272 = *((_OWORD *)v76 + 10);
          long long v273 = *((_OWORD *)v76 + 11);
          uint64_t v274 = *((void *)v76 + 24);
          long long v267 = *((_OWORD *)v76 + 5);
          long long v268 = *((_OWORD *)v76 + 6);
          long long v269 = *((_OWORD *)v76 + 7);
          long long v270 = *((_OWORD *)v76 + 8);
          long long v263 = *((_OWORD *)v76 + 1);
          long long v264 = *((_OWORD *)v76 + 2);
          long long v265 = *((_OWORD *)v76 + 3);
          long long v266 = *((_OWORD *)v76 + 4);
          long long v262 = *(_OWORD *)v76;
          double v77 = *((double *)v76 + 25);
          long long v253 = *((_OWORD *)v76 + 13);
          memmove((void *)(v257 + 224), v76, 0xC8uLL);
          *(double *)(v68 + 424) = v77;
          *(_OWORD *)(v68 + 432) = v253;
          uint64_t v258 = v67 - 1;
          uint64_t v78 = *((uint64_t *)&v257 + 1) >> 1;
          long long v285 = v272;
          long long v286 = v273;
          uint64_t v287 = v274;
          long long v281 = v268;
          long long v282 = v269;
          long long v283 = v270;
          long long v284 = v271;
          long long v277 = v264;
          long long v278 = v265;
          long long v279 = v266;
          long long v280 = v267;
          uint64_t v79 = 1;
          uint64_t v80 = 2;
          uint64_t v81 = 3;
          long long v275 = v262;
          long long v276 = v263;
          while (1)
          {
            uint64_t v82 = v257 + 224 * v80;
            double v83 = *(double *)(v82 + 200);
            long long v248 = *(_OWORD *)(v82 + 208);
            uint64_t v84 = v257 + 224 * v81;
            long long v297 = *(_OWORD *)(v84 + 144);
            long long v298 = *(_OWORD *)(v84 + 160);
            long long v299 = *(_OWORD *)(v84 + 176);
            uint64_t v300 = *(void *)(v84 + 192);
            long long v293 = *(_OWORD *)(v84 + 80);
            long long v294 = *(_OWORD *)(v84 + 96);
            long long v295 = *(_OWORD *)(v84 + 112);
            long long v296 = *(_OWORD *)(v84 + 128);
            long long v289 = *(_OWORD *)(v84 + 16);
            long long v290 = *(_OWORD *)(v84 + 32);
            long long v291 = *(_OWORD *)(v84 + 48);
            long long v292 = *(_OWORD *)(v84 + 64);
            long long v288 = *(_OWORD *)v84;
            double v85 = *(double *)(v84 + 200);
            long long v255 = *(_OWORD *)(v84 + 208);
            if (v81 >= v67)
            {
              long long v298 = xmmword_1BDA7EF70;
              long long v299 = unk_1BDA7EF80;
              uint64_t v300 = 0;
              long long v294 = xmmword_1BDA7EF30;
              long long v295 = unk_1BDA7EF40;
              long long v297 = unk_1BDA7EF60;
              long long v296 = xmmword_1BDA7EF50;
              long long v290 = xmmword_1BDA7EEF0;
              long long v291 = unk_1BDA7EF00;
              long long v293 = unk_1BDA7EF20;
              long long v292 = xmmword_1BDA7EF10;
              long long v289 = unk_1BDA7EEE0;
              long long v288 = max_CompletionItem_s;
              long long v255 = xmmword_1BDA7EFA0;
              if (v80 >= v67) {
                goto LABEL_69;
              }
              double v85 = 1.79769313e308;
            }
            if (v83 >= v77)
            {
              if (v85 >= v77)
              {
                _X8 = v257 + 448 * v79;
                __asm { PRFM            #1, [X8] }
LABEL_69:
                (*(void (**)(uint64_t, _OWORD *, long long *))(v245 + 16))(v245, v301, &v261);
                if ((void)v309) {
                  CFRelease((CFTypeRef)v309);
                }
                if ((_BYTE)v261)
                {
LABEL_72:
                  pqdispose_CompletionItem_s((void **)&v257);
                  return;
                }
                goto LABEL_49;
              }
              uint64_t v88 = &v255;
              long long v87 = &v288;
            }
            else
            {
              _NF = v85 < v83;
              if (v85 >= v83) {
                long long v87 = (long long *)(v257 + 224 * v80);
              }
              else {
                long long v87 = &v288;
              }
              if (v85 < v83)
              {
                uint64_t v88 = &v255;
              }
              else
              {
                double v85 = v83;
                uint64_t v88 = &v248;
              }
              if (!_NF) {
                uint64_t v81 = v80;
              }
            }
            long long v271 = v87[9];
            long long v272 = v87[10];
            long long v273 = v87[11];
            uint64_t v274 = *((void *)v87 + 24);
            long long v267 = v87[5];
            long long v268 = v87[6];
            long long v269 = v87[7];
            long long v270 = v87[8];
            long long v263 = v87[1];
            long long v264 = v87[2];
            long long v265 = v87[3];
            long long v266 = v87[4];
            long long v262 = *v87;
            _X11 = v257 + 448 * v81;
            __asm { PRFM            #1, [X11] }
            if (v81 != v79)
            {
              uint64_t v80 = 2 * v81;
              uint64_t v94 = v257 + 224 * v81;
              *(_OWORD *)(v94 + 144) = v284;
              *(_OWORD *)(v94 + 160) = v285;
              *(_OWORD *)(v94 + 176) = v286;
              *(void *)(v94 + 192) = v287;
              *(_OWORD *)(v94 + 80) = v280;
              *(_OWORD *)(v94 + 96) = v281;
              *(_OWORD *)(v94 + 112) = v282;
              *(_OWORD *)(v94 + 128) = v283;
              *(_OWORD *)(v94 + 16) = v276;
              *(_OWORD *)(v94 + 32) = v277;
              *(_OWORD *)(v94 + 48) = v278;
              *(_OWORD *)(v94 + 64) = v279;
              *(_OWORD *)uint64_t v94 = v275;
              *(double *)(v94 + 200) = v77;
              *(_OWORD *)(v94 + 208) = v253;
              uint64_t v95 = v257 + 224 * v79;
              uint64_t v79 = v81;
              *(_OWORD *)uint64_t v95 = v262;
              *(_OWORD *)(v95 + 144) = v271;
              *(_OWORD *)(v95 + 160) = v272;
              *(_OWORD *)(v95 + 176) = v273;
              *(void *)(v95 + 192) = v274;
              *(_OWORD *)(v95 + 80) = v267;
              *(_OWORD *)(v95 + 96) = v268;
              *(_OWORD *)(v95 + 112) = v269;
              *(_OWORD *)(v95 + 128) = v270;
              *(_OWORD *)(v95 + 16) = v263;
              *(_OWORD *)(v95 + 32) = v264;
              *(_OWORD *)(v95 + 48) = v265;
              *(_OWORD *)(v95 + 64) = v266;
              *(double *)(v95 + 200) = v85;
              *(_OWORD *)(v95 + 208) = *v88;
              long long v272 = v285;
              long long v273 = v286;
              uint64_t v274 = v287;
              long long v268 = v281;
              long long v269 = v282;
              long long v270 = v283;
              long long v271 = v284;
              long long v264 = v277;
              long long v265 = v278;
              long long v266 = v279;
              long long v267 = v280;
              long long v262 = v275;
              long long v263 = v276;
              BOOL v96 = v81 < v78;
              uint64_t v81 = (2 * v81) | 1;
              if (v96) {
                continue;
              }
            }
            goto LABEL_69;
          }
        }
LABEL_17:
        char v25 = 0;
        v23[v27++] = v30;
        char v26 = v29;
      }
    }
  }
  long long v255 = 0uLL;
  uint64_t v256 = 0;
  pqinit_CompletionItem_s((uint64_t)&v255);
  long long v253 = 0uLL;
  uint64_t v254 = 0;
  pqinit_CompletionItem_s((uint64_t)&v253);
  uint64_t v12 = *(void *)(v9 + 24);
  uint64_t v13 = strdup(v8);
  uint64_t v14 = v13;
  char v15 = 0;
  char v16 = 0;
  int v17 = 0;
  int8x16_t v18 = v13;
  while (1)
  {
    char v19 = v15;
    int v21 = *v18++;
    int v20 = v21;
    if (v21 != 92) {
      break;
    }
    char v15 = 1;
    if (v19)
    {
LABEL_11:
      char v15 = 0;
      v13[v17++] = v20;
      char v16 = v19;
    }
  }
  if (v20) {
    goto LABEL_11;
  }
  if (!((v17 == 0) | v16 & 1))
  {
    uint64_t v32 = v17 - 1;
    if (v13[v32] == 42) {
      v13[v32] = 0;
    }
  }
  v13[v17] = 0;
  int v33 = *__error();
  double v34 = _SILogForLogForCategory(1);
  os_log_type_t v35 = 2 * (dword_1E9FC90A8 < 4);
  if (os_log_type_enabled(v34, v35))
  {
    int v36 = *(_DWORD *)(v9 + 4);
    LODWORD(v301[0]) = 67109376;
    DWORD1(v301[0]) = v36;
    WORD4(v301[0]) = 2048;
    *(void *)((char *)v301 + 10) = v241;
    _os_log_impl(&dword_1BD672000, v34, v35, "Completion v2 options: 0x%x count:%llu", (uint8_t *)v301, 0x12u);
  }
  *__error() = v33;
  if (dword_1E9FC90A8 >= 5)
  {
    int v226 = *__error();
    v227 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v227, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v301[0]) = 136315394;
      *(void *)((char *)v301 + 4) = v14;
      WORD6(v301[0]) = 2080;
      *(void *)((char *)v301 + 14) = v8;
      _os_log_impl(&dword_1BD672000, v227, OS_LOG_TYPE_DEFAULT, "Creating unescaped string %s with from %s", (uint8_t *)v301, 0x16u);
    }
    *__error() = v226;
  }
  CFAllocatorRef v37 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v38 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v14, 0x8000100u);
  CFAllocatorRef v239 = v37;
  CFMutableStringRef v39 = CFStringCreateMutableCopy(v37, 0, v38);
  CFRelease(v38);
  CFStringLowercase(v39, 0);
  CFIndex v40 = CFStringGetLength(v39);
  uint64_t v41 = CFStringGetCharactersPtr(v39);
  if (v12)
  {
    uint64_t v42 = v41;
    bzero(&v275, 0x1180uLL);
    uint64_t v43 = -4480;
    do
    {
      uint64_t v44 = (char *)&v275 + v43;
      *((void *)v44 + 584) = 0;
      *((_OWORD *)v44 + 291) = 0uLL;
      *((_OWORD *)v44 + 290) = 0uLL;
      *((_OWORD *)v44 + 289) = 0uLL;
      *((_OWORD *)v44 + 288) = 0uLL;
      *((_OWORD *)v44 + 287) = 0uLL;
      *((_OWORD *)v44 + 286) = 0uLL;
      *((_OWORD *)v44 + 285) = 0uLL;
      *((_OWORD *)v44 + 284) = 0uLL;
      *((_OWORD *)v44 + 283) = 0uLL;
      *((_OWORD *)v44 + 282) = 0uLL;
      *((_OWORD *)v44 + 281) = 0uLL;
      *((_OWORD *)v44 + 280) = 0uLL;
      *((void *)v44 + 585) = 0xFFEFFFFFFFFFFFFFLL;
      *((_OWORD *)v44 + 293) = 0uLL;
      v43 += 224;
    }
    while (v43);
    long long v265 = 0u;
    long long v266 = 0u;
    long long v263 = 0u;
    long long v264 = 0u;
    long long v262 = 0u;
    long long v249 = 0u;
    long long v250 = 0u;
    long long v248 = 0x3FF0000000000000uLL;
    *(void *)((char *)&v249 + 7) = 0;
    *(void *)&long long v250 = &v262;
    *(void *)&long long v251 = v247;
    *(void *)&long long v257 = 0;
    *((void *)&v257 + 1) = &v257;
    uint64_t v258 = 0x2000000000;
    char v259 = 0;
    if ((void)v247 && (!strncmp("ja", (const char *)v247, 2uLL) || !strncmp("zh", (const char *)v247, 2uLL))) {
      char v259 = 1;
    }
    *(void *)&long long v288 = MEMORY[0x1E4F143A8];
    *((void *)&v288 + 1) = 0x40000000;
    *(void *)&long long v289 = ___ZL27update_completions_queue_v2P16_CompletionModelP13si_wordtrie_sPKcS4_myP23PQueue_CompletionItem_s_block_invoke;
    *((void *)&v289 + 1) = &unk_1E6343370;
    *((void *)&v290 + 1) = v9;
    *(void *)&long long v290 = &v257;
    *(void *)&long long v291 = *((void *)&v247 + 1);
    *((void *)&v291 + 1) = v40;
    *(void *)&long long v292 = v241;
    *((void *)&v292 + 1) = &v275;
    *(void *)&long long v293 = v42;
    *((void *)&v293 + 1) = &v255;
    *(void *)&long long v294 = v14;
    bzero(v301, 0x1400uLL);
    word_trie_s::iterateFragments(v12 + 16, (uint64_t)v301, 0, 0, &v248, (uint64_t)&v288, 0, 0);
    _Block_object_dispose(&v257, 8);
  }
  CFRelease(v39);
  free(v14);
  uint64_t v45 = *(void *)(v9 + 32);
  uint64_t v46 = strdup(v8);
  char v47 = v46;
  char v48 = 0;
  char v49 = 0;
  int v50 = 0;
  uint64_t v51 = v46;
  while (2)
  {
    while (2)
    {
      char v52 = v48;
      int v54 = *v51++;
      int v53 = v54;
      if (v54 == 92)
      {
        char v48 = 1;
        if ((v52 & 1) == 0) {
          continue;
        }
        goto LABEL_37;
      }
      break;
    }
    if (v53)
    {
LABEL_37:
      char v48 = 0;
      v46[v50++] = v53;
      char v49 = v52;
      continue;
    }
    break;
  }
  if (!((v50 == 0) | v49 & 1))
  {
    uint64_t v99 = v50 - 1;
    if (v46[v99] == 42) {
      v46[v99] = 0;
    }
  }
  v46[v50] = 0;
  int v100 = *__error();
  int v101 = _SILogForLogForCategory(1);
  os_log_type_t v102 = 2 * (dword_1E9FC90A8 < 4);
  if (os_log_type_enabled(v101, v102))
  {
    int v103 = *(_DWORD *)(v9 + 4);
    LODWORD(v301[0]) = 67109376;
    DWORD1(v301[0]) = v103;
    WORD4(v301[0]) = 2048;
    *(void *)((char *)v301 + 10) = v241;
    _os_log_impl(&dword_1BD672000, v101, v102, "Completion v3 options: 0x%x count:%llu", (uint8_t *)v301, 0x12u);
  }
  *__error() = v100;
  if (dword_1E9FC90A8 >= 5)
  {
    int v230 = *__error();
    v231 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v231, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v301[0]) = 136315394;
      *(void *)((char *)v301 + 4) = v47;
      WORD6(v301[0]) = 2080;
      *(void *)((char *)v301 + 14) = v8;
      _os_log_impl(&dword_1BD672000, v231, OS_LOG_TYPE_DEFAULT, "Creating unescaped string %s with from %s", (uint8_t *)v301, 0x16u);
    }
    *__error() = v230;
  }
  CFStringRef v104 = CFStringCreateWithCString(v239, v47, 0x8000100u);
  CFMutableStringRef v105 = CFStringCreateMutableCopy(v239, 0, v104);
  CFRelease(v104);
  CFStringLowercase(v105, 0);
  CFIndex v106 = CFStringGetLength(v105);
  uint64_t v107 = CFStringGetCharactersPtr(v105);
  if (v45)
  {
    long long v108 = v107;
    bzero(&v275, 0x1180uLL);
    uint64_t v109 = -4480;
    do
    {
      uint64_t v110 = (char *)&v275 + v109;
      *((void *)v110 + 584) = 0;
      *((_OWORD *)v110 + 291) = 0uLL;
      *((_OWORD *)v110 + 290) = 0uLL;
      *((_OWORD *)v110 + 289) = 0uLL;
      *((_OWORD *)v110 + 288) = 0uLL;
      *((_OWORD *)v110 + 287) = 0uLL;
      *((_OWORD *)v110 + 286) = 0uLL;
      *((_OWORD *)v110 + 285) = 0uLL;
      *((_OWORD *)v110 + 284) = 0uLL;
      *((_OWORD *)v110 + 283) = 0uLL;
      *((_OWORD *)v110 + 282) = 0uLL;
      *((_OWORD *)v110 + 281) = 0uLL;
      *((_OWORD *)v110 + 280) = 0uLL;
      *((void *)v110 + 585) = 0xFFEFFFFFFFFFFFFFLL;
      *((_OWORD *)v110 + 293) = 0uLL;
      v109 += 224;
    }
    while (v109);
    long long v265 = 0u;
    long long v266 = 0u;
    long long v263 = 0u;
    long long v264 = 0u;
    long long v262 = 0u;
    long long v249 = 0u;
    long long v250 = 0u;
    long long v248 = 0x3FF0000000000000uLL;
    *(void *)((char *)&v249 + 7) = 0;
    *(void *)&long long v250 = &v262;
    *(void *)&long long v251 = v247;
    *(void *)&long long v288 = MEMORY[0x1E4F143A8];
    *((void *)&v288 + 1) = 0x40000000;
    *(void *)&long long v289 = ___ZL27update_completions_queue_v3P16_CompletionModelP13si_wordtrie_sPKcS4_myP23PQueue_CompletionItem_s_block_invoke;
    *((void *)&v289 + 1) = &__block_descriptor_tmp_32_1615;
    *(void *)&long long v290 = v106;
    *((void *)&v290 + 1) = *((void *)&v247 + 1);
    *(void *)&long long v291 = v241;
    *((void *)&v291 + 1) = &v275;
    *(void *)&long long v292 = v108;
    *((void *)&v292 + 1) = &v253;
    *(void *)&long long v293 = v47;
    bzero(v301, 0x1400uLL);
    word_trie_s::iterateFragments(v45 + 16, (uint64_t)v301, 0, 0, &v248, (uint64_t)&v288, 0, 0);
  }
  CFRelease(v105);
  free(v47);
  v234 = v232;
  uint64_t v111 = v241;
  uint64_t v112 = 224 * v241;
  MEMORY[0x1F4188790](v113);
  v236 = &v232[-v112];
  bzero(&v232[-v112], 224 * v111);
  MEMORY[0x1F4188790](v114);
  unint64_t v115 = (8 * v111 + 15) & 0xFFFFFFFFFFFFFFF0;
  long long v246 = &v232[-v115];
  bzero(&v232[-v115], 8 * v111);
  MEMORY[0x1F4188790](v116);
  v237 = &v232[-v112];
  bzero(&v232[-v112], 224 * v111);
  MEMORY[0x1F4188790](v117);
  v238 = &v232[-v115];
  bzero(&v232[-v115], 8 * v111);
  unsigned int v118 = (const CFSetCallBacks *)MEMORY[0x1E4F1D548];
  CFAllocatorRef v119 = v239;
  CFSetRef Mutable = CFSetCreateMutable(v239, 0, MEMORY[0x1E4F1D548]);
  CFSetRef v243 = CFSetCreateMutable(v119, 0, v118);
  unsigned int v235 = ((double)v111 * 0.5);
  uint64_t v120 = v256;
  uint64_t v121 = v256 - 1;
  if (v256 == 1)
  {
    unsigned int v240 = 0;
    goto LABEL_112;
  }
  unsigned int v240 = 0;
  while (2)
  {
    uint64_t v122 = v255;
    long long v123 = *(_OWORD *)(v255 + 336);
    long long v268 = *(_OWORD *)(v255 + 320);
    long long v269 = v123;
    long long v270 = *(_OWORD *)(v255 + 352);
    long long v124 = *(_OWORD *)(v255 + 272);
    long long v264 = *(_OWORD *)(v255 + 256);
    long long v265 = v124;
    long long v125 = *(_OWORD *)(v255 + 304);
    long long v266 = *(_OWORD *)(v255 + 288);
    long long v267 = v125;
    long long v126 = *(_OWORD *)(v255 + 240);
    long long v262 = *(_OWORD *)(v255 + 224);
    long long v263 = v126;
    *((void *)&v247 + 1) = *(void *)(v255 + 368);
    long long v127 = *(_OWORD *)(v255 + 392);
    long long v128 = *(_OWORD *)(v255 + 424);
    long long v250 = *(_OWORD *)(v255 + 408);
    long long v251 = v128;
    uint64_t v252 = *(void *)(v255 + 440);
    long long v248 = *(_OWORD *)(v255 + 376);
    long long v249 = v127;
    CFRange v129 = (_OWORD *)(v255 + 224 * v121);
    long long v297 = v129[9];
    long long v298 = v129[10];
    long long v299 = v129[11];
    uint64_t v300 = *((void *)v129 + 24);
    long long v293 = v129[5];
    long long v294 = v129[6];
    long long v295 = v129[7];
    long long v296 = v129[8];
    long long v289 = v129[1];
    long long v290 = v129[2];
    long long v291 = v129[3];
    long long v292 = v129[4];
    long long v288 = *v129;
    double v130 = *((double *)v129 + 25);
    long long v260 = v129[13];
    memmove((void *)(v255 + 224), v129, 0xC8uLL);
    *(double *)(v122 + 424) = v130;
    *(_OWORD *)(v122 + 432) = v129[13];
    uint64_t v256 = v121;
    uint64_t v131 = *((uint64_t *)&v255 + 1) >> 1;
    long long v310 = v298;
    long long v311 = v299;
    *(void *)&long long v312 = v300;
    long long v306 = v294;
    long long v307 = v295;
    long long v309 = v297;
    long long v308 = v296;
    long long v302 = v290;
    long long v303 = v291;
    long long v305 = v293;
    long long v304 = v292;
    uint64_t v132 = 1;
    uint64_t v133 = 2;
    uint64_t v134 = 3;
    v301[1] = v289;
    v301[0] = v288;
    while (2)
    {
      uint64_t v135 = v255 + 224 * v133;
      double v136 = *(double *)(v135 + 200);
      long long v257 = *(_OWORD *)(v135 + 208);
      uint64_t v137 = v255 + 224 * v134;
      long long v284 = *(_OWORD *)(v137 + 144);
      long long v285 = *(_OWORD *)(v137 + 160);
      long long v286 = *(_OWORD *)(v137 + 176);
      uint64_t v287 = *(void *)(v137 + 192);
      long long v280 = *(_OWORD *)(v137 + 80);
      long long v281 = *(_OWORD *)(v137 + 96);
      long long v282 = *(_OWORD *)(v137 + 112);
      long long v283 = *(_OWORD *)(v137 + 128);
      long long v276 = *(_OWORD *)(v137 + 16);
      long long v277 = *(_OWORD *)(v137 + 32);
      long long v278 = *(_OWORD *)(v137 + 48);
      long long v279 = *(_OWORD *)(v137 + 64);
      long long v275 = *(_OWORD *)v137;
      double v138 = *(double *)(v137 + 200);
      long long v261 = *(_OWORD *)(v137 + 208);
      if (v134 >= v120)
      {
        long long v285 = xmmword_1BDA7EF70;
        long long v286 = unk_1BDA7EF80;
        uint64_t v287 = 0;
        long long v281 = xmmword_1BDA7EF30;
        long long v282 = unk_1BDA7EF40;
        long long v283 = xmmword_1BDA7EF50;
        long long v284 = unk_1BDA7EF60;
        long long v277 = xmmword_1BDA7EEF0;
        long long v278 = unk_1BDA7EF00;
        long long v279 = xmmword_1BDA7EF10;
        long long v280 = unk_1BDA7EF20;
        long long v275 = max_CompletionItem_s;
        long long v276 = unk_1BDA7EEE0;
        long long v261 = xmmword_1BDA7EFA0;
        if (v133 >= v120) {
          goto LABEL_104;
        }
        double v138 = 1.79769313e308;
      }
      if (v136 < v130)
      {
        BOOL v139 = v138 < v136;
        if (v138 >= v136) {
          v140 = (long long *)(v255 + 224 * v133);
        }
        else {
          v140 = &v275;
        }
        if (v138 < v136)
        {
          char v141 = &v261;
        }
        else
        {
          double v138 = v136;
          char v141 = &v257;
        }
        if (!v139) {
          uint64_t v134 = v133;
        }
LABEL_96:
        long long v297 = v140[9];
        long long v298 = v140[10];
        long long v299 = v140[11];
        uint64_t v300 = *((void *)v140 + 24);
        long long v293 = v140[5];
        long long v294 = v140[6];
        long long v295 = v140[7];
        long long v296 = v140[8];
        long long v289 = v140[1];
        long long v290 = v140[2];
        long long v291 = v140[3];
        long long v292 = v140[4];
        long long v288 = *v140;
        _X11 = v255 + 448 * v134;
        __asm { PRFM            #1, [X11] }
        if (v134 == v132) {
          goto LABEL_104;
        }
        uint64_t v133 = 2 * v134;
        uint64_t v144 = v255 + 224 * v134;
        *(_OWORD *)(v144 + 144) = v309;
        *(_OWORD *)(v144 + 160) = v310;
        *(_OWORD *)(v144 + 176) = v311;
        *(void *)(v144 + 192) = v312;
        *(_OWORD *)(v144 + 80) = v305;
        *(_OWORD *)(v144 + 96) = v306;
        *(_OWORD *)(v144 + 112) = v307;
        *(_OWORD *)(v144 + 128) = v308;
        *(_OWORD *)(v144 + 16) = v301[1];
        *(_OWORD *)(v144 + 32) = v302;
        *(_OWORD *)(v144 + 48) = v303;
        *(_OWORD *)(v144 + 64) = v304;
        *(_OWORD *)uint64_t v144 = v301[0];
        *(double *)(v144 + 200) = v130;
        *(_OWORD *)(v144 + 208) = v260;
        uint64_t v145 = v255 + 224 * v132;
        uint64_t v132 = v134;
        *(_OWORD *)uint64_t v145 = v288;
        *(_OWORD *)(v145 + 144) = v297;
        *(_OWORD *)(v145 + 160) = v298;
        *(_OWORD *)(v145 + 176) = v299;
        *(void *)(v145 + 192) = v300;
        *(_OWORD *)(v145 + 80) = v293;
        *(_OWORD *)(v145 + 96) = v294;
        *(_OWORD *)(v145 + 112) = v295;
        *(_OWORD *)(v145 + 128) = v296;
        *(_OWORD *)(v145 + 16) = v289;
        *(_OWORD *)(v145 + 32) = v290;
        *(_OWORD *)(v145 + 48) = v291;
        *(_OWORD *)(v145 + 64) = v292;
        *(double *)(v145 + 200) = v138;
        *(_OWORD *)(v145 + 208) = *v141;
        long long v298 = v310;
        long long v299 = v311;
        uint64_t v300 = v312;
        long long v294 = v306;
        long long v295 = v307;
        long long v297 = v309;
        long long v296 = v308;
        long long v290 = v302;
        long long v291 = v303;
        long long v293 = v305;
        long long v292 = v304;
        long long v289 = v301[1];
        long long v288 = v301[0];
        BOOL v96 = v134 < v131;
        uint64_t v134 = (2 * v134) | 1;
        if (!v96) {
          goto LABEL_104;
        }
        continue;
      }
      break;
    }
    if (v138 < v130)
    {
      char v141 = &v261;
      v140 = &v275;
      goto LABEL_96;
    }
    _X8 = v255 + 448 * v132;
    __asm { PRFM            #1, [X8] }
LABEL_104:
    CFMutableStringRef v148 = (const void *)*((void *)&v247 + 1);
    if (*((void *)&v247 + 1))
    {
      v149 = Mutable;
      if (!contains_similar_string(*((const __CFString **)&v247 + 1), Mutable, (const char *)v247)
        && !CFSetContainsValue(v149, v148))
      {
        long long v150 = v269;
        unsigned int v151 = v240;
        CFAllocatorRef v152 = &v236[224 * v240];
        *((_OWORD *)v152 + 6) = v268;
        *((_OWORD *)v152 + 7) = v150;
        *((_OWORD *)v152 + 8) = v270;
        long long v153 = v265;
        *((_OWORD *)v152 + 2) = v264;
        *((_OWORD *)v152 + 3) = v153;
        long long v154 = v267;
        *((_OWORD *)v152 + 4) = v266;
        *((_OWORD *)v152 + 5) = v154;
        long long v155 = v263;
        *(_OWORD *)CFAllocatorRef v152 = v262;
        *((_OWORD *)v152 + 1) = v155;
        long long v156 = v248;
        *(_OWORD *)(v152 + 168) = v249;
        long long v157 = v251;
        *(_OWORD *)(v152 + 184) = v250;
        *(_OWORD *)(v152 + 200) = v157;
        *((void *)v152 + 18) = v148;
        *((void *)v152 + 27) = v252;
        *(_OWORD *)(v152 + 152) = v156;
        CFTypeRef v158 = CFRetain(v148);
        *(void *)&v246[8 * v151] = v158;
        CFSetAddValue(v149, v148);
        unsigned int v240 = v151 + 1;
      }
      CFRelease(v148);
    }
    uint64_t v120 = v256;
    uint64_t v121 = v256 - 1;
    if (v256 != 1) {
      continue;
    }
    break;
  }
LABEL_112:
  unsigned int v233 = v241 - v235;
  uint64_t v159 = v254;
  uint64_t v160 = v254 - 1;
  if (v254 == 1)
  {
    unsigned int v242 = 0;
    goto LABEL_141;
  }
  unsigned int v242 = 0;
  while (2)
  {
    uint64_t v161 = v253;
    long long v162 = *(_OWORD *)(v253 + 336);
    long long v268 = *(_OWORD *)(v253 + 320);
    long long v269 = v162;
    long long v270 = *(_OWORD *)(v253 + 352);
    long long v163 = *(_OWORD *)(v253 + 272);
    long long v264 = *(_OWORD *)(v253 + 256);
    long long v265 = v163;
    long long v164 = *(_OWORD *)(v253 + 304);
    long long v266 = *(_OWORD *)(v253 + 288);
    long long v267 = v164;
    long long v165 = *(_OWORD *)(v253 + 240);
    long long v262 = *(_OWORD *)(v253 + 224);
    long long v263 = v165;
    *((void *)&v247 + 1) = *(void *)(v253 + 368);
    long long v166 = *(_OWORD *)(v253 + 392);
    long long v167 = *(_OWORD *)(v253 + 424);
    long long v250 = *(_OWORD *)(v253 + 408);
    long long v251 = v167;
    uint64_t v252 = *(void *)(v253 + 440);
    long long v248 = *(_OWORD *)(v253 + 376);
    long long v249 = v166;
    char v168 = (_OWORD *)(v253 + 224 * v160);
    long long v297 = v168[9];
    long long v298 = v168[10];
    long long v299 = v168[11];
    uint64_t v300 = *((void *)v168 + 24);
    long long v293 = v168[5];
    long long v294 = v168[6];
    long long v295 = v168[7];
    long long v296 = v168[8];
    long long v289 = v168[1];
    long long v290 = v168[2];
    long long v291 = v168[3];
    long long v292 = v168[4];
    long long v288 = *v168;
    double v169 = *((double *)v168 + 25);
    long long v260 = v168[13];
    memmove((void *)(v253 + 224), v168, 0xC8uLL);
    *(double *)(v161 + 424) = v169;
    *(_OWORD *)(v161 + 432) = v168[13];
    uint64_t v254 = v160;
    uint64_t v170 = *((uint64_t *)&v253 + 1) >> 1;
    long long v310 = v298;
    long long v311 = v299;
    *(void *)&long long v312 = v300;
    long long v306 = v294;
    long long v307 = v295;
    long long v309 = v297;
    long long v308 = v296;
    long long v302 = v290;
    long long v303 = v291;
    long long v305 = v293;
    long long v304 = v292;
    uint64_t v171 = 1;
    uint64_t v172 = 2;
    uint64_t v173 = 3;
    v301[1] = v289;
    v301[0] = v288;
    while (2)
    {
      uint64_t v174 = v253 + 224 * v172;
      double v175 = *(double *)(v174 + 200);
      long long v257 = *(_OWORD *)(v174 + 208);
      uint64_t v176 = v253 + 224 * v173;
      long long v284 = *(_OWORD *)(v176 + 144);
      long long v285 = *(_OWORD *)(v176 + 160);
      long long v286 = *(_OWORD *)(v176 + 176);
      uint64_t v287 = *(void *)(v176 + 192);
      long long v280 = *(_OWORD *)(v176 + 80);
      long long v281 = *(_OWORD *)(v176 + 96);
      long long v282 = *(_OWORD *)(v176 + 112);
      long long v283 = *(_OWORD *)(v176 + 128);
      long long v276 = *(_OWORD *)(v176 + 16);
      long long v277 = *(_OWORD *)(v176 + 32);
      long long v278 = *(_OWORD *)(v176 + 48);
      long long v279 = *(_OWORD *)(v176 + 64);
      long long v275 = *(_OWORD *)v176;
      double v177 = *(double *)(v176 + 200);
      long long v261 = *(_OWORD *)(v176 + 208);
      if (v173 >= v159)
      {
        long long v285 = xmmword_1BDA7EF70;
        long long v286 = unk_1BDA7EF80;
        uint64_t v287 = 0;
        long long v281 = xmmword_1BDA7EF30;
        long long v282 = unk_1BDA7EF40;
        long long v283 = xmmword_1BDA7EF50;
        long long v284 = unk_1BDA7EF60;
        long long v277 = xmmword_1BDA7EEF0;
        long long v278 = unk_1BDA7EF00;
        long long v279 = xmmword_1BDA7EF10;
        long long v280 = unk_1BDA7EF20;
        long long v275 = max_CompletionItem_s;
        long long v276 = unk_1BDA7EEE0;
        long long v261 = xmmword_1BDA7EFA0;
        if (v172 >= v159) {
          goto LABEL_133;
        }
        double v177 = 1.79769313e308;
      }
      if (v175 < v169)
      {
        BOOL v178 = v177 < v175;
        if (v177 >= v175) {
          v179 = (long long *)(v253 + 224 * v172);
        }
        else {
          v179 = &v275;
        }
        if (v177 < v175)
        {
          char v180 = &v261;
        }
        else
        {
          double v177 = v175;
          char v180 = &v257;
        }
        if (!v178) {
          uint64_t v173 = v172;
        }
LABEL_125:
        long long v297 = v179[9];
        long long v298 = v179[10];
        long long v299 = v179[11];
        uint64_t v300 = *((void *)v179 + 24);
        long long v293 = v179[5];
        long long v294 = v179[6];
        long long v295 = v179[7];
        long long v296 = v179[8];
        long long v289 = v179[1];
        long long v290 = v179[2];
        long long v291 = v179[3];
        long long v292 = v179[4];
        long long v288 = *v179;
        _X11 = v253 + 448 * v173;
        __asm { PRFM            #1, [X11] }
        if (v173 == v171) {
          goto LABEL_133;
        }
        uint64_t v172 = 2 * v173;
        uint64_t v183 = v253 + 224 * v173;
        *(_OWORD *)(v183 + 144) = v309;
        *(_OWORD *)(v183 + 160) = v310;
        *(_OWORD *)(v183 + 176) = v311;
        *(void *)(v183 + 192) = v312;
        *(_OWORD *)(v183 + 80) = v305;
        *(_OWORD *)(v183 + 96) = v306;
        *(_OWORD *)(v183 + 112) = v307;
        *(_OWORD *)(v183 + 128) = v308;
        *(_OWORD *)(v183 + 16) = v301[1];
        *(_OWORD *)(v183 + 32) = v302;
        *(_OWORD *)(v183 + 48) = v303;
        *(_OWORD *)(v183 + 64) = v304;
        *(_OWORD *)uint64_t v183 = v301[0];
        *(double *)(v183 + 200) = v169;
        *(_OWORD *)(v183 + 208) = v260;
        uint64_t v184 = v253 + 224 * v171;
        uint64_t v171 = v173;
        *(_OWORD *)uint64_t v184 = v288;
        *(_OWORD *)(v184 + 144) = v297;
        *(_OWORD *)(v184 + 160) = v298;
        *(_OWORD *)(v184 + 176) = v299;
        *(void *)(v184 + 192) = v300;
        *(_OWORD *)(v184 + 80) = v293;
        *(_OWORD *)(v184 + 96) = v294;
        *(_OWORD *)(v184 + 112) = v295;
        *(_OWORD *)(v184 + 128) = v296;
        *(_OWORD *)(v184 + 16) = v289;
        *(_OWORD *)(v184 + 32) = v290;
        *(_OWORD *)(v184 + 48) = v291;
        *(_OWORD *)(v184 + 64) = v292;
        *(double *)(v184 + 200) = v177;
        *(_OWORD *)(v184 + 208) = *v180;
        long long v298 = v310;
        long long v299 = v311;
        uint64_t v300 = v312;
        long long v294 = v306;
        long long v295 = v307;
        long long v297 = v309;
        long long v296 = v308;
        long long v290 = v302;
        long long v291 = v303;
        long long v293 = v305;
        long long v292 = v304;
        long long v289 = v301[1];
        long long v288 = v301[0];
        BOOL v96 = v173 < v170;
        uint64_t v173 = (2 * v173) | 1;
        if (!v96) {
          goto LABEL_133;
        }
        continue;
      }
      break;
    }
    if (v177 < v169)
    {
      char v180 = &v261;
      v179 = &v275;
      goto LABEL_125;
    }
    _X8 = v253 + 448 * v171;
    __asm { PRFM            #1, [X8] }
LABEL_133:
    CFStringRef v187 = (const __CFString *)*((void *)&v247 + 1);
    if (*((void *)&v247 + 1))
    {
      CFRange v188 = v243;
      if (!contains_similar_string(*((const __CFString **)&v247 + 1), v243, (const char *)v247)
        && !CFSetContainsValue(v188, v187))
      {
        long long v189 = v269;
        unsigned int v190 = v242;
        CFRange v191 = &v237[224 * v242];
        *((_OWORD *)v191 + 6) = v268;
        *((_OWORD *)v191 + 7) = v189;
        *((_OWORD *)v191 + 8) = v270;
        long long v192 = v265;
        *((_OWORD *)v191 + 2) = v264;
        *((_OWORD *)v191 + 3) = v192;
        long long v193 = v267;
        *((_OWORD *)v191 + 4) = v266;
        *((_OWORD *)v191 + 5) = v193;
        long long v194 = v263;
        *(_OWORD *)CFRange v191 = v262;
        *((_OWORD *)v191 + 1) = v194;
        long long v195 = v248;
        *(_OWORD *)(v191 + 168) = v249;
        long long v196 = v251;
        *(_OWORD *)(v191 + 184) = v250;
        *(_OWORD *)(v191 + 200) = v196;
        *((void *)v191 + 18) = v187;
        *((void *)v191 + 27) = v252;
        *(_OWORD *)(v191 + 152) = v195;
        CFStringRef Copy = CFStringCreateCopy(v239, v187);
        *(void *)&v238[8 * v190] = Copy;
        CFSetAddValue(v188, v187);
        unsigned int v242 = v190 + 1;
      }
      CFRelease(v187);
    }
    uint64_t v159 = v254;
    uint64_t v160 = v254 - 1;
    if (v254 != 1) {
      continue;
    }
    break;
  }
LABEL_141:
  if (v240 >= v235) {
    unsigned int v198 = v235;
  }
  else {
    unsigned int v198 = v240;
  }
  if (v242 >= v233) {
    unsigned int v199 = v233;
  }
  else {
    unsigned int v199 = v242;
  }
  if (v199 + v198 >= v241)
  {
    uint64_t v201 = v245;
  }
  else
  {
    unsigned int v200 = v242 - v233;
    if (v242 < v233) {
      unsigned int v200 = 0;
    }
    uint64_t v201 = v245;
    if (v240 <= v235 || v242 > v233)
    {
      if (v242 > v233 && v240 <= v235)
      {
        unsigned int v225 = v199 + v200;
        if (v225 >= v241) {
          unsigned int v199 = v241;
        }
        else {
          unsigned int v199 = v225;
        }
      }
    }
    else
    {
      unsigned int v202 = v240 - v235;
      if (v240 < v235) {
        unsigned int v202 = 0;
      }
      v198 += v202;
      if (v198 >= v241) {
        unsigned int v198 = v241;
      }
    }
  }
  LOBYTE(v275) = 0;
  uint64_t v203 = v240 - 1;
  if ((int)(v240 - 1) >= 0)
  {
    uint64_t v204 = v198;
    v205 = &v236[224 * v203];
    do
    {
      long long v206 = v205[11];
      long long v310 = v205[10];
      long long v311 = v206;
      long long v207 = v205[13];
      long long v312 = v205[12];
      long long v313 = v207;
      long long v208 = v205[7];
      long long v306 = v205[6];
      long long v307 = v208;
      long long v209 = v205[9];
      long long v308 = v205[8];
      long long v309 = v209;
      long long v210 = v205[3];
      long long v302 = v205[2];
      long long v303 = v210;
      long long v211 = v205[5];
      long long v304 = v205[4];
      long long v305 = v211;
      long long v212 = v205[1];
      v301[0] = *v205;
      v301[1] = v212;
      char v213 = *(const void **)&v246[8 * v203];
      *(void *)&long long v309 = v213;
      if (!(_BYTE)v275 && v204 != v203) {
        (*(void (**)(uint64_t, _OWORD *, long long *))(v201 + 16))(v201, v301, &v275);
      }
      if (v213) {
        CFRelease(v213);
      }
      v205 -= 14;
      BOOL v96 = v203-- <= 0;
    }
    while (!v96);
  }
  uint64_t v214 = v242 - 1;
  v215 = v238;
  if ((int)(v242 - 1) >= 0)
  {
    char v216 = &v237[224 * v214];
    do
    {
      long long v217 = v216[11];
      long long v310 = v216[10];
      long long v311 = v217;
      long long v218 = v216[13];
      long long v312 = v216[12];
      long long v313 = v218;
      long long v219 = v216[7];
      long long v306 = v216[6];
      long long v307 = v219;
      long long v220 = v216[9];
      long long v308 = v216[8];
      long long v309 = v220;
      long long v221 = v216[3];
      long long v302 = v216[2];
      long long v303 = v221;
      long long v222 = v216[5];
      long long v304 = v216[4];
      long long v305 = v222;
      long long v223 = v216[1];
      v301[0] = *v216;
      v301[1] = v223;
      v224 = *(const void **)&v215[8 * v214];
      *(void *)&long long v309 = v224;
      if (!(_BYTE)v275 && v199 != v214) {
        (*(void (**)(uint64_t, _OWORD *, long long *))(v201 + 16))(v201, v301, &v275);
      }
      if (v224) {
        CFRelease(v224);
      }
      v216 -= 14;
      BOOL v96 = v214-- <= 0;
    }
    while (!v96);
  }
  CFRelease(Mutable);
  CFRelease(v243);
  pqdispose_CompletionItem_s((void **)&v255);
  pqdispose_CompletionItem_s((void **)&v253);
}

void ___ZL24update_completions_queueP16_CompletionModelP13si_wordtrie_sPKcS4_myP23PQueue_CompletionItem_s_block_invoke(void *a1, SIModelManager *a2, SIModelManager *a3, unint64_t a4, long long *a5, uint64_t a6, int a7, int a8, double a9, double a10, double a11, int a12, int a13, int a14, __int16 a15, char a16, unsigned int a17, unsigned __int8 a18, uint64_t a19, uint64_t a20)
{
  uint64_t v255 = *MEMORY[0x1E4F143B8];
  unint64_t v28 = 0;
  if (a3)
  {
    char v29 = (uint64_t *)((char *)a2 + 8);
    int v30 = a3;
    do
    {
      uint64_t v31 = *v29;
      v29 += 2;
      v28 += v31;
      int v30 = (SIModelManager *)((char *)v30 - 1);
    }
    while (v30);
  }
  if (a17 && v28 <= a1[4]) {
    return;
  }
  unsigned __int8 v32 = a18;
  if (a17 == 2)
  {
    if (v28 < a18) {
      return;
    }
    unsigned __int8 v32 = 0;
  }
  unsigned __int8 v199 = v32;
  int v33 = *(SIModelManager **)(a20 + 16);
  double v35 = _hasPunctuation(a2, (unint64_t)a3, a20, 1);
  double v36 = v35;
  if ((unint64_t)a3 <= 1 && v35 != 0.0) {
    return;
  }
  uint64_t v37 = a1[5];
  if (v37) {
    LODWORD(v37) = *(_DWORD *)(v37 + 4);
  }
  unsigned int v38 = (v37 >> 1) & 1;
  if ((unint64_t)(a6 - 1) >= 0xFFFFFFFFFFFFFFFELL) {
    LOBYTE(v38) = 0;
  }
  if ((v38 & 1) != 0 || v35 == 0.0) {
    return;
  }
  uint64_t v197 = (uint64_t)a2;
  unsigned int v198 = a1;
  if (v33 == a3)
  {
    double v39 = *(double *)(a20 + 8);
    CFIndex v40 = a1;
  }
  else
  {
    CFIndex v40 = a1;
    uint64_t v41 = (char *)a1[6];
    SIModelManager::getInstance(v34);
    SIModelManager::getPhraseScore(v197, v41, a3, (char *)(a20 + 40));
    *(double *)(a20 + 8) = v39;
  }
  int v42 = a7;
  double v190 = a11;
  uint64_t v43 = (SIModelManager *)v40[7];
  unint64_t v44 = v40[8];
  if ((SIModelManager *)((char *)a3 + 1) == v43) {
    uint64_t v45 = 1;
  }
  else {
    uint64_t v45 = (SIModelManager *)((char *)a3 + 1) - v43;
  }
  float v46 = (float)a13;
  double v47 = *(double *)&qword_1E9FC9288;
  unint64_t v48 = *(void *)a5;
  unint64_t v49 = *((void *)a5 + 1);
  long long v217 = 0u;
  long long v218 = 0u;
  memset(v216, 0, sizeof(v216));
  long long v214 = 0u;
  long long v215 = 0u;
  long long v212 = 0u;
  long long v213 = 0u;
  long long v210 = 0u;
  long long v211 = 0u;
  long long v209 = 0u;
  long long v206 = 0u;
  *(void *)&long long v207 = 0;
  *((void *)&v207 + 1) = v28;
  *(void *)&long long v208 = a3;
  double v196 = a9;
  *((double *)&v208 + 1) = a9;
  long long v51 = *a5;
  long long v50 = a5[1];
  long long v52 = a5[2];
  long long v53 = a5[4];
  long long v213 = a5[3];
  long long v214 = v53;
  long long v211 = v50;
  long long v212 = v52;
  long long v210 = v51;
  *((void *)&v215 + 1) = __PAIR64__(a8, a7);
  LODWORD(v216[0]) = a12;
  *(_OWORD *)((char *)v216 + 4) = 0uLL;
  double v195 = v39;
  *((double *)&v216[1] + 1) = v39;
  double v54 = 0.0;
  double v55 = *(double *)&s_completion_weights;
  if (v49)
  {
    long double v56 = log((double)v49);
    float v46 = (float)a13;
    int v42 = a7;
    double v54 = v56 * 18.9648897;
  }
  float v57 = (float)v42;
  float v58 = (float)a8;
  float v59 = (float)a12;
  float v191 = v46 + 1.0;
  float v60 = v47;
  double v61 = v54 + (double)v48;
  double v187 = (double)v48;
  double v62 = log((double)v48);
  double v186 = v62;
  if (v61 == 0.0) {
    double v62 = 0.0;
  }
  double v63 = *(double *)&qword_1E9FC9250;
  double v64 = *(double *)&qword_1E9FC9248 * v62 + ((double)a7 + (double)v44) / (double)v44 * v55;
  unint64_t v65 = (unint64_t)*(double *)&qword_1E9FC92B8;
  unint64_t v189 = v48;
  if (v28 <= (unint64_t)*(double *)&qword_1E9FC92B8)
  {
    double v69 = log((double)v28) * (v63 + v63);
  }
  else
  {
    float v66 = v60;
    double v67 = (double)v65;
    double v193 = log((double)v65);
    long double v68 = (double)v28 - v67;
    float v60 = v66;
    float v58 = (float)a8;
    float v59 = (float)a12;
    double v69 = log(v68) * *(double *)&qword_1E9FC9290 + v193 * v63;
  }
  float v194 = v57 / v58;
  float v70 = v57 / v59;
  float v71 = v57 / (float)v44;
  double v72 = v60;
  double v73 = v64 + v69;
  double v74 = *(double *)&qword_1E9FC9258 * 1.5;
  float v75 = 1.0 / v191;
  uint64_t v76 = v45 - (uint64_t)*(double *)&qword_1E9FC92C0;
  if (v45 <= (uint64_t)*(double *)&qword_1E9FC92C0)
  {
    if (v45 >= 0) {
      uint64_t v79 = v45;
    }
    else {
      uint64_t v79 = v45 + 1;
    }
    double v78 = log((double)((v79 >> 1) + 1)) * v74;
  }
  else
  {
    double v77 = log((double)(uint64_t)*(double *)&qword_1E9FC92C0 * 0.5 + 1.0);
    double v78 = log((double)v76 * 0.5 + 1.0) * *(double *)&qword_1E9FC92A8 + v77 * v74;
  }
  uint64_t v80 = v198;
  double v81 = v73 + v78;
  double v82 = *(double *)&qword_1E9FC9260;
  if (v194 <= 0.25) {
    double v82 = 0.0;
  }
  double v83 = v81 + v82;
  if (v70 <= 0.25) {
    double v84 = 0.0;
  }
  else {
    double v84 = dbl_1E9FC9268;
  }
  double v85 = v83 + v84;
  double v192 = v71;
  double v86 = *(double *)&qword_1E9FC9270;
  if (v71 >= 0.1) {
    double v86 = 0.0;
  }
  double v87 = v75;
  double v88 = v85 + v86 + v195 * unk_1E9FC9278 + v75 * *(double *)&qword_1E9FC9280;
  if (!(_BYTE)a15) {
    double v72 = 0.0;
  }
  double v89 = v72 + v88;
  double v90 = *(double *)&qword_1E9FC9298;
  if (!a16) {
    double v90 = 0.0;
  }
  double v91 = v90 + v89;
  if (HIBYTE(a15)) {
    double v92 = dbl_1E9FC92A0;
  }
  else {
    double v92 = 0.0;
  }
  double v93 = v92 + v91 + 0.0;
  double v94 = *(double *)&qword_1E9FC92B0;
  double v95 = 157680000.0;
  if (v196 > 0.0) {
    double v95 = v196;
  }
  double v96 = log(v95);
  *(void *)&long long v218 = __PAIR64__(a17, LODWORD(v75));
  BYTE8(v218) = v199;
  *(_WORD *)((char *)&v218 + 9) = a15;
  BYTE11(v218) = a16;
  double v97 = v93 - v94 * v96 + -1.0 / v36;
  *((double *)&v217 + 1) = v97;
  switch(a17)
  {
    case 2u:
      double v98 = -1000000.0;
      break;
    case 3u:
      double v98 = -100000000.0;
      break;
    case 4u:
      double v98 = -1.0e10;
      break;
    default:
      int v99 = HIBYTE(a15);
      goto LABEL_60;
  }
  int v99 = HIBYTE(a15);
  double v97 = v97 + v98;
  *((double *)&v217 + 1) = v97;
LABEL_60:
  int v100 = *__error();
  int v101 = _SILogForLogForCategory(1);
  os_log_type_t v102 = 2 * (dword_1E9FC90A8 < 4);
  if (os_log_type_enabled(v101, v102))
  {
    double v200 = v72;
    double v103 = (double)(unint64_t)v198[8];
    double v104 = *(double *)&s_completion_weights;
    double v105 = 0.0;
    if (v49) {
      double v105 = log((double)v49) * 18.9648897;
    }
    double v106 = ((double)a7 + v103) / v103;
    BOOL v107 = v105 + v187 == 0.0;
    double v108 = v186;
    if (v107) {
      double v108 = 0.0;
    }
    double v188 = v108;
    unint64_t v109 = (unint64_t)*(double *)&qword_1E9FC92B8;
    double v110 = (double)(unint64_t)v198[4];
    double v111 = *(double *)&qword_1E9FC9250;
    float v185 = v70;
    if (v28 <= (unint64_t)*(double *)&qword_1E9FC92B8)
    {
      double v114 = (v111 + v111) * log((double)v28 - v110);
    }
    else
    {
      double v112 = (double)v109;
      double v113 = log((double)v109 - v110);
      double v114 = log((double)v28 - v112) * *(double *)&qword_1E9FC9290 + v113 * v111;
    }
    double v115 = v104 * v106;
    double v116 = *(double *)&qword_1E9FC9258 * 1.5;
    uint64_t v117 = v45 - (uint64_t)*(double *)&qword_1E9FC92C0;
    if (v45 <= (uint64_t)*(double *)&qword_1E9FC92C0)
    {
      if (v45 >= 0) {
        uint64_t v122 = v45;
      }
      else {
        uint64_t v122 = v45 + 1;
      }
      double v121 = log((double)((v122 >> 1) + 1)) * v116;
    }
    else
    {
      double v118 = v96;
      double v119 = v115;
      double v120 = log((double)(uint64_t)*(double *)&qword_1E9FC92C0 * 0.5 + 1.0);
      double v121 = log((double)v117 * 0.5 + 1.0) * *(double *)&qword_1E9FC92A8 + v120 * v116;
      double v115 = v119;
      double v96 = v118;
    }
    uint64_t v80 = v198;
    uint64_t v123 = qword_1E9FC9260;
    double v124 = dbl_1E9FC9268;
    if (v194 <= 0.25) {
      uint64_t v123 = 0;
    }
    if (v185 <= 0.25) {
      double v124 = 0.0;
    }
    double v125 = *(double *)&qword_1E9FC9270;
    if (v192 >= 0.1) {
      double v125 = 0.0;
    }
    uint64_t v126 = qword_1E9FC9298;
    double v127 = dbl_1E9FC92A0;
    if (!a16) {
      uint64_t v126 = 0;
    }
    if (!v99) {
      double v127 = 0.0;
    }
    *(_DWORD *)iovec buf = 134223104;
    double v220 = v115;
    __int16 v221 = 2048;
    *(double *)long long v222 = v188;
    *(_WORD *)&v222[8] = 2048;
    *(double *)&v222[10] = v114;
    *(_WORD *)&v222[18] = 2048;
    double v223 = v121;
    *(_WORD *)v224 = 2048;
    *(void *)&v224[2] = v123;
    __int16 v225 = 2048;
    *(double *)int v226 = v124;
    *(_WORD *)&v226[8] = 2048;
    *(double *)&v226[10] = v125;
    __int16 v227 = 2048;
    double v228 = v195 * unk_1E9FC9278;
    __int16 v229 = 2048;
    double v230 = *(double *)&qword_1E9FC9280 * v87;
    __int16 v231 = 2048;
    double v232 = v200;
    __int16 v233 = 2048;
    uint64_t v234 = v126;
    __int16 v235 = 2048;
    double v236 = v127;
    __int16 v237 = 2048;
    double v238 = v96 * *(double *)&qword_1E9FC92B0;
    __int16 v239 = 2048;
    unint64_t v240 = v28;
    __int16 v241 = 2048;
    uint64_t v242 = v45;
    __int16 v243 = 2048;
    v244 = a3;
    __int16 v245 = 2048;
    double v246 = v196;
    __int16 v247 = 2048;
    unint64_t v248 = v49;
    __int16 v249 = 2048;
    unint64_t v250 = v189;
    __int16 v251 = 1024;
    int v252 = a7;
    __int16 v253 = 2048;
    double v254 = v97;
    _os_log_impl(&dword_1BD672000, v101, v102, " weight_F:%g score_F:%g len_F:%g fragment_F:%g wf1_F:%g wf2_F:%g wf3_F:%g phrase_F:%g field_F:%g thread_F:%g shortcut_F:%g used_F:%g age_F:%g\nlen:%ld scoringFragmentCount:%ld fragmentCount:%ld age:%f score:(%llu, %llu) weight:%d computed score:(%g)", buf, 0xD0u);
  }
  *__error() = v100;
  unint64_t v128 = a4;
  if (a4 >= 0x14)
  {
    uint64_t v176 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v176, v177, v178, v179, v180, v181, v182, v183, (char)"SICompletions.cpp");
    free(v176);
    if (__valid_fs(-1)) {
      uint64_t v184 = 2989;
    }
    else {
      uint64_t v184 = 3072;
    }
    *(_DWORD *)uint64_t v184 = -559038737;
    abort();
  }
  CFRange v129 = (_OWORD *)(v80[9] + 224 * a4);
  long long v130 = v207;
  *CFRange v129 = v206;
  v129[1] = v130;
  long long v131 = v208;
  long long v132 = v209;
  long long v133 = v211;
  v129[4] = v210;
  v129[5] = v133;
  v129[2] = v131;
  v129[3] = v132;
  long long v134 = v212;
  long long v135 = v213;
  long long v136 = v215;
  v129[8] = v214;
  v129[9] = v136;
  v129[6] = v134;
  v129[7] = v135;
  long long v137 = v216[0];
  long long v138 = v216[1];
  long long v139 = v218;
  v129[12] = v217;
  v129[13] = v139;
  v129[10] = v137;
  v129[11] = v138;
  uint64_t v140 = v197;
  if (v190 == 1.79769313e308)
  {
    if (a3 == (SIModelManager *)1)
    {
      char v141 = (const void *)v80[10];
      if (v141)
      {
        size_t v142 = v80[4];
        if (v142 == *(void *)(v197 + 8) && !memcmp(v141, *(const void **)v197, v142)) {
          *(void *)(v80[9] + 224 * a4 + 200) = 0xFFEFFFFFFFFFFFFFLL;
        }
      }
    }
    return;
  }
  if (v190 == -1.79769313e308)
  {
    uint64_t v143 = v80[9] + 224 * a4;
    *(_OWORD *)(v143 + 384) = 0u;
    *(_OWORD *)(v143 + 400) = 0u;
    *(_OWORD *)(v143 + 352) = 0u;
    *(_OWORD *)(v143 + 368) = 0u;
    *(_OWORD *)(v143 + 320) = 0u;
    *(_OWORD *)(v143 + 336) = 0u;
    *(_OWORD *)(v143 + 288) = 0u;
    *(_OWORD *)(v143 + 304) = 0u;
    *(_OWORD *)(v143 + 256) = 0u;
    *(_OWORD *)(v143 + 272) = 0u;
    *(_OWORD *)(v143 + 224) = 0u;
    *(_OWORD *)(v143 + 240) = 0u;
    *(void *)(v143 + 416) = 0;
    *(void *)(v143 + 424) = 0xFFEFFFFFFFFFFFFFLL;
    *(void *)(v143 + 432) = 0;
    *(void *)(v143 + 440) = 0;
  }
  uint64_t v144 = (uint64_t *)v80[11];
  if (v144[2] >= 22)
  {
    uint64_t v145 = *v144;
    if (v145) {
      long long v146 = (double *)(v145 + 224);
    }
    else {
      long long v146 = (double *)&empty_CompletionItem_s;
    }
    double v147 = v146[25];
    if (v147 > *((double *)&v217 + 1)) {
      return;
    }
    double v149 = v146[3];
    uint64_t v148 = *((void *)v146 + 4);
    uint64_t v150 = *((void *)v146 + 5);
    double v151 = v146[9];
    uint64_t v201 = *((void *)v146 + 8);
    int v203 = *((_DWORD *)v146 + 38);
    int v152 = *__error();
    long long v153 = _SILogForLogForCategory(1);
    os_log_type_t v154 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v153, v154))
    {
      *(_DWORD *)iovec buf = 134219520;
      double v220 = v149;
      __int16 v221 = 2048;
      *(void *)long long v222 = v148;
      *(_WORD *)&v222[8] = 2048;
      *(void *)&v222[10] = v150;
      *(_WORD *)&v222[18] = 2048;
      double v223 = v151;
      *(_WORD *)v224 = 2048;
      *(void *)&v224[2] = v201;
      __int16 v225 = 1024;
      *(_DWORD *)int v226 = v203;
      *(_WORD *)&v226[4] = 2048;
      *(double *)&v226[6] = v147;
      _os_log_impl(&dword_1BD672000, v153, v154, "Pop: %ld %ld %f (%llu,%llu) %d (%g)", buf, 0x44u);
    }
    *__error() = v152;
    uint64_t v140 = v197;
    unint64_t v128 = a4;
  }
  if (v128 <= 1)
  {
    BOOL v155 = 0;
    double v162 = *((double *)&v217 + 1);
  }
  else
  {
    BOOL v155 = 1;
    uint64_t v156 = 424;
    uint64_t v157 = 1;
    while (1)
    {
      int v158 = *__error();
      uint64_t v159 = _SILogForLogForCategory(1);
      os_log_type_t v160 = 2 * (dword_1E9FC90A8 < 4);
      if (os_log_type_enabled(v159, v160))
      {
        uint64_t v161 = *(void *)(v80[9] + v156);
        *(void *)&v222[10] = *((void *)&v217 + 1);
        double v162 = *((double *)&v217 + 1);
        *(_DWORD *)iovec buf = 134218496;
        double v220 = *(double *)&v157;
        __int16 v221 = 2048;
        *(void *)long long v222 = v161;
        *(_WORD *)&v222[8] = 2048;
        _os_log_impl(&dword_1BD672000, v159, v160, "Comparing to parent at %ld (%g) %g", buf, 0x20u);
      }
      else
      {
        double v162 = *((double *)&v217 + 1);
      }
      *__error() = v158;
      if (*(double *)(v80[9] + v156) > v162) {
        break;
      }
      BOOL v155 = ++v157 < a4;
      v156 += 224;
      if (a4 == v157)
      {
        BOOL v155 = 0;
        goto LABEL_116;
      }
    }
    int v163 = *__error();
    long long v164 = _SILogForLogForCategory(1);
    os_log_type_t v165 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v164, v165))
    {
      uint64_t v166 = *(void *)(v80[9] + 224 * v157 + 200);
      *(_DWORD *)iovec buf = 134218496;
      double v220 = *(double *)&v157;
      __int16 v221 = 2048;
      *(void *)long long v222 = v166;
      *(_WORD *)&v222[8] = 2048;
      *(double *)&v222[10] = v162;
      _os_log_impl(&dword_1BD672000, v164, v165, "Dropping weak child %ld (%g) %g", buf, 0x20u);
    }
    *__error() = v163;
LABEL_116:
    uint64_t v140 = v197;
  }
  if (v162 <= v190)
  {
    int v172 = *__error();
    uint64_t v173 = _SILogForLogForCategory(1);
    os_log_type_t v174 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v173, v174))
    {
      *(_DWORD *)iovec buf = 134218240;
      double v220 = v190;
      __int16 v221 = 2048;
      *(double *)long long v222 = v162;
      _os_log_impl(&dword_1BD672000, v173, v174, "Dropping weak parent (%g) %g", buf, 0x16u);
    }
    *__error() = v172;
  }
  else if (!v155)
  {
    *(double *)&long long v167 = COERCE_DOUBLE(_CreateCFStringFromFragments((const char *)v80[12], (unsigned char *)&v218 + 8, v140, (uint64_t)a3, v28));
    int v168 = *__error();
    double v169 = _SILogForLogForCategory(1);
    os_log_type_t v170 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v169, v170))
    {
      uint64_t v171 = v80[12];
      *(_DWORD *)iovec buf = 138413570;
      double v220 = *(double *)&v167;
      __int16 v221 = 1024;
      *(_DWORD *)long long v222 = DWORD1(v218);
      *(_WORD *)&v222[4] = 2080;
      *(void *)&v222[6] = v171;
      *(_WORD *)&v222[14] = 1024;
      *(_DWORD *)&v222[16] = BYTE8(v218);
      LOWORD(v223) = 1024;
      *(_DWORD *)((char *)&v223 + 2) = DWORD2(v215);
      HIWORD(v223) = 2048;
      *(void *)v224 = *((void *)&v217 + 1);
      _os_log_impl(&dword_1BD672000, v169, v170, "Creating suggestion string %@, type %d, with completion %s length:%d weight:%d score:%g", buf, 0x32u);
    }
    *__error() = v168;
    if (*(double *)&v167 != 0.0)
    {
      if (CFEqual(v167, (CFTypeRef)v80[13]))
      {
        CFRelease(v167);
      }
      else
      {
        *(void *)&long long v215 = v167;
        double v175 = (void **)v80[11];
        v205[10] = v216[0];
        v205[11] = v216[1];
        v205[12] = v217;
        v205[13] = v218;
        v205[6] = v212;
        v205[7] = v213;
        v205[2] = v208;
        v205[3] = v209;
        v205[4] = v210;
        v205[5] = v211;
        v205[0] = v206;
        v205[1] = v207;
        v205[8] = v214;
        v205[9] = v215;
        pqpush_CompletionItem_s(v175, (uint64_t)v205);
      }
    }
  }
}

double ___ZL27update_completions_queue_v2P16_CompletionModelP13si_wordtrie_sPKcS4_myP23PQueue_CompletionItem_s_block_invoke(uint64_t a1, SIModelManager *a2, unint64_t a3, unint64_t a4, long long *a5, uint64_t a6, unsigned int a7, unsigned int a8, double a9, double a10, double a11, int a12, int a13, int a14, __int16 a15, char a16, int a17, unsigned __int8 a18, unsigned __int8 a19, uint64_t a20,uint64_t a21)
{
  unsigned __int8 v30 = a18;
  uint64_t v129 = *MEMORY[0x1E4F143B8];
  unint64_t v31 = 0;
  if (a3)
  {
    unsigned __int8 v32 = (uint64_t *)((char *)a2 + 8);
    unint64_t v33 = a3;
    do
    {
      uint64_t v34 = *v32;
      v32 += 2;
      v31 += v34;
      --v33;
    }
    while (v33);
  }
  uint64_t v35 = *(void *)(a1 + 40);
  if (!v35)
  {
    if (a17 == 3) {
      return -1.79769313e308;
    }
    goto LABEL_14;
  }
  int v36 = *(_DWORD *)(v35 + 4);
  if (a19 && (v36 & 4) != 0 && *(void *)(a1 + 48) != a19) {
    return -1.79769313e308;
  }
  if (a17 != 3)
  {
LABEL_14:
    uint64_t v37 = (size_t *)(a1 + 56);
    if (a17 && v31 < *(void *)(a1 + 56)) {
      return -1.79769313e308;
    }
    if (a17 == 2)
    {
      if (v31 < a18) {
        return -1.79769313e308;
      }
      unint64_t v100 = a4;
      int v103 = 0;
      unsigned __int8 v30 = 0;
    }
    else
    {
      unint64_t v100 = a4;
      int v103 = 0;
    }
    goto LABEL_20;
  }
  if ((v36 & 8) == 0) {
    return -1.79769313e308;
  }
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    if (a3 < 3) {
      return -1.79769313e308;
    }
  }
  else if (a3 < 5)
  {
    return -1.79769313e308;
  }
  unint64_t v100 = a4;
  os_log_type_t v102 = a2;
  *(void *)&long long valuePtr = a6;
  if (!*(void *)(v35 + 40)) {
    return -1.79769313e308;
  }
  CFNumberRef v61 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
  if (!v61) {
    return -1.79769313e308;
  }
  CFNumberRef v62 = v61;
  CFSetRef v63 = *(const __CFSet **)(v35 + 40);
  CFNumberRef v64 = v62;
  int v104 = CFSetContainsValue(v63, v62);
  CFRelease(v64);
  if (!v104) {
    return -1.79769313e308;
  }
  uint64_t v37 = (size_t *)(a1 + 56);
  if (v31 < *(void *)(a1 + 56)) {
    return -1.79769313e308;
  }
  int v103 = 1;
  a2 = v102;
LABEL_20:
  int v101 = a2;
  v38.n128_f64[0] = _hasPunctuation(a2, a3, a21, 0);
  if (a3 <= 1 && v38.n128_f64[0] != 0.0 && v31 == *v37) {
    return -1.79769313e308;
  }
  if ((v103 & 1) == 0)
  {
    uint64_t v39 = *(void *)(a1 + 40);
    if (v39)
    {
      if ((unint64_t)(a6 - 1) <= 0xFFFFFFFFFFFFFFFDLL && (*(_DWORD *)(v39 + 4) & 2) != 0) {
        return -1.79769313e308;
      }
    }
  }
  if (a14 < 2)
  {
    a10 = 0.0;
    if (v38.n128_f64[0] != 0.0) {
      goto LABEL_32;
    }
    return -1.79769313e308;
  }
  double v40 = -1.79769313e308;
  if (fabs(a10) <= fabs(*(double *)&xmmword_1EC02E4D8) && v38.n128_f64[0] != 0.0)
  {
LABEL_32:
    long long v117 = 0u;
    long long v118 = 0u;
    memset(v116, 0, sizeof(v116));
    long long v109 = 0u;
    long long v110 = 0u;
    long long v41 = *a5;
    long long v42 = a5[1];
    long long v111 = 0u;
    long long v112 = 0u;
    *((double *)&v108 + 1) = a9;
    *(double *)&long long v109 = a10;
    long long v44 = a5[2];
    long long v43 = a5[3];
    long long v113 = 0u;
    long long v114 = 0u;
    long long v110 = v41;
    long long v114 = a5[4];
    long long v115 = 0u;
    uint64_t v45 = *(void *)(a1 + 48);
    *(void *)&long long valuePtr = *(void *)(a1 + 56);
    *((void *)&valuePtr + 1) = v45;
    *(void *)&long long v107 = *(void *)(a1 + 64);
    *((void *)&v107 + 1) = v31;
    *(void *)&long long v108 = a3;
    long long v112 = v44;
    long long v113 = v43;
    long long v111 = v42;
    *((void *)&v115 + 1) = __PAIR64__(a8, a7);
    LODWORD(v116[0]) = a12;
    *(_OWORD *)((char *)v116 + 4) = 0uLL;
    *(void *)&long long v117 = v38.n128_u64[0];
    v38.n128_f32[0] = 1.0 / (float)((float)a13 + 1.0);
    *(float *)&long long v118 = v38.n128_f32[0];
    DWORD1(v118) = a17;
    BYTE8(v118) = v30;
    *(_WORD *)((char *)&v118 + 9) = a15;
    BYTE11(v118) = a16;
    BYTE12(v118) = (unint64_t)(a6 - 1) < 0xFFFFFFFFFFFFFFFELL;
    update_item_bundle_ids((uint64_t)&valuePtr, a20, v38);
    GetCompletionItemWeight(&valuePtr);
    *((void *)&v117 + 1) = v46;
    unint64_t v47 = v100;
    if (v100 >= 0x14)
    {
      double v85 = __si_assert_copy_extra_329();
      __message_assert_333((uint64_t)v85, v86, v87, v88, v89, v90, v91, v92, (char)"SICompletions.cpp");
      free(v85);
      if (__valid_fs(-1)) {
        uint64_t v93 = 2989;
      }
      else {
        uint64_t v93 = 3072;
      }
      *(_DWORD *)uint64_t v93 = -559038737;
      abort();
    }
    unint64_t v48 = (_OWORD *)(*(void *)(a1 + 72) + 224 * v100);
    long long v49 = v107;
    *unint64_t v48 = valuePtr;
    v48[1] = v49;
    long long v50 = v108;
    long long v51 = v109;
    long long v52 = v111;
    v48[4] = v110;
    v48[5] = v52;
    v48[2] = v50;
    v48[3] = v51;
    long long v53 = v112;
    long long v54 = v113;
    long long v55 = v115;
    v48[8] = v114;
    v48[9] = v55;
    v48[6] = v53;
    v48[7] = v54;
    long long v56 = v116[0];
    long long v57 = v116[1];
    long long v58 = v118;
    v48[12] = v117;
    v48[13] = v58;
    v48[10] = v56;
    v48[11] = v57;
    uint64_t v59 = (uint64_t)v101;
    if (a11 == 1.79769313e308)
    {
      if (a3 == 1)
      {
        float v60 = *(const void **)(a1 + 80);
        if (v60)
        {
          if (*v37 == *((void *)v101 + 1) && !memcmp(v60, *(const void **)v101, *v37))
          {
            *(void *)(*(void *)(a1 + 72) + 224 * v100 + 200) = 0xFFEFFFFFFFFFFFFFLL;
            return -1.79769313e308;
          }
        }
      }
      return *((double *)&v117 + 1);
    }
    if (a11 == -1.79769313e308)
    {
      uint64_t v66 = *(void *)(a1 + 72) + 224 * v100;
      *(_OWORD *)(v66 + 384) = 0u;
      *(_OWORD *)(v66 + 400) = 0u;
      *(_OWORD *)(v66 + 352) = 0u;
      *(_OWORD *)(v66 + 368) = 0u;
      *(_OWORD *)(v66 + 320) = 0u;
      *(_OWORD *)(v66 + 336) = 0u;
      *(_OWORD *)(v66 + 288) = 0u;
      *(_OWORD *)(v66 + 304) = 0u;
      *(_OWORD *)(v66 + 256) = 0u;
      *(_OWORD *)(v66 + 272) = 0u;
      *(_OWORD *)(v66 + 224) = 0u;
      *(_OWORD *)(v66 + 240) = 0u;
      *(void *)(v66 + 416) = 0;
      *(void *)(v66 + 424) = 0xFFEFFFFFFFFFFFFFLL;
      *(void *)(v66 + 432) = 0;
      *(void *)(v66 + 440) = 0;
    }
    double v67 = *(uint64_t **)(a1 + 88);
    if (v67[2] >= 22)
    {
      uint64_t v68 = *v67;
      if (v68) {
        double v69 = (double *)(v68 + 224);
      }
      else {
        double v69 = (double *)&empty_CompletionItem_s;
      }
      double v70 = v69[25];
      if (v70 > *((double *)&v117 + 1)) {
        return *((double *)&v117 + 1);
      }
      double v71 = v69[3];
      uint64_t v94 = *((void *)v69 + 4);
      uint64_t v95 = *((void *)v69 + 5);
      uint64_t v96 = *((void *)v69 + 9);
      uint64_t v97 = *((void *)v69 + 8);
      int v98 = *((_DWORD *)v69 + 38);
      int v99 = *__error();
      double v72 = _SILogForLogForCategory(1);
      os_log_type_t v73 = 2 * (dword_1E9FC90A8 < 4);
      if (os_log_type_enabled(v72, v73))
      {
        *(_DWORD *)iovec buf = 134219520;
        double v120 = v71;
        __int16 v121 = 2048;
        *(void *)uint64_t v122 = v94;
        *(_WORD *)&v122[8] = 2048;
        *(void *)&v122[10] = v95;
        *(_WORD *)&v122[18] = 2048;
        uint64_t v123 = v96;
        *(_WORD *)double v124 = 2048;
        *(void *)&v124[2] = v97;
        __int16 v125 = 1024;
        int v126 = v98;
        __int16 v127 = 2048;
        double v128 = v70;
        _os_log_impl(&dword_1BD672000, v72, v73, "Pop: %ld %ld %f (%llu,%llu) %d (%g)", buf, 0x44u);
      }
      *__error() = v99;
      unint64_t v47 = v100;
      uint64_t v59 = (uint64_t)v101;
    }
    if (a14 < 2
      || a11 == -1.79769313e308
      || v47 > 0x12
      || (uint64_t v74 = *(void *)(a1 + 72), *(double *)(v74 + 224 * (v47 + 1) + 200) == -1.79769313e308)
      || *(double *)(v74 + 224 * (v47 + 1) + 48) != *(double *)&v109)
    {
      if (v103) {
        CFStringFromCrossFieldFragments = _CreateCFStringFromCrossFieldFragments(SBYTE8(v118), v59, a3, v31);
      }
      else {
        CFStringFromCrossFieldFragments = _CreateCFStringFromFragments(*(const char **)(a1 + 96), (unsigned char *)&v118 + 8, v59, a3, v31);
      }
      uint64_t v79 = CFStringFromCrossFieldFragments;
      int v80 = *__error();
      double v81 = _SILogForLogForCategory(1);
      os_log_type_t v82 = 2 * (dword_1E9FC90A8 < 4);
      if (os_log_type_enabled(v81, v82))
      {
        uint64_t v83 = *(void *)(a1 + 96);
        *(_DWORD *)iovec buf = 138413570;
        double v120 = *(double *)&v79;
        __int16 v121 = 1024;
        *(_DWORD *)uint64_t v122 = DWORD1(v118);
        *(_WORD *)&v122[4] = 2080;
        *(void *)&v122[6] = v83;
        *(_WORD *)&v122[14] = 1024;
        *(_DWORD *)&v122[16] = BYTE8(v118);
        LOWORD(v123) = 1024;
        *(_DWORD *)((char *)&v123 + 2) = DWORD2(v115);
        HIWORD(v123) = 2048;
        *(void *)double v124 = *((void *)&v117 + 1);
        _os_log_impl(&dword_1BD672000, v81, v82, "Creating suggestion string %@, type %d, with completion %s length:%d weight:%d score:%g", buf, 0x32u);
      }
      *__error() = v80;
      if (*(double *)&v79 != 0.0)
      {
        *(void *)&long long v115 = v79;
        double v84 = *(void ***)(a1 + 88);
        v105[10] = v116[0];
        v105[11] = v116[1];
        v105[12] = v117;
        v105[13] = v118;
        v105[6] = v112;
        v105[7] = v113;
        v105[2] = v108;
        v105[3] = v109;
        v105[4] = v110;
        v105[5] = v111;
        v105[0] = valuePtr;
        v105[1] = v107;
        v105[8] = v114;
        v105[9] = v115;
        pqpush_CompletionItem_s(v84, (uint64_t)v105);
      }
    }
    else
    {
      int v75 = *__error();
      uint64_t v76 = _SILogForLogForCategory(1);
      os_log_type_t v77 = 2 * (dword_1E9FC90A8 < 4);
      if (os_log_type_enabled(v76, v77))
      {
        *(_DWORD *)iovec buf = 134218240;
        double v120 = a11;
        __int16 v121 = 2048;
        *(void *)uint64_t v122 = *((void *)&v117 + 1);
        _os_log_impl(&dword_1BD672000, v76, v77, "Dropping dangling parent (%g) %g", buf, 0x16u);
      }
      *__error() = v75;
    }
    return *((double *)&v117 + 1);
  }
  return v40;
}

void ___ZL27update_completions_queue_v3P16_CompletionModelP13si_wordtrie_sPKcS4_myP23PQueue_CompletionItem_s_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, __n128 *a5, uint64_t a6, unsigned int a7, unsigned int a8, double a9, double a10, double a11, int a12, int a13, int a14, __int16 a15, char a16, int a17, char a18, uint64_t a19)
{
  uint64_t v141 = *MEMORY[0x1E4F143B8];
  uint64_t v24 = 0;
  if (a3)
  {
    char v25 = (uint64_t *)(a2 + 8);
    uint64_t v26 = a3;
    do
    {
      uint64_t v27 = *v25;
      v25 += 2;
      v24 += v27;
      --v26;
    }
    while (v26);
  }
  long long v129 = 0u;
  long long v130 = 0u;
  memset(v128, 0, sizeof(v128));
  long long v121 = 0u;
  __n128 v122 = 0u;
  long long v118 = *(_OWORD *)(a1 + 32);
  __n128 v28 = *a5;
  __n128 v29 = a5[1];
  __n128 v123 = 0u;
  __n128 v124 = 0u;
  *((double *)&v120 + 1) = a9;
  double v30 = 0.0;
  if (a14 > 1) {
    double v30 = a10;
  }
  *(double *)&long long v121 = v30;
  __n128 v32 = a5[2];
  __n128 v31 = a5[3];
  __n128 v125 = 0uLL;
  __n128 v126 = 0uLL;
  __n128 v122 = v28;
  __n128 v123 = v29;
  __n128 v126 = a5[4];
  long long v127 = 0uLL;
  *(void *)&long long v119 = *(void *)(a1 + 48);
  *((void *)&v119 + 1) = v24;
  *(void *)&long long v120 = a3;
  __n128 v124 = v32;
  __n128 v125 = v31;
  *((void *)&v127 + 1) = __PAIR64__(a8, a7);
  LODWORD(v128[0]) = a12;
  *(_OWORD *)((char *)v128 + 4) = 0uLL;
  *(void *)&long long v129 = 0x3FF0000000000000;
  v31.n128_f32[0] = 1.0 / (float)((float)a13 + 1.0);
  *(float *)&long long v130 = v31.n128_f32[0];
  DWORD1(v130) = a17;
  BYTE8(v130) = a18;
  *(_WORD *)((char *)&v130 + 9) = a15;
  BYTE11(v130) = a16;
  BYTE12(v130) = (unint64_t)(a6 - 1) < 0xFFFFFFFFFFFFFFFELL;
  update_item_bundle_ids((uint64_t)&v118, a19, v31);
  GetCompletionItemWeight(&v118);
  *((void *)&v129 + 1) = v33;
  if (a4 > 0x13)
  {
    uint64_t v89 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v89, v90, v91, v92, v93, v94, v95, v96, (char)"SICompletions.cpp");
    free(v89);
    if (__valid_fs(-1)) {
      uint64_t v97 = 2989;
    }
    else {
      uint64_t v97 = 3072;
    }
    *(_DWORD *)uint64_t v97 = -559038737;
    abort();
  }
  uint64_t v34 = (_OWORD *)(*(void *)(a1 + 56) + 224 * a4);
  long long v35 = v119;
  *uint64_t v34 = v118;
  v34[1] = v35;
  long long v36 = v120;
  long long v37 = v121;
  __n128 v38 = v123;
  v34[4] = v122;
  v34[5] = v38;
  v34[2] = v36;
  void v34[3] = v37;
  __n128 v39 = v124;
  __n128 v40 = v125;
  long long v41 = v127;
  v34[8] = v126;
  v34[9] = v41;
  v34[6] = v39;
  v34[7] = v40;
  long long v42 = v128[0];
  long long v43 = v128[1];
  long long v44 = v130;
  v34[12] = v129;
  v34[13] = v44;
  v34[10] = v42;
  v34[11] = v43;
  if (a11 == 1.79769313e308)
  {
    if (a3 == 1)
    {
      uint64_t v45 = *(const void **)(a1 + 64);
      if (v45)
      {
        size_t v46 = *(void *)(a1 + 32);
        if (v46 == *(void *)(a2 + 8) && !memcmp(v45, *(const void **)a2, v46)) {
          *(void *)(*(void *)(a1 + 56) + 224 * a4 + 200) = 0xFFEFFFFFFFFFFFFFLL;
        }
      }
    }
    return;
  }
  if (a11 == -1.79769313e308)
  {
    uint64_t v47 = *(void *)(a1 + 56) + 224 * a4;
    *(_OWORD *)(v47 + 384) = 0u;
    *(_OWORD *)(v47 + 400) = 0u;
    *(_OWORD *)(v47 + 352) = 0u;
    *(_OWORD *)(v47 + 368) = 0u;
    *(_OWORD *)(v47 + 320) = 0u;
    *(_OWORD *)(v47 + 336) = 0u;
    *(_OWORD *)(v47 + 288) = 0u;
    *(_OWORD *)(v47 + 304) = 0u;
    *(_OWORD *)(v47 + 256) = 0u;
    *(_OWORD *)(v47 + 272) = 0u;
    *(_OWORD *)(v47 + 224) = 0u;
    *(_OWORD *)(v47 + 240) = 0u;
    *(void *)(v47 + 416) = 0;
    *(void *)(v47 + 424) = 0xFFEFFFFFFFFFFFFFLL;
    *(void *)(v47 + 432) = 0;
    *(void *)(v47 + 440) = 0;
  }
  unint64_t v48 = *(uint64_t **)(a1 + 72);
  if (v48[2] >= 22)
  {
    uint64_t v49 = *v48;
    if (v49) {
      long long v50 = (double *)(v49 + 224);
    }
    else {
      long long v50 = (double *)&empty_CompletionItem_s;
    }
    double v51 = v50[25];
    if (v51 > *((double *)&v129 + 1)) {
      return;
    }
    uint64_t v52 = *((void *)v50 + 3);
    uint64_t v98 = *((void *)v50 + 4);
    uint64_t v99 = *((void *)v50 + 5);
    uint64_t v100 = *((void *)v50 + 9);
    uint64_t v101 = *((void *)v50 + 8);
    int v102 = *((_DWORD *)v50 + 38);
    int v103 = *__error();
    long long v53 = _SILogForLogForCategory(1);
    os_log_type_t v54 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v53, v54))
    {
      *(_DWORD *)iovec buf = 134219520;
      *(void *)&uint8_t buf[4] = v52;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v98;
      *(_WORD *)&buf[22] = 2048;
      *(void *)&uint8_t buf[24] = v99;
      *(_WORD *)&buf[32] = 2048;
      *(void *)&buf[34] = v100;
      *(_WORD *)&buf[42] = 2048;
      *(void *)&buf[44] = v101;
      *(_WORD *)&buf[52] = 1024;
      *(_DWORD *)&buf[54] = v102;
      *(_WORD *)&buf[58] = 2048;
      *(double *)&buf[60] = v51;
      _os_log_impl(&dword_1BD672000, v53, v54, "Pop: %ld %ld %f (%llu,%llu) %d (%g)", buf, 0x44u);
    }
    *__error() = v103;
  }
  if (a11 == -1.79769313e308
    || a4 > 0x12
    || (uint64_t v55 = *(void *)(a1 + 56), *(double *)(v55 + 224 * (a4 + 1) + 200) == -1.79769313e308)
    || *(double *)(v55 + 224 * (a4 + 1) + 48) != *(double *)&v121)
  {
    CFStringFromFragments = _CreateCFStringFromFragments(*(const char **)(a1 + 80), (unsigned char *)&v130 + 8, a2, a3, v24);
    int v60 = *__error();
    CFNumberRef v61 = _SILogForLogForCategory(1);
    os_log_type_t v62 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v61, v62))
    {
      uint64_t v63 = *(void *)(a1 + 80);
      *(_DWORD *)iovec buf = 138413570;
      *(void *)&uint8_t buf[4] = CFStringFromFragments;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = DWORD1(v130);
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = v63;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = BYTE8(v130);
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = DWORD2(v127);
      *(_WORD *)&buf[40] = 2048;
      *(void *)&buf[42] = *((void *)&v129 + 1);
      _os_log_impl(&dword_1BD672000, v61, v62, "Creating suggestion string %@, type %d, with completion %s length:%d weight:%d score:%g", buf, 0x32u);
    }
    *__error() = v60;
    if (CFStringFromFragments)
    {
      *(void *)&long long v127 = CFStringFromFragments;
      CFNumberRef v64 = *(void ***)(a1 + 72);
      long long v114 = v128[0];
      long long v115 = v128[1];
      long long v116 = v129;
      long long v117 = v130;
      __n128 v110 = v124;
      __n128 v111 = v125;
      long long v106 = v120;
      long long v107 = v121;
      __n128 v108 = v122;
      __n128 v109 = v123;
      long long v104 = v118;
      long long v105 = v119;
      uint64_t v65 = (uint64_t)v64[1];
      unint64_t v66 = (unint64_t)v64[2];
      unint64_t v67 = v66;
      __n128 v112 = v126;
      long long v113 = v127;
      if ((uint64_t)(v66 + 2) >= v65)
      {
        uint64_t v68 = 2 * v65;
        if (v65 < 4) {
          uint64_t v68 = 4;
        }
        v64[1] = (void *)v68;
        size_t v69 = 224 * v68 + 448;
        if (*v64) {
          double v70 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, *v64, v69, 0xECA6AA46uLL);
        }
        else {
          double v70 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v69, 0x8DDAA030uLL);
        }
        double v71 = v70;
        if (!v70) {
          _log_fault_for_malloc_failure();
        }
        const UniChar *v64 = v71;
        v71[12] = 0u;
        v71[13] = 0u;
        v71[10] = 0u;
        v71[11] = 0u;
        v71[8] = 0u;
        v71[9] = 0u;
        v71[6] = 0u;
        v71[7] = 0u;
        v71[4] = 0u;
        v71[5] = 0u;
        v71[2] = 0u;
        v71[3] = 0u;
        *double v71 = 0u;
        v71[1] = 0u;
        unint64_t v67 = (unint64_t)v64[2];
      }
      v64[2] = (void *)(v67 + 1);
      double v72 = (char *)*v64 + 224 * v66;
      *((_OWORD *)v72 + 10) = v114;
      *((_OWORD *)v72 + 11) = v115;
      *((_OWORD *)v72 + 12) = v116;
      *((_OWORD *)v72 + 13) = v117;
      *((__n128 *)v72 + 6) = v110;
      *((__n128 *)v72 + 7) = v111;
      *((__n128 *)v72 + 8) = v112;
      *((_OWORD *)v72 + 9) = v113;
      *((_OWORD *)v72 + 2) = v106;
      *((_OWORD *)v72 + 3) = v107;
      *((__n128 *)v72 + 4) = v108;
      *((__n128 *)v72 + 5) = v109;
      *(_OWORD *)double v72 = v104;
      *((_OWORD *)v72 + 1) = v105;
      if ((uint64_t)v66 >= 2)
      {
        do
        {
          os_log_type_t v73 = (char *)*v64;
          unint64_t v74 = v66 >> 1;
          if (*((double *)*v64 + 28 * v66 + 25) > *((double *)*v64 + 28 * (v66 >> 1) + 25)) {
            break;
          }
          int v75 = &v73[224 * v66];
          long long v137 = *((_OWORD *)v75 + 10);
          long long v138 = *((_OWORD *)v75 + 11);
          long long v139 = *((_OWORD *)v75 + 12);
          long long v140 = *((_OWORD *)v75 + 13);
          long long v133 = *((_OWORD *)v75 + 6);
          long long v134 = *((_OWORD *)v75 + 7);
          long long v135 = *((_OWORD *)v75 + 8);
          long long v136 = *((_OWORD *)v75 + 9);
          *(_OWORD *)&buf[32] = *((_OWORD *)v75 + 2);
          *(_OWORD *)&buf[48] = *((_OWORD *)v75 + 3);
          *(_OWORD *)&buf[64] = *((_OWORD *)v75 + 4);
          long long v132 = *((_OWORD *)v75 + 5);
          *(_OWORD *)iovec buf = *(_OWORD *)v75;
          *(_OWORD *)&buf[16] = *((_OWORD *)v75 + 1);
          uint64_t v76 = &v73[224 * v74];
          long long v77 = *((_OWORD *)v76 + 1);
          *(_OWORD *)int v75 = *(_OWORD *)v76;
          *((_OWORD *)v75 + 1) = v77;
          long long v78 = *((_OWORD *)v76 + 2);
          long long v79 = *((_OWORD *)v76 + 3);
          long long v80 = *((_OWORD *)v76 + 5);
          *((_OWORD *)v75 + 4) = *((_OWORD *)v76 + 4);
          *((_OWORD *)v75 + 5) = v80;
          *((_OWORD *)v75 + 2) = v78;
          *((_OWORD *)v75 + 3) = v79;
          long long v81 = *((_OWORD *)v76 + 6);
          long long v82 = *((_OWORD *)v76 + 7);
          long long v83 = *((_OWORD *)v76 + 9);
          *((_OWORD *)v75 + 8) = *((_OWORD *)v76 + 8);
          *((_OWORD *)v75 + 9) = v83;
          *((_OWORD *)v75 + 6) = v81;
          *((_OWORD *)v75 + 7) = v82;
          long long v84 = *((_OWORD *)v76 + 10);
          long long v85 = *((_OWORD *)v76 + 11);
          long long v86 = *((_OWORD *)v76 + 13);
          *((_OWORD *)v75 + 12) = *((_OWORD *)v76 + 12);
          *((_OWORD *)v75 + 13) = v86;
          *((_OWORD *)v75 + 10) = v84;
          *((_OWORD *)v75 + 11) = v85;
          uint64_t v87 = (char *)*v64 + 224 * v74;
          *((_OWORD *)v87 + 10) = v137;
          *((_OWORD *)v87 + 11) = v138;
          *((_OWORD *)v87 + 12) = v139;
          *((_OWORD *)v87 + 13) = v140;
          *((_OWORD *)v87 + 6) = v133;
          *((_OWORD *)v87 + 7) = v134;
          *((_OWORD *)v87 + 8) = v135;
          *((_OWORD *)v87 + 9) = v136;
          *((_OWORD *)v87 + 2) = *(_OWORD *)&buf[32];
          *((_OWORD *)v87 + 3) = *(_OWORD *)&buf[48];
          *((_OWORD *)v87 + 4) = *(_OWORD *)&buf[64];
          *((_OWORD *)v87 + 5) = v132;
          *(_OWORD *)uint64_t v87 = *(_OWORD *)buf;
          *((_OWORD *)v87 + 1) = *(_OWORD *)&buf[16];
          BOOL v88 = v66 > 3;
          v66 >>= 1;
        }
        while (v88);
      }
    }
  }
  else
  {
    int v56 = *__error();
    long long v57 = _SILogForLogForCategory(1);
    os_log_type_t v58 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v57, v58))
    {
      *(_DWORD *)iovec buf = 134218240;
      *(double *)&uint8_t buf[4] = a11;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = *((void *)&v129 + 1);
      _os_log_impl(&dword_1BD672000, v57, v58, "Dropping dangling parent (%g) %g", buf, 0x16u);
    }
    *__error() = v56;
  }
}

BOOL contains_similar_string(const __CFString *a1, CFSetRef theSet, const char *a3)
{
  buf[3] = *MEMORY[0x1E4F143B8];
  if (!theSet || (CFIndex Count = CFSetGetCount(theSet)) == 0) {
    return 0;
  }
  uint64_t v6 = Count;
  CFIndex Length = CFStringGetLength(a1);
  v28[0] = Length;
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  uint64_t v26 = (uint64_t)&v26;
  MEMORY[0x1F4188790](MaximumSizeForEncoding);
  uint64_t v10 = (UInt8 *)&v26 - v9;
  bzero((char *)&v26 - v9, MaximumSizeForEncoding);
  v30.locatiouint64_t n = 0;
  v30.uint64_t length = Length;
  CFStringGetBytes(a1, v30, 0x8000100u, 0x2Du, 0, v10, MaximumSizeForEncoding, v28);
  v10[v28[0]] = 0;
  uint64_t v11 = icu_search_context_create();
  MEMORY[0x1F4188790](v11);
  uint64_t v13 = (char *)&v26 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v13, v12);
  CFSetGetValues(theSet, (const void **)v13);
  if (v6 < 1)
  {
    BOOL v15 = 0;
    goto LABEL_19;
  }
  uint64_t v14 = 0;
  BOOL v15 = 1;
  while (1)
  {
    CFStringRef v16 = *(const __CFString **)&v13[8 * v14];
    CFIndex v27 = 0;
    CFIndex v17 = CFStringGetLength(v16);
    CFIndex v27 = v17;
    unint64_t v18 = v17 - v28[0];
    if (v17 - v28[0] < 0) {
      unint64_t v18 = v28[0] - v17;
    }
    if (v18 > 3) {
      goto LABEL_12;
    }
    if (v17 != v28[0]) {
      break;
    }
    if (CFStringCompare(v16, a1, 0))
    {
      CFIndex v17 = v27;
      break;
    }
LABEL_12:
    BOOL v15 = ++v14 < v6;
    if (v6 == v14) {
      goto LABEL_19;
    }
  }
  CFIndex v19 = CFStringGetMaximumSizeForEncoding(v17, 0x8000100u);
  MEMORY[0x1F4188790](v19);
  int v21 = (UInt8 *)&v26 - v20;
  bzero((char *)&v26 - v20, v19);
  v31.uint64_t length = v27;
  v31.locatiouint64_t n = 0;
  CFStringGetBytes(v16, v31, 0x8000100u, 0x2Du, 0, v21, v19, &v27);
  v21[v27] = 0;
  v28[1] = 0;
  buf[0] = 0;
  if (!icu_search_match()) {
    goto LABEL_12;
  }
  int v22 = *__error();
  uint64_t v23 = _SILogForLogForCategory(1);
  os_log_type_t v24 = 2 * (dword_1E9FC90A8 < 4);
  if (os_log_type_enabled(v23, v24))
  {
    LODWORD(buf[0]) = 134217984;
    *(void *)((char *)buf + 4) = v27;
    _os_log_impl(&dword_1BD672000, v23, v24, "Dropping similar completion of length %ld", (uint8_t *)buf, 0xCu);
  }
  *__error() = v22;
LABEL_19:
  icu_ctx_release();
  return v15;
}

void update_item_bundle_ids(uint64_t a1, uint64_t a2, __n128 a3)
{
  if (a2)
  {
    int v3 = *(_DWORD *)(a2 + 24);
    if (v3 >= 3) {
      int v3 = 3;
    }
    int v24 = v3;
    *(_DWORD *)(a1 + 164) = v3;
    unint64_t v4 = *(__n128 **)(a2 + 16);
    if (v4)
    {
      uint64_t v5 = 0;
      uint64_t v6 = 0;
      unint64_t v7 = 0;
      do
      {
        unsigned __int32 v8 = v4[1].n128_u32[0];
        __n128 v28 = v4[4];
        __n128 v29 = v4[5];
        __n128 v30 = v4[6];
        __n128 v26 = v4[2];
        __n128 v27 = v4[3];
        if (v6 >= (__n128 *)v7)
        {
          unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((char *)v6 - v5) >> 5) + 1;
          if (v9 > 0x2AAAAAAAAAAAAAALL) {
            abort();
          }
          if (0x5555555555555556 * ((v7 - v5) >> 5) > v9) {
            unint64_t v9 = 0x5555555555555556 * ((v7 - v5) >> 5);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((v7 - v5) >> 5) >= 0x155555555555555) {
            unint64_t v10 = 0x2AAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v10 = v9;
          }
          if (v10)
          {
            if (v10 > 0x2AAAAAAAAAAAAAALL) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            uint64_t v11 = (char *)operator new(96 * v10);
          }
          else
          {
            uint64_t v11 = 0;
          }
          size_t v12 = &v11[32 * (((char *)v6 - v5) >> 5)];
          *(_DWORD *)size_t v12 = v8;
          *((__n128 *)v12 + 3) = v28;
          *((__n128 *)v12 + 4) = v29;
          *((__n128 *)v12 + 5) = v30;
          a3 = v27;
          *((__n128 *)v12 + 1) = v26;
          *((__n128 *)v12 + 2) = v27;
          uint64_t v13 = (__n128 *)v12;
          while (v6 != (__n128 *)v5)
          {
            __int32 v14 = v6[-6].n128_i32[0];
            v6 -= 6;
            v13[-6].n128_u32[0] = v14;
            v13 -= 6;
            v13[1] = v6[1];
            a3 = v6[2];
            __n128 v15 = v6[3];
            __n128 v16 = v6[5];
            v13[4] = v6[4];
            v13[5] = v16;
            v13[2] = a3;
            void v13[3] = v15;
          }
          unint64_t v7 = &v11[96 * v10];
          uint64_t v6 = (__n128 *)(v12 + 96);
          if (v5) {
            operator delete(v5);
          }
          uint64_t v5 = (char *)v13;
        }
        else
        {
          v6->n128_u32[0] = v8;
          v6[1] = v26;
          a3 = v27;
          v6[4] = v29;
          v6[5] = v30;
          v6[2] = v27;
          void v6[3] = v28;
          v6 += 6;
        }
        unint64_t v4 = (__n128 *)v4->n128_u64[0];
      }
      while (v4);
    }
    else
    {
      uint64_t v6 = 0;
      uint64_t v5 = 0;
    }
    unint64_t v17 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (((char *)v6 - v5) >> 5));
    if (v6 == (__n128 *)v5) {
      uint64_t v18 = 0;
    }
    else {
      uint64_t v18 = v17;
    }
    std::__introsort<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *,false>((unint64_t)v5, (int *)v6, v18, 1, a3);
    if (v6 != (__n128 *)v5)
    {
      CFIndex v19 = (_DWORD *)(a1 + 168);
      if (v24 <= 1) {
        uint64_t v20 = 1;
      }
      else {
        uint64_t v20 = v24;
      }
      uint64_t v21 = v20 - 1;
      int v22 = (__n128 *)(v5 + 96);
      do
      {
        *v19++ = v22[-6].n128_u32[0];
        if (!v21) {
          break;
        }
        --v21;
        BOOL v23 = v22 == v6;
        v22 += 6;
      }
      while (!v23);
    }
    if (v5)
    {
      operator delete(v5);
    }
  }
}

__CFString *_CreateCFStringFromFragments(const char *a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2) {
    unsigned int v9 = *a2;
  }
  else {
    unsigned int v9 = 0;
  }
  CFSetRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a5 + v9 + 1);
  uint64_t v11 = Mutable;
  if (v9)
  {
    char v12 = a1[v9];
    a1[v9] = 0;
    CFStringAppendCString(Mutable, a1, 0x8000100u);
    a1[v9] = v12;
    *a2 = CFStringGetLength(v11);
  }
  if (a4)
  {
    uint64_t v13 = (CFIndex *)(a3 + 8);
    do
    {
      CFStringAppendCharacters(v11, (const UniChar *)*(v13 - 1), *v13);
      v13 += 2;
      --a4;
    }
    while (a4);
  }
  return v11;
}

double _hasPunctuation(SIModelManager *IsCharacterMember, unint64_t a2, uint64_t a3, int a4)
{
  double v4 = 0.0;
  if (!a2) {
    return v4;
  }
  unsigned __int32 v8 = IsCharacterMember;
  if (_hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::onceToken != -1) {
    dispatch_once(&_hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::onceToken, &__block_literal_global_17_1634);
  }
  int v9 = *(_DWORD *)(a3 + 24);
  if (v9 < 0) {
    return v4;
  }
  if (*(void *)(a3 + 16) == a2)
  {
    if (!v9) {
      return *(double *)a3;
    }
    return v4;
  }
  *(void *)(a3 + 16) = a2;
  if (*(unsigned char *)(a3 + 30))
  {
LABEL_9:
    *(unsigned char *)(a3 + 30) = 1;
    *(void *)a3 = 0;
    return v4;
  }
  uint64_t v10 = (uint64_t)v8 + 16 * a2;
  uint64_t v11 = *(SIModelManager **)(v10 - 16);
  unint64_t v13 = *(void *)(v10 - 8);
  uint64_t v12 = v10 - 16;
  if (!v13)
  {
    unint64_t v17 = 0;
    char v18 = *(unsigned char *)(a3 + 29) != 0;
    char v19 = *(unsigned char *)(a3 + 28) != 0;
    goto LABEL_40;
  }
  uint64_t v14 = 0;
  CFCharacterSetRef v15 = (const __CFCharacterSet *)_hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::newLineAndTabs;
  BOOL v16 = 1;
  do
  {
    int IsCharacterMember = (SIModelManager *)CFCharacterSetIsCharacterMember(v15, *((_WORD *)v11 + v14));
    if (IsCharacterMember) {
      break;
    }
    BOOL v16 = ++v14 < v13;
  }
  while (v13 != v14);
  if (v16) {
    goto LABEL_9;
  }
  uint64_t v11 = *(SIModelManager **)v12;
  unint64_t v17 = *(unsigned __int16 **)(v12 + 8);
  int v9 = *(_DWORD *)(a3 + 24);
  if (v9 < 0)
  {
    char v26 = 0;
    goto LABEL_43;
  }
  char v18 = *(unsigned char *)(a3 + 29) != 0;
  char v19 = *(unsigned char *)(a3 + 28) != 0;
  if (!v17)
  {
LABEL_40:
    *(unsigned char *)(a3 + 29) = v18 & 1;
    *(unsigned char *)(a3 + 28) = v19 & 1;
    *(_DWORD *)(a3 + 24) = v9;
    char v25 = (v18 | v19) ^ 1;
    if (v9) {
      char v26 = 0;
    }
    else {
      char v26 = v25;
    }
    goto LABEL_43;
  }
  uint64_t v20 = 0;
  while (1)
  {
    BOOL v21 = v20 == (unsigned __int16 *)((char *)v17 - 1) || v20 == 0;
    int v22 = *((unsigned __int16 *)v11 + (void)v20);
    if (!v21 || v22 != 39) {
      break;
    }
    v18 ^= 1u;
LABEL_37:
    uint64_t v20 = (unsigned __int16 *)((char *)v20 + 1);
    if (v20 == v17) {
      goto LABEL_40;
    }
  }
  if (v22 == 34)
  {
    v19 ^= 1u;
    goto LABEL_37;
  }
  for (uint64_t i = 0; i != 11; ++i)
  {
    if ((unsigned __int16)asc_1BDA86EA0[i] == v22)
    {
      *(_WORD *)(*(void *)(a3 + 32) + 2 * v9++) = word_1BDA86EB6[i];
      goto LABEL_37;
    }
  }
  if (v9 && *(unsigned __int16 *)(*(void *)(a3 + 32) + 2 * (v9 - 1)) == v22)
  {
    --v9;
    goto LABEL_37;
  }
  uint64_t v24 = 0;
  while ((unsigned __int16)word_1BDA86EB6[v24] != v22)
  {
    if (++v24 == 11) {
      goto LABEL_37;
    }
  }
  char v26 = 0;
  *(unsigned char *)(a3 + 29) = v18 & 1;
  *(unsigned char *)(a3 + 28) = v19 & 1;
  *(_DWORD *)(a3 + 24) = -1;
LABEL_43:
  double v4 = *(double *)a3;
  if (v17)
  {
    CFCharacterSetRef v27 = (const __CFCharacterSet *)_hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::characterSet;
    double v28 = 1.0;
    __n128 v29 = (UniChar *)v11;
    __n128 v30 = v17;
    do
    {
      UniChar v31 = *v29++;
      if (CFCharacterSetIsCharacterMember(v27, v31)) {
        double v28 = v28 * 0.1;
      }
      __n128 v30 = (unsigned __int16 *)((char *)v30 - 1);
    }
    while (v30);
    double v4 = v4 * v28;
    int IsCharacterMember = (SIModelManager *)CFCharacterSetIsCharacterMember((CFCharacterSetRef)_hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::whiteSpaceAndPunctuation, *((_WORD *)v11 + (void)v17 - 1));
    if (IsCharacterMember) {
      double v4 = v4 * 0.01;
    }
  }
  if (a2 >= 2) {
    *(double *)a3 = v4;
  }
  if (a4)
  {
    __n128 v32 = *(char **)(a3 + 48);
    SIModelManager::getInstance(IsCharacterMember);
    if (SIModelManager::isStopword(v11, v17, v32, v33)) {
      double v4 = v4 * 0.01;
    }
  }
  if (a2 <= 1) {
    *(double *)a3 = v4;
  }
  if ((v26 & 1) == 0) {
    return 0.0;
  }
  return v4;
}

__CFString *_CreateCFStringFromCrossFieldFragments(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFSetRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a4 + 1);
  CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  if (a3)
  {
    CFCharacterSetRef v9 = Predefined;
    uint64_t v10 = 0;
    char v11 = 1;
    do
    {
      if (a1)
      {
        a1 -= *(unsigned char *)(a2 + 16 * v10 + 8);
      }
      else
      {
        if ((v11 & 1) != 0 && (v12 = a2 + 16 * v10, v14 = *(void *)(v12 + 8), unint64_t v13 = (void *)(v12 + 8), v14))
        {
          uint64_t v15 = 0;
          do
          {
            if (!CFCharacterSetIsCharacterMember(v9, *(_WORD *)(*(void *)(a2 + 16 * v10) + 2 * v15))) {
              break;
            }
            ++v15;
          }
          while (v15 != *v13);
        }
        else
        {
          uint64_t v15 = 0;
        }
        CFStringAppendCharacters(Mutable, (const UniChar *)(*(void *)(a2 + 16 * v10) + 2 * v15), *(void *)(a2 + 16 * v10 + 8) - v15);
        a1 = 0;
        char v11 = 0;
      }
      ++v10;
    }
    while (v10 != a3);
  }
  return Mutable;
}

__n128 pqpush_CompletionItem_s(void **a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t)a1[1];
  unint64_t v5 = (unint64_t)a1[2];
  unint64_t v6 = v5;
  if ((uint64_t)(v5 + 2) >= v4)
  {
    uint64_t v7 = 2 * v4;
    if (v4 < 4) {
      uint64_t v7 = 4;
    }
    a1[1] = (void *)v7;
    size_t v8 = 224 * v7 + 448;
    if (*a1) {
      CFCharacterSetRef v9 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, *a1, v8, 0xECA6AA46uLL);
    }
    else {
      CFCharacterSetRef v9 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v8, 0x8DDAA030uLL);
    }
    uint64_t v10 = v9;
    if (!v9) {
      _log_fault_for_malloc_failure();
    }
    *a1 = v10;
    v10[12] = 0u;
    v10[13] = 0u;
    v10[10] = 0u;
    v10[11] = 0u;
    v10[8] = 0u;
    v10[9] = 0u;
    v10[6] = 0u;
    v10[7] = 0u;
    v10[4] = 0u;
    v10[5] = 0u;
    v10[2] = 0u;
    void v10[3] = 0u;
    _OWORD *v10 = 0u;
    v10[1] = 0u;
    unint64_t v6 = (unint64_t)a1[2];
  }
  a1[2] = (void *)(v6 + 1);
  uint64_t v11 = (uint64_t)*a1 + 224 * v5;
  __n128 result = *(__n128 *)(a2 + 16);
  *(_OWORD *)uint64_t v11 = *(_OWORD *)a2;
  long long v13 = *(_OWORD *)(a2 + 32);
  long long v14 = *(_OWORD *)(a2 + 48);
  long long v15 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(v11 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v11 + 80) = v15;
  *(_OWORD *)(v11 + 32) = v13;
  *(_OWORD *)(v11 + 48) = v14;
  long long v16 = *(_OWORD *)(a2 + 96);
  long long v17 = *(_OWORD *)(a2 + 112);
  long long v18 = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(v11 + 128) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(v11 + 144) = v18;
  *(_OWORD *)(v11 + 96) = v16;
  *(_OWORD *)(v11 + 112) = v17;
  long long v19 = *(_OWORD *)(a2 + 160);
  long long v20 = *(_OWORD *)(a2 + 176);
  long long v21 = *(_OWORD *)(a2 + 208);
  *(_OWORD *)(v11 + 192) = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(v11 + 208) = v21;
  *(_OWORD *)(v11 + 160) = v19;
  *(_OWORD *)(v11 + 176) = v20;
  *(__n128 *)(v11 + 16) = result;
  if ((uint64_t)v5 >= 2)
  {
    do
    {
      int v22 = (char *)*a1;
      result.n128_u64[0] = *((void *)*a1 + 28 * v5 + 25);
      unint64_t v23 = v5 >> 1;
      if (result.n128_f64[0] > *((double *)*a1 + 28 * (v5 >> 1) + 25)) {
        break;
      }
      uint64_t v24 = (__n128 *)&v22[224 * v5];
      __n128 v48 = v24[10];
      __n128 v49 = v24[11];
      __n128 v50 = v24[12];
      __n128 v51 = v24[13];
      __n128 v44 = v24[6];
      __n128 v45 = v24[7];
      __n128 v46 = v24[8];
      __n128 v47 = v24[9];
      __n128 v40 = v24[2];
      __n128 v41 = v24[3];
      __n128 v42 = v24[4];
      __n128 v43 = v24[5];
      __n128 v38 = *v24;
      __n128 v39 = v24[1];
      char v25 = (__n128 *)&v22[224 * v23];
      __n128 v26 = v25[1];
      __n128 *v24 = *v25;
      v24[1] = v26;
      __n128 v27 = v25[2];
      __n128 v28 = v25[3];
      __n128 v29 = v25[5];
      v24[4] = v25[4];
      v24[5] = v29;
      int v24[2] = v27;
      void v24[3] = v28;
      __n128 v30 = v25[6];
      __n128 v31 = v25[7];
      __n128 v32 = v25[9];
      v24[8] = v25[8];
      v24[9] = v32;
      v24[6] = v30;
      v24[7] = v31;
      __n128 v33 = v25[10];
      __n128 v34 = v25[11];
      __n128 v35 = v25[13];
      v24[12] = v25[12];
      v24[13] = v35;
      v24[10] = v33;
      v24[11] = v34;
      long long v36 = (__n128 *)((char *)*a1 + 224 * v23);
      v36[10] = v48;
      v36[11] = v49;
      v36[12] = v50;
      v36[13] = v51;
      v36[6] = v44;
      v36[7] = v45;
      v36[8] = v46;
      v36[9] = v47;
      v36[2] = v40;
      void v36[3] = v41;
      v36[4] = v42;
      v36[5] = v43;
      __n128 result = v38;
      *long long v36 = v38;
      v36[1] = v39;
      BOOL v37 = v5 > 3;
      v5 >>= 1;
    }
    while (v37);
  }
  return result;
}

void ___ZL15_hasPunctuationP18SIWordTrieFragmentmP10cachedInfob_block_invoke()
{
  CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetAlphaNumeric);
  CFCharacterSetRef v1 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  _hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::openPareuint64_t n = (uint64_t)CFCharacterSetCreateWithCharactersInString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"[(<\"");
  _hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::closePareuint64_t n = (uint64_t)CFCharacterSetCreateWithCharactersInString(v2, @"]>\""));
  CFMutableStringRef MutableCopy = CFCharacterSetCreateMutableCopy(v2, Predefined);
  CFCharacterSetUnion(MutableCopy, v1);
  CFCharacterSetInvert(MutableCopy);
  CFCharacterSetUnion(MutableCopy, (CFCharacterSetRef)_hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::openParen);
  CFCharacterSetUnion(MutableCopy, (CFCharacterSetRef)_hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::closeParen);
  _hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::characterSet = (uint64_t)CFCharacterSetCreateCopy(v2, MutableCopy);
  CFRelease(MutableCopy);
  CFCharacterSetRef v4 = CFCharacterSetCreateWithCharactersInString(v2, @"\t");
  CFCharacterSetRef v5 = CFCharacterSetGetPredefined(kCFCharacterSetNewline);
  unint64_t v6 = CFCharacterSetCreateMutableCopy(v2, v5);
  CFCharacterSetUnion(v6, v4);
  _hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::newLineAndTabs = (uint64_t)CFCharacterSetCreateCopy(v2, v6);
  CFRelease(v4);
  CFRelease(v6);
  CFCharacterSetRef v7 = CFCharacterSetCreateWithCharactersInString(v2, @"-");
  CFCharacterSetRef v8 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespaceAndNewline);
  CFCharacterSetRef v9 = CFCharacterSetCreateMutableCopy(v2, v8);
  CFCharacterSetUnion(v9, v7);
  CFCharacterSetRef v10 = CFCharacterSetGetPredefined(kCFCharacterSetPunctuation);
  CFCharacterSetUnion(v9, v10);
  _hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::whiteSpaceAndPunctuatiouint64_t n = (uint64_t)v9;
  CFRelease(v7);
}

uint64_t anonymous namespace'::stokencallback(_anonymous_namespace_ *this, const unsigned __int16 *a2, uint64_t a3, uint64_t *a4, void *a5)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  CFCharacterSetRef v8 = (void *)a4[3];
  if (v8)
  {
    uint64_t v9 = a4[1];
    if (v9 != *a4) {
      goto LABEL_8;
    }
    uint64_t v10 = 2 * v9;
  }
  else
  {
    uint64_t v10 = 4;
  }
  *a4 = v10;
  uint64_t v11 = malloc_type_realloc(v8, 8 * v10, 0x50040EE9192B6uLL);
  CFCharacterSetRef v8 = v11;
  if (!a4[3]) {
    a4[1] = 0;
  }
  a4[3] = (uint64_t)v11;
LABEL_8:
  bzero(__src, 0x400uLL);
  uint64_t v17 = 0;
  if (!utf8_encodestr((unsigned __int16 *)this, 2 * (void)a2, __src, &v17, 1024))
  {
    size_t v12 = v17 + 1;
    long long v13 = malloc_type_malloc(v17 + 1, 0x443BC30FuLL);
    memcpy(v13, __src, v12);
    uint64_t v14 = a4[1];
    *((void *)v8 + v14) = v13;
    size_t v15 = a4[2] + v12;
    a4[1] = v14 + 1;
    a4[2] = v15;
  }
  return 0;
}

uint64_t SISetCompletionRankingWeights(uint64_t result)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (!result) {
    return result;
  }
  CFArrayRef v1 = (const __CFArray *)result;
  __n128 result = CFArrayGetCount((CFArrayRef)result);
  if (result == 32)
  {
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long __src = 0u;
    long long v30 = 0u;
    p_src = &__src;
    CFTypeID TypeID = CFNumberGetTypeID();
    CFIndex v4 = 0;
    while (1)
    {
      CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(v1, v4);
      if (CFGetTypeID(ValueAtIndex) != TypeID)
      {
        int v10 = *__error();
        uint64_t v11 = _SILogForLogForCategory(1);
        BOOL v12 = dword_1E9FC90A8 < 3;
        if (!os_log_type_enabled(v11, (os_log_type_t)(dword_1E9FC90A8 < 3))) {
          goto LABEL_34;
        }
        int v25 = 134218242;
        CFIndex v26 = v4;
        __int16 v27 = 2112;
        CFArrayRef v28 = ValueAtIndex;
        long long v13 = "*warn* Non-numeric in factor array at index %ld: %@";
        goto LABEL_19;
      }
      __n128 result = CFNumberGetValue(ValueAtIndex, kCFNumberDoubleType, p_src);
      if (!result) {
        break;
      }
      ++v4;
      p_src = (long long *)((char *)p_src + 8);
      if (v4 == 32)
      {
        xmmword_1EC02E4D8 = v41;
        *(_OWORD *)&qword_1EC02E4E8 = v42;
        xmmword_1EC02E4F8 = v43;
        unk_1EC02E508 = v44;
        xmmword_1EC02E498 = v37;
        *(_OWORD *)&qword_1EC02E4A8 = v38;
        xmmword_1EC02E4B8 = v39;
        *(_OWORD *)&qword_1EC02E4C8 = v40;
        xmmword_1EC02E458 = v33;
        *(_OWORD *)&qword_1EC02E468 = v34;
        xmmword_1EC02E478 = v35;
        *(_OWORD *)&qword_1EC02E488 = v36;
        ranking_factor_weights = __src;
        *(_OWORD *)&qword_1EC02E428 = v30;
        xmmword_1EC02E438 = v31;
        unk_1EC02E448 = v32;
        return result;
      }
    }
    int v10 = *__error();
    uint64_t v11 = _SILogForLogForCategory(1);
    BOOL v12 = dword_1E9FC90A8 < 3;
    if (!os_log_type_enabled(v11, (os_log_type_t)(dword_1E9FC90A8 < 3))) {
      goto LABEL_34;
    }
    int v25 = 134218242;
    CFIndex v26 = v4;
    __int16 v27 = 2112;
    CFArrayRef v28 = ValueAtIndex;
    long long v13 = "*warn* Bad value in factor array at index %ld: %@";
LABEL_19:
    uint64_t v14 = v11;
    os_log_type_t v15 = v12;
  }
  else
  {
    uint64_t v6 = result;
    *(void *)&long long v37 = 0;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long __src = 0u;
    long long v30 = 0u;
    if (result >= 18)
    {
      if (dword_1E9FC90D8 >= 5)
      {
        int v7 = *__error();
        CFCharacterSetRef v8 = _SILogForLogForCategory(13);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          int v25 = 134218242;
          CFIndex v26 = v6;
          __int16 v27 = 2112;
          CFArrayRef v28 = v1;
          _os_log_impl(&dword_1BD672000, v8, OS_LOG_TYPE_DEFAULT, "completion weight array too large (%ld): %@", (uint8_t *)&v25, 0x16u);
        }
        __n128 result = (uint64_t)__error();
        *(_DWORD *)__n128 result = v7;
      }
      return result;
    }
    if (result == 17)
    {
      CFTypeID v9 = CFNumberGetTypeID();
    }
    else
    {
      int v16 = *__error();
      uint64_t v17 = _SILogForLogForCategory(1);
      os_log_type_t v18 = dword_1E9FC90A8 < 3;
      if (os_log_type_enabled(v17, (os_log_type_t)(dword_1E9FC90A8 < 3)))
      {
        int v25 = 134218242;
        CFIndex v26 = v6;
        __int16 v27 = 2112;
        CFArrayRef v28 = v1;
        _os_log_impl(&dword_1BD672000, v17, v18, "*warn* completion weight array incomplete (%ld): %@", (uint8_t *)&v25, 0x16u);
      }
      *__error() = v16;
      CFTypeID v9 = CFNumberGetTypeID();
      if (v6 < 1) {
        return (uint64_t)memcpy(&s_completion_weights, &__src, 8 * v6);
      }
    }
    CFTypeID v19 = v9;
    CFIndex v20 = 0;
    for (uint64_t i = &__src; ; uint64_t i = (long long *)((char *)i + 8))
    {
      CFArrayRef v22 = (const __CFArray *)CFArrayGetValueAtIndex(v1, v20);
      if (CFGetTypeID(v22) != v19)
      {
        int v10 = *__error();
        unint64_t v23 = _SILogForLogForCategory(1);
        BOOL v24 = dword_1E9FC90A8 < 3;
        if (!os_log_type_enabled(v23, (os_log_type_t)(dword_1E9FC90A8 < 3))) {
          goto LABEL_34;
        }
        int v25 = 134218242;
        CFIndex v26 = v20;
        __int16 v27 = 2112;
        CFArrayRef v28 = v22;
        long long v13 = "*warn* Non-numeric in weight array at index %ld: %@";
        goto LABEL_32;
      }
      if (!CFNumberGetValue(v22, kCFNumberDoubleType, i)) {
        break;
      }
      if (v6 == ++v20) {
        return (uint64_t)memcpy(&s_completion_weights, &__src, 8 * v6);
      }
    }
    int v10 = *__error();
    unint64_t v23 = _SILogForLogForCategory(1);
    BOOL v24 = dword_1E9FC90A8 < 3;
    if (!os_log_type_enabled(v23, (os_log_type_t)(dword_1E9FC90A8 < 3))) {
      goto LABEL_34;
    }
    int v25 = 134218242;
    CFIndex v26 = v20;
    __int16 v27 = 2112;
    CFArrayRef v28 = v22;
    long long v13 = "*warn* Bad value in weight array at index %ld: %@";
LABEL_32:
    uint64_t v14 = v23;
    os_log_type_t v15 = v24;
  }
  _os_log_impl(&dword_1BD672000, v14, v15, v13, (uint8_t *)&v25, 0x16u);
LABEL_34:
  __n128 result = (uint64_t)__error();
  *(_DWORD *)__n128 result = v10;
  return result;
}

uint64_t SIGetCompletionOptionsFromRankingWeights()
{
  if (unk_1EC02E508 == 1.0) {
    unsigned int v0 = (2 * (*((double *)&xmmword_1EC02E4F8 + 1) == 1.0)) | 4;
  }
  else {
    unsigned int v0 = 2 * (*((double *)&xmmword_1EC02E4F8 + 1) == 1.0);
  }
  if (*(double *)&qword_1EC02E510 == 1.0) {
    return v0 | 8;
  }
  else {
    return v0;
  }
}

uint64_t si_enqueue_barrier_routine(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t), uint64_t a4, unsigned int a5)
{
  CFTypeID v9 = (pthread_mutex_t *)(a2 + 48);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 48));
  if (*(_DWORD *)(a2 + 36))
  {
    pthread_mutex_unlock(v9);
    return a3(a4, 1);
  }
  else
  {
    si_enqueue_barrier_for_job(*(void *)(a1 + 8 * a5 + 1008), (uint64_t)a3, a4, a2);
    return pthread_mutex_unlock(v9);
  }
}

uint64_t preadvall(uint64_t __fd, uint64_t a2, off_t a3)
{
  while (1)
  {
    size_t v6 = *(void *)(a2 + 8);
    if (!v6) {
      return 0;
    }
    unint64_t v7 = pread(__fd, *(void **)a2, v6, a3);
    if ((v7 & 0x8000000000000000) != 0) {
      break;
    }
    if (!v7) {
      return 4294967274;
    }
    unint64_t v8 = *(void *)(a2 + 8);
    unint64_t v9 = v7 - v8;
    if (v7 >= v8)
    {
      if (v7 == v8) {
        return 0;
      }
      int v10 = 0;
      unint64_t v8 = *(void *)(a2 + 24);
      a2 += 16;
    }
    else
    {
      int v10 = 1;
      unint64_t v9 = v7;
    }
    a3 += v7;
    *(void *)a2 += v9;
    *(void *)(a2 + 8) = v8 - v9;
LABEL_13:
    if (!v10) {
      return 0;
    }
  }
  uint64_t v11 = *__error();
  if (v11 == 4
    || g_prot_error_callback
    && ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(g_prot_error_callback + 16))(g_prot_error_callback, __fd, v11, 16) & 1) != 0)
  {
    int v10 = 1;
    goto LABEL_13;
  }
  return -(int)v11;
}

uint64_t pwritevall(uint64_t __fd, void *a2, int a3, off_t a4)
{
  if (!a3) {
    return 0;
  }
  int v5 = a3;
  while (1)
  {
    unint64_t v8 = pwrite(__fd, (const void *)*a2, a2[1], a4);
    if ((v8 & 0x8000000000000000) == 0)
    {
      a4 += v8;
      unint64_t v9 = &a2[2 * (v5 - 1) + 2];
      while (1)
      {
        unint64_t v10 = a2[1];
        BOOL v11 = v8 >= v10;
        unint64_t v12 = v8 - v10;
        if (!v11) {
          break;
        }
        a2 += 2;
        unint64_t v8 = v12;
        if (!--v5)
        {
          if (!v12) {
            goto LABEL_10;
          }
          goto LABEL_9;
        }
      }
      unint64_t v9 = a2;
      unint64_t v12 = v8;
      if (v8)
      {
LABEL_9:
        unint64_t v13 = *v9 + v12;
        unint64_t v14 = v9[1] - v12;
        *unint64_t v9 = v13;
        v9[1] = v14;
      }
LABEL_10:
      a2 = v9;
      goto LABEL_14;
    }
    uint64_t v15 = *__error();
    if (v15 != 4
      && (!g_prot_error_callback
       || ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(g_prot_error_callback + 16))(g_prot_error_callback, __fd, v15, 17) & 1) == 0))
    {
      return -(int)v15;
    }
LABEL_14:
    if (!v5) {
      return 0;
    }
  }
}

uint64_t writevall(uint64_t a1, iovec *a2, int a3)
{
  if (!a3) {
    return 0;
  }
  int v3 = a3;
  do
  {
    while (1)
    {
      unint64_t v6 = writev(a1, a2, v3);
      if ((v6 & 0x8000000000000000) != 0) {
        break;
      }
      unint64_t v7 = &a2[(v3 - 1) + 1];
      while (1)
      {
        iov_leuint64_t n = a2->iov_len;
        BOOL v9 = v6 >= iov_len;
        unint64_t v10 = v6 - iov_len;
        if (!v9) {
          break;
        }
        ++a2;
        unint64_t v6 = v10;
        BOOL v11 = v3 == 1;
        int v3 = 1;
        if (v11)
        {
          int v3 = 0;
          if (!v10) {
            goto LABEL_17;
          }
          goto LABEL_16;
        }
      }
      unint64_t v7 = a2;
      unint64_t v10 = v6;
      if (!v6) {
        goto LABEL_17;
      }
LABEL_16:
      unint64_t v13 = (char *)v7->iov_base + v10;
      size_t v14 = v7->iov_len - v10;
      v7->iov_base = v13;
      v7->iov_leuint64_t n = v14;
LABEL_17:
      a2 = v7;
      if (!v3) {
        return 0;
      }
    }
    uint64_t v12 = *__error();
  }
  while (v12 == 4
       || g_prot_error_callback
       && ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(g_prot_error_callback + 16))(g_prot_error_callback, a1, v12, 18) & 1) != 0);
  return -(int)v12;
}

off_t get_file_size(int a1)
{
  memset(&v2, 0, sizeof(v2));
  if (fstat(a1, &v2)) {
    return -(uint64_t)*__error();
  }
  else {
    return v2.st_size;
  }
}

void SIModelManager::loadDictionaryForLanguage(SIModelManager *this, const char *a2)
{
  int v2 = (int)a2;
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  bzero(buffer, 0x400uLL);
  CFStringRef v4 = (const __CFString *)CFPreferencesCopyAppValue(@"RootDirectory", @"com.apple.spotlight");
  if (v4)
  {
    CFStringRef v5 = v4;
    CFIndex Length = CFStringGetLength(v4);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    if (MaximumSizeForEncoding >= 1024) {
      CFIndex v8 = 1024;
    }
    else {
      CFIndex v8 = MaximumSizeForEncoding;
    }
    CFStringGetCString(v5, buffer, v8, 0x8000100u);
    CFRelease(v5);
  }
  else
  {
    if (dword_1E9FC90A8 >= 5)
    {
      int v31 = *__error();
      long long v32 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl(&dword_1BD672000, v32, OS_LOG_TYPE_DEFAULT, "No RootDirectory set for Suggestions", (uint8_t *)__p, 2u);
      }
      *__error() = v31;
    }
    strcpy(buffer, "/var/mobile/Library/Caches/com.apple.parsecd");
  }
  memset(v38, 0, sizeof(v38));
  if (v2) {
    strcpy((char *)v38, "spotlight_stopword");
  }
  else {
    strcpy((char *)v38, "spotlight_phrase_dictionary");
  }
  __p[0] = (void *)open(buffer, 0);
  __p[1] = v38;
  uint64_t v34 = 0xA00000004;
  long long v35 = 0u;
  long long v36 = 0u;
  uint64_t v37 = 0;
  uint64_t v9 = data_map32_init_with_ctx((uint64_t)__p);
  if (v9)
  {
    unint64_t v10 = (uint64_t *)v9;
    if (v2)
    {
      std::string::basic_string[abi:nn180100]<0>(__p, (char *)this);
      BOOL v11 = (uint64_t **)&SIModelManager::getInstance(void)::instance;
    }
    else
    {
      double v12 = *(double *)&xmmword_1E9FE3A30;
      LOBYTE(__p[0]) = 0;
      unint64_t extra_with_key = data_map_get_extra_with_key(v9, (uint64_t)&kPhraseDefaultScore, 0x12uLL, __p);
      if (extra_with_key) {
        BOOL v14 = HIDWORD(extra_with_key) == 4;
      }
      else {
        BOOL v14 = 0;
      }
      BOOL v15 = !v14 || LOBYTE(__p[0]) == 0;
      double v16 = (double)extra_with_key;
      if (v15) {
        double v16 = v12;
      }
      *(double *)&xmmword_1E9FE3A30 = v16;
      LOBYTE(__p[0]) = 0;
      uint64_t v17 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&kPhraseStopwordScore, 0xCuLL, __p);
      if (LOBYTE(__p[0]) && (v17 & 0xFFFFFFFF00000000) == 0x400000000 && v17) {
        *((double *)&xmmword_1E9FE3A30 + 1) = 1.0 / (double)v17;
      }
      LOBYTE(__p[0]) = 0;
      uint64_t v18 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&kPhraseIncompleteScore, 0x18uLL, __p);
      if (LOBYTE(__p[0]) && (v18 & 0xFFFFFFFF00000000) == 0x400000000 && v18) {
        *(double *)&qword_1E9FE3A40 = 1.0 / (double)v18;
      }
      LOBYTE(__p[0]) = 0;
      uint64_t v19 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&kPhraseDiscountedScore, 0x14uLL, __p);
      if (LOBYTE(__p[0]) && (v19 & 0xFFFFFFFF00000000) == 0x400000000 && v19) {
        *(double *)&qword_1E9FE3A48 = 1.0 / (double)v19;
      }
      uint64_t v20 = qword_1E9FE3A50;
      LOBYTE(__p[0]) = 0;
      unint64_t v21 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&kTotal, 0xEuLL, __p);
      if (v21) {
        BOOL v22 = HIDWORD(v21) == 4;
      }
      else {
        BOOL v22 = 0;
      }
      BOOL v23 = !v22 || LOBYTE(__p[0]) == 0;
      double v24 = (double)v21;
      if (v23) {
        double v24 = *(double *)&v20;
      }
      qword_1E9FE3A50 = *(void *)&v24;
      LOBYTE(__p[0]) = 0;
      uint64_t v25 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&k1gramSize, 0xEuLL, __p);
      if (LOBYTE(__p[0]) && (v25 & 0xFFFFFFFF00000000) == 0x400000000 && v25) {
        *(double *)&xmmword_1E9FE3A60 = 1.0 / (double)v25;
      }
      LOBYTE(__p[0]) = 0;
      uint64_t v26 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&k2gramSize, 0xEuLL, __p);
      if (LOBYTE(__p[0]) && (v26 & 0xFFFFFFFF00000000) == 0x400000000 && v26) {
        *((double *)&xmmword_1E9FE3A60 + 1) = 1.0 / (double)v26;
      }
      LOBYTE(__p[0]) = 0;
      uint64_t v27 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&k3gramSize, 0xEuLL, __p);
      if (LOBYTE(__p[0]) && (v27 & 0xFFFFFFFF00000000) == 0x400000000 && v27) {
        *(double *)&qword_1E9FE3A70 = 1.0 / (double)v27;
      }
      LOBYTE(__p[0]) = 0;
      uint64_t v28 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&k4gramSize, 0xEuLL, __p);
      if (LOBYTE(__p[0]) && (v28 & 0xFFFFFFFF00000000) == 0x400000000 && v28) {
        *(double *)&qword_1E9FE3A78 = 1.0 / (double)v28;
      }
      LOBYTE(__p[0]) = 0;
      uint64_t v29 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&kNgramSize, 0xEuLL, __p);
      if (LOBYTE(__p[0]) && (v29 & 0xFFFFFFFF00000000) == 0x400000000 && v29) {
        *(double *)&qword_1E9FE3A80 = 1.0 / (double)v29;
      }
      LOBYTE(__p[0]) = 0;
      uint64_t v30 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&kNotUseLog, 0xCuLL, __p);
      if (LOBYTE(__p[0]) && (v30 & 0xFFFFFFFF00000000) == 0x400000000 && v30) {
        byte_1E9FE3A58 = 0;
      }
      std::string::basic_string[abi:nn180100]<0>(__p, (char *)this);
      BOOL v11 = (uint64_t **)&unk_1E9FE3A18;
    }
    std::__tree<std::__value_type<std::string,data_map_s *>,std::__map_value_compare<std::string,std::__value_type<std::string,data_map_s *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,data_map_s *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v11, __p, (uint64_t)__p)[7] = v10;
    if (SHIBYTE(v34) < 0) {
      operator delete(__p[0]);
    }
  }
}

uint64_t **std::__tree<std::__value_type<std::string,data_map_s *>,std::__map_value_compare<std::string,std::__value_type<std::string,data_map_s *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,data_map_s *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, void *a2, uint64_t a3)
{
  unint64_t v6 = a1 + 1;
  CFStringRef v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v6 = (uint64_t **)v5;
        CFIndex v8 = v5 + 4;
        if (!std::less<std::string>::operator()[abi:nn180100](a2, v5 + 4)) {
          break;
        }
        CFStringRef v5 = *v6;
        uint64_t v9 = v6;
        if (!*v6) {
          goto LABEL_9;
        }
      }
      if (!std::less<std::string>::operator()[abi:nn180100](v8, a2)) {
        break;
      }
      uint64_t v9 = v6 + 1;
      CFStringRef v5 = v6[1];
      if (!v5) {
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_9:
    unint64_t v10 = (uint64_t *)v6;
    unint64_t v6 = (uint64_t **)operator new(0x40uLL);
    *((_OWORD *)v6 + 2) = *(_OWORD *)a3;
    BOOL v11 = *(uint64_t **)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    void v6[6] = v11;
    v6[7] = 0;
    *unint64_t v6 = 0;
    v6[1] = 0;
    v6[2] = v10;
    *uint64_t v9 = (uint64_t *)v6;
    double v12 = (uint64_t *)**a1;
    unint64_t v13 = (uint64_t *)v6;
    if (v12)
    {
      *a1 = v12;
      unint64_t v13 = *v9;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v6;
}

BOOL SIModelManager::isStopword(SIModelManager *this, unsigned __int16 *a2, char *__s, const char *a4)
{
  if (!a2) {
    return 0;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, __s);
  unint64_t v7 = std::__tree<std::__value_type<std::string,data_map_s *>,std::__map_value_compare<std::string,std::__value_type<std::string,data_map_s *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,data_map_s *>>>::find<std::string>((uint64_t)&SIModelManager::getInstance(void)::instance, __p);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  if (v7 == &qword_1E9FE3A08) {
    SIModelManager::loadDictionaryForLanguage((SIModelManager *)__s, (const char *)1);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, __s);
  CFIndex v8 = std::__tree<std::__value_type<std::string,data_map_s *>,std::__map_value_compare<std::string,std::__value_type<std::string,data_map_s *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,data_map_s *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&SIModelManager::getInstance(void)::instance, __p, (uint64_t)__p)[7];
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if (v8) {
      goto LABEL_8;
    }
    return 0;
  }
  if (!v8) {
    return 0;
  }
LABEL_8:
  LOBYTE(__p[0]) = 0;
  unint64_t extra_with_key = data_map_get_extra_with_key((uint64_t)v8, (uint64_t)this, 2 * (void)a2, __p);
  if (extra_with_key) {
    BOOL v10 = HIDWORD(extra_with_key) == 4;
  }
  else {
    BOOL v10 = 0;
  }
  double v11 = (double)extra_with_key;
  if (!v10 || LOBYTE(__p[0]) == 0) {
    double v11 = 0.0;
  }
  return v11 == 1.0;
}

void *std::__tree<std::__value_type<std::string,data_map_s *>,std::__map_value_compare<std::string,std::__value_type<std::string,data_map_s *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,data_map_s *>>>::find<std::string>(uint64_t a1, void *a2)
{
  int v2 = (void *)(a1 + 8);
  int v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  CFStringRef v5 = (void *)(a1 + 8);
  do
  {
    BOOL v6 = std::less<std::string>::operator()[abi:nn180100](v3 + 4, a2);
    unint64_t v7 = v3 + 1;
    if (!v6)
    {
      unint64_t v7 = v3;
      CFStringRef v5 = v3;
    }
    int v3 = (void *)*v7;
  }
  while (*v7);
  if (v5 == v2 || std::less<std::string>::operator()[abi:nn180100](a2, v5 + 4)) {
    return v2;
  }
  return v5;
}

double SIModelManager::getScore(SIModelManager *this, long double a2)
{
  int v3 = (uint64_t *)&xmmword_1E9FE3A60;
  if ((unint64_t)this - 1 < 2) {
    goto LABEL_8;
  }
  if ((unint64_t)this - 3 < 2)
  {
    int v3 = (uint64_t *)&xmmword_1E9FE3A60 + 1;
LABEL_8:
    double v4 = *(double *)v3;
    goto LABEL_9;
  }
  if ((unint64_t)this - 5 < 2)
  {
    int v3 = &qword_1E9FE3A70;
    goto LABEL_8;
  }
  if ((unint64_t)this - 7 <= 1)
  {
    int v3 = &qword_1E9FE3A78;
    goto LABEL_8;
  }
  double v4 = *(double *)&qword_1E9FE3A80;
LABEL_9:
  int v5 = byte_1E9FE3A58;
  double v6 = log(a2);
  if (!v5) {
    double v6 = a2;
  }
  return v4 * v6;
}

void SIModelManager::getPhraseScore(uint64_t a1, char *__s, SIModelManager *a3, char *a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if ((unint64_t)a3 >= 2)
  {
    if (SIModelManager::isStopword(*(SIModelManager **)(a1 + 16 * (void)a3 - 16), *(unsigned __int16 **)(a1 + 16 * (void)a3 - 8), __s, a4))
    {
      uint64_t v8 = qword_1E9FE3A40;
LABEL_23:
      SIModelManager::getScore(a3, *(long double *)&v8);
      return;
    }
LABEL_21:
    if (*a4) {
      goto LABEL_22;
    }
    goto LABEL_6;
  }
  if (a3 != (SIModelManager *)1) {
    goto LABEL_21;
  }
  BOOL isStopword = SIModelManager::isStopword(*(SIModelManager **)a1, *(unsigned __int16 **)(a1 + 8), __s, a4);
  *a4 = isStopword;
  if (isStopword)
  {
LABEL_22:
    uint64_t v8 = qword_1E9FE3A48;
    goto LABEL_23;
  }
LABEL_6:
  std::string::basic_string[abi:nn180100]<0>(v35, __s);
  BOOL v10 = std::__tree<std::__value_type<std::string,data_map_s *>,std::__map_value_compare<std::string,std::__value_type<std::string,data_map_s *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,data_map_s *>>>::find<std::string>((uint64_t)&qword_1E9FE3A18, v35);
  if (v36 < 0) {
    operator delete(v35[0]);
  }
  if (v10 == &qword_1E9FE3A20) {
    SIModelManager::loadDictionaryForLanguage((SIModelManager *)__s, 0);
  }
  std::string::basic_string[abi:nn180100]<0>(v35, __s);
  double v11 = std::__tree<std::__value_type<std::string,data_map_s *>,std::__map_value_compare<std::string,std::__value_type<std::string,data_map_s *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,data_map_s *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(&qword_1E9FE3A18, v35, (uint64_t)v35);
  uint64_t v12 = (uint64_t)v11[7];
  if (v36 < 0)
  {
    operator delete(v35[0]);
    if (v12) {
      goto LABEL_12;
    }
LABEL_27:
    SIModelManager::getScore(a3, *(double *)&qword_1E9FE3A50 / *(double *)&xmmword_1E9FE3A30);
    return;
  }
  if (!v12) {
    goto LABEL_27;
  }
LABEL_12:
  if ((int)a3 <= 0)
  {
    size_t v27 = 0;
    uint64_t v18 = &v37;
  }
  else
  {
    int v13 = 0;
    BOOL v14 = (int *)(a1 + 8);
    uint64_t v15 = a3;
    do
    {
      int v16 = *v14;
      v14 += 4;
      v13 += v16;
      --v15;
    }
    while (v15);
    MEMORY[0x1F4188790](v11);
    uint64_t v18 = (char *)&v35[-1] - v17;
    bzero((char *)&v35[-1] - v17, v19);
    uint64_t v20 = 0;
    int v21 = 0;
    do
    {
      uint64_t v22 = *(void *)(a1 + 16 * v20 + 8);
      if ((int)v22 >= 1)
      {
        uint64_t v23 = *(void *)(a1 + 16 * v20 + 8);
        double v24 = *(__int16 **)(a1 + 16 * v20);
        uint64_t v25 = &v18[2 * v21];
        do
        {
          __int16 v26 = *v24++;
          *(_WORD *)uint64_t v25 = v26;
          v25 += 2;
          --v23;
        }
        while (v23);
      }
      v21 += v22;
      ++v20;
    }
    while (v20 != a3);
    size_t v27 = 2 * v13;
  }
  double v28 = *(double *)&qword_1E9FE3A50;
  double v29 = *(double *)&xmmword_1E9FE3A30;
  LOBYTE(v35[0]) = 0;
  unint64_t extra_with_key = data_map_get_extra_with_key(v12, (uint64_t)v18, v27, v35);
  if (extra_with_key) {
    BOOL v31 = HIDWORD(extra_with_key) == 4;
  }
  else {
    BOOL v31 = 0;
  }
  BOOL v32 = !v31 || LOBYTE(v35[0]) == 0;
  double v33 = (double)extra_with_key;
  if (v32) {
    double v33 = v29;
  }
  SIModelManager::getScore(a3, v28 / v33);
}

void SIModelManager::getInstance(SIModelManager *this)
{
  {
    qword_1E9FE3A08 = 0;
    SIModelManager::getInstance(void)::instance = (uint64_t)&qword_1E9FE3A08;
    qword_1E9FE3A20 = 0;
    qword_1E9FE3A28 = 0;
    qword_1E9FE3A10 = 0;
    unk_1E9FE3A18 = &qword_1E9FE3A20;
    xmmword_1E9FE3A30 = xmmword_1BDA82340;
    *(int64x2_t *)&qword_1E9FE3A40 = vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
    qword_1E9FE3A50 = 0x3FF0000000000000;
    byte_1E9FE3A58 = 1;
    __asm { FMOV            V0.2D, #1.0 }
    xmmword_1E9FE3A60 = _Q0;
    *(_OWORD *)&qword_1E9FE3A70 = xmmword_1BDA82350;
    qword_1E9FE3A80 = 0x3FD0000000000000;
  }
}

void analytics::SampledLogger<analytics::GetEvent>::logEvent(uint64_t a1, uint64_t *a2)
{
  double v4 = (std::mutex *)(a1 + 88);
  std::mutex::lock((std::mutex *)(a1 + 88));
  uint64_t v5 = *(void *)(a1 + 56);
  double v6 = *(void **)(a1 + 64);
  unint64_t v7 = ((uint64_t)v6 - v5) >> 3;
  if (v7 >= *(void *)(a1 + 24))
  {
    ++*(void *)(a1 + 80);
    unint64_t v11 = (unint64_t)rand() % *(void *)(a1 + 80);
    uint64_t v12 = *(void *)(a1 + 56);
    if (v11 < (*(void *)(a1 + 64) - v12) >> 3)
    {
      uint64_t v13 = *a2;
      *a2 = 0;
      uint64_t v14 = *(void *)(v12 + 8 * v11);
      *(void *)(v12 + 8 * v11) = v13;
      if (v14) {
        MEMORY[0x1C1881000](v14, 0x1000C4073594BB7);
      }
    }
  }
  else
  {
    unint64_t v8 = *(void *)(a1 + 72);
    if ((unint64_t)v6 >= v8)
    {
      if ((v7 + 1) >> 61) {
        abort();
      }
      uint64_t v15 = v8 - v5;
      uint64_t v16 = v15 >> 2;
      if (v15 >> 2 <= v7 + 1) {
        uint64_t v16 = v7 + 1;
      }
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v16;
      }
      if (v17)
      {
        if (v17 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v18 = (char *)operator new(8 * v17);
      }
      else
      {
        uint64_t v18 = 0;
      }
      size_t v19 = &v18[8 * v7];
      uint64_t v20 = &v18[8 * v17];
      uint64_t v21 = *a2;
      *a2 = 0;
      *(void *)size_t v19 = v21;
      BOOL v10 = v19 + 8;
      uint64_t v23 = *(void **)(a1 + 56);
      uint64_t v22 = *(void **)(a1 + 64);
      if (v22 == v23)
      {
        int64x2_t v25 = vdupq_n_s64((unint64_t)v22);
      }
      else
      {
        do
        {
          uint64_t v24 = *--v22;
          *uint64_t v22 = 0;
          *((void *)v19 - 1) = v24;
          v19 -= 8;
        }
        while (v22 != v23);
        int64x2_t v25 = *(int64x2_t *)(a1 + 56);
      }
      *(void *)(a1 + 56) = v19;
      *(void *)(a1 + 64) = v10;
      *(void *)(a1 + 72) = v20;
      size_t v27 = (void *)v25.i64[1];
      __int16 v26 = (void *)v25.i64[0];
      while (v27 != v26)
      {
        uint64_t v29 = *--v27;
        uint64_t v28 = v29;
        *size_t v27 = 0;
        if (v29) {
          MEMORY[0x1C1881000](v28, 0x1000C4073594BB7);
        }
      }
      if (v26) {
        operator delete(v26);
      }
    }
    else
    {
      uint64_t v9 = *a2;
      *a2 = 0;
      *double v6 = v9;
      BOOL v10 = v6 + 1;
    }
    *(void *)(a1 + 64) = v10;
  }
  std::mutex::unlock(v4);
}

void analytics::SampledLogger<analytics::GetEvent>::~SampledLogger(uint64_t a1)
{
  analytics::SampledLogger<analytics::GetEvent>::~SampledLogger(a1);
  JUMPOUT(0x1C1881000);
}

uint64_t analytics::SampledLogger<analytics::GetEvent>::~SampledLogger(uint64_t a1)
{
  *(void *)a1 = &unk_1F1811390;
  std::mutex::~mutex((std::mutex *)(a1 + 88));
  uint64_t v5 = (void **)(a1 + 56);
  std::vector<std::unique_ptr<analytics::GetEvent>>::__destroy_vector::operator()[abi:nn180100](&v5);
  int v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void std::vector<std::unique_ptr<analytics::GetEvent>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  int v2 = *a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<analytics::GetEvent>>::__base_destruct_at_end[abi:nn180100]((uint64_t)v2, *v2);
    int v3 = **a1;
    operator delete(v3);
  }
}

uint64_t std::vector<std::unique_ptr<analytics::GetEvent>>::__base_destruct_at_end[abi:nn180100](uint64_t result, void *a2)
{
  uint64_t v3 = result;
  double v4 = *(void **)(result + 8);
  while (v4 != a2)
  {
    uint64_t v5 = *--v4;
    __n128 result = v5;
    *double v4 = 0;
    if (v5) {
      __n128 result = MEMORY[0x1C1881000](result, 0x1000C4073594BB7);
    }
  }
  *(void *)(v3 + 8) = a2;
  return result;
}

void analytics::SampledLogger<analytics::PutEvent>::logEvent(uint64_t a1, uint64_t *a2)
{
  double v4 = (std::mutex *)(a1 + 88);
  std::mutex::lock((std::mutex *)(a1 + 88));
  uint64_t v5 = *(void *)(a1 + 56);
  double v6 = *(void **)(a1 + 64);
  unint64_t v7 = ((uint64_t)v6 - v5) >> 3;
  if (v7 >= *(void *)(a1 + 24))
  {
    ++*(void *)(a1 + 80);
    unint64_t v11 = (unint64_t)rand() % *(void *)(a1 + 80);
    uint64_t v12 = *(void *)(a1 + 56);
    if (v11 < (*(void *)(a1 + 64) - v12) >> 3)
    {
      uint64_t v13 = *a2;
      *a2 = 0;
      uint64_t v14 = *(void *)(v12 + 8 * v11);
      *(void *)(v12 + 8 * v11) = v13;
      if (v14) {
        MEMORY[0x1C1881000](v14, 0x1000C4022EED179);
      }
    }
  }
  else
  {
    unint64_t v8 = *(void *)(a1 + 72);
    if ((unint64_t)v6 >= v8)
    {
      if ((v7 + 1) >> 61) {
        abort();
      }
      uint64_t v15 = v8 - v5;
      uint64_t v16 = v15 >> 2;
      if (v15 >> 2 <= v7 + 1) {
        uint64_t v16 = v7 + 1;
      }
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v16;
      }
      if (v17)
      {
        if (v17 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v18 = (char *)operator new(8 * v17);
      }
      else
      {
        uint64_t v18 = 0;
      }
      size_t v19 = &v18[8 * v7];
      uint64_t v20 = &v18[8 * v17];
      uint64_t v21 = *a2;
      *a2 = 0;
      *(void *)size_t v19 = v21;
      BOOL v10 = v19 + 8;
      uint64_t v23 = *(void **)(a1 + 56);
      uint64_t v22 = *(void **)(a1 + 64);
      if (v22 == v23)
      {
        int64x2_t v25 = vdupq_n_s64((unint64_t)v22);
      }
      else
      {
        do
        {
          uint64_t v24 = *--v22;
          *uint64_t v22 = 0;
          *((void *)v19 - 1) = v24;
          v19 -= 8;
        }
        while (v22 != v23);
        int64x2_t v25 = *(int64x2_t *)(a1 + 56);
      }
      *(void *)(a1 + 56) = v19;
      *(void *)(a1 + 64) = v10;
      *(void *)(a1 + 72) = v20;
      size_t v27 = (void *)v25.i64[1];
      __int16 v26 = (void *)v25.i64[0];
      while (v27 != v26)
      {
        uint64_t v29 = *--v27;
        uint64_t v28 = v29;
        *size_t v27 = 0;
        if (v29) {
          MEMORY[0x1C1881000](v28, 0x1000C4022EED179);
        }
      }
      if (v26) {
        operator delete(v26);
      }
    }
    else
    {
      uint64_t v9 = *a2;
      *a2 = 0;
      *double v6 = v9;
      BOOL v10 = v6 + 1;
    }
    *(void *)(a1 + 64) = v10;
  }
  std::mutex::unlock(v4);
}

void analytics::SampledLogger<analytics::PutEvent>::~SampledLogger(uint64_t a1)
{
  analytics::SampledLogger<analytics::PutEvent>::~SampledLogger(a1);
  JUMPOUT(0x1C1881000);
}

uint64_t analytics::SampledLogger<analytics::PutEvent>::~SampledLogger(uint64_t a1)
{
  *(void *)a1 = &unk_1F18113B8;
  std::mutex::~mutex((std::mutex *)(a1 + 88));
  uint64_t v5 = (void **)(a1 + 56);
  std::vector<std::unique_ptr<analytics::PutEvent>>::__destroy_vector::operator()[abi:nn180100](&v5);
  int v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void std::vector<std::unique_ptr<analytics::PutEvent>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  int v2 = *a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<analytics::PutEvent>>::__base_destruct_at_end[abi:nn180100]((uint64_t)v2, *v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

uint64_t std::vector<std::unique_ptr<analytics::PutEvent>>::__base_destruct_at_end[abi:nn180100](uint64_t result, void *a2)
{
  uint64_t v3 = result;
  double v4 = *(void **)(result + 8);
  while (v4 != a2)
  {
    uint64_t v5 = *--v4;
    __n128 result = v5;
    *double v4 = 0;
    if (v5) {
      __n128 result = MEMORY[0x1C1881000](result, 0x1000C4022EED179);
    }
  }
  *(void *)(v3 + 8) = a2;
  return result;
}

void analytics::SampledLogger<analytics::DeleteEvent>::logEvent(uint64_t a1, uint64_t *a2)
{
  double v4 = (std::mutex *)(a1 + 88);
  std::mutex::lock((std::mutex *)(a1 + 88));
  uint64_t v5 = *(void *)(a1 + 56);
  double v6 = *(void **)(a1 + 64);
  unint64_t v7 = ((uint64_t)v6 - v5) >> 3;
  if (v7 >= *(void *)(a1 + 24))
  {
    ++*(void *)(a1 + 80);
    unint64_t v11 = (unint64_t)rand() % *(void *)(a1 + 80);
    uint64_t v12 = *(void *)(a1 + 56);
    if (v11 < (*(void *)(a1 + 64) - v12) >> 3)
    {
      uint64_t v13 = *a2;
      *a2 = 0;
      uint64_t v14 = *(void *)(v12 + 8 * v11);
      *(void *)(v12 + 8 * v11) = v13;
      if (v14) {
        MEMORY[0x1C1881000](v14, 0x1000C4073594BB7);
      }
    }
  }
  else
  {
    unint64_t v8 = *(void *)(a1 + 72);
    if ((unint64_t)v6 >= v8)
    {
      if ((v7 + 1) >> 61) {
        abort();
      }
      uint64_t v15 = v8 - v5;
      uint64_t v16 = v15 >> 2;
      if (v15 >> 2 <= v7 + 1) {
        uint64_t v16 = v7 + 1;
      }
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v16;
      }
      if (v17)
      {
        if (v17 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v18 = (char *)operator new(8 * v17);
      }
      else
      {
        uint64_t v18 = 0;
      }
      size_t v19 = &v18[8 * v7];
      uint64_t v20 = &v18[8 * v17];
      uint64_t v21 = *a2;
      *a2 = 0;
      *(void *)size_t v19 = v21;
      BOOL v10 = v19 + 8;
      uint64_t v23 = *(void **)(a1 + 56);
      uint64_t v22 = *(void **)(a1 + 64);
      if (v22 == v23)
      {
        int64x2_t v25 = vdupq_n_s64((unint64_t)v22);
      }
      else
      {
        do
        {
          uint64_t v24 = *--v22;
          *uint64_t v22 = 0;
          *((void *)v19 - 1) = v24;
          v19 -= 8;
        }
        while (v22 != v23);
        int64x2_t v25 = *(int64x2_t *)(a1 + 56);
      }
      *(void *)(a1 + 56) = v19;
      *(void *)(a1 + 64) = v10;
      *(void *)(a1 + 72) = v20;
      size_t v27 = (void *)v25.i64[1];
      __int16 v26 = (void *)v25.i64[0];
      while (v27 != v26)
      {
        uint64_t v29 = *--v27;
        uint64_t v28 = v29;
        *size_t v27 = 0;
        if (v29) {
          MEMORY[0x1C1881000](v28, 0x1000C4073594BB7);
        }
      }
      if (v26) {
        operator delete(v26);
      }
    }
    else
    {
      uint64_t v9 = *a2;
      *a2 = 0;
      *double v6 = v9;
      BOOL v10 = v6 + 1;
    }
    *(void *)(a1 + 64) = v10;
  }
  std::mutex::unlock(v4);
}

void analytics::SampledLogger<analytics::DeleteEvent>::~SampledLogger(uint64_t a1)
{
  analytics::SampledLogger<analytics::DeleteEvent>::~SampledLogger(a1);
  JUMPOUT(0x1C1881000);
}

uint64_t analytics::SampledLogger<analytics::DeleteEvent>::~SampledLogger(uint64_t a1)
{
  *(void *)a1 = &unk_1F1811368;
  std::mutex::~mutex((std::mutex *)(a1 + 88));
  uint64_t v5 = (void **)(a1 + 56);
  std::vector<std::unique_ptr<analytics::GetEvent>>::__destroy_vector::operator()[abi:nn180100](&v5);
  int v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void analytics::XpcActivityScheduler::start(uint64_t a1, uint64_t a2)
{
  double v4 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  unint64_t v5 = *(void *)(a1 + 88);
  unint64_t v6 = *(void *)(a1 + 96);
  if (v5 < v6)
  {
    uint64_t v7 = std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100](v5, a2) + 32;
    goto LABEL_20;
  }
  uint64_t v8 = *(void *)(a1 + 80);
  uint64_t v9 = (uint64_t)(v5 - v8) >> 5;
  if ((unint64_t)(v9 + 1) >> 59) {
    abort();
  }
  uint64_t v10 = v6 - v8;
  uint64_t v11 = v10 >> 4;
  if (v10 >> 4 <= (unint64_t)(v9 + 1)) {
    uint64_t v11 = v9 + 1;
  }
  if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v12 = v11;
  }
  if (v12)
  {
    if (v12 >> 59) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v13 = (char *)operator new(32 * v12);
  }
  else
  {
    uint64_t v13 = 0;
  }
  uint64_t v14 = &v13[32 * v12];
  uint64_t v15 = std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100]((uint64_t)&v13[32 * v9], a2);
  uint64_t v7 = v15 + 32;
  unint64_t v17 = *(char **)(a1 + 80);
  uint64_t v16 = *(char **)(a1 + 88);
  if (v16 == v17)
  {
    *(void *)(a1 + 80) = v15;
    *(void *)(a1 + 88) = v7;
    *(void *)(a1 + 96) = v14;
    if (v16) {
LABEL_19:
    }
      operator delete(v16);
  }
  else
  {
    do
    {
      v16 -= 32;
      uint64_t v15 = std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100](v15 - 32, (uint64_t)v16);
    }
    while (v16 != v17);
    uint64_t v18 = *(char **)(a1 + 80);
    uint64_t v16 = *(char **)(a1 + 88);
    *(void *)(a1 + 80) = v15;
    *(void *)(a1 + 88) = v7;
    *(void *)(a1 + 96) = v14;
    if (v16 != v18)
    {
      do
      {
        v16 -= 32;
        std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v16);
      }
      while (v16 != v18);
      uint64_t v16 = v18;
    }
    if (v16) {
      goto LABEL_19;
    }
  }
LABEL_20:
  *(void *)(a1 + 88) = v7;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN9analytics20XpcActivityScheduler23registerXpcActivityOnceEv_block_invoke;
  block[3] = &__block_descriptor_tmp_20;
  block[4] = a1;
  if (analytics::XpcActivityScheduler::registerXpcActivityOnce(void)::onceToken != -1) {
    dispatch_once(&analytics::XpcActivityScheduler::registerXpcActivityOnce(void)::onceToken, block);
  }
  std::mutex::unlock(v4);
}

uint64_t std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = v3;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void ___ZN9analytics20XpcActivityScheduler23registerXpcActivityOnceEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_BOOL(v2, (const char *)*MEMORY[0x1E4F142F8], 1);
  xpc_dictionary_set_int64(v2, (const char *)*MEMORY[0x1E4F14170], *MEMORY[0x1E4F141F8]);
  xpc_dictionary_set_int64(v2, (const char *)*MEMORY[0x1E4F141A8], *MEMORY[0x1E4F14220]);
  uint64_t v3 = *(void (**)(const char *, xpc_object_t, void *))(v1 + 8);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = ___ZN9analytics20XpcActivityScheduler23registerXpcActivityOnceEv_block_invoke_2;
  void v4[3] = &__block_descriptor_tmp_19_1711;
  void v4[4] = v1;
  v3("com.apple.spotlight.textstore.Analytics", v2, v4);
  xpc_release(v2);
}

void ___ZN9analytics20XpcActivityScheduler23registerXpcActivityOnceEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  xpc_object_t v2 = (std::mutex *)(v1 + 16);
  std::mutex::lock((std::mutex *)(v1 + 16));
  uint64_t v3 = *(void *)(v1 + 80);
  uint64_t v4 = *(void *)(v1 + 88);
  while (v3 != v4)
  {
    uint64_t v5 = *(void *)(v3 + 24);
    if (!v5)
    {
      unint64_t v6 = (void *)std::__throw_bad_function_call[abi:nn180100]();
      std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v6);
      return;
    }
    (*(void (**)(uint64_t))(*(void *)v5 + 48))(v5);
    v3 += 32;
  }
  std::mutex::unlock(v2);
}

void *std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](void *a1)
{
  xpc_object_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void analytics::XpcActivityScheduler::~XpcActivityScheduler(analytics::XpcActivityScheduler *this)
{
  *(void *)this = &unk_1F18113E0;
  uint64_t v1 = (std::mutex *)((char *)this + 16);
  xpc_object_t v2 = (void **)((char *)this + 80);
  std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:nn180100](&v2);
  std::mutex::~mutex(v1);
  JUMPOUT(0x1C1881000);
}

{
  std::mutex *v1;
  void **v2;

  *(void *)this = &unk_1F18113E0;
  uint64_t v1 = (std::mutex *)((char *)this + 16);
  xpc_object_t v2 = (void **)((char *)this + 80);
  std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:nn180100](&v2);
  std::mutex::~mutex(v1);
}

void std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        uint64_t v4 = std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v4 - 4);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__function::__func<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t a1)
{
  xpc_object_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        std::mutex::lock((std::mutex *)(v5 + 88));
        long long v12 = *(_OWORD *)(v5 + 56);
        long long v10 = v12;
        uint64_t v13 = *(void *)(v5 + 72);
        *(_OWORD *)(v5 + 72) = 0u;
        *(_OWORD *)(v5 + 56) = 0u;
        std::mutex::unlock((std::mutex *)(v5 + 88));
        for (uint64_t i = (uint64_t *)v10; i != *((uint64_t **)&v10 + 1); ++i)
        {
          uint64_t v7 = *(void *)(v5 + 32);
          uint64_t v8 = *i;
          uint64_t *i = 0;
          uint64_t v11 = v8;
          (*(void (**)(uint64_t, uint64_t *))(*(void *)v7 + 16))(v7, &v11);
          uint64_t v9 = v11;
          uint64_t v11 = 0;
          if (v9) {
            MEMORY[0x1C1881000](v9, 0x1000C4073594BB7);
          }
        }
        uint64_t v14 = (void **)&v12;
        std::vector<std::unique_ptr<analytics::GetEvent>>::__destroy_vector::operator()[abi:nn180100](&v14);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void std::__function::__func<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::destroy_deallocate(void *__p)
{
  xpc_object_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void std::__function::__func<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t std::__function::__func<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = &unk_1F1811528;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *std::__function::__func<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *__n128 result = &unk_1F1811528;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F1811528;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1C1881000);
}

void *std::__function::__func<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F1811528;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void ___ZN9analytics20XpcActivityScheduler11getInstanceEv_block_invoke()
{
}

void analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::GetEvent>::logEvent(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*a2) {
    operator new();
  }
  *a2 = 0;
  int v2 = analytics_send_event_lazy();
  int v3 = *__error();
  uint64_t v4 = _SILogForLogForCategory(8);
  os_log_type_t v5 = 2 * (dword_1E9FC90C4 < 4);
  BOOL v6 = os_log_type_enabled(v4, v5);
  if (v2)
  {
    if (v6)
    {
      *(_DWORD *)iovec buf = 136315138;
      uint64_t v9 = "com.apple.spotlight.textstore.Get";
      uint64_t v7 = "successfully logged event: %s";
LABEL_8:
      _os_log_impl(&dword_1BD672000, v4, v5, v7, buf, 0xCu);
    }
  }
  else if (v6)
  {
    *(_DWORD *)iovec buf = 136315138;
    uint64_t v9 = "com.apple.spotlight.textstore.Get";
    uint64_t v7 = "event logging disabled: %s";
    goto LABEL_8;
  }
  *__error() = v3;
}

xpc_object_t ___ZN9analytics12_GLOBAL__N_119CoreAnalyticsLoggerINS_8GetEventEE8logEventENSt3__110unique_ptrIS2_NS4_14default_deleteIS2_EEEE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 32);
  long long v121 = 0;
  __n128 v122 = 0;
  __n128 v123 = 0;
  std::string __p = 0;
  long long v119 = 0;
  long long v120 = 0;
  if (v1[1])
  {
    int v2 = (char *)operator new(8uLL);
    *(void *)int v2 = "success";
    int v3 = v2 + 8;
    __n128 v122 = v2 + 8;
    __n128 v123 = v2 + 8;
    int v4 = *v1;
    long long v121 = v2;
    xpc_object_t v5 = xpc_BOOL_create(v4 != 0);
    BOOL v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(1uLL);
    *(void *)BOOL v6 = v5;
    std::string __p = v6;
    long long v119 = v6 + 8;
    long long v120 = &v6[8 * v7];
  }
  else
  {
    int v2 = 0;
    int v3 = 0;
  }
  if (v1[8])
  {
    uint64_t v8 = v3 - v2;
    uint64_t v9 = (v3 - v2) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      goto LABEL_177;
    }
    if (v8 >> 2 > v10) {
      unint64_t v10 = v8 >> 2;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    if (v11) {
      unint64_t v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v13 = (char *)(v11 + 8 * v9);
    *(void *)uint64_t v13 = "error_code";
    uint64_t v14 = v13 + 8;
    if (v3 != v2)
    {
      do
      {
        uint64_t v15 = *((void *)v3 - 1);
        v3 -= 8;
        *((void *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v3 != v2);
      int v2 = (char *)v121;
    }
    long long v121 = v13;
    __n128 v123 = (char *)(v11 + 8 * v12);
    if (v2) {
      operator delete(v2);
    }
    __n128 v122 = v14;
    xpc_object_t v16 = xpc_int64_create(*((int *)v1 + 1));
    xpc_object_t v17 = v16;
    uint64_t v18 = v119;
    if (v119 >= v120)
    {
      uint64_t v20 = (char *)__p;
      uint64_t v21 = (v119 - (unsigned char *)__p) >> 3;
      unint64_t v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v23 = v120 - (unsigned char *)__p;
      if ((v120 - (unsigned char *)__p) >> 2 > v22) {
        unint64_t v22 = v23 >> 2;
      }
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v24 = v22;
      }
      if (v24) {
        unint64_t v24 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v24);
      }
      else {
        uint64_t v25 = 0;
      }
      __int16 v26 = (char *)(v24 + 8 * v21);
      *(void *)__int16 v26 = v17;
      size_t v19 = v26 + 8;
      if (v18 != v20)
      {
        do
        {
          uint64_t v27 = *((void *)v18 - 1);
          v18 -= 8;
          *((void *)v26 - 1) = v27;
          v26 -= 8;
        }
        while (v18 != v20);
        uint64_t v18 = (char *)__p;
      }
      std::string __p = v26;
      long long v120 = (char *)(v24 + 8 * v25);
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      *(void *)long long v119 = v16;
      size_t v19 = v18 + 8;
    }
    long long v119 = v19;
  }
  if (v1[24])
  {
    uint64_t v28 = v122;
    if (v122 >= v123)
    {
      uint64_t v30 = (char *)v121;
      uint64_t v31 = (v122 - (unsigned char *)v121) >> 3;
      unint64_t v32 = v31 + 1;
      if ((unint64_t)(v31 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v33 = v123 - (unsigned char *)v121;
      if ((v123 - (unsigned char *)v121) >> 2 > v32) {
        unint64_t v32 = v33 >> 2;
      }
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v34 = v32;
      }
      if (v34) {
        unint64_t v34 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v34);
      }
      else {
        uint64_t v35 = 0;
      }
      char v36 = (char *)(v34 + 8 * v31);
      *(void *)char v36 = "requested_doc_count";
      uint64_t v29 = v36 + 8;
      if (v28 != v30)
      {
        do
        {
          uint64_t v37 = *((void *)v28 - 1);
          v28 -= 8;
          *((void *)v36 - 1) = v37;
          v36 -= 8;
        }
        while (v28 != v30);
        uint64_t v28 = (char *)v121;
      }
      long long v121 = v36;
      __n128 v123 = (char *)(v34 + 8 * v35);
      if (v28) {
        operator delete(v28);
      }
    }
    else
    {
      *(void *)__n128 v122 = "requested_doc_count";
      uint64_t v29 = v28 + 8;
    }
    __n128 v122 = v29;
    xpc_object_t v38 = xpc_int64_create(*((void *)v1 + 2));
    xpc_object_t v39 = v38;
    uint64_t v40 = v119;
    if (v119 >= v120)
    {
      long long v42 = (char *)__p;
      uint64_t v43 = (v119 - (unsigned char *)__p) >> 3;
      unint64_t v44 = v43 + 1;
      if ((unint64_t)(v43 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v45 = v120 - (unsigned char *)__p;
      if ((v120 - (unsigned char *)__p) >> 2 > v44) {
        unint64_t v44 = v45 >> 2;
      }
      if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v46 = v44;
      }
      if (v46) {
        unint64_t v46 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v46);
      }
      else {
        uint64_t v47 = 0;
      }
      __n128 v48 = (char *)(v46 + 8 * v43);
      *(void *)__n128 v48 = v39;
      long long v41 = v48 + 8;
      if (v40 != v42)
      {
        do
        {
          uint64_t v49 = *((void *)v40 - 1);
          v40 -= 8;
          *((void *)v48 - 1) = v49;
          v48 -= 8;
        }
        while (v40 != v42);
        uint64_t v40 = (char *)__p;
      }
      std::string __p = v48;
      long long v120 = (char *)(v46 + 8 * v47);
      if (v40) {
        operator delete(v40);
      }
    }
    else
    {
      *(void *)long long v119 = v38;
      long long v41 = v40 + 8;
    }
    long long v119 = v41;
  }
  if (v1[40])
  {
    __n128 v50 = v122;
    if (v122 >= v123)
    {
      uint64_t v52 = (char *)v121;
      uint64_t v53 = (v122 - (unsigned char *)v121) >> 3;
      unint64_t v54 = v53 + 1;
      if ((unint64_t)(v53 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v55 = v123 - (unsigned char *)v121;
      if ((v123 - (unsigned char *)v121) >> 2 > v54) {
        unint64_t v54 = v55 >> 2;
      }
      if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v56 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v56 = v54;
      }
      if (v56) {
        unint64_t v56 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v56);
      }
      else {
        uint64_t v57 = 0;
      }
      os_log_type_t v58 = (char *)(v56 + 8 * v53);
      *(void *)os_log_type_t v58 = "hot_shard_doc_count";
      __n128 v51 = v58 + 8;
      if (v50 != v52)
      {
        do
        {
          uint64_t v59 = *((void *)v50 - 1);
          v50 -= 8;
          *((void *)v58 - 1) = v59;
          v58 -= 8;
        }
        while (v50 != v52);
        __n128 v50 = (char *)v121;
      }
      long long v121 = v58;
      __n128 v123 = (char *)(v56 + 8 * v57);
      if (v50) {
        operator delete(v50);
      }
    }
    else
    {
      *(void *)__n128 v122 = "hot_shard_doc_count";
      __n128 v51 = v50 + 8;
    }
    __n128 v122 = v51;
    xpc_object_t v60 = xpc_int64_create(*((void *)v1 + 4));
    xpc_object_t v61 = v60;
    os_log_type_t v62 = v119;
    if (v119 >= v120)
    {
      CFNumberRef v64 = (char *)__p;
      uint64_t v65 = (v119 - (unsigned char *)__p) >> 3;
      unint64_t v66 = v65 + 1;
      if ((unint64_t)(v65 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v67 = v120 - (unsigned char *)__p;
      if ((v120 - (unsigned char *)__p) >> 2 > v66) {
        unint64_t v66 = v67 >> 2;
      }
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v68 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v68 = v66;
      }
      if (v68) {
        unint64_t v68 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v68);
      }
      else {
        uint64_t v69 = 0;
      }
      double v70 = (char *)(v68 + 8 * v65);
      *(void *)double v70 = v61;
      uint64_t v63 = v70 + 8;
      if (v62 != v64)
      {
        do
        {
          uint64_t v71 = *((void *)v62 - 1);
          v62 -= 8;
          *((void *)v70 - 1) = v71;
          v70 -= 8;
        }
        while (v62 != v64);
        os_log_type_t v62 = (char *)__p;
      }
      std::string __p = v70;
      long long v120 = (char *)(v68 + 8 * v69);
      if (v62) {
        operator delete(v62);
      }
    }
    else
    {
      *(void *)long long v119 = v60;
      uint64_t v63 = v62 + 8;
    }
    long long v119 = v63;
  }
  if (v1[56])
  {
    double v72 = v122;
    if (v122 >= v123)
    {
      unint64_t v74 = (char *)v121;
      uint64_t v75 = (v122 - (unsigned char *)v121) >> 3;
      unint64_t v76 = v75 + 1;
      if ((unint64_t)(v75 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v77 = v123 - (unsigned char *)v121;
      if ((v123 - (unsigned char *)v121) >> 2 > v76) {
        unint64_t v76 = v77 >> 2;
      }
      if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v78 = v76;
      }
      if (v78) {
        unint64_t v78 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v78);
      }
      else {
        uint64_t v79 = 0;
      }
      long long v80 = (char *)(v78 + 8 * v75);
      *(void *)long long v80 = "cold_shard_doc_count";
      os_log_type_t v73 = v80 + 8;
      if (v72 != v74)
      {
        do
        {
          uint64_t v81 = *((void *)v72 - 1);
          v72 -= 8;
          *((void *)v80 - 1) = v81;
          v80 -= 8;
        }
        while (v72 != v74);
        double v72 = (char *)v121;
      }
      long long v121 = v80;
      __n128 v123 = (char *)(v78 + 8 * v79);
      if (v72) {
        operator delete(v72);
      }
    }
    else
    {
      *(void *)__n128 v122 = "cold_shard_doc_count";
      os_log_type_t v73 = v72 + 8;
    }
    __n128 v122 = v73;
    xpc_object_t v82 = xpc_int64_create(*((void *)v1 + 6));
    xpc_object_t v83 = v82;
    long long v84 = v119;
    if (v119 >= v120)
    {
      long long v86 = (char *)__p;
      uint64_t v87 = (v119 - (unsigned char *)__p) >> 3;
      unint64_t v88 = v87 + 1;
      if ((unint64_t)(v87 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v89 = v120 - (unsigned char *)__p;
      if ((v120 - (unsigned char *)__p) >> 2 > v88) {
        unint64_t v88 = v89 >> 2;
      }
      if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v90 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v90 = v88;
      }
      if (v90) {
        unint64_t v90 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v90);
      }
      else {
        uint64_t v91 = 0;
      }
      uint64_t v92 = (char *)(v90 + 8 * v87);
      *(void *)uint64_t v92 = v83;
      long long v85 = v92 + 8;
      if (v84 != v86)
      {
        do
        {
          uint64_t v93 = *((void *)v84 - 1);
          v84 -= 8;
          *((void *)v92 - 1) = v93;
          v92 -= 8;
        }
        while (v84 != v86);
        long long v84 = (char *)__p;
      }
      std::string __p = v92;
      long long v120 = (char *)(v90 + 8 * v91);
      if (v84) {
        operator delete(v84);
      }
    }
    else
    {
      *(void *)long long v119 = v82;
      long long v85 = v84 + 8;
    }
    long long v119 = v85;
  }
  if (!v1[68]) {
    goto LABEL_172;
  }
  uint64_t v94 = v122;
  if (v122 >= v123)
  {
    uint64_t v96 = (char *)v121;
    uint64_t v97 = (v122 - (unsigned char *)v121) >> 3;
    unint64_t v98 = v97 + 1;
    if ((unint64_t)(v97 + 1) >> 61) {
      goto LABEL_177;
    }
    uint64_t v99 = v123 - (unsigned char *)v121;
    if ((v123 - (unsigned char *)v121) >> 2 > v98) {
      unint64_t v98 = v99 >> 2;
    }
    if ((unint64_t)v99 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v100 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v100 = v98;
    }
    if (v100) {
      unint64_t v100 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v100);
    }
    else {
      uint64_t v101 = 0;
    }
    int v102 = (char *)(v100 + 8 * v97);
    *(void *)int v102 = "elapsed_ms";
    uint64_t v95 = v102 + 8;
    if (v94 != v96)
    {
      do
      {
        uint64_t v103 = *((void *)v94 - 1);
        v94 -= 8;
        *((void *)v102 - 1) = v103;
        v102 -= 8;
      }
      while (v94 != v96);
      uint64_t v94 = (char *)v121;
    }
    long long v121 = v102;
    __n128 v123 = (char *)(v100 + 8 * v101);
    if (v94) {
      operator delete(v94);
    }
  }
  else
  {
    *(void *)__n128 v122 = "elapsed_ms";
    uint64_t v95 = v94 + 8;
  }
  __n128 v122 = v95;
  xpc_object_t v104 = xpc_double_create(*((float *)v1 + 16));
  xpc_object_t v105 = v104;
  long long v106 = v119;
  if (v119 >= v120)
  {
    __n128 v108 = (char *)__p;
    uint64_t v109 = (v119 - (unsigned char *)__p) >> 3;
    unint64_t v110 = v109 + 1;
    if (!((unint64_t)(v109 + 1) >> 61))
    {
      uint64_t v111 = v120 - (unsigned char *)__p;
      if ((v120 - (unsigned char *)__p) >> 2 > v110) {
        unint64_t v110 = v111 >> 2;
      }
      if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v112 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v112 = v110;
      }
      if (v112) {
        unint64_t v112 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v112);
      }
      else {
        uint64_t v113 = 0;
      }
      long long v114 = (char *)(v112 + 8 * v109);
      *(void *)long long v114 = v105;
      long long v107 = v114 + 8;
      if (v106 != v108)
      {
        do
        {
          uint64_t v115 = *((void *)v106 - 1);
          v106 -= 8;
          *((void *)v114 - 1) = v115;
          v114 -= 8;
        }
        while (v106 != v108);
        long long v106 = (char *)__p;
      }
      std::string __p = v114;
      long long v120 = (char *)(v112 + 8 * v113);
      if (v106) {
        operator delete(v106);
      }
      goto LABEL_171;
    }
LABEL_177:
    abort();
  }
  *(void *)long long v119 = v104;
  long long v107 = v106 + 8;
LABEL_171:
  long long v119 = v107;
LABEL_172:
  if (__p) {
    operator delete(__p);
  }
  if (v121) {
    operator delete(v121);
  }
  return v116;
}

void __destroy_helper_block_8_32c47_ZTSNSt3__110shared_ptrIN9analytics8GetEventEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_8_32c47_ZTSNSt3__110shared_ptrIN9analytics8GetEventEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

xpc_object_t analytics::anonymous namespace'::to_dictionary(uint64_t a1, xpc_object_t **a2)
{
  int v4 = *(const char *const **)a1;
  size_t v6 = (uint64_t)(*(void *)(a1 + 8) - (void)v4) >> 3;
  uint64_t v7 = *a2;
  if (v6 != a2[1] - v7) {
    __assert_rtn("to_dictionary", "Analytics.cpp", 22, "keys.size() == values.size()");
  }
  xpc_object_t v9 = xpc_dictionary_create(v4, v7, v6);
  unint64_t v10 = *a2;
  unint64_t v11 = a2[1];
  if (*a2 != v11)
  {
    do
    {
      uint64_t v12 = *v10++;
      xpc_release(v12);
    }
    while (v10 != v11);
    unint64_t v10 = *a2;
  }
  *(void *)(a1 + 8) = *(void *)a1;
  a2[1] = v10;
  return v9;
}

uint64_t std::__shared_ptr_pointer<analytics::GetEvent  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x1C1881000);
  }
  return result;
}

void std::__shared_ptr_pointer<analytics::GetEvent  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::GetEvent>::~CoreAnalyticsLogger()
{
}

uint64_t std::__shared_ptr_emplace<analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::GetEvent>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::GetEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1811628;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void std::__shared_ptr_emplace<analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::GetEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1811628;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__function::__func<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        std::mutex::lock((std::mutex *)(v5 + 88));
        long long v12 = *(_OWORD *)(v5 + 56);
        long long v10 = v12;
        uint64_t v13 = *(void *)(v5 + 72);
        *(_OWORD *)(v5 + 72) = 0u;
        *(_OWORD *)(v5 + 56) = 0u;
        std::mutex::unlock((std::mutex *)(v5 + 88));
        for (uint64_t i = (uint64_t *)v10; i != *((uint64_t **)&v10 + 1); ++i)
        {
          uint64_t v7 = *(void *)(v5 + 32);
          uint64_t v8 = *i;
          uint64_t *i = 0;
          uint64_t v11 = v8;
          (*(void (**)(uint64_t, uint64_t *))(*(void *)v7 + 16))(v7, &v11);
          uint64_t v9 = v11;
          uint64_t v11 = 0;
          if (v9) {
            MEMORY[0x1C1881000](v9, 0x1000C4022EED179);
          }
        }
        uint64_t v14 = (void **)&v12;
        std::vector<std::unique_ptr<analytics::PutEvent>>::__destroy_vector::operator()[abi:nn180100](&v14);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void std::__function::__func<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void std::__function::__func<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t std::__function::__func<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = &unk_1F1811570;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *std::__function::__func<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = &unk_1F1811570;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F1811570;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1C1881000);
}

void *std::__function::__func<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F1811570;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::PutEvent>::logEvent(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*a2) {
    operator new();
  }
  *a2 = 0;
  int v2 = analytics_send_event_lazy();
  int v3 = *__error();
  uint64_t v4 = _SILogForLogForCategory(8);
  os_log_type_t v5 = 2 * (dword_1E9FC90C4 < 4);
  BOOL v6 = os_log_type_enabled(v4, v5);
  if (v2)
  {
    if (v6)
    {
      *(_DWORD *)iovec buf = 136315138;
      uint64_t v9 = "com.apple.spotlight.textstore.Put";
      uint64_t v7 = "successfully logged event: %s";
LABEL_8:
      _os_log_impl(&dword_1BD672000, v4, v5, v7, buf, 0xCu);
    }
  }
  else if (v6)
  {
    *(_DWORD *)iovec buf = 136315138;
    uint64_t v9 = "com.apple.spotlight.textstore.Put";
    uint64_t v7 = "event logging disabled: %s";
    goto LABEL_8;
  }
  *__error() = v3;
}

xpc_object_t ___ZN9analytics12_GLOBAL__N_119CoreAnalyticsLoggerINS_8PutEventEE8logEventENSt3__110unique_ptrIS2_NS4_14default_deleteIS2_EEEE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 32);
  uint64_t v77 = 0;
  unint64_t v78 = 0;
  uint64_t v79 = 0;
  std::string __p = 0;
  uint64_t v75 = 0;
  unint64_t v76 = 0;
  if (v1[1])
  {
    int v2 = (char *)operator new(8uLL);
    *(void *)int v2 = "success";
    int v3 = v2 + 8;
    unint64_t v78 = v2 + 8;
    uint64_t v79 = v2 + 8;
    int v4 = *v1;
    uint64_t v77 = v2;
    xpc_object_t v5 = xpc_BOOL_create(v4 != 0);
    BOOL v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(1uLL);
    *(void *)BOOL v6 = v5;
    std::string __p = v6;
    uint64_t v75 = v6 + 8;
    unint64_t v76 = &v6[8 * v7];
  }
  else
  {
    int v2 = 0;
    int v3 = 0;
  }
  if (v1[8])
  {
    uint64_t v8 = v3 - v2;
    uint64_t v9 = (v3 - v2) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      goto LABEL_109;
    }
    if (v8 >> 2 > v10) {
      unint64_t v10 = v8 >> 2;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    if (v11) {
      unint64_t v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v13 = (char *)(v11 + 8 * v9);
    *(void *)uint64_t v13 = "error_code";
    uint64_t v14 = v13 + 8;
    if (v3 != v2)
    {
      do
      {
        uint64_t v15 = *((void *)v3 - 1);
        v3 -= 8;
        *((void *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v3 != v2);
      int v2 = (char *)v77;
    }
    uint64_t v77 = v13;
    uint64_t v79 = (char *)(v11 + 8 * v12);
    if (v2) {
      operator delete(v2);
    }
    unint64_t v78 = v14;
    xpc_object_t v16 = xpc_int64_create(*((int *)v1 + 1));
    xpc_object_t v17 = v16;
    uint64_t v18 = v75;
    if (v75 >= v76)
    {
      uint64_t v20 = (char *)__p;
      uint64_t v21 = (v75 - (unsigned char *)__p) >> 3;
      unint64_t v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 61) {
        goto LABEL_109;
      }
      uint64_t v23 = v76 - (unsigned char *)__p;
      if ((v76 - (unsigned char *)__p) >> 2 > v22) {
        unint64_t v22 = v23 >> 2;
      }
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v24 = v22;
      }
      if (v24) {
        unint64_t v24 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v24);
      }
      else {
        uint64_t v25 = 0;
      }
      __int16 v26 = (char *)(v24 + 8 * v21);
      *(void *)__int16 v26 = v17;
      size_t v19 = v26 + 8;
      if (v18 != v20)
      {
        do
        {
          uint64_t v27 = *((void *)v18 - 1);
          v18 -= 8;
          *((void *)v26 - 1) = v27;
          v26 -= 8;
        }
        while (v18 != v20);
        uint64_t v18 = (char *)__p;
      }
      std::string __p = v26;
      unint64_t v76 = (char *)(v24 + 8 * v25);
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      *(void *)uint64_t v75 = v16;
      size_t v19 = v18 + 8;
    }
    uint64_t v75 = v19;
  }
  if (v1[24])
  {
    uint64_t v28 = v78;
    if (v78 >= v79)
    {
      uint64_t v30 = (char *)v77;
      uint64_t v31 = (v78 - (unsigned char *)v77) >> 3;
      unint64_t v32 = v31 + 1;
      if ((unint64_t)(v31 + 1) >> 61) {
        goto LABEL_109;
      }
      uint64_t v33 = v79 - (unsigned char *)v77;
      if ((v79 - (unsigned char *)v77) >> 2 > v32) {
        unint64_t v32 = v33 >> 2;
      }
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v34 = v32;
      }
      if (v34) {
        unint64_t v34 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v34);
      }
      else {
        uint64_t v35 = 0;
      }
      char v36 = (char *)(v34 + 8 * v31);
      *(void *)char v36 = "doc_size";
      uint64_t v29 = v36 + 8;
      if (v28 != v30)
      {
        do
        {
          uint64_t v37 = *((void *)v28 - 1);
          v28 -= 8;
          *((void *)v36 - 1) = v37;
          v36 -= 8;
        }
        while (v28 != v30);
        uint64_t v28 = (char *)v77;
      }
      uint64_t v77 = v36;
      uint64_t v79 = (char *)(v34 + 8 * v35);
      if (v28) {
        operator delete(v28);
      }
    }
    else
    {
      *(void *)unint64_t v78 = "doc_size";
      uint64_t v29 = v28 + 8;
    }
    unint64_t v78 = v29;
    xpc_object_t v38 = xpc_int64_create(*((void *)v1 + 2));
    xpc_object_t v39 = v38;
    uint64_t v40 = v75;
    if (v75 >= v76)
    {
      long long v42 = (char *)__p;
      uint64_t v43 = (v75 - (unsigned char *)__p) >> 3;
      unint64_t v44 = v43 + 1;
      if ((unint64_t)(v43 + 1) >> 61) {
        goto LABEL_109;
      }
      uint64_t v45 = v76 - (unsigned char *)__p;
      if ((v76 - (unsigned char *)__p) >> 2 > v44) {
        unint64_t v44 = v45 >> 2;
      }
      if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v46 = v44;
      }
      if (v46) {
        unint64_t v46 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v46);
      }
      else {
        uint64_t v47 = 0;
      }
      __n128 v48 = (char *)(v46 + 8 * v43);
      *(void *)__n128 v48 = v39;
      long long v41 = v48 + 8;
      if (v40 != v42)
      {
        do
        {
          uint64_t v49 = *((void *)v40 - 1);
          v40 -= 8;
          *((void *)v48 - 1) = v49;
          v48 -= 8;
        }
        while (v40 != v42);
        uint64_t v40 = (char *)__p;
      }
      std::string __p = v48;
      unint64_t v76 = (char *)(v46 + 8 * v47);
      if (v40) {
        operator delete(v40);
      }
    }
    else
    {
      *(void *)uint64_t v75 = v38;
      long long v41 = v40 + 8;
    }
    uint64_t v75 = v41;
  }
  if (!v1[36]) {
    goto LABEL_104;
  }
  __n128 v50 = v78;
  if (v78 >= v79)
  {
    uint64_t v52 = (char *)v77;
    uint64_t v53 = (v78 - (unsigned char *)v77) >> 3;
    unint64_t v54 = v53 + 1;
    if ((unint64_t)(v53 + 1) >> 61) {
      goto LABEL_109;
    }
    uint64_t v55 = v79 - (unsigned char *)v77;
    if ((v79 - (unsigned char *)v77) >> 2 > v54) {
      unint64_t v54 = v55 >> 2;
    }
    if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v56 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v56 = v54;
    }
    if (v56) {
      unint64_t v56 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v56);
    }
    else {
      uint64_t v57 = 0;
    }
    os_log_type_t v58 = (char *)(v56 + 8 * v53);
    *(void *)os_log_type_t v58 = "elapsed_ms";
    __n128 v51 = v58 + 8;
    if (v50 != v52)
    {
      do
      {
        uint64_t v59 = *((void *)v50 - 1);
        v50 -= 8;
        *((void *)v58 - 1) = v59;
        v58 -= 8;
      }
      while (v50 != v52);
      __n128 v50 = (char *)v77;
    }
    uint64_t v77 = v58;
    uint64_t v79 = (char *)(v56 + 8 * v57);
    if (v50) {
      operator delete(v50);
    }
  }
  else
  {
    *(void *)unint64_t v78 = "elapsed_ms";
    __n128 v51 = v50 + 8;
  }
  unint64_t v78 = v51;
  xpc_object_t v60 = xpc_double_create(*((float *)v1 + 8));
  xpc_object_t v61 = v60;
  os_log_type_t v62 = v75;
  if (v75 >= v76)
  {
    CFNumberRef v64 = (char *)__p;
    uint64_t v65 = (v75 - (unsigned char *)__p) >> 3;
    unint64_t v66 = v65 + 1;
    if (!((unint64_t)(v65 + 1) >> 61))
    {
      uint64_t v67 = v76 - (unsigned char *)__p;
      if ((v76 - (unsigned char *)__p) >> 2 > v66) {
        unint64_t v66 = v67 >> 2;
      }
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v68 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v68 = v66;
      }
      if (v68) {
        unint64_t v68 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v68);
      }
      else {
        uint64_t v69 = 0;
      }
      double v70 = (char *)(v68 + 8 * v65);
      *(void *)double v70 = v61;
      uint64_t v63 = v70 + 8;
      if (v62 != v64)
      {
        do
        {
          uint64_t v71 = *((void *)v62 - 1);
          v62 -= 8;
          *((void *)v70 - 1) = v71;
          v70 -= 8;
        }
        while (v62 != v64);
        os_log_type_t v62 = (char *)__p;
      }
      std::string __p = v70;
      unint64_t v76 = (char *)(v68 + 8 * v69);
      if (v62) {
        operator delete(v62);
      }
      goto LABEL_103;
    }
LABEL_109:
    abort();
  }
  *(void *)uint64_t v75 = v60;
  uint64_t v63 = v62 + 8;
LABEL_103:
  uint64_t v75 = v63;
LABEL_104:
  if (__p) {
    operator delete(__p);
  }
  if (v77) {
    operator delete(v77);
  }
  return v72;
}

void __destroy_helper_block_8_32c47_ZTSNSt3__110shared_ptrIN9analytics8PutEventEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_8_32c47_ZTSNSt3__110shared_ptrIN9analytics8PutEventEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<analytics::PutEvent  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x1C1881000);
  }
  return result;
}

void std::__shared_ptr_pointer<analytics::PutEvent  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::PutEvent>::~CoreAnalyticsLogger()
{
}

uint64_t std::__shared_ptr_emplace<analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::PutEvent>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::PutEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1811660;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void std::__shared_ptr_emplace<analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::PutEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1811660;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__function::__func<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        std::mutex::lock((std::mutex *)(v5 + 88));
        long long v12 = *(_OWORD *)(v5 + 56);
        long long v10 = v12;
        uint64_t v13 = *(void *)(v5 + 72);
        *(_OWORD *)(v5 + 72) = 0u;
        *(_OWORD *)(v5 + 56) = 0u;
        std::mutex::unlock((std::mutex *)(v5 + 88));
        for (uint64_t i = (uint64_t *)v10; i != *((uint64_t **)&v10 + 1); ++i)
        {
          uint64_t v7 = *(void *)(v5 + 32);
          uint64_t v8 = *i;
          uint64_t *i = 0;
          uint64_t v11 = v8;
          (*(void (**)(uint64_t, uint64_t *))(*(void *)v7 + 16))(v7, &v11);
          uint64_t v9 = v11;
          uint64_t v11 = 0;
          if (v9) {
            MEMORY[0x1C1881000](v9, 0x1000C4073594BB7);
          }
        }
        uint64_t v14 = (void **)&v12;
        std::vector<std::unique_ptr<analytics::GetEvent>>::__destroy_vector::operator()[abi:nn180100](&v14);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void std::__function::__func<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void std::__function::__func<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t std::__function::__func<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = &unk_1F18114E0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *std::__function::__func<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = &unk_1F18114E0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F18114E0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1C1881000);
}

void *std::__function::__func<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F18114E0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::DeleteEvent>::logEvent(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*a2) {
    operator new();
  }
  *a2 = 0;
  int v2 = analytics_send_event_lazy();
  int v3 = *__error();
  uint64_t v4 = _SILogForLogForCategory(8);
  os_log_type_t v5 = 2 * (dword_1E9FC90C4 < 4);
  BOOL v6 = os_log_type_enabled(v4, v5);
  if (v2)
  {
    if (v6)
    {
      *(_DWORD *)iovec buf = 136315138;
      uint64_t v9 = "com.apple.spotlight.textstore.Delete";
      uint64_t v7 = "successfully logged event: %s";
LABEL_8:
      _os_log_impl(&dword_1BD672000, v4, v5, v7, buf, 0xCu);
    }
  }
  else if (v6)
  {
    *(_DWORD *)iovec buf = 136315138;
    uint64_t v9 = "com.apple.spotlight.textstore.Delete";
    uint64_t v7 = "event logging disabled: %s";
    goto LABEL_8;
  }
  *__error() = v3;
}

xpc_object_t ___ZN9analytics12_GLOBAL__N_119CoreAnalyticsLoggerINS_11DeleteEventEE8logEventENSt3__110unique_ptrIS2_NS4_14default_deleteIS2_EEEE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 32);
  long long v121 = 0;
  __n128 v122 = 0;
  __n128 v123 = 0;
  std::string __p = 0;
  long long v119 = 0;
  long long v120 = 0;
  if (v1[1])
  {
    int v2 = (char *)operator new(8uLL);
    *(void *)int v2 = "success";
    int v3 = v2 + 8;
    __n128 v122 = v2 + 8;
    __n128 v123 = v2 + 8;
    int v4 = *v1;
    long long v121 = v2;
    xpc_object_t v5 = xpc_BOOL_create(v4 != 0);
    BOOL v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(1uLL);
    *(void *)BOOL v6 = v5;
    std::string __p = v6;
    long long v119 = v6 + 8;
    long long v120 = &v6[8 * v7];
  }
  else
  {
    int v2 = 0;
    int v3 = 0;
  }
  if (v1[8])
  {
    uint64_t v8 = v3 - v2;
    uint64_t v9 = (v3 - v2) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      goto LABEL_177;
    }
    if (v8 >> 2 > v10) {
      unint64_t v10 = v8 >> 2;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    if (v11) {
      unint64_t v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v13 = (char *)(v11 + 8 * v9);
    *(void *)uint64_t v13 = "error_code";
    uint64_t v14 = v13 + 8;
    if (v3 != v2)
    {
      do
      {
        uint64_t v15 = *((void *)v3 - 1);
        v3 -= 8;
        *((void *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v3 != v2);
      int v2 = (char *)v121;
    }
    long long v121 = v13;
    __n128 v123 = (char *)(v11 + 8 * v12);
    if (v2) {
      operator delete(v2);
    }
    __n128 v122 = v14;
    xpc_object_t v16 = xpc_int64_create(*((int *)v1 + 1));
    xpc_object_t v17 = v16;
    uint64_t v18 = v119;
    if (v119 >= v120)
    {
      uint64_t v20 = (char *)__p;
      uint64_t v21 = (v119 - (unsigned char *)__p) >> 3;
      unint64_t v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v23 = v120 - (unsigned char *)__p;
      if ((v120 - (unsigned char *)__p) >> 2 > v22) {
        unint64_t v22 = v23 >> 2;
      }
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v24 = v22;
      }
      if (v24) {
        unint64_t v24 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v24);
      }
      else {
        uint64_t v25 = 0;
      }
      __int16 v26 = (char *)(v24 + 8 * v21);
      *(void *)__int16 v26 = v17;
      size_t v19 = v26 + 8;
      if (v18 != v20)
      {
        do
        {
          uint64_t v27 = *((void *)v18 - 1);
          v18 -= 8;
          *((void *)v26 - 1) = v27;
          v26 -= 8;
        }
        while (v18 != v20);
        uint64_t v18 = (char *)__p;
      }
      std::string __p = v26;
      long long v120 = (char *)(v24 + 8 * v25);
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      *(void *)long long v119 = v16;
      size_t v19 = v18 + 8;
    }
    long long v119 = v19;
  }
  if (v1[24])
  {
    uint64_t v28 = v122;
    if (v122 >= v123)
    {
      uint64_t v30 = (char *)v121;
      uint64_t v31 = (v122 - (unsigned char *)v121) >> 3;
      unint64_t v32 = v31 + 1;
      if ((unint64_t)(v31 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v33 = v123 - (unsigned char *)v121;
      if ((v123 - (unsigned char *)v121) >> 2 > v32) {
        unint64_t v32 = v33 >> 2;
      }
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v34 = v32;
      }
      if (v34) {
        unint64_t v34 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v34);
      }
      else {
        uint64_t v35 = 0;
      }
      char v36 = (char *)(v34 + 8 * v31);
      *(void *)char v36 = "requested_doc_count";
      uint64_t v29 = v36 + 8;
      if (v28 != v30)
      {
        do
        {
          uint64_t v37 = *((void *)v28 - 1);
          v28 -= 8;
          *((void *)v36 - 1) = v37;
          v36 -= 8;
        }
        while (v28 != v30);
        uint64_t v28 = (char *)v121;
      }
      long long v121 = v36;
      __n128 v123 = (char *)(v34 + 8 * v35);
      if (v28) {
        operator delete(v28);
      }
    }
    else
    {
      *(void *)__n128 v122 = "requested_doc_count";
      uint64_t v29 = v28 + 8;
    }
    __n128 v122 = v29;
    xpc_object_t v38 = xpc_int64_create(*((void *)v1 + 2));
    xpc_object_t v39 = v38;
    uint64_t v40 = v119;
    if (v119 >= v120)
    {
      long long v42 = (char *)__p;
      uint64_t v43 = (v119 - (unsigned char *)__p) >> 3;
      unint64_t v44 = v43 + 1;
      if ((unint64_t)(v43 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v45 = v120 - (unsigned char *)__p;
      if ((v120 - (unsigned char *)__p) >> 2 > v44) {
        unint64_t v44 = v45 >> 2;
      }
      if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v46 = v44;
      }
      if (v46) {
        unint64_t v46 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v46);
      }
      else {
        uint64_t v47 = 0;
      }
      __n128 v48 = (char *)(v46 + 8 * v43);
      *(void *)__n128 v48 = v39;
      long long v41 = v48 + 8;
      if (v40 != v42)
      {
        do
        {
          uint64_t v49 = *((void *)v40 - 1);
          v40 -= 8;
          *((void *)v48 - 1) = v49;
          v48 -= 8;
        }
        while (v40 != v42);
        uint64_t v40 = (char *)__p;
      }
      std::string __p = v48;
      long long v120 = (char *)(v46 + 8 * v47);
      if (v40) {
        operator delete(v40);
      }
    }
    else
    {
      *(void *)long long v119 = v38;
      long long v41 = v40 + 8;
    }
    long long v119 = v41;
  }
  if (v1[40])
  {
    __n128 v50 = v122;
    if (v122 >= v123)
    {
      uint64_t v52 = (char *)v121;
      uint64_t v53 = (v122 - (unsigned char *)v121) >> 3;
      unint64_t v54 = v53 + 1;
      if ((unint64_t)(v53 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v55 = v123 - (unsigned char *)v121;
      if ((v123 - (unsigned char *)v121) >> 2 > v54) {
        unint64_t v54 = v55 >> 2;
      }
      if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v56 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v56 = v54;
      }
      if (v56) {
        unint64_t v56 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v56);
      }
      else {
        uint64_t v57 = 0;
      }
      os_log_type_t v58 = (char *)(v56 + 8 * v53);
      *(void *)os_log_type_t v58 = "hot_shard_doc_count";
      __n128 v51 = v58 + 8;
      if (v50 != v52)
      {
        do
        {
          uint64_t v59 = *((void *)v50 - 1);
          v50 -= 8;
          *((void *)v58 - 1) = v59;
          v58 -= 8;
        }
        while (v50 != v52);
        __n128 v50 = (char *)v121;
      }
      long long v121 = v58;
      __n128 v123 = (char *)(v56 + 8 * v57);
      if (v50) {
        operator delete(v50);
      }
    }
    else
    {
      *(void *)__n128 v122 = "hot_shard_doc_count";
      __n128 v51 = v50 + 8;
    }
    __n128 v122 = v51;
    xpc_object_t v60 = xpc_int64_create(*((void *)v1 + 4));
    xpc_object_t v61 = v60;
    os_log_type_t v62 = v119;
    if (v119 >= v120)
    {
      CFNumberRef v64 = (char *)__p;
      uint64_t v65 = (v119 - (unsigned char *)__p) >> 3;
      unint64_t v66 = v65 + 1;
      if ((unint64_t)(v65 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v67 = v120 - (unsigned char *)__p;
      if ((v120 - (unsigned char *)__p) >> 2 > v66) {
        unint64_t v66 = v67 >> 2;
      }
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v68 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v68 = v66;
      }
      if (v68) {
        unint64_t v68 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v68);
      }
      else {
        uint64_t v69 = 0;
      }
      double v70 = (char *)(v68 + 8 * v65);
      *(void *)double v70 = v61;
      uint64_t v63 = v70 + 8;
      if (v62 != v64)
      {
        do
        {
          uint64_t v71 = *((void *)v62 - 1);
          v62 -= 8;
          *((void *)v70 - 1) = v71;
          v70 -= 8;
        }
        while (v62 != v64);
        os_log_type_t v62 = (char *)__p;
      }
      std::string __p = v70;
      long long v120 = (char *)(v68 + 8 * v69);
      if (v62) {
        operator delete(v62);
      }
    }
    else
    {
      *(void *)long long v119 = v60;
      uint64_t v63 = v62 + 8;
    }
    long long v119 = v63;
  }
  if (v1[56])
  {
    xpc_object_t v72 = v122;
    if (v122 >= v123)
    {
      unint64_t v74 = (char *)v121;
      uint64_t v75 = (v122 - (unsigned char *)v121) >> 3;
      unint64_t v76 = v75 + 1;
      if ((unint64_t)(v75 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v77 = v123 - (unsigned char *)v121;
      if ((v123 - (unsigned char *)v121) >> 2 > v76) {
        unint64_t v76 = v77 >> 2;
      }
      if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v78 = v76;
      }
      if (v78) {
        unint64_t v78 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v78);
      }
      else {
        uint64_t v79 = 0;
      }
      long long v80 = (char *)(v78 + 8 * v75);
      *(void *)long long v80 = "cold_shard_doc_count";
      os_log_type_t v73 = v80 + 8;
      if (v72 != v74)
      {
        do
        {
          uint64_t v81 = *((void *)v72 - 1);
          v72 -= 8;
          *((void *)v80 - 1) = v81;
          v80 -= 8;
        }
        while (v72 != v74);
        xpc_object_t v72 = (char *)v121;
      }
      long long v121 = v80;
      __n128 v123 = (char *)(v78 + 8 * v79);
      if (v72) {
        operator delete(v72);
      }
    }
    else
    {
      *(void *)__n128 v122 = "cold_shard_doc_count";
      os_log_type_t v73 = v72 + 8;
    }
    __n128 v122 = v73;
    xpc_object_t v82 = xpc_int64_create(*((void *)v1 + 6));
    xpc_object_t v83 = v82;
    long long v84 = v119;
    if (v119 >= v120)
    {
      long long v86 = (char *)__p;
      uint64_t v87 = (v119 - (unsigned char *)__p) >> 3;
      unint64_t v88 = v87 + 1;
      if ((unint64_t)(v87 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v89 = v120 - (unsigned char *)__p;
      if ((v120 - (unsigned char *)__p) >> 2 > v88) {
        unint64_t v88 = v89 >> 2;
      }
      if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v90 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v90 = v88;
      }
      if (v90) {
        unint64_t v90 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v90);
      }
      else {
        uint64_t v91 = 0;
      }
      uint64_t v92 = (char *)(v90 + 8 * v87);
      *(void *)uint64_t v92 = v83;
      long long v85 = v92 + 8;
      if (v84 != v86)
      {
        do
        {
          uint64_t v93 = *((void *)v84 - 1);
          v84 -= 8;
          *((void *)v92 - 1) = v93;
          v92 -= 8;
        }
        while (v84 != v86);
        long long v84 = (char *)__p;
      }
      std::string __p = v92;
      long long v120 = (char *)(v90 + 8 * v91);
      if (v84) {
        operator delete(v84);
      }
    }
    else
    {
      *(void *)long long v119 = v82;
      long long v85 = v84 + 8;
    }
    long long v119 = v85;
  }
  if (!v1[68]) {
    goto LABEL_172;
  }
  uint64_t v94 = v122;
  if (v122 >= v123)
  {
    uint64_t v96 = (char *)v121;
    uint64_t v97 = (v122 - (unsigned char *)v121) >> 3;
    unint64_t v98 = v97 + 1;
    if ((unint64_t)(v97 + 1) >> 61) {
      goto LABEL_177;
    }
    uint64_t v99 = v123 - (unsigned char *)v121;
    if ((v123 - (unsigned char *)v121) >> 2 > v98) {
      unint64_t v98 = v99 >> 2;
    }
    if ((unint64_t)v99 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v100 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v100 = v98;
    }
    if (v100) {
      unint64_t v100 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v100);
    }
    else {
      uint64_t v101 = 0;
    }
    int v102 = (char *)(v100 + 8 * v97);
    *(void *)int v102 = "elapsed_ms";
    uint64_t v95 = v102 + 8;
    if (v94 != v96)
    {
      do
      {
        uint64_t v103 = *((void *)v94 - 1);
        v94 -= 8;
        *((void *)v102 - 1) = v103;
        v102 -= 8;
      }
      while (v94 != v96);
      uint64_t v94 = (char *)v121;
    }
    long long v121 = v102;
    __n128 v123 = (char *)(v100 + 8 * v101);
    if (v94) {
      operator delete(v94);
    }
  }
  else
  {
    *(void *)__n128 v122 = "elapsed_ms";
    uint64_t v95 = v94 + 8;
  }
  __n128 v122 = v95;
  xpc_object_t v104 = xpc_double_create(*((float *)v1 + 16));
  xpc_object_t v105 = v104;
  long long v106 = v119;
  if (v119 >= v120)
  {
    __n128 v108 = (char *)__p;
    uint64_t v109 = (v119 - (unsigned char *)__p) >> 3;
    unint64_t v110 = v109 + 1;
    if (!((unint64_t)(v109 + 1) >> 61))
    {
      uint64_t v111 = v120 - (unsigned char *)__p;
      if ((v120 - (unsigned char *)__p) >> 2 > v110) {
        unint64_t v110 = v111 >> 2;
      }
      if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v112 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v112 = v110;
      }
      if (v112) {
        unint64_t v112 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v112);
      }
      else {
        uint64_t v113 = 0;
      }
      long long v114 = (char *)(v112 + 8 * v109);
      *(void *)long long v114 = v105;
      long long v107 = v114 + 8;
      if (v106 != v108)
      {
        do
        {
          uint64_t v115 = *((void *)v106 - 1);
          v106 -= 8;
          *((void *)v114 - 1) = v115;
          v114 -= 8;
        }
        while (v106 != v108);
        long long v106 = (char *)__p;
      }
      std::string __p = v114;
      long long v120 = (char *)(v112 + 8 * v113);
      if (v106) {
        operator delete(v106);
      }
      goto LABEL_171;
    }
LABEL_177:
    abort();
  }
  *(void *)long long v119 = v104;
  long long v107 = v106 + 8;
LABEL_171:
  long long v119 = v107;
LABEL_172:
  if (__p) {
    operator delete(__p);
  }
  if (v121) {
    operator delete(v121);
  }
  return v116;
}

void __destroy_helper_block_8_32c51_ZTSNSt3__110shared_ptrIN9analytics11DeleteEventEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_8_32c51_ZTSNSt3__110shared_ptrIN9analytics11DeleteEventEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<analytics::DeleteEvent  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x1C1881000);
  }
  return result;
}

void std::__shared_ptr_pointer<analytics::DeleteEvent  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::DeleteEvent>::~CoreAnalyticsLogger()
{
}

uint64_t std::__shared_ptr_emplace<analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::DeleteEvent>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::DeleteEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F18115B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void std::__shared_ptr_emplace<analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::DeleteEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F18115B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::OpenEvent>::logEvent(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*a2) {
    operator new();
  }
  *a2 = 0;
  int v2 = analytics_send_event_lazy();
  int v3 = *__error();
  int v4 = _SILogForLogForCategory(8);
  os_log_type_t v5 = 2 * (dword_1E9FC90C4 < 4);
  BOOL v6 = os_log_type_enabled(v4, v5);
  if (v2)
  {
    if (v6)
    {
      *(_DWORD *)iovec buf = 136315138;
      uint64_t v9 = "com.apple.spotlight.textstore.Open";
      uint64_t v7 = "successfully logged event: %s";
LABEL_8:
      _os_log_impl(&dword_1BD672000, v4, v5, v7, buf, 0xCu);
    }
  }
  else if (v6)
  {
    *(_DWORD *)iovec buf = 136315138;
    uint64_t v9 = "com.apple.spotlight.textstore.Open";
    uint64_t v7 = "event logging disabled: %s";
    goto LABEL_8;
  }
  *__error() = v3;
}

xpc_object_t ___ZN9analytics12_GLOBAL__N_119CoreAnalyticsLoggerINS_9OpenEventEE8logEventENSt3__110unique_ptrIS2_NS4_14default_deleteIS2_EEEE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(int **)(a1 + 32);
  std::string __p = 0;
  long long v212 = 0;
  long long v213 = 0;
  long long v208 = 0;
  long long v209 = 0;
  unint64_t v210 = 0;
  if (*((unsigned char *)v1 + 4))
  {
    int v2 = (char *)operator new(8uLL);
    *(void *)int v2 = "open_type";
    std::string __p = v2;
    long long v213 = v2 + 8;
    int v3 = *v1;
    long long v212 = v2 + 8;
    int v4 = "load";
    if (v3 != 1) {
      int v4 = 0;
    }
    if (v3) {
      os_log_type_t v5 = v4;
    }
    else {
      os_log_type_t v5 = "create";
    }
    xpc_object_t v6 = xpc_string_create(v5);
    uint64_t v7 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(1uLL);
    uint64_t v9 = &v7[8 * v8];
    *(void *)uint64_t v7 = v6;
    uint64_t v10 = v7 + 8;
    uint64_t v12 = (char *)v208;
    unint64_t v11 = v209;
    if (v209 != v208)
    {
      do
      {
        uint64_t v13 = *((void *)v11 - 1);
        v11 -= 8;
        *((void *)v7 - 1) = v13;
        v7 -= 8;
      }
      while (v11 != v12);
      unint64_t v11 = (char *)v208;
    }
    long long v208 = v7;
    unint64_t v210 = (unint64_t)v9;
    if (v11) {
      operator delete(v11);
    }
    long long v209 = v10;
  }
  if (*((unsigned char *)v1 + 9))
  {
    uint64_t v14 = v212;
    if (v212 >= v213)
    {
      uint64_t v16 = (v212 - (unsigned char *)__p) >> 3;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_290;
      }
      unint64_t v17 = (v213 - (unsigned char *)__p) >> 2;
      if (v17 <= v16 + 1) {
        unint64_t v17 = v16 + 1;
      }
      if ((unint64_t)(v213 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v17;
      }
      if (v18) {
        unint64_t v18 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v18);
      }
      else {
        uint64_t v19 = 0;
      }
      uint64_t v20 = (char *)(v18 + 8 * v16);
      unint64_t v21 = v18 + 8 * v19;
      *(void *)uint64_t v20 = "success";
      uint64_t v15 = v20 + 8;
      uint64_t v23 = (char *)__p;
      unint64_t v22 = v212;
      if (v212 != __p)
      {
        do
        {
          uint64_t v24 = *((void *)v22 - 1);
          v22 -= 8;
          *((void *)v20 - 1) = v24;
          v20 -= 8;
        }
        while (v22 != v23);
        unint64_t v22 = (char *)__p;
      }
      std::string __p = v20;
      long long v213 = (char *)v21;
      if (v22) {
        operator delete(v22);
      }
    }
    else
    {
      *(void *)long long v212 = "success";
      uint64_t v15 = v14 + 8;
    }
    long long v212 = v15;
    xpc_object_t v25 = xpc_BOOL_create(*((unsigned char *)v1 + 8));
    xpc_object_t v26 = v25;
    uint64_t v27 = v209;
    if ((unint64_t)v209 >= v210)
    {
      uint64_t v29 = (v209 - (unsigned char *)v208) >> 3;
      if ((unint64_t)(v29 + 1) >> 61) {
        goto LABEL_290;
      }
      unint64_t v30 = (uint64_t)(v210 - (void)v208) >> 2;
      if (v30 <= v29 + 1) {
        unint64_t v30 = v29 + 1;
      }
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v31 = v30;
      }
      if (v31) {
        unint64_t v31 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v31);
      }
      else {
        uint64_t v32 = 0;
      }
      uint64_t v33 = (char *)(v31 + 8 * v29);
      unint64_t v34 = v31 + 8 * v32;
      *(void *)uint64_t v33 = v26;
      uint64_t v28 = v33 + 8;
      char v36 = (char *)v208;
      uint64_t v35 = v209;
      if (v209 != v208)
      {
        do
        {
          uint64_t v37 = *((void *)v35 - 1);
          v35 -= 8;
          *((void *)v33 - 1) = v37;
          v33 -= 8;
        }
        while (v35 != v36);
        uint64_t v35 = (char *)v208;
      }
      long long v208 = v33;
      unint64_t v210 = v34;
      if (v35) {
        operator delete(v35);
      }
    }
    else
    {
      *(void *)long long v209 = v25;
      uint64_t v28 = v27 + 8;
    }
    long long v209 = v28;
  }
  if (*((unsigned char *)v1 + 16))
  {
    xpc_object_t v38 = v212;
    if (v212 >= v213)
    {
      uint64_t v40 = (v212 - (unsigned char *)__p) >> 3;
      if ((unint64_t)(v40 + 1) >> 61) {
        goto LABEL_290;
      }
      unint64_t v41 = (v213 - (unsigned char *)__p) >> 2;
      if (v41 <= v40 + 1) {
        unint64_t v41 = v40 + 1;
      }
      if ((unint64_t)(v213 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v42 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v42 = v41;
      }
      if (v42) {
        unint64_t v42 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v42);
      }
      else {
        uint64_t v43 = 0;
      }
      unint64_t v44 = (char *)(v42 + 8 * v40);
      unint64_t v45 = v42 + 8 * v43;
      *(void *)unint64_t v44 = "error_code";
      xpc_object_t v39 = v44 + 8;
      uint64_t v47 = (char *)__p;
      unint64_t v46 = v212;
      if (v212 != __p)
      {
        do
        {
          uint64_t v48 = *((void *)v46 - 1);
          v46 -= 8;
          *((void *)v44 - 1) = v48;
          v44 -= 8;
        }
        while (v46 != v47);
        unint64_t v46 = (char *)__p;
      }
      std::string __p = v44;
      long long v213 = (char *)v45;
      if (v46) {
        operator delete(v46);
      }
    }
    else
    {
      *(void *)long long v212 = "error_code";
      xpc_object_t v39 = v38 + 8;
    }
    long long v212 = v39;
    xpc_object_t v49 = xpc_int64_create(v1[3]);
    xpc_object_t v50 = v49;
    __n128 v51 = v209;
    if ((unint64_t)v209 >= v210)
    {
      uint64_t v53 = (v209 - (unsigned char *)v208) >> 3;
      if ((unint64_t)(v53 + 1) >> 61) {
        goto LABEL_290;
      }
      unint64_t v54 = (uint64_t)(v210 - (void)v208) >> 2;
      if (v54 <= v53 + 1) {
        unint64_t v54 = v53 + 1;
      }
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v55 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v55 = v54;
      }
      if (v55) {
        unint64_t v55 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v55);
      }
      else {
        uint64_t v56 = 0;
      }
      uint64_t v57 = (char *)(v55 + 8 * v53);
      unint64_t v58 = v55 + 8 * v56;
      *(void *)uint64_t v57 = v50;
      uint64_t v52 = v57 + 8;
      xpc_object_t v60 = (char *)v208;
      uint64_t v59 = v209;
      if (v209 != v208)
      {
        do
        {
          uint64_t v61 = *((void *)v59 - 1);
          v59 -= 8;
          *((void *)v57 - 1) = v61;
          v57 -= 8;
        }
        while (v59 != v60);
        uint64_t v59 = (char *)v208;
      }
      long long v208 = v57;
      unint64_t v210 = v58;
      if (v59) {
        operator delete(v59);
      }
    }
    else
    {
      *(void *)long long v209 = v49;
      uint64_t v52 = v51 + 8;
    }
    long long v209 = v52;
  }
  if (*((unsigned char *)v1 + 32))
  {
    os_log_type_t v62 = v212;
    if (v212 >= v213)
    {
      uint64_t v64 = (v212 - (unsigned char *)__p) >> 3;
      if ((unint64_t)(v64 + 1) >> 61) {
        goto LABEL_290;
      }
      unint64_t v65 = (v213 - (unsigned char *)__p) >> 2;
      if (v65 <= v64 + 1) {
        unint64_t v65 = v64 + 1;
      }
      if ((unint64_t)(v213 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v66 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v66 = v65;
      }
      if (v66) {
        unint64_t v66 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v66);
      }
      else {
        uint64_t v67 = 0;
      }
      unint64_t v68 = (char *)(v66 + 8 * v64);
      unint64_t v69 = v66 + 8 * v67;
      *(void *)unint64_t v68 = "hot_shard_size";
      uint64_t v63 = v68 + 8;
      uint64_t v71 = (char *)__p;
      double v70 = v212;
      if (v212 != __p)
      {
        do
        {
          uint64_t v72 = *((void *)v70 - 1);
          v70 -= 8;
          *((void *)v68 - 1) = v72;
          v68 -= 8;
        }
        while (v70 != v71);
        double v70 = (char *)__p;
      }
      std::string __p = v68;
      long long v213 = (char *)v69;
      if (v70) {
        operator delete(v70);
      }
    }
    else
    {
      *(void *)long long v212 = "hot_shard_size";
      uint64_t v63 = v62 + 8;
    }
    long long v212 = v63;
    xpc_object_t v73 = xpc_int64_create(*((void *)v1 + 3));
    xpc_object_t v74 = v73;
    uint64_t v75 = v209;
    if ((unint64_t)v209 >= v210)
    {
      uint64_t v77 = (v209 - (unsigned char *)v208) >> 3;
      if ((unint64_t)(v77 + 1) >> 61) {
        goto LABEL_290;
      }
      unint64_t v78 = (uint64_t)(v210 - (void)v208) >> 2;
      if (v78 <= v77 + 1) {
        unint64_t v78 = v77 + 1;
      }
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v79 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v79 = v78;
      }
      if (v79) {
        unint64_t v79 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v79);
      }
      else {
        uint64_t v80 = 0;
      }
      uint64_t v81 = (char *)(v79 + 8 * v77);
      unint64_t v82 = v79 + 8 * v80;
      *(void *)uint64_t v81 = v74;
      unint64_t v76 = v81 + 8;
      long long v84 = (char *)v208;
      xpc_object_t v83 = v209;
      if (v209 != v208)
      {
        do
        {
          uint64_t v85 = *((void *)v83 - 1);
          v83 -= 8;
          *((void *)v81 - 1) = v85;
          v81 -= 8;
        }
        while (v83 != v84);
        xpc_object_t v83 = (char *)v208;
      }
      long long v208 = v81;
      unint64_t v210 = v82;
      if (v83) {
        operator delete(v83);
      }
    }
    else
    {
      *(void *)long long v209 = v73;
      unint64_t v76 = v75 + 8;
    }
    long long v209 = v76;
  }
  if (*((unsigned char *)v1 + 48))
  {
    long long v86 = v212;
    if (v212 >= v213)
    {
      uint64_t v88 = (v212 - (unsigned char *)__p) >> 3;
      if ((unint64_t)(v88 + 1) >> 61) {
        goto LABEL_290;
      }
      unint64_t v89 = (v213 - (unsigned char *)__p) >> 2;
      if (v89 <= v88 + 1) {
        unint64_t v89 = v88 + 1;
      }
      if ((unint64_t)(v213 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v90 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v90 = v89;
      }
      if (v90) {
        unint64_t v90 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v90);
      }
      else {
        uint64_t v91 = 0;
      }
      uint64_t v92 = (char *)(v90 + 8 * v88);
      unint64_t v93 = v90 + 8 * v91;
      *(void *)uint64_t v92 = "cold_shard_file_count";
      uint64_t v87 = v92 + 8;
      uint64_t v95 = (char *)__p;
      uint64_t v94 = v212;
      if (v212 != __p)
      {
        do
        {
          uint64_t v96 = *((void *)v94 - 1);
          v94 -= 8;
          *((void *)v92 - 1) = v96;
          v92 -= 8;
        }
        while (v94 != v95);
        uint64_t v94 = (char *)__p;
      }
      std::string __p = v92;
      long long v213 = (char *)v93;
      if (v94) {
        operator delete(v94);
      }
    }
    else
    {
      *(void *)long long v212 = "cold_shard_file_count";
      uint64_t v87 = v86 + 8;
    }
    long long v212 = v87;
    xpc_object_t v97 = xpc_int64_create(*((void *)v1 + 5));
    xpc_object_t v98 = v97;
    uint64_t v99 = v209;
    if ((unint64_t)v209 >= v210)
    {
      uint64_t v101 = (v209 - (unsigned char *)v208) >> 3;
      if ((unint64_t)(v101 + 1) >> 61) {
        goto LABEL_290;
      }
      unint64_t v102 = (uint64_t)(v210 - (void)v208) >> 2;
      if (v102 <= v101 + 1) {
        unint64_t v102 = v101 + 1;
      }
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v103 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v103 = v102;
      }
      if (v103) {
        unint64_t v103 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v103);
      }
      else {
        uint64_t v104 = 0;
      }
      xpc_object_t v105 = (char *)(v103 + 8 * v101);
      unint64_t v106 = v103 + 8 * v104;
      *(void *)xpc_object_t v105 = v98;
      unint64_t v100 = v105 + 8;
      __n128 v108 = (char *)v208;
      long long v107 = v209;
      if (v209 != v208)
      {
        do
        {
          uint64_t v109 = *((void *)v107 - 1);
          v107 -= 8;
          *((void *)v105 - 1) = v109;
          v105 -= 8;
        }
        while (v107 != v108);
        long long v107 = (char *)v208;
      }
      long long v208 = v105;
      unint64_t v210 = v106;
      if (v107) {
        operator delete(v107);
      }
    }
    else
    {
      *(void *)long long v209 = v97;
      unint64_t v100 = v99 + 8;
    }
    long long v209 = v100;
  }
  if (*((unsigned char *)v1 + 64))
  {
    unint64_t v110 = v212;
    if (v212 >= v213)
    {
      uint64_t v112 = (v212 - (unsigned char *)__p) >> 3;
      if ((unint64_t)(v112 + 1) >> 61) {
        goto LABEL_290;
      }
      unint64_t v113 = (v213 - (unsigned char *)__p) >> 2;
      if (v113 <= v112 + 1) {
        unint64_t v113 = v112 + 1;
      }
      if ((unint64_t)(v213 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v114 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v114 = v113;
      }
      if (v114) {
        unint64_t v114 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v114);
      }
      else {
        uint64_t v115 = 0;
      }
      xpc_object_t v116 = (char *)(v114 + 8 * v112);
      unint64_t v117 = v114 + 8 * v115;
      *(void *)xpc_object_t v116 = "cold_shard_total_size";
      uint64_t v111 = v116 + 8;
      long long v119 = (char *)__p;
      long long v118 = v212;
      if (v212 != __p)
      {
        do
        {
          uint64_t v120 = *((void *)v118 - 1);
          v118 -= 8;
          *((void *)v116 - 1) = v120;
          v116 -= 8;
        }
        while (v118 != v119);
        long long v118 = (char *)__p;
      }
      std::string __p = v116;
      long long v213 = (char *)v117;
      if (v118) {
        operator delete(v118);
      }
    }
    else
    {
      *(void *)long long v212 = "cold_shard_total_size";
      uint64_t v111 = v110 + 8;
    }
    long long v212 = v111;
    xpc_object_t v121 = xpc_int64_create(*((void *)v1 + 7));
    xpc_object_t v122 = v121;
    __n128 v123 = v209;
    if ((unint64_t)v209 >= v210)
    {
      uint64_t v125 = (v209 - (unsigned char *)v208) >> 3;
      if ((unint64_t)(v125 + 1) >> 61) {
        goto LABEL_290;
      }
      unint64_t v126 = (uint64_t)(v210 - (void)v208) >> 2;
      if (v126 <= v125 + 1) {
        unint64_t v126 = v125 + 1;
      }
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v127 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v127 = v126;
      }
      if (v127) {
        unint64_t v127 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v127);
      }
      else {
        uint64_t v128 = 0;
      }
      long long v129 = (char *)(v127 + 8 * v125);
      unint64_t v130 = v127 + 8 * v128;
      *(void *)long long v129 = v122;
      __n128 v124 = v129 + 8;
      long long v132 = (char *)v208;
      long long v131 = v209;
      if (v209 != v208)
      {
        do
        {
          uint64_t v133 = *((void *)v131 - 1);
          v131 -= 8;
          *((void *)v129 - 1) = v133;
          v129 -= 8;
        }
        while (v131 != v132);
        long long v131 = (char *)v208;
      }
      long long v208 = v129;
      unint64_t v210 = v130;
      if (v131) {
        operator delete(v131);
      }
    }
    else
    {
      *(void *)long long v209 = v121;
      __n128 v124 = v123 + 8;
    }
    long long v209 = v124;
  }
  if (*((unsigned char *)v1 + 76))
  {
    long long v134 = v212;
    if (v212 >= v213)
    {
      uint64_t v136 = (v212 - (unsigned char *)__p) >> 3;
      if ((unint64_t)(v136 + 1) >> 61) {
        goto LABEL_290;
      }
      unint64_t v137 = (v213 - (unsigned char *)__p) >> 2;
      if (v137 <= v136 + 1) {
        unint64_t v137 = v136 + 1;
      }
      if ((unint64_t)(v213 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v138 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v138 = v137;
      }
      if (v138) {
        unint64_t v138 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v138);
      }
      else {
        uint64_t v139 = 0;
      }
      long long v140 = (char *)(v138 + 8 * v136);
      unint64_t v141 = v138 + 8 * v139;
      *(void *)long long v140 = "elapsed_ms";
      long long v135 = v140 + 8;
      uint64_t v143 = (char *)__p;
      size_t v142 = v212;
      if (v212 != __p)
      {
        do
        {
          uint64_t v144 = *((void *)v142 - 1);
          v142 -= 8;
          *((void *)v140 - 1) = v144;
          v140 -= 8;
        }
        while (v142 != v143);
        size_t v142 = (char *)__p;
      }
      std::string __p = v140;
      long long v213 = (char *)v141;
      if (v142) {
        operator delete(v142);
      }
    }
    else
    {
      *(void *)long long v212 = "elapsed_ms";
      long long v135 = v134 + 8;
    }
    long long v212 = v135;
    xpc_object_t v145 = xpc_double_create(*((float *)v1 + 18));
    xpc_object_t v146 = v145;
    double v147 = v209;
    if ((unint64_t)v209 >= v210)
    {
      uint64_t v149 = (v209 - (unsigned char *)v208) >> 3;
      if ((unint64_t)(v149 + 1) >> 61) {
        goto LABEL_290;
      }
      unint64_t v150 = (uint64_t)(v210 - (void)v208) >> 2;
      if (v150 <= v149 + 1) {
        unint64_t v150 = v149 + 1;
      }
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v151 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v151 = v150;
      }
      if (v151) {
        unint64_t v151 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v151);
      }
      else {
        uint64_t v152 = 0;
      }
      long long v153 = (char *)(v151 + 8 * v149);
      unint64_t v154 = v151 + 8 * v152;
      *(void *)long long v153 = v146;
      uint64_t v148 = v153 + 8;
      uint64_t v156 = (char *)v208;
      BOOL v155 = v209;
      if (v209 != v208)
      {
        do
        {
          uint64_t v157 = *((void *)v155 - 1);
          v155 -= 8;
          *((void *)v153 - 1) = v157;
          v153 -= 8;
        }
        while (v155 != v156);
        BOOL v155 = (char *)v208;
      }
      long long v208 = v153;
      unint64_t v210 = v154;
      if (v155) {
        operator delete(v155);
      }
    }
    else
    {
      *(void *)long long v209 = v145;
      uint64_t v148 = v147 + 8;
    }
    long long v209 = v148;
  }
  if (*((unsigned char *)v1 + 88))
  {
    int v158 = v212;
    if (v212 >= v213)
    {
      uint64_t v160 = (v212 - (unsigned char *)__p) >> 3;
      if ((unint64_t)(v160 + 1) >> 61) {
        goto LABEL_290;
      }
      unint64_t v161 = (v213 - (unsigned char *)__p) >> 2;
      if (v161 <= v160 + 1) {
        unint64_t v161 = v160 + 1;
      }
      if ((unint64_t)(v213 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v162 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v162 = v161;
      }
      if (v162) {
        unint64_t v162 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v162);
      }
      else {
        uint64_t v163 = 0;
      }
      long long v164 = (char *)(v162 + 8 * v160);
      unint64_t v165 = v162 + 8 * v163;
      *(void *)long long v164 = "extra_hot_shard_corrupt_count";
      uint64_t v159 = v164 + 8;
      long long v167 = (char *)__p;
      uint64_t v166 = v212;
      if (v212 != __p)
      {
        do
        {
          uint64_t v168 = *((void *)v166 - 1);
          v166 -= 8;
          *((void *)v164 - 1) = v168;
          v164 -= 8;
        }
        while (v166 != v167);
        uint64_t v166 = (char *)__p;
      }
      std::string __p = v164;
      long long v213 = (char *)v165;
      if (v166) {
        operator delete(v166);
      }
    }
    else
    {
      *(void *)long long v212 = "extra_hot_shard_corrupt_count";
      uint64_t v159 = v158 + 8;
    }
    long long v212 = v159;
    xpc_object_t v169 = xpc_int64_create(*((void *)v1 + 10));
    xpc_object_t v170 = v169;
    uint64_t v171 = v209;
    if ((unint64_t)v209 >= v210)
    {
      uint64_t v173 = (v209 - (unsigned char *)v208) >> 3;
      if ((unint64_t)(v173 + 1) >> 61) {
        goto LABEL_290;
      }
      unint64_t v174 = (uint64_t)(v210 - (void)v208) >> 2;
      if (v174 <= v173 + 1) {
        unint64_t v174 = v173 + 1;
      }
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v175 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v175 = v174;
      }
      if (v175) {
        unint64_t v175 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v175);
      }
      else {
        uint64_t v176 = 0;
      }
      uint64_t v177 = (char *)(v175 + 8 * v173);
      unint64_t v178 = v175 + 8 * v176;
      *(void *)uint64_t v177 = v170;
      int v172 = v177 + 8;
      uint64_t v180 = (char *)v208;
      uint64_t v179 = v209;
      if (v209 != v208)
      {
        do
        {
          uint64_t v181 = *((void *)v179 - 1);
          v179 -= 8;
          *((void *)v177 - 1) = v181;
          v177 -= 8;
        }
        while (v179 != v180);
        uint64_t v179 = (char *)v208;
      }
      long long v208 = v177;
      unint64_t v210 = v178;
      if (v179) {
        operator delete(v179);
      }
    }
    else
    {
      *(void *)long long v209 = v169;
      int v172 = v171 + 8;
    }
    long long v209 = v172;
  }
  if (!*((unsigned char *)v1 + 104)) {
    goto LABEL_285;
  }
  uint64_t v182 = v212;
  if (v212 >= v213)
  {
    uint64_t v184 = (v212 - (unsigned char *)__p) >> 3;
    if ((unint64_t)(v184 + 1) >> 61) {
      goto LABEL_290;
    }
    unint64_t v185 = (v213 - (unsigned char *)__p) >> 2;
    if (v185 <= v184 + 1) {
      unint64_t v185 = v184 + 1;
    }
    if ((unint64_t)(v213 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v186 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v186 = v185;
    }
    if (v186) {
      unint64_t v186 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v186);
    }
    else {
      uint64_t v187 = 0;
    }
    double v188 = (char *)(v186 + 8 * v184);
    unint64_t v189 = v186 + 8 * v187;
    *(void *)double v188 = "extra_hot_shard_cooled_count";
    uint64_t v183 = v188 + 8;
    float v191 = (char *)__p;
    double v190 = v212;
    if (v212 != __p)
    {
      do
      {
        uint64_t v192 = *((void *)v190 - 1);
        v190 -= 8;
        *((void *)v188 - 1) = v192;
        v188 -= 8;
      }
      while (v190 != v191);
      double v190 = (char *)__p;
    }
    std::string __p = v188;
    long long v213 = (char *)v189;
    if (v190) {
      operator delete(v190);
    }
  }
  else
  {
    *(void *)long long v212 = "extra_hot_shard_cooled_count";
    uint64_t v183 = v182 + 8;
  }
  long long v212 = v183;
  xpc_object_t v193 = xpc_int64_create(*((void *)v1 + 12));
  xpc_object_t v194 = v193;
  double v195 = v209;
  if ((unint64_t)v209 >= v210)
  {
    uint64_t v197 = (v209 - (unsigned char *)v208) >> 3;
    if (!((unint64_t)(v197 + 1) >> 61))
    {
      unint64_t v198 = (uint64_t)(v210 - (void)v208) >> 2;
      if (v198 <= v197 + 1) {
        unint64_t v198 = v197 + 1;
      }
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v199 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v199 = v198;
      }
      if (v199) {
        unint64_t v199 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v199);
      }
      else {
        uint64_t v200 = 0;
      }
      uint64_t v201 = (char *)(v199 + 8 * v197);
      unint64_t v202 = v199 + 8 * v200;
      *(void *)uint64_t v201 = v194;
      double v196 = v201 + 8;
      uint64_t v204 = (char *)v208;
      int v203 = v209;
      if (v209 != v208)
      {
        do
        {
          uint64_t v205 = *((void *)v203 - 1);
          v203 -= 8;
          *((void *)v201 - 1) = v205;
          v201 -= 8;
        }
        while (v203 != v204);
        int v203 = (char *)v208;
      }
      long long v208 = v201;
      unint64_t v210 = v202;
      if (v203) {
        operator delete(v203);
      }
      goto LABEL_284;
    }
LABEL_290:
    abort();
  }
  *(void *)long long v209 = v193;
  double v196 = v195 + 8;
LABEL_284:
  long long v209 = v196;
LABEL_285:
  if (v208) {
    operator delete(v208);
  }
  if (__p) {
    operator delete(__p);
  }
  return v206;
}

void __destroy_helper_block_8_32c48_ZTSNSt3__110shared_ptrIN9analytics9OpenEventEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_8_32c48_ZTSNSt3__110shared_ptrIN9analytics9OpenEventEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<analytics::OpenEvent  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x1C1881000);
  }
  return result;
}

void std::__shared_ptr_pointer<analytics::OpenEvent  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::OpenEvent>::~CoreAnalyticsLogger()
{
}

uint64_t std::__shared_ptr_emplace<analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::OpenEvent>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::OpenEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1811698;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void std::__shared_ptr_emplace<analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::OpenEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1811698;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void analytics::ScopedLogger<analytics::OpenEvent>::ScopedLogger()
{
}

void *analytics::ScopedLogger<analytics::OpenEvent>::~ScopedLogger(void *a1)
{
  v2.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v3 = *a1;
  double v4 = (double)(v2.__d_.__rep_ - a1[1]) * 0.00001;
  if (!*(unsigned char *)(*a1 + 76)) {
    *(unsigned char *)(v3 + 76) = 1;
  }
  float v5 = v4;
  *(float *)(v3 + 72) = v5;
  uint64_t v6 = a1[2];
  uint64_t v7 = *a1;
  *a1 = 0;
  uint64_t v12 = v7;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 16))(v6, &v12);
  uint64_t v8 = v12;
  uint64_t v12 = 0;
  if (v8) {
    MEMORY[0x1C1881000](v8, 0x1000C4027064493);
  }
  uint64_t v9 = (std::__shared_weak_count *)a1[3];
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  uint64_t v10 = *a1;
  *a1 = 0;
  if (v10) {
    MEMORY[0x1C1881000](v10, 0x1000C4027064493);
  }
  return a1;
}

void analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::HotShardCoolDownEvent>::logEvent(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*a2) {
    operator new();
  }
  *a2 = 0;
  int v2 = analytics_send_event_lazy();
  int v3 = *__error();
  double v4 = _SILogForLogForCategory(8);
  os_log_type_t v5 = 2 * (dword_1E9FC90C4 < 4);
  BOOL v6 = os_log_type_enabled(v4, v5);
  if (v2)
  {
    if (v6)
    {
      *(_DWORD *)iovec buf = 136315138;
      uint64_t v9 = "com.apple.spotlight.textstore.HotShardCoolDown";
      uint64_t v7 = "successfully logged event: %s";
LABEL_8:
      _os_log_impl(&dword_1BD672000, v4, v5, v7, buf, 0xCu);
    }
  }
  else if (v6)
  {
    *(_DWORD *)iovec buf = 136315138;
    uint64_t v9 = "com.apple.spotlight.textstore.HotShardCoolDown";
    uint64_t v7 = "event logging disabled: %s";
    goto LABEL_8;
  }
  *__error() = v3;
}

xpc_object_t ___ZN9analytics12_GLOBAL__N_119CoreAnalyticsLoggerINS_21HotShardCoolDownEventEE8logEventENSt3__110unique_ptrIS2_NS4_14default_deleteIS2_EEEE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 32);
  xpc_object_t v121 = 0;
  xpc_object_t v122 = 0;
  __n128 v123 = 0;
  std::string __p = 0;
  long long v119 = 0;
  uint64_t v120 = 0;
  if (v1[1])
  {
    int v2 = (char *)operator new(8uLL);
    *(void *)int v2 = "success";
    int v3 = v2 + 8;
    xpc_object_t v122 = v2 + 8;
    __n128 v123 = v2 + 8;
    int v4 = *v1;
    xpc_object_t v121 = v2;
    xpc_object_t v5 = xpc_BOOL_create(v4 != 0);
    BOOL v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(1uLL);
    *(void *)BOOL v6 = v5;
    std::string __p = v6;
    long long v119 = v6 + 8;
    uint64_t v120 = &v6[8 * v7];
  }
  else
  {
    int v2 = 0;
    int v3 = 0;
  }
  if (v1[8])
  {
    uint64_t v8 = v3 - v2;
    uint64_t v9 = (v3 - v2) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      goto LABEL_177;
    }
    if (v8 >> 2 > v10) {
      unint64_t v10 = v8 >> 2;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    if (v11) {
      unint64_t v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v13 = (char *)(v11 + 8 * v9);
    *(void *)uint64_t v13 = "error_code";
    uint64_t v14 = v13 + 8;
    if (v3 != v2)
    {
      do
      {
        uint64_t v15 = *((void *)v3 - 1);
        v3 -= 8;
        *((void *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v3 != v2);
      int v2 = (char *)v121;
    }
    xpc_object_t v121 = v13;
    __n128 v123 = (char *)(v11 + 8 * v12);
    if (v2) {
      operator delete(v2);
    }
    xpc_object_t v122 = v14;
    xpc_object_t v16 = xpc_int64_create(*((int *)v1 + 1));
    xpc_object_t v17 = v16;
    unint64_t v18 = v119;
    if (v119 >= v120)
    {
      uint64_t v20 = (char *)__p;
      uint64_t v21 = (v119 - (unsigned char *)__p) >> 3;
      unint64_t v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v23 = v120 - (unsigned char *)__p;
      if ((v120 - (unsigned char *)__p) >> 2 > v22) {
        unint64_t v22 = v23 >> 2;
      }
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v24 = v22;
      }
      if (v24) {
        unint64_t v24 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v24);
      }
      else {
        uint64_t v25 = 0;
      }
      xpc_object_t v26 = (char *)(v24 + 8 * v21);
      *(void *)xpc_object_t v26 = v17;
      uint64_t v19 = v26 + 8;
      if (v18 != v20)
      {
        do
        {
          uint64_t v27 = *((void *)v18 - 1);
          v18 -= 8;
          *((void *)v26 - 1) = v27;
          v26 -= 8;
        }
        while (v18 != v20);
        unint64_t v18 = (char *)__p;
      }
      std::string __p = v26;
      uint64_t v120 = (char *)(v24 + 8 * v25);
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      *(void *)long long v119 = v16;
      uint64_t v19 = v18 + 8;
    }
    long long v119 = v19;
  }
  if (v1[24])
  {
    uint64_t v28 = v122;
    if (v122 >= v123)
    {
      unint64_t v30 = (char *)v121;
      uint64_t v31 = (v122 - (unsigned char *)v121) >> 3;
      unint64_t v32 = v31 + 1;
      if ((unint64_t)(v31 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v33 = v123 - (unsigned char *)v121;
      if ((v123 - (unsigned char *)v121) >> 2 > v32) {
        unint64_t v32 = v33 >> 2;
      }
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v34 = v32;
      }
      if (v34) {
        unint64_t v34 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v34);
      }
      else {
        uint64_t v35 = 0;
      }
      char v36 = (char *)(v34 + 8 * v31);
      *(void *)char v36 = "hot_shard_doc_count";
      uint64_t v29 = v36 + 8;
      if (v28 != v30)
      {
        do
        {
          uint64_t v37 = *((void *)v28 - 1);
          v28 -= 8;
          *((void *)v36 - 1) = v37;
          v36 -= 8;
        }
        while (v28 != v30);
        uint64_t v28 = (char *)v121;
      }
      xpc_object_t v121 = v36;
      __n128 v123 = (char *)(v34 + 8 * v35);
      if (v28) {
        operator delete(v28);
      }
    }
    else
    {
      *(void *)xpc_object_t v122 = "hot_shard_doc_count";
      uint64_t v29 = v28 + 8;
    }
    xpc_object_t v122 = v29;
    xpc_object_t v38 = xpc_int64_create(*((void *)v1 + 2));
    xpc_object_t v39 = v38;
    uint64_t v40 = v119;
    if (v119 >= v120)
    {
      unint64_t v42 = (char *)__p;
      uint64_t v43 = (v119 - (unsigned char *)__p) >> 3;
      unint64_t v44 = v43 + 1;
      if ((unint64_t)(v43 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v45 = v120 - (unsigned char *)__p;
      if ((v120 - (unsigned char *)__p) >> 2 > v44) {
        unint64_t v44 = v45 >> 2;
      }
      if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v46 = v44;
      }
      if (v46) {
        unint64_t v46 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v46);
      }
      else {
        uint64_t v47 = 0;
      }
      uint64_t v48 = (char *)(v46 + 8 * v43);
      *(void *)uint64_t v48 = v39;
      unint64_t v41 = v48 + 8;
      if (v40 != v42)
      {
        do
        {
          uint64_t v49 = *((void *)v40 - 1);
          v40 -= 8;
          *((void *)v48 - 1) = v49;
          v48 -= 8;
        }
        while (v40 != v42);
        uint64_t v40 = (char *)__p;
      }
      std::string __p = v48;
      uint64_t v120 = (char *)(v46 + 8 * v47);
      if (v40) {
        operator delete(v40);
      }
    }
    else
    {
      *(void *)long long v119 = v38;
      unint64_t v41 = v40 + 8;
    }
    long long v119 = v41;
  }
  if (v1[40])
  {
    xpc_object_t v50 = v122;
    if (v122 >= v123)
    {
      uint64_t v52 = (char *)v121;
      uint64_t v53 = (v122 - (unsigned char *)v121) >> 3;
      unint64_t v54 = v53 + 1;
      if ((unint64_t)(v53 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v55 = v123 - (unsigned char *)v121;
      if ((v123 - (unsigned char *)v121) >> 2 > v54) {
        unint64_t v54 = v55 >> 2;
      }
      if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v56 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v56 = v54;
      }
      if (v56) {
        unint64_t v56 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v56);
      }
      else {
        uint64_t v57 = 0;
      }
      unint64_t v58 = (char *)(v56 + 8 * v53);
      *(void *)unint64_t v58 = "hot_shard_size";
      __n128 v51 = v58 + 8;
      if (v50 != v52)
      {
        do
        {
          uint64_t v59 = *((void *)v50 - 1);
          v50 -= 8;
          *((void *)v58 - 1) = v59;
          v58 -= 8;
        }
        while (v50 != v52);
        xpc_object_t v50 = (char *)v121;
      }
      xpc_object_t v121 = v58;
      __n128 v123 = (char *)(v56 + 8 * v57);
      if (v50) {
        operator delete(v50);
      }
    }
    else
    {
      *(void *)xpc_object_t v122 = "hot_shard_size";
      __n128 v51 = v50 + 8;
    }
    xpc_object_t v122 = v51;
    xpc_object_t v60 = xpc_int64_create(*((void *)v1 + 4));
    xpc_object_t v61 = v60;
    os_log_type_t v62 = v119;
    if (v119 >= v120)
    {
      uint64_t v64 = (char *)__p;
      uint64_t v65 = (v119 - (unsigned char *)__p) >> 3;
      unint64_t v66 = v65 + 1;
      if ((unint64_t)(v65 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v67 = v120 - (unsigned char *)__p;
      if ((v120 - (unsigned char *)__p) >> 2 > v66) {
        unint64_t v66 = v67 >> 2;
      }
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v68 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v68 = v66;
      }
      if (v68) {
        unint64_t v68 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v68);
      }
      else {
        uint64_t v69 = 0;
      }
      double v70 = (char *)(v68 + 8 * v65);
      *(void *)double v70 = v61;
      uint64_t v63 = v70 + 8;
      if (v62 != v64)
      {
        do
        {
          uint64_t v71 = *((void *)v62 - 1);
          v62 -= 8;
          *((void *)v70 - 1) = v71;
          v70 -= 8;
        }
        while (v62 != v64);
        os_log_type_t v62 = (char *)__p;
      }
      std::string __p = v70;
      uint64_t v120 = (char *)(v68 + 8 * v69);
      if (v62) {
        operator delete(v62);
      }
    }
    else
    {
      *(void *)long long v119 = v60;
      uint64_t v63 = v62 + 8;
    }
    long long v119 = v63;
  }
  if (v1[56])
  {
    uint64_t v72 = v122;
    if (v122 >= v123)
    {
      xpc_object_t v74 = (char *)v121;
      uint64_t v75 = (v122 - (unsigned char *)v121) >> 3;
      unint64_t v76 = v75 + 1;
      if ((unint64_t)(v75 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v77 = v123 - (unsigned char *)v121;
      if ((v123 - (unsigned char *)v121) >> 2 > v76) {
        unint64_t v76 = v77 >> 2;
      }
      if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v78 = v76;
      }
      if (v78) {
        unint64_t v78 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v78);
      }
      else {
        uint64_t v79 = 0;
      }
      uint64_t v80 = (char *)(v78 + 8 * v75);
      *(void *)uint64_t v80 = "cold_shard_size";
      xpc_object_t v73 = v80 + 8;
      if (v72 != v74)
      {
        do
        {
          uint64_t v81 = *((void *)v72 - 1);
          v72 -= 8;
          *((void *)v80 - 1) = v81;
          v80 -= 8;
        }
        while (v72 != v74);
        uint64_t v72 = (char *)v121;
      }
      xpc_object_t v121 = v80;
      __n128 v123 = (char *)(v78 + 8 * v79);
      if (v72) {
        operator delete(v72);
      }
    }
    else
    {
      *(void *)xpc_object_t v122 = "cold_shard_size";
      xpc_object_t v73 = v72 + 8;
    }
    xpc_object_t v122 = v73;
    xpc_object_t v82 = xpc_int64_create(*((void *)v1 + 6));
    xpc_object_t v83 = v82;
    long long v84 = v119;
    if (v119 >= v120)
    {
      long long v86 = (char *)__p;
      uint64_t v87 = (v119 - (unsigned char *)__p) >> 3;
      unint64_t v88 = v87 + 1;
      if ((unint64_t)(v87 + 1) >> 61) {
        goto LABEL_177;
      }
      uint64_t v89 = v120 - (unsigned char *)__p;
      if ((v120 - (unsigned char *)__p) >> 2 > v88) {
        unint64_t v88 = v89 >> 2;
      }
      if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v90 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v90 = v88;
      }
      if (v90) {
        unint64_t v90 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v90);
      }
      else {
        uint64_t v91 = 0;
      }
      uint64_t v92 = (char *)(v90 + 8 * v87);
      *(void *)uint64_t v92 = v83;
      uint64_t v85 = v92 + 8;
      if (v84 != v86)
      {
        do
        {
          uint64_t v93 = *((void *)v84 - 1);
          v84 -= 8;
          *((void *)v92 - 1) = v93;
          v92 -= 8;
        }
        while (v84 != v86);
        long long v84 = (char *)__p;
      }
      std::string __p = v92;
      uint64_t v120 = (char *)(v90 + 8 * v91);
      if (v84) {
        operator delete(v84);
      }
    }
    else
    {
      *(void *)long long v119 = v82;
      uint64_t v85 = v84 + 8;
    }
    long long v119 = v85;
  }
  if (!v1[68]) {
    goto LABEL_172;
  }
  uint64_t v94 = v122;
  if (v122 >= v123)
  {
    uint64_t v96 = (char *)v121;
    uint64_t v97 = (v122 - (unsigned char *)v121) >> 3;
    unint64_t v98 = v97 + 1;
    if ((unint64_t)(v97 + 1) >> 61) {
      goto LABEL_177;
    }
    uint64_t v99 = v123 - (unsigned char *)v121;
    if ((v123 - (unsigned char *)v121) >> 2 > v98) {
      unint64_t v98 = v99 >> 2;
    }
    if ((unint64_t)v99 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v100 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v100 = v98;
    }
    if (v100) {
      unint64_t v100 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v100);
    }
    else {
      uint64_t v101 = 0;
    }
    unint64_t v102 = (char *)(v100 + 8 * v97);
    *(void *)unint64_t v102 = "elapsed_ms";
    uint64_t v95 = v102 + 8;
    if (v94 != v96)
    {
      do
      {
        uint64_t v103 = *((void *)v94 - 1);
        v94 -= 8;
        *((void *)v102 - 1) = v103;
        v102 -= 8;
      }
      while (v94 != v96);
      uint64_t v94 = (char *)v121;
    }
    xpc_object_t v121 = v102;
    __n128 v123 = (char *)(v100 + 8 * v101);
    if (v94) {
      operator delete(v94);
    }
  }
  else
  {
    *(void *)xpc_object_t v122 = "elapsed_ms";
    uint64_t v95 = v94 + 8;
  }
  xpc_object_t v122 = v95;
  xpc_object_t v104 = xpc_double_create(*((float *)v1 + 16));
  xpc_object_t v105 = v104;
  unint64_t v106 = v119;
  if (v119 >= v120)
  {
    __n128 v108 = (char *)__p;
    uint64_t v109 = (v119 - (unsigned char *)__p) >> 3;
    unint64_t v110 = v109 + 1;
    if (!((unint64_t)(v109 + 1) >> 61))
    {
      uint64_t v111 = v120 - (unsigned char *)__p;
      if ((v120 - (unsigned char *)__p) >> 2 > v110) {
        unint64_t v110 = v111 >> 2;
      }
      if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v112 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v112 = v110;
      }
      if (v112) {
        unint64_t v112 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v112);
      }
      else {
        uint64_t v113 = 0;
      }
      unint64_t v114 = (char *)(v112 + 8 * v109);
      *(void *)unint64_t v114 = v105;
      long long v107 = v114 + 8;
      if (v106 != v108)
      {
        do
        {
          uint64_t v115 = *((void *)v106 - 1);
          v106 -= 8;
          *((void *)v114 - 1) = v115;
          v114 -= 8;
        }
        while (v106 != v108);
        unint64_t v106 = (char *)__p;
      }
      std::string __p = v114;
      uint64_t v120 = (char *)(v112 + 8 * v113);
      if (v106) {
        operator delete(v106);
      }
      goto LABEL_171;
    }
LABEL_177:
    abort();
  }
  *(void *)long long v119 = v104;
  long long v107 = v106 + 8;
LABEL_171:
  long long v119 = v107;
LABEL_172:
  if (__p) {
    operator delete(__p);
  }
  if (v121) {
    operator delete(v121);
  }
  return v116;
}

void __destroy_helper_block_8_32c61_ZTSNSt3__110shared_ptrIN9analytics21HotShardCoolDownEventEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_8_32c61_ZTSNSt3__110shared_ptrIN9analytics21HotShardCoolDownEventEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<analytics::HotShardCoolDownEvent  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x1C1881000);
  }
  return result;
}

void std::__shared_ptr_pointer<analytics::HotShardCoolDownEvent  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::HotShardCoolDownEvent>::~CoreAnalyticsLogger()
{
}

uint64_t std::__shared_ptr_emplace<analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::HotShardCoolDownEvent>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::HotShardCoolDownEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F18115F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void std::__shared_ptr_emplace<analytics::anonymous namespace'::CoreAnalyticsLogger<analytics::HotShardCoolDownEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F18115F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void analytics::ScopedLogger<analytics::DeleteEvent>::ScopedLogger()
{
}

void *analytics::ScopedLogger<analytics::DeleteEvent>::~ScopedLogger(void *a1)
{
  v2.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v3 = *a1;
  double v4 = (double)(v2.__d_.__rep_ - a1[1]) * 0.00001;
  if (!*(unsigned char *)(*a1 + 68)) {
    *(unsigned char *)(v3 + 68) = 1;
  }
  float v5 = v4;
  *(float *)(v3 + 64) = v5;
  uint64_t v6 = a1[2];
  uint64_t v7 = *a1;
  *a1 = 0;
  uint64_t v12 = v7;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 16))(v6, &v12);
  uint64_t v8 = v12;
  uint64_t v12 = 0;
  if (v8) {
    MEMORY[0x1C1881000](v8, 0x1000C4073594BB7);
  }
  uint64_t v9 = (std::__shared_weak_count *)a1[3];
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  uint64_t v10 = *a1;
  *a1 = 0;
  if (v10) {
    MEMORY[0x1C1881000](v10, 0x1000C4073594BB7);
  }
  return a1;
}

uint64_t SISetLogging(uint64_t result, int a2)
{
  if (result <= 0x14) {
    gSILogLevels[result] = a2;
  }
  return result;
}

uint64_t trie_level_info_hash(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 16);
  int v2 = ((16 * *(_DWORD *)(a1 + 4)) | (*(_DWORD *)a1 << 6)) ^ *(_DWORD *)(a1 + 24) ^ *(_DWORD *)(a1 + 32);
  if (v1 >= 0) {
    int v3 = *(_DWORD *)(a1 + 16);
  }
  else {
    int v3 = v1 + 3;
  }
  unsigned int v4 = v2 ^ 0x971E137B;
  float v5 = (unsigned __int8 *)(*(void *)(a1 + 8) + (int)(v3 & 0xFFFFFFFC));
  if ((v1 + 3) >= 7)
  {
    uint64_t v8 = -(v3 >> 2);
    int v9 = -1789642873;
    int v10 = 718793509;
    do
    {
      int v9 = 5 * v9 + 2071795100;
      int v10 = 5 * v10 + 1808688022;
      HIDWORD(v11) = v9 * *(_DWORD *)&v5[4 * v8];
      LODWORD(v11) = HIDWORD(v11);
      int v12 = (v11 >> 21) * v10;
      HIDWORD(v11) = v4;
      LODWORD(v11) = v4;
      unsigned int v4 = v12 ^ (5 * (v11 >> 19) + 1390208809);
    }
    while (!__CFADD__(v8++, 1));
    int v7 = 5 * v9 + 2071795100;
    int v6 = 5 * v10 + 1808688022;
  }
  else
  {
    int v6 = 1107688271;
    int v7 = 1713515327;
  }
  int v14 = 0;
  int v15 = v1 & 3;
  switch(v15)
  {
    case 1:
      goto LABEL_15;
    case 2:
LABEL_14:
      v14 |= v5[1] << 8;
LABEL_15:
      HIDWORD(v16) = (v14 ^ *v5) * v7;
      LODWORD(v16) = HIDWORD(v16);
      int v17 = (v16 >> 21) * v6;
      HIDWORD(v16) = v4;
      LODWORD(v16) = v4;
      unsigned int v4 = v17 ^ (5 * (v16 >> 19) + 1390208809);
      break;
    case 3:
      int v14 = v5[2] << 16;
      goto LABEL_14;
  }
  unsigned int v18 = -1028477387 * ((-2048144789 * (v4 ^ v1)) ^ ((-2048144789 * (v4 ^ v1)) >> 13));
  return v2 ^ HIWORD(v18) ^ v18;
}

BOOL trie_level_info_eq(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 24) == *(void *)(a2 + 24)
    && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32)
    && *(_DWORD *)a1 == *(_DWORD *)a2
    && *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4)
    && (size_t v2 = *(int *)(a1 + 16), v2 == *(_DWORD *)(a2 + 16)))
  {
    return memcmp(*(const void **)(a1 + 8), *(const void **)(a2 + 8), v2) == 0;
  }
  else
  {
    return 0;
  }
}

uint64_t bt_changePrefix(uint64_t a1, const char *a2, const char *a3, int a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  snprintf((char *)__str, 0x400uLL, "%s%s", a3, "indexDirectory");
  int v8 = fd_rename(*(void *)(a1 + 4576), (const char *)__str);
  snprintf((char *)__str, 0x400uLL, "%s%s", a3, "indexCompactDirectory");
  if (v8)
  {
    snprintf((char *)__str, 0x400uLL, "%s%s", a3, "indexArrays");
    return 0;
  }
  int v10 = fd_rename(*(void *)(a1 + 112), (const char *)__str);
  snprintf((char *)__str, 0x400uLL, "%s%s", a3, "indexArrays");
  if (v10) {
    return 0;
  }
  int v11 = fd_rename(*(void *)(a1 + 376), (const char *)__str);
  BOOL v9 = v11 == 0;
  if (!v11 && a4)
  {
    bzero(&__from, 0x400uLL);
    uint64_t v12 = *(unsigned int *)(a1 + 152);
    memset(&v23, 0, sizeof(v23));
    if (fstat(v12, &v23)) {
      return 1;
    }
    uint64_t v14 = open(".", 4);
    if (MEMORY[0x1C1882290](v12))
    {
      if ((v14 & 0x80000000) == 0) {
        close(v14);
      }
      return 1;
    }
    snprintf((char *)&__from, 0x400uLL, "%s%s", a2, "shadowIndexArrays");
    snprintf((char *)__str, 0x400uLL, "%s%s", a3, "shadowIndexArrays");
    rename(&__from, __str, v15);
    int v17 = v16;
    snprintf((char *)&__from, 0x400uLL, "%s%s", a2, "shadowIndexDirectory");
    snprintf((char *)__str, 0x400uLL, "%s%s", a3, "shadowIndexDirectory");
    if (v17)
    {
      snprintf((char *)&__from, 0x400uLL, "%s%s", a2, "shadowIndexCompactDirectory");
      snprintf((char *)__str, 0x400uLL, "%s%s", a3, "shadowIndexCompactDirectory");
    }
    else
    {
      rename(&__from, __str, v18);
      int v20 = v19;
      snprintf((char *)&__from, 0x400uLL, "%s%s", a2, "shadowIndexCompactDirectory");
      snprintf((char *)__str, 0x400uLL, "%s%s", a3, "shadowIndexCompactDirectory");
      if (!v20)
      {
        rename(&__from, __str, v21);
        BOOL v9 = v22 == 0;
LABEL_17:
        MEMORY[0x1C1882290](v14);
        if ((v14 & 0x80000000) == 0) {
          close(v14);
        }
        return v9;
      }
    }
    BOOL v9 = 0;
    goto LABEL_17;
  }
  return v9;
}

uint64_t bt_openTrie(uint64_t a1, int a2, const char *a3, int a4, int a5, int a6, int a7, void *a8)
{
  uint64_t v122 = *MEMORY[0x1E4F143B8];
  int v15 = (_OWORD *)(a1 + 4536);
  *(_DWORD *)(a1 + 4584) = a4;
  *(_DWORD *)(a1 + 152) = a2;
  if (!*(void *)(a1 + 4544))
  {
    CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    *int v15 = xmmword_1BDA82360;
    CFSetRef Mutable = CFBitVectorCreateMutable(v16, 0x2000);
    *(void *)(a1 + 4552) = Mutable;
    CFBitVectorSetCount(Mutable, 0x2000);
    if (!*(void *)(a1 + 4552))
    {
      unint64_t v98 = __si_assert_copy_extra_1921(0);
      uint64_t v99 = v98;
      unint64_t v100 = "";
      if (v98) {
        unint64_t v100 = v98;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 47, "bv->_cfbv", v100);
      free(v99);
      if (__valid_fs(-1)) {
        uint64_t v101 = 2989;
      }
      else {
        uint64_t v101 = 3072;
      }
      *(_DWORD *)uint64_t v101 = -559038737;
      abort();
    }
  }
  uint64_t v109 = v15;
  BOOL v18 = 0;
  if (a5) {
    int v19 = 0;
  }
  else {
    int v19 = 514;
  }
  if (a6)
  {
    if ((a5 & 1) == 0)
    {
      xpc_object_t v105 = __si_assert_copy_extra_1921(0);
      unint64_t v106 = v105;
      long long v107 = "";
      if (v105) {
        long long v107 = v105;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 531, "0", v107);
      free(v106);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    BOOL v18 = a4 == 0;
  }
  memset(&v111, 0, sizeof(v111));
  bzero(__str, 0x400uLL);
  int v20 = "indexDirectory";
  int v110 = *(_DWORD *)(a1 + 148);
  if (v110)
  {
    if (v18) {
      int v20 = "shadowIndexDirectory";
    }
    snprintf(__str, 0x400uLL, "%s%s", a3, v20);
    uint64_t v21 = fd_create_protected(a2, __str, v19, 0);
    *(void *)(a1 + 4576) = v21;
    if (v21 || (a5 & 1) != 0)
    {
LABEL_18:
      if (v21) {
        goto LABEL_19;
      }
LABEL_45:
      int v35 = *__error();
      unint64_t v42 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        int v44 = *__error();
        *(_DWORD *)iovec buf = 136315906;
        uint64_t v113 = "bt_openTrie";
        __int16 v114 = 1024;
        int v115 = 600;
        __int16 v116 = 2080;
        *(void *)unint64_t v117 = __str;
        *(_WORD *)&v117[8] = 1024;
        *(_DWORD *)&v117[10] = v44;
        xpc_object_t v39 = "%s:%d: open %s err: %d";
        goto LABEL_90;
      }
      goto LABEL_92;
    }
    if (*__error() == 13)
    {
      int v22 = *__error();
      stat v23 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)iovec buf = 136315650;
        uint64_t v113 = "bt_openTrie";
        __int16 v114 = 1024;
        int v115 = 593;
        __int16 v116 = 2080;
        *(void *)unint64_t v117 = __str;
        _os_log_error_impl(&dword_1BD672000, v23, OS_LOG_TYPE_ERROR, "%s:%d: open rdwr error tyring readonly %s", buf, 0x1Cu);
      }
      *__error() = v22;
      uint64_t v21 = fd_create_protected(a2, __str, 0, 0);
      int v19 = 0;
      *(void *)(a1 + 4576) = v21;
      a5 = 1;
      goto LABEL_18;
    }
    a5 = 0;
    uint64_t v21 = *(void **)(a1 + 4576);
    if (!v21) {
      goto LABEL_45;
    }
LABEL_19:
    while (1)
    {
      int v24 = fstatat(*((_DWORD *)v21 + 11), (const char *)v21[9], &v111, 2048);
      uint64_t v25 = g_prot_error_callback;
      if (v24 != -1 || g_prot_error_callback == 0) {
        break;
      }
      uint64_t v27 = *((unsigned int *)v21 + 10);
      uint64_t v28 = __error();
      if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v25 + 16))(v25, v27, *v28, 8) & 1) == 0) {
        goto LABEL_42;
      }
    }
    if (v24 == -1)
    {
LABEL_42:
      int v35 = *__error();
      unint64_t v42 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        int v43 = *__error();
        *(_DWORD *)iovec buf = 136315906;
        uint64_t v113 = "bt_openTrie";
        __int16 v114 = 1024;
        int v115 = 605;
        __int16 v116 = 1024;
        *(_DWORD *)unint64_t v117 = v43;
        *(_WORD *)&v117[4] = 2080;
        *(void *)&v117[6] = __str;
        xpc_object_t v39 = "%s:%d: fstat err:%d %s";
LABEL_90:
        uint64_t v40 = v42;
        uint32_t v41 = 34;
        goto LABEL_91;
      }
LABEL_92:
      unint64_t v58 = 0;
      uint64_t v53 = 0;
LABEL_93:
      *__error() = v35;
      goto LABEL_94;
    }
    off_t v34 = 1028 * *(unsigned int *)(a1 + 148);
    if (v111.st_size > v34 || v111.st_size < 1028 * *(unsigned int *)(a1 + 144))
    {
      int v35 = *__error();
      char v36 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
        goto LABEL_92;
      }
      int v37 = *(_DWORD *)(a1 + 148);
      int v38 = 1028 * *(_DWORD *)(a1 + 144);
      *(_DWORD *)iovec buf = 136316418;
      uint64_t v113 = "bt_openTrie";
      __int16 v114 = 1024;
      int v115 = 613;
      __int16 v116 = 1024;
      *(_DWORD *)unint64_t v117 = v111.st_size;
      *(_WORD *)&v117[4] = 1024;
      *(_DWORD *)&v117[6] = v38;
      *(_WORD *)&v117[10] = 1024;
      *(_DWORD *)&v117[12] = 1028 * v37;
      *(_WORD *)&v117[16] = 2080;
      *(void *)&v117[18] = __str;
      xpc_object_t v39 = "%s:%d: FAT: bad file size:%d (expected %d - %d) %s";
      uint64_t v40 = v36;
      uint32_t v41 = 46;
LABEL_91:
      _os_log_error_impl(&dword_1BD672000, v40, OS_LOG_TYPE_ERROR, v39, buf, v41);
      goto LABEL_92;
    }
    if ((a5 & 1) != 0 || fd_truncate(*(void *)(a1 + 4576), v34) != -1)
    {
      if (!*(void *)(a1 + 8))
      {
        uint64_t v80 = (void *)fd_mmap(*(void *)(a1 + 4576));
        *(void *)(a1 + 8) = v80;
        if (v80 == (void *)-1)
        {
          int v35 = *__error();
          unint64_t v42 = _SILogForLogForCategory(0);
          if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
            goto LABEL_92;
          }
          int v84 = *__error();
          uint64_t v85 = 1028 * *(unsigned int *)(a1 + 148);
          *(_DWORD *)iovec buf = 136315906;
          uint64_t v113 = "bt_openTrie";
          __int16 v114 = 1024;
          int v115 = 626;
          __int16 v116 = 1024;
          *(_DWORD *)unint64_t v117 = v84;
          *(_WORD *)&v117[4] = 2048;
          *(void *)&v117[6] = v85;
          xpc_object_t v39 = "%s:%d: fd_mmap err: %d, %ld";
          goto LABEL_90;
        }
        if (a5)
        {
          madvise(v80, 1028 * *(unsigned int *)(a1 + 148), 2);
          a5 = 1;
        }
      }
      goto LABEL_69;
    }
    int v35 = *__error();
    uint64_t v47 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      goto LABEL_92;
    }
    int v81 = *__error();
    *(_DWORD *)iovec buf = 136315650;
    uint64_t v113 = "bt_openTrie";
    __int16 v114 = 1024;
    int v115 = 619;
    __int16 v116 = 1024;
    *(_DWORD *)unint64_t v117 = v81;
    xpc_object_t v39 = "%s:%d: ftruncate err: %d";
LABEL_61:
    uint64_t v40 = v47;
    uint32_t v41 = 24;
    goto LABEL_91;
  }
  *(_DWORD *)a1 = 11;
  if (a5) {
    int v29 = 0;
  }
  else {
    int v29 = 1538;
  }
  *(void *)(a1 + 144) = 0x800000001;
  if (v18) {
    int v20 = "shadowIndexDirectory";
  }
  snprintf(__str, 0x400uLL, "%s%s", a3, v20);
  unint64_t v30 = fd_create_protected(a2, __str, v29, 0);
  *(void *)(a1 + 4576) = v30;
  if (!v30 && (a5 & 1) == 0)
  {
    if (*__error() == 13)
    {
      int v31 = *__error();
      unint64_t v32 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)iovec buf = 136315650;
        uint64_t v113 = "bt_openTrie";
        __int16 v114 = 1024;
        int v115 = 556;
        __int16 v116 = 2080;
        *(void *)unint64_t v117 = __str;
        _os_log_error_impl(&dword_1BD672000, v32, OS_LOG_TYPE_ERROR, "%s:%d: open rdwr error tyring readonly %s", buf, 0x1Cu);
      }
      *__error() = v31;
      uint64_t v33 = fd_create_protected(a2, __str, 0, 0);
      *(void *)(a1 + 4576) = v33;
      if (!v33)
      {
LABEL_52:
        int v35 = *__error();
        unint64_t v42 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        {
          int v45 = *__error();
          *(_DWORD *)iovec buf = 136315906;
          uint64_t v113 = "bt_openTrie";
          __int16 v114 = 1024;
          int v115 = 563;
          __int16 v116 = 2080;
          *(void *)unint64_t v117 = __str;
          *(_WORD *)&v117[8] = 1024;
          *(_DWORD *)&v117[10] = v45;
          xpc_object_t v39 = "%s:%d: open %s err: %d";
          goto LABEL_90;
        }
        goto LABEL_92;
      }
LABEL_50:
      int v19 = 0;
      a5 = 1;
      if (*(void *)(a1 + 8)) {
        goto LABEL_69;
      }
      goto LABEL_56;
    }
    unint64_t v30 = *(void **)(a1 + 4576);
  }
  if (!v30) {
    goto LABEL_52;
  }
  if (a5) {
    goto LABEL_50;
  }
  if (fd_truncate((uint64_t)v30, 1028 * *(unsigned int *)(a1 + 148)) == -1)
  {
    int v35 = *__error();
    uint64_t v47 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      goto LABEL_92;
    }
    int v48 = *__error();
    *(_DWORD *)iovec buf = 136315650;
    uint64_t v113 = "bt_openTrie";
    __int16 v114 = 1024;
    int v115 = 569;
    __int16 v116 = 1024;
    *(_DWORD *)unint64_t v117 = v48;
    xpc_object_t v39 = "%s:%d: ftruncate err: %d";
    goto LABEL_61;
  }
  a5 = 0;
  int v19 = 1538;
  if (*(void *)(a1 + 8)) {
    goto LABEL_69;
  }
LABEL_56:
  unint64_t v46 = (void *)fd_mmap(*(void *)(a1 + 4576));
  *(void *)(a1 + 8) = v46;
  if (v46 == (void *)-1)
  {
    int v35 = *__error();
    unint64_t v42 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      int v49 = *__error();
      uint64_t v50 = 1028 * *(unsigned int *)(a1 + 148);
      *(_DWORD *)iovec buf = 136315906;
      uint64_t v113 = "bt_openTrie";
      __int16 v114 = 1024;
      int v115 = 578;
      __int16 v116 = 1024;
      *(_DWORD *)unint64_t v117 = v49;
      *(_WORD *)&v117[4] = 2048;
      *(void *)&v117[6] = v50;
      xpc_object_t v39 = "%s:%d: fd_mmap err: %d, %ld";
      goto LABEL_90;
    }
    goto LABEL_92;
  }
  if (a5)
  {
    madvise(v46, 1028 * *(unsigned int *)(a1 + 148), 2);
    a5 = 1;
  }
  else
  {
    bzero(v46, 0x808uLL);
    a5 = 0;
  }
LABEL_69:
  __n128 v51 = "indexCompactDirectory";
  if (v18) {
    __n128 v51 = "shadowIndexCompactDirectory";
  }
  snprintf(__str, 0x400uLL, "%s%s", a3, v51);
  uint64_t v52 = fd_create_protected(a2, __str, v19, 0);
  uint64_t v53 = v52;
  if ((a5 & 1) == 0 && !v52)
  {
    if (*__error() != 13) {
      goto LABEL_88;
    }
    int v54 = *__error();
    uint64_t v55 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)iovec buf = 136315650;
      uint64_t v113 = "bt_openTrie";
      __int16 v114 = 1024;
      int v115 = 639;
      __int16 v116 = 2080;
      *(void *)unint64_t v117 = __str;
      _os_log_error_impl(&dword_1BD672000, v55, OS_LOG_TYPE_ERROR, "%s:%d: open rdwr error tyring readonly %s", buf, 0x1Cu);
    }
    *__error() = v54;
    uint64_t v53 = fd_create_protected(a2, __str, 0, 0);
    int v19 = 0;
    a5 = 1;
  }
  if (!v53)
  {
LABEL_88:
    int v35 = *__error();
    unint64_t v42 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      int v64 = *__error();
      *(_DWORD *)iovec buf = 136315906;
      uint64_t v113 = "bt_openTrie";
      __int16 v114 = 1024;
      int v115 = 645;
      __int16 v116 = 2080;
      *(void *)unint64_t v117 = __str;
      *(_WORD *)&v117[8] = 1024;
      *(_DWORD *)&v117[10] = v64;
      xpc_object_t v39 = "%s:%d: open %s err: %d";
      goto LABEL_90;
    }
    goto LABEL_92;
  }
  unint64_t v56 = "indexArrays";
  if (v18) {
    unint64_t v56 = "shadowIndexArrays";
  }
  snprintf(__str, 0x400uLL, "%s%s", a3, v56);
  uint64_t v57 = (atomic_uint *)fd_create_protected(a2, __str, v19, 0);
  if (!v57)
  {
    int v35 = *__error();
    uint64_t v67 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      int v89 = *__error();
      *(_DWORD *)iovec buf = 136315906;
      uint64_t v113 = "bt_openTrie";
      __int16 v114 = 1024;
      int v115 = 655;
      __int16 v116 = 2080;
      *(void *)unint64_t v117 = __str;
      *(_WORD *)&v117[8] = 1024;
      *(_DWORD *)&v117[10] = v89;
      _os_log_error_impl(&dword_1BD672000, v67, OS_LOG_TYPE_ERROR, "%s:%d: open %s err: %d", buf, 0x22u);
    }
    unint64_t v58 = 0;
    goto LABEL_93;
  }
  unint64_t v58 = v57;
  if (v110)
  {
    while (1)
    {
      int v59 = fstatat(*((_DWORD *)v53 + 11), (const char *)v53[9], &v111, 2048);
      uint64_t v60 = g_prot_error_callback;
      if (v59 != -1 || g_prot_error_callback == 0) {
        break;
      }
      uint64_t v62 = *((unsigned int *)v53 + 10);
      uint64_t v63 = __error();
      if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v60 + 16))(v60, v62, *v63, 8) & 1) == 0) {
        goto LABEL_116;
      }
    }
    if (v59 == -1)
    {
LABEL_116:
      int v35 = *__error();
      uint64_t v77 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
        goto LABEL_93;
      }
      int v78 = *__error();
      uint64_t v79 = "indexCompactDirectory";
      if (v18) {
        uint64_t v79 = "shadowIndexCompactDirectory";
      }
      *(_DWORD *)iovec buf = 136316162;
      uint64_t v113 = "bt_openTrie";
      __int16 v114 = 1024;
      int v115 = 665;
      __int16 v116 = 1024;
      *(_DWORD *)unint64_t v117 = v78;
      *(_WORD *)&v117[4] = 2080;
      *(void *)&v117[6] = a3;
      *(_WORD *)&v117[14] = 2080;
      *(void *)&v117[16] = v79;
      xpc_object_t v74 = "%s:%d: fstat err:%d %s%s";
    }
    else
    {
      if (v111.st_size > *(void *)(a1 + 40)
        || (off_t v70 = *(void *)(a1 + 32), v111.st_size < v70) && (unint64_t)v70 >= 9)
      {
        int v35 = *__error();
        uint64_t v71 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
          goto LABEL_93;
        }
        uint64_t v72 = *(void *)(a1 + 32);
        uint64_t v73 = *(void *)(a1 + 40);
        *(_DWORD *)iovec buf = 136316674;
        uint64_t v113 = "bt_openTrie";
        __int16 v114 = 1024;
        int v115 = 669;
        __int16 v116 = 1024;
        *(_DWORD *)unint64_t v117 = v111.st_size;
        *(_WORD *)&v117[4] = 1024;
        *(_DWORD *)&v117[6] = v72;
        *(_WORD *)&v117[10] = 1024;
        *(_DWORD *)&v117[12] = v73;
        *(_WORD *)&v117[16] = 2080;
        *(void *)&v117[18] = a3;
        *(_WORD *)&v117[26] = 2080;
        *(void *)long long v118 = "indexCompactDirectory";
        xpc_object_t v74 = "%s:%d: COMP: bad file size:%d (expected %d - %d) %s%s";
        uint64_t v75 = v71;
        uint32_t v76 = 56;
        goto LABEL_121;
      }
      if (fd_stat((uint64_t)v58, &v111) != -1)
      {
        off_t v86 = *(void *)(a1 + 384);
        if (v111.st_size > v86 && !((unint64_t)(v111.st_size - v86) >> 17))
        {
          int v87 = *__error();
          unint64_t v88 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
          {
            uint64_t v103 = *(void *)(a1 + 384);
            uint64_t v102 = *(void *)(a1 + 392);
            xpc_object_t v104 = "indexArrays";
            if (v18) {
              xpc_object_t v104 = "shadowIndexArrays";
            }
            *(_DWORD *)iovec buf = 136316674;
            uint64_t v113 = "bt_openTrie";
            __int16 v114 = 1024;
            int v115 = 680;
            __int16 v116 = 2048;
            *(void *)unint64_t v117 = v111.st_size;
            *(_WORD *)&v117[8] = 2048;
            *(void *)&v117[10] = v102;
            *(_WORD *)&v117[18] = 2048;
            *(void *)&v117[20] = v103;
            *(_WORD *)long long v118 = 2080;
            *(void *)&v118[2] = a3;
            __int16 v119 = 2080;
            uint64_t v120 = v104;
            _os_log_error_impl(&dword_1BD672000, v88, OS_LOG_TYPE_ERROR, "%s:%d: FLAT: file size:%lld (expected %lld - %lld) %s%s", buf, 0x44u);
          }
          *__error() = v87;
          goto LABEL_138;
        }
        if (v111.st_size <= v86)
        {
          off_t v92 = *(void *)(a1 + 392);
          if (v111.st_size >= v92 || v92 < 65)
          {
LABEL_138:
            if (a5) {
              int v68 = 2;
            }
            else {
              int v68 = 0;
            }
            *(void *)(a1 + 112) = v53;
            goto LABEL_104;
          }
        }
        int v35 = *__error();
        uint64_t v93 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v93, OS_LOG_TYPE_ERROR)) {
          goto LABEL_93;
        }
        uint64_t v95 = *(void *)(a1 + 384);
        uint64_t v94 = *(void *)(a1 + 392);
        uint64_t v96 = "indexArrays";
        if (v18) {
          uint64_t v96 = "shadowIndexArrays";
        }
        *(_DWORD *)iovec buf = 136316674;
        uint64_t v113 = "bt_openTrie";
        __int16 v114 = 1024;
        int v115 = 682;
        __int16 v116 = 2048;
        *(void *)unint64_t v117 = v111.st_size;
        *(_WORD *)&v117[8] = 2048;
        *(void *)&v117[10] = v94;
        *(_WORD *)&v117[18] = 2048;
        *(void *)&v117[20] = v95;
        *(_WORD *)long long v118 = 2080;
        *(void *)&v118[2] = a3;
        __int16 v119 = 2080;
        uint64_t v120 = v96;
        xpc_object_t v74 = "%s:%d: FLAT: bad file size:%lld (expected %lld - %lld) %s%s";
        uint64_t v75 = v93;
        uint32_t v76 = 68;
LABEL_121:
        _os_log_error_impl(&dword_1BD672000, v75, OS_LOG_TYPE_ERROR, v74, buf, v76);
        goto LABEL_93;
      }
      int v35 = *__error();
      uint64_t v77 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
        goto LABEL_93;
      }
      int v90 = *__error();
      uint64_t v91 = "indexArrays";
      if (v18) {
        uint64_t v91 = "shadowIndexArrays";
      }
      *(_DWORD *)iovec buf = 136316162;
      uint64_t v113 = "bt_openTrie";
      __int16 v114 = 1024;
      int v115 = 674;
      __int16 v116 = 1024;
      *(_DWORD *)unint64_t v117 = v90;
      *(_WORD *)&v117[4] = 2080;
      *(void *)&v117[6] = a3;
      *(_WORD *)&v117[14] = 2080;
      *(void *)&v117[16] = v91;
      xpc_object_t v74 = "%s:%d: fstat err:%d %s%s";
    }
    uint64_t v75 = v77;
    uint32_t v76 = 44;
    goto LABEL_121;
  }
  *((unsigned char *)v109 + 52) = 1;
  if (a5) {
    int v68 = 2;
  }
  else {
    int v68 = 0;
  }
  *(void *)(a1 + 112) = v53;
  *(_DWORD *)(a1 + 24) = 38;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 32) = xmmword_1BDA82370;
  *(_OWORD *)(a1 + 48) = 0u;
LABEL_104:
  *(_DWORD *)(a1 + 120) = v68;
  *(unsigned char *)(a1 + 124) = 0;
  if ((unint64_t)(*(void *)(a1 + 16) + 1) <= 1)
  {
    uint64_t v69 = (void *)fd_mmap((uint64_t)v53);
    *(void *)(a1 + 16) = v69;
    madvise(v69, *(void *)(a1 + 40), *(_DWORD *)(a1 + 120));
  }
  if ((a5 & 1) == 0 && fd_truncate(*(void *)(a1 + 112), *(void *)(a1 + 40)) == -1)
  {
    int v82 = *__error();
    xpc_object_t v83 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
    {
      int v97 = *__error();
      *(_DWORD *)iovec buf = 136315650;
      uint64_t v113 = "initMF";
      __int16 v114 = 1024;
      int v115 = 151;
      __int16 v116 = 1024;
      *(_DWORD *)unint64_t v117 = v97;
      _os_log_error_impl(&dword_1BD672000, v83, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate err: %d", buf, 0x18u);
    }
    uint64_t v53 = 0;
    *__error() = v82;
  }
  else
  {
    if (storageInit(a1 + 160, 0x10000, 0x40uLL, (uint64_t)v58, v110 == 0, 2, a5, a7, a8)) {
      return 1;
    }
    unint64_t v58 = 0;
    uint64_t v53 = 0;
  }
LABEL_94:
  fd_release((atomic_uint *)v53);
  fd_release(v58);
  uint64_t v65 = *(void **)(a1 + 8);
  if ((unint64_t)v65 + 1 >= 2) {
    munmap(v65, 1028 * *(unsigned int *)(a1 + 148));
  }
  uint64_t result = 0;
  *(void *)(a1 + 8) = 0;
  return result;
}

char *__si_assert_copy_extra_1921(_DWORD *a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  bzero(v12, 0x400uLL);
  if (!a1
    || (int v11 = 0, v2 = _fd_acquire_fd((uint64_t)a1, &v11), v2 == -1)
    || (int v3 = v2,
        unsigned int v4 = v12,
        int v5 = fcntl(v2, 50, v12),
        int v6 = v12[0],
        _fd_release_fd(a1, v3, 0, (uint64_t)v11),
        v5 < 0)
    || !v6)
  {
    int v7 = getcwd(v12, 0x400uLL);
    if (v7) {
      unsigned int v4 = v7;
    }
    else {
      unsigned int v4 = "";
    }
  }
  int v11 = 0;
  int v8 = (const char *)pthread_getspecific(__THREAD_STR_DATA_KEY);
  if (v8) {
    BOOL v9 = v8;
  }
  else {
    BOOL v9 = "";
  }
  asprintf(&v11, "%s %s", v4, v9);
  return v11;
}

uint64_t bt_recoverTrie(uint64_t a1, const char *a2, _DWORD *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  bzero(v10, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexDirectory");
  snprintf(v10, 0x400uLL, "%s%s", a2, "shadowIndexDirectory");
  memset(&v12, 0, sizeof(v12));
  if ((fstatat(a1, __str, &v12, 0) || v12.st_mode != 256) && (copyFileFallback(a1, v10, a1, __str, a3, 1, 1) & 1) == 0)
  {
    if (!*a3)
    {
      int v7 = *__error();
      int v8 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v12.st_dev = 136315650;
        *(void *)&v12.st_mode = "bt_recoverTrie";
        WORD2(v12.st_ino) = 1024;
        *(_DWORD *)((char *)&v12.st_ino + 6) = 721;
        HIWORD(v12.st_uid) = 2080;
        *(void *)&v12.st_gid = __str;
        goto LABEL_23;
      }
LABEL_20:
      uint64_t v6 = 0;
      *__error() = v7;
      return v6;
    }
    return 0;
  }
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexCompactDirectory");
  snprintf(v10, 0x400uLL, "%s%s", a2, "shadowIndexCompactDirectory");
  memset(&v12, 0, sizeof(v12));
  if ((fstatat(a1, __str, &v12, 0) || v12.st_mode != 256) && (copyFileFallback(a1, v10, a1, __str, a3, 1, 1) & 1) == 0)
  {
    if (!*a3)
    {
      int v7 = *__error();
      int v8 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v12.st_dev = 136315650;
        *(void *)&v12.st_mode = "bt_recoverTrie";
        WORD2(v12.st_ino) = 1024;
        *(_DWORD *)((char *)&v12.st_ino + 6) = 727;
        HIWORD(v12.st_uid) = 2080;
        *(void *)&v12.st_gid = __str;
        goto LABEL_23;
      }
      goto LABEL_20;
    }
    return 0;
  }
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexArrays");
  snprintf(v10, 0x400uLL, "%s%s", a2, "shadowIndexArrays");
  memset(&v12, 0, sizeof(v12));
  if (fstatat(a1, __str, &v12, 0) || v12.st_mode != 256)
  {
    uint64_t v6 = 1;
    if (copyFileFallback(a1, v10, a1, __str, a3, 1, 1)) {
      return v6;
    }
    if (!*a3)
    {
      int v7 = *__error();
      int v8 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v12.st_dev = 136315650;
        *(void *)&v12.st_mode = "bt_recoverTrie";
        WORD2(v12.st_ino) = 1024;
        *(_DWORD *)((char *)&v12.st_ino + 6) = 733;
        HIWORD(v12.st_uid) = 2080;
        *(void *)&v12.st_gid = __str;
LABEL_23:
        _os_log_error_impl(&dword_1BD672000, v8, OS_LOG_TYPE_ERROR, "%s:%d: Could not recover %s", (uint8_t *)&v12, 0x1Cu);
        goto LABEL_20;
      }
      goto LABEL_20;
    }
    return 0;
  }
  return 1;
}

uint64_t bt_syncTrie(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  double Current = CFAbsoluteTimeGetCurrent();
  if (*(void *)(a1 + 4576))
  {
    int v3 = *(void **)(a1 + 8);
    size_t v4 = 1028 * (*(_DWORD *)(a1 + 144) + 1);
    if (_gSystemStatusBool)
    {
      pthread_mutex_lock(&_gSystemStatusLock);
      while (_gSystemStatusBool)
        pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
      pthread_mutex_unlock(&_gSystemStatusLock);
    }
    msync(v3, v4, 16);
    int v5 = *(_DWORD **)(a1 + 4576);
    if (_gSystemStatusBool)
    {
      pthread_mutex_lock(&_gSystemStatusLock);
      while (_gSystemStatusBool)
        pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
      pthread_mutex_unlock(&_gSystemStatusLock);
    }
    *(void *)int v22 = 0;
    uint64_t v6 = _fd_acquire_fd((uint64_t)v5, v22);
    if (v6 != -1)
    {
      int v7 = v6;
      prot_fsync(v6, 0);
      _fd_release_fd(v5, v7, 0, *(uint64_t *)v22);
    }
  }
  int v8 = *(void **)(a1 + 16);
  size_t v9 = *(void *)(a1 + 40);
  if (_gSystemStatusBool)
  {
    pthread_mutex_lock(&_gSystemStatusLock);
    while (_gSystemStatusBool)
      pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
    pthread_mutex_unlock(&_gSystemStatusLock);
  }
  msync(v8, v9, 16);
  int v10 = *(_DWORD **)(a1 + 112);
  if (_gSystemStatusBool)
  {
    pthread_mutex_lock(&_gSystemStatusLock);
    while (_gSystemStatusBool)
      pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
    pthread_mutex_unlock(&_gSystemStatusLock);
  }
  *(void *)int v22 = 0;
  uint64_t v11 = _fd_acquire_fd((uint64_t)v10, v22);
  if (v11 != -1)
  {
    int v12 = v11;
    prot_fsync(v11, 0);
    _fd_release_fd(v10, v12, 0, *(uint64_t *)v22);
  }
  uint64_t v13 = storageSyncPages(a1 + 160, a1 + 4536, 0x20000uLL);
  if (!v13)
  {
    uint64_t v14 = *(_DWORD **)(a1 + 376);
    if (v14)
    {
      if (_gSystemStatusBool)
      {
        pthread_mutex_lock(&_gSystemStatusLock);
        while (_gSystemStatusBool)
          pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
        pthread_mutex_unlock(&_gSystemStatusLock);
      }
      *(void *)int v22 = 0;
      uint64_t v15 = _fd_acquire_fd((uint64_t)v14, v22);
      if (v15 != -1)
      {
        int v16 = v15;
        prot_fsync(v15, 0);
        _fd_release_fd(v14, v16, 0, *(uint64_t *)v22);
      }
    }
    int v17 = *__error();
    BOOL v18 = _SILogForLogForCategory(10);
    os_log_type_t v19 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v18, v19))
    {
      float v20 = CFAbsoluteTimeGetCurrent() - Current;
      *(_DWORD *)int v22 = 134217984;
      *(double *)&v22[4] = v20;
      _os_log_impl(&dword_1BD672000, v18, v19, "syncTrie took %f seconds", v22, 0xCu);
    }
    *__error() = v17;
  }
  return v13;
}

uint64_t bt_freeTrie(uint64_t a1)
{
  fd_release(*(atomic_uint **)(a1 + 4576));
  *(void *)(a1 + 4576) = 0;
  int v2 = *(void **)(a1 + 8);
  if ((unint64_t)v2 + 1 >= 2)
  {
    munmap(v2, 1028 * *(unsigned int *)(a1 + 148));
    *(void *)(a1 + 8) = 0;
  }
  closeMF(a1 + 16);
  storageClose(a1 + 160);
  int v3 = *(const void **)(a1 + 4552);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 4552) = 0;
  }
  *(_OWORD *)(a1 + 4536) = 0u;
  return db_rwlock_destroy((pthread_mutex_t *)(a1 + 4600));
}

uint64_t insertFromBurst(void *a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7)
{
  uint64_t v170 = *MEMORY[0x1E4F143B8];
  uint64_t v155 = a7;
  if (!a3) {
    return a7;
  }
  if (*(_DWORD *)(a2 + 4)) {
    return 0;
  }
  if (!HIDWORD(a7))
  {
    if ((unint64_t)a7 << 6 >= a1[49])
    {
      unint64_t v130 = __si_assert_copy_extra_1921(0);
      long long v131 = v130;
      long long v132 = "";
      if (v130) {
        long long v132 = v130;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1117, "flatStoreGetOffset(ptr) < storageGetCount(&t->flatStore)", v132);
LABEL_177:
      free(v131);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    if (appendStringFlat((uint64_t)a1, a2, a7, a4, a3, a5, a6, (unint64_t *)&v155))
    {
      if (!*(_DWORD *)(a2 + 4))
      {
        uint64_t v155 = burst2(a1, a2, v155);
        if (!*(_DWORD *)(a2 + 4))
        {
          int v36 = *__error();
          int v37 = _SILogForLogForCategory(10);
          os_log_type_t v38 = 2 * (dword_1E9FC90CC < 4);
          if (os_log_type_enabled(v37, v38))
          {
            *(_WORD *)iovec buf = 0;
            _os_log_impl(&dword_1BD672000, v37, v38, "Re-burst!", buf, 2u);
          }
          *__error() = v36;
          return insertFromBurst(a1, a2, a3, a4, a5, a6, v155);
        }
      }
    }
    return v155;
  }
  if (HIDWORD(a7) != 1)
  {
    if (HIDWORD(a7) != 3)
    {
      uint64_t v143 = __si_assert_copy_extra_1921(0);
      uint64_t v144 = v143;
      if (v143) {
        xpc_object_t v145 = v143;
      }
      else {
        xpc_object_t v145 = "";
      }
      __message_assert("%s:%u: Unexpected code path %s ", "BurstTrie.c", 1129, v145);
      free(v144);
      goto LABEL_190;
    }
    if (a4)
    {
      uint64_t v156 = 0;
      unsigned int v14 = a7;
      unsigned int v15 = *(_DWORD *)(a1[1] + 1028 * a7 + 4 * *a3 + 4);
      LODWORD(v16) = v15 >> 1;
      unsigned int v17 = v15 >> 3;
      unint64_t v18 = (unint64_t)(v15 & 7) << 32;
      if ((v15 & 3) == 1)
      {
        unint64_t v18 = 0x100000000;
        unsigned int v17 = v15 >> 2;
      }
      BOOL v19 = (v15 & 1) == 0;
      if (v15) {
        unint64_t v20 = v18;
      }
      else {
        unint64_t v20 = 0;
      }
      if (v19) {
        uint64_t v16 = v16;
      }
      else {
        uint64_t v16 = v17;
      }
      uint64_t v156 = v20 | v16;
      if (v16)
      {
        uint64_t v21 = insertFromBurst(a1, a2, a3 + 1, (a4 - 1), a5, a6, v20 | v16);
        uint64_t v156 = v21;
        uint64_t v22 = a1[1] + 1028 * v14 + 4 * *a3;
        unsigned int v25 = *(_DWORD *)(v22 + 4);
        uint64_t v23 = (unsigned int *)(v22 + 4);
        char v24 = v25;
        unsigned int v26 = v25 >> 1;
        unsigned int v27 = v25 >> 3;
        int v28 = v25 & 7;
        unsigned int v29 = v25 >> 2;
        if ((v25 & 3) == 1)
        {
          int v28 = 1;
          unsigned int v27 = v29;
        }
        BOOL v30 = (v24 & 1) == 0;
        if (v24) {
          int v31 = v28;
        }
        else {
          int v31 = 0;
        }
        if (!v30) {
          unsigned int v26 = v27;
        }
        if (v26 == v21 && v31 == HIDWORD(v21)) {
          return v155;
        }
        unsigned int v33 = HIDWORD(v21) | (8 * v21);
        if (!HIDWORD(v21)) {
          unsigned int v33 = 2 * v21;
        }
        if (HIDWORD(v21) == 1) {
          unsigned int v34 = (4 * v21) | 1;
        }
        else {
          unsigned int v34 = v33;
        }
        if ((v34 & 3) == 1) {
          char v35 = 2;
        }
        else {
          char v35 = 3;
        }
        if ((v34 & 1) == 0) {
          char v35 = 1;
        }
        if (v34 >> v35 != v21) {
          goto LABEL_174;
        }
        goto LABEL_85;
      }
      if (*(_DWORD *)a2)
      {
        long long v153 = (unint64_t *)(a2 + 2148);
        unint64_t v85 = *(void *)(a2 + 2148);
        long long v168 = 0u;
        long long v169 = 0u;
        long long v166 = 0u;
        long long v167 = 0u;
        long long v165 = 0u;
        long long v163 = 0u;
        long long v164 = 0u;
        long long v161 = 0u;
        long long v162 = 0u;
        long long v159 = 0u;
        long long v160 = 0u;
        *(_OWORD *)iovec buf = 0u;
        int v157 = 0;
        unint64_t v86 = flatStoreNewBlockForCompact((uint64_t)(a1 + 20), v85, (uint64_t)buf, &v157);
        if (v157) {
          dirtyStorageOffsets((uint64_t)(a1 + 20), (unint64_t *)buf, v157);
        }
        uint64_t v156 = v86;
        *long long v153 = v86;
        if (v86)
        {
LABEL_104:
          appendStringFlat((uint64_t)a1, a2, v86, a4 - 1, a3 + 1, a5, a6, (unint64_t *)&v156);
          if (!*(_DWORD *)(a2 + 4)) {
            goto LABEL_120;
          }
          goto LABEL_155;
        }
      }
      else
      {
        unint64_t v86 = trieNewFlatStoreBlock((uint64_t)a1, (int)a4 - 1);
        uint64_t v156 = v86;
        if (v86) {
          goto LABEL_104;
        }
      }
      uint64_t v94 = __error();
      int v95 = *v94;
      *(_DWORD *)(a2 + 4) = *v94;
      if (!v95)
      {
LABEL_120:
        uint64_t v96 = a1[1] + 1028 * v14 + 4 * *a3;
        *(_DWORD *)(v96 + 4) = ptrD(v156);
        return v155;
      }
LABEL_155:
      LODWORD(v156) = 0;
      return v156;
    }
    uint64_t v71 = (_DWORD *)(a1[1] + 1028 * a7);
    if (!*v71)
    {
      if (*(_DWORD *)a2 != 1)
      {
        *uint64_t v71 = a5;
        return a7;
      }
      unsigned int v148 = a7;
      unint64_t v72 = *(void *)(a2 + 2148);
      long long v168 = 0u;
      long long v169 = 0u;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v165 = 0u;
      long long v163 = 0u;
      long long v164 = 0u;
      long long v161 = 0u;
      long long v162 = 0u;
      long long v159 = 0u;
      long long v160 = 0u;
      *(_OWORD *)iovec buf = 0u;
      int v157 = 0;
      uint64_t v147 = (uint64_t)(a1 + 20);
      unint64_t v73 = flatStoreNewBlockForCompact((uint64_t)(a1 + 20), v72, (uint64_t)buf, &v157);
      uint64_t v74 = v157;
      if (v157 >= 1)
      {
        uint64_t v75 = buf;
        do
        {
          unint64_t v77 = *(void *)v75;
          v75 += 8;
          unint64_t v76 = v77;
          bit_vector_set_3386(a1 + 567, (v77 >> 17));
          if ((v77 >> 17) != (v77 + 8) >> 17) {
            bit_vector_set_3386(a1 + 567, (v76 >> 17) + 1);
          }
          --v74;
        }
        while (v74);
      }
      *(_DWORD *)(a2 + 2148) = v73;
      *(_DWORD *)(a2 + 2152) = 0;
      if (v73)
      {
        *(_OWORD *)iovec buf = 0u;
        *(void *)&long long v159 = a5;
        *((void *)&v159 + 1) = a6;
        uint64_t v90 = storageResolvePtr(v147, v73 << 6, 8, 1);
        uint64_t v91 = (_WORD *)storageResolvePtr(v147, v73 << 6, 64 << *(unsigned char *)(v90 + 2), 1);
        *(_OWORD *)(a2 + 1084) = 0u;
        *uint64_t v91 = FlatStorePageEntryWrite2((uint64_t)v91, (unsigned int *)buf, (uint64_t *)(a2 + 1084));
        *(_DWORD *)(a1[1] + 1028 * v148) = 0;
        if ((v73 & 0x80000000) == 0)
        {
          *(_DWORD *)(a1[1] + 1028 * v148) = 2 * v73;
LABEL_116:
          *(_DWORD *)(a2 + 36) = 0;
          *(_DWORD *)(a2 + 24) = 0;
          return a7;
        }
        goto LABEL_174;
      }
      goto LABEL_117;
    }
    long long v135 = __si_assert_copy_extra_1921(0);
    uint64_t v136 = v135;
    unint64_t v137 = "";
    if (v135) {
      unint64_t v137 = v135;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 903, "getNum(t->baseFat[s].termInfo.termId.ptr)==0", v137);
LABEL_189:
    free(v136);
    if (!__valid_fs(-1))
    {
      uint64_t v142 = 3072;
LABEL_192:
      *(_DWORD *)uint64_t v142 = -559038737;
      abort();
    }
LABEL_190:
    uint64_t v142 = 2989;
    goto LABEL_192;
  }
  unint64_t v39 = a7;
  uint64_t v40 = mgetBase((uint64_t)a1, a7);
  uint32_t v41 = (_DWORD *)v40;
  if (!a4)
  {
    if (!*(_DWORD *)v40)
    {
      if (*(_DWORD *)a2 != 1)
      {
        *(_DWORD *)uint64_t v40 = a5;
        return a7;
      }
      unint64_t v78 = *(void *)(a2 + 2148);
      long long v168 = 0u;
      long long v169 = 0u;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v165 = 0u;
      long long v163 = 0u;
      long long v164 = 0u;
      long long v161 = 0u;
      long long v162 = 0u;
      long long v159 = 0u;
      long long v160 = 0u;
      *(_OWORD *)iovec buf = 0u;
      int v157 = 0;
      uint64_t v149 = (uint64_t)(a1 + 20);
      uint64_t v152 = a6;
      unint64_t v79 = flatStoreNewBlockForCompact((uint64_t)(a1 + 20), v78, (uint64_t)buf, &v157);
      uint64_t v80 = v157;
      if (v157 >= 1)
      {
        int v81 = a1 + 567;
        int v82 = buf;
        do
        {
          unint64_t v84 = *(void *)v82;
          v82 += 8;
          unint64_t v83 = v84;
          bit_vector_set_3386(v81, (v84 >> 17));
          if ((v84 >> 17) != (v84 + 8) >> 17) {
            bit_vector_set_3386(v81, (v83 >> 17) + 1);
          }
          --v80;
        }
        while (v80);
      }
      *(_DWORD *)(a2 + 2148) = v79;
      *(_DWORD *)(a2 + 2152) = 0;
      if (v79)
      {
        *(_OWORD *)iovec buf = 0u;
        *(void *)&long long v159 = a5;
        *((void *)&v159 + 1) = v152;
        uint64_t v92 = storageResolvePtr(v149, v79 << 6, 8, 1);
        uint64_t v93 = (_WORD *)storageResolvePtr(v149, v79 << 6, 64 << *(unsigned char *)(v92 + 2), 1);
        *(_OWORD *)(a2 + 1084) = 0u;
        *uint64_t v93 = FlatStorePageEntryWrite2((uint64_t)v93, (unsigned int *)buf, (uint64_t *)(a2 + 1084));
        *uint32_t v41 = 0;
        if ((v79 & 0x80000000) == 0)
        {
          *uint32_t v41 = 2 * v79;
          goto LABEL_116;
        }
LABEL_174:
        uint64_t v133 = __si_assert_copy_extra_1921(0);
        long long v131 = v133;
        long long v134 = "";
        if (v133) {
          long long v134 = v133;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.h", 81, "ptrM(newptr).next == ptr.next", v134);
        goto LABEL_177;
      }
LABEL_117:
      *(_DWORD *)(a2 + 4) = *__error();
      return 0;
    }
    unint64_t v138 = __si_assert_copy_extra_1921(0);
    uint64_t v136 = v138;
    uint64_t v139 = "";
    if (v138) {
      uint64_t v139 = v138;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 963, "getNum(b->termInfo.termId.ptr)==0", v139);
    goto LABEL_189;
  }
  unint64_t v42 = *a3;
  if ((*(_DWORD *)(v40 + ((v42 >> 3) & 0x1C) + 4) >> v42))
  {
    uint64_t v43 = 0;
    unint64_t v44 = v40 + 4;
    unint64_t v45 = v42 >> 6;
    if ((v42 >> 6) != 1)
    {
      if (v45 != 2)
      {
        if (v45 != 3)
        {
LABEL_55:
          uint8x8_t v49 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)(v44 + 8 * v45) & ~(-1 << v42)));
          v49.i16[0] = vaddlv_u8(v49);
          uint64_t v50 = v49.u32[0] + v43;
          unsigned int v51 = *(_DWORD *)(v40 + 4 * v50 + 38);
          LODWORD(v44) = v51 >> 1;
          unsigned int v52 = v51 >> 3;
          unint64_t v53 = (unint64_t)(v51 & 7) << 32;
          if ((v51 & 3) == 1)
          {
            unint64_t v53 = 0x100000000;
            unsigned int v52 = v51 >> 2;
          }
          BOOL v54 = (v51 & 1) == 0;
          if (v51) {
            unint64_t v55 = v53;
          }
          else {
            unint64_t v55 = 0;
          }
          if (v54) {
            unint64_t v44 = v44;
          }
          else {
            unint64_t v44 = v52;
          }
          unint64_t v56 = insertFromBurst(a1, a2, a3 + 1, (a4 - 1), a5, a6, v55 | v44);
          int v57 = v56;
          if (!v56) {
            return v155;
          }
          unint64_t v58 = HIDWORD(v56);
          uint64_t v59 = mgetBase((uint64_t)a1, v39) + 4 * v50;
          unsigned int v61 = *(_DWORD *)(v59 + 38);
          uint64_t v23 = (unsigned int *)(v59 + 38);
          char v60 = v61;
          unsigned int v62 = v61 >> 1;
          unsigned int v63 = v61 >> 3;
          int v64 = v61 & 7;
          unsigned int v65 = v61 >> 2;
          if ((v61 & 3) == 1)
          {
            int v64 = 1;
            unsigned int v63 = v65;
          }
          BOOL v66 = (v60 & 1) == 0;
          if (v60) {
            int v67 = v64;
          }
          else {
            int v67 = 0;
          }
          if (!v66) {
            unsigned int v62 = v63;
          }
          if (v67 == v58 && v62 == v57) {
            return v155;
          }
          unsigned int v34 = (4 * v57) | 1;
          int v69 = v58 | (8 * v57);
          if (!v58) {
            int v69 = 2 * v57;
          }
          if (v58 != 1) {
            unsigned int v34 = v69;
          }
          if ((v34 & 3) == 1) {
            char v70 = 2;
          }
          else {
            char v70 = 3;
          }
          if ((v34 & 1) == 0) {
            char v70 = 1;
          }
          if (v34 >> v70 == v57)
          {
LABEL_85:
            *uint64_t v23 = v34;
            return v155;
          }
          long long v140 = __si_assert_copy_extra_1921(0);
          uint64_t v136 = v140;
          unint64_t v141 = "";
          if (v140) {
            unint64_t v141 = v140;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.h", 81, "ptrM(newptr).next == ptr.next", v141);
          goto LABEL_189;
        }
        uint8x8_t v46 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v40 + 20));
        v46.i16[0] = vaddlv_u8(v46);
        uint64_t v43 = v46.u32[0];
      }
      uint8x8_t v47 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v40 + 12));
      v47.i16[0] = vaddlv_u8(v47);
      v43 += v47.u32[0];
    }
    uint8x8_t v48 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v44);
    v48.i16[0] = vaddlv_u8(v48);
    v43 += v48.u32[0];
    goto LABEL_55;
  }
  int v87 = *(unsigned __int8 *)(v40 + 36);
  HIDWORD(v88) = v87;
  LODWORD(v88) = v87 - 4;
  __int16 v89 = 16;
  switch((v88 >> 2))
  {
    case 0u:
      __int16 v89 = 8;
      goto LABEL_122;
    case 1u:
      goto LABEL_122;
    case 3u:
      __int16 v89 = 32;
LABEL_122:
      uint64_t v150 = *(unsigned __int8 *)(v40 + 36);
      char v154 = v89;
      uint64_t v97 = (4 * v89 + 41) & 0x1E8;
      unint64_t v98 = mmalloc(v97, (uint64_t)(a1 + 2), *(uint64_t (**)(uint64_t))(a2 + 2160), *(void *)(a2 + 2168));
      if (v98)
      {
        unint64_t v146 = v98;
        unint64_t v99 = v98 >> 2;
        uint64_t v100 = mgetBase((uint64_t)a1, v98 >> 2);
        if (v97 >= 0x20)
        {
          uint64_t v101 = v97 - 8;
          *(_OWORD *)uint64_t v100 = 0u;
          *(_OWORD *)(v100 + 16) = 0u;
          char v102 = v154;
          if (v97 != 40)
          {
            *(_OWORD *)(v100 + 32) = 0uLL;
            *(_OWORD *)(v100 + 48) = 0uLL;
            if (v97 != 72)
            {
              *(_OWORD *)(v100 + 64) = 0uLL;
              *(_OWORD *)(v100 + 80) = 0uLL;
              if (v97 != 104)
              {
                *(_OWORD *)(v100 + 96) = 0uLL;
                *(_OWORD *)(v100 + 112) = 0uLL;
                if (v97 != 136)
                {
                  *(_OWORD *)(v100 + 128) = 0uLL;
                  *(_OWORD *)(v100 + 144) = 0uLL;
                }
              }
            }
          }
        }
        else
        {
          uint64_t v101 = 0;
          char v102 = v154;
        }
        uint64_t v116 = v101 - v97;
        unint64_t v117 = (void *)(v100 + v101);
        do
        {
          *v117++ = 0;
          v116 += 8;
        }
        while (v116);
        *(unsigned char *)(v100 + 37) = v102;
        LODWORD(v155) = v99;
        if (v99)
        {
          uint32_t v41 = (_DWORD *)mgetBase((uint64_t)a1, (v146 >> 2));
          long long v118 = (const void *)mgetBase((uint64_t)a1, a7);
          memcpy(v41, v118, 4 * v150 + 38);
          *((unsigned char *)v41 + 37) = v154;
          mfree((4 * a7), (4 * (_WORD)v150 + 41) & 0x7FC, a1 + 2);
          LODWORD(v42) = *a3;
LABEL_147:
          int v119 = set_follows((uint64_t)v41, v42);
          if (*(_DWORD *)a2)
          {
            unint64_t v120 = trieNewFlatStoreBlockForCompact((uint64_t)a1, *(void *)(a2 + 2148));
            *(void *)(a2 + 2148) = v120;
          }
          else
          {
            unint64_t v120 = trieNewFlatStoreBlock((uint64_t)a1, (int)a4 - 1);
          }
          uint64_t v156 = v120;
          if (v120)
          {
            appendStringFlat((uint64_t)a1, a2, v120, a4 - 1, a3 + 1, a5, a6, (unint64_t *)&v156);
            int v121 = *(_DWORD *)(a2 + 4);
          }
          else
          {
            uint64_t v122 = __error();
            int v121 = *v122;
            *(_DWORD *)(a2 + 4) = *v122;
          }
          if (!v121)
          {
            *(_DWORD *)((char *)&v41[v119 + 9] + 2) = ptrD(v156);
            return v155;
          }
          goto LABEL_155;
        }
      }
      else
      {
        LODWORD(v155) = 0;
      }
LABEL_149:
      *(_DWORD *)(a2 + 4) = *__error();
      return v155;
    case 7u:
      unsigned int v103 = newbaseFat((uint64_t)a1, *(uint64_t (**)(uint64_t))(a2 + 2160), *(void *)(a2 + 2168));
      uint64_t v155 = v103 | 0x300000000;
      if (!v103) {
        goto LABEL_149;
      }
      uint64_t v104 = 0;
      xpc_object_t v105 = (int8x8_t *)(v41 + 1);
      unsigned int v106 = v103;
      uint64_t v107 = 1028 * v103 + 4;
      break;
    default:
      goto LABEL_147;
  }
  do
  {
    if (((v41[(v104 >> 5) + 1] >> v104) & 1) == 0)
    {
      uint64_t v108 = a1[1];
      *(_DWORD *)(v108 + v107 + 4 * v104) = 0;
      goto LABEL_129;
    }
    uint64_t v109 = 0;
    unsigned int v110 = v104 >> 6;
    if (v104 >> 6 == 1) {
      goto LABEL_136;
    }
    if (v110 == 2) {
      goto LABEL_135;
    }
    if (v110 == 3)
    {
      uint8x8_t v111 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v41 + 5));
      v111.i16[0] = vaddlv_u8(v111);
      uint64_t v109 = v111.u32[0];
LABEL_135:
      uint8x8_t v112 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v41 + 3));
      v112.i16[0] = vaddlv_u8(v112);
      v109 += v112.u32[0];
LABEL_136:
      uint8x8_t v113 = (uint8x8_t)vcnt_s8(*v105);
      v113.i16[0] = vaddlv_u8(v113);
      v109 += v113.u32[0];
    }
    uint8x8_t v114 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v105[v110] & ~(-1 << v104)));
    v114.i16[0] = vaddlv_u8(v114);
    uint64_t v115 = v114.u32[0] + v109;
    uint64_t v108 = a1[1];
    *(_DWORD *)(v108 + v107 + 4 * v104) = *(_DWORD *)((char *)&v41[v115 + 9] + 2);
LABEL_129:
    ++v104;
  }
  while (v104 != 256);
  *(_DWORD *)(v108 + 1028 * v103) = *v41;
  if (*(_DWORD *)a2)
  {
    unint64_t v125 = trieNewFlatStoreBlockForCompact((uint64_t)a1, *(void *)(a2 + 2148));
    *(void *)(a2 + 2148) = v125;
  }
  else
  {
    unint64_t v125 = trieNewFlatStoreBlock((uint64_t)a1, (int)a4 - 1);
  }
  *(void *)iovec buf = v125;
  if (v125)
  {
    appendStringFlat((uint64_t)a1, a2, v125, a4 - 1, a3 + 1, a5, a6, (unint64_t *)buf);
    int v126 = *(_DWORD *)(a2 + 4);
  }
  else
  {
    unint64_t v127 = __error();
    int v126 = *v127;
    *(_DWORD *)(a2 + 4) = *v127;
  }
  if (v126)
  {
    *(_DWORD *)iovec buf = 0;
    uint64_t v128 = buf;
  }
  else
  {
    uint64_t v129 = a1[1] + 1028 * v106 + 4 * *a3;
    *(_DWORD *)(v129 + 4) = ptrD(*(uint64_t *)buf);
    mfree((4 * a7), (4 * (_WORD)v87 + 41) & 0x7FC, a1 + 2);
    uint64_t v128 = (uint8_t *)&v155;
  }
  return *(void *)v128;
}

uint64_t FlatStorePageEntryWrite2(uint64_t a1, unsigned int *a2, uint64_t *a3)
{
  int v5 = (unsigned char *)(a1 + 8);
  unsigned int v6 = *a2;
  if (*a2 > 0x7F)
  {
    if (v6 >> 14)
    {
      if (v6 >> 21)
      {
        if (v6 >> 28)
        {
          *(unsigned char *)(a1 + 8) = -16;
          *(_DWORD *)(a1 + 9) = v6;
          uint64_t v7 = 5;
        }
        else
        {
          *(unsigned char *)(a1 + 8) = HIBYTE(v6) | 0xE0;
          *(unsigned char *)(a1 + 9) = BYTE2(v6);
          *(unsigned char *)(a1 + 10) = BYTE1(v6);
          *(unsigned char *)(a1 + 11) = v6;
          uint64_t v7 = 4;
        }
      }
      else
      {
        *(unsigned char *)(a1 + 8) = BYTE2(v6) | 0xC0;
        *(unsigned char *)(a1 + 9) = BYTE1(v6);
        *(unsigned char *)(a1 + 10) = v6;
        uint64_t v7 = 3;
      }
    }
    else
    {
      *(unsigned char *)(a1 + 8) = BYTE1(v6) | 0x80;
      *(unsigned char *)(a1 + 9) = v6;
      uint64_t v7 = 2;
    }
  }
  else
  {
    *int v5 = v6;
    uint64_t v7 = 1;
  }
  unsigned int v8 = a2[1];
  if (v8 <= 0x7F)
  {
    uint64_t v9 = v7 + 1;
    v5[v7] = v8;
    if (!*a2) {
      goto LABEL_26;
    }
LABEL_23:
    unint64_t v14 = 0;
    do
    {
      *(unsigned char *)(v9 + a1 + 8 + v14) = *(unsigned char *)(*((void *)a2 + 1) + v14);
      ++v14;
    }
    while (v14 < *a2);
    v9 += v14;
    goto LABEL_26;
  }
  if (v8 >> 14)
  {
    if (v8 >> 21)
    {
      if (v8 >> 28)
      {
        uint64_t v13 = &v5[v7];
        *uint64_t v13 = -16;
        *(_DWORD *)(v13 + 1) = v8;
        uint64_t v9 = v7 + 5;
        if (!*a2) {
          goto LABEL_26;
        }
        goto LABEL_23;
      }
      int v12 = &v5[v7];
      unsigned char *v12 = HIBYTE(v8) | 0xE0;
      v12[1] = BYTE2(v8);
      void v12[2] = BYTE1(v8);
      uint64_t v9 = v7 + 4;
      void v12[3] = v8;
      if (*a2) {
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v11 = &v5[v7];
      *uint64_t v11 = BYTE2(v8) | 0xC0;
      v11[1] = BYTE1(v8);
      uint64_t v9 = v7 + 3;
      v11[2] = v8;
      if (*a2) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    int v10 = &v5[v7];
    unsigned char *v10 = BYTE1(v8) | 0x80;
    uint64_t v9 = v7 + 2;
    v10[1] = v8;
    if (*a2) {
      goto LABEL_23;
    }
  }
LABEL_26:
  uint64_t v15 = *((void *)a2 + 2);
  uint64_t v16 = *a3;
  *a3 = v15;
  uint64_t v17 = v2_writeVInt64(a1 + 8, v9, v15 - v16);
  uint64_t v18 = *((void *)a2 + 3);
  if (v18)
  {
    uint64_t v19 = a3[1];
    a3[1] = v18;
    unint64_t v20 = v18 - v19;
  }
  else
  {
    unint64_t v20 = 0;
  }
  return v2_writeVInt64((uint64_t)v5, v17, v20);
}

uint64_t trieNewFlatStoreBlock(uint64_t a1, int a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  unsigned int v16 = 0;
  int v3 = 64;
  do
  {
    unsigned int v4 = v3;
    v3 *= 2;
  }
  while (v4 < a2 + 23);
  memset(v17, 0, sizeof(v17));
  unint64_t v5 = storageAllocOffset(a1 + 160, v4, (uint64_t)v17, (int *)&v16);
  if (v5)
  {
    unint64_t v6 = v5;
    uint64_t v7 = storageResolvePtr(a1 + 160, v5, v4, 1);
    *(_WORD *)uint64_t v7 = 0;
    char v8 = __clz(__rbit32(v4 >> 6));
    if (!v4) {
      char v8 = -1;
    }
    *(unsigned char *)(v7 + 2) = v8;
    uint64_t v9 = (v6 >> 6);
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v10 = v16;
  if ((int)v16 >= 1)
  {
    uint64_t v11 = (void *)(a1 + 4536);
    int v12 = (unint64_t *)v17;
    do
    {
      unint64_t v14 = *v12++;
      unint64_t v13 = v14;
      bit_vector_set_3386(v11, (v14 >> 17));
      if ((v14 >> 17) != (v14 + 8) >> 17) {
        bit_vector_set_3386(v11, (v13 >> 17) + 1);
      }
      --v10;
    }
    while (v10);
  }
  return v9;
}

uint64_t ptrD(uint64_t a1)
{
  int v1 = a1;
  unsigned int v2 = HIDWORD(a1) | (8 * a1);
  if (!HIDWORD(a1)) {
    unsigned int v2 = 2 * a1;
  }
  if (HIDWORD(a1) == 1) {
    uint64_t result = (4 * a1) | 1u;
  }
  else {
    uint64_t result = v2;
  }
  if ((result & 3) == 1) {
    char v4 = 2;
  }
  else {
    char v4 = 3;
  }
  if ((result & 1) == 0) {
    char v4 = 1;
  }
  if (result >> v4 != v1)
  {
    unint64_t v5 = __si_assert_copy_extra_1921(0);
    unint64_t v6 = v5;
    uint64_t v7 = "";
    if (v5) {
      uint64_t v7 = v5;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.h", 81, "ptrM(newptr).next == ptr.next", v7);
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return result;
}

uint64_t newbaseFat(uint64_t a1, uint64_t (*a2)(uint64_t), uint64_t a3)
{
  unint64_t v5 = *(unsigned int *)(a1 + 148);
  uint64_t v6 = (*(_DWORD *)(a1 + 144) + 1);
  if (v6 < v5) {
    goto LABEL_5;
  }
  unint64_t v8 = 0;
  if (!expandUnsafeMapNew((void **)(a1 + 8), *(void *)(a1 + 4576), v5, 0x404uLL, &v8, a2, a3))
  {
    *(_DWORD *)(a1 + 148) = v8;
LABEL_5:
    *(_DWORD *)(a1 + 144) = v6;
    return v6;
  }
  uint64_t v6 = 0;
  *__error() = -1;
  return v6;
}

unint64_t trieNewFlatStoreBlockForCompact(uint64_t a1, unint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  memset(v11, 0, sizeof(v11));
  unsigned int v10 = 0;
  unint64_t v3 = flatStoreNewBlockForCompact(a1 + 160, a2, (uint64_t)v11, (int *)&v10);
  uint64_t v4 = v10;
  if ((int)v10 >= 1)
  {
    unint64_t v5 = (void *)(a1 + 4536);
    uint64_t v6 = (unint64_t *)v11;
    do
    {
      unint64_t v8 = *v6++;
      unint64_t v7 = v8;
      bit_vector_set_3386(v5, (v8 >> 17));
      if ((v8 >> 17) != (v8 + 8) >> 17) {
        bit_vector_set_3386(v5, (v7 >> 17) + 1);
      }
      --v4;
    }
    while (v4);
  }
  return v3;
}

uint64_t set_follows(uint64_t a1, unsigned int a2)
{
  __int32 v3 = 0;
  uint64_t v4 = *(unsigned __int8 *)(a1 + 36);
  unint64_t v5 = (int8x8_t *)(a1 + 4);
  *(_DWORD *)(a1 + 4 + 4 * (a2 >> 5)) |= 1 << a2;
  unsigned int v6 = a2 >> 6;
  if (a2 >> 6 != 1)
  {
    if (v6 != 2)
    {
      if (v6 != 3) {
        goto LABEL_7;
      }
      uint8x8_t v7 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(a1 + 20));
      v7.i16[0] = vaddlv_u8(v7);
      __int32 v3 = v7.i32[0];
    }
    uint8x8_t v8 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(a1 + 12));
    v8.i16[0] = vaddlv_u8(v8);
    v3 += v8.i32[0];
  }
  uint8x8_t v9 = (uint8x8_t)vcnt_s8(*v5);
  v9.i16[0] = vaddlv_u8(v9);
  v3 += v9.i32[0];
LABEL_7:
  uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v5[v6] & ~(-1 << a2)));
  v10.i16[0] = vaddlv_u8(v10);
  uint64_t v11 = (v3 + v10.i32[0]);
  if (v11 >= v4) {
    goto LABEL_17;
  }
  uint64_t v12 = (~v11 + v4);
  if (v12 < 0x2B
    || ((uint64_t v13 = 4 * v4 + a1, v14 = 4 * (v4 - 1) + a1, v13 + 38 - 4 * v12 <= (unint64_t)(v13 + 38))
      ? (BOOL v15 = v14 + 38 - 4 * v12 > (unint64_t)(v14 + 38))
      : (BOOL v15 = 1),
        v15 || (unint64_t)(v14 - v13) < 0x20))
  {
    uint64_t v16 = v4;
    goto LABEL_15;
  }
  uint64_t v22 = v12 + 1;
  uint64_t v23 = (v12 + 1) & 0x1FFFFFFF8;
  uint64_t v24 = v4 + 0xFFFFFFFFLL;
  unsigned int v25 = (_OWORD *)(4 * v4 + a1 + 26);
  uint64_t v26 = v23;
  do
  {
    uint64_t v27 = a1 + 4 * v24;
    long long v28 = *(_OWORD *)(v27 + 26);
    *(v25 - 1) = *(_OWORD *)(v27 + 10);
    *unsigned int v25 = v28;
    v24 -= 8;
    v25 -= 2;
    v26 -= 8;
  }
  while (v26);
  if (v22 != v23)
  {
    uint64_t v16 = v4 - v23;
LABEL_15:
    uint64_t v17 = (int *)(a1 + 4 * (v16 - 1) + 38);
    uint64_t v18 = (_DWORD *)(a1 + 4 * v16 + 38);
    do
    {
      int v19 = *v17--;
      *v18-- = v19;
      LODWORD(v16) = v16 - 1;
    }
    while (v11 < v16);
  }
LABEL_17:
  unsigned __int8 v20 = v4 + 1;
  *(unsigned char *)(a1 + 36) = v20;
  if (*(unsigned __int8 *)(a1 + 37) < v20)
  {
    if ((__native_fs() & 1) == 0)
    {
      unint64_t v32 = __si_assert_copy_extra_1921(0);
      si_analytics_log_1964((uint64_t)v32, v33, v34, v35, v36, v37, v38, v39, (char)"BurstTrie.c");
      free(v32);
      MEMORY[0xB00] = -559038737;
      abort();
    }
    if (*(unsigned __int8 *)(a1 + 37) < *(unsigned __int8 *)(a1 + 36))
    {
      unsigned int v29 = __si_assert_copy_extra_1921(0);
      BOOL v30 = v29;
      int v31 = "";
      if (v29) {
        int v31 = v29;
      }
      __message_assert("%s:%u: failed assertion '%s' %s %d < %d", "BurstTrie.c", 327, "t->size>=t->count", v31, *(unsigned __int8 *)(a1 + 37), *(unsigned __int8 *)(a1 + 36));
      free(v30);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
  }
  return v11;
}

unint64_t burst2(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_DWORD *)(a2 + 4))
  {
    uint64_t v4 = 0;
    unint64_t v5 = a3 & 0xFFFFFFFF00000000;
  }
  else
  {
    unint64_t v8 = mmalloc(0x38u, a1 + 16, *(uint64_t (**)(uint64_t))(a2 + 2160), *(void *)(a2 + 2168));
    if (v8
      && (unint64_t v9 = v8,
          uint64_t v10 = mgetBase(a1, v8 >> 2),
          *(_OWORD *)(v10 + 16) = 0u,
          *(_OWORD *)(v10 + 32) = 0u,
          *(_OWORD *)uint64_t v10 = 0u,
          *(void *)(v10 + 48) = 0,
          *(unsigned char *)(v10 + 37) = 4,
          (v9 & 0x3FFFFFFFCLL) != 0))
    {
      if (HIDWORD(a3))
      {
        uint64_t v14 = __si_assert_copy_extra_1921(0);
        BOOL v15 = v14;
        uint64_t v16 = "";
        if (v14) {
          uint64_t v16 = v14;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 3606, "oldPtr.kind == FLAT", v16);
        free(v15);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      long long v17 = *(_OWORD *)(a2 + 1084);
      unint64_t v11 = burstFlat(a1, (int *)a2, a3, (v9 >> 2) | 0x100000000);
      unint64_t v5 = v11 & 0xFFFFFFFF00000000;
      *(_OWORD *)(a2 + 1084) = v17;
      uint64_t v4 = v11;
    }
    else
    {
      uint64_t v12 = __error();
      uint64_t v4 = 0;
      *(_DWORD *)(a2 + 4) = *v12;
      unint64_t v5 = 0x100000000;
    }
  }
  return v5 | v4;
}

void si_analytics_log_1964(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  string[0] = 0;
  string[1] = &a9;
  vasprintf(string, "%s:%u: failed assertion '%s' %s %d < %d", &a9);
  SISetCrashCStr(string[0]);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)keys = 136315138;
    *(char **)&keys[4] = string[0];
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "%s", keys, 0xCu);
  }
  *(void *)keys = "crash_string";
  xpc_object_t v9 = xpc_string_create(string[0]);
  xpc_object_t values = v9;
  xpc_object_t v10 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  analytics_send_event();
  xpc_release(v10);
  xpc_release(v9);
  free(string[0]);
}

unint64_t bt_getOffset(uint64_t a1, int a2, uint64_t a3, _DWORD *a4)
{
  unsigned int v5 = *(_DWORD *)a1 >> 3;
  unsigned int v6 = *(_DWORD *)a1 & 7;
  if ((*(_DWORD *)a1 & 3) == 1)
  {
    unsigned int v6 = 1;
    unsigned int v5 = *(_DWORD *)a1 >> 2;
  }
  if (*(_DWORD *)a1) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  if (*(_DWORD *)a1) {
    unsigned int v8 = v5;
  }
  else {
    unsigned int v8 = *(_DWORD *)a1 >> 1;
  }
  if (v8) {
    BOOL v9 = a2 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    uint64_t v12 = 0;
    int v13 = a2 - 1;
    while (v7 != 1)
    {
      if (v7 != 3)
      {
        if (v7)
        {
          uint64_t v35 = __si_assert_copy_extra_1921(0);
          uint64_t v36 = v35;
          if (v35) {
            uint64_t v37 = v35;
          }
          else {
            uint64_t v37 = "";
          }
          __message_assert("%s:%u: Unexpected code path %s ", "BurstTrie.c", 1181, v37);
          free(v36);
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        goto LABEL_45;
      }
      if (v8 > *(_DWORD *)(a1 + 144))
      {
        unint64_t v32 = __si_assert_copy_extra_1921(*(_DWORD **)(a1 + 4576));
        uint64_t v33 = v32;
        uint64_t v34 = "";
        if (v32) {
          uint64_t v34 = v32;
        }
        __message_assert("%s:%u: failed assertion '%s' %s s: %d, c: %d", "BurstTrie.c", 1144, "ptr.next<=getNum(t->baseFatCount)", v34, v8, *(_DWORD *)(a1 + 144));
        free(v33);
        if (__valid_fsp(*(_DWORD **)(a1 + 4576)))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      unsigned int v16 = *(_DWORD *)(*(void *)(a1 + 8) + 1028 * v8 + 4 * *(unsigned __int8 *)(a3 + v12) + 4);
      unsigned int v17 = v16 >> 1;
      unsigned int v18 = v16 >> 3;
      unsigned int v19 = v16 & 7;
      if ((v16 & 3) == 1)
      {
        unsigned int v19 = 1;
        unsigned int v18 = v16 >> 2;
      }
      BOOL v20 = (v16 & 1) == 0;
      if (v16) {
        uint64_t v7 = v19;
      }
      else {
        uint64_t v7 = 0;
      }
      if (v20) {
        unsigned int v8 = v17;
      }
      else {
        unsigned int v8 = v18;
      }
LABEL_18:
      int v14 = v12++;
      if (v8) {
        BOOL v15 = v13 == v14;
      }
      else {
        BOOL v15 = 1;
      }
      if (v15) {
        goto LABEL_15;
      }
    }
    uint64_t v21 = mgetBase(a1, v8);
    unint64_t v22 = *(unsigned __int8 *)(a3 + v12);
    if (((*(_DWORD *)(v21 + ((v22 >> 3) & 0x1C) + 4) >> v22) & 1) == 0)
    {
      unsigned int v8 = 0;
      uint64_t v7 = 1;
      return v8 | (unint64_t)(v7 << 32);
    }
    uint64_t v23 = 0;
    uint64_t v24 = (int8x8_t *)(v21 + 4);
    unint64_t v25 = v22 >> 6;
    if ((v22 >> 6) != 1)
    {
      if (v25 != 2)
      {
        if (v25 != 3) {
          goto LABEL_40;
        }
        uint8x8_t v26 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v21 + 20));
        v26.i16[0] = vaddlv_u8(v26);
        uint64_t v23 = v26.u32[0];
      }
      uint8x8_t v27 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v21 + 12));
      v27.i16[0] = vaddlv_u8(v27);
      v23 += v27.u32[0];
    }
    uint8x8_t v28 = (uint8x8_t)vcnt_s8(*v24);
    v28.i16[0] = vaddlv_u8(v28);
    v23 += v28.u32[0];
LABEL_40:
    uint8x8_t v29 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v24[v25] & ~(-1 << v22)));
    v29.i16[0] = vaddlv_u8(v29);
    unsigned int v30 = *(_DWORD *)(v21 + 4 * (v29.u32[0] + v23) + 38);
    if (v30)
    {
      if ((v30 & 3) == 1)
      {
        unsigned int v8 = v30 >> 2;
        uint64_t v7 = 1;
      }
      else
      {
        unsigned int v8 = v30 >> 3;
        uint64_t v7 = v30 & 7;
      }
    }
    else
    {
      uint64_t v7 = 0;
      unsigned int v8 = v30 >> 1;
    }
    goto LABEL_18;
  }
  LODWORD(v12) = 0;
LABEL_15:
  if (v7)
  {
    unsigned int v8 = 0;
  }
  else
  {
LABEL_45:
    uint64_t v7 = 0;
    *a4 = v12;
  }
  return v8 | (unint64_t)(v7 << 32);
}

uint64_t bt_shadowTrie(uint64_t a1, const char *a2, int a3, _DWORD *a4)
{
  uint64_t v145 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (unsigned char *)(a1 + 4588);
  if (*(unsigned char *)(a1 + 4588)) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = a3 == 0;
  }
  if (v5) {
    return 0;
  }
  char v7 = a3;
  *(_DWORD *)long long valuePtr = *(_DWORD *)(a1 + 152);
  CFNumberRef v10 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, valuePtr);
  pthread_mutex_lock(&registeredFdsLock);
  if (registeredCloneFds)
  {
    int v11 = CFSetContainsValue((CFSetRef)registeredCloneFds, v10);
    pthread_mutex_unlock(&registeredFdsLock);
    CFRelease(v10);
    if (v11)
    {
      bzero(valuePtr, 0x400uLL);
      bzero(__str, 0x400uLL);
      double Current = CFAbsoluteTimeGetCurrent();
      snprintf(valuePtr, 0x400uLL, "%s%s", a2, "indexCompactDirectory");
      snprintf(__str, 0x400uLL, "%s%s", a2, "shadowIndexCompactDirectory");
      char v13 = copyFileFallback(*(unsigned int *)(a1 + 152), valuePtr, *(_DWORD *)(a1 + 152), __str, a4, 1, 1);
      int v14 = *__error();
      if (v13)
      {
        BOOL v15 = _SILogForLogForCategory(10);
        os_log_type_t v16 = 2 * (dword_1E9FC90CC < 4);
        if (os_log_type_enabled(v15, v16))
        {
          float v17 = CFAbsoluteTimeGetCurrent() - Current;
          *(_DWORD *)iovec buf = 134217984;
          *(double *)&uint8_t buf[4] = v17;
          _os_log_impl(&dword_1BD672000, v15, v16, "shadowIndexCompactDirectory took %f seconds", buf, 0xCu);
        }
        *__error() = v14;
        double v18 = CFAbsoluteTimeGetCurrent();
        snprintf(valuePtr, 0x400uLL, "%s%s", a2, "indexDirectory");
        snprintf(__str, 0x400uLL, "%s%s", a2, "shadowIndexDirectory");
        char v19 = copyFileFallback(*(unsigned int *)(a1 + 152), valuePtr, *(_DWORD *)(a1 + 152), __str, a4, 1, 1);
        int v20 = *__error();
        if (v19)
        {
          uint64_t v21 = _SILogForLogForCategory(10);
          os_log_type_t v22 = 2 * (dword_1E9FC90CC < 4);
          if (os_log_type_enabled(v21, v22))
          {
            float v23 = CFAbsoluteTimeGetCurrent() - v18;
            *(_DWORD *)iovec buf = 134217984;
            *(double *)&uint8_t buf[4] = v23;
            _os_log_impl(&dword_1BD672000, v21, v22, "shadowIndexDirectory took %f seconds", buf, 0xCu);
          }
          *__error() = v20;
          CFAbsoluteTimeGetCurrent();
          snprintf(valuePtr, 0x400uLL, "%s%s", a2, "indexArrays");
          snprintf(__str, 0x400uLL, "%s%s", a2, "shadowIndexArrays");
          if (copyFileFallback(*(unsigned int *)(a1 + 152), valuePtr, *(_DWORD *)(a1 + 152), __str, a4, 1, 1))
          {
            uint64_t v24 = *(void *)(a1 + 4536);
            if (v24 >= 1)
            {
              CFIndex v25 = 0;
              uint8x8_t v26 = (void *)(a1 + 4536);
              do
                bit_vector_set_1980(v26, v25++, 0);
              while (v24 != v25);
            }
LABEL_17:
            uint64_t result = 0;
            *uint64_t v4 = 0;
            return result;
          }
          if (*__error() == 1) {
            goto LABEL_57;
          }
          int v47 = *__error();
          uint8x8_t v48 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)iovec buf = 136315906;
            *(void *)&uint8_t buf[4] = "bt_shadowTrie";
            __int16 v109 = 1024;
            int v110 = 1922;
            __int16 v111 = 2080;
            *(void *)uint8x8_t v112 = valuePtr;
            *(_WORD *)&v112[8] = 2080;
            *(void *)&v112[10] = __str;
            goto LABEL_78;
          }
LABEL_79:
          *__error() = v47;
          return 0xFFFFFFFFLL;
        }
        if (v20 == 1)
        {
LABEL_57:
          bzero(v107, 0x400uLL);
          CFAbsoluteTimeGetCurrent();
          goto LABEL_58;
        }
        int v47 = *__error();
        uint8x8_t v48 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
          goto LABEL_79;
        }
        *(_DWORD *)iovec buf = 136315906;
        *(void *)&uint8_t buf[4] = "bt_shadowTrie";
        __int16 v109 = 1024;
        int v110 = 1907;
        __int16 v111 = 2080;
        *(void *)uint8x8_t v112 = valuePtr;
        *(_WORD *)&v112[8] = 2080;
        *(void *)&v112[10] = __str;
LABEL_78:
        _os_log_error_impl(&dword_1BD672000, v48, OS_LOG_TYPE_ERROR, "%s:%d: copyFile error, src: %s, dst: %s", buf, 0x26u);
        goto LABEL_79;
      }
      if (v14 != 1)
      {
        int v47 = *__error();
        uint8x8_t v48 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
          goto LABEL_79;
        }
        *(_DWORD *)iovec buf = 136315906;
        *(void *)&uint8_t buf[4] = "bt_shadowTrie";
        __int16 v109 = 1024;
        int v110 = 1891;
        __int16 v111 = 2080;
        *(void *)uint8x8_t v112 = valuePtr;
        *(_WORD *)&v112[8] = 2080;
        *(void *)&v112[10] = __str;
        goto LABEL_78;
      }
    }
  }
  else
  {
    pthread_mutex_unlock(&registeredFdsLock);
    CFRelease(v10);
  }
  bzero(v107, 0x400uLL);
  double v28 = CFAbsoluteTimeGetCurrent();
  snprintf(v107, 0x400uLL, "%s%s", a2, "shadowIndexCompactDirectory");
  uint8x8_t v29 = fd_create_protected(*(_DWORD *)(a1 + 152), v107, 1538, 0);
  if (!v29)
  {
    unsigned int v43 = *__error();
    int v44 = *__error();
    unint64_t v45 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long valuePtr = 136315906;
      *(void *)&valuePtr[4] = "bt_shadowTrie";
      __int16 v139 = 1024;
      int v140 = 1947;
      __int16 v141 = 1024;
      unsigned int v142 = v43;
      __int16 v143 = 2080;
      uint64_t v144 = v107;
      goto LABEL_87;
    }
LABEL_41:
    uint64_t v30 = 0;
    goto LABEL_43;
  }
  uint64_t v30 = (uint64_t)v29;
  *(void *)long long valuePtr = 0;
  int v31 = _fd_acquire_fd((uint64_t)v29, valuePtr);
  if (v31 != -1)
  {
    int v32 = v31;
    *(_WORD *)(v30 + 56) |= 1u;
    fcntl(v31, 48, 1);
    fcntl(v32, 76, *(_WORD *)(v30 + 56) & 1);
    _fd_release_fd((_DWORD *)v30, v32, 0, *(uint64_t *)valuePtr);
  }
  if (__THREAD_SLOT_KEY)
  {
    uint64_t v33 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v33) {
      goto LABEL_26;
    }
  }
  else
  {
    makeThreadId();
    uint64_t v33 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v33)
    {
LABEL_26:
      if ((unint64_t)v33 < 0x801) {
        goto LABEL_27;
      }
    }
  }
  makeThreadId();
  uint64_t v33 = pthread_getspecific(__THREAD_SLOT_KEY);
LABEL_27:
  uint64_t v34 = (uint64_t)v33 - 1;
  unint64_t v35 = CICleanUpPush((uint64_t)v33 - 1, (uint64_t)fd_release, v30);
  uint64_t v36 = fd_pwrite(v30, *(void *)(a1 + 16), *(void *)(a1 + 32), 0);
  CICleanUpClearItem(v34, v35);
  CICleanUpPop(v34);
  if (v36 == -1)
  {
    unsigned int v43 = *__error();
    int v44 = *__error();
    uint8x8_t v46 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
      goto LABEL_43;
    }
    *(_DWORD *)long long valuePtr = 136315906;
    *(void *)&valuePtr[4] = "bt_shadowTrie";
    __int16 v139 = 1024;
    int v140 = 1960;
    __int16 v141 = 1024;
    unsigned int v142 = v43;
    __int16 v143 = 2080;
    uint64_t v144 = v107;
    goto LABEL_103;
  }
  if (_gSystemStatusBool)
  {
    pthread_mutex_lock(&_gSystemStatusLock);
    while (_gSystemStatusBool)
      pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
    pthread_mutex_unlock(&_gSystemStatusLock);
  }
  *(void *)long long valuePtr = 0;
  uint64_t v37 = _fd_acquire_fd(v30, valuePtr);
  if (v37 != -1)
  {
    int v38 = v37;
    prot_fsync(v37, 0);
    _fd_release_fd((_DWORD *)v30, v38, 0, *(uint64_t *)valuePtr);
  }
  fd_release((atomic_uint *)v30);
  int v39 = *__error();
  uint64_t v40 = _SILogForLogForCategory(10);
  os_log_type_t v41 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v40, v41))
  {
    float v42 = CFAbsoluteTimeGetCurrent() - v28;
    *(_DWORD *)long long valuePtr = 134217984;
    *(double *)&valuePtr[4] = v42;
    _os_log_impl(&dword_1BD672000, v40, v41, "shadowIndexCompactDirectory took %f seconds", valuePtr, 0xCu);
  }
  *__error() = v39;
  if (*a4 == 1 || *a4 == -1 && (v7 & 1) != 0) {
    return 89;
  }
  double v49 = CFAbsoluteTimeGetCurrent();
  snprintf(v107, 0x400uLL, "%s%s", a2, "shadowIndexDirectory");
  uint64_t v50 = fd_create_protected(*(_DWORD *)(a1 + 152), v107, 1538, 0);
  if (!v50)
  {
    unsigned int v43 = *__error();
    int v44 = *__error();
    unint64_t v45 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long valuePtr = 136315906;
      *(void *)&valuePtr[4] = "bt_shadowTrie";
      __int16 v139 = 1024;
      int v140 = 1983;
      __int16 v141 = 1024;
      unsigned int v142 = v43;
      __int16 v143 = 2080;
      uint64_t v144 = v107;
LABEL_87:
      _os_log_error_impl(&dword_1BD672000, v45, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", valuePtr, 0x22u);
      goto LABEL_41;
    }
    goto LABEL_41;
  }
  uint64_t v30 = (uint64_t)v50;
  fd_no_cache((uint64_t)v50);
  unsigned int v51 = CICleanUpThreadLoc();
  unint64_t v52 = CICleanUpPush((uint64_t)v51, (uint64_t)fd_release, v30);
  uint64_t v53 = fd_pwrite(v30, *(void *)(a1 + 8), 1028 * (*(_DWORD *)(a1 + 144) + 1), 0);
  CICleanUpClearItem((uint64_t)v51, v52);
  CICleanUpPop((uint64_t)v51);
  if (v53 != -1)
  {
    fd_sync(v30, 0);
    fd_release((atomic_uint *)v30);
    int v54 = *__error();
    unint64_t v55 = _SILogForLogForCategory(10);
    os_log_type_t v56 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v55, v56))
    {
      float v57 = CFAbsoluteTimeGetCurrent() - v49;
      *(_DWORD *)long long valuePtr = 134217984;
      *(double *)&valuePtr[4] = v57;
      _os_log_impl(&dword_1BD672000, v55, v56, "shadowIndexDirectory took %f seconds", valuePtr, 0xCu);
    }
    *__error() = v54;
LABEL_58:
    long long v137 = 0u;
    long long v136 = 0u;
    long long v135 = 0u;
    long long v134 = 0u;
    long long v133 = 0u;
    long long v132 = 0u;
    long long v131 = 0u;
    long long v130 = 0u;
    long long v129 = 0u;
    long long v128 = 0u;
    long long v127 = 0u;
    long long v126 = 0u;
    long long v125 = 0u;
    long long v124 = 0u;
    long long v123 = 0u;
    long long v122 = 0u;
    long long v121 = 0u;
    long long v120 = 0u;
    long long v119 = 0u;
    long long v118 = 0u;
    long long v117 = 0u;
    long long v116 = 0u;
    long long v115 = 0u;
    long long v114 = 0u;
    *(_OWORD *)std::string __str = 0u;
    bzero(valuePtr, 0x400uLL);
    uint64_t v105 = 0;
    uint64_t v106 = 0;
    double v58 = CFAbsoluteTimeGetCurrent();
    snprintf(valuePtr, 0x400uLL, "%s%s", a2, "shadowIndexArrays");
    uint64_t v59 = fd_create_protected(*(_DWORD *)(a1 + 152), valuePtr, 514, 0);
    *(void *)iovec buf = 0;
    int v60 = _fd_acquire_fd((uint64_t)v59, buf);
    if (v60 == -1)
    {
      if (!v59)
      {
        unsigned int v72 = *__error();
        int v73 = *__error();
        unint64_t v76 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)iovec buf = 136315906;
          *(void *)&uint8_t buf[4] = "shadowFlatStore";
          __int16 v109 = 1024;
          int v110 = 1740;
          __int16 v111 = 1024;
          *(_DWORD *)uint8x8_t v112 = v72;
          *(_WORD *)&v112[4] = 2080;
          *(void *)&v112[6] = valuePtr;
          _os_log_error_impl(&dword_1BD672000, v76, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", buf, 0x22u);
        }
        int v64 = 0;
        goto LABEL_94;
      }
    }
    else
    {
      int v61 = v60;
      *((_WORD *)v59 + 28) |= 1u;
      fcntl(v60, 48, 1);
      fcntl(v61, 76, v59[7] & 1);
      _fd_release_fd(v59, v61, 0, *(uint64_t *)buf);
    }
    uint64_t v62 = (*(_DWORD *)(a1 + 392) + 0x1FFFF) >> 17;
    if ((v7 & 1) == 0 && v62 >= *(void *)(a1 + 4536)) {
      uint64_t v62 = *(void *)(a1 + 4536);
    }
    unsigned int v63 = malloc_type_malloc(0x20000uLL, 0xD85BE8CAuLL);
    if (!v63)
    {
      uint64_t v97 = __si_assert_copy_extra_1921(0);
      unint64_t v98 = v97;
      unint64_t v99 = "";
      if (v97) {
        unint64_t v99 = v97;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1754, "readBuffer", v99);
      free(v98);
      if (__valid_fs(-1)) {
        uint64_t v100 = 2989;
      }
      else {
        uint64_t v100 = 3072;
      }
      *(_DWORD *)uint64_t v100 = -559038737;
      abort();
    }
    int v64 = v63;
    size_t v65 = *(void *)(a1 + 392);
    BOOL v66 = *(_DWORD **)(a1 + 376);
    if (v65 >> 17)
    {
      unsigned int v67 = _fd_acquire_fd((uint64_t)v66, &v105);
      if (v67 != -1)
      {
        unsigned int v68 = v67;
        unsigned int v69 = _fd_acquire_fd((uint64_t)v59, &v106);
        if (v69 != -1)
        {
          unsigned int v102 = v69;
          unsigned int __fd = v68;
          if (v62 < 1)
          {
LABEL_155:
            _fd_release_fd(*(_DWORD **)(a1 + 376), __fd, 0, v105);
            _fd_release_fd(v59, v102, 0, v106);
            goto LABEL_156;
          }
          uint64_t v101 = (CFIndex *)(a1 + 4536);
          __iovec buf = v64;
          if (v7)
          {
            uint64_t v70 = 0;
            unsigned int v71 = 0;
            while (v71 != 100)
            {
LABEL_104:
              *(_DWORD *)&__str[4 * v71++] = v70;
              if (++v70 == v62) {
                goto LABEL_136;
              }
            }
            uint64_t v79 = 0;
            while (*a4 != 1 && *a4 != -1)
            {
              CFIndex v80 = *(unsigned int *)&__str[v79];
              if (prot_pread(__fd, __buf, 0x20000uLL, v80 << 17) == -1) {
                goto LABEL_130;
              }
              if (*a4 == 1 || *a4 == -1) {
                break;
              }
              if (prot_pwrite_guarded(v102, (uint64_t)&v106, (uint64_t)__buf, 0x20000uLL, v80 << 17) == -1) {
                goto LABEL_133;
              }
              bit_vector_set_1980(v101, v80, 0);
              v79 += 4;
              if (v79 == 400)
              {
                unsigned int v71 = 0;
                int v64 = __buf;
                goto LABEL_104;
              }
            }
LABEL_128:
            unsigned int v72 = 89;
            int v64 = __buf;
          }
          else
          {
            CFIndex v81 = 0;
            unsigned int v71 = 0;
            do
            {
              if (v71 == 100)
              {
                uint64_t v82 = 0;
                while (*a4 != 1)
                {
                  CFIndex v83 = *(unsigned int *)&__str[v82];
                  if (prot_pread(v68, __buf, 0x20000uLL, v83 << 17) == -1)
                  {
LABEL_130:
                    unsigned int v72 = *__error();
                    int v73 = *__error();
                    unint64_t v84 = _SILogForLogForCategory(0);
                    int v77 = v102;
                    if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)iovec buf = 136315650;
                      *(void *)&uint8_t buf[4] = "shadowFlatStore";
                      __int16 v109 = 1024;
                      int v110 = 1790;
                      __int16 v111 = 1024;
                      *(_DWORD *)uint8x8_t v112 = v72;
                      _os_log_error_impl(&dword_1BD672000, v84, OS_LOG_TYPE_ERROR, "%s:%d: read err: %d", buf, 0x18u);
                    }
                    int v64 = __buf;
                    unsigned int v68 = __fd;
                    goto LABEL_95;
                  }
                  if (*a4 == 1) {
                    goto LABEL_128;
                  }
                  if (prot_pwrite_guarded(v102, (uint64_t)&v106, (uint64_t)__buf, 0x20000uLL, v83 << 17) == -1)
                  {
LABEL_133:
                    unsigned int v72 = *__error();
                    int v73 = *__error();
                    unint64_t v85 = _SILogForLogForCategory(0);
                    unsigned int v68 = __fd;
                    if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)iovec buf = 136315650;
                      *(void *)&uint8_t buf[4] = "shadowFlatStore";
                      __int16 v109 = 1024;
                      int v110 = 1799;
                      __int16 v111 = 1024;
                      *(_DWORD *)uint8x8_t v112 = v72;
                      _os_log_error_impl(&dword_1BD672000, v85, OS_LOG_TYPE_ERROR, "%s:%d: pwrite err: %d", buf, 0x18u);
                    }
                    int v64 = __buf;
                    int v77 = v102;
                    goto LABEL_95;
                  }
                  bit_vector_set_1980(v101, v83, 0);
                  v82 += 4;
                  if (v82 == 400)
                  {
                    unsigned int v71 = 0;
                    int v64 = __buf;
                    goto LABEL_125;
                  }
                }
                goto LABEL_128;
              }
LABEL_125:
              if (*v101 > v81 && CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a1 + 4552), v81)) {
                *(_DWORD *)&__str[4 * v71++] = v81;
              }
              ++v81;
            }
            while (v81 != v62);
LABEL_136:
            if (!v71) {
              goto LABEL_155;
            }
            uint64_t v86 = v71;
            if ((v7 & 1) == 0)
            {
              __int16 v89 = __str;
              while (1)
              {
                if (*a4 == 1) {
                  goto LABEL_162;
                }
                CFIndex v90 = *(unsigned int *)v89;
                if (prot_pread(__fd, v64, 0x20000uLL, v90 << 17) == -1) {
                  break;
                }
                if (*a4 == 1) {
                  goto LABEL_162;
                }
                if (prot_pwrite_guarded(v102, (uint64_t)&v106, (uint64_t)v64, 0x20000uLL, v90 << 17) == -1)
                {
LABEL_165:
                  unsigned int v72 = *__error();
                  int v73 = *__error();
                  int v95 = _SILogForLogForCategory(0);
                  if (!os_log_type_enabled(v95, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_166;
                  }
                  *(_DWORD *)iovec buf = 136315650;
                  *(void *)&uint8_t buf[4] = "shadowFlatStore";
                  __int16 v109 = 1024;
                  int v110 = 1837;
                  __int16 v111 = 1024;
                  *(_DWORD *)uint8x8_t v112 = v72;
                  uint64_t v96 = "%s:%d: pwrite err: %d";
                  goto LABEL_174;
                }
                bit_vector_set_1980(v101, v90, 0);
                v89 += 4;
                if (!--v86) {
                  goto LABEL_155;
                }
              }
LABEL_163:
              unsigned int v72 = *__error();
              int v73 = *__error();
              int v95 = _SILogForLogForCategory(0);
              if (!os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
              {
LABEL_166:
                int v64 = __buf;
                int v77 = v102;
                unsigned int v68 = __fd;
                goto LABEL_95;
              }
              *(_DWORD *)iovec buf = 136315650;
              *(void *)&uint8_t buf[4] = "shadowFlatStore";
              __int16 v109 = 1024;
              int v110 = 1828;
              __int16 v111 = 1024;
              *(_DWORD *)uint8x8_t v112 = v72;
              uint64_t v96 = "%s:%d: pread err: %d";
LABEL_174:
              _os_log_error_impl(&dword_1BD672000, v95, OS_LOG_TYPE_ERROR, v96, buf, 0x18u);
              goto LABEL_166;
            }
            int v87 = __str;
            while (*a4 != 1 && *a4 != -1)
            {
              CFIndex v88 = *(unsigned int *)v87;
              if (prot_pread(__fd, v64, 0x20000uLL, v88 << 17) == -1) {
                goto LABEL_163;
              }
              if (*a4 == 1 || *a4 == -1) {
                break;
              }
              if (prot_pwrite_guarded(v102, (uint64_t)&v106, (uint64_t)v64, 0x20000uLL, v88 << 17) == -1) {
                goto LABEL_165;
              }
              bit_vector_set_1980(v101, v88, 0);
              v87 += 4;
              if (!--v86) {
                goto LABEL_155;
              }
            }
LABEL_162:
            unsigned int v72 = 89;
          }
          int v77 = v102;
          unsigned int v68 = __fd;
LABEL_96:
          free(v64);
          _fd_release_fd(*(_DWORD **)(a1 + 376), v68, 0, v105);
          _fd_release_fd(v59, v77, 0, v106);
          fd_release((atomic_uint *)v59);
          if (v72) {
            return v72;
          }
          else {
            return 0xFFFFFFFFLL;
          }
        }
        unsigned int v72 = *__error();
        int v73 = *__error();
        unint64_t v78 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)iovec buf = 136315650;
          *(void *)&uint8_t buf[4] = "shadowFlatStore";
          __int16 v109 = 1024;
          int v110 = 1777;
          __int16 v111 = 1024;
          *(_DWORD *)uint8x8_t v112 = v72;
          _os_log_error_impl(&dword_1BD672000, v78, OS_LOG_TYPE_ERROR, "%s:%d: fd_open err: %d", buf, 0x18u);
        }
        int v77 = -1;
LABEL_95:
        *__error() = v73;
        goto LABEL_96;
      }
      unsigned int v72 = *__error();
      int v73 = *__error();
      uint64_t v74 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)iovec buf = 136315650;
        *(void *)&uint8_t buf[4] = "shadowFlatStore";
        __int16 v109 = 1024;
        int v110 = 1771;
        __int16 v111 = 1024;
        *(_DWORD *)uint8x8_t v112 = v72;
        uint64_t v75 = "%s:%d: fd_open err: %d";
        goto LABEL_93;
      }
    }
    else
    {
      if (fd_pread(v66, v64, v65, 0) != -1)
      {
        if (fd_pwrite((uint64_t)v59, (uint64_t)v64, *(void *)(a1 + 392), 0) != -1)
        {
          bit_vector_set_1980((void *)(a1 + 4536), 0, 0);
LABEL_156:
          free(v64);
          fd_truncate((uint64_t)v59, *(void *)(a1 + 384));
          fd_sync((uint64_t)v59, 0);
          fd_release((atomic_uint *)v59);
          int v91 = *__error();
          uint64_t v92 = _SILogForLogForCategory(10);
          os_log_type_t v93 = 2 * (dword_1E9FC90CC < 4);
          if (os_log_type_enabled(v92, v93))
          {
            float v94 = CFAbsoluteTimeGetCurrent() - v58;
            *(_DWORD *)iovec buf = 134217984;
            *(double *)&uint8_t buf[4] = v94;
            _os_log_impl(&dword_1BD672000, v92, v93, "shadowIndexArrays took %f seconds", buf, 0xCu);
          }
          *__error() = v91;
          if (*a4 != 1 && (*a4 != -1 || (v7 & 1) == 0)) {
            goto LABEL_17;
          }
          int v64 = 0;
          uint64_t v59 = 0;
          unsigned int v72 = 89;
          int v77 = -1;
          unsigned int v68 = -1;
          goto LABEL_96;
        }
        unsigned int v72 = *__error();
        int v73 = *__error();
        uint64_t v74 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
          goto LABEL_94;
        }
        *(_DWORD *)iovec buf = 136315650;
        *(void *)&uint8_t buf[4] = "shadowFlatStore";
        __int16 v109 = 1024;
        int v110 = 1763;
        __int16 v111 = 1024;
        *(_DWORD *)uint8x8_t v112 = v72;
        uint64_t v75 = "%s:%d: pwrite err: %d";
        goto LABEL_93;
      }
      unsigned int v72 = *__error();
      int v73 = *__error();
      uint64_t v74 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)iovec buf = 136315650;
        *(void *)&uint8_t buf[4] = "shadowFlatStore";
        __int16 v109 = 1024;
        int v110 = 1758;
        __int16 v111 = 1024;
        *(_DWORD *)uint8x8_t v112 = v72;
        uint64_t v75 = "%s:%d: read err: %d";
LABEL_93:
        _os_log_error_impl(&dword_1BD672000, v74, OS_LOG_TYPE_ERROR, v75, buf, 0x18u);
      }
    }
LABEL_94:
    int v77 = -1;
    unsigned int v68 = -1;
    goto LABEL_95;
  }
  unsigned int v43 = *__error();
  int v44 = *__error();
  uint8x8_t v46 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long valuePtr = 136315906;
    *(void *)&valuePtr[4] = "bt_shadowTrie";
    __int16 v139 = 1024;
    int v140 = 1996;
    __int16 v141 = 1024;
    unsigned int v142 = v43;
    __int16 v143 = 2080;
    uint64_t v144 = v107;
LABEL_103:
    _os_log_error_impl(&dword_1BD672000, v46, OS_LOG_TYPE_ERROR, "%s:%d: write err: %d, %s", valuePtr, 0x22u);
  }
LABEL_43:
  *__error() = v44;
  fd_release((atomic_uint *)v30);
  if (v43) {
    return v43;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void bit_vector_set_1980(void *a1, CFIndex idx, CFBit value)
{
  if (idx < 0)
  {
    unsigned int v8 = __si_assert_copy_extra_1921(0);
    BOOL v9 = v8;
    CFNumberRef v10 = "";
    if (v8) {
      CFNumberRef v10 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 129, "bitIndex >= 0", v10);
LABEL_11:
    free(v9);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  CFIndex v6 = a1[1];
  if (v6 > idx) {
    goto LABEL_3;
  }
  if (v6) {
    CFIndex v11 = a1[1];
  }
  else {
    CFIndex v11 = 32;
  }
  while (1)
  {
    v11 *= 2;
    if (v11 > idx) {
      break;
    }
    if (v11 <= v6)
    {
      uint64_t v12 = __si_assert_copy_extra_1921(0);
      BOOL v9 = v12;
      char v13 = "";
      if (v12) {
        char v13 = v12;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v13);
      goto LABEL_11;
    }
  }
  CFBitVectorRef v14 = (const __CFBitVector *)a1[2];
  CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (v14) {
    CFMutableStringRef MutableCopy = CFBitVectorCreateMutableCopy(v15, v11, v14);
  }
  else {
    CFMutableStringRef MutableCopy = CFBitVectorCreateMutable(v15, v11);
  }
  float v17 = MutableCopy;
  if (!MutableCopy)
  {
    char v19 = __si_assert_copy_extra_1921(0);
    BOOL v9 = v19;
    int v20 = "";
    if (v19) {
      int v20 = v19;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v20);
    goto LABEL_11;
  }
  CFBitVectorSetCount(MutableCopy, v11);
  double v18 = (const void *)a1[2];
  if (v18) {
    CFRelease(v18);
  }
  a1[1] = v11;
  a1[2] = v17;
LABEL_3:
  if (*a1 <= idx) {
    *a1 = idx + 1;
  }
  char v7 = (__CFBitVector *)a1[2];
  CFBitVectorSetBitAtIndex(v7, idx, value);
}

uint64_t bt_mergeCallback(unsigned int a1, void *__s2, int **a3)
{
  __int32 v3 = a3 + 1;
  uint64_t v4 = (unsigned int *)*a3;
  unsigned int v5 = **a3;
  unsigned int v6 = v5 >> 3;
  unint64_t v7 = (unint64_t)(v5 & 7) << 32;
  if ((v5 & 3) == 1)
  {
    unint64_t v7 = 0x100000000;
    unsigned int v6 = v5 >> 2;
  }
  if (v5) {
    unint64_t v8 = v7;
  }
  else {
    unint64_t v8 = 0;
  }
  if (v5) {
    uint64_t v9 = v6;
  }
  else {
    uint64_t v9 = v5 >> 1;
  }
  if (*((_DWORD *)a3 + 3)) {
    return 0;
  }
  v18[0] = 0;
  v18[1] = 0;
  ++currentCount;
  unsigned int v13 = *((_DWORD *)a3 + 11);
  if (v13 && a1 > v13 && !memcmp(a3 + 6, __s2, *((unsigned int *)a3 + 11)))
  {
    if ((mergeEntryFlat((uint64_t)v4) & 1) == 0) {
      return LODWORD(v18[0]);
    }
    if (*((_DWORD *)a3 + 3)) {
      return 0;
    }
    if (*((_DWORD *)a3 + 11))
    {
      char v14 = 0;
      goto LABEL_15;
    }
  }
  else
  {
    a3[4] = 0;
    a3[5] = 0;
  }
  *(_OWORD *)((char *)a3 + 1092) = 0u;
  char v14 = 1;
LABEL_15:
  bt_mergeEntry((uint64_t)v4, v3, v8 | v9, v18, (unsigned __int8 *)__s2, a1);
  if (*((_DWORD *)a3 + 3)) {
    return 0;
  }
  char v16 = v14 ^ 1;
  if (*((_DWORD *)a3 + 10)) {
    char v16 = 1;
  }
  if ((v16 & 1) == 0 && *((_DWORD *)a3 + 8))
  {
    int v17 = *((_DWORD *)a3 + 11);
    if (v17)
    {
      *((_DWORD *)a3 + 11) = a1 - v17;
      __strncpy_chk();
      *((unsigned char *)a3 + *((unsigned int *)a3 + 11) + 48) = 0;
    }
  }
  return LODWORD(v18[0]);
}

unint64_t bt_mergeEntry(uint64_t a1, _DWORD *a2, uint64_t a3, _DWORD *a4, unsigned __int8 *a5, int a6)
{
  unsigned int v6 = a3;
  if (HIDWORD(a3) != 3)
  {
    if (HIDWORD(a3) != 1)
    {
      if (HIDWORD(a3))
      {
        unint64_t v8 = __si_assert_copy_extra_1921(0);
        uint64_t v9 = v8;
        if (v8) {
          CFNumberRef v10 = v8;
        }
        else {
          CFNumberRef v10 = "";
        }
        __message_assert("%s:%u: Unexpected code path %s ", "BurstTrie.c", 1710, v10);
        free(v9);
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      char v14 = __si_assert_copy_extra_1921(0);
      CFAllocatorRef v15 = v14;
      char v16 = "";
      if (v14) {
        char v16 = v14;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1691, "ptr.kind", v16);
      goto LABEL_24;
    }
    if (a3)
    {
      unint64_t v13 = mergeEntry(a1, a2, a3, a5, a6, a4, a3 | 0x100000000);
      unsigned int v6 = v13;
      if (HIDWORD(v13))
      {
        unint64_t v11 = v13 & 0xFFFFFFFF00000000;
        return v6 | v11;
      }
      if (a2[1])
      {
        unint64_t v11 = 0;
        return v6 | v11;
      }
      char v19 = __si_assert_copy_extra_1921(0);
      CFAllocatorRef v15 = v19;
      int v20 = "";
      if (v19) {
        int v20 = v19;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1713, "ptr.kind || ms->err", v20);
    }
    else
    {
      int v17 = __si_assert_copy_extra_1921(0);
      CFAllocatorRef v15 = v17;
      double v18 = "";
      if (v17) {
        double v18 = v17;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1705, "ptr.next", v18);
    }
LABEL_24:
    free(v15);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  mergeEntryFat(a1, (uint64_t)a2, a3, a5, a6, a4);
  unint64_t v11 = 0x300000000;
  return v6 | v11;
}

uint64_t mergeEntryFat(uint64_t result, uint64_t a2, unsigned int a3, unsigned __int8 *a4, int a5, _DWORD *a6)
{
  uint64_t v8 = result;
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  if (!a5)
  {
    uint64_t v24 = (_DWORD *)(*(void *)(result + 8) + 1028 * a3);
    if (!*v24)
    {
      _DWORD *v24 = *(_DWORD *)(a2 + 8);
      if (!*(_DWORD *)a2) {
        ++*(_DWORD *)(a2 + 8);
      }
    }
    *a6 = *(_DWORD *)(*(void *)(result + 8) + 1028 * a3);
    return result;
  }
  uint64_t v11 = *(void *)(result + 8) + 1028 * a3 + 4 * *a4;
  unsigned int v14 = *(_DWORD *)(v11 + 4);
  uint64_t v12 = (unsigned int *)(v11 + 4);
  char v13 = v14;
  unsigned int v15 = v14 >> 1;
  unsigned int v16 = v14 >> 3;
  unint64_t v17 = (unint64_t)(v14 & 7) << 32;
  unsigned int v18 = v14 >> 2;
  if ((v14 & 3) == 1)
  {
    unint64_t v17 = 0x100000000;
    unsigned int v16 = v18;
  }
  BOOL v19 = (v13 & 1) == 0;
  if (v13) {
    unint64_t v20 = v17;
  }
  else {
    unint64_t v20 = 0;
  }
  if (v19) {
    uint64_t v21 = v15;
  }
  else {
    uint64_t v21 = v16;
  }
  unint64_t v22 = v20 | v21;
  if (!v21)
  {
    unsigned int v93 = a3;
    if (*(_DWORD *)a2)
    {
      uint64_t v92 = (unint64_t *)(a2 + 2148);
      unint64_t v25 = *(void *)(a2 + 2148);
      long long v107 = 0u;
      long long v108 = 0u;
      long long v105 = 0u;
      long long v106 = 0u;
      long long v103 = 0u;
      long long v104 = 0u;
      long long v101 = 0u;
      long long v102 = 0u;
      long long v99 = 0u;
      long long v100 = 0u;
      long long v97 = 0u;
      long long v98 = 0u;
      unsigned int v96 = 0;
      unint64_t v26 = flatStoreNewBlockForCompact(result + 160, v25, (uint64_t)&v97, (int *)&v96);
      uint64_t v27 = v96;
      if ((int)v96 >= 1)
      {
        double v28 = (unint64_t *)&v97;
        do
        {
          unint64_t v30 = *v28++;
          unint64_t v29 = v30;
          bit_vector_set_3386((void *)(v8 + 4536), (v30 >> 17));
          if ((v30 >> 17) != (v30 + 8) >> 17) {
            bit_vector_set_3386((void *)(v8 + 4536), (v29 >> 17) + 1);
          }
          --v27;
        }
        while (v27);
      }
      unint64_t v94 = v26;
      *uint64_t v92 = v26;
      unsigned int v31 = v93;
      if (v26)
      {
LABEL_27:
        uint64_t result = mergeEntryFlat(v8);
        if (result)
        {
          if (*(_DWORD *)(a2 + 4)) {
            return result;
          }
          int v32 = __si_assert_copy_extra_1921(0);
          uint64_t v33 = v32;
          uint64_t v34 = "";
          if (v32) {
            uint64_t v34 = v32;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1293, "ms->err", v34);
LABEL_120:
          free(v33);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        unsigned int v76 = HIDWORD(v94) | (8 * v94);
        if (!HIDWORD(v94)) {
          unsigned int v76 = 2 * v94;
        }
        if (HIDWORD(v94) == 1) {
          unsigned int v77 = (4 * v94) | 1;
        }
        else {
          unsigned int v77 = v76;
        }
        if ((v77 & 3) == 1) {
          char v78 = 2;
        }
        else {
          char v78 = 3;
        }
        if ((v77 & 1) == 0) {
          char v78 = 1;
        }
        if (v77 >> v78 == v94)
        {
          *(_DWORD *)(*(void *)(v8 + 8) + 1028 * v31 + 4 * *a4 + 4) = v77;
          return result;
        }
LABEL_117:
        CFIndex v83 = __si_assert_copy_extra_1921(0);
        uint64_t v33 = v83;
        unint64_t v84 = "";
        if (v83) {
          unint64_t v84 = v83;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.h", 81, "ptrM(newptr).next == ptr.next", v84);
        goto LABEL_120;
      }
    }
    else
    {
      long long v107 = 0u;
      long long v108 = 0u;
      long long v105 = 0u;
      long long v106 = 0u;
      long long v103 = 0u;
      long long v104 = 0u;
      long long v101 = 0u;
      long long v102 = 0u;
      long long v99 = 0u;
      long long v100 = 0u;
      long long v97 = 0u;
      long long v98 = 0u;
      int v69 = 64;
      unsigned int v96 = 0;
      do
      {
        unsigned int v70 = v69;
        v69 *= 2;
      }
      while (v70 < a5 + 22);
      unint64_t v71 = storageAllocOffset(result + 160, v70, (uint64_t)&v97, (int *)&v96);
      if (v71)
      {
        unint64_t v72 = v71;
        uint64_t v73 = storageResolvePtr(v8 + 160, v71, v70, 1);
        *(_WORD *)uint64_t v73 = 0;
        char v74 = __clz(__rbit32(v70 >> 6));
        if (!v70) {
          char v74 = -1;
        }
        *(unsigned char *)(v73 + 2) = v74;
        unint64_t v75 = (v72 >> 6);
      }
      else
      {
        unint64_t v75 = 0;
      }
      uint64_t v79 = v96;
      if ((int)v96 >= 1)
      {
        CFIndex v80 = (unint64_t *)&v97;
        do
        {
          unint64_t v82 = *v80++;
          unint64_t v81 = v82;
          bit_vector_set_3386((void *)(v8 + 4536), (v82 >> 17));
          if ((v82 >> 17) != (v82 + 8) >> 17) {
            bit_vector_set_3386((void *)(v8 + 4536), (v81 >> 17) + 1);
          }
          --v79;
        }
        while (v79);
      }
      unint64_t v94 = v75;
      unsigned int v31 = v93;
      if (v75) {
        goto LABEL_27;
      }
    }
    uint64_t result = (uint64_t)__error();
    *(_DWORD *)(a2 + 4) = *(_DWORD *)result;
    return result;
  }
  unint64_t v23 = HIDWORD(v20);
  if (v23)
  {
    if (v23 != 1)
    {
      if (v23 == 3) {
        return mergeEntryFat(result, a2);
      }
      __int16 v89 = __si_assert_copy_extra_1921(0);
      CFIndex v90 = v89;
      if (v89) {
        int v91 = v89;
      }
      else {
        int v91 = "";
      }
      __message_assert("%s:%u: Unexpected code path %s ", "BurstTrie.c", 1275, v91);
      free(v90);
      goto LABEL_126;
    }
    uint64_t result = mergeEntry(result, (_DWORD *)a2, v21, a4 + 1, a5 - 1, a6, v22);
    if (!*(_DWORD *)(a2 + 4))
    {
      uint64_t v57 = *(void *)(v8 + 8) + 1028 * a3 + 4 * *a4;
      unsigned int v59 = *(_DWORD *)(v57 + 4);
      int v44 = (unsigned int *)(v57 + 4);
      char v58 = v59;
      unsigned int v60 = v59 >> 1;
      unsigned int v61 = v59 >> 3;
      int v62 = v59 & 7;
      unsigned int v63 = v59 >> 2;
      if ((v59 & 3) == 1)
      {
        int v62 = 1;
        unsigned int v61 = v63;
      }
      BOOL v64 = (v58 & 1) == 0;
      if (v58) {
        int v65 = v62;
      }
      else {
        int v65 = 0;
      }
      if (!v64) {
        unsigned int v60 = v61;
      }
      if (v60 != result || v65 != HIDWORD(result))
      {
        unsigned int v67 = HIDWORD(result) | (8 * result);
        if (!HIDWORD(result)) {
          unsigned int v67 = 2 * result;
        }
        if (HIDWORD(result) == 1) {
          unsigned int v54 = (4 * result) | 1;
        }
        else {
          unsigned int v54 = v67;
        }
        if ((v54 & 3) == 1) {
          char v68 = 2;
        }
        else {
          char v68 = 3;
        }
        if ((v54 & 1) == 0) {
          char v68 = 1;
        }
        if (v54 >> v68 != result)
        {
          unint64_t v85 = __si_assert_copy_extra_1921(0);
          uint64_t v86 = v85;
          int v87 = "";
          if (v85) {
            int v87 = v85;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.h", 81, "ptrM(newptr).next == ptr.next", v87);
          free(v86);
          if (!__valid_fs(-1))
          {
            uint64_t v88 = 3072;
LABEL_128:
            *(_DWORD *)uint64_t v88 = -559038737;
            abort();
          }
LABEL_126:
          uint64_t v88 = 2989;
          goto LABEL_128;
        }
        goto LABEL_90;
      }
    }
    return result;
  }
  unsigned int v35 = *v12;
  LODWORD(v36) = v35 >> 1;
  unsigned int v37 = v35 >> 3;
  unint64_t v38 = (unint64_t)(v35 & 7) << 32;
  if ((v35 & 3) == 1)
  {
    unint64_t v38 = 0x100000000;
    unsigned int v37 = v35 >> 2;
  }
  BOOL v39 = (v35 & 1) == 0;
  if (v35) {
    unint64_t v40 = v38;
  }
  else {
    unint64_t v40 = 0;
  }
  if (v39) {
    uint64_t v36 = v36;
  }
  else {
    uint64_t v36 = v37;
  }
  unint64_t v95 = v40 | v36;
  uint64_t v41 = (a5 - 1);
  uint64_t result = mergeEntryFlat(result);
  if (result)
  {
    if (*(_DWORD *)(a2 + 4)) {
      return result;
    }
    uint64_t result = burst2(v8, a2, v95);
    if (*(_DWORD *)(a2 + 4)) {
      return result;
    }
    uint64_t result = bt_mergeEntry(v8, a2, result, a6, a4 + 1, v41);
    unint64_t v95 = result;
    if (*(_DWORD *)(a2 + 4)) {
      return result;
    }
    uint64_t v42 = *(void *)(v8 + 8) + 1028 * a3 + 4 * *a4;
    uint64_t result = ptrD(result);
    *(_DWORD *)(v42 + 4) = result;
  }
  uint64_t v43 = *(void *)(v8 + 8) + 1028 * a3 + 4 * *a4;
  unsigned int v46 = *(_DWORD *)(v43 + 4);
  int v44 = (unsigned int *)(v43 + 4);
  char v45 = v46;
  unsigned int v47 = v46 >> 1;
  unsigned int v48 = v46 >> 3;
  int v49 = v46 & 7;
  unsigned int v50 = v46 >> 2;
  if ((v46 & 3) == 1)
  {
    int v49 = 1;
    unsigned int v48 = v50;
  }
  BOOL v51 = (v45 & 1) == 0;
  if (v45) {
    int v52 = v49;
  }
  else {
    int v52 = 0;
  }
  if (!v51) {
    unsigned int v47 = v48;
  }
  if (v95 != v47 || HIDWORD(v95) != v52)
  {
    unsigned int v54 = (4 * v95) | 1;
    unsigned int v55 = HIDWORD(v95) | (8 * v95);
    if (!HIDWORD(v95)) {
      unsigned int v55 = 2 * v95;
    }
    if (HIDWORD(v95) != 1) {
      unsigned int v54 = v55;
    }
    if ((v54 & 3) == 1) {
      char v56 = 2;
    }
    else {
      char v56 = 3;
    }
    if ((v54 & 1) == 0) {
      char v56 = 1;
    }
    if (v54 >> v56 == v95)
    {
LABEL_90:
      *int v44 = v54;
      return result;
    }
    goto LABEL_117;
  }
  return result;
}

uint64_t mergeEntry(uint64_t a1, _DWORD *a2, unsigned int a3, unsigned __int8 *a4, int a5, _DWORD *a6, unint64_t a7)
{
  unint64_t v14 = a3;
  uint64_t v15 = mgetBase(a1, a3);
  if (!a5)
  {
    int v33 = *(_DWORD *)v15;
    if (!*(_DWORD *)v15)
    {
      int v33 = a2[2];
      *(_DWORD *)uint64_t v15 = v33;
      if (!*a2) {
        a2[2] = v33 + 1;
      }
    }
    *a6 = v33;
    return a7;
  }
  unint64_t v16 = *a4;
  if (!*a4)
  {
    unint64_t v71 = __si_assert_copy_extra_1921(0);
    unint64_t v72 = v71;
    uint64_t v73 = "";
    if (v71) {
      uint64_t v73 = v71;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1580, "*string", v73);
LABEL_94:
    free(v72);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if ((*(_DWORD *)(v15 + ((v16 >> 3) & 0x1C) + 4) >> v16))
  {
    uint64_t v17 = 0;
    unsigned int v18 = (int8x8_t *)(v15 + 4);
    unint64_t v19 = v16 >> 6;
    if ((v16 >> 6) != 1)
    {
      if (v19 != 2)
      {
        if (v19 != 3) {
          goto LABEL_10;
        }
        uint8x8_t v20 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v15 + 20));
        v20.i16[0] = vaddlv_u8(v20);
        uint64_t v17 = v20.u32[0];
      }
      uint8x8_t v21 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v15 + 12));
      v21.i16[0] = vaddlv_u8(v21);
      v17 += v21.u32[0];
    }
    uint8x8_t v22 = (uint8x8_t)vcnt_s8(*v18);
    v22.i16[0] = vaddlv_u8(v22);
    v17 += v22.u32[0];
LABEL_10:
    uint8x8_t v23 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v18[v19] & ~(-1 << v16)));
    v23.i16[0] = vaddlv_u8(v23);
    uint64_t v24 = v23.u32[0] + v17;
    uint64_t v25 = v15 + 4 * v24;
    unsigned int v28 = *(_DWORD *)(v25 + 38);
    uint64_t v27 = (unsigned int *)(v25 + 38);
    unsigned int v26 = v28;
    if ((v28 & 1) == 0)
    {
      unint64_t v79 = v26 >> 1;
      goto LABEL_12;
    }
    if ((v26 & 3) != 1)
    {
      unint64_t v79 = (v26 >> 3) | ((unint64_t)(v26 & 7) << 32);
      int v43 = v26 & 7;
      if (!v43)
      {
LABEL_12:
        unint64_t v29 = a4 + 1;
        uint64_t v30 = (a5 - 1);
        if (mergeEntryFlat(a1))
        {
          unint64_t v31 = v79;
          if (a2[1]) {
            return v31;
          }
          unint64_t v31 = burst2(a1, (uint64_t)a2, v79);
          if (a2[1]) {
            return v31;
          }
          uint64_t v32 = HIDWORD(v31) == 1 ? mergeEntry(a1, a2) : bt_mergeEntry(a1, a2, v31, a6, v29, v30);
          unint64_t v31 = v32;
          uint64_t v80 = v32;
          if (a2[1]) {
            return v31;
          }
          uint64_t v60 = mgetBase(a1, v14) + 4 * v24;
          unsigned int v63 = *(_DWORD *)(v60 + 38);
          int v62 = (_DWORD *)(v60 + 38);
          char v61 = v63;
          unsigned int v64 = v63 >> 1;
          unsigned int v65 = v63 >> 3;
          int v66 = v63 & 7;
          unsigned int v67 = v63 >> 2;
          if ((v63 & 3) == 1)
          {
            int v66 = 1;
            unsigned int v65 = v67;
          }
          BOOL v68 = (v61 & 1) == 0;
          if (v61) {
            int v69 = v66;
          }
          else {
            int v69 = 0;
          }
          if (!v68) {
            unsigned int v64 = v65;
          }
          if (v80 != v64 || HIDWORD(v80) != v69) {
            _DWORD *v62 = ptrD(v80);
          }
          return a7;
        }
        unsigned int v35 = *v27 >> 1;
        unsigned int v36 = *v27 >> 3;
        int v37 = *v27 & 7;
        if ((*v27 & 3) == 1)
        {
          int v37 = 1;
          unsigned int v36 = *v27 >> 2;
        }
        if (*v27) {
          int v38 = v37;
        }
        else {
          int v38 = 0;
        }
        if (*v27) {
          unsigned int v35 = v36;
        }
        if (v79 != v35 || HIDWORD(v79) != v38)
        {
          unsigned int v40 = (4 * v79) | 1;
          unsigned int v41 = HIDWORD(v79) | (8 * v79);
          if (!HIDWORD(v79)) {
            unsigned int v41 = 2 * v79;
          }
          if (HIDWORD(v79) != 1) {
            unsigned int v40 = v41;
          }
          if ((v40 & 3) == 1) {
            char v42 = 2;
          }
          else {
            char v42 = 3;
          }
          if ((v40 & 1) == 0) {
            char v42 = 1;
          }
          if (v40 >> v42 == v79)
          {
            *uint64_t v27 = v40;
            return a7;
          }
          goto LABEL_97;
        }
        return a7;
      }
      if (v43 != 1)
      {
        if (v43 != 3)
        {
          unsigned int v76 = __si_assert_copy_extra_1921(0);
          unsigned int v77 = v76;
          if (v76) {
            char v78 = v76;
          }
          else {
            char v78 = "";
          }
          __message_assert("%s:%u: Unexpected code path %s ", "BurstTrie.c", 1664, v78);
          free(v77);
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        mergeEntryFat(a1, a2);
        return a7;
      }
    }
    unint64_t v44 = mergeEntry(a1, a2);
    unint64_t v31 = v44;
    if (a2[1]) {
      return v31;
    }
    unint64_t v45 = HIDWORD(v44);
    uint64_t v46 = mgetBase(a1, v14) + 4 * v24;
    unsigned int v49 = *(_DWORD *)(v46 + 38);
    unsigned int v47 = (unsigned int *)(v46 + 38);
    char v48 = v49;
    unsigned int v50 = v49 >> 1;
    unsigned int v51 = v49 >> 3;
    int v52 = v49 & 7;
    unsigned int v53 = v49 >> 2;
    if ((v49 & 3) == 1)
    {
      int v52 = 1;
      unsigned int v51 = v53;
    }
    BOOL v54 = (v48 & 1) == 0;
    if (v48) {
      int v55 = v52;
    }
    else {
      int v55 = 0;
    }
    if (!v54) {
      unsigned int v50 = v51;
    }
    if (v50 != v31 || v55 != v45)
    {
      unsigned int v57 = (4 * v31) | 1;
      unsigned int v58 = v45 | (8 * v31);
      if (!v45) {
        unsigned int v58 = 2 * v31;
      }
      if (v45 != 1) {
        unsigned int v57 = v58;
      }
      if ((v57 & 3) == 1) {
        char v59 = 2;
      }
      else {
        char v59 = 3;
      }
      if ((v57 & 1) == 0) {
        char v59 = 1;
      }
      if (v57 >> v59 == v31)
      {
        *unsigned int v47 = v57;
        return a7;
      }
LABEL_97:
      char v74 = __si_assert_copy_extra_1921(0);
      unint64_t v72 = v74;
      unint64_t v75 = "";
      if (v74) {
        unint64_t v75 = v74;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.h", 81, "ptrM(newptr).next == ptr.next", v75);
      goto LABEL_94;
    }
    return a7;
  }
  return _mergeEntryNoFollows(a1, (uint64_t)a2, a3, a4, a5, (uint64_t)a6, a7);
}

uint64_t _mergeEntryNoFollows(uint64_t a1, uint64_t a2, unsigned int a3, unsigned __int8 *a4, int a5, uint64_t a6, unint64_t a7)
{
  uint64_t v130 = *MEMORY[0x1E4F143B8];
  unsigned int v12 = a7;
  unint64_t v113 = HIDWORD(a7);
  uint64_t v13 = mgetBase(a1, a3);
  unsigned int v14 = *(unsigned __int8 *)(v13 + 36);
  if (*(unsigned __int8 *)(v13 + 37) != v14)
  {
LABEL_37:
    uint64_t v109 = mgetBase(a1, v12);
    unsigned int v107 = set_follows(v109, *a4);
    if (*(_DWORD *)a2)
    {
      uint64_t v44 = a2;
      unint64_t v45 = (unint64_t *)(a2 + 2148);
      unint64_t v46 = *(void *)(a2 + 2148);
      long long v128 = 0u;
      long long v129 = 0u;
      long long v126 = 0u;
      long long v127 = 0u;
      long long v124 = 0u;
      long long v125 = 0u;
      long long v122 = 0u;
      long long v123 = 0u;
      long long v120 = 0u;
      long long v121 = 0u;
      long long v118 = 0u;
      long long v119 = 0u;
      int v117 = 0;
      unint64_t v47 = flatStoreNewBlockForCompact(a1 + 160, v46, (uint64_t)&v118, &v117);
      uint64_t v48 = v117;
      if (v117 >= 1)
      {
        unsigned int v49 = (unint64_t *)&v118;
        do
        {
          unint64_t v51 = *v49++;
          unint64_t v50 = v51;
          bit_vector_set_3386((void *)(a1 + 4536), (v51 >> 17));
          if ((v51 >> 17) != (v51 + 8) >> 17) {
            bit_vector_set_3386((void *)(a1 + 4536), (v50 >> 17) + 1);
          }
          --v48;
        }
        while (v48);
      }
      uint64_t v116 = v47;
      *unint64_t v45 = v47;
      if (v47)
      {
LABEL_44:
        if (mergeEntryFlat(a1))
        {
          if (*(_DWORD *)(v44 + 4)) {
            return v116;
          }
          int v52 = __si_assert_copy_extra_1921(0);
          unsigned int v53 = v52;
          BOOL v54 = "";
          if (v52) {
            BOOL v54 = v52;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1540, "ms->err", v54);
LABEL_124:
          free(v53);
          if (__valid_fs(-1)) {
            uint64_t v106 = 2989;
          }
          else {
            uint64_t v106 = 3072;
          }
          *(_DWORD *)uint64_t v106 = -559038737;
          abort();
        }
        unsigned int v62 = HIDWORD(v116) | (8 * v116);
        if (!HIDWORD(v116)) {
          unsigned int v62 = 2 * v116;
        }
        if (HIDWORD(v116) == 1) {
          unsigned int v63 = (4 * v116) | 1;
        }
        else {
          unsigned int v63 = v62;
        }
        if ((v63 & 3) == 1) {
          char v64 = 2;
        }
        else {
          char v64 = 3;
        }
        if ((v63 & 1) == 0) {
          char v64 = 1;
        }
        if (v63 >> v64 != v116)
        {
          long long v102 = __si_assert_copy_extra_1921(0);
          unsigned int v53 = v102;
          long long v103 = "";
          if (v102) {
            long long v103 = v102;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.h", 81, "ptrM(newptr).next == ptr.next", v103);
          goto LABEL_124;
        }
        *(_DWORD *)(v109 + 4 * v107 + 38) = v63;
        LODWORD(v116) = v12;
LABEL_67:
        HIDWORD(v116) = v113;
        return v116;
      }
    }
    else
    {
      long long v128 = 0u;
      long long v129 = 0u;
      long long v126 = 0u;
      long long v127 = 0u;
      long long v124 = 0u;
      long long v125 = 0u;
      long long v122 = 0u;
      long long v123 = 0u;
      long long v120 = 0u;
      long long v121 = 0u;
      long long v118 = 0u;
      long long v119 = 0u;
      int v55 = 64;
      int v117 = 0;
      do
      {
        unsigned int v56 = v55;
        v55 *= 2;
      }
      while (v56 < a5 + 22);
      unint64_t v57 = storageAllocOffset(a1 + 160, v56, (uint64_t)&v118, &v117);
      if (v57)
      {
        unint64_t v58 = v57;
        uint64_t v44 = a2;
        uint64_t v59 = storageResolvePtr(a1 + 160, v57, v56, 1);
        *(_WORD *)uint64_t v59 = 0;
        char v60 = __clz(__rbit32(v56 >> 6));
        if (!v56) {
          char v60 = -1;
        }
        *(unsigned char *)(v59 + 2) = v60;
        uint64_t v61 = (v58 >> 6);
      }
      else
      {
        uint64_t v44 = a2;
        uint64_t v61 = 0;
      }
      uint64_t v65 = v117;
      if (v117 >= 1)
      {
        int v66 = (unint64_t *)&v118;
        do
        {
          unint64_t v68 = *v66++;
          unint64_t v67 = v68;
          bit_vector_set_3386((void *)(a1 + 4536), (v68 >> 17));
          if ((v68 >> 17) != (v68 + 8) >> 17) {
            bit_vector_set_3386((void *)(a1 + 4536), (v67 >> 17) + 1);
          }
          --v65;
        }
        while (v65);
      }
      uint64_t v116 = v61;
      if (v61) {
        goto LABEL_44;
      }
    }
    *(_DWORD *)(v44 + 4) = *__error();
    return v116;
  }
  HIDWORD(v15) = *(unsigned __int8 *)(v13 + 36);
  LODWORD(v15) = v14 - 4;
  __int16 v16 = 16;
  switch((v15 >> 2))
  {
    case 0u:
      __int16 v16 = 8;
      goto LABEL_5;
    case 1u:
      goto LABEL_5;
    case 3u:
      __int16 v16 = 32;
LABEL_5:
      if (v12 != a3)
      {
        long long v100 = __si_assert_copy_extra_1921(0);
        unsigned int v53 = v100;
        long long v101 = "";
        if (v100) {
          long long v101 = v100;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1442, "old==s", v101);
        goto LABEL_124;
      }
      uint64_t v17 = (4 * v16 + 41) & 0x1E8;
      unint64_t v18 = mmalloc((4 * v16 + 41) & 0x1E8, a1 + 16, *(uint64_t (**)(uint64_t))(a2 + 2160), *(void *)(a2 + 2168));
      if (!v18) {
        goto LABEL_31;
      }
      unint64_t v19 = v18;
      unint64_t v20 = v18 >> 2;
      uint64_t v21 = mgetBase(a1, v18 >> 2);
      if (v17 >= 0x20)
      {
        uint64_t v22 = v17 - 8;
        *(_OWORD *)uint64_t v21 = 0u;
        *(_OWORD *)(v21 + 16) = 0u;
        if (v17 != 40)
        {
          *(_OWORD *)(v21 + 32) = 0uLL;
          *(_OWORD *)(v21 + 48) = 0uLL;
          if (v17 != 72)
          {
            *(_OWORD *)(v21 + 64) = 0uLL;
            *(_OWORD *)(v21 + 80) = 0uLL;
            if (v17 != 104)
            {
              *(_OWORD *)(v21 + 96) = 0uLL;
              *(_OWORD *)(v21 + 112) = 0uLL;
              if (v17 != 136)
              {
                *(_OWORD *)(v21 + 128) = 0uLL;
                *(_OWORD *)(v21 + 144) = 0uLL;
              }
            }
          }
        }
      }
      else
      {
        uint64_t v22 = 0;
      }
      uint64_t v29 = v22 - v17;
      uint64_t v30 = (void *)(v21 + v22);
      do
      {
        *v30++ = 0;
        v29 += 8;
      }
      while (v29);
      *(unsigned char *)(v21 + 37) = v16;
      if (!v20)
      {
LABEL_31:
        *(_DWORD *)(a2 + 4) = *__error();
        LODWORD(v116) = 0;
        goto LABEL_67;
      }
      unsigned int v111 = v20;
      unint64_t v31 = (unsigned char *)mgetBase(a1, (v19 >> 2));
      uint64_t v32 = (const void *)mgetBase(a1, a7);
      memcpy(v31, v32, 4 * v14 + 38);
      v31[37] = v16;
      uint64_t v33 = (4 * a7) & 0xFFFFFFFC;
      unsigned int v34 = (4 * (_WORD)v14 + 41) & 0x7FC;
      unsigned int v35 = *(_DWORD *)(a1 + 24);
      BOOL v36 = v34 >= v35;
      unsigned int v37 = v34 - v35;
      if (v37 != 0 && v36)
      {
        unsigned int v38 = __clz(v37);
        BOOL v40 = (v37 & (v37 - 1)) != 0 || v37 == 0;
        int v41 = v40 - v38 + 28;
      }
      else
      {
        int v41 = 0;
      }
      unsigned int v12 = v111;
      if (v33 + (8 << v41) == *(void *)(a1 + 32))
      {
        *(void *)(a1 + 32) = 4 * (int)a7;
      }
      else
      {
        uint64_t v42 = *(void *)(a1 + 16);
        if (*(_DWORD *)(a1 + 128) < v41) {
          *(_DWORD *)(a1 + 128) = v41;
        }
        uint64_t v43 = a1 + 4 * v41;
        *(_DWORD *)(v42 + v33) = *(_DWORD *)(v43 + 48);
        *(_DWORD *)(v43 + 48) = 4 * a7;
      }
      goto LABEL_37;
    case 7u:
      if (v12 != a3)
      {
        long long v104 = __si_assert_copy_extra_1921(0);
        unsigned int v53 = v104;
        long long v105 = "";
        if (v104) {
          long long v105 = v104;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1463, "old==s", v105);
        goto LABEL_124;
      }
      uint64_t v23 = v13;
      unint64_t v24 = *(unsigned int *)(a1 + 148);
      unsigned int v25 = *(_DWORD *)(a1 + 144) + 1;
      if (v25 < v24) {
        goto LABEL_78;
      }
      uint64_t v26 = *(void *)(a2 + 2168);
      uint64_t v27 = *(uint64_t (**)(uint64_t))(a2 + 2160);
      *(void *)&long long v118 = 0;
      int v28 = expandUnsafeMapNew((void **)(a1 + 8), *(void *)(a1 + 4576), v24, 0x404uLL, (unint64_t *)&v118, v27, v26);
      if (v28)
      {
        *__error() = v28;
        goto LABEL_13;
      }
      *(_DWORD *)(a1 + 148) = v118;
LABEL_78:
      *(_DWORD *)(a1 + 144) = v25;
      if (!v25)
      {
LABEL_13:
        *(_DWORD *)(a2 + 4) = *__error();
        return 0x300000000;
      }
      uint64_t v70 = 0;
      unint64_t v71 = (int8x8_t *)(v23 + 4);
      unsigned int v72 = v25;
      uint64_t v73 = 1028 * v25 + 4;
      break;
    default:
      goto LABEL_37;
  }
  do
  {
    if (((*(_DWORD *)(v23 + 4 * (v70 >> 5) + 4) >> v70) & 1) == 0)
    {
      uint64_t v74 = *(void *)(a1 + 8);
      *(_DWORD *)(v74 + v73 + 4 * v70) = 0;
      goto LABEL_81;
    }
    uint64_t v75 = 0;
    unsigned int v76 = v70 >> 6;
    if (v70 >> 6 == 1) {
      goto LABEL_88;
    }
    if (v76 == 2) {
      goto LABEL_87;
    }
    if (v76 == 3)
    {
      uint8x8_t v77 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v23 + 20));
      v77.i16[0] = vaddlv_u8(v77);
      uint64_t v75 = v77.u32[0];
LABEL_87:
      uint8x8_t v78 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v23 + 12));
      v78.i16[0] = vaddlv_u8(v78);
      v75 += v78.u32[0];
LABEL_88:
      uint8x8_t v79 = (uint8x8_t)vcnt_s8(*v71);
      v79.i16[0] = vaddlv_u8(v79);
      v75 += v79.u32[0];
    }
    uint8x8_t v80 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v71[v76] & ~(-1 << v70)));
    v80.i16[0] = vaddlv_u8(v80);
    uint64_t v81 = v80.u32[0] + v75;
    uint64_t v74 = *(void *)(a1 + 8);
    *(_DWORD *)(v74 + v73 + 4 * v70) = *(_DWORD *)(v23 + 4 * v81 + 38);
LABEL_81:
    ++v70;
  }
  while (v70 != 256);
  *(_DWORD *)(v74 + 1028 * v25) = *(_DWORD *)v23;
  if (*(_DWORD *)a2)
  {
    uint64_t v108 = a2;
    unsigned int v110 = v25;
    unsigned int v112 = v25;
    long long v114 = a4;
    unint64_t v82 = (unint64_t *)(a2 + 2148);
    unint64_t v83 = *(void *)(a2 + 2148);
    long long v128 = 0u;
    long long v129 = 0u;
    long long v126 = 0u;
    long long v127 = 0u;
    long long v124 = 0u;
    long long v125 = 0u;
    long long v122 = 0u;
    long long v123 = 0u;
    long long v120 = 0u;
    long long v121 = 0u;
    long long v118 = 0u;
    long long v119 = 0u;
    int v117 = 0;
    unint64_t v84 = flatStoreNewBlockForCompact(a1 + 160, v83, (uint64_t)&v118, &v117);
    uint64_t v85 = v117;
    if (v117 >= 1)
    {
      uint64_t v86 = (unint64_t *)&v118;
      do
      {
        unint64_t v88 = *v86++;
        unint64_t v87 = v88;
        bit_vector_set_3386((void *)(a1 + 4536), (v88 >> 17));
        if ((v88 >> 17) != (v88 + 8) >> 17) {
          bit_vector_set_3386((void *)(a1 + 4536), (v87 >> 17) + 1);
        }
        --v85;
      }
      while (v85);
    }
    uint64_t v116 = v84;
    *unint64_t v82 = v84;
    a2 = v108;
    unsigned int v72 = v110;
    a4 = v114;
    unsigned int v25 = v112;
    if (v84) {
      goto LABEL_97;
    }
LABEL_114:
    *(_DWORD *)(a2 + 4) = *__error();
  }
  else
  {
    long long v128 = 0u;
    long long v129 = 0u;
    long long v126 = 0u;
    long long v127 = 0u;
    long long v124 = 0u;
    long long v125 = 0u;
    long long v122 = 0u;
    long long v123 = 0u;
    long long v120 = 0u;
    long long v121 = 0u;
    long long v118 = 0u;
    long long v119 = 0u;
    int v92 = 64;
    int v117 = 0;
    do
    {
      unsigned int v93 = v92;
      v92 *= 2;
    }
    while (v93 < a5 + 22);
    unint64_t v94 = storageAllocOffset(a1 + 160, v93, (uint64_t)&v118, &v117);
    if (v94)
    {
      unint64_t v95 = v94;
      uint64_t v96 = storageResolvePtr(a1 + 160, v94, v93, 1);
      *(_WORD *)uint64_t v96 = 0;
      char v97 = __clz(__rbit32(v93 >> 6));
      if (!v93) {
        char v97 = -1;
      }
      *(unsigned char *)(v96 + 2) = v97;
      uint64_t v98 = (v95 >> 6);
    }
    else
    {
      uint64_t v98 = 0;
    }
    if (v117) {
      dirtyStorageOffsets(a1 + 160, (unint64_t *)&v118, v117);
    }
    uint64_t v116 = v98;
    if (!v98) {
      goto LABEL_114;
    }
LABEL_97:
    if (mergeEntryFlat(a1))
    {
      if (!*(_DWORD *)(a2 + 4))
      {
        __int16 v89 = __si_assert_copy_extra_1921(0);
        CFIndex v90 = v89;
        int v91 = "";
        if (v89) {
          int v91 = v89;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1504, "ms->err", v91);
        free(v90);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
    }
    else
    {
      uint64_t v99 = *(void *)(a1 + 8) + 1028 * v72 + 4 * *a4;
      *(_DWORD *)(v99 + 4) = ptrD(v116);
      mfree((4 * a7), (4 * (_WORD)v14 + 41) & 0x7FC, (uint64_t *)(a1 + 16));
      return v25 | 0x300000000;
    }
  }
  return v116;
}

uint64_t bt_mergeSet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, unsigned int *a8, unsigned __int8 a9, uint64_t a10, uint64_t a11)
{
  uint64_t v332 = *MEMORY[0x1E4F143B8];
  bzero(v326, 0x848uLL);
  uint64_t v293 = a3;
  unsigned int v15 = *(_DWORD *)(a3 + 4456);
  long long v325 = 0u;
  uint64_t v327 = a10;
  uint64_t v328 = a11;
  *(_OWORD *)&v326[1044] = 0u;
  v324[0] = (int *)a1;
  v324[1] = 0;
  void v324[3] = 0;
  v324[2] = (int *)v15;
  ++generation;
  double Current = CFAbsoluteTimeGetCurrent();
  int v17 = *__error();
  unint64_t v18 = _SILogForLogForCategory(10);
  unint64_t v19 = &unk_1E9FC9000;
  os_log_type_t v20 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v18, v20))
  {
    *(_WORD *)iovec buf = 0;
    _os_log_impl(&dword_1BD672000, v18, v20, "Merge update set ... ", buf, 2u);
  }
  *__error() = v17;
  currentSet = (uint64_t)a7;
  currentCFIndex Count = 0;
  if (__THREAD_SLOT_KEY)
  {
    uint64_t v21 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v21) {
      goto LABEL_5;
    }
  }
  else
  {
    makeThreadId();
    uint64_t v21 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v21)
    {
LABEL_5:
      if ((unint64_t)v21 < 0x801) {
        goto LABEL_6;
      }
    }
  }
  makeThreadId();
  uint64_t v21 = pthread_getspecific(__THREAD_SLOT_KEY);
LABEL_6:
  long long v303 = (unsigned char *)(a1 + 4588);
  uint64_t v22 = (uint64_t)v21 - 1;
  uint64_t v23 = malloc_type_zone_calloc((malloc_zone_t *)indexingZone, 1uLL, 0x38uLL, 0x10A0040FEFBC11AuLL);
  *uint64_t v23 = a1;
  v23[1] = a7;
  CIOnThreadCleanUpPush(v22, (uint64_t)TrieMergeCleanup, (uint64_t)v23);
  HIDWORD(v25) = qos_class_self() - 9;
  LODWORD(v25) = HIDWORD(v25);
  unsigned int v24 = v25 >> 2;
  if (v24 > 6) {
    signed int v26 = 0;
  }
  else {
    signed int v26 = dword_1BDA87810[v24];
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4600));
  if (*(void *)(a1 + 4784) || *(_DWORD *)(a1 + 4796) || *(unsigned char *)(a1 + 4812)) {
    goto LABEL_12;
  }
  if (v26 > 5)
  {
LABEL_106:
    *(void *)(a1 + 4784) = pthread_self();
    *(unsigned char *)(a1 + 4812) = 1;
    goto LABEL_13;
  }
  if (!*(void *)(a1 + 16 * v26 + 4664))
  {
    uint64_t v93 = v26 - 1;
    unint64_t v94 = (uint64_t *)(a1 + 16 * v26 + 4680);
    while (v93 != 4)
    {
      uint64_t v95 = *v94;
      v94 += 2;
      ++v93;
      if (v95)
      {
        if (v93 <= 4) {
          goto LABEL_12;
        }
        goto LABEL_106;
      }
    }
    goto LABEL_106;
  }
LABEL_12:
  db_rwlock_wait(a1 + 4600, v26, 3);
LABEL_13:
  v301 = (pthread_mutex_t *)(a1 + 4600);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4600));
  *((unsigned char *)v23 + 49) = 1;
  db_read_lock((uint64_t)(a7 + 38));
  *((unsigned char *)v23 + 48) = 1;
  long long v304 = (unsigned int (*)(uint64_t))a7[74];
  uint64_t v306 = a7[75];
  unsigned int v27 = atomic_load((unsigned int *)(a7[3] + 16));
  uint64_t v288 = a1;
  if (!v27 && !a7[10] && !a7[6])
  {
LABEL_326:
    uint64_t v36 = 0;
    goto LABEL_327;
  }
  uint64_t v289 = a4;
  long long v296 = a7;
  unint64_t v28 = atomic_load((unsigned int *)(a7[3] + 16));
  uint64_t v29 = malloc_type_zone_malloc((malloc_zone_t *)indexingZone, 8 * (v28 + 1), 0x2004093837F09uLL);
  v23[2] = v29;
  uint64_t v30 = v23;
  unint64_t v31 = malloc_type_zone_malloc((malloc_zone_t *)indexingZone, 16 * (v28 + 1), 0x1000040451B5BE8uLL);
  void v23[3] = v31;
  uint64_t v32 = (long long *)malloc_type_zone_malloc((malloc_zone_t *)indexingZone, 16 * (v28 + 1), 0x1000040451B5BE8uLL);
  v30[5] = v32;
  uint64_t v33 = malloc_type_zone_calloc((malloc_zone_t *)indexingZone, v28 + 1, 0x18uLL, 0x10200409F4E64B8uLL);
  *(void *)long long v295 = v30;
  v30[4] = v33;
  if (v29) {
    BOOL v34 = v31 == 0;
  }
  else {
    BOOL v34 = 1;
  }
  if (v34 || v33 == 0)
  {
    uint64_t v36 = 0xFFFFFFFFLL;
    goto LABEL_327;
  }
  size_t v297 = (size_t)v33;
  __base = v31;
  uint64_t v292 = v22;
  int v37 = *__error();
  unsigned int v38 = _SILogForLogForCategory(10);
  os_log_type_t v39 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v38, v39))
  {
    *(_DWORD *)iovec buf = 134217984;
    *(void *)&uint8_t buf[4] = v28;
    _os_log_impl(&dword_1BD672000, v38, v39, "Merge %lu terms", buf, 0xCu);
  }
  *__error() = v37;
  if (v304(v306) == -1)
  {
    int v59 = *__error();
    char v60 = _SILogForLogForCategory(10);
    os_log_type_t v61 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v60, v61))
    {
      *(_WORD *)iovec buf = 0;
LABEL_54:
      _os_log_impl(&dword_1BD672000, v60, v61, "Merge Canceled", buf, 2u);
    }
LABEL_55:
    *__error() = v59;
    uint64_t v36 = 89;
    uint64_t v22 = v292;
    goto LABEL_327;
  }
  double v41 = CFAbsoluteTimeGetCurrent();
  uint64_t v42 = v296[3];
  *(void *)&__n[1] = 0;
  *(void *)&__n[3] = &__n[1];
  LODWORD(__src[1]) = 0;
  __src[0] = (void *)0x2000000000;
  *(void *)iovec buf = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&uint8_t buf[16] = ___hashTableIterate_block_invoke;
  *(void *)&uint8_t buf[24] = &unk_1E6343AA0;
  *(void *)&buf[32] = &__n[1];
  *(void *)&buf[40] = v29;
  _TermTrieWalkFatWithOptions(v42 + 32, 0, 1, 0, (uint64_t)buf, 0, 0);
  _Block_object_dispose(&__n[1], 8);
  int v43 = *__error();
  uint64_t v44 = _SILogForLogForCategory(10);
  os_log_type_t v45 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v44, v45))
  {
    CFAbsoluteTime v46 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)iovec buf = 134217984;
    *(double *)&uint8_t buf[4] = v46 - v41;
    _os_log_impl(&dword_1BD672000, v44, v45, "Copied term data: %f seconds", buf, 0xCu);
  }
  *__error() = v43;
  if (v304(v306) == -1)
  {
    int v59 = *__error();
    char v60 = _SILogForLogForCategory(10);
    os_log_type_t v61 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v60, v61))
    {
      *(_WORD *)iovec buf = 0;
      goto LABEL_54;
    }
    goto LABEL_55;
  }
  uint64_t v47 = *(void *)v293;
  unint64_t v283 = *(void *)(v293 + 8);
  double v48 = CFAbsoluteTimeGetCurrent();
  __n[0] = 0;
  if (v28)
  {
    LODWORD(v49) = 0;
    unsigned int v50 = 0;
    unsigned int v51 = 0;
    int v52 = __base;
    do
    {
      while (1)
      {
        unsigned int v53 = &v52[4 * v51];
        unsigned int *v53 = v49;
        unint64_t Offset = bt_getOffset(a1, *(unsigned __int16 *)(v29[v49] + 16), v29[v49] + 18, __n);
        *((void *)v53 + 1) = Offset;
        uint64_t v49 = (v49 + 1);
        if (!Offset) {
          break;
        }
        if (v49 < v28)
        {
          size_t v55 = __n[0];
          while (1)
          {
            uint64_t v56 = v29[v49];
            if (v55 >= *(unsigned __int16 *)(v56 + 16)
              || memcmp((const void *)(v29[*v53] + 18), (const void *)(v56 + 18), v55))
            {
              break;
            }
            if (v28 == ++v49)
            {
              LODWORD(v49) = v28;
              break;
            }
          }
          int v52 = __base;
        }
        v52[4 * v51++ + 1] = v49;
        if (v49 >= v28) {
          goto LABEL_47;
        }
      }
      unint64_t v57 = &v32[v50];
      *(_DWORD *)unint64_t v57 = *v53;
      *((_DWORD *)v57 + 2) = 0;
      if (v49 < v28)
      {
        while (!bt_getOffset(a1, *(unsigned __int16 *)(v29[v49] + 16), v29[v49] + 18, __n))
        {
          if (v28 == ++v49)
          {
            LODWORD(v49) = v28;
            break;
          }
        }
      }
      DWORD1(v32[v50++]) = v49;
    }
    while (v49 < v28);
LABEL_47:
    if (v51 > v28)
    {
      long long v261 = __si_assert_copy_extra_1921(0);
      char v259 = v261;
      long long v262 = "";
      if (v261) {
        long long v262 = v261;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 2531, "j<=count", v262);
      goto LABEL_352;
    }
    if (v50 > v28)
    {
LABEL_82:
      long long v264 = __si_assert_copy_extra_1921(0);
      __message_assert("%s:%u: failed assertion '%s' %s ");
      goto LABEL_356;
    }
    size_t v58 = v51;
  }
  else
  {
    unsigned int v51 = 0;
    unsigned int v50 = 0;
    size_t v58 = 0;
    int v52 = v31;
  }
  if (v50 + v51 > v28)
  {
    uint64_t v258 = __si_assert_copy_extra_1921(0);
    char v259 = v258;
    long long v260 = "";
    if (v258) {
      long long v260 = v258;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 2533, "j+z<=count", v260);
    goto LABEL_352;
  }
  uint64_t v282 = v47;
  qsort(v52, v58, 0x10uLL, (int (__cdecl *)(const void *, const void *))mergeRangeCompare);
  if (v50)
  {
    uint64_t v62 = v50;
    unsigned int v63 = v32;
    uint64_t v22 = v292;
    do
    {
      unsigned int v64 = v51 + 1;
      long long v65 = *v63++;
      *(_OWORD *)&v52[4 * v51++] = v65;
      --v62;
    }
    while (v62);
  }
  else
  {
    unsigned int v64 = v51;
    uint64_t v22 = v292;
  }
  unsigned int v284 = v64;
  *(void *)(*(void *)v295 + 40) = 0;
  free(v32);
  int v66 = *__error();
  unint64_t v67 = _SILogForLogForCategory(10);
  os_log_type_t v68 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v67, v68))
  {
    CFAbsoluteTime v69 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)iovec buf = 134217984;
    *(double *)&uint8_t buf[4] = v69 - v48;
    _os_log_impl(&dword_1BD672000, v67, v68, "Computed ranges: %f seconds", buf, 0xCu);
  }
  *__error() = v66;
  if (v304(v306) == -1)
  {
    int v90 = *__error();
    int v91 = _SILogForLogForCategory(10);
    unint64_t v19 = &unk_1E9FC9000;
    os_log_type_t v92 = 2 * (dword_1E9FC90CC < 4);
    if (!os_log_type_enabled(v91, v92))
    {
LABEL_98:
      *__error() = v90;
      uint64_t v36 = 89;
      goto LABEL_327;
    }
    *(_WORD *)iovec buf = 0;
LABEL_97:
    _os_log_impl(&dword_1BD672000, v91, v92, "Merge Canceled", buf, 2u);
    goto LABEL_98;
  }
  double v70 = CFAbsoluteTimeGetCurrent();
  db_upgrade_lock((uint64_t)v301);
  if (v284)
  {
    uint64_t v71 = 0;
    int v310 = 0;
    unsigned int v72 = 0;
    BOOL v73 = 1;
    uint64_t v74 = (char *)__base;
    while (1)
    {
      BOOL v285 = v73;
      pthread_mutex_lock(v301);
      *(unsigned char *)(a1 + 4812) = 1;
      db_rwlock_wakeup((uint64_t)v301, 1, 1);
      pthread_mutex_unlock(v301);
      if (v71)
      {
        uint64_t v75 = &v74[16 * v71];
        unint64_t v76 = *((void *)v75 + 1);
        unint64_t v77 = (unint64_t)v76 << 6;
        if (HIDWORD(v76)) {
          unint64_t v77 = 0;
        }
        unint64_t v78 = *((void *)v75 - 1);
        BOOL v79 = (unint64_t)v78 << 6 > v77 && HIDWORD(v78) == 0;
        BOOL v80 = v79 || v78 == 0;
        if (v80 && v76 != 0) {
          goto LABEL_82;
        }
      }
      db_upgrade_lock((uint64_t)v301);
      unint64_t v82 = v74;
      unint64_t v83 = &v74[16 * v71];
      unint64_t v84 = *(unsigned int *)&v82[16 * v71];
      unsigned int v86 = *((_DWORD *)v83 + 1);
      uint64_t v85 = (unsigned int *)(v83 + 4);
      if (v84 < v86) {
        break;
      }
LABEL_68:
      BOOL v73 = ++v71 < (unint64_t)v284;
      uint64_t v74 = (char *)__base;
      if (v71 == v284)
      {
        BOOL v285 = 0;
        goto LABEL_109;
      }
    }
    unint64_t v87 = (void *)(v297 + 8 + 24 * v84);
    while (1)
    {
      unsigned int v88 = bt_mergeCallback(*(unsigned __int16 *)(v29[v84] + 16), (void *)(v29[v84] + 18), v324);
      if (!v88) {
        break;
      }
      if (v88 > v72) {
        unsigned int v72 = v88;
      }
      *((_DWORD *)v87 - 2) = v88;
      void *v87 = v29[v84];
      if (*(_DWORD *)(a1 + 4592)) {
        BOOL v89 = v310 <= 9999;
      }
      else {
        BOOL v89 = 0;
      }
      if (v89) {
        v310 += db_writer_yield_lock((uint64_t)v301);
      }
      ++v84;
      v87 += 3;
      if (v84 >= *v85) {
        goto LABEL_68;
      }
    }
  }
  else
  {
    BOOL v285 = 0;
    unsigned int v72 = 0;
    int v310 = 0;
  }
  uint64_t v74 = (char *)__base;
LABEL_109:
  *(void *)(*(void *)v295 + 32) = 0;
  uint64_t v314 = (unsigned int *)v297;
  unint64_t v315 = v28;
  unint64_t v316 = v28;
  uint64_t v317 = v72;
  if (a5) {
    directoryStoreMergeUpdateSet(a5, v296 + 6, (uint64_t)&v314);
  }
  if (a6)
  {
    if (_os_feature_enabled_impl()) {
      long long v286 = (void *)v296[10];
    }
    else {
      long long v286 = 0;
    }
    if (__THREAD_SLOT_KEY)
    {
      unint64_t v96 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v96) {
        goto LABEL_361;
      }
    }
    else
    {
      makeThreadId();
      unint64_t v96 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v96) {
        goto LABEL_361;
      }
    }
    if (v96 < 0x801)
    {
      int v97 = 0;
LABEL_119:
      if (v96 <= 0x800)
      {
        uint64_t v98 = &threadData[18 * v96];
        int v97 = *(v98 - 11);
        *(v98 - 11) = 1;
      }
LABEL_121:
      int v281 = v97;
      if (__THREAD_SLOT_KEY)
      {
        unint64_t v99 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v99) {
          goto LABEL_364;
        }
      }
      else
      {
        makeThreadId();
        unint64_t v99 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v99) {
          goto LABEL_364;
        }
      }
      if (v99 < 0x801)
      {
        int v100 = 0;
LABEL_125:
        if (v99 <= 0x800)
        {
          long long v101 = &threadData[18 * v99];
          int v100 = *(v101 - 11);
          *(v101 - 11) = 1;
        }
LABEL_127:
        int v280 = v100;
        if (*(unsigned char *)(a6 + 13) && v286[2])
        {
          int v102 = *__error();
          long long v103 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
          {
            double v220 = (void *)(a6 + 128);
            if (*(char *)(a6 + 151) < 0) {
              double v220 = (void *)*v220;
            }
            __int16 v221 = (void *)(a6 + 104);
            if (*(char *)(a6 + 127) < 0) {
              __int16 v221 = (void *)*v221;
            }
            uint64_t v222 = v286[2];
            *(_DWORD *)iovec buf = 136316162;
            *(void *)&uint8_t buf[4] = "mergeUpdateSet";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 4386;
            *(_WORD *)&buf[18] = 2080;
            *(void *)&buf[20] = v220;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = v221;
            *(_WORD *)&buf[38] = 2048;
            *(void *)&buf[40] = v222;
            _os_log_error_impl(&dword_1BD672000, v103, OS_LOG_TYPE_ERROR, "%s:%d: [%s] mergeUpdateSet readonly %s updateSet %zu", buf, 0x30u);
          }
          *__error() = v102;
          if (*(unsigned char *)(a6 + 13))
          {
            if (v286[2])
            {
              long long v266 = __si_assert_copy_extra_329();
              long long v264 = v266;
              long long v267 = "";
              if (v266) {
                long long v267 = v266;
              }
              __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 4387, "!fReadOnly || updateSet->vectorIndexes.size() == 0", v267);
LABEL_356:
              free(v264);
              if (__valid_fs(-1)) {
                uint64_t v265 = 2989;
              }
              else {
                uint64_t v265 = 3072;
              }
              *(_DWORD *)uint64_t v265 = -559038737;
              abort();
            }
          }
        }
        long long v104 = (void *)*v286;
        if ((void *)*v286 != v286 + 1)
        {
          while (1)
          {
            uint64_t v105 = v104[5];
            uint64_t v106 = (std::__shared_weak_count *)v104[6];
            if (v106) {
              atomic_fetch_add_explicit(&v106->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v322 = 0;
            v323 = 0;
            int v107 = *(_DWORD *)(v105 + 12);
            if (v107 == 512) {
              int v108 = 1;
            }
            else {
              int v108 = 3;
            }
            if (v107 == 768) {
              int v108 = 2;
            }
            if (v107 == 256) {
              int v109 = 0;
            }
            else {
              int v109 = v108;
            }
            int v110 = *(_DWORD *)(v105 + 16);
            if (v110 == 2) {
              int v111 = 1;
            }
            else {
              int v111 = 3;
            }
            if (v110 == 4) {
              int v112 = 0;
            }
            else {
              int v112 = v111;
            }
            IVFVectorIndex_s::getOrCreateVectorIndex(&v322, a6 + 8, *(unsigned int *)(v105 + 8), *(unsigned __int16 *)(v105 + 20), v109, v112, *(unsigned __int8 *)(v105 + 22));
            *(_OWORD *)&__n[1] = 0uLL;
            __src[0] = 0;
            (*(void (**)(uint8_t *__return_ptr))(*(void *)v322 + 312))(buf);
            if ((buf[23] & 0x80u) == 0) {
              unint64_t v113 = buf;
            }
            else {
              unint64_t v113 = *(uint8_t **)buf;
            }
            size_t v114 = strlen((const char *)v113);
            if (v114 >= 0x7FFFFFFFFFFFFFF8) {
              abort();
            }
            size_t v115 = v114;
            if (v114 >= 0x17) {
              break;
            }
            HIBYTE(__src[0]) = v114;
            uint64_t v116 = &__n[1];
            if (v114) {
              goto LABEL_161;
            }
LABEL_162:
            *((unsigned char *)v116 + v115) = 0;
            if ((char)buf[23] < 0) {
              operator delete(*(void **)buf);
            }
            uint64_t v119 = v322;
            (*(void (**)(uint64_t, uint64_t, void *, unsigned int **))(*(void *)v322 + 96))(v322, v105, v296 + 11, &v314);
            int v120 = *__error();
            long long v121 = _SILogForLogForCategory(16);
            if (os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v122 = a6 + 128;
              if (*(char *)(a6 + 151) < 0) {
                uint64_t v122 = *(void *)(a6 + 128);
              }
              char v321 = 3;
              LODWORD(__p[0]) = 4085052;
              (*(void (**)(unsigned char *__return_ptr, uint64_t, void **))(*(void *)v105 + 312))(v329, v105, __p);
              if (v330 >= 0) {
                long long v123 = v329;
              }
              else {
                long long v123 = *(unsigned char **)v329;
              }
              if (SHIBYTE(__src[0]) >= 0) {
                long long v124 = &__n[1];
              }
              else {
                long long v124 = *(_DWORD **)&__n[1];
              }
              int v125 = (*(uint64_t (**)(uint64_t))(*(void *)v119 + 16))(v119);
              *(_DWORD *)iovec buf = 136316162;
              *(void *)&uint8_t buf[4] = v122;
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v286;
              *(_WORD *)&buf[22] = 2080;
              *(void *)&uint8_t buf[24] = v123;
              *(_WORD *)&buf[32] = 2080;
              *(void *)&buf[34] = v124;
              *(_WORD *)&buf[42] = 1024;
              *(_DWORD *)&buf[44] = v125;
              _os_log_impl(&dword_1BD672000, v121, OS_LOG_TYPE_DEFAULT, "[%s] mergeUpdateSet %p %s to %s total %u", buf, 0x30u);
              if (v330 < 0) {
                operator delete(*(void **)v329);
              }
              if (v321 < 0) {
                operator delete(__p[0]);
              }
            }
            *__error() = v120;
            if (SHIBYTE(__src[0]) < 0) {
              operator delete(*(void **)&__n[1]);
            }
            long long v126 = v323;
            uint64_t v74 = (char *)__base;
            if (v323 && !atomic_fetch_add(&v323->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v126->__on_zero_shared)(v126);
              std::__shared_weak_count::__release_weak(v126);
              if (!v106)
              {
LABEL_183:
                long long v127 = (void *)v104[1];
                if (!v127) {
                  goto LABEL_189;
                }
                goto LABEL_184;
              }
            }
            else if (!v106)
            {
              goto LABEL_183;
            }
            if (atomic_fetch_add(&v106->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
              goto LABEL_183;
            }
            ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
            std::__shared_weak_count::__release_weak(v106);
            long long v127 = (void *)v104[1];
            if (!v127)
            {
              do
              {
LABEL_189:
                long long v128 = (void *)v104[2];
                BOOL v34 = *v128 == (void)v104;
                long long v104 = v128;
              }
              while (!v34);
              goto LABEL_134;
            }
            do
            {
LABEL_184:
              long long v128 = v127;
              long long v127 = (void *)*v127;
            }
            while (v127);
LABEL_134:
            long long v104 = v128;
            if (v128 == v286 + 1) {
              goto LABEL_192;
            }
          }
          uint64_t v117 = (v114 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v114 | 7) != 0x17) {
            uint64_t v117 = v114 | 7;
          }
          uint64_t v118 = v117 + 1;
          uint64_t v116 = operator new(v117 + 1);
          *(void *)&__n[3] = v115;
          __src[0] = (void *)(v118 | 0x8000000000000000);
          *(void *)&__n[1] = v116;
LABEL_161:
          memmove(v116, v113, v115);
          goto LABEL_162;
        }
LABEL_192:
        if (__THREAD_SLOT_KEY)
        {
          unint64_t v129 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
          if (!v129) {
            goto LABEL_367;
          }
        }
        else
        {
          makeThreadId();
          unint64_t v129 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
          if (!v129) {
            goto LABEL_367;
          }
        }
        if (v129 < 0x801)
        {
LABEL_195:
          if (v129 <= 0x800) {
            threadData[18 * v129 - 11] = v280;
          }
LABEL_197:
          if (__THREAD_SLOT_KEY)
          {
            unint64_t v130 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
            if (!v130) {
              goto LABEL_370;
            }
          }
          else
          {
            makeThreadId();
            unint64_t v130 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
            if (!v130) {
              goto LABEL_370;
            }
          }
          if (v130 < 0x801)
          {
            int v131 = v281;
LABEL_201:
            if (v130 <= 0x800) {
              threadData[18 * v130 - 11] = v131;
            }
            goto LABEL_203;
          }
LABEL_370:
          makeThreadId();
          unint64_t v130 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
          int v131 = v281;
          if (!v130) {
            goto LABEL_203;
          }
          goto LABEL_201;
        }
LABEL_367:
        makeThreadId();
        unint64_t v129 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v129) {
          goto LABEL_197;
        }
        goto LABEL_195;
      }
LABEL_364:
      makeThreadId();
      unint64_t v99 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
      int v100 = 0;
      if (!v99) {
        goto LABEL_127;
      }
      goto LABEL_125;
    }
LABEL_361:
    makeThreadId();
    unint64_t v96 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
    int v97 = 0;
    if (!v96) {
      goto LABEL_121;
    }
    goto LABEL_119;
  }
LABEL_203:
  long long v132 = v314;
  unint64_t v133 = v315;
  *(void *)(*(void *)v295 + 32) = v314;
  unsigned int v134 = v317;
  if (v310)
  {
    int v135 = *__error();
    long long v136 = _SILogForLogForCategory(10);
    os_log_type_t v137 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v136, v137))
    {
      *(_DWORD *)iovec buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v310;
      _os_log_impl(&dword_1BD672000, v136, v137, "Flush yielded %d times.", buf, 8u);
    }
    *__error() = v135;
    uint64_t v74 = (char *)__base;
  }
  if (v285)
  {
    uint64_t v36 = 0xFFFFFFFFLL;
    unint64_t v19 = (_DWORD *)&unk_1E9FC9000;
    uint64_t v22 = v292;
    goto LABEL_327;
  }
  uint64_t v22 = v292;
  if (a8)
  {
    unsigned int v138 = v284;
    if (v284 <= 0x200) {
      unsigned int v138 = 0;
    }
    *a8 = v138;
  }
  uint64_t v139 = v293 + 40;
  *(void *)(*(void *)v295 + 24) = 0;
  free(v74);
  int v140 = (void *)v296[29];
  unint64_t v19 = &unk_1E9FC9000;
  if (v140)
  {
    do
    {
      __int16 v141 = (void *)*v140;
      madvise(v140, v140[2] - (void)v140, 4);
      int v140 = v141;
    }
    while (v141);
  }
  unsigned int v142 = *(_DWORD *)(v293 + 4456);
  BOOL v143 = v134 >= v142;
  unsigned int v144 = v134 - v142;
  if (v143)
  {
    uint64_t v36 = termIdStoreAllocBulk(v139, v144 + 1);
    if (v36) {
      goto LABEL_327;
    }
  }
  unsigned int v145 = *(_DWORD *)(v289 + 4456);
  BOOL v143 = v134 >= v145;
  unsigned int v146 = v134 - v145;
  if (v143)
  {
    uint64_t v36 = termIdStoreAllocBulk(v289 + 40, v146 + 1);
    if (v36) {
      goto LABEL_327;
    }
  }
  __basea = (void *)(v289 + 40);
  if (v133)
  {
    *(void *)&v132[6 * v133 + 2] = *(void *)&v132[6 * v133 - 4];
    db_downgrade_lock(v301);
  }
  *(void *)(*(void *)v295 + 16) = 0;
  free(v29);
  storageDeactivateAll(v288 + 160, 0);
  storageUnmap(v288 + 160);
  db_write_unlock((uint64_t)v301);
  *(unsigned char *)(*(void *)v295 + 49) = 0;
  int v147 = *__error();
  unsigned int v148 = _SILogForLogForCategory(10);
  os_log_type_t v149 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v148, v149))
  {
    CFAbsoluteTime v150 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)iovec buf = 134217984;
    *(double *)&uint8_t buf[4] = v150 - v70;
    _os_log_impl(&dword_1BD672000, v148, v149, "Merged terms: %f seconds", buf, 0xCu);
  }
  *__error() = v147;
  unint64_t v151 = (void *)v289;
  if (v304(v306) == -1)
  {
    int v90 = *__error();
    int v91 = _SILogForLogForCategory(10);
    os_log_type_t v92 = 2 * (dword_1E9FC90CC < 4);
    uint64_t v22 = v292;
    if (!os_log_type_enabled(v91, v92)) {
      goto LABEL_98;
    }
    *(_WORD *)iovec buf = 0;
    goto LABEL_97;
  }
  uint64_t v22 = v292;
  if (v133 >= 2) {
    _qsort_termids((uint64_t)v132, v133 - 1);
  }
  double v152 = CFAbsoluteTimeGetCurrent();
  long long v153 = v296;
  uint64_t v154 = atomic_load((unsigned int *)v296 + 25);
  uint64_t v155 = compressPostings(v293, v154, v153[11], v153[1], v133, (uint64_t)v132, *((unsigned int *)v153 + 4), a10, a11);
  if (v155)
  {
    uint64_t v36 = v155;
    int v156 = *__error();
    int v157 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)iovec buf = 136315650;
      *(void *)&uint8_t buf[4] = "TrieMergeUpdates";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2902;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v36;
      _os_log_error_impl(&dword_1BD672000, v157, OS_LOG_TYPE_ERROR, "%s:%d: compressPostings err:%d", buf, 0x18u);
    }
    *__error() = v156;
    goto LABEL_327;
  }
  storageUnmap(v139);
  double v158 = CFAbsoluteTimeGetCurrent() - v152;
  *(double *)&TrieMergeUpdates_postingsCompressionTime = *(double *)&TrieMergeUpdates_postingsCompressionTime + v158;
  int v159 = *__error();
  long long v160 = _SILogForLogForCategory(10);
  os_log_type_t v161 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v160, v161))
  {
    *(_DWORD *)iovec buf = 134218240;
    *(double *)&uint8_t buf[4] = v158;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = TrieMergeUpdates_postingsCompressionTime;
    _os_log_impl(&dword_1BD672000, v160, v161, "Compressed postings data: %f seconds %f total", buf, 0x16u);
  }
  *__error() = v159;
  __p[0] = 0;
  uint64_t v162 = _fd_acquire_fd(*(void *)(v293 + 4488), __p);
  uint64_t v163 = v162;
  unint64_t v164 = *(void *)(v293 + 8);
  uint64_t v165 = v283 - v164;
  if (v283 <= v164)
  {
    sync_invalidate_fd(v162, v282, *(void *)v293 - v282);
    unint64_t v164 = *(void *)(v293 + 8);
    uint64_t v165 = *(void *)(v293 + 24) - v164;
  }
  sync_invalidate_fd(v163, v164, v165);
  uint64_t v22 = v292;
  uint64_t v166 = v289 + 40;
  fsync(v163);
  _fd_release_fd(*(_DWORD **)(v293 + 4488), v163, 0, (uint64_t)__p[0]);
  if (!v133) {
    goto LABEL_325;
  }
  uint64_t v167 = *(void *)v289;
  unint64_t v168 = *(void *)(v289 + 8);
  double v169 = CFAbsoluteTimeGetCurrent();
  unsigned int v170 = *v132;
  if (*v132 <= v132[6 * v133 - 6]) {
    unsigned int v170 = v132[6 * v133 - 6];
  }
  unsigned int v171 = *(_DWORD *)(v289 + 4456);
  BOOL v143 = v170 >= v171;
  unsigned int v172 = v170 - v171;
  if (!v143 || (uint64_t v36 = termIdStoreAllocBulk((uint64_t)__basea, v172 + 1), !v36))
  {
    unint64_t v294 = v168;
    uint64_t v290 = v167;
    memset(buf, 0, 40);
    PayloadWriteBufferInit(buf, (_DWORD *)v289);
    uint64_t v173 = *(void *)(v289 + 8);
    *(_OWORD *)&__n[1] = 0u;
    *(_OWORD *)long long __src = 0u;
    ci_position_run_init((uint64_t)&__n[1]);
    if (*(void *)&buf[32]) {
      goto LABEL_320;
    }
    unint64_t v174 = 0;
    int v307 = 0;
    int v311 = 0;
    long long v305 = (char *)(v296 + 30);
    while (1)
    {
      unint64_t v175 = &v132[6 * v174];
      unint64_t v178 = (unsigned char *)*((void *)v175 + 1);
      uint64_t v177 = v175 + 2;
      uint64_t v176 = v178;
      if ((*v178 & 1) != 0 || (unsigned int v179 = *((_DWORD *)v176 + 3)) == 0)
      {
        uint64_t v192 = 0;
        ++v174;
        uint64_t v166 = v289 + 40;
        goto LABEL_304;
      }
      unsigned int v180 = atomic_load((unsigned int *)v296 + 62);
      if (v179 >= v180)
      {
        uint64_t v166 = v289 + 40;
LABEL_318:
        if (v311) {
          PayloadWritePulseHeader((int *)buf, v151, v173 - v151[1], v307);
        }
LABEL_320:
        free(*(void **)buf);
        free(__src[1]);
        int v223 = *__error();
        v224 = _SILogForLogForCategory(10);
        os_log_type_t v225 = 2 * (v19[51] < 4);
        if (os_log_type_enabled(v224, v225))
        {
          float v226 = CFAbsoluteTimeGetCurrent() - v169;
          *(_DWORD *)v329 = 134217984;
          *(double *)&v329[4] = v226;
          _os_log_impl(&dword_1BD672000, v224, v225, "flush positions %f", v329, 0xCu);
        }
        *__error() = v223;
        *(void *)v329 = 0;
        uint64_t v227 = _fd_acquire_fd(v151[561], v329);
        uint64_t v228 = v227;
        unint64_t v229 = v151[1];
        uint64_t v230 = v294 - v229;
        if (v294 <= v229)
        {
          sync_invalidate_fd(v227, v290, *v151 - v290);
          unint64_t v229 = v151[1];
          uint64_t v230 = v151[3] - v229;
        }
        sync_invalidate_fd(v228, v229, v230);
        fsync(v228);
        _fd_release_fd((_DWORD *)v151[561], v228, 0, *(uint64_t *)v329);
        uint64_t v36 = *(unsigned int *)&buf[32];
        if (!*(_DWORD *)&buf[32])
        {
LABEL_325:
          storageUnmap(v166);
          int v231 = _fd_acquire_fd(v151[561], __p);
          fsync(v231);
          _fd_release_fd((_DWORD *)v151[561], v231, 0, (uint64_t)__p[0]);
          goto LABEL_326;
        }
        break;
      }
      unsigned int v181 = *(_DWORD *)(*(void *)v177 + 12);
      unsigned int v182 = atomic_load((unsigned int *)v296 + 62);
      if (v181 >= v182)
      {
        long long v264 = __si_assert_copy_extra_1921(0);
        atomic_load((unsigned int *)v296 + 62);
        __message_assert("%s:%u: failed assertion '%s' %s termId: %d next_term_id: %d");
        goto LABEL_356;
      }
      uint64_t v183 = *(void *)v305;
      uint64_t v184 = *(void *)v177;
      uint64_t v185 = v132[6 * v174];
      uint64_t v186 = *(unsigned int *)(v184 + 12);
      uint64_t v187 = 8 * v185;
      uint64_t v188 = *(void *)storageResolvePtr((uint64_t)__basea, 8 * v185, 8, 1);
      __n[1] = 0;
      v329[0] = 0;
      unint64_t v189 = v174 + 1;
      if (v174 + 1 >= v133)
      {
        unsigned int v191 = v307;
      }
      else
      {
        uint64_t v190 = (uint64_t)&v132[6 * v174 + 8];
        unsigned int v191 = v307;
        do
        {
          if ((**(unsigned char **)v190 & 1) == 0 && *(_DWORD *)(*(void *)v190 + 12))
          {
            unsigned int v191 = v132[6 * v189];
            goto LABEL_259;
          }
          ++v189;
          v190 += 24;
        }
        while (v133 != v189);
        unint64_t v189 = v133;
      }
LABEL_259:
      BOOL v193 = v189 == v133;
      if (v189 == v133) {
        unsigned int v191 = v185;
      }
      unsigned int v194 = v185 - v191;
      if (v185 != v191) {
        BOOL v193 = 0;
      }
      if (v185 <= v191 && !v193)
      {
        long long v264 = __si_assert_copy_extra_1921(0);
        __message_assert("%s:%u: failed assertion '%s' %s termId: %d prevTermId: %d j: %ld count: %ld", "BurstTrie.c");
        goto LABEL_356;
      }
      double v195 = (char *)__src[1];
      int v300 = v185;
      if (v194 > 0x7F)
      {
        if (v194 >> 14)
        {
          if (v194 >> 21)
          {
            if (v194 >> 28)
            {
              *(unsigned char *)__src[1] = -16;
              *(_DWORD *)(v195 + 1) = v194;
              uint64_t v196 = 5;
            }
            else
            {
              *(unsigned char *)__src[1] = HIBYTE(v194) | 0xE0;
              v195[1] = BYTE2(v194);
              v195[2] = BYTE1(v194);
              v195[3] = v194;
              uint64_t v196 = 4;
            }
          }
          else
          {
            *(unsigned char *)__src[1] = BYTE2(v194) | 0xC0;
            v195[1] = BYTE1(v194);
            v195[2] = v194;
            uint64_t v196 = 3;
          }
        }
        else
        {
          *(unsigned char *)__src[1] = BYTE1(v194) | 0x80;
          v195[1] = v194;
          uint64_t v196 = 2;
        }
      }
      else
      {
        *(unsigned char *)__src[1] = v194;
        uint64_t v196 = 1;
      }
      int v307 = v191;
      uint64_t v197 = v196;
      if (v188) {
        uint64_t v197 = v2_writeVInt64((uint64_t)v195, v196, (2 * v188) | 1);
      }
      uint64_t v309 = v196;
      uint64_t v198 = v183 + 32 * v186;
      unint64_t v199 = (char *)v2_writeVInt64((uint64_t)v195, v197, 2 * *(void *)(v198 + 16));
      __src[0] = v199;
      if (!*(_DWORD *)v198 && !*(_DWORD *)(v198 + 4))
      {
        if (*(void *)(v198 + 16))
        {
          long long v271 = v199 + 1;
          size_t v272 = *(void *)&__n[3];
          while ((unint64_t)v271 >= v272)
          {
            v272 *= 2;
            double v195 = (char *)malloc_type_realloc(v195, v272, 0x485463EBuLL);
            if (!v195)
            {
              long long v273 = __si_assert_copy_extra_1921(0);
              char v259 = v273;
              uint64_t v274 = "";
              if (v273) {
                uint64_t v274 = v273;
              }
              __message_assert("%s:%u: failed assertion '%s' %s ", "CIPositionRun.h", 75, "run->buffer", v274);
              goto LABEL_352;
            }
          }
          int v275 = v329[0];
          long long v276 = __si_assert_copy_extra_1921(0);
          char v259 = v276;
          long long v277 = "";
          if (v276) {
            long long v277 = v276;
          }
          if (v275) {
            __message_assert("%s:%u: failed assertion '%s' %s ", "CIPositionRun.h", 78, "len == 0 || bytes[len-1]==0", v277);
          }
          else {
            __message_assert("%s:%u: failed assertion '%s' %s ", "CIPositionRun.h", 77, "bytes[0]!=0", v277);
          }
        }
        else
        {
          long long v278 = __si_assert_copy_extra_1921(0);
          char v259 = v278;
          long long v279 = "";
          if (v278) {
            long long v279 = v278;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 2263, "node->offset", v279);
        }
LABEL_352:
        long long v263 = v259;
LABEL_353:
        free(v263);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      unint64_t v302 = v187;
      uint64_t v200 = (unsigned int *)v296 + 67;
      unsigned int v201 = atomic_load((unsigned int *)v296 + 67);
      CIBuildPositionRun(v305, a2, v198, (uint64_t)&__n[1], a9);
      atomic_store(v201, v200);
      int64_t v202 = (int64_t)__src[0];
      int v203 = (char *)__src[0] + 21;
      uint64_t v204 = *(void *)(v289 + 8);
      unint64_t v19 = (_DWORD *)&unk_1E9FC9000;
      if ((char *)__src[0] + 21 <= (void *)(v204 - *(void *)v289) || *(void *)&buf[32])
      {
        uint64_t v211 = *(void *)&buf[24];
        unint64_t v151 = (void *)v289;
        uint64_t v205 = v289 + 40;
        uint64_t v206 = v309;
      }
      else
      {
        long long v298 = __src[0];
        unint64_t v151 = (void *)v289;
        uint64_t v205 = v289 + 40;
        uint64_t v206 = v309;
        if (!v311
          || (PayloadWritePulseHeader((int *)buf, (void *)v289, v173 - v204, v300), (uint64_t v207 = *(void *)&buf[32]) == 0))
        {
          int v208 = growPayloadData(v289);
          uint64_t v207 = v208;
          *(void *)&buf[32] = v208;
        }
        int v311 = 0;
        uint64_t v173 = *(void *)(v289 + 8);
        unint64_t v209 = v173 - *(void *)v289;
        unint64_t v210 = *(void *)&buf[8];
        uint64_t v211 = (v173 - *(_DWORD *)v289);
        if (v209 >= *(void *)&buf[8]) {
          uint64_t v211 = *(void *)&buf[8];
        }
        *(void *)&uint8_t buf[16] = v211;
        *(void *)&uint8_t buf[24] = v211;
        if ((unint64_t)v203 <= v209)
        {
          uint64_t v204 = v173;
LABEL_297:
          int64_t v202 = (int64_t)v298;
          goto LABEL_298;
        }
        uint64_t v204 = v173;
        int64_t v202 = (int64_t)v298;
        if (!v207)
        {
          do
          {
            int v212 = growPayloadData(v289);
            uint64_t v173 = *(void *)(v289 + 8);
            unint64_t v213 = v173 - *(void *)v289;
          }
          while ((unint64_t)v203 > v213 && v212 == 0);
          int v311 = 0;
          if (v213 >= v210) {
            uint64_t v211 = v210;
          }
          else {
            uint64_t v211 = (v173 - *(_DWORD *)v289);
          }
          *(void *)&uint8_t buf[16] = v211;
          *(void *)&uint8_t buf[24] = v211;
          *(void *)&buf[32] = v212;
          uint64_t v204 = v173;
          uint64_t v205 = v289 + 40;
          uint64_t v206 = v309;
          goto LABEL_297;
        }
      }
LABEL_298:
      if (v211 < 2)
      {
        int64_t v219 = v202;
        _PayloadWriteData((int *)buf, v151, v329, 1);
        int64_t v202 = v219;
        int64_t v215 = *(void *)&buf[24];
      }
      else
      {
        v151[1] = v204 - 1;
        int64_t v215 = v211 - 1;
        *(void *)&uint8_t buf[24] = v215;
        *(unsigned char *)(*(void *)buf + v215) = v329[0];
      }
      uint64_t v22 = v292;
      char v216 = __src[1];
      BOOL v89 = v215 <= v202;
      int64_t v217 = v215 - v202;
      if (v89)
      {
        _PayloadWriteData((int *)buf, v151, (char *)__src[1], v202);
      }
      else
      {
        v151[1] -= v202;
        *(void *)&uint8_t buf[24] = v217;
        memcpy((void *)(*(void *)buf + v217), v216, v202);
      }
      unint64_t v218 = v151[1] + v206;
      if (v218 >> 62)
      {
        long long v268 = __si_assert_copy_extra_1921(0);
        long long v269 = v268;
        long long v270 = "";
        if (v268) {
          long long v270 = v268;
        }
        __message_assert("%s:%u: failed assertion '%s' %s write invalid offset %llu", "TermIdStore.h", 97, "offset <= OFFSET_VALUE_MASK", v270, v218);
        long long v263 = v269;
        goto LABEL_353;
      }
      ++v311;
      bit_vector_set_1980((void *)(v289 + 4464), v302 / *MEMORY[0x1E4F14B00], 1u);
      uint64_t v166 = v205;
      *(void *)storageResolvePtr(v205, v302, 8, 1) = v218;
      uint64_t v192 = *(void *)&buf[32];
      unint64_t v174 = v189;
LABEL_304:
      if (v174 >= v133 || v192) {
        goto LABEL_318;
      }
    }
  }
LABEL_327:
  CIOnThreadCleanUpPop(v22);
  ++thingCount;
  if (!v36)
  {
    *long long v303 = 1;
    double v232 = CFAbsoluteTimeGetCurrent();
    int v233 = *__error();
    uint64_t v234 = _SILogForLogForCategory(10);
    os_log_type_t v235 = 2 * (v19[51] < 4);
    if (os_log_type_enabled(v234, v235))
    {
      *(_WORD *)iovec buf = 0;
      _os_log_impl(&dword_1BD672000, v234, v235, "Done", buf, 2u);
    }
    double v236 = v232 - Current;
    *__error() = v233;
    int v237 = *__error();
    double v238 = _SILogForLogForCategory(10);
    os_log_type_t v239 = 2 * (v19[51] < 4);
    if (os_log_type_enabled(v238, v239))
    {
      float v240 = v236;
      *(_DWORD *)iovec buf = 134217984;
      *(double *)&uint8_t buf[4] = v240;
      _os_log_impl(&dword_1BD672000, v238, v239, "Merge took %f seconds", buf, 0xCu);
    }
    *__error() = v237;
    *(double *)&bt_mergeSet_accTime = *(double *)&bt_mergeSet_accTime + v236;
    int v241 = *__error();
    uint64_t v242 = _SILogForLogForCategory(10);
    os_log_type_t v243 = 2 * (v19[51] < 4);
    if (os_log_type_enabled(v242, v243))
    {
      float v244 = *(double *)&bt_mergeSet_accTime;
      *(_DWORD *)iovec buf = 134217984;
      *(double *)&uint8_t buf[4] = v244;
      _os_log_impl(&dword_1BD672000, v242, v243, "Total merge time: %f seconds", buf, 0xCu);
    }
    *__error() = v241;
    if (gSILogLevels[0] >= 5)
    {
      int v246 = *__error();
      __int16 v247 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v247, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v248 = *(void *)(v288 + 32);
        double v249 = (double)v248 * 100.0 / (double)*(unint64_t *)(v288 + 40);
        *(_DWORD *)iovec buf = 134218240;
        *(void *)&uint8_t buf[4] = v248 >> 10;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(double *)&buf[14] = v249;
        _os_log_impl(&dword_1BD672000, v247, OS_LOG_TYPE_DEFAULT, "Mapped Bases: %luKB (%f%% used)", buf, 0x16u);
      }
      *__error() = v246;
      if (gSILogLevels[0] >= 5)
      {
        int v250 = *__error();
        __int16 v251 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v251, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v253 = *(_DWORD *)(v288 + 144);
          uint64_t v252 = *(unsigned int *)(v288 + 148);
          *(_DWORD *)iovec buf = 134218496;
          *(void *)&uint8_t buf[4] = ((unint64_t)(257 * v252) >> 8) & 0x3FFFFFFFFFFFFFLL;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v253;
          *(_WORD *)&buf[18] = 2048;
          *(double *)&buf[20] = (double)v253 * 100.0 / (double)v252;
          _os_log_impl(&dword_1BD672000, v251, OS_LOG_TYPE_DEFAULT, "Sparse Bases: %luKB for %d entries (%f%% used)", buf, 0x1Cu);
        }
        *__error() = v250;
        if (gSILogLevels[0] >= 5)
        {
          int v254 = *__error();
          uint64_t v255 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v255, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v256 = *(void *)(v288 + 384);
            float v257 = (double)*(unint64_t *)(v288 + 392) * 100.0 / (double)v256;
            *(_DWORD *)iovec buf = 134218240;
            *(void *)&uint8_t buf[4] = v256 >> 10;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(double *)&buf[14] = v257;
            _os_log_impl(&dword_1BD672000, v255, OS_LOG_TYPE_DEFAULT, "String arrays: %lluKB %f%% used", buf, 0x16u);
          }
          *__error() = v254;
        }
      }
    }
  }
  return v36;
}

void _qsort_termids(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = malloc_type_malloc(0x800uLL, 0x1000040451B5BE8uLL);
  uint64_t v5 = 0;
  *uint64_t v4 = 0;
  v4[1] = 0;
  uint64_t v6 = a1 + 28;
  uint64_t v7 = 1;
  do
  {
    if (a2 > v5)
    {
      if (v7 <= 128) {
        uint64_t v9 = 128;
      }
      else {
        uint64_t v9 = v7;
      }
      while (1)
      {
        unint64_t v10 = a2 - v5;
        if (a2 - v5 <= 16) {
          break;
        }
        size_t v11 = v10 + 1;
        unsigned int v12 = (char *)(a1 + 24 * v5);
        uint64_t v13 = &v12[24 * ((v10 + 1) >> 1)];
        unsigned int v14 = (unsigned int *)(a1 + 24 * a2);
        if (v10 < 0x400)
        {
          unint64_t v19 = (char *)(a1 + 24 * v5);
          unint64_t v28 = v13;
          uint64_t v29 = (unsigned int *)(a1 + 24 * a2);
        }
        else
        {
          size_t v15 = v11 >> 3;
          __int16 v16 = &v12[24 * (v11 >> 3)];
          unsigned int v17 = *(_DWORD *)v12;
          unsigned int v18 = *(_DWORD *)v16;
          unint64_t v19 = (char *)(a1 + 24 * v5);
          if (*(_DWORD *)v16 != *(_DWORD *)v12)
          {
            unint64_t v19 = &v12[48 * v15];
            unsigned int v20 = *(_DWORD *)v19;
            if (*(_DWORD *)v19 >= v17) {
              uint64_t v21 = &v12[48 * v15];
            }
            else {
              uint64_t v21 = (char *)(a1 + 24 * v5);
            }
            if (v20 > v18) {
              uint64_t v21 = &v12[24 * (v11 >> 3)];
            }
            if (v20 >= v17) {
              uint64_t v22 = (char *)(a1 + 24 * v5);
            }
            else {
              uint64_t v22 = &v12[48 * v15];
            }
            if (v20 >= v18) {
              __int16 v16 = v22;
            }
            if (v18 >= v17) {
              __int16 v16 = v21;
            }
            if (v17 != v20 && v18 != v20) {
              unint64_t v19 = v16;
            }
          }
          unsigned int v24 = *(_DWORD *)&v13[-24 * v15];
          unsigned int v25 = *(_DWORD *)v13;
          if (*(_DWORD *)v13 == v24)
          {
            unint64_t v28 = &v13[-24 * v15];
          }
          else
          {
            unsigned int v26 = *(_DWORD *)&v13[24 * v15];
            BOOL v27 = v24 == v26 || v25 == v26;
            unint64_t v28 = &v13[24 * v15];
            if (!v27)
            {
              unint64_t v28 = v13;
              if (v25 >= v24)
              {
                if (v26 <= v25)
                {
                  if (v26 >= v24) {
                    unint64_t v28 = &v13[24 * v15];
                  }
                  else {
                    unint64_t v28 = &v13[-24 * v15];
                  }
                }
              }
              else if (v26 >= v25)
              {
                if (v26 >= v24) {
                  unint64_t v28 = &v13[-24 * v15];
                }
                else {
                  unint64_t v28 = &v13[24 * v15];
                }
              }
            }
          }
          uint64_t v30 = -(uint64_t)v15;
          uint64_t v29 = &v14[-12 * v15];
          unint64_t v31 = &v14[6 * v30];
          unsigned int v32 = *v29;
          unsigned int v33 = *v31;
          if (*v31 != *v29)
          {
            unsigned int v34 = *v14;
            if (*v14 >= v32) {
              unsigned int v35 = (unsigned int *)(a1 + 24 * a2);
            }
            else {
              unsigned int v35 = v29;
            }
            if (v34 > v33) {
              unsigned int v35 = v31;
            }
            if (v34 < v32) {
              uint64_t v29 = (unsigned int *)(a1 + 24 * a2);
            }
            if (v34 < v33) {
              uint64_t v29 = v31;
            }
            if (v33 >= v32) {
              uint64_t v29 = v35;
            }
            if (v32 == v34 || v33 == v34) {
              uint64_t v29 = (unsigned int *)(a1 + 24 * a2);
            }
          }
        }
        unsigned int v37 = *(_DWORD *)v19;
        unsigned int v38 = *(_DWORD *)v28;
        if (*(_DWORD *)v28 == *(_DWORD *)v19)
        {
          unint64_t v28 = v19;
        }
        else
        {
          unsigned int v39 = *v29;
          if (v37 == *v29 || v38 == v39)
          {
            unint64_t v28 = (char *)v29;
          }
          else if (v38 >= v37)
          {
            if (v39 <= v38)
            {
              if (v39 >= v37) {
                unint64_t v28 = (char *)v29;
              }
              else {
                unint64_t v28 = v19;
              }
            }
          }
          else if (v39 >= v38)
          {
            if (v39 >= v37) {
              unint64_t v28 = v19;
            }
            else {
              unint64_t v28 = (char *)v29;
            }
          }
        }
        unsigned int v41 = *(_DWORD *)v28;
        long long v77 = *(_OWORD *)(v28 + 4);
        unsigned int v79 = *((_DWORD *)v28 + 5);
        uint64_t v42 = *((void *)v14 + 2);
        *(_OWORD *)unint64_t v28 = *(_OWORD *)v14;
        *((void *)v28 + 2) = v42;
        *unsigned int v14 = v41;
        *(_OWORD *)(v14 + 1) = v77;
        v14[5] = v79;
        unsigned int v43 = *(_DWORD *)v12;
        long long v73 = *(_OWORD *)(v12 + 4);
        int v75 = *((_DWORD *)v12 + 5);
        uint64_t v44 = (long long *)(v6 + 24 * v5);
        uint64_t v45 = a2;
        uint64_t v46 = v5;
        do
        {
          long long v71 = v73;
          int v72 = v75;
          unsigned int v47 = *((_DWORD *)v44 - 1);
          long long v73 = *v44;
          int v75 = *((_DWORD *)v44 + 4);
          if (v41 <= v43)
          {
            double v48 = (long long *)(a1 + 24 * v46);
            long long v49 = *v48;
            *(void *)((char *)v44 - 12) = *((void *)v48 + 2);
            *(long long *)((char *)v44 - 28) = v49;
            *(_DWORD *)double v48 = v43;
            *(long long *)((char *)v48 + 4) = v71;
            *((_DWORD *)v48 + 5) = v72;
            ++v46;
          }
          uint64_t v44 = (long long *)((char *)v44 + 24);
          --v45;
          unsigned int v43 = v47;
        }
        while (v5 != v45);
        unsigned int v50 = (long long *)(a1 + 24 * v46);
        uint64_t v51 = *((void *)v50 + 2);
        long long v52 = *v50;
        uint64_t v53 = *((void *)v14 + 2);
        *unsigned int v50 = *(_OWORD *)v14;
        *((void *)v50 + 2) = v53;
        *(_OWORD *)unsigned int v14 = v52;
        *((void *)v14 + 2) = v51;
        uint64_t v54 = v46 - v5;
        if (v46 < v5)
        {
          os_log_type_t v68 = __si_assert_copy_extra_1921(0);
          CFAbsoluteTime v69 = v68;
          double v70 = "";
          if (v68) {
            double v70 = v68;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 2170, "q>=left", v70);
          free(v69);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        if (v7 == v9)
        {
          heapsort_b(v12, v11, 0x18uLL, &__block_literal_global_2045);
          uint64_t v7 = v9;
          goto LABEL_3;
        }
        BOOL v55 = v54 <= a2 - v46;
        if (v54 <= a2 - v46) {
          uint64_t v56 = v46 - 1;
        }
        else {
          uint64_t v56 = a2;
        }
        if (v55) {
          uint64_t v57 = v5;
        }
        else {
          uint64_t v57 = v46;
        }
        if (v55) {
          uint64_t v5 = v46;
        }
        else {
          a2 = v46 - 1;
        }
        size_t v58 = &v4[2 * v7];
        void *v58 = v57;
        v58[1] = v56;
        ++v7;
        if (a2 <= v5) {
          goto LABEL_3;
        }
      }
      uint64_t v59 = v6 + 24 * v5;
      uint64_t v60 = v5;
      do
      {
        uint64_t v62 = v60++;
        unsigned int v63 = (int *)(a1 + 24 * v62);
        long long v78 = *(_OWORD *)(v63 + 7);
        int v80 = v63[11];
        unsigned int v64 = *v63;
        long long v74 = *(_OWORD *)(v63 + 1);
        unsigned int v65 = v63[6];
        int v76 = v63[5];
        uint64_t v66 = v60;
        if (v65 > v64)
        {
          uint64_t v67 = v59;
          do
          {
            uint64_t v66 = v62;
            *(_DWORD *)(v67 - 4) = v64;
            *(_OWORD *)uint64_t v67 = v74;
            *(_DWORD *)(v67 + 16) = v76;
            if (v62 <= v5) {
              break;
            }
            unsigned int v64 = *(_DWORD *)(v67 - 52);
            long long v74 = *(_OWORD *)(v67 - 48);
            int v76 = *(_DWORD *)(v67 - 32);
            v67 -= 24;
            --v62;
          }
          while (v65 > v64);
        }
        uint64_t v61 = a1 + 24 * v66;
        *(_DWORD *)uint64_t v61 = v65;
        *(_OWORD *)(v61 + 4) = v78;
        *(_DWORD *)(v61 + 20) = v80;
        v59 += 24;
      }
      while (v60 != a2);
    }
LABEL_3:
    --v7;
    uint64_t v8 = &v4[2 * v7];
    uint64_t v5 = *v8;
    a2 = v8[1];
  }
  while (v7);
  free(v4);
}

int *_PayloadWriteData(int *result, void *a2, char *a3, int64_t a4)
{
  uint64_t v5 = result;
  uint64_t v6 = &a3[a4];
  if (a4)
  {
    int64_t v7 = a4;
    do
    {
      if (*((void *)v5 + 4)) {
        break;
      }
      int64_t v9 = *((void *)v5 + 3);
      if (v7 >= v9) {
        size_t v10 = *((void *)v5 + 3);
      }
      else {
        size_t v10 = v7;
      }
      a2[1] -= v10;
      size_t v11 = v9 - v10;
      *((void *)v5 + 3) = v11;
      v6 -= v10;
      uint64_t result = (int *)memcpy((void *)(*(void *)v5 + v11), v6, v10);
      if (!*((void *)v5 + 3)) {
        uint64_t result = PayloadWriteBufferWrite(v5, a2);
      }
      v7 -= v10;
    }
    while (v7);
  }
  if (v6 != a3 && !*((void *)v5 + 4))
  {
    unsigned int v12 = __si_assert_copy_extra_1921(0);
    uint64_t v13 = v12;
    unsigned int v14 = "";
    if (v12) {
      unsigned int v14 = v12;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHPayload.h", 146, "src == ptr || wb->err", v14);
    free(v13);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return result;
}

uint64_t ___qsort_termids_block_invoke(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  if (*a3 == *a2) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = -1;
  }
  if (*a3 > *a2) {
    return 1;
  }
  else {
    return v3;
  }
}

uint64_t mergeRangeCompare(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)*(void *)(a1 + 8) << 6;
  if (HIDWORD(*(void *)(a2 + 8))) {
    unint64_t v3 = 0;
  }
  else {
    unint64_t v3 = (unint64_t)*(void *)(a2 + 8) << 6;
  }
  if (HIDWORD(*(void *)(a1 + 8))) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = v2 == 0;
  }
  if (v4)
  {
    if (v3) {
      return 1;
    }
    BOOL v6 = *(_DWORD *)a1 > *(_DWORD *)a2;
  }
  else
  {
    if (!v3) {
      return 0xFFFFFFFFLL;
    }
    BOOL v6 = v2 > v3;
  }
  if (v6) {
    return 1;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void TrieMergeCleanup(uint64_t *a1)
{
  if (*((unsigned char *)a1 + 49))
  {
    uint64_t v2 = *a1;
    uint64_t v3 = *a1 + 4776;
    BOOL v4 = (pthread_mutex_t *)(*a1 + 4600);
    pthread_mutex_lock(v4);
    *(_DWORD *)(v2 + 4804) = 0;
    uint64_t v5 = *(pthread_override_s **)(v2 + 4776);
    *(_OWORD *)uint64_t v3 = 0u;
    char v6 = *(_DWORD *)(v2 + 4796) != 0;
    *(unsigned char *)(v3 + 36) = 0;
    db_rwlock_wakeup((uint64_t)v4, v6, 0);
    pthread_mutex_unlock(v4);
    if (v5) {
      pthread_override_qos_class_end_np(v5);
    }
  }
  if (*((unsigned char *)a1 + 48))
  {
    uint64_t v7 = a1[1];
    pthread_mutex_lock((pthread_mutex_t *)(v7 + 304));
    int v8 = *(_DWORD *)(v7 + 500) - 1;
    *(_DWORD *)(v7 + 500) = v8;
    if (!v8) {
      db_rwlock_wakeup(v7 + 304, 0, 0);
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v7 + 304));
  }
  free((void *)a1[2]);
  free((void *)a1[3]);
  free((void *)a1[4]);
  free((void *)a1[5]);
  free(a1);
}

void findMatchRangeChars(uint64_t a1, uint64_t a2)
{
  if (HIDWORD(a2) == 1)
  {
    uint64_t v10 = mgetBase(*(void *)(a1 + 8), a2);
    char v11 = *(unsigned char *)(v10 + 36);
    if (!v11) {
      return;
    }
    uint64_t v12 = v10;
    unint64_t v13 = 0;
    unsigned int v14 = (int8x8_t *)(v10 + 4);
    while (((*(_DWORD *)(v12 + 4 * (v13 >> 5) + 4) >> v13) & 1) == 0)
    {
LABEL_31:
      if (v11)
      {
        if (v13++ < 0xFF) {
          continue;
        }
      }
      return;
    }
    uint64_t v15 = 0;
    unsigned int v16 = v13 >> 6;
    if (v13 >> 6 != 1)
    {
      if (v16 != 2)
      {
        if (v16 != 3)
        {
LABEL_23:
          uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v14[v16] & ~(-1 << v13)));
          v20.i16[0] = vaddlv_u8(v20);
          unint64_t v21 = *(unsigned int *)(v12 + 4 * (v20.u32[0] + v15) + 38);
          unint64_t v22 = v21 >> 1;
          unint64_t v23 = v21 >> 3;
          uint64_t v24 = (v21 & 7) << 32;
          if ((v21 & 3) == 1)
          {
            uint64_t v24 = 0x100000000;
            unint64_t v23 = v21 >> 2;
          }
          BOOL v25 = (v21 & 1) == 0;
          if (v21) {
            uint64_t v26 = v24;
          }
          else {
            uint64_t v26 = 0;
          }
          if (!v25) {
            unint64_t v22 = v23;
          }
          _findMatchRangeChars(a1, v26 | v22, tcmr[v13]);
          --v11;
          goto LABEL_31;
        }
        uint8x8_t v17 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v12 + 20));
        v17.i16[0] = vaddlv_u8(v17);
        uint64_t v15 = v17.u32[0];
      }
      uint8x8_t v18 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v12 + 12));
      v18.i16[0] = vaddlv_u8(v18);
      v15 += v18.u32[0];
    }
    uint8x8_t v19 = (uint8x8_t)vcnt_s8(*v14);
    v19.i16[0] = vaddlv_u8(v19);
    v15 += v19.u32[0];
    goto LABEL_23;
  }
  if (HIDWORD(a2) == 3)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 8) + 1028 * a2 + 4;
    do
    {
      unint64_t v5 = *(unsigned int *)(v4 + 4 * v3);
      unint64_t v6 = v5 >> 1;
      unint64_t v7 = v5 >> 3;
      uint64_t v8 = (v5 & 7) << 32;
      if ((v5 & 3) == 1)
      {
        uint64_t v8 = 0x100000000;
        unint64_t v7 = v5 >> 2;
      }
      if (v5) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = 0;
      }
      if (*(_DWORD *)(v4 + 4 * v3)) {
        unint64_t v6 = v7;
      }
      if (v6) {
        _findMatchRangeChars(a1, v9 | v6, tcmr[v3]);
      }
      ++v3;
    }
    while (v3 != 256);
  }
}

void trie_level_list_insert_with_state(int *a1, uint64_t a2, void *a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  value[0] = a2;
  value[1] = a3;
  value[3] = a5;
  value[2] = a4;
  value[4] = a6;
  if (CFSetContainsValue(*((CFSetRef *)a1 + 2), value))
  {
    free(a3);
    return;
  }
  LODWORD(v12) = a1[1];
  if ((int)v12 >= *a1)
  {
    CFSetRemoveAllValues(*((CFMutableSetRef *)a1 + 2));
    int v13 = 2 * *a1;
    *a1 = v13;
    *((void *)a1 + 1) = malloc_type_realloc(*((void **)a1 + 1), 40 * v13, 0x1010040796FF4C2uLL);
    LODWORD(v12) = a1[1];
    if ((int)v12 >= 1)
    {
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      do
      {
        CFSetAddValue(*((CFMutableSetRef *)a1 + 2), (const void *)(*((void *)a1 + 1) + v14));
        ++v15;
        uint64_t v12 = a1[1];
        v14 += 40;
      }
      while (v15 < v12);
    }
    uint64_t v16 = *a1;
    if ((int)v12 < (int)v16)
    {
      uint64_t v17 = *((void *)a1 + 1);
      unint64_t v18 = (int)v12;
      unint64_t v19 = v16 - (int)v12;
      if (v19 > 1)
      {
        unint64_t v20 = v19 & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v21 = v17 + 40 * (int)v12 + 48;
        unint64_t v22 = v19 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          *(void *)(v21 - 40) = 0;
          *(void *)uint64_t v21 = 0;
          *(_DWORD *)(v21 - 32) = 0;
          *(_DWORD *)(v21 + 8) = 0;
          v21 += 80;
          v22 -= 2;
        }
        while (v22);
        if (v19 == v20) {
          goto LABEL_15;
        }
        unint64_t v18 = v20 + (int)v12;
      }
      uint64_t v23 = v16 - v18;
      uint64_t v24 = (_DWORD *)(v17 + 40 * v18 + 16);
      do
      {
        *((void *)v24 - 1) = 0;
        _DWORD *v24 = 0;
        v24 += 10;
        --v23;
      }
      while (v23);
    }
  }
LABEL_15:
  *(void *)(*((void *)a1 + 1) + 40 * (int)v12) = a2;
  free(*(void **)(*((void *)a1 + 1) + 40 * a1[1] + 8));
  uint64_t v25 = *((void *)a1 + 1) + 40 * a1[1];
  *(void *)(v25 + 8) = a3;
  *(_DWORD *)(v25 + 16) = a4;
  *(void *)(v25 + 24) = a5;
  *(void *)(v25 + 32) = a6;
  CFSetAddValue(*((CFMutableSetRef *)a1 + 2), (const void *)(*((void *)a1 + 1) + 40 * a1[1]++));
}

void __trie_resolve_fuzzy_transition_block_invoke(uint64_t a1, unint64_t a2, unsigned char *a3, int a4)
{
  *(void *)(*(void *)(a1 + 32) + 1272) = a1 + 64;
  findAddFlatBucket(*(void *)(a1 + 32), a2, *(unsigned char **)(a1 + 48), *(int *)(a1 + 56), a3, a4);
  *(void *)(*(void *)(a1 + 32) + 1272) = 0;
}

void __trie_resolve_fuzzy_transition_block_invoke_2(uint64_t a1, unint64_t a2, uint64_t a3, const void *a4, int a5)
{
  size_t v10 = (*(_DWORD *)(a1 + 48) + a5);
  char v11 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, (v10 + 1), 0x6085D6BuLL);
  if (!v11 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    LOWORD(v16) = 0;
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", (uint8_t *)&v16, 2u);
  }
  memcpy(v11, *(const void **)(a1 + 40), *(int *)(a1 + 48));
  memcpy(&v11[*(int *)(a1 + 48)], a4, a5);
  v11[v10] = 0;
  if (a3)
  {
    uint64_t v12 = la_new_state_from_state_with_char_at_index(*(void *)(*(void *)(a1 + 88) + 1264), *(void *)(a1 + 56), *(void *)(a1 + 64), (*(unsigned char *)(a3 + 16) + *(void *)(a1 + 64)));
    *(void *)&long long v16 = v12;
    *((void *)&v16 + 1) = v13;
    if (!v12) {
      goto LABEL_10;
    }
  }
  else
  {
    long long v16 = *(_OWORD *)(a1 + 72);
    uint64_t v12 = v16;
    if (!(void)v16)
    {
LABEL_10:
      free(v11);
      return;
    }
  }
  if (!HIDWORD(a2))
  {
    *(void *)(*(void *)(a1 + 88) + 1272) = &v16;
    findAddFlatBucket(*(void *)(a1 + 88), a2, v11, v10, 0, 0);
    *(void *)(*(void *)(a1 + 88) + 1272) = 0;
    goto LABEL_10;
  }
  uint64_t v14 = *(int **)(a1 + 96);
  uint64_t v15 = *((void *)&v16 + 1);
  trie_level_list_insert_with_state(v14, a2, v11, v10, v12, v15);
}

unint64_t _trie_resolve_sub_trie(unint64_t result, unint64_t a2, char **a3, uint64_t a4, uint64_t a5, char a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2;
  if (!a2) {
    return result;
  }
  if (a3 && *((unsigned char *)a3 + 18))
  {
    uint64_t v16 = result;
    if (*((unsigned __int8 *)a3 + 16) != 255) {
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, char **, uint64_t, uint64_t))(a8 + 16))(a8, a2, a3, a4, a5);
    }
    if (!HIDWORD(a2))
    {
      uint64_t v17 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a7 + 16);
      return v17(a7, v8, a4, a5);
    }
    if (a6)
    {
      if (!*((unsigned char *)a3 + 18) || (**a3 & 0x80000000) == 0)
      {
        uint64_t v19 = 0;
        unsigned int v20 = 0;
        uint64_t v21 = (int)a5;
        uint64_t v22 = (a5 + 1);
        do
        {
          uint64_t result = trieGetRawChild(v16, a2, v19);
          *(unsigned char *)(a4 + v21) = tcmr[v19];
          if (v20 < *((unsigned __int8 *)a3 + 18) && v19 == (*a3)[v20])
          {
            if (result) {
              uint64_t result = _trie_resolve_sub_trie(v16);
            }
            ++v20;
          }
          else if (result)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, void, uint64_t, uint64_t))(a8 + 16))(a8, result, 0, a4, v22);
          }
          ++v19;
        }
        while (v19 != 128);
        return result;
      }
    }
    else if (!*((unsigned char *)a3 + 18))
    {
      return result;
    }
    unint64_t v23 = 0;
    do
    {
      uint64_t v24 = (*a3)[v23];
      uint64_t result = trieGetRawChild(v16, a2, (*a3)[v23]);
      if (result)
      {
        *(unsigned char *)(a4 + (int)a5) = tcmr[v24];
        uint64_t result = _trie_resolve_sub_trie(v16);
      }
      ++v23;
    }
    while (v23 < *((unsigned __int8 *)a3 + 18));
  }
  else
  {
    unint64_t v18 = *(uint64_t (**)(uint64_t))(a8 + 16);
    return v18(a8);
  }
  return result;
}

void _trie_resolve_combining(uint64_t a1, long long *a2, int *a3)
{
  uint64_t v44 = 0;
  int v43 = 204;
  if (_trie_resolve_string(*(void *)(a1 + 8), *(void *)a2, (uint64_t)&v43, 1, &v44))
  {
    if (HIDWORD(v44))
    {
      unsigned int v6 = 128;
      do
      {
        BYTE1(v43) = v6;
        long long v7 = a2[1];
        long long v40 = *a2;
        long long v41 = v7;
        uint64_t v42 = *((void *)a2 + 4);
        trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 2, a3);
        BOOL v8 = v6++ >= 0xBF;
      }
      while (!v8);
    }
    else
    {
      long long v9 = a2[1];
      long long v40 = *a2;
      long long v41 = v9;
      uint64_t v42 = *((void *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 1, a3);
    }
  }
  LOBYTE(v43) = -51;
  if (_trie_resolve_string(*(void *)(a1 + 8), *(void *)a2, (uint64_t)&v43, 1, &v44))
  {
    if (HIDWORD(v44))
    {
      unsigned int v10 = 128;
      do
      {
        BYTE1(v43) = v10;
        long long v11 = a2[1];
        long long v40 = *a2;
        long long v41 = v11;
        uint64_t v42 = *((void *)a2 + 4);
        trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 2, a3);
        BOOL v8 = v10++ >= 0xDF;
      }
      while (!v8);
    }
    else
    {
      long long v12 = a2[1];
      long long v40 = *a2;
      long long v41 = v12;
      uint64_t v42 = *((void *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 1, a3);
    }
  }
  LOBYTE(v43) = 45;
  long long v13 = a2[1];
  long long v40 = *a2;
  long long v41 = v13;
  uint64_t v42 = *((void *)a2 + 4);
  trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 1, a3);
  LOWORD(v43) = -32542;
  BYTE2(v43) = -112;
  long long v14 = a2[1];
  long long v40 = *a2;
  long long v41 = v14;
  uint64_t v42 = *((void *)a2 + 4);
  trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 3, a3);
  LOBYTE(v43) = -42;
  if (_trie_resolve_string(*(void *)(a1 + 8), *(void *)a2, (uint64_t)&v43, 1, &v44))
  {
    if (HIDWORD(v44))
    {
      unsigned int v15 = 145;
      do
      {
        BYTE1(v43) = v15;
        long long v16 = a2[1];
        long long v40 = *a2;
        long long v41 = v16;
        uint64_t v42 = *((void *)a2 + 4);
        trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 2, a3);
        BOOL v8 = v15++ >= 0xBF;
      }
      while (!v8);
    }
    else
    {
      long long v17 = a2[1];
      long long v40 = *a2;
      long long v41 = v17;
      uint64_t v42 = *((void *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 1, a3);
    }
  }
  LOBYTE(v43) = -41;
  if (_trie_resolve_string(*(void *)(a1 + 8), *(void *)a2, (uint64_t)&v43, 1, &v44))
  {
    if (HIDWORD(v44))
    {
      BYTE1(v43) = 0x80;
      long long v18 = a2[1];
      long long v40 = *a2;
      long long v41 = v18;
      uint64_t v42 = *((void *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 2, a3);
      BYTE1(v43) = -127;
      long long v19 = a2[1];
      long long v40 = *a2;
      long long v41 = v19;
      uint64_t v42 = *((void *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 2, a3);
      BYTE1(v43) = -126;
      long long v20 = a2[1];
      long long v40 = *a2;
      long long v41 = v20;
      uint64_t v42 = *((void *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 2, a3);
      BYTE1(v43) = -125;
      long long v21 = a2[1];
      long long v40 = *a2;
      long long v41 = v21;
      uint64_t v42 = *((void *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 2, a3);
      BYTE1(v43) = -124;
      long long v22 = a2[1];
      long long v40 = *a2;
      long long v41 = v22;
      uint64_t v42 = *((void *)a2 + 4);
      uint64_t v23 = a1;
      uint64_t v24 = 2;
    }
    else
    {
      long long v25 = a2[1];
      long long v40 = *a2;
      long long v41 = v25;
      uint64_t v42 = *((void *)a2 + 4);
      uint64_t v23 = a1;
      uint64_t v24 = 1;
    }
    trie_resolve_sub_string(v23, (uint64_t)&v40, &v43, v24, a3);
  }
  LOWORD(v43) = -32029;
  uint64_t v26 = _trie_resolve_string(*(void *)(a1 + 8), *(void *)a2, (uint64_t)&v43, 2, &v44);
  if (v26)
  {
    uint64_t v27 = v26;
    if (HIDWORD(v44))
    {
      if (v26 != 2) {
        goto LABEL_33;
      }
      BYTE2(v43) = -103;
      long long v28 = a2[1];
      long long v40 = *a2;
      long long v41 = v28;
      uint64_t v42 = *((void *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 3, a3);
      BYTE2(v43) = -102;
      long long v29 = a2[1];
      long long v40 = *a2;
      long long v41 = v29;
      uint64_t v42 = *((void *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 3, a3);
      BYTE2(v43) = -101;
      long long v30 = a2[1];
      long long v40 = *a2;
      long long v41 = v30;
      uint64_t v42 = *((void *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 3, a3);
      BYTE2(v43) = -100;
      long long v31 = a2[1];
      long long v40 = *a2;
      long long v41 = v31;
      uint64_t v42 = *((void *)a2 + 4);
      uint64_t v32 = a1;
      uint64_t v27 = 3;
    }
    else
    {
      long long v33 = a2[1];
      long long v40 = *a2;
      long long v41 = v33;
      uint64_t v42 = *((void *)a2 + 4);
      uint64_t v32 = a1;
    }
    trie_resolve_sub_string(v32, (uint64_t)&v40, &v43, v27, a3);
  }
LABEL_33:
  LOWORD(v43) = -16657;
  uint64_t v34 = _trie_resolve_string(*(void *)(a1 + 8), *(void *)a2, (uint64_t)&v43, 2, &v44);
  if (!v34) {
    return;
  }
  uint64_t v35 = v34;
  if (HIDWORD(v44))
  {
    if (v34 != 2) {
      return;
    }
    BYTE2(v43) = -98;
    long long v36 = a2[1];
    long long v40 = *a2;
    long long v41 = v36;
    uint64_t v42 = *((void *)a2 + 4);
    trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 3, a3);
    BYTE2(v43) = -97;
    long long v37 = a2[1];
    long long v40 = *a2;
    long long v41 = v37;
    uint64_t v42 = *((void *)a2 + 4);
    uint64_t v38 = a1;
    uint64_t v35 = 3;
  }
  else
  {
    long long v39 = a2[1];
    long long v40 = *a2;
    long long v41 = v39;
    uint64_t v42 = *((void *)a2 + 4);
    uint64_t v38 = a1;
  }
  trie_resolve_sub_string(v38, (uint64_t)&v40, &v43, v35, a3);
}

void trie_resolve_sub_string(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4, int *a5)
{
  int v6 = a4;
  uint64_t v23 = 0;
  int v10 = _trie_resolve_string(*(void *)(a1 + 8), *(void *)a2, (uint64_t)a3, a4, &v23);
  if (v10)
  {
    if (HIDWORD(v23))
    {
      if (v10 != v6)
      {
        long long v20 = __si_assert_copy_extra_1921(0);
        long long v21 = v20;
        long long v22 = "";
        if (v20) {
          long long v22 = v20;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 5466, "str_len==resolve_len", v22);
        free(v21);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      uint64_t v11 = *(int *)(a2 + 16) + (uint64_t)v6;
      if ((int)v11 <= 4094)
      {
        long long v12 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v11 + 1, 0x6085D6BuLL);
        if (!v12 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)iovec buf = 0;
          _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
        }
        memcpy(v12, *(const void **)(a2 + 8), *(int *)(a2 + 16));
        memcpy(&v12[*(int *)(a2 + 16)], a3, v6);
        v12[*(int *)(a2 + 16) + (uint64_t)v6] = 0;
        unsigned int v13 = *(_DWORD *)(a2 + 16) + v6;
        uint64_t v14 = v23;
        uint64_t v15 = *(void *)(a2 + 24);
        uint64_t v16 = *(void *)(a2 + 32);
        trie_level_list_insert_with_state(a5, v14, v12, v13, v15, v16);
      }
    }
    else
    {
      long long v17 = *(unsigned char **)(a2 + 8);
      size_t v18 = *(int *)(a2 + 16);
      unint64_t v19 = v23;
      findAddFlatBucket(a1, v19, v17, v18, a3, v10);
    }
  }
}

void _trie_resolve_sub_string_ignore_diacritics(uint64_t a1, long long *a2, unsigned __int8 *a3, int a4, int *a5, unsigned char *a6, int a7)
{
  if (!a4) {
    return;
  }
  uint64_t v14 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[(unint64_t)*a3 >> 4];
  unint64_t v56 = 0;
  int v15 = _trie_resolve_string(*(void *)(a1 + 8), *(void *)a2, (uint64_t)a3, v14, &v56);
  if (!v15) {
    return;
  }
  int v16 = v15;
  memcpy(&a6[a7], a3, v15);
  uint64_t v17 = v16 + (uint64_t)a7;
  if (!HIDWORD(v56))
  {
    long long v20 = (unsigned char *)*((void *)a2 + 1);
    size_t v21 = *((int *)a2 + 4);
    size_t v22 = (int)v17;
    unint64_t v23 = v56;
    uint64_t v24 = a1;
    long long v25 = a6;
    goto LABEL_11;
  }
  if (v16 != v14) {
    return;
  }
  if (a4 == v14)
  {
    uint64_t v18 = *((int *)a2 + 4) + (uint64_t)(int)v17;
    if ((int)v18 <= 4094)
    {
      unint64_t v19 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v18 + 1, 0x6085D6BuLL);
      if (!v19) {
        _log_fault_for_malloc_failure();
      }
      memcpy(v19, *((const void **)a2 + 1), *((int *)a2 + 4));
      memcpy(&v19[*((int *)a2 + 4)], a6, (int)v17);
      v19[*((int *)a2 + 4) + (uint64_t)(int)v17] = 0;
      trie_level_list_insert_with_state(a5, v56, v19, *((_DWORD *)a2 + 4) + v17, 0, 0);
    }
    return;
  }
  unint64_t v26 = v56;
  *(void *)a2 = v56;
  long long v27 = a2[1];
  long long v53 = *a2;
  long long v54 = v27;
  uint64_t v55 = *((void *)a2 + 4);
  _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
  unint64_t v52 = 0;
  a6[v17] = -52;
  unint64_t v50 = v26;
  uint64_t v51 = &a6[v17];
  if (_trie_resolve_string(*(void *)(a1 + 8), v26, (uint64_t)&a6[v17], 1, &v52))
  {
    if (HIDWORD(v52))
    {
      unsigned int v28 = 128;
      do
      {
        a6[(int)v17 + 1] = v28;
        if (_trie_resolve_string(*(void *)(a1 + 8), v52, (uint64_t)(v51 + 1), 1, &v52))
        {
          if (HIDWORD(v52))
          {
            *(void *)a2 = v52;
            long long v29 = a2[1];
            long long v53 = *a2;
            long long v54 = v29;
            uint64_t v55 = *((void *)a2 + 4);
            _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
          }
          else
          {
            findAddFlatBucket(a1, v52, *((unsigned char **)a2 + 1), *((int *)a2 + 4), a6, (int)v17 + 2);
          }
        }
        BOOL v30 = v28++ >= 0xBF;
      }
      while (!v30);
    }
    else
    {
      findAddFlatBucket(a1, v52, *((unsigned char **)a2 + 1), *((int *)a2 + 4), a6, (int)v17 + 1);
    }
  }
  unsigned char *v51 = -51;
  if (_trie_resolve_string(*(void *)(a1 + 8), v50, (uint64_t)v51, 1, &v52))
  {
    if (HIDWORD(v52))
    {
      unsigned int v31 = 128;
      do
      {
        a6[(int)v17 + 1] = v31;
        if (_trie_resolve_string(*(void *)(a1 + 8), v52, (uint64_t)(v51 + 1), 1, &v52))
        {
          if (HIDWORD(v52))
          {
            *(void *)a2 = v52;
            long long v32 = a2[1];
            long long v53 = *a2;
            long long v54 = v32;
            uint64_t v55 = *((void *)a2 + 4);
            _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
          }
          else
          {
            findAddFlatBucket(a1, v52, *((unsigned char **)a2 + 1), *((int *)a2 + 4), a6, (int)v17 + 2);
          }
        }
        BOOL v30 = v31++ >= 0xDF;
      }
      while (!v30);
    }
    else
    {
      findAddFlatBucket(a1, v52, *((unsigned char **)a2 + 1), *((int *)a2 + 4), a6, (int)v17 + 1);
    }
  }
  unsigned char *v51 = 45;
  if (_trie_resolve_string(*(void *)(a1 + 8), v50, (uint64_t)v51, 1, &v52))
  {
    if (HIDWORD(v52))
    {
      *(void *)a2 = v52;
      int v33 = v17 + 1;
      long long v34 = a2[1];
      long long v53 = *a2;
      long long v54 = v34;
      uint64_t v55 = *((void *)a2 + 4);
      _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
    }
    else
    {
      int v33 = v17 + 1;
      findAddFlatBucket(a1, v52, *((unsigned char **)a2 + 1), *((int *)a2 + 4), a6, (int)v17 + 1);
    }
  }
  else
  {
    int v33 = v17 + 1;
  }
  unsigned char *v51 = -30;
  size_t v35 = v33;
  a6[v33] = 0x80;
  size_t v36 = (int)v17 + 2;
  a6[v36] = -112;
  if (_trie_resolve_string(*(void *)(a1 + 8), v50, (uint64_t)v51, 3, &v52))
  {
    if (HIDWORD(v52))
    {
      *(void *)a2 = v52;
      long long v37 = a2[1];
      long long v53 = *a2;
      long long v54 = v37;
      uint64_t v55 = *((void *)a2 + 4);
      _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
    }
    else
    {
      findAddFlatBucket(a1, v52, *((unsigned char **)a2 + 1), *((int *)a2 + 4), a6, v35);
    }
  }
  unsigned char *v51 = -42;
  if (_trie_resolve_string(*(void *)(a1 + 8), v50, (uint64_t)v51, 1, &v52))
  {
    if (HIDWORD(v52))
    {
      unsigned int v38 = 145;
      do
      {
        a6[v35] = v38;
        if (_trie_resolve_string(*(void *)(a1 + 8), v52, (uint64_t)(v51 + 1), 1, &v52))
        {
          if (HIDWORD(v52))
          {
            *(void *)a2 = v52;
            long long v39 = a2[1];
            long long v53 = *a2;
            long long v54 = v39;
            uint64_t v55 = *((void *)a2 + 4);
            _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
          }
          else
          {
            findAddFlatBucket(a1, v52, *((unsigned char **)a2 + 1), *((int *)a2 + 4), a6, v36);
          }
        }
        BOOL v30 = v38++ >= 0xBF;
      }
      while (!v30);
    }
    else
    {
      findAddFlatBucket(a1, v52, *((unsigned char **)a2 + 1), *((int *)a2 + 4), a6, v35);
    }
  }
  unsigned char *v51 = -41;
  if (_trie_resolve_string(*(void *)(a1 + 8), v50, (uint64_t)v51, 1, &v52))
  {
    if (HIDWORD(v52))
    {
      uint64_t v40 = (uint64_t)(v51 + 1);
      a6[v35] = 0x80;
      if (_trie_resolve_string(*(void *)(a1 + 8), v52, (uint64_t)(v51 + 1), 1, &v52))
      {
        if (HIDWORD(v52))
        {
          unint64_t v41 = v52;
          *(void *)a2 = v52;
          long long v42 = a2[1];
          long long v53 = *a2;
          long long v54 = v42;
          uint64_t v55 = *((void *)a2 + 4);
          _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
        }
        else
        {
          unint64_t v41 = v52;
          findAddFlatBucket(a1, v52, *((unsigned char **)a2 + 1), *((int *)a2 + 4), a6, v36);
        }
      }
      else
      {
        unint64_t v41 = v52;
      }
      a6[v35] = -127;
      if (_trie_resolve_string(*(void *)(a1 + 8), v41, v40, 1, &v52))
      {
        if (HIDWORD(v52))
        {
          unint64_t v43 = v52;
          *(void *)a2 = v52;
          long long v44 = a2[1];
          long long v53 = *a2;
          long long v54 = v44;
          uint64_t v55 = *((void *)a2 + 4);
          _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
        }
        else
        {
          unint64_t v43 = v52;
          findAddFlatBucket(a1, v52, *((unsigned char **)a2 + 1), *((int *)a2 + 4), a6, v36);
        }
      }
      else
      {
        unint64_t v43 = v52;
      }
      a6[v35] = -126;
      if (_trie_resolve_string(*(void *)(a1 + 8), v43, v40, 1, &v52))
      {
        if (HIDWORD(v52))
        {
          unint64_t v45 = v52;
          *(void *)a2 = v52;
          long long v46 = a2[1];
          long long v53 = *a2;
          long long v54 = v46;
          uint64_t v55 = *((void *)a2 + 4);
          _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
        }
        else
        {
          unint64_t v45 = v52;
          findAddFlatBucket(a1, v52, *((unsigned char **)a2 + 1), *((int *)a2 + 4), a6, v36);
        }
      }
      else
      {
        unint64_t v45 = v52;
      }
      a6[v35] = -125;
      if (_trie_resolve_string(*(void *)(a1 + 8), v45, v40, 1, &v52))
      {
        if (HIDWORD(v52))
        {
          unint64_t v47 = v52;
          *(void *)a2 = v52;
          long long v48 = a2[1];
          long long v53 = *a2;
          long long v54 = v48;
          uint64_t v55 = *((void *)a2 + 4);
          _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
        }
        else
        {
          unint64_t v47 = v52;
          findAddFlatBucket(a1, v52, *((unsigned char **)a2 + 1), *((int *)a2 + 4), a6, v36);
        }
      }
      else
      {
        unint64_t v47 = v52;
      }
      a6[v35] = -124;
      if (!_trie_resolve_string(*(void *)(a1 + 8), v47, v40, 1, &v52)) {
        return;
      }
      if (HIDWORD(v52))
      {
        *(void *)a2 = v52;
        long long v49 = a2[1];
        long long v53 = *a2;
        long long v54 = v49;
        uint64_t v55 = *((void *)a2 + 4);
        _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
        return;
      }
      long long v20 = (unsigned char *)*((void *)a2 + 1);
      size_t v21 = *((int *)a2 + 4);
      unint64_t v23 = v52;
      uint64_t v24 = a1;
      long long v25 = a6;
      size_t v22 = v36;
    }
    else
    {
      long long v20 = (unsigned char *)*((void *)a2 + 1);
      size_t v21 = *((int *)a2 + 4);
      unint64_t v23 = v52;
      uint64_t v24 = a1;
      long long v25 = a6;
      size_t v22 = v35;
    }
LABEL_11:
    findAddFlatBucket(v24, v23, v20, v21, v25, v22);
  }
}

double oq_force_meta(uint64_t a1)
{
  if (!*(unsigned char *)a1)
  {
    if (*(void *)(a1 + 32))
    {
      uint64_t v3 = __si_assert_copy_extra_1921(0);
      uint64_t v4 = v3;
      unint64_t v5 = "";
      if (v3) {
        unint64_t v5 = v3;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 452, "queue->just_offsets.count == 0", v5);
      free(v4);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    free(*(void **)(a1 + 16));
    *(unsigned char *)a1 = 1;
    double result = 0.0;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 44) = 0u;
    *(void *)(a1 + 64) = 0xFFFFFFFFLL;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

_DWORD *___bt_findBulk_block_invoke(_DWORD *result, uint64_t *a2)
{
  uint64_t v2 = *((void *)result + 4);
  uint64_t v3 = *(unsigned int *)(v2 + 1176);
  if (v3 < result[10])
  {
    unint64_t v5 = result;
    unsigned int v6 = v3 + 1;
    *(_DWORD *)(v2 + 1176) = v3 + 1;
    unint64_t v7 = (8 * **(unsigned int **)(*(void *)(v2 + 40) + 8 * v3)) & 0x7FFFFFFC0;
    if (v6 >= result[10])
    {
      LODWORD(v9) = 0x10000;
    }
    else
    {
      unint64_t v8 = 0;
      uint64_t v9 = 0x10000;
      do
      {
        unint64_t v10 = (8 * **(unsigned int **)(*(void *)(v2 + 40) + 8 * v6)) & 0x7FFFFFFC0;
        if (v10 <= v7 + v9)
        {
          uint64_t v9 = v10 - v7 + 0x10000;
        }
        else
        {
          uint64_t v11 = *a2;
          unint64_t v12 = v7 >> *(unsigned char *)(*a2 + 264);
          if (v12 < *(int *)(*a2 + 248)
            && (unsigned int v13 = *(void **)(v11 + 8 * v12 + 272)) != 0
            && (unint64_t v14 = v13[2], v14 <= v7)
            && (unint64_t v15 = (int)v9 + v7, v13[3] >= v15)
            && *(void *)(v11 + 224) >= v15)
          {
            madvise((void *)(v13[1] + v7 - v14), (int)v9, 3);
          }
          else
          {
            unint64_t v36 = v7;
            uint64_t v37 = v9;
            int v16 = *(_DWORD **)(v11 + 216);
            uint64_t v38 = 0;
            int v17 = _fd_acquire_fd((uint64_t)v16, &v38);
            do
            {
              int v18 = fcntl(v17, 44, &v36);
              uint64_t v19 = g_prot_error_callback;
              if (v18 != -1 || g_prot_error_callback == 0) {
                break;
              }
              uint64_t v21 = v16[10];
              size_t v22 = __error();
            }
            while (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v19 + 16))(v19, v21, *v22, 12) & 1) != 0);
            _fd_release_fd(v16, v17, 0, v38);
          }
          v8 += v9;
          uint64_t v2 = *((void *)v5 + 4);
          uint64_t v9 = 0x10000;
          unint64_t v7 = v10;
        }
        unsigned int v6 = *(_DWORD *)(v2 + 1176) + 1;
        *(_DWORD *)(v2 + 1176) = v6;
      }
      while (v6 < v5[10] && v8 < 0x70000);
    }
    uint64_t v23 = *a2;
    unint64_t v24 = v7 >> *(unsigned char *)(*a2 + 264);
    if (v24 < *(int *)(*a2 + 248)
      && (long long v25 = *(void **)(v23 + 8 * v24 + 272)) != 0
      && (unint64_t v26 = v25[2], v26 <= v7)
      && (unint64_t v27 = (int)v9 + v7, v25[3] >= v27)
      && *(void *)(v23 + 224) >= v27)
    {
      unsigned int v28 = (void *)(v25[1] + v7 - v26);
      return (_DWORD *)madvise(v28, (int)v9, 3);
    }
    else
    {
      unint64_t v36 = v7;
      uint64_t v37 = v9;
      long long v29 = *(_DWORD **)(v23 + 216);
      uint64_t v38 = 0;
      int v30 = _fd_acquire_fd((uint64_t)v29, &v38);
      do
      {
        int v31 = fcntl(v30, 44, &v36);
        uint64_t v32 = g_prot_error_callback;
        if (v31 != -1 || g_prot_error_callback == 0) {
          break;
        }
        uint64_t v34 = v29[10];
        size_t v35 = __error();
      }
      while (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v32 + 16))(v32, v34, *v35, 12) & 1) != 0);
      return _fd_release_fd(v29, v30, 0, v38);
    }
  }
  return result;
}

unint64_t v2_readVInt64_2086(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a2 + 1;
  int v5 = *(char *)(a1 + *a2);
  unint64_t result = *(unsigned __int8 *)(a1 + *a2);
  if (v5 < 0)
  {
    if (v5 > 0xBFu)
    {
      if (v5 > 0xDFu)
      {
        if (v5 > 0xEFu)
        {
          if (v5 > 0xF7u)
          {
            if (v5 > 0xFBu)
            {
              if (v5 > 0xFDu)
              {
                if (v5 == 255)
                {
                  unint64_t result = *(void *)(a1 + v4);
                  *a2 = v3 + 9;
                }
                else
                {
                  unint64_t v9 = (unint64_t)*(unsigned __int8 *)(a1 + v4) << 48;
                  unint64_t v10 = (unsigned __int8 *)(v3 + a1);
                  unint64_t result = v9 | ((unint64_t)v10[2] << 40) | ((unint64_t)v10[3] << 32) | ((unint64_t)v10[4] << 24) | ((unint64_t)v10[5] << 16) | ((unint64_t)v10[6] << 8) | v10[7];
                  *a2 = v3 + 8;
                }
              }
              else
              {
                unint64_t v7 = ((result & 1) << 48) | ((unint64_t)*(unsigned __int8 *)(a1 + v4) << 40);
                unint64_t v8 = (unsigned __int8 *)(v3 + a1);
                unint64_t result = v7 | ((unint64_t)v8[2] << 32) | ((unint64_t)v8[3] << 24) | ((unint64_t)v8[4] << 16) | ((unint64_t)v8[5] << 8) | v8[6];
                *a2 = v3 + 7;
              }
            }
            else
            {
              unint64_t result = ((result & 3) << 40) | ((unint64_t)*(unsigned __int8 *)(a1 + v4) << 32) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 2) << 24) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 3) << 16) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 4) << 8) | *(unsigned __int8 *)(v3 + a1 + 5);
              *a2 = v3 + 6;
            }
          }
          else
          {
            unint64_t result = ((result & 7) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + v4) << 24) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 2) << 16) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 3) << 8) | *(unsigned __int8 *)(v3 + a1 + 4);
            *a2 = v3 + 5;
          }
        }
        else
        {
          unint64_t result = ((result & 0xF) << 24) | ((unint64_t)*(unsigned __int8 *)(a1 + v4) << 16) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 2) << 8) | *(unsigned __int8 *)(v3 + a1 + 3);
          *a2 = v3 + 4;
        }
      }
      else
      {
        unint64_t result = ((result & 0x1F) << 16) | ((unint64_t)*(unsigned __int8 *)(a1 + v4) << 8) | *(unsigned __int8 *)(v3 + a1 + 2);
        *a2 = v3 + 3;
      }
    }
    else
    {
      unint64_t result = *(unsigned __int8 *)(a1 + v4) | ((result & 0x3F) << 8);
      *a2 = v3 + 2;
    }
  }
  else
  {
    *a2 = v4;
  }
  return result;
}

uint64_t termPropertyID(unsigned __int8 *a1, unsigned int a2)
{
  if (a2 < 2) {
    return 0;
  }
  if (*a1 > 3u)
  {
    unsigned int v13 = &a1[a2];
    unint64_t v14 = v13 - 6;
    if (a2 < 6) {
      unint64_t v14 = a1 + 1;
    }
    int v15 = (char)*(v13 - 1);
    if (v15 < 0) {
      return 0;
    }
    int v17 = *(v13 - 2);
    int v16 = v13 - 2;
    if (v17 == 1 && v15 == 3) {
      uint64_t v19 = (char *)(v16 - 1);
    }
    else {
      uint64_t v19 = (char *)v16;
    }
    if (v19 <= (char *)v14)
    {
LABEL_27:
      if (*v19 != 1) {
        return 0;
      }
    }
    else
    {
      while (*v19 < 0)
      {
        if (--v19 <= (char *)v14)
        {
          uint64_t v19 = (char *)v14;
          goto LABEL_27;
        }
      }
      if (*v19 != 1) {
        return 0;
      }
    }
    uint64_t result = v19[1];
    if (v19[1] < 0)
    {
      int v5 = v19[2];
      if (v19[2] < 0)
      {
        int v6 = v19[3];
        if (v19[3] < 0)
        {
          int v7 = v19[4];
          if (v19[4] < 0)
          {
            int v8 = v19[5];
            if (v8 < 0)
            {
              size_t v22 = __si_assert_copy_extra_1921(0);
              uint64_t v23 = v22;
              unint64_t v24 = "";
              if (v22) {
                unint64_t v24 = v22;
              }
              __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v24);
              free(v23);
              if (__valid_fs(-1))
              {
                MEMORY[0xBAD] = -559038737;
                abort();
              }
              MEMORY[0xC00] = -559038737;
              abort();
            }
            goto LABEL_38;
          }
LABEL_36:
          int v21 = ((v6 & 0x7F) << 14) | (v7 << 21);
LABEL_39:
          unsigned int v20 = v21 & 0xFFFFC07F | ((v5 & 0x7F) << 7);
          return v20 & 0xFFFFFF80 | result & 0x7F;
        }
LABEL_34:
        unsigned int v20 = ((v5 & 0x7F) << 7) | (v6 << 14);
        return v20 & 0xFFFFFF80 | result & 0x7F;
      }
      return result & 0x7F | (v5 << 7);
    }
  }
  else
  {
    int v4 = (char)a1[1];
    uint64_t result = a1[1];
    if (v4 < 0)
    {
      int v5 = a1[2];
      if ((char)a1[2] < 0)
      {
        int v6 = a1[3];
        if ((char)a1[3] < 0)
        {
          int v7 = a1[4];
          if ((char)a1[4] < 0)
          {
            int v8 = (char)a1[5];
            if (v8 < 0)
            {
              unint64_t v9 = __si_assert_copy_extra_1921(0);
              unint64_t v10 = v9;
              uint64_t v11 = "";
              if (v9) {
                uint64_t v11 = v9;
              }
              __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v11);
              free(v10);
              if (__valid_fs(-1)) {
                uint64_t v12 = 2989;
              }
              else {
                uint64_t v12 = 3072;
              }
              *(_DWORD *)uint64_t v12 = -559038737;
              abort();
            }
LABEL_38:
            int v21 = ((v7 & 0x7F) << 21) | (v8 << 28) | ((v6 & 0x7F) << 14);
            goto LABEL_39;
          }
          goto LABEL_36;
        }
        goto LABEL_34;
      }
      return result & 0x7F | (v5 << 7);
    }
  }
  return result;
}

uint64_t __findTermIDsContextMatchPatternsRegExMatch()
{
  return icu_regex_find();
}

void findMatchTermExpansion(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  uint64_t v5 = 0;
  int v6 = a3 + 1;
  LOBYTE(v7) = *a3;
  uint64_t v8 = *(void *)(a1 + 52);
  while (1)
  {
    unint64_t Child = trieGetChild(*(void *)(a1 + 8), *(void *)(a1 + 52), v7);
    if (!Child) {
      break;
    }
    *(void *)(a1 + 52) = Child;
    uint64_t v10 = *(unsigned int *)(a1 + 1140);
    *(_DWORD *)(a1 + 1140) = v10 + 1;
    uint64_t v11 = a1 + 88;
    *(unsigned char *)(v11 + v10) = v7;
    *(unsigned char *)(v11 + *(unsigned int *)(a1 + 1140)) = 0;
    if (!HIDWORD(Child))
    {
      LODWORD(v5) = v5 + 1;
      findAddFlatBucket(a1, Child, 0, 0, 0, 0);
      break;
    }
    int v7 = v6[v5++];
    if (!v7)
    {
      *(void *)(a1 + 1224) += a2;
      findMatchTerm(a1, 0);
      *(void *)(a1 + 1224) -= a2;
      break;
    }
  }
  *(_DWORD *)(a1 + 1140) -= v5;
  *(void *)(a1 + 52) = v8;
}

void findMatchIgnoringDiacritics(uint64_t a1, uint64_t a2)
{
  unint64_t Child = trieGetChild(*(void *)(a1 + 8), a2, 0xCCu);
  uint64_t v5 = Child;
  if (Child)
  {
    uint64_t v6 = *(unsigned int *)(a1 + 1140);
    *(_DWORD *)(a1 + 1140) = v6 + 1;
    *(unsigned char *)(a1 + v6 + 88) = -52;
    switch(HIDWORD(Child))
    {
      case 3:
        if (*(void *)(a1 + 64) > (unint64_t)Child) {
          goto LABEL_33;
        }
        int v21 = __si_assert_copy_extra_1921(*(_DWORD **)(*(void *)(a1 + 8) + 4576));
        size_t v22 = v21;
        uint64_t v23 = "";
        if (v21) {
          uint64_t v23 = v21;
        }
        __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 4641, "child.next < ctx->trie_fat_max", v23, v5, *(void *)(a1 + 64));
        free(v22);
        unint64_t v24 = *(_DWORD **)(*(void *)(a1 + 8) + 4576);
        break;
      case 1:
        if (*(void *)(a1 + 72) > (unint64_t)Child) {
          goto LABEL_33;
        }
        unint64_t v50 = __si_assert_copy_extra_1921(*(_DWORD **)(*(void *)(a1 + 8) + 112));
        uint64_t v51 = v50;
        unint64_t v52 = "";
        if (v50) {
          unint64_t v52 = v50;
        }
        __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 4643, "child.next < ctx->trie_max", v52, v5, *(void *)(a1 + 64));
        free(v51);
        unint64_t v24 = *(_DWORD **)(*(void *)(a1 + 8) + 112);
        break;
      case 0:
        findAddFlatBucket(a1, Child, 0, 0, 0, 0);
LABEL_6:
        --*(_DWORD *)(a1 + 1140);
        goto LABEL_7;
      default:
LABEL_33:
        unsigned __int8 v25 = 0x80;
        do
        {
          unsigned int v26 = v25;
          unint64_t v27 = trieGetChild(*(void *)(a1 + 8), v5, v25);
          if (v27)
          {
            uint64_t v28 = *(unsigned int *)(a1 + 1140);
            *(_DWORD *)(a1 + 1140) = v28 + 1;
            *(unsigned char *)(a1 + v28 + 88) = v25;
            if (HIDWORD(v27))
            {
              *(void *)(a1 + 52) = v27;
              findMatchTerm(a1, 0);
              *(void *)(a1 + 52) = a2;
            }
            else
            {
              findAddFlatBucket(a1, v27, 0, 0, 0, 0);
            }
            --*(_DWORD *)(a1 + 1140);
          }
          ++v25;
        }
        while (v26 < 0xBF);
        goto LABEL_6;
    }
    if (__valid_fsp(v24))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
LABEL_7:
  unint64_t v7 = trieGetChild(*(void *)(a1 + 8), a2, 0xCDu);
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(unsigned int *)(a1 + 1140);
    *(_DWORD *)(a1 + 1140) = v9 + 1;
    *(unsigned char *)(a1 + v9 + 88) = -51;
    if (HIDWORD(v7))
    {
      unsigned __int8 v11 = 0x80;
      do
      {
        unsigned int v12 = v11;
        unint64_t v13 = trieGetChild(*(void *)(a1 + 8), v8, v11);
        if (v13)
        {
          uint64_t v14 = *(unsigned int *)(a1 + 1140);
          *(_DWORD *)(a1 + 1140) = v14 + 1;
          *(unsigned char *)(a1 + v14 + 88) = v11;
          if (HIDWORD(v13))
          {
            *(void *)(a1 + 52) = v13;
            findMatchTerm(a1, 0);
            *(void *)(a1 + 52) = a2;
          }
          else
          {
            findAddFlatBucket(a1, v13, 0, 0, 0, 0);
          }
          --*(_DWORD *)(a1 + 1140);
        }
        ++v11;
      }
      while (v12 < 0xDF);
    }
    else
    {
      findAddFlatBucket(a1, v7, 0, 0, 0, 0);
    }
    --*(_DWORD *)(a1 + 1140);
  }
  unint64_t v10 = trieGetChild(*(void *)(a1 + 8), a2, 0x2Du);
  if (v10)
  {
    if (HIDWORD(v10))
    {
      uint64_t v15 = *(unsigned int *)(a1 + 1140);
      *(_DWORD *)(a1 + 1140) = v15 + 1;
      *(unsigned char *)(a1 + v15 + 88) = 45;
      findMatchTerm(a1, 0);
      --*(_DWORD *)(a1 + 1140);
    }
    else
    {
      findAddFlatBucket(a1, v10, 0, 0, 0, 0);
    }
  }
  unint64_t v16 = trieGetChild(*(void *)(a1 + 8), a2, 0xE2u);
  if (v16)
  {
    uint64_t v17 = *(unsigned int *)(a1 + 1140);
    *(_DWORD *)(a1 + 1140) = v17 + 1;
    *(unsigned char *)(a1 + v17 + 88) = -30;
    if (HIDWORD(v16))
    {
      unint64_t v19 = trieGetChild(*(void *)(a1 + 8), v16, 0x80u);
      uint64_t v18 = *(unsigned int *)(a1 + 1140);
      if (v19)
      {
        *(_DWORD *)(a1 + 1140) = v18 + 1;
        *(unsigned char *)(a1 + v18 + 88) = 0x80;
        if (HIDWORD(v19))
        {
          unint64_t v29 = trieGetChild(*(void *)(a1 + 8), v19, 0x90u);
          uint64_t v20 = *(unsigned int *)(a1 + 1140);
          if (v29)
          {
            *(_DWORD *)(a1 + 1140) = v20 + 1;
            *(unsigned char *)(a1 + v20 + 88) = -112;
            if (HIDWORD(v29))
            {
              *(void *)(a1 + 52) = v29;
              findMatchTerm(a1, 0);
              *(void *)(a1 + 52) = a2;
            }
            else
            {
              findAddFlatBucket(a1, v29, 0, 0, 0, 0);
            }
            LODWORD(v20) = *(_DWORD *)(a1 + 1140) - 1;
          }
        }
        else
        {
          findAddFlatBucket(a1, v19, 0, 0, 0, 0);
          LODWORD(v20) = *(_DWORD *)(a1 + 1140);
        }
        LODWORD(v18) = v20 - 1;
      }
    }
    else
    {
      findAddFlatBucket(a1, v16, 0, 0, 0, 0);
      LODWORD(v18) = *(_DWORD *)(a1 + 1140);
    }
    *(_DWORD *)(a1 + 1140) = v18 - 1;
  }
  unint64_t v30 = trieGetChild(*(void *)(a1 + 8), a2, 0xD6u);
  if (v30)
  {
    uint64_t v31 = v30;
    uint64_t v32 = *(unsigned int *)(a1 + 1140);
    *(_DWORD *)(a1 + 1140) = v32 + 1;
    *(unsigned char *)(a1 + v32 + 88) = -42;
    if (HIDWORD(v30))
    {
      unsigned __int8 v37 = -111;
      do
      {
        unsigned int v38 = v37;
        unint64_t v39 = trieGetChild(*(void *)(a1 + 8), v31, v37);
        if (v39)
        {
          uint64_t v40 = *(unsigned int *)(a1 + 1140);
          *(_DWORD *)(a1 + 1140) = v40 + 1;
          *(unsigned char *)(a1 + v40 + 88) = v37;
          if (HIDWORD(v39))
          {
            *(void *)(a1 + 52) = v39;
            findMatchTerm(a1, 0);
            *(void *)(a1 + 52) = a2;
          }
          else
          {
            findAddFlatBucket(a1, v39, 0, 0, 0, 0);
          }
          --*(_DWORD *)(a1 + 1140);
        }
        ++v37;
      }
      while (v38 < 0xBF);
    }
    else
    {
      findAddFlatBucket(a1, v30, 0, 0, 0, 0);
    }
    --*(_DWORD *)(a1 + 1140);
  }
  unint64_t v33 = trieGetChild(*(void *)(a1 + 8), a2, 0xD7u);
  if (v33)
  {
    uint64_t v34 = v33;
    uint64_t v35 = *(unsigned int *)(a1 + 1140);
    *(_DWORD *)(a1 + 1140) = v35 + 1;
    *(unsigned char *)(a1 + v35 + 88) = -41;
    if (HIDWORD(v33))
    {
      unint64_t v41 = trieGetChild(*(void *)(a1 + 8), v33, 0x80u);
      if (v41)
      {
        uint64_t v42 = *(unsigned int *)(a1 + 1140);
        *(_DWORD *)(a1 + 1140) = v42 + 1;
        *(unsigned char *)(a1 + v42 + 88) = 0x80;
        if (HIDWORD(v41))
        {
          *(void *)(a1 + 52) = v41;
          findMatchTerm(a1, 0);
          *(void *)(a1 + 52) = a2;
        }
        else
        {
          findAddFlatBucket(a1, v41, 0, 0, 0, 0);
        }
        --*(_DWORD *)(a1 + 1140);
      }
      unint64_t v43 = trieGetChild(*(void *)(a1 + 8), v34, 0x81u);
      if (v43)
      {
        uint64_t v44 = *(unsigned int *)(a1 + 1140);
        *(_DWORD *)(a1 + 1140) = v44 + 1;
        *(unsigned char *)(a1 + v44 + 88) = -127;
        if (HIDWORD(v43))
        {
          *(void *)(a1 + 52) = v43;
          findMatchTerm(a1, 0);
          *(void *)(a1 + 52) = a2;
        }
        else
        {
          findAddFlatBucket(a1, v43, 0, 0, 0, 0);
        }
        --*(_DWORD *)(a1 + 1140);
      }
      unint64_t v45 = trieGetChild(*(void *)(a1 + 8), v34, 0x82u);
      if (v45)
      {
        uint64_t v46 = *(unsigned int *)(a1 + 1140);
        *(_DWORD *)(a1 + 1140) = v46 + 1;
        *(unsigned char *)(a1 + v46 + 88) = -126;
        if (HIDWORD(v45))
        {
          *(void *)(a1 + 52) = v45;
          findMatchTerm(a1, 0);
          *(void *)(a1 + 52) = a2;
        }
        else
        {
          findAddFlatBucket(a1, v45, 0, 0, 0, 0);
        }
        --*(_DWORD *)(a1 + 1140);
      }
      unint64_t v47 = trieGetChild(*(void *)(a1 + 8), v34, 0x83u);
      if (v47)
      {
        uint64_t v48 = *(unsigned int *)(a1 + 1140);
        *(_DWORD *)(a1 + 1140) = v48 + 1;
        *(unsigned char *)(a1 + v48 + 88) = -125;
        if (HIDWORD(v47))
        {
          *(void *)(a1 + 52) = v47;
          findMatchTerm(a1, 0);
          *(void *)(a1 + 52) = a2;
        }
        else
        {
          findAddFlatBucket(a1, v47, 0, 0, 0, 0);
        }
        --*(_DWORD *)(a1 + 1140);
      }
      unint64_t v49 = trieGetChild(*(void *)(a1 + 8), v34, 0x84u);
      uint64_t v36 = *(unsigned int *)(a1 + 1140);
      if (v49)
      {
        *(_DWORD *)(a1 + 1140) = v36 + 1;
        *(unsigned char *)(a1 + v36 + 88) = -124;
        if (HIDWORD(v49))
        {
          *(void *)(a1 + 52) = v49;
          findMatchTerm(a1, 0);
          *(void *)(a1 + 52) = a2;
        }
        else
        {
          findAddFlatBucket(a1, v49, 0, 0, 0, 0);
        }
        LODWORD(v36) = *(_DWORD *)(a1 + 1140) - 1;
      }
    }
    else
    {
      findAddFlatBucket(a1, v33, 0, 0, 0, 0);
      LODWORD(v36) = *(_DWORD *)(a1 + 1140);
    }
    *(_DWORD *)(a1 + 1140) = v36 - 1;
  }
}

void findMatchTermChar(uint64_t a1, uint64_t a2, unsigned int a3)
{
  char v3 = a3;
  unint64_t Child = trieGetChild(*(void *)(a1 + 8), a2, a3);
  if (Child)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 1140);
    *(_DWORD *)(a1 + 1140) = v7 + 1;
    uint64_t v8 = a1 + 88;
    *(unsigned char *)(v8 + v7) = v3;
    *(unsigned char *)(v8 + *(unsigned int *)(a1 + 1140)) = 0;
    ++*(void *)(a1 + 1224);
    if (HIDWORD(Child))
    {
      *(void *)(a1 + 52) = Child;
      findMatchTerm(a1, 0);
      *(void *)(a1 + 52) = a2;
    }
    else
    {
      findAddFlatBucket(a1, Child, 0, 0, 0, 0);
    }
    --*(void *)(a1 + 1224);
    --*(_DWORD *)(a1 + 1140);
  }
}

unint64_t trieGetRawChild(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (HIDWORD(a2) == 1)
  {
    uint64_t v5 = mgetBase(a1, a2);
    if (((*(_DWORD *)(v5 + 4 * (a3 >> 5) + 4) >> a3) & 1) == 0) {
      return 0;
    }
    uint64_t v6 = 0;
    uint64_t v7 = (int8x8_t *)(v5 + 4);
    unsigned int v8 = a3 >> 6;
    if (a3 >> 6 != 1)
    {
      if (v8 != 2)
      {
        if (v8 != 3)
        {
LABEL_11:
          uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v7[v8] & ~(-1 << a3)));
          v12.i16[0] = vaddlv_u8(v12);
          unsigned int v4 = *(_DWORD *)(v5 + 4 * (v12.u32[0] + v6) + 38);
          goto LABEL_12;
        }
        uint8x8_t v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v5 + 20));
        v9.i16[0] = vaddlv_u8(v9);
        uint64_t v6 = v9.u32[0];
      }
      uint8x8_t v10 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v5 + 12));
      v10.i16[0] = vaddlv_u8(v10);
      v6 += v10.u32[0];
    }
    uint8x8_t v11 = (uint8x8_t)vcnt_s8(*v7);
    v11.i16[0] = vaddlv_u8(v11);
    v6 += v11.u32[0];
    goto LABEL_11;
  }
  if (HIDWORD(a2) != 3) {
    return 0;
  }
  unsigned int v4 = *(_DWORD *)(*(void *)(a1 + 8) + 1028 * a2 + 4 * a3 + 4);
LABEL_12:
  LODWORD(v13) = v4 >> 1;
  unsigned int v14 = v4 >> 3;
  unint64_t v15 = (unint64_t)(v4 & 7) << 32;
  if ((v4 & 3) == 1)
  {
    unint64_t v15 = 0x100000000;
    unsigned int v14 = v4 >> 2;
  }
  BOOL v16 = (v4 & 1) == 0;
  if (v4) {
    unint64_t v17 = v15;
  }
  else {
    unint64_t v17 = 0;
  }
  if (v16) {
    uint64_t v13 = v13;
  }
  else {
    uint64_t v13 = v14;
  }
  return v17 | v13;
}

unsigned __int8 *localizedFieldTermMatch(uint64_t a1, int a2, unsigned __int8 *a3, int a4, int a5)
{
  uint64_t result = termFieldMatch(a2, a3, a4, a5);
  if (result) {
    return (unsigned __int8 *)icu_search_match();
  }
  return result;
}

BOOL termMatch(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, unsigned __int8 a4)
{
  uint64_t v5 = a3;
  uint64_t v6 = a1;
  unsigned int v7 = *a3;
  if (v7 > 4)
  {
    if (v7 != 42 || termPropertyID(a1, a2) != 2) {
      return matche(v5, v6, a4, 0, 0) == 1;
    }
    return 0;
  }
  if (v7 != *a1) {
    return 0;
  }
  unsigned int v8 = a3 + 1;
  int v9 = a3[1];
  if (v9 != a1[1]) {
    return 0;
  }
  if (v9 != 2)
  {
    uint64_t v6 = a1 + 2;
    uint64_t v5 = a3 + 2;
    if ((v9 & 0x80) != 0) {
      goto LABEL_12;
    }
    return matche(v5, v6, a4, 0, 0) == 1;
  }
  if (a3[2] != a1[2]) {
    return 0;
  }
  uint64_t v6 = a1 + 3;
  unsigned int v8 = a3 + 2;
  uint64_t v5 = a3 + 3;
  if ((a3[2] & 0x80) == 0) {
    return matche(v5, v6, a4, 0, 0) == 1;
  }
LABEL_12:
  int v11 = *v5;
  if (v11 != *v6) {
    return 0;
  }
  uint64_t v5 = v8 + 2;
  if (((char)v11 & 0x80000000) == 0) {
    return matche(v5, ++v6, a4, 0, 0) == 1;
  }
  int v12 = *v5;
  if (v12 != v6[1]) {
    return 0;
  }
  if (((char)v12 & 0x80000000) == 0)
  {
    v6 += 2;
    uint64_t v5 = v8 + 3;
    return matche(v5, v6, a4, 0, 0) == 1;
  }
  BOOL result = 0;
  int v13 = (char)v8[3];
  if ((v13 & 0x80000000) == 0 && v6[2] == v13)
  {
    v6 += 3;
    uint64_t v5 = v8 + 4;
    return matche(v5, v6, a4, 0, 0) == 1;
  }
  return result;
}

uint64_t termNumberCompare(unsigned char *a1, unsigned __int8 *a2)
{
  unsigned int v2 = *a1;
  BOOL v3 = *a1 == 0;
  unsigned int v4 = *a2;
  if (*a1) {
    BOOL v5 = v2 == v4;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
    uint64_t v6 = a2 + 1;
    unsigned int v7 = a1 + 1;
    do
    {
      unsigned int v8 = *v7++;
      unsigned int v2 = v8;
      BOOL v3 = v8 == 0;
      unsigned int v9 = *v6++;
      unsigned int v4 = v9;
      if (v2) {
        BOOL v10 = v2 == v4;
      }
      else {
        BOOL v10 = 0;
      }
    }
    while (v10);
  }
  if (v4) {
    unsigned int v11 = -1;
  }
  else {
    unsigned int v11 = 0;
  }
  if (v2 < v4) {
    unsigned int v12 = -1;
  }
  else {
    unsigned int v12 = 1;
  }
  if (v3) {
    return v11;
  }
  else {
    return v12;
  }
}

void _findMatchTermWildcard(uint64_t a1, uint64_t a2, uint64_t a3, char a4, int a5)
{
  uint64_t v6 = *(unsigned int *)(a1 + 1140);
  if (v6 >= 0x414)
  {
    unsigned int v9 = __si_assert_copy_extra_1921(*(_DWORD **)(*(void *)(a1 + 8) + 4576));
    BOOL v10 = v9;
    unsigned int v11 = "";
    if (v9) {
      unsigned int v11 = v9;
    }
    __message_assert("%s:%u: failed assertion '%s' %s max depth exceeded: %d", "BurstTrie.c", 4526, "ctx->stringLen<CI_UTF8CHARS_BUFFER_SIZE", v11, *(_DWORD *)(a1 + 1140));
    free(v10);
    if (__valid_fsp(*(_DWORD **)(*(void *)(a1 + 8) + 4576)))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  *(_DWORD *)(a1 + 1140) = v6 + 1;
  uint64_t v7 = a1 + 88;
  *(unsigned char *)(v7 + v6) = a4;
  *(unsigned char *)(v7 + *(unsigned int *)(a1 + 1140)) = 0;
  if (HIDWORD(a3))
  {
    *(void *)(a1 + 52) = a3;
    if (a5) {
      findMatchTermWildcard(a1, *(void *)(a1 + 52), 0, 1);
    }
    else {
      findMatchTerm(a1, 0);
    }
    *(void *)(a1 + 52) = a2;
  }
  else
  {
    findAddFlatBucket(a1, a3, 0, 0, 0, 0);
  }
  --*(_DWORD *)(a1 + 1140);
}

void _findMatchRangeChars(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v5 = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 1140);
  *(_DWORD *)(a1 + 1140) = v6 + 1;
  uint64_t v7 = (unsigned __int8 *)(a1 + 88);
  v7[v6] = a3;
  v7[*(unsigned int *)(a1 + 1140)] = 0;
  unsigned int v8 = *(uint64_t **)(a1 + 1240);
  uint64_t v10 = *v8;
  uint64_t v9 = v8[1];
  do
  {
    unsigned int v11 = *(unsigned __int8 *)(a1 + v5 + 88);
    if (!*(unsigned char *)(a1 + v5 + 88)) {
      break;
    }
    unsigned int v12 = *(unsigned __int8 *)(v10 + v5);
    if (!*(unsigned char *)(v10 + v5)) {
      break;
    }
    if (v11 < v12) {
      goto LABEL_95;
    }
    ++v5;
  }
  while (v11 <= v12);
  uint64_t v13 = 0;
  do
  {
    unsigned int v14 = *(unsigned __int8 *)(a1 + v13 + 88);
    if (!*(unsigned char *)(a1 + v13 + 88)) {
      break;
    }
    unsigned int v15 = *(unsigned __int8 *)(v9 + v13);
    if (v14 > v15) {
      goto LABEL_95;
    }
    ++v13;
  }
  while (v14 >= v15);
  if (HIDWORD(a2) == 3)
  {
    uint64_t v16 = *(void *)(a1 + 8);
    if ((unint64_t)a2 < *(void *)(a1 + 64))
    {
      unint64_t v17 = (unsigned int *)(*(void *)(v16 + 8) + 1028 * a2);
      goto LABEL_18;
    }
    int v80 = __si_assert_copy_extra_1921(*(_DWORD **)(v16 + 4576));
    uint64_t v81 = v80;
    unint64_t v82 = "";
    if (v80) {
      unint64_t v82 = v80;
    }
    __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 6136, "child.next < ctx->trie_fat_max", v82, a2, *(void *)(a1 + 64));
    free(v81);
    unint64_t v83 = *(_DWORD **)(*(void *)(a1 + 8) + 4576);
LABEL_138:
    if (!__valid_fsp(v83))
    {
LABEL_169:
      uint64_t v87 = 3072;
LABEL_170:
      *(_DWORD *)uint64_t v87 = -559038737;
      abort();
    }
LABEL_139:
    uint64_t v87 = 2989;
    goto LABEL_170;
  }
  if (HIDWORD(a2) == 1)
  {
    unint64_t v18 = *(void *)(a1 + 72);
    uint64_t v19 = *(void *)(a1 + 8);
    if (a2 < v18)
    {
      unint64_t v17 = (unsigned int *)mgetBase(v19, a2);
LABEL_18:
      unsigned int v20 = *v17;
      if (*(_DWORD *)(a1 + 48) != 1)
      {
        if (!v20) {
          goto LABEL_94;
        }
        int v21 = 0;
LABEL_29:
        size_t v22 = *(unsigned __int8 ***)(a1 + 1240);
        int v23 = *((_DWORD *)v22 + 4);
        unint64_t v24 = *v22;
        int v25 = *(unsigned __int8 *)(a1 + 88);
        BOOL v26 = *(unsigned char *)(a1 + 88) == 0;
        int v27 = **v22;
        BOOL v28 = v25 != v27 || *(unsigned char *)(a1 + 88) == 0;
        unsigned int v29 = *(unsigned __int8 *)(a1 + 88);
        if ((v23 & 0x20) != 0)
        {
          unsigned int v37 = *v24;
          BOOL v38 = *(unsigned char *)(a1 + 88) == 0;
          if (!v28)
          {
            unint64_t v39 = v24 + 1;
            uint64_t v40 = (unsigned __int8 *)(a1 + 89);
            do
            {
              unsigned int v41 = *v40++;
              unsigned int v29 = v41;
              BOOL v38 = v41 == 0;
              unsigned int v42 = *v39++;
              unsigned int v37 = v42;
              if (v29) {
                BOOL v43 = v29 == v37;
              }
              else {
                BOOL v43 = 0;
              }
            }
            while (v43);
          }
          BOOL v44 = v29 < v37;
          if (v38) {
            BOOL v44 = v37 != 0;
          }
          if (v44) {
            goto LABEL_94;
          }
        }
        else
        {
          unsigned int v30 = *v24;
          BOOL v31 = *(unsigned char *)(a1 + 88) == 0;
          if (!v28)
          {
            uint64_t v32 = v24 + 1;
            unint64_t v33 = (unsigned __int8 *)(a1 + 89);
            do
            {
              unsigned int v34 = *v33++;
              unsigned int v29 = v34;
              BOOL v31 = v34 == 0;
              unsigned int v35 = *v32++;
              unsigned int v30 = v35;
              if (v29) {
                BOOL v36 = v29 == v30;
              }
              else {
                BOOL v36 = 0;
              }
            }
            while (v36);
          }
          if (v31 || v29 < v30) {
            goto LABEL_94;
          }
        }
        unint64_t v45 = v22[1];
        unsigned int v46 = *v45;
        if (*(unsigned char *)(a1 + 88)) {
          BOOL v47 = v25 == v46;
        }
        else {
          BOOL v47 = 0;
        }
        char v48 = !v47;
        unsigned int v49 = *(unsigned __int8 *)(a1 + 88);
        if ((v23 & 0x40) != 0)
        {
          if ((v48 & 1) == 0)
          {
            size_t v58 = v45 + 1;
            uint64_t v59 = (unsigned __int8 *)(a1 + 89);
            do
            {
              unsigned int v60 = *v59++;
              unsigned int v49 = v60;
              LOBYTE(v26) = v60 == 0;
              unsigned int v61 = *v58++;
              unsigned int v46 = v61;
              if (v49) {
                BOOL v62 = v49 == v46;
              }
              else {
                BOOL v62 = 0;
              }
            }
            while (v62);
          }
          if (v49 >= v46 && !v26) {
            goto LABEL_94;
          }
        }
        else
        {
          if ((v48 & 1) == 0)
          {
            unint64_t v50 = v45 + 1;
            uint64_t v51 = (unsigned __int8 *)(a1 + 89);
            do
            {
              unsigned int v52 = *v51++;
              unsigned int v49 = v52;
              BOOL v26 = v52 == 0;
              unsigned int v53 = *v50++;
              unsigned int v46 = v53;
              if (v49) {
                BOOL v54 = v49 == v46;
              }
              else {
                BOOL v54 = 0;
              }
            }
            while (v54);
          }
          if (v46) {
            int v55 = -1;
          }
          else {
            int v55 = 0;
          }
          int v56 = (v49 < v46) << 31;
          if (v26) {
            int v57 = v55;
          }
          else {
            int v57 = v56;
          }
          if ((v57 & 0x80000000) == 0) {
            goto LABEL_94;
          }
        }
        uint64_t v63 = v20;
        if (v21)
        {
          LODWORD(v64) = v20 >> 1;
          unsigned int v65 = v20 >> 3;
          unint64_t v66 = (unint64_t)(v20 & 7) << 32;
          if ((v20 & 3) == 1)
          {
            unint64_t v66 = 0x100000000;
            unsigned int v65 = v20 >> 2;
          }
          BOOL v67 = (v20 & 1) == 0;
          if (v20) {
            unint64_t v68 = v66;
          }
          else {
            unint64_t v68 = 0;
          }
          if (v67) {
            uint64_t v64 = v64;
          }
          else {
            uint64_t v64 = v65;
          }
          findAddFlatBucket(a1, v68 | v64, 0, 0, 0, 0);
          goto LABEL_94;
        }
        if ((v23 & 0x610) != 0 || **(unsigned char **)a1)
        {
LABEL_94:
          findMatchRangeChars(a1, a2);
          goto LABEL_95;
        }
        if ((v23 & 4) != 0)
        {
          if ((v25 - 2) > 2 || v25 != v27) {
            goto LABEL_94;
          }
          int v73 = termNumberCompare(v7, *v22);
          if ((v23 & 0x20) != 0)
          {
            if (v73 < 0) {
              goto LABEL_94;
            }
          }
          else if (v73 < 1)
          {
            goto LABEL_94;
          }
          int v74 = termNumberCompare(v7, v45);
          if ((v23 & 0x40) != 0)
          {
            if (v74 > 0) {
              goto LABEL_94;
            }
          }
          else if ((v74 & 0x80000000) == 0)
          {
            goto LABEL_94;
          }
        }
        else if ((v23 & 0x8000) != 0 || v27 != 42 || v24[1])
        {
          uint64_t v69 = (uint64_t)v22[4];
          double v70 = v22[5];
          if (v69)
          {
            if (v70) {
              goto LABEL_102;
            }
            if (!localizedFieldTermMatch(v69, *((_DWORD *)v22 + 5), v7, *(_DWORD *)(a1 + 1140), *((_DWORD *)v22 + 4)))goto LABEL_94; {
LABEL_122:
            }
            unsigned int v75 = *(_DWORD *)(a1 + 1140);
            uint64_t v76 = a1;
            uint64_t v77 = v63;
            long long v78 = v7;
            char v79 = 1;
LABEL_129:
            findHandleMatch(v76, v77, 0, v78, v75, v79);
            goto LABEL_94;
          }
          if (v70)
          {
LABEL_102:
            if (v25 != 1)
            {
              int v71 = termPropertyID(v7, *(_DWORD *)(a1 + 1140));
              uint64_t v72 = 0;
              goto LABEL_154;
            }
            int v71 = *(unsigned __int8 *)(a1 + 89);
            if (v71 == 2)
            {
              int v71 = *(unsigned __int8 *)(a1 + 90);
              if ((*(char *)(a1 + 90) & 0x80000000) == 0)
              {
                uint64_t v72 = 3;
                goto LABEL_154;
              }
              int v88 = *(unsigned __int8 *)(a1 + 91);
              if ((*(char *)(a1 + 91) & 0x80000000) == 0)
              {
                int v71 = v71 & 0x7F | (v88 << 7);
                uint64_t v72 = 4;
                goto LABEL_154;
              }
              int v90 = *(unsigned __int8 *)(a1 + 92);
              if ((*(char *)(a1 + 92) & 0x80000000) == 0)
              {
                int v91 = ((v88 & 0x7F) << 7) | (v90 << 14);
LABEL_152:
                unsigned int v93 = v91 & 0xFFFFFF80 | v71 & 0x7F;
                uint64_t v72 = 5;
                goto LABEL_153;
              }
              int v94 = *(unsigned __int8 *)(a1 + 93);
              if ((*(char *)(a1 + 93) & 0x80000000) == 0)
              {
                unsigned int v93 = ((v90 & 0x7F) << 14) | (v94 << 21) | ((v88 & 0x7F) << 7) | v71 & 0x7F;
                uint64_t v72 = 6;
                goto LABEL_153;
              }
              int v98 = *(char *)(a1 + 94);
              if ((v98 & 0x80000000) == 0)
              {
                int v99 = ((v94 & 0x7F) << 21) | (v98 << 28) | ((v90 & 0x7F) << 14) | ((v88 & 0x7F) << 7) | v71 & 0x7F;
                uint64_t v72 = 7;
                int v71 = v99;
                goto LABEL_154;
              }
            }
            else
            {
              if ((v71 & 0x80) == 0)
              {
                uint64_t v72 = 2;
                goto LABEL_154;
              }
              int v89 = *(unsigned __int8 *)(a1 + 90);
              if ((*(char *)(a1 + 90) & 0x80000000) == 0)
              {
                int v71 = v71 & 0x7F | (v89 << 7);
                uint64_t v72 = 3;
                goto LABEL_154;
              }
              int v92 = *(unsigned __int8 *)(a1 + 91);
              if ((*(char *)(a1 + 91) & 0x80000000) == 0)
              {
                unsigned int v93 = ((v89 & 0x7F) << 7) | (v92 << 14) | v71 & 0x7F;
                uint64_t v72 = 4;
LABEL_153:
                int v71 = v93;
                goto LABEL_154;
              }
              int v95 = *(unsigned __int8 *)(a1 + 92);
              if ((*(char *)(a1 + 92) & 0x80000000) == 0)
              {
                int v91 = ((v92 & 0x7F) << 14) | (v95 << 21) | ((v89 & 0x7F) << 7);
                goto LABEL_152;
              }
              int v100 = *(char *)(a1 + 93);
              if ((v100 & 0x80000000) == 0)
              {
                int v101 = ((v95 & 0x7F) << 21) | (v100 << 28) | ((v92 & 0x7F) << 14) | ((v89 & 0x7F) << 7) | v71 & 0x7F;
                uint64_t v72 = 6;
                int v71 = v101;
LABEL_154:
                if (*((_DWORD *)v22 + 5) == v71)
                {
                  int v96 = *(_DWORD *)(a1 + 1140) - v72;
                  while (v96 >= 1)
                  {
                    unsigned int v97 = *(unsigned __int8 *)(a1 + v72 - 1 + v96 + 88);
                    if (v97 > 5)
                    {
                      if (!__findTermIDsContextMatchPatternsRegExMatch()) {
                        goto LABEL_94;
                      }
                      goto LABEL_122;
                    }
                    --v96;
                    if ((v97 & 0xFFFFFFFD) != 1) {
                      goto LABEL_94;
                    }
                  }
                }
                goto LABEL_94;
              }
            }
            int v102 = __si_assert_copy_extra_1921(0);
            long long v103 = v102;
            long long v104 = "";
            if (v102) {
              long long v104 = v102;
            }
            __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v104);
            free(v103);
            if (!__valid_fs(-1)) {
              goto LABEL_169;
            }
            goto LABEL_139;
          }
          if (*((_DWORD *)v22 + 5) == 1)
          {
            if (termPropertyID(v7, *(_DWORD *)(a1 + 1140)) != 1) {
              goto LABEL_94;
            }
            unint64_t v24 = *v22;
          }
          if (!termMatch(v7, *(_DWORD *)(a1 + 1140), v24, *((_DWORD *)v22 + 6))) {
            goto LABEL_94;
          }
        }
        else if (!termFieldMatch(*((_DWORD *)v22 + 5), v7, *(_DWORD *)(a1 + 1140), *((_DWORD *)v22 + 4)))
        {
          goto LABEL_94;
        }
        if ((v23 & 0x8000) != 0) {
          goto LABEL_94;
        }
        unsigned int v75 = *(_DWORD *)(a1 + 1140);
        uint64_t v76 = a1;
        uint64_t v77 = v63;
        long long v78 = v7;
        char v79 = 0;
        goto LABEL_129;
      }
      if (v20)
      {
        if ((*v17 & 3) == 1)
        {
          if (!(v20 >> 2)) {
            goto LABEL_94;
          }
        }
        else if (!(v20 >> 3))
        {
          goto LABEL_94;
        }
LABEL_26:
        int v21 = 1;
        goto LABEL_29;
      }
LABEL_25:
      if (!(v20 >> 1)) {
        goto LABEL_94;
      }
      goto LABEL_26;
    }
    unint64_t v84 = __si_assert_copy_extra_1921(*(_DWORD **)(v19 + 112));
    uint64_t v85 = v84;
    unsigned int v86 = "";
    if (v84) {
      unsigned int v86 = v84;
    }
    __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 6139, "child.next < ctx->trie_max", v86, a2, *(void *)(a1 + 64));
    free(v85);
    unint64_t v83 = *(_DWORD **)(*(void *)(a1 + 8) + 112);
    goto LABEL_138;
  }
  if (HIDWORD(a2))
  {
    if (*(_DWORD *)(a1 + 48) != 1) {
      goto LABEL_94;
    }
    unsigned int v20 = 0;
    goto LABEL_25;
  }
  findAddFlatBucket(a1, a2, 0, 0, 0, 0);
LABEL_95:
  --*(_DWORD *)(a1 + 1140);
}

uint64_t _dumpTrie(unint64_t a1, int a2, _DWORD *a3, void *a4, uint64_t a5, uint64_t a6)
{
  if (__THREAD_SLOT_KEY)
  {
    unsigned int v12 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v12) {
      goto LABEL_3;
    }
  }
  else
  {
    makeThreadId();
    unsigned int v12 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v12)
    {
LABEL_3:
      uint64_t v13 = v12;
      if ((unint64_t)v12 < 0x801) {
        goto LABEL_4;
      }
    }
  }
  makeThreadId();
  uint64_t v13 = pthread_getspecific(__THREAD_SLOT_KEY);
LABEL_4:
  uint64_t v14 = (uint64_t)v13 - 1;
  uint64_t v15 = (uint64_t)v13 - 1;
  unint64_t v16 = threadData[18 * ((uint64_t)v13 - 1) + 8];
  db_read_lock(a1 + 4600);
  CIOnThreadCleanUpPush(v14, (uint64_t)si_dglock_rdunlock, a1 + 4600);
  unint64_t v17 = a4;
  if (!a4)
  {
    unint64_t v17 = malloc_type_malloc(0x5160uLL, 0x10A00408BF7D057uLL);
    CICleanUpPush(v15, MEMORY[0x1E4F14838], (uint64_t)v17);
  }
  unint64_t v18 = v16;
  uint64_t v19 = malloc_type_malloc(0x18uLL, 0x1020040F21E5318uLL);
  storage_reader_init(a1 + 160, (uint64_t)v19);
  CICleanUpPush(v15, (uint64_t)storage_reader_free, (uint64_t)v19);
  void *v17 = v19;
  v17[1] = a5;
  v17[2] = a6;
  *((_DWORD *)v17 + 6) = 0;
  int v20 = *(_DWORD *)(a1 + 4584);
  uint64_t v51 = 0;
  if (*((void *)v19 + 1))
  {
    if (*((unsigned char *)v19 + 16))
    {
      unint64_t v43 = v18;
      int v21 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
      unint64_t v22 = setThreadIdAndInfo(-1, sStorageReaderExceptionCallbacks, (uint64_t)v19, 0, v21);
      unsigned int v49 = HIDWORD(v22);
      *(_DWORD *)iovec buf = v22;
      unint64_t v48 = __PAIR64__(v23, v24);
      uint64_t v25 = *(void *)&threadData[18 * v22 + 2];
      uint64_t v26 = v25 + 320 * HIDWORD(v22);
      int v27 = *(_DWORD *)(v26 + 312);
      BOOL v28 = *(void (**)(void))(v26 + 224);
      if (v28) {
        v28(*(void *)(v25 + 320 * HIDWORD(v22) + 288));
      }
      unsigned int v47 = *(_DWORD *)buf;
      unsigned int v46 = v49;
      unint64_t v45 = v48;
      if (!_setjmp((int *)v26))
      {
        if (a2) {
          unsigned int v37 = (unint64_t *)&v51;
        }
        else {
          unsigned int v37 = 0;
        }
        dumpTrieFatData(a1, v20 == 1, 1u, 0, (uint64_t)(v17 + 2092), v37, a3, (uint64_t)v17);
        uint64_t v38 = *(void *)&threadData[18 * v47 + 2];
        unsigned int v39 = v46;
        uint64_t v40 = v38 + 320 * v46;
        *(_DWORD *)(v40 + 312) = v27;
        unsigned int v41 = *(void (**)(void))(v40 + 232);
        if (v41) {
          v41(*(void *)(v38 + 320 * v39 + 288));
        }
        dropThreadId(v47, 0, v21);
        goto LABEL_31;
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)BOOL v44 = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v44, 2u);
      }
      *(_DWORD *)(v26 + 312) = v27;
      unsigned int v29 = v45;
      if (__THREAD_SLOT_KEY)
      {
        unsigned int v30 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v30) {
          goto LABEL_36;
        }
      }
      else
      {
        makeThreadId();
        unsigned int v30 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v30) {
          goto LABEL_36;
        }
      }
      BOOL v31 = v30;
      if ((unint64_t)v30 < 0x801)
      {
LABEL_16:
        uint64_t v32 = (uint64_t)v31 - 1;
        unint64_t v33 = &threadData[18 * ((uint64_t)v31 - 1)];
        unsigned int v35 = v33[14];
        unsigned int v34 = v33 + 14;
        if (v35 > v29)
        {
          do
            CIOnThreadCleanUpPop(v32);
          while (*v34 > v29);
        }
        dropThreadId(v47, 1, v21);
        CICleanUpReset(v47, HIDWORD(v45));
LABEL_31:
        unint64_t v18 = v43;
        goto LABEL_32;
      }
LABEL_36:
      makeThreadId();
      BOOL v31 = pthread_getspecific(__THREAD_SLOT_KEY);
      goto LABEL_16;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      *(_WORD *)iovec buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
    }
  }
  else
  {
    if (a2) {
      BOOL v36 = (unint64_t *)&v51;
    }
    else {
      BOOL v36 = (unint64_t *)*((void *)v19 + 1);
    }
    dumpTrieFatData(a1, v20 == 1, 1u, 0, (uint64_t)(v17 + 2092), v36, a3, (uint64_t)v17);
  }
LABEL_32:
  CIOnThreadCleanUpPop(v15);
  return CICleanUpReset(v15, v18);
}

unint64_t dumpTrieFatData(unint64_t result, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, unint64_t *a6, _DWORD *a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(_DWORD *)(result + 144) < a3)
  {
    unint64_t v48 = __si_assert_copy_extra_1921(*(_DWORD **)(result + 4576));
    unsigned int v49 = v48;
    unint64_t v50 = "";
    if (v48) {
      unint64_t v50 = v48;
    }
    __message_assert("%s:%u: failed assertion '%s' %s s: %d, c: %d", "BurstTrie.c", 3423, "s<=getNum(t->baseFatCount)", v50, a3, *(_DWORD *)(v9 + 144));
    free(v49);
    if (__valid_fsp(*(_DWORD **)(v9 + 4576)))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v10 = a8;
  unsigned int v14 = a4;
  uint64_t v15 = a2;
  unsigned int v16 = a3;
  unsigned int v17 = *(_DWORD *)(*(void *)(result + 8) + 1028 * a3);
  if (a2)
  {
    if (v17)
    {
      if ((*(_DWORD *)(*(void *)(result + 8) + 1028 * a3) & 3) == 1) {
        goto LABEL_11;
      }
      unsigned int v18 = v17 >> 3;
      if ((v17 & 7) != 0) {
        goto LABEL_11;
      }
    }
    else
    {
      unsigned int v18 = v17 >> 1;
    }
    if (v18) {
      BOOL result = dumpFlatData(result, 1, *(uint64_t **)a8, v18, a4, a5, a7, *(void (**)(uint64_t, unsigned char *, void, void, uint64_t))(a8 + 8), *(void *)(a8 + 16));
    }
  }
  else if (v17)
  {
    *(unsigned char *)(a5 + a4) = 0;
    BOOL result = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void))(a8 + 8))(a4, a5, *(unsigned int *)(*(void *)(result + 8) + 1028 * a3), 0, *(void *)(a8 + 16));
  }
LABEL_11:
  if (!*a7)
  {
    unint64_t v19 = 0;
    unsigned int v60 = v14 + 1;
    uint64_t v61 = v14;
    int v56 = a6;
    uint64_t v57 = v10;
    unsigned int v55 = v15;
    unsigned int v54 = a3;
    do
    {
      unsigned int v20 = *(_DWORD *)(*(void *)(v9 + 8) + 1028 * v16 + 4 * v19 + 4);
      unsigned int v21 = v20 >> 1;
      unsigned int v22 = v20 >> 3;
      int v23 = v20 & 7;
      if ((v20 & 3) == 1)
      {
        int v23 = 1;
        unsigned int v22 = v20 >> 2;
      }
      BOOL v24 = (v20 & 1) == 0;
      if (v20) {
        int v25 = v23;
      }
      else {
        int v25 = 0;
      }
      if (v24) {
        uint64_t v26 = v21;
      }
      else {
        uint64_t v26 = v22;
      }
      if (!v26) {
        goto LABEL_43;
      }
      *(unsigned char *)(a5 + v61) = v19;
      if (v25)
      {
        if (v25 == 1)
        {
          BOOL result = dumpTrieData(v9, v15, v26, v60, a5, a6, a7, v10);
LABEL_43:
          if (*a7) {
            return result;
          }
          goto LABEL_44;
        }
        if (v25 != 3)
        {
          uint64_t v51 = __si_assert_copy_extra_1921(0);
          unsigned int v52 = v51;
          if (v51) {
            unsigned int v53 = v51;
          }
          else {
            unsigned int v53 = "";
          }
          __message_assert("%s:%u: Unexpected code path %s ", "BurstTrie.c", 3460, v53);
          free(v52);
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        BOOL result = dumpTrieFatData(v9, v15, v26, v60, a5, a6, a7, v10);
        if (*a7) {
          return result;
        }
      }
      else
      {
        BOOL result = dumpFlatData(v9, v15, *(uint64_t **)v10, v26, v60, a5, a7, *(void (**)(uint64_t, unsigned char *, void, void, uint64_t))(v10 + 8), *(void *)(v10 + 16));
        if (!a6) {
          goto LABEL_43;
        }
        unint64_t v27 = *a6;
        if (result <= *a6 || result - *a6 <= 0x10000) {
          goto LABEL_43;
        }
        size_t v58 = *(uint64_t **)v10;
        unint64_t v59 = result;
        unint64_t v28 = result & ~*MEMORY[0x1E4F14AF0];
        uint64_t v29 = *(void *)(*(void *)v10 + 8);
        if (v29)
        {
          int v30 = *(_DWORD *)(v29 + 560);
          if (v30 >= 1)
          {
            for (uint64_t i = 0; i < v30; ++i)
            {
              uint64_t v32 = *(void **)(v29 + 584 + 8 * i);
              if (v32)
              {
                unint64_t v33 = v32[2];
                BOOL v34 = v27 >= v33;
                unint64_t v35 = v27 - v33;
                if (v34)
                {
                  unint64_t v36 = v32[3];
                  uint64_t v37 = v32[1];
                  if (v36 <= v28) {
                    unint64_t v38 = 0;
                  }
                  else {
                    unint64_t v38 = v35;
                  }
                  BOOL result = sync_invalidate_mapping((char *)(v37 + v38), v28 - v27);
                  int v30 = *(_DWORD *)(v29 + 560);
                }
              }
            }
          }
        }
        uint64_t v39 = *v58;
        if (*v58)
        {
          int v40 = *(_DWORD *)(v39 + 248);
          if (v40 >= 1)
          {
            for (uint64_t j = 0; j < v40; ++j)
            {
              unsigned int v42 = *(void **)(v39 + 272 + 8 * j);
              if (v42)
              {
                unint64_t v43 = v42[2];
                BOOL v34 = v27 >= v43;
                unint64_t v44 = v27 - v43;
                if (v34)
                {
                  unint64_t v45 = v42[3];
                  uint64_t v46 = v42[1];
                  if (v45 <= v28) {
                    unint64_t v47 = 0;
                  }
                  else {
                    unint64_t v47 = v44;
                  }
                  BOOL result = sync_invalidate_mapping((char *)(v46 + v47), v28 - v27);
                  int v40 = *(_DWORD *)(v39 + 248);
                }
              }
            }
          }
        }
        a6 = v56;
        uint64_t v10 = v57;
        *int v56 = v59 & ~*MEMORY[0x1E4F14AF0];
        uint64_t v15 = v55;
        unsigned int v16 = v54;
        if (*a7) {
          return result;
        }
      }
LABEL_44:
      BOOL v34 = v19++ >= 0xFF;
    }
    while (!v34);
  }
  return result;
}

unint64_t dumpTrieData(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t a5, unint64_t *a6, _DWORD *a7, uint64_t a8)
{
  uint64_t v8 = a8;
  uint64_t v9 = a7;
  uint64_t v10 = a6;
  uint64_t v11 = a5;
  uint64_t v12 = a2;
  int v66 = 0;
  uint64_t v60 = a8 + 16 * *(int *)(a8 + 24) + 32;
  unsigned int v61 = a2;
  unint64_t result = mgetBase(a1, a3);
LABEL_4:
  unint64_t v16 = result;
  unint64_t v17 = *(unsigned int *)result;
  if (!v12)
  {
    if (*(_DWORD *)result) {
      unint64_t result = (*(uint64_t (**)(void, uint64_t, unint64_t, void, void))(v8 + 8))((v66 + a4), v11, v17, 0, *(void *)(v8 + 16));
    }
    goto LABEL_13;
  }
  if ((v17 & 1) == 0)
  {
    unint64_t v18 = v17 >> 1;
    goto LABEL_11;
  }
  if ((v17 & 3) != 1)
  {
    unint64_t v18 = v17 >> 3;
    if ((v17 & 7) == 0)
    {
LABEL_11:
      if (v18) {
        unint64_t result = dumpFlatData(a1, 1, *(uint64_t **)v8, v18, v66 + a4, v11, v9, *(void (**)(uint64_t, unsigned char *, void, void, uint64_t))(v8 + 8), *(void *)(v8 + 16));
      }
    }
  }
LABEL_13:
  int v19 = 0;
  uint64_t v67 = v66;
  if (*v9) {
    goto LABEL_58;
  }
LABEL_14:
  if (v19 > 255) {
    goto LABEL_58;
  }
  uint64_t v70 = (v67 + a4);
  unsigned int v69 = v70 + 1;
  int v66 = v67 + 1;
  do
  {
    if (((*(_DWORD *)(v16 + 4 * (v19 >> 5) + 4) >> v19) & 1) == 0) {
      goto LABEL_56;
    }
    uint64_t v20 = 0;
    unsigned int v21 = v19 >> 6;
    if (v21 == 1)
    {
      unsigned int v22 = (int8x8_t *)(v16 + 4);
    }
    else
    {
      unsigned int v22 = (int8x8_t *)(v16 + 4);
      if (v21 != 2)
      {
        if (v21 != 3) {
          goto LABEL_24;
        }
        uint8x8_t v23 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v16 + 20));
        v23.i16[0] = vaddlv_u8(v23);
        uint64_t v20 = v23.u32[0];
      }
      uint8x8_t v24 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v16 + 12));
      v24.i16[0] = vaddlv_u8(v24);
      v20 += v24.u32[0];
    }
    uint8x8_t v25 = (uint8x8_t)vcnt_s8(*v22);
    v25.i16[0] = vaddlv_u8(v25);
    v20 += v25.u32[0];
LABEL_24:
    uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v22[v21] & ~(-1 << v19)));
    v26.i16[0] = vaddlv_u8(v26);
    unsigned int v27 = *(_DWORD *)(v16 + 4 * (v26.u32[0] + v20) + 38);
    if (v27)
    {
      if ((v27 & 3) == 1)
      {
        LODWORD(v14) = v27 >> 2;
        *(unsigned char *)(v11 + v70) = v19;
      }
      else
      {
        uint64_t v14 = v27 >> 3;
        *(unsigned char *)(v11 + v70) = v19;
        int v28 = v27 & 7;
        if (!v28) {
          goto LABEL_30;
        }
        if (v28 == 3)
        {
          int v29 = *(_DWORD *)(v8 + 24);
          *(_DWORD *)(v8 + 24) = v66 + v29;
          unint64_t result = dumpTrieFatData(a1, v12, v14, v69, v11, v10, v9, v8);
          *(_DWORD *)(v8 + 24) = v29;
          goto LABEL_56;
        }
        if (v28 != 1)
        {
          int v56 = __si_assert_copy_extra_1921(0);
          uint64_t v57 = v56;
          if (v56) {
            size_t v58 = v56;
          }
          else {
            size_t v58 = "";
          }
          __message_assert("%s:%u: Unexpected code path %s ", "BurstTrie.c", 3562, v58);
          free(v57);
          MEMORY[0xBAD] = -559038737;
          abort();
        }
      }
      uint64_t v15 = v60 + 16 * (int)v67;
      *(_DWORD *)(v15 + 8) = v19;
      *(void *)uint64_t v15 = v16;
      unint64_t result = mgetBase(a1, v14);
      goto LABEL_4;
    }
    LODWORD(v14) = v27 >> 1;
    *(unsigned char *)(v11 + v70) = v19;
LABEL_30:
    unint64_t result = dumpFlatData(a1, v12, *(uint64_t **)v8, v14, v69, v11, v9, *(void (**)(uint64_t, unsigned char *, void, void, uint64_t))(v8 + 8), *(void *)(v8 + 16));
    if (v10)
    {
      unint64_t v30 = result;
      unint64_t v31 = *v10;
      if (result > *v10 && result - *v10 > 0x10000)
      {
        uint64_t v32 = *(uint64_t **)v8;
        unint64_t v33 = result & ~*MEMORY[0x1E4F14AF0];
        uint64_t v34 = *(void *)(*(void *)v8 + 8);
        if (v34)
        {
          int v35 = *(_DWORD *)(v34 + 560);
          if (v35 >= 1)
          {
            for (uint64_t i = 0; i < v35; ++i)
            {
              uint64_t v37 = *(void **)(v34 + 584 + 8 * i);
              if (v37)
              {
                unint64_t v38 = v37[2];
                BOOL v39 = v31 >= v38;
                unint64_t v40 = v31 - v38;
                if (v39)
                {
                  unint64_t v41 = v37[3];
                  uint64_t v42 = v37[1];
                  if (v41 <= v33) {
                    unint64_t v43 = 0;
                  }
                  else {
                    unint64_t v43 = v40;
                  }
                  unint64_t result = sync_invalidate_mapping((char *)(v42 + v43), v33 - v31);
                  int v35 = *(_DWORD *)(v34 + 560);
                }
              }
            }
          }
        }
        uint64_t v44 = *v32;
        uint64_t v12 = v61;
        if (v44)
        {
          int v45 = *(_DWORD *)(v44 + 248);
          if (v45 >= 1)
          {
            for (uint64_t j = 0; j < v45; ++j)
            {
              unint64_t v47 = *(void **)(v44 + 272 + 8 * j);
              if (v47)
              {
                unint64_t v48 = v47[2];
                BOOL v39 = v31 >= v48;
                unint64_t v49 = v31 - v48;
                if (v39)
                {
                  unint64_t v50 = v47[3];
                  uint64_t v51 = v47[1];
                  if (v50 <= v33) {
                    unint64_t v52 = 0;
                  }
                  else {
                    unint64_t v52 = v49;
                  }
                  unint64_t result = sync_invalidate_mapping((char *)(v51 + v52), v33 - v31);
                  int v45 = *(_DWORD *)(v44 + 248);
                }
              }
            }
          }
        }
        uint64_t v10 = a6;
        uint64_t v9 = a7;
        *a6 = v30 & ~*MEMORY[0x1E4F14AF0];
        uint64_t v8 = a8;
        uint64_t v11 = a5;
      }
    }
LABEL_56:
    if (*v9) {
      break;
    }
  }
  while (v19++ < 255);
LABEL_58:
  while (1)
  {
    uint64_t v54 = v67;
    if (!v67) {
      return result;
    }
    --v67;
    uint64_t v55 = v60 + 16 * (v54 - 1);
    int v19 = *(_DWORD *)(v55 + 8) + 1;
    unint64_t v16 = *(void *)v55;
    if (!*v9) {
      goto LABEL_14;
    }
  }
}

uint64_t scanTrieFatData(uint64_t result, unsigned int a2, unint64_t a3, unint64_t a4, int *a5)
{
  uint64_t v6 = result;
  if (*(_DWORD *)(result + 144) < a2)
  {
    uint8x8_t v23 = __si_assert_copy_extra_1921(*(_DWORD **)(result + 4576));
    uint8x8_t v24 = v23;
    uint8x8_t v25 = "";
    if (v23) {
      uint8x8_t v25 = v23;
    }
    __message_assert("%s:%u: failed assertion '%s' %s s: %d, c: %d", "BurstTrie.c", 3248, "s<=getNum(t->baseFatCount)", v25, a2, *(_DWORD *)(v6 + 144));
    free(v24);
    if (__valid_fsp(*(_DWORD **)(v6 + 4576)))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v10 = 0;
  uint64_t v11 = 1028 * a2 + 4;
  do
  {
    unsigned int v12 = *(_DWORD *)(*(void *)(v6 + 8) + v11 + v10);
    unsigned int v13 = v12 >> 1;
    unsigned int v14 = v12 >> 3;
    int v15 = v12 & 7;
    if ((v12 & 3) == 1)
    {
      int v15 = 1;
      unsigned int v14 = v12 >> 2;
    }
    BOOL v16 = (v12 & 1) == 0;
    if (v12) {
      int v17 = v15;
    }
    else {
      int v17 = 0;
    }
    if (v16) {
      uint64_t v18 = v13;
    }
    else {
      uint64_t v18 = v14;
    }
    if (v18)
    {
      if (v17)
      {
        if (v17 == 1)
        {
          unint64_t result = scanTrieData(v6, v18, a3, a4, a5);
        }
        else
        {
          if (v17 != 3)
          {
            uint8x8_t v26 = __si_assert_copy_extra_1921(0);
            unsigned int v27 = v26;
            if (v26) {
              int v28 = v26;
            }
            else {
              int v28 = "";
            }
            __message_assert("%s:%u: Unexpected code path %s ", "BurstTrie.c", 3265, v28);
            free(v27);
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          unint64_t result = scanTrieFatData(v6, v18, a3, a4, a5);
        }
      }
      else if (v18 << 6 > a3 && v18 << 6 < a4)
      {
        uint64_t v20 = __si_assert_copy_extra_1921(0);
        unsigned int v21 = v20;
        unsigned int v22 = "";
        if (v20) {
          unsigned int v22 = v20;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 3263, "!(offset>flatPagePtr && offset<flatPageEnd)", v22);
        free(v21);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
    }
    v10 += 4;
  }
  while (v10 != 1024);
  return result;
}

uint64_t scanTrieData(uint64_t a1, unsigned int a2, unint64_t a3, unint64_t a4, int *a5)
{
  int v8 = 0;
  uint64_t v34 = (uint64_t)&a5[4 * *a5 + 2];
  uint64_t result = mgetBase(a1, a2);
LABEL_4:
  uint64_t v12 = result;
  int v13 = 0;
  uint64_t v14 = v8;
LABEL_5:
  int v15 = (int8x8_t *)(v12 + 4);
  do
  {
    if (((*(_DWORD *)(v12 + 4 * (v13 >> 5) + 4) >> v13) & 1) == 0) {
      goto LABEL_12;
    }
    uint64_t v18 = 0;
    unsigned int v19 = v13 >> 6;
    if (v19 != 1)
    {
      if (v19 != 2)
      {
        if (v19 != 3) {
          goto LABEL_20;
        }
        uint8x8_t v20 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v12 + 20));
        v20.i16[0] = vaddlv_u8(v20);
        uint64_t v18 = v20.u32[0];
      }
      uint8x8_t v21 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v12 + 12));
      v21.i16[0] = vaddlv_u8(v21);
      v18 += v21.u32[0];
    }
    uint8x8_t v22 = (uint8x8_t)vcnt_s8(*v15);
    v22.i16[0] = vaddlv_u8(v22);
    v18 += v22.u32[0];
LABEL_20:
    uint8x8_t v23 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v15[v19] & ~(-1 << v13)));
    v23.i16[0] = vaddlv_u8(v23);
    unsigned int v24 = *(_DWORD *)(v12 + 4 * (v23.u32[0] + v18) + 38);
    if ((v24 & 1) == 0)
    {
      LODWORD(v10) = v24 >> 1;
LABEL_7:
      unint64_t v16 = (unint64_t)v10 << 6;
      if (v16 > a3 && v16 < a4)
      {
        unint64_t v31 = __si_assert_copy_extra_1921(0);
        uint64_t v32 = v31;
        unint64_t v33 = "";
        if (v31) {
          unint64_t v33 = v31;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 3227, "!(offset>flatPagePtr && offset<flatPageEnd)", v33);
        free(v32);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      goto LABEL_12;
    }
    if ((v24 & 3) == 1)
    {
      LODWORD(v10) = v24 >> 2;
LABEL_3:
      uint64_t v11 = v34 + 16 * (int)v14;
      *(_DWORD *)(v11 + 8) = v13;
      *(void *)uint64_t v11 = v12;
      int v8 = v14 + 1;
      uint64_t result = mgetBase(a1, v10);
      goto LABEL_4;
    }
    uint64_t v10 = v24 >> 3;
    int v25 = v24 & 7;
    if (!v25) {
      goto LABEL_7;
    }
    if (v25 != 3)
    {
      if (v25 != 1)
      {
        int v28 = __si_assert_copy_extra_1921(0);
        int v29 = v28;
        if (v28) {
          unint64_t v30 = v28;
        }
        else {
          unint64_t v30 = "";
        }
        __message_assert("%s:%u: Unexpected code path %s ", "BurstTrie.c", 3229, v30);
        free(v29);
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      goto LABEL_3;
    }
    int v26 = *a5;
    *a5 += v14 + 1;
    uint64_t result = scanTrieFatData(a1, v10, a3, a4, a5);
    *a5 = v26;
LABEL_12:
    ++v13;
  }
  while (v13 != 256);
  while (v14)
  {
    --v14;
    uint64_t v27 = v34 + 16 * v14;
    int v13 = *(_DWORD *)(v27 + 8) + 1;
    uint64_t v12 = *(void *)v27;
    if (v13 <= 255) {
      goto LABEL_5;
    }
  }
  return result;
}

uint64_t trieLastCompactTermOffset(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4584) == 1)
  {
    int v2 = 0;
    unint64_t v3 = 1;
LABEL_3:
    int v4 = v2 - 1;
    while (2)
    {
      if (v3 <= *(unsigned int *)(a1 + 144))
      {
        uint64_t v5 = *(void *)(a1 + 8);
        unint64_t v6 = *(unsigned int *)(v5 + 1028 * v3);
        unint64_t v7 = v6 >> 1;
        unint64_t v8 = v6 >> 3;
        uint64_t v9 = v6 & 7;
        if ((v6 & 3) == 1)
        {
          uint64_t v9 = 1;
          unint64_t v8 = v6 >> 2;
        }
        if (v6) {
          uint64_t v10 = v9;
        }
        else {
          uint64_t v10 = 0;
        }
        if (*(_DWORD *)(v5 + 1028 * v3)) {
          unint64_t v7 = v8;
        }
        uint64_t v11 = v5 + 1028 * v3;
        uint64_t v12 = 1024;
        while (1)
        {
          unint64_t v13 = *(unsigned int *)(v11 + v12);
          unint64_t v14 = v13 >> 1;
          unint64_t v15 = v13 >> 3;
          uint64_t v16 = v13 & 7;
          if ((v13 & 3) == 1)
          {
            uint64_t v16 = 1;
            unint64_t v15 = v13 >> 2;
          }
          uint64_t v17 = (v13 & 1) != 0 ? v16 : 0;
          unint64_t v3 = (*(_DWORD *)(v11 + v12) & 1) != 0 ? v15 : v14;
          if (v3) {
            break;
          }
          v12 -= 4;
          if (!v12)
          {
            uint64_t v17 = v10;
            unint64_t v3 = v7;
            goto LABEL_50;
          }
        }
        switch(v17)
        {
          case 3:
            ++v2;
            ++v4;
            if (v2 != 1045) {
              continue;
            }
            break;
          case 0:
LABEL_50:
            uint64_t v21 = v17 << 32;
            unint64_t v22 = v3;
LABEL_51:
            return flatLastCompactTermOffset(a1, v21 | v22);
          case 1:
            while ((v4 + 2) <= 0x414)
            {
              uint64_t v18 = (unsigned int *)mgetBase(a1, v3);
              unint64_t v20 = *v18;
              if (v20)
              {
                if ((v20 & 3) == 1)
                {
                  unint64_t v22 = v20 >> 2;
                  uint64_t v21 = 0x100000000;
                }
                else
                {
                  unint64_t v22 = v20 >> 3;
                  uint64_t v21 = (v20 & 7) << 32;
                }
              }
              else
              {
                uint64_t v21 = 0;
                unint64_t v22 = v20 >> 1;
              }
              unsigned int v23 = v18[1];
              unsigned int v24 = v18[2];
              int v25 = v24 & v23;
              int v26 = v24 ^ v23;
              unsigned int v27 = v18[3];
              unsigned int v28 = v18[4];
              int v29 = v26 ^ v27;
              int v30 = v26 & v27;
              int v31 = v29 & v28;
              int v32 = v29 & v28 | v30;
              int v33 = v29 ^ v28;
              int v34 = v31 & v25;
              int v35 = v32 ^ v25;
              unsigned int v36 = v18[5];
              unsigned int v37 = v18[6];
              int v38 = v33 ^ v36;
              int v39 = (v33 ^ v36) & v37 | v33 & v36;
              int v40 = v38 ^ v37;
              unsigned int v41 = v18[7];
              unsigned int v42 = v18[8];
              int v43 = v40 ^ v41;
              int v44 = (v40 ^ v41) & v42 | v40 & v41;
              int v45 = v43 ^ v42;
              int v46 = v39 ^ v35;
              int v47 = (v44 & (v39 ^ v35) | v39 & v35) ^ v34;
              v19.i32[0] = v44 & v46 & v34;
              int8x8_t v48 = vcnt_s8(v19);
              v48.i16[0] = vaddlv_u8((uint8x8_t)v48);
              __int32 v49 = v48.i32[0];
              v48.i32[0] = v47;
              int8x8_t v50 = vcnt_s8(v48);
              v50.i16[0] = vaddlv_u8((uint8x8_t)v50);
              __int32 v51 = v50.i32[0];
              v50.i32[0] = v44 ^ v46;
              int8x8_t v52 = vcnt_s8(v50);
              v52.i16[0] = vaddlv_u8((uint8x8_t)v52);
              __int32 v53 = v52.i32[0];
              v52.i32[0] = v45;
              uint8x8_t v54 = (uint8x8_t)vcnt_s8(v52);
              v54.i16[0] = vaddlv_u8(v54);
              __int32 v55 = v54.i32[0] + 2 * v53 + 8 * v49 + 4 * v51;
              if (!v55) {
                goto LABEL_51;
              }
              unint64_t v56 = *(unsigned int *)((char *)&v18[v55 - 1 + 9] + 2);
              unint64_t v57 = v56 >> 1;
              unint64_t v58 = v56 >> 3;
              uint64_t v59 = v56 & 7;
              if ((v56 & 3) == 1)
              {
                uint64_t v59 = 1;
                unint64_t v58 = v56 >> 2;
              }
              BOOL v60 = (v56 & 1) == 0;
              uint64_t v61 = (v56 & 1) != 0 ? v59 : 0;
              unint64_t v3 = v60 ? v57 : v58;
              if (!v3) {
                goto LABEL_51;
              }
              ++v4;
              if (v61 != 1)
              {
                if (!v61)
                {
                  unint64_t v22 = v3;
                  uint64_t v21 = 0;
                  goto LABEL_51;
                }
                if (v61 == 3)
                {
                  int v2 = v4 + 2;
                  if ((v4 + 2) <= 0x414) {
                    goto LABEL_3;
                  }
                }
                return 0;
              }
            }
            break;
        }
      }
      break;
    }
  }
  return 0;
}

uint64_t ___bt_findTokens_block_invoke(void *a1, _DWORD *a2, unsigned int a3)
{
  int v6 = *a2 - a2[2];
  unint64_t v7 = *(void *)(*(void *)(a1[5] + 8) + 24);
  if (*(void *)(*(void *)(a1[4] + 8) + 24) + 1 >= v7)
  {
    size_t v8 = 2 * v7;
    if (((v7 >> 13) & 0x7FFFFFFFFFFFLL) == 0 && 16 * v7 > *MEMORY[0x1E4F14B00]) {
      ++sTotal;
    }
    uint64_t v10 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, v8, 8uLL, 0x31F9A007uLL);
    if (!v10 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)unint64_t v13 = 0;
      _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", v13, 2u);
    }
    memcpy(v10, *(const void **)(*(void *)(a1[6] + 8) + 24), 8 * *(void *)(*(void *)(a1[5] + 8) + 24));
    if (*(void *)(*(void *)(a1[5] + 8) + 24) >= 0x21uLL) {
      free(*(void **)(*(void *)(a1[6] + 8) + 24));
    }
    *(void *)(*(void *)(a1[6] + 8) + 24) = v10;
    *(void *)(*(void *)(a1[5] + 8) + 24) = v8;
  }
  uint64_t result = TokenDataAddRange(a1[7], (unsigned __int16)v6 | ((unsigned __int16)a3 << 16));
  if (result)
  {
    if (v6 + a3 < *(_DWORD *)(a1[7] + 20))
    {
      *(void *)(*(void *)(*(void *)(a1[6] + 8) + 24) + (*(void *)(*(void *)(a1[4] + 8) + 24) << 6)) = *(void *)a2 + a3;
      *(_DWORD *)(*(void *)(*(void *)(a1[6] + 8) + 24)
                + (*(void *)(*(void *)(a1[4] + 8) + 24) << 6)
                + 56) = a2[14] - a3;
      *(void *)(*(void *)(*(void *)(a1[6] + 8) + 24)
                + (*(void *)(*(void *)(a1[4] + 8) + 24) << 6)
                + 8) = *((void *)a2 + 1);
      int v12 = a2[5];
      *(_DWORD *)(*(void *)(*(void *)(a1[6] + 8) + 24)
                + (*(void *)(*(void *)(a1[4] + 8) + 24) << 6)
                + 16) = a2[4];
      *(_DWORD *)(*(void *)(*(void *)(a1[6] + 8) + 24)
                + ((*(void *)(*(void *)(a1[4] + 8) + 24))++ << 6)
                + 20) = v12;
    }
  }
  return result;
}

void ___bt_resolveTokens_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 1152))
  {
    uint64_t v3 = 0;
    while (1)
    {
      if (**(unsigned char **)a2) {
        return;
      }
      int v4 = (int *)(*(void *)(a2 + 1144) + (v3 << 6));
      *(void *)(a2 + 1240) = v4;
      uint64_t v5 = *(unsigned __int8 **)v4;
      *(void *)(a2 + 1224) = *(void *)v4;
      *(void *)(a2 + 1232) = v5;
      *(_DWORD *)(a2 + 1140) = 0;
      *(unsigned char *)(a2 + 88) = 0;
      int v6 = *(_DWORD **)(a2 + 8);
      unint64_t v7 = *v6;
      unint64_t v8 = v7 >> 1;
      unint64_t v9 = v7 >> 3;
      uint64_t v10 = (v7 & 7) << 32;
      if ((v7 & 3) == 1)
      {
        uint64_t v10 = 0x100000000;
        unint64_t v9 = v7 >> 2;
      }
      if (v7) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = 0;
      }
      if (*v6) {
        unint64_t v8 = v9;
      }
      unint64_t v12 = v11 | v8;
      *(void *)(a2 + 52) = v11 | v8;
      unint64_t v13 = *(unsigned __int8 **)v4;
      if (*(void *)v4)
      {
        if (*v13 <= 3u) {
          break;
        }
      }
LABEL_30:
      uint64_t v25 = *(void *)(a1 + 32);
      unint64_t v26 = v4[14];
      unint64_t v65 = 0;
      unsigned int v27 = v13;
      if (v4[5] >= 7)
      {
        unsigned int v27 = v13;
        if (*v13 == 1)
        {
          int v28 = v13[1];
          if ((char)v13[1] < 0)
          {
            int v30 = v13[2];
            if ((char)v13[2] < 0)
            {
              int v31 = v13[3];
              if ((char)v13[3] < 0)
              {
                int v32 = v13[4];
                if ((char)v13[4] < 0)
                {
                  int v33 = (char)v13[5];
                  if (v33 < 0) {
                    goto LABEL_113;
                  }
                  unint64_t v29 = 6;
                  if ((((v32 & 0x7F) << 21) | (v33 << 28) | ((v31 & 0x7F) << 14) | ((v30 & 0x7F) << 7) | v28 & 0x7F) != 2) {
                    goto LABEL_54;
                  }
                }
                else
                {
                  unint64_t v29 = 5;
                  if ((((v31 & 0x7F) << 14) | (v32 << 21) | ((v30 & 0x7F) << 7) | v28 & 0x7F) != 2) {
                    goto LABEL_54;
                  }
                }
              }
              else
              {
                unint64_t v29 = 4;
                if ((((v30 & 0x7F) << 7) | (v31 << 14) | v28 & 0x7F) != 2) {
                  goto LABEL_54;
                }
              }
            }
            else
            {
              unint64_t v29 = 3;
              if ((v28 & 0x7F | (v30 << 7)) != 2) {
                goto LABEL_54;
              }
            }
          }
          else
          {
            unint64_t v29 = 2;
            if (v28 != 2) {
              goto LABEL_54;
            }
          }
          unint64_t v34 = v29 + 1;
          if ((char)v13[v29] < 0)
          {
            unint64_t v35 = v29 + 2;
            if ((char)v13[v34] < 0)
            {
              unint64_t v34 = v29 + 3;
              if (((char)v13[v35] & 0x80000000) == 0) {
                goto LABEL_51;
              }
              unint64_t v35 = v29 + 4;
              if ((char)v13[v34] < 0)
              {
                if ((char)v13[v35] < 0)
                {
LABEL_113:
                  uint64_t v61 = __si_assert_copy_extra_1921(0);
                  BOOL v62 = v61;
                  uint64_t v63 = "";
                  if (v61) {
                    uint64_t v63 = v61;
                  }
                  __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v63);
                  free(v62);
                  if (__valid_fs(-1))
                  {
                    MEMORY[0xBAD] = -559038737;
                    abort();
                  }
                  MEMORY[0xC00] = -559038737;
                  abort();
                }
                v29 += 5;
                goto LABEL_54;
              }
            }
            unint64_t v29 = v35;
          }
          else
          {
LABEL_51:
            unint64_t v29 = v34;
          }
LABEL_54:
          unsigned int v27 = v13;
          if (v29 <= v26)
          {
            int v36 = _trie_resolve_string((uint64_t)v6, v12, (uint64_t)v13, v29, &v65);
            unsigned int v27 = v13;
            if (v36)
            {
              unsigned int v27 = &v13[v36];
              if (HIDWORD(v65)) {
                *(void *)(a2 + 52) = v65;
              }
              else {
                findAddFlatBucket(a2, v65, v13, v36, 0, 0);
              }
            }
          }
        }
      }
      unsigned int v37 = &v13[v26];
      if (v13) {
        BOOL v38 = v27 >= v37;
      }
      else {
        BOOL v38 = 1;
      }
      if (v38) {
        goto LABEL_3;
      }
      while (2)
      {
        uint64_t v39 = 0;
        uint64_t v40 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[(unint64_t)*v27 >> 4];
        uint64_t v41 = *(void *)(a2 + 8);
        unint64_t v42 = *(void *)(a2 + 52);
        uint64_t v43 = HIDWORD(*(void *)(a2 + 52));
        while (v43 == 3)
        {
          unint64_t v53 = *(unsigned int *)(*(void *)(v41 + 8) + 1028 * v42 + 4 * *((unsigned __int8 *)&tcm + v27[v39]) + 4);
          if (v53)
          {
LABEL_75:
            if ((v53 & 3) == 1)
            {
              unint64_t v42 = v53 >> 2;
              if (!(v53 >> 2)) {
                goto LABEL_3;
              }
              uint64_t v43 = 1;
            }
            else
            {
              unint64_t v42 = v53 >> 3;
              if (!(v53 >> 3)) {
                goto LABEL_3;
              }
              uint64_t v43 = v53 & 7;
            }
            goto LABEL_64;
          }
LABEL_79:
          unint64_t v42 = v53 >> 1;
          if (!(v53 >> 1)) {
            goto LABEL_3;
          }
          uint64_t v43 = 0;
LABEL_64:
          if (v40 == ++v39) {
            goto LABEL_86;
          }
        }
        if (v43 == 1)
        {
          uint64_t v44 = mgetBase(v41, v42);
          unint64_t v45 = *((unsigned __int8 *)&tcm + v27[v39]);
          if (((*(_DWORD *)(v44 + ((v45 >> 3) & 0x1C) + 4) >> v45) & 1) == 0) {
            break;
          }
          uint64_t v46 = 0;
          int v47 = (int8x8_t *)(v44 + 4);
          unint64_t v48 = v45 >> 6;
          if ((v45 >> 6) == 1) {
            goto LABEL_73;
          }
          if (v48 == 2) {
            goto LABEL_72;
          }
          if (v48 == 3)
          {
            uint8x8_t v49 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v44 + 20));
            v49.i16[0] = vaddlv_u8(v49);
            uint64_t v46 = v49.u32[0];
LABEL_72:
            uint8x8_t v50 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v44 + 12));
            v50.i16[0] = vaddlv_u8(v50);
            v46 += v50.u32[0];
LABEL_73:
            uint8x8_t v51 = (uint8x8_t)vcnt_s8(*v47);
            v51.i16[0] = vaddlv_u8(v51);
            v46 += v51.u32[0];
          }
          uint8x8_t v52 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v47[v48] & ~(-1 << v45)));
          v52.i16[0] = vaddlv_u8(v52);
          unint64_t v53 = *(unsigned int *)(v44 + 4 * (v52.u32[0] + v46) + 38);
          if (v53) {
            goto LABEL_75;
          }
          goto LABEL_79;
        }
        if (v43 || !v42) {
          break;
        }
        LODWORD(v43) = 0;
        LODWORD(v40) = v39;
LABEL_86:
        unint64_t v65 = __PAIR64__(v43, v42);
        if (!v40) {
          break;
        }
        v27 += (int)v40;
        unint64_t v54 = v65;
        *(void *)(a2 + 52) = v65;
        switch(HIDWORD(v54))
        {
          case 1:
            __int32 v55 = (_DWORD *)mgetBase(*(void *)(a2 + 8), v54);
LABEL_91:
            unint64_t v56 = *v55;
            if (*(_DWORD *)(a2 + 48) == 1)
            {
              unint64_t v57 = v56 >> 1;
              unint64_t v58 = v56 >> 3;
              uint64_t v59 = (v56 & 7) << 32;
              if ((v56 & 3) == 1)
              {
                uint64_t v59 = 0x100000000;
                unint64_t v58 = v56 >> 2;
              }
              if (v56) {
                uint64_t v60 = v59;
              }
              else {
                uint64_t v60 = 0;
              }
              if (*v55) {
                unint64_t v57 = v58;
              }
              if (v57) {
                findAddFlatBucket(a2, v60 | v57, v13, v27 - v13, 0, 0);
              }
            }
            else if (v25 && *v55)
            {
              (*(void (**)(uint64_t, void, void))(v25 + 16))(v25, *(void *)(a2 + 1240), (v27 - v13));
            }
            if (v27 >= v37) {
              break;
            }
            continue;
          case 3:
            __int32 v55 = *(_DWORD **)(*(void *)(a2 + 8) + 8);
            goto LABEL_91;
          case 0:
            findAddFlatBucket(a2, v54, v13, v27 - v13, 0, 0);
            break;
        }
        break;
      }
LABEL_3:
      if (++v3 >= (unint64_t)*(unsigned int *)(a2 + 1152)) {
        return;
      }
    }
    int v14 = v13[1];
    if ((char)v13[1] < 0)
    {
      int v16 = v13[2];
      if ((char)v13[2] < 0)
      {
        int v17 = v13[3];
        if ((char)v13[3] < 0)
        {
          int v19 = v13[4];
          if ((char)v13[4] < 0)
          {
            int v21 = (char)v13[5];
            if (v21 < 0) {
              goto LABEL_113;
            }
            int v22 = ((v19 & 0x7F) << 21) | (v21 << 28) | ((v17 & 0x7F) << 14) | ((v16 & 0x7F) << 7) | v14 & 0x7F;
            uint64_t v15 = 6;
            int v14 = v22;
          }
          else
          {
            int v20 = ((v17 & 0x7F) << 14) | (v19 << 21) | ((v16 & 0x7F) << 7) | v14 & 0x7F;
            uint64_t v15 = 5;
            int v14 = v20;
          }
        }
        else
        {
          int v18 = ((v16 & 0x7F) << 7) | (v17 << 14) | v14 & 0x7F;
          uint64_t v15 = 4;
          int v14 = v18;
        }
      }
      else
      {
        int v14 = v14 & 0x7F | (v16 << 7);
        uint64_t v15 = 3;
      }
    }
    else
    {
      uint64_t v15 = 2;
    }
    if ((v14 - 1) > 5)
    {
LABEL_29:
      *(void *)(a2 + 1232) = &v5[v15];
      goto LABEL_30;
    }
    uint64_t v23 = v15 + 1;
    if (((char)v13[v15] & 0x80000000) == 0)
    {
LABEL_26:
      uint64_t v15 = v23;
      goto LABEL_29;
    }
    uint64_t v24 = v15 + 2;
    if ((char)v13[v23] < 0)
    {
      uint64_t v23 = v15 + 3;
      if (((char)v13[v24] & 0x80000000) == 0) {
        goto LABEL_26;
      }
      uint64_t v24 = v15 + 4;
      if ((char)v13[v23] < 0)
      {
        if ((char)v13[v24] < 0) {
          goto LABEL_113;
        }
        v15 += 5;
        goto LABEL_29;
      }
    }
    uint64_t v15 = v24;
    goto LABEL_29;
  }
}

BOOL ___bt_resolveTokens_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v130 = *MEMORY[0x1E4F143B8];
  if (!*(_DWORD *)(a2 + 1152))
  {
    int v7 = 0;
    return v7 > 0;
  }
  uint64_t v3 = a3;
  uint64_t v5 = a1;
  uint64_t v6 = 0;
  int v7 = 0;
  unint64_t v8 = (unsigned __int8 *)(a2 + 88);
  int v110 = (unsigned __int8 *)(a2 + 89);
  int v111 = (unsigned __int8 *)(a2 + 88);
  while (2)
  {
    if (((*(unsigned __int8 *)(v3 + (v6 >> 3)) >> (v6 & 7)) & 1) == 0) {
      goto LABEL_4;
    }
    uint64_t v9 = *(void *)(a2 + 1144);
    *(void *)(a2 + 1240) = v9 + (v6 << 6);
    ++*(_DWORD *)(a2 + 1280);
    unsigned int v10 = *(_DWORD *)(a2 + 1140);
    if (v10 < 3) {
      goto LABEL_3;
    }
    uint64_t v11 = *(unsigned char **)(v9 + (v6 << 6));
    uint64_t v115 = *(unsigned int *)(a2 + 1140);
    int v12 = termPropertyID(v8, v10);
    uint64_t v13 = *(void *)(a2 + 1240);
    int v14 = *(_DWORD *)(v13 + 20);
    if ((*(unsigned char *)(v13 + 19) & 4) == 0)
    {
      if (!v14)
      {
        int v15 = v115;
        if (v12 == 2) {
          goto LABEL_3;
        }
        goto LABEL_19;
      }
      goto LABEL_12;
    }
    if (v14)
    {
LABEL_12:
      int v15 = v115;
      if (v12 != 1) {
        goto LABEL_3;
      }
      unsigned int v16 = v8[v115 - 1];
      BOOL v17 = v16 == 3;
      if (v16 > 3) {
        goto LABEL_3;
      }
      uint64_t v18 = -2;
      if (!v17) {
        uint64_t v18 = -1;
      }
      if (v8[v115 + v18] == 2) {
        goto LABEL_3;
      }
      goto LABEL_19;
    }
    int v15 = v115;
    if (v12 != 2)
    {
LABEL_3:
      ++v7;
      goto LABEL_4;
    }
LABEL_19:
    int v108 = v7;
    int v109 = v7 + 1;
    BOOL v19 = 0;
    BOOL v20 = 0;
    unint64_t v114 = v15 & 0xFFFFFFFFFFFFFFFELL;
    uint64_t v118 = v15;
    unint64_t v113 = &v123 + v15;
    for (uint64_t i = v8; ; i += v38)
    {
      unsigned int v22 = *v11;
      uint64_t v23 = *v11 >> 4;
      if ((char)*v11 < 0)
      {
        uint64_t v24 = utf8_byte_length(unsigned char)::utf8_len_table[v23];
        unsigned int v25 = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v24] & v22;
        if ((~(_BYTE)v23 & 0xC) != 0)
        {
          v22 &= utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v24];
        }
        else
        {
          if (v24 <= 2) {
            uint64_t v26 = 2;
          }
          else {
            uint64_t v26 = utf8_byte_length(unsigned char)::utf8_len_table[v23];
          }
          uint64_t v27 = v26 - 1;
          int v28 = v11 + 1;
          do
          {
            char v29 = *v28++;
            unsigned int v22 = v29 & 0x3F | (v25 << 6);
            unsigned int v25 = v22;
            --v27;
          }
          while (v27);
        }
      }
      unint64_t v30 = *i;
      unint64_t v31 = v30 >> 4;
      if ((v30 & 0x80) != 0)
      {
        uint64_t v32 = utf8_byte_length(unsigned char)::utf8_len_table[v31];
        int v33 = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v32] & v30;
        if ((~(v30 >> 4) & 0xC) != 0)
        {
          LODWORD(v30) = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v32] & v30;
        }
        else
        {
          if (v32 <= 2) {
            uint64_t v34 = 2;
          }
          else {
            uint64_t v34 = utf8_byte_length(unsigned char)::utf8_len_table[v31];
          }
          uint64_t v35 = v34 - 1;
          int v36 = (char *)(i + 1);
          do
          {
            char v37 = *v36++;
            LODWORD(v30) = v37 & 0x3F | (v33 << 6);
            int v33 = v30;
            --v35;
          }
          while (v35);
        }
      }
      uint64_t v38 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[v31];
      uint64_t v39 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[v23];
      if (v30 < 2)
      {
        if (v19 && v22 != 0 && v22 - 12448 < 0x60 || v20 && v22 != 0 && v22 - 12352 < 0x60)
        {
          int v7 = v109;
          goto LABEL_146;
        }
LABEL_46:
        uint64_t v116 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[v23];
        uint64_t v117 = v38;
        if ((int)v118 > 1043)
        {
LABEL_117:
          (*(void (**)(void))(*(void *)(v5 + 32) + 16))();
          uint64_t v39 = v116;
          uint64_t v38 = v117;
          goto LABEL_118;
        }
        bzero(&v124, 0x415uLL);
        __memcpy_chk();
        if (!v115)
        {
          uint64_t v54 = 0;
          int v51 = 0;
          unsigned int v52 = 0;
          BOOL v53 = 0;
          *(&v124 + v118) = 0;
          goto LABEL_66;
        }
        uint64_t v40 = v110;
        uint64_t v41 = &v125;
        unint64_t v42 = v114;
        if (v115 == 1)
        {
          unint64_t v43 = 0;
        }
        else
        {
          do
          {
            uint64_t v44 = *(v40 - 1);
            int v45 = *v40;
            v40 += 2;
            unsigned __int8 v46 = tcmn[v45];
            *(v41 - 1) = tcmn[v44];
            *uint64_t v41 = v46;
            v41 += 2;
            v42 -= 2;
          }
          while (v42);
          unint64_t v43 = v114;
          if (v114 == v118) {
            goto LABEL_54;
          }
        }
        uint64_t v47 = v118 - v43;
        unint64_t v48 = (char *)(&v124 + v43);
        uint8x8_t v49 = &v8[v43];
        do
        {
          int v50 = *v49++;
          *v48++ = tcmn[v50];
          --v47;
        }
        while (v47);
LABEL_54:
        *(&v124 + v118) = 0;
        if ((int)v118 >= 2)
        {
          int v51 = v124;
          if (v124 - 2 < 3)
          {
            unsigned int v52 = v125;
            if ((char)v125 < 0)
            {
              if ((char)v126 < 0)
              {
                if ((char)v127 < 0)
                {
                  if ((char)v128 < 0)
                  {
                    if ((char)v129 < 0)
                    {
                      int v92 = __si_assert_copy_extra_329();
                      unsigned int v93 = v92;
                      int v94 = "";
                      if (v92) {
                        int v94 = v92;
                      }
                      __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v94);
                      free(v93);
                      if (__valid_fs(-1)) {
                        uint64_t v95 = 2989;
                      }
                      else {
                        uint64_t v95 = 3072;
                      }
                      *(_DWORD *)uint64_t v95 = -559038737;
                      abort();
                    }
                    BOOL v53 = 0;
                    uint64_t v54 = 6;
                    unsigned int v52 = ((v128 & 0x7F) << 21) | (v129 << 28) | ((v127 & 0x7F) << 14) | ((v126 & 0x7F) << 7) | v125 & 0x7F;
                  }
                  else
                  {
                    BOOL v53 = 0;
                    uint64_t v54 = 5;
                    unsigned int v52 = ((v127 & 0x7F) << 14) | (v128 << 21) | ((v126 & 0x7F) << 7) | v125 & 0x7F;
                  }
                }
                else
                {
                  BOOL v53 = 0;
                  uint64_t v54 = 4;
                  unsigned int v52 = ((v126 & 0x7F) << 7) | (v127 << 14) | v125 & 0x7F;
                }
              }
              else
              {
                BOOL v53 = 0;
                unsigned int v52 = v125 & 0x7F | (v126 << 7);
                uint64_t v54 = 3;
              }
            }
            else
            {
              BOOL v53 = 0;
              uint64_t v54 = 2;
            }
            goto LABEL_66;
          }
          if (v124 == 1)
          {
            BOOL v53 = v125 == 2;
            if (v125 == 2) {
              uint64_t v55 = 2;
            }
            else {
              uint64_t v55 = 1;
            }
            uint64_t v54 = v55 + 1;
            unsigned int v52 = *(&v124 + v55);
            if ((char)*(&v124 + v55) < 0)
            {
              uint64_t v78 = v55 + 2;
              int v79 = (char)*(&v124 + v54);
              char v80 = v79;
              if (v79 < 0)
              {
                uint64_t v81 = v55 + 3;
                int v82 = (char)*(&v124 + v78);
                int v83 = *(&v124 + v78);
                if (v82 < 0)
                {
                  uint64_t v54 = v55 | 4;
                  int v84 = (char)*(&v124 + v81);
                  int v85 = *(&v124 + v81);
                  if (v84 < 0)
                  {
                    int v87 = (char)*(&v124 + v54);
                    if (v87 < 0)
                    {
                      int v96 = __si_assert_copy_extra_329();
                      unsigned int v97 = v96;
                      int v98 = "";
                      if (v96) {
                        int v98 = v96;
                      }
                      __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v98);
                      free(v97);
                      if (__valid_fs(-1))
                      {
                        MEMORY[0xBAD] = -559038737;
                        abort();
                      }
                      MEMORY[0xC00] = -559038737;
                      abort();
                    }
                    int v51 = 0;
                    int v88 = v87;
                    uint64_t v54 = v55 + 5;
                    int v86 = ((v85 & 0x7F) << 21) | (v88 << 28) | ((v83 & 0x7F) << 14);
                  }
                  else
                  {
                    int v51 = 0;
                    int v86 = ((v83 & 0x7F) << 14) | (v85 << 21);
                  }
                  unsigned int v52 = v86 & 0xFFFFC000 | ((v80 & 0x7F) << 7) | v52 & 0x7F;
                }
                else
                {
                  int v51 = 0;
                  uint64_t v54 = v55 + 3;
                  unsigned int v52 = ((v80 & 0x7F) << 7) | (v83 << 14) | v52 & 0x7F;
                }
              }
              else
              {
                int v51 = 0;
                unsigned int v52 = v52 & 0x7F | (v79 << 7);
                uint64_t v54 = v55 + 2;
              }
            }
            else
            {
              int v51 = 0;
            }
            goto LABEL_66;
          }
        }
        uint64_t v54 = 0;
        int v51 = 0;
        unsigned int v52 = 0;
        BOOL v53 = 0;
LABEL_66:
        unint64_t v56 = (char *)(&v124 + v54);
        unint64_t v57 = v113;
        unsigned int v58 = *v113;
        if (v58 > 5) {
          goto LABEL_78;
        }
        if (v113 <= v56)
        {
          int v63 = 0;
          if (v58 != 1)
          {
            int v65 = 0;
            int v64 = 0;
            if (!v52) {
              goto LABEL_115;
            }
            goto LABEL_79;
          }
          int v59 = 1;
          uint64_t v61 = v113;
          int v64 = 0;
          goto LABEL_114;
        }
        int v59 = v115 - v54;
        int v60 = 1;
        uint64_t v61 = v113;
        while (1)
        {
          unsigned int v62 = *--v57;
          if (v62 > 5) {
            break;
          }
          ++v60;
          uint64_t v61 = v57;
          if (v57 <= v56)
          {
            uint64_t v61 = v56;
            goto LABEL_75;
          }
        }
        int v59 = v60;
LABEL_75:
        if (*v61 != 1)
        {
LABEL_78:
          int v63 = 0;
          int v65 = 0;
          int v64 = 0;
          if (!v52)
          {
LABEL_115:
            if (dword_1E9FC90A8 < 5) {
              goto LABEL_116;
            }
            int v102 = v64;
            int v106 = *__error();
            log = _SILogForLogForCategory(1);
            if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
            {
              int v89 = "";
              int v90 = "(0) ";
              if (!v65) {
                int v90 = "";
              }
              *(_DWORD *)iovec buf = 136315906;
              int v120 = "match ";
              if (v102) {
                int v90 = "(2) ";
              }
              __int16 v121 = 2080;
              if (v63) {
                int v89 = "[*] ";
              }
              *(void *)uint64_t v122 = v90;
              *(_WORD *)&v122[8] = 2080;
              *(void *)&v122[10] = v89;
              *(_WORD *)&v122[18] = 2080;
              *(void *)&unsigned char v122[20] = v56;
              _os_log_impl(&dword_1BD672000, log, OS_LOG_TYPE_DEFAULT, "%s%s%s%s", buf, 0x2Au);
            }
            int v67 = v106;
LABEL_141:
            *__error() = v67;
            goto LABEL_116;
          }
LABEL_79:
          if (v51)
          {
            if (dword_1E9FC90A8 >= 5)
            {
              int v103 = v51;
              unsigned int v66 = v52;
              int v67 = *__error();
              int v100 = _SILogForLogForCategory(1);
              if (!os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_141;
              }
              *(_DWORD *)iovec buf = 136315906;
              int v120 = "match ";
              __int16 v121 = 1024;
              *(_DWORD *)uint64_t v122 = v66;
              *(_WORD *)&v122[4] = 1024;
              *(_DWORD *)&v122[6] = v103;
              *(_WORD *)&v122[10] = 2080;
              *(void *)&v122[12] = v56;
              unint64_t v68 = v100;
              unsigned int v69 = "%s(%d) [%d] %s";
              uint32_t v70 = 34;
LABEL_100:
              _os_log_impl(&dword_1BD672000, v68, OS_LOG_TYPE_DEFAULT, v69, buf, v70);
              goto LABEL_141;
            }
          }
          else
          {
            BOOL v17 = v58 == 3;
            BOOL v71 = v58 == 3;
            uint64_t v72 = "";
            if (v17)
            {
              uint64_t v72 = "[f] ";
              int v73 = 1;
            }
            else
            {
              int v73 = v53;
            }
            BOOL v17 = !v53 || !v71;
            int v74 = "[l] ";
            if (!v17) {
              int v74 = "[fl] ";
            }
            if (v53) {
              unsigned int v75 = v74;
            }
            else {
              unsigned int v75 = v72;
            }
            if (v73 == 1)
            {
              if (dword_1E9FC90A8 >= 5)
              {
                unsigned int v104 = v52;
                int v67 = *__error();
                int v101 = _SILogForLogForCategory(1);
                if (!os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_141;
                }
                *(_DWORD *)iovec buf = 136315906;
                int v120 = "match ";
                __int16 v121 = 1024;
                *(_DWORD *)uint64_t v122 = v104;
                *(_WORD *)&v122[4] = 2080;
                *(void *)&v122[6] = v75;
                *(_WORD *)&v122[14] = 2080;
                *(void *)&v122[16] = v56;
                unint64_t v68 = v101;
                unsigned int v69 = "%s(%d) %s%s";
                uint32_t v70 = 38;
                goto LABEL_100;
              }
            }
            else if (dword_1E9FC90A8 >= 5)
            {
              unsigned int v105 = v52;
              int v67 = *__error();
              uint64_t v76 = _SILogForLogForCategory(1);
              if (!os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_141;
              }
              *(_DWORD *)iovec buf = 136315650;
              int v120 = "match ";
              __int16 v121 = 1024;
              *(_DWORD *)uint64_t v122 = v105;
              *(_WORD *)&v122[4] = 2080;
              *(void *)&v122[6] = v56;
              unint64_t v68 = v76;
              unsigned int v69 = "%s(%d) %s";
              uint32_t v70 = 28;
              goto LABEL_100;
            }
          }
LABEL_116:
          unint64_t v8 = v111;
          uint64_t v5 = a1;
          goto LABEL_117;
        }
        if (v59 == 1)
        {
          int v63 = 0;
          int v64 = 0;
          goto LABEL_114;
        }
        int v77 = v61[1];
        if ((v77 - 4) < 2)
        {
          int v59 = 1;
        }
        else
        {
          int v59 = 0;
          if (v77 != 1)
          {
            if (v77 == 2)
            {
              int v59 = 0;
              int v64 = 0;
              int v63 = 1;
            }
            else
            {
              int v63 = 0;
              int v64 = 0;
            }
LABEL_114:
            int v65 = v63;
            *uint64_t v61 = 0;
            int v63 = v59;
            if (!v52) {
              goto LABEL_115;
            }
            goto LABEL_79;
          }
        }
        int v63 = 0;
        int v64 = 1;
        goto LABEL_114;
      }
      if (!v22) {
        break;
      }
LABEL_118:
      if (!v22 || v22 != v30) {
        goto LABEL_144;
      }
      BOOL v19 = v22 - 12448 < 0x60;
      BOOL v20 = v22 - 12352 < 0x60;
      v11 += v39;
    }
    if ((*(unsigned char *)(*(void *)(a2 + 1240) + 17) & 8) != 0) {
      goto LABEL_46;
    }
    unsigned int v22 = 0;
LABEL_144:
    int v7 = v108;
    if (v22 >= v30) {
      int v7 = v109;
    }
LABEL_146:
    uint64_t v3 = a3;
LABEL_4:
    if (++v6 < (unint64_t)*(unsigned int *)(a2 + 1152)) {
      continue;
    }
    return v7 > 0;
  }
}

uint64_t __bt_findTokens_block_invoke(uint64_t a1, int a2)
{
  return TokenDataAddRange(*(void *)(a1 + 32), a2);
}

uint64_t si_fileProvidersPsid_vet_path()
{
  return 1;
}

uint64_t si_fileProvidersPsid_oid_to_oid_path(uint64_t a1, uint64_t a2, void *a3, int a4, uint64_t a5, int *a6, const __CFString *a7, const __CFString *a8, uint64_t a9, uint64_t a10)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!a7 || !a9) {
    goto LABEL_8;
  }
  CFArrayRef v17 = (const __CFArray *)(*(uint64_t (**)(uint64_t, const __CFString *, const __CFString *, uint64_t, uint64_t))(copyFPItemAllParentsBlock + 16))(copyFPItemAllParentsBlock, a7, a8, a9, a10);
  if (!v17)
  {
    if (*__error() == 60) {
      return 0xFFFFFFFFLL;
    }
LABEL_8:
    *__error() = 2;
    return 0xFFFFFFFFLL;
  }
  CFArrayRef v18 = v17;
  CFIndex Count = CFArrayGetCount(v17);
  if (Count < 0) {
    goto LABEL_8;
  }
  CFIndex v20 = Count;
  if (a4)
  {
    *a3 = a2;
    int v21 = 1;
  }
  else
  {
    int v21 = 0;
  }
  bzero(buffer, 0x400uLL);
  uint64_t v27 = *(uint64_t **)(a1 + 16);
  unint64_t v28 = -1;
  if (v20)
  {
    CFIndex v24 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v18, v24);
      if (!CFStringGetCString(ValueAtIndex, buffer, 1024, 0x8000100u)) {
        break;
      }
      if (strstr(buffer, "NSFileProviderRootContainerItemIdentifier"))
      {
        unint64_t v26 = 2;
      }
      else
      {
        si_get_object_for_identifier_createParentDBO(*v27, a7, ValueAtIndex, a8, 1, &v28, 0, 1u);
        unint64_t v26 = v28;
      }
      a3[(v21 + v24++)] = v26;
      if (v20 == v24)
      {
        uint64_t v22 = 0;
        v21 += v24;
        goto LABEL_22;
      }
    }
    *__error() = 2;
    uint64_t v22 = 0xFFFFFFFFLL;
    v21 += v24;
  }
  else
  {
    uint64_t v22 = 0;
  }
LABEL_22:
  *a6 = v21;
  CFRelease(v18);
  return v22;
}

uint64_t si_fileProvidersPsid_oid_to_parent(uint64_t a1, uint64_t a2, uint64_t a3, const __CFString *a4, const __CFString *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(uint64_t **)(a1 + 16);
  int v12 = __error();
  if (a4 && a6)
  {
    int *v12 = 0;
    CFStringRef v13 = (const __CFString *)(*(uint64_t (**)(uint64_t, const __CFString *, const __CFString *, uint64_t, uint64_t))(copyFPItemParentBlock + 16))(copyFPItemParentBlock, a4, a5, a6, a7);
    unint64_t v16 = -1;
    if (!v13) {
      goto LABEL_9;
    }
    CFStringRef v14 = v13;
    if (CFStringHasSuffix(v13, @"NSFileProviderRootContainerItemIdentifier")) {
      unint64_t v16 = 2;
    }
    else {
      si_get_object_for_identifier_createParentDBO(*v11, a4, v14, a5, 1, &v16, 0, 1u);
    }
    CFRelease(v14);
    if (v16 == -1)
    {
LABEL_9:
      if (*__error() != 60) {
        *__error() = 2;
      }
    }
    return v16;
  }
  else
  {
    int *v12 = 22;
    return -1;
  }
}

uint64_t si_fileProvidersPsid_close(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t result = *(unsigned int *)(v1 + 8);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = close(result);
    *(_DWORD *)(v1 + 8) = -1;
  }
  return result;
}

uint64_t si_fileProvidersPsid_path_to_oid_path(uint64_t a1, char *__s)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!__s) {
    goto LABEL_14;
  }
  if (*__s == 47)
  {
    size_t v4 = strlen(__s);
    CFURLRef v5 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)__s, v4, 0);
    if (!v5) {
      return 0;
    }
    CFURLRef v6 = v5;
    CFArrayRef v7 = (const __CFArray *)(*(uint64_t (**)(uint64_t, CFURLRef))(copyFPItemBlock + 16))(copyFPItemBlock, v5);
    CFRelease(v6);
    if (!v7) {
      return 0;
    }
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, 0);
    CFStringRef v9 = (const __CFString *)CFArrayGetValueAtIndex(v7, 1);
    if (gSILogLevels[0] >= 5)
    {
      CFStringRef theString = v9;
      int v18 = *__error();
      BOOL v19 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)cStr = 136315394;
        CStringPtr = CFStringGetCStringPtr(ValueAtIndex, 0x8000100u);
        __int16 v28 = 2080;
        char v29 = CFStringGetCStringPtr(theString, 0x8000100u);
        _os_log_impl(&dword_1BD672000, v19, OS_LOG_TYPE_DEFAULT, "path_to_oid_path, bundleID: %s, uniqueID: %s", (uint8_t *)cStr, 0x16u);
      }
      *__error() = v18;
    }
    uint64_t v10 = oidPathDepthFromBundleIDUniqueID(*(void *)(a1 + 16));
    uint64_t v11 = v7;
    goto LABEL_13;
  }
  if (!strchr(__s, 58))
  {
LABEL_14:
    *__error() = 22;
    return 0xFFFFFFFFLL;
  }
  bzero(cStr, 0x400uLL);
  bzero(v25, 0x400uLL);
  __strncpy_chk();
  strlen(__s);
  __strncpy_chk();
  if (gSILogLevels[0] >= 5)
  {
    int v16 = *__error();
    CFArrayRef v17 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)iovec buf = 136315394;
      uint64_t v22 = cStr;
      __int16 v23 = 2080;
      CFIndex v24 = v25;
      _os_log_impl(&dword_1BD672000, v17, OS_LOG_TYPE_DEFAULT, "specialPath_to_oid_path, bundleIDStr: %s, identifierStr: %s", buf, 0x16u);
    }
    *__error() = v16;
  }
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v13 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0x8000100u);
  CFStringRef v14 = CFStringCreateWithCString(v12, v25, 0x8000100u);
  uint64_t v10 = oidPathDepthFromBundleIDUniqueID(*(void *)(a1 + 16));
  if (v13) {
    CFRelease(v13);
  }
  if (v14)
  {
    uint64_t v11 = v14;
LABEL_13:
    CFRelease(v11);
  }
  return v10;
}

uint64_t oidPathDepthFromBundleIDUniqueID(uint64_t a1)
{
  size_t v4 = (uint64_t *)MEMORY[0x1F4188790](a1);
  uint64_t result = 0;
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (!v1) {
    return result;
  }
  CFStringRef v6 = v2;
  if (!v2) {
    return result;
  }
  CFArrayRef v7 = v3;
  CFStringRef v8 = v1;
  unint64_t v39 = -1;
  if (CFStringHasSuffix(v2, @"NSFileProviderRootContainerItemIdentifier"))
  {
    unint64_t v9 = 2;
    unint64_t v39 = 2;
  }
  else
  {
    si_get_object_for_identifier_createParentDBO(*v4, v8, v6, 0, 0, &v39, 0, 1u);
    si_indexDeleteDeferredItemsIfItemIncluded(*v4, v39);
    unint64_t v9 = v39;
  }
  uint64_t v10 = *v4;
  uint64_t v11 = *(void *)(*v4 + 6616);
  if (v11) {
    BOOL v12 = v9 == -1;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12) {
    return 0;
  }
  bzero(__src, 0x1000uLL);
  *CFArrayRef v7 = v9;
  int Path = directoryStoreGetPath(v11, v9, (uint64_t)__src);
  LODWORD(v14) = Path;
  if (!Path)
  {
    uint64_t v41 = 0;
    if (db_get_obj(*(_DWORD **)(v10 + 1184), v39, (void **)&v41, 0)) {
      goto LABEL_18;
    }
    uint64_t v38 = v7;
    int v15 = 0;
    int64_t v16 = 0;
    LODWORD(v14) = 0;
    CFArrayRef v17 = v41;
    unint64_t v18 = v41[3];
    while (1)
    {
      uint64_t v40 = 0;
      if (db_get_obj(*(_DWORD **)(v10 + 1184), v18, (void **)&v40, 0))
      {
        free(v17);
        CFArrayRef v17 = 0;
        if (!v16) {
          goto LABEL_33;
        }
      }
      else
      {
        int64_t v16 = v40[3];
        if (v18 != 2 && v16 <= 0)
        {
          int v21 = *__error();
          uint64_t v22 = _SILogForLogForCategory(4);
          os_log_type_t v23 = 2 * (dword_1E9FC90B4 < 4);
          if (os_log_type_enabled(v22, v23))
          {
            int v24 = *__error();
            uint64_t v25 = *v41;
            *(_DWORD *)iovec buf = 67110144;
            int v44 = v24;
            __int16 v45 = 1024;
            int v46 = 250;
            __int16 v47 = 2048;
            uint64_t v48 = v25;
            __int16 v49 = 2048;
            unint64_t v50 = v18;
            __int16 v51 = 2048;
            int64_t v52 = v16;
            _os_log_impl(&dword_1BD672000, v22, v23, "lookupPathByDBO error:%d at:%d in_oid:%lld oid:%lld parent:%lld", buf, 0x2Cu);
          }
          *__error() = v21;
        }
        free(v17);
        CFArrayRef v17 = v40;
        if (!v16)
        {
LABEL_33:
          BOOL v20 = 0;
          LODWORD(v14) = v15;
          if (v15) {
            goto LABEL_38;
          }
          goto LABEL_41;
        }
      }
      uint64_t v19 = v15 + 1;
      __src[v15] = v16;
      if (v16 != 2)
      {
        int v26 = directoryStoreWriterGetPath(*(void *)(v10 + 6616), v16, (uint64_t)&__src[v19]);
        BOOL v20 = v26 == 0;
        if (v26) {
          LODWORD(v14) = v26 + v19;
        }
        ++v15;
        if (!v14) {
          goto LABEL_41;
        }
LABEL_38:
        uint64_t v27 = 0;
        do
        {
          if ((uint64_t)__src[v27] <= 0)
          {
            char v29 = __si_assert_copy_extra_329();
            __message_assert_2145((uint64_t)v29, v30, v31, v32, v33, v34, v35, v36, (char)"SIFileProvidersPSIDSupport.c");
            free(v29);
            if (__valid_fs(-1)) {
              uint64_t v37 = 2989;
            }
            else {
              uint64_t v37 = 3072;
            }
            *(_DWORD *)uint64_t v37 = -559038737;
            abort();
          }
          ++v27;
        }
        while (v14 != v27);
        goto LABEL_41;
      }
      BOOL v20 = 1;
      ++v15;
      LODWORD(v14) = v19;
      if (v19) {
        goto LABEL_38;
      }
LABEL_41:
      BOOL v28 = v16 != 2 && v20;
      if (v28)
      {
        unint64_t v18 = v16;
        if (v15 < 512) {
          continue;
        }
      }
      if (v17) {
        free(v17);
      }
      CFArrayRef v7 = v38;
      if (!v28)
      {
        if (!v14) {
          return (v14 + 1);
        }
        break;
      }
LABEL_18:
      LODWORD(v14) = 0;
      return (v14 + 1);
    }
  }
  if ((int)v14 >= 1) {
    memcpy(v7 + 1, __src, 8 * v14);
  }
  if (v7[(int)v14] != 2)
  {
    uint64_t v14 = (int)v14 + 1;
    v7[v14] = 2;
  }
  return (v14 + 1);
}

void __message_assert_2145(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  string[0] = 0;
  string[1] = &a9;
  vasprintf(string, "%s:%u: failed assertion '%s' %s Got parent[%d] with id %lld depth: %d", &a9);
  SISetCrashCStr(string[0]);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)keys = 136315138;
    *(char **)&keys[4] = string[0];
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s", keys, 0xCu);
  }
  *(void *)keys = "crash_string";
  xpc_object_t v9 = xpc_string_create(string[0]);
  xpc_object_t values = v9;
  xpc_object_t v10 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  analytics_send_event();
  xpc_release(v10);
  xpc_release(v9);
  free(string[0]);
}

void si_fileProvidersPsid_destruct(uint64_t a1)
{
}

uint64_t pushMove(void *a1, uint64_t a2)
{
  size_t v4 = (char *)*a1;
  if (v4)
  {
    CFURLRef v5 = (char **)(a1 + 1);
    CFStringRef v6 = (void *)a1[1];
    CFArrayRef v7 = a1 + 2;
    uint64_t v8 = a1[2];
    if (v8)
    {
      unint64_t v9 = a1[3];
      if (*v6 == -1)
      {
        if (v8 + 8 <= v9)
        {
          uint64_t v15 = v6[1];
          v6[v15 + 2] = a2;
          v6[1] = v15 + 1;
          uint64_t v14 = 8;
          goto LABEL_13;
        }
      }
      else if (v8 + 24 <= v9)
      {
        if (&v4[v8] != (char *)&v6[v6[1] + 2]) {
          __assert_rtn("pushMove", "MoveHolder.c", 26, "holder->count==0 || holder->count + holder->data == ((char*)current) + sizeof(PossibleFileMoves_t)+sizeof(oid_t)*current->count");
        }
        goto LABEL_12;
      }
      return 0;
    }
    unint64_t v11 = a1[3];
  }
  else
  {
    xpc_object_t v10 = (void *)MEMORY[0x1E4F14B00];
    size_t v4 = (char *)mmap(0, 16 * *MEMORY[0x1E4F14B00], 3, 4098, 0, 0);
    *a1 = v4;
    unint64_t v11 = 16 * *v10;
    a1[3] = v11;
    a1[2] = 0;
    CFArrayRef v7 = a1 + 2;
    a1[1] = v4;
    CFURLRef v5 = (char **)(a1 + 1);
  }
  if (v11 < 0x18) {
    return 0;
  }
  uint64_t v8 = 0;
LABEL_12:
  CFStringRef v13 = &v4[v8];
  *CFURLRef v5 = v13;
  *((void *)v13 + 2) = a2;
  *(_OWORD *)CFStringRef v13 = xmmword_1BDA823D0;
  uint64_t v14 = 24;
LABEL_13:
  *v7 += v14;
  return 1;
}

uint64_t _CICreateNew(uint64_t a1, const __CFString *a2, uint64_t a3, int a4, unsigned int a5, int a6, int a7, uint64_t a8, uint64_t a9, const void *a10, int a11)
{
  *(void *)&v34[1023] = *MEMORY[0x1E4F143B8];
  bzero(v34, 0x3FFuLL);
  int v32 = 0;
  char buffer = 0;
  uint64_t v19 = copyVolumeInfoStr(a1);
  if (CFStringGetFileSystemRepresentation(a2, &buffer, 1024))
  {
    uint64_t v20 = createIndex(a1, &buffer, a3, (uint64_t)v19, a5, 0, a6, &v32, a7, a8, a9, a10, a11);
    uint64_t v21 = v20;
    if (v20)
    {
      *(_DWORD *)(v20 + 40) = a4;
      if (a3 && *(void *)(v20 + 80) != a3)
      {
        os_log_type_t v23 = __si_assert_copy_extra_329();
        __message_assert_333((uint64_t)v23, v24, v25, v26, v27, v28, v29, v30, (char)"ContentIndex.c");
        free(v23);
        if (__valid_fs(-1)) {
          uint64_t v31 = 2989;
        }
        else {
          uint64_t v31 = 3072;
        }
        *(_DWORD *)uint64_t v31 = -559038737;
        abort();
      }
      if (g_fd_list) {
        _fd_close_inactive(*(unsigned int *)(v20 + 64), (const char *)(v20 + 15208), 0, 0);
      }
    }
  }
  else
  {
    uint64_t v21 = 0;
  }
  free(v19);
  return v21;
}

uint64_t indexUpdateHeader(uint64_t a1)
{
  int v1 = MEMORY[0x1F4188790](a1);
  int v3 = v2;
  unsigned int v5 = v4;
  unsigned int v7 = v6;
  unsigned int v9 = v8;
  unint64_t v11 = v10;
  int v12 = v1;
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  bzero(v20, 0x400uLL);
  bzero(&v18, 0x1000uLL);
  snprintf(v20, 0x400uLL, "%sindexHead", v11);
  CFStringRef v13 = (atomic_uint *)fd_create_protected(v12, v20, 536870914, 3u);
  uint64_t v14 = v13;
  if (!v13 || fd_pread(v13, &v18, 0x1000uLL, 0) != 4096)
  {
LABEL_9:
    unsigned int v16 = *__error();
    if (v16) {
      uint64_t v15 = v16;
    }
    else {
      uint64_t v15 = 0xFFFFFFFFLL;
    }
    goto LABEL_12;
  }
  if (v18 == v9 || (uint64_t v15 = 22, v18 >= v7) && v18 <= v5)
  {
    if (v19 == v3 || (unsigned int v18 = v9, v19 = v3, fd_pwrite((uint64_t)v14, (uint64_t)&v18, 0x1000uLL, 0) == 4096))
    {
      uint64_t v15 = 0;
      goto LABEL_12;
    }
    goto LABEL_9;
  }
LABEL_12:
  fd_release(v14);
  return v15;
}

void _CIIndexSetRemoveAllValues(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 8))
    {
      unint64_t v2 = 0;
      do
      {
        freeIndex(*(void *)(*(void *)a1 + 8 * v2));
        *(void *)(*(void *)a1 + 8 * v2++) = 0;
      }
      while (v2 < *(unsigned int *)(a1 + 8));
    }
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = -1;
  }
}

uint64_t _CISyncContextCommitData(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)a1 + 42))
  {
    int v4 = *__error();
    unsigned int v5 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_3;
    }
    int v43 = *((_DWORD *)a1 + 42);
    *(_DWORD *)iovec buf = 136315650;
    *(void *)&uint8_t buf[4] = "_CISyncContextCommitData";
    __int16 v64 = 1024;
    *(_DWORD *)int v65 = 1527;
    *(_WORD *)&v65[4] = 1024;
    *(_DWORD *)&v65[6] = v43;
    uint64_t v14 = "%s:%d: pre-error:%d";
LABEL_70:
    uint64_t v15 = v5;
    uint32_t v16 = 24;
    goto LABEL_71;
  }
  uint64_t v61 = *((unsigned int *)a1 + 34);
  unsigned int v9 = (uint64_t (*)(uint64_t, BOOL))a1[5];
  uint64_t v60 = a1[18];
  if (v9)
  {
    int v10 = v9(a1[10], (a1[1] & 6) != 0);
    *((_DWORD *)a1 + 42) = v10;
    if (v10)
    {
      if (v10 == 89) {
        return *((unsigned int *)a1 + 42);
      }
      int v4 = *__error();
      unint64_t v11 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        goto LABEL_3;
      }
      int v12 = *((_DWORD *)a1 + 42);
      int v13 = *__error();
      *(_DWORD *)iovec buf = 136315906;
      *(void *)&uint8_t buf[4] = "_CISyncContextCommitData";
      __int16 v64 = 1024;
      *(_DWORD *)int v65 = 1540;
      *(_WORD *)&v65[4] = 1024;
      *(_DWORD *)&v65[6] = v12;
      *(_WORD *)&v65[10] = 1024;
      *(_DWORD *)&v65[12] = v13;
      uint64_t v14 = "%s:%d: postSync error:%d %d";
      uint64_t v15 = v11;
      uint32_t v16 = 30;
LABEL_71:
      _os_log_error_impl(&dword_1BD672000, v15, OS_LOG_TYPE_ERROR, v14, buf, v16);
      goto LABEL_3;
    }
  }
  unint64_t v56 = a2;
  int v17 = *((_DWORD *)a1 + 2);
  uint64_t v18 = *a1;
  uint64_t v19 = a1[16];
  if (*((_DWORD *)a1 + 26)) {
    BOOL v20 = 1;
  }
  else {
    BOOL v20 = (a1[1] & 6) == 0;
  }
  int v57 = v20;
  if (!v61)
  {
    uint64_t v22 = 0;
LABEL_60:
    if (v18 && v57 && *(void *)(v18 + 8) && !*(unsigned char *)(v18 + 88))
    {
      ++*(_DWORD *)(v18 + 32);
      *(void *)(v18 + 40) = v19;
      *((unsigned char *)a1 + 101) = 1;
    }
    *((_DWORD *)a1 + 42) = 0;
    if (v56)
    {
      *unint64_t v56 = v22;
    }
    else if (v22)
    {
      fd_sync(v22, 1);
    }
    return *((unsigned int *)a1 + 42);
  }
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v58 = a1[19];
  uint64_t v59 = a1[20];
  while (1)
  {
    uint64_t v23 = *(void *)(v60 + 8 * v21);
    if ((v17 & 1) == 0)
    {
      unsigned int v24 = atomic_load((unsigned int *)(v23 + 32));
      if (v24 == -1073623027)
      {
        if (!CIDocCountsNonEmpty((void *)(v23 + 14936)))
        {
          char v25 = atomic_load((unsigned int *)(v23 + 36));
          if ((v25 & 1) == 0 || (char v26 = atomic_load((unsigned int *)(v23 + 36)), (v26 & 2) != 0))
          {
            if (*(unsigned char *)(v59 + v21))
            {
              int v44 = __si_assert_copy_extra_329();
              int64_t v52 = v44;
              __message_assert_333((uint64_t)v44, v45, v46, v47, v48, v49, v50, v51, (char)"ContentIndex.c");
              free(v52);
              if (__valid_fs(-1)) {
                uint64_t v53 = 2989;
              }
              else {
                uint64_t v53 = 3072;
              }
              *(_DWORD *)uint64_t v53 = -559038737;
              abort();
            }
            goto LABEL_49;
          }
        }
      }
      else
      {
        unsigned int v27 = atomic_load((unsigned int *)(v23 + 32));
        if ((v17 & 6) != 0 && v27 == 2) {
          goto LABEL_49;
        }
      }
    }
    if (v18)
    {
      *(_DWORD *)(v23 + 48) = *(_DWORD *)(v18 + 32) + 1;
      int v57 = 1;
    }
    uint64_t v28 = (int64x2_t *)(v23 + 14936);
    if (*(unsigned char *)(v23 + 15203)) {
      break;
    }
    if (!*(unsigned char *)(v23 + 8)) {
      break;
    }
    int v29 = *(_DWORD *)(v23 + 15196);
    if (v29 == -1) {
      break;
    }
    unsigned int v62 = (void *)(v58 + (v21 << 12));
    if (dword_1E9FC90CC >= 5)
    {
      int v55 = *__error();
      log = _SILogForLogForCategory(10);
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v32 = *(void *)(v23 + 136);
        *(_DWORD *)iovec buf = 134218242;
        *(void *)&uint8_t buf[4] = v32;
        __int16 v64 = 2080;
        *(void *)int v65 = v23 + 15208;
        _os_log_impl(&dword_1BD672000, log, OS_LOG_TYPE_DEFAULT, "bases.size: %ld (%s)", buf, 0x16u);
      }
      *__error() = v55;
      int v29 = *(_DWORD *)(v23 + 15196);
      if ((v17 & 4) != 0) {
        goto LABEL_37;
      }
    }
    else if ((v17 & 4) != 0)
    {
      goto LABEL_37;
    }
    if (v29 != 1)
    {
      atomic_store(0xD00D0DD0, (unsigned int *)(v23 + 32));
      if (a3)
      {
        uint64_t v30 = *(void *)(a3 + 40);
        *(void *)(a3 + 48) += *(void *)(v23 + 14984);
        *(int64x2_t *)(a3 + 24) = vaddq_s64(*(int64x2_t *)(a3 + 24), *(int64x2_t *)(v23 + 14960));
        *(void *)(a3 + 56) += *(void *)(v23 + 14992);
        *(int64x2_t *)a3 = vaddq_s64(*(int64x2_t *)a3, *v28);
        *(void *)(a3 + 40) = v30 + *(void *)(v23 + 14976);
        *(void *)(a3 + 16) += *(void *)(v23 + 14952);
        int64x2_t v31 = *(int64x2_t *)(a3 + 80);
        *(int64x2_t *)(a3 + 64) = vaddq_s64(*(int64x2_t *)(a3 + 64), *(int64x2_t *)(v23 + 15000));
        *(int64x2_t *)(a3 + 80) = vaddq_s64(v31, *(int64x2_t *)(v23 + 15016));
        *(void *)(a3 + 96) += *(void *)(v23 + 15032);
        *(void *)(v23 + 15032) = 0;
        *(_OWORD *)(v23 + 15000) = 0u;
        *(_OWORD *)(v23 + 15016) = 0u;
        *(_OWORD *)(v23 + 14968) = 0u;
        *(_OWORD *)(v23 + 14984) = 0u;
        int64x2_t *v28 = 0u;
        *(_OWORD *)(v23 + 14952) = 0u;
      }
      goto LABEL_38;
    }
LABEL_37:
    atomic_store(2u, (unsigned int *)(v23 + 32));
LABEL_38:
    indexStoreToBuffer(v23, &v62);
    uint64_t v33 = *(_DWORD **)(v23 + 14480);
    if (v33)
    {
      uint64_t v34 = fd_pwrite(*(void *)(v23 + 14480), v58 + (v21 << 12), 0x1000uLL, 0);
      if (v34 == -1)
      {
        int v37 = *__error();
        if (v37) {
          goto LABEL_55;
        }
      }
      else
      {
        if (v34 != 4096) {
          goto LABEL_54;
        }
        if (_gSystemStatusBool)
        {
          pthread_mutex_lock(&_gSystemStatusLock);
          while (_gSystemStatusBool)
            pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
          pthread_mutex_unlock(&_gSystemStatusLock);
        }
        *(void *)iovec buf = 0;
        uint64_t v35 = _fd_acquire_fd((uint64_t)v33, buf);
        if (v35 != -1)
        {
          int v36 = v35;
          prot_fsync(v35, 0);
          _fd_release_fd(v33, v36, 0, *(uint64_t *)buf);
        }
      }
    }
    *(unsigned char *)(v59 + v21) |= 4u;
    uint64_t v22 = *(void *)(v23 + 14472);
LABEL_49:
    if (++v21 == v61) {
      goto LABEL_60;
    }
  }
  int v38 = *__error();
  unint64_t v39 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)iovec buf = 136315650;
    *(void *)&uint8_t buf[4] = "indexCommitSync";
    __int16 v64 = 1024;
    *(_DWORD *)int v65 = 3029;
    *(_WORD *)&v65[4] = 2080;
    *(void *)&v65[6] = v23 + 15208;
    _os_log_error_impl(&dword_1BD672000, v39, OS_LOG_TYPE_ERROR, "%s:%d: can't commit %s", buf, 0x1Cu);
  }
  *__error() = v38;
LABEL_54:
  int v37 = -1;
LABEL_55:
  int v40 = *__error();
  uint64_t v41 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)iovec buf = 136315906;
    *(void *)&uint8_t buf[4] = "indexCommitSyncBulk";
    __int16 v64 = 1024;
    *(_DWORD *)int v65 = 1169;
    *(_WORD *)&v65[4] = 1024;
    *(_DWORD *)&v65[6] = v37;
    *(_WORD *)&v65[10] = 2080;
    *(void *)&v65[12] = v23 + 15208;
    _os_log_error_impl(&dword_1BD672000, v41, OS_LOG_TYPE_ERROR, "%s:%d: indexCommitSync error %d %s", buf, 0x22u);
  }
  *__error() = v40;
  *((_DWORD *)a1 + 42) = -1;
  int v4 = *__error();
  unsigned int v5 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    int v42 = *((_DWORD *)a1 + 42);
    *(_DWORD *)iovec buf = 136315650;
    *(void *)&uint8_t buf[4] = "_CISyncContextCommitData";
    __int16 v64 = 1024;
    *(_DWORD *)int v65 = 1551;
    *(_WORD *)&v65[4] = 1024;
    *(_DWORD *)&v65[6] = v42;
    uint64_t v14 = "%s:%d: indexCommitSyncBulk error:%d";
    goto LABEL_70;
  }
LABEL_3:
  *__error() = v4;
  return *((unsigned int *)a1 + 42);
}

uint64_t _CISyncContextCommitHeader(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 168))
  {
    int v2 = *__error();
    int v3 = _SILogForLogForCategory(11);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v5 = *(_DWORD *)(a1 + 168);
      int v6 = 136315650;
      unsigned int v7 = "_CISyncContextCommitHeader";
      __int16 v8 = 1024;
      int v9 = 1568;
      __int16 v10 = 1024;
      int v11 = v5;
      _os_log_error_impl(&dword_1BD672000, v3, OS_LOG_TYPE_ERROR, "%s:%d: pre-error %d", (uint8_t *)&v6, 0x18u);
    }
    *__error() = v2;
    return *(unsigned int *)(a1 + 168);
  }
  else if (*(unsigned char *)(a1 + 101))
  {
    uint64_t result = _CIMetaInfoSync(*(void *)a1, gTerminating == 0);
    *(_DWORD *)(a1 + 168) = result;
    *(unsigned char *)(a1 + 101) = 0;
  }
  else
  {
    return 0;
  }
  return result;
}

void _CISyncContextDestroy(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 136);
    uint64_t v3 = *(void *)(a1 + 144);
    if (*(unsigned char *)(a1 + 97))
    {
      int v4 = *(void (**)(void))(a1 + 24);
      if (v4) {
        v4(*(void *)(a1 + 80));
      }
    }
    uint64_t v5 = (v2 - 1);
    if (v2 - 1 >= 0)
    {
      uint64_t v6 = (v2 - 1);
      do
      {
        if (!*(_DWORD *)(a1 + 168) && !*(unsigned char *)(*(void *)(v3 + 8 * v6) + 8))
        {
          int v7 = *__error();
          __int16 v8 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)iovec buf = 136315394;
            int v17 = "_CISyncContextDestroy";
            __int16 v18 = 1024;
            int v19 = 1371;
            _os_log_error_impl(&dword_1BD672000, v8, OS_LOG_TYPE_ERROR, "%s:%d: index invalid", buf, 0x12u);
          }
          *__error() = v7;
          *(_DWORD *)(a1 + 168) = -1;
        }
        if (*(unsigned char *)(a1 + 98))
        {
          uint64_t v9 = *(void *)(v3 + 8 * v6);
          pthread_mutex_lock((pthread_mutex_t *)(v9 + 4696));
          int v10 = *(_DWORD *)(v9 + 4892) - 1;
          *(_DWORD *)(v9 + 4892) = v10;
          if (!v10) {
            db_rwlock_wakeup(v9 + 4696, 0, 0);
          }
          pthread_mutex_unlock((pthread_mutex_t *)(v9 + 4696));
        }
        BOOL v11 = v6-- <= 0;
      }
      while (!v11);
      if (*(unsigned char *)(a1 + 99))
      {
        uint64_t v12 = 8 * v5;
        do
        {
          uint64_t v13 = *(void *)(v3 + v12) + 14504;
          pthread_mutex_lock((pthread_mutex_t *)v13);
          int32x2_t v14 = vadd_s32(*(int32x2_t *)(v13 + 196), (int32x2_t)-1);
          *(int32x2_t *)(v13 + 196) = v14;
          if (!v14.i32[0]) {
            db_rwlock_wakeup(v13, 0, 0);
          }
          pthread_mutex_unlock((pthread_mutex_t *)v13);
          v12 -= 8;
        }
        while (v12 != -8);
      }
      int v15 = *(_DWORD *)(a1 + 168);
      do
      {
        if (v15)
        {
          if (v15 != 89) {
            *(unsigned char *)(*(void *)(v3 + 8 * v5) + 8) = 0;
          }
        }
        pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(v3 + 8 * v5) + 15120));
        BOOL v11 = v5-- <= 0;
      }
      while (!v11);
    }
    free(*(void **)(a1 + 144));
    free(*(void **)(a1 + 152));
    free(*(void **)(a1 + 160));
    free((void *)a1);
  }
}

uint64_t _indexShadowBulk(uint64_t a1)
{
  unsigned int v1 = MEMORY[0x1F4188790](a1);
  uint64_t v53 = v7;
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  if (!v1) {
    return 0;
  }
  uint64_t v8 = v6;
  char v9 = v5;
  int v10 = v4;
  uint64_t v51 = v4;
  unint64_t v50 = (unint64_t)v1 << 12;
  BOOL v11 = v2;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  char v52 = v5;
  while (1)
  {
    uint64_t v48 = v13;
    uint64_t v14 = *v11;
    if (*v10 == 1) {
      return 89;
    }
    uint64_t v15 = v12;
    uint32_t v16 = v3;
    if ((v9 & 1) == 0)
    {
      unsigned int v17 = atomic_load((unsigned int *)(v14 + 32));
      if (v17 == -1073623027 && !*v3 && !CIDocCountsNonEmpty((void *)(v14 + 14936)))
      {
        uint64_t v43 = v15;
        goto LABEL_24;
      }
    }
    if (!*(unsigned char *)(v14 + 8)) {
      break;
    }
    uint64_t v18 = v14;
    uint64_t v49 = v16;
    uint64_t v54 = v15;
    int v19 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v20 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, v14, 0, v19);
    unsigned int v57 = HIDWORD(v20);
    unsigned int v58 = v20;
    unsigned int v55 = v22;
    unsigned int v56 = v21;
    uint64_t v23 = *(void *)&threadData[18 * v20 + 2];
    uint64_t v24 = v23 + 320 * HIDWORD(v20);
    *(unsigned char *)(v24 + 216) = 0;
    int v25 = *(_DWORD *)(v24 + 312);
    char v26 = *(void (**)(void))(v24 + 224);
    if (v26) {
      v26(*(void *)(v23 + 320 * HIDWORD(v20) + 288));
    }
    if (_setjmp((int *)v24))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)iovec buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
      }
      *(_DWORD *)(v24 + 312) = v25;
      CIOnThreadCleanUpReset(v55);
      dropThreadId(v58, 1, v19);
      CICleanUpReset(v58, v56);
      uint64_t v42 = 0xFFFFFFFFLL;
LABEL_36:
      uint64_t v15 = v54;
      goto LABEL_37;
    }
    int v47 = v25;
    unsigned int v27 = (void *)(v53 + (v13 & 0xFFFFF000));
    if (v8)
    {
      uint64_t v28 = *(void *)(v8 + 40);
      *(void *)(v8 + 48) += *(void *)(v14 + 14984);
      *(int64x2_t *)(v8 + 24) = vaddq_s64(*(int64x2_t *)(v8 + 24), *(int64x2_t *)(v14 + 14960));
      *(void *)(v8 + 56) += *(void *)(v14 + 14992);
      *(int64x2_t *)uint64_t v8 = vaddq_s64(*(int64x2_t *)v8, *(int64x2_t *)(v14 + 14936));
      *(void *)(v8 + 40) = v28 + *(void *)(v14 + 14976);
      *(void *)(v8 + 16) += *(void *)(v14 + 14952);
      int64x2_t v29 = *(int64x2_t *)(v8 + 80);
      *(int64x2_t *)(v8 + 64) = vaddq_s64(*(int64x2_t *)(v8 + 64), *(int64x2_t *)(v14 + 15000));
      *(int64x2_t *)(v8 + 80) = vaddq_s64(v29, *(int64x2_t *)(v14 + 15016));
      *(void *)(v8 + 96) += *(void *)(v14 + 15032);
      *(void *)(v14 + 15032) = 0;
      *(_OWORD *)(v14 + 15000) = 0u;
      *(_OWORD *)(v14 + 15016) = 0u;
      *(_OWORD *)(v14 + 14968) = 0u;
      *(_OWORD *)(v14 + 14984) = 0u;
      *(_OWORD *)(v14 + 14936) = 0u;
      *(_OWORD *)(v14 + 14952) = 0u;
      uint64_t v30 = v14;
      int v31 = *(unsigned __int8 *)(v14 + 45);
      int v32 = v19;
      if (*(unsigned char *)(v18 + 45)) {
        int v33 = 111;
      }
      else {
        int v33 = 95;
      }
      if (v31) {
        unsigned int v34 = 114;
      }
      else {
        unsigned int v34 = 102;
      }
      bzero(buf, 0x3D68uLL);
      uint64_t v59 = v27;
      unsigned int v35 = v33;
      int v19 = v32;
      int v36 = v31;
      uint64_t v14 = v30;
      indexRestoreFromBuffer((uint64_t)buf, (unsigned int **)&v59, *(_DWORD *)(v18 + 4), v35, v34, 0, v36);
      long long v68 = 0u;
      long long v69 = 0u;
      long long v70 = 0u;
      long long v71 = 0u;
      long long v72 = 0u;
      long long v73 = 0u;
      uint64_t v74 = 0;
      uint64_t v59 = v27;
      indexStoreToBuffer((uint64_t)buf, &v59);
    }
    char v9 = v52;
    int v37 = v27;
    int v10 = v51;
    uint64_t v38 = indexShadowFiles(v18, v52, v37, v51);
    uint64_t v39 = *(void *)&threadData[18 * v58 + 2];
    uint64_t v40 = v39 + 320 * v57;
    *(_DWORD *)(v40 + 312) = v47;
    uint64_t v41 = *(void (**)(void))(v40 + 232);
    if (v41) {
      v41(*(void *)(v39 + 320 * v57 + 288));
    }
    uint64_t v42 = v38;
    dropThreadId(v58, 0, v19);
    if (v38)
    {
      if (v38 == 89) {
        return v42;
      }
      goto LABEL_36;
    }
    uint64_t v43 = *(void *)(v18 + 14472);
    uint32_t v16 = v49;
LABEL_24:
    uint64_t v13 = v48 + 4096;
    uint64_t v3 = v16 + 1;
    ++v11;
    uint64_t v12 = v43;
    if (v50 == v48 + 4096)
    {
      uint64_t v42 = 0;
      goto LABEL_40;
    }
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_WORD *)iovec buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
  }
  uint64_t v42 = 0xFFFFFFFFLL;
LABEL_37:
  int v44 = *__error();
  uint64_t v45 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)iovec buf = 136315906;
    uint64_t v61 = "_indexShadowBulk";
    int v63 = 1226;
    __int16 v62 = 1024;
    __int16 v64 = 1024;
    int v65 = v42;
    __int16 v66 = 2080;
    uint64_t v67 = v14 + 15208;
    _os_log_error_impl(&dword_1BD672000, v45, OS_LOG_TYPE_ERROR, "%s:%d: indexShadowFiles error: %d, %s", buf, 0x22u);
  }
  *__error() = v44;
  uint64_t v43 = v15;
  if (v42) {
    return v42;
  }
LABEL_40:
  if (!v43) {
    return v42;
  }
  fd_sync(v43, 1);
  return 0;
}

uint64_t indexPerformSyncBulk(unsigned int a1, uint64_t *a2, _DWORD *a3, char a4, uint64_t *a5)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  int v6 = a4 & 6;
  uint64_t v7 = a1;
  uint64_t v8 = threadData;
  uint64_t v10 = 0;
  int v36 = v6;
  while (1)
  {
    uint64_t v11 = *a2;
    if (*a3 == 1) {
      return 89;
    }
    unsigned int v12 = atomic_load((unsigned int *)(v11 + 32));
    if (v12 != -1073623027)
    {
      unsigned int v13 = atomic_load((unsigned int *)(v11 + 32));
      if (!v6 || v13 != 2) {
        break;
      }
    }
    uint64_t v14 = v10;
LABEL_19:
    ++a2;
    uint64_t v10 = v14;
    if (!--v7)
    {
      uint64_t v31 = 0;
      int v32 = a5;
      goto LABEL_33;
    }
  }
  if (!*(unsigned char *)(v11 + 8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      *(_WORD *)iovec buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
    }
    goto LABEL_29;
  }
  int v15 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v16 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, v11, 0, v15);
  unsigned int v44 = HIDWORD(v16);
  *(_DWORD *)iovec buf = v16;
  unsigned int v42 = v18;
  unsigned int v43 = v17;
  int v19 = v8;
  uint64_t v20 = *(void *)&v8[18 * v16 + 2];
  uint64_t v21 = v20 + 320 * HIDWORD(v16);
  *(unsigned char *)(v21 + 216) = 0;
  int v22 = *(_DWORD *)(v21 + 312);
  uint64_t v23 = *(void (**)(void))(v21 + 224);
  if (v23) {
    v23(*(void *)(v20 + 320 * HIDWORD(v16) + 288));
  }
  unsigned int v41 = *(_DWORD *)buf;
  unsigned int v40 = v44;
  unint64_t v39 = __PAIR64__(v43, v42);
  if (_setjmp((int *)v21))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v38 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v38, 2u);
    }
    *(_DWORD *)(v21 + 312) = v22;
    CIOnThreadCleanUpReset(v39);
    dropThreadId(v41, 1, v15);
    CICleanUpReset(v41, HIDWORD(v39));
LABEL_29:
    uint64_t v31 = 4294967293;
    goto LABEL_30;
  }
  uint64_t v24 = indexPerformSync(v11);
  int v25 = v22;
  uint64_t v26 = v24;
  uint64_t v8 = v19;
  uint64_t v27 = *(void *)&v19[18 * v41 + 2];
  unsigned int v28 = v40;
  uint64_t v29 = v27 + 320 * v40;
  *(_DWORD *)(v29 + 312) = v25;
  uint64_t v30 = *(void (**)(void))(v29 + 232);
  if (v30) {
    v30(*(void *)(v27 + 320 * v28 + 288));
  }
  uint64_t v31 = v26;
  dropThreadId(v41, 0, v15);
  if (!v26)
  {
    if (*(void *)(v11 + 14472)) {
      uint64_t v14 = *(void *)(v11 + 14472);
    }
    else {
      uint64_t v14 = v10;
    }
    int v6 = v36;
    goto LABEL_19;
  }
  if (v26 == 89) {
    return v31;
  }
LABEL_30:
  int v32 = a5;
  int v33 = *__error();
  unsigned int v34 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)iovec buf = 136315906;
    uint64_t v46 = "indexPerformSyncBulk";
    int v48 = 1117;
    __int16 v47 = 1024;
    __int16 v49 = 1024;
    int v50 = v31;
    __int16 v51 = 2080;
    uint64_t v52 = v11 + 15208;
    _os_log_error_impl(&dword_1BD672000, v34, OS_LOG_TYPE_ERROR, "%s:%d: indexPerformSync error: %d, %s", buf, 0x22u);
  }
  *__error() = v33;
  uint64_t v14 = v10;
  if (v31) {
    return v31;
  }
LABEL_33:
  if (!v14) {
    return v31;
  }
  if (v32) {
    *int v32 = v14;
  }
  else {
    fd_sync(v14, 1);
  }
  return 0;
}

uint64_t _CIFlushCache(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (pthread_mutex_t *)(a1 + 15120);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 15120));
  char v34 = 0;
  if (!*(unsigned char *)(a1 + 8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      uint64_t v19 = 0;
      *(_WORD *)iovec buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
      goto LABEL_17;
    }
    goto LABEL_10;
  }
  int v11 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v12 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v11);
  unsigned int v32 = HIDWORD(v12);
  *(_DWORD *)iovec buf = v12;
  unint64_t v31 = __PAIR64__(v13, v14);
  uint64_t v15 = *(void *)&threadData[18 * v12 + 2];
  uint64_t v16 = v15 + 320 * HIDWORD(v12);
  *(unsigned char *)(v16 + 216) = 0;
  int v17 = *(_DWORD *)(v16 + 312);
  unsigned int v18 = *(void (**)(void))(v16 + 224);
  if (v18) {
    v18(*(void *)(v15 + 320 * HIDWORD(v12) + 288));
  }
  unsigned int v30 = *(_DWORD *)buf;
  unsigned int v29 = v32;
  unint64_t v28 = v31;
  if (_setjmp((int *)v16))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      v27[0] = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)v27, 2u);
    }
    *(_DWORD *)(v16 + 312) = v17;
    CIOnThreadCleanUpReset(v28);
    dropThreadId(v30, 1, v11);
    CICleanUpReset(v30, HIDWORD(v28));
LABEL_10:
    uint64_t v19 = 0;
    goto LABEL_17;
  }
  if (atomic_load((unsigned int *)(a1 + 15192)))
  {
    (*(void (**)(uint64_t))(a5 + 16))(a5);
    uint64_t v21 = 0;
  }
  else
  {
    uint64_t v21 = index_FlushCache(a1, a2, a3, a4, a5);
  }
  char v34 = 1;
  uint64_t v22 = *(void *)&threadData[18 * v30 + 2];
  unsigned int v23 = v29;
  uint64_t v24 = v22 + 320 * v29;
  *(_DWORD *)(v24 + 312) = v17;
  int v25 = *(void (**)(void))(v24 + 232);
  if (v25) {
    v25(*(void *)(v22 + 320 * v23 + 288));
  }
  dropThreadId(v30, 0, v11);
  uint64_t v19 = v21;
LABEL_17:
  if (!v34) {
    (*(void (**)(uint64_t))(a5 + 16))(a5);
  }
  pthread_mutex_unlock(v10);
  return v19;
}

_DWORD *_CIEnsureOpenFiles(uint64_t a1)
{
  fd_warmup(*(_DWORD **)(a1 + 4672));
  fd_warmup(*(_DWORD **)(a1 + 208));
  uint64_t result = fd_warmup(*(_DWORD **)(a1 + 472));
  uint64_t v3 = *(void *)(a1 + 4928);
  if (v3)
  {
    int v4 = *(_DWORD **)(v3 + 224);
    return fd_warmup(v4);
  }
  return result;
}

uint64_t _CIListsClean(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  unsigned int v23 = 0;
  MEMORY[0x1F4188790](a1);
  char v5 = (char *)v21 - v4;
  bzero((char *)v21 - v4, v6);
  int v7 = GatherAndLockIndexes(a1, a2, (uint64_t)v5, &v23);
  unsigned int v8 = v23;
  if (v7) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = v23 == 0;
  }
  if (v9)
  {
    uint64_t v10 = 1;
  }
  else
  {
    unint64_t v11 = 0;
    while (1)
    {
      uint64_t v12 = *(void *)&v5[8 * v11];
      BOOL v13 = CIDocCountsNonEmpty((void *)(v12 + 14936));
      if (v13)
      {
LABEL_12:
        uint64_t v10 = !v13;
        goto LABEL_13;
      }
      char v14 = atomic_load((unsigned int *)(v12 + 36));
      if ((v14 & 2) == 0)
      {
        uint64_t v15 = *(void *)(v12 + 14392);
        if (v15)
        {
          long long v16 = *(_OWORD *)(v15 + 168);
          long long v17 = *(_OWORD *)(v15 + 200);
          v21[4] = *(_OWORD *)(v15 + 184);
          void v21[5] = v17;
          uint64_t v22 = *(void *)(v15 + 216);
          long long v18 = *(_OWORD *)(v15 + 136);
          v21[0] = *(_OWORD *)(v15 + 120);
          v21[1] = v18;
          v21[2] = *(_OWORD *)(v15 + 152);
          void v21[3] = v16;
          if (CIDocCountsNonEmpty(v21)) {
            break;
          }
        }
      }
      ++v11;
      unsigned int v8 = v23;
      if (v11 >= v23) {
        goto LABEL_12;
      }
    }
    uint64_t v10 = 0;
    unsigned int v8 = v23;
  }
LABEL_13:
  if ((int)(v8 - 1) >= 0)
  {
    uint64_t v19 = 8 * (v8 - 1);
    do
    {
      pthread_mutex_unlock((pthread_mutex_t *)(*(void *)&v5[v19] + 15120));
      v19 -= 8;
    }
    while (v19 != -8);
  }
  return v10;
}

uint64_t _CICompact(uint64_t a1, _OWORD *a2, char a3, unsigned char *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (a4) {
    *a4 = 0;
  }
  bzero(v28, 0x400uLL);
  if ((a3 & 1) == 0 || *(unsigned char *)(a1 + 45) || confstr(65537, v28, 0x400uLL) - 1 > 0x3FF) {
    int v7 = -1;
  }
  else {
    int v7 = open(v28, 4);
  }
  if (!*(unsigned char *)(a1 + 8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      *(_WORD *)iovec buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
    }
    goto LABEL_17;
  }
  int v8 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v9 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v8);
  unsigned int v24 = HIDWORD(v9);
  unsigned int v25 = v9;
  unsigned int v22 = v11;
  unsigned int v23 = v10;
  uint64_t v12 = *(void *)&threadData[18 * v9 + 2];
  uint64_t v13 = v12 + 320 * HIDWORD(v9);
  *(unsigned char *)(v13 + 216) = 1;
  int v14 = *(_DWORD *)(v13 + 312);
  uint64_t v15 = *(void (**)(void))(v13 + 224);
  if (v15) {
    v15(*(void *)(v12 + 320 * HIDWORD(v9) + 288));
  }
  if (_setjmp((int *)v13))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)iovec buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v13 + 312) = v14;
    CIOnThreadCleanUpReset(v22);
    dropThreadId(v25, 1, v8);
    CICleanUpReset(v25, v23);
LABEL_17:
    uint64_t v16 = 0xFFFFFFFFLL;
    goto LABEL_21;
  }
  long long v17 = a2[1];
  *(_OWORD *)iovec buf = *a2;
  long long v27 = v17;
  uint64_t v16 = index_compact(a1);
  uint64_t v18 = *(void *)&threadData[18 * v25 + 2];
  uint64_t v19 = v18 + 320 * v24;
  *(_DWORD *)(v19 + 312) = v14;
  uint64_t v20 = *(void (**)(void))(v19 + 232);
  if (v20) {
    v20(*(void *)(v18 + 320 * v24 + 288));
  }
  dropThreadId(v25, 0, v8);
LABEL_21:
  if (v7 != -1) {
    close(v7);
  }
  return v16;
}

uint64_t _CIMakeInvalid(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1 + 14720;
  _db_write_lock(a1 + 14720);
  int v3 = *__error();
  uint64_t v4 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    v8.st_dev = 136315906;
    *(void *)&v8.st_mode = "indexMakeInvalid";
    WORD2(v8.st_ino) = 1024;
    *(_DWORD *)((char *)&v8.st_ino + 6) = 2690;
    HIWORD(v8.st_uid) = 2080;
    *(void *)&v8.st_gid = a1 + 15208;
    *((_WORD *)&v8.st_rdev + 2) = 1024;
    *(dev_t *)((char *)&v8.st_rdev + 6) = 2690;
    _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", (uint8_t *)&v8, 0x22u);
  }
  *__error() = v3;
  *(unsigned char *)(a1 + 8) = 0;
  uint64_t v5 = *(unsigned int *)(a1 + 64);
  memset(&v8, 0, sizeof(v8));
  if (!fstat(v5, &v8))
  {
    uint64_t v6 = open(".", 4);
    if (!MEMORY[0x1C1882290](v5))
    {
      bzero(&v8, 0x400uLL);
      snprintf((char *)&v8, 0x400uLL, "%s%s", (const char *)(a1 + 15208), "indexHead");
      unlink((const char *)&v8);
      snprintf((char *)&v8, 0x400uLL, "%s%s", (const char *)(a1 + 15208), "shadowIndexHead");
      unlink((const char *)&v8);
      MEMORY[0x1C1882290](v6);
    }
    if ((v6 & 0x80000000) == 0) {
      close(v6);
    }
  }
  return db_write_unlock(v2);
}

uint64_t ContentIndexVerifyIndex(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      *(_WORD *)iovec buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
    }
    return 0xFFFFFFFFLL;
  }
  int v2 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v3 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v2);
  unsigned int v21 = HIDWORD(v3);
  *(_DWORD *)iovec buf = v3;
  unint64_t v20 = __PAIR64__(v4, v5);
  uint64_t v6 = *(void *)&threadData[18 * v3 + 2];
  uint64_t v7 = v6 + 320 * HIDWORD(v3);
  *(unsigned char *)(v7 + 216) = 0;
  int v8 = *(_DWORD *)(v7 + 312);
  uint64_t v9 = *(void (**)(void))(v7 + 224);
  if (v9) {
    v9(*(void *)(v6 + 320 * HIDWORD(v3) + 288));
  }
  unsigned int v19 = *(_DWORD *)buf;
  unsigned int v18 = v21;
  unint64_t v17 = v20;
  if (_setjmp((int *)v7))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v16 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v16, 2u);
    }
    *(_DWORD *)(v7 + 312) = v8;
    CIOnThreadCleanUpReset(v17);
    dropThreadId(v19, 1, v2);
    CICleanUpReset(v19, HIDWORD(v17));
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = index_verify(a1);
  uint64_t v12 = *(void *)&threadData[18 * v19 + 2];
  unsigned int v13 = v18;
  uint64_t v14 = v12 + 320 * v18;
  *(_DWORD *)(v14 + 312) = v8;
  uint64_t v15 = *(void (**)(void))(v14 + 232);
  if (v15) {
    v15(*(void *)(v12 + 320 * v13 + 288));
  }
  dropThreadId(v19, 0, v2);
  return v11;
}

uint64_t iterateTermsCallback(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  if (!*(_DWORD *)(a5 + 4))
  {
    storageResolvePtr(*(void *)(a5 + 8), 8 * a3, 8, 1);
    storageResolvePtr(*(void *)(a5 + 16), 8 * a3, 8, 1);
  }
  return (*(uint64_t (**)(void))(*(void *)(a5 + 24) + 16))();
}

void _CIDisableUpdates(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(v1 + 8))
  {
    int v3 = v2;
    uint64_t v4 = v1;
    int v5 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v6 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, v1, 0, v5);
    unsigned int v46 = HIDWORD(v6);
    unsigned int v47 = v6;
    unsigned int v44 = v8;
    unsigned int v45 = v7;
    uint64_t v9 = *(void *)&threadData[18 * v6 + 2];
    uint64_t v10 = v9 + 320 * HIDWORD(v6);
    *(unsigned char *)(v10 + 216) = 0;
    int v11 = *(_DWORD *)(v10 + 312);
    uint64_t v12 = *(void (**)(void))(v10 + 224);
    if (v12) {
      v12(*(void *)(v9 + 320 * HIDWORD(v6) + 288));
    }
    if (_setjmp((int *)v10))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)iovec buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
      }
      *(_DWORD *)(v10 + 312) = v11;
      CIOnThreadCleanUpReset(v44);
      dropThreadId(v47, 1, v5);
      CICleanUpReset(v47, v45);
      return;
    }
    HIDWORD(v14) = qos_class_self() - 9;
    LODWORD(v14) = HIDWORD(v14);
    unsigned int v13 = v14 >> 2;
    if (v13 > 6) {
      signed int v15 = 0;
    }
    else {
      signed int v15 = dword_1BDA87810[v13];
    }
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 14720));
    if (*(void *)(v4 + 14904) || *(_DWORD *)(v4 + 14916) || *(unsigned char *)(v4 + 14932)) {
      goto LABEL_16;
    }
    if (v15 <= 5)
    {
      if (*(void *)(v4 + 16 * v15 + 14784))
      {
LABEL_16:
        db_rwlock_wait(v4 + 14720, v15, 2);
LABEL_17:
        pthread_mutex_unlock((pthread_mutex_t *)(v4 + 14720));
        char v16 = atomic_load((unsigned int *)(v4 + 36));
        if (v16)
        {
          if (dword_1E9FC90CC >= 5)
          {
            int v24 = *__error();
            unsigned int v25 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
            {
              int v26 = *(_DWORD *)(v4 + 56);
              unsigned int v27 = atomic_load((unsigned int *)(v4 + 36));
              int v28 = *(_DWORD *)(v4 + 15668);
              *(_DWORD *)iovec buf = 134219008;
              uint64_t v50 = v4;
              *(_WORD *)__int16 v51 = 1024;
              *(_DWORD *)&v51[2] = v26;
              __int16 v52 = 1024;
              int v53 = v3;
              __int16 v54 = 1024;
              unsigned int v55 = v27;
              __int16 v56 = 1024;
              int v57 = v28;
              _os_log_impl(&dword_1BD672000, v25, OS_LOG_TYPE_DEFAULT, "skip index updates disable for %p (%d) from %d; flags 0x%x, disabled at %d",
                buf,
                0x24u);
            }
            *__error() = v24;
          }
        }
        else
        {
          if (dword_1E9FC90CC >= 5)
          {
            int v40 = *__error();
            unsigned int v41 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
            {
              int v43 = *(_DWORD *)(v4 + 56);
              *(_DWORD *)iovec buf = 134218496;
              uint64_t v50 = v4;
              *(_WORD *)__int16 v51 = 1024;
              *(_DWORD *)&v51[2] = v43;
              __int16 v52 = 1024;
              int v53 = v3;
              _os_log_impl(&dword_1BD672000, v41, OS_LOG_TYPE_DEFAULT, "index updates disabled for %p (%d) from %d", buf, 0x18u);
            }
            *__error() = v40;
          }
          atomic_fetch_or((atomic_uint *volatile)(v4 + 36), 1u);
          unsigned int v17 = atomic_load((unsigned int *)(v4 + 32));
          bzero(buf, 0x1000uLL);
          atomic_store(v17, (unsigned int *)(v4 + 32));
          int v18 = *(_DWORD *)(v4 + 4);
          unsigned int v19 = atomic_load((unsigned int *)(v4 + 32));
          *(_DWORD *)iovec buf = v18;
          LODWORD(v50) = v19;
          unsigned int v20 = atomic_load((unsigned int *)(v4 + 36));
          int v21 = *(_DWORD *)(v4 + 48);
          HIDWORD(v50) = v20;
          *(_DWORD *)__int16 v51 = v21;
          pthread_mutex_lock((pthread_mutex_t *)(v4 + 14720));
          *(unsigned char *)(v4 + 14932) = 1;
          db_rwlock_wakeup(v4 + 14720, 1, 1);
          pthread_mutex_unlock((pthread_mutex_t *)(v4 + 14720));
          uint64_t v22 = *(void *)(v4 + 14480);
          if (v22)
          {
            uint64_t v23 = fd_pwrite(*(void *)(v4 + 14480), (uint64_t)buf, 0x10uLL, 0);
            if (v23 == 16)
            {
              if (_gSystemStatusBool)
              {
                pthread_mutex_lock(&_gSystemStatusLock);
                while (_gSystemStatusBool)
                  pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
                pthread_mutex_unlock(&_gSystemStatusLock);
              }
              uint64_t v48 = 0;
              uint64_t v29 = _fd_acquire_fd(v22, &v48);
              if (v29 != -1)
              {
                int v30 = v29;
                prot_fsync(v29, (*(_WORD *)(v22 + 56) & 8) == 0);
                _fd_release_fd((_DWORD *)v22, v30, 0, v48);
              }
            }
            else if (v23 == -1)
            {
              __error();
            }
          }
          *(_DWORD *)(v4 + 15668) = v3;
        }
        pthread_mutex_lock((pthread_mutex_t *)(v4 + 14720));
        *(_DWORD *)(v4 + 14924) = 0;
        unint64_t v31 = *(pthread_override_s **)(v4 + 14896);
        *(void *)(v4 + 14904) = 0;
        *(void *)(v4 + 14896) = 0;
        char v32 = *(_DWORD *)(v4 + 14916) != 0;
        *(unsigned char *)(v4 + 14932) = 0;
        db_rwlock_wakeup(v4 + 14720, v32, 0);
        pthread_mutex_unlock((pthread_mutex_t *)(v4 + 14720));
        if (v31) {
          pthread_override_qos_class_end_np(v31);
        }
        uint64_t v33 = *(void *)&threadData[18 * v47 + 2];
        uint64_t v34 = v33 + 320 * v46;
        *(_DWORD *)(v34 + 312) = v11;
        unsigned int v35 = *(void (**)(void))(v34 + 232);
        if (v35) {
          v35(*(void *)(v33 + 320 * v46 + 288));
        }
        dropThreadId(v47, 0, v5);
        return;
      }
      uint64_t v36 = v15 - 1;
      int v37 = (uint64_t *)(v4 + 16 * v15 + 14800);
      while (v36 != 4)
      {
        uint64_t v38 = *v37;
        v37 += 2;
        uint64_t v39 = ++v36;
        if (v38)
        {
          if (v39 <= 4) {
            goto LABEL_16;
          }
          break;
        }
      }
    }
    *(void *)(v4 + 14904) = pthread_self();
    goto LABEL_17;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_WORD *)iovec buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
  }
}

uint64_t _ContentIndexMergeIndexes(uint64_t **a1, unsigned int a2, uint64_t a3, uint64_t *a4, long long *a5)
{
  uint64_t v26 = a3;
  unsigned int v27 = a1;
  v40[1] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = a2;
  size_t v9 = 8 * a2;
  MEMORY[0x1F4188790](a1);
  int v11 = (char *)&v26 - v10;
  uint64_t v12 = (uint64_t)CICleanUpThreadLoc();
  unint64_t v13 = threadData[18 * v12 + 8];
  if (*(void *)a5) {
    uint64_t v14 = (*(uint64_t (**)(void))a5)(*((void *)a5 + 4));
  }
  else {
    uint64_t v14 = 0;
  }
  bzero(v11, v9);
  if (a2)
  {
    signed int v15 = v27;
    char v16 = (uint64_t **)v11;
    uint64_t v17 = v8;
    do
    {
      int v18 = *v15++;
      *v16++ = v18;
      unsigned int v19 = IndexFdInfoCreate(v18, 0);
      CICleanUpPush(v12, (uint64_t)IndexFdInfoDispose, (uint64_t)v19);
      --v17;
    }
    while (v17);
  }
  uint64_t v38 = 0;
  unsigned int v20 = (void (*)(void, uint64_t))*((void *)a5 + 1);
  if (v20) {
    v20(*((void *)a5 + 4), v14);
  }
  long long v21 = a5[3];
  long long v35 = a5[2];
  long long v36 = v21;
  long long v37 = a5[4];
  long long v22 = a5[1];
  long long v33 = *a5;
  long long v34 = v22;
  uint64_t v23 = mergeIndexData((uint64_t)v11);
  CICleanUpReset(v12, v13);
  if (v23)
  {
    if (g_fd_list) {
      _fd_close_inactive(*(unsigned int *)(v23 + 64), (const char *)(v23 + 15208), 0, 0);
    }
    if (a4) {
      *a4 = CIRemappingCreateWithContext(*MEMORY[0x1E4F1CF80], *(void *)(v23 + 80), v38);
    }
    uint64_t v32 = 0;
    long long v31 = 0u;
    long long v30 = 0u;
    long long v29 = 0u;
    long long v28 = 0u;
    atomic_fetch_or((atomic_uint *volatile)(v23 + 36), 0x64u);
    _CIDisableUpdates(v23);
    uint64_t v24 = (uint64_t)(*v27 + 1899);
    long long v35 = v30;
    long long v36 = v31;
    *(void *)&long long v37 = v32;
    long long v33 = v28;
    long long v34 = v29;
    v39[2] = 0;
    v40[0] = v23;
    v39[0] = v40;
    v39[1] = 0x100000001;
    _ContentIndexSyncIndexBulk(0, (uint64_t)v39, 0, 1, 0, (uint64_t)&v33, v24, 0, 0);
    *(_DWORD *)(v23 + 15680) = *(_DWORD *)(v23 + 68);
  }
  return v23;
}

BOOL _CIMergeDeletes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *(void *)(a1 + 80);
  unsigned int v5 = *(_DWORD *)(a1 + 68);
  if (v5 >= 2) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  char v38 = 0;
  char v37 = 0;
  if (!*(unsigned char *)(a1 + 8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      *(_WORD *)iovec buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
    }
    goto LABEL_13;
  }
  int v11 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v12 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v11);
  unsigned int v35 = HIDWORD(v12);
  *(_DWORD *)iovec buf = v12;
  unint64_t v34 = __PAIR64__(v13, v14);
  uint64_t v15 = *(void *)&threadData[18 * v12 + 2];
  uint64_t v16 = v15 + 320 * HIDWORD(v12);
  *(unsigned char *)(v16 + 216) = 0;
  int v17 = *(_DWORD *)(v16 + 312);
  int v18 = *(void (**)(void))(v16 + 224);
  if (v18) {
    v18(*(void *)(v15 + 320 * HIDWORD(v12) + 288));
  }
  unsigned int v33 = *(_DWORD *)buf;
  unsigned int v32 = v35;
  unint64_t v31 = v34;
  if (_setjmp((int *)v16))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v30 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v30, 2u);
    }
    *(_DWORD *)(v16 + 312) = v17;
    CIOnThreadCleanUpReset(v31);
    dropThreadId(v33, 1, v11);
    CICleanUpReset(v33, HIDWORD(v31));
LABEL_13:
    BOOL v19 = v38 == 0;
    return !v19;
  }
  if (a4 < 1)
  {
    int v24 = 1;
  }
  else
  {
    uint64_t v21 = 0;
    do
    {
      uint64_t v22 = v21;
      int v23 = _MergeDeletes(a1, *(void *)(a3 + 8 * v21), a2, v4, v4 + v6, &v37);
      uint64_t v21 = v22 + 1;
    }
    while (v22 + 1 < a4 && (v23 & 1) != 0);
    int v24 = v23;
  }
  char v38 = 1;
  uint64_t v25 = *(void *)&threadData[18 * v33 + 2];
  unsigned int v26 = v32;
  uint64_t v27 = v25 + 320 * v32;
  *(_DWORD *)(v27 + 312) = v17;
  long long v28 = *(void (**)(void))(v27 + 232);
  if (v28) {
    v28(*(void *)(v25 + 320 * v26 + 288));
  }
  dropThreadId(v33, 0, v11);
  if (v38) {
    BOOL v29 = v24 == 0;
  }
  else {
    BOOL v29 = 1;
  }
  BOOL v19 = v29;
  if (!v29 && v37)
  {
    _indexShadowGroups(a1, 1);
    BOOL v19 = 0;
  }
  return !v19;
}

uint64_t _MergeDeletes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, unsigned char *a6)
{
  unsigned __int8 v83 = 0;
  if (!*(unsigned char *)(a2 + 8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      *(_WORD *)iovec buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
    }
    return v83;
  }
  int v12 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v13 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a2, 0, v12);
  unsigned int v81 = HIDWORD(v13);
  *(_DWORD *)iovec buf = v13;
  unint64_t v80 = __PAIR64__(v14, v15);
  uint64_t v16 = *(void *)&threadData[18 * v13 + 2];
  uint64_t v17 = v16 + 320 * HIDWORD(v13);
  *(unsigned char *)(v17 + 216) = 0;
  int v18 = *(_DWORD *)(v17 + 312);
  BOOL v19 = *(void (**)(void))(v17 + 224);
  if (v19) {
    v19(*(void *)(v16 + 320 * HIDWORD(v13) + 288));
  }
  unsigned int v79 = *(_DWORD *)buf;
  unsigned int v78 = v81;
  unint64_t v77 = v80;
  if (_setjmp((int *)v17))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v76 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v76, 2u);
    }
    *(_DWORD *)(v17 + 312) = v18;
    CIOnThreadCleanUpReset(v77);
    dropThreadId(v79, 1, v12);
    CICleanUpReset(v79, HIDWORD(v77));
    return v83;
  }
  uint64_t v20 = *(unsigned int *)(a2 + 68);
  if (v20 < 2) {
    goto LABEL_48;
  }
  uint64_t v21 = *(void *)(a2 + 80);
  uint64_t v22 = 1;
  int v23 = (void *)MEMORY[0x1E4F14B00];
  uint64_t v24 = 0;
  do
  {
    uint64_t v25 = v24;
    if (*(unsigned char *)(a2 + 45)) {
      int v26 = *(unsigned __int8 *)(*(void *)(a2 + 14432) + v22);
    }
    else {
      int v26 = (*(_DWORD *)(*(void *)(a2 + 14432) + 4 * (v22 / 5uLL)) >> (6 * (v22 % 5))) & 0x3F;
    }
    if ((v26 & 0xFFFFFFDF) != 0) {
      goto LABEL_16;
    }
    unint64_t v27 = v21 + v22;
    unint64_t v28 = v21 + v22;
    if (a3 && (BOOL v29 = *(uint64_t **)(a3 + 16), v30 = *v29, *v29 >= 1))
    {
      uint64_t v31 = 0;
      uint64_t v32 = v29[1];
      unsigned int v33 = (unsigned int *)(v32 + 8);
      while (1)
      {
        unint64_t v34 = *((void *)v33 - 1);
        if (v27 > v34 && v34 + *v33 > v27) {
          break;
        }
        ++v31;
        v33 += 6;
        if (v30 == v31) {
          goto LABEL_24;
        }
      }
      uint64_t v52 = *(unsigned int *)(*(void *)(v32 + 24 * v31 + 16) + 4 * (v27 - v34));
      if (!v52) {
        goto LABEL_16;
      }
      unint64_t v28 = *(void *)(a3 + 32) + v52;
      if (!v28) {
        goto LABEL_16;
      }
    }
    else
    {
LABEL_24:
      if (!v28) {
        goto LABEL_16;
      }
    }
    unsigned int v35 = v28 - a4;
    if (v28 <= a4 || v28 > a5)
    {
LABEL_52:
      uint64_t v58 = __si_assert_copy_extra_329();
      __message_assert_333((uint64_t)v58, v59, v60, v61, v62, v63, v64, v65, (char)"ContentIndex.c");
      free(v58);
      if (__valid_fs(-1)) {
        uint64_t v66 = 2989;
      }
      else {
        uint64_t v66 = 3072;
      }
      *(_DWORD *)uint64_t v66 = -559038737;
      abort();
    }
    unsigned int v36 = v28 - a4;
    if (*(unsigned char *)(a1 + 45))
    {
      uint64_t v37 = *(void *)(a1 + 14432);
      if ((*(unsigned char *)(v37 + v35) & 0xDF) != 0)
      {
        unint64_t v38 = v35;
        *(unsigned char *)(v37 + v35) = 0;
        uint64_t v39 = *(void *)(a1 + 14440);
        if (v39) {
          *(unsigned char *)(v39 + v38 / (32 * *v23)) |= 1 << ((v38 / (4 * *v23)) & 7);
        }
        uint64_t v25 = 1;
      }
      goto LABEL_16;
    }
    unint64_t v40 = v35 / 5uLL;
    unsigned int v41 = 6 * (v35 % 5);
    uint64_t v42 = *(void *)(a1 + 14432);
    unsigned int v43 = *(_DWORD *)(v42 + 4 * v40);
    if (((v43 >> (6 * (v36 - 5 * v40))) & 0x1F) == 0) {
      goto LABEL_16;
    }
    unint64_t v44 = v40;
    unsigned int v45 = v43 & ~(63 << v41);
    if (!*(void *)(a1 + 14440))
    {
      *(_DWORD *)(v42 + 4 * v40) = v45;
LABEL_43:
      int v51 = (v45 >> v41) & 0x3F;
      goto LABEL_44;
    }
    unint64_t v46 = v40 / (8 * *v23);
    uint64_t v47 = (v40 / *v23) & 7;
    *(unsigned char *)(*(void *)(a1 + 14440) + v46) |= 1 << v47;
    if (!*(unsigned char *)(*(void *)(a1 + 14440) + v46)
      || (uint64_t v48 = v47 | (8 * v46), *v23 * v48 > v40)
      || *v23 * (unint64_t)(v48 + 1) <= v40)
    {
      uint64_t v67 = __si_assert_copy_extra_329();
      __message_assert_333((uint64_t)v67, v68, v69, v70, v71, v72, v73, v74, (char)"ContentIndex.c");
      free(v67);
      if (__valid_fs(-1)) {
        uint64_t v75 = 2989;
      }
      else {
        uint64_t v75 = 3072;
      }
      *(_DWORD *)uint64_t v75 = -559038737;
      abort();
    }
    uint64_t v49 = *(void *)(a1 + 14432);
    int v50 = *(unsigned __int8 *)(a1 + 45);
    *(_DWORD *)(v49 + 4 * v44) = v45;
    if (!v50) {
      goto LABEL_43;
    }
    int v51 = *(unsigned __int8 *)(v49 + v36);
LABEL_44:
    if (v51) {
      goto LABEL_52;
    }
    uint64_t v25 = 1;
LABEL_16:
    ++v22;
    uint64_t v24 = v25;
  }
  while (v22 != v20);
  if (((a6 != 0) & v25) != 0) {
    *a6 = 1;
  }
LABEL_48:
  unsigned __int8 v83 = 1;
  uint64_t v53 = *(void *)&threadData[18 * v79 + 2];
  unsigned int v54 = v78;
  uint64_t v55 = v53 + 320 * v78;
  *(_DWORD *)(v55 + 312) = v18;
  __int16 v56 = *(void (**)(void))(v55 + 232);
  if (v56) {
    v56(*(void *)(v53 + 320 * v54 + 288));
  }
  dropThreadId(v79, 0, v12);
  return v83;
}

void _CIUpdateGroupAndDate(uint64_t a1, unint64_t a2, int a3, int a4)
{
  if (*(unsigned char *)(a1 + 8))
  {
    int v8 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v9 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v8);
    unsigned int v62 = HIDWORD(v9);
    *(_DWORD *)iovec buf = v9;
    unsigned int v60 = v11;
    unsigned int v61 = v10;
    uint64_t v12 = *(void *)&threadData[18 * v9 + 2];
    uint64_t v13 = v12 + 320 * HIDWORD(v9);
    *(unsigned char *)(v13 + 216) = 0;
    int v14 = *(_DWORD *)(v13 + 312);
    unsigned int v15 = *(void (**)(void))(v13 + 224);
    if (v15) {
      v15(*(void *)(v12 + 320 * HIDWORD(v9) + 288));
    }
    unsigned int v59 = *(_DWORD *)buf;
    unsigned int v58 = v62;
    unint64_t v57 = __PAIR64__(v61, v60);
    if (_setjmp((int *)v13))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int16 v56 = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v56, 2u);
      }
      *(_DWORD *)(v13 + 312) = v14;
      CIOnThreadCleanUpReset(v57);
      dropThreadId(v59, 1, v8);
      CICleanUpReset(v59, HIDWORD(v57));
      return;
    }
    if (!a2) {
      goto LABEL_32;
    }
    unint64_t v16 = *(void *)(a1 + 80);
    unsigned int v17 = a2 - v16;
    if (a2 <= v16 || v16 + *(unsigned int *)(a1 + 68) <= a2) {
      goto LABEL_32;
    }
    int v18 = CICleanUpThreadLoc();
    _db_write_lock(a1 + 14504);
    CIOnThreadCleanUpPush((uint64_t)v18, (uint64_t)si_rwlock_wrunlock, a1 + 14504);
    if (a4)
    {
      uint64_t v19 = *(void *)(a1 + 14416);
      if (v19) {
        *(_DWORD *)(v19 + 4 * v17) = a4;
      }
    }
    if (!a3) {
      goto LABEL_31;
    }
    if (*(unsigned char *)(a1 + 45))
    {
      if ((*(unsigned char *)(*(void *)(a1 + 14432) + v17) & 0xDF) != 0)
      {
        *(unsigned char *)(*(void *)(a1 + 14432) + v17) = a3;
        uint64_t v20 = *(void *)(a1 + 14440);
        if (v20) {
          *(unsigned char *)(v20 + v17 / (unint64_t)(32 * *MEMORY[0x1E4F14B00])) |= 1 << ((v17
        }
                                                                                          / (unint64_t)(4 * *MEMORY[0x1E4F14B00])) & 7);
      }
      goto LABEL_31;
    }
    unint64_t v21 = v17 / 5uLL;
    unsigned int v22 = 6 * (v17 % 5);
    uint64_t v23 = *(void *)(a1 + 14432);
    unsigned int v24 = *(_DWORD *)(v23 + 4 * v21);
    if (((v24 >> (6 * (v17 % 5))) & 0x1F) == 0)
    {
LABEL_31:
      CIOnThreadCleanUpPop((uint64_t)v18);
LABEL_32:
      uint64_t v34 = *(void *)&threadData[18 * v59 + 2];
      unsigned int v35 = v58;
      uint64_t v36 = v34 + 320 * v58;
      *(_DWORD *)(v36 + 312) = v14;
      uint64_t v37 = *(void (**)(void))(v36 + 232);
      if (v37) {
        v37(*(void *)(v34 + 320 * v35 + 288));
      }
      dropThreadId(v59, 0, v8);
      return;
    }
    unsigned int v25 = v24 & ~(63 << v22) | ((a3 & 0x3F) << v22);
    if (*(void *)(a1 + 14440))
    {
      int v26 = (uint64_t *)MEMORY[0x1E4F14B00];
      unint64_t v27 = v21 / (8 * *MEMORY[0x1E4F14B00]);
      uint64_t v28 = (v21 / *MEMORY[0x1E4F14B00]) & 7;
      *(unsigned char *)(*(void *)(a1 + 14440) + v27) |= 1 << v28;
      if (!*(unsigned char *)(*(void *)(a1 + 14440) + v27)
        || (uint64_t v29 = *v26, v30 = v28 | (8 * v27), v29 * v30 > v21)
        || v29 * (unint64_t)(v30 + 1) <= v21)
      {
        uint64_t v47 = __si_assert_copy_extra_329();
        __message_assert_333((uint64_t)v47, v48, v49, v50, v51, v52, v53, v54, (char)"ContentIndex.c");
        free(v47);
        if (__valid_fs(-1)) {
          uint64_t v55 = 2989;
        }
        else {
          uint64_t v55 = 3072;
        }
        *(_DWORD *)uint64_t v55 = -559038737;
        abort();
      }
      uint64_t v31 = *(void *)(a1 + 14432);
      int v32 = *(unsigned __int8 *)(a1 + 45);
      *(_DWORD *)(v31 + 4 * (v17 / 5uLL)) = v25;
      if (v32)
      {
        int v33 = *(unsigned __int8 *)(v31 + v17);
        goto LABEL_30;
      }
    }
    else
    {
      *(_DWORD *)(v23 + 4 * v21) = v25;
    }
    int v33 = (v25 >> v22) & 0x3F;
LABEL_30:
    if (v33 != (a3 & 0x3F))
    {
      unint64_t v38 = __si_assert_copy_extra_329();
      __message_assert_333((uint64_t)v38, v39, v40, v41, v42, v43, v44, v45, (char)"ContentIndex.c");
      free(v38);
      if (__valid_fs(-1)) {
        uint64_t v46 = 2989;
      }
      else {
        uint64_t v46 = 3072;
      }
      *(_DWORD *)uint64_t v46 = -559038737;
      abort();
    }
    goto LABEL_31;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_WORD *)iovec buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
  }
}

void _CIReassign(uint64_t a1, uint64_t a2, const char *a3, const char *a4)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 8))
  {
    int v8 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v9 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v8);
    unsigned int v54 = HIDWORD(v9);
    unsigned int v55 = v9;
    unsigned int v52 = v11;
    unsigned int v53 = v10;
    uint64_t v12 = *(void *)&threadData[18 * v9 + 2];
    uint64_t v13 = v12 + 320 * HIDWORD(v9);
    *(unsigned char *)(v13 + 216) = 0;
    int v14 = *(_DWORD *)(v13 + 312);
    unsigned int v15 = *(void (**)(void))(v13 + 224);
    if (v15) {
      v15(*(void *)(v12 + 320 * HIDWORD(v9) + 288));
    }
    if (_setjmp((int *)v13))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)iovec buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
      }
      *(_DWORD *)(v13 + 312) = v14;
      CIOnThreadCleanUpReset(v52);
      dropThreadId(v55, 1, v8);
      CICleanUpReset(v55, v53);
      return;
    }
    if (dword_1E9FC90CC >= 5)
    {
      int v50 = *__error();
      uint64_t v51 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)iovec buf = 67109120;
        LODWORD(v65) = a2;
        _os_log_impl(&dword_1BD672000, v51, OS_LOG_TYPE_DEFAULT, "reassign docId: %d", buf, 8u);
      }
      *__error() = v50;
    }
    if (!*(unsigned char *)(a1 + 8))
    {
      bzero(buf, 0x400uLL);
      if ((reassignDocument__COUNT_ & 1) == 0)
      {
        reassignDocument__COUNT_ = 1;
        int v16 = *__error();
        unsigned int v17 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          int v46 = fcntl(*(_DWORD *)(a1 + 64), 50, buf);
          if (buf[0]) {
            BOOL v47 = v46 < 0;
          }
          else {
            BOOL v47 = 1;
          }
          *(_DWORD *)__int16 v56 = 136315906;
          unint64_t v57 = "reassignDocument";
          uint64_t v48 = (uint8_t *)"";
          if (!v47) {
            uint64_t v48 = buf;
          }
          __int16 v58 = 1024;
          int v59 = 4918;
          __int16 v60 = 2080;
          unsigned int v61 = v48;
          __int16 v62 = 2080;
          uint64_t v63 = a1 + 15208;
          unint64_t v21 = "%s:%d: trying to delete from invalid index %s/%s";
          goto LABEL_70;
        }
LABEL_23:
        *__error() = v16;
      }
LABEL_53:
      uint64_t v39 = *(void *)&threadData[18 * v55 + 2];
      uint64_t v40 = v39 + 320 * v54;
      *(_DWORD *)(v40 + 312) = v14;
      uint64_t v41 = *(void (**)(void))(v40 + 232);
      if (v41) {
        v41(*(void *)(v39 + 320 * v54 + 288));
      }
      dropThreadId(v55, 0, v8);
      return;
    }
    if (*(unsigned char *)(a1 + 15203))
    {
      bzero(buf, 0x400uLL);
      if ((reassignDocument__COUNT__54 & 1) == 0)
      {
        reassignDocument__COUNT__54 = 1;
        int v16 = *__error();
        unsigned int v17 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          int v18 = fcntl(*(_DWORD *)(a1 + 64), 50, buf);
          if (buf[0]) {
            BOOL v19 = v18 < 0;
          }
          else {
            BOOL v19 = 1;
          }
          *(_DWORD *)__int16 v56 = 136315906;
          unint64_t v57 = "reassignDocument";
          uint64_t v20 = (uint8_t *)"";
          if (!v19) {
            uint64_t v20 = buf;
          }
          __int16 v58 = 1024;
          int v59 = 4924;
          __int16 v60 = 2080;
          unsigned int v61 = v20;
          __int16 v62 = 2080;
          uint64_t v63 = a1 + 15208;
          unint64_t v21 = "%s:%d: trying to modify read only index %s/%s";
LABEL_70:
          _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, v21, v56, 0x26u);
          goto LABEL_23;
        }
        goto LABEL_23;
      }
      goto LABEL_53;
    }
    pthread_key_t v22 = __THREAD_SLOT_KEY;
    if (!__THREAD_SLOT_KEY)
    {
      makeThreadId();
      pthread_key_t v22 = __THREAD_SLOT_KEY;
    }
    uint64_t v23 = pthread_getspecific(v22);
    if (!v23 || (unsigned int v24 = v23, (unint64_t)v23 >= 0x801))
    {
      makeThreadId();
      unsigned int v24 = pthread_getspecific(__THREAD_SLOT_KEY);
    }
    uint64_t v25 = (uint64_t)v24 - 1;
    HIDWORD(v27) = qos_class_self() - 9;
    LODWORD(v27) = HIDWORD(v27);
    unsigned int v26 = v27 >> 2;
    if (v26 > 6) {
      signed int v28 = 0;
    }
    else {
      signed int v28 = dword_1BDA87810[v26];
    }
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 14504));
    if (*(void *)(a1 + 14688) || *(_DWORD *)(a1 + 14700) || *(unsigned char *)(a1 + 14716)) {
      goto LABEL_34;
    }
    if (v28 <= 5)
    {
      if (*(void *)(a1 + 16 * v28 + 14568))
      {
LABEL_34:
        db_rwlock_wait(a1 + 14504, v28, 2);
        goto LABEL_35;
      }
      uint64_t v42 = v28 - 1;
      uint64_t v43 = (uint64_t *)(a1 + 16 * v28 + 14584);
      while (v42 != 4)
      {
        uint64_t v44 = *v43;
        v43 += 2;
        uint64_t v45 = ++v42;
        if (v44)
        {
          if (v45 <= 4) {
            goto LABEL_34;
          }
          break;
        }
      }
    }
    *(void *)(a1 + 14688) = pthread_self();
LABEL_35:
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14504));
    uint64_t v29 = v25;
    CIOnThreadCleanUpPush(v25, (uint64_t)si_rwlock_wrunlock_2795, a1 + 14504);
    unint64_t v30 = a2 - *(void *)(a1 + 80);
    unint64_t v31 = v30;
    if (v30 && v30 >= *(unsigned int *)(a1 + 68))
    {
      int v32 = *__error();
      int v33 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        int v49 = *(_DWORD *)(a1 + 68);
        *(_DWORD *)iovec buf = 136315906;
        uint64_t v65 = "reassignDocument";
        __int16 v66 = 1024;
        *(_DWORD *)uint64_t v67 = 4938;
        *(_WORD *)&v67[4] = 2048;
        *(void *)&v67[6] = v31;
        *(_WORD *)&v67[14] = 1024;
        *(_DWORD *)&v67[16] = v49;
        _os_log_error_impl(&dword_1BD672000, v33, OS_LOG_TYPE_ERROR, "%s:%d: reassignDocument error - docId (%lld) >= max (%d) ", buf, 0x22u);
      }
      *__error() = v32;
      uint64_t v29 = v25;
    }
    if (v31 && *(_DWORD *)(a1 + 68) > v31)
    {
      uint64_t v34 = *(const char **)(*(void *)(a1 + 14408) + 8 * v31);
      if (v34 == a3)
      {
        if (indexMarkDirty(a1)) {
          *(void *)(*(void *)(a1 + 14408) + 8 * v31) = a4;
        }
      }
      else if (v34 != a4 && v34 != 0)
      {
        int v36 = *__error();
        uint64_t v37 = _SILogForLogForCategory(0);
        os_log_type_t v38 = gSILogLevels[0] < 3;
        if (os_log_type_enabled(v37, (os_log_type_t)(gSILogLevels[0] < 3)))
        {
          *(_DWORD *)iovec buf = 134218752;
          uint64_t v65 = a3;
          __int16 v66 = 2048;
          *(void *)uint64_t v67 = a4;
          *(_WORD *)&v67[8] = 2048;
          *(void *)&v67[10] = v31;
          *(_WORD *)&v67[18] = 2048;
          uint64_t v68 = v34;
          _os_log_impl(&dword_1BD672000, v37, v38, "*warn* reassignDocument error: oid mismatch oldOid: %ld newOid: %ld docId: %ld idxOid: %ld", buf, 0x2Au);
        }
        *__error() = v36;
        uint64_t v29 = v25;
      }
    }
    CIOnThreadCleanUpPop(v29);
    goto LABEL_53;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_WORD *)iovec buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
  }
}

void _CIRebaseDocId(uint64_t a1, uint64_t a2, int a3)
{
  if (*(unsigned char *)(a1 + 8))
  {
    int v6 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v7 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v6);
    unsigned int v34 = HIDWORD(v7);
    *(_DWORD *)iovec buf = v7;
    unint64_t v33 = __PAIR64__(v8, v9);
    uint64_t v10 = *(void *)&threadData[18 * v7 + 2];
    uint64_t v11 = v10 + 320 * HIDWORD(v7);
    *(unsigned char *)(v11 + 216) = 0;
    int v12 = *(_DWORD *)(v11 + 312);
    uint64_t v13 = *(void (**)(void))(v11 + 224);
    if (v13) {
      v13(*(void *)(v10 + 320 * HIDWORD(v7) + 288));
    }
    unsigned int v32 = *(_DWORD *)buf;
    unsigned int v31 = v34;
    unint64_t v30 = v33;
    if (_setjmp((int *)v11))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v29 = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v29, 2u);
      }
      *(_DWORD *)(v11 + 312) = v12;
      CIOnThreadCleanUpReset(v30);
      dropThreadId(v32, 1, v6);
      CICleanUpReset(v32, HIDWORD(v30));
    }
    else
    {
      if (*(_DWORD *)(a1 + 68) >= 2u)
      {
        uint64_t v20 = __si_assert_copy_extra_329();
        __message_assert_333((uint64_t)v20, v21, v22, v23, v24, v25, v26, v27, (char)"ContentIndex.c");
        free(v20);
        if (__valid_fs(-1)) {
          uint64_t v28 = 2989;
        }
        else {
          uint64_t v28 = 3072;
        }
        *(_DWORD *)uint64_t v28 = -559038737;
        abort();
      }
      *(void *)(a1 + 80) = a2;
      *(_DWORD *)(a1 + 88) = a3;
      uint64_t v14 = *(void *)(a1 + 14392);
      if (v14) {
        *(void *)(v14 + 8) = a2;
      }
      uint64_t v15 = *(void *)(a1 + 14400);
      if (v15) {
        *(void *)(v15 + 8) = a2;
      }
      uint64_t v16 = *(void *)&threadData[18 * v32 + 2];
      unsigned int v17 = v31;
      uint64_t v18 = v16 + 320 * v31;
      *(_DWORD *)(v18 + 312) = v12;
      BOOL v19 = *(void (**)(void))(v18 + 232);
      if (v19) {
        v19(*(void *)(v16 + 320 * v17 + 288));
      }
      dropThreadId(v32, 0, v6);
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_WORD *)iovec buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
  }
}

uint64_t _CIDocIdForOID(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      *(_WORD *)iovec buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
    }
    return 0;
  }
  uint64_t v4 = *(unsigned int *)(a1 + 68);
  int v5 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v6 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v5);
  unsigned int v28 = HIDWORD(v6);
  *(_DWORD *)iovec buf = v6;
  unint64_t v27 = __PAIR64__(v7, v8);
  uint64_t v9 = *(void *)&threadData[18 * v6 + 2];
  uint64_t v10 = v9 + 320 * HIDWORD(v6);
  *(unsigned char *)(v10 + 216) = 0;
  int v11 = *(_DWORD *)(v10 + 312);
  int v12 = *(void (**)(void))(v10 + 224);
  if (v12) {
    v12(*(void *)(v9 + 320 * HIDWORD(v6) + 288));
  }
  unsigned int v26 = *(_DWORD *)buf;
  unsigned int v25 = v28;
  unint64_t v24 = v27;
  if (_setjmp((int *)v10))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v23 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v23, 2u);
    }
    *(_DWORD *)(v10 + 312) = v11;
    CIOnThreadCleanUpReset(v24);
    dropThreadId(v26, 1, v5);
    CICleanUpReset(v26, HIDWORD(v24));
    return 0;
  }
  uint64_t v14 = a1 + 14504;
  db_read_lock(a1 + 14504);
  if ((int)v4 < 1)
  {
LABEL_19:
    uint64_t v18 = 0;
  }
  else
  {
    char v15 = 0;
    uint64_t v16 = 0;
    while (1)
    {
      int v17 = *(unsigned char *)(a1 + 45)
          ? *(unsigned __int8 *)(*(void *)(a1 + 14432) + v16)
          : (*(_DWORD *)(*(void *)(a1 + 14432)
                       + (((3435973837u * (unint64_t)v16) >> 32) & 0xFFFFFFFC)) >> (v15 - 30 * (v16 / 5))) & 0x3F;
      if ((v17 & 0xFFFFFFDF) != 0 && *(void *)(*(void *)(a1 + 14408) + 8 * v16) == a2) {
        break;
      }
      ++v16;
      v15 += 6;
      if (v4 == v16) {
        goto LABEL_19;
      }
    }
    uint64_t v18 = *(void *)(a1 + 80) + v16;
  }
  db_read_unlock(v14);
  uint64_t v19 = *(void *)&threadData[18 * v26 + 2];
  unsigned int v20 = v25;
  uint64_t v21 = v19 + 320 * v25;
  *(_DWORD *)(v21 + 312) = v11;
  uint64_t v22 = *(void (**)(void))(v21 + 232);
  if (v22) {
    v22(*(void *)(v19 + 320 * v20 + 288));
  }
  dropThreadId(v26, 0, v5);
  return v18;
}

uint64_t _CIDeleteDuplicates(uint64_t a1, uint64_t a2)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      *(_WORD *)iovec buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
    }
    return 0;
  }
  int v66 = *(unsigned __int8 *)(a1 + 15203);
  uint64_t v3 = *(unsigned int *)(a1 + 68);
  int v4 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v5 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v4);
  unsigned int v75 = HIDWORD(v5);
  unsigned int v76 = v5;
  unint64_t v74 = __PAIR64__(v6, v7);
  uint64_t v8 = *(void *)&threadData[18 * v5 + 2];
  uint64_t v9 = v8 + 320 * HIDWORD(v5);
  *(unsigned char *)(v9 + 216) = 0;
  int v10 = *(_DWORD *)(v9 + 312);
  int v11 = *(void (**)(void))(v9 + 224);
  if (v11) {
    v11(*(void *)(v8 + 320 * HIDWORD(v5) + 288));
  }
  int v12 = v4;
  unsigned int v73 = v76;
  unsigned int v72 = v75;
  unint64_t v71 = v74;
  if (_setjmp((int *)v9))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)iovec buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v9 + 312) = v10;
    CIOnThreadCleanUpReset(v71);
    dropThreadId(v73, 1, v4);
    CICleanUpReset(v73, HIDWORD(v71));
    return 0;
  }
  unsigned int v70 = 0;
  if (fd_setDir(*(unsigned int *)(a1 + 64), (int *)&v70))
  {
    int v68 = v10;
    int v69 = v4;
    uint64_t v14 = v3;
    if ((int)v3 >= 1)
    {
      char v15 = 0;
      uint64_t v16 = 0;
      int v17 = v14;
      uint64_t v18 = a2;
      uint64_t v19 = v14 + 1;
      char v20 = 6 * v17 - 6;
      unsigned int v21 = v17 - 1;
      while (1)
      {
        uint64_t v22 = v19;
        unint64_t v23 = v21 / 5uLL;
        if (*(unsigned char *)(a1 + 45)) {
          int v24 = *(unsigned __int8 *)(*(void *)(a1 + 14432) + v21);
        }
        else {
          int v24 = (*(_DWORD *)(*(void *)(a1 + 14432) + (((3435973837u * (unint64_t)v21) >> 32) & 0xFFFFFFFC)) >> (v20 - 30 * (v21 / 5))) & 0x3F;
        }
        if ((v24 & 0xFFFFFFDF) != 0)
        {
          char v64 = v20 - 30 * (v21 / 5);
          uint64_t v65 = v22;
          unint64_t v25 = *(void *)(*(void *)(a1 + 14408) + 8 * v21);
          if (SIUINT64SetContainsValue(v18, v25))
          {
            int v26 = *__error();
            unint64_t v27 = _SILogForLogForCategory(10);
            os_log_type_t v28 = 2 * (dword_1E9FC90CC < 4);
            if (os_log_type_enabled(v27, v28))
            {
              *(_DWORD *)iovec buf = 134217984;
              unint64_t v78 = v25;
              _os_log_impl(&dword_1BD672000, v27, v28, "dup oid (%lld)", buf, 0xCu);
            }
            *__error() = v26;
            if (!v66)
            {
              if ((v15 & 1) == 0) {
                indexMarkDirty(a1);
              }
              if (!*(unsigned char *)(a1 + 45))
              {
                uint64_t v31 = *(void *)(a1 + 14432);
                unsigned int v32 = *(_DWORD *)(v31 + 4 * v23) & ~(63 << v64);
                unint64_t v33 = (void *)MEMORY[0x1E4F14B00];
                if (*(void *)(a1 + 14440))
                {
                  unint64_t v34 = v23 / (8 * *MEMORY[0x1E4F14B00]);
                  uint64_t v35 = (v23 / *MEMORY[0x1E4F14B00]) & 7;
                  *(unsigned char *)(*(void *)(a1 + 14440) + v34) |= 1 << v35;
                  if (!*(unsigned char *)(*(void *)(a1 + 14440) + v34)
                    || (uint64_t v36 = v35 | (8 * v34), *v33 * v36 > v23)
                    || *v33 * (unint64_t)(v36 + 1) <= v23)
                  {
                    unsigned int v55 = __si_assert_copy_extra_329();
                    __message_assert_333((uint64_t)v55, v56, v57, v58, v59, v60, v61, v62, (char)"ContentIndex.c");
                    free(v55);
                    if (__valid_fs(-1)) {
                      uint64_t v63 = 2989;
                    }
                    else {
                      uint64_t v63 = 3072;
                    }
                    *(_DWORD *)uint64_t v63 = -559038737;
                    abort();
                  }
                  uint64_t v37 = *(void *)(a1 + 14432);
                  int v38 = *(unsigned __int8 *)(a1 + 45);
                  *(_DWORD *)(v37 + 4 * v23) = v32;
                  if (v38)
                  {
                    int v39 = *(unsigned __int8 *)(v37 + v21);
LABEL_40:
                    uint64_t v22 = v65;
                    if (v39)
                    {
                      int v46 = __si_assert_copy_extra_329();
                      __message_assert_333((uint64_t)v46, v47, v48, v49, v50, v51, v52, v53, (char)"ContentIndex.c");
                      free(v46);
                      if (__valid_fs(-1)) {
                        uint64_t v54 = 2989;
                      }
                      else {
                        uint64_t v54 = 3072;
                      }
                      *(_DWORD *)uint64_t v54 = -559038737;
                      abort();
                    }
                    char v15 = 1;
                    ++v16;
                    uint64_t v18 = a2;
                    goto LABEL_25;
                  }
                }
                else
                {
                  *(_DWORD *)(v31 + 4 * v23) = v32;
                }
                int v39 = (v32 >> v64) & 0x3F;
                goto LABEL_40;
              }
              *(unsigned char *)(*(void *)(a1 + 14432) + v21) = 0;
              uint64_t v30 = *(void *)(a1 + 14440);
              char v15 = 1;
              if (v30) {
                *(unsigned char *)(v30 + v21 / (unint64_t)(32 * *MEMORY[0x1E4F14B00])) |= 1 << ((v21
              }
                                                                                                / (unint64_t)(4 * *MEMORY[0x1E4F14B00])) & 7);
            }
            ++v16;
            uint64_t v18 = a2;
          }
          else
          {
            SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(a2 + 16), v25);
          }
          uint64_t v22 = v65;
        }
LABEL_25:
        uint64_t v29 = v16;
        uint64_t v19 = v22 - 1;
        v20 -= 6;
        --v21;
        if (v22 - 1 <= 1) {
          goto LABEL_44;
        }
      }
    }
    uint64_t v29 = 0;
LABEL_44:
    uint64_t v40 = v29;
    int v41 = v70;
    MEMORY[0x1C1882290](v70);
    int v12 = v69;
    if ((v41 & 0x80000000) == 0) {
      close(v41);
    }
    int v10 = v68;
  }
  else
  {
    uint64_t v40 = 0;
  }
  uint64_t v42 = *(void *)&threadData[18 * v73 + 2];
  unsigned int v43 = v72;
  uint64_t v44 = v42 + 320 * v72;
  *(_DWORD *)(v44 + 312) = v10;
  uint64_t v45 = *(void (**)(void))(v44 + 232);
  if (v45) {
    v45(*(void *)(v42 + 320 * v43 + 288));
  }
  dropThreadId(v73, 0, v12);
  return v40;
}

void _CIFindTokens(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  unsigned int v55 = v2;
  char v4 = v3;
  unsigned int v6 = v5;
  uint64_t v8 = v7;
  int v10 = v9;
  int v12 = v11;
  uint64_t v13 = v1;
  v89[5] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = v1 + 14720;
  db_read_lock(v1 + 14720);
  char v15 = *(atomic_uint **)(v13 + 14392);
  uint64_t v16 = (uint64_t)v15;
  int v17 = *(atomic_uint **)(v13 + 14400);
  if (v15) {
    atomic_fetch_add(v15, 1u);
  }
  if (v17) {
    atomic_fetch_add(v17, 1u);
  }
  db_read_unlock(v14);
  if (v16) {
    _CITermUpdateSetFindTokens(v16);
  }
  if (v17) {
    _CITermUpdateSetFindTokens((uint64_t)v17);
  }
  if (!*(unsigned char *)(v13 + 8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", (uint8_t *)buf, 2u);
    }
    if (v16) {
      goto LABEL_20;
    }
    goto LABEL_21;
  }
  char v53 = v4;
  uint64_t v56 = v6;
  int v18 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v19 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, v13, 0, v18);
  unsigned int v61 = HIDWORD(v19);
  unsigned int v62 = v19;
  unsigned int v59 = v21;
  unsigned int v60 = v20;
  uint64_t v22 = *(void *)&threadData[18 * v19 + 2];
  uint64_t v23 = v22 + 320 * HIDWORD(v19);
  *(unsigned char *)(v23 + 216) = 0;
  int v24 = *(_DWORD *)(v23 + 312);
  unint64_t v25 = *(void (**)(void))(v23 + 224);
  if (v25) {
    v25(*(void *)(v22 + 320 * HIDWORD(v19) + 288));
  }
  if (_setjmp((int *)v23))
  {
    int v26 = (_DWORD *)(v23 + 312);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf[0]) = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)buf, 2u);
    }
    *int v26 = v24;
    CIOnThreadCleanUpReset(v59);
    dropThreadId(v62, 1, v18);
    CICleanUpReset(v62, v60);
    if (!v16) {
      goto LABEL_21;
    }
LABEL_20:
    TermUpdateSetRelease(v16);
    goto LABEL_21;
  }
  unint64_t v27 = TokenDataCreate(*v10, *v8);
  if (v27)
  {
    uint64_t v57 = v16;
    uint64_t v58 = v17;
    unint64_t v77 = &v76;
    uint64_t v78 = 0x2000000000;
    uint64_t v79 = v84;
    unsigned int v73 = &v72;
    uint64_t v74 = 0x2000000000;
    uint64_t v28 = 32;
    uint64_t v75 = 32;
    uint64_t v76 = 0;
    uint64_t v29 = v27;
    uint64_t v68 = 0;
    int v69 = &v68;
    uint64_t v70 = 0x2000000000;
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    bzero(v88, 0x7E8uLL);
    bzero(v84, 0x800uLL);
    unsigned int v30 = v29[4];
    int v31 = v29[5];
    unsigned int v32 = v30 >> 1;
    if (v30) {
      int v33 = 2056;
    }
    else {
      int v33 = 8;
    }
    uint64_t v54 = v29;
    buf[0] = *((void *)v29 + 1);
    buf[1] = buf[0];
    v88[8] = v31;
    unsigned int v86 = v33 & 0xFBFFFFFF | ((v32 & 1) << 26);
    int v87 = v12;
    unint64_t v34 = buf;
    unsigned int v35 = 1;
    do
    {
      if (dword_1E9FC90A8 >= 5)
      {
        int v52 = *__error();
        log = _SILogForLogForCategory(1);
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v89[0]) = 67109120;
          HIDWORD(v89[0]) = v35;
          _os_log_impl(&dword_1BD672000, log, OS_LOG_TYPE_DEFAULT, "### trie processing - %d ###", (uint8_t *)v89, 8u);
        }
        *__error() = v52;
      }
      v67[0] = MEMORY[0x1E4F143A8];
      v67[1] = 0x40000000;
      v67[2] = ___bt_findTokens_block_invoke;
      v67[3] = &unk_1E63435A8;
      v67[4] = &v68;
      v67[5] = &v72;
      v67[6] = &v76;
      v67[7] = v54;
      v89[0] = MEMORY[0x1E4F143A8];
      v89[1] = 0x40000000;
      v89[2] = ___bt_resolveTokens_block_invoke;
      void v89[3] = &unk_1E63435D0;
      v89[4] = v67;
      *(void *)&long long v80 = MEMORY[0x1E4F143A8];
      *((void *)&v80 + 1) = 0x40000000;
      unsigned int v81 = ___bt_resolveTokens_block_invoke_2;
      int v82 = &unk_1E63435F8;
      unsigned __int8 v83 = v67;
      _bt_findBulk(v13, v13 + 96, 0, 0, 0, v35, (uint64_t)v34, 0, 0, v55, (uint64_t)v89, &v80, v53);
      uint64_t v36 = (void *)v77[3];
      v77[3] = (uint64_t)v34;
      uint64_t v37 = v73;
      unint64_t v38 = v73[3];
      v73[3] = v28;
      uint64_t v39 = v69[3];
      v69[3] = 0;
      unint64_t v34 = v36;
      uint64_t v28 = v38;
      unsigned int v35 = v39;
    }
    while (v39);
    if (v38 >= 0x21)
    {
      free(v36);
      uint64_t v37 = v73;
    }
    if ((unint64_t)v37[3] >= 0x21) {
      free((void *)v77[3]);
    }
    _Block_object_dispose(&v68, 8);
    _Block_object_dispose(&v72, 8);
    _Block_object_dispose(&v76, 8);
    if (v54[6])
    {
      uint64_t v40 = *v56;
      if (!*v56)
      {
        *uint64_t v56 = (uint64_t)v54;
        goto LABEL_46;
      }
      v63[0] = MEMORY[0x1E4F143A8];
      v63[1] = 0x40000000;
      char v64 = __bt_findTokens_block_invoke;
      uint64_t v65 = &__block_descriptor_tmp_2131;
      uint64_t v66 = v40;
      uint64_t v42 = (int)v54[10];
      unint64_t v41 = (int)v54[11];
      if ((int)v41 < (int)v42)
      {
        uint64_t v43 = *((void *)v54 + 4);
        unint64_t v44 = v43 + v42;
        uint64_t v45 = (unsigned int *)(v43 + v41);
        do
        {
          int v46 = v45 + 1;
          unint64_t v47 = v41 & 0xFFFFFFFF00000000 | *v45;
          ((void (*)(void *))v64)(v63);
          unint64_t v41 = v47;
          uint64_t v45 = v46;
        }
        while ((unint64_t)v46 < v44);
      }
    }
    free(*((void **)v54 + 1));
    free(*((void **)v54 + 4));
    free(v54);
LABEL_46:
    uint64_t v16 = v57;
    int v17 = v58;
  }
  uint64_t v48 = *(void *)&threadData[18 * v62 + 2];
  uint64_t v49 = v48 + 320 * v61;
  *(_DWORD *)(v49 + 312) = v24;
  uint64_t v50 = *(void (**)(void))(v49 + 232);
  if (v50) {
    v50(*(void *)(v48 + 320 * v61 + 288));
  }
  dropThreadId(v62, 0, v18);
  if (v16) {
    goto LABEL_20;
  }
LABEL_21:
  if (v17) {
    TermUpdateSetRelease((uint64_t)v17);
  }
}

void _CIPreHeatIndex(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
    int v4 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v5 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v4);
    unsigned int v29 = HIDWORD(v5);
    *(_DWORD *)iovec buf = v5;
    unint64_t v28 = __PAIR64__(v6, v7);
    uint64_t v8 = *(void *)&threadData[18 * v5 + 2];
    uint64_t v9 = v8 + 320 * HIDWORD(v5);
    *(unsigned char *)(v9 + 216) = 0;
    int v10 = *(_DWORD *)(v9 + 312);
    int v11 = *(void (**)(void))(v9 + 224);
    if (v11) {
      v11(*(void *)(v8 + 320 * HIDWORD(v5) + 288));
    }
    unsigned int v27 = *(_DWORD *)buf;
    unsigned int v26 = v29;
    unint64_t v25 = v28;
    if (_setjmp((int *)v9))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int v24 = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v24, 2u);
      }
      *(_DWORD *)(v9 + 312) = v10;
      CIOnThreadCleanUpReset(v25);
      dropThreadId(v27, 1, v4);
      CICleanUpReset(v27, HIDWORD(v25));
    }
    else
    {
      if (a2)
      {
        nice_read_advise(*(_DWORD **)(a1 + 4672), 1028 * *(_DWORD *)(a1 + 240));
        nice_read_advise(*(_DWORD **)(a1 + 208), *(int *)(a1 + 128));
        char v12 = atomic_load((unsigned int *)(a1 + 36));
        if ((v12 & 4) != 0)
        {
          uint64_t v13 = *(_DWORD **)(a1 + 472);
          int64_t v14 = *(_DWORD *)(a1 + 488) / 50;
        }
        else
        {
          uint64_t v13 = *(_DWORD **)(a1 + 5200);
          int64_t v14 = 4 * *(unsigned int *)(a1 + 9400);
        }
        nice_read_advise(v13, v14);
      }
      else
      {
        nice_madvise(*(char **)(a1 + 112), *(void *)(a1 + 128));
        nice_madvise(*(char **)(a1 + 104), (1028 * *(_DWORD *)(a1 + 240)));
        char v15 = atomic_load((unsigned int *)(a1 + 36));
        if ((v15 & 4) != 0)
        {
          uint64_t v16 = *(void *)(a1 + 528);
          if (v16)
          {
            int v17 = *(char **)(v16 + 8);
            if (v17) {
              nice_madvise(v17, *(void *)(a1 + 488) / 0x32uLL);
            }
          }
        }
      }
      uint64_t v18 = *(void *)(a1 + 4928);
      if (v18) {
        nice_read_advise(*(_DWORD **)(v18 + 224), *(int *)(v18 + 240));
      }
      char v19 = atomic_load((unsigned int *)(a1 + 36));
      if ((v19 & 4) != 0) {
        nice_read_advise(*(_DWORD **)(a1 + 9432), *(_DWORD *)(a1 + 4968) / 50);
      }
      uint64_t v20 = *(void *)&threadData[18 * v27 + 2];
      unsigned int v21 = v26;
      uint64_t v22 = v20 + 320 * v26;
      *(_DWORD *)(v22 + 312) = v10;
      uint64_t v23 = *(void (**)(void))(v22 + 232);
      if (v23) {
        v23(*(void *)(v20 + 320 * v21 + 288));
      }
      dropThreadId(v27, 0, v4);
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_WORD *)iovec buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
  }
}

uint64_t nice_read_advise(_DWORD *a1, int64_t a2)
{
  kern_return_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  int v10;
  uint64_t v11;
  integer_t v12;
  integer_t v13;
  int v14;
  mach_msg_type_number_t host_info_outCnt[2];
  integer_t host_info_out[4];
  long long v17;
  long long v18;

  int64_t v4 = nice_read_advise_limit;
  if (!nice_read_advise_limit)
  {
    int v17 = 0u;
    uint64_t v18 = 0u;
    *(_OWORD *)host_info_out = 0u;
    host_info_outCnt[0] = 12;
    host_t v5 = MEMORY[0x1C1881C90]();
    unsigned int v6 = host_info(v5, 1, host_info_out, host_info_outCnt);
    unsigned int v7 = *((void *)&v18 + 1);
    if (*((void *)&v18 + 1) >= 0x80000000uLL) {
      unsigned int v7 = 0x80000000;
    }
    int64_t v4 = (unint64_t)(3435973837 * v7) >> 36;
    if (v6) {
      int64_t v4 = 53687091;
    }
    else {
      int64_t v4 = v4;
    }
    nice_read_advise_limit = v4;
  }
  if (v4 >= a2) {
    uint64_t v8 = a2;
  }
  else {
    uint64_t v8 = v4;
  }
  *(void *)host_info_outCnt = 0;
  uint64_t result = _fd_acquire_fd((uint64_t)a1, host_info_outCnt);
  if ((result & 0x80000000) == 0)
  {
    int v10 = result;
    memset(host_info_out, 0, sizeof(host_info_out));
    if (v8 >= 1)
    {
      int v11 = 0x20000;
      char v12 = v8;
      do
      {
        *(void *)host_info_out = v11 - 0x20000;
        if (v11 >= v8) {
          uint64_t v13 = v12;
        }
        else {
          uint64_t v13 = 0x20000;
        }
        host_info_out[2] = v13;
        int64_t v14 = fcntl(v10, 44, host_info_out);
        if (v11 >= v8) {
          break;
        }
        v12 -= 0x20000;
        v11 += 0x20000;
      }
      while (!v14);
    }
    return (uint64_t)_fd_release_fd(a1, v10, 0, *(uint64_t *)host_info_outCnt);
  }
  return result;
}

char *nice_madvise(char *result, unint64_t a2)
{
  char v3 = result;
  unint64_t v4 = nice_madvise_limit;
  if (!nice_madvise_limit)
  {
    long long v11 = 0u;
    long long v12 = 0u;
    *(_OWORD *)host_info_out = 0u;
    mach_msg_type_number_t host_info_outCnt = 12;
    host_t v5 = MEMORY[0x1C1881C90]();
    uint64_t result = (char *)host_info(v5, 1, host_info_out, &host_info_outCnt);
    uint64_t v6 = *((void *)&v12 + 1);
    if (*((void *)&v12 + 1) >= 0x80000000uLL) {
      uint64_t v6 = 0x80000000;
    }
    unint64_t v4 = (unint64_t)(3435973837 * v6) >> 36;
    if (result) {
      unint64_t v4 = 53687091;
    }
    else {
      unint64_t v4 = v4;
    }
    nice_madvise_limit = v4;
  }
  if (v4 >= a2) {
    unint64_t v7 = a2;
  }
  else {
    unint64_t v7 = v4;
  }
  do
  {
    if (!v7) {
      break;
    }
    size_t v8 = v7 >= 0x20000 ? 0x20000 : v7;
    uint64_t result = (char *)madvise(v3, v8, 3);
    v3 += v8;
    v7 -= v8;
  }
  while (!result);
  return result;
}

uint64_t _CIGetDocIDInfo(uint64_t a1, uint64_t a2, unsigned int *a3, _DWORD *a4, unint64_t a5, unint64_t a6, int a7)
{
  unint64_t v7 = a2 - *(void *)(a1 + 80);
  unsigned __int8 v42 = 0;
  if (v7 >= *(unsigned int *)(a1 + 68)) {
    return v42;
  }
  if (*(unsigned char *)(a1 + 8))
  {
    int v13 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v14 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v13);
    unsigned int v40 = HIDWORD(v14);
    *(_DWORD *)iovec buf = v14;
    unsigned int v38 = v16;
    unsigned int v39 = v15;
    uint64_t v17 = *(void *)&threadData[18 * v14 + 2];
    uint64_t v18 = v17 + 320 * HIDWORD(v14);
    *(unsigned char *)(v18 + 216) = 0;
    int v19 = *(_DWORD *)(v18 + 312);
    uint64_t v20 = *(void (**)(void))(v18 + 224);
    if (v20) {
      v20(*(void *)(v17 + 320 * HIDWORD(v14) + 288));
    }
    unsigned int v37 = *(_DWORD *)buf;
    unsigned int v36 = v40;
    unint64_t v35 = __PAIR64__(v39, v38);
    if (_setjmp((int *)v18))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)unint64_t v34 = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v34, 2u);
      }
      *(_DWORD *)(v18 + 312) = v19;
      CIOnThreadCleanUpReset(v35);
      dropThreadId(v37, 1, v13);
      CICleanUpReset(v37, HIDWORD(v35));
      return v42;
    }
    if (a7)
    {
      unsigned int v32 = CICleanUpThreadLoc();
      db_read_lock(a1 + 14504);
      CIOnThreadCleanUpPush((uint64_t)v32, (uint64_t)si_rwlock_rdunlock, a1 + 14504);
      uint64_t v21 = (uint64_t)v32;
    }
    else
    {
      uint64_t v21 = 0;
    }
    if (a3)
    {
      if (*(unsigned char *)(a1 + 45)) {
        int v22 = *(unsigned __int8 *)(*(void *)(a1 + 14432) + v7);
      }
      else {
        int v22 = (*(_DWORD *)(*(void *)(a1 + 14432) + 4 * (v7 / 5uLL)) >> (6 * (v7 % 5))) & 0x3F;
      }
      *a3 = v22 & 0xFFFFFFDF;
    }
    if (a4)
    {
      uint64_t v23 = *(void *)(a1 + 14416);
      if (v23) {
        int v24 = *(_DWORD *)(v23 + 4 * v7);
      }
      else {
        int v24 = 0;
      }
      *a4 = v24;
    }
    if (!(a5 | a6)) {
      goto LABEL_35;
    }
    uint64_t v25 = *(void *)(a1 + 14424);
    if (v25)
    {
      if (a5) {
        *(_DWORD *)a5 = *(_DWORD *)(v25 + 8 * v7);
      }
      if (!a6) {
        goto LABEL_35;
      }
      int v26 = *(_DWORD *)(v25 + 8 * v7 + 4);
    }
    else
    {
      if (a5) {
        *(_DWORD *)a5 = 0;
      }
      if (!a6) {
        goto LABEL_35;
      }
      int v26 = 0;
    }
    *(_DWORD *)a6 = v26;
LABEL_35:
    if (a7) {
      CIOnThreadCleanUpPop(v21);
    }
    unsigned __int8 v42 = 1;
    uint64_t v27 = *(void *)&threadData[18 * v37 + 2];
    unsigned int v28 = v36;
    uint64_t v29 = v27 + 320 * v36;
    *(_DWORD *)(v29 + 312) = v19;
    unsigned int v30 = *(void (**)(void))(v29 + 232);
    if (v30) {
      v30(*(void *)(v27 + 320 * v28 + 288));
    }
    dropThreadId(v37, 0, v13);
    return v42;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_WORD *)iovec buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
  }
  return v42;
}

BOOL _CIGetGroupForDocId(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = a2 - *(void *)(a1 + 80);
  if (v2 >= *(unsigned int *)(a1 + 68)) {
    return 0;
  }
  if (!*(unsigned char *)(a1 + 8))
  {
    BOOL result = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO);
    if (!result) {
      return result;
    }
    *(_WORD *)iovec buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
    return 0;
  }
  int v4 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v5 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v4);
  unsigned int v25 = HIDWORD(v5);
  *(_DWORD *)iovec buf = v5;
  unint64_t v24 = __PAIR64__(v6, v7);
  uint64_t v8 = *(void *)&threadData[18 * v5 + 2];
  uint64_t v9 = v8 + 320 * HIDWORD(v5);
  *(unsigned char *)(v9 + 216) = 0;
  int v10 = *(_DWORD *)(v9 + 312);
  long long v11 = *(void (**)(void))(v9 + 224);
  if (v11) {
    v11(*(void *)(v8 + 320 * HIDWORD(v5) + 288));
  }
  unsigned int v23 = *(_DWORD *)buf;
  unsigned int v22 = v25;
  unint64_t v21 = v24;
  if (_setjmp((int *)v9))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v20 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v20, 2u);
    }
    *(_DWORD *)(v9 + 312) = v10;
    CIOnThreadCleanUpReset(v21);
    dropThreadId(v23, 1, v4);
    CICleanUpReset(v23, HIDWORD(v21));
    return 0;
  }
  int v13 = CICleanUpThreadLoc();
  db_read_lock(a1 + 14504);
  CIOnThreadCleanUpPush((uint64_t)v13, (uint64_t)si_rwlock_rdunlock, a1 + 14504);
  if (*(unsigned char *)(a1 + 45)) {
    int v14 = *(unsigned __int8 *)(*(void *)(a1 + 14432) + v2);
  }
  else {
    int v14 = (*(_DWORD *)(*(void *)(a1 + 14432) + 4 * (v2 / 5uLL)) >> (6 * (v2 % 5))) & 0x3F;
  }
  uint64_t v15 = v14 & 0xFFFFFFDF;
  CIOnThreadCleanUpPop((uint64_t)v13);
  uint64_t v16 = *(void *)&threadData[18 * v23 + 2];
  unsigned int v17 = v22;
  uint64_t v18 = v16 + 320 * v22;
  *(_DWORD *)(v18 + 312) = v10;
  int v19 = *(void (**)(void))(v18 + 232);
  if (v19) {
    v19(*(void *)(v16 + 320 * v17 + 288));
  }
  dropThreadId(v23, 0, v4);
  return v15;
}

BOOL _CIGetRankingSecondsForDocId(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = a2 - *(void *)(a1 + 80);
  if (v2 >= *(unsigned int *)(a1 + 68)) {
    return 0;
  }
  if (!*(unsigned char *)(a1 + 8))
  {
    BOOL result = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO);
    if (!result) {
      return result;
    }
    *(_WORD *)iovec buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
    return 0;
  }
  int v4 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v5 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v4);
  unsigned int v24 = HIDWORD(v5);
  *(_DWORD *)iovec buf = v5;
  unint64_t v23 = __PAIR64__(v6, v7);
  uint64_t v8 = *(void *)&threadData[18 * v5 + 2];
  uint64_t v9 = v8 + 320 * HIDWORD(v5);
  *(unsigned char *)(v9 + 216) = 0;
  int v10 = *(_DWORD *)(v9 + 312);
  long long v11 = *(void (**)(void))(v9 + 224);
  if (v11) {
    v11(*(void *)(v8 + 320 * HIDWORD(v5) + 288));
  }
  unsigned int v22 = *(_DWORD *)buf;
  unsigned int v21 = v24;
  unint64_t v20 = v23;
  if (_setjmp((int *)v9))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v19 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v19, 2u);
    }
    *(_DWORD *)(v9 + 312) = v10;
    CIOnThreadCleanUpReset(v20);
    dropThreadId(v22, 1, v4);
    CICleanUpReset(v22, HIDWORD(v20));
    return 0;
  }
  uint64_t v13 = *(void *)(a1 + 14416);
  if (v13) {
    uint64_t v14 = *(unsigned int *)(v13 + 4 * v2);
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *(void *)&threadData[18 * v22 + 2];
  unsigned int v16 = v21;
  uint64_t v17 = v15 + 320 * v21;
  *(_DWORD *)(v17 + 312) = v10;
  uint64_t v18 = *(void (**)(void))(v17 + 232);
  if (v18) {
    v18(*(void *)(v15 + 320 * v16 + 288));
  }
  dropThreadId(v22, 0, v4);
  return v14;
}

void _CIAddOids(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      *(_WORD *)iovec buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
    }
    goto LABEL_10;
  }
  int v4 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v5 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v4);
  unsigned int v36 = HIDWORD(v5);
  *(_DWORD *)iovec buf = v5;
  unint64_t v35 = __PAIR64__(v6, v7);
  uint64_t v8 = *(void *)&threadData[18 * v5 + 2];
  uint64_t v9 = v8 + 320 * HIDWORD(v5);
  *(unsigned char *)(v9 + 216) = 0;
  int v10 = *(_DWORD *)(v9 + 312);
  long long v11 = *(void (**)(void))(v9 + 224);
  if (v11) {
    v11(*(void *)(v8 + 320 * HIDWORD(v5) + 288));
  }
  unsigned int v34 = *(_DWORD *)buf;
  unsigned int v33 = v36;
  unint64_t v32 = v35;
  if (_setjmp((int *)v9))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v31 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v31, 2u);
    }
    *(_DWORD *)(v9 + 312) = v10;
    CIOnThreadCleanUpReset(v32);
    dropThreadId(v34, 1, v4);
    CICleanUpReset(v34, HIDWORD(v32));
LABEL_10:
    long long v12 = 0;
    goto LABEL_32;
  }
  uint64_t v13 = CICleanUpThreadLoc();
  db_read_lock(a1 + 14504);
  CIOnThreadCleanUpPush((uint64_t)v13, (uint64_t)si_rwlock_rdunlock, a1 + 14504);
  uint64_t v14 = *(int *)(a1 + 68);
  if (v14)
  {
    uint64_t v15 = *(unsigned int *)(a1 + 68);
    int v16 = *(_DWORD *)(a1 + 68);
    uint64_t v17 = malloc_type_malloc(8 * v14, 0x100004000313F17uLL);
    if (v16 >= 2)
    {
      uint64_t v18 = *(void *)(a1 + 14408);
      char v19 = 6;
      uint64_t v20 = 1;
      uint64_t v21 = 0;
      do
      {
        uint64_t v22 = *(void *)(v18 + 8 * v20);
        v17[(int)v21] = v22;
        if (v22)
        {
          if (*(unsigned char *)(a1 + 45)) {
            LOBYTE(v23) = *(unsigned char *)(*(void *)(a1 + 14432) + v20);
          }
          else {
            int v23 = (*(_DWORD *)(*(void *)(a1 + 14432)
          }
                             + (((3435973837u * (unint64_t)v20) >> 32) & 0xFFFFFFFC)) >> (v19 - 30 * (v20 / 5))) & 0x3F;
          if ((v23 & 0xDF) != 0) {
            uint64_t v24 = (v21 + 1);
          }
          else {
            uint64_t v24 = v21;
          }
        }
        else
        {
          uint64_t v24 = v21;
        }
        ++v20;
        v19 += 6;
        uint64_t v21 = v24;
      }
      while (v15 != v20);
      unsigned int v25 = v17;
      int v26 = v24;
      goto LABEL_27;
    }
    unsigned int v25 = v17;
  }
  else
  {
    unsigned int v25 = 0;
  }
  int v26 = 0;
LABEL_27:
  CIOnThreadCleanUpPop((uint64_t)v13);
  uint64_t v27 = *(void *)&threadData[18 * v34 + 2];
  unsigned int v28 = v33;
  uint64_t v29 = v27 + 320 * v33;
  *(_DWORD *)(v29 + 312) = v10;
  unsigned int v30 = *(void (**)(void))(v29 + 232);
  if (v30) {
    v30(*(void *)(v27 + 320 * v28 + 288));
  }
  dropThreadId(v34, 0, v4);
  if (v14)
  {
    qsort_oids((uint64_t)v25, v26);
    RLEOIDArrayAddSortedOids(a2, v25, v26);
  }
  long long v12 = v25;
LABEL_32:
  free(v12);
}

void _CIDeleteByOidsBulk(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
    int v4 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v5 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v4);
    unsigned int v56 = HIDWORD(v5);
    *(_DWORD *)iovec buf = v5;
    unint64_t v55 = __PAIR64__(v6, v7);
    uint64_t v8 = *(void *)&threadData[18 * v5 + 2];
    uint64_t v9 = v8 + 320 * HIDWORD(v5);
    *(unsigned char *)(v9 + 216) = 0;
    int v10 = *(_DWORD *)(v9 + 312);
    long long v11 = *(void (**)(void))(v9 + 224);
    if (v11) {
      v11(*(void *)(v8 + 320 * HIDWORD(v5) + 288));
    }
    unsigned int v54 = *(_DWORD *)buf;
    unsigned int v53 = v56;
    unint64_t v52 = v55;
    if (_setjmp((int *)v9))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v51 = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v51, 2u);
      }
      *(_DWORD *)(v9 + 312) = v10;
      CIOnThreadCleanUpReset(v52);
      dropThreadId(v54, 1, v4);
      CICleanUpReset(v54, HIDWORD(v52));
      return;
    }
    long long v12 = CICleanUpThreadLoc();
    _db_write_lock(a1 + 14504);
    uint64_t v50 = (uint64_t)v12;
    CIOnThreadCleanUpPush((uint64_t)v12, (uint64_t)si_rwlock_wrunlock, a1 + 14504);
    uint64_t v13 = *(unsigned int *)(a1 + 68);
    if ((int)v13 >= 2)
    {
      char v14 = 6;
      unint64_t v15 = 1;
      int v16 = (void *)MEMORY[0x1E4F14B00];
      do
      {
        if (RLEOIDArrayContainsOid_locked(a2, *(void *)(*(void *)(a1 + 14408) + 8 * v15)))
        {
          if (!*(unsigned char *)(a1 + 45))
          {
            unint64_t v18 = v15 / 5uLL;
            uint64_t v19 = *(void *)(a1 + 14432);
            unint64_t v20 = v18;
            unsigned int v21 = *(_DWORD *)(v19 + 4 * v18) & ~(63 << (v14 - 30 * (v15 / 5)));
            if (*(void *)(a1 + 14440))
            {
              unint64_t v22 = v18 / (8 * *v16);
              uint64_t v23 = (v18 / *v16) & 7;
              *(unsigned char *)(*(void *)(a1 + 14440) + v22) |= 1 << v23;
              if (!*(unsigned char *)(*(void *)(a1 + 14440) + v22)
                || (uint64_t v24 = v23 | (8 * v22), *v16 * v24 > v18)
                || *v16 * (unint64_t)(v24 + 1) <= v18)
              {
                unint64_t v41 = __si_assert_copy_extra_329();
                __message_assert_333((uint64_t)v41, v42, v43, v44, v45, v46, v47, v48, (char)"ContentIndex.c");
                free(v41);
                if (__valid_fs(-1)) {
                  uint64_t v49 = 2989;
                }
                else {
                  uint64_t v49 = 3072;
                }
                *(_DWORD *)uint64_t v49 = -559038737;
                abort();
              }
              uint64_t v25 = *(void *)(a1 + 14432);
              int v26 = *(unsigned __int8 *)(a1 + 45);
              *(_DWORD *)(v25 + 4 * v20) = v21;
              if (v26)
              {
                int v27 = *(unsigned __int8 *)(v25 + v15);
                goto LABEL_24;
              }
            }
            else
            {
              *(_DWORD *)(v19 + 4 * v18) = v21;
            }
            int v27 = (v21 >> (v14 - 30 * (v15 / 5))) & 0x3F;
LABEL_24:
            if (v27)
            {
              unint64_t v32 = __si_assert_copy_extra_329();
              __message_assert_333((uint64_t)v32, v33, v34, v35, v36, v37, v38, v39, (char)"ContentIndex.c");
              free(v32);
              if (__valid_fs(-1)) {
                uint64_t v40 = 2989;
              }
              else {
                uint64_t v40 = 3072;
              }
              *(_DWORD *)uint64_t v40 = -559038737;
              abort();
            }
            goto LABEL_25;
          }
          *(unsigned char *)(*(void *)(a1 + 14432) + v15) = 0;
          uint64_t v17 = *(void *)(a1 + 14440);
          if (v17) {
            *(unsigned char *)(v17 + v15 / (32 * *v16)) |= 1 << ((v15 / (4 * *v16)) & 7);
          }
        }
LABEL_25:
        ++v15;
        v14 += 6;
      }
      while (v13 != v15);
    }
    CIOnThreadCleanUpPop(v50);
    uint64_t v28 = *(void *)&threadData[18 * v54 + 2];
    unsigned int v29 = v53;
    uint64_t v30 = v28 + 320 * v53;
    *(_DWORD *)(v30 + 312) = v10;
    int v31 = *(void (**)(void))(v30 + 232);
    if (v31) {
      v31(*(void *)(v28 + 320 * v29 + 288));
    }
    dropThreadId(v54, 0, v4);
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_WORD *)iovec buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
  }
}

uint64_t _CIMoveDirectory(uint64_t a1, int a2, uint64_t *a3, int a4, uint64_t a5)
{
  int v10 = *(unsigned __int8 *)(a1 + 15203);
  indexMarkDirty(a1);
  uint64_t v11 = a1 + 4696;
  _db_write_lock(a1 + 4696);
  if (!v10)
  {
    _db_write_lock(a1 + 14720);
    uint64_t v12 = *(void *)(a1 + 14392);
    if (v12) {
      _TermUpdateSetLock(v12, 1);
    }
    uint64_t v13 = *(void *)(a1 + 14400);
    if (v13) {
      _TermUpdateSetLock(v13, 1);
    }
  }
  if (*(unsigned char *)(a1 + 8))
  {
    int v14 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v15 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v14);
    unsigned int v36 = HIDWORD(v15);
    *(_DWORD *)iovec buf = v15;
    unint64_t v35 = __PAIR64__(v16, v17);
    uint64_t v18 = *(void *)&threadData[18 * v15 + 2];
    uint64_t v19 = v18 + 320 * HIDWORD(v15);
    *(unsigned char *)(v19 + 216) = 0;
    int v20 = *(_DWORD *)(v19 + 312);
    unsigned int v21 = *(void (**)(void))(v19 + 224);
    if (v21) {
      v21(*(void *)(v18 + 320 * HIDWORD(v15) + 288));
    }
    unsigned int v34 = *(_DWORD *)buf;
    unsigned int v33 = v36;
    unint64_t v32 = v35;
    if (_setjmp((int *)v19))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int v31 = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v31, 2u);
      }
      *(_DWORD *)(v19 + 312) = v20;
      CIOnThreadCleanUpReset(v32);
      dropThreadId(v34, 1, v14);
      CICleanUpReset(v34, HIDWORD(v32));
      uint64_t v11 = a1 + 4696;
    }
    else
    {
      uint64_t v11 = a1 + 4696;
      if (!v10)
      {
        uint64_t v22 = *(void *)(a1 + 14392);
        if (v22) {
          moveDirectory((uint64_t *)(v22 + 48), a2, a3, a4, a5);
        }
        uint64_t v23 = *(void *)(a1 + 14400);
        if (v23) {
          moveDirectory((uint64_t *)(v23 + 48), a2, a3, a4, a5);
        }
      }
      directoryStoreMoveDirectory(*(void *)(a1 + 4928), a2, (unint64_t *)a3, a4, a5);
      uint64_t v24 = *(void *)&threadData[18 * v34 + 2];
      unsigned int v25 = v33;
      uint64_t v26 = v24 + 320 * v33;
      *(_DWORD *)(v26 + 312) = v20;
      int v27 = *(void (**)(void))(v26 + 232);
      if (v27) {
        v27(*(void *)(v24 + 320 * v25 + 288));
      }
      dropThreadId(v34, 0, v14);
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_WORD *)iovec buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
  }
  uint64_t result = db_write_unlock(v11);
  if (!v10)
  {
    uint64_t v29 = *(void *)(a1 + 14392);
    if (v29) {
      _TermUpdateSetUnlock(v29);
    }
    uint64_t v30 = *(void *)(a1 + 14400);
    if (v30) {
      _TermUpdateSetUnlock(v30);
    }
    return db_write_unlock(a1 + 14720);
  }
  return result;
}

BOOL _CICreateFdAndHoldAssertion(uint64_t a1, uint64_t a2, const char *a3, double a4)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  uint64_t v8 = a1 + 15208;
  snprintf(__str, 0x400uLL, "%s%s", (const char *)(a1 + 15208), a3);
  uint64_t v9 = (atomic_uint *)fd_create_protected(*(_DWORD *)(a1 + 64), __str, 514, 0);
  if (v9)
  {
    int v10 = v9;
    uint64_t v24 = 0;
    int v11 = _fd_acquire_fd((uint64_t)v9, &v24);
    if (v11 < 0)
    {
      int v15 = *__error();
      unsigned int v16 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        int v21 = *__error();
        uint64_t v22 = __error();
        uint64_t v23 = strerror(*v22);
        *(_DWORD *)iovec buf = 136316674;
        uint64_t v26 = "_CICreateFdAndHoldAssertion";
        __int16 v27 = 1024;
        int v28 = 3382;
        __int16 v29 = 1024;
        *(_DWORD *)uint64_t v30 = v11;
        *(_WORD *)&uint8_t v30[4] = 2080;
        *(void *)&v30[6] = v8;
        *(_WORD *)&v30[14] = 2080;
        *(void *)&v30[16] = a3;
        __int16 v31 = 1024;
        LODWORD(v32[0]) = v21;
        WORD2(v32[0]) = 2080;
        *(void *)((char *)v32 + 6) = v23;
        _os_log_error_impl(&dword_1BD672000, v16, OS_LOG_TYPE_ERROR, "%s:%d: fd = %d for %s%s file: %d(%s)", buf, 0x3Cu);
      }
      BOOL v12 = 0;
      *__error() = v15;
    }
    else
    {
      BOOL v12 = (int)fd_hold_assertion((uint64_t)v10, a2, a4) >= 0;
      _fd_release_fd(v10, v11, 0, v24);
    }
    fd_release(v10);
  }
  else
  {
    int v13 = *__error();
    int v14 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      int v18 = *__error();
      uint64_t v19 = __error();
      int v20 = strerror(*v19);
      *(_DWORD *)iovec buf = 136316418;
      uint64_t v26 = "_CICreateFdAndHoldAssertion";
      __int16 v27 = 1024;
      int v28 = 3369;
      __int16 v29 = 2080;
      *(void *)uint64_t v30 = v8;
      *(_WORD *)&v30[8] = 2080;
      *(void *)&v30[10] = a3;
      *(_WORD *)&v30[18] = 1024;
      *(_DWORD *)&v30[20] = v18;
      __int16 v31 = 2080;
      v32[0] = v20;
      _os_log_error_impl(&dword_1BD672000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Unable to get fdptr for %s%s file: %d(%s)", buf, 0x36u);
    }
    BOOL v12 = 0;
    *__error() = v13;
  }
  return v12;
}

BOOL _CICreateFdAndDropAssertion(uint64_t a1, const char *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  uint64_t v4 = a1 + 15208;
  snprintf(__str, 0x400uLL, "%s%s", (const char *)(a1 + 15208), a2);
  unint64_t v5 = (atomic_uint *)fd_create_protected(*(_DWORD *)(a1 + 64), __str, 2, 0);
  if (v5)
  {
    unsigned int v6 = v5;
    uint64_t v20 = 0;
    int v7 = _fd_acquire_fd((uint64_t)v5, &v20);
    if (v7 < 0)
    {
      int v11 = *__error();
      BOOL v12 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        int v17 = *__error();
        int v18 = __error();
        uint64_t v19 = strerror(*v18);
        *(_DWORD *)iovec buf = 136316674;
        uint64_t v22 = "_CICreateFdAndDropAssertion";
        __int16 v23 = 1024;
        int v24 = 3410;
        __int16 v25 = 1024;
        *(_DWORD *)uint64_t v26 = v7;
        *(_WORD *)&v26[4] = 2080;
        *(void *)&v26[6] = v4;
        *(_WORD *)&v26[14] = 2080;
        *(void *)&v26[16] = a2;
        __int16 v27 = 1024;
        LODWORD(v28[0]) = v17;
        WORD2(v28[0]) = 2080;
        *(void *)((char *)v28 + 6) = v19;
        _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: fd = %d for %s%s file: %d(%s)", buf, 0x3Cu);
      }
      BOOL v8 = 0;
      *__error() = v11;
    }
    else
    {
      BOOL v8 = (int)fd_drop_assertion((uint64_t)v6) >= 0;
      _fd_release_fd(v6, v7, 0, v20);
    }
    fd_release(v6);
  }
  else
  {
    int v9 = *__error();
    int v10 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v14 = *__error();
      int v15 = __error();
      unsigned int v16 = strerror(*v15);
      *(_DWORD *)iovec buf = 136316418;
      uint64_t v22 = "_CICreateFdAndDropAssertion";
      __int16 v23 = 1024;
      int v24 = 3397;
      __int16 v25 = 2080;
      *(void *)uint64_t v26 = v4;
      *(_WORD *)&v26[8] = 2080;
      *(void *)&v26[10] = a2;
      *(_WORD *)&v26[18] = 1024;
      *(_DWORD *)&v26[20] = v14;
      __int16 v27 = 2080;
      v28[0] = v16;
      _os_log_error_impl(&dword_1BD672000, v10, OS_LOG_TYPE_ERROR, "%s:%d: Unable to get fdptr for %s%s file: %d(%s)", buf, 0x36u);
    }
    BOOL v8 = 0;
    *__error() = v9;
  }
  return v8;
}

uint64_t expandMap(uint64_t a1, size_t a2, void **a3, uint64_t (*a4)(uint64_t), uint64_t a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = fd_mmap(a1);
  *a3 = (void *)v10;
  if (v10 == -1)
  {
    int v14 = *__error();
    int v15 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      int v17 = *__error();
      int v18 = 136315650;
      uint64_t v19 = "expandMap";
      __int16 v20 = 1024;
      int v21 = 29;
      __int16 v22 = 1024;
      int v23 = v17;
      _os_log_error_impl(&dword_1BD672000, v15, OS_LOG_TYPE_ERROR, "%s:%d: mmap err: %d", (uint8_t *)&v18, 0x18u);
    }
    *__error() = v14;
  }
  else
  {
    while (1)
    {
      if (fd_truncate(a1, a2) != -1) {
        return 0;
      }
      int v11 = *__error();
      if (!a4 || v11 != 28) {
        break;
      }
      if ((a4(a5) & 1) == 0)
      {
        int v11 = 28;
        break;
      }
    }
    int v12 = *__error();
    int v13 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      int v18 = 136315650;
      uint64_t v19 = "expandMap";
      __int16 v20 = 1024;
      int v21 = 38;
      __int16 v22 = 1024;
      int v23 = v11;
      _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate err: %d", (uint8_t *)&v18, 0x18u);
    }
    *__error() = v12;
    munmap(*a3, a2);
    *a3 = (void *)-1;
  }
  return 0xFFFFFFFFLL;
}

uint64_t expandUnsafeMapNew(void **a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t *a5, uint64_t (*a6)(uint64_t), uint64_t a7)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (a3 <= 8) {
    unint64_t v14 = 8;
  }
  else {
    unint64_t v14 = a3;
  }
  int v15 = *a1;
  size_t v16 = a4 * a3;
  fd_system_status_stall_if_busy();
  msync(v15, v16, 16);
  munmap(*a1, v16);
  *a1 = 0;
  *a5 = 0;
  if ((a3 & (a3 - 1)) == 0) {
    goto LABEL_8;
  }
  unsigned int v17 = 2;
  do
  {
    unint64_t v18 = v17;
    v17 *= 2;
  }
  while (v18 < a3);
  uint64_t result = expandMap(a2, v18 * a4, a1, a6, a7);
  if (!result)
  {
    *a5 = v18;
  }
  else
  {
LABEL_8:
    unint64_t v20 = v14 + a3;
    while (1)
    {
      if (v20 > 0xFFFFFFFF / a4)
      {
        *__error() = 7;
        return 0xFFFFFFFFLL;
      }
      unint64_t v21 = v20 * a4;
      uint64_t result = expandMap(a2, v20 * a4, a1, a6, a7);
      if (!result)
      {
        *a5 = v21 / a4;
        return result;
      }
      if (v14 <= 8) {
        break;
      }
      unint64_t v20 = a3 + (v14 >> 1);
      v14 >>= 1;
    }
    int v22 = *__error();
    int v23 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      int v24 = *__error();
      int v25 = 136315906;
      uint64_t v26 = "expandUnsafeMapNew";
      __int16 v27 = 1024;
      int v28 = 82;
      __int16 v29 = 1024;
      int v30 = v24;
      __int16 v31 = 1024;
      int v32 = -1;
      _os_log_error_impl(&dword_1BD672000, v23, OS_LOG_TYPE_ERROR, "%s:%d: expandUnsafeMap errno: %d err: %d", (uint8_t *)&v25, 0x1Eu);
    }
    *__error() = v22;
    return 0xFFFFFFFFLL;
  }
  return result;
}

unint64_t flatStoreNewBlockForCompact(uint64_t a1, unint64_t a2, uint64_t a3, int *a4)
{
  if (a2)
  {
    unint64_t v7 = HIDWORD(a2) ? 0 : (unint64_t)a2 << 6;
    if (v7 < *(void *)(a1 + 232))
    {
      uint64_t v8 = storageResolvePtr(a1, v7, 8, 1);
      *(void *)(a1 + 232) = v7
                            + ((*(unsigned __int16 *)storageResolvePtr(a1, v7, 64 << *(unsigned char *)(v8 + 2), 1) + 71) & 0x1FFC0);
    }
  }
  unint64_t result = storageAllocOffset(a1, 0x10000u, a3, a4);
  if (result)
  {
    unint64_t v10 = result;
    uint64_t v11 = storageResolvePtr(a1, result, 0x10000, 1);
    *(_WORD *)uint64_t v11 = 0;
    *(unsigned char *)(v11 + 2) = 10;
    return (v10 >> 6);
  }
  return result;
}

uint64_t mergeEntryFlat(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  double v232 = v3;
  unsigned int v5 = v4;
  unint64_t v7 = v6;
  unsigned int v9 = v8;
  float v244 = v10;
  uint64_t v12 = v11;
  uint64_t v13 = v1;
  uint64_t v255 = *MEMORY[0x1E4F143B8];
  unint64_t v14 = HIDWORD(v2);
  uint64_t v15 = v1 + 160;
  unsigned int v238 = v2;
  unint64_t v226 = (unint64_t)v2 << 6;
  if (HIDWORD(v2)) {
    unint64_t v16 = 0;
  }
  else {
    unint64_t v16 = (unint64_t)v2 << 6;
  }
  uint64_t v17 = storageResolvePtr(v1 + 160, v16, 8, 1);
  uint64_t v228 = v15;
  unint64_t v18 = (unsigned __int16 *)storageResolvePtr(v15, v16, 64 << *(unsigned char *)(v17 + 2), 1);
  uint64_t v20 = *v18;
  unsigned int v21 = (64 << *((unsigned char *)v18 + 2)) - 8;
  uint64_t v252 = 0;
  long long v253 = 0uLL;
  unsigned int v243 = v9;
  unsigned int v250 = v9;
  int v251 = 0;
  if (v21 < v20)
  {
    unint64_t v22 = (v20 + 7) | ((unint64_t)(v20 + 7) >> 1) | (((v20 + 7) | ((unint64_t)(v20 + 7) >> 1)) >> 2);
    unint64_t v23 = v22 | (v22 >> 4) | ((v22 | (v22 >> 4)) >> 8);
    uint64_t v24 = (v23 | (v23 >> 16)) + 1;
    bzero(__s1, 0x4148uLL);
    scanTrieFatData(v13, 0, v16, v24 + v16, __s1);
    unint64_t v25 = *(void *)(v13 + 392);
    if (v25 < v20 + 8) {
      uint64_t v26 = 0;
    }
    else {
      uint64_t v26 = -1;
    }
    if (v16 == v26)
    {
      uint64_t v183 = __si_assert_copy_extra_1921(*(_DWORD **)(v13 + 376));
      uint64_t v184 = v183;
      uint64_t v185 = "";
      if (v183) {
        uint64_t v185 = v183;
      }
      __message_assert("%s:%u: failed assertion '%s' %s offset: %lld, freeRegion: %lld, kind:%d", "FlatStore.c", 175, "flatStoreGetOffset(ptr)+roundup2(pageEnd+int_sizeof(*page) <= freeRegion)", v185, 0, v25, v14);
      unint64_t v174 = v184;
      goto LABEL_427;
    }
    char v27 = __clz(__rbit32((v24 + 8) >> 6));
    if (v24 < 0x38) {
      char v27 = -1;
    }
    *((unsigned char *)v18 + 2) = v27;
    unsigned int v21 = (64 << v27) - 8;
  }
  if (v21 < v20)
  {
    if (!isExFat(*(_DWORD *)(v13 + 152)))
    {
LABEL_408:
      unsigned int v171 = __si_assert_copy_extra_1921(*(_DWORD **)(v13 + 376));
      unsigned int v172 = v171;
      uint64_t v173 = "";
      if (v171) {
        uint64_t v173 = v171;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ps:%d, pe:%d, pk:%d, po:%llx, ss:%llx se:%llx", "FlatStore.c", 190, "pageSize >= pageEnd && pageSize && (__builtin_popcount(pageSize+int_sizeof(*page)) == 1)", v173, v21, v20, v14, v16, *(void *)(v13 + 384), *(void *)(v13 + 392));
      unint64_t v174 = v172;
      goto LABEL_427;
    }
LABEL_403:
    unint64_t v168 = __si_assert_copy_extra_1921(*(_DWORD **)(v13 + 376));
    double v169 = v168;
    unsigned int v170 = "";
    if (v168) {
      unsigned int v170 = v168;
    }
    si_analytics_log_2351("%s:%u: failure log '%s' %s ps:%d, pe:%d, pk:%d, po:%llx, ss:%llx se:%llx", "FlatStore.c", 184, "pageSize >= pageEnd && pageSize && (__builtin_popcount(pageSize+int_sizeof(*page)) == 1)", v170, v21, v20, v14, v16, *(void *)(v13 + 384), *(void *)(v13 + 392));
    uint64_t v167 = v169;
    goto LABEL_406;
  }
  v19.i32[0] = v21 + 8;
  uint8x8_t v28 = (uint8x8_t)vcnt_s8(v19);
  v28.i16[0] = vaddlv_u8(v28);
  if (v28.i32[0] != 1)
  {
    if (!isExFat(*(_DWORD *)(v13 + 152))) {
      goto LABEL_408;
    }
    goto LABEL_403;
  }
  uint64_t v234 = v7;
  unsigned int v236 = v21;
  uint64_t v240 = v13;
  unsigned int v29 = *(_DWORD *)(v12 + 1100);
  if (v29 > 0x1000)
  {
    unint64_t v175 = __si_assert_copy_extra_1921(*(_DWORD **)(v13 + 376));
    uint64_t v176 = v175;
    uint64_t v177 = "";
    if (v175) {
      uint64_t v177 = v175;
    }
    __message_assert("%s:%u: failed assertion '%s' %s %ld, ps:%d, pe:%d, pk:%d, po:%llx, ss:%llx se:%llx", "FlatStore.c", 194, "ms->currentStringLen <= CMPBUFFER_SIZE", v177, *(unsigned int *)(v12 + 1100), v21, v20, v14, v16, *(void *)(v13 + 384), *(void *)(v13 + 392));
    free(v176);
    unint64_t v178 = *(_DWORD **)(v13 + 376);
    goto LABEL_416;
  }
  bzero(__s1, 0x1000uLL);
  if (!v5)
  {
    *(_DWORD *)(v12 + 28) = v238;
    *(_DWORD *)(v12 + 32) = v14;
    if (!v14) {
      goto LABEL_18;
    }
LABEL_50:
    uint64_t v45 = v13;
    uint64_t v46 = __si_assert_copy_extra_1921(*(_DWORD **)(v13 + 376));
LABEL_51:
    __message_assert("%s:%u: failed assertion '%s' %s flat store");
LABEL_415:
    free(v46);
    unint64_t v178 = *(_DWORD **)(v45 + 376);
    goto LABEL_416;
  }
  __memcpy_chk();
  if (*(_DWORD *)(v12 + 28) != v238)
  {
    uint64_t v179 = v13;
    unsigned int v180 = __si_assert_copy_extra_1921(*(_DWORD **)(v13 + 376));
    unsigned int v181 = v180;
    unsigned int v182 = "";
    if (v180) {
      unsigned int v182 = v180;
    }
    __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 201, "ms->pageOffset.next==_ptr.next", v182);
    goto LABEL_422;
  }
  if (v14) {
    goto LABEL_50;
  }
LABEL_18:
  if (v16 >= *(void *)(v13 + 392))
  {
    uint64_t v45 = v13;
    uint64_t v46 = __si_assert_copy_extra_1921(*(_DWORD **)(v13 + 376));
    __message_assert("%s:%u: failed assertion '%s' %s offset: %lld, freeRegion: %lld, kind:%d");
    goto LABEL_415;
  }
  long long v30 = 0uLL;
  *(_OWORD *)__uint64_t n = 0u;
  long long v249 = 0u;
  if (*(_DWORD *)v12)
  {
    if (v20 && v5 == 0)
    {
      int v32 = (_OWORD *)(v12 + 1084);
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0;
      *(unsigned char *)(v12 + 40) = 0;
      goto LABEL_26;
    }
  }
  unsigned int v34 = v5;
  unsigned int v230 = v5;
  uint64_t v242 = v12;
  if (v20 <= v5)
  {
LABEL_40:
    if (v34)
    {
      if (v29 >= v243) {
        uint64_t v43 = v243;
      }
      else {
        uint64_t v43 = v29;
      }
      if (v43)
      {
        uint64_t v44 = 0;
        while (*(unsigned __int8 *)(v12 + 1104 + v44) == v244[v44])
        {
          if (v43 == ++v44) {
            goto LABEL_70;
          }
        }
        LODWORD(v43) = v44;
      }
LABEL_70:
      unsigned int v47 = v243 - v43;
      int v251 = v43;
      unsigned int v250 = v243 - v43;
      if (v243 == v43)
      {
LABEL_428:
        uint64_t v45 = v240;
        uint64_t v46 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
        goto LABEL_51;
      }
    }
    else
    {
      LODWORD(v43) = 0;
      unsigned int v47 = v243;
    }
    uint64_t v252 = &v244[v43];
    long long v253 = *(_OWORD *)(v12 + 8);
    if (*(_DWORD *)v12)
    {
      if (v47 >= 0x80)
      {
        if (v47 >= 0x4000)
        {
          if (v47 >= 0x200000)
          {
            if (v47 >> 28) {
              int v52 = 5;
            }
            else {
              int v52 = 4;
            }
          }
          else
          {
            int v52 = 3;
          }
        }
        else
        {
          int v52 = 2;
        }
      }
      else
      {
        int v52 = 1;
      }
      if (v43 >= 0x80)
      {
        if (v43 >= 0x4000)
        {
          if (v43 >= 0x200000)
          {
            if (v43 >> 28) {
              int v55 = 5;
            }
            else {
              int v55 = 4;
            }
          }
          else
          {
            int v55 = 3;
          }
        }
        else
        {
          int v55 = 2;
        }
      }
      else
      {
        int v55 = 1;
      }
      int v56 = v253;
      unint64_t v57 = v253 - *(void *)(v12 + 1084);
      if (v57 >= 0x80)
      {
        if (v57 >= 0x4000)
        {
          if (v57 >= 0x200000)
          {
            if (v57 >> 28)
            {
              if (v57 >> 35)
              {
                if (v57 >> 42)
                {
                  if (v57 >> 49)
                  {
                    if (HIBYTE(v57)) {
                      int v58 = 9;
                    }
                    else {
                      int v58 = 8;
                    }
                  }
                  else
                  {
                    int v58 = 7;
                  }
                }
                else
                {
                  int v58 = 6;
                }
              }
              else
              {
                int v58 = 5;
              }
            }
            else
            {
              int v58 = 4;
            }
          }
          else
          {
            int v58 = 3;
          }
        }
        else
        {
          int v58 = 2;
        }
      }
      else
      {
        int v58 = 1;
      }
      uint64_t v132 = *(void *)(v12 + 1092);
      if (v132) {
        BOOL v133 = *((void *)&v253 + 1) == 0;
      }
      else {
        BOOL v133 = 1;
      }
      if (v133) {
        uint64_t v132 = 0;
      }
      unint64_t v134 = *((void *)&v253 + 1) - v132;
      if (v134 >= 0x80)
      {
        if (v134 >= 0x4000)
        {
          if (v134 >= 0x200000)
          {
            if (v134 >> 28)
            {
              if (v134 >> 35)
              {
                if (v134 >> 42)
                {
                  if (v134 >> 49)
                  {
                    if (HIBYTE(v134)) {
                      int v135 = 9;
                    }
                    else {
                      int v135 = 8;
                    }
                  }
                  else
                  {
                    int v135 = 7;
                  }
                }
                else
                {
                  int v135 = 6;
                }
              }
              else
              {
                int v135 = 5;
              }
            }
            else
            {
              int v135 = 4;
            }
          }
          else
          {
            int v135 = 3;
          }
        }
        else
        {
          int v135 = 2;
        }
      }
      else
      {
        int v135 = 1;
      }
      int v62 = v52 + v47 + v55 + v58 + v135;
    }
    else
    {
      if (v47 >= 0x80)
      {
        if (v47 >= 0x4000)
        {
          if (v47 >= 0x200000)
          {
            if (v47 >> 28) {
              int v53 = 5;
            }
            else {
              int v53 = 4;
            }
          }
          else
          {
            int v53 = 3;
          }
        }
        else
        {
          int v53 = 2;
        }
      }
      else
      {
        int v53 = 1;
      }
      if (v43 >= 0x80)
      {
        if (v43 >= 0x4000)
        {
          if (v43 >= 0x200000)
          {
            if (v43 >> 28) {
              int v60 = 5;
            }
            else {
              int v60 = 4;
            }
          }
          else
          {
            int v60 = 3;
          }
        }
        else
        {
          int v60 = 2;
        }
      }
      else
      {
        int v60 = 1;
      }
      int v56 = v253;
      if (v253 >= 0x80)
      {
        if (v253 >= 0x4000)
        {
          if (v253 >= 0x200000)
          {
            if (v253 >> 28) {
              int v61 = 5;
            }
            else {
              int v61 = 4;
            }
          }
          else
          {
            int v61 = 3;
          }
        }
        else
        {
          int v61 = 2;
        }
      }
      else
      {
        int v61 = 1;
      }
      int v62 = v53 + v47 + v60 + v61;
    }
    unsigned int v136 = v62 + v20;
    unsigned int v137 = v236;
    if (v62 + (int)v20 <= v236)
    {
LABEL_362:
      uint64_t v142 = v242;
      if (v136 > v137)
      {
        int v156 = __si_assert_copy_extra_1921(0);
        int v157 = v156;
        double v158 = "";
        if (v156) {
          double v158 = v156;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.c", 481, "pageEnd + newEntrySize <= pageSize", v158);
        goto LABEL_396;
      }
      goto LABEL_363;
    }
    if (v232 && v236 <= 0xFFF7)
    {
      unint64_t v138 = reallocBlock(v240, v238, v62 + (int)v20, v232);
      if (!v138) {
        goto LABEL_392;
      }
      if (*(_DWORD *)(v242 + 28)) {
        *(void *)(v242 + 28) = v138;
      }
      if (HIDWORD(v138)) {
        unint64_t v139 = 0;
      }
      else {
        unint64_t v139 = (unint64_t)v138 << 6;
      }
      uint64_t v140 = storageResolvePtr(v228, v139, 8, 1);
      __int16 v141 = (unsigned __int16 *)storageResolvePtr(v228, v139, 64 << *(unsigned char *)(v140 + 2), 1);
      LODWORD(v20) = *v141;
      unsigned int v137 = (64 << *((unsigned char *)v141 + 2)) - 8;
      unsigned int v136 = v62 + v20;
      if (v62 + (int)v20 > v137)
      {
        uint64_t v179 = v240;
        uint64_t v207 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
        unsigned int v181 = v207;
        int v208 = "";
        if (v207) {
          int v208 = v207;
        }
        __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 462, "pageEnd + newEntrySize <= pageSize", v208);
        goto LABEL_422;
      }
      unint64_t v18 = v141;
      goto LABEL_362;
    }
    if (v236 <= 0xFFF7 && extendBlock(v240, v238, v62 + (int)v20))
    {
      unint64_t v153 = (unint64_t)v238 << 6;
      uint64_t v154 = storageResolvePtr(v228, v153, 8, 1);
      uint64_t v155 = storageResolvePtr(v228, v153, 64 << *(unsigned char *)(v154 + 2), 1);
      uint64_t v142 = v242;
      if (v136 <= (64 << *(unsigned char *)(v155 + 2)) - 8)
      {
        unint64_t v18 = (unsigned __int16 *)v155;
LABEL_363:
        if (*(_DWORD *)v142)
        {
          _OWORD *v234 = v253;
          int v143 = FlatStorePageEntryWrite2_2375((uint64_t)v18, &v250, (uint64_t *)(v142 + 1084), v20);
        }
        else
        {
          int v144 = *(_DWORD *)(v142 + 8);
          *(_DWORD *)(v142 + 8) = v144 + 1;
          _OWORD *v234 = v253;
          if (v144 != v56)
          {
            uint64_t v186 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
            uint64_t v187 = v186;
            uint64_t v188 = "";
            if (v186) {
              uint64_t v188 = v186;
            }
            __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 504, "termID == getNum(newEntry.termInfo.termInfo.termId.ptr)", v188);
            free(v187);
            unint64_t v178 = *(_DWORD **)(v240 + 376);
            goto LABEL_416;
          }
          int v143 = FlatStorePageEntryWrite((uint64_t)v18, &v250, v20);
        }
        int v145 = v143;
        *unint64_t v18 = v143;
        uint64_t v146 = 64 << *((unsigned char *)v18 + 2);
        unint64_t v147 = *(unsigned int *)(v240 + 408);
        if ((int)v147 < 1)
        {
          unint64_t v151 = -1;
        }
        else
        {
          uint64_t v148 = 54;
          do
          {
            os_log_type_t v149 = *(void **)(v240 + 8 * v148);
            if (v149
              && (unint64_t v150 = v149[1], v150 + 1 >= 2)
              && v150 <= (unint64_t)v18
              && (uint64_t v152 = v149[2], v150 - v152 + v149[3] > (unint64_t)v18))
            {
              unint64_t v151 = (unint64_t)v18 + v152 - v150;
            }
            else
            {
              unint64_t v151 = -1;
            }
            if (v148 - 53 >= v147) {
              break;
            }
            ++v148;
          }
          while (v151 == -1);
        }
        bit_vector_set_3386((void *)(v240 + 4536), (v151 >> 17));
        if ((v151 >> 17) != (v151 + v146) >> 17) {
          bit_vector_set_3386((void *)(v240 + 4536), (v151 >> 17) + 1);
        }
        *(_DWORD *)(v142 + 24) = v145;
        if (!v230) {
          *(_DWORD *)(v142 + 36) = v43 + v47;
        }
        memcpy((void *)(v142 + 1104), v244, v243);
        uint64_t result = 0;
        *(_DWORD *)(v142 + 1100) = v243;
        return result;
      }
      goto LABEL_428;
    }
    int v32 = (_OWORD *)(v242 + 1084);
    *(void *)(v242 + 24) = 0;
    *(void *)(v242 + 32) = 0;
    *(unsigned char *)(v242 + 40) = 0;
    long long v30 = 0uLL;
LABEL_26:
    *int v32 = v30;
    return 1;
  }
  int v241 = (char *)(v12 + 1104);
  unsigned int v35 = v5;
  while (1)
  {
    if (*(_DWORD *)v12)
    {
      int v159 = __si_assert_copy_extra_1921(0);
      int v157 = v159;
      long long v160 = "";
      if (v159) {
        long long v160 = v159;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.c", 228, "ms->type == kTermInfoTypeId", v160);
      goto LABEL_396;
    }
    unsigned int v36 = FlatStorePageEntryRead(v18, v20, (int *)__n, v35, 0);
    size_t v37 = LODWORD(__n[0]);
    uint64_t v38 = HIDWORD(__n[0]);
    unsigned int v29 = HIDWORD(__n[0]) + LODWORD(__n[0]);
    if ((HIDWORD(__n[0]) + LODWORD(__n[0])) > 0x1000)
    {
      uint64_t v13 = v240;
      BOOL v162 = isExFat(*(_DWORD *)(v240 + 152));
      uint64_t v163 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
      unint64_t v164 = v163;
      uint64_t v165 = "";
      if (v163) {
        uint64_t v165 = v163;
      }
      uint64_t v166 = *(void *)(v240 + 392);
      if (v162)
      {
        si_analytics_log_2351("%s:%u: failure log '%s' %s %ld, ps:%d, pe:%d, pk:%d, po:%llx, ss:%llx se:%llx", "FlatStore.c", 238, "oldEntry.pfxLen + oldEntry.len <= CMPBUFFER_SIZE", v165, v38 + v37, v236, v20, 0, v226, *(void *)(v240 + 384), v166);
        uint64_t v167 = v164;
LABEL_406:
        free(v167);
        *(_DWORD *)(v12 + 4) = -1;
        return 1;
      }
      __message_assert("%s:%u: failed assertion '%s' %s %ld, ps:%d, pe:%d, pk:%d, po:%llx, ss:%llx se:%llx", "FlatStore.c", 244, "oldEntry.pfxLen + oldEntry.len <= CMPBUFFER_SIZE", v165, v38 + v37, v236, v20, 0, v226, *(void *)(v240 + 384), v166);
      unint64_t v174 = v164;
LABEL_427:
      free(v174);
      unint64_t v178 = *(_DWORD **)(v13 + 376);
      goto LABEL_416;
    }
    unsigned int v34 = v36;
    uint64_t v39 = (const void *)__n[1];
    memcpy((char *)__s1 + HIDWORD(__n[0]), (const void *)__n[1], LODWORD(__n[0]));
    size_t v40 = v29 >= v243 ? v243 : v29;
    int v41 = memcmp(__s1, v244, v40);
    int v42 = v41 ? v41 : v29 - v243;
    if (v42 >= 1) {
      break;
    }
    uint64_t v12 = v242;
    if (!v42)
    {
      if (!*(_DWORD *)v242)
      {
        _OWORD *v234 = v249;
        *(_DWORD *)(v242 + 24) = v34;
        if (!v5) {
          *(_DWORD *)(v242 + 36) = v243;
        }
        memcpy(&v241[v38], v39, v37);
        uint64_t result = 0;
        *(_DWORD *)(v242 + 1100) = v243;
        return result;
      }
      uint64_t v179 = v240;
      uint64_t v192 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
      unsigned int v181 = v192;
      BOOL v193 = "";
      if (v192) {
        BOOL v193 = v192;
      }
      __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 385, "ms->type == kTermInfoTypeId", v193);
LABEL_422:
      free(v181);
      if (!__valid_fsp(*(_DWORD **)(v179 + 376))) {
        goto LABEL_476;
      }
      goto LABEL_423;
    }
    memcpy(&v241[v38], v39, v37);
    *(_DWORD *)(v242 + 1100) = v29;
    unsigned int v35 = v34;
    if (v34 >= v20) {
      goto LABEL_40;
    }
  }
  unsigned int v250 = v243;
  int v251 = 0;
  if (!v5) {
    *(_DWORD *)(v242 + 36) = v243;
  }
  uint64_t v48 = v240;
  if (*(_DWORD *)v242)
  {
    unint64_t v189 = __si_assert_copy_extra_1921(0);
    uint64_t v190 = v189;
    unsigned int v191 = "";
    if (v189) {
      unsigned int v191 = v189;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.c", 264, "ms->type == kTermInfoTypeId", v191);
    goto LABEL_475;
  }
  if (!v35)
  {
    LODWORD(v50) = 0;
    unsigned int v54 = v243;
    goto LABEL_107;
  }
  unsigned int v49 = *(_DWORD *)(v242 + 1100);
  if (v49 >= v243) {
    uint64_t v50 = v243;
  }
  else {
    uint64_t v50 = v49;
  }
  if (v50)
  {
    uint64_t v51 = 0;
    while (*(unsigned __int8 *)(v242 + 1104 + v51) == v244[v51])
    {
      if (v50 == ++v51) {
        goto LABEL_106;
      }
    }
    LODWORD(v50) = v51;
  }
LABEL_106:
  unsigned int v54 = v243 - v50;
  int v251 = v50;
  unsigned int v250 = v243 - v50;
  if (v243 == v50)
  {
    uint64_t v204 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
    uint64_t v205 = v204;
    uint64_t v206 = "";
    if (v204) {
      uint64_t v206 = v204;
    }
    __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 273, "newEntry.len", v206);
    goto LABEL_487;
  }
LABEL_107:
  uint64_t v252 = &v244[v50];
  long long v253 = *(_OWORD *)(v242 + 8);
  if (v54 >= 0x80)
  {
    if (v54 >= 0x4000)
    {
      if (v54 >= 0x200000)
      {
        if (v54 >> 28) {
          int v59 = 5;
        }
        else {
          int v59 = 4;
        }
      }
      else
      {
        int v59 = 3;
      }
    }
    else
    {
      int v59 = 2;
    }
  }
  else
  {
    int v59 = 1;
  }
  if (v50 >= 0x80)
  {
    if (v50 >= 0x4000)
    {
      if (v50 >= 0x200000)
      {
        if (v50 >> 28) {
          int v63 = 5;
        }
        else {
          int v63 = 4;
        }
      }
      else
      {
        int v63 = 3;
      }
    }
    else
    {
      int v63 = 2;
    }
  }
  else
  {
    int v63 = 1;
  }
  int v64 = v253;
  if (v253 >= 0x80)
  {
    if (v253 >= 0x4000)
    {
      if (v253 >= 0x200000)
      {
        if (v253 >> 28) {
          int v65 = 5;
        }
        else {
          int v65 = 4;
        }
      }
      else
      {
        int v65 = 3;
      }
    }
    else
    {
      int v65 = 2;
    }
  }
  else
  {
    int v65 = 1;
  }
  int v227 = v59 + v54 + v63 + v65;
  unsigned int v66 = v227 + v20;
  unsigned int v67 = v236;
  unsigned int v231 = v227 + v20;
  if (v227 + (int)v20 <= v236) {
    goto LABEL_174;
  }
  if (!v232 || v236 > 0xFFF7)
  {
    if (v236 > 0xFFF7 || !extendBlock(v240, v238, v66))
    {
      *(void *)(v242 + 24) = 0;
      *(void *)(v242 + 32) = 0;
      uint64_t result = 1;
      *(unsigned char *)(v242 + 40) = 0;
      return result;
    }
    unint64_t v75 = (unint64_t)v238 << 6;
    uint64_t v76 = storageResolvePtr(v228, v75, 8, 1);
    unint64_t v77 = (unsigned __int16 *)storageResolvePtr(v228, v75, 64 << *(unsigned char *)(v76 + 2), 1);
    unsigned int v67 = (64 << *((unsigned char *)v77 + 2)) - 8;
    if (v67 <= v20)
    {
      __int16 v221 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
      unsigned int v73 = v221;
      uint64_t v222 = "";
      if (v221) {
        uint64_t v222 = v221;
      }
      __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 299, "pageEnd<pageSize", v222);
      goto LABEL_471;
    }
    unint64_t v18 = v77;
    unsigned int v66 = v227 + v20;
    if (v20 == *v77) {
      goto LABEL_174;
    }
    int v223 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
    uint64_t v205 = v223;
    v224 = "";
    if (v223) {
      v224 = v223;
    }
    __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 300, "(int)pageEnd==storePageEnd(page)", v224);
    goto LABEL_487;
  }
  unint64_t v68 = reallocBlock(v240, v238, v66, v232);
  if (v68)
  {
    *(void *)(v242 + 28) = v68;
    if (HIDWORD(v68)) {
      unint64_t v69 = 0;
    }
    else {
      unint64_t v69 = (unint64_t)v68 << 6;
    }
    uint64_t v70 = storageResolvePtr(v228, v69, 8, 1);
    uint64_t v71 = (unsigned __int16 *)storageResolvePtr(v228, v69, 64 << *(unsigned char *)(v70 + 2), 1);
    if (v20 != *v71)
    {
      int64_t v219 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
      uint64_t v205 = v219;
      double v220 = "";
      if (v219) {
        double v220 = v219;
      }
      __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 293, "(int)pageEnd==storePageEnd(page)", v220);
      goto LABEL_487;
    }
    unint64_t v18 = v71;
    unsigned int v67 = (64 << *((unsigned char *)v71 + 2)) - 8;
    unsigned int v66 = v227 + v20;
    if (v67 <= v20)
    {
      uint64_t v72 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
      unsigned int v73 = v72;
      uint64_t v74 = "";
      if (v72) {
        uint64_t v74 = v72;
      }
      __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 295, "pageEnd<pageSize", v74);
      goto LABEL_471;
    }
LABEL_174:
    if (v67 <= v20)
    {
      unsigned int v194 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
      unsigned int v73 = v194;
      double v195 = "";
      if (v194) {
        double v195 = v194;
      }
      __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 311, "pageEnd < pageSize", v195);
      goto LABEL_471;
    }
    if (v66 > v67)
    {
      uint64_t v196 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
      unsigned int v73 = v196;
      uint64_t v197 = "";
      if (v196) {
        uint64_t v197 = v196;
      }
      __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 312, "pageEnd + newEntrySize <= pageSize", v197);
      goto LABEL_471;
    }
    int v78 = *(_DWORD *)(v242 + 8);
    if (!*(_DWORD *)v242) {
      *(_DWORD *)(v242 + 8) = v78 + 1;
    }
    _OWORD *v234 = v253;
    if (v78 == v64)
    {
      long long v246 = 0u;
      long long v247 = 0u;
      unint64_t v79 = (unint64_t)v18;
      FlatStorePageEntryRead(v18, v20, (int *)&v246, v35, 0);
      LODWORD(v80) = 0;
      if (v50 == DWORD1(v246))
      {
        uint64_t v80 = v246 >= v54 ? v54 : v246;
        if (v80)
        {
          uint64_t v81 = 0;
          while (*(unsigned __int8 *)(*((void *)&v246 + 1) + v81) == v244[v50 + v81])
          {
            if (v80 == ++v81) {
              goto LABEL_190;
            }
          }
          LODWORD(v80) = v81;
        }
      }
LABEL_190:
      if (v246 <= v80)
      {
        uint64_t v200 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
        unsigned int v73 = v200;
        unsigned int v201 = "";
        if (v200) {
          unsigned int v201 = v200;
        }
        __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 334, "i < entry.len", v201);
        goto LABEL_471;
      }
      if (v80 > v54)
      {
        int64_t v202 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
        unsigned int v73 = v202;
        int v203 = "";
        if (v202) {
          int v203 = v202;
        }
        __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 335, "i<=newEntry.len", v203);
        goto LABEL_471;
      }
      if (!v80)
      {
        memmove((char *)v18 + v227 + v35 + 8, (char *)v18 + v35 + 8, v20 - v35);
        __int16 v83 = 0;
        goto LABEL_307;
      }
      if (v246 >= 0x80)
      {
        if (v246 >= 0x4000)
        {
          if (v246 >= 0x200000)
          {
            if (v246 >> 28) {
              int v82 = 5;
            }
            else {
              int v82 = 4;
            }
          }
          else
          {
            int v82 = 3;
          }
        }
        else
        {
          int v82 = 2;
        }
      }
      else
      {
        int v82 = 1;
      }
      if (DWORD1(v246) >= 0x80)
      {
        if (DWORD1(v246) >= 0x4000)
        {
          if (DWORD1(v246) >= 0x200000)
          {
            if (DWORD1(v246) >> 28) {
              int v84 = 5;
            }
            else {
              int v84 = 4;
            }
          }
          else
          {
            int v84 = 3;
          }
        }
        else
        {
          int v84 = 2;
        }
      }
      else
      {
        int v84 = 1;
      }
      unsigned int v85 = v247;
      unsigned int v86 = v247 >> 28;
      if (v247 >= 0x80)
      {
        if (v247 >= 0x4000)
        {
          if (v247 >= 0x200000)
          {
            if (v86) {
              int v87 = 5;
            }
            else {
              int v87 = 4;
            }
          }
          else
          {
            int v87 = 3;
          }
        }
        else
        {
          int v87 = 2;
        }
      }
      else
      {
        int v87 = 1;
      }
      unsigned int v239 = v54;
      size_t v88 = (v246 - v80);
      if (v246 == v80)
      {
        unint64_t v209 = __si_assert_copy_extra_1921(0);
        uint64_t v190 = v209;
        unint64_t v210 = "";
        if (v209) {
          unint64_t v210 = v209;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.c", 344, "entry.len > 0", v210);
        goto LABEL_475;
      }
      unsigned int v89 = v82 + v246 + v84 + v87;
      int v90 = (const void *)(*((void *)&v246 + 1) + v80);
      unsigned int v91 = v80 + DWORD1(v246);
      unsigned int v229 = v88 >> 28;
      if (v88 >> 28) {
        int v92 = 5;
      }
      else {
        int v92 = 4;
      }
      if (v88 >= 0x200000) {
        int v93 = v92;
      }
      else {
        int v93 = 3;
      }
      if (v88 >= 0x4000) {
        int v94 = v93;
      }
      else {
        int v94 = 2;
      }
      if (v88 >= 0x80) {
        int v95 = v94;
      }
      else {
        int v95 = 1;
      }
      unsigned int v233 = v91 >> 28;
      if (v91 >> 28) {
        int v96 = 5;
      }
      else {
        int v96 = 4;
      }
      if (v91 >= 0x200000) {
        int v97 = v96;
      }
      else {
        int v97 = 3;
      }
      if (v91 >= 0x4000) {
        int v98 = v97;
      }
      else {
        int v98 = 2;
      }
      if (v91 >= 0x80) {
        int v99 = v98;
      }
      else {
        int v99 = 1;
      }
      unsigned int v225 = v247 >> 28;
      if (v86) {
        int v100 = 5;
      }
      else {
        int v100 = 4;
      }
      if (v247 < 0x200000) {
        int v100 = 3;
      }
      if (v247 < 0x4000) {
        int v100 = 2;
      }
      if (v247 >= 0x80) {
        int v101 = v100;
      }
      else {
        int v101 = 1;
      }
      int v102 = v18 + 4;
      uint64_t v103 = v227 + v35;
      unsigned int v235 = v95 + v88 + v99 + v101;
      unsigned int v237 = v89;
      memmove((char *)v18 + v235 + v103 + 8, (char *)v18 + v89 + v35 + 8, v20 - (v89 + v35));
      unsigned int v104 = (char *)v18 + v103 + 8;
      if (v88 >= 0x80)
      {
        int v106 = v90;
        if (v88 >= 0x4000)
        {
          unsigned int v54 = v239;
          if (v88 >= 0x200000)
          {
            uint64_t v105 = 4;
            if (v229) {
              uint64_t v105 = 5;
            }
          }
          else
          {
            uint64_t v105 = 3;
          }
        }
        else
        {
          uint64_t v105 = 2;
          unsigned int v54 = v239;
        }
      }
      else
      {
        uint64_t v105 = 1;
        int v106 = v90;
        unsigned int v54 = v239;
      }
      int v107 = &v104[v105];
      if (v91 >= 0x80)
      {
        if (v91 >= 0x4000)
        {
          if (v91 >= 0x200000)
          {
            uint64_t v108 = 4;
            if (v233) {
              uint64_t v108 = 5;
            }
          }
          else
          {
            uint64_t v108 = 3;
          }
        }
        else
        {
          uint64_t v108 = 2;
        }
      }
      else
      {
        uint64_t v108 = 1;
      }
      memmove(&v107[v108], v106, v88);
      if (v88 > 0x7F)
      {
        if (v88 >> 14)
        {
          if (v88 >> 21)
          {
            if (v229)
            {
              unint64_t v113 = (char *)v102 + v103;
              *unint64_t v113 = -16;
              *(_DWORD *)(v113 + 1) = v88;
              uint64_t v109 = v103 + 5;
            }
            else
            {
              int v112 = (char *)v102 + v103;
              unsigned char *v112 = BYTE3(v88) | 0xE0;
              v112[1] = BYTE2(v88);
              v112[2] = BYTE1(v88);
              uint64_t v109 = v103 + 4;
              v112[3] = v88;
            }
          }
          else
          {
            int v111 = (char *)v102 + v103;
            *int v111 = BYTE2(v88) | 0xC0;
            v111[1] = BYTE1(v88);
            uint64_t v109 = v103 + 3;
            v111[2] = v88;
          }
        }
        else
        {
          int v110 = (char *)v102 + v103;
          *int v110 = BYTE1(v88) | 0x80;
          uint64_t v109 = v103 + 2;
          v110[1] = v88;
        }
      }
      else
      {
        uint64_t v109 = v103 + 1;
        *unsigned int v104 = v88;
      }
      uint64_t v48 = v240;
      if (v91 > 0x7F)
      {
        if (v91 >> 14)
        {
          if (v91 >> 21)
          {
            if (v233)
            {
              uint64_t v118 = (char *)v102 + v109;
              *uint64_t v118 = -16;
              *(_DWORD *)(v118 + 1) = v91;
              uint64_t v114 = v109 + 5;
            }
            else
            {
              uint64_t v117 = (char *)v102 + v109;
              *uint64_t v117 = HIBYTE(v91) | 0xE0;
              v117[1] = BYTE2(v91);
              _OWORD v117[2] = BYTE1(v91);
              uint64_t v114 = v109 + 4;
              v117[3] = v91;
            }
          }
          else
          {
            uint64_t v116 = (char *)v102 + v109;
            *uint64_t v116 = BYTE2(v91) | 0xC0;
            v116[1] = BYTE1(v91);
            uint64_t v114 = v109 + 3;
            _OWORD v116[2] = v91;
          }
        }
        else
        {
          uint64_t v115 = (char *)v102 + v109;
          unsigned char *v115 = BYTE1(v91) | 0x80;
          uint64_t v114 = v109 + 2;
          v115[1] = v91;
        }
      }
      else
      {
        uint64_t v114 = v109 + 1;
        *((unsigned char *)v102 + v109) = v91;
      }
      size_t v119 = v114 + v88;
      if (v85 > 0x7F)
      {
        if (v85 >> 14)
        {
          if (v85 >> 21)
          {
            uint64_t v122 = (char *)v102 + v119;
            if (v225)
            {
              *uint64_t v122 = -16;
              *(_DWORD *)(v122 + 1) = v85;
            }
            else
            {
              *uint64_t v122 = HIBYTE(v85) | 0xE0;
              v122[1] = BYTE2(v85);
              v122[2] = BYTE1(v85);
              v122[3] = v85;
            }
          }
          else
          {
            __int16 v121 = (char *)v102 + v119;
            *__int16 v121 = BYTE2(v85) | 0xC0;
            v121[1] = BYTE1(v85);
            v121[2] = v85;
          }
        }
        else
        {
          int v120 = (char *)v102 + v119;
          *int v120 = BYTE1(v85) | 0x80;
          v120[1] = v85;
        }
      }
      else
      {
        *((unsigned char *)v102 + v119) = v85;
      }
      memset(v245, 0, sizeof(v245));
      FlatStorePageEntryRead(v18, v231, (int *)v245, v35, v227);
      if (v88 != LODWORD(v245[0]))
      {
        uint64_t v211 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
        unsigned int v73 = v211;
        int v212 = "";
        if (v211) {
          int v212 = v211;
        }
        __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 350, "entry.len==entryCopy.len", v212);
        goto LABEL_471;
      }
      if (v91 == DWORD1(v245[0]))
      {
        __int16 v83 = v235 - v237;
        if (v235 <= v237)
        {
          unint64_t v79 = (unint64_t)v18;
LABEL_307:
          unsigned int v123 = v54;
          int v124 = FlatStorePageEntryWrite(v79, &v250, v35);
          uint64_t v125 = 64 << *(unsigned char *)(v79 + 2);
          unint64_t v126 = *(unsigned int *)(v48 + 408);
          if ((int)v126 < 1)
          {
            unint64_t v130 = -1;
          }
          else
          {
            uint64_t v127 = 54;
            do
            {
              unsigned __int8 v128 = *(void **)(v48 + 8 * v127);
              if (v128
                && (unint64_t v129 = v128[1], v129 + 1 >= 2)
                && v129 <= v79
                && (uint64_t v131 = v128[2], v129 - v131 + v128[3] > v79))
              {
                unint64_t v130 = v79 - v129 + v131;
              }
              else
              {
                unint64_t v130 = -1;
              }
              if (v127 - 53 >= v126) {
                break;
              }
              ++v127;
            }
            while (v130 == -1);
          }
          bit_vector_set_3386((void *)(v48 + 4536), (v130 >> 17));
          if ((v130 >> 17) != (v130 + v125) >> 17) {
            bit_vector_set_3386((void *)(v48 + 4536), (v130 >> 17) + 1);
          }
          *(_WORD *)unint64_t v79 = v83 + v231;
          if (!v50 || v123)
          {
            *(_DWORD *)(v242 + 24) = v124;
            memcpy(v241, v244, v243);
            uint64_t result = 0;
            *(_DWORD *)(v242 + 1100) = v243;
            return result;
          }
          int64_t v217 = __si_assert_copy_extra_1921(0);
          uint64_t v190 = v217;
          unint64_t v218 = "";
          if (v217) {
            unint64_t v218 = v217;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.c", 364, "newEntry.len", v218);
LABEL_475:
          free(v190);
          if (!__valid_fs(-1))
          {
LABEL_476:
            MEMORY[0xC00] = -559038737;
            abort();
          }
LABEL_423:
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        int64_t v215 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
        unsigned int v73 = v215;
        char v216 = "";
        if (v215) {
          char v216 = v215;
        }
        __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 352, "len2 <= len1", v216);
LABEL_471:
        free(v73);
        unint64_t v178 = *(_DWORD **)(v48 + 376);
LABEL_416:
        if (__valid_fsp(v178))
        {
LABEL_417:
          uint64_t v161 = 2989;
LABEL_418:
          *(_DWORD *)uint64_t v161 = -559038737;
          abort();
        }
LABEL_397:
        uint64_t v161 = 3072;
        goto LABEL_418;
      }
      unint64_t v213 = __si_assert_copy_extra_1921(*(_DWORD **)(v240 + 376));
      uint64_t v205 = v213;
      long long v214 = "";
      if (v213) {
        long long v214 = v213;
      }
      __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 351, "entry.pfxLen==entryCopy.pfxLen", v214);
LABEL_487:
      free(v205);
      if (!__valid_fsp(*(_DWORD **)(v48 + 376))) {
        goto LABEL_476;
      }
      goto LABEL_423;
    }
    uint64_t v198 = __si_assert_copy_extra_1921(0);
    int v157 = v198;
    unint64_t v199 = "";
    if (v198) {
      unint64_t v199 = v198;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.c", 318, "termID == getNum(newEntry.termInfo.termInfo.termId.ptr)", v199);
LABEL_396:
    free(v157);
    if (__valid_fs(-1)) {
      goto LABEL_417;
    }
    goto LABEL_397;
  }
LABEL_392:
  *(_DWORD *)(v242 + 4) = -1;
  return 1;
}

void si_analytics_log_2351(char *a1, ...)
{
  va_start(va, a1);
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  v1[0] = 0;
  va_copy((va_list)&v1[1], va);
  vasprintf((char **)v1, a1, va);
  SISetCrashCStr((const char *)v1[0]);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)iovec buf = 136315138;
    char v3 = v1[0];
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "%s", buf, 0xCu);
  }
  free(v1[0]);
}

uint64_t FlatStorePageEntryRead(unsigned __int16 *a1, unsigned int a2, int *a3, unsigned int a4, int a5)
{
  uint64_t v10 = a5 + a4;
  uint64_t v11 = a1 + 4;
  uint64_t v12 = v10 + 1;
  unsigned int v13 = *((unsigned __int8 *)a1 + v10 + 8);
  if (*((char *)a1 + v10 + 8) < 0)
  {
    if (v13 > 0xBF)
    {
      if (v13 > 0xDF)
      {
        if (v13 > 0xEF)
        {
          unsigned int v13 = *(_DWORD *)((char *)v11 + v12);
          LODWORD(v12) = v10 + 5;
        }
        else
        {
          unsigned int v13 = ((v13 & 0xF) << 24) | (*((unsigned __int8 *)v11 + v12) << 16) | (*((unsigned __int8 *)v11 + v10 + 2) << 8) | *((unsigned __int8 *)v11 + v10 + 3);
          LODWORD(v12) = v10 + 4;
        }
      }
      else
      {
        unsigned int v13 = ((v13 & 0x1F) << 16) | (*((unsigned __int8 *)v11 + v12) << 8) | *((unsigned __int8 *)v11 + v10 + 2);
        LODWORD(v12) = v10 + 3;
      }
    }
    else
    {
      int v14 = *((unsigned __int8 *)v11 + v12) | ((v13 & 0x3F) << 8);
      LODWORD(v12) = v10 + 2;
      unsigned int v13 = v14;
    }
  }
  *a3 = v13;
  if (v13) {
    BOOL v15 = 1;
  }
  else {
    BOOL v15 = v12 == 1;
  }
  if (!v15)
  {
    uint8x8_t v28 = __si_assert_copy_extra_1921(0);
    unsigned int v29 = v28;
    if (v28) {
      long long v30 = v28;
    }
    else {
      long long v30 = "";
    }
    int v31 = *a1;
    int v32 = (64 << *((unsigned char *)a1 + 2)) - 8;
    int v33 = *a3;
    BOOL v34 = _checkFlatPage(a1, a4, a5);
    unsigned int v35 = "false";
    if (v34) {
      unsigned int v35 = "true";
    }
    __message_assert("%s:%u: failed assertion '%s' %s len:%d cursor:%d, pe:%d, ps:%d, valid cursor:%s", "FlatStore.h", 241, "entry->len > 0 || pageCursor == v2_vInt32Size(0)", v30, v33, v12, v31, v32, v35);
    free(v29);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v16 = v12 + 1;
  unsigned int v17 = *((unsigned __int8 *)v11 + v12);
  if (*((char *)v11 + v12) < 0)
  {
    if (v17 > 0xBF)
    {
      if (v17 > 0xDF)
      {
        if (v17 > 0xEF)
        {
          unsigned int v17 = *(_DWORD *)((char *)v11 + v16);
          LODWORD(v16) = v12 + 5;
        }
        else
        {
          unsigned int v17 = ((v17 & 0xF) << 24) | (*((unsigned __int8 *)v11 + v16) << 16) | (*((unsigned __int8 *)v11
                                                                                 + v12
                                                                                 + 2) << 8) | *((unsigned __int8 *)v11
                                                                                              + v12
                                                                                              + 3);
          LODWORD(v16) = v12 + 4;
        }
      }
      else
      {
        unsigned int v17 = ((v17 & 0x1F) << 16) | (*((unsigned __int8 *)v11 + v16) << 8) | *((unsigned __int8 *)v11
                                                                              + v12
                                                                              + 2);
        LODWORD(v16) = v12 + 3;
      }
    }
    else
    {
      int v18 = *((unsigned __int8 *)v11 + v16) | ((v17 & 0x3F) << 8);
      LODWORD(v16) = v12 + 2;
      unsigned int v17 = v18;
    }
  }
  a3[1] = v17;
  *((void *)a3 + 1) = (char *)v11 + v16;
  uint64_t v19 = v13 + v16;
  uint64_t v20 = v19 + 1;
  unsigned int v21 = *((unsigned __int8 *)v11 + v19);
  if (*((char *)v11 + v19) < 0)
  {
    if (v21 > 0xBF)
    {
      if (v21 > 0xDF)
      {
        if (v21 > 0xEF)
        {
          unsigned int v21 = *(_DWORD *)((char *)v11 + v20);
          uint64_t v20 = v19 + 5;
        }
        else
        {
          unsigned int v21 = ((v21 & 0xF) << 24) | (*((unsigned __int8 *)v11 + v20) << 16) | (*((unsigned __int8 *)v11 + v19 + 2) << 8) | *((unsigned __int8 *)v11 + v19 + 3);
          uint64_t v20 = v19 + 4;
        }
      }
      else
      {
        unsigned int v21 = ((v21 & 0x1F) << 16) | (*((unsigned __int8 *)v11 + v20) << 8) | *((unsigned __int8 *)v11 + v19 + 2);
        uint64_t v20 = v19 + 3;
      }
    }
    else
    {
      int v22 = *((unsigned __int8 *)v11 + v20) | ((v21 & 0x3F) << 8);
      uint64_t v20 = v19 + 2;
      unsigned int v21 = v22;
    }
  }
  a3[4] = v21;
  if (v20 > a2)
  {
    if (__valid_fs(-1))
    {
      uint64_t v24 = __si_assert_copy_extra_1921(0);
      unint64_t v25 = v24;
      uint64_t v26 = "";
      if (v24) {
        uint64_t v26 = v24;
      }
      si_analytics_log_2351("%s:%u: failed assertion '%s' %s cursor %d should have been <= end %d. len:%d pe:%d ps:%d", "FlatStore.h", 259, "pageCursor <= pageEnd", v26, v20, a2, *a3, *a1, (64 << *((unsigned char *)a1 + 2)) - 8);
      free(v25);
      uint64_t v27 = 2816;
    }
    else
    {
      uint64_t v27 = 3072;
    }
    *(_DWORD *)uint64_t v27 = -559038737;
    abort();
  }
  return v20;
}

unint64_t reallocBlock(uint64_t a1, unint64_t a2, unsigned int a3, unint64_t *a4)
{
  unint64_t v6 = a2;
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = a1 + 160;
  unint64_t v9 = HIDWORD(a2);
  if (HIDWORD(a2)) {
    unint64_t v10 = 0;
  }
  else {
    unint64_t v10 = (unint64_t)a2 << 6;
  }
  uint64_t v11 = storageResolvePtr(a1 + 160, v10, 8, 1);
  uint64_t v12 = (unsigned __int16 *)storageResolvePtr(v8, v10, 64 << *(unsigned char *)(v11 + 2), 1);
  signed int v13 = 64 << *((unsigned char *)v12 + 2);
  unint64_t v14 = a3 + 8;
  LODWORD(v15) = v13;
  do
    unint64_t v15 = (2 * v15);
  while (v14 > v15);
  if (v13 - 8 < *v12)
  {
    uint64_t v46 = __si_assert_copy_extra_1921(0);
    unsigned int v47 = v46;
    uint64_t v48 = "";
    if (v46) {
      uint64_t v48 = v46;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.c", 665, "storePageEnd(page) <= storePageDataSize(page)", v48);
    free(v47);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  int v55 = a4;
  unint64_t v16 = *(unsigned int *)(a1 + 408);
  if ((int)v16 < 1)
  {
    unint64_t v21 = -1;
  }
  else
  {
    uint64_t v17 = 54;
    do
    {
      int v18 = *(void **)(a1 + 8 * v17);
      if (v18
        && (unint64_t v19 = v18[1], v19 + 1 >= 2)
        && v19 <= (unint64_t)v12
        && (uint64_t v20 = v18[2], v19 - v20 + v18[3] > (unint64_t)v12))
      {
        unint64_t v21 = (unint64_t)v12 + v20 - v19;
      }
      else
      {
        unint64_t v21 = -1;
      }
      if (v17 - 53 >= v16) {
        break;
      }
      ++v17;
    }
    while (v21 == -1);
  }
  int v22 = (void *)(a1 + 4536);
  bit_vector_set_3386((void *)(a1 + 4536), (v21 >> 17));
  if ((v21 >> 17) != (v21 + v13) >> 17) {
    bit_vector_set_3386((void *)(a1 + 4536), (v21 >> 17) + 1);
  }
  if (storageExtendOffset(v8, v10, v13, v15))
  {
    uint64_t v23 = storageResolvePtr(v8, v10, 8, 1);
    uint64_t v24 = storageResolvePtr(v8, v10, 64 << *(unsigned char *)(v23 + 2), 1);
    char v25 = __clz(__rbit32(v15 >> 6));
    if (!v15) {
      char v25 = -1;
    }
    *(unsigned char *)(v24 + 2) = v25;
    if (v10 >= *(void *)(a1 + 392))
    {
      uint64_t v26 = __si_assert_copy_extra_1921(*(_DWORD **)(a1 + 376));
      uint64_t v27 = v26;
      uint8x8_t v28 = "";
      if (v26) {
        uint8x8_t v28 = v26;
      }
      __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 670, "flatStoreGetOffset(info) < storageGetCount(store)", v28);
      goto LABEL_77;
    }
  }
  else
  {
    if (!v55) {
      return 0;
    }
    memset(v57, 0, sizeof(v57));
    unsigned int v56 = 0;
    if (v15 > 0x10000)
    {
      unsigned int v49 = __si_assert_copy_extra_1921(0);
      uint64_t v50 = v49;
      uint64_t v51 = "";
      if (v49) {
        uint64_t v51 = v49;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.c", 677, "reSize<=4096*16", v51);
      free(v50);
      if (__valid_fs(-1)) {
        uint64_t v52 = 2989;
      }
      else {
        uint64_t v52 = 3072;
      }
      *(_DWORD *)uint64_t v52 = -559038737;
      abort();
    }
    unint64_t v6 = storageGrowOffset(v8, v10, v13, v15, (uint64_t)v57, (int *)&v56);
    if (v6)
    {
      storageResolvePtr(v8, v6, v15, 1);
      if (v9) {
        unint64_t v6 = 0;
      }
      else {
        unint64_t v6 = (v6 >> 6);
      }
    }
    unint64_t *v55 = v6;
    uint64_t v29 = v56;
    if ((int)v56 < 1)
    {
      if (!v6) {
        return v6;
      }
    }
    else
    {
      long long v30 = (unint64_t *)v57;
      do
      {
        unint64_t v32 = *v30++;
        unint64_t v31 = v32;
        bit_vector_set_3386((void *)(a1 + 4536), (v32 >> 17));
        if ((v32 >> 17) != (v32 + 8) >> 17) {
          bit_vector_set_3386((void *)(a1 + 4536), (v31 >> 17) + 1);
        }
        --v29;
      }
      while (v29);
      unint64_t v6 = *v55;
      if (!*(_DWORD *)v55) {
        return v6;
      }
    }
    if (HIDWORD(v6)) {
      unint64_t v33 = 0;
    }
    else {
      unint64_t v33 = (unint64_t)v6 << 6;
    }
    if (v33 >= *(void *)(a1 + 392))
    {
      int v53 = __si_assert_copy_extra_1921(*(_DWORD **)(a1 + 376));
      uint64_t v27 = v53;
      unsigned int v54 = "";
      if (v53) {
        unsigned int v54 = v53;
      }
      __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 682, "flatStoreGetOffset(*newOffset) < storageGetCount(store)", v54);
LABEL_77:
      free(v27);
      if (__valid_fsp(*(_DWORD **)(a1 + 376)))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    uint64_t v34 = storageResolvePtr(v8, v33, 8, 1);
    unint64_t v35 = storageResolvePtr(v8, v33, 64 << *(unsigned char *)(v34 + 2), 1);
    unint64_t v36 = v35;
    uint64_t v37 = 64 << *(unsigned char *)(v35 + 2);
    unint64_t v38 = *(unsigned int *)(a1 + 408);
    if ((int)v38 < 1)
    {
      unint64_t v42 = -1;
    }
    else
    {
      uint64_t v39 = 54;
      do
      {
        size_t v40 = *(void **)(a1 + 8 * v39);
        if (v40 && (unint64_t v41 = v40[1], v41 + 1 >= 2) && v41 <= v35 && (v43 = v40[2], v41 - v43 + v40[3] > v35)) {
          unint64_t v42 = v35 - v41 + v43;
        }
        else {
          unint64_t v42 = -1;
        }
        if (v39 - 53 >= v38) {
          break;
        }
        ++v39;
      }
      while (v42 == -1);
    }
    bit_vector_set_3386(v22, (v42 >> 17));
    if ((v42 >> 17) != (v42 + v37) >> 17) {
      bit_vector_set_3386(v22, (v42 >> 17) + 1);
    }
    char v44 = __clz(__rbit32(v15 >> 6));
    if (!v15) {
      char v44 = -1;
    }
    *(unsigned char *)(v36 + 2) = v44;
    return *v55;
  }
  return v6;
}

uint64_t extendBlock(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v5 = a1 + 160;
  unint64_t v6 = (unint64_t)a2 << 6;
  uint64_t v7 = storageResolvePtr(a1 + 160, v6, 8, 1);
  uint64_t v8 = (unsigned __int16 *)storageResolvePtr(v5, v6, 64 << *(unsigned char *)(v7 + 2), 1);
  unsigned int v9 = 64 << *((unsigned char *)v8 + 2);
  if ((int)(v9 - 8) < *v8)
  {
    unint64_t v16 = __si_assert_copy_extra_1921(*(_DWORD **)(a1 + 376));
    uint64_t v17 = v16;
    int v18 = "";
    if (v16) {
      int v18 = v16;
    }
    __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 641, "storePageEnd(page) <= storePageDataSize(page)", v18);
    free(v17);
    if (__valid_fsp(*(_DWORD **)(a1 + 376)))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  LODWORD(v10) = 64 << *((unsigned char *)v8 + 2);
  do
    unint64_t v10 = (2 * v10);
  while ((unint64_t)a3 + 8 > v10);
  uint64_t v11 = storageExtendOffset(v5, v6, v9, v10);
  if (v11)
  {
    uint64_t v12 = storageResolvePtr(v5, v6, 8, 1);
    uint64_t v13 = storageResolvePtr(v5, v6, 64 << *(unsigned char *)(v12 + 2), 1);
    char v14 = __clz(__rbit32(v10 >> 6));
    if (!v10) {
      char v14 = -1;
    }
    *(unsigned char *)(v13 + 2) = v14;
  }
  return v11;
}

uint64_t FlatStorePageEntryWrite(uint64_t a1, unsigned int *a2, unsigned int a3)
{
  uint64_t v3 = a1 + 8;
  unsigned int v4 = *a2;
  if (*a2 > 0x7F)
  {
    if (v4 >> 14)
    {
      if (v4 >> 21)
      {
        if (v4 >> 28)
        {
          uint64_t v9 = v3 + a3;
          *(unsigned char *)uint64_t v9 = -16;
          *(_DWORD *)(v9 + 1) = v4;
          uint64_t v5 = a3 + 5;
        }
        else
        {
          uint64_t v8 = (unsigned char *)(v3 + a3);
          *uint64_t v8 = HIBYTE(v4) | 0xE0;
          v8[1] = BYTE2(v4);
          v8[2] = BYTE1(v4);
          uint64_t v5 = a3 + 4;
          void v8[3] = v4;
        }
      }
      else
      {
        uint64_t v7 = (unsigned char *)(v3 + a3);
        *uint64_t v7 = BYTE2(v4) | 0xC0;
        v7[1] = BYTE1(v4);
        uint64_t v5 = a3 + 3;
        v7[2] = v4;
      }
    }
    else
    {
      unint64_t v6 = (unsigned char *)(v3 + a3);
      *unint64_t v6 = BYTE1(v4) | 0x80;
      uint64_t v5 = a3 + 2;
      v6[1] = v4;
    }
  }
  else
  {
    uint64_t v5 = a3 + 1;
    *(unsigned char *)(v3 + a3) = v4;
  }
  unsigned int v10 = a2[1];
  if (v10 <= 0x7F)
  {
    uint64_t v11 = v5 + 1;
    *(unsigned char *)(v3 + v5) = v10;
    if (!*a2) {
      goto LABEL_26;
    }
LABEL_23:
    unint64_t v16 = 0;
    do
    {
      *(unsigned char *)(v11 + a1 + 8 + v16) = *(unsigned char *)(*((void *)a2 + 1) + v16);
      ++v16;
    }
    while (v16 < *a2);
    v11 += v16;
    goto LABEL_26;
  }
  if (v10 >> 14)
  {
    if (v10 >> 21)
    {
      if (v10 >> 28)
      {
        uint64_t v15 = v3 + v5;
        *(unsigned char *)uint64_t v15 = -16;
        *(_DWORD *)(v15 + 1) = v10;
        uint64_t v11 = v5 + 5;
        if (!*a2) {
          goto LABEL_26;
        }
        goto LABEL_23;
      }
      char v14 = (unsigned char *)(v3 + v5);
      *char v14 = HIBYTE(v10) | 0xE0;
      v14[1] = BYTE2(v10);
      void v14[2] = BYTE1(v10);
      uint64_t v11 = v5 + 4;
      void v14[3] = v10;
      if (*a2) {
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v13 = (unsigned char *)(v3 + v5);
      *uint64_t v13 = BYTE2(v10) | 0xC0;
      v13[1] = BYTE1(v10);
      uint64_t v11 = v5 + 3;
      v13[2] = v10;
      if (*a2) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    uint64_t v12 = (unsigned char *)(v3 + v5);
    unsigned char *v12 = BYTE1(v10) | 0x80;
    uint64_t v11 = v5 + 2;
    v12[1] = v10;
    if (*a2) {
      goto LABEL_23;
    }
  }
LABEL_26:
  unsigned int v17 = a2[4];
  if (v17 > 0x7F)
  {
    if (v17 >> 14)
    {
      if (v17 >> 21)
      {
        uint64_t v21 = v3 + v11;
        if (v17 >> 28)
        {
          *(unsigned char *)uint64_t v21 = -16;
          *(_DWORD *)(v21 + 1) = v17;
          return v11 + 5;
        }
        else
        {
          *(unsigned char *)uint64_t v21 = HIBYTE(v17) | 0xE0;
          *(unsigned char *)(v21 + 1) = BYTE2(v17);
          *(unsigned char *)(v21 + 2) = BYTE1(v17);
          uint64_t result = v11 + 4;
          *(unsigned char *)(v21 + 3) = v17;
        }
      }
      else
      {
        uint64_t v20 = (unsigned char *)(v3 + v11);
        *uint64_t v20 = BYTE2(v17) | 0xC0;
        v20[1] = BYTE1(v17);
        uint64_t result = v11 + 3;
        void v20[2] = v17;
      }
    }
    else
    {
      unint64_t v19 = (unsigned char *)(v3 + v11);
      unsigned char *v19 = BYTE1(v17) | 0x80;
      uint64_t result = v11 + 2;
      v19[1] = v17;
    }
  }
  else
  {
    uint64_t result = v11 + 1;
    *(unsigned char *)(v3 + v11) = v17;
  }
  return result;
}

uint64_t FlatStorePageEntryWrite2_2375(uint64_t a1, unsigned int *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6 = a1 + 8;
  unsigned int v7 = *a2;
  if (*a2 > 0x7F)
  {
    if (v7 >> 14)
    {
      if (v7 >> 21)
      {
        if (v7 >> 28)
        {
          uint64_t v12 = v6 + a4;
          *(unsigned char *)uint64_t v12 = -16;
          *(_DWORD *)(v12 + 1) = v7;
          uint64_t v8 = a4 + 5;
        }
        else
        {
          uint64_t v11 = (unsigned char *)(v6 + a4);
          *uint64_t v11 = HIBYTE(v7) | 0xE0;
          v11[1] = BYTE2(v7);
          v11[2] = BYTE1(v7);
          uint64_t v8 = a4 + 4;
          void v11[3] = v7;
        }
      }
      else
      {
        unsigned int v10 = (unsigned char *)(v6 + a4);
        unsigned char *v10 = BYTE2(v7) | 0xC0;
        v10[1] = BYTE1(v7);
        uint64_t v8 = a4 + 3;
        v10[2] = v7;
      }
    }
    else
    {
      uint64_t v9 = (unsigned char *)(v6 + a4);
      *uint64_t v9 = BYTE1(v7) | 0x80;
      uint64_t v8 = a4 + 2;
      v9[1] = v7;
    }
  }
  else
  {
    uint64_t v8 = a4 + 1;
    *(unsigned char *)(v6 + a4) = v7;
  }
  unsigned int v13 = a2[1];
  if (v13 <= 0x7F)
  {
    uint64_t v14 = v8 + 1;
    *(unsigned char *)(v6 + v8) = v13;
    if (!*a2) {
      goto LABEL_26;
    }
LABEL_23:
    unint64_t v19 = 0;
    do
    {
      *(unsigned char *)(v14 + a1 + 8 + v19) = *(unsigned char *)(*((void *)a2 + 1) + v19);
      ++v19;
    }
    while (v19 < *a2);
    v14 += v19;
    goto LABEL_26;
  }
  if (v13 >> 14)
  {
    if (v13 >> 21)
    {
      if (v13 >> 28)
      {
        uint64_t v18 = v6 + v8;
        *(unsigned char *)uint64_t v18 = -16;
        *(_DWORD *)(v18 + 1) = v13;
        uint64_t v14 = v8 + 5;
        if (!*a2) {
          goto LABEL_26;
        }
        goto LABEL_23;
      }
      unsigned int v17 = (unsigned char *)(v6 + v8);
      unsigned char *v17 = HIBYTE(v13) | 0xE0;
      v17[1] = BYTE2(v13);
      v17[2] = BYTE1(v13);
      uint64_t v14 = v8 + 4;
      void v17[3] = v13;
      if (*a2) {
        goto LABEL_23;
      }
    }
    else
    {
      unint64_t v16 = (unsigned char *)(v6 + v8);
      unsigned char *v16 = BYTE2(v13) | 0xC0;
      v16[1] = BYTE1(v13);
      uint64_t v14 = v8 + 3;
      v16[2] = v13;
      if (*a2) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    uint64_t v15 = (unsigned char *)(v6 + v8);
    *uint64_t v15 = BYTE1(v13) | 0x80;
    uint64_t v14 = v8 + 2;
    v15[1] = v13;
    if (*a2) {
      goto LABEL_23;
    }
  }
LABEL_26:
  uint64_t v20 = *((void *)a2 + 2);
  uint64_t v21 = *a3;
  *a3 = v20;
  uint64_t v22 = v2_writeVInt64(a1 + 8, v14, v20 - v21);
  uint64_t v23 = *((void *)a2 + 3);
  if (v23)
  {
    uint64_t v24 = a3[1];
    a3[1] = v23;
    unint64_t v25 = v23 - v24;
  }
  else
  {
    unint64_t v25 = 0;
  }
  return v2_writeVInt64(v6, v22, v25);
}

BOOL _checkFlatPage(unsigned __int16 *a1, unsigned int a2, int a3)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = *a1;
  if (a3) {
    unsigned int v6 = a2;
  }
  else {
    unsigned int v6 = *a1;
  }
  if (v5 < a2)
  {
    int v7 = *__error();
    uint64_t v8 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v31 = 136316162;
      unint64_t v32 = "_checkFlatPage";
      __int16 v33 = 1024;
      int v34 = 188;
      __int16 v35 = 1024;
      unsigned int v36 = a2;
      __int16 v37 = 2048;
      unint64_t v38 = a1 + 4;
      __int16 v39 = 1024;
      unsigned int v40 = v5;
      _os_log_error_impl(&dword_1BD672000, v8, OS_LOG_TYPE_ERROR, "%s:%d: invalid offset %d, %p (%d)", (uint8_t *)&v31, 0x28u);
    }
    uint64_t v9 = __error();
    BOOL result = 0;
    *uint64_t v9 = v7;
    return result;
  }
  uint64_t v11 = a1 + 4;
  unsigned int v12 = a2;
  while (1)
  {
    if (v12 >= v6) {
      return v12 == v6;
    }
    unsigned int v13 = v12;
    uint64_t v14 = v12;
    uint64_t v15 = v12 + 1;
    unsigned int v16 = *((unsigned __int8 *)v11 + v14);
    if (*((char *)v11 + v14) < 0)
    {
      if (v16 > 0xBF)
      {
        if (v16 > 0xDF)
        {
          if (v16 > 0xEF)
          {
            unsigned int v16 = *(_DWORD *)((char *)v11 + v15);
            LODWORD(v15) = v14 + 5;
          }
          else
          {
            unsigned int v16 = ((v16 & 0xF) << 24) | (*((unsigned __int8 *)v11 + v15) << 16) | (*((unsigned __int8 *)v11 + v14 + 2) << 8) | *((unsigned __int8 *)v11 + v14 + 3);
            LODWORD(v15) = v14 + 4;
          }
        }
        else
        {
          unsigned int v16 = ((v16 & 0x1F) << 16) | (*((unsigned __int8 *)v11 + v15) << 8) | *((unsigned __int8 *)v11 + v14 + 2);
          LODWORD(v15) = v14 + 3;
        }
      }
      else
      {
        int v17 = *((unsigned __int8 *)v11 + v15) | ((v16 & 0x3F) << 8);
        LODWORD(v15) = v14 + 2;
        unsigned int v16 = v17;
      }
    }
    uint64_t v18 = v15;
    uint64_t v19 = v15 + 1;
    unsigned int v20 = *((unsigned __int8 *)v11 + v18);
    if ((*((char *)v11 + v18) & 0x80000000) == 0) {
      break;
    }
    if (v20 > 0xBF)
    {
      if (v20 > 0xDF)
      {
        if (v20 <= 0xEF)
        {
          unsigned int v20 = ((v20 & 0xF) << 24) | (*((unsigned __int8 *)v11 + v19) << 16) | (*((unsigned __int8 *)v11 + v18 + 2) << 8) | *((unsigned __int8 *)v11 + v18 + 3);
          LODWORD(v19) = v18 + 4;
          break;
        }
        unsigned int v20 = *(_DWORD *)((char *)v11 + v19);
        LODWORD(v19) = v18 + 5;
        if (v13) {
          goto LABEL_30;
        }
      }
      else
      {
        unsigned int v20 = ((v20 & 0x1F) << 16) | (*((unsigned __int8 *)v11 + v19) << 8) | *((unsigned __int8 *)v11 + v18 + 2);
        LODWORD(v19) = v18 + 3;
        if (v13) {
          goto LABEL_30;
        }
      }
    }
    else
    {
      int v21 = *((unsigned __int8 *)v11 + v19) | ((v20 & 0x3F) << 8);
      LODWORD(v19) = v18 + 2;
      unsigned int v20 = v21;
      if (v13) {
        goto LABEL_30;
      }
    }
LABEL_31:
    unsigned int v22 = v16 + v19;
    if (v22 >= v5)
    {
      int v28 = *__error();
      uint64_t v29 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
LABEL_49:
        long long v30 = __error();
        BOOL result = 0;
        *long long v30 = v28;
        return result;
      }
      int v31 = 136316930;
      unint64_t v32 = "_checkFlatPage";
      __int16 v33 = 1024;
      int v34 = 211;
      __int16 v35 = 1024;
      unsigned int v36 = a2;
      __int16 v37 = 2048;
      unint64_t v38 = v11;
      __int16 v39 = 1024;
      unsigned int v40 = v5;
      __int16 v41 = 1024;
      unsigned int v42 = v13;
      __int16 v43 = 1024;
      unsigned int v44 = v16;
      __int16 v45 = 1024;
      unsigned int v46 = v20;
LABEL_51:
      _os_log_error_impl(&dword_1BD672000, v29, OS_LOG_TYPE_ERROR, "%s:%d: invalid offset %d, %p (%d) s:%d l1:%d l2:%d", (uint8_t *)&v31, 0x3Au);
      goto LABEL_49;
    }
    if (*((char *)v11 + v22) < 0)
    {
      unsigned int v23 = *((unsigned __int8 *)v11 + v22);
      if (v23 > 0xBF)
      {
        unsigned int v24 = v22 + 5;
        if (v23 <= 0xEF) {
          unsigned int v24 = v22 + 4;
        }
        unsigned int v12 = v22 + 3;
        if (v23 > 0xDF) {
          unsigned int v12 = v24;
        }
      }
      else
      {
        unsigned int v12 = v22 + 2;
      }
    }
    else
    {
      unsigned int v12 = v22 + 1;
    }
    if (v12 > v5)
    {
      int v28 = *__error();
      uint64_t v29 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        goto LABEL_49;
      }
      int v31 = 136316930;
      unint64_t v32 = "_checkFlatPage";
      __int16 v33 = 1024;
      int v34 = 220;
      __int16 v35 = 1024;
      unsigned int v36 = a2;
      __int16 v37 = 2048;
      unint64_t v38 = v11;
      __int16 v39 = 1024;
      unsigned int v40 = v5;
      __int16 v41 = 1024;
      unsigned int v42 = v13;
      __int16 v43 = 1024;
      unsigned int v44 = v16;
      __int16 v45 = 1024;
      unsigned int v46 = v20;
      goto LABEL_51;
    }
  }
  if (!v13) {
    goto LABEL_31;
  }
LABEL_30:
  if (v16) {
    goto LABEL_31;
  }
  int v25 = *__error();
  uint64_t v26 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    int v31 = 136316930;
    unint64_t v32 = "_checkFlatPage";
    __int16 v33 = 1024;
    int v34 = 205;
    __int16 v35 = 1024;
    unsigned int v36 = a2;
    __int16 v37 = 2048;
    unint64_t v38 = v11;
    __int16 v39 = 1024;
    unsigned int v40 = v5;
    __int16 v41 = 1024;
    unsigned int v42 = v13;
    __int16 v43 = 1024;
    unsigned int v44 = 0;
    __int16 v45 = 1024;
    unsigned int v46 = v20;
    _os_log_error_impl(&dword_1BD672000, v26, OS_LOG_TYPE_ERROR, "%s:%d: invalid offset %d, %p (%d) s:%d l1:%d l2:%d", (uint8_t *)&v31, 0x3Au);
  }
  uint64_t v27 = __error();
  BOOL result = 0;
  *uint64_t v27 = v25;
  return result;
}

uint64_t appendStringFlat(uint64_t a1, uint64_t a2, unint64_t a3, unsigned int a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, unint64_t *a8)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = a1 + 160;
  if (HIDWORD(a3)) {
    unint64_t v16 = 0;
  }
  else {
    unint64_t v16 = (unint64_t)a3 << 6;
  }
  uint64_t v17 = storageResolvePtr(a1 + 160, v16, 8, 1);
  uint64_t v72 = v15;
  uint64_t v18 = (unsigned __int16 *)storageResolvePtr(v15, v16, 64 << *(unsigned char *)(v17 + 2), 1);
  if (v16 >= *(void *)(a1 + 392))
  {
    int v63 = __si_assert_copy_extra_1921(*(_DWORD **)(a1 + 376));
    int v64 = v63;
    int v65 = "";
    if (v63) {
      int v65 = v63;
    }
    __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 554, "flatStoreGetOffset(info) < storageGetCount(store)", v65);
    free(v64);
    if (!__valid_fsp(*(_DWORD **)(a1 + 376)))
    {
LABEL_161:
      MEMORY[0xC00] = -559038737;
      abort();
    }
LABEL_156:
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  uint64_t v19 = v18;
  uint64_t v20 = *v18;
  char v21 = *((unsigned char *)v18 + 2);
  unsigned int v74 = a4;
  int v75 = 0;
  uint64_t v77 = a6;
  uint64_t v78 = a7;
  if (v20)
  {
    unsigned int v22 = *(_DWORD *)(a2 + 1100);
    if (v22 >= a4) {
      uint64_t v23 = a4;
    }
    else {
      uint64_t v23 = v22;
    }
    if (v23)
    {
      uint64_t v24 = 0;
      while (*(unsigned __int8 *)(a2 + 1104 + v24) == a5[v24])
      {
        if (v23 == ++v24) {
          goto LABEL_16;
        }
      }
      LODWORD(v23) = v24;
    }
LABEL_16:
    unsigned int v25 = a4 - v23;
    unsigned int v74 = a4 - v23;
    int v75 = v23;
    if (a4 == v23)
    {
      unsigned int v66 = __si_assert_copy_extra_1921(0);
      unsigned int v67 = v66;
      unint64_t v68 = "";
      if (v66) {
        unint64_t v68 = v66;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.c", 565, "entry.len", v68);
LABEL_160:
      free(v67);
      if (!__valid_fs(-1)) {
        goto LABEL_161;
      }
      goto LABEL_156;
    }
  }
  else
  {
    LODWORD(v23) = 0;
    *(_OWORD *)(a2 + 1084) = 0u;
    unsigned int v25 = a4;
  }
  unsigned int v26 = (64 << v21) - 8;
  uint64_t v76 = &a5[v23];
  if (*(_DWORD *)a2)
  {
    if (v25 >= 0x80)
    {
      if (v25 >= 0x4000)
      {
        if (v25 >= 0x200000)
        {
          if (v25 >> 28) {
            int v27 = 5;
          }
          else {
            int v27 = 4;
          }
        }
        else
        {
          int v27 = 3;
        }
      }
      else
      {
        int v27 = 2;
      }
    }
    else
    {
      int v27 = 1;
    }
    if (v23 >= 0x80)
    {
      if (v23 >= 0x4000)
      {
        if (v23 >= 0x200000)
        {
          if (v23 >> 28) {
            int v31 = 5;
          }
          else {
            int v31 = 4;
          }
        }
        else
        {
          int v31 = 3;
        }
      }
      else
      {
        int v31 = 2;
      }
    }
    else
    {
      int v31 = 1;
    }
    unint64_t v32 = a6 - *(void *)(a2 + 1084);
    if (v32 >= 0x80)
    {
      if (v32 >= 0x4000)
      {
        if (v32 >= 0x200000)
        {
          if (v32 >> 28)
          {
            if (v32 >> 35)
            {
              if (v32 >> 42)
              {
                if (v32 >> 49)
                {
                  if (HIBYTE(v32)) {
                    int v33 = 9;
                  }
                  else {
                    int v33 = 8;
                  }
                }
                else
                {
                  int v33 = 7;
                }
              }
              else
              {
                int v33 = 6;
              }
            }
            else
            {
              int v33 = 5;
            }
          }
          else
          {
            int v33 = 4;
          }
        }
        else
        {
          int v33 = 3;
        }
      }
      else
      {
        int v33 = 2;
      }
    }
    else
    {
      int v33 = 1;
    }
    uint64_t v35 = *(void *)(a2 + 1092);
    if (v35) {
      BOOL v36 = a7 == 0;
    }
    else {
      BOOL v36 = 1;
    }
    if (v36) {
      uint64_t v35 = 0;
    }
    unint64_t v37 = a7 - v35;
    if (v37 >= 0x80)
    {
      if (v37 >= 0x4000)
      {
        if (v37 >= 0x200000)
        {
          if (v37 >> 28)
          {
            if (v37 >> 35)
            {
              if (v37 >> 42)
              {
                if (v37 >> 49)
                {
                  if (HIBYTE(v37)) {
                    int v38 = 9;
                  }
                  else {
                    int v38 = 8;
                  }
                }
                else
                {
                  int v38 = 7;
                }
              }
              else
              {
                int v38 = 6;
              }
            }
            else
            {
              int v38 = 5;
            }
          }
          else
          {
            int v38 = 4;
          }
        }
        else
        {
          int v38 = 3;
        }
      }
      else
      {
        int v38 = 2;
      }
    }
    else
    {
      int v38 = 1;
    }
    int v34 = v27 + v25 + v31 + v33 + v38;
    goto LABEL_109;
  }
  if (v25 < 0x80)
  {
    int v28 = 1;
    if (v23 < 0x80) {
      goto LABEL_22;
    }
LABEL_28:
    if (v23 >= 0x4000)
    {
      if (v23 >= 0x200000)
      {
        if (v23 >> 28) {
          int v29 = 5;
        }
        else {
          int v29 = 4;
        }
        if (a6 < 0x80) {
          goto LABEL_23;
        }
      }
      else
      {
        int v29 = 3;
        if (a6 < 0x80) {
          goto LABEL_23;
        }
      }
    }
    else
    {
      int v29 = 2;
      if (a6 < 0x80) {
        goto LABEL_23;
      }
    }
LABEL_30:
    if (a6 >= 0x4000)
    {
      if (a6 >= 0x200000)
      {
        if (a6 >> 28) {
          int v30 = 5;
        }
        else {
          int v30 = 4;
        }
      }
      else
      {
        int v30 = 3;
      }
    }
    else
    {
      int v30 = 2;
    }
    goto LABEL_75;
  }
  if (v25 >= 0x4000)
  {
    if (v25 >= 0x200000)
    {
      if (v25 >> 28) {
        int v28 = 5;
      }
      else {
        int v28 = 4;
      }
      if (v23 >= 0x80) {
        goto LABEL_28;
      }
    }
    else
    {
      int v28 = 3;
      if (v23 >= 0x80) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    int v28 = 2;
    if (v23 >= 0x80) {
      goto LABEL_28;
    }
  }
LABEL_22:
  int v29 = 1;
  if (a6 >= 0x80) {
    goto LABEL_30;
  }
LABEL_23:
  int v30 = 1;
LABEL_75:
  int v34 = v28 + v25 + v29 + v30;
LABEL_109:
  unsigned int v39 = v34 + v20;
  if (v34 + (int)v20 > v26)
  {
    if (v26 > 0xFFF7) {
      return 1;
    }
    unint64_t v41 = *(unsigned int *)(a1 + 408);
    uint64_t v71 = 64 << *((unsigned char *)v18 + 2);
    if ((int)v41 < 1)
    {
      unint64_t v45 = -1;
    }
    else
    {
      uint64_t v42 = 54;
      do
      {
        __int16 v43 = *(void **)(a1 + 8 * v42);
        if (v43
          && (unint64_t v44 = v43[1], v44 + 1 >= 2)
          && v44 <= (unint64_t)v18
          && (uint64_t v46 = v43[2], v44 - v46 + v43[3] > (unint64_t)v18))
        {
          unint64_t v45 = (unint64_t)v18 + v46 - v44;
        }
        else
        {
          unint64_t v45 = -1;
        }
        if (v42 - 53 >= v41) {
          break;
        }
        ++v42;
      }
      while (v45 == -1);
    }
    bit_vector_set_3386((void *)(a1 + 4536), (v45 >> 17));
    if ((v45 >> 17) != (v45 + v71) >> 17) {
      bit_vector_set_3386((void *)(a1 + 4536), (v45 >> 17) + 1);
    }
    if (!reallocBlock(a1, a3, v39, a8))
    {
      *(_DWORD *)(a2 + 4) = -1;
      return 1;
    }
    unint64_t v47 = HIDWORD(*a8) ? 0 : (unint64_t)*a8 << 6;
    uint64_t v48 = storageResolvePtr(v72, v47, 8, 1);
    uint64_t v19 = (unsigned __int16 *)storageResolvePtr(v72, v47, 64 << *(unsigned char *)(v48 + 2), 1);
    if (v20 != *v19)
    {
      unsigned int v49 = *(_DWORD **)(a1 + 4576);
      uint64_t v79 = 0;
      int v50 = _fd_acquire_fd((uint64_t)v49, &v79);
      if (v50 != -1)
      {
        int v51 = v50;
        bzero(&v80, 0x878uLL);
        int v52 = fstatfs(v51, &v80);
        _fd_release_fd(v49, v51, 0, v79);
        if (!v52)
        {
          unint64_t v69 = __si_assert_copy_extra_1921(0);
          unsigned int v67 = v69;
          uint64_t v70 = "";
          if (v69) {
            uint64_t v70 = v69;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.c", 594, "(int)pageEnd==storePageEnd(page) || trie_unavailable(t)", v70);
          goto LABEL_160;
        }
      }
    }
  }
  if (*(_DWORD *)a2) {
    unsigned __int16 v53 = FlatStorePageEntryWrite2_2375((uint64_t)v19, &v74, (uint64_t *)(a2 + 1084), v20);
  }
  else {
    unsigned __int16 v53 = FlatStorePageEntryWrite((uint64_t)v19, &v74, v20);
  }
  unsigned __int16 v54 = v53;
  uint64_t v55 = 64 << *((unsigned char *)v19 + 2);
  unint64_t v56 = *(unsigned int *)(a1 + 408);
  if ((int)v56 < 1)
  {
    unint64_t v60 = -1;
  }
  else
  {
    uint64_t v57 = 54;
    do
    {
      uint64_t v58 = *(void **)(a1 + 8 * v57);
      if (v58
        && (unint64_t v59 = v58[1], v59 + 1 >= 2)
        && v59 <= (unint64_t)v19
        && (uint64_t v61 = v58[2], v59 - v61 + v58[3] > (unint64_t)v19))
      {
        unint64_t v60 = (unint64_t)v19 + v61 - v59;
      }
      else
      {
        unint64_t v60 = -1;
      }
      if (v57 - 53 >= v56) {
        break;
      }
      ++v57;
    }
    while (v60 == -1);
  }
  int v62 = (void *)(a1 + 4536);
  bit_vector_set_3386(v62, (v60 >> 17));
  if ((v60 >> 17) != (v60 + v55) >> 17) {
    bit_vector_set_3386(v62, (v60 >> 17) + 1);
  }
  unsigned __int16 *v19 = v54;
  memcpy((void *)(a2 + 1104), a5, a4);
  uint64_t result = 0;
  *(_DWORD *)(a2 + 1100) = a4;
  return result;
}

unint64_t burstFlat(uint64_t a1, int *a2, unsigned int a3, unint64_t a4)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a1 + 160;
  unint64_t v8 = (unint64_t)a3 << 6;
  uint64_t v9 = 64 << *(unsigned char *)(storageResolvePtr(a1 + 160, v8, 8, 1) + 2);
  uint64_t v31 = v7;
  unsigned int v10 = (unsigned char *)storageResolvePtr(v7, v8, v9, 1);
  uint64_t v30 = *(unsigned __int16 *)v10;
  size_t v11 = v30 + 8;
  MEMORY[0x1F4188790](v10);
  unsigned int v13 = (unsigned __int16 *)((char *)&v28 - v12);
  bzero(v41, 0x414uLL);
  memcpy(v13, v10, v11);
  uint64_t v29 = 64 << v10[2];
  unint64_t v14 = *(unsigned int *)(a1 + 408);
  if ((int)v14 < 1)
  {
    unint64_t v19 = -1;
  }
  else
  {
    uint64_t v15 = 54;
    do
    {
      unint64_t v16 = *(void **)(a1 + 8 * v15);
      if (v16
        && (unint64_t v17 = v16[1], v17 + 1 >= 2)
        && v17 <= (unint64_t)v10
        && (uint64_t v18 = v16[2], v17 - v18 + v16[3] > (unint64_t)v10))
      {
        unint64_t v19 = (unint64_t)&v10[v18 - v17];
      }
      else
      {
        unint64_t v19 = -1;
      }
      if (v15 - 53 >= v14) {
        break;
      }
      ++v15;
    }
    while (v19 == -1);
  }
  bit_vector_set_3386((void *)(a1 + 4536), (v19 >> 17));
  if ((v19 >> 17) != (v19 + v29) >> 17) {
    bit_vector_set_3386((void *)(a1 + 4536), (v19 >> 17) + 1);
  }
  storageFreeOffset(v31, v8, 64 << v10[2]);
  int v32 = *a2;
  uint64_t v33 = 0;
  unsigned int v20 = *v13;
  int v35 = 0;
  BOOL v36 = v13 + 4;
  uint64_t v34 = 0;
  uint64_t v37 = 0;
  uint64_t v38 = v20;
  if (v20 != v30)
  {
    uint64_t v23 = __si_assert_copy_extra_1921(*(_DWORD **)(a1 + 376));
    uint64_t v24 = v23;
    unsigned int v25 = "";
    if (v23) {
      unsigned int v25 = v23;
    }
    __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 723, "oldPageEnd == iter.pageEnd", v25);
LABEL_28:
    free(v24);
    if (__valid_fsp(*(_DWORD **)(a1 + 376)))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  long long v39 = 0u;
  for (long long i = 0u;
        FlatStorePageIteratorGetNext((uint64_t)&v32, (uint64_t)&v39);
        a4 = insertFromBurst((void *)a1, (uint64_t)a2, v41, v21, i, *((uint64_t *)&i + 1), a4))
  {
    uint64_t v21 = (v39 + DWORD1(v39));
    if (v21 > 0x413) {
      break;
    }
    memcpy(&v41[DWORD1(v39)], *((const void **)&v39 + 1), v39);
  }
  if (v37 != v38)
  {
    unsigned int v26 = __si_assert_copy_extra_1921(*(_DWORD **)(a1 + 376));
    uint64_t v24 = v26;
    int v27 = "";
    if (v26) {
      int v27 = v26;
    }
    __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 732, "iter.pageCursor==iter.pageEnd", v27);
    goto LABEL_28;
  }
  return a4;
}

uint64_t FlatStorePageIteratorGetNext(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a1 + 32);
  unint64_t v2 = *(void *)(a1 + 40);
  unsigned int v4 = (uint64_t *)(a1 + 32);
  if (v3 >= v2) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 24);
  unint64_t v8 = v3 + 1;
  unsigned int v9 = *(unsigned __int8 *)(v7 + v3);
  if (*(char *)(v7 + v3) < 0)
  {
    if (v9 > 0xBF)
    {
      if (v9 > 0xDF)
      {
        if (v9 > 0xEF)
        {
          unsigned int v9 = *(_DWORD *)(v7 + v8);
          unint64_t v8 = v3 + 5;
        }
        else
        {
          unsigned int v9 = ((v9 & 0xF) << 24) | (*(unsigned __int8 *)(v7 + v8) << 16) | (*(unsigned __int8 *)(v3 + v7 + 2) << 8) | *(unsigned __int8 *)(v3 + v7 + 3);
          unint64_t v8 = v3 + 4;
        }
      }
      else
      {
        unsigned int v9 = ((v9 & 0x1F) << 16) | (*(unsigned __int8 *)(v7 + v8) << 8) | *(unsigned __int8 *)(v3 + v7 + 2);
        unint64_t v8 = v3 + 3;
      }
    }
    else
    {
      int v10 = *(unsigned __int8 *)(v7 + v8) | ((v9 & 0x3F) << 8);
      unint64_t v8 = v3 + 2;
      unsigned int v9 = v10;
    }
  }
  *unsigned int v4 = v8;
  *(_DWORD *)a2 = v9;
  if (v9) {
    BOOL v11 = 1;
  }
  else {
    BOOL v11 = v8 == 1;
  }
  if (!v11)
  {
    uint64_t v24 = __si_assert_copy_extra_1921(0);
    unsigned int v25 = v24;
    unsigned int v26 = "";
    if (v24) {
      unsigned int v26 = v24;
    }
    __message_assert("%s:%u: failed assertion '%s' %s %d, %ld", "FlatStore.h", 431, "entry->len > 0 || iter->pageCursor == v2_vInt32Size(0)", v26, *(_DWORD *)a2, *v4);
    free(v25);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  unint64_t v12 = v8 + 1;
  unsigned int v13 = *(unsigned __int8 *)(v7 + v8);
  if (*(char *)(v7 + v8) < 0)
  {
    if (v13 > 0xBF)
    {
      if (v13 > 0xDF)
      {
        if (v13 > 0xEF)
        {
          unsigned int v13 = *(_DWORD *)(v7 + v12);
          unint64_t v12 = v8 + 5;
        }
        else
        {
          unsigned int v13 = ((v13 & 0xF) << 24) | (*(unsigned __int8 *)(v7 + v12) << 16) | (*(unsigned __int8 *)(v8 + v7 + 2) << 8) | *(unsigned __int8 *)(v8 + v7 + 3);
          unint64_t v12 = v8 + 4;
        }
      }
      else
      {
        unsigned int v13 = ((v13 & 0x1F) << 16) | (*(unsigned __int8 *)(v7 + v12) << 8) | *(unsigned __int8 *)(v8 + v7 + 2);
        unint64_t v12 = v8 + 3;
      }
    }
    else
    {
      int v14 = *(unsigned __int8 *)(v7 + v12) | ((v13 & 0x3F) << 8);
      unint64_t v12 = v8 + 2;
      unsigned int v13 = v14;
    }
  }
  *(_DWORD *)(a2 + 4) = v13;
  *(void *)(a2 + 8) = v7 + v12;
  unint64_t v15 = v12 + v9;
  *unsigned int v4 = v15;
  if (v15 > v2) {
    return 0;
  }
  if (*(_DWORD *)a1)
  {
    uint64_t v17 = *(void *)(a1 + 4);
    unint64_t VInt64_2086 = v2_readVInt64_2086(v7, v4);
    *(void *)(a1 + 4) = VInt64_2086 + v17;
    *(void *)(a2 + 16) = VInt64_2086 + v17;
    unint64_t v19 = v2_readVInt64_2086(*(void *)(a1 + 24), v4);
    if (v19)
    {
      unint64_t v20 = *(void *)(a1 + 12) + v19;
      *(void *)(a1 + 12) = v20;
      *(void *)(a2 + 24) = v20;
    }
    else
    {
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    unint64_t v21 = v15 + 1;
    unsigned int v22 = *(unsigned __int8 *)(v7 + v15);
    if (*(char *)(v7 + v15) < 0)
    {
      if (v22 > 0xBF)
      {
        if (v22 > 0xDF)
        {
          if (v22 > 0xEF)
          {
            unsigned int v22 = *(_DWORD *)(v7 + v21);
            unint64_t v21 = v15 + 5;
          }
          else
          {
            unsigned int v22 = ((v22 & 0xF) << 24) | (*(unsigned __int8 *)(v7 + v21) << 16) | (*(unsigned __int8 *)(v15 + v7 + 2) << 8) | *(unsigned __int8 *)(v15 + v7 + 3);
            unint64_t v21 = v15 + 4;
          }
        }
        else
        {
          unsigned int v22 = ((v22 & 0x1F) << 16) | (*(unsigned __int8 *)(v7 + v21) << 8) | *(unsigned __int8 *)(v15 + v7 + 2);
          unint64_t v21 = v15 + 3;
        }
      }
      else
      {
        int v23 = *(unsigned __int8 *)(v7 + v21) | ((v22 & 0x3F) << 8);
        unint64_t v21 = v15 + 2;
        unsigned int v22 = v23;
      }
    }
    *unsigned int v4 = v21;
    *(_DWORD *)(a2 + 16) = v22;
  }
  if (*(void *)(a1 + 32) > *(void *)(a1 + 40))
  {
    int v27 = __si_assert_copy_extra_1921(0);
    uint64_t v28 = v27;
    uint64_t v29 = "";
    if (v27) {
      uint64_t v29 = v27;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.h", 470, "iter->pageCursor <= iter->pageEnd", v29);
    free(v28);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return 1;
}

unint64_t dumpFlatData(uint64_t a1, char a2, uint64_t *a3, unsigned int a4, int a5, uint64_t a6, _DWORD *a7, void (*a8)(uint64_t, unsigned char *, void, void, uint64_t), uint64_t a9)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  unint64_t v15 = (unint64_t)a4 << 6;
  ptr = (unsigned __int16 *)storage_reader_get_ptr(*a3, a3[1], v15, 8);
  if (ptr == (unsigned __int16 *)-1) {
    goto LABEL_37;
  }
  uint64_t v17 = ptr;
  uint64_t v44 = a1;
  unsigned int v18 = *ptr;
  unsigned int v19 = *((unsigned __int8 *)ptr + 2);
  uint64_t v20 = ((64 << v19) - 8);
  if (v20 < v18)
  {
    if (!isExFat(*(_DWORD *)(v44 + 152)) && !isMsDos(*(_DWORD *)(v44 + 152)) && !isFat32(*(_DWORD *)(v44 + 152)))
    {
      uint64_t v38 = __si_assert_copy_extra_1921(*(_DWORD **)(v44 + 376));
      long long v39 = v38;
      unsigned int v40 = "";
      if (v38) {
        unsigned int v40 = v38;
      }
      __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 768, "pageEnd <= pageSize", v40);
      free(v39);
      if (__valid_fsp(*(_DWORD **)(v44 + 376)))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    uint64_t v33 = __si_assert_copy_extra_1921(*(_DWORD **)(v44 + 376));
    si_analytics_log_2351("%s:%u: failure log '%s' %s flat store, pageSize = %u, pageEnd = %u");
    goto LABEL_36;
  }
  if (v19 >= 0x1A && (a2 & 1) == 0)
  {
    if (!isExFat(*(_DWORD *)(v44 + 152)) && !isMsDos(*(_DWORD *)(v44 + 152)) && !isFat32(*(_DWORD *)(v44 + 152)))
    {
      unint64_t v41 = __si_assert_copy_extra_1921(*(_DWORD **)(v44 + 376));
      uint64_t v42 = v41;
      __int16 v43 = "";
      if (v41) {
        __int16 v43 = v41;
      }
      __message_assert("%s:%u: failed assertion '%s' %s flat store, pageSize = %u, sizeShift = %d", "FlatStore.c", 778, "__builtin_popcount(pageSize+(uint32_t)sizeof(*page)) == 1", v43, v20, *((unsigned __int8 *)v17 + 2));
      free(v42);
      if (__valid_fsp(*(_DWORD **)(v44 + 376)))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    uint64_t v33 = __si_assert_copy_extra_1921(*(_DWORD **)(v44 + 376));
    si_analytics_log_2351("%s:%u: failure log '%s' %s flat store, pageSize = %u, sizeShift = %d");
LABEL_36:
    free(v33);
    goto LABEL_37;
  }
  uint64_t v21 = storage_reader_get_ptr(*a3, a3[1], v15, v20 + 8);
  if (v21 == -1)
  {
LABEL_37:
    unint64_t result = 0;
    *a7 = 1;
    return result;
  }
  unsigned int v22 = (unsigned __int16 *)v21;
  bzero(v53, 0x414uLL);
  __memcpy_chk();
  *(_OWORD *)long long __src = 0u;
  long long v52 = 0u;
  *(void *)&v47[4] = 0;
  uint64_t v23 = v44;
  int v24 = *(_DWORD *)(v44 + 4584);
  if ((a2 & 1) == 0)
  {
    if (!v24) {
      goto LABEL_8;
    }
LABEL_20:
    uint64_t v30 = __si_assert_copy_extra_1921(0);
    uint64_t v31 = v30;
    int v32 = "";
    if (v30) {
      int v32 = v30;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.c", 796, "(!compacted && t->type==kTermInfoTypeId) || (compacted && t->type!=kTermInfoTypeId)", v32);
    free(v31);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (!v24) {
    goto LABEL_20;
  }
LABEL_8:
  uint64_t v25 = 0;
  int v45 = *(_DWORD *)(v44 + 4584);
  *(void *)unint64_t v47 = 0;
  uint64_t v46 = 0;
  uint64_t v26 = *v22;
  uint64_t v48 = v22 + 4;
  uint64_t v49 = 0;
  uint64_t v50 = v26;
  if (!*a7)
  {
    do
    {
      if (!FlatStorePageIteratorGetNext((uint64_t)&v45, (uint64_t)__src)) {
        break;
      }
      uint64_t v27 = (HIDWORD(__src[0]) + a5 + LODWORD(__src[0]));
      if (v27 > 0x413) {
        break;
      }
      memcpy(&v53[a5 + HIDWORD(__src[0])], __src[1], LODWORD(__src[0]));
      v53[v27] = 0;
      a8(v27, v53, v52, *((void *)&v52 + 1), a9);
    }
    while (!*a7);
    uint64_t v25 = v49;
    uint64_t v26 = v50;
    uint64_t v23 = v44;
  }
  if (*a7) {
    BOOL v28 = 1;
  }
  else {
    BOOL v28 = v25 == v26;
  }
  if (!v28)
  {
    uint64_t v34 = __si_assert_copy_extra_1921(*(_DWORD **)(v23 + 376));
    int v35 = v34;
    BOOL v36 = "";
    if (v34) {
      BOOL v36 = v34;
    }
    __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 808, "*canceled || iter.pageCursor==iter.pageEnd", v36);
    free(v35);
    if (__valid_fsp(*(_DWORD **)(v23 + 376))) {
      uint64_t v37 = 2989;
    }
    else {
      uint64_t v37 = 3072;
    }
    *(_DWORD *)uint64_t v37 = -559038737;
    abort();
  }
  return v15 + v18;
}

uint64_t flatLastCompactTermOffset(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = 0;
  if (!HIDWORD(a2) && a2)
  {
    if (*(_DWORD *)(a1 + 4584) == 1
      && (unint64_t v4 = (unint64_t)a2 << 6,
          unsigned int v5 = (unsigned __int16 *)storageResolvePtr(a1 + 160, v4, 8, 1),
          (unint64_t)v5 + 1 >= 2)
      && (unsigned int v6 = *v5,
          uint64_t v7 = ((64 << *((unsigned char *)v5 + 2)) - 8),
          unint64_t v8 = (unsigned __int16 *)storageResolvePtr(a1 + 160, v4, v7 + 8, 1),
          (unint64_t)v8 + 1 >= 2)
      && v7 >= v6)
    {
      uint64_t v2 = 0;
      long long v18 = 0u;
      long long v19 = 0u;
      int v11 = *(_DWORD *)(a1 + 4584);
      uint64_t v10 = *v8;
      uint64_t v12 = 0;
      int v14 = 0;
      unint64_t v15 = v8 + 4;
      uint64_t v13 = 0;
      uint64_t v16 = 0;
      uint64_t v17 = v10;
      while (FlatStorePageIteratorGetNext((uint64_t)&v11, (uint64_t)&v18))
        uint64_t v2 = v19;
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t _indexMarkInvalid(uint64_t result)
{
  if (result) {
    *(unsigned char *)(result + 8) = 0;
  }
  return result;
}

uint64_t _indexMatchAddress(uint64_t result, unint64_t a2)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uint64_t v3 = result;
    unint64_t v4 = *(void *)(result + 14408);
    if (v4 + 1 >= 2 && v4 <= a2)
    {
      unint64_t v9 = *(unsigned int *)(result + 72);
      if (v4 + 8 * v9 > a2)
      {
        uint64_t v10 = *(void *)(result + 14448);
        int v11 = "index docId array";
        goto LABEL_95;
      }
    }
    unint64_t v4 = *(void *)(result + 14416);
    if (v4 + 1 >= 2 && v4 <= a2)
    {
      unint64_t v9 = *(unsigned int *)(result + 72);
      if (v4 + 4 * v9 > a2)
      {
        uint64_t v10 = *(void *)(result + 14456);
        int v11 = "index date array";
        goto LABEL_95;
      }
    }
    unint64_t v4 = *(void *)(result + 14424);
    if (v4 + 1 >= 2 && v4 <= a2)
    {
      unint64_t v9 = *(unsigned int *)(result + 72);
      if (v4 + 8 * v9 > a2)
      {
        uint64_t v10 = *(void *)(result + 14464);
        int v11 = "index score array";
        goto LABEL_95;
      }
    }
    unint64_t v4 = *(void *)(result + 14432);
    if (v4 + 1 >= 2 && v4 <= a2)
    {
      unint64_t v9 = *(unsigned int *)(result + 72);
      if (!*(unsigned char *)(result + 45)) {
        unint64_t v9 = (4 * v9 + 4) / 5uLL;
      }
      if (v4 + v9 > a2)
      {
        uint64_t v10 = *(void *)(result + 14472);
        int v11 = "index group array";
        goto LABEL_95;
      }
    }
    unint64_t v4 = *(void *)(result + 112);
    if (v4 + 1 >= 2 && v4 <= a2)
    {
      unint64_t v9 = *(void *)(result + 136);
      if (v4 + v9 > a2)
      {
        uint64_t v10 = *(void *)(result + 208);
        int v11 = "bases";
        goto LABEL_95;
      }
    }
    unint64_t v4 = *(void *)(result + 104);
    if (v4 + 1 >= 2 && v4 <= a2)
    {
      unint64_t v9 = *(unsigned int *)(result + 244);
      if (v4 + 1028 * v9 > a2)
      {
        uint64_t v10 = *(void *)(result + 4672);
        int v11 = "fat bases";
LABEL_95:
        log_map_access_error(a2, v4, v9, (uint64_t)v11, v10);
        return 1;
      }
    }
    unint64_t v12 = *(unsigned int *)(result + 504);
    if ((int)v12 >= 1)
    {
      uint64_t v13 = 66;
      do
      {
        int v14 = *(void **)(result + 8 * v13);
        if (v14 && (unint64_t v15 = v14[1], v15 + 1 >= 2) && v15 <= a2 && (v17 = v14[2], v15 - v17 + v14[3] > a2)) {
          uint64_t v16 = a2 - v15 + v17;
        }
        else {
          uint64_t v16 = -1;
        }
        if (v13 - 65 >= v12) {
          break;
        }
        ++v13;
      }
      while (v16 == -1);
      if (v16 != -1)
      {
        long long v60 = 0u;
        long long v61 = 0u;
        long long v58 = 0u;
        long long v59 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        *(_OWORD *)std::string __str = 0u;
        long long v47 = 0u;
        uint64_t v18 = result + 15208;
        int v19 = snprintf(__str, 0xFFuLL, "c:%d s:%lld", v12, *(void *)(result + 480));
        if (*(int *)(v3 + 504) >= 1 && v19 <= 0xFE)
        {
          uint64_t v20 = 0;
          uint64_t v21 = &__str[v19];
          size_t v22 = 255 - v19;
          do
          {
            snprintf(v21, v22, "%d:(mem:%p so:%lld eo:%lld)", v20, *(const void **)(*(void *)(v3 + 528 + 8 * v20) + 8), *(void *)(*(void *)(v3 + 528 + 8 * v20) + 16), *(void *)(*(void *)(v3 + 528 + 8 * v20) + 24));
            ++v20;
          }
          while (v20 < *(int *)(v3 + 504));
        }
        uint64_t v23 = *(void *)(v3 + 472);
        goto LABEL_89;
      }
    }
    unint64_t v24 = *(unsigned int *)(result + 5232);
    if ((int)v24 >= 1)
    {
      uint64_t v25 = 657;
      do
      {
        uint64_t v26 = *(void **)(result + 8 * v25);
        if (v26 && (unint64_t v27 = v26[1], v27 + 1 >= 2) && v27 <= a2 && (v29 = v26[2], v27 - v29 + v26[3] > a2)) {
          uint64_t v28 = a2 - v27 + v29;
        }
        else {
          uint64_t v28 = -1;
        }
        if (v25 - 656 >= v24) {
          break;
        }
        ++v25;
      }
      while (v28 == -1);
      if (v28 != -1)
      {
        long long v60 = 0u;
        long long v61 = 0u;
        long long v58 = 0u;
        long long v59 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        *(_OWORD *)std::string __str = 0u;
        long long v47 = 0u;
        uint64_t v18 = result + 15208;
        int v30 = snprintf(__str, 0xFFuLL, "c:%d s:%lld", v24, *(void *)(result + 5208));
        if (*(int *)(v3 + 5232) >= 1 && v30 <= 0xFE)
        {
          uint64_t v31 = 0;
          int v32 = &__str[v30];
          size_t v33 = 255 - v30;
          do
          {
            snprintf(v32, v33, "%d:(mem:%p so:%lld eo:%lld)", v31, *(const void **)(*(void *)(v3 + 5256 + 8 * v31) + 8), *(void *)(*(void *)(v3 + 5256 + 8 * v31) + 16), *(void *)(*(void *)(v3 + 5256 + 8 * v31) + 24));
            ++v31;
          }
          while (v31 < *(int *)(v3 + 5232));
        }
        uint64_t v23 = *(void *)(v3 + 5200);
        goto LABEL_89;
      }
    }
    unint64_t v34 = *(unsigned int *)(result + 9952);
    if ((int)v34 >= 1)
    {
      uint64_t v35 = 1247;
      do
      {
        BOOL v36 = *(void **)(result + 8 * v35);
        if (v36 && (v37 = v36[1], v37 + 1 >= 2) && v37 <= a2 && (uint64_t v38 = v36[2], v37 - v38 + v36[3] > a2)) {
          uint64_t v39 = a2 - v37 + v38;
        }
        else {
          uint64_t v39 = -1;
        }
        if (v35 - 1246 >= v34) {
          break;
        }
        ++v35;
      }
      while (v39 == -1);
      if (v39 != -1)
      {
        long long v60 = 0u;
        long long v61 = 0u;
        long long v58 = 0u;
        long long v59 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        *(_OWORD *)std::string __str = 0u;
        long long v47 = 0u;
        uint64_t v18 = result + 15208;
        int v40 = snprintf(__str, 0xFFuLL, "c:%d s:%lld", v34, *(void *)(result + 9928));
        if (*(int *)(v3 + 9952) >= 1 && v40 <= 0xFE)
        {
          uint64_t v41 = 0;
          uint64_t v42 = &__str[v40];
          size_t v43 = 255 - v40;
          do
          {
            snprintf(v42, v43, "%d:(mem:%p so:%lld eo:%lld)", v41, *(const void **)(*(void *)(v3 + 9976 + 8 * v41) + 8), *(void *)(*(void *)(v3 + 9976 + 8 * v41) + 16), *(void *)(*(void *)(v3 + 9976 + 8 * v41) + 24));
            ++v41;
          }
          while (v41 < *(int *)(v3 + 9952));
        }
        uint64_t v23 = *(void *)(v3 + 9920);
        goto LABEL_89;
      }
    }
    uint64_t v44 = *(void *)(result + 4928);
    if (v44 && _windowsAddressOffset(v44 + 224, a2) != -1)
    {
      long long v60 = 0u;
      long long v61 = 0u;
      long long v58 = 0u;
      long long v59 = 0u;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      uint64_t v18 = v3 + 15208;
      *(_OWORD *)std::string __str = 0u;
      long long v47 = 0u;
      storage_describe_windows(v44 + 8, __str);
      uint64_t v23 = *(void *)(*(void *)(v3 + 4928) + 224);
LABEL_89:
      uint64_t v45 = v18;
LABEL_90:
      log_map_access_error_mini(v45, a2, (uint64_t)__str, v23);
      return 1;
    }
    unint64_t result = *(void *)(v3 + 4912);
    if (result)
    {
      unint64_t result = vectorIndexValidAddress(result, a2);
      if (result)
      {
        uint64_t v45 = v3 + 15208;
        long long v60 = 0u;
        long long v61 = 0u;
        long long v58 = 0u;
        long long v59 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        *(_OWORD *)std::string __str = 0u;
        long long v47 = 0u;
        uint64_t v23 = *(void *)(*(void *)(v3 + 4928) + 224);
        goto LABEL_90;
      }
    }
  }
  return result;
}

int *log_map_access_error(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (a5) {
    int v9 = *(_DWORD *)(a5 + 44);
  }
  else {
    int v9 = -1;
  }
  memset(&v15, 0, sizeof(v15));
  memset(v38, 0, sizeof(v38));
  uint64_t v10 = fd_name(a5, (char *)v38, 0x100uLL);
  int v11 = fstatat(v9, v10, &v15, 32);
  int v12 = *__error();
  uint64_t v13 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)iovec buf = 136317698;
    uint64_t v17 = "log_map_access_error";
    __int16 v18 = 1024;
    int v19 = 4983;
    __int16 v20 = 2080;
    uint64_t v21 = a4;
    __int16 v22 = 2080;
    uint64_t v23 = v10;
    __int16 v24 = 2048;
    uint64_t v25 = a1;
    __int16 v26 = 2048;
    uint64_t v27 = a2;
    __int16 v28 = 2048;
    uint64_t v29 = a2 + a3;
    __int16 v30 = 1024;
    int v31 = v11;
    __int16 v32 = 2048;
    st_std::string::size_type size = v15.st_size;
    __int16 v34 = 1024;
    dev_t st_dev = v15.st_dev;
    __int16 v36 = 2048;
    __darwin_ino64_t st_ino = v15.st_ino;
    _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Got exception on %s %s addr:%p start:%p map end:%p sres:%d file_size:%lld dev:%d ino:%lld", buf, 0x64u);
  }
  unint64_t result = __error();
  *unint64_t result = v12;
  return result;
}

int *log_map_access_error_mini(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (a4) {
    int v7 = *(_DWORD *)(a4 + 44);
  }
  else {
    int v7 = -1;
  }
  memset(&v13, 0, sizeof(v13));
  memset(v34, 0, sizeof(v34));
  unint64_t v8 = fd_name(a4, (char *)v34, 0x100uLL);
  int v9 = fstatat(v7, v8, &v13, 32);
  int v10 = *__error();
  int v11 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)iovec buf = 136317442;
    stat v15 = "log_map_access_error_mini";
    __int16 v16 = 1024;
    int v17 = 4993;
    __int16 v18 = 2080;
    uint64_t v19 = a1;
    __int16 v20 = 2080;
    uint64_t v21 = v8;
    __int16 v22 = 2048;
    uint64_t v23 = a2;
    __int16 v24 = 2080;
    uint64_t v25 = a3;
    __int16 v26 = 1024;
    int v27 = v9;
    __int16 v28 = 2048;
    st_std::string::size_type size = v13.st_size;
    __int16 v30 = 1024;
    dev_t st_dev = v13.st_dev;
    __int16 v32 = 2048;
    __darwin_ino64_t st_ino = v13.st_ino;
    _os_log_error_impl(&dword_1BD672000, v11, OS_LOG_TYPE_ERROR, "%s:%d: Got exception on %s %s addr:%p %s sres:%d file_size:%lld dev:%d ino:%lld", buf, 0x5Au);
  }
  unint64_t result = __error();
  *unint64_t result = v10;
  return result;
}

uint64_t indexCopyDeleteDocIds(uint64_t a1, int a2, CFIndex **a3)
{
  if (a2) {
    db_read_lock(a1 + 14504);
  }
  CFIndex v6 = *(unsigned int *)(a1 + 68);
  int v7 = (CFIndex *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
  if (!v7)
  {
    __int16 v20 = __si_assert_copy_extra_2445(0, -1);
    uint64_t v21 = v20;
    __int16 v22 = "";
    if (v20) {
      __int16 v22 = v20;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 41, "bv", v22);
LABEL_33:
    free(v21);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  unint64_t v8 = v7;
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (v6 <= 128) {
    CFIndex v6 = 128;
  }
  *unint64_t v8 = 0;
  v8[1] = v6;
  CFSetRef Mutable = CFBitVectorCreateMutable(v9, v6);
  v8[2] = (CFIndex)Mutable;
  CFBitVectorSetCount(Mutable, v6);
  if (!v8[2])
  {
    uint64_t v23 = __si_assert_copy_extra_2445(0, -1);
    uint64_t v21 = v23;
    __int16 v24 = "";
    if (v23) {
      __int16 v24 = v23;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 47, "bv->_cfbv", v24);
    goto LABEL_33;
  }
  unint64_t v11 = *(unsigned int *)(a1 + 68);
  if (v11 < 2)
  {
    uint64_t v12 = 0;
    goto LABEL_22;
  }
  uint64_t v12 = 0;
  unsigned int v13 = -1;
  unint64_t v14 = 1;
  char v15 = 6;
  int v16 = 1;
  int v17 = -1;
  do
  {
    if (*(unsigned char *)(a1 + 45))
    {
      if ((*(unsigned char *)(*(void *)(a1 + 14432) + v14) & 0xDF) == 0) {
        goto LABEL_9;
      }
    }
    else if (((*(_DWORD *)(*(void *)(a1 + 14432) {
                          + (((3435973837u * (unint64_t)v14) >> 32) & 0xFFFFFFFC)) >> (v15 - 30 * (v14 / 5))) & 0x1F) == 0)
    }
    {
LABEL_9:
      if (v13 == -1) {
        unsigned int v13 = v14;
      }
      uint64_t v12 = (v12 + 1);
      int v17 = v14;
      goto LABEL_12;
    }
    if (v13 != -1)
    {
      bit_vector_set_bits(v8, v13, (v17 + v16 + 1));
      unint64_t v11 = *(unsigned int *)(a1 + 68);
      int v17 = -1;
      unsigned int v13 = -1;
    }
LABEL_12:
    ++v14;
    int v16 = -v13;
    v15 += 6;
  }
  while (v14 < v11);
  if (v13 != -1) {
    bit_vector_set_bits(v8, v13, v17 - v13 + 1);
  }
LABEL_22:
  if (a2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 14504));
    int v18 = *(_DWORD *)(a1 + 14700) - 1;
    *(_DWORD *)(a1 + 14700) = v18;
    if (!v18) {
      db_rwlock_wakeup(a1 + 14504, 0, 0);
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14504));
  }
  *a3 = v8;
  return v12;
}

char *__si_assert_copy_extra_2445(_DWORD *a1, int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  bzero(v14, 0x400uLL);
  if (a1)
  {
    unsigned int v13 = 0;
    int v4 = _fd_acquire_fd((uint64_t)a1, &v13);
    if (v4 != -1)
    {
      int v5 = v4;
      CFIndex v6 = v14;
      int v7 = fcntl(v4, 50, v14);
      int v8 = v14[0];
      _fd_release_fd(a1, v5, 0, (uint64_t)v13);
      if ((v7 & 0x80000000) == 0)
      {
        if (v8) {
          goto LABEL_12;
        }
      }
    }
  }
  else if (a2 != -1)
  {
    CFIndex v6 = v14;
    if ((fcntl(a2, 50, v14) & 0x80000000) == 0)
    {
      if (v14[0]) {
        goto LABEL_12;
      }
    }
  }
  CFAllocatorRef v9 = getcwd(v14, 0x400uLL);
  if (v9) {
    CFIndex v6 = v9;
  }
  else {
    CFIndex v6 = "";
  }
LABEL_12:
  unsigned int v13 = 0;
  int v10 = (const char *)pthread_getspecific(__THREAD_STR_DATA_KEY);
  if (v10) {
    unint64_t v11 = v10;
  }
  else {
    unint64_t v11 = "";
  }
  asprintf(&v13, "%s %s", v6, v11);
  return v13;
}

void bit_vector_set_bits(CFIndex *a1, CFIndex a2, CFIndex a3)
{
  if (a2 < 0)
  {
    int v8 = __si_assert_copy_extra_2445(0, -1);
    CFAllocatorRef v9 = v8;
    int v10 = "";
    if (v8) {
      int v10 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 151, "range.location >= 0", v10);
    free(v9);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (a3 >= 1)
  {
    bit_vector_internal_touch_for_set(a1, a3 + a2 - 1);
    CFIndex v6 = (__CFBitVector *)a1[2];
    v7.locatiouint64_t n = a2;
    v7.uint64_t length = a3;
    CFBitVectorSetBits(v6, v7, 1u);
  }
}

void bit_vector_internal_touch_for_set(CFIndex *a1, CFIndex a2)
{
  CFIndex v4 = a1[1];
  if (v4 <= a2)
  {
    if (v4) {
      CFIndex v5 = a1[1];
    }
    else {
      CFIndex v5 = 32;
    }
    while (1)
    {
      v5 *= 2;
      if (v5 > a2) {
        break;
      }
      if (v5 <= v4)
      {
        CFIndex v6 = __si_assert_copy_extra_2445(0, -1);
        CFRange v7 = v6;
        int v8 = "";
        if (v6) {
          int v8 = v6;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v8);
        goto LABEL_13;
      }
    }
    CFBitVectorRef v9 = (const __CFBitVector *)a1[2];
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (v9) {
      CFMutableStringRef MutableCopy = CFBitVectorCreateMutableCopy(v10, v5, v9);
    }
    else {
      CFMutableStringRef MutableCopy = CFBitVectorCreateMutable(v10, v5);
    }
    uint64_t v12 = MutableCopy;
    if (!MutableCopy)
    {
      unint64_t v14 = __si_assert_copy_extra_2445(0, -1);
      CFRange v7 = v14;
      uint64_t v15 = "";
      if (v14) {
        uint64_t v15 = v14;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v15);
LABEL_13:
      free(v7);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    CFBitVectorSetCount(MutableCopy, v5);
    unsigned int v13 = (const void *)a1[2];
    if (v13) {
      CFRelease(v13);
    }
    a1[1] = v5;
    a1[2] = (CFIndex)v12;
  }
  if (*a1 <= a2) {
    *a1 = a2 + 1;
  }
}

{
  CFIndex v4;
  CFIndex v5;
  char *v6;
  char *v7;
  const char *v8;
  CFBitVectorRef v9;
  CFAllocatorRef v10;
  __CFBitVector *MutableCopy;
  __CFBitVector *v12;
  const void *v13;
  char *v14;
  const char *v15;

  CFIndex v4 = a1[1];
  if (v4 <= a2)
  {
    if (v4) {
      CFIndex v5 = a1[1];
    }
    else {
      CFIndex v5 = 32;
    }
    while (1)
    {
      v5 *= 2;
      if (v5 > a2) {
        break;
      }
      if (v5 <= v4)
      {
        CFIndex v6 = __si_assert_copy_extra_329();
        CFRange v7 = v6;
        int v8 = "";
        if (v6) {
          int v8 = v6;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v8);
        goto LABEL_13;
      }
    }
    CFBitVectorRef v9 = (const __CFBitVector *)a1[2];
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (v9) {
      CFMutableStringRef MutableCopy = CFBitVectorCreateMutableCopy(v10, v5, v9);
    }
    else {
      CFMutableStringRef MutableCopy = CFBitVectorCreateMutable(v10, v5);
    }
    uint64_t v12 = MutableCopy;
    if (!MutableCopy)
    {
      unint64_t v14 = __si_assert_copy_extra_329();
      CFRange v7 = v14;
      uint64_t v15 = "";
      if (v14) {
        uint64_t v15 = v14;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v15);
LABEL_13:
      free(v7);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    CFBitVectorSetCount(MutableCopy, v5);
    unsigned int v13 = (const void *)a1[2];
    if (v13) {
      CFRelease(v13);
    }
    a1[1] = v5;
    a1[2] = (CFIndex)v12;
  }
  if (*a1 <= a2) {
    *a1 = a2 + 1;
  }
}

uint64_t index_FlushCache(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  kern_return_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unint64_t v22;
  signed int v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  pthread_override_s *v28;
  char v29;
  uint64_t v30;
  unsigned int v31;
  unint64_t v32;
  signed int v33;
  uint64_t v34;
  void *v35;
  char v36;
  uint64_t v37;
  double Current;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  char v42;
  double v43;
  void *v44;
  const void *v45;
  __int16 v46;
  int v47;
  int v48;
  NSObject *v49;
  unsigned int v50;
  unint64_t v51;
  signed int v52;
  uint64_t v53;
  int v54;
  NSObject *v55;
  uint64_t v56;
  int8x16_t v57;
  int8x16_t v58;
  int8x16_t v59;
  int8x16_t v60;
  int8x16_t v61;
  int8x16_t v62;
  uint64_t v63;
  int8x16_t v64;
  unint64_t v65;
  int v66;
  NSObject *v67;
  os_log_type_t v68;
  uint64_t v69;
  uint64_t v70;
  char v71;
  unsigned int v72;
  int v73;
  NSObject *v74;
  os_log_type_t v75;
  integer_t v76;
  integer_t v77;
  pthread_override_s *v78;
  char v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t *v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  uint64_t *v88;
  uint64_t v89;
  char *v90;
  char *v91;
  const char *v92;
  uint64_t v93;
  unint64_t v94;
  mach_msg_type_number_t host_info_outCnt;
  integer_t host_info_out[12];
  uint64_t v97;

  int v97 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = a1 + 14932;
  unint64_t v11 = index_FlushCache_physMem;
  if (index_FlushCache_physMem)
  {
    if (*(unsigned char *)(a1 + 15203))
    {
LABEL_3:
      if ((index_FlushCache__COUNT_ & 1) == 0)
      {
        index_FlushCache__COUNT_ = 1;
        int v12 = *__error();
        unsigned int v13 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          host_info_out[0] = 136315650;
          *(void *)&host_info_out[1] = "index_FlushCache";
          LOWORD(host_info_out[3]) = 1024;
          *(integer_t *)((char *)&host_info_out[3] + 2) = 310;
          HIWORD(host_info_out[4]) = 2080;
          *(void *)&host_info_out[5] = a1 + 15208;
          _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: trying to modify read only index %s", (uint8_t *)host_info_out, 0x1Cu);
        }
        *__error() = v12;
      }
      (*(void (**)(uint64_t))(a5 + 16))(a5);
      return 1;
    }
  }
  else
  {
    memset(host_info_out, 0, sizeof(host_info_out));
    mach_msg_type_number_t host_info_outCnt = 12;
    host_t v16 = MEMORY[0x1C1881C90]();
    int v17 = host_info(v16, 1, host_info_out, &host_info_outCnt);
    int v18 = *(void *)&host_info_out[10];
    if (*(void *)&host_info_out[10] >= 0x80000000uLL) {
      int v18 = 0x80000000;
    }
    if (v17) {
      unint64_t v11 = 0x40000000;
    }
    else {
      unint64_t v11 = v18;
    }
    index_FlushCache_physMeuint64_t m = v11;
    if (*(unsigned char *)(v10 + 271)) {
      goto LABEL_3;
    }
  }
  if (!*(void *)(a1 + 14392))
  {
    (*(void (**)(uint64_t))(a5 + 16))(a5);
    return 0;
  }
  uint64_t v19 = v11 >> 3;
  __int16 v20 = (v11 >> 3) - 0x800000;
  if (v11 <= 0x40000007) {
    __int16 v20 = v11 >> 3;
  }
  int v93 = *MEMORY[0x1E4F14B00];
  int v94 = v20;
  HIDWORD(v22) = qos_class_self() - 9;
  LODWORD(v22) = HIDWORD(v22);
  uint64_t v21 = v22 >> 2;
  if (v21 > 6) {
    uint64_t v23 = 0;
  }
  else {
    uint64_t v23 = dword_1BDA87810[v21];
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 14720));
  if (*(void *)(a1 + 14904) || *(_DWORD *)(a1 + 14916) || *(unsigned char *)v10) {
    goto LABEL_25;
  }
  if (v23 <= 5)
  {
    if (*(void *)(a1 + 16 * v23 + 14784))
    {
LABEL_25:
      db_rwlock_wait(a1 + 14720, v23, 2);
      goto LABEL_26;
    }
    statfs v80 = v23 - 1;
    uint64_t v81 = (uint64_t *)(a1 + 16 * v23 + 14800);
    while (v80 != 4)
    {
      int v82 = *v81;
      v81 += 2;
      ++v80;
      if (v82)
      {
        if (v80 <= 4) {
          goto LABEL_25;
        }
        break;
      }
    }
  }
  *(void *)(a1 + 14904) = pthread_self();
LABEL_26:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14720));
  if (*(void *)(a1 + 14400))
  {
    int v90 = __si_assert_copy_extra_2445(0, *(_DWORD *)(a1 + 64));
    unsigned int v91 = v90;
    int v92 = "";
    if (v90) {
      int v92 = v90;
    }
    __message_assert("%s:%u: failed assertion '%s' %s Expected cindex->_oldSet==0, got %p", "JHContentIndex.c", 408, "cindex->_oldSet==0", v92, *(const void **)(a1 + 14400));
    free(v91);
    if (__valid_fs(*(_DWORD *)(a1 + 64)))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  __int16 v24 = *(void *)(a1 + 14392);
  *(void *)(a1 + 14400) = v24;
  TermUpdateSetRemoveFromAccounting(v24);
  uint64_t v25 = *(_DWORD *)(a1 + 68);
  __int16 v26 = 32 * *(unsigned __int8 *)(a1 + 46);
  *(unsigned char *)(v10 + 732) = 0;
  *(void *)(a1 + 14392) = TermUpdateSetCreate((uint64_t (*)())_indexProgress, a1, *(void *)(a1 + 80), v25, v26, *(void *)(a1 + 14384), *(unsigned int *)(a1 + 56), *(const void **)(a1 + 4936));
  (*(void (**)(uint64_t))(a5 + 16))(a5);
  int v27 = *(void *)(a1 + 14392);
  if (v27)
  {
    if (*(unsigned char *)(v10 + 270)) {
      *(void *)(v27 + 608) = getPropertyStringCallback;
    }
    *(void *)(v27 + 280) = a1 + 14184;
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 14720));
  *(_DWORD *)(a1 + 14924) = 0;
  __int16 v28 = *(pthread_override_s **)(a1 + 14896);
  *(void *)(a1 + 14904) = 0;
  *(void *)(a1 + 14896) = 0;
  uint64_t v29 = *(_DWORD *)(a1 + 14916) != 0;
  *(unsigned char *)uint64_t v10 = 0;
  db_rwlock_wakeup(a1 + 14720, v29, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14720));
  if (v28) {
    pthread_override_qos_class_end_np(v28);
  }
  __int16 v30 = *(void *)(a1 + 14400);
  if (a2)
  {
    if (!v30)
    {
      HIDWORD(v32) = qos_class_self() - 9;
      LODWORD(v32) = HIDWORD(v32);
      int v31 = v32 >> 2;
      if (v31 > 6) {
        size_t v33 = 0;
      }
      else {
        size_t v33 = dword_1BDA87810[v31];
      }
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 14720));
      if (*(void *)(a1 + 14904) || *(_DWORD *)(a1 + 14916) || *(unsigned char *)v10) {
        goto LABEL_91;
      }
      if (v33 <= 5)
      {
        if (*(void *)(a1 + 16 * v33 + 14784))
        {
LABEL_91:
          db_rwlock_wait(a1 + 14720, v33, 2);
          goto LABEL_92;
        }
        int v87 = v33 - 1;
        size_t v88 = (uint64_t *)(a1 + 16 * v33 + 14800);
        while (v87 != 4)
        {
          unsigned int v89 = *v88;
          v88 += 2;
          ++v87;
          if (v89)
          {
            if (v87 <= 4) {
              goto LABEL_91;
            }
            break;
          }
        }
      }
      *(void *)(a1 + 14904) = pthread_self();
LABEL_92:
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14720));
      if (!v25) {
        goto LABEL_66;
      }
LABEL_65:
      *(void *)(a1 + 4960) = *(void *)(a1 + 4952);
      *(void *)(a1 + 9680) = *(void *)(a1 + 9672);
      *(_DWORD *)(a1 + 60) = v25 - 1;
      goto LABEL_66;
    }
  }
  else
  {
    *(void *)(v30 + 592) = _termUpdateSetProgress;
    *(void *)(v30 + 600) = 0;
  }
  __int16 v34 = *(void *)(a1 + 15576);
  **(void **)(a1 + 104) = v34;
  **(void **)(a1 + 112) = v34;
  uint64_t v35 = (void *)storageResolvePtr(a1 + 256, 0, 8, 1);
  if (v35)
  {
    *uint64_t v35 = *(void *)(a1 + 15576);
    mach_msg_type_number_t host_info_outCnt = 0;
    *(void *)host_info_out = 0;
    __int16 v36 = atomic_load((unsigned int *)(a1 + 36));
    if ((v36 & 0xC) == 8) {
      indexCopyDeleteDocIds(a1, a2 ^ 1, (CFIndex **)host_info_out);
    }
    unint64_t v37 = *(void *)(a1 + 4928);
    double Current = CFAbsoluteTimeGetCurrent();
    uint64_t v39 = *(void *)host_info_out;
    int v40 = *(void *)(a1 + 4912);
    uint64_t v41 = *(void **)(a1 + 14400);
    uint64_t v42 = atomic_load((unsigned int *)(a1 + 36));
    uint64_t v14 = bt_mergeSet(a1 + 96, v39, a1 + 4944, a1 + 9664, v37, v40, v41, &host_info_outCnt, (v42 & 8) != 0, a3, a4);
    size_t v43 = CFAbsoluteTimeGetCurrent();
    uint64_t v44 = *(void **)host_info_out;
    uint64_t v19 = v11 >> 3;
    if (*(void *)host_info_out)
    {
      uint64_t v45 = *(const void **)(*(void *)host_info_out + 16);
      if (v45) {
        CFRelease(v45);
      }
      free(v44);
    }
    if (host_info_outCnt
      && *(void *)(a1 + 128) + 1028 * (unint64_t)*(unsigned int *)(a1 + 240) + *(void *)(a1 + 488) > v11 / (4 * v93 / 5uLL)
      && ((v46 = atomic_load((unsigned int *)(a1 + 36)), (v46 & 0x800) != 0) ? (long long v47 = 4) : (long long v47 = 10),
          v43 - Current > (double)v47)
      || *(void *)(a1 + 128) + 1028 * (unint64_t)*(unsigned int *)(a1 + 240) + *(void *)(a1 + 488) >= 0x8000001)
    {
      *(unsigned char *)(v10 + 268) |= 2u;
    }
  }
  else
  {
    long long v48 = *__error();
    long long v49 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      unsigned int v86 = *__error();
      host_info_out[0] = 136315650;
      *(void *)&host_info_out[1] = "index_FlushCache";
      LOWORD(host_info_out[3]) = 1024;
      *(integer_t *)((char *)&host_info_out[3] + 2) = 482;
      HIWORD(host_info_out[4]) = 1024;
      host_info_out[5] = v86;
      _os_log_error_impl(&dword_1BD672000, v49, OS_LOG_TYPE_ERROR, "%s:%d: error %d updating sync count", (uint8_t *)host_info_out, 0x18u);
    }
    *__error() = v48;
    uint64_t v14 = *__error();
  }
  HIDWORD(v51) = qos_class_self() - 9;
  LODWORD(v51) = HIDWORD(v51);
  long long v50 = v51 >> 2;
  if (v50 > 6) {
    long long v52 = 0;
  }
  else {
    long long v52 = dword_1BDA87810[v50];
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 14720));
  if (*(void *)(a1 + 14904) || *(_DWORD *)(a1 + 14916) || *(unsigned char *)v10) {
    goto LABEL_62;
  }
  if (v52 <= 5)
  {
    if (*(void *)(a1 + 16 * v52 + 14784))
    {
LABEL_62:
      db_rwlock_wait(a1 + 14720, v52, 2);
      goto LABEL_63;
    }
    __int16 v83 = v52 - 1;
    int v84 = (uint64_t *)(a1 + 16 * v52 + 14800);
    while (v83 != 4)
    {
      unsigned int v85 = *v84;
      v84 += 2;
      ++v83;
      if (v85)
      {
        if (v83 <= 4) {
          goto LABEL_62;
        }
        break;
      }
    }
  }
  *(void *)(a1 + 14904) = pthread_self();
LABEL_63:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14720));
  if (v14) {
    goto LABEL_73;
  }
  if (v25) {
    goto LABEL_65;
  }
LABEL_66:
  long long v53 = indexFastFlush(a1, 0);
  uint64_t v14 = v53;
  if (v53)
  {
    if (*(unsigned char *)(a1 + 8))
    {
      *(unsigned char *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = v53;
    }
    long long v54 = *__error();
    long long v55 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      host_info_out[0] = 136315906;
      *(void *)&host_info_out[1] = "index_FlushCache";
      LOWORD(host_info_out[3]) = 1024;
      *(integer_t *)((char *)&host_info_out[3] + 2) = 570;
      HIWORD(host_info_out[4]) = 2080;
      *(void *)&host_info_out[5] = a1 + 15208;
      LOWORD(host_info_out[7]) = 1024;
      *(integer_t *)((char *)&host_info_out[7] + 2) = 570;
      _os_log_error_impl(&dword_1BD672000, v55, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", (uint8_t *)host_info_out, 0x22u);
    }
    *__error() = v54;
  }
  else
  {
    *(CFAbsoluteTime *)(a1 + 15040) = CFAbsoluteTimeGetCurrent();
    long long v56 = *(void *)(a1 + 14400);
    long long v57 = *(int8x16_t *)(v56 + 120);
    long long v58 = *(int8x16_t *)(v56 + 136);
    long long v59 = *(int8x16_t *)(v56 + 152);
    long long v60 = *(int8x16_t *)(v56 + 168);
    long long v61 = *(int8x16_t *)(v56 + 184);
    uint64_t v62 = *(int8x16_t *)(v56 + 200);
    int v63 = *(void *)(a1 + 15032) + *(unsigned int *)(v56 + 216);
    v64.i64[0] = 0xFFFFFFFFLL;
    v64.i64[1] = 0xFFFFFFFFLL;
    *(int64x2_t *)(v10 + 52) = vaddq_s64(*(int64x2_t *)(v10 + 52), (int64x2_t)vandq_s8(v60, v64));
    *(int64x2_t *)(v10 + 4) = vaddq_s64(*(int64x2_t *)(v10 + 4), (int64x2_t)vandq_s8(v57, v64));
    *(int64x2_t *)(v10 + 36) = vaddq_s64(*(int64x2_t *)(v10 + 36), (int64x2_t)vandq_s8(v59, v64));
    *(int64x2_t *)(v10 + 20) = vaddq_s64(*(int64x2_t *)(v10 + 20), (int64x2_t)vandq_s8(v58, v64));
    *(int64x2_t *)(v10 + 68) = vaddq_s64(*(int64x2_t *)(v10 + 68), (int64x2_t)vandq_s8(v61, v64));
    *(int64x2_t *)(v10 + 84) = vaddq_s64(*(int64x2_t *)(v10 + 84), (int64x2_t)vandq_s8(v62, v64));
    *(void *)(a1 + 15032) = v63;
  }
LABEL_73:
  TermUpdateSetRelease(*(void *)(a1 + 14400));
  *(void *)(a1 + 14400) = 0;
  int v65 = *(void *)(a1 + 9688);
  if (v65 >= v19 || *(void *)(a1 + 9664) + v65 - *(void *)(a1 + 9672) >= v94)
  {
    unsigned int v66 = *__error();
    unsigned int v67 = _SILogForLogForCategory(10);
    unint64_t v68 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v67, v68))
    {
      unint64_t v69 = *(void *)(a1 + 9688);
      uint64_t v70 = *(void *)(a1 + 9664) + v69 - *(void *)(a1 + 9672);
      host_info_out[0] = 134218752;
      *(void *)&host_info_out[1] = v69;
      LOWORD(host_info_out[3]) = 2048;
      *(void *)((char *)&host_info_out[3] + 2) = v19;
      HIWORD(host_info_out[5]) = 2048;
      *(void *)&host_info_out[6] = v70;
      LOWORD(host_info_out[8]) = 2048;
      *(void *)((char *)&host_info_out[8] + 2) = v94;
      _os_log_impl(&dword_1BD672000, v67, v68, "Force split for large index %lld (%lld) %lld (%lld)", (uint8_t *)host_info_out, 0x2Au);
    }
    *__error() = v66;
    uint64_t v71 = *(unsigned char *)(v10 + 268) | 2;
    *(unsigned char *)(v10 + 268) = v71;
    if ((v71 & 6) != 0) {
      goto LABEL_85;
    }
    goto LABEL_80;
  }
  if ((*(unsigned char *)(v10 + 268) & 6) == 0)
  {
LABEL_80:
    if (*(_DWORD *)(a1 + 68) >= 0x2711u)
    {
      uint64_t v72 = atomic_load((unsigned int *)(a1 + 16));
      if (*(_DWORD *)(a1 + 68) < 4 * v72)
      {
        unsigned int v73 = *__error();
        unsigned int v74 = _SILogForLogForCategory(10);
        int v75 = 2 * (dword_1E9FC90CC < 4);
        if (os_log_type_enabled(v74, v75))
        {
          uint64_t v76 = *(_DWORD *)(a1 + 68);
          uint64_t v77 = atomic_load((unsigned int *)(a1 + 16));
          host_info_out[0] = 67109376;
          host_info_out[1] = v76;
          LOWORD(host_info_out[2]) = 1024;
          *(integer_t *)((char *)&host_info_out[2] + 2) = v77;
          _os_log_impl(&dword_1BD672000, v74, v75, "Force split for high delete count; %d %d",
            (uint8_t *)host_info_out,
            0xEu);
        }
        *__error() = v73;
        *(unsigned char *)(v10 + 268) |= 2u;
      }
    }
  }
LABEL_85:
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 14720));
  *(_DWORD *)(a1 + 14924) = 0;
  uint64_t v78 = *(pthread_override_s **)(a1 + 14896);
  *(_OWORD *)(a1 + 14896) = 0u;
  uint64_t v79 = *(_DWORD *)(a1 + 14916) != 0;
  *(unsigned char *)uint64_t v10 = 0;
  db_rwlock_wakeup(a1 + 14720, v79, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14720));
  if (v78) {
    pthread_override_qos_class_end_np(v78);
  }
  return v14;
}

uint64_t indexFastFlush(uint64_t a1, _DWORD *a2)
{
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  long long v95 = 0u;
  *(_OWORD *)int v96 = 0u;
  long long v93 = 0u;
  long long v94 = 0u;
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s%s", (const char *)(a1 + 15208), "indexUpdates");
  unlinkat(*(_DWORD *)(a1 + 64), __str, 0);
  if (a2)
  {
    int v4 = 1538;
    unsigned __int8 v5 = 0;
  }
  else
  {
    int v4 = 536872450;
    unsigned __int8 v5 = 3;
  }
  CFIndex v6 = fd_create_protected(*(_DWORD *)(a1 + 64), __str, v4, v5);
  *(void *)iovec buf = 0;
  uint64_t v7 = _fd_acquire_fd((uint64_t)v6, buf);
  int v8 = v7;
  uint64_t v9 = *(void *)buf;
  if ((store_stream_init_fd((uint64_t)&v93, v7, *(uint64_t *)buf, 0, 1) & 1) == 0)
  {
    _fd_release_fd(v6, v8, 0, v9);
    return v94;
  }
  v96[1] = v6;
  uint64_t v10 = *((void *)&v95 + 1);
  if ((void)v95 - *((void *)&v95 + 1) < 6uLL)
  {
    *(void *)&buf[9] = 0;
    *(void *)&buf[1] = 0;
    *(void *)&uint8_t buf[24] = 0;
    *(void *)&buf[17] = 0;
    buf[0] = 2;
    store_stream_write_bytes_2478((uint64_t)&v93, (char *)buf, 1uLL);
  }
  else
  {
    *((unsigned char *)v96[0] + *((void *)&v95 + 1)) = 2;
    *((void *)&v95 + 1) = v10 + 1;
  }
  uint64_t v11 = *(void *)(a1 + 4928);
  char v12 = atomic_load((unsigned int *)(a1 + 36));
  if ((v12 & 2) != 0)
  {
    uint64_t v13 = 0;
    if (!*(void *)(a1 + 4928)) {
      goto LABEL_18;
    }
    goto LABEL_16;
  }
  uint64_t v13 = *(void *)(a1 + 9408);
  if (*(void *)(a1 + 14128) > v13) {
    uint64_t v13 = *(void *)(a1 + 14128);
  }
  if (*(void *)(a1 + 4632) > v13) {
    uint64_t v13 = *(void *)(a1 + 4632);
  }
  if (*(void *)(a1 + 4928))
  {
LABEL_16:
    if (*(void *)(v11 + 4384) > v13) {
      uint64_t v13 = *(void *)(v11 + 4384);
    }
  }
LABEL_18:
  uint64_t v16 = v13 + 7;
  BOOL v15 = v13 < -7;
  uint64_t v17 = v13 + 14;
  if (!v15) {
    uint64_t v17 = v16;
  }
  size_t v18 = v17 >> 3;
  uint64_t v19 = (UInt8 *)malloc_type_malloc(v17 >> 3, 0xB4DC06D4uLL);
  if (!v19)
  {
    uint64_t v39 = __si_assert_copy_extra_2445(0, -1);
    int v40 = v39;
    uint64_t v41 = "";
    if (v39) {
      uint64_t v41 = v39;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", 2779, "bits", v41);
    free(v40);
    if (__valid_fs(-1)) {
      uint64_t v42 = 2989;
    }
    else {
      uint64_t v42 = 3072;
    }
    *(_DWORD *)uint64_t v42 = -559038737;
    abort();
  }
  __int16 v20 = v19;
  char v21 = atomic_load((unsigned int *)(a1 + 36));
  if ((v21 & 2) != 0)
  {
    uint64_t v22 = *((void *)&v95 + 1);
    if ((void)v95 - *((void *)&v95 + 1) < 6uLL)
    {
      memset(buf, 0, 32);
      store_stream_write_bytes_2478((uint64_t)&v93, (char *)buf, 1uLL);
      uint64_t v23 = *((void *)&v95 + 1);
    }
    else
    {
      *((unsigned char *)v96[0] + *((void *)&v95 + 1)) = 0;
      uint64_t v23 = v22 + 1;
      *((void *)&v95 + 1) = v23;
    }
    if ((unint64_t)(v95 - v23) < 6)
    {
      memset(buf, 0, 32);
      store_stream_write_bytes_2478((uint64_t)&v93, (char *)buf, 1uLL);
      uint64_t v24 = *((void *)&v95 + 1);
    }
    else
    {
      *((unsigned char *)v96[0] + v23) = 0;
      uint64_t v24 = v23 + 1;
      *((void *)&v95 + 1) = v24;
    }
    if ((unint64_t)(v95 - v24) < 6)
    {
      memset(buf, 0, 32);
      store_stream_write_bytes_2478((uint64_t)&v93, (char *)buf, 1uLL);
    }
    else
    {
      *((unsigned char *)v96[0] + v24) = 0;
      *((void *)&v95 + 1) = v24 + 1;
    }
  }
  else
  {
    store_stream_write_vint32_2480(&v93, *(_DWORD *)(a1 + 9408));
    store_stream_write_vint32_2480(&v93, *(_DWORD *)(a1 + 14128));
    store_stream_write_vint32_2480(&v93, *(_DWORD *)(a1 + 4632));
  }
  char v25 = atomic_load((unsigned int *)(a1 + 36));
  if (v25 < 0)
  {
    if (v11) {
      unsigned int v26 = *(_DWORD *)(v11 + 4384);
    }
    else {
      unsigned int v26 = 0;
    }
    store_stream_write_vint32_2480(&v93, v26);
  }
  if (dword_1E9FC90CC >= 5)
  {
    int v43 = *__error();
    uint64_t v44 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)iovec buf = 134217984;
      *(void *)&uint8_t buf[4] = *((void *)&v95 + 1) + *((void *)&v94 + 1);
      _os_log_impl(&dword_1BD672000, v44, OS_LOG_TYPE_DEFAULT, "Post counts at %lld", buf, 0xCu);
    }
    *__error() = v43;
  }
  int v27 = (unsigned int *)(a1 + 36);
  char v28 = atomic_load((unsigned int *)(a1 + 36));
  if ((v28 & 2) != 0) {
    goto LABEL_85;
  }
  v29.uint64_t length = *(void *)(a1 + 9408);
  if (v29.length)
  {
    v29.locatiouint64_t n = 0;
    CFBitVectorGetBits(*(CFBitVectorRef *)(a1 + 9424), v29, v20);
  }
  else
  {
    bzero(v20, v18);
  }
  uint64_t v30 = *(void *)(a1 + 9408);
  uint64_t v31 = v30 + 7;
  BOOL v15 = v30 < -7;
  uint64_t v32 = v30 + 14;
  if (!v15) {
    uint64_t v32 = v31;
  }
  size_t v33 = v32 >> 3;
  uint64_t v34 = *((void *)&v95 + 1);
  uint64_t v35 = v95;
  __int16 v36 = v20;
  if (v33 + *((void *)&v95 + 1) >= (unint64_t)v95)
  {
    while (1)
    {
      uint64_t v45 = v35 - v34;
      int v90 = v36;
      memcpy((char *)v96[0] + v34, v36, v35 - v34);
      *((void *)&v95 + 1) += v45;
      if (store_stream_flush((unsigned int *)&v93, 0)) {
        break;
      }
      __int16 v36 = &v90[v45];
      v33 -= v45;
      uint64_t v34 = *((void *)&v95 + 1);
      uint64_t v35 = v95;
      if (*((void *)&v95 + 1) + v33 < (unint64_t)v95) {
        goto LABEL_42;
      }
    }
  }
  else
  {
LABEL_42:
    memcpy((char *)v96[0] + v34, v36, v33);
    *((void *)&v95 + 1) += v33;
  }
  if (dword_1E9FC90CC >= 5)
  {
    int v46 = *__error();
    long long v47 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)iovec buf = 134217984;
      *(void *)&uint8_t buf[4] = *((void *)&v95 + 1) + *((void *)&v94 + 1);
      _os_log_impl(&dword_1BD672000, v47, OS_LOG_TYPE_DEFAULT, "Post bv1 at %lld", buf, 0xCu);
    }
    *__error() = v46;
    v37.uint64_t length = *(void *)(a1 + 14128);
    if (v37.length) {
      goto LABEL_45;
    }
  }
  else
  {
    v37.uint64_t length = *(void *)(a1 + 14128);
    if (v37.length)
    {
LABEL_45:
      v37.locatiouint64_t n = 0;
      CFBitVectorGetBits(*(CFBitVectorRef *)(a1 + 14144), v37, v20);
      uint64_t v38 = *(void *)(a1 + 14128);
      goto LABEL_66;
    }
  }
  uint64_t v38 = 0;
LABEL_66:
  uint64_t v48 = v38 + 7;
  BOOL v15 = v38 < -7;
  uint64_t v49 = v38 + 14;
  if (!v15) {
    uint64_t v49 = v48;
  }
  size_t v50 = v49 >> 3;
  uint64_t v51 = *((void *)&v95 + 1);
  uint64_t v52 = v95;
  long long v53 = v20;
  if (v50 + *((void *)&v95 + 1) >= (unint64_t)v95)
  {
    while (1)
    {
      uint64_t v56 = v52 - v51;
      unsigned int v91 = v53;
      memcpy((char *)v96[0] + v51, v53, v52 - v51);
      *((void *)&v95 + 1) += v56;
      if (store_stream_flush((unsigned int *)&v93, 0)) {
        break;
      }
      long long v53 = &v91[v56];
      v50 -= v56;
      uint64_t v51 = *((void *)&v95 + 1);
      uint64_t v52 = v95;
      if (*((void *)&v95 + 1) + v50 < (unint64_t)v95) {
        goto LABEL_69;
      }
    }
  }
  else
  {
LABEL_69:
    memcpy((char *)v96[0] + v51, v53, v50);
    *((void *)&v95 + 1) += v50;
  }
  if (dword_1E9FC90CC >= 5)
  {
    int v57 = *__error();
    long long v58 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)iovec buf = 134217984;
      *(void *)&uint8_t buf[4] = *((void *)&v95 + 1) + *((void *)&v94 + 1);
      _os_log_impl(&dword_1BD672000, v58, OS_LOG_TYPE_DEFAULT, "Post bv2 at %lld", buf, 0xCu);
    }
    *__error() = v57;
    v54.uint64_t length = *(void *)(a1 + 4632);
    if (v54.length) {
      goto LABEL_72;
    }
  }
  else
  {
    v54.uint64_t length = *(void *)(a1 + 4632);
    if (v54.length)
    {
LABEL_72:
      v54.locatiouint64_t n = 0;
      CFBitVectorGetBits(*(CFBitVectorRef *)(a1 + 4648), v54, v20);
      uint64_t v55 = *(void *)(a1 + 4632);
      goto LABEL_80;
    }
  }
  uint64_t v55 = 0;
LABEL_80:
  uint64_t v59 = v55 + 7;
  BOOL v15 = v55 < -7;
  uint64_t v60 = v55 + 14;
  if (!v15) {
    uint64_t v60 = v59;
  }
  size_t v61 = v60 >> 3;
  uint64_t v62 = *((void *)&v95 + 1);
  uint64_t v63 = v95;
  int v64 = v20;
  if (v61 + *((void *)&v95 + 1) >= (unint64_t)v95)
  {
    while (1)
    {
      uint64_t v82 = v63 - v62;
      int v92 = v64;
      memcpy((char *)v96[0] + v62, v64, v63 - v62);
      *((void *)&v95 + 1) += v82;
      if (store_stream_flush((unsigned int *)&v93, 0)) {
        break;
      }
      int v64 = &v92[v82];
      v61 -= v82;
      uint64_t v62 = *((void *)&v95 + 1);
      uint64_t v63 = v95;
      if (*((void *)&v95 + 1) + v61 < (unint64_t)v95) {
        goto LABEL_83;
      }
    }
  }
  else
  {
LABEL_83:
    memcpy((char *)v96[0] + v62, v64, v61);
    *((void *)&v95 + 1) += v61;
  }
  if (dword_1E9FC90CC < 5)
  {
LABEL_85:
    char v65 = atomic_load(v27);
    if (v65 < 0) {
      goto LABEL_86;
    }
    goto LABEL_96;
  }
  int v83 = *__error();
  int v84 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)iovec buf = 134217984;
    *(void *)&uint8_t buf[4] = *((void *)&v95 + 1) + *((void *)&v94 + 1);
    _os_log_impl(&dword_1BD672000, v84, OS_LOG_TYPE_DEFAULT, "Post bv3 at %lld", buf, 0xCu);
  }
  *__error() = v83;
  char v85 = atomic_load(v27);
  if (v85 < 0)
  {
LABEL_86:
    if (*(void *)(a1 + 4928))
    {
      if (v11 && (v66.uint64_t length = *(void *)(v11 + 4384)) != 0)
      {
        v66.locatiouint64_t n = 0;
        CFBitVectorGetBits(*(CFBitVectorRef *)(v11 + 4400), v66, v20);
        uint64_t v67 = *(void *)(v11 + 4384);
        uint64_t v68 = v67 + 7;
        BOOL v15 = v67 < -7;
        uint64_t v69 = v67 + 14;
        if (!v15) {
          uint64_t v69 = v68;
        }
        size_t v70 = v69 >> 3;
      }
      else
      {
        size_t v70 = 0;
      }
      uint64_t v71 = *((void *)&v95 + 1);
      uint64_t v72 = v95;
      unsigned int v73 = v20;
      if (*((void *)&v95 + 1) + v70 >= (unint64_t)v95)
      {
        while (1)
        {
          uint64_t v86 = v72 - v71;
          int v87 = v73;
          memcpy((char *)v96[0] + v71, v73, v72 - v71);
          *((void *)&v95 + 1) += v86;
          if (store_stream_flush((unsigned int *)&v93, 0)) {
            break;
          }
          unsigned int v73 = &v87[v86];
          v70 -= v86;
          uint64_t v71 = *((void *)&v95 + 1);
          uint64_t v72 = v95;
          if (*((void *)&v95 + 1) + v70 < (unint64_t)v95) {
            goto LABEL_94;
          }
        }
      }
      else
      {
LABEL_94:
        memcpy((char *)v96[0] + v71, v73, v70);
        *((void *)&v95 + 1) += v70;
      }
      if (dword_1E9FC90CC >= 5)
      {
        int v88 = *__error();
        unsigned int v89 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)iovec buf = 134217984;
          *(void *)&uint8_t buf[4] = *((void *)&v95 + 1) + *((void *)&v94 + 1);
          _os_log_impl(&dword_1BD672000, v89, OS_LOG_TYPE_DEFAULT, "Post bv4 at %lld", buf, 0xCu);
        }
        *__error() = v88;
      }
    }
  }
LABEL_96:
  free(v20);
  char v74 = atomic_load((unsigned int *)(a1 + 36));
  if ((v74 & 2) != 0)
  {
    char v80 = atomic_load((unsigned int *)(a1 + 36));
    TermUpdateSetStore(0, 0, &v93, (v80 & 8) != 0);
  }
  else
  {
    *(void *)iovec buf = 0;
    if (a2)
    {
      char v75 = atomic_load((unsigned int *)(a1 + 36));
      if ((v75 & 0xC) == 8) {
        indexCopyDeleteDocIds(a1, 0, (CFIndex **)buf);
      }
    }
    uint64_t v76 = *(void *)buf;
    char v77 = atomic_load((unsigned int *)(a1 + 36));
    TermUpdateSetStore(a2, v76, &v93, (v77 & 8) != 0);
    uint64_t v78 = *(void **)buf;
    if (*(void *)buf)
    {
      uint64_t v79 = *(const void **)(*(void *)buf + 16);
      if (v79) {
        CFRelease(v79);
      }
      free(v78);
    }
  }
  store_stream_flush((unsigned int *)&v93, 1);
  uint64_t v14 = v94;
  if (v96[0])
  {
    free(v96[0]);
    v96[0] = 0;
    *(void *)&long long v95 = 0;
    if (v93 != -1 && v96[1])
    {
      _fd_release_fd((_DWORD *)v96[1], v93, 0, *((uint64_t *)&v93 + 1));
      LODWORD(v93) = -1;
    }
    v96[1] = 0;
  }
  fd_release((atomic_uint *)v6);
  return v14;
}

uint64_t store_stream_write_bytes_2478(uint64_t a1, char *__src, size_t __n)
{
  size_t v3 = __n;
  size_t v7 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  if (v6 + __n >= v7)
  {
    while (1)
    {
      size_t v9 = v7 - v6;
      memcpy((void *)(*(void *)(a1 + 48) + v6), __src, v7 - v6);
      *(void *)(a1 + 40) += v9;
      uint64_t result = store_stream_flush((unsigned int *)a1, 0);
      if (result) {
        break;
      }
      __src += v9;
      v3 -= v9;
      size_t v7 = *(void *)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 40);
      if (v6 + v3 < v7) {
        goto LABEL_2;
      }
    }
  }
  else
  {
LABEL_2:
    uint64_t result = (uint64_t)memcpy((void *)(*(void *)(a1 + 48) + v6), __src, v3);
    *(void *)(a1 + 40) += v3;
  }
  return result;
}

void *store_stream_write_vint32_2480(void *result, unsigned int a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = result[5];
  if ((unint64_t)(result[4] - v2) < 6)
  {
    memset(v9, 0, sizeof(v9));
    if (a2 >> 28)
    {
      LOBYTE(v9[0]) = a2 | 0x80;
      BYTE1(v9[0]) = (a2 >> 7) | 0x80;
      BYTE2(v9[0]) = (a2 >> 14) | 0x80;
      BYTE3(v9[0]) = (a2 >> 21) | 0x80;
      BYTE4(v9[0]) = a2 >> 28;
      size_t v8 = 5;
    }
    else if ((a2 & 0xFE00000) != 0)
    {
      LOBYTE(v9[0]) = a2 | 0x80;
      BYTE1(v9[0]) = (a2 >> 7) | 0x80;
      BYTE2(v9[0]) = (a2 >> 14) | 0x80;
      BYTE3(v9[0]) = (a2 & 0xFE00000) >> 21;
      size_t v8 = 4;
    }
    else if ((a2 & 0x1FC000) != 0)
    {
      LOBYTE(v9[0]) = a2 | 0x80;
      BYTE1(v9[0]) = (a2 >> 7) | 0x80;
      BYTE2(v9[0]) = (a2 & 0x1FC000) >> 14;
      size_t v8 = 3;
    }
    else if ((a2 & 0x3F80) != 0)
    {
      LOBYTE(v9[0]) = a2 | 0x80;
      BYTE1(v9[0]) = (unsigned __int16)(a2 & 0x3F80) >> 7;
      size_t v8 = 2;
    }
    else
    {
      LOBYTE(v9[0]) = a2;
      size_t v8 = 1;
    }
    return (void *)store_stream_write_bytes_2478((uint64_t)result, (char *)v9, v8);
  }
  else
  {
    uint64_t v3 = result[6];
    unsigned int v4 = a2 >> 28;
    if (a2 >> 28)
    {
      uint64_t v6 = (unsigned char *)(v3 + v2);
      *uint64_t v6 = a2 | 0x80;
      v6[1] = (a2 >> 7) | 0x80;
      v6[2] = (a2 >> 14) | 0x80;
      v2 += 4;
      void v6[3] = (a2 >> 21) | 0x80;
    }
    else if ((a2 & 0xFE00000) != 0)
    {
      unsigned __int8 v5 = (unsigned char *)(v3 + v2);
      *unsigned __int8 v5 = a2 | 0x80;
      v5[1] = (a2 >> 7) | 0x80;
      v2 += 3;
      v5[2] = (a2 >> 14) | 0x80;
      unsigned int v4 = (a2 & 0xFE00000) >> 21;
    }
    else if ((a2 & 0x1FC000) != 0)
    {
      size_t v7 = (unsigned char *)(v3 + v2);
      *size_t v7 = a2 | 0x80;
      v2 += 2;
      v7[1] = (a2 >> 7) | 0x80;
      unsigned int v4 = (a2 & 0x1FC000) >> 14;
    }
    else if ((a2 & 0x3F80) != 0)
    {
      *(unsigned char *)(v3 + v2++) = a2 | 0x80;
      unsigned int v4 = (unsigned __int16)(a2 & 0x3F80) >> 7;
    }
    else
    {
      LOBYTE(v4) = a2;
    }
    *(unsigned char *)(v3 + v2) = v4;
    result[5] = v2 + 1;
  }
  return result;
}

uint64_t termIdStoreReaderGetNext(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t ptr = storage_reader_get_ptr(a1, a2, 8 * a3, 8);
  if (ptr == -1)
  {
    uint64_t v6 = __si_assert_copy_extra_2445(0, -1);
    size_t v7 = v6;
    size_t v8 = "";
    if (v6) {
      size_t v8 = v6;
    }
    __message_assert("%s:%u: failed assertion '%s' %s failed to read offset for term %d", "TermIdStore.h", 89, "(intptr_t)ptr!=-1", v8, a3);
    free(v7);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return *(void *)ptr;
}

void oqpush_2500(uint64_t a1, uint64_t a2, size_t size)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v16 = __si_assert_copy_extra_2445(0, -1);
    size_t v7 = v16;
    uint64_t v17 = "";
    if (v16) {
      uint64_t v17 = v16;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 327, "!oqueue->has_meta", v17);
LABEL_26:
    free(v7);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (!*(_DWORD *)(a1 + 56))
  {
    uint64_t v10 = *(void *)(a1 + 24);
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5 < v10) {
      goto LABEL_18;
    }
    uint64_t v11 = 2 * v10;
    if (!v10) {
      uint64_t v11 = 4;
    }
    *(void *)(a1 + 24) = v11;
    char v12 = *(void **)(a1 + 16);
    size_t v13 = 8 * v11;
    if (v12)
    {
      uint64_t v14 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v12, v13, 0xECA6AA46uLL);
      if (!v14)
      {
LABEL_15:
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)iovec buf = 0;
          _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
        }
      }
    }
    else
    {
      uint64_t v14 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v13, 0x8DDAA030uLL);
      if (!v14) {
        goto LABEL_15;
      }
    }
    *(void *)(a1 + 16) = v14;
    uint64_t v5 = *(void *)(a1 + 32);
    goto LABEL_18;
  }
  if (*(void *)(a1 + 64) < (a2 & 0x3FFFFFFFFFFFFFFFuLL))
  {
    size_t v18 = __si_assert_copy_extra_2445(0, -1);
    size_t v7 = v18;
    size_t v8 = "";
    if (v18) {
      size_t v8 = v18;
    }
    size_t v9 = "!queue->split || queue->splitPoint >= offset_t_GET_VALUE(value)";
    goto LABEL_25;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5 >= *(void *)(a1 + 24))
  {
    uint64_t v6 = __si_assert_copy_extra_2445(0, -1);
    size_t v7 = v6;
    size_t v8 = "";
    if (v6) {
      size_t v8 = v6;
    }
    size_t v9 = "!queue->split";
LABEL_25:
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 247, v9, v8);
    goto LABEL_26;
  }
LABEL_18:
  uint64_t v15 = *(void *)(a1 + 16);
  *(void *)(a1 + 32) = v5 + 1;
  *(void *)(v15 + 8 * v5) = a2;
}

float oq_meta_at_index(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)a1)
  {
    uint64_t v3 = __si_assert_copy_extra_2445(0, -1);
    unsigned int v4 = v3;
    uint64_t v5 = "";
    if (v3) {
      uint64_t v5 = v3;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 318, "oqueue->has_meta", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return *(float *)(*(void *)(a1 + 16) + 16 * a2 + 8);
}

uint64_t oq_set_offset_with_meta_at_index(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!*(unsigned char *)result)
  {
    uint64_t v5 = __si_assert_copy_extra_2445(0, -1);
    uint64_t v6 = v5;
    size_t v7 = "";
    if (v5) {
      size_t v7 = v5;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 467, "queue->has_meta", v7);
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  unsigned int v4 = (void *)(*(void *)(result + 16) + 16 * a2);
  *unsigned int v4 = a3;
  v4[1] = a4;
  return result;
}

uint64_t index_DeleteIndex(uint64_t a1, uint64_t a2, const char *a3, int a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  if (a1)
  {
    int v8 = *__error();
    size_t v9 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = *(_DWORD *)(a1 + 64);
      int v11 = *(_DWORD *)(a1 + 56);
      buf[0].dev_t st_dev = 67109634;
      *(_DWORD *)&buf[0].st_mode = v10;
      LOWORD(buf[0].st_ino) = 1024;
      *(_DWORD *)((char *)&buf[0].st_ino + 2) = v11;
      HIWORD(buf[0].st_ino) = 2080;
      *(void *)&buf[0].st_uid = a1 + 15208;
      _os_log_impl(&dword_1BD672000, v9, OS_LOG_TYPE_DEFAULT, "### delete index [%d] %d %s", (uint8_t *)buf, 0x18u);
    }
    *__error() = v8;
    fd_zero_truncate(*(void *)(a1 + 4672));
    fd_zero_truncate(*(void *)(a1 + 208));
    fd_zero_truncate(*(void *)(a1 + 472));
    uint64_t v12 = *(void *)(a1 + 5200);
    if (v12) {
      fd_zero_truncate(v12);
    }
    fd_zero_truncate(*(void *)(a1 + 9432));
    uint64_t v13 = *(void *)(a1 + 9920);
    if (v13) {
      fd_zero_truncate(v13);
    }
    fd_zero_truncate(*(void *)(a1 + 14152));
    fd_zero_truncate(*(void *)(a1 + 14448));
    fd_zero_truncate(*(void *)(a1 + 14456));
    fd_zero_truncate(*(void *)(a1 + 14464));
    fd_zero_truncate(*(void *)(a1 + 14472));
    fd_zero_truncate(*(void *)(a1 + 14480));
    fd_zero_truncate(*(void *)(a1 + 14488));
    uint64_t v14 = *(void *)(a1 + 4928);
    if (v14) {
      fd_zero_truncate(*(void *)(v14 + 224));
    }
    uint64_t v15 = *(void *)(a1 + 4912);
    if (v15) {
      truncateVectorIndex(v15);
    }
    a2 = *(unsigned int *)(a1 + 64);
    if (a4) {
      freeIndex(a1);
    }
  }
  if (a2 == -1)
  {
    uint64_t v22 = __si_assert_copy_extra_2445(0, -1);
    uint64_t v23 = v22;
    uint64_t v24 = "";
    if (v22) {
      uint64_t v24 = v22;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", 1037, "parentDirFd!=-1", v24);
    free(v23);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  memset(buf, 0, 144);
  if (!fstat(a2, buf))
  {
    uint64_t v16 = open(".", 4);
    if (MEMORY[0x1C1882290](a2))
    {
      if ((v16 & 0x80000000) != 0) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
    bzero(buf, 0x400uLL);
    snprintf((char *)buf, 0x400uLL, "%s%s", a3, "indexDirectory");
    unlink((const char *)buf);
    snprintf((char *)buf, 0x400uLL, "%s%s", a3, "indexCompactDirectory");
    unlink((const char *)buf);
    snprintf((char *)buf, 0x400uLL, "%s%s", a3, "indexPostings");
    unlink((const char *)buf);
    snprintf((char *)buf, 0x400uLL, "%s%s", a3, "indexPositions");
    unlink((const char *)buf);
    snprintf((char *)buf, 0x400uLL, "%s%s", a3, "indexArrays");
    unlink((const char *)buf);
    snprintf((char *)buf, 0x400uLL, "%s%s", a3, "indexTermIds");
    unlink((const char *)buf);
    snprintf((char *)buf, 0x400uLL, "%s%s", a3, "indexPositionTable");
    unlink((const char *)buf);
    MEMORY[0x1C1882290](v16);
    if ((v16 & 0x80000000) == 0) {
LABEL_18:
    }
      close(v16);
  }
LABEL_19:
  memset(buf, 0, 144);
  if (!fstat(a2, buf))
  {
    uint64_t v17 = open(".", 4);
    if (MEMORY[0x1C1882290](a2))
    {
      if ((v17 & 0x80000000) == 0) {
LABEL_22:
      }
        close(v17);
    }
    else
    {
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexHead");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexId");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexIds");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexDates");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexBigDates");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexScores");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexGroups");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexUpdates");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "topK.v2.mdplistc");
      unlink(__str);
      bzero(buf, 0x400uLL);
      snprintf((char *)buf, 0x400uLL, "%s%s", a3, "directoryStoreFile");
      unlink((const char *)buf);
      int v19 = fcntl(a2, 50, __str);
      if (__str[0]) {
        BOOL v20 = v19 < 0;
      }
      else {
        BOOL v20 = 1;
      }
      if (v20) {
        char v21 = 0;
      }
      else {
        char v21 = __str;
      }
      IVFVectorIndex_s::unlink((IVFVectorIndex_s *)v21, a3, 0);
      MEMORY[0x1C1882290](v17);
      if ((v17 & 0x80000000) == 0) {
        goto LABEL_22;
      }
    }
  }
  return index_DeleteShadow(a2, a3, 0);
}

void freeIndex(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void **)(a1 + 14432);
    if ((unint64_t)v2 + 1 >= 2)
    {
      unsigned int v3 = *(_DWORD *)(a1 + 72);
      if (*(unsigned char *)(a1 + 45)) {
        size_t v4 = v3;
      }
      else {
        size_t v4 = (4 * v3 + 4) / 5;
      }
      munmap(v2, v4);
      *(void *)(a1 + 14432) = 0;
    }
    free(*(void **)(a1 + 14440));
    *(void *)(a1 + 14440) = 0;
    fd_release(*(atomic_uint **)(a1 + 14472));
    *(void *)(a1 + 14472) = 0;
    uint64_t v5 = *(void **)(a1 + 14408);
    if (v5)
    {
      munmap(v5, 8 * *(unsigned int *)(a1 + 72));
      *(void *)(a1 + 14408) = 0;
    }
    uint64_t v6 = *(void **)(a1 + 14416);
    if (v6)
    {
      munmap(v6, 4 * *(unsigned int *)(a1 + 72));
      *(void *)(a1 + 14416) = 0;
    }
    size_t v7 = *(void **)(a1 + 14424);
    if (v7)
    {
      munmap(v7, 8 * *(unsigned int *)(a1 + 72));
      *(void *)(a1 + 14424) = 0;
    }
    int v8 = *(const void **)(a1 + 14496);
    if (v8)
    {
      CFRelease(v8);
      *(void *)(a1 + 14496) = 0;
    }
    size_t v9 = *(atomic_uint **)(a1 + 14488);
    if (v9)
    {
      fd_release(v9);
      *(void *)(a1 + 14488) = 0;
    }
    fd_release(*(atomic_uint **)(a1 + 14448));
    *(void *)(a1 + 14448) = 0;
    fd_release(*(atomic_uint **)(a1 + 14456));
    *(void *)(a1 + 14456) = 0;
    fd_release(*(atomic_uint **)(a1 + 14464));
    *(void *)(a1 + 14464) = 0;
    int v10 = *(_DWORD *)(a1 + 9440);
    if (v10 != -1)
    {
      _fd_release_fd(*(_DWORD **)(a1 + 9432), v10, 0, *(void *)(a1 + 9448));
      *(_DWORD *)(a1 + 9440) = -1;
    }
    fd_release(*(atomic_uint **)(a1 + 9432));
    *(void *)(a1 + 9432) = 0;
    storageClose(a1 + 4984);
    int v11 = *(_DWORD *)(a1 + 14160);
    if (v11 != -1)
    {
      _fd_release_fd(*(_DWORD **)(a1 + 14152), v11, 0, *(void *)(a1 + 14168));
      *(_DWORD *)(a1 + 14160) = -1;
    }
    fd_release(*(atomic_uint **)(a1 + 14152));
    *(void *)(a1 + 14152) = 0;
    storageClose(a1 + 9704);
    fd_release(*(atomic_uint **)(a1 + 4672));
    *(void *)(a1 + 4672) = 0;
    uint64_t v12 = *(void **)(a1 + 104);
    if ((unint64_t)v12 + 1 >= 2)
    {
      munmap(v12, 1028 * *(unsigned int *)(a1 + 244));
      *(void *)(a1 + 104) = 0;
    }
    closeMF(a1 + 112);
    storageClose(a1 + 256);
    fd_release(*(atomic_uint **)(a1 + 14480));
    *(void *)(a1 + 14480) = 0;
    uint64_t v13 = *(void **)(a1 + 4928);
    if (v13)
    {
      storageClose((uint64_t)(v13 + 1));
      uint64_t v14 = (const void *)v13[550];
      if (v14) {
        CFRelease(v14);
      }
      free(v13);
      *(void *)(a1 + 4928) = 0;
    }
    uint64_t v15 = *(void *)(a1 + 4912);
    if (v15)
    {
      IVFVectorIndex_s::~IVFVectorIndex_s((IVFVectorIndex_s *)(v15 + 8));
      MEMORY[0x1C1881000](v15, 0x1032C400935D19DLL);
      *(void *)(a1 + 4912) = 0;
    }
    freePayload(a1 + 4944);
    freePayload(a1 + 9664);
    bt_freeTrie(a1 + 96);
    uint64_t v16 = *(void *)(a1 + 14392);
    if (v16)
    {
      TermUpdateSetRemoveFromAccounting(v16);
      TermUpdateSetRelease(*(void *)(a1 + 14392));
      atomic_fetch_add((atomic_uint *volatile)gTermUpdateSetCount, 0xFFFFFFFF);
    }
    uint64_t v17 = *(void *)(a1 + 14400);
    if (v17) {
      TermUpdateSetRelease(v17);
    }
    db_rwlock_destroy((pthread_mutex_t *)(a1 + 14720));
    db_rwlock_destroy((pthread_mutex_t *)(a1 + 14504));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 15056));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 15120));
    dispatch_release(*(dispatch_object_t *)(a1 + 15696));
    free(*(void **)(a1 + 14440));
    *(void *)(a1 + 14440) = 0;
    size_t v18 = *(const void **)(a1 + 15184);
    if (v18) {
      _Block_release(v18);
    }
    *(void *)(a1 + 15184) = 0;
    _Block_release(*(const void **)(a1 + 4936));
    free((void *)a1);
  }
}

uint64_t index_DeleteShadow(uint64_t a1, const char *a2, char a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  memset(&v13, 0, sizeof(v13));
  if (!fstat(a1, &v13))
  {
    uint64_t v6 = open(".", 4);
    if (MEMORY[0x1C1882290](a1))
    {
      if ((v6 & 0x80000000) != 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
    bzero(&v13, 0x400uLL);
    snprintf((char *)&v13, 0x400uLL, "%s%s", a2, "shadowIndexDirectory");
    unlink((const char *)&v13);
    snprintf((char *)&v13, 0x400uLL, "%s%s", a2, "shadowIndexCompactDirectory");
    unlink((const char *)&v13);
    snprintf((char *)&v13, 0x400uLL, "%s%s", a2, "shadowIndexArrays");
    unlink((const char *)&v13);
    MEMORY[0x1C1882290](v6);
    if ((v6 & 0x80000000) == 0) {
LABEL_4:
    }
      close(v6);
  }
LABEL_5:
  memset(&v13, 0, sizeof(v13));
  uint64_t result = fstat(a1, &v13);
  if (result) {
    return result;
  }
  uint64_t v8 = open(".", 4);
  uint64_t result = MEMORY[0x1C1882290](a1);
  if (result)
  {
    if ((v8 & 0x80000000) != 0) {
      return result;
    }
    return close(v8);
  }
  if ((a3 & 1) == 0)
  {
    snprintf(__str, 0x400uLL, "%s%s", a2, "shadowIndexHead");
    unlink(__str);
    snprintf(__str, 0x400uLL, "%s%s", a2, "shadowIndexGroups");
    unlink(__str);
    bzero(&v13, 0x400uLL);
    snprintf((char *)&v13, 0x400uLL, "%s%s.shadow", a2, "directoryStoreFile");
    unlink((const char *)&v13);
    int v9 = fcntl(a1, 50, __str);
    if (__str[0]) {
      BOOL v10 = v9 < 0;
    }
    else {
      BOOL v10 = 1;
    }
    if (v10) {
      int v11 = 0;
    }
    else {
      int v11 = __str;
    }
    IVFVectorIndex_s::unlink((IVFVectorIndex_s *)v11, a2, (const char *)1);
  }
  snprintf(__str, 0x400uLL, "%s%s", a2, "shadowIndexTermIds");
  unlink(__str);
  snprintf(__str, 0x400uLL, "%s%s", a2, "shadowIndexPositionTable");
  unlink(__str);
  uint64_t result = MEMORY[0x1C1882290](v8);
  if ((v8 & 0x80000000) == 0) {
    return close(v8);
  }
  return result;
}

uint64_t createIndex(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, unsigned int a5, char a6, int a7, int *a8, int a9, uint64_t a10, uint64_t a11, const void *a12, int a13)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  *a8 = -1;
  if (!a2) {
    a2 = "";
  }
  if ((a5 & 0x1000) != 0)
  {
    int v28 = *__error();
    CFRange v29 = _SILogForLogForCategory(10);
    os_log_type_t v30 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v29, v30))
    {
      LOWORD(buf.f_bsize) = 0;
      _os_log_impl(&dword_1BD672000, v29, v30, "creating new index not allowed during locked indexing", (uint8_t *)&buf, 2u);
    }
    *__error() = v28;
    goto LABEL_85;
  }
  char v21 = a8;
  char v64 = a6;
  int v22 = *__error();
  uint64_t v23 = _SILogForLogForCategory(10);
  os_log_type_t v24 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v23, v24))
  {
    buf.f_bstd::string::size_type size = 136315138;
    *(void *)&buf.f_iostd::string::size_type size = a2;
    _os_log_impl(&dword_1BD672000, v23, v24, "creating index at %s", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v22;
  index_DeleteIndex(0, a1, a2, 1);
  char v25 = (char *)malloc_type_calloc(1uLL, 0x3D68uLL, 0x10F0040F3430A86uLL);
  if (!v25)
  {
    *char v21 = -1;
    goto LABEL_85;
  }
  uint64_t v26 = (uint64_t)v25;
  uint64_t v63 = (BOOL *)(v25 + 15202);
  initIndex((uint64_t)v25, a12);
  __strlcpy_chk();
  *(_DWORD *)(v26 + 4) = a9;
  if (a7 && (v64 & 1) == 0) {
    atomic_fetch_or((atomic_uint *volatile)(v26 + 36), 8u);
  }
  *(void *)(v26 + 80) = a3;
  *(_DWORD *)(v26 + 88) = 1437;
  if (a11) {
    int v27 = (*(uint64_t (**)(uint64_t, void))(a11 + 16))(a11, 0);
  }
  else {
    int v27 = 0;
  }
  *(_DWORD *)(v26 + 56) = v27;
  *(_DWORD *)(v26 + 64) = a1;
  *(_DWORD *)(v26 + 15716) = a13;
  __strlcpy_chk();
  __strlcpy_chk();
  *(void *)(v26 + 68) = 0x100000000001;
  *uint64_t v63 = (a5 & 0x10) != 0;
  *(unsigned char *)(v26 + 45) = BYTE1(a5) & 1;
  *(unsigned char *)(v26 + 46) = (a5 & 0x400) != 0;
  *(_WORD *)(v63 + 511) = 0;
  bzero(&buf, 0x878uLL);
  if (fstatfs(a1, &buf))
  {
    int v31 = *__error();
    uint64_t v32 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)char v65 = 136315650;
      *(void *)&v65[4] = "createIndex";
      *(_WORD *)&v65[12] = 1024;
      *(_DWORD *)&v65[14] = 1459;
      *(_WORD *)&v65[18] = 2080;
      *(void *)&unsigned char v65[20] = a4;
      _os_log_error_impl(&dword_1BD672000, v32, OS_LOG_TYPE_ERROR, "%s:%d: Couldn't statfs parent directory: %s", v65, 0x1Cu);
    }
    goto LABEL_45;
  }
  int v33 = *(_DWORD *)buf.f_fstypename;
  BOOL v34 = *(_DWORD *)buf.f_fstypename == 1634105445 && *(unsigned __int16 *)&buf.f_fstypename[4] == 116;
  char v35 = v34;
  v63[511] = v35;
  BOOL v36 = 1;
  if (!(v33 ^ 0x73667061 | buf.f_fstypename[4]) || v33 == 7562856)
  {
LABEL_38:
    BOOL v39 = 0;
    if ((a5 & 0x8000) != 0) {
      goto LABEL_39;
    }
    goto LABEL_41;
  }
  if (*(_DWORD *)buf.f_fstypename != 1634105445 || *(unsigned __int16 *)&buf.f_fstypename[4] != 116)
  {
    BOOL v36 = *(_DWORD *)buf.f_fstypename == 1868854125 && *(unsigned __int16 *)&buf.f_fstypename[4] == 115;
    goto LABEL_38;
  }
  BOOL v36 = 1;
  BOOL v39 = 0;
  if ((a5 & 0x8000) != 0)
  {
LABEL_39:
    if (v36) {
      BOOL v39 = (a5 & 0x20) == 0;
    }
  }
LABEL_41:
  v63[512] = v39;
  int v31 = *__error();
  int v40 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v34 = !v63[512];
    *(_DWORD *)char v65 = 136316162;
    uint64_t v41 = "";
    if (v34) {
      uint64_t v41 = "not";
    }
    *(void *)&v65[4] = a2;
    *(_WORD *)&v65[12] = 2080;
    *(void *)&v65[14] = v41;
    *(_WORD *)&v65[22] = 2080;
    *(void *)&v65[24] = buf.f_fstypename;
    __int16 v66 = 1024;
    int v67 = (a5 >> 15) & 1;
    __int16 v68 = 1024;
    int v69 = (a5 >> 5) & 1;
    _os_log_impl(&dword_1BD672000, v40, OS_LOG_TYPE_DEFAULT, "createIndex(%s) VectorIndex %s supported on %s isLocalVolume: %d, isBackup: %d", v65, 0x2Cu);
  }
LABEL_45:
  *__error() = v31;
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexHead");
  uint64_t v42 = v21;
  int v43 = open_index_file(a1, __str, 1538, 0, 0, 0, 0, 0, v21);
  *(void *)(v26 + 14480) = v43;
  if (!v43) {
    goto LABEL_83;
  }
  uint64_t v44 = v43;
  *(void *)char v65 = 0;
  int v45 = _fd_acquire_fd((uint64_t)v43, v65);
  if (v45 != -1)
  {
    int v46 = v45;
    *((_WORD *)v44 + 28) |= 1u;
    fcntl(v45, 48, 1);
    fcntl(v46, 76, v44[7] & 1);
    _fd_release_fd(v44, v46, 0, *(uint64_t *)v65);
  }
  unsigned int v47 = *(_DWORD *)(v26 + 56);
  if (v47)
  {
    memset(v65, 0, sizeof(v65));
    if ((v47 & 0xF0000000) != 0)
    {
      v65[0] = v47 | 0x80;
      v65[1] = (v47 >> 7) | 0x80;
      v65[2] = (v47 >> 14) | 0x80;
      v65[3] = (v47 >> 21) | 0x80;
      v65[4] = (unint64_t)(v47 & 0xF0000000) >> 28;
      unint64_t v48 = 5;
    }
    else if ((v47 & 0xFE00000) != 0)
    {
      v65[0] = v47 | 0x80;
      v65[1] = (v47 >> 7) | 0x80;
      v65[2] = (v47 >> 14) | 0x80;
      v65[3] = (unint64_t)(v47 & 0xFE00000) >> 21;
      unint64_t v48 = 4;
    }
    else if ((*(void *)&v47 & 0x1FC000) != 0)
    {
      v65[0] = v47 | 0x80;
      v65[1] = (v47 >> 7) | 0x80;
      v65[2] = (*(void *)&v47 & 0x1FC000uLL) >> 14;
      unint64_t v48 = 3;
    }
    else if ((v47 & 0x3F80) != 0)
    {
      v65[0] = v47 | 0x80;
      v65[1] = (unint64_t)(v47 & 0x3F80) >> 7;
      unint64_t v48 = 2;
    }
    else
    {
      v65[0] = v47;
      unint64_t v48 = 1;
    }
    snprintf(__str, 0x400uLL, "%s%s", a2, "indexId");
    uint64_t v49 = (atomic_uint *)open_index_file(a1, __str, 1538, 0, 0, 1, 0, 2, v21);
    if (v49)
    {
      size_t v50 = v49;
      fd_pwrite((uint64_t)v49, (uint64_t)v65, v48, 0);
      fd_release(v50);
    }
  }
  int v51 = *__error();
  uint64_t v52 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
  {
    int v53 = *(_DWORD *)(v26 + 56);
    *(_DWORD *)char v65 = 67109378;
    *(_DWORD *)&v65[4] = v53;
    *(_WORD *)&v65[8] = 2080;
    *(void *)&v65[10] = __str;
    _os_log_impl(&dword_1BD672000, v52, OS_LOG_TYPE_DEFAULT, "create indexid %u %s", v65, 0x12u);
  }
  *__error() = v51;
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexIds");
  CFRange v54 = open_index_file(a1, __str, 1538, 0x8000, 0, 1, (uint64_t *)(v26 + 14408), 3, v42);
  *(void *)(v26 + 14448) = v54;
  if (!v54) {
    goto LABEL_83;
  }
  v63[3] = 1;
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexBigDates");
  *(void *)(v26 + 14456) = open_index_file(a1, __str, 1538, 0x4000, 0, 1, (uint64_t *)(v26 + 14416), 3, v42);
  if ((a5 & 0x100) != 0)
  {
    snprintf(__str, 0x400uLL, "%s%s", a2, "indexScores");
    *(void *)(v26 + 14464) = open_index_file(a1, __str, 1538, 0x8000, 0, 1, (uint64_t *)(v26 + 14424), 3, v42);
  }
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexGroups");
  off_t v55 = *(unsigned char *)(v26 + 45) ? 4096 : 3277;
  uint64_t v56 = open_index_file(a1, __str, 1538, v55, 0, 1, (uint64_t *)(v26 + 14432), 3, v42);
  *(void *)(v26 + 14472) = v56;
  if (!v56
    || !openPayload(v26 + 4944, *(_DWORD *)(v26 + 64), a2, "indexPostings", "indexTermIds", __str, 0, 0, v64 ^ 1u, *(_DWORD *)(v26 + 4), *(void **)(v26 + 4936))|| !openPayload(v26 + 9664, *(_DWORD *)(v26 + 64), a2, "indexPositions", "indexPositionTable", __str, 0,
                        0,
                        v64 ^ 1u,
                        *(_DWORD *)(v26 + 4),
                        *(void **)(v26 + 4936))
    || !bt_openTrie(v26 + 96, *(_DWORD *)(v26 + 64), a2, 0, 0, 0, *(_DWORD *)(v26 + 4), *(void **)(v26 + 4936))|| (snprintf(__str, 0x400uLL, "%s%s", a2, "indexUpdates"), int v57 = (atomic_uint *)fd_create_protected(a1, __str, 1538, 0), fd_release(v57), (a5 & 0x40) != 0)&& (atomic_fetch_or((atomic_uint *volatile)(v26 + 36), 0x80u), ForwardStore = createForwardStore(a1, a2, *(void **)(v26 + 4936)), (*(void *)(v26 + 4928) = ForwardStore) == 0))
  {
LABEL_83:
    if (!*v42) {
      return v26;
    }
    freeIndex(v26);
LABEL_85:
    index_DeleteIndex(0, a1, a2, 1);
    return 0;
  }
  if (_os_feature_enabled_impl() && v63[512])
  {
    int v59 = *__error();
    uint64_t v60 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
    {
      int v61 = *(_DWORD *)(v26 + 56);
      *(_DWORD *)char v65 = 67109120;
      *(_DWORD *)&v65[4] = v61;
      _os_log_impl(&dword_1BD672000, v60, OS_LOG_TYPE_DEFAULT, "create vector index for indexid %d", v65, 8u);
    }
    *__error() = v59;
    if (*(_DWORD *)(v26 + 56)) {
      createVectorIndex(a1, a2);
    }
  }
  *(unsigned char *)(v26 + 8) = 1;
  int *v42 = 0;
  return v26;
}

void *initIndex(uint64_t a1, const void *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)a1 = -1163003219;
  v5.__sig = 0;
  *(void *)v5.__opaque = 0;
  pthread_mutexattr_init(&v5);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 15056), &v5);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 15120), &v5);
  pthread_mutexattr_destroy(&v5);
  *(_DWORD *)(a1 + 15688) = 0;
  *(void *)(a1 + 15696) = dispatch_semaphore_create(0);
  *(_OWORD *)(a1 + 14720) = 0u;
  *(_OWORD *)(a1 + 14736) = 0u;
  *(_OWORD *)(a1 + 14752) = 0u;
  *(_OWORD *)(a1 + 14768) = 0u;
  *(_OWORD *)(a1 + 14784) = 0u;
  *(_OWORD *)(a1 + 14800) = 0u;
  *(_OWORD *)(a1 + 14816) = 0u;
  *(_OWORD *)(a1 + 14832) = 0u;
  *(_OWORD *)(a1 + 14848) = 0u;
  *(_OWORD *)(a1 + 14864) = 0u;
  *(_OWORD *)(a1 + 14880) = 0u;
  *(_OWORD *)(a1 + 14896) = 0u;
  *(_OWORD *)(a1 + 14912) = 0u;
  *(void *)(a1 + 14928) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 14720), 0);
  *(_OWORD *)(a1 + 14504) = 0u;
  *(_OWORD *)(a1 + 14520) = 0u;
  *(_OWORD *)(a1 + 14536) = 0u;
  *(_OWORD *)(a1 + 14552) = 0u;
  *(_OWORD *)(a1 + 14568) = 0u;
  *(_OWORD *)(a1 + 14584) = 0u;
  *(_OWORD *)(a1 + 14600) = 0u;
  *(_OWORD *)(a1 + 14616) = 0u;
  *(_OWORD *)(a1 + 14632) = 0u;
  *(_OWORD *)(a1 + 14648) = 0u;
  *(_OWORD *)(a1 + 14664) = 0u;
  *(_OWORD *)(a1 + 14680) = 0u;
  *(_OWORD *)(a1 + 14696) = 0u;
  *(void *)(a1 + 14712) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 14504), 0);
  *(_DWORD *)(a1 + 9440) = -1;
  memset(&v6, 0, sizeof(v6));
  pthread_rwlockattr_init(&v6);
  pthread_rwlock_init((pthread_rwlock_t *)(a1 + 9464), &v6);
  pthread_rwlockattr_destroy(&v6);
  *(_DWORD *)(a1 + 14160) = -1;
  memset(&v6, 0, sizeof(v6));
  pthread_rwlockattr_init(&v6);
  pthread_rwlock_init((pthread_rwlock_t *)(a1 + 14184), &v6);
  pthread_rwlockattr_destroy(&v6);
  *(void *)(a1 + 4904) = 0;
  *(_OWORD *)(a1 + 4872) = 0u;
  *(_OWORD *)(a1 + 4888) = 0u;
  *(_OWORD *)(a1 + 4840) = 0u;
  *(_OWORD *)(a1 + 4856) = 0u;
  *(_OWORD *)(a1 + 4808) = 0u;
  *(_OWORD *)(a1 + 4824) = 0u;
  *(_OWORD *)(a1 + 4776) = 0u;
  *(_OWORD *)(a1 + 4792) = 0u;
  *(_OWORD *)(a1 + 4744) = 0u;
  *(_OWORD *)(a1 + 4760) = 0u;
  *(_OWORD *)(a1 + 4712) = 0u;
  *(_OWORD *)(a1 + 4728) = 0u;
  *(_OWORD *)(a1 + 4696) = 0u;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 4696), 0);
  uint64_t result = _Block_copy(a2);
  *(void *)(a1 + 4936) = result;
  return result;
}

void *open_index_file(int a1, const char *a2, int a3, off_t a4, off_t a5, int a6, uint64_t *a7, uint64_t a8, int *a9)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = fd_create_protected(a1, a2, a3 | (((a3 & 3) != 0) << 29), 3u);
  if (!v14)
  {
    *a9 = *__error();
    int v26 = *__error();
    int v27 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      gid_t v32 = *a9;
      v44.dev_t st_dev = 136315906;
      *(void *)&v44.st_mode = "open_index_file";
      WORD2(v44.st_ino) = 1024;
      *(_DWORD *)((char *)&v44.st_ino + 6) = 1300;
      HIWORD(v44.st_uid) = 1024;
      v44.st_gid = v32;
      LOWORD(v44.st_rdev) = 2080;
      *(void *)((char *)&v44.st_rdev + 2) = a2;
      _os_log_error_impl(&dword_1BD672000, v27, OS_LOG_TYPE_ERROR, "%s:%d: open file error: %d, %s\n", (uint8_t *)&v44, 0x22u);
    }
    *__error() = v26;
    goto LABEL_23;
  }
  if (a5)
  {
    memset(&v44, 0, sizeof(v44));
    do
    {
      int v15 = fstatat(*((_DWORD *)v14 + 11), (const char *)v14[9], &v44, 2048);
      uint64_t v16 = g_prot_error_callback;
      if (v15 != -1 || g_prot_error_callback == 0) {
        break;
      }
      uint64_t v18 = *((unsigned int *)v14 + 10);
      int v19 = __error();
    }
    while (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v16 + 16))(v16, v18, *v19, 8) & 1) != 0);
    if (v44.st_size < a5)
    {
      *a9 = -1;
      int v20 = *__error();
      char v21 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        int v34 = 136316162;
        char v35 = "open_index_file";
        __int16 v36 = 1024;
        int v37 = 1308;
        __int16 v38 = 1024;
        st_std::string::size_type size = v44.st_size;
        __int16 v40 = 1024;
        int v41 = a5;
        __int16 v42 = 2080;
        int v43 = a2;
        int v22 = "%s:%d: bad file size: %d, min size %d, %s\n";
        uint64_t v23 = (stat *)&v34;
        os_log_type_t v24 = v21;
        uint32_t v25 = 40;
LABEL_27:
        _os_log_error_impl(&dword_1BD672000, v24, OS_LOG_TYPE_ERROR, v22, (uint8_t *)v23, v25);
      }
LABEL_22:
      *__error() = v20;
LABEL_23:
      fd_release((atomic_uint *)v14);
      return 0;
    }
  }
  if (a7)
  {
    uint64_t v28 = fd_mmap((uint64_t)v14);
    *a7 = v28;
    if (v28 == -1)
    {
      *a9 = *__error();
      int v20 = *__error();
      CFRange v29 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        goto LABEL_22;
      }
      gid_t v33 = *a9;
      v44.dev_t st_dev = 136316162;
      *(void *)&v44.st_mode = "open_index_file";
      WORD2(v44.st_ino) = 1024;
      *(_DWORD *)((char *)&v44.st_ino + 6) = 1316;
      HIWORD(v44.st_uid) = 1024;
      v44.st_gid = v33;
      LOWORD(v44.st_rdev) = 2048;
      *(void *)((char *)&v44.st_rdev + 2) = a4;
      WORD1(v44.st_atimespec.tv_sec) = 2080;
      *(__darwin_time_t *)((char *)&v44.st_atimespec.tv_sec + 4) = (__darwin_time_t)a2;
      int v22 = "%s:%d: map error: %d, size: %lld, %s";
      goto LABEL_26;
    }
  }
  if (a6 && fd_truncate((uint64_t)v14, a4) == -1)
  {
    *a9 = *__error();
    int v20 = *__error();
    CFRange v29 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    gid_t v30 = *a9;
    v44.dev_t st_dev = 136316162;
    *(void *)&v44.st_mode = "open_index_file";
    WORD2(v44.st_ino) = 1024;
    *(_DWORD *)((char *)&v44.st_ino + 6) = 1322;
    HIWORD(v44.st_uid) = 1024;
    v44.st_gid = v30;
    LOWORD(v44.st_rdev) = 2048;
    *(void *)((char *)&v44.st_rdev + 2) = a4;
    WORD1(v44.st_atimespec.tv_sec) = 2080;
    *(__darwin_time_t *)((char *)&v44.st_atimespec.tv_sec + 4) = (__darwin_time_t)a2;
    int v22 = "%s:%d: ftruncate error: %d, size: %lld, %s";
LABEL_26:
    uint64_t v23 = &v44;
    os_log_type_t v24 = v29;
    uint32_t v25 = 44;
    goto LABEL_27;
  }
  return v14;
}

uint64_t *storeVInt64(uint64_t *result, unint64_t a2)
{
  uint64_t v2 = *result;
  if (HIDWORD(a2))
  {
    if ((a2 & 0x8000000000000000) != 0)
    {
      *(unsigned char *)uint64_t v2 = a2 | 0x80;
      uint64x2_t v6 = (uint64x2_t)vdupq_n_s64(a2);
      *(int8x8_t *)(v2 + 1) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v6, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v6, (uint64x2_t)xmmword_1BDA822E0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v6, (uint64x2_t)xmmword_1BDA823F0), (int32x4_t)vshlq_u64(v6, (uint64x2_t)xmmword_1BDA823E0)))), (int8x8_t)0x8080808080808080);
      *(unsigned char *)(v2 + 9) = 1;
      uint64_t v3 = 10;
    }
    else if ((a2 & 0x7F00000000000000) != 0)
    {
      uint64x2_t v4 = (uint64x2_t)vdupq_n_s64(a2);
      *(unsigned char *)uint64_t v2 = a2 | 0x80;
      int16x8_t v5 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v4, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v4, (uint64x2_t)xmmword_1BDA822E0));
      v5.i64[0] = *(void *)&vmovn_s32((int32x4_t)v5) | 0x80008000800080;
      *(_DWORD *)(v2 + 1) = vmovn_s16(v5).u32[0];
      *(unsigned char *)(v2 + 5) = (a2 >> 35) | 0x80;
      *(unsigned char *)(v2 + 6) = (a2 >> 42) | 0x80;
      *(unsigned char *)(v2 + 7) = (a2 >> 49) | 0x80;
      *(unsigned char *)(v2 + 8) = (a2 & 0x7F00000000000000) >> 56;
      uint64_t v3 = 9;
    }
    else if ((a2 & 0xFE000000000000) != 0)
    {
      *(unsigned char *)uint64_t v2 = a2 | 0x80;
      uint64x2_t v7 = (uint64x2_t)vdupq_n_s64(a2);
      int16x8_t v8 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v7, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v7, (uint64x2_t)xmmword_1BDA822E0));
      v8.i64[0] = *(void *)&vmovn_s32((int32x4_t)v8) | 0x80008000800080;
      *(_DWORD *)(v2 + 1) = vmovn_s16(v8).u32[0];
      *(unsigned char *)(v2 + 5) = (a2 >> 35) | 0x80;
      *(unsigned char *)(v2 + 6) = (a2 >> 42) | 0x80;
      *(unsigned char *)(v2 + 7) = (a2 & 0xFE000000000000) >> 49;
      uint64_t v3 = 8;
    }
    else
    {
      *(unsigned char *)uint64_t v2 = a2 | 0x80;
      uint64x2_t v9 = (uint64x2_t)vdupq_n_s64(a2);
      int16x8_t v10 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v9, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v9, (uint64x2_t)xmmword_1BDA822E0));
      v10.i64[0] = *(void *)&vmovn_s32((int32x4_t)v10) | 0x80008000800080;
      *(_DWORD *)(v2 + 1) = vmovn_s16(v10).u32[0];
      if ((a2 & 0x1FC0000000000) != 0)
      {
        *(unsigned char *)(v2 + 5) = (a2 >> 35) | 0x80;
        *(unsigned char *)(v2 + 6) = (a2 & 0x1FC0000000000) >> 42;
        uint64_t v3 = 7;
      }
      else
      {
        *(unsigned char *)(v2 + 5) = (a2 >> 35) & 0x7F;
        uint64_t v3 = 6;
      }
    }
  }
  else if ((a2 & 0x7F0000000) != 0)
  {
    *(unsigned char *)uint64_t v2 = a2 | 0x80;
    *(unsigned char *)(v2 + 1) = (a2 >> 7) | 0x80;
    *(unsigned char *)(v2 + 2) = (a2 >> 14) | 0x80;
    *(unsigned char *)(v2 + 3) = (a2 >> 21) | 0x80;
    *(unsigned char *)(v2 + 4) = (a2 & 0x7F0000000) >> 28;
    uint64_t v3 = 5;
  }
  else if ((a2 & 0xFE00000) != 0)
  {
    *(unsigned char *)uint64_t v2 = a2 | 0x80;
    *(unsigned char *)(v2 + 1) = (a2 >> 7) | 0x80;
    *(unsigned char *)(v2 + 2) = (a2 >> 14) | 0x80;
    *(unsigned char *)(v2 + 3) = (a2 & 0xFE00000) >> 21;
    uint64_t v3 = 4;
  }
  else if ((a2 & 0x1FC000) != 0)
  {
    *(unsigned char *)uint64_t v2 = a2 | 0x80;
    *(unsigned char *)(v2 + 1) = (a2 >> 7) | 0x80;
    *(unsigned char *)(v2 + 2) = (a2 & 0x1FC000) >> 14;
    uint64_t v3 = 3;
  }
  else if ((a2 & 0x3F80) != 0)
  {
    *(unsigned char *)uint64_t v2 = a2 | 0x80;
    *(unsigned char *)(v2 + 1) = (a2 & 0x3F80) >> 7;
    uint64_t v3 = 2;
  }
  else
  {
    *(unsigned char *)uint64_t v2 = a2;
    uint64_t v3 = 1;
  }
  *result += v3;
  return result;
}

uint64_t openPayload(uint64_t a1, int a2, const char *a3, const char *a4, const char *a5, char *__str, int a7, char a8, unsigned __int8 a9, int a10, void *a11)
{
  char v12 = a7;
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  if (a7) {
    int v18 = 0;
  }
  else {
    int v18 = 536871426;
  }
  snprintf(__str, 0x400uLL, "%s%s", a3, a4);
  int v19 = (atomic_uint *)fd_create_protected(a2, __str, v18, 3u);
  if (v19)
  {
    int v20 = v19;
    if (a8)
    {
      uint64_t result = initPayload(a1, (uint64_t)v19, 0, v12, a9, a10, a11);
      if (result)
      {
        memset(&v47, 0, sizeof(v47));
        uint64_t v22 = *(void *)(a1 + 4488);
        if (!v22) {
          goto LABEL_28;
        }
        while (1)
        {
          int v23 = fstatat(*(_DWORD *)(v22 + 44), *(const char **)(v22 + 72), &v47, 2048);
          uint64_t v24 = g_prot_error_callback;
          if (v23 != -1 || g_prot_error_callback == 0) {
            break;
          }
          uint64_t v26 = *(unsigned int *)(v22 + 40);
          int v27 = __error();
          if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v24 + 16))(v24, v26, *v27, 8) & 1) == 0)goto LABEL_28; {
        }
          }
        if (v23 == -1)
        {
LABEL_28:
          int v37 = *__error();
          __int16 v38 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          {
            int v41 = *__error();
            *(_DWORD *)statfs buf = 136315650;
            int v59 = "openPayload";
            __int16 v60 = 1024;
            int v61 = 1212;
            __int16 v62 = 1024;
            int v63 = v41;
            _os_log_error_impl(&dword_1BD672000, v38, OS_LOG_TYPE_ERROR, "%s:%d: stat err: %d", buf, 0x18u);
          }
          BOOL v39 = __error();
          uint64_t result = 0;
          int *v39 = v37;
        }
        else if (v47.st_size >= *(void *)(a1 + 24))
        {
          return 1;
        }
        else
        {
          bzero(buf, 0x400uLL);
          int v34 = *__error();
          char v35 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            st_std::string::size_type size = v47.st_size;
            uint64_t v44 = *(void *)(a1 + 24);
            uint64_t v45 = fd_realpath(*(_DWORD **)(a1 + 4488), buf);
            *(_DWORD *)unint64_t v48 = 136316162;
            uint64_t v49 = "openPayload";
            int v46 = "";
            __int16 v50 = 1024;
            if (v45) {
              int v46 = v45;
            }
            int v51 = 1217;
            __int16 v52 = 2048;
            off_t v53 = st_size;
            __int16 v54 = 2048;
            uint64_t v55 = v44;
            __int16 v56 = 2080;
            int v57 = v46;
            _os_log_error_impl(&dword_1BD672000, v35, OS_LOG_TYPE_ERROR, "%s:%d: bad file size: %lldd, min size %lldd, %s\n", v48, 0x30u);
          }
          __int16 v36 = __error();
          uint64_t result = 0;
          *__int16 v36 = v34;
        }
      }
    }
    else
    {
      snprintf(__str, 0x400uLL, "%s%s", a3, a5);
      int v31 = fd_create_protected(a2, __str, v18, 3u);
      if (v31)
      {
        return initPayload(a1, (uint64_t)v20, (uint64_t)v31, v12, a9, a10, a11);
      }
      else
      {
        int v32 = *__error();
        gid_t v33 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        {
          int v42 = *__error();
          *(_DWORD *)statfs buf = 136315906;
          int v59 = "openPayload";
          __int16 v60 = 1024;
          int v61 = 1199;
          __int16 v62 = 1024;
          int v63 = v42;
          __int16 v64 = 2080;
          char v65 = __str;
          _os_log_error_impl(&dword_1BD672000, v33, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", buf, 0x22u);
        }
        *__error() = v32;
        fd_release(v20);
        return 0;
      }
    }
  }
  else
  {
    int v28 = *__error();
    CFRange v29 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      int v40 = *__error();
      *(_DWORD *)statfs buf = 136315906;
      int v59 = "openPayload";
      __int16 v60 = 1024;
      int v61 = 1187;
      __int16 v62 = 1024;
      int v63 = v40;
      __int16 v64 = 2080;
      char v65 = __str;
      _os_log_error_impl(&dword_1BD672000, v29, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", buf, 0x22u);
    }
    gid_t v30 = __error();
    uint64_t result = 0;
    *gid_t v30 = v28;
  }
  return result;
}

uint64_t indexRestoreFromBuffer(uint64_t a1, unsigned int **a2, int a3, unsigned int a4, unsigned int a5, unsigned char *a6, int a7)
{
  uint64_t v142 = *MEMORY[0x1E4F143B8];
  int16x8_t v10 = *a2;
  uint64_t result = indexRestoreHeaderFromBuffer((_DWORD *)a1, a2, a3, a4, a5, a6);
  if (!result) {
    return result;
  }
  int v12 = *(*a2)++;
  *(_DWORD *)(a1 + 60) = restoreVInt32_2563((char **)a2);
  *(_DWORD *)(a1 + 68) = restoreVInt32_2563((char **)a2);
  *(_DWORD *)(a1 + 72) = restoreVInt32_2563((char **)a2);
  *(void *)(a1 + 14936) = restoreVInt32_2563((char **)a2);
  *(void *)(a1 + 14944) = restoreVInt32_2563((char **)a2);
  if (*(_DWORD *)(a1 + 4) >= 0x57u)
  {
    *(void *)(a1 + 14952) = restoreVInt32_2563((char **)a2);
    *(void *)(a1 + 15008) = restoreVInt32_2563((char **)a2);
  }
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = *a2;
  do
  {
    uint64_t v17 = v14 + 1;
    char v18 = *((unsigned char *)v16 + v14);
    v15 |= (unint64_t)(v18 & 0x7F) << v13;
    if ((v18 & 0x80) == 0) {
      break;
    }
    uint64_t v14 = v17;
    BOOL v19 = v13 == 63;
    v13 += 7;
  }
  while (!v19);
  *a2 = (unsigned int *)((char *)v16 + v17);
  *(void *)(a1 + 80) = v15;
  *(_DWORD *)(a1 + 88) = 5336;
  atomic_store(restoreVInt32_2563((char **)a2), (unsigned int *)(a1 + 16));
  *(_DWORD *)(a1 + 52) = restoreVInt32_2563((char **)a2);
  *(void *)(a1 + 24) = restoreVInt32_2563((char **)a2);
  *(_DWORD *)(a1 + 96) = restoreVInt32_2563((char **)a2);
  *(_DWORD *)(a1 + 240) = restoreVInt32_2563((char **)a2);
  int v20 = restoreVInt32_2563((char **)a2);
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  *(_DWORD *)(a1 + 244) = v20;
  uint64_t v24 = *a2;
  do
  {
    char v25 = *((unsigned char *)v24 + v22++);
    v23 |= (unint64_t)(v25 & 0x7F) << v21;
    if ((v25 & 0x80) == 0) {
      break;
    }
    BOOL v19 = v21 == 63;
    v21 += 7;
  }
  while (!v19);
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  *a2 = (unsigned int *)((char *)v24 + v22);
  *(void *)(a1 + 4944) = v23;
  do
  {
    uint64_t v29 = v27 + 1;
    v28 |= (unint64_t)(*((unsigned char *)v24 + v27 + v22) & 0x7F) << v26;
    if ((*((unsigned char *)v24 + v27 + v22) & 0x80) == 0) {
      break;
    }
    ++v27;
    BOOL v19 = v26 == 63;
    v26 += 7;
  }
  while (!v19);
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  gid_t v33 = (unsigned int *)((char *)v24 + v22 + v29);
  *a2 = v33;
  *(void *)(a1 + 4952) = v28;
  *(void *)(a1 + 4960) = v28;
  int v34 = v33;
  do
  {
    ++v31;
    char v35 = *(unsigned char *)v34;
    int v34 = (unsigned int *)((char *)v34 + 1);
    v32 |= (unint64_t)(v35 & 0x7F) << v30;
    if ((v35 & 0x80) == 0) {
      break;
    }
    BOOL v19 = v30 == 63;
    v30 += 7;
  }
  while (!v19);
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  BOOL v39 = (unsigned int *)((char *)v33 + v31);
  *a2 = v39;
  *(void *)(a1 + 4968) = v32;
  do
  {
    ++v37;
    char v40 = *(unsigned char *)v34;
    int v34 = (unsigned int *)((char *)v34 + 1);
    v38 |= (unint64_t)(v40 & 0x7F) << v36;
    if ((v40 & 0x80) == 0) {
      break;
    }
    BOOL v19 = v36 == 63;
    v36 += 7;
  }
  while (!v19);
  *a2 = (unsigned int *)((char *)v39 + v37);
  *(void *)(a1 + 4976) = v38;
  *(_DWORD *)(a1 + 40) = restoreVInt32_2563((char **)a2);
  *(unsigned char *)(a1 + 44) = restoreVInt32_2563((char **)a2) != 0;
  *(_DWORD *)(a1 + 9400) = restoreVInt32_10044((char **)a2);
  unsigned int v41 = restoreVInt32_10044((char **)a2);
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  *(_DWORD *)(a1 + 9404) = v41;
  uint64_t v45 = *(unsigned int *)(a1 + 9400);
  *(void *)(a1 + 5216) = 8 * v45;
  *(void *)(a1 + 5208) = 8 * v41;
  int v46 = *a2;
  do
  {
    char v47 = *((unsigned char *)v46 + v43++);
    v44 |= (unint64_t)(v47 & 0x7F) << v42;
    if ((v47 & 0x80) == 0) {
      break;
    }
    BOOL v19 = v42 == 63;
    v42 += 7;
  }
  while (!v19);
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  *a2 = (unsigned int *)((char *)v46 + v43);
  *(void *)(a1 + 9664) = v44;
  do
  {
    uint64_t v51 = v49 + 1;
    v50 |= (unint64_t)(*((unsigned char *)v46 + v49 + v43) & 0x7F) << v48;
    if ((*((unsigned char *)v46 + v49 + v43) & 0x80) == 0) {
      break;
    }
    ++v49;
    BOOL v19 = v48 == 63;
    v48 += 7;
  }
  while (!v19);
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  uint64_t v54 = 0;
  uint64_t v55 = (unsigned int *)((char *)v46 + v43 + v51);
  *a2 = v55;
  *(void *)(a1 + 9672) = v50;
  *(void *)(a1 + 9680) = v50;
  __int16 v56 = v55;
  do
  {
    ++v53;
    char v57 = *(unsigned char *)v56;
    __int16 v56 = (unsigned int *)((char *)v56 + 1);
    v54 |= (unint64_t)(v57 & 0x7F) << v52;
    if ((v57 & 0x80) == 0) {
      break;
    }
    BOOL v19 = v52 == 63;
    v52 += 7;
  }
  while (!v19);
  int v139 = a7;
  uint64_t v58 = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  int v61 = (unsigned int *)((char *)v55 + v53);
  *a2 = v61;
  *(void *)(a1 + 9688) = v54;
  do
  {
    ++v59;
    char v62 = *(unsigned char *)v56;
    __int16 v56 = (unsigned int *)((char *)v56 + 1);
    v60 |= (unint64_t)(v62 & 0x7F) << v58;
    if ((v62 & 0x80) == 0) {
      break;
    }
    BOOL v19 = v58 == 63;
    v58 += 7;
  }
  while (!v19);
  *a2 = (unsigned int *)((char *)v61 + v59);
  *(void *)(a1 + 9696) = v60;
  restoreVInt32_2563((char **)a2);
  restoreVInt32_2563((char **)a2);
  *(_DWORD *)(a1 + 14120) = restoreVInt32_10044((char **)a2);
  unsigned int v63 = restoreVInt32_10044((char **)a2);
  *(_DWORD *)(a1 + 14124) = v63;
  uint64_t v64 = *(unsigned int *)(a1 + 14120);
  *(void *)(a1 + 9936) = 8 * v64;
  *(void *)(a1 + 9928) = 8 * v63;
  *(_DWORD *)(a1 + 120) = restoreVInt32_2977((char **)a2);
  *(void *)(a1 + 128) = restoreVInt32_2977((char **)a2);
  *(void *)(a1 + 136) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 144) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 148) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 152) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 156) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 160) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 164) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 168) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 172) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 176) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 180) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 184) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 188) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 192) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 196) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 200) = restoreVInt32_2977((char **)a2);
  *(_DWORD *)(a1 + 204) = restoreVInt32_2977((char **)a2);
  unint64_t v137 = *(void *)(a1 + 128);
  unint64_t v138 = *(void *)(a1 + 136);
  BOOL v65 = storageHeaderRestore(a1 + 256, (char **)a2);
  memset(__s, 0, sizeof(__s));
  __strlcpy_chk();
  *a2 = (unsigned int *)((char *)*a2 + strlen((const char *)(a1 + 15495)) + 1);
  __strlcpy_chk();
  *a2 = (unsigned int *)((char *)*a2 + strlen((const char *)(a1 + 15463)) + 1);
  __strlcpy_chk();
  *a2 = (unsigned int *)((char *)*a2 + strlen(__s) + 1);
  __strlcpy_chk();
  size_t v66 = strlen((const char *)(a1 + 15527));
  uint64_t v67 = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  uint64_t v70 = (uint64_t)*a2 + v66 + 1;
  *a2 = (unsigned int *)v70;
  do
  {
    char v71 = *(unsigned char *)(v70 + v68++);
    v69 |= (unint64_t)(v71 & 0x7F) << v67;
    if ((v71 & 0x80) == 0) {
      break;
    }
    BOOL v19 = v67 == 63;
    v67 += 7;
  }
  while (!v19);
  uint64_t v72 = 0;
  uint64_t v73 = 0;
  uint64_t v74 = 0;
  *a2 = (unsigned int *)(v70 + v68);
  *(void *)(a1 + 15560) = v69;
  do
  {
    uint64_t v75 = v73 + 1;
    char v76 = *(unsigned char *)(v70 + v73 + v68);
    v74 |= (unint64_t)(v76 & 0x7F) << v72;
    if ((v76 & 0x80) == 0) {
      break;
    }
    uint64_t v73 = v75;
    BOOL v19 = v72 == 63;
    v72 += 7;
  }
  while (!v19);
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  uint64_t v79 = 0;
  char v80 = (unsigned int *)(v70 + v68 + v75);
  *a2 = v80;
  *(void *)(a1 + 15584) = v74;
  uint64_t v81 = v80;
  do
  {
    ++v78;
    char v82 = *(unsigned char *)v81;
    uint64_t v81 = (unsigned int *)((char *)v81 + 1);
    v79 |= (unint64_t)(v82 & 0x7F) << v77;
    if ((v82 & 0x80) == 0) {
      break;
    }
    BOOL v19 = v77 == 63;
    v77 += 7;
  }
  while (!v19);
  uint64_t v83 = 0;
  uint64_t v84 = 0;
  uint64_t v85 = 0;
  uint64_t v86 = (unsigned int *)((char *)v80 + v78);
  *a2 = v86;
  *(void *)(a1 + 15592) = v79;
  do
  {
    ++v84;
    char v87 = *(unsigned char *)v81;
    uint64_t v81 = (unsigned int *)((char *)v81 + 1);
    v85 |= (unint64_t)(v87 & 0x7F) << v83;
    if ((v87 & 0x80) == 0) {
      break;
    }
    BOOL v19 = v83 == 63;
    v83 += 7;
  }
  while (!v19);
  uint64_t v88 = 0;
  uint64_t v89 = 0;
  uint64_t v90 = 0;
  unsigned int v91 = (unsigned int *)((char *)v86 + v84);
  *a2 = v91;
  *(void *)(a1 + 15600) = v85;
  do
  {
    ++v89;
    char v92 = *(unsigned char *)v81;
    uint64_t v81 = (unsigned int *)((char *)v81 + 1);
    v90 |= (unint64_t)(v92 & 0x7F) << v88;
    if ((v92 & 0x80) == 0) {
      break;
    }
    BOOL v19 = v88 == 63;
    v88 += 7;
  }
  while (!v19);
  uint64_t v93 = 0;
  uint64_t v94 = 0;
  uint64_t v95 = 0;
  int v96 = (unsigned int *)((char *)v91 + v89);
  *a2 = v96;
  *(void *)(a1 + 15608) = v90;
  do
  {
    ++v94;
    char v97 = *(unsigned char *)v81;
    uint64_t v81 = (unsigned int *)((char *)v81 + 1);
    v95 |= (unint64_t)(v97 & 0x7F) << v93;
    if ((v97 & 0x80) == 0) {
      break;
    }
    BOOL v19 = v93 == 63;
    v93 += 7;
  }
  while (!v19);
  uint64_t v98 = 0;
  uint64_t v99 = 0;
  uint64_t v100 = 0;
  int v101 = (unsigned int *)((char *)v96 + v94);
  *a2 = v101;
  *(void *)(a1 + 15616) = v95;
  do
  {
    ++v99;
    char v102 = *(unsigned char *)v81;
    uint64_t v81 = (unsigned int *)((char *)v81 + 1);
    v100 |= (unint64_t)(v102 & 0x7F) << v98;
    if ((v102 & 0x80) == 0) {
      break;
    }
    BOOL v19 = v98 == 63;
    v98 += 7;
  }
  while (!v19);
  uint64_t v103 = 0;
  uint64_t v104 = 0;
  uint64_t v105 = 0;
  int v106 = (char *)v101 + v99;
  *a2 = (unsigned int *)((char *)v101 + v99);
  *(void *)(a1 + 15624) = v100;
  do
  {
    ++v104;
    char v107 = *(unsigned char *)v81;
    uint64_t v81 = (unsigned int *)((char *)v81 + 1);
    v105 |= (unint64_t)(v107 & 0x7F) << v103;
    if ((v107 & 0x80) == 0) {
      break;
    }
    BOOL v19 = v103 == 63;
    v103 += 7;
  }
  while (!v19);
  uint64_t v108 = 0;
  uint64_t v109 = 0;
  uint64_t v110 = 0;
  int v111 = (unsigned int *)&v106[v104];
  *a2 = v111;
  *(void *)(a1 + 15632) = v105;
  do
  {
    ++v109;
    char v112 = *(unsigned char *)v81;
    uint64_t v81 = (unsigned int *)((char *)v81 + 1);
    v110 |= (unint64_t)(v112 & 0x7F) << v108;
    if ((v112 & 0x80) == 0) {
      break;
    }
    BOOL v19 = v108 == 63;
    v108 += 7;
  }
  while (!v19);
  *a2 = (unsigned int *)((char *)v111 + v109);
  *(void *)(a1 + 15640) = v110;
  *(void *)(a1 + 15576) = v74;
  *(void *)(a1 + 14984) = v79;
  *(void *)(a1 + 14992) = v85;
  *(void *)(a1 + 15032) = v90;
  *(void *)(a1 + 14960) = v95;
  *(void *)(a1 + 14968) = v100;
  *(void *)(a1 + 15024) = v105;
  if (v110) {
    uint64_t v69 = v110;
  }
  *(void *)(a1 + 15568) = v69;
  *(void *)(a1 + 15016) = *(void *)(a1 + 15648);
  int64_t v113 = (v12 - 4);
  uint64_t v114 = *a2;
  int64_t v115 = (char *)*a2 - (char *)v10;
  if (v115 < v113)
  {
    unsigned int v116 = *(_DWORD *)(a1 + 4);
    if (v139)
    {
      if (v116 >= 0x72)
      {
        uint64_t v117 = 0;
        uint64_t v118 = 0;
        uint64_t v119 = 0;
        do
        {
          char v120 = *((unsigned char *)v114 + v118++);
          v119 |= (unint64_t)(v120 & 0x7F) << v117;
          if ((v120 & 0x80) == 0) {
            break;
          }
          BOOL v19 = v117 == 63;
          v117 += 7;
        }
        while (!v19);
LABEL_91:
        uint64_t v114 = (unsigned int *)((char *)v114 + v118);
        *(void *)(a1 + 15656) = v119;
        int64_t v115 = (char *)v114 - (char *)v10;
      }
    }
    else if (v116 >= 0x65)
    {
      uint64_t v121 = 0;
      uint64_t v118 = 0;
      uint64_t v119 = 0;
      do
      {
        char v122 = *((unsigned char *)v114 + v118++);
        v119 |= (unint64_t)(v122 & 0x7F) << v121;
        if ((v122 & 0x80) == 0) {
          break;
        }
        BOOL v19 = v121 == 63;
        v121 += 7;
      }
      while (!v19);
      goto LABEL_91;
    }
  }
  BOOL v123 = v113 <= v115;
  int64_t v124 = v113 - v115;
  if (v123) {
    int64_t v124 = 0;
  }
  uint64_t v125 = (unsigned int *)((char *)v114 + v124);
  int v128 = *v125;
  unint64_t v126 = v125 + 1;
  int v127 = v128;
  *a2 = v126;
  if (v12 == v128)
  {
    BOOL v129 = (char *)v126 - (char *)v10 == v12 && v65;
    BOOL v130 = v129 && v138 >= v137;
    BOOL v131 = v130 && v63 >= v64;
    if (v131 && v41 >= v45) {
      return 1;
    }
  }
  int v133 = *__error();
  unint64_t v134 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
  {
    int v136 = *(_DWORD *)a2 - v10;
    *(_DWORD *)__s = 136316162;
    *(void *)&__s[4] = "indexRestoreFromBuffer";
    *(_WORD *)&__s[12] = 1024;
    *(_DWORD *)&__s[14] = 5451;
    *(_WORD *)&__s[18] = 1024;
    *(_DWORD *)&__s[20] = v12;
    *(_WORD *)&__s[24] = 1024;
    *(_DWORD *)&__s[26] = v127;
    *(_WORD *)&__s[30] = 1024;
    int v141 = v136;
    _os_log_error_impl(&dword_1BD672000, v134, OS_LOG_TYPE_ERROR, "%s:%d: invalid file (%d, %d, %d)\n", (uint8_t *)__s, 0x24u);
  }
  int v135 = __error();
  uint64_t result = 0;
  int *v135 = v133;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

uint64_t indexRestoreHeaderFromBuffer(_DWORD *a1, unsigned int **a2, int a3, unsigned int a4, unsigned int a5, unsigned char *a6)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  int v12 = *(*a2)++;
  a1[1] = v12;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    int v23 = 67109120;
    LODWORD(v24) = v12;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Restored header version %d", (uint8_t *)&v23, 8u);
  }
  if (a3 < (int)a4 || a3 > (int)a5 || v12 == a3)
  {
    if (v12 == a3)
    {
LABEL_8:
      uint64_t v14 = *a2;
      unsigned int v15 = *(*a2)++;
      atomic_store(v15, a1 + 8);
      unsigned int v16 = v14[1];
      *a2 = v14 + 2;
      atomic_store(v16, a1 + 9);
      unsigned int v17 = v14[2];
      *a2 = v14 + 3;
      a1[12] = v17;
      return 1;
    }
  }
  else
  {
    unsigned int v13 = a1[1];
    if (v13 >= a4 && v13 <= a5) {
      goto LABEL_8;
    }
  }
  if (a6) {
    *a6 = 1;
  }
  int v19 = *__error();
  int v20 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    int v22 = a1[1];
    int v23 = 136315906;
    uint64_t v24 = "indexRestoreHeaderFromBuffer";
    __int16 v25 = 1024;
    int v26 = 5309;
    __int16 v27 = 1024;
    int v28 = v22;
    __int16 v29 = 1024;
    int v30 = a3;
    _os_log_error_impl(&dword_1BD672000, v20, OS_LOG_TYPE_ERROR, "%s:%d: Invalid version (%d) expected (%d)", (uint8_t *)&v23, 0x1Eu);
  }
  uint64_t v21 = __error();
  uint64_t result = 0;
  *uint64_t v21 = v19;
  return result;
}

uint64_t restoreVInt32_2563(char **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (**a1 < 0)
  {
    int v4 = v1[1];
    if (v1[1] < 0)
    {
      int v5 = v1[2];
      if (v1[2] < 0)
      {
        int v7 = v1[3];
        if (v1[3] < 0)
        {
          int v9 = v1[4];
          if (v9 < 0)
          {
            int v12 = __si_assert_copy_extra_2445(0, -1);
            unsigned int v13 = v12;
            uint64_t v14 = "";
            if (v12) {
              uint64_t v14 = v12;
            }
            __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v14);
            free(v13);
            if (__valid_fs(-1))
            {
              MEMORY[0xBAD] = -559038737;
              abort();
            }
            MEMORY[0xC00] = -559038737;
            abort();
          }
          uint64_t v10 = ((v7 & 0x7F) << 21) | (v9 << 28) | ((v5 & 0x7F) << 14) | ((v4 & 0x7F) << 7) | (v2 & 0x7F);
          uint64_t v3 = 5;
          uint64_t v2 = v10;
        }
        else
        {
          uint64_t v8 = ((v5 & 0x7F) << 14) | (v7 << 21) | ((v4 & 0x7F) << 7) | (v2 & 0x7F);
          uint64_t v3 = 4;
          uint64_t v2 = v8;
        }
      }
      else
      {
        uint64_t v6 = ((v4 & 0x7F) << 7) | (v5 << 14) | (v2 & 0x7F);
        uint64_t v3 = 3;
        uint64_t v2 = v6;
      }
    }
    else
    {
      uint64_t v2 = v2 & 0x7F | (v4 << 7);
      uint64_t v3 = 2;
    }
  }
  else
  {
    uint64_t v3 = 1;
  }
  *a1 = &v1[v3];
  return v2;
}

void __openIndexShadow_block_invoke(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, int a9)
{
  uint64_t v9 = *(void *)(a1 + 32);
  *(_DWORD *)(v9 + 4920) += a9;
  if (a8 == 4) {
    writeVectorIndexDrop(*(unsigned int *)(v9 + 15716), a9, *(unsigned __int8 *)(v9 + 15203), *(const char **)(a1 + 40), a3);
  }
}

void writeVectorIndexDrop(uint64_t a1, int a2, int a3, const char *a4, int a5)
{
  int v20 = a5;
  int valuePtr = a2;
  int v19 = 4;
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFSetRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFNumberRef v10 = CFNumberCreate(v8, kCFNumberIntType, &valuePtr);
  if (v10)
  {
    CFNumberRef v11 = v10;
    CFDictionaryAddValue(Mutable, @"vectorcount", v10);
    CFRelease(v11);
  }
  int v12 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!a3) {
    int v12 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionaryAddValue(Mutable, @"readonly", *v12);
  if (a4)
  {
    CFStringRef v13 = CFStringCreateWithCString(v8, a4, 0x8000100u);
    if (v13)
    {
      CFStringRef v14 = v13;
      CFDictionaryAddValue(Mutable, @"prefix", v13);
      CFRelease(v14);
    }
  }
  CFNumberRef v15 = CFNumberCreate(v8, kCFNumberNSIntegerType, &v20);
  if (v15)
  {
    CFNumberRef v16 = v15;
    CFDictionaryAddValue(Mutable, @"propertyname", v15);
    CFRelease(v16);
  }
  CFNumberRef v17 = CFNumberCreate(v8, kCFNumberIntType, &v19);
  if (v17)
  {
    CFNumberRef v18 = v17;
    CFDictionaryAddValue(Mutable, @"dropreason", v17);
    CFRelease(v18);
  }
  if (Mutable)
  {
    (*(void (**)(uint64_t, uint64_t, __CFDictionary *))(sVectorIndexDropCallback + 16))(sVectorIndexDropCallback, a1, Mutable);
    CFRelease(Mutable);
  }
}

uint64_t index_read_index_id(int a1, const char *a2, char *__str)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexId");
  int v27 = -1;
  bzero(__p, 0x400uLL);
  int v6 = fcntl(a1, 50, __p);
  if (LOBYTE(__p[0])) {
    BOOL v7 = v6 < 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7) {
    CFAllocatorRef v8 = "";
  }
  else {
    CFAllocatorRef v8 = (const char *)__p;
  }
  size_t v9 = strlen(v8);
  if (v9 > 0x7FFFFFFFFFFFFFF7) {
LABEL_43:
  }
    abort();
  size_t v10 = v9;
  if (v9 >= 0x17)
  {
    uint64_t v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17) {
      uint64_t v12 = v9 | 7;
    }
    uint64_t v13 = v12 + 1;
    p_dst = (long long *)operator new(v12 + 1);
    *((void *)&__dst + 1) = v10;
    unint64_t v31 = v13 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_14;
  }
  HIBYTE(v31) = v9;
  p_dst = &__dst;
  if (v9) {
LABEL_14:
  }
    memcpy(p_dst, v8, v10);
  *((unsigned char *)p_dst + v10) = 0;
  *(_OWORD *)uint64_t v32 = __dst;
  unint64_t v33 = v31;
  long long __dst = 0uLL;
  unint64_t v31 = 0;
  size_t v14 = strlen(a2);
  if (v14 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_43;
  }
  CFNumberRef v15 = (void *)v14;
  if (v14 >= 0x17)
  {
    uint64_t v17 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v17 = v14 | 7;
    }
    uint64_t v18 = v17 + 1;
    CFNumberRef v16 = operator new(v17 + 1);
    v28[1] = v15;
    unint64_t v29 = v18 | 0x8000000000000000;
    v28[0] = v16;
    goto LABEL_22;
  }
  HIBYTE(v29) = v14;
  CFNumberRef v16 = v28;
  if (v14) {
LABEL_22:
  }
    memcpy(v16, a2, (size_t)v15);
  *((unsigned char *)v15 + (void)v16) = 0;
  IVFVectorIndex_s::metaFilename((std::string *)__p, (uint64_t)v32, (const void **)v28);
  LODWORD(v19) = IVFVectorIndex_s::readIndexId((uint64_t **)__p);
  if (SBYTE7(v35) < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v29) & 0x80000000) == 0)
    {
LABEL_25:
      if ((SHIBYTE(v33) & 0x80000000) == 0) {
        goto LABEL_26;
      }
LABEL_39:
      operator delete(v32[0]);
      if ((SHIBYTE(v31) & 0x80000000) == 0) {
        goto LABEL_27;
      }
      goto LABEL_40;
    }
  }
  else if ((SHIBYTE(v29) & 0x80000000) == 0)
  {
    goto LABEL_25;
  }
  operator delete(v28[0]);
  if (SHIBYTE(v33) < 0) {
    goto LABEL_39;
  }
LABEL_26:
  if ((SHIBYTE(v31) & 0x80000000) == 0) {
    goto LABEL_27;
  }
LABEL_40:
  operator delete((void *)__dst);
LABEL_27:
  if (v19 == -1) {
    uint64_t v19 = 0;
  }
  else {
    uint64_t v19 = v19;
  }
  if (!v19)
  {
    int v20 = (atomic_uint *)open_index_file(a1, __str, 0, 0, 0, 0, 0, 0, &v27);
    if (v20)
    {
      uint64_t v21 = v20;
      *(_OWORD *)std::string __p = 0u;
      long long v35 = 0u;
      int v22 = __p;
      fd_pread(v20, __p, 0x20uLL, 0);
      uint64_t v23 = 0;
      uint64_t v19 = 0;
      do
      {
        char v24 = *(unsigned char *)v22;
        int v22 = (void **)((char *)v22 + 1);
        v19 |= (unint64_t)(v24 & 0x7F) << v23;
        if ((v24 & 0x80) == 0) {
          break;
        }
        BOOL v25 = v23 == 63;
        v23 += 7;
      }
      while (!v25);
      fd_release(v21);
    }
    else
    {
      return 0;
    }
  }
  return v19;
}

char *openIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _DWORD *a9, int a10, uint64_t a11, uint64_t a12, const void *a13, int a14)
{
  int v14 = MEMORY[0x1F4188790](a1);
  CFNumberRef v16 = v15;
  uint64_t v297 = v17;
  unsigned int v19 = v18;
  int v296 = v20;
  uint64_t v22 = v21;
  uint64_t v24 = v23;
  int v26 = v25;
  int v27 = v14;
  uint64_t v321 = *MEMORY[0x1E4F143B8];
  bzero(v320, 0x400uLL);
  bzero(v319, 0x1000uLL);
  int *v16 = -1;
  unsigned int v293 = v19;
  int v291 = v19 & 0x100;
  if ((v19 & 0x100) != 0) {
    int v28 = 111;
  }
  else {
    int v28 = 95;
  }
  if ((v19 & 0x100) != 0) {
    int v29 = 114;
  }
  else {
    int v29 = 102;
  }
  long long v312 = 0u;
  long long v313 = 0u;
  if (v26) {
    int v30 = v26;
  }
  else {
    int v30 = "";
  }
  long long v310 = 0uLL;
  long long v311 = 0uLL;
  LODWORD(v310) = -1;
  int v31 = *__error();
  uint64_t v32 = _SILogForLogForCategory(10);
  os_log_type_t v33 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v32, v33))
  {
    buf[0].dev_t st_dev = 136315138;
    *(void *)&buf[0].st_mode = v30;
    _os_log_impl(&dword_1BD672000, v32, v33, "open index at %s", (uint8_t *)buf, 0xCu);
  }
  *__error() = v31;
  uint64_t result = (char *)malloc_type_calloc(1uLL, 0x3D68uLL, 0x10F0040F3430A86uLL);
  if (!result)
  {
    int *v16 = -1;
    return result;
  }
  uint64_t v279 = v22;
  unsigned int v280 = v29;
  unsigned int v281 = v28;
  long long v298 = v16;
  int v290 = v27;
  long long v35 = result;
  uint64_t v36 = (char *)v30;
  uint64_t v37 = (BOOL *)(result + 15202);
  uint64_t v38 = (atomic_uint *)result;
  initIndex((uint64_t)result, a13);
  unint64_t v294 = (char *)(v38 + 3802);
  uint64_t v289 = v36;
  uint64_t v39 = (uint64_t)v35;
  __strlcpy_chk();
  *((void *)v35 + 10) = v24;
  *((_DWORD *)v35 + 22) = 1899;
  *((_DWORD *)v35 + 16) = v27;
  *((_DWORD *)v35 + 3929) = a14;
  BOOL *v37 = (v293 & 0x10) != 0;
  char v40 = v37;
  v35[45] = BYTE1(v291);
  v35[46] = (v293 & 0x400) != 0;
  long long v295 = v38;
  atomic_fetch_and(v38 + 9, 0xFFFFF7FF);
  atomic_fetch_or(v38 + 9, 0x800u);
  *(_WORD *)(v37 + 511) = 0;
  bzero(&v318, 0x878uLL);
  if (fstatfs(v27, &v318))
  {
    int v41 = *__error();
    uint64_t v42 = _SILogForLogForCategory(10);
    int v43 = v296;
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      buf[0].dev_t st_dev = 136315650;
      *(void *)&buf[0].st_mode = "openIndex";
      WORD2(buf[0].st_ino) = 1024;
      *(_DWORD *)((char *)&buf[0].st_ino + 6) = 1918;
      HIWORD(buf[0].st_uid) = 2080;
      *(void *)&buf[0].st_gid = v279;
      _os_log_error_impl(&dword_1BD672000, v42, OS_LOG_TYPE_ERROR, "%s:%d: Couldn't statfs parent directory: %s", (uint8_t *)buf, 0x1Cu);
    }
    uint64_t v44 = v298;
    uint64_t v45 = v289;
  }
  else
  {
    int v46 = *(_DWORD *)v318.f_fstypename;
    BOOL v47 = *(_DWORD *)v318.f_fstypename == 1634105445 && *(unsigned __int16 *)&v318.f_fstypename[4] == 116;
    char v48 = v47;
    v37[511] = v48;
    BOOL v49 = 1;
    int v43 = v296;
    if (v46 ^ 0x73667061 | v318.f_fstypename[4])
    {
      uint64_t v44 = v298;
      uint64_t v45 = v289;
      if (v46 != 7562856) {
        BOOL v49 = *(_DWORD *)v318.f_fstypename == 1634105445 && *(unsigned __int16 *)&v318.f_fstypename[4] == 116
      }
           || *(_DWORD *)v318.f_fstypename == 1868854125 && *(unsigned __int16 *)&v318.f_fstypename[4] == 115;
    }
    else
    {
      uint64_t v44 = v298;
      uint64_t v45 = v289;
    }
    BOOL v52 = 0;
    if ((v293 & 0x8000) != 0 && v49) {
      BOOL v52 = (v293 & 0x20) == 0;
    }
    v40[512] = v52;
    int v41 = *__error();
    uint64_t v53 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v54 = v40[512];
      buf[0].dev_t st_dev = 136316162;
      *(void *)&buf[0].st_mode = v45;
      WORD2(buf[0].st_ino) = 2080;
      BOOL v47 = !v54;
      uint64_t v55 = "";
      if (v47) {
        uint64_t v55 = "not";
      }
      *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 6) = (__darwin_ino64_t)v55;
      HIWORD(buf[0].st_gid) = 2080;
      *(void *)&buf[0].st_rdev = v318.f_fstypename;
      LOWORD(buf[0].st_atimespec.tv_sec) = 1024;
      *(_DWORD *)((char *)&buf[0].st_atimespec.tv_sec + 2) = (v293 >> 15) & 1;
      HIWORD(buf[0].st_atimespec.tv_sec) = 1024;
      LODWORD(buf[0].st_atimespec.tv_nsec) = (v293 >> 5) & 1;
      _os_log_impl(&dword_1BD672000, v53, OS_LOG_TYPE_DEFAULT, "openIndex(%s) VectorIndex %s supported on %s isLocalVolume: %d, isBackup: %d", (uint8_t *)buf, 0x2Cu);
    }
  }
  *__error() = v41;
  snprintf(v320, 0x400uLL, "%s%s", v45, "indexHead");
  if (v43) {
    int v56 = 0;
  }
  else {
    int v56 = 2;
  }
  char v57 = open_index_file(v27, v320, v56, 4096, 4096, 0, 0, 0, v44);
  *(void *)(v39 + 14480) = v57;
  if (!v57) {
    goto LABEL_238;
  }
  int v58 = v43;
  if ((v43 & 1) == 0)
  {
    uint64_t v59 = v40;
    uint64_t v60 = v57;
    *(void *)&buf[0].dev_t st_dev = 0;
    int v61 = _fd_acquire_fd((uint64_t)v57, buf);
    if (v61 != -1)
    {
      int v62 = v61;
      *((_WORD *)v60 + 28) |= 1u;
      fcntl(v61, 48, 1);
      fcntl(v62, 76, v60[7] & 1);
      int v63 = v62;
      int v58 = v43;
      _fd_release_fd(v60, v63, 0, *(uint64_t *)&buf[0].st_dev);
    }
    char v40 = v59;
  }
  int index_id = index_read_index_id(v27, v45, v320);
  *(_DWORD *)(v39 + 56) = index_id;
  if (a12 && !index_id && (v58 & 1) == 0) {
    *(_DWORD *)(v39 + 56) = (*(uint64_t (**)(uint64_t, void))(a12 + 16))(a12, 0);
  }
  BOOL v65 = *(_DWORD **)(v39 + 14480);
  if (!v65) {
    goto LABEL_236;
  }
  uint64_t v66 = fd_pread(v65, v319, 0x1000uLL, 0);
  if (v66 != 4096)
  {
    if (v66 != -1) {
      goto LABEL_236;
    }
    int v67 = *__error();
    if (v67)
    {
LABEL_237:
      *uint64_t v44 = v67;
      goto LABEL_238;
    }
  }
  int v68 = v58;
  uint64_t v309 = v319;
  if (!indexRestoreFromBuffer(v39, &v309, a10, v281, v280, 0, v291 != 0)) {
    goto LABEL_238;
  }
  int v69 = *__error();
  uint64_t v70 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
  {
    int v71 = *(_DWORD *)(v39 + 56);
    buf[0].dev_t st_dev = 67109378;
    *(_DWORD *)&buf[0].st_mode = v71;
    LOWORD(buf[0].st_ino) = 2080;
    *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 2) = (__darwin_ino64_t)v320;
    _os_log_impl(&dword_1BD672000, v70, OS_LOG_TYPE_DEFAULT, "open indexid %u at %s", (uint8_t *)buf, 0x12u);
  }
  *__error() = v69;
  if ((v293 & 0x400) != 0) {
    goto LABEL_70;
  }
  unsigned int v72 = *(_DWORD *)(v39 + 4);
  if (v291)
  {
    if (v72 <= 0x70) {
      goto LABEL_71;
    }
LABEL_70:
    *(unsigned char *)(v39 + 46) = 1;
    goto LABEL_71;
  }
  if (v72 == 98 || v72 >= 0x64) {
    goto LABEL_70;
  }
LABEL_71:
  if (v68) {
    v40[1] = 1;
  }
  char v73 = atomic_load((unsigned int *)v295 + 9);
  unsigned int v74 = atomic_load((unsigned int *)v295 + 9);
  unsigned int v75 = atomic_load((unsigned int *)v295 + 8);
  if (v75 == -1073623027)
  {
    uint64_t v76 = *(unsigned int *)(v39 + 72);
    if (*(unsigned char *)(v39 + 45)) {
      unint64_t v77 = (unint64_t)(v76 + 3) >> 2;
    }
    else {
      unint64_t v77 = (v76 + 4) / 5uLL;
    }
    size_t v84 = (8 * *MEMORY[0x1E4F14B00] - 1 + v77) / (8 * *MEMORY[0x1E4F14B00]);
    malloc_type_id_t v85 = 2012446981;
LABEL_89:
    *(void *)(v39 + 14440) = malloc_type_calloc(1uLL, v84, v85);
    int v83 = 1;
    goto LABEL_90;
  }
  unsigned int v78 = atomic_load((unsigned int *)v295 + 8);
  if (v78 == 1)
  {
    unsigned int v79 = *(_DWORD *)(v39 + 60);
    if (*(_DWORD *)(v39 + 68) > v79) {
      *(_DWORD *)(v39 + 68) = v79 + 1;
    }
    uint64_t v80 = *(unsigned int *)(v39 + 72);
    if (*(unsigned char *)(v39 + 45)) {
      unint64_t v81 = (unint64_t)(v80 + 3) >> 2;
    }
    else {
      unint64_t v81 = (v80 + 4) / 5uLL;
    }
    size_t v84 = (8 * *MEMORY[0x1E4F14B00] - 1 + v81) / (8 * *MEMORY[0x1E4F14B00]);
    malloc_type_id_t v85 = 615778698;
    goto LABEL_89;
  }
  unsigned int v82 = atomic_load((unsigned int *)v295 + 8);
  if (v82 == -804450864)
  {
    int v83 = 0;
LABEL_90:
    int v87 = 0;
    goto LABEL_91;
  }
  unsigned int v86 = atomic_load((unsigned int *)v295 + 8);
  if (v86 != 2)
  {
    unsigned int v110 = *(_DWORD *)(v39 + 60);
    if (*(_DWORD *)(v39 + 68) > v110) {
      *(_DWORD *)(v39 + 68) = v110 + 1;
    }
    goto LABEL_238;
  }
  int v87 = 1;
  int v83 = 1;
LABEL_91:
  int v88 = v83;
  int v285 = v56;
  int v286 = v87;
  snprintf(v320, 0x400uLL, "%s%s", v289, "indexIds");
  uint64_t v89 = *(unsigned int *)(v39 + 68);
  uint64_t v90 = *(unsigned int *)(v39 + 72);
  if (v89 >= 2) {
    off_t v91 = 8 * v89;
  }
  else {
    off_t v91 = 0;
  }
  int v292 = v88;
  if (v89 <= v90)
  {
    off_t v92 = 8 * v90;
  }
  else
  {
    *(_DWORD *)(v39 + 72) = v89;
    off_t v92 = 8 * v89;
  }
  char v287 = v73;
  if (v43) {
    uint64_t v93 = 1;
  }
  else {
    uint64_t v93 = 3;
  }
  int v94 = v43 | ((v73 & 2) >> 1);
  uint64_t v95 = open_index_file(v290, v320, v285, v92, v91, v94 ^ 1u, (uint64_t *)v295 + 1801, v93, v44);
  *(void *)(v39 + 14448) = v95;
  if (!v95) {
    goto LABEL_238;
  }
  uint64_t v288 = v40;
  snprintf(v320, 0x400uLL, "%s%s", v289, "indexBigDates");
  uint64_t v96 = *(unsigned int *)(v39 + 68);
  if (v96 >= 2) {
    off_t v97 = 4 * v96;
  }
  else {
    off_t v97 = 0;
  }
  uint64_t v98 = open_index_file(v290, v320, v285, 4 * *(unsigned int *)(v39 + 72), v97, v94 ^ 1u, (uint64_t *)v295 + 1802, v93, v44);
  *(void *)(v39 + 14456) = v98;
  if (!v98) {
    *(void *)(v39 + 14456) = open_index_file(v290, v320, 1538, 4 * *(unsigned int *)(v39 + 72), 0, 1, (uint64_t *)v295 + 1802, 3, v44);
  }
  if (v291)
  {
    snprintf(v320, 0x400uLL, "%s%s", v289, "indexScores");
    uint64_t v99 = *(unsigned int *)(v39 + 68);
    off_t v100 = v99 >= 2 ? 8 * v99 : 0;
    int v101 = open_index_file(v290, v320, v285, 8 * *(unsigned int *)(v39 + 72), v100, v43 ^ 1u, (uint64_t *)v295 + 1803, v93, v44);
    *(void *)(v39 + 14464) = v101;
    if (!v101) {
      *(void *)(v39 + 14464) = open_index_file(v290, v320, 1538, 8 * *(unsigned int *)(v39 + 72), 0, 1, (uint64_t *)v295 + 1803, 3, v44);
    }
  }
  snprintf(v320, 0x400uLL, "%s%s", v289, "indexGroups");
  unsigned int v102 = *(_DWORD *)(v39 + 72);
  if (*(unsigned char *)(v39 + 45))
  {
    unsigned int v103 = *(_DWORD *)(v39 + 68);
  }
  else
  {
    unsigned int v102 = (4 * v102 + 4) / 5;
    unsigned int v103 = (4 * *(_DWORD *)(v39 + 68) + 4) / 5u;
  }
  uint64_t v104 = open_index_file(v290, v320, v285, v102, v103, v94 ^ 1u, (uint64_t *)v295 + 1804, v93, v44);
  *(void *)(v39 + 14472) = v104;
  if (!v104) {
    goto LABEL_238;
  }
  if (!openPayload((uint64_t)(v295 + 1236), *(_DWORD *)(v39 + 64), v289, "indexPostings", "indexTermIds", v320, v94, (v74 & 4) != 0, 1u, *(_DWORD *)(v39 + 4), *(void **)(v39 + 4936)))goto LABEL_238; {
  if (!openPayload((uint64_t)(v295 + 2416), *(_DWORD *)(v39 + 64), v289, "indexPositions", "indexPositionTable", v320, v94, (v74 & 4) != 0, 1u, *(_DWORD *)(v39 + 4), *(void **)(v39 + 4936)))goto LABEL_238;
  }
  int v105 = (v74 >> 2) & 1;
  int v106 = v289;
  if (!bt_openTrie((uint64_t)(v295 + 24), *(_DWORD *)(v39 + 64), v289, v105, v94, 0, *(_DWORD *)(v39 + 4), *(void **)(v39 + 4936)))goto LABEL_238; {
  int v107 = v290;
  }
  char v108 = v68;
  if ((v293 & 0x40) != 0)
  {
    uint64_t v109 = openForwardStore(*(_DWORD *)(v39 + 64), v289, (v293 >> 14) & 1, v68, 0, *(void **)(v39 + 4936));
    *(void *)(v39 + 4928) = v109;
    if (v109)
    {
      atomic_fetch_or(v295 + 9, 0x80u);
    }
    else
    {
      int v111 = *__error();
      char v112 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
      {
        buf[0].dev_t st_dev = 136315394;
        *(void *)&buf[0].st_mode = "openIndex";
        WORD2(buf[0].st_ino) = 1024;
        *(_DWORD *)((char *)&buf[0].st_ino + 6) = 2048;
        _os_log_error_impl(&dword_1BD672000, v112, OS_LOG_TYPE_ERROR, "%s:%d: Failed to open path index", (uint8_t *)buf, 0x12u);
      }
      *__error() = v111;
      if (!v291) {
        goto LABEL_238;
      }
      *(void *)(v39 + 4928) = 0;
      int v113 = *__error();
      uint64_t v114 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
      {
        buf[0].dev_t st_dev = 136315394;
        *(void *)&buf[0].st_mode = "openIndex";
        WORD2(buf[0].st_ino) = 1024;
        *(_DWORD *)((char *)&buf[0].st_ino + 6) = 2051;
        _os_log_error_impl(&dword_1BD672000, v114, OS_LOG_TYPE_ERROR, "%s:%d: Ignoring failed dirstore open for corespotlight", (uint8_t *)buf, 0x12u);
      }
      *__error() = v113;
      int v107 = v290;
      int v106 = v289;
      char v108 = v68;
    }
  }
  if (*(void *)(v39 + 4928))
  {
    char v115 = atomic_load((unsigned int *)v295 + 9);
    if ((v115 & 0x24) == 4)
    {
      if (*(_DWORD *)(v39 + 52))
      {
        memset(buf, 0, 144);
        if (fd_stat(*(void *)(v39 + 9432), buf) == -1) {
          goto LABEL_148;
        }
        st_std::string::size_type size = buf[0].st_size;
        if (buf[0].st_size < 0x100000001uLL) {
          goto LABEL_148;
        }
        LOBYTE(v300) = 0;
        *(unsigned char *)(v39 + 8) = 1;
        int v117 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
        unint64_t v118 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, v39, 0, v117);
        unsigned int v308 = HIDWORD(v118);
        LODWORD(v301[0]) = v118;
        unsigned int v307 = v119;
        unsigned int v306 = v120;
        uint64_t v121 = *(void *)&threadData[18 * v118 + 2];
        uint64_t v122 = v121 + 320 * HIDWORD(v118);
        *(unsigned char *)(v122 + 216) = 0;
        int v123 = *(_DWORD *)(v122 + 312);
        int64_t v124 = *(void (**)(void))(v122 + 224);
        if (v124) {
          v124(*(void *)(v121 + 320 * HIDWORD(v118) + 288));
        }
        unsigned int v305 = v301[0];
        unsigned int v304 = v308;
        unsigned int v303 = v307;
        unsigned int v302 = v306;
        if (_setjmp((int *)v122))
        {
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint64_t v314 = 0;
            _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v314, 2u);
          }
          *(_DWORD *)(v122 + 312) = v123;
          CIOnThreadCleanUpReset(v302);
          dropThreadId(v305, 1, v117);
          CICleanUpReset(v305, v303);
          uint64_t v125 = 0;
        }
        else
        {
          CompactTermunint64_t Offset = trieLastCompactTermOffset((uint64_t)(v295 + 24));
          int v127 = *__error();
          int v128 = _SILogForLogForCategory(10);
          os_log_type_t v129 = 2 * (dword_1E9FC90CC < 4);
          if (os_log_type_enabled(v128, v129))
          {
            *(_DWORD *)uint64_t v314 = 134217984;
            *(void *)&v314[4] = CompactTermOffset;
            _os_log_impl(&dword_1BD672000, v128, v129, "last term offset: %llu", v314, 0xCu);
          }
          *__error() = v127;
          LOBYTE(v300) = 1;
          uint64_t v130 = *(void *)&threadData[18 * v305 + 2];
          unsigned int v131 = v304;
          uint64_t v132 = v130 + 320 * v304;
          *(_DWORD *)(v132 + 312) = v123;
          int v133 = *(void (**)(void))(v132 + 232);
          if (v133) {
            v133(*(void *)(v130 + 320 * v131 + 288));
          }
          dropThreadId(v305, 0, v117);
          uint64_t v125 = CompactTermOffset;
          uint64_t v44 = v298;
        }
        *(unsigned char *)(v39 + 8) = 0;
        if ((_BYTE)v300)
        {
          uint64_t v134 = *(void *)(v39 + 4928);
          *(void *)(v134 + 4440) = v125;
          *(void *)(v134 + 4448) = st_size;
          int v43 = v296;
          char v40 = v288;
          int v107 = v290;
          char v108 = v68;
LABEL_148:
          int v106 = v289;
          goto LABEL_149;
        }
LABEL_236:
        int v67 = -1;
        goto LABEL_237;
      }
    }
  }
LABEL_149:
  if (_os_feature_enabled_impl() && v40[512])
  {
    int v135 = *__error();
    int v136 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
    {
      int v137 = *(_DWORD *)(v39 + 56);
      buf[0].dev_t st_dev = 67109120;
      *(_DWORD *)&buf[0].st_mode = v137;
      _os_log_impl(&dword_1BD672000, v136, OS_LOG_TYPE_DEFAULT, "open vector index for indexid %d", (uint8_t *)buf, 8u);
    }
    *__error() = v135;
    if ((v293 & 0x2000) != 0)
    {
      bzero(buf, 0x400uLL);
      int v152 = fcntl(v107, 50, buf);
      if (LOBYTE(buf[0].st_dev)) {
        BOOL v153 = v152 < 0;
      }
      else {
        BOOL v153 = 1;
      }
      if (v153) {
        uint64_t v154 = 0;
      }
      else {
        uint64_t v154 = (IVFVectorIndex_s *)buf;
      }
      int v106 = v289;
      IVFVectorIndex_s::unlink(v154, v289, 0);
      writeVectorIndexDrop(*(unsigned int *)(v39 + 15716), 1, v40[1], v289, 0);
    }
    else
    {
      int v106 = v289;
      if (*(_DWORD *)(v39 + 56))
      {
        if ((v108 & 1) == 0) {
          atomic_load((unsigned int *)v295 + 9);
        }
        _OWORD v301[2] = (void *)MEMORY[0x1E4F143A8];
        void v301[3] = (void *)0x40000000;
        v301[4] = __openIndex_block_invoke;
        v301[5] = &__block_descriptor_tmp_16_2604;
        v301[6] = (void *)v39;
        v301[7] = v289;
        openVectorIndex();
      }
    }
  }
  else
  {
    bzero(buf, 0x400uLL);
    int v138 = fcntl(v107, 50, buf);
    if (LOBYTE(buf[0].st_dev)) {
      BOOL v139 = v138 < 0;
    }
    else {
      BOOL v139 = 1;
    }
    if (v139) {
      uint64_t v140 = 0;
    }
    else {
      uint64_t v140 = (IVFVectorIndex_s *)buf;
    }
    IVFVectorIndex_s::unlink(v140, v106, 0);
  }
  if ((v293 & 0x1100) == 0x100)
  {
    snprintf(v320, 0x400uLL, "%s%s", v106, "topK.v2.mdplistc");
    int v141 = fd_create_protected(v107, v320, 0, 0);
    *(void *)(v39 + 14488) = v141;
    if (v141)
    {
      memset(buf, 0, 144);
      if (fd_stat((uint64_t)v141, buf) != -1)
      {
        uint64_t v142 = fd_mmap(*(void *)(v39 + 14488));
        if (v142 != -1)
        {
          int v143 = (void *)v142;
          *(void *)uint64_t v314 = v142;
          *(void *)&v314[8] = buf[0].st_size;
          *(void *)&v314[16] = 0;
          v301[0] = (void *)1;
          v301[1] = v314;
          int v144 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
          unsigned int v308 = 0;
          unsigned int v307 = 0;
          unsigned int v306 = 0;
          unsigned int v305 = 0;
          unint64_t v145 = setThreadIdAndInfo(-1, (long long *)sMappingExceptionCallbacks, (uint64_t)v301, 0, v144);
          unsigned int v307 = HIDWORD(v145);
          unsigned int v308 = v145;
          unsigned int v306 = v146;
          unsigned int v305 = v147;
          uint64_t v148 = *(void *)&threadData[18 * v145 + 2];
          uint64_t v149 = v148 + 320 * HIDWORD(v145);
          *(unsigned char *)(v149 + 216) = 0;
          int v150 = *(_DWORD *)(v149 + 312);
          unint64_t v151 = *(void (**)(void))(v149 + 224);
          if (v151) {
            v151(*(void *)(v148 + 320 * HIDWORD(v145) + 288));
          }
          unsigned int v304 = v308;
          unsigned int v303 = v307;
          unsigned int v302 = v306;
          unsigned int v300 = v305;
          if (_setjmp((int *)v149))
          {
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long v299 = 0;
              _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v299, 2u);
            }
            *(_DWORD *)(v149 + 312) = v150;
            CIOnThreadCleanUpReset(v300);
            dropThreadId(v304, 1, v144);
            CICleanUpReset(v304, v302);
          }
          else
          {
            *(void *)(v39 + 14496) = _MDPlistContainerCreateWithBytes();
            uint64_t v155 = *(void *)&threadData[18 * v304 + 2];
            unsigned int v156 = v303;
            uint64_t v157 = v155 + 320 * v303;
            *(_DWORD *)(v157 + 312) = v150;
            double v158 = *(void (**)(void))(v157 + 232);
            if (v158) {
              v158(*(void *)(v155 + 320 * v156 + 288));
            }
            dropThreadId(v304, 0, v144);
          }
          int v107 = v290;
          if (!*(void *)(v39 + 14496)) {
            munmap(v143, buf[0].st_size);
          }
        }
      }
    }
  }
  unint64_t v159 = *(void *)(v39 + 15576);
  if (v159)
  {
    LOBYTE(v302) = 0;
    *(unsigned char *)(v39 + 8) = 1;
    int v160 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    *(_DWORD *)uint64_t v314 = 0;
    LODWORD(v301[0]) = 0;
    unsigned int v308 = 0;
    unsigned int v307 = 0;
    unint64_t v161 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, v39, 0, v160);
    LODWORD(v301[0]) = HIDWORD(v161);
    *(_DWORD *)uint64_t v314 = v161;
    unsigned int v308 = v162;
    unsigned int v307 = v163;
    uint64_t v164 = *(void *)&threadData[18 * v161 + 2];
    uint64_t v165 = v164 + 320 * HIDWORD(v161);
    *(unsigned char *)(v165 + 216) = 0;
    int v166 = *(_DWORD *)(v165 + 312);
    uint64_t v167 = *(void (**)(void))(v165 + 224);
    if (v167) {
      v167(*(void *)(v164 + 320 * HIDWORD(v161) + 288));
    }
    unsigned int v306 = *(_DWORD *)v314;
    unsigned int v305 = v301[0];
    unsigned int v304 = v308;
    unsigned int v303 = v307;
    if (_setjmp((int *)v165))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf[0].st_dev) = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)buf, 2u);
      }
      *(_DWORD *)(v165 + 312) = v166;
      CIOnThreadCleanUpReset(v303);
      dropThreadId(v306, 1, v160);
      CICleanUpReset(v306, v304);
      int v107 = v290;
      goto LABEL_226;
    }
    __darwin_ino64_t v168 = **(void **)(v39 + 104);
    unint64_t v169 = **(void **)(v39 + 112);
    unint64_t v170 = *(void *)storageResolvePtr((uint64_t)(v295 + 64), 0, 8, 1);
    uint64_t v171 = *(void *)(v39 + 4928);
    if (v171) {
      unint64_t v172 = *(void *)storageResolvePtr(v171 + 8, 0, 8, 1);
    }
    else {
      unint64_t v172 = 0;
    }
    unint64_t v278 = v172;
    __darwin_ino64_t v276 = v168;
    int v277 = *__error();
    uint64_t v173 = _SILogForLogForCategory(10);
    unint64_t v174 = v173;
    if (v168 <= v159 && v169 <= v159 && v170 <= v159 && v278 <= v159)
    {
      os_log_type_t v175 = 2 * (dword_1E9FC90CC < 4);
      if (os_log_type_enabled(v173, v175))
      {
        buf[0].dev_t st_dev = 134219008;
        *(void *)&buf[0].st_mode = v159;
        WORD2(buf[0].st_ino) = 2048;
        *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 6) = v276;
        HIWORD(buf[0].st_gid) = 2048;
        *(void *)&buf[0].st_rdev = v169;
        LOWORD(buf[0].st_atimespec.tv_sec) = 2048;
        *(__darwin_time_t *)((char *)&buf[0].st_atimespec.tv_sec + 2) = v170;
        WORD1(buf[0].st_atimespec.tv_nsec) = 2048;
        *(uint64_t *)((char *)&buf[0].st_atimespec.tv_nsec + 4) = v278;
        _os_log_impl(&dword_1BD672000, v174, v175, "head:%lld fat:%lld compact:%lld flat:%lld dir:%lld", (uint8_t *)buf, 0x34u);
      }
      *__error() = v277;
      LOBYTE(v302) = 1;
      int v107 = v290;
      goto LABEL_223;
    }
    if (os_log_type_enabled(v173, OS_LOG_TYPE_ERROR))
    {
      buf[0].dev_t st_dev = 136316674;
      *(void *)&buf[0].st_mode = "openIndex";
      WORD2(buf[0].st_ino) = 1024;
      *(_DWORD *)((char *)&buf[0].st_ino + 6) = 2165;
      HIWORD(buf[0].st_uid) = 2048;
      *(void *)&buf[0].st_gid = v168;
      *((_WORD *)&buf[0].st_rdev + 2) = 2048;
      *(void *)((char *)&buf[0].st_rdev + 6) = v169;
      HIWORD(buf[0].st_atimespec.tv_sec) = 2048;
      buf[0].st_atimespec.tv_nsec = v170;
      LOWORD(buf[0].st_mtimespec.tv_sec) = 2048;
      *(__darwin_time_t *)((char *)&buf[0].st_mtimespec.tv_sec + 2) = v278;
      WORD1(buf[0].st_mtimespec.tv_nsec) = 2048;
      *(uint64_t *)((char *)&buf[0].st_mtimespec.tv_nsec + 4) = v159;
      _os_log_error_impl(&dword_1BD672000, v174, OS_LOG_TYPE_ERROR, "%s:%d: unexpected sync count %lld %lld %lld %lld, expected %lld", (uint8_t *)buf, 0x44u);
    }
    *__error() = v277;
    BOOL v177 = v168 == v169 && v169 == v170;
    if (v291)
    {
      int v107 = v290;
      if (!v177 || v168 != v159 + 1 || v278 > v159 + 1) {
        goto LABEL_223;
      }
    }
    else
    {
      if (v170 != v278) {
        BOOL v177 = 0;
      }
      int v107 = v290;
      if (!v177 || v278 != v159 + 1) {
        goto LABEL_223;
      }
    }
    LOBYTE(v302) = 1;
LABEL_223:
    uint64_t v178 = *(void *)&threadData[18 * v306 + 2];
    unsigned int v179 = v305;
    uint64_t v180 = v178 + 320 * v305;
    *(_DWORD *)(v180 + 312) = v166;
    unsigned int v181 = *(void (**)(void))(v180 + 232);
    if (v181) {
      v181(*(void *)(v178 + 320 * v179 + 288));
    }
    dropThreadId(v306, 0, v160);
LABEL_226:
    *(unsigned char *)(v39 + 8) = 0;
    if ((_BYTE)v302) {
      goto LABEL_227;
    }
    goto LABEL_236;
  }
LABEL_227:
  unsigned int v182 = v288;
  if ((v287 & 2) != 0) {
    goto LABEL_228;
  }
  snprintf(v320, 0x400uLL, "%s%s", v289, "indexUpdates");
  if ((v293 & 0x1000) != 0)
  {
    if (!v286) {
      goto LABEL_258;
    }
    uint64_t v204 = __si_assert_copy_extra_2445(0, -1);
    uint64_t v205 = v204;
    uint64_t v206 = "";
    if (v204) {
      uint64_t v206 = v204;
    }
    uint64_t v274 = "!wasFastFlush";
    int v275 = v206;
    int v207 = 2196;
    goto LABEL_270;
  }
  unsigned int v191 = (atomic_uint *)fd_create_protected(v107, v320, v285, 0);
  if (!v191) {
    goto LABEL_238;
  }
  uint64_t v192 = v191;
  int v193 = store_stream_init((uint64_t)&v310, v191, 0);
  unsigned int v194 = (int *)&unk_1E9FC9000;
  if (dword_1E9FC90CC >= 5)
  {
    int v209 = *__error();
    unint64_t v210 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v210, OS_LOG_TYPE_DEFAULT))
    {
      buf[0].dev_t st_dev = 134217984;
      *(void *)&buf[0].st_mode = *((void *)&v311 + 1) - v312 + *((void *)&v312 + 1);
      _os_log_impl(&dword_1BD672000, v210, OS_LOG_TYPE_DEFAULT, "Post init at %lld", (uint8_t *)buf, 0xCu);
    }
    *__error() = v209;
    unsigned int v182 = v288;
    unsigned int v194 = (_DWORD *)&unk_1E9FC9000;
  }
  if (v311) {
    int v195 = 0;
  }
  else {
    int v195 = v193;
  }
  if (v195 == 1)
  {
    int v196 = v286;
    if (!(void)v312) {
      int v196 = 0;
    }
    if (v196 == 1)
    {
      if (v194[51] >= 5)
      {
        int v211 = *__error();
        int v212 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v212, OS_LOG_TYPE_DEFAULT))
        {
          buf[0].dev_t st_dev = 134217984;
          *(void *)&buf[0].st_mode = *((void *)&v311 + 1) - v312 + *((void *)&v312 + 1);
          _os_log_impl(&dword_1BD672000, v212, OS_LOG_TYPE_DEFAULT, "At start %lld", (uint8_t *)buf, 0xCu);
        }
        *__error() = v211;
        if ((v293 & 0x40) == 0) {
          goto LABEL_253;
        }
      }
      else if ((v293 & 0x40) == 0)
      {
LABEL_253:
        uint64_t v197 = 0;
        goto LABEL_281;
      }
      uint64_t v197 = *(void *)(v39 + 4928) + 4384;
LABEL_281:
      uint64_t v282 = (CFIndex *)v197;
      int vint32_2613 = store_stream_read_vint32_2613((uint64_t)&v310);
      int v214 = vint32_2613;
      if (dword_1E9FC90CC >= 5)
      {
        int v253 = *__error();
        int v254 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v254, OS_LOG_TYPE_DEFAULT))
        {
          buf[0].dev_t st_dev = 134217984;
          *(void *)&buf[0].st_mode = *((void *)&v311 + 1) - v312 + *((void *)&v312 + 1);
          _os_log_impl(&dword_1BD672000, v254, OS_LOG_TYPE_DEFAULT, "Post version at %lld", (uint8_t *)buf, 0xCu);
        }
        *__error() = v253;
        if (v214 != 2) {
          goto LABEL_342;
        }
      }
      else if (vint32_2613 != 2)
      {
        goto LABEL_342;
      }
      BOOL v215 = (a10 - 111) < 4;
      if (!v291) {
        BOOL v215 = (a10 - 95) < 8;
      }
      if (v215)
      {
        CFIndex v216 = store_stream_read_vint32_2613((uint64_t)&v310);
        CFIndex v217 = store_stream_read_vint32_2613((uint64_t)&v310);
        CFIndex v284 = store_stream_read_vint32_2613((uint64_t)&v310);
        char v218 = atomic_load((unsigned int *)v295 + 9);
        if (v218 < 0) {
          unsigned int v219 = store_stream_read_vint32_2613((uint64_t)&v310);
        }
        else {
          unsigned int v219 = 0;
        }
        if (v217 <= v216) {
          unsigned int v220 = v216;
        }
        else {
          unsigned int v220 = v217;
        }
        if (v220 <= v284) {
          LODWORD(v221) = v284;
        }
        else {
          LODWORD(v221) = v220;
        }
        if (v221 <= v219) {
          uint64_t v221 = v219;
        }
        else {
          uint64_t v221 = v221;
        }
        uint64_t v222 = (UInt8 *)malloc_type_malloc((unint64_t)(v221 + 7) >> 3, 0xDE6A440BuLL);
        if (v222)
        {
          int v223 = v222;
          if (dword_1E9FC90CC >= 5)
          {
            int v257 = *__error();
            uint64_t v258 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v258, OS_LOG_TYPE_DEFAULT))
            {
              buf[0].dev_t st_dev = 134217984;
              *(void *)&buf[0].st_mode = *((void *)&v311 + 1) - v312 + *((void *)&v312 + 1);
              _os_log_impl(&dword_1BD672000, v258, OS_LOG_TYPE_DEFAULT, "Pre-loop at %lld", (uint8_t *)buf, 0xCu);
            }
            *__error() = v257;
          }
          bytes = v223;
          if (*a9) {
            goto LABEL_336;
          }
          if (store_stream_read_bytes_2616((unsigned int *)&v310, (char *)v223, (unint64_t)(v216 + 7) >> 3) == (unint64_t)(v216 + 7) >> 3)
          {
            CFBitVectorRef v224 = CFBitVectorCreate(0, v223, v216);
            if (v224)
            {
              CFBitVectorRef v225 = v224;
              if (v216)
              {
                for (CFIndex i = 0; i != v216; ++i)
                {
                  CFBit v227 = CFBitVectorGetBitAtIndex(v225, i) != 0;
                  bit_vector_set_2617((CFIndex *)v295 + 1176, i, v227);
                }
              }
              CFRelease(v225);
              if (dword_1E9FC90CC >= 5)
              {
                int v266 = *__error();
                long long v267 = _SILogForLogForCategory(10);
                if (os_log_type_enabled(v267, OS_LOG_TYPE_DEFAULT))
                {
                  buf[0].dev_t st_dev = 134217984;
                  *(void *)&buf[0].st_mode = *((void *)&v311 + 1) - v312 + *((void *)&v312 + 1);
                  _os_log_impl(&dword_1BD672000, v267, OS_LOG_TYPE_DEFAULT, "Post bv1 at %lld", (uint8_t *)buf, 0xCu);
                }
                *__error() = v266;
                if (*a9) {
                  goto LABEL_336;
                }
              }
              else if (*a9)
              {
                goto LABEL_336;
              }
              if (store_stream_read_bytes_2616((unsigned int *)&v310, (char *)bytes, (unint64_t)(v217 + 7) >> 3) == (unint64_t)(v217 + 7) >> 3)
              {
                CFBitVectorRef v228 = CFBitVectorCreate(0, bytes, v217);
                if (v228)
                {
                  CFBitVectorRef v229 = v228;
                  if (v217)
                  {
                    for (CFIndex j = 0; j != v217; ++j)
                    {
                      CFBit v231 = CFBitVectorGetBitAtIndex(v229, j) != 0;
                      bit_vector_set_2617((CFIndex *)v295 + 1766, j, v231);
                    }
                  }
                  CFRelease(v229);
                  if (dword_1E9FC90CC >= 5)
                  {
                    int v268 = *__error();
                    long long v269 = _SILogForLogForCategory(10);
                    if (os_log_type_enabled(v269, OS_LOG_TYPE_DEFAULT))
                    {
                      buf[0].dev_t st_dev = 134217984;
                      *(void *)&buf[0].st_mode = *((void *)&v311 + 1) - v312 + *((void *)&v312 + 1);
                      _os_log_impl(&dword_1BD672000, v269, OS_LOG_TYPE_DEFAULT, "Post bv2 at %lld", (uint8_t *)buf, 0xCu);
                    }
                    *__error() = v268;
                    if (*a9) {
                      goto LABEL_336;
                    }
                  }
                  else if (*a9)
                  {
                    goto LABEL_336;
                  }
                  if (store_stream_read_bytes_2616((unsigned int *)&v310, (char *)bytes, (unint64_t)(v284 + 7) >> 3) == (unint64_t)(v284 + 7) >> 3)
                  {
                    CFBitVectorRef v232 = CFBitVectorCreate(0, bytes, v284);
                    if (v232)
                    {
                      CFBitVectorRef v233 = v232;
                      if (v284)
                      {
                        for (CFIndex k = 0; k != v284; ++k)
                        {
                          CFBit v235 = CFBitVectorGetBitAtIndex(v233, k) != 0;
                          bit_vector_set_2617((CFIndex *)v295 + 579, k, v235);
                        }
                      }
                      CFRelease(v233);
                      if (dword_1E9FC90CC >= 5)
                      {
                        int v270 = *__error();
                        long long v271 = _SILogForLogForCategory(10);
                        if (os_log_type_enabled(v271, OS_LOG_TYPE_DEFAULT))
                        {
                          buf[0].dev_t st_dev = 134217984;
                          *(void *)&buf[0].st_mode = *((void *)&v311 + 1) - v312 + *((void *)&v312 + 1);
                          _os_log_impl(&dword_1BD672000, v271, OS_LOG_TYPE_DEFAULT, "Post bv3 at %lld", (uint8_t *)buf, 0xCu);
                        }
                        *__error() = v270;
                      }
                      unsigned int v236 = v219;
                      if ((v293 & 0x40) == 0 || !*(void *)(v39 + 4928)) {
                        goto LABEL_330;
                      }
                      if (!*a9)
                      {
                        if (store_stream_read_bytes_2616((unsigned int *)&v310, (char *)bytes, ((unint64_t)v219 + 7) >> 3) == ((unint64_t)v219 + 7) >> 3)
                        {
                          CFBitVectorRef v237 = CFBitVectorCreate(0, bytes, v219);
                          if (v237)
                          {
                            CFBitVectorRef v238 = v237;
                            if (v219)
                            {
                              for (CFIndex m = 0; m != v219; bit_vector_set_2617(v282, m++, v240))
                                CFBit v240 = CFBitVectorGetBitAtIndex(v238, m) != 0;
                            }
                            **(unsigned char **)(v39 + 4928) = 1;
                            CFRelease(v238);
LABEL_330:
                            if (!*a9)
                            {
                              if (dword_1E9FC90CC >= 5)
                              {
                                int v272 = *__error();
                                long long v273 = _SILogForLogForCategory(10);
                                if (os_log_type_enabled(v273, OS_LOG_TYPE_DEFAULT))
                                {
                                  buf[0].dev_t st_dev = 134217984;
                                  *(void *)&buf[0].st_mode = *((void *)&v311 + 1) - v312 + *((void *)&v312 + 1);
                                  _os_log_impl(&dword_1BD672000, v273, OS_LOG_TYPE_DEFAULT, "Post bv4 at %lld", (uint8_t *)buf, 0xCu);
                                }
                                *__error() = v272;
                              }
                              uint64_t v241 = 32 * *(unsigned __int8 *)(v39 + 46);
                              uint64_t v242 = *(void *)(v39 + 80);
                              uint64_t v243 = *(unsigned int *)(v39 + 68);
                              unsigned int v244 = atomic_load((unsigned int *)v295 + 9);
                              updated = TermUpdateSetRestore((uint64_t)&v310, (uint64_t)_indexProgress, v39, v242, v243, v241, v243, (v244 >> 3) & 1, *(void *)(v39 + 14384), *(_DWORD *)(v39 + 56), *(const void **)(v39 + 4936));
                              *(void *)(v39 + 14392) = updated;
                              if (!updated)
                              {
                                int v252 = v311;
                                if (v311 == 22)
                                {
                                  __si_set_error_str(1, "%s:%u: %s", v246, v247, v248, v249, v250, v251, (char)"JHContentIndex.c");
                                  _si_set_invalid_term_update_set();
                                }
                                else
                                {
                                  bzero(buf, 0x400uLL);
                                  snprintf((char *)buf, 0x400uLL, "restoring term update set failed %d", v252);
                                  __si_set_error_str(1, "%s:%u: %s", v259, v260, v261, v262, v263, v264, (char)"JHContentIndex.c");
                                }
                                if (!v311) {
                                  LODWORD(v311) = -1;
                                }
                              }
                              if (!v216 && !v217 && !v284 && !v236)
                              {
                                uint64_t v265 = *(void *)(v39 + 14392);
                                if (v265) {
                                  atomic_load((unsigned int *)(*(void *)(v265 + 24) + 16));
                                }
                              }
                            }
                            goto LABEL_336;
                          }
                        }
                        goto LABEL_335;
                      }
LABEL_336:
                      free(bytes);
                      unsigned int v182 = v288;
                      goto LABEL_337;
                    }
                  }
                }
              }
            }
          }
LABEL_335:
          LODWORD(v311) = -1;
          goto LABEL_336;
        }
        uint64_t v255 = __si_assert_copy_extra_2445(0, -1);
        uint64_t v205 = v255;
        unint64_t v256 = "";
        if (v255) {
          unint64_t v256 = v255;
        }
        uint64_t v274 = "bits";
        int v275 = v256;
        int v207 = 2251;
LABEL_270:
        __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", v207, v274, v275);
        free(v205);
        if (__valid_fs(-1)) {
          uint64_t v208 = 2989;
        }
        else {
          uint64_t v208 = 3072;
        }
        *(_DWORD *)uint64_t v208 = -559038737;
        abort();
      }
LABEL_342:
      LODWORD(v311) = -1;
      store_stream_destroy((uint64_t)&v310);
      fd_release(v192);
      uint64_t v44 = v298;
      goto LABEL_238;
    }
  }
LABEL_337:
  store_stream_destroy((uint64_t)&v310);
  fd_release(v192);
  uint64_t v44 = v298;
  int v43 = v296;
  if (!v311)
  {
LABEL_258:
    if (*a9) {
      goto LABEL_238;
    }
LABEL_228:
    uint64_t v183 = *(void *)(v39 + 14392);
    uint64_t v184 = v295;
    if (v183)
    {
      if (*v182) {
        *(void *)(v183 + 608) = getPropertyStringCallback;
      }
      *(void *)(v183 + 280) = v295 + 3546;
    }
    *(unsigned char *)(v39 + 8) = 1;
    if ((v292 | v43))
    {
      uint64_t v185 = v297;
      if (!v297)
      {
LABEL_235:
        *uint64_t v44 = 0;
        goto LABEL_238;
      }
LABEL_234:
      long long v186 = *(_OWORD *)(v184 + 3734);
      long long v187 = *(_OWORD *)(v184 + 3742);
      *(_OWORD *)(v185 + 16) = *(_OWORD *)(v184 + 3738);
      *(_OWORD *)(v185 + 32) = v187;
      *(_OWORD *)uint64_t v185 = v186;
      long long v188 = *(_OWORD *)(v184 + 3746);
      long long v189 = *(_OWORD *)(v184 + 3750);
      long long v190 = *(_OWORD *)(v184 + 3754);
      *(void *)(v185 + 96) = *(void *)(v39 + 15032);
      *(_OWORD *)(v185 + 64) = v189;
      *(_OWORD *)(v185 + 80) = v190;
      *(_OWORD *)(v185 + 48) = v188;
      goto LABEL_235;
    }
    if (indexShadowFiles(v39, 1, v319, a9))
    {
      *uint64_t v44 = -1;
      int v198 = *__error();
      unint64_t v199 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v199, OS_LOG_TYPE_ERROR))
      {
LABEL_262:
        *__error() = v198;
        goto LABEL_238;
      }
      gid_t v200 = *v44;
      buf[0].dev_t st_dev = 136315906;
      *(void *)&buf[0].st_mode = "openIndex";
      WORD2(buf[0].st_ino) = 1024;
      *(_DWORD *)((char *)&buf[0].st_ino + 6) = 2387;
      HIWORD(buf[0].st_uid) = 1024;
      buf[0].st_gid = v200;
      LOWORD(buf[0].st_rdev) = 2080;
      *(void *)((char *)&buf[0].st_rdev + 2) = v294;
      unsigned int v201 = "%s:%d: index shadow err:%d at %s\n";
      int64_t v202 = (uint8_t *)buf;
    }
    else
    {
      bzero(buf, 0x1000uLL);
      v301[0] = buf;
      indexStoreToBuffer(v39, v301);
      if (!indexCommitShadow(v39, buf))
      {
        fd_sync(*(void *)(v39 + 14472), 1);
        uint64_t v184 = v295;
        uint64_t v185 = v297;
        if (!v297) {
          goto LABEL_235;
        }
        goto LABEL_234;
      }
      *uint64_t v44 = -1;
      int v198 = *__error();
      unint64_t v199 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v199, OS_LOG_TYPE_ERROR)) {
        goto LABEL_262;
      }
      int v203 = *v44;
      *(_DWORD *)uint64_t v314 = 136315906;
      *(void *)&v314[4] = "openIndex";
      *(_WORD *)&v314[12] = 1024;
      *(_DWORD *)&v314[14] = 2396;
      *(_WORD *)&v314[18] = 1024;
      *(_DWORD *)&v314[20] = v203;
      __int16 v315 = 2080;
      unint64_t v316 = v294;
      unsigned int v201 = "%s:%d: index commit shadow err:%d at %s\n";
      int64_t v202 = v314;
    }
    _os_log_error_impl(&dword_1BD672000, v199, OS_LOG_TYPE_ERROR, v201, v202, 0x22u);
    goto LABEL_262;
  }
LABEL_238:
  if (!*v44) {
    return (char *)v39;
  }
  freeIndex(v39);
  return 0;
}

void __openIndex_block_invoke(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, int a9)
{
  uint64_t v9 = *(void *)(a1 + 32);
  *(_DWORD *)(v9 + 4920) += a9;
  if (a8 == 4) {
    writeVectorIndexDrop(*(unsigned int *)(v9 + 15716), a9, *(unsigned __int8 *)(v9 + 15203), *(const char **)(a1 + 40), a3);
  }
}

uint64_t store_stream_read_vint32_2613(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if ((unint64_t)(*(void *)(a1 + 32) - v2) < 6)
  {
    int v17 = 0;
    LODWORD(v5) = 0;
    char __dst = 0;
    while (store_stream_read_bytes_2616((unsigned int *)a1, &__dst, 1uLL) == 1)
    {
      uint64_t v5 = ((__dst & 0x7F) << v17) | v5;
      v17 += 7;
      if ((__dst & 0x80) == 0) {
        return v5;
      }
    }
    return 0;
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 48);
    uint64_t v4 = v2 + 1;
    uint64_t v5 = *(unsigned __int8 *)(v3 + v2);
    if (*(char *)(v3 + v2) < 0)
    {
      uint64_t v6 = v2 + 2;
      int v7 = *(char *)(v3 + v4);
      int v8 = *(unsigned __int8 *)(v3 + v4);
      if (v7 < 0)
      {
        uint64_t v9 = v2 + 3;
        int v10 = *(char *)(v3 + v6);
        char v11 = v10;
        if (v10 < 0)
        {
          uint64_t v12 = v2 + 4;
          int v13 = *(char *)(v3 + v9);
          int v14 = *(unsigned __int8 *)(v3 + v9);
          if (v13 < 0)
          {
            int v15 = *(char *)(v3 + v12);
            *(void *)(a1 + 40) = v2 + 5;
            if (v15 < 0)
            {
              return ((v14 & 0x7F) << 21) | (v15 << 28) | ((v11 & 0x7F) << 14) | ((v8 & 0x7F) << 7) | (v5 & 0x7F);
            }
            else
            {
              uint64_t v5 = 0;
              *(_DWORD *)(a1 + 16) = 22;
            }
          }
          else
          {
            uint64_t v5 = ((v11 & 0x7F) << 14) | (v14 << 21) | ((v8 & 0x7F) << 7) | (v5 & 0x7F);
            *(void *)(a1 + 40) = v12;
          }
        }
        else
        {
          uint64_t v5 = ((v8 & 0x7F) << 7) | (v10 << 14) | (v5 & 0x7F);
          *(void *)(a1 + 40) = v9;
        }
      }
      else
      {
        uint64_t v5 = v5 & 0x7F | (v8 << 7);
        *(void *)(a1 + 40) = v6;
      }
    }
    else
    {
      *(void *)(a1 + 40) = v4;
    }
  }
  return v5;
}

size_t store_stream_read_bytes_2616(unsigned int *a1, char *__dst, size_t __n)
{
  uint64_t v4 = __dst;
  size_t v6 = *((void *)a1 + 4);
  uint64_t v7 = *((void *)a1 + 5);
  if (v7 + __n > v6)
  {
    size_t v8 = v6 - v7;
    if (v6 != v7)
    {
      memcpy(__dst, (const void *)(*((void *)a1 + 6) + v7), v6 - v7);
      size_t v6 = *((void *)a1 + 4);
      *((void *)a1 + 5) += v8;
    }
    unint64_t v11 = prot_pread(*a1, *((void **)a1 + 6), v6, *((void *)a1 + 3));
    if (v11 == -1)
    {
      size_t v8 = 0;
    }
    else
    {
      *((void *)a1 + 4) = v11;
      *((void *)a1 + 5) = 0;
      *((void *)a1 + 3) += v11;
      if (!v11)
      {
        size_t v9 = 0;
        return v8 + v9;
      }
      v4 += v8;
      __n -= v8;
      if (__n <= v11)
      {
        uint64_t v7 = 0;
        goto LABEL_3;
      }
      size_t __na = v11;
      while (1)
      {
        memcpy(v4, *((const void **)a1 + 6), __na);
        uint64_t v12 = (void *)*((void *)a1 + 6);
        *((void *)a1 + 5) += __na;
        unint64_t v13 = prot_pread(*a1, v12, *((void *)a1 + 4), *((void *)a1 + 3));
        if (v13 == -1) {
          break;
        }
        *((void *)a1 + 4) = v13;
        *((void *)a1 + 5) = 0;
        *((void *)a1 + 3) += v13;
        if (!v13)
        {
          size_t v9 = v8;
          size_t v8 = __na;
          return v8 + v9;
        }
        uint64_t v7 = 0;
        v4 += __na;
        __n -= __na;
        v8 += __na;
        size_t __na = v13;
        if (__n <= v13) {
          goto LABEL_3;
        }
      }
    }
    a1[4] = *__error();
    size_t v9 = v8;
    size_t v8 = 0;
    return v8 + v9;
  }
  size_t v8 = 0;
LABEL_3:
  memcpy(v4, (const void *)(*((void *)a1 + 6) + v7), __n);
  *((void *)a1 + 5) += __n;
  size_t v9 = v8;
  size_t v8 = __n;
  return v8 + v9;
}

void bit_vector_set_2617(CFIndex *a1, CFIndex a2, CFBit a3)
{
  if (a2 < 0)
  {
    uint64_t v7 = __si_assert_copy_extra_2445(0, -1);
    size_t v8 = v7;
    size_t v9 = "";
    if (v7) {
      size_t v9 = v7;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 129, "bitIndex >= 0", v9);
    free(v8);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  bit_vector_internal_touch_for_set(a1, a2);
  size_t v6 = (__CFBitVector *)a1[2];
  CFBitVectorSetBitAtIndex(v6, a2, a3);
}

uint64_t indexShadowFiles(uint64_t a1, char a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  if (*(unsigned char *)(a1 + 15203))
  {
    if (indexShadowFiles__COUNT_)
    {
      uint64_t v8 = 0;
LABEL_29:
      unsigned int v26 = 22;
      goto LABEL_30;
    }
    indexShadowFiles__COUNT_ = 1;
    int v27 = *__error();
    int v28 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)statfs buf = 136315650;
      *(void *)&uint8_t buf[4] = "indexShadowFiles";
      __int16 v67 = 1024;
      int v68 = 3190;
      __int16 v69 = 2080;
      *(void *)uint64_t v70 = a1 + 15208;
      int v29 = "%s:%d: trying to modify read only index %s";
LABEL_50:
      _os_log_error_impl(&dword_1BD672000, v28, OS_LOG_TYPE_ERROR, v29, buf, 0x1Cu);
      goto LABEL_28;
    }
    goto LABEL_28;
  }
  if (!*(unsigned char *)(a1 + 8) || *(_DWORD *)(a1 + 15196) == -1)
  {
    int v27 = *__error();
    int v28 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)statfs buf = 136315650;
      *(void *)&uint8_t buf[4] = "indexShadowFiles";
      __int16 v67 = 1024;
      int v68 = 3199;
      __int16 v69 = 2080;
      *(void *)uint64_t v70 = a1 + 15208;
      int v29 = "%s:%d: can't shadow %s";
      goto LABEL_50;
    }
LABEL_28:
    uint64_t v8 = 0;
    *__error() = v27;
    goto LABEL_29;
  }
  size_t v9 = (unsigned int *)(a1 + 36);
  char v10 = atomic_load((unsigned int *)(a1 + 36));
  if ((v10 & 1) == 0
    || (char v11 = atomic_load(v9), (v11 & 2) != 0)
    || (v12 = *(void *)(a1 + 14392)) != 0 && (unsigned int v13 = atomic_load((unsigned int *)(*(void *)(v12 + 24) + 16))) != 0)
  {
    int v14 = 0;
  }
  else
  {
    atomic_fetch_or((atomic_uint *volatile)(a1 + 36), 2u);
    int v40 = *__error();
    int v41 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      int v42 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)statfs buf = 136315394;
      *(void *)&uint8_t buf[4] = a1 + 15208;
      __int16 v67 = 1024;
      int v68 = v42;
      _os_log_impl(&dword_1BD672000, v41, OS_LOG_TYPE_DEFAULT, "mark index %s (%u) read-only during shadow", buf, 0x12u);
    }
    *__error() = v40;
    unsigned int v43 = atomic_load((unsigned int *)(a1 + 36));
    a3[2] = v43;
    uint64_t v44 = *(void *)(a1 + 14392);
    if (v44)
    {
      if (atomic_load((unsigned int *)(*(void *)(v44 + 24) + 16)))
      {
        int v62 = __si_assert_copy_extra_2445(0, -1);
        int v63 = v62;
        uint64_t v64 = "";
        if (v62) {
          uint64_t v64 = v62;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", 3225, "0 == TermUpdateSetTermCount(cindex->_deltaSet)", v64);
        free(v63);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      _db_write_lock(a1 + 14720);
      TermUpdateSetRelease(*(void *)(a1 + 14392));
      atomic_fetch_add((atomic_uint *volatile)gTermUpdateSetCount, 0xFFFFFFFF);
      *(void *)(a1 + 14392) = 0;
      db_write_unlock(a1 + 14720);
    }
    int v14 = 1;
  }
  char v15 = atomic_load(v9);
  snprintf(__str, 0x400uLL, "%s%s", (const char *)(a1 + 15208), "shadowIndexHead");
  CFNumberRef v16 = fd_create_protected(*(_DWORD *)(a1 + 64), __str, 536872450, 3u);
  if (!v16)
  {
    unsigned int v26 = *__error();
    int v33 = *__error();
    int v34 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)statfs buf = 136315906;
      *(void *)&uint8_t buf[4] = "indexShadowFiles";
      __int16 v67 = 1024;
      int v68 = 3244;
      __int16 v69 = 1024;
      *(_DWORD *)uint64_t v70 = v26;
      *(_WORD *)&v70[4] = 2080;
      *(void *)&v70[6] = __str;
      _os_log_error_impl(&dword_1BD672000, v34, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", buf, 0x22u);
    }
    uint64_t v8 = 0;
    *__error() = v33;
    goto LABEL_30;
  }
  uint64_t v8 = (uint64_t)v16;
  int v65 = v14;
  *(void *)statfs buf = 0;
  int v17 = _fd_acquire_fd((uint64_t)v16, buf);
  if (v17 != -1)
  {
    int v18 = v17;
    *(_WORD *)(v8 + 56) |= 1u;
    fcntl(v17, 48, 1);
    fcntl(v18, 76, *(_WORD *)(v8 + 56) & 1);
    _fd_release_fd((_DWORD *)v8, v18, 0, *(uint64_t *)buf);
  }
  *a3 = 1;
  uint64_t v19 = fd_pwrite(v8, (uint64_t)a3, 0x1000uLL, 0);
  *a3 = *(_DWORD *)(a1 + 4);
  if (v19 == -1)
  {
    unsigned int v26 = *__error();
    int v35 = *__error();
    uint64_t v36 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)statfs buf = 136315650;
      *(void *)&uint8_t buf[4] = "indexShadowFiles";
      __int16 v67 = 1024;
      int v68 = 3255;
      __int16 v69 = 1024;
      *(_DWORD *)uint64_t v70 = v26;
      uint64_t v37 = "%s:%d: write err: %d";
LABEL_42:
      uint64_t v38 = v36;
      uint32_t v39 = 24;
LABEL_54:
      _os_log_error_impl(&dword_1BD672000, v38, OS_LOG_TYPE_ERROR, v37, buf, v39);
      goto LABEL_80;
    }
    goto LABEL_80;
  }
  if (_gSystemStatusBool)
  {
    pthread_mutex_lock(&_gSystemStatusLock);
    while (_gSystemStatusBool)
      pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
    pthread_mutex_unlock(&_gSystemStatusLock);
  }
  *(void *)statfs buf = 0;
  uint64_t v20 = _fd_acquire_fd(v8, buf);
  if (v20 != -1)
  {
    int v21 = v20;
    prot_fsync(v20, 0);
    _fd_release_fd((_DWORD *)v8, v21, 0, *(uint64_t *)buf);
  }
  if ((v15 & 2) != 0) {
    goto LABEL_64;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  snprintf(__str, 0x400uLL, "%s%s", (const char *)(a1 + 15208), "shadowIndexTermIds");
  uint64_t v23 = (atomic_uint *)fd_create_protected(*(_DWORD *)(a1 + 64), __str, 536871426, 3u);
  if (!v23)
  {
    unsigned int v26 = *__error();
    int v35 = *__error();
    int v46 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)statfs buf = 136315906;
      *(void *)&uint8_t buf[4] = "indexShadowFiles";
      __int16 v67 = 1024;
      int v68 = 3270;
      __int16 v69 = 1024;
      *(_DWORD *)uint64_t v70 = v26;
      *(_WORD *)&v70[4] = 2080;
      *(void *)&v70[6] = __str;
      uint64_t v37 = "%s:%d: open err: %d, %s";
LABEL_53:
      uint64_t v38 = v46;
      uint32_t v39 = 34;
      goto LABEL_54;
    }
LABEL_80:
    *__error() = v35;
    goto LABEL_30;
  }
  uint64_t v24 = v23;
  fd_no_cache((uint64_t)v23);
  unsigned int v25 = termIdStoreShadow(a1 + 4984, (uint64_t)v24, a2 & 1, a4);
  if (v25)
  {
LABEL_24:
    unsigned int v26 = v25;
    fd_release(v24);
LABEL_30:
    int v30 = *__error();
    int v31 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)statfs buf = 136315906;
      *(void *)&uint8_t buf[4] = "indexShadowFiles";
      __int16 v67 = 1024;
      int v68 = 3367;
      __int16 v69 = 2080;
      *(void *)uint64_t v70 = a1 + 15208;
      *(_WORD *)&v70[8] = 1024;
      *(_DWORD *)&v70[10] = 3367;
      _os_log_error_impl(&dword_1BD672000, v31, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", buf, 0x22u);
    }
    *__error() = v30;
    if (*(unsigned char *)(a1 + 8))
    {
      *(unsigned char *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = v26;
    }
    fd_release((atomic_uint *)v8);
    if (v26) {
      return v26;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  fd_sync((uint64_t)v24, 0);
  fd_release(v24);
  int v47 = *__error();
  char v48 = _SILogForLogForCategory(10);
  os_log_type_t v49 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v48, v49))
  {
    float v50 = CFAbsoluteTimeGetCurrent() - Current;
    *(_DWORD *)statfs buf = 134217984;
    *(double *)&uint8_t buf[4] = v50;
    _os_log_impl(&dword_1BD672000, v48, v49, "shadowIndexTermIds took %f seconds", buf, 0xCu);
  }
  *__error() = v47;
  double v51 = CFAbsoluteTimeGetCurrent();
  snprintf(__str, 0x400uLL, "%s%s", (const char *)(a1 + 15208), "shadowIndexPositionTable");
  BOOL v52 = (atomic_uint *)fd_create_protected(*(_DWORD *)(a1 + 64), __str, 536871426, 3u);
  if (!v52)
  {
    unsigned int v26 = *__error();
    int v35 = *__error();
    int v46 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
      goto LABEL_80;
    }
    *(_DWORD *)statfs buf = 136315906;
    *(void *)&uint8_t buf[4] = "indexShadowFiles";
    __int16 v67 = 1024;
    int v68 = 3291;
    __int16 v69 = 1024;
    *(_DWORD *)uint64_t v70 = v26;
    *(_WORD *)&v70[4] = 2080;
    *(void *)&v70[6] = __str;
    uint64_t v37 = "%s:%d: open err: %d, %s";
    goto LABEL_53;
  }
  uint64_t v24 = v52;
  fd_no_cache((uint64_t)v52);
  unsigned int v25 = termIdStoreShadow(a1 + 9704, (uint64_t)v24, a2 & 1, a4);
  if (v25) {
    goto LABEL_24;
  }
  fd_sync((uint64_t)v24, 0);
  fd_release(v24);
  int v53 = *__error();
  BOOL v54 = _SILogForLogForCategory(10);
  os_log_type_t v55 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v54, v55))
  {
    float v56 = CFAbsoluteTimeGetCurrent() - v51;
    *(_DWORD *)statfs buf = 134217984;
    *(double *)&uint8_t buf[4] = v56;
    _os_log_impl(&dword_1BD672000, v54, v55, "shadowIndexPositionTable took %f seconds", buf, 0xCu);
  }
  *__error() = v53;
  unsigned int v57 = bt_shadowTrie(a1 + 96, (const char *)(a1 + 15208), a2 & 1, a4);
  if (v57)
  {
LABEL_67:
    unsigned int v26 = v57;
    goto LABEL_30;
  }
  uint64_t v58 = *(void *)(a1 + 4912);
  if (v58) {
    shadowVectorIndex(v58, a2 & 1, (uint64_t)a4);
  }
LABEL_64:
  uint64_t v59 = *(void *)(a1 + 4928);
  if (v59) {
    shadowForwardStore(v59, a2 & 1, a4);
  }
  unsigned int v57 = _indexShadowGroups(a1, 0);
  if (v57) {
    goto LABEL_67;
  }
  if (fd_pwrite(v8, (uint64_t)a3, 0x1000uLL, 0) == -1)
  {
    unsigned int v26 = *__error();
    int v35 = *__error();
    uint64_t v36 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
      goto LABEL_80;
    }
    *(_DWORD *)statfs buf = 136315650;
    *(void *)&uint8_t buf[4] = "indexShadowFiles";
    __int16 v67 = 1024;
    int v68 = 3328;
    __int16 v69 = 1024;
    *(_DWORD *)uint64_t v70 = v26;
    uint64_t v37 = "%s:%d: write err: %d";
    goto LABEL_42;
  }
  fd_sync(v8, 0);
  if (v65)
  {
    fd_sync(v8, 1);
    if (_os_feature_enabled_impl())
    {
      uint64_t v60 = *(void *)(a1 + 4912);
      if (v60) {
        IVFVectorIndex_s::makeReadOnly((void *)(v60 + 8));
      }
    }
    storageTruncateAndMakeReadOnly(a1 + 256);
    fd_truncate_and_make_readonly(*(void *)(a1 + 208), *(void *)(a1 + 128));
    fd_truncate_and_make_readonly(*(void *)(a1 + 4672), 1028 * (*(_DWORD *)(a1 + 240) + 1));
    fd_truncate(*(void *)(a1 + 14448), 8 * *(unsigned int *)(a1 + 68));
    fd_truncate(*(void *)(a1 + 14456), 4 * *(unsigned int *)(a1 + 68));
    fd_truncate(*(void *)(a1 + 14464), 8 * *(unsigned int *)(a1 + 68));
    char v61 = atomic_load((unsigned int *)(a1 + 36));
    if ((v61 & 4) == 0)
    {
      storageTruncateAndMakeReadOnly(a1 + 4984);
      storageTruncateAndMakeReadOnly(a1 + 9704);
    }
    index_DeleteShadow(*(unsigned int *)(a1 + 64), (const char *)(a1 + 15208), 1);
  }
  fd_release((atomic_uint *)v8);
  return 0;
}

uint64_t *indexStoreToBuffer(uint64_t a1, void **a2)
{
  uint64_t v4 = *a2;
  bzero(*a2, 0x1000uLL);
  uint64_t v5 = (unsigned int *)*a2;
  *v5++ = *(_DWORD *)(a1 + 4);
  *a2 = v5;
  unsigned int v6 = atomic_load((unsigned int *)(a1 + 32));
  *v5++ = v6;
  *a2 = v5;
  unsigned int v7 = atomic_load((unsigned int *)(a1 + 36));
  uint64_t v8 = v5;
  *uint64_t v5 = v7;
  v5[1] = *(_DWORD *)(a1 + 48);
  v5[2] = 0;
  size_t v9 = v5 + 3;
  *a2 = v9;
  unsigned int v10 = *(_DWORD *)(a1 + 60);
  if (v10 >> 28)
  {
    *((unsigned char *)v8 + 12) = v10 | 0x80;
    *((unsigned char *)v8 + 13) = (v10 >> 7) | 0x80;
    *((unsigned char *)v8 + 14) = (v10 >> 14) | 0x80;
    *((unsigned char *)v8 + 15) = (v10 >> 21) | 0x80;
    *((unsigned char *)v8 + 16) = v10 >> 28;
    uint64_t v11 = 5;
  }
  else if ((v10 & 0xFE00000) != 0)
  {
    *((unsigned char *)v8 + 12) = v10 | 0x80;
    *((unsigned char *)v8 + 13) = (v10 >> 7) | 0x80;
    *((unsigned char *)v8 + 14) = (v10 >> 14) | 0x80;
    *((unsigned char *)v8 + 15) = (v10 & 0xFE00000) >> 21;
    uint64_t v11 = 4;
  }
  else if ((v10 & 0x1FC000) != 0)
  {
    *((unsigned char *)v8 + 12) = v10 | 0x80;
    *((unsigned char *)v8 + 13) = (v10 >> 7) | 0x80;
    *((unsigned char *)v8 + 14) = (v10 & 0x1FC000) >> 14;
    uint64_t v11 = 3;
  }
  else if ((v10 & 0x3F80) != 0)
  {
    *((unsigned char *)v8 + 12) = v10 | 0x80;
    *((unsigned char *)v8 + 13) = (unsigned __int16)(v10 & 0x3F80) >> 7;
    uint64_t v11 = 2;
  }
  else
  {
    *size_t v9 = v10;
    uint64_t v11 = 1;
  }
  uint64_t v12 = (char *)*a2 + v11;
  *a2 = v12;
  unsigned int v13 = *(_DWORD *)(a1 + 68);
  if (v13 >> 28)
  {
    unsigned char *v12 = v13 | 0x80;
    v12[1] = (v13 >> 7) | 0x80;
    void v12[2] = (v13 >> 14) | 0x80;
    void v12[3] = (v13 >> 21) | 0x80;
    v12[4] = v13 >> 28;
    uint64_t v14 = 5;
  }
  else if ((v13 & 0xFE00000) != 0)
  {
    unsigned char *v12 = v13 | 0x80;
    v12[1] = (v13 >> 7) | 0x80;
    void v12[2] = (v13 >> 14) | 0x80;
    void v12[3] = (v13 & 0xFE00000) >> 21;
    uint64_t v14 = 4;
  }
  else if ((v13 & 0x1FC000) != 0)
  {
    unsigned char *v12 = v13 | 0x80;
    v12[1] = (v13 >> 7) | 0x80;
    void v12[2] = (v13 & 0x1FC000) >> 14;
    uint64_t v14 = 3;
  }
  else if ((v13 & 0x3F80) != 0)
  {
    unsigned char *v12 = v13 | 0x80;
    v12[1] = (unsigned __int16)(v13 & 0x3F80) >> 7;
    uint64_t v14 = 2;
  }
  else
  {
    unsigned char *v12 = v13;
    uint64_t v14 = 1;
  }
  char v15 = (char *)*a2 + v14;
  *a2 = v15;
  unsigned int v16 = *(_DWORD *)(a1 + 72);
  if (v16 >> 28)
  {
    *char v15 = v16 | 0x80;
    v15[1] = (v16 >> 7) | 0x80;
    v15[2] = (v16 >> 14) | 0x80;
    void v15[3] = (v16 >> 21) | 0x80;
    v15[4] = v16 >> 28;
    uint64_t v17 = 5;
  }
  else if ((v16 & 0xFE00000) != 0)
  {
    *char v15 = v16 | 0x80;
    v15[1] = (v16 >> 7) | 0x80;
    v15[2] = (v16 >> 14) | 0x80;
    void v15[3] = (v16 & 0xFE00000) >> 21;
    uint64_t v17 = 4;
  }
  else if ((v16 & 0x1FC000) != 0)
  {
    *char v15 = v16 | 0x80;
    v15[1] = (v16 >> 7) | 0x80;
    v15[2] = (v16 & 0x1FC000) >> 14;
    uint64_t v17 = 3;
  }
  else if ((v16 & 0x3F80) != 0)
  {
    *char v15 = v16 | 0x80;
    v15[1] = (unsigned __int16)(v16 & 0x3F80) >> 7;
    uint64_t v17 = 2;
  }
  else
  {
    *char v15 = v16;
    uint64_t v17 = 1;
  }
  int v18 = (char *)*a2 + v17;
  *a2 = v18;
  uint64_t v19 = *(void *)(a1 + 14936);
  if (v19 >> 28)
  {
    *int v18 = v19 | 0x80;
    v18[1] = (v19 >> 7) | 0x80;
    void v18[2] = (v19 >> 14) | 0x80;
    void v18[3] = (v19 >> 21) | 0x80;
    v18[4] = v19 >> 28;
    uint64_t v20 = 5;
  }
  else if ((v19 & 0xFE00000) != 0)
  {
    *int v18 = v19 | 0x80;
    v18[1] = (v19 >> 7) | 0x80;
    void v18[2] = (v19 >> 14) | 0x80;
    void v18[3] = (v19 & 0xFE00000) >> 21;
    uint64_t v20 = 4;
  }
  else if ((v19 & 0x1FC000) != 0)
  {
    *int v18 = v19 | 0x80;
    v18[1] = (v19 >> 7) | 0x80;
    void v18[2] = (v19 & 0x1FC000) >> 14;
    uint64_t v20 = 3;
  }
  else if ((v19 & 0x3F80) != 0)
  {
    *int v18 = v19 | 0x80;
    v18[1] = (unsigned __int16)(v19 & 0x3F80) >> 7;
    uint64_t v20 = 2;
  }
  else
  {
    *int v18 = v19;
    uint64_t v20 = 1;
  }
  int v21 = (char *)*a2 + v20;
  *a2 = v21;
  uint64_t v22 = *(void *)(a1 + 14944);
  if (v22 >> 28)
  {
    *int v21 = v22 | 0x80;
    v21[1] = (v22 >> 7) | 0x80;
    v21[2] = (v22 >> 14) | 0x80;
    void v21[3] = (v22 >> 21) | 0x80;
    v21[4] = v22 >> 28;
    uint64_t v23 = 5;
  }
  else if ((v22 & 0xFE00000) != 0)
  {
    *int v21 = v22 | 0x80;
    v21[1] = (v22 >> 7) | 0x80;
    v21[2] = (v22 >> 14) | 0x80;
    void v21[3] = (v22 & 0xFE00000) >> 21;
    uint64_t v23 = 4;
  }
  else if ((v22 & 0x1FC000) != 0)
  {
    *int v21 = v22 | 0x80;
    v21[1] = (v22 >> 7) | 0x80;
    v21[2] = (v22 & 0x1FC000) >> 14;
    uint64_t v23 = 3;
  }
  else if ((v22 & 0x3F80) != 0)
  {
    *int v21 = v22 | 0x80;
    v21[1] = (unsigned __int16)(v22 & 0x3F80) >> 7;
    uint64_t v23 = 2;
  }
  else
  {
    *int v21 = v22;
    uint64_t v23 = 1;
  }
  uint64_t v24 = (char *)*a2 + v23;
  *a2 = v24;
  if (*(_DWORD *)(a1 + 4) >= 0x57u)
  {
    uint64_t v25 = *(void *)(a1 + 14952);
    if (v25 >> 28)
    {
      unsigned char *v24 = v25 | 0x80;
      v24[1] = (v25 >> 7) | 0x80;
      int v24[2] = (v25 >> 14) | 0x80;
      void v24[3] = (v25 >> 21) | 0x80;
      uint8_t v24[4] = v25 >> 28;
      uint64_t v26 = 5;
    }
    else if ((v25 & 0xFE00000) != 0)
    {
      unsigned char *v24 = v25 | 0x80;
      v24[1] = (v25 >> 7) | 0x80;
      int v24[2] = (v25 >> 14) | 0x80;
      void v24[3] = (v25 & 0xFE00000) >> 21;
      uint64_t v26 = 4;
    }
    else if ((v25 & 0x1FC000) != 0)
    {
      unsigned char *v24 = v25 | 0x80;
      v24[1] = (v25 >> 7) | 0x80;
      int v24[2] = (v25 & 0x1FC000) >> 14;
      uint64_t v26 = 3;
    }
    else if ((v25 & 0x3F80) != 0)
    {
      unsigned char *v24 = v25 | 0x80;
      v24[1] = (unsigned __int16)(v25 & 0x3F80) >> 7;
      uint64_t v26 = 2;
    }
    else
    {
      unsigned char *v24 = v25;
      uint64_t v26 = 1;
    }
    int v27 = (char *)*a2 + v26;
    *a2 = v27;
    uint64_t v28 = *(void *)(a1 + 15008);
    if (v28 >> 28)
    {
      *int v27 = v28 | 0x80;
      v27[1] = (v28 >> 7) | 0x80;
      __int16 v27[2] = (v28 >> 14) | 0x80;
      void v27[3] = (v28 >> 21) | 0x80;
      v27[4] = v28 >> 28;
      uint64_t v29 = 5;
    }
    else if ((v28 & 0xFE00000) != 0)
    {
      *int v27 = v28 | 0x80;
      v27[1] = (v28 >> 7) | 0x80;
      __int16 v27[2] = (v28 >> 14) | 0x80;
      void v27[3] = (v28 & 0xFE00000) >> 21;
      uint64_t v29 = 4;
    }
    else if ((v28 & 0x1FC000) != 0)
    {
      *int v27 = v28 | 0x80;
      v27[1] = (v28 >> 7) | 0x80;
      __int16 v27[2] = (v28 & 0x1FC000) >> 14;
      uint64_t v29 = 3;
    }
    else if ((v28 & 0x3F80) != 0)
    {
      *int v27 = v28 | 0x80;
      v27[1] = (unsigned __int16)(v28 & 0x3F80) >> 7;
      uint64_t v29 = 2;
    }
    else
    {
      *int v27 = v28;
      uint64_t v29 = 1;
    }
    *a2 = (char *)*a2 + v29;
  }
  storeVInt64((uint64_t *)a2, *(void *)(a1 + 80));
  unsigned int v30 = atomic_load((unsigned int *)(a1 + 16));
  int v31 = *a2;
  if (v30 >> 28)
  {
    *int v31 = v30 | 0x80;
    v31[1] = (v30 >> 7) | 0x80;
    v31[2] = (v30 >> 14) | 0x80;
    void v31[3] = (v30 >> 21) | 0x80;
    uint8_t v31[4] = v30 >> 28;
    uint64_t v32 = 5;
  }
  else if ((v30 & 0xFE00000) != 0)
  {
    *int v31 = v30 | 0x80;
    v31[1] = (v30 >> 7) | 0x80;
    v31[2] = (v30 >> 14) | 0x80;
    void v31[3] = (v30 & 0xFE00000) >> 21;
    uint64_t v32 = 4;
  }
  else if ((v30 & 0x1FC000) != 0)
  {
    *int v31 = v30 | 0x80;
    v31[1] = (v30 >> 7) | 0x80;
    v31[2] = (v30 & 0x1FC000) >> 14;
    uint64_t v32 = 3;
  }
  else if ((v30 & 0x3F80) != 0)
  {
    *int v31 = v30 | 0x80;
    v31[1] = (unsigned __int16)(v30 & 0x3F80) >> 7;
    uint64_t v32 = 2;
  }
  else
  {
    *int v31 = v30;
    uint64_t v32 = 1;
  }
  int v33 = (char *)*a2 + v32;
  *a2 = v33;
  unsigned int v34 = *(_DWORD *)(a1 + 52);
  if (v34 >> 28)
  {
    *int v33 = v34 | 0x80;
    v33[1] = (v34 >> 7) | 0x80;
    v33[2] = (v34 >> 14) | 0x80;
    void v33[3] = (v34 >> 21) | 0x80;
    v33[4] = v34 >> 28;
    uint64_t v35 = 5;
  }
  else if ((v34 & 0xFE00000) != 0)
  {
    *int v33 = v34 | 0x80;
    v33[1] = (v34 >> 7) | 0x80;
    v33[2] = (v34 >> 14) | 0x80;
    void v33[3] = (v34 & 0xFE00000) >> 21;
    uint64_t v35 = 4;
  }
  else if ((v34 & 0x1FC000) != 0)
  {
    *int v33 = v34 | 0x80;
    v33[1] = (v34 >> 7) | 0x80;
    v33[2] = (v34 & 0x1FC000) >> 14;
    uint64_t v35 = 3;
  }
  else if ((v34 & 0x3F80) != 0)
  {
    *int v33 = v34 | 0x80;
    v33[1] = (unsigned __int16)(v34 & 0x3F80) >> 7;
    uint64_t v35 = 2;
  }
  else
  {
    *int v33 = v34;
    uint64_t v35 = 1;
  }
  uint64_t v36 = (char *)*a2 + v35;
  *a2 = v36;
  uint64_t v37 = *(void *)(a1 + 24);
  if (v37 >> 28)
  {
    *uint64_t v36 = v37 | 0x80;
    v36[1] = (v37 >> 7) | 0x80;
    v36[2] = (v37 >> 14) | 0x80;
    void v36[3] = (v37 >> 21) | 0x80;
    v36[4] = v37 >> 28;
    uint64_t v38 = 5;
  }
  else if ((v37 & 0xFE00000) != 0)
  {
    *uint64_t v36 = v37 | 0x80;
    v36[1] = (v37 >> 7) | 0x80;
    v36[2] = (v37 >> 14) | 0x80;
    void v36[3] = (v37 & 0xFE00000) >> 21;
    uint64_t v38 = 4;
  }
  else if ((v37 & 0x1FC000) != 0)
  {
    *uint64_t v36 = v37 | 0x80;
    v36[1] = (v37 >> 7) | 0x80;
    v36[2] = (v37 & 0x1FC000) >> 14;
    uint64_t v38 = 3;
  }
  else if ((v37 & 0x3F80) != 0)
  {
    *uint64_t v36 = v37 | 0x80;
    v36[1] = (unsigned __int16)(v37 & 0x3F80) >> 7;
    uint64_t v38 = 2;
  }
  else
  {
    *uint64_t v36 = v37;
    uint64_t v38 = 1;
  }
  uint32_t v39 = (char *)*a2 + v38;
  *a2 = v39;
  unsigned int v40 = *(_DWORD *)(a1 + 96);
  if (v40 >> 28)
  {
    unsigned char *v39 = v40 | 0x80;
    v39[1] = (v40 >> 7) | 0x80;
    v39[2] = (v40 >> 14) | 0x80;
    void v39[3] = (v40 >> 21) | 0x80;
    v39[4] = v40 >> 28;
    uint64_t v41 = 5;
  }
  else if ((v40 & 0xFE00000) != 0)
  {
    unsigned char *v39 = v40 | 0x80;
    v39[1] = (v40 >> 7) | 0x80;
    v39[2] = (v40 >> 14) | 0x80;
    void v39[3] = (v40 & 0xFE00000) >> 21;
    uint64_t v41 = 4;
  }
  else if ((v40 & 0x1FC000) != 0)
  {
    unsigned char *v39 = v40 | 0x80;
    v39[1] = (v40 >> 7) | 0x80;
    v39[2] = (v40 & 0x1FC000) >> 14;
    uint64_t v41 = 3;
  }
  else if ((v40 & 0x3F80) != 0)
  {
    unsigned char *v39 = v40 | 0x80;
    v39[1] = (unsigned __int16)(v40 & 0x3F80) >> 7;
    uint64_t v41 = 2;
  }
  else
  {
    unsigned char *v39 = v40;
    uint64_t v41 = 1;
  }
  int v42 = (char *)*a2 + v41;
  *a2 = v42;
  unsigned int v43 = *(_DWORD *)(a1 + 240);
  if (v43 >> 28)
  {
    unsigned char *v42 = v43 | 0x80;
    v42[1] = (v43 >> 7) | 0x80;
    v42[2] = (v43 >> 14) | 0x80;
    void v42[3] = (v43 >> 21) | 0x80;
    v42[4] = v43 >> 28;
    uint64_t v44 = 5;
  }
  else if ((v43 & 0xFE00000) != 0)
  {
    unsigned char *v42 = v43 | 0x80;
    v42[1] = (v43 >> 7) | 0x80;
    v42[2] = (v43 >> 14) | 0x80;
    void v42[3] = (v43 & 0xFE00000) >> 21;
    uint64_t v44 = 4;
  }
  else if ((v43 & 0x1FC000) != 0)
  {
    unsigned char *v42 = v43 | 0x80;
    v42[1] = (v43 >> 7) | 0x80;
    v42[2] = (v43 & 0x1FC000) >> 14;
    uint64_t v44 = 3;
  }
  else if ((v43 & 0x3F80) != 0)
  {
    unsigned char *v42 = v43 | 0x80;
    v42[1] = (unsigned __int16)(v43 & 0x3F80) >> 7;
    uint64_t v44 = 2;
  }
  else
  {
    unsigned char *v42 = v43;
    uint64_t v44 = 1;
  }
  uint64_t v45 = (char *)*a2 + v44;
  *a2 = v45;
  unsigned int v46 = *(_DWORD *)(a1 + 244);
  if (v46 >> 28)
  {
    *uint64_t v45 = v46 | 0x80;
    v45[1] = (v46 >> 7) | 0x80;
    v45[2] = (v46 >> 14) | 0x80;
    void v45[3] = (v46 >> 21) | 0x80;
    v45[4] = v46 >> 28;
    uint64_t v47 = 5;
  }
  else if ((v46 & 0xFE00000) != 0)
  {
    *uint64_t v45 = v46 | 0x80;
    v45[1] = (v46 >> 7) | 0x80;
    v45[2] = (v46 >> 14) | 0x80;
    void v45[3] = (v46 & 0xFE00000) >> 21;
    uint64_t v47 = 4;
  }
  else if ((v46 & 0x1FC000) != 0)
  {
    *uint64_t v45 = v46 | 0x80;
    v45[1] = (v46 >> 7) | 0x80;
    v45[2] = (v46 & 0x1FC000) >> 14;
    uint64_t v47 = 3;
  }
  else if ((v46 & 0x3F80) != 0)
  {
    *uint64_t v45 = v46 | 0x80;
    v45[1] = (unsigned __int16)(v46 & 0x3F80) >> 7;
    uint64_t v47 = 2;
  }
  else
  {
    *uint64_t v45 = v46;
    uint64_t v47 = 1;
  }
  *a2 = (char *)*a2 + v47;
  storeVInt64((uint64_t *)a2, *(void *)(a1 + 4944));
  storeVInt64((uint64_t *)a2, *(void *)(a1 + 4952));
  storeVInt64((uint64_t *)a2, *(void *)(a1 + 4968));
  storeVInt64((uint64_t *)a2, *(void *)(a1 + 4976));
  unsigned int v48 = *(_DWORD *)(a1 + 40);
  os_log_type_t v49 = *a2;
  if (v48 >> 28)
  {
    *os_log_type_t v49 = v48 | 0x80;
    v49[1] = (v48 >> 7) | 0x80;
    v49[2] = (v48 >> 14) | 0x80;
    v49[3] = (v48 >> 21) | 0x80;
    v49[4] = v48 >> 28;
    uint64_t v50 = 5;
  }
  else if ((v48 & 0xFE00000) != 0)
  {
    *os_log_type_t v49 = v48 | 0x80;
    v49[1] = (v48 >> 7) | 0x80;
    v49[2] = (v48 >> 14) | 0x80;
    v49[3] = (v48 & 0xFE00000) >> 21;
    uint64_t v50 = 4;
  }
  else if ((v48 & 0x1FC000) != 0)
  {
    *os_log_type_t v49 = v48 | 0x80;
    v49[1] = (v48 >> 7) | 0x80;
    v49[2] = (v48 & 0x1FC000) >> 14;
    uint64_t v50 = 3;
  }
  else if ((v48 & 0x3F80) != 0)
  {
    *os_log_type_t v49 = v48 | 0x80;
    v49[1] = (unsigned __int16)(v48 & 0x3F80) >> 7;
    uint64_t v50 = 2;
  }
  else
  {
    *os_log_type_t v49 = v48;
    uint64_t v50 = 1;
  }
  double v51 = *a2;
  *a2 = (char *)*a2 + v50;
  v51[v50] = *(unsigned char *)(a1 + 44);
  *a2 = (char *)*a2 + 1;
  termIdStoreHeaderStore(a1 + 4984, (unsigned char **)a2);
  storeVInt64((uint64_t *)a2, *(void *)(a1 + 9664));
  storeVInt64((uint64_t *)a2, *(void *)(a1 + 9672));
  storeVInt64((uint64_t *)a2, *(void *)(a1 + 9688));
  storeVInt64((uint64_t *)a2, *(void *)(a1 + 9696));
  *(unsigned char *)*a2 = 0;
  BOOL v52 = (char *)*a2 + 1;
  *a2 = v52;
  *BOOL v52 = 0;
  *a2 = (char *)*a2 + 1;
  termIdStoreHeaderStore(a1 + 9704, (unsigned char **)a2);
  unsigned int v53 = *(_DWORD *)(a1 + 120);
  BOOL v54 = *a2;
  if (v53 >> 28)
  {
    *BOOL v54 = v53 | 0x80;
    v54[1] = (v53 >> 7) | 0x80;
    v54[2] = (v53 >> 14) | 0x80;
    v54[3] = (v53 >> 21) | 0x80;
    v54[4] = v53 >> 28;
    uint64_t v55 = 5;
  }
  else if ((v53 & 0xFE00000) != 0)
  {
    *BOOL v54 = v53 | 0x80;
    v54[1] = (v53 >> 7) | 0x80;
    v54[2] = (v53 >> 14) | 0x80;
    v54[3] = (v53 & 0xFE00000) >> 21;
    uint64_t v55 = 4;
  }
  else if ((v53 & 0x1FC000) != 0)
  {
    *BOOL v54 = v53 | 0x80;
    v54[1] = (v53 >> 7) | 0x80;
    v54[2] = (v53 & 0x1FC000) >> 14;
    uint64_t v55 = 3;
  }
  else if ((v53 & 0x3F80) != 0)
  {
    *BOOL v54 = v53 | 0x80;
    v54[1] = (unsigned __int16)(v53 & 0x3F80) >> 7;
    uint64_t v55 = 2;
  }
  else
  {
    *BOOL v54 = v53;
    uint64_t v55 = 1;
  }
  float v56 = (char *)*a2 + v55;
  *a2 = v56;
  uint64_t v57 = *(void *)(a1 + 128);
  if (v57 >> 28)
  {
    *float v56 = v57 | 0x80;
    v56[1] = (v57 >> 7) | 0x80;
    v56[2] = (v57 >> 14) | 0x80;
    v56[3] = (v57 >> 21) | 0x80;
    uint8_t v56[4] = v57 >> 28;
    uint64_t v58 = 5;
  }
  else if ((v57 & 0xFE00000) != 0)
  {
    *float v56 = v57 | 0x80;
    v56[1] = (v57 >> 7) | 0x80;
    v56[2] = (v57 >> 14) | 0x80;
    v56[3] = (v57 & 0xFE00000) >> 21;
    uint64_t v58 = 4;
  }
  else if ((v57 & 0x1FC000) != 0)
  {
    *float v56 = v57 | 0x80;
    v56[1] = (v57 >> 7) | 0x80;
    v56[2] = (v57 & 0x1FC000) >> 14;
    uint64_t v58 = 3;
  }
  else if ((v57 & 0x3F80) != 0)
  {
    *float v56 = v57 | 0x80;
    v56[1] = (unsigned __int16)(v57 & 0x3F80) >> 7;
    uint64_t v58 = 2;
  }
  else
  {
    *float v56 = v57;
    uint64_t v58 = 1;
  }
  uint64_t v59 = (char *)*a2 + v58;
  *a2 = v59;
  uint64_t v60 = *(void *)(a1 + 136);
  if (v60 >> 28)
  {
    *uint64_t v59 = v60 | 0x80;
    v59[1] = (v60 >> 7) | 0x80;
    v59[2] = (v60 >> 14) | 0x80;
    v59[3] = (v60 >> 21) | 0x80;
    v59[4] = v60 >> 28;
    uint64_t v61 = 5;
  }
  else if ((v60 & 0xFE00000) != 0)
  {
    *uint64_t v59 = v60 | 0x80;
    v59[1] = (v60 >> 7) | 0x80;
    v59[2] = (v60 >> 14) | 0x80;
    v59[3] = (v60 & 0xFE00000) >> 21;
    uint64_t v61 = 4;
  }
  else if ((v60 & 0x1FC000) != 0)
  {
    *uint64_t v59 = v60 | 0x80;
    v59[1] = (v60 >> 7) | 0x80;
    v59[2] = (v60 & 0x1FC000) >> 14;
    uint64_t v61 = 3;
  }
  else if ((v60 & 0x3F80) != 0)
  {
    *uint64_t v59 = v60 | 0x80;
    v59[1] = (unsigned __int16)(v60 & 0x3F80) >> 7;
    uint64_t v61 = 2;
  }
  else
  {
    *uint64_t v59 = v60;
    uint64_t v61 = 1;
  }
  uint64_t v62 = 0;
  int v63 = (char *)*a2 + v61;
  *a2 = v63;
  do
  {
    unsigned int v65 = *(_DWORD *)(a1 + 144 + v62);
    if (v65 >> 28)
    {
      *int v63 = v65 | 0x80;
      v63[1] = (v65 >> 7) | 0x80;
      void v63[2] = (v65 >> 14) | 0x80;
      v63[3] = (v65 >> 21) | 0x80;
      v63[4] = v65 >> 28;
      uint64_t v64 = 5;
    }
    else if ((v65 & 0xFE00000) != 0)
    {
      *int v63 = v65 | 0x80;
      v63[1] = (v65 >> 7) | 0x80;
      void v63[2] = (v65 >> 14) | 0x80;
      v63[3] = (v65 & 0xFE00000) >> 21;
      uint64_t v64 = 4;
    }
    else if ((v65 & 0x1FC000) != 0)
    {
      *int v63 = v65 | 0x80;
      v63[1] = (v65 >> 7) | 0x80;
      void v63[2] = (v65 & 0x1FC000) >> 14;
      uint64_t v64 = 3;
    }
    else if ((v65 & 0x3F80) != 0)
    {
      *int v63 = v65 | 0x80;
      v63[1] = (unsigned __int16)(v65 & 0x3F80) >> 7;
      uint64_t v64 = 2;
    }
    else
    {
      *int v63 = v65;
      uint64_t v64 = 1;
    }
    v62 += 4;
    int v63 = (char *)*a2 + v64;
    *a2 = v63;
  }
  while (v62 != 64);
  storageHeaderStore(a1 + 256, (uint64_t *)a2);
  strlcpy((char *)*a2, (const char *)(a1 + 15495), 0x20uLL);
  int v66 = strlen((const char *)(a1 + 15495));
  if ((v66 & 0xFFFFFFE0) != 0)
  {
    uint64_t v80 = __si_assert_copy_extra_2445(0, -1);
    unint64_t v81 = v80;
    unsigned int v82 = "";
    if (v80) {
      unsigned int v82 = v80;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", 5225, "len > 0 && len <= 32", v82);
LABEL_191:
    free(v81);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  __int16 v67 = (char *)*a2 + (v66 + 1);
  *a2 = v67;
  strlcpy(v67, (const char *)(a1 + 15463), 0x20uLL);
  int v68 = strlen((const char *)(a1 + 15463));
  if ((v68 & 0xFFFFFFE0) != 0)
  {
    int v83 = __si_assert_copy_extra_2445(0, -1);
    unint64_t v81 = v83;
    size_t v84 = "";
    if (v83) {
      size_t v84 = v83;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", 5231, "len > 0 && len <= 32", v84);
    goto LABEL_191;
  }
  __int16 v69 = (char *)*a2 + (v68 + 1);
  *a2 = v69;
  strlcpy(v69, (const char *)sysVersionCStr, 0x20uLL);
  int v70 = strlen((const char *)sysVersionCStr);
  if ((v70 & 0xFFFFFFE0) != 0)
  {
    malloc_type_id_t v85 = __si_assert_copy_extra_2445(0, -1);
    unint64_t v81 = v85;
    unsigned int v86 = "";
    if (v85) {
      unsigned int v86 = v85;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", 5237, "len > 0 && len <= 32", v86);
    goto LABEL_191;
  }
  int v71 = (char *)*a2 + (v70 + 1);
  *a2 = v71;
  strlcpy(v71, (const char *)buildVersionCStr, 0x20uLL);
  int v72 = strlen((const char *)buildVersionCStr);
  if ((v72 & 0xFFFFFFE0) != 0)
  {
    int v87 = __si_assert_copy_extra_2445(0, -1);
    unint64_t v81 = v87;
    int v88 = "";
    if (v87) {
      int v88 = v87;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", 5243, "len > 0 && len <= 32", v88);
    goto LABEL_191;
  }
  *a2 = (char *)*a2 + (v72 + 1);
  storeVInt64((uint64_t *)a2, *(void *)(a1 + 15560));
  *(void *)(a1 + 15584) = *(void *)(a1 + 15576);
  *(_OWORD *)(a1 + 15592) = *(_OWORD *)(a1 + 14984);
  *(void *)(a1 + 15608) = *(void *)(a1 + 15032);
  *(_OWORD *)(a1 + 15616) = *(_OWORD *)(a1 + 14960);
  *(void *)(a1 + 15632) = *(void *)(a1 + 15024);
  *(void *)(a1 + 15640) = *(void *)(a1 + 15568);
  *(void *)(a1 + 15648) = *(void *)(a1 + 15016);
  unsigned int v73 = *(_DWORD *)(a1 + 4);
  if (!*(unsigned char *)(a1 + 45))
  {
    if (v73 >= 0x65) {
      goto LABEL_88;
    }
LABEL_90:
    uint64_t v74 = 9;
    goto LABEL_91;
  }
  if (v73 <= 0x71) {
    goto LABEL_90;
  }
LABEL_88:
  *(void *)(a1 + 15656) = *(unsigned int *)(a1 + 56);
  uint64_t v74 = 10;
LABEL_91:
  unsigned int v75 = (unint64_t *)(a1 + 15584);
  do
  {
    unint64_t v76 = *v75++;
    uint64_t result = storeVInt64((uint64_t *)a2, v76);
    --v74;
  }
  while (v74);
  unsigned int v78 = *a2;
  unsigned int v79 = *a2 - v4 + 4;
  *unsigned int v78 = v79;
  *a2 = v78 + 1;
  v8[2] = v79;
  return result;
}

uint64_t indexCommitShadow(uint64_t a1, _DWORD *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  atomic_store(0xC001D00D, (unsigned int *)(a1 + 32));
  *a2 = *(_DWORD *)(a1 + 4);
  unsigned int v4 = atomic_load((unsigned int *)(a1 + 32));
  a2[1] = v4;
  unsigned int v5 = atomic_load((unsigned int *)(a1 + 36));
  a2[2] = v5;
  a2[3] = *(_DWORD *)(a1 + 48);
  unsigned int v6 = *(_DWORD **)(a1 + 14480);
  if (v6)
  {
    uint64_t v7 = fd_pwrite(*(void *)(a1 + 14480), (uint64_t)a2, 0x1000uLL, 0);
    if (v7 == -1)
    {
      uint64_t result = *__error();
      if (result) {
        return result;
      }
    }
    else
    {
      if (v7 != 4096) {
        return 0xFFFFFFFFLL;
      }
      if (_gSystemStatusBool)
      {
        pthread_mutex_lock(&_gSystemStatusLock);
        while (_gSystemStatusBool)
          pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
        pthread_mutex_unlock(&_gSystemStatusLock);
      }
      uint64_t v13 = 0;
      uint64_t v8 = _fd_acquire_fd((uint64_t)v6, &v13);
      if (v8 != -1)
      {
        int v9 = v8;
        prot_fsync(v8, 0);
        _fd_release_fd(v6, v9, 0, v13);
      }
    }
  }
  char v11 = atomic_load((unsigned int *)(a1 + 36));
  if ((v11 & 2) == 0)
  {
    snprintf(__str, 0x400uLL, "%s%s", (const char *)(a1 + 15208), "indexUpdates");
    unlinkat(*(_DWORD *)(a1 + 64), __str, 0);
    uint64_t v12 = (atomic_uint *)fd_create_protected(*(_DWORD *)(a1 + 64), __str, 536872450, 3u);
    fd_release(v12);
  }
  return 0;
}

uint64_t _indexShadowGroups(uint64_t a1, int a2)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  double Current = CFAbsoluteTimeGetCurrent();
  snprintf(__str, 0x400uLL, "%s%s", (const char *)(a1 + 15208), "shadowIndexGroups");
  unsigned int v5 = fd_create_protected(*(_DWORD *)(a1 + 64), __str, 536871426, 3u);
  uint64_t v6 = (uint64_t)v5;
  if (!v5)
  {
    unsigned int v25 = *__error();
    int v26 = *__error();
    int v27 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_86;
    }
    *(_DWORD *)statfs buf = 136315906;
    *(void *)&uint8_t buf[4] = "_indexShadowGroups";
    __int16 v81 = 1024;
    int v82 = 3080;
    __int16 v83 = 1024;
    int v84 = v25;
    __int16 v85 = 2080;
    *(void *)unsigned int v86 = __str;
    uint64_t v28 = "%s:%d: open err: %d, %s";
    uint64_t v29 = v27;
    uint32_t v30 = 34;
    goto LABEL_91;
  }
  *(void *)statfs buf = 0;
  int v7 = _fd_acquire_fd((uint64_t)v5, buf);
  if (v7 != -1)
  {
    int v8 = v7;
    *(_WORD *)(v6 + 56) |= 1u;
    fcntl(v7, 48, 1);
    fcntl(v8, 76, *(_WORD *)(v6 + 56) & 1);
    _fd_release_fd((_DWORD *)v6, v8, 0, *(uint64_t *)buf);
  }
  uint64_t v9 = *(void *)(a1 + 14440);
  if (__THREAD_SLOT_KEY)
  {
    unsigned int v10 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v10) {
      goto LABEL_6;
    }
  }
  else
  {
    makeThreadId();
    unsigned int v10 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v10)
    {
LABEL_6:
      if ((unint64_t)v10 < 0x801) {
        goto LABEL_7;
      }
    }
  }
  makeThreadId();
  unsigned int v10 = pthread_getspecific(__THREAD_SLOT_KEY);
LABEL_7:
  uint64_t v11 = (uint64_t)v10 - 1;
  unint64_t v12 = CICleanUpPush((uint64_t)v10 - 1, (uint64_t)fd_release, v6);
  if (!v9)
  {
    unsigned int v31 = *(_DWORD *)(a1 + 68);
    if (*(unsigned char *)(a1 + 45)) {
      unint64_t v32 = v31;
    }
    else {
      unint64_t v32 = (4 * v31 + 4) / 5;
    }
    uint64_t v33 = fd_pwrite(v6, *(void *)(a1 + 14432), v32, 0);
    CICleanUpClearItem(v11, v12);
    CICleanUpPop(v11);
    if (v33 == v32)
    {
      uint64_t v34 = *(unsigned int *)(a1 + 72);
      unint64_t v35 = (v34 + 4) / 5uLL;
      unint64_t v36 = (unint64_t)(v34 + 3) >> 2;
      if (*(unsigned char *)(a1 + 45)) {
        unint64_t v37 = v36;
      }
      else {
        unint64_t v37 = v35;
      }
      *(void *)(a1 + 14440) = malloc_type_calloc(1uLL, (8 * *MEMORY[0x1E4F14B00] - 1 + v37) / (8 * *MEMORY[0x1E4F14B00]), 0xBE5D8627uLL);
      goto LABEL_28;
    }
    if (v33 == -1) {
      unsigned int v25 = *__error();
    }
    else {
      unsigned int v25 = 0;
    }
    int v26 = *__error();
    __int16 v69 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
      goto LABEL_86;
    }
    *(_DWORD *)statfs buf = 136316418;
    *(void *)&uint8_t buf[4] = "_indexShadowGroups";
    __int16 v81 = 1024;
    int v82 = 3110;
    __int16 v83 = 1024;
    int v84 = v32;
    __int16 v85 = 1024;
    *(_DWORD *)unsigned int v86 = v33;
    *(_WORD *)&v86[4] = 1024;
    *(_DWORD *)&v86[6] = v25;
    __int16 v87 = 2080;
    int v88 = __str;
    uint64_t v28 = "%s:%d: write(%d) %d err: %d, %s";
LABEL_90:
    uint64_t v29 = v69;
    uint32_t v30 = 46;
LABEL_91:
    _os_log_error_impl(&dword_1BD672000, v29, OS_LOG_TYPE_ERROR, v28, buf, v30);
    goto LABEL_86;
  }
  uint64_t v79 = 0;
  uint64_t v13 = _fd_acquire_fd(v6, &v79);
  int v14 = *(unsigned __int8 *)(a1 + 45);
  uint64_t v15 = *(unsigned int *)(a1 + 68);
  unsigned int v16 = (uint64_t *)MEMORY[0x1E4F14B00];
  unint64_t v17 = 8 * *MEMORY[0x1E4F14B00];
  unint64_t v18 = (v15 + 4) / 5uLL;
  if (*(unsigned char *)(a1 + 45)) {
    unint64_t v18 = (unint64_t)(v15 + 3) >> 2;
  }
  unint64_t v19 = v17 - 1 + v18;
  if (v17 > v19)
  {
LABEL_11:
    if (v14) {
      off_t v20 = v15;
    }
    else {
      off_t v20 = (4 * (int)v15 + 4) / 5u;
    }
    _fd_ftruncate(v13, v20);
    _fd_release_fd((_DWORD *)v6, v13, 0, v79);
    CICleanUpClearItem(v11, v12);
    CICleanUpPop(v11);
    uint64_t v21 = *(unsigned int *)(a1 + 68);
    unint64_t v22 = (v21 + 4) / 5uLL;
    unint64_t v23 = (unint64_t)(v21 + 3) >> 2;
    if (*(unsigned char *)(a1 + 45)) {
      unint64_t v24 = v23;
    }
    else {
      unint64_t v24 = v22;
    }
    bzero(*(void **)(a1 + 14440), (8 * *v16 - 1 + v24) / (8 * *v16));
LABEL_28:
    if (_gSystemStatusBool)
    {
      pthread_mutex_lock(&_gSystemStatusLock);
      while (_gSystemStatusBool)
        pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
      pthread_mutex_unlock(&_gSystemStatusLock);
    }
    *(void *)statfs buf = 0;
    uint64_t v38 = _fd_acquire_fd(v6, buf);
    if (v38 != -1)
    {
      int v39 = v38;
      if (a2) {
        BOOL v40 = (*(_WORD *)(v6 + 56) & 8) == 0;
      }
      else {
        BOOL v40 = 0;
      }
      prot_fsync(v38, v40);
      _fd_release_fd((_DWORD *)v6, v39, 0, *(uint64_t *)buf);
    }
    fd_release((atomic_uint *)v6);
    int v63 = *__error();
    uint64_t v64 = _SILogForLogForCategory(10);
    os_log_type_t v65 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v64, v65))
    {
      float v66 = CFAbsoluteTimeGetCurrent() - Current;
      *(_DWORD *)statfs buf = 134217984;
      *(double *)&uint8_t buf[4] = v66;
      _os_log_impl(&dword_1BD672000, v64, v65, "shadowIndexGroups took %f seconds", buf, 0xCu);
    }
    __int16 v67 = __error();
    uint64_t result = 0;
    *__int16 v67 = v63;
    return result;
  }
  uint64_t v72 = v11;
  uint64_t v41 = 0;
  uint64_t v78 = 4 * *MEMORY[0x1E4F14B00];
  unint64_t v73 = v19 / v17;
  unint64_t v77 = v12;
  while (!*(unsigned char *)(*(void *)(a1 + 14440) + v41))
  {
LABEL_63:
    if (++v41 == v73)
    {
      int v14 = *(unsigned __int8 *)(a1 + 45);
      LODWORD(v15) = *(_DWORD *)(a1 + 68);
      uint64_t v11 = v72;
      goto LABEL_11;
    }
  }
  uint64_t v42 = 0;
  uint64_t v43 = 8 * v41;
  while (1)
  {
    if (((*(char *)(*(void *)(a1 + 14440) + v41) >> v42) & 1) == 0) {
      goto LABEL_39;
    }
    uint64_t v44 = *v16;
    uint64_t v45 = v43 + v42;
    unint64_t v46 = (4 * v45 + 4) * *v16;
    unint64_t v47 = *(unsigned int *)(a1 + 68);
    if (*(unsigned char *)(a1 + 45))
    {
      if (v46 < v47) {
        break;
      }
      goto LABEL_52;
    }
    unint64_t v47 = (4 * v47 + 4) / 5uLL;
    if (v46 < v47) {
      break;
    }
LABEL_52:
    uint64_t v56 = 4 * v44 * v45;
    unint64_t v57 = v47 - v56;
    uint64_t v58 = *(void *)(a1 + 14432) + v56;
    unint64_t v74 = v47 - v56;
    uint64_t v76 = 0;
    do
    {
      while (1)
      {
        unint64_t v59 = guarded_pwrite_np();
        if ((v59 & 0x8000000000000000) != 0) {
          break;
        }
        uint64_t v62 = v59 + v76;
        BOOL v55 = v57 > v59;
        v57 -= v59;
        if (!v55) {
          goto LABEL_61;
        }
        v76 += v59;
        v58 += v59;
        v56 += v59;
      }
      uint64_t v60 = g_prot_error_callback;
      if (!g_prot_error_callback) {
        break;
      }
      uint64_t v61 = __error();
    }
    while (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v60 + 16))(v60, v13, *v61, 5) & 1) != 0);
    uint64_t v62 = -1;
LABEL_61:
    unint64_t v12 = v77;
    uint64_t v43 = 8 * v41;
    unsigned int v16 = (uint64_t *)MEMORY[0x1E4F14B00];
    if (v62 != v74)
    {
      int v70 = v62;
      if (v62 == -1) {
        unsigned int v25 = *__error();
      }
      else {
        unsigned int v25 = 0;
      }
      int v26 = *__error();
      __int16 v69 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)statfs buf = 136316418;
        *(void *)&uint8_t buf[4] = "_indexShadowGroups";
        __int16 v81 = 1024;
        int v82 = 3143;
        __int16 v83 = 1024;
        int v84 = v74;
        __int16 v85 = 1024;
        *(_DWORD *)unsigned int v86 = v70;
        *(_WORD *)&v86[4] = 1024;
        *(_DWORD *)&v86[6] = v25;
        __int16 v87 = 2080;
        int v88 = __str;
        uint64_t v28 = "%s:%d: write(%d) %d err: %d, %s";
        goto LABEL_90;
      }
      goto LABEL_86;
    }
LABEL_39:
    if (++v42 == 8) {
      goto LABEL_63;
    }
  }
  uint64_t v75 = 0;
  uint64_t v48 = 4 * v44 * v45;
  uint64_t v49 = *(void *)(a1 + 14432) + v48;
  unint64_t v50 = v78;
  while (1)
  {
    while (1)
    {
      unint64_t v51 = guarded_pwrite_np();
      if ((v51 & 0x8000000000000000) == 0) {
        break;
      }
      uint64_t v52 = g_prot_error_callback;
      if (g_prot_error_callback)
      {
        unsigned int v53 = __error();
        if ((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v52 + 16))(v52, v13, *v53, 5))continue; {
      }
        }
      goto LABEL_84;
    }
    uint64_t v54 = v51 + v75;
    BOOL v55 = v50 > v51;
    v50 -= v51;
    if (!v55) {
      break;
    }
    v75 += v51;
    v49 += v51;
    v48 += v51;
  }
  uint64_t v43 = 8 * v41;
  unint64_t v12 = v77;
  unsigned int v16 = (uint64_t *)MEMORY[0x1E4F14B00];
  if (v54 == v78) {
    goto LABEL_39;
  }
  if (v54 != -1)
  {
    int v71 = v51 + v75;
    unsigned int v25 = 0;
    goto LABEL_85;
  }
LABEL_84:
  unsigned int v25 = *__error();
  int v71 = -1;
LABEL_85:
  int v26 = *__error();
  __int16 v69 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)statfs buf = 136316418;
    *(void *)&uint8_t buf[4] = "_indexShadowGroups";
    __int16 v81 = 1024;
    int v82 = 3132;
    __int16 v83 = 1024;
    int v84 = v78;
    __int16 v85 = 1024;
    *(_DWORD *)unsigned int v86 = v71;
    *(_WORD *)&v86[4] = 1024;
    *(_DWORD *)&v86[6] = v25;
    __int16 v87 = 2080;
    int v88 = __str;
    uint64_t v28 = "%s:%d: write(%d) %d err: %d, %s";
    goto LABEL_90;
  }
LABEL_86:
  *__error() = v26;
  fd_release((atomic_uint *)v6);
  if (v25) {
    return v25;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t index_verify(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  __int16 v5 = v4;
  uint64_t v6 = v1;
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  int v7 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v8 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v7);
  unsigned int v71 = HIDWORD(v8);
  unsigned int v72 = v8;
  unint64_t v70 = __PAIR64__(v9, v10);
  uint64_t v11 = *(void *)&threadData[18 * v8 + 2];
  uint64_t v12 = v11 + 320 * HIDWORD(v8);
  int v59 = *(_DWORD *)(v12 + 312);
  uint64_t v13 = *(void (**)(void))(v12 + 224);
  if (v13) {
    v13(*(void *)(v11 + 320 * HIDWORD(v8) + 288));
  }
  unsigned int v69 = v72;
  unsigned int v68 = v71;
  unint64_t v67 = v70;
  int v14 = &unk_1E9FC9000;
  if (_setjmp((int *)v12))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v12 + 312) = v59;
    if (__THREAD_SLOT_KEY)
    {
      uint64_t v15 = pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v15) {
        goto LABEL_73;
      }
    }
    else
    {
      makeThreadId();
      uint64_t v15 = pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v15) {
        goto LABEL_73;
      }
    }
    unsigned int v16 = v15;
    if ((unint64_t)v15 < 0x801)
    {
LABEL_9:
      uint64_t v17 = (uint64_t)v16 - 1;
      unint64_t v18 = &threadData[18 * ((uint64_t)v16 - 1)];
      unsigned int v20 = v18[14];
      unint64_t v19 = v18 + 14;
      if (v20 > v67)
      {
        do
          CIOnThreadCleanUpPop(v17);
        while (*v19 > v67);
      }
      dropThreadId(v69, 1, v7);
      CICleanUpReset(v69, HIDWORD(v67));
      uint64_t v21 = 0xFFFFFFFFLL;
      goto LABEL_67;
    }
LABEL_73:
    makeThreadId();
    unsigned int v16 = pthread_getspecific(__THREAD_SLOT_KEY);
    goto LABEL_9;
  }
  int v22 = *__error();
  unint64_t v23 = _SILogForLogForCategory(10);
  os_log_type_t v24 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v23, v24))
  {
    *(_DWORD *)statfs buf = 136315138;
    unint64_t v74 = (const char *)(v6 + 15208);
    _os_log_impl(&dword_1BD672000, v23, v24, "Validating %s", buf, 0xCu);
  }
  *__error() = v22;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  v66[0] = 0;
  v66[1] = v3;
  DWORD2(v63) = *(_DWORD *)(v6 + 9400);
  *(void *)&long long v65 = v6 + 4984;
  *((void *)&v65 + 1) = v6 + 9704;
  uint64_t v25 = *(void *)(v6 + 9688);
  *(void *)&long long v64 = *(void *)(v6 + 4968);
  *((void *)&v64 + 1) = v25;
  LODWORD(v66[0]) = *(_DWORD *)(v6 + 4680);
  char v26 = atomic_load((unsigned int *)(v6 + 36));
  if (v5 < 0 || (v26 & 2) == 0)
  {
    int v29 = *(_DWORD *)(v6 + 4680);
    if (v29 == 1)
    {
      int v60 = v7;
      if ((v5 & 2) != 0)
      {
        uint64_t v61 = 0;
        BOOL v37 = strtod((const char *)(v6 + 15463), &v61) > 425.0 && v61 != (char *)(v6 + 15463);
        bzero(buf, 0x5160uLL);
        _dumpTrie(v6 + 96, v37, (_DWORD *)v66 + 1, buf, (uint64_t)verifyTermsCallback, (uint64_t)&v62);
      }
    }
    else
    {
      if (v29)
      {
        int v38 = *__error();
        int v39 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          int v58 = *(_DWORD *)(v6 + 4680);
          *(_DWORD *)statfs buf = 136315906;
          unint64_t v74 = "index_verify";
          __int16 v75 = 1024;
          int v76 = 2569;
          __int16 v77 = 2080;
          uint64_t v78 = v6 + 15208;
          __int16 v79 = 1024;
          int v80 = v58;
          _os_log_error_impl(&dword_1BD672000, v39, OS_LOG_TYPE_ERROR, "%s:%d: %s invalid type %d", buf, 0x22u);
        }
        int v28 = v59;
        goto LABEL_63;
      }
      int v60 = v7;
      if (v5)
      {
        bzero(buf, 0x5160uLL);
        _dumpTrie(v6 + 96, 1, (_DWORD *)v66 + 1, buf, (uint64_t)verifyTermsCallback, (uint64_t)&v62);
        if (*(int *)(v6 + 5232) >= 1)
        {
          uint64_t v30 = 0;
          int v31 = *(_DWORD *)(v6 + 5232);
          do
          {
            uint64_t v32 = *(void *)(v6 + 8 * v30 + 5256);
            if (v32)
            {
              uint64_t v33 = *(void **)(v32 + 8);
              if (v33)
              {
                uint64_t v35 = *(void *)(v32 + 16);
                uint64_t v34 = *(void *)(v32 + 24);
                if (_gSystemStatusBool)
                {
                  pthread_mutex_lock(&_gSystemStatusLock);
                  while (_gSystemStatusBool)
                    pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
                  pthread_mutex_unlock(&_gSystemStatusLock);
                }
                msync(v33, v34 - v35, 16);
                madvise(*(void **)(v32 + 8), *(void *)(v32 + 24) - *(void *)(v32 + 16), 4);
                int v31 = *(_DWORD *)(v6 + 5232);
              }
            }
            ++v30;
          }
          while (v30 < v31);
        }
        if (*(int *)(v6 + 9952) >= 1)
        {
          uint64_t v40 = 0;
          int v41 = *(_DWORD *)(v6 + 9952);
          do
          {
            uint64_t v42 = *(void *)(v6 + 8 * v40 + 9976);
            if (v42)
            {
              uint64_t v43 = *(void **)(v42 + 8);
              if (v43)
              {
                uint64_t v45 = *(void *)(v42 + 16);
                uint64_t v44 = *(void *)(v42 + 24);
                if (_gSystemStatusBool)
                {
                  pthread_mutex_lock(&_gSystemStatusLock);
                  while (_gSystemStatusBool)
                    pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
                  pthread_mutex_unlock(&_gSystemStatusLock);
                }
                msync(v43, v44 - v45, 16);
                madvise(*(void **)(v42 + 8), *(void *)(v42 + 24) - *(void *)(v42 + 16), 4);
                int v41 = *(_DWORD *)(v6 + 9952);
              }
            }
            ++v40;
          }
          while (v40 < v41);
        }
      }
    }
    int v46 = HIDWORD(v66[0]);
    int v28 = v59;
    if (HIDWORD(v66[0]) && !*v3)
    {
      int v38 = *__error();
      uint64_t v48 = _SILogForLogForCategory(0);
      int v14 = (_DWORD *)&unk_1E9FC9000;
      int v7 = v60;
      if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
        goto LABEL_63;
      }
      *(_DWORD *)statfs buf = 136315650;
      unint64_t v74 = "index_verify";
      __int16 v75 = 1024;
      int v76 = 2573;
      __int16 v77 = 2080;
      uint64_t v78 = v6 + 15208;
      uint64_t v49 = "%s:%d: %s error walking terms";
    }
    else
    {
      uint64_t v47 = *(void *)(v6 + 4928);
      int v14 = &unk_1E9FC9000;
      int v7 = v60;
      if (v47)
      {
        dumpDirectoryStore(v47);
        int v46 = HIDWORD(v66[0]);
      }
      if (!v46 || *v3)
      {
        uint64_t v27 = 0;
        goto LABEL_64;
      }
      int v38 = *__error();
      uint64_t v48 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
LABEL_63:
        *__error() = v38;
        uint64_t v27 = 0xFFFFFFFFLL;
        goto LABEL_64;
      }
      *(_DWORD *)statfs buf = 136315650;
      unint64_t v74 = "index_verify";
      __int16 v75 = 1024;
      int v76 = 2589;
      __int16 v77 = 2080;
      uint64_t v78 = v6 + 15208;
      uint64_t v49 = "%s:%d: %s error walking directoyr store";
    }
    _os_log_error_impl(&dword_1BD672000, v48, OS_LOG_TYPE_ERROR, v49, buf, 0x1Cu);
    goto LABEL_63;
  }
  uint64_t v27 = 0;
  int v28 = v59;
LABEL_64:
  uint64_t v50 = *(void *)&threadData[18 * v69 + 2];
  unsigned int v51 = v68;
  uint64_t v52 = v50 + 320 * v68;
  *(_DWORD *)(v52 + 312) = v28;
  unsigned int v53 = *(void (**)(void))(v52 + 232);
  if (v53) {
    v53(*(void *)(v50 + 320 * v51 + 288));
  }
  dropThreadId(v69, 0, v7);
  uint64_t v21 = v27;
LABEL_67:
  int v54 = *__error();
  BOOL v55 = _SILogForLogForCategory(10);
  os_log_type_t v56 = 2 * (v14[51] < 4);
  if (os_log_type_enabled(v55, v56))
  {
    *(_DWORD *)statfs buf = 136315394;
    unint64_t v74 = (const char *)(v6 + 15208);
    __int16 v75 = 1024;
    int v76 = v21;
    _os_log_impl(&dword_1BD672000, v55, v56, "Validate %s complete %d", buf, 0x12u);
  }
  *__error() = v54;
  return v21;
}

BOOL __index_verify_block_invoke(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = a2 - 1;
  if (a2 >= 1 && gSILogLevels[0] >= 5)
  {
    int v10 = *__error();
    uint64_t v11 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a3 + 8 * v5);
      int v13 = 134218496;
      uint64_t v14 = v12;
      __int16 v15 = 1024;
      int v16 = a2;
      __int16 v17 = 2048;
      uint64_t v18 = a4;
      _os_log_impl(&dword_1BD672000, v11, OS_LOG_TYPE_DEFAULT, "oid: %lld depth: %d offset: %llu ", (uint8_t *)&v13, 0x1Cu);
    }
    *__error() = v10;
  }
  return **(_DWORD **)(a1 + 32) != 0;
}

_DWORD *verifyTermsCallback(_DWORD *result, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (**(_DWORD **)(a5 + 72)) {
    goto LABEL_21;
  }
  int v6 = (int)result;
  if ((result - 1044) <= 0xFFFFFBEC)
  {
    int v7 = *__error();
    unint64_t v8 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v25 = 136315650;
      char v26 = "verifyTermsCallback";
      __int16 v27 = 1024;
      int v28 = 2467;
      __int16 v29 = 1024;
      *(_DWORD *)uint64_t v30 = v6;
      unsigned int v9 = "%s:%d: invalid term length: %d";
      int v10 = v8;
      uint32_t v11 = 24;
LABEL_26:
      _os_log_error_impl(&dword_1BD672000, v10, OS_LOG_TYPE_ERROR, v9, (uint8_t *)&v25, v11);
      goto LABEL_20;
    }
    goto LABEL_20;
  }
  unint64_t v12 = a3;
  if (*(_DWORD *)(a5 + 64))
  {
    unsigned int v14 = *(_DWORD *)a5 + 1;
    if (*(_DWORD *)a5 == -1)
    {
LABEL_19:
      int v7 = *__error();
      int v16 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        int v19 = *(_DWORD *)(a5 + 24);
        int v25 = 136315906;
        char v26 = "verifyTermsCallback";
        __int16 v27 = 1024;
        int v28 = 2496;
        __int16 v29 = 1024;
        *(_DWORD *)uint64_t v30 = v14;
        *(_WORD *)&uint8_t v30[4] = 1024;
        *(_DWORD *)&v30[6] = v19;
        unsigned int v9 = "%s:%d: invalid termID: %d, max: %d";
        int v10 = v16;
        uint32_t v11 = 30;
        goto LABEL_26;
      }
LABEL_20:
      uint64_t result = __error();
      *uint64_t result = v7;
LABEL_21:
      *(_DWORD *)(a5 + 68) = 1;
      return result;
    }
  }
  else
  {
    unint64_t v15 = *(void *)storageResolvePtr(*(void *)(a5 + 48), 8 * a3, 8, 1);
    uint64_t result = (_DWORD *)storageResolvePtr(*(void *)(a5 + 56), 8 * v12, 8, 1);
    a4 = *(void *)result;
    unsigned int v14 = v12;
    unint64_t v12 = v15;
    if (!v14) {
      goto LABEL_19;
    }
  }
  if (v14 >= *(_DWORD *)(a5 + 24)) {
    goto LABEL_19;
  }
  if (!v12 || v12 >= *(void *)(a5 + 32))
  {
    int v17 = *__error();
    uint64_t v18 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      uint64_t v24 = *(void *)(a5 + 32);
      int v25 = 136315906;
      char v26 = "verifyTermsCallback";
      __int16 v27 = 1024;
      int v28 = 2501;
      __int16 v29 = 2048;
      *(void *)uint64_t v30 = v12;
      *(_WORD *)&v30[8] = 2048;
      uint64_t v31 = v24;
      int v22 = "%s:%d: invalid posting offset: %lld, max: %lld";
      unint64_t v23 = v18;
      goto LABEL_30;
    }
LABEL_24:
    uint64_t result = __error();
    *uint64_t result = v17;
    goto LABEL_21;
  }
  if (v12 > *(void *)(a5 + 8)) {
    *(void *)(a5 + 8) = v12;
  }
  if (a4 && a4 >= *(void *)(a5 + 40))
  {
    int v17 = *__error();
    unsigned int v20 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      uint64_t v21 = *(void *)(a5 + 40);
      int v25 = 136315906;
      char v26 = "verifyTermsCallback";
      __int16 v27 = 1024;
      int v28 = 2511;
      __int16 v29 = 2048;
      *(void *)uint64_t v30 = a4;
      *(_WORD *)&v30[8] = 2048;
      uint64_t v31 = v21;
      int v22 = "%s:%d: invalid position offset: %lld, max: %lld";
      unint64_t v23 = v20;
LABEL_30:
      _os_log_error_impl(&dword_1BD672000, v23, OS_LOG_TYPE_ERROR, v22, (uint8_t *)&v25, 0x26u);
      goto LABEL_24;
    }
    goto LABEL_24;
  }
  if (a4 > *(void *)(a5 + 16)) {
    *(void *)(a5 + 16) = a4;
  }
  ++*(_DWORD *)a5;
  return result;
}

uint64_t indexPerformSync(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  int v3 = v2;
  uint64_t v4 = v1;
  v29[512] = *MEMORY[0x1E4F143B8];
  unsigned int v5 = (unsigned char *)(v1 + 15203);
  uint64_t v6 = *(void *)(v1 + 4928);
  if (v6) {
    flushForwardStore(v6, *(void *)(v4 + 15576));
  }
  uint64_t v7 = *(void *)(v4 + 4912);
  if (v7) {
    IVFVectorIndex_s::flush((void *)(v7 + 8), *(void *)(v4 + 15576));
  }
  if (*v5) {
    return 0;
  }
  unint64_t v8 = *(void **)(v4 + 14432);
  unsigned int v9 = *(_DWORD *)(v4 + 68);
  if (*(unsigned char *)(v4 + 45)) {
    size_t v10 = v9;
  }
  else {
    size_t v10 = (4 * v9 + 4) / 5;
  }
  if (_gSystemStatusBool)
  {
    pthread_mutex_lock(&_gSystemStatusLock);
    while (_gSystemStatusBool)
      pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
    pthread_mutex_unlock(&_gSystemStatusLock);
  }
  msync(v8, v10, 16);
  uint32_t v11 = *(_DWORD **)(v4 + 14472);
  if (_gSystemStatusBool)
  {
    pthread_mutex_lock(&_gSystemStatusLock);
    while (_gSystemStatusBool)
      pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
    pthread_mutex_unlock(&_gSystemStatusLock);
  }
  v29[0] = 0;
  uint64_t v12 = _fd_acquire_fd((uint64_t)v11, v29);
  if (v12 != -1)
  {
    int v13 = v12;
    prot_fsync(v12, 0);
    _fd_release_fd(v11, v13, 0, v29[0]);
  }
  char v14 = atomic_load((unsigned int *)(v4 + 36));
  if ((v14 & 2) != 0) {
    return 0;
  }
  uint64_t result = syncPayload(v4 + 4944);
  if (!result)
  {
    uint64_t result = syncPayload(v4 + 9664);
    if (!result)
    {
      uint64_t result = bt_syncTrie(v4 + 96);
      if (!result)
      {
        int v16 = *(void **)(v4 + 14408);
        size_t v17 = 8 * *(unsigned int *)(v4 + 68);
        fd_system_status_stall_if_busy();
        int v18 = msync(v16, v17, 16);
        int v19 = *(void **)(v4 + 14416);
        size_t v20 = 4 * *(unsigned int *)(v4 + 68);
        fd_system_status_stall_if_busy();
        int v21 = msync(v19, v20, 16);
        if (v21) {
          unsigned int v22 = v21;
        }
        else {
          unsigned int v22 = v18;
        }
        unint64_t v23 = *(void **)(v4 + 14424);
        if (v23)
        {
          size_t v24 = 8 * *(unsigned int *)(v4 + 68);
          fd_system_status_stall_if_busy();
          int v25 = msync(v23, v24, 16);
          if (v25) {
            unsigned int v22 = v25;
          }
        }
        if (v5[2])
        {
          if (fd_sync(*(void *)(v4 + 14456), 0)) {
            unsigned int v22 = *__error();
          }
          uint64_t v26 = *(void *)(v4 + 14464);
          if (v26 && fd_sync(v26, 0)) {
            unsigned int v22 = *__error();
          }
          if (fd_sync(*(void *)(v4 + 14448), 0)) {
            unsigned int v22 = *__error();
          }
          v5[2] = 0;
        }
        if (v3)
        {
          int v27 = *(_DWORD *)(v4 + 68);
          if (v27)
          {
            *(void *)(v4 + 4960) = *(void *)(v4 + 4952);
            *(void *)(v4 + 9680) = *(void *)(v4 + 9672);
            *(_DWORD *)(v4 + 60) = v27 - 1;
          }
        }
        bzero(v29, 0x1000uLL);
        int v28 = v29;
        indexStoreToBuffer(v4, (void **)&v28);
        LODWORD(result) = index_header_write(*(void *)(v4 + 14480), (uint64_t)v29);
        if (result) {
          return result;
        }
        else {
          return v22;
        }
      }
    }
  }
  return result;
}

uint64_t index_header_write(uint64_t result, uint64_t a2)
{
  if (!result) {
    return result;
  }
  uint64_t v2 = result;
  uint64_t v3 = fd_pwrite(result, a2, 0x1000uLL, 0);
  if (v3 != 4096)
  {
    if (v3 == -1) {
      return *__error();
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  if (*(_WORD *)(v2 + 56))
  {
    if (_gSystemStatusBool)
    {
      pthread_mutex_lock(&_gSystemStatusLock);
      while (_gSystemStatusBool)
        pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
      goto LABEL_14;
    }
  }
  else if (_gSystemStatusBool)
  {
    pthread_mutex_lock(&_gSystemStatusLock);
    while (_gSystemStatusBool)
      pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
LABEL_14:
    pthread_mutex_unlock(&_gSystemStatusLock);
  }
  uint64_t v6 = 0;
  uint64_t v4 = _fd_acquire_fd(v2, &v6);
  if (v4 != -1)
  {
    int v5 = v4;
    prot_fsync(v4, 0);
    _fd_release_fd((_DWORD *)v2, v5, 0, v6);
  }
  return 0;
}

uint64_t recoverIndex(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  unsigned int v3 = v2;
  unsigned int v5 = v4;
  int v7 = v6;
  int v9 = v8;
  uint32_t v11 = v10;
  int v13 = v12;
  uint64_t v14 = v1;
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  bzero(v89, 0x400uLL);
  bzero(v88, 0x400uLL);
  memset(&v66, 0, sizeof(v66));
  int v15 = *__error();
  int v16 = _SILogForLogForCategory(0);
  os_log_type_t v17 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v16, v17))
  {
    *(_DWORD *)statfs buf = 136315138;
    uint64_t v81 = v13;
    _os_log_impl(&dword_1BD672000, v16, v17, "recoverIndex: %s", buf, 0xCu);
  }
  *__error() = v15;
  bzero(v87, 0x1000uLL);
  long long v65 = v87;
  snprintf(v89, 0x400uLL, "%s%s", v13, "indexPostings");
  if (stat(v89, &v66))
  {
    int v18 = *__error();
    int v19 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)statfs buf = 136315650;
      uint64_t v81 = "recoverIndex";
      __int16 v82 = 1024;
      int v83 = 3554;
      __int16 v84 = 2080;
      __int16 v85 = v13;
      size_t v20 = "%s:%d: Unrecoverable error: Missing postings file (%s)";
LABEL_33:
      _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, v20, buf, 0x1Cu);
      goto LABEL_8;
    }
    goto LABEL_8;
  }
  snprintf(v89, 0x400uLL, "%s%s", v13, "indexPositions");
  if (stat(v89, &v66))
  {
    int v18 = *__error();
    int v19 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)statfs buf = 136315650;
      uint64_t v81 = "recoverIndex";
      __int16 v82 = 1024;
      int v83 = 3561;
      __int16 v84 = 2080;
      __int16 v85 = v13;
      size_t v20 = "%s:%d: Unrecoverable error: Missing positions file (%s)";
      goto LABEL_33;
    }
LABEL_8:
    int v21 = 0;
LABEL_9:
    unsigned int v22 = __error();
    unint64_t v23 = 0;
LABEL_10:
    *unsigned int v22 = v18;
    goto LABEL_11;
  }
  snprintf(v88, 0x400uLL, "%s%s", v13, "shadowIndexHead");
  __int16 v29 = (atomic_uint *)fd_create_protected(v14, v88, 536870914, 3u);
  if (!v29)
  {
    int v18 = *__error();
    uint64_t v34 = _SILogForLogForCategory(0);
    os_log_type_t v35 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v34, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      int v36 = *__error();
      *(_DWORD *)statfs buf = 136315394;
      uint64_t v81 = v13;
      __int16 v82 = 1024;
      int v83 = v36;
      _os_log_impl(&dword_1BD672000, v34, v35, "*warn* Unrecoverable error: Missing shadow head file (%s) %d", buf, 0x12u);
    }
    goto LABEL_8;
  }
  int v21 = v29;
  uint64_t v30 = fd_pread(v29, v87, 0x1000uLL, 0);
  if (v30 != 4096)
  {
    int v37 = v30;
    int v18 = *__error();
    int v38 = _SILogForLogForCategory(0);
    os_log_type_t v39 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v38, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      int v40 = *__error();
      *(_DWORD *)statfs buf = 136315650;
      uint64_t v81 = v13;
      __int16 v82 = 1024;
      int v83 = v37;
      __int16 v84 = 1024;
      LODWORD(v85) = v40;
      _os_log_impl(&dword_1BD672000, v38, v39, "*warn* Unrecoverable error: Missing data in index head file (%s) %d %d", buf, 0x18u);
    }
    goto LABEL_9;
  }
  fd_release(v21);
  bzero(buf, 0x3D68uLL);
  if ((indexRestoreHeaderFromBuffer(buf, &v65, v7, v5, v3, 0) & 1) == 0)
  {
    int v41 = *__error();
    uint64_t v42 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    *(_DWORD *)std::string __str = 136315650;
    unsigned int v71 = "recoverIndex";
    __int16 v72 = 1024;
    int v73 = 3584;
    __int16 v74 = 2080;
    __int16 v75 = v13;
    uint64_t v48 = "%s:%d: Unrecoverable error: Malformed index head file (%s)";
LABEL_73:
    int v59 = v42;
    uint32_t v60 = 28;
LABEL_74:
    _os_log_error_impl(&dword_1BD672000, v59, OS_LOG_TYPE_ERROR, v48, (uint8_t *)__str, v60);
    goto LABEL_31;
  }
  char v31 = atomic_load(v86);
  if ((v31 & 2) != 0)
  {
    long long v65 = v87;
    goto LABEL_35;
  }
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s%s", v13, "indexDirectory");
  if (fstatat(v14, __str, &v66, 0) || v66.st_mode != 256)
  {
    long long v65 = v87;
    snprintf(v89, 0x400uLL, "%s%s", v13, "indexUpdates");
    unlinkat(v14, v89, 0);
    uint64_t v49 = (atomic_uint *)fd_create_protected(v14, v89, 536872450, 3u);
    *(void *)unint64_t v67 = 0;
    int v50 = _fd_acquire_fd((uint64_t)v49, v67);
    _fd_release_fd(v49, v50, 0, *(uint64_t *)v67);
    fd_release(v49);
    if (v50 == -1)
    {
      int v51 = *__error();
      uint64_t v52 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string __str = 136315650;
        unsigned int v71 = "recoverIndex";
        __int16 v72 = 1024;
        int v73 = 3616;
        __int16 v74 = 2080;
        __int16 v75 = v13;
        unsigned int v53 = "%s:%d: Unrecoverable error: could not open update file (%s)";
        goto LABEL_78;
      }
    }
    else
    {
      snprintf(v89, 0x400uLL, "%s%s", v13, "indexTermIds");
      snprintf(v88, 0x400uLL, "%s%s", v13, "shadowIndexTermIds");
      if (copyFileFallback(v14, v88, v14, v89, v11, 1, 1))
      {
        snprintf(v89, 0x400uLL, "%s%s", v13, "indexPositionTable");
        snprintf(v88, 0x400uLL, "%s%s", v13, "shadowIndexPositionTable");
        if (copyFileFallback(v14, v88, v14, v89, v11, 1, 1))
        {
          if (bt_recoverTrie(v14, v13, v11)) {
            goto LABEL_35;
          }
          if (*v11) {
            goto LABEL_80;
          }
          int v51 = *__error();
          uint64_t v52 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string __str = 136315650;
            unsigned int v71 = "recoverIndex";
            __int16 v72 = 1024;
            int v73 = 3637;
            __int16 v74 = 2080;
            __int16 v75 = v13;
            unsigned int v53 = "%s:%d: Unrecoverable error: could not recover term index (%s)";
LABEL_78:
            _os_log_error_impl(&dword_1BD672000, v52, OS_LOG_TYPE_ERROR, v53, (uint8_t *)__str, 0x1Cu);
          }
        }
        else
        {
          if (*v11) {
            goto LABEL_80;
          }
          int v51 = *__error();
          uint64_t v52 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string __str = 136315650;
            unsigned int v71 = "recoverIndex";
            __int16 v72 = 1024;
            int v73 = 3631;
            __int16 v74 = 2080;
            __int16 v75 = v13;
            unsigned int v53 = "%s:%d: Unrecoverable error: could not recover term id file (positions) (%s)";
            goto LABEL_78;
          }
        }
      }
      else
      {
        if (*v11) {
          goto LABEL_80;
        }
        int v51 = *__error();
        uint64_t v52 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string __str = 136315650;
          unsigned int v71 = "recoverIndex";
          __int16 v72 = 1024;
          int v73 = 3623;
          __int16 v74 = 2080;
          __int16 v75 = v13;
          unsigned int v53 = "%s:%d: Unrecoverable error: could not recover term id file (%s)";
          goto LABEL_78;
        }
      }
    }
    *__error() = v51;
    goto LABEL_80;
  }
  atomic_fetch_or((atomic_uint *volatile)v86, 2u);
  int v32 = *__error();
  uint64_t v33 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)unint64_t v67 = 136315394;
    *(void *)&v67[4] = v13;
    __int16 v68 = 1024;
    unsigned int v69 = v86[5];
    _os_log_impl(&dword_1BD672000, v33, OS_LOG_TYPE_DEFAULT, "mark index %s (%u) read-only during recover", v67, 0x12u);
  }
  *__error() = v32;
  long long v65 = v87;
LABEL_35:
  if (v9 && (recoverForwardStore(v14, v13, v11) & 1) == 0)
  {
    if (!*v11)
    {
      int v41 = *__error();
      uint64_t v42 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        goto LABEL_31;
      }
      *(_DWORD *)std::string __str = 136315650;
      unsigned int v71 = "recoverIndex";
      __int16 v72 = 1024;
      int v73 = 3644;
      __int16 v74 = 2080;
      __int16 v75 = v13;
      uint64_t v48 = "%s:%d: Unrecoverable error: could not recover path index (%s)";
      goto LABEL_73;
    }
  }
  else
  {
    if (_os_feature_enabled_impl() && !recoverVectorIndex(v14, v13, (uint64_t)v11) && !*v11)
    {
      int v43 = *__error();
      uint64_t v44 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string __str = 136315650;
        unsigned int v71 = "recoverIndex";
        __int16 v72 = 1024;
        int v73 = 3652;
        __int16 v74 = 2080;
        __int16 v75 = v13;
        _os_log_error_impl(&dword_1BD672000, v44, OS_LOG_TYPE_ERROR, "%s:%d: error: could not recover vector index (%s)", (uint8_t *)__str, 0x1Cu);
      }
      *__error() = v43;
    }
    snprintf(v89, 0x400uLL, "%s%s", v13, "indexGroups");
    snprintf(v88, 0x400uLL, "%s%s", v13, "shadowIndexGroups");
    if (copyFileFallback(v14, v88, v14, v89, v11, 1, 1))
    {
      snprintf(v89, 0x400uLL, "%s%s", v13, "indexHead");
      snprintf(v88, 0x400uLL, "%s%s", v13, "shadowIndexHead");
      uint64_t v45 = (atomic_uint *)fd_create_protected(v14, v88, 536870914, 0);
      if (v45)
      {
        int v21 = v45;
        uint64_t v46 = fd_pread(v45, v87, 0x1000uLL, 0);
        if (v46 != 4096)
        {
          int v56 = v46;
          int v57 = *__error();
          int v58 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
          {
            int v63 = *__error();
            *(_DWORD *)std::string __str = 136316162;
            unsigned int v71 = "recoverIndex";
            __int16 v72 = 1024;
            int v73 = 3677;
            __int16 v74 = 2080;
            __int16 v75 = v13;
            __int16 v76 = 1024;
            int v77 = v56;
            __int16 v78 = 1024;
            int v79 = v63;
            _os_log_error_impl(&dword_1BD672000, v58, OS_LOG_TYPE_ERROR, "%s:%d: Unrecoverable error: could not read shadow head file (%s) %d, %d", (uint8_t *)__str, 0x28u);
          }
          unint64_t v23 = 0;
          *__error() = v57;
          goto LABEL_11;
        }
        fd_release(v21);
        v87[0] = v7;
        v87[1] = 1;
        uint64_t v47 = (atomic_uint *)fd_create_protected(v14, v89, 536872450, 0);
        if (v47)
        {
          unint64_t v23 = v47;
          if (fd_pwrite((uint64_t)v47, (uint64_t)v87, 0x1000uLL, 0) != -1)
          {
            uint64_t v27 = 1;
            fd_sync((uint64_t)v23, 1);
            int v21 = 0;
            goto LABEL_16;
          }
          int v18 = *__error();
          long long v62 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
          {
            int v64 = *__error();
            *(_DWORD *)std::string __str = 136315906;
            unsigned int v71 = "recoverIndex";
            __int16 v72 = 1024;
            int v73 = 3692;
            __int16 v74 = 2080;
            __int16 v75 = v13;
            __int16 v76 = 1024;
            int v77 = v64;
            _os_log_error_impl(&dword_1BD672000, v62, OS_LOG_TYPE_ERROR, "%s:%d: Unrecoverable error: could not write index head file (%s) %d", (uint8_t *)__str, 0x22u);
          }
          unsigned int v22 = __error();
          int v21 = 0;
          goto LABEL_10;
        }
        int v41 = *__error();
        int v54 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
          goto LABEL_31;
        }
        int v61 = *__error();
        *(_DWORD *)std::string __str = 136315906;
        unsigned int v71 = "recoverIndex";
        __int16 v72 = 1024;
        int v73 = 3688;
        __int16 v74 = 2080;
        __int16 v75 = v13;
        __int16 v76 = 1024;
        int v77 = v61;
        uint64_t v48 = "%s:%d: Unrecoverable error: could not open index head file (%s) %d";
        goto LABEL_83;
      }
      int v41 = *__error();
      int v54 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        int v55 = *__error();
        *(_DWORD *)std::string __str = 136315906;
        unsigned int v71 = "recoverIndex";
        __int16 v72 = 1024;
        int v73 = 3671;
        __int16 v74 = 2080;
        __int16 v75 = v13;
        __int16 v76 = 1024;
        int v77 = v55;
        uint64_t v48 = "%s:%d: Unrecoverable error: could not open shadow head file (%s) %d";
LABEL_83:
        int v59 = v54;
        uint32_t v60 = 34;
        goto LABEL_74;
      }
LABEL_31:
      unint64_t v23 = 0;
      int v21 = 0;
      *__error() = v41;
      goto LABEL_11;
    }
    if (!*v11)
    {
      int v41 = *__error();
      uint64_t v42 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        goto LABEL_31;
      }
      *(_DWORD *)std::string __str = 136315650;
      unsigned int v71 = "recoverIndex";
      __int16 v72 = 1024;
      int v73 = 3661;
      __int16 v74 = 2080;
      __int16 v75 = v13;
      uint64_t v48 = "%s:%d: Unrecoverable error: could not recover groups file (%s)";
      goto LABEL_73;
    }
  }
LABEL_80:
  unint64_t v23 = 0;
  int v21 = 0;
LABEL_11:
  if (*v11)
  {
    int v24 = *__error();
    int v25 = _SILogForLogForCategory(0);
    os_log_type_t v26 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v25, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      *(_DWORD *)statfs buf = 136315138;
      uint64_t v81 = v13;
      _os_log_impl(&dword_1BD672000, v25, v26, "*warn* recover canceled (%s)", buf, 0xCu);
    }
    uint64_t v27 = 0;
    *__error() = v24;
  }
  else
  {
    uint64_t v27 = 0;
  }
LABEL_16:
  fd_release(v21);
  fd_release(v23);
  return v27;
}

BOOL indexClosing(uint64_t a1)
{
  unsigned int v1 = atomic_fetch_or((atomic_uint *volatile)(a1 + 15192), 1u);
  if (!v1)
  {
    *(CFAbsoluteTime *)(a1 + 15048) = CFAbsoluteTimeGetCurrent();
    if (gSILogLevels[0] >= 5)
    {
      int v3 = *__error();
      unsigned int v4 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)unsigned int v5 = 0;
        _os_log_impl(&dword_1BD672000, v4, OS_LOG_TYPE_DEFAULT, "close requested\n", v5, 2u);
      }
      *__error() = v3;
    }
  }
  return v1 != 0;
}

uint64_t indexGrowDocumentPayloads(uint64_t a1, uint64_t (*a2)(uint64_t), uint64_t a3)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 8)) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v40 = 0;
  unint64_t v6 = *(unsigned int *)(a1 + 72);
  int v7 = (void **)(a1 + 14408);
  if (expandUnsafeMapNew((void **)(a1 + 14408), *(void *)(a1 + 14448), v6, 8uLL, &v40, a2, a3))
  {
    uint64_t v8 = *__error();
    int v9 = *__error();
    size_t v10 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)statfs buf = 136315906;
      uint64_t v42 = "indexGrowDocumentPayloads";
      __int16 v43 = 1024;
      int v44 = 4804;
      __int16 v45 = 2080;
      uint64_t v46 = a1 + 15208;
      __int16 v47 = 1024;
      int v48 = 4804;
      _os_log_error_impl(&dword_1BD672000, v10, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", buf, 0x22u);
    }
    *__error() = v9;
    if (*(unsigned char *)(a1 + 8))
    {
      *(unsigned char *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = v8;
    }
  }
  else
  {
    *(unsigned char *)(a1 + 15205) = 1;
    uint64_t v38 = a3;
    os_log_type_t v39 = (void **)(a1 + 14432);
    uint32_t v11 = *(void **)(a1 + 14432);
    uint64_t v37 = 4 * v6;
    uint64_t v12 = 4 * v6 + 4;
    size_t v13 = ((unint64_t)v12 * (unsigned __int128)0x3333333333333334uLL) >> 64;
    if (*(unsigned char *)(a1 + 45)) {
      size_t v14 = v6;
    }
    else {
      size_t v14 = ((unint64_t)v12 * (unsigned __int128)0x3333333333333334uLL) >> 64;
    }
    if (_gSystemStatusBool)
    {
      pthread_mutex_lock(&_gSystemStatusLock);
      while (_gSystemStatusBool)
        pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
      pthread_mutex_unlock(&_gSystemStatusLock);
    }
    msync(v11, v14, 16);
    if (*(unsigned char *)(a1 + 45)) {
      size_t v15 = v6;
    }
    else {
      size_t v15 = v13;
    }
    munmap(*(void **)(a1 + 14432), v15);
    *(void *)(a1 + 14432) = -1;
    unint64_t v16 = v40;
    size_t v17 = v40;
    if (!*(unsigned char *)(a1 + 45)) {
      size_t v17 = (4 * v40 + 4) / 5;
    }
    if (expandMap(*(void *)(a1 + 14472), v17, v39, a2, a3))
    {
      uint64_t v8 = *__error();
      int v18 = *__error();
      int v19 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)statfs buf = 136315906;
        uint64_t v42 = "indexGrowDocumentPayloads";
        __int16 v43 = 1024;
        int v44 = 4793;
        __int16 v45 = 2080;
        uint64_t v46 = a1 + 15208;
        __int16 v47 = 1024;
        int v48 = 4793;
        _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", buf, 0x22u);
      }
      *__error() = v18;
      if (*(unsigned char *)(a1 + 8))
      {
        *(unsigned char *)(a1 + 8) = 0;
        *(_DWORD *)(a1 + 12) = v8;
      }
      munmap(*v7, 8 * v16);
      *int v7 = (void *)-1;
    }
    else
    {
      size_t v20 = *(void **)(a1 + 14440);
      if (v20)
      {
        int v21 = (void *)MEMORY[0x1E4F14B00];
        if (*(unsigned char *)(a1 + 45)) {
          unint64_t v22 = v16 + 3;
        }
        else {
          unint64_t v22 = ((v16 + 4) * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64;
        }
        unint64_t v23 = (char *)malloc_type_realloc(v20, (8 * *MEMORY[0x1E4F14B00] - 1 + (v22 >> 2)) / (8 * *MEMORY[0x1E4F14B00]), 0x5F6BB211uLL);
        *(void *)(a1 + 14440) = v23;
        if (*(unsigned char *)(a1 + 45))
        {
          uint64_t v25 = (v6 + 3) >> 2;
          unint64_t v26 = v16 + 3;
        }
        else
        {
          uint64_t v25 = ((v6 + 4) * (unsigned __int128)0x3333333333333334uLL) >> 64;
          unint64_t v26 = ((v16 + 4) * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64;
        }
        unint64_t v24 = 8 * *v21;
        bzero(&v23[(v25 + v24 - 1) / v24], (v24 + (v26 >> 2) - 1) / v24 - (v25 + v24 - 1) / v24);
      }
      uint64_t v27 = *(void **)(a1 + 14416);
      if (_gSystemStatusBool)
      {
        pthread_mutex_lock(&_gSystemStatusLock);
        while (_gSystemStatusBool)
          pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
        pthread_mutex_unlock(&_gSystemStatusLock);
      }
      msync(v27, v37, 16);
      munmap(*(void **)(a1 + 14416), v37);
      *(void *)(a1 + 14416) = -1;
      if (expandMap(*(void *)(a1 + 14456), 4 * v16, (void **)(a1 + 14416), a2, v38))
      {
        uint64_t v8 = *__error();
        int v28 = *__error();
        __int16 v29 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)statfs buf = 136315906;
          uint64_t v42 = "indexGrowDocumentPayloads";
          __int16 v43 = 1024;
          int v44 = 4777;
          __int16 v45 = 2080;
          uint64_t v46 = a1 + 15208;
          __int16 v47 = 1024;
          int v48 = 4777;
          _os_log_error_impl(&dword_1BD672000, v29, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", buf, 0x22u);
        }
        *__error() = v28;
        if (*(unsigned char *)(a1 + 8))
        {
          *(unsigned char *)(a1 + 8) = 0;
          *(_DWORD *)(a1 + 12) = v8;
        }
        munmap(*(void **)(a1 + 14408), 8 * v16);
        *(void *)(a1 + 14408) = -1;
        munmap(*(void **)(a1 + 14416), 4 * v16);
        *(void *)(a1 + 14416) = -1;
      }
      else
      {
        if (!*(void *)(a1 + 14464)) {
          goto LABEL_60;
        }
        char v31 = *(void **)(a1 + 14424);
        size_t v32 = 8 * v6;
        if (_gSystemStatusBool)
        {
          pthread_mutex_lock(&_gSystemStatusLock);
          while (_gSystemStatusBool)
            pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
          pthread_mutex_unlock(&_gSystemStatusLock);
        }
        msync(v31, v32, 16);
        munmap(*(void **)(a1 + 14424), v32);
        *(void *)(a1 + 14424) = -1;
        uint64_t v33 = *(void *)(a1 + 14464);
        if (!v33 || !expandMap(v33, 8 * v16, (void **)(a1 + 14424), a2, v38))
        {
LABEL_60:
          uint64_t v8 = 0;
          *(_DWORD *)(a1 + 72) = v16;
          return v8;
        }
        uint64_t v8 = *__error();
        int v34 = *__error();
        os_log_type_t v35 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)statfs buf = 136315906;
          uint64_t v42 = "indexGrowDocumentPayloads";
          __int16 v43 = 1024;
          int v44 = 4760;
          __int16 v45 = 2080;
          uint64_t v46 = a1 + 15208;
          __int16 v47 = 1024;
          int v48 = 4760;
          _os_log_error_impl(&dword_1BD672000, v35, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", buf, 0x22u);
        }
        *__error() = v34;
        if (*(unsigned char *)(a1 + 8))
        {
          *(unsigned char *)(a1 + 8) = 0;
          *(_DWORD *)(a1 + 12) = v8;
        }
        munmap(*(void **)(a1 + 14408), 8 * v16);
        *(void *)(a1 + 14408) = -1;
        munmap(*(void **)(a1 + 14416), 4 * v16);
        *(void *)(a1 + 14416) = -1;
        munmap(*(void **)(a1 + 14424), 8 * v16);
        *(void *)(a1 + 14424) = -1;
      }
      if (*(unsigned char *)(a1 + 45)) {
        size_t v30 = v16;
      }
      else {
        size_t v30 = (4 * v16 + 4) / 5;
      }
      munmap(*(void **)(a1 + 14432), v30);
      NSObject *v39 = (void *)-1;
    }
  }
  return v8;
}

void attributeMergeInfoWildcardApplier(unint64_t key, const void *a2, uint64_t a3)
{
  if ((key & 0x80000000) == 0 && !CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 8), (const void *)key))
  {
    CFSetRef Mutable = *(__CFDictionary **)(a3 + 16);
    if (!Mutable)
    {
      CFSetRef Mutable = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E4F1D540]);
      *(void *)(a3 + 16) = Mutable;
    }
    CFDictionarySetValue(Mutable, (const void *)(key | 0x40000000), a2);
  }
}

void attributeMergeInfoRemoveApplier(void *key, void *value, uint64_t a3)
{
  CFDictionaryRef v6 = *(const __CFDictionary **)(a3 + 8);
  if (!v6 || !CFDictionaryGetValue(v6, key))
  {
    CFSetRef Mutable = *(__CFDictionary **)(a3 + 16);
    if (!Mutable)
    {
      CFSetRef Mutable = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E4F1D540]);
      *(void *)(a3 + 16) = Mutable;
    }
    CFDictionarySetValue(Mutable, key, value);
  }
}

void attributeMergeInfoApplier(void *key, const void *a2, CFDictionaryRef *a3)
{
  CFArrayRef Value = CFDictionaryGetValue(*a3, key);
  CFTypeID v7 = CFGetTypeID(a2);
  if (v7 == CFNullGetTypeID())
  {
    if (!Value) {
      return;
    }
    CFSetRef Mutable = a3[2];
    if (!Mutable)
    {
      CFSetRef Mutable = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E4F1D540]);
      a3[2] = Mutable;
    }
    int v9 = key;
    size_t v10 = Value;
    goto LABEL_12;
  }
  if (!Value)
  {
    CFSetRef Mutable = a3[3];
    if (!Mutable)
    {
      CFSetRef Mutable = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E4F1D540]);
      a3[3] = Mutable;
    }
    int v9 = key;
    size_t v10 = a2;
LABEL_12:
    CFDictionarySetValue(Mutable, v9, v10);
    uint32_t v11 = a3[4];
    updateChangedAttributes(v11, (int)key, a2);
    return;
  }
  if (!CFEqual(a2, Value))
  {
    updateChangedAttributes(a3[4], (int)key, a2);
    uint64_t v12 = a3[3];
    if (!v12)
    {
      uint64_t v12 = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E4F1D540]);
      a3[3] = v12;
    }
    CFDictionarySetValue(v12, key, a2);
    size_t v13 = a3[2];
    if (!v13)
    {
      size_t v13 = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E4F1D540]);
      a3[2] = v13;
    }
    CFDictionarySetValue(v13, key, Value);
  }
}

void updateChangedAttributes(__CFSet *a1, int a2, const void *a3)
{
  if (a1)
  {
    CFSetAddValue(a1, (const void *)(a2 & 0x3FFFFFF));
    if (updateChangedAttributes_onceToken == -1)
    {
      if (a2 < 0) {
        return;
      }
    }
    else
    {
      dispatch_once(&updateChangedAttributes_onceToken, &__block_literal_global_132);
      if (a2 < 0) {
        return;
      }
    }
    CFTypeID v6 = CFGetTypeID(a3);
    if (v6 == updateChangedAttributes_arrayType && CFArrayGetCount((CFArrayRef)a3))
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a3, 0);
      CFTypeID v6 = CFGetTypeID(ValueAtIndex);
    }
    if (v6 != updateChangedAttributes_dateType)
    {
      CFSetAddValue(a1, (const void *)0x40000000);
    }
  }
}

CFTypeID __updateChangedAttributes_block_invoke()
{
  updateChangedAttributes_dateType = CFDateGetTypeID();
  CFTypeID result = CFArrayGetTypeID();
  updateChangedAttributes_arrayType = result;
  return result;
}

uint64_t cleanUpTermUpdateMergeContext(pthread_mutex_t **a1)
{
  unsigned int v2 = *a1;
  uint64_t v1 = (uint64_t)a1[1];
  int v3 = *a1 + 230;
  pthread_mutex_lock(v3);
  *(_DWORD *)&v2[233].__opaque[4] = 0;
  unsigned int v4 = *(pthread_override_s **)&v2[232].__opaque[40];
  *(void *)&v2[232].__opaque[48] = 0;
  *(void *)&v2[232].__opaque[40] = 0;
  char v5 = HIDWORD(v2[233].__sig) != 0;
  v3[3].__opaque[12] = 0;
  db_rwlock_wakeup((uint64_t)v3, v5, 0);
  pthread_mutex_unlock(v3);
  if (v4) {
    pthread_override_qos_class_end_np(v4);
  }
  dispatch_release(*(dispatch_object_t *)(*(void *)&v2[245].__opaque[16] + 40));
  CFTypeID v6 = *(void **)&v2[245].__opaque[16];
  *(void *)&v2[245].__opaque[16] = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)v2[245].__opaque);
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)&v2[245].__opaque[8]);
  free(v6);
  TermUpdateSetRelease(v1);
  return 0;
}

void mergeAttributesForNewEntryApplier(void *key, const void *a2, CFDictionaryRef *a3)
{
  CFArrayRef Value = CFDictionaryGetValue(*a3, key);
  if (!Value || Value != a2 && !CFEqual(Value, a2)) {
    CFSetSetValue(a3[1], (const void *)(key & 0x3FFFFFF));
  }
  CFTypeID v7 = CFGetTypeID(a2);
  CFTypeID TypeID = CFNullGetTypeID();
  int v9 = a3[2];
  if (v7 == TypeID)
  {
    CFDictionaryRemoveValue(v9, key);
  }
  else
  {
    CFDictionarySetValue(v9, key, a2);
  }
}

uint64_t si_rwlock_wrunlock_2795(uint64_t a1)
{
  uint64_t v2 = pthread_mutex_lock((pthread_mutex_t *)a1);
  *(_DWORD *)(a1 + 204) = 0;
  int v3 = *(pthread_override_s **)(a1 + 176);
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  char v4 = *(_DWORD *)(a1 + 196) != 0;
  *(unsigned char *)(a1 + 212) = 0;
  db_rwlock_wakeup(a1, v4, 0);
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v3) {
    pthread_override_qos_class_end_np(v3);
  }
  return v2;
}

void IndexFdInfoDispose(void *a1)
{
  if (a1)
  {
    int v2 = *((_DWORD *)a1 + 2);
    if (v2 != -1) {
      _fd_release_fd(*(_DWORD **)(*(void *)a1 + 14480), v2, 0, *((void *)a1 + 2));
    }
    int v3 = *((_DWORD *)a1 + 6);
    if (v3 != -1) {
      _fd_release_fd(*(_DWORD **)(*(void *)a1 + 472), v3, 0, *((void *)a1 + 4));
    }
    int v4 = *((_DWORD *)a1 + 10);
    if (v4 != -1) {
      _fd_release_fd(*(_DWORD **)(*(void *)a1 + 9432), v4, 0, *((void *)a1 + 6));
    }
    int v5 = *((_DWORD *)a1 + 14);
    if (v5 != -1) {
      _fd_release_fd(*(_DWORD **)(*(void *)a1 + 5200), v5, 0, *((void *)a1 + 8));
    }
    int v6 = *((_DWORD *)a1 + 18);
    if (v6 != -1) {
      _fd_release_fd(*(_DWORD **)(*(void *)a1 + 14152), v6, 0, *((void *)a1 + 10));
    }
    int v7 = *((_DWORD *)a1 + 22);
    if (v7 != -1) {
      _fd_release_fd(*(_DWORD **)(*(void *)a1 + 9920), v7, 0, *((void *)a1 + 12));
    }
    int v8 = *((_DWORD *)a1 + 26);
    if (v8 != -1) {
      _fd_release_fd(*(_DWORD **)(*(void *)a1 + 14472), v8, 0, *((void *)a1 + 14));
    }
    int v9 = *((_DWORD *)a1 + 30);
    if (v9 != -1) {
      _fd_release_fd(*(_DWORD **)(*(void *)a1 + 14448), v9, 0, *((void *)a1 + 16));
    }
    int v10 = *((_DWORD *)a1 + 34);
    if (v10 != -1) {
      _fd_release_fd(*(_DWORD **)(*(void *)a1 + 14456), v10, 0, *((void *)a1 + 18));
    }
    int v11 = *((_DWORD *)a1 + 38);
    if (v11 != -1) {
      _fd_release_fd(*(_DWORD **)(*(void *)a1 + 14464), v11, 0, *((void *)a1 + 20));
    }
    free(a1);
  }
}

_DWORD *IndexFdInfoCreate(uint64_t *a1, int a2)
{
  int v4 = malloc_type_malloc(0xA8uLL, 0x1020040A0A6502FuLL);
  *(void *)int v4 = a1;
  v4[6] = -1;
  v4[10] = -1;
  v4[14] = -1;
  v4[18] = -1;
  v4[22] = -1;
  v4[26] = -1;
  v4[30] = -1;
  v4[34] = -1;
  v4[38] = -1;
  int v5 = _fd_acquire_fd(a1[1810], (void *)v4 + 2);
  v4[2] = v5;
  if (v5 == -1) {
    goto LABEL_14;
  }
  int v6 = _fd_acquire_fd(a1[59], (void *)v4 + 4);
  v4[6] = v6;
  if (v6 == -1) {
    goto LABEL_14;
  }
  int v7 = _fd_acquire_fd(a1[1179], (void *)v4 + 6);
  v4[10] = v7;
  if (v7 == -1) {
    goto LABEL_14;
  }
  int v8 = _fd_acquire_fd(a1[1769], (void *)v4 + 10);
  v4[18] = v8;
  if (v8 == -1) {
    goto LABEL_14;
  }
  if (a2)
  {
    int v9 = _fd_acquire_fd(a1[650], (void *)v4 + 8);
    v4[14] = v9;
    if (v9 == -1 || (int v10 = _fd_acquire_fd(a1[1240], (void *)v4 + 12), v4[22] = v10, v10 == -1))
    {
LABEL_14:
      IndexFdInfoDispose(v4);
      return 0;
    }
  }
  else
  {
    int v11 = _fd_acquire_fd(a1[1809], (void *)v4 + 14);
    v4[26] = v11;
    if (v11 == -1) {
      goto LABEL_14;
    }
    int v12 = _fd_acquire_fd(a1[1806], (void *)v4 + 16);
    v4[30] = v12;
    if (v12 == -1) {
      goto LABEL_14;
    }
    int v13 = _fd_acquire_fd(a1[1807], (void *)v4 + 18);
    v4[34] = v13;
    if (v13 == -1) {
      goto LABEL_14;
    }
    uint64_t v14 = a1[1808];
    if (v14)
    {
      int v15 = _fd_acquire_fd(v14, (void *)v4 + 20);
      v4[38] = v15;
      if (v15 == -1) {
        goto LABEL_14;
      }
    }
  }
  return v4;
}

uint64_t index_compact(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  int v3 = v2;
  int v5 = v4;
  uint64_t v7 = v6;
  uint64_t v8 = v1;
  uint64_t v206 = *MEMORY[0x1E4F143B8];
  bzero(v205, 0x400uLL);
  bzero(v204, 0x400uLL);
  bzero(v203, 0x400uLL);
  bzero(v195, 0x4908uLL);
  unsigned int v9 = atomic_load((unsigned int *)(v8 + 36));
  unsigned char *v3 = 0;
  unsigned int v10 = atomic_load((unsigned int *)(v8 + 15192));
  if (v10 || ((*(uint64_t (**)(void))(v7 + 16))(*(void *)(v7 + 24)) & 1) != 0) {
    return 0xFFFFFFFFLL;
  }
  if (!*(unsigned char *)(v8 + 8))
  {
    int v14 = *__error();
    int v15 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v179[0]) = 136315650;
      *(void *)((char *)v179 + 4) = "index_compact";
      WORD6(v179[0]) = 1024;
      *(_DWORD *)((char *)v179 + 14) = 5761;
      WORD1(v179[1]) = 2080;
      *(void *)((char *)&v179[1] + 4) = v8 + 15208;
      unint64_t v16 = "%s:%d: invalid index: %s";
      goto LABEL_67;
    }
LABEL_10:
    *__error() = v14;
    return 0xFFFFFFFFLL;
  }
  char v12 = atomic_load((unsigned int *)(v8 + 36));
  if ((v12 & 4) == 0)
  {
    char v13 = atomic_load((unsigned int *)(v8 + 36));
    if ((v13 & 2) == 0)
    {
      int v14 = *__error();
      int v15 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v179[0]) = 136315650;
        *(void *)((char *)v179 + 4) = "index_compact";
        WORD6(v179[0]) = 1024;
        *(_DWORD *)((char *)v179 + 14) = 5769;
        WORD1(v179[1]) = 2080;
        *(void *)((char *)&v179[1] + 4) = v8 + 15208;
        unint64_t v16 = "%s:%d: cant compact writable index: %s";
LABEL_67:
        _os_log_error_impl(&dword_1BD672000, v15, OS_LOG_TYPE_ERROR, v16, (uint8_t *)v179, 0x1Cu);
        goto LABEL_10;
      }
      goto LABEL_10;
    }
    if (v5 == -1)
    {
      int v19 = -1;
    }
    else if (preflight_compact(v8, v5))
    {
      int v19 = v5;
    }
    else
    {
      int v19 = -1;
    }
    int v20 = v19;
    if (!preflight_compact(v8, *(_DWORD *)(v8 + 64))) {
      return 0xFFFFFFFFLL;
    }
    int v150 = v20;
    double Current = CFAbsoluteTimeGetCurrent();
    unsigned int v143 = *(_DWORD *)(v8 + 64);
    ForwardStore = 0;
    _initPayload((char *)v201, 1);
    _initPayload((char *)v202, 1);
    bzero(v200, 0x12D0uLL);
    pthread_mutex_init((pthread_mutex_t *)&v200[575], 0);
    bzero(&v200[20], 0x1140uLL);
    bzero(v195, 0x1144uLL);
    uint64_t v144 = SIUINT32SetCreate();
    int v22 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v23 = setThreadIdAndInfo(-1, sExcCompactCallbacks, (uint64_t)v195, 0, v22);
    unsigned int v166 = HIDWORD(v23);
    unsigned int v167 = v23;
    unint64_t v165 = __PAIR64__(v24, v25);
    uint64_t v26 = *(void *)&threadData[18 * v23 + 2];
    uint64_t v27 = v26 + 320 * HIDWORD(v23);
    int v156 = *(_DWORD *)(v27 + 312);
    int v28 = *(void (**)(void))(v27 + 224);
    if (v28) {
      v28(*(void *)(v26 + 320 * HIDWORD(v23) + 288));
    }
    int v157 = v22;
    unsigned int v164 = v167;
    unsigned int v163 = v166;
    unint64_t v162 = v165;
    __int16 v29 = (_DWORD *)&unk_1E9FC9000;
    if (_setjmp((int *)v27))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        LOWORD(v179[0]) = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)v179, 2u);
      }
      *(_DWORD *)(v27 + 312) = v156;
      CIOnThreadCleanUpReset(v162);
      dropThreadId(v164, 1, v157);
      CICleanUpReset(v164, HIDWORD(v162));
      unsigned int v30 = 0;
      int v31 = 0;
      uint64_t v32 = v143;
      uint64_t v33 = (const void *)v144;
LABEL_73:
      if (v33) {
        CFRelease(v33);
      }
      int v59 = *__error();
      uint32_t v60 = _SILogForLogForCategory(10);
      os_log_type_t v61 = 2 * (v29[51] < 4);
      if (os_log_type_enabled(v60, v61))
      {
        float v62 = CFAbsoluteTimeGetCurrent() - Current;
        LODWORD(v179[0]) = 134218240;
        *(double *)((char *)v179 + 4) = v62;
        WORD6(v179[0]) = 1024;
        *(_DWORD *)((char *)v179 + 14) = v30;
        _os_log_impl(&dword_1BD672000, v60, v61, "index_compact time (%f) - %d", (uint8_t *)v179, 0x12u);
      }
      *__error() = v59;
      if (v30) {
        int v63 = 1;
      }
      else {
        int v63 = v31;
      }
      if (v63) {
        uint64_t v64 = v30;
      }
      else {
        uint64_t v64 = 0xFFFFFFFFLL;
      }
      if (v203[0]) {
        index_DeleteIndex(0, v32, v203, 1);
      }
      return v64;
    }
    LODWORD(v34) = 0;
    uint64_t v154 = (uint64_t)CICleanUpThreadLoc();
    unint64_t v155 = threadData[18 * v154 + 8];
    v203[0] = 0;
    BOOL v153 = (const char *)(v8 + 15208);
    snprintf(v203, 0x400uLL, "tmp.%scmpt.", (const char *)(v8 + 15208));
    uint64_t v32 = v143;
    if (!openPayload((uint64_t)v201, v143, v203, "indexPostings", "indexTermIds", (char *)v205, 0, 0, 0, *(_DWORD *)(v8 + 4), *(void **)(v8 + 4936))|| (LODWORD(v34) = 0, !openPayload((uint64_t)v202, v143, v203, "indexPositions", "indexPositionTable", (char *)v205,
                           0,
                           0,
                           0,
                           *(_DWORD *)(v8 + 4),
                           *(void **)(v8 + 4936)))
      || (LODWORD(v34) = 0,
          !bt_openTrie((uint64_t)v200, v143, v203, 1, 0, 0, *(_DWORD *)(v8 + 4), *(void **)(v8 + 4936))))
    {
      int v43 = 0;
      goto LABEL_53;
    }
    if (*(void *)(v8 + 4928))
    {
      ForwardStore = createForwardStore(v143, v203, *(void **)(v8 + 4936));
      if (!ForwardStore)
      {
        LODWORD(v34) = 0;
        int v43 = 0;
        goto LABEL_53;
      }
    }
    if (_os_feature_enabled_impl() && *(unsigned char *)(v8 + 15714) && *(void *)(v8 + 4912)) {
      createVectorIndexWithPrototype();
    }
    snprintf((char *)v205, 0x400uLL, "%s%s", v203, "newTermIDMap");
    uint64_t v35 = *(unsigned int *)(v8 + 9400);
    if (v35 <= 0x4000000) {
      int v36 = 0x8000000;
    }
    else {
      int v36 = 0x10000000;
    }
    if (v35 >= 0x2000001) {
      int v37 = v36;
    }
    else {
      int v37 = 0x4000000;
    }
    if (v35 >= 0x1000001) {
      unsigned int v38 = v37;
    }
    else {
      unsigned int v38 = 0x2000000;
    }
    if (v35 > 0x800000) {
      uint64_t v39 = v38;
    }
    else {
      uint64_t v39 = 0x1000000;
    }
    LODWORD(v34) = 0;
    unint64_t v40 = fd_create_protected(v143, (const char *)v205, 536872450, 0);
    if (!uint32_map_init((uint64_t)v195, (uint64_t)v40, v35, v39, (v9 >> 9) & 1))
    {
LABEL_51:
      int v43 = 1;
      uint64_t v32 = v143;
LABEL_53:
      int v44 = v43;
      CICleanUpReset(v154, v155);
      __int16 v45 = 0;
      unsigned int v46 = v34;
      uint64_t v33 = (const void *)v144;
      int v47 = v156;
      goto LABEL_54;
    }
    int v41 = termIdStoreAllocBulk((uint64_t)&v201[5], v35);
    if (v41 || (v42 = v35, (int v41 = termIdStoreAllocBulk((uint64_t)&v202[5], v35)) != 0))
    {
      LODWORD(v34) = v41;
      goto LABEL_51;
    }
    if (*(void *)v7) {
      uint64_t v65 = (*(uint64_t (**)(void))v7)(*(void *)(v7 + 24));
    }
    else {
      uint64_t v65 = 0;
    }
    int v34 = IndexFdInfoCreate((uint64_t *)v8, 1);
    stat v66 = *(void (**)(void, uint64_t))(v7 + 8);
    if (v66)
    {
      v66(*(void *)(v7 + 24), v65);
      uint64_t v65 = 0;
    }
    uint64_t v145 = v65;
    if (!v34)
    {
      int v43 = 1;
      goto LABEL_105;
    }
    CICleanUpPush(v154, (uint64_t)IndexFdInfoDispose, (uint64_t)v34);
    double v67 = CFAbsoluteTimeGetCurrent();
    v161[0] = v195;
    v161[1] = 1;
    unsigned char *v3 = 1;
    bzero(v179, 0x5160uLL);
    __int16 v68 = (unsigned int *)(v8 + 15192);
    _dumpTrie(v8 + 96, 0, (_DWORD *)(v8 + 15192), v179, (uint64_t)reorderTermIdCallback, (uint64_t)v161);
    uint64_t v69 = *(void *)(v8 + 4928);
    if (v69)
    {
      v160[6] = MEMORY[0x1E4F143A8];
      v160[7] = 0x40000000;
      v160[8] = __index_compact_block_invoke;
      v160[9] = &__block_descriptor_tmp_64;
      v160[10] = v161;
      v160[11] = v8;
      dumpDirectoryStore(v69);
    }
    uint64_t v70 = *(void *)(v8 + 4912);
    if (v70)
    {
      v160[0] = MEMORY[0x1E4F143A8];
      v160[1] = 0x40000000;
      v160[2] = __index_compact_block_invoke_2;
      v160[3] = &__block_descriptor_tmp_67;
      v160[4] = v161;
      v160[5] = v8;
      dumpVectorIndex(v70, 0, (_DWORD *)(v8 + 15192), 0, (uint64_t)v160);
    }
    unsigned char *v3 = 0;
    unsigned int v71 = atomic_load((unsigned int *)(v8 + 15192));
    if (v71 || ((*(uint64_t (**)(void))(v7 + 16))(*(void *)(v7 + 24)) & 1) != 0) {
      goto LABEL_102;
    }
    int v72 = *__error();
    int v73 = _SILogForLogForCategory(10);
    os_log_type_t v74 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v73, v74))
    {
      float v75 = CFAbsoluteTimeGetCurrent() - v67;
      LODWORD(v179[0]) = 134217984;
      *(double *)((char *)v179 + 4) = v75;
      _os_log_impl(&dword_1BD672000, v73, v74, "computer new term ids time (%f)", (uint8_t *)v179, 0xCu);
    }
    *__error() = v72;
    if (atomic_load(v68)) {
      goto LABEL_102;
    }
    int v152 = (void *)(v8 + 4944);
    unint64_t v159 = 0;
    char v77 = atomic_load((unsigned int *)(v8 + 36));
    BOOL v78 = (v77 & 0xC) == 8 && indexCopyDeleteDocIds(v8, 1, &v159) + 1 == *(_DWORD *)(v8 + 68);
    BOOL v146 = v78;
    int v79 = v159;
    CICleanUpPush(v154, (uint64_t)bit_vector_release, (uint64_t)v159);
    unsigned char *v3 = 1;
    char v80 = atomic_load((unsigned int *)(v8 + 36));
    int v81 = CICompactPayloads(v201, 1, (uint64_t)v79, (uint64_t)v195, (uint64_t)v152, v203, v150, (v80 & 8) != 0, (_DWORD *)(v8 + 15192));
    unsigned char *v3 = 0;
    if (v81
      || (unsigned int v82 = atomic_load(v68)) != 0
      || !*(unsigned char *)(v8 + 8)
      || (*(unsigned int (**)(void))(v7 + 16))(*(void *)(v7 + 24)))
    {
      int v83 = v81;
      int v84 = *__error();
      __int16 v85 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v179[0]) = 136315394;
        *(void *)((char *)v179 + 4) = "index_compact";
        WORD6(v179[0]) = 1024;
        *(_DWORD *)((char *)v179 + 14) = 5943;
        uint64_t v89 = "%s:%d: Failed compacting postings";
        goto LABEL_122;
      }
    }
    else
    {
      if (v146
        || (unsigned char *v3 = 1,
            unsigned int v86 = v159,
            char v87 = atomic_load((unsigned int *)(v8 + 36)),
            v83 = CICompactPayloads(v202, 2, (uint64_t)v86, (uint64_t)v195, v8 + 9664, v203, v150, (v87 & 8) != 0, (_DWORD *)(v8 + 15192)), unsigned char *v3 = 0, !v83))
      {
        unsigned int v88 = atomic_load(v68);
        if (!v88 && *(unsigned char *)(v8 + 8) && !(*(unsigned int (**)(void))(v7 + 16))(*(void *)(v7 + 24)))
        {
          double v90 = CFAbsoluteTimeGetCurrent();
          bzero(&v185, 0x890uLL);
          v180[0] = v8;
          v180[1] = v8 + 96;
          unint64_t v151 = (void *)(v8 + 96);
          v180[2] = v200;
          unsigned int v181 = v201;
          unsigned int v182 = v202;
          uint64_t v183 = v195;
          uint64_t v184 = v3;
          bzero(v179, 0x10000uLL);
          fd_pread((_DWORD *)v202[561], v179, 0x10000uLL, 0);
          if (v42 >= 2)
          {
            unint64_t v91 = 0;
            uint64_t v92 = 1;
            unint64_t v93 = 8;
            do
            {
              unint64_t v142 = v93;
              unsigned int v94 = atomic_load(v68);
              if (v94 || (*(unsigned int (**)(void))(v7 + 16))(*(void *)(v7 + 24))) {
                break;
              }
              unint64_t v95 = *(void *)storageResolvePtr((uint64_t)&v202[5], v93, 8, 1);
              if (v95)
              {
                if (v95 < v91 || v95 + 10 > v91 + 0x10000)
                {
                  unint64_t v91 = v95 & ~*MEMORY[0x1E4F14AF0];
                  fd_pread((_DWORD *)v202[561], v179, 0x10000uLL, v91);
                }
                v176[0] = v95 - v91;
                if (!v2_readVInt32((uint64_t)v179, v176))
                {
                  int v133 = v92;
                  unsigned int v134 = 1;
                  do
                  {
                    if (uint32_map_get((uint64_t)v195, v134) == v92) {
                      goto LABEL_206;
                    }
                    ++v134;
                  }
                  while (v42 != v134);
                  unsigned int v134 = 0;
LABEL_206:
                  unsigned char *v3 = 1;
                  int v135 = __si_assert_copy_extra_2445((_DWORD *)v202[561], -1);
                  int v136 = v135;
                  int v137 = "";
                  if (v135) {
                    int v137 = v135;
                  }
                  __message_assert("%s:%u: failed assertion '%s' %s missing positions for term %d (%d)", "JHContentIndex.c", 6000, "false", v137, v133, v134);
                  free(v136);
                  if (__valid_fsp((_DWORD *)v202[561])) {
                    uint64_t v138 = 2989;
                  }
                  else {
                    uint64_t v138 = 3072;
                  }
                  *(_DWORD *)uint64_t v138 = -559038737;
                  abort();
                }
              }
              ++v92;
              unint64_t v93 = v142 + 8;
            }
            while (v42 != v92);
          }
          long long v186 = v200;
          int v192 = 0;
          long long v190 = 0u;
          long long v194 = 0u;
          uint64_t v187 = 1;
          long long v191 = 0u;
          uint64_t v193 = 0;
          uint64_t v188 = 0;
          uint64_t v189 = 0;
          _dumpTrie((unint64_t)v151, 0, (_DWORD *)(v8 + 15192), 0, (uint64_t)compactTermsCallback, (uint64_t)v180);
          uint64_t v97 = *(void *)(v8 + 4928);
          if (v97)
          {
            long long v98 = *(_OWORD *)(v7 + 16);
            v179[0] = *(_OWORD *)v7;
            v179[1] = v98;
            compactForwardDirectoryStore(v97);
          }
          uint64_t v99 = *(void *)(v8 + 4912);
          if (v99)
          {
            long long v100 = *(_OWORD *)(v7 + 16);
            v179[0] = *(_OWORD *)v7;
            v179[1] = v100;
            compactVectorIndex(v99, v199, (uint64_t)v183, (uint64_t)(v181 + 5), v179, (_DWORD *)(v8 + 15192));
          }
          unsigned int v101 = atomic_load(v68);
          if (v101 || ((*(uint64_t (**)(void))(v7 + 16))(*(void *)(v7 + 24)) & 1) != 0 || HIDWORD(v187))
          {
LABEL_102:
            LODWORD(v34) = 0;
LABEL_103:
            int v43 = 1;
LABEL_105:
            uint64_t v32 = v143;
            goto LABEL_53;
          }
          if (v197 - 1 < v185)
          {
            unsigned char *v3 = 1;
            BOOL v139 = __si_assert_copy_extra_2445(*(_DWORD **)(v8 + 14480), -1);
            uint64_t v140 = v139;
            int v141 = "";
            if (v139) {
              int v141 = v139;
            }
            __message_assert("%s:%u: failed assertion '%s' %s inconsistent term counts (%d %d)", "JHContentIndex.c", 6029, "false", v141, v185, v197 - 1);
            free(v140);
            if (__valid_fsp(*(_DWORD **)(v8 + 14480)))
            {
              MEMORY[0xBAD] = -559038737;
              abort();
            }
            MEMORY[0xC00] = -559038737;
            abort();
          }
          int v102 = *__error();
          unsigned int v103 = _SILogForLogForCategory(10);
          os_log_type_t v104 = 2 * (dword_1E9FC90CC < 4);
          if (os_log_type_enabled(v103, v104))
          {
            float v105 = CFAbsoluteTimeGetCurrent() - v90;
            LODWORD(v179[0]) = 134217984;
            *(double *)((char *)v179 + 4) = v105;
            _os_log_impl(&dword_1BD672000, v103, v104, "compact_trie time (%f)", (uint8_t *)v179, 0xCu);
          }
          *__error() = v102;
          _fd_unlink_with_origin(v201[32], 0);
          termIdStoreDestroy((uint64_t)&v201[5]);
          _fd_unlink_with_origin(v202[32], 0);
          termIdStoreDestroy((uint64_t)&v202[5]);
          if (SLODWORD(v200[51]) >= 1)
          {
            uint64_t v106 = 0;
            do
            {
              uint64_t v107 = v106;
              storageWindowSync(v200[v106 + 54], 0);
              uint64_t v106 = v107 + 1;
            }
            while (v107 + 1 < SLODWORD(v200[51]));
          }
          if (SLODWORD(v202[36]) >= 1)
          {
            uint64_t v108 = 0;
            do
            {
              uint64_t v109 = v108;
              storageWindowSync(v202[v108 + 39], 0);
              uint64_t v108 = v109 + 1;
            }
            while (v109 + 1 < SLODWORD(v202[36]));
          }
          bt_syncTrie((uint64_t)v200);
          off_t v110 = v201[3];
          if (v201[3] == v201[4] && v201[1] == v201[3])
          {
            v201[1] = v201[0];
            v201[3] = v201[0];
            off_t v110 = v201[0];
          }
          fd_truncate(v201[561], v110);
          fd_sync(v201[561], 0);
          off_t v111 = v202[3];
          if (v202[3] == v202[4] && v202[1] == v202[3])
          {
            v202[1] = v202[0];
            v202[3] = v202[0];
            off_t v111 = v202[0];
          }
          fd_truncate(v202[561], v111);
          fd_sync(v202[561], 0);
          storageTruncate(&v200[20]);
          fd_truncate(v200[14], v200[4]);
          fd_truncate(v200[572], 1028 * (LODWORD(v200[18]) + 1));
          uint64_t v112 = v145;
          if (*(void *)v7) {
            uint64_t v112 = (*(uint64_t (**)(void))v7)(*(void *)(v7 + 24));
          }
          CICleanUpReset(v154, v155);
          uint64_t v113 = *(void *)(v8 + 14448);
          if (v113 && (*(unsigned char *)(v113 + 48) & 3) != 0)
          {
            fd_truncate(v113, 8 * *(unsigned int *)(v8 + 68));
            fd_make_readonly(*(void *)(v8 + 14448));
          }
          storageMakeReadOnly((uint64_t)&v200[20]);
          if (v199) {
            IVFVectorIndex_s::makeReadOnly((void *)(v199 + 8));
          }
          fd_reparent(v202[561], *(_DWORD *)(v8 + 64));
          fd_reparent(v201[561], *(_DWORD *)(v8 + 64));
          fd_make_readonly(v200[14]);
          fd_make_readonly(v201[561]);
          _fd_unlink_with_origin(v201[32], 0);
          storageClose(v8 + 4984);
          fd_make_readonly(v202[561]);
          _fd_unlink_with_origin(v202[32], 0);
          storageClose((uint64_t)&v202[5]);
          if (*(void *)(v8 + 4928))
          {
            LODWORD(v179[0]) = 0;
            shadowForwardStore((uint64_t)ForwardStore, 1, v179);
          }
          _db_write_lock(v8 + 14504);
          _db_write_lock(v8 + 4696);
          _db_write_lock(v8 + 14720);
          bzero(v178, 0x208uLL);
          uint64_t v177 = 0x6D6F76650A00;
          v178[0] = 4;
          __strlcpy_chk();
          __strlcpy_chk();
          int v114 = si_openat_protected(*(unsigned int *)(v8 + 64), "tmp.movePlan", 1538, 3);
          pwrite(v114, &v177, 0x210uLL, 0);
          fcntl(v114, 85);
          close(v114);
          *(unsigned char *)(v8 + 4685) = 1;
          memcpy(v179, (const void *)v8, 0x3D68uLL);
          memcpy(&v179[6], v200, 0x12D0uLL);
          memcpy(&v179[604], v202, 0x1270uLL);
          memcpy(&v179[309], v201, 0x1270uLL);
          bzero(v176, 0x1000uLL);
          double v158 = 0;
          DWORD1(v179[0]) = *(_DWORD *)(v8 + 4);
          atomic_fetch_or((atomic_uint *volatile)&v179[2] + 1, 4u);
          if (v146) {
            atomic_fetch_or((atomic_uint *volatile)&v179[2] + 1, 0x10u);
          }
          uint64_t v147 = v8 + 4696;
          uint64_t v148 = v8 + 14504;
          uint64_t v149 = v8 + 14720;
          atomic_store(0xC001D00D, (unsigned int *)&v179[2]);
          double v158 = v176;
          indexStoreToBuffer((uint64_t)v179, (void **)&v158);
          snprintf((char *)v205, 0x400uLL, "%s%s", v203, "shadowIndexHead");
          char v115 = (atomic_uint *)fd_create_protected(*(_DWORD *)(v8 + 64), (const char *)v205, 536872450, 0);
          if (v115)
          {
            unsigned int v116 = v115;
            if (fd_pwrite((uint64_t)v115, (uint64_t)v176, 0x1000uLL, 0) == -1)
            {
              int v128 = *__error();
              os_log_type_t v129 = _SILogForLogForCategory(0);
              if (!os_log_type_enabled(v129, OS_LOG_TYPE_ERROR))
              {
LABEL_195:
                int v125 = v128;
                goto LABEL_196;
              }
              int v130 = *__error();
              *(_DWORD *)statfs buf = 136315650;
              unint64_t v169 = "index_compact";
              __int16 v170 = 1024;
              int v171 = 6173;
              __int16 v172 = 1024;
              int v173 = v130;
LABEL_201:
              _os_log_error_impl(&dword_1BD672000, v129, OS_LOG_TYPE_ERROR, "%s:%d: pwrite err: %d", buf, 0x18u);
              goto LABEL_195;
            }
            fd_release(v116);
            snprintf((char *)v205, 0x400uLL, "%s%s", v203, "indexHead");
            int v117 = (atomic_uint *)fd_create_protected(v143, (const char *)v205, 536872450, 0);
            if (v117)
            {
              unsigned int v116 = v117;
              fd_no_cache((uint64_t)v117);
              if (fd_pwrite((uint64_t)v116, (uint64_t)v176, 0x1000uLL, 0) != -1)
              {
                fd_sync((uint64_t)v116, 1);
                snprintf((char *)v205, 0x400uLL, "%s%s", v153, "indexHead");
                fd_rename((uint64_t)v116, (const char *)v205);
                unint64_t v118 = *(atomic_uint **)(v8 + 14480);
                *(void *)(v8 + 14480) = v116;
                fd_release(v118);
                snprintf((char *)v205, 0x400uLL, "%s%s", v153, "indexPostings");
                fd_rename(v201[561], (const char *)v205);
                memcpy(v179, v201, 0x1270uLL);
                memcpy(v201, v152, 0x11A8uLL);
                memcpy(v152, v179, 0x11A8uLL);
                snprintf((char *)v205, 0x400uLL, "%s%s", v153, "indexPositions");
                fd_rename(v202[561], (const char *)v205);
                memcpy(v179, v202, 0x1270uLL);
                memcpy(v202, (const void *)(v8 + 9664), 0x11A8uLL);
                memcpy((void *)(v8 + 9664), v179, 0x11A8uLL);
                bt_changePrefix((uint64_t)v200, v203, v153, 0);
                memcpy(v179, v200, 0x12D0uLL);
                memcpy(v200, v151, 0x11F8uLL);
                memcpy(v151, v179, 0x11F8uLL);
                LODWORD(v179[0]) = 0;
                if (fd_setDir(*(unsigned int *)(v8 + 64), (int *)v179))
                {
                  snprintf((char *)v205, 0x400uLL, "%s%s", v153, "indexUpdates");
                  unlink((const char *)v205);
                  snprintf((char *)v205, 0x400uLL, "%s%s", v153, "shadowIndexHead");
                  snprintf((char *)v204, 0x400uLL, "%s%s", v203, "shadowIndexHead");
                  rename(v204, v205, v119);
                  unsigned int v120 = *(void **)(v8 + 4928);
                  if (v120)
                  {
                    subvertForwardDirectoryStore(v120, (uint64_t)ForwardStore);
                    *(void *)(v8 + 4928) = ForwardStore;
                    ForwardStore = 0;
                  }
                  uint64_t v121 = *(void *)(v8 + 4912);
                  if (v121)
                  {
                    subvertVectorIndex(v121, v199);
                    uint64_t v122 = v199;
                    *(void *)(v8 + 4912) = v199;
                    uint64_t v199 = 0;
                    vectorIndexEndMerge(v122);
                  }
                  fd_resetDir(v179[0]);
                }
                unlinkat(*(_DWORD *)(v8 + 64), "tmp.movePlan", 2048);
                if (v146) {
                  unsigned int v123 = 20;
                }
                else {
                  unsigned int v123 = 4;
                }
                atomic_fetch_or((atomic_uint *volatile)(v8 + 36), v123);
                int64_t v124 = *(void (**)(void, uint64_t))(v7 + 8);
                if (v124) {
                  v124(*(void *)(v7 + 24), v112);
                }
                CICleanUpReset(v154, v155);
                db_write_unlock(v147);
                db_write_unlock(v148);
                db_write_unlock(v149);
                index_optimize_disk_space(v8);
                unsigned int v52 = 0;
                if (g_fd_list) {
                  _fd_close_inactive(*(unsigned int *)(v8 + 64), v153, 0, 0);
                }
                int v51 = 1;
                uint64_t v32 = v143;
                uint64_t v33 = (const void *)v144;
                int v54 = v157;
                int v47 = v156;
                goto LABEL_69;
              }
              int v128 = *__error();
              os_log_type_t v129 = _SILogForLogForCategory(0);
              if (!os_log_type_enabled(v129, OS_LOG_TYPE_ERROR)) {
                goto LABEL_195;
              }
              int v132 = *__error();
              *(_DWORD *)statfs buf = 136315650;
              unint64_t v169 = "index_compact";
              __int16 v170 = 1024;
              int v171 = 6188;
              __int16 v172 = 1024;
              int v173 = v132;
              goto LABEL_201;
            }
            int v125 = *__error();
            unint64_t v126 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v126, OS_LOG_TYPE_ERROR))
            {
LABEL_193:
              unsigned int v116 = 0;
LABEL_196:
              *__error() = v125;
              CICleanUpReset(v154, v155);
              db_write_unlock(v147);
              db_write_unlock(v148);
              db_write_unlock(v149);
              unsigned int v46 = 0;
              int v44 = 1;
              __int16 v45 = v116;
              uint64_t v32 = v143;
              uint64_t v33 = (const void *)v144;
              int v47 = v156;
LABEL_54:
              fd_release(v45);
              if (v199) {
                vectorIndexCancelMerge(v199);
              }
              fd_zero_truncate(v200[572]);
              fd_zero_truncate(v200[14]);
              fd_zero_truncate(v200[47]);
              fd_zero_truncate(v201[32]);
              fd_zero_truncate(v201[561]);
              fd_zero_truncate(v202[32]);
              fd_zero_truncate(v202[561]);
              fd_zero_truncate(v196);
              if (ForwardStore)
              {
                fd_zero_truncate(ForwardStore[28]);
                freeForwardDirectoryStore(ForwardStore);
                ForwardStore = 0;
                unlinkDirectoryStore(v203);
                unlinkDirectoryStoreShadow(v203);
              }
              if (v199)
              {
                int v48 = (IVFVectorIndex_s *)v205;
                int v49 = fcntl(*(_DWORD *)v199, 50, v205);
                if (v205[0].__pn_.__r_.__value_.__s.__data_[0]) {
                  BOOL v50 = v49 < 0;
                }
                else {
                  BOOL v50 = 1;
                }
                if (v50) {
                  int v48 = 0;
                }
                truncateVectorIndex(v199);
                freeVectorIndex(v199);
                uint64_t v199 = 0;
                IVFVectorIndex_s::unlink(v48, v203, 0);
                IVFVectorIndex_s::unlink(v48, v203, (const char *)1);
                int v51 = 0;
                unsigned int v52 = v46;
                int v53 = 0;
                int v54 = v157;
                if ((v44 & 1) == 0) {
                  goto LABEL_70;
                }
              }
              else
              {
                int v51 = 0;
                unsigned int v52 = v46;
                int v53 = 0;
                int v54 = v157;
                if (!v44)
                {
LABEL_70:
                  storageClose((uint64_t)v195);
                  bt_freeTrie((uint64_t)v200);
                  freePayload((uint64_t)v202);
                  freePayload((uint64_t)v201);
                  uint64_t v55 = *(void *)&threadData[18 * v164 + 2];
                  unsigned int v56 = v163;
                  uint64_t v57 = v55 + 320 * v163;
                  *(_DWORD *)(v57 + 312) = v47;
                  int v58 = *(void (**)(void))(v57 + 232);
                  if (v58) {
                    v58(*(void *)(v55 + 320 * v56 + 288));
                  }
                  dropThreadId(v164, 0, v54);
                  int v31 = v53;
                  unsigned int v30 = v46;
                  __int16 v29 = &unk_1E9FC9000;
                  goto LABEL_73;
                }
              }
LABEL_69:
              int v53 = v51;
              _fd_unlink_with_origin(v196, 0);
              unsigned int v46 = v52;
              goto LABEL_70;
            }
            int v131 = *__error();
            *(_DWORD *)statfs buf = 136315906;
            unint64_t v169 = "index_compact";
            __int16 v170 = 1024;
            int v171 = 6183;
            __int16 v172 = 1024;
            int v173 = v131;
            __int16 v174 = 2080;
            os_log_type_t v175 = v205;
          }
          else
          {
            int v125 = *__error();
            unint64_t v126 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v126, OS_LOG_TYPE_ERROR)) {
              goto LABEL_193;
            }
            int v127 = *__error();
            *(_DWORD *)statfs buf = 136315906;
            unint64_t v169 = "index_compact";
            __int16 v170 = 1024;
            int v171 = 6169;
            __int16 v172 = 1024;
            int v173 = v127;
            __int16 v174 = 2080;
            os_log_type_t v175 = v205;
          }
          _os_log_error_impl(&dword_1BD672000, v126, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", buf, 0x22u);
          unsigned int v116 = 0;
          goto LABEL_196;
        }
        int v83 = 0;
      }
      int v84 = *__error();
      __int16 v85 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v179[0]) = 136315394;
        *(void *)((char *)v179 + 4) = "index_compact";
        WORD6(v179[0]) = 1024;
        *(_DWORD *)((char *)v179 + 14) = 5956;
        uint64_t v89 = "%s:%d: Failed compacting positions";
LABEL_122:
        _os_log_error_impl(&dword_1BD672000, v85, OS_LOG_TYPE_ERROR, v89, (uint8_t *)v179, 0x12u);
      }
    }
    LODWORD(v34) = v83;
    *__error() = v84;
    goto LABEL_103;
  }
  int v17 = *__error();
  int v18 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LODWORD(v179[0]) = 136315650;
    *(void *)((char *)v179 + 4) = "index_compact";
    WORD6(v179[0]) = 1024;
    *(_DWORD *)((char *)v179 + 14) = 5765;
    WORD1(v179[1]) = 2080;
    *(void *)((char *)&v179[1] + 4) = v8 + 15208;
    _os_log_error_impl(&dword_1BD672000, v18, OS_LOG_TYPE_ERROR, "%s:%d: index alreay compact: %s", (uint8_t *)v179, 0x1Cu);
  }
  *__error() = v17;
  return 0;
}

uint64_t preflight_compact(uint64_t a1, int a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  bzero(&v35, 0x878uLL);
  char v4 = atomic_load((unsigned int *)(a1 + 36));
  atomic_load((unsigned int *)(a1 + 36));
  uint64_t v5 = 68;
  if ((v4 & 4) == 0) {
    uint64_t v5 = 72;
  }
  uint64_t v6 = *(unsigned int *)(a1 + v5);
  if (*(unsigned char *)(a1 + 45)) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = ((unint64_t)(4 * v6 + 4) * (unsigned __int128)0x3333333333333334uLL) >> 64;
  }
  uint64_t v8 = v7 + 8 * v6 + *(void *)(a1 + 4968) + 4096;
  if ((v4 & 4) != 0)
  {
    uint64_t v9 = *(void *)(a1 + 9688) + v8;
    unsigned int v10 = (unsigned int *)(a1 + 240);
    int v11 = (void *)(a1 + 128);
    char v12 = (void *)(a1 + 488);
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 9688) + v8 + 8 * *(unsigned int *)(a1 + 9404) + 8 * *(unsigned int *)(a1 + 14124);
    unsigned int v10 = (unsigned int *)(a1 + 244);
    int v11 = (void *)(a1 + 136);
    char v12 = (void *)(a1 + 480);
  }
  uint64_t v13 = *v11 + v9 + 1028 * *v10 + *v12 + 1028;
  uint64_t v14 = *(void *)(a1 + 4928);
  if (v14) {
    v13 += *(void *)(v14 + 232);
  }
  if (fstatfs(a2, &v35) == -1)
  {
    int v17 = *__error();
    int v22 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      int v25 = *__error();
      int v26 = 136315906;
      uint64_t v27 = "preflight_compact";
      __int16 v28 = 1024;
      int v29 = 5547;
      __int16 v30 = 1024;
      *(_DWORD *)int v31 = a2;
      *(_WORD *)&uint8_t v31[4] = 1024;
      *(_DWORD *)&v31[6] = v25;
      int v19 = "%s:%d: fstatfs(%d) err:%d";
      int v20 = v22;
      uint32_t v21 = 30;
      goto LABEL_22;
    }
LABEL_17:
    unint64_t v23 = __error();
    uint64_t result = 0;
    *unint64_t v23 = v17;
    return result;
  }
  uint64_t v15 = v35.f_bavail * v35.f_bsize;
  unint64_t v16 = v13
      - *(void *)(a1 + 4968)
      - *(void *)(a1 + 9688)
      + 2 * (*(void *)(a1 + 4968) - *(void *)(a1 + 4952) + *(void *)(a1 + 4944))
      + 2 * (*(void *)(a1 + 9688) - *(void *)(a1 + 9672) + *(void *)(a1 + 9664));
  if (v16 <= v15) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 64) == a2)
  {
    int v17 = *__error();
    int v18 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      int v26 = 136316162;
      uint64_t v27 = "preflight_compact";
      __int16 v28 = 1024;
      int v29 = 5564;
      __int16 v30 = 2048;
      *(void *)int v31 = v16;
      *(_WORD *)&v31[8] = 2048;
      uint64_t v32 = v15;
      __int16 v33 = 2048;
      uint64_t v34 = v35.f_blocks * v35.f_bsize;
      int v19 = "%s:%d: not enought space to compact index - needed: %lld, avail: %lld, device: %lld";
      int v20 = v18;
      uint32_t v21 = 48;
LABEL_22:
      _os_log_error_impl(&dword_1BD672000, v20, OS_LOG_TYPE_ERROR, v19, (uint8_t *)&v26, v21);
      goto LABEL_17;
    }
    goto LABEL_17;
  }
  return 0;
}

BOOL __index_compact_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    if (uint32_map_get(**(void **)(a1 + 32), a4))
    {
      si_analytics_log_2842("Duplicate term id %llu (file tree)", a4);
    }
    else
    {
      uint64_t v6 = *(uint64_t **)(a1 + 32);
      int v7 = *((_DWORD *)v6 + 2);
      *((_DWORD *)v6 + 2) = v7 + 1;
      if (!a4 || *(_DWORD *)(*v6 + 4416) <= a4)
      {
        unsigned int v10 = __si_assert_copy_extra(0);
        int v11 = v10;
        char v12 = "";
        if (v10) {
          char v12 = v10;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1549, "position && position < inMap->count", v12);
        free(v11);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      *(_DWORD *)storageResolvePtr(*v6, 4 * a4, 4, 1) = v7;
    }
  }
  unsigned int v8 = atomic_load((unsigned int *)(*(void *)(a1 + 40) + 15192));
  return v8 != 0;
}

BOOL __index_compact_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a8)
  {
    if (uint32_map_get(**(void **)(a1 + 32), a8))
    {
      si_analytics_log_2842("Duplicate term id %llu (vector index)", a8);
    }
    else
    {
      unsigned int v10 = *(uint64_t **)(a1 + 32);
      int v11 = *((_DWORD *)v10 + 2);
      *((_DWORD *)v10 + 2) = v11 + 1;
      if (!a8 || *(_DWORD *)(*v10 + 4416) <= a8)
      {
        uint64_t v14 = __si_assert_copy_extra(0);
        uint64_t v15 = v14;
        unint64_t v16 = "";
        if (v14) {
          unint64_t v16 = v14;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1549, "position && position < inMap->count", v16);
        free(v15);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      *(_DWORD *)storageResolvePtr(*v10, 4 * a8, 4, 1) = v11;
    }
  }
  unsigned int v12 = atomic_load((unsigned int *)(*(void *)(a1 + 40) + 15192));
  return v12 != 0;
}

uint64_t v2_readVInt32(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a2 + 1;
  int v5 = *(char *)(a1 + *a2);
  uint64_t result = *(unsigned __int8 *)(a1 + *a2);
  if (v5 < 0)
  {
    if (result > 0xBF)
    {
      if (result > 0xDF)
      {
        if (result > 0xEF)
        {
          uint64_t result = *(unsigned int *)(a1 + v4);
          *a2 = v3 + 5;
        }
        else
        {
          uint64_t result = ((result & 0xF) << 24) | (*(unsigned __int8 *)(a1 + v4) << 16) | (*(unsigned __int8 *)(v3 + a1 + 2) << 8) | *(unsigned __int8 *)(v3 + a1 + 3);
          *a2 = v3 + 4;
        }
      }
      else
      {
        uint64_t result = ((result & 0x1F) << 16) | (*(unsigned __int8 *)(a1 + v4) << 8) | *(unsigned __int8 *)(v3 + a1 + 2);
        *a2 = v3 + 3;
      }
    }
    else
    {
      uint64_t result = *(unsigned __int8 *)(a1 + v4) | ((result & 0x3F) << 8);
      *a2 = v3 + 2;
    }
  }
  else
  {
    *a2 = v4;
  }
  return result;
}

void index_optimize_disk_space(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (atomic_load((unsigned int *)(a1 + 15192))) {
    return;
  }
  if (!*(unsigned char *)(a1 + 8))
  {
    int v5 = *__error();
    uint64_t v6 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v25.dev_t st_dev = 136315650;
      *(void *)&v25.st_mode = "index_optimize_disk_space";
      WORD2(v25.st_ino) = 1024;
      *(_DWORD *)((char *)&v25.st_ino + 6) = 6366;
      HIWORD(v25.st_uid) = 2080;
      *(void *)&v25.st_gid = a1 + 15208;
      int v7 = "%s:%d: invalid index: %s";
      goto LABEL_32;
    }
LABEL_10:
    *__error() = v5;
    return;
  }
  __int16 v3 = atomic_load((unsigned int *)(a1 + 36));
  if ((v3 & 0x100) != 0)
  {
    int v5 = *__error();
    uint64_t v6 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v25.dev_t st_dev = 136315650;
      *(void *)&v25.st_mode = "index_optimize_disk_space";
      WORD2(v25.st_ino) = 1024;
      *(_DWORD *)((char *)&v25.st_ino + 6) = 6370;
      HIWORD(v25.st_uid) = 2080;
      *(void *)&v25.st_gid = a1 + 15208;
      int v7 = "%s:%d: index alreay compact: %s";
      goto LABEL_32;
    }
    goto LABEL_10;
  }
  char v4 = atomic_load((unsigned int *)(a1 + 36));
  if ((v4 & 2) == 0)
  {
    int v5 = *__error();
    uint64_t v6 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v25.dev_t st_dev = 136315650;
      *(void *)&v25.st_mode = "index_optimize_disk_space";
      WORD2(v25.st_ino) = 1024;
      *(_DWORD *)((char *)&v25.st_ino + 6) = 6374;
      HIWORD(v25.st_uid) = 2080;
      *(void *)&v25.st_gid = a1 + 15208;
      int v7 = "%s:%d: cant optimize writable index: %s";
LABEL_32:
      _os_log_error_impl(&dword_1BD672000, v6, OS_LOG_TYPE_ERROR, v7, (uint8_t *)&v25, 0x1Cu);
      goto LABEL_10;
    }
    goto LABEL_10;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v21 = 0;
  int v22 = &v21;
  uint64_t v23 = 0x2000000000;
  char v24 = 0;
  uint64_t v9 = *(unsigned int *)(a1 + 64);
  memset(&v25, 0, sizeof(v25));
  if (!fstat(v9, &v25))
  {
    uint64_t v10 = open(".", 4);
    if (!MEMORY[0x1C1882290](v9))
    {
      if (_os_feature_enabled_impl() && *(void *)(a1 + 4912)) {
        vectorIndexFinalizeMerge();
      }
      MEMORY[0x1C1882290](v10);
      if ((v10 & 0x80000000) != 0) {
        goto LABEL_16;
      }
      goto LABEL_15;
    }
    if ((v10 & 0x80000000) == 0) {
LABEL_15:
    }
      close(v10);
  }
LABEL_16:
  atomic_fetch_or((atomic_uint *volatile)(a1 + 36), 0x100u);
  if (*((unsigned char *)v22 + 24))
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 4696));
    *(_DWORD *)(a1 + 4900) = 0;
    int v11 = *(pthread_override_s **)(a1 + 4872);
    *(void *)(a1 + 4872) = 0;
    *(void *)(a1 + 4880) = 0;
    char v12 = *(_DWORD *)(a1 + 4892) != 0;
    *(unsigned char *)(a1 + 4908) = 0;
    db_rwlock_wakeup(a1 + 4696, v12, 0);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4696));
    if (v11) {
      pthread_override_qos_class_end_np(v11);
    }
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 14504));
    *(_DWORD *)(a1 + 14708) = 0;
    uint64_t v13 = *(pthread_override_s **)(a1 + 14680);
    *(_OWORD *)(a1 + 14680) = 0u;
    char v14 = *(_DWORD *)(a1 + 14700) != 0;
    *(unsigned char *)(a1 + 14716) = 0;
    db_rwlock_wakeup(a1 + 14504, v14, 0);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14504));
    if (v13) {
      pthread_override_qos_class_end_np(v13);
    }
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 14720));
    *(_DWORD *)(a1 + 14924) = 0;
    uint64_t v15 = *(pthread_override_s **)(a1 + 14896);
    *(void *)(a1 + 14904) = 0;
    *(void *)(a1 + 14896) = 0;
    char v16 = *(_DWORD *)(a1 + 14916) != 0;
    *(unsigned char *)(a1 + 14932) = 0;
    db_rwlock_wakeup(a1 + 14720, v16, 0);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14720));
    if (v15) {
      pthread_override_qos_class_end_np(v15);
    }
  }
  int v17 = *__error();
  int v18 = _SILogForLogForCategory(10);
  os_log_type_t v19 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v18, v19))
  {
    float v20 = CFAbsoluteTimeGetCurrent() - Current;
    v25.dev_t st_dev = 134217984;
    *(double *)&v25.st_mode = v20;
    _os_log_impl(&dword_1BD672000, v18, v19, "index_optimize time (%f)", (uint8_t *)&v25, 0xCu);
  }
  *__error() = v17;
  _Block_object_dispose(&v21, 8);
}

uint64_t __index_optimize_disk_space_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  HIDWORD(v4) = qos_class_self() - 9;
  LODWORD(v4) = HIDWORD(v4);
  unsigned int v3 = v4 >> 2;
  if (v3 > 6) {
    signed int v5 = 0;
  }
  else {
    signed int v5 = dword_1BDA87810[v3];
  }
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 14504));
  if (*(void *)(v2 + 14688) || *(_DWORD *)(v2 + 14700) || *(unsigned char *)(v2 + 14716)) {
    goto LABEL_7;
  }
  if (v5 <= 5)
  {
    if (*(void *)(v2 + 16 * v5 + 14568))
    {
LABEL_7:
      db_rwlock_wait(v2 + 14504, v5, 2);
      goto LABEL_8;
    }
    uint64_t v15 = v5 - 1;
    char v16 = (uint64_t *)(v2 + 16 * v5 + 14584);
    while (v15 != 4)
    {
      uint64_t v17 = *v16;
      v16 += 2;
      ++v15;
      if (v17)
      {
        if (v15 <= 4) {
          goto LABEL_7;
        }
        break;
      }
    }
  }
  *(void *)(v2 + 14688) = pthread_self();
LABEL_8:
  pthread_mutex_unlock((pthread_mutex_t *)(v2 + 14504));
  uint64_t v6 = *(void *)(a1 + 40);
  HIDWORD(v8) = qos_class_self() - 9;
  LODWORD(v8) = HIDWORD(v8);
  unsigned int v7 = v8 >> 2;
  if (v7 > 6) {
    signed int v9 = 0;
  }
  else {
    signed int v9 = dword_1BDA87810[v7];
  }
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 4696));
  if (*(void *)(v6 + 4880) || *(_DWORD *)(v6 + 4892) || *(unsigned char *)(v6 + 4908)) {
    goto LABEL_14;
  }
  if (v9 <= 5)
  {
    if (*(void *)(v6 + 16 * v9 + 4760))
    {
LABEL_14:
      db_rwlock_wait(v6 + 4696, v9, 2);
      goto LABEL_15;
    }
    uint64_t v18 = v9 - 1;
    os_log_type_t v19 = (uint64_t *)(v6 + 16 * v9 + 4776);
    while (v18 != 4)
    {
      uint64_t v20 = *v19;
      v19 += 2;
      ++v18;
      if (v20)
      {
        if (v18 <= 4) {
          goto LABEL_14;
        }
        break;
      }
    }
  }
  *(void *)(v6 + 4880) = pthread_self();
LABEL_15:
  pthread_mutex_unlock((pthread_mutex_t *)(v6 + 4696));
  uint64_t v10 = *(void *)(a1 + 40);
  HIDWORD(v12) = qos_class_self() - 9;
  LODWORD(v12) = HIDWORD(v12);
  unsigned int v11 = v12 >> 2;
  if (v11 > 6) {
    signed int v13 = 0;
  }
  else {
    signed int v13 = dword_1BDA87810[v11];
  }
  pthread_mutex_lock((pthread_mutex_t *)(v10 + 14720));
  if (*(void *)(v10 + 14904) || *(_DWORD *)(v10 + 14916) || *(unsigned char *)(v10 + 14932)) {
    goto LABEL_21;
  }
  if (v13 > 5)
  {
LABEL_43:
    *(void *)(v10 + 14904) = pthread_self();
    goto LABEL_22;
  }
  if (!*(void *)(v10 + 16 * v13 + 14784))
  {
    uint64_t v21 = v13 - 1;
    int v22 = (uint64_t *)(v10 + 16 * v13 + 14800);
    while (v21 != 4)
    {
      uint64_t v23 = *v22;
      v22 += 2;
      ++v21;
      if (v23)
      {
        if (v21 <= 4) {
          goto LABEL_21;
        }
        goto LABEL_43;
      }
    }
    goto LABEL_43;
  }
LABEL_21:
  db_rwlock_wait(v10 + 14720, v13, 2);
LABEL_22:
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v10 + 14720));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  return result;
}

uint64_t __index_optimize_disk_space_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 14504));
  *(_DWORD *)(v2 + 14708) = 0;
  unsigned int v3 = *(pthread_override_s **)(v2 + 14680);
  *(_OWORD *)(v2 + 14680) = 0u;
  char v4 = *(_DWORD *)(v2 + 14700) != 0;
  *(unsigned char *)(v2 + 14716) = 0;
  db_rwlock_wakeup(v2 + 14504, v4, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(v2 + 14504));
  if (v3) {
    pthread_override_qos_class_end_np(v3);
  }
  uint64_t v5 = *(void *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 4696));
  *(_DWORD *)(v5 + 4900) = 0;
  uint64_t v6 = *(pthread_override_s **)(v5 + 4872);
  *(_OWORD *)(v5 + 4872) = 0u;
  char v7 = *(_DWORD *)(v5 + 4892) != 0;
  *(unsigned char *)(v5 + 4908) = 0;
  db_rwlock_wakeup(v5 + 4696, v7, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(v5 + 4696));
  if (v6) {
    pthread_override_qos_class_end_np(v6);
  }
  uint64_t v8 = *(void *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(v8 + 14720));
  *(_DWORD *)(v8 + 14924) = 0;
  signed int v9 = *(pthread_override_s **)(v8 + 14896);
  *(void *)(v8 + 14904) = 0;
  *(void *)(v8 + 14896) = 0;
  char v10 = *(_DWORD *)(v8 + 14916) != 0;
  *(unsigned char *)(v8 + 14932) = 0;
  db_rwlock_wakeup(v8 + 14720, v10, 0);
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v8 + 14720));
  if (v9) {
    uint64_t result = pthread_override_qos_class_end_np(v9);
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  return result;
}

uint64_t compactTermsCallback(unsigned int a1, unsigned __int8 *a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = uint32_map_get(*(void *)(a5 + 40), a3);
  if (!*(_DWORD *)(a5 + 76))
  {
    unint64_t v9 = 8 * result;
    *(void *)(a5 + 80) = *(void *)storageResolvePtr(*(void *)(a5 + 24) + 40, v9, 8, 1);
    char v10 = (uint64_t *)storageResolvePtr(*(void *)(a5 + 32) + 40, v9, 8, 1);
    uint64_t v11 = *v10;
    *(void *)(a5 + 88) = *v10;
    if (a1 < 2 || !v11) {
      goto LABEL_41;
    }
    if (*a2 > 3u)
    {
      char v14 = &a2[a1];
      uint64_t v15 = v14 - 6;
      if (a1 < 6) {
        uint64_t v15 = a2 + 1;
      }
      int v16 = (char)*(v14 - 1);
      if (v16 < 0) {
        goto LABEL_41;
      }
      int v18 = *(v14 - 2);
      uint64_t v17 = v14 - 2;
      if (v18 == 1 && v16 == 3) {
        --v17;
      }
      if (v17 <= v15)
      {
LABEL_20:
        if (*v17 != 1) {
          goto LABEL_41;
        }
      }
      else
      {
        while ((char)*v17 < 0)
        {
          if (--v17 <= v15)
          {
            uint64_t v17 = v15;
            goto LABEL_20;
          }
        }
        if (*v17 != 1) {
          goto LABEL_41;
        }
      }
      unsigned int v12 = v17[1];
      if ((char)v17[1] < 0)
      {
        int v20 = v17[2];
        if (((char)v17[2] & 0x80000000) == 0)
        {
          unsigned int v12 = v12 & 0x7F | (v20 << 7);
          goto LABEL_40;
        }
        int v24 = v17[3];
        if ((char)v17[3] < 0)
        {
          int v26 = v17[4];
          if ((char)v17[4] < 0)
          {
            int v28 = (char)v17[5];
            if (v28 < 0)
            {
              unsigned int v38 = __si_assert_copy_extra_2445(0, -1);
              uint64_t v39 = v38;
              unint64_t v40 = "";
              if (v38) {
                unint64_t v40 = v38;
              }
              __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v40);
              free(v39);
              if (__valid_fs(-1)) {
                uint64_t v41 = 2989;
              }
              else {
                uint64_t v41 = 3072;
              }
LABEL_64:
              *(_DWORD *)uint64_t v41 = -559038737;
              abort();
            }
            int v27 = ((v26 & 0x7F) << 21) | (v28 << 28) | ((v24 & 0x7F) << 14);
          }
          else
          {
            int v27 = ((v24 & 0x7F) << 14) | (v26 << 21);
          }
          unsigned int v22 = v27 & 0xFFFFC07F | ((v20 & 0x7F) << 7);
        }
        else
        {
          unsigned int v22 = ((v20 & 0x7F) << 7) | (v24 << 14);
        }
        goto LABEL_39;
      }
    }
    else
    {
      unsigned int v12 = a2[1];
      if (((char)a2[1] & 0x80000000) == 0) {
        goto LABEL_40;
      }
      int v13 = a2[2];
      if (((char)a2[2] & 0x80000000) == 0)
      {
        unsigned int v12 = v12 & 0x7F | (v13 << 7);
        goto LABEL_40;
      }
      int v21 = a2[3];
      if (((char)a2[3] & 0x80000000) == 0)
      {
        unsigned int v22 = ((v13 & 0x7F) << 7) | (v21 << 14);
LABEL_39:
        unsigned int v12 = v22 & 0xFFFFFF80 | v12 & 0x7F;
        goto LABEL_40;
      }
      int v23 = a2[4];
      if ((char)a2[4] < 0)
      {
        int v25 = (char)a2[5];
        if (v25 < 0)
        {
          statfs v35 = __si_assert_copy_extra_2445(0, -1);
          uint64_t v36 = v35;
          int v37 = "";
          if (v35) {
            int v37 = v35;
          }
          __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v37);
          free(v36);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        unsigned int v12 = ((v23 & 0x7F) << 21) | (v25 << 28) | ((v21 & 0x7F) << 14) | ((v13 & 0x7F) << 7) | v12 & 0x7F;
      }
      else
      {
        unsigned int v12 = ((v21 & 0x7F) << 14) | (v23 << 21) | ((v13 & 0x7F) << 7) | v12 & 0x7F;
      }
    }
LABEL_40:
    if (v12)
    {
      *(void *)(a5 + 88) = 0;
      if (*(void *)(a5 + 80))
      {
LABEL_42:
        uint64_t result = bt_mergeCallback((unsigned __int16)a1, a2, (int **)(a5 + 64));
        if (result) {
          ++*(void *)(a5 + 56);
        }
        return result;
      }
      goto LABEL_46;
    }
LABEL_41:
    if (*(void *)(a5 + 80)) {
      goto LABEL_42;
    }
LABEL_46:
    int v29 = *(unsigned char **)(a5 + 48);
    if (v29) {
      *int v29 = 1;
    }
    char v30 = __native_fsp(*(_DWORD **)(*(void *)(a5 + 8) + 376));
    int v31 = __si_assert_copy_extra_2445(*(_DWORD **)(*(void *)(a5 + 8) + 376), -1);
    uint64_t v32 = v31;
    __int16 v33 = "";
    if (v31) {
      __int16 v33 = v31;
    }
    uint64_t v34 = (const char *)(*(void *)a5 + 15463);
    if (v30)
    {
      __message_assert("%s:%u: failed assertion '%s' %s no posting for term (%s %s)", "JHContentIndex.c", 5508, "0", v33, (const char *)(*(void *)a5 + 15495), v34);
      free(v32);
      if (__valid_fsp(*(_DWORD **)(*(void *)(a5 + 8) + 376)))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    si_analytics_log_2842("%s:%u: failed assertion '%s' %s no posting for term (%s %s)", "JHContentIndex.c", 5508, "false", v33, (const char *)(*(void *)a5 + 15495), v34);
    free(v32);
    uint64_t v41 = 2816;
    goto LABEL_64;
  }
  return result;
}

void si_analytics_log_2842(char *a1, ...)
{
  va_start(va, a1);
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  string[0] = 0;
  va_copy((va_list)&string[1], va);
  vasprintf(string, a1, va);
  SISetCrashCStr(string[0]);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)keys = 136315138;
    *(char **)&keys[4] = string[0];
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "%s", keys, 0xCu);
  }
  *(void *)keys = "crash_string";
  xpc_object_t v1 = xpc_string_create(string[0]);
  xpc_object_t values = v1;
  xpc_object_t v2 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  analytics_send_event();
  xpc_release(v2);
  xpc_release(v1);
  free(string[0]);
}

void bit_vector_release(void *a1)
{
  if (a1)
  {
    xpc_object_t v2 = (const void *)a1[2];
    if (v2) {
      CFRelease(v2);
    }
    free(a1);
  }
}

_DWORD *reorderTermIdCallback(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  int v7 = *(_DWORD *)(a5 + 8);
  *(_DWORD *)(a5 + 8) = v7 + 1;
  if (uint32_map_get(*(void *)a5, a3))
  {
    if ((__native_fs() & 1) == 0)
    {
      int v16 = __si_assert_copy_extra_2445(0, -1);
      uint64_t v17 = v16;
      int v18 = "";
      if (v16) {
        int v18 = v16;
      }
      si_analytics_log_2842("%s:%u: failed assertion '%s' %s duplicate term id (%d)", "JHContentIndex.c", 5530, "0 == uint32_map_get(ctx->newTermIds, termId)", v18, a3);
      free(v17);
      uint64_t v12 = 2816;
LABEL_16:
      *(_DWORD *)uint64_t v12 = -559038737;
      abort();
    }
    if (uint32_map_get(*(void *)a5, a3))
    {
      int v13 = __si_assert_copy_extra_2445(0, -1);
      char v14 = v13;
      uint64_t v15 = "";
      if (v13) {
        uint64_t v15 = v13;
      }
      __message_assert("%s:%u: failed assertion '%s' %s duplicate term id (%d)", "JHContentIndex.c", 5530, "0 == uint32_map_get(ctx->newTermIds, termId)", v15, a3);
      free(v14);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
  }
  if (!a3 || *(_DWORD *)(*(void *)a5 + 4416) <= a3)
  {
    unint64_t v9 = __si_assert_copy_extra(0);
    char v10 = v9;
    uint64_t v11 = "";
    if (v9) {
      uint64_t v11 = v9;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1549, "position && position < inMap->count", v11);
    free(v10);
    if (__valid_fs(-1)) {
      uint64_t v12 = 2989;
    }
    else {
      uint64_t v12 = 3072;
    }
    goto LABEL_16;
  }
  uint64_t result = (_DWORD *)storageResolvePtr(*(void *)a5, 4 * a3, 4, 1);
  *uint64_t result = v7;
  return result;
}

void _excCompactCleanup(uint64_t a1)
{
  storageClose(a1);
  bt_freeTrie(a1 + 4440);
  freePayload(a1 + 13976);
  freePayload(a1 + 9256);
  xpc_object_t v2 = *(void **)(a1 + 4424);
  if (v2)
  {
    storageClose((uint64_t)(v2 + 1));
    unsigned int v3 = (const void *)v2[550];
    if (v3) {
      CFRelease(v3);
    }
    free(v2);
    *(void *)(a1 + 4424) = 0;
  }
  uint64_t v4 = *(void *)(a1 + 4432);
  if (v4)
  {
    IVFVectorIndex_s::~IVFVectorIndex_s((IVFVectorIndex_s *)(v4 + 8));
    MEMORY[0x1C1881000](v4, 0x1032C400935D19DLL);
    *(void *)(a1 + 4432) = 0;
  }
}

uint64_t _excCompactMatch(uint64_t a1, unint64_t a2)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *(unsigned int *)(a1 + 248);
  if ((int)v4 >= 1)
  {
    uint64_t v5 = 34;
    do
    {
      uint64_t v6 = *(void **)(a1 + 8 * v5);
      if (v6 && (v7 = v6[1], v7 + 1 >= 2) && v7 <= a2 && (uint64_t v9 = v6[2], v7 - v9 + v6[3] > a2)) {
        uint64_t v8 = a2 - v7 + v9;
      }
      else {
        uint64_t v8 = -1;
      }
      if (v5 - 33 >= v4) {
        break;
      }
      ++v5;
    }
    while (v8 == -1);
    if (v8 != -1) {
      return 1;
    }
  }
  unint64_t v10 = *(void *)(a1 + 4456);
  if (v10 + 1 >= 2 && v10 <= a2)
  {
    uint64_t v46 = *(void *)(a1 + 4480);
    if (v10 + v46 > a2)
    {
      uint64_t v47 = *(void *)(a1 + 4552);
      int v48 = "bases";
LABEL_80:
      log_map_access_error(a2, v10, v46, (uint64_t)v48, v47);
      return 1;
    }
  }
  unint64_t v10 = *(void *)(a1 + 4448);
  if (v10 + 1 >= 2 && v10 <= a2)
  {
    uint64_t v46 = *(unsigned int *)(a1 + 4588);
    if (v10 + 1028 * v46 > a2)
    {
      uint64_t v47 = *(void *)(a1 + 9016);
      int v48 = "fat bases";
      goto LABEL_80;
    }
  }
  unint64_t v13 = *(unsigned int *)(a1 + 4848);
  if ((int)v13 >= 1)
  {
    uint64_t v14 = 609;
    do
    {
      uint64_t v15 = *(void **)(a1 + 8 * v14);
      if (v15 && (unint64_t v16 = v15[1], v16 + 1 >= 2) && v16 <= a2 && (v17 = v15[2], v16 - v17 + v15[3] > a2)) {
        uint64_t v18 = a2 - v16 + v17;
      }
      else {
        uint64_t v18 = -1;
      }
      if (v14 - 608 >= v13) {
        break;
      }
      ++v14;
    }
    while (v18 == -1);
    if (v18 != -1)
    {
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      *(_OWORD *)std::string __str = 0u;
      long long v50 = 0u;
      int v19 = snprintf(__str, 0xFFuLL, "c:%d s:%lld", v13, *(void *)(a1 + 4824));
      if (*(int *)(a1 + 4848) >= 1 && v19 <= 0xFE)
      {
        uint64_t v20 = 0;
        int v21 = &__str[v19];
        size_t v22 = 255 - v19;
        do
        {
          snprintf(v21, v22, "%d:(mem:%p so:%lld eo:%lld)", v20, *(const void **)(*(void *)(a1 + 4872 + 8 * v20) + 8), *(void *)(*(void *)(a1 + 4872 + 8 * v20) + 16), *(void *)(*(void *)(a1 + 4872 + 8 * v20) + 24));
          ++v20;
        }
        while (v20 < *(int *)(a1 + 4848));
      }
      uint64_t v23 = *(void *)(a1 + 4816);
      int v24 = "flat\n";
LABEL_73:
      log_map_access_error_mini((uint64_t)v24, a2, (uint64_t)__str, v23);
      return 1;
    }
  }
  unint64_t v25 = *(unsigned int *)(a1 + 9544);
  if ((int)v25 >= 1)
  {
    uint64_t v26 = 1196;
    do
    {
      int v27 = *(void **)(a1 + 8 * v26);
      if (v27 && (unint64_t v28 = v27[1], v28 + 1 >= 2) && v28 <= a2 && (v30 = v27[2], v28 - v30 + v27[3] > a2)) {
        uint64_t v29 = a2 - v28 + v30;
      }
      else {
        uint64_t v29 = -1;
      }
      if (v26 - 1195 >= v25) {
        break;
      }
      ++v26;
    }
    while (v29 == -1);
    if (v29 != -1)
    {
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      *(_OWORD *)std::string __str = 0u;
      long long v50 = 0u;
      int v31 = snprintf(__str, 0xFFuLL, "c:%d s:%lld", v25, *(void *)(a1 + 9520));
      if (*(int *)(a1 + 9544) >= 1 && v31 <= 0xFE)
      {
        uint64_t v32 = 0;
        __int16 v33 = &__str[v31];
        size_t v34 = 255 - v31;
        do
        {
          snprintf(v33, v34, "%d:(mem:%p so:%lld eo:%lld)", v32, *(const void **)(*(void *)(a1 + 9568 + 8 * v32) + 8), *(void *)(*(void *)(a1 + 9568 + 8 * v32) + 16), *(void *)(*(void *)(a1 + 9568 + 8 * v32) + 24));
          ++v32;
        }
        while (v32 < *(int *)(a1 + 9544));
      }
      uint64_t v23 = *(void *)(a1 + 9512);
      int v24 = "termIdStore\n";
      goto LABEL_73;
    }
  }
  unint64_t v35 = *(unsigned int *)(a1 + 14264);
  if ((int)v35 >= 1)
  {
    uint64_t v36 = 1786;
    do
    {
      int v37 = *(void **)(a1 + 8 * v36);
      if (v37 && (unint64_t v38 = v37[1], v38 + 1 >= 2) && v38 <= a2 && (v40 = v37[2], v38 - v40 + v37[3] > a2)) {
        uint64_t v39 = a2 - v38 + v40;
      }
      else {
        uint64_t v39 = -1;
      }
      if (v36 - 1785 >= v35) {
        break;
      }
      ++v36;
    }
    while (v39 == -1);
    if (v39 != -1)
    {
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      *(_OWORD *)std::string __str = 0u;
      long long v50 = 0u;
      int v41 = snprintf(__str, 0xFFuLL, "c:%d s:%lld", v35, *(void *)(a1 + 14240));
      if (*(int *)(a1 + 14264) >= 1 && v41 <= 0xFE)
      {
        uint64_t v42 = 0;
        int v43 = &__str[v41];
        size_t v44 = 255 - v41;
        do
        {
          snprintf(v43, v44, "%d:(mem:%p so:%lld eo:%lld)", v42, *(const void **)(*(void *)(a1 + 14288 + 8 * v42) + 8), *(void *)(*(void *)(a1 + 14288 + 8 * v42) + 16), *(void *)(*(void *)(a1 + 14288 + 8 * v42) + 24));
          ++v42;
        }
        while (v42 < *(int *)(a1 + 14264));
      }
      uint64_t v23 = *(void *)(a1 + 14232);
      int v24 = "positions header table\n";
      goto LABEL_73;
    }
  }
  return 0;
}

void _initPayload(char *a1, int a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    bzero(a1, 0x1270uLL);
    *((_DWORD *)a1 + 1124) = -1;
    memset(&v3, 0, sizeof(v3));
    pthread_rwlockattr_init(&v3);
    pthread_rwlock_init((pthread_rwlock_t *)(a1 + 4520), &v3);
    pthread_rwlockattr_destroy(&v3);
    bzero(a1 + 40, 0x1160uLL);
  }
  else
  {
    *((_DWORD *)a1 + 1124) = -1;
    memset(&v3, 0, sizeof(v3));
    pthread_rwlockattr_init(&v3);
    pthread_rwlock_init((pthread_rwlock_t *)(a1 + 4520), &v3);
    pthread_rwlockattr_destroy(&v3);
  }
}

uint64_t initPayload(uint64_t a1, uint64_t a2, uint64_t a3, char a4, int a5, int a6, void *a7)
{
  uint64_t v11 = a2;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  unint64_t v13 = (unsigned char *)(a1 + 4516);
  *(void *)(a1 + 4488) = a2;
  uint64_t v14 = (int8x16_t *)(a1 + 40);
  *(void *)(a1 + 256) = a3;
  *(unsigned char *)(a1 + 4517) = a5;
  off_t v15 = *(void *)(a1 + 24);
  if (v15)
  {
    if (a4)
    {
LABEL_8:
      if (!a3) {
        return 1;
      }
      unint64_t v16 = v14;
      uint64_t v17 = a3;
      int v18 = 0;
      char v19 = a4;
      goto LABEL_21;
    }
    if (a5 && v11)
    {
      *(_WORD *)(v11 + 56) |= 4u;
      uint64_t v11 = *(void *)(a1 + 4488);
      off_t v15 = *(void *)(a1 + 24);
    }
    if (fd_truncate(v11, v15) != -1)
    {
      *unint64_t v13 = 1;
      goto LABEL_8;
    }
    int v25 = *__error();
    uint64_t v26 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      int v27 = *__error();
      *(_DWORD *)uint64_t v30 = 136315650;
      *(void *)&uint8_t v30[4] = "initPayload";
      __int16 v31 = 1024;
      int v32 = 117;
      __int16 v33 = 1024;
      int v34 = v27;
LABEL_30:
      _os_log_error_impl(&dword_1BD672000, v26, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate err: %d", v30, 0x18u);
      goto LABEL_27;
    }
    goto LABEL_27;
  }
  if (a4) {
    return 0;
  }
  if (a5 && v11)
  {
    *(_WORD *)(v11 + 56) |= 4u;
    uint64_t v11 = *(void *)(a1 + 4488);
  }
  *(void *)uint64_t v30 = 0;
  uint64_t v21 = _fd_acquire_fd(v11, v30);
  if (v21 != -1)
  {
    int v22 = v21;
    int v23 = _fd_ftruncate_guarded(v21, (uint64_t)v30, 0);
    int v24 = *__error();
    *(_WORD *)(v11 + 56) &= ~2u;
    _fd_release_fd((_DWORD *)v11, v22, 0, *(uint64_t *)v30);
    if (v23 == -1) {
      *__error() = v24;
    }
  }
  if (fd_truncate(*(void *)(a1 + 4488), 4096) == -1)
  {
    int v25 = *__error();
    uint64_t v26 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      int v29 = *__error();
      *(_DWORD *)uint64_t v30 = 136315650;
      *(void *)&uint8_t v30[4] = "initPayload";
      __int16 v31 = 1024;
      int v32 = 101;
      __int16 v33 = 1024;
      int v34 = v29;
      goto LABEL_30;
    }
LABEL_27:
    unint64_t v28 = __error();
    uint64_t result = 0;
    int *v28 = v25;
    return result;
  }
  *unint64_t v13 = 1;
  *(_OWORD *)a1 = xmmword_1BDA82400;
  *(int64x2_t *)(a1 + 24) = vdupq_n_s64(0x1000uLL);
  unint64_t v16 = v14;
  uint64_t v17 = a3;
  int v18 = 1;
  char v19 = 0;
LABEL_21:
  return termIDStoreInit(v16, v17, v18, v19, a6, a7);
}

uint64_t freePayload(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int v2 = *__error();
  pthread_rwlockattr_t v3 = _SILogForLogForCategory(10);
  os_log_type_t v4 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v3, v4))
  {
    unint64_t v5 = *(void *)(a1 + 24);
    double v6 = (double)(*(void *)a1 + v5 - *(void *)(a1 + 8)) * 100.0 / (double)v5;
    int v10 = 134218240;
    unint64_t v11 = v5 >> 10;
    __int16 v12 = 2048;
    double v13 = v6;
    _os_log_impl(&dword_1BD672000, v3, v4, "Payloads: %lluKB %f", (uint8_t *)&v10, 0x16u);
  }
  *__error() = v2;
  int v7 = *(_DWORD *)(a1 + 4496);
  if (v7 != -1)
  {
    _fd_release_fd(*(_DWORD **)(a1 + 4488), v7, 0, *(void *)(a1 + 4504));
    *(_DWORD *)(a1 + 4496) = -1;
  }
  fd_release(*(atomic_uint **)(a1 + 4488));
  *(void *)(a1 + 4488) = 0;
  storageClose(a1 + 40);
  storageClose(a1 + 40);
  uint64_t v8 = *(const void **)(a1 + 4480);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 4480) = 0;
  }
  *(_OWORD *)(a1 + 4464) = 0u;
  return pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 4520));
}

uint64_t syncPayload(uint64_t a1)
{
  int v2 = (unsigned char *)(a1 + 4516);
  uint64_t v3 = *(void *)(a1 + 4488);
  if (!*(unsigned char *)(a1 + 4516))
  {
    if (_gSystemStatusBool)
    {
      pthread_mutex_lock(&_gSystemStatusLock);
      while (_gSystemStatusBool)
        pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
      pthread_mutex_unlock(&_gSystemStatusLock);
    }
    uint64_t v17 = 0;
    uint64_t v8 = _fd_acquire_fd(v3, &v17);
    if (v8 != -1)
    {
      int v9 = v8;
      int v10 = prot_fsync(v8, 0);
      _fd_release_fd((_DWORD *)v3, v9, 0, v17);
      if (v10 != -1) {
        goto LABEL_19;
      }
    }
    return *__error();
  }
  int v4 = *(unsigned __int8 *)(a1 + 4517);
  if (_gSystemStatusBool)
  {
    pthread_mutex_lock(&_gSystemStatusLock);
    while (_gSystemStatusBool)
      pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
    pthread_mutex_unlock(&_gSystemStatusLock);
  }
  uint64_t v17 = 0;
  uint64_t v5 = _fd_acquire_fd(v3, &v17);
  if (v5 == -1) {
    return *__error();
  }
  int v6 = v5;
  BOOL v7 = v4 && (*(_WORD *)(v3 + 56) & 8) == 0;
  int v11 = prot_fsync(v5, v7);
  _fd_release_fd((_DWORD *)v3, v6, 0, v17);
  if (v11 == -1) {
    return *__error();
  }
  *int v2 = 0;
LABEL_19:
  uint64_t v12 = storageSyncPages(a1 + 40, a1 + 4464, *MEMORY[0x1E4F14B00]);
  double v13 = *(_DWORD **)(a1 + 256);
  if (v13)
  {
    if (_gSystemStatusBool)
    {
      pthread_mutex_lock(&_gSystemStatusLock);
      while (_gSystemStatusBool)
        pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
      pthread_mutex_unlock(&_gSystemStatusLock);
    }
    uint64_t v17 = 0;
    uint64_t v14 = _fd_acquire_fd((uint64_t)v13, &v17);
    if (v14 != -1)
    {
      int v15 = v14;
      prot_fsync(v14, 0);
      _fd_release_fd(v13, v15, 0, v17);
    }
  }
  return v12;
}

uint64_t expandPayload(uint64_t a1, uint64_t (*a2)(uint64_t), uint64_t a3)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = 2 * v4;
  *(void *)(a1 + 24) = 2 * v4;
  *(void *)a1 = v4;
  *(void *)(a1 + 8) = 2 * v4;
  int v6 = (void *)(a1 + 4504);
  if (a2)
  {
    uint64_t v7 = a3;
    uint64_t v8 = a2;
    while (1)
    {
      off_t v9 = *(void *)(a1 + 24);
      uint64_t v10 = _fd_acquire_fd(*(void *)(a1 + 4488), v6);
      off_t v11 = lseek(v10, 0, 2);
      if (v9 <= v11 || (int v12 = ci_preallocate(v10, v9 - v11), v12 == -1))
      {
        int v13 = fd_truncate(*(void *)(a1 + 4488), *(void *)(a1 + 24));
      }
      else
      {
        int v13 = v12;
        uint64_t v14 = 0;
        off_t v15 = v9 - 1;
        unint64_t v16 = "";
        unint64_t v17 = 1;
        while (1)
        {
          while (1)
          {
            unint64_t v18 = guarded_pwrite_np();
            if ((v18 & 0x8000000000000000) == 0) {
              break;
            }
            uint64_t v19 = g_prot_error_callback;
            if (g_prot_error_callback)
            {
              uint64_t v20 = __error();
              if ((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v19 + 16))(v19, v10, *v20, 5))continue; {
            }
              }
            int v13 = -1;
            goto LABEL_15;
          }
          v14 += v18;
          BOOL v42 = v17 > v18;
          v17 -= v18;
          if (!v42) {
            break;
          }
          v16 += v18;
          v15 += v18;
        }
        if (v14 != 1) {
          int v13 = -1;
        }
LABEL_15:
        uint64_t v8 = a2;
        uint64_t v7 = a3;
      }
      _fd_release_fd(*(_DWORD **)(a1 + 4488), v10, 0, *(void *)(a1 + 4504));
      if (v13 != -1) {
        break;
      }
      uint64_t v21 = *__error();
      if (v21 != 28) {
        goto LABEL_37;
      }
      if ((v8(v7) & 1) == 0)
      {
        uint64_t v21 = 28;
        goto LABEL_37;
      }
    }
LABEL_35:
    uint64_t v21 = 0;
    *(unsigned char *)(a1 + 4516) = 1;
    return v21;
  }
  uint64_t v22 = _fd_acquire_fd(*(void *)(a1 + 4488), v6);
  off_t v23 = lseek(v22, 0, 2);
  if (v5 <= v23 || (int v24 = ci_preallocate(v22, v5 - v23), v24 == -1))
  {
    int v33 = fd_truncate(*(void *)(a1 + 4488), *(void *)(a1 + 24));
  }
  else
  {
    int v25 = v24;
    uint64_t v26 = 0;
    uint64_t v27 = v5 - 1;
    unint64_t v28 = 1;
    int v29 = "";
    while (1)
    {
      while (1)
      {
        unint64_t v30 = guarded_pwrite_np();
        if ((v30 & 0x8000000000000000) == 0) {
          break;
        }
        uint64_t v31 = g_prot_error_callback;
        if (g_prot_error_callback)
        {
          int v32 = __error();
          if ((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v31 + 16))(v31, v22, *v32, 5))continue; {
        }
          }
        int v33 = -1;
        goto LABEL_34;
      }
      v26 += v30;
      BOOL v42 = v28 > v30;
      v28 -= v30;
      if (!v42) {
        break;
      }
      v29 += v30;
      v27 += v30;
    }
    if (v26 == 1) {
      int v33 = v25;
    }
    else {
      int v33 = -1;
    }
  }
LABEL_34:
  _fd_release_fd(*(_DWORD **)(a1 + 4488), v22, 0, *(void *)(a1 + 4504));
  if (v33 != -1) {
    goto LABEL_35;
  }
  uint64_t v21 = *__error();
LABEL_37:
  bzero(v56, 0x400uLL);
  int v34 = *__error();
  uint64_t v35 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
  {
    int v37 = *(_DWORD **)(a1 + 4488);
    *(void *)statfs buf = 0;
    int v38 = _fd_acquire_fd((uint64_t)v37, buf);
    uint64_t v39 = 0;
    if (v38 != -1)
    {
      int v40 = v38;
      uint64_t v39 = v56;
      int v41 = fcntl(v38, 50, v56);
      if (v56[0]) {
        BOOL v42 = v41 < 0;
      }
      else {
        BOOL v42 = 1;
      }
      if (v42) {
        uint64_t v39 = 0;
      }
      _fd_release_fd(v37, v40, 0, *(uint64_t *)buf);
    }
    int v43 = "";
    uint64_t v44 = *(void *)(a1 + 24);
    if (v39) {
      int v43 = v39;
    }
    *(_DWORD *)statfs buf = 136316162;
    *(void *)&uint8_t buf[4] = "expandPayload";
    __int16 v48 = 1024;
    int v49 = 207;
    __int16 v50 = 2080;
    long long v51 = v43;
    __int16 v52 = 2048;
    uint64_t v53 = v44;
    __int16 v54 = 1024;
    int v55 = v21;
    _os_log_error_impl(&dword_1BD672000, v35, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate(%s, %lld) err: %d", buf, 0x2Cu);
  }
  *__error() = v34;
  return v21;
}

void *PayloadWriteBufferInit(void *a1, _DWORD *a2)
{
  uint64_t result = malloc_type_malloc(0x10000uLL, 0x2318F62BuLL);
  *a1 = result;
  if (!result)
  {
    int v6 = __si_assert_copy_extra_329();
    uint64_t v7 = v6;
    uint64_t v8 = "";
    if (v6) {
      uint64_t v8 = v6;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHPayload.c", 235, "wb->buffer", v8);
    free(v7);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (*((void *)a2 + 1) - *(void *)a2 >= 0x10000uLL) {
    uint64_t v5 = 0x10000;
  }
  else {
    uint64_t v5 = (a2[2] - *a2);
  }
  a1[1] = 0x10000;
  a1[2] = v5;
  a1[3] = v5;
  a1[4] = 0;
  return result;
}

int *PayloadWriteBufferWrite(int *result, void *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)result + 2);
  uint64_t v3 = *((void *)result + 3);
  unint64_t v4 = v2 - v3;
  if (v2 != v3)
  {
    if (a2[1] < *a2)
    {
      off_t v23 = __si_assert_copy_extra_329();
      int v24 = v23;
      int v25 = "";
      if (v23) {
        int v25 = v23;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "JHPayload.c", 253, "pd->payloadIndex >= pd->payloadLimit", v25);
      free(v24);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    int v6 = result;
    uint64_t v7 = _fd_acquire_fd(a2[561], a2 + 563);
    if (v7 == -1)
    {
      *((void *)v6 + 4) = *__error();
      int v16 = *__error();
      unint64_t v17 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        uint64_t v18 = *((void *)v6 + 4);
        *(_DWORD *)statfs buf = 136315650;
        uint64_t v27 = "PayloadWriteBufferWrite";
        __int16 v28 = 1024;
        int v29 = 257;
        __int16 v30 = 2048;
        uint64_t v31 = v18;
        _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: open error; %ld", buf, 0x1Cu);
      }
      uint64_t result = __error();
      *uint64_t result = v16;
    }
    else
    {
      uint64_t v8 = v7;
      uint64_t v9 = 0;
      uint64_t v10 = *(void *)v6 + *((void *)v6 + 3);
      for (uint64_t i = a2[1]; ; i += v12)
      {
        while (1)
        {
          unint64_t v12 = guarded_pwrite_np();
          if ((v12 & 0x8000000000000000) == 0) {
            break;
          }
          uint64_t v13 = g_prot_error_callback;
          if (g_prot_error_callback)
          {
            uint64_t v14 = __error();
            if ((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v13 + 16))(v13, v8, *v14, 5))continue; {
          }
            }
          goto LABEL_16;
        }
        v9 += v12;
        BOOL v15 = v4 > v12;
        v4 -= v12;
        if (!v15) {
          break;
        }
        v10 += v12;
      }
      if (v9 != -1) {
        goto LABEL_19;
      }
LABEL_16:
      *((void *)v6 + 4) = *__error();
      int v19 = *__error();
      uint64_t v20 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        uint64_t v22 = *((void *)v6 + 4);
        *(_DWORD *)statfs buf = 136315650;
        uint64_t v27 = "PayloadWriteBufferWrite";
        __int16 v28 = 1024;
        int v29 = 261;
        __int16 v30 = 2048;
        uint64_t v31 = v22;
        _os_log_error_impl(&dword_1BD672000, v20, OS_LOG_TYPE_ERROR, "%s:%d: pwrite error; %ld", buf, 0x1Cu);
      }
      *__error() = v19;
LABEL_19:
      uint64_t result = _fd_release_fd((_DWORD *)a2[561], v8, 0, a2[563]);
    }
    if (a2[1] - *a2 >= *((void *)v6 + 1)) {
      uint64_t v21 = *((void *)v6 + 1);
    }
    else {
      uint64_t v21 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    }
    *((void *)v6 + 2) = v21;
    *((void *)v6 + 3) = v21;
  }
  return result;
}

int *PayloadWritePulseHeader(int *result, void *a2, uint64_t a3, int a4)
{
  if (a3 && !*((void *)result + 4))
  {
    uint64_t v4 = a2[1];
    if ((unint64_t)(v4 - *a2) <= 0x13)
    {
      uint64_t v8 = __si_assert_copy_extra_329();
      uint64_t v9 = v8;
      uint64_t v10 = "";
      if (v8) {
        uint64_t v10 = v8;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "JHPayload.c", 274, "pd->payloadIndex - pd->payloadLimit >= sizeof(PulseHeaderDisk)", v10);
      free(v9);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    LODWORD(v13) = -1;
    *(void *)((char *)&v13 + 4) = a3;
    HIDWORD(v13) = a4;
    int v14 = -1;
    uint64_t v5 = *((void *)result + 3);
    if (v5 < 21)
    {
      off_t v11 = a2;
      unint64_t v12 = result;
      _PayloadWriteData_2914(result, a2, (char *)&v13, 20);
      a2 = v11;
      uint64_t result = v12;
    }
    else
    {
      a2[1] = v4 - 20;
      *((void *)result + 3) = v5 - 20;
      uint64_t v6 = *(void *)result + v5 - 20;
      long long v7 = v13;
      *(_DWORD *)(v6 + 16) = v14;
      *(_OWORD *)uint64_t v6 = v7;
    }
    return PayloadWriteBufferWrite(result, a2);
  }
  return result;
}

int *_PayloadWriteData_2914(int *result, void *a2, char *a3, int64_t a4)
{
  uint64_t v5 = result;
  uint64_t v6 = &a3[a4];
  if (a4)
  {
    int64_t v7 = a4;
    do
    {
      if (*((void *)v5 + 4)) {
        break;
      }
      int64_t v9 = *((void *)v5 + 3);
      if (v7 >= v9) {
        size_t v10 = *((void *)v5 + 3);
      }
      else {
        size_t v10 = v7;
      }
      a2[1] -= v10;
      size_t v11 = v9 - v10;
      *((void *)v5 + 3) = v11;
      v6 -= v10;
      uint64_t result = (int *)memcpy((void *)(*(void *)v5 + v11), v6, v10);
      if (!*((void *)v5 + 3)) {
        uint64_t result = PayloadWriteBufferWrite(v5, a2);
      }
      v7 -= v10;
    }
    while (v7);
  }
  if (v6 != a3 && !*((void *)v5 + 4))
  {
    unint64_t v12 = __si_assert_copy_extra_329();
    long long v13 = v12;
    int v14 = "";
    if (v12) {
      int v14 = v12;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHPayload.h", 146, "src == ptr || wb->err", v14);
    free(v13);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return result;
}

uint64_t growPayloadData(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v20 = v2;
  uint64_t v21 = v3;
  uint64_t v4 = (uint64_t *)v1;
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  bzero(v23, 0x1000uLL);
  uint64_t v5 = *v4;
  unint64_t v6 = v4[1] - *v4;
  uint64_t v22 = (uint64_t)v4;
  for (uint64_t i = _fd_acquire_fd(v4[561], v4 + 563); v6; v6 -= v8)
  {
    if (v6 >= 0x1000) {
      uint64_t v8 = 4096;
    }
    else {
      uint64_t v8 = v6;
    }
    int64_t v9 = v23;
    unint64_t v10 = v8;
    uint64_t v11 = v5;
    do
    {
      while (1)
      {
        unint64_t v12 = guarded_pwrite_np();
        if ((v12 & 0x8000000000000000) != 0) {
          break;
        }
        BOOL v15 = v10 > v12;
        v10 -= v12;
        if (!v15) {
          goto LABEL_3;
        }
        v9 += v12;
        v11 += v12;
      }
      uint64_t v13 = g_prot_error_callback;
      if (!g_prot_error_callback) {
        break;
      }
      int v14 = __error();
    }
    while (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v13 + 16))(v13, i, *v14, 5) & 1) != 0);
LABEL_3:
    v5 += v8;
  }
  _fd_release_fd(*(_DWORD **)(v22 + 4488), i, 0, *(void *)(v22 + 4504));
  if (v5 != *(void *)(v22 + 8))
  {
    unint64_t v17 = __si_assert_copy_extra_329();
    uint64_t v18 = v17;
    int v19 = "";
    if (v17) {
      int v19 = v17;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHPayload.c", 375, "pos == pd->payloadIndex", v19);
    free(v18);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return expandPayload(v22, v20, v21);
}

uint64_t compressPostings(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v180 = v10;
  unsigned int v166 = v11;
  uint64_t v13 = v12;
  unint64_t v15 = v14;
  uint64_t v178 = v16;
  unsigned int v182 = v17;
  unsigned int v19 = v18;
  uint64_t v20 = v9;
  uint64_t v200 = *MEMORY[0x1E4F143B8];
  uint64_t v195 = 0;
  *(_OWORD *)uint64_t v193 = 0u;
  long long v194 = 0u;
  long long v197 = 0uLL;
  v196[1] = 0x8000;
  os_log_type_t v175 = (char *)malloc_type_malloc(0x8000uLL, 0x9D8A9808uLL);
  v196[0] = v175;
  PayloadWriteBufferInit(v193, (_DWORD *)v20);
  uint64_t v21 = *(void *)(v20 + 8);
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v168 = v20 + 40;
  uint64_t v177 = v13;
  uint64_t v181 = v20;
  int v23 = 0;
  if (v15)
  {
    unsigned int v24 = *(_DWORD *)(v20 + 4456);
    int v25 = (void *)(v13 + 24 * v15 - 8);
    unint64_t v26 = v15;
    do
    {
      uint64_t v28 = *((unsigned int *)v25 - 4);
      if (v24 <= v28)
      {
        uint64_t v27 = 0;
        ++v23;
      }
      else
      {
        uint64_t v27 = *(void *)storageResolvePtr(v168, 8 * v28, 8, 1);
      }
      *int v25 = v27;
      v25 -= 3;
      --v26;
    }
    while (v26);
  }
  int v29 = *__error();
  __int16 v30 = _SILogForLogForCategory(10);
  os_log_type_t v31 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v30, v31))
  {
    float v32 = CFAbsoluteTimeGetCurrent() - Current;
    *(_DWORD *)statfs buf = 134217984;
    *(double *)&uint8_t buf[4] = v32;
    _os_log_impl(&dword_1BD672000, v30, v31, "resolve term id offsets: %f", buf, 0xCu);
  }
  int v33 = __error();
  *int v33 = v29;
  if (v23) {
    si_analytics_log_2923((uint64_t)v33, v34, v35, v36, v37, v38, v39, v40, v23);
  }
  double v41 = CFAbsoluteTimeGetCurrent();
  madvise(v182, 12 * v19, 3);
  int v42 = *__error();
  int v43 = _SILogForLogForCategory(10);
  os_log_type_t v44 = 2 * (dword_1E9FC90CC < 4);
  uint64_t v45 = v177;
  if (os_log_type_enabled(v43, v44))
  {
    float v46 = CFAbsoluteTimeGetCurrent() - v41;
    *(_DWORD *)statfs buf = 134217984;
    *(double *)&uint8_t buf[4] = v46;
    _os_log_impl(&dword_1BD672000, v43, v44, "make hot: %f", buf, 0xCu);
  }
  *__error() = v42;
  double v47 = CFAbsoluteTimeGetCurrent();
  uint64_t v192 = 0;
  *(_OWORD *)long long v190 = 0u;
  *(_OWORD *)long long v191 = 0u;
  long long v188 = 0u;
  *(_OWORD *)uint64_t v189 = 0u;
  *(_OWORD *)uint64_t v187 = 0u;
  LODWORD(v189[1]) = 16;
  v189[0] = malloc_type_malloc(0x80uLL, 0x2004093837F09uLL);
  LODWORD(v190[1]) = 16;
  v190[0] = malloc_type_malloc(0x80uLL, 0x100004000313F17uLL);
  LODWORD(v191[1]) = 16;
  __int16 v48 = malloc_type_malloc(0x10uLL, 0x100004077774924uLL);
  unint64_t v49 = 0;
  unsigned int v50 = 0;
  v191[0] = v48;
  *(_OWORD *)unsigned int v185 = 0u;
  long long v186 = 0u;
  unint64_t v51 = v15 - 1;
  uint64_t v52 = v181;
  if (!v15 || v195) {
    goto LABEL_136;
  }
  unint64_t v173 = v15;
  unint64_t v49 = 0;
  uint64_t v53 = 0;
  unint64_t v167 = v51;
  do
  {
    unsigned int v50 = *(_DWORD *)(v45 + 24 * v49);
    unsigned int v179 = v50;
    if (v49 != v51)
    {
      unsigned int v50 = *(_DWORD *)(v45 + 24 * (v49 + 1));
      if (v179 <= v50)
      {
        uint64_t v72 = 0;
        ++v49;
        continue;
      }
    }
    __int16 v54 = (void *)(v45 + 24 * v49);
    unint64_t v56 = v54[2];
    v54 += 2;
    unint64_t v55 = v56;
    uint64_t v57 = (char *)*(v54 - 1);
    long long v197 = xmmword_1BDA82410;
    LODWORD(v187[1]) = 0;
    *(void *)&long long v188 = 0;
    uint64_t v192 = 0;
    DWORD2(v188) = -1;
    int v171 = v54;
    unint64_t v172 = v49;
    unsigned int v174 = v50;
    if (*(_DWORD *)v57 >= 2u)
    {
      do
      {
        long long v62 = &v182[12 * (*(_DWORD *)v57 >> 1)];
        if (*(_DWORD *)v57 >= 2u) {
          _X28 = &v182[12 * (*(_DWORD *)v57 >> 1)];
        }
        else {
          _X28 = 0;
        }
        __asm { PRFM            #0, [X28] }
        if (*(_DWORD *)v57)
        {
          unint64_t v70 = *((void *)v57 + 1);
          if (*((_DWORD *)v57 + 1) == 2) {
            int v71 = 1;
          }
          else {
            int v71 = 2;
          }
          checkChangeHolderIntegrity((uint64_t)v185);
          changesHandleUpdate((uint64_t)v185, v70, v71);
          if (v185[1] && !*((void *)&v186 + 1))
          {
            *(_OWORD *)v185[0] = *((_OWORD *)v185[0] + v186 - (unint64_t)v185[1]);
            *((void *)&v186 + 1) = 1;
          }
          checkChangeHolderIntegrity((uint64_t)v185);
        }
        else if (!v185[1] {
               || (uint64_t v69 = *((unsigned int *)v57 + 2), (unint64_t)(v69 + v178) > *(void *)v185[0])
        }
               || (merge_checkAgainstUpdates((uint64_t)v187, (uint64_t)v185, v69, v178) & 1) == 0)
        {
          packContextAppend((uint64_t)v187, *((_DWORD *)v57 + 2));
        }
        uint64_t v57 = v62;
      }
      while (_X28);
      merge_checkAgainstUpdates1((uint64_t)v187, (unint64_t **)v185, v166, v178);
      uint64_t v73 = packContextFinalize((uint64_t)v196);
      unsigned int v50 = v174;
    }
    else
    {
      if (*(_DWORD *)v57)
      {
        unsigned int v123 = v50;
        uint64_t updated = packUpdateLink((uint64_t)v175, v55, *(void *)(v57 + 4), *((_DWORD *)v57 + 3));
        unsigned int v50 = v123;
        *(void *)&long long v197 = updated;
      }
      else
      {
        unint64_t v58 = *(void *)(v57 + 4);
        unint64_t v59 = 2 * v55;
        if ((v55 >> 31))
        {
          long long v60 = v175;
          if ((v59 & 0x8000000000000000) != 0)
          {
            uint64x2_t v76 = (uint64x2_t)vdupq_n_s64(v59);
            v77.i32[0] = 2 * v55;
            v77.i32[1] = v59 >> 7;
            *(int8x8_t *)(v175 + 20) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v77, (int64x2_t)vshlq_u64(v76, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v76, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v76, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
            v175[28] = HIBYTE(v59) | 0x80;
            LOBYTE(v59) = 1;
            uint64_t v61 = 29;
          }
          else if ((v59 & 0x7F00000000000000) != 0)
          {
            uint64x2_t v74 = (uint64x2_t)vdupq_n_s64(v59);
            v75.i32[0] = 2 * v55;
            v75.i32[1] = v59 >> 7;
            *(int8x8_t *)(v175 + 20) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v75, (int64x2_t)vshlq_u64(v74, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v74, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v74, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
            unint64_t v59 = (v59 & 0x7F00000000000000) >> 56;
            uint64_t v61 = 28;
          }
          else if ((v59 & 0xFE000000000000) != 0)
          {
            v175[20] = v59 | 0x80;
            uint64x2_t v78 = (uint64x2_t)vdupq_n_s64(v59);
            int16x8_t v79 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v78, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v78, (uint64x2_t)xmmword_1BDA822E0));
            v79.i64[0] = *(void *)&vmovn_s32((int32x4_t)v79) | 0x80008000800080;
            *(_DWORD *)(v175 + 21) = vmovn_s16(v79).u32[0];
            v175[25] = (v59 >> 35) | 0x80;
            v175[26] = (v59 >> 42) | 0x80;
            unint64_t v59 = (v59 & 0xFE000000000000) >> 49;
            uint64_t v61 = 27;
          }
          else
          {
            v175[20] = v59 | 0x80;
            uint64x2_t v80 = (uint64x2_t)vdupq_n_s64(v59);
            int16x8_t v81 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v80, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v80, (uint64x2_t)xmmword_1BDA822E0));
            v81.i64[0] = *(void *)&vmovn_s32((int32x4_t)v81) | 0x80008000800080;
            *(_DWORD *)(v175 + 21) = vmovn_s16(v81).u32[0];
            if ((v59 & 0x1FC0000000000) != 0)
            {
              v175[25] = (v59 >> 35) | 0x80;
              unint64_t v59 = (v59 & 0x1FC0000000000) >> 42;
              uint64_t v61 = 26;
            }
            else
            {
              unint64_t v59 = (v59 >> 35) & 0x7F;
              uint64_t v61 = 25;
            }
          }
        }
        else
        {
          long long v60 = v175;
          if ((v59 & 0x7F0000000) != 0)
          {
            v175[20] = v59 | 0x80;
            v175[21] = (v59 >> 7) | 0x80;
            v175[22] = (v59 >> 14) | 0x80;
            v175[23] = (v59 >> 21) | 0x80;
            unint64_t v59 = (v59 & 0x7F0000000) >> 28;
            uint64_t v61 = 24;
          }
          else if ((v59 & 0xFE00000) != 0)
          {
            v175[20] = v59 | 0x80;
            v175[21] = (v59 >> 7) | 0x80;
            v175[22] = (v59 >> 14) | 0x80;
            unint64_t v59 = (v59 & 0xFE00000) >> 21;
            uint64_t v61 = 23;
          }
          else if ((v59 & 0x1FC000) != 0)
          {
            v175[20] = v59 | 0x80;
            v175[21] = (v59 >> 7) | 0x80;
            unint64_t v59 = (v59 & 0x1FC000) >> 14;
            uint64_t v61 = 22;
          }
          else if ((v59 & 0x3F80) != 0)
          {
            v175[20] = v59 | 0x80;
            unint64_t v59 = (v59 & 0x3F80) >> 7;
            uint64_t v61 = 21;
          }
          else
          {
            uint64_t v61 = 20;
          }
        }
        v60[v61] = v59;
        uint64_t v82 = v61 + 1;
        unint64_t v83 = v58 >> 31;
        if (v58 == 1)
        {
          unsigned int v84 = v83 >> 28;
          if (v83 >> 28)
          {
            v60[v82] = v83 | 0x81;
            double v90 = &v60[v61];
            v90[2] = (v58 >> 38) | 0x80;
            v90[3] = (v58 >> 45) | 0x80;
            uint64_t v82 = v61 + 5;
            v90[4] = (v58 >> 52) | 0x80;
            LOBYTE(v58) = v84;
          }
          else
          {
            unsigned int v85 = v83 & 0xFE00000;
            if ((v83 & 0xFE00000) != 0)
            {
              v60[v82] = v83 | 0x81;
              unsigned int v86 = &v60[v61];
              void v86[2] = (v58 >> 38) | 0x80;
              uint64_t v82 = v61 + 4;
              v86[3] = (v58 >> 45) | 0x80;
              LODWORD(v58) = v85 >> 21;
            }
            else if ((v83 & 0x1FC000) != 0)
            {
              v60[v82] = v83 | 0x81;
              uint64_t v82 = v61 + 3;
              v60[v61 + 2] = (v58 >> 38) | 0x80;
              LODWORD(v58) = (v83 & 0x1FC000) >> 14;
            }
            else if ((v83 & 0x3F80) != 0)
            {
              v60[v82] = v83 | 0x81;
              uint64_t v82 = v61 + 2;
              LODWORD(v58) = (unsigned __int16)(v83 & 0x3F80) >> 7;
            }
            else
            {
              LOBYTE(v58) = v83 | 1;
            }
          }
        }
        else
        {
          LOBYTE(v87) = v83 & 0xFE;
          if ((v83 & 0xFFFFFFFE) >> 28)
          {
            v60[v82] = v83 & 0x7E | 0x80;
            unint64_t v91 = &v60[v61];
            v91[2] = (v58 >> 38) | 0x80;
            v91[3] = (v58 >> 45) | 0x80;
            uint64_t v82 = v61 + 5;
            v91[4] = (v58 >> 52) | 0x80;
            unsigned int v87 = v83 >> 28;
          }
          else
          {
            unsigned int v88 = v83 & 0xFE00000;
            if ((v83 & 0xFE00000) != 0)
            {
              v60[v82] = v83 & 0x7E | 0x80;
              uint64_t v89 = &v60[v61];
              v89[2] = (v58 >> 38) | 0x80;
              uint64_t v82 = v61 + 4;
              void v89[3] = (v58 >> 45) | 0x80;
              unsigned int v87 = v88 >> 21;
            }
            else if ((v83 & 0x1FC000) != 0)
            {
              v60[v82] = v83 & 0x7E | 0x80;
              uint64_t v82 = v61 + 3;
              v60[v61 + 2] = (v58 >> 38) | 0x80;
              unsigned int v87 = (v83 & 0x1FC000) >> 14;
            }
            else
            {
              unsigned int v122 = v83 & 0x3F80;
              if (v122)
              {
                v60[v82] = v87 | 0x80;
                uint64_t v82 = v61 + 2;
                unsigned int v87 = v122 >> 7;
              }
            }
          }
          v60[v82] = v87;
          uint64_t v92 = v82 + 1;
          if (v58 >> 28)
          {
            v60[v92] = v58 | 0x80;
            unsigned int v94 = &v60[v82];
            v94[2] = (v58 >> 7) | 0x80;
            v94[3] = (v58 >> 14) | 0x80;
            v82 += 5;
            v94[4] = (v58 >> 21) | 0x80;
            LODWORD(v58) = v58 >> 28;
          }
          else if ((v58 & 0xFE00000) != 0)
          {
            v60[v92] = v58 | 0x80;
            unint64_t v93 = &v60[v82];
            v93[2] = (v58 >> 7) | 0x80;
            v82 += 4;
            v93[3] = (v58 >> 14) | 0x80;
            LODWORD(v58) = (v58 & 0xFE00000) >> 21;
          }
          else if ((v58 & 0x1FC000) != 0)
          {
            v60[v92] = v58 | 0x80;
            uint64_t v121 = &v60[v82];
            v82 += 3;
            v121[2] = (v58 >> 7) | 0x80;
            LODWORD(v58) = (v58 & 0x1FC000) >> 14;
          }
          else if ((v58 & 0x3F80) != 0)
          {
            v82 += 2;
            v60[v92] = v58 | 0x80;
            LODWORD(v58) = (unsigned __int16)(v58 & 0x3F80) >> 7;
          }
          else
          {
            ++v82;
          }
        }
        v60[v82] = v58;
        *(void *)&long long v197 = v82 + 1;
      }
      uint64_t v73 = 20;
    }
    unsigned int v95 = v179 - v50;
    uint64_t v96 = v196[0];
    os_log_type_t v175 = (char *)v196[0];
    uint64_t v170 = v73;
    if ((v179 - v50) >> 28)
    {
      *(_DWORD *)(v73 + v196[0] - 4) = v95;
      LOBYTE(v95) = -16;
      uint64_t v98 = -5;
    }
    else if ((v95 & 0xFE00000) != 0)
    {
      uint64_t v97 = v73 + v196[0];
      *(_WORD *)(v97 - 2) = bswap32(v95) >> 16;
      *(unsigned char *)(v97 - 3) = BYTE2(v95);
      unsigned int v95 = HIBYTE(v95) | 0xFFFFFFE0;
      uint64_t v98 = -4;
    }
    else if ((v95 & 0x1FC000) != 0)
    {
      *(_WORD *)(v73 + v196[0] - 2) = bswap32(v95) >> 16;
      unsigned int v95 = HIWORD(v95) | 0xFFFFFFC0;
      uint64_t v98 = -3;
    }
    else
    {
      uint64_t v99 = v73 - 1;
      *(unsigned char *)(v196[0] + v73 - 1) = v95;
      if ((v95 & 0x3F80) == 0) {
        goto LABEL_77;
      }
      unsigned int v95 = (v95 >> 8) | 0xFFFFFF80;
      uint64_t v98 = -2;
    }
    uint64_t v99 = v73 + v98;
    *(unsigned char *)(v96 + v73 + v98) = v95;
LABEL_77:
    uint64_t v176 = v99;
    __uint64_t n = v197 - v99;
    uint64_t v101 = *(void *)v52;
    uint64_t v100 = *(void *)(v52 + 8);
    unint64_t v102 = v100 - *(void *)v52;
    unint64_t v183 = v197 - v99 + 20;
    if (v183 <= v102)
    {
      uint64_t v111 = *((void *)&v194 + 1);
      uint64_t v103 = v21;
      goto LABEL_108;
    }
    uint64_t v103 = *(void *)(v52 + 8);
    while (1)
    {
      if (!v53 || v21 == v103) {
        goto LABEL_85;
      }
      if (v102 <= 0x13)
      {
        int v152 = __si_assert_copy_extra_329();
        BOOL v153 = v152;
        uint64_t v154 = "";
        if (v152) {
          uint64_t v154 = v152;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "JHPayload.c", 274, "pd->payloadIndex - pd->payloadLimit >= sizeof(PulseHeaderDisk)", v154);
        unint64_t v155 = v153;
        goto LABEL_173;
      }
      *(void *)&uint8_t buf[4] = v21 - v103;
      int v199 = -1;
      *(_DWORD *)statfs buf = -1;
      *(_DWORD *)&unsigned char buf[12] = v179;
      uint64_t v104 = *((void *)&v194 + 1);
      if (*((uint64_t *)&v194 + 1) < 21)
      {
        _PayloadWriteData_2914((int *)v193, (void *)v52, (char *)buf, 20);
      }
      else
      {
        *(void *)(v52 + 8) = v103 - 20;
        *((void *)&v194 + 1) = v104 - 20;
        float v105 = (char *)v193[0] + v104 - 20;
        int v106 = v199;
        *(_OWORD *)float v105 = *(_OWORD *)buf;
        *((_DWORD *)v105 + 4) = v106;
      }
      PayloadWriteBufferWrite((int *)v193, (void *)v52);
      uint64_t v107 = v195;
      uint64_t v101 = *(void *)v52;
      uint64_t v103 = *(void *)(v52 + 8);
      if (!v195)
      {
LABEL_85:
        bzero(buf, 0x1000uLL);
        unint64_t v108 = v103 - v101;
        uint64_t v109 = _fd_acquire_fd(*(void *)(v52 + 4488), (void *)(v181 + 4504));
        if (v103 != v101)
        {
          do
          {
            if (v108 >= 0x1000) {
              uint64_t v112 = 4096;
            }
            else {
              uint64_t v112 = v108;
            }
            uint64_t v113 = buf;
            unint64_t v114 = v112;
            uint64_t v115 = v101;
            do
            {
              while (1)
              {
                unint64_t v116 = guarded_pwrite_np();
                if ((v116 & 0x8000000000000000) != 0) {
                  break;
                }
                BOOL v119 = v114 > v116;
                v114 -= v116;
                if (!v119) {
                  goto LABEL_93;
                }
                v113 += v116;
                v115 += v116;
              }
              uint64_t v117 = g_prot_error_callback;
              if (!g_prot_error_callback) {
                break;
              }
              unint64_t v118 = __error();
            }
            while (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v117 + 16))(v117, v109, *v118, 5) & 1) != 0);
LABEL_93:
            v101 += v112;
            v108 -= v112;
          }
          while (v108);
        }
        uint64_t v52 = v181;
        _fd_release_fd(*(_DWORD **)(v181 + 4488), v109, 0, *(void *)(v181 + 4504));
        if (v101 != *(void *)(v181 + 8))
        {
          uint64_t v149 = __si_assert_copy_extra_329();
          int v150 = v149;
          unint64_t v151 = "";
          if (v149) {
            unint64_t v151 = v149;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "JHPayload.c", 375, "pos == pd->payloadIndex", v151);
LABEL_164:
          free(v150);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        int v110 = expandPayload(v181, v180, a9);
        uint64_t v107 = v110;
        uint64_t v195 = v110;
        uint64_t v101 = *(void *)v181;
        uint64_t v103 = *(void *)(v181 + 8);
      }
      uint64_t v53 = 0;
      unint64_t v102 = v103 - v101;
      uint64_t v111 = (uint64_t)v193[1];
      if ((void *)(v103 - v101) < v193[1]) {
        uint64_t v111 = (v103 - v101);
      }
      *(void *)&long long v194 = v111;
      *((void *)&v194 + 1) = v111;
      if (v183 <= v102) {
        break;
      }
      uint64_t v21 = v103;
      uint64_t v100 = v103;
      if (v107) {
        goto LABEL_108;
      }
    }
    uint64_t v100 = v103;
LABEL_108:
    unsigned int v120 = &v175[v176];
    if (v111 <= __n)
    {
      _PayloadWriteData_2914((int *)v193, (void *)v52, v120, __n);
    }
    else
    {
      *(void *)(v52 + 8) = v100 - __n;
      *((void *)&v194 + 1) = v111 - __n;
      memcpy((char *)v193[0] + v111 - __n, v120, __n);
    }
    uint64_t v45 = v177;
    void *v171 = v170 - v176 + *(void *)(v52 + 8);
    unint64_t v51 = v167;
    unsigned int v50 = v174;
    if (v170 == v176)
    {
      int v160 = __si_assert_copy_extra_329();
      int v150 = v160;
      unint64_t v161 = "";
      if (v160) {
        unint64_t v161 = v160;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "JHPayload.c", 481, "postingStart-postingTermIdStart", v161);
      goto LABEL_164;
    }
    ++v53;
    uint64_t v72 = v195;
    unint64_t v49 = v172 + 1;
    uint64_t v21 = v103;
  }
  while (v49 < v173 && !v72);
LABEL_136:
  int v125 = v50;
  free(v187[0]);
  free(v189[0]);
  free(v190[0]);
  free(v191[0]);
  free(v185[0]);
  PayloadWritePulseHeader((int *)v193, (void *)v52, v21 - *(void *)(v52 + 8), v125);
  int v126 = *__error();
  int v127 = _SILogForLogForCategory(10);
  os_log_type_t v128 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v127, v128))
  {
    float v129 = CFAbsoluteTimeGetCurrent() - v47;
    *(_DWORD *)statfs buf = 134217984;
    *(double *)&uint8_t buf[4] = v129;
    _os_log_impl(&dword_1BD672000, v127, v128, "write postings: %f", buf, 0xCu);
  }
  *__error() = v126;
  double v130 = CFAbsoluteTimeGetCurrent();
  if (v49)
  {
    uint64_t v131 = 0;
    unsigned int v132 = 0;
    CFAllocatorRef v133 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    unsigned int v134 = (void *)MEMORY[0x1E4F14B00];
    while (1)
    {
      unint64_t v135 = *(void *)(v45 + 24 * v131 + 16);
      if (v135 >> 62) {
        break;
      }
      unint64_t v136 = 8 * *(unsigned int *)(v45 + 24 * v131);
      CFIndex v137 = v136 / *v134;
      CFIndex v138 = *(void *)(v52 + 4472);
      if (v138 <= v137)
      {
        if (v138) {
          CFIndex v139 = *(void *)(v52 + 4472);
        }
        else {
          CFIndex v139 = 32;
        }
        while (1)
        {
          v139 *= 2;
          if (v139 > v137) {
            break;
          }
          if (v139 <= v138)
          {
            unint64_t v162 = __si_assert_copy_extra_329();
            int v150 = v162;
            unsigned int v163 = "";
            if (v162) {
              unsigned int v163 = v162;
            }
            __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v163);
            goto LABEL_164;
          }
        }
        CFBitVectorRef v140 = *(const __CFBitVector **)(v181 + 4480);
        if (v140) {
          CFMutableStringRef MutableCopy = CFBitVectorCreateMutableCopy(v133, v139, v140);
        }
        else {
          CFMutableStringRef MutableCopy = CFBitVectorCreateMutable(v133, v139);
        }
        if (!MutableCopy)
        {
          unsigned int v164 = __si_assert_copy_extra_329();
          int v150 = v164;
          unint64_t v165 = "";
          if (v164) {
            unint64_t v165 = v164;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v165);
          goto LABEL_164;
        }
        uint64_t v184 = MutableCopy;
        CFBitVectorSetCount(MutableCopy, v139);
        unint64_t v142 = *(const void **)(v181 + 4480);
        if (v142) {
          CFRelease(v142);
        }
        *(void *)(v181 + 4480) = v184;
        *(void *)(v181 + 4472) = v139;
        uint64_t v52 = v181;
      }
      if (*(void *)(v52 + 4464) <= v137) {
        *(void *)(v52 + 4464) = v137 + 1;
      }
      CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(v52 + 4480), v137, 1u);
      *(void *)storageResolvePtr(v168, v136, 8, 1) = v135;
      uint64_t v131 = ++v132;
      uint64_t v45 = v177;
      if (v49 <= v132) {
        goto LABEL_158;
      }
    }
    int v156 = __si_assert_copy_extra_329();
    int v157 = v156;
    double v158 = "";
    if (v156) {
      double v158 = v156;
    }
    __message_assert("%s:%u: failed assertion '%s' %s write invalid offset %llu", "TermIdStore.h", 97, "offset <= OFFSET_VALUE_MASK", v158, v135);
    unint64_t v155 = v157;
LABEL_173:
    free(v155);
    if (__valid_fs(-1)) {
      uint64_t v159 = 2989;
    }
    else {
      uint64_t v159 = 3072;
    }
    *(_DWORD *)uint64_t v159 = -559038737;
    abort();
  }
LABEL_158:
  int v143 = *__error();
  uint64_t v144 = _SILogForLogForCategory(10);
  os_log_type_t v145 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v144, v145))
  {
    float v146 = CFAbsoluteTimeGetCurrent() - v130;
    *(_DWORD *)statfs buf = 134217984;
    *(double *)&uint8_t buf[4] = v146;
    _os_log_impl(&dword_1BD672000, v144, v145, "update term id offsets: %f", buf, 0xCu);
  }
  *__error() = v143;
  uint64_t v147 = v195;
  free(v193[0]);
  free(v175);
  return v147;
}

void si_analytics_log_2923(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  v9[0] = 0;
  v9[1] = &a9;
  vasprintf((char **)v9, "%u term ids out of range", &a9);
  SISetCrashCStr((const char *)v9[0]);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)statfs buf = 136315138;
    unsigned int v11 = v9[0];
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "%s", buf, 0xCu);
  }
  free(v9[0]);
}

uint64_t packUpdateLink(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4)
{
  int v4 = a3;
  unint64_t v6 = 2 * a2;
  if ((a2 >> 31))
  {
    if ((v6 & 0x8000000000000000) != 0)
    {
      uint64x2_t v10 = (uint64x2_t)vdupq_n_s64(v6);
      v11.i32[0] = 2 * a2;
      v11.i32[1] = v6 >> 7;
      *(int8x8_t *)(a1 + 20) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v11, (int64x2_t)vshlq_u64(v10, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v10, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v10, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
      *(unsigned char *)(a1 + 28) = HIBYTE(v6) | 0x80;
      LOBYTE(v6) = 1;
      uint64_t v7 = 29;
    }
    else if ((v6 & 0x7F00000000000000) != 0)
    {
      uint64x2_t v8 = (uint64x2_t)vdupq_n_s64(v6);
      v9.i32[0] = 2 * a2;
      v9.i32[1] = v6 >> 7;
      *(int8x8_t *)(a1 + 20) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v9, (int64x2_t)vshlq_u64(v8, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v8, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v8, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
      unint64_t v6 = (v6 & 0x7F00000000000000) >> 56;
      uint64_t v7 = 28;
    }
    else if ((v6 & 0xFE000000000000) != 0)
    {
      *(unsigned char *)(a1 + 20) = v6 | 0x80;
      uint64x2_t v12 = (uint64x2_t)vdupq_n_s64(v6);
      int16x8_t v13 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v12, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v12, (uint64x2_t)xmmword_1BDA822E0));
      v13.i64[0] = *(void *)&vmovn_s32((int32x4_t)v13) | 0x80008000800080;
      *(_DWORD *)(a1 + 21) = vmovn_s16(v13).u32[0];
      *(unsigned char *)(a1 + 25) = (v6 >> 35) | 0x80;
      *(unsigned char *)(a1 + 26) = (v6 >> 42) | 0x80;
      unint64_t v6 = (v6 & 0xFE000000000000) >> 49;
      uint64_t v7 = 27;
    }
    else
    {
      *(unsigned char *)(a1 + 20) = v6 | 0x80;
      uint64x2_t v14 = (uint64x2_t)vdupq_n_s64(v6);
      int16x8_t v15 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v14, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v14, (uint64x2_t)xmmword_1BDA822E0));
      v15.i64[0] = *(void *)&vmovn_s32((int32x4_t)v15) | 0x80008000800080;
      *(_DWORD *)(a1 + 21) = vmovn_s16(v15).u32[0];
      if ((v6 & 0x1FC0000000000) != 0)
      {
        *(unsigned char *)(a1 + 25) = (v6 >> 35) | 0x80;
        unint64_t v6 = (v6 & 0x1FC0000000000) >> 42;
        uint64_t v7 = 26;
      }
      else
      {
        unint64_t v6 = (v6 >> 35) & 0x7F;
        uint64_t v7 = 25;
      }
    }
  }
  else if ((v6 & 0x7F0000000) != 0)
  {
    *(unsigned char *)(a1 + 20) = v6 | 0x80;
    *(unsigned char *)(a1 + 21) = (v6 >> 7) | 0x80;
    *(unsigned char *)(a1 + 22) = (v6 >> 14) | 0x80;
    *(unsigned char *)(a1 + 23) = (v6 >> 21) | 0x80;
    unint64_t v6 = (v6 & 0x7F0000000) >> 28;
    uint64_t v7 = 24;
  }
  else if ((v6 & 0xFE00000) != 0)
  {
    *(unsigned char *)(a1 + 20) = v6 | 0x80;
    *(unsigned char *)(a1 + 21) = (v6 >> 7) | 0x80;
    *(unsigned char *)(a1 + 22) = (v6 >> 14) | 0x80;
    unint64_t v6 = (v6 & 0xFE00000) >> 21;
    uint64_t v7 = 23;
  }
  else if ((v6 & 0x1FC000) != 0)
  {
    *(unsigned char *)(a1 + 20) = v6 | 0x80;
    *(unsigned char *)(a1 + 21) = (v6 >> 7) | 0x80;
    unint64_t v6 = (v6 & 0x1FC000) >> 14;
    uint64_t v7 = 22;
  }
  else if ((v6 & 0x3F80) != 0)
  {
    *(unsigned char *)(a1 + 20) = v6 | 0x80;
    unint64_t v6 = (v6 & 0x3F80) >> 7;
    uint64_t v7 = 21;
  }
  else
  {
    uint64_t v7 = 20;
  }
  *(unsigned char *)(a1 + v7) = v6;
  uint64_t v16 = writeVInt64(a1, v7 + 1, 2 * __PAIR64__(a4, HIDWORD(a3)));
  *(unsigned char *)(a1 + v16) = 0;
  if (v4) {
    char v17 = 1;
  }
  else {
    char v17 = 2;
  }
  *(unsigned char *)(a1 + v16 + 1) = v17;
  return v16 + 2;
}

BOOL SIStringContainsNewlineCharacters(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  if (a1 && a2)
  {
    if (a2 < 1)
    {
      return 0;
    }
    else
    {
      uint64_t v5 = 0;
      BOOL v6 = 1;
      do
      {
        int v7 = *(unsigned __int16 *)(a1 + 2 * v5);
        if (v7 == 9 || v7 == 8200) {
          break;
        }
        if (v7 == 12288) {
          break;
        }
        CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetNewline);
        if (CFCharacterSetIsCharacterMember(Predefined, *(_WORD *)(a1 + 2 * v5))) {
          break;
        }
        BOOL v6 = ++v5 < a2;
      }
      while (a2 != v5);
    }
    return v6;
  }
  return result;
}

__n128 L1RankQueuePop(long long *a1, __n128 **a2)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2[2];
  if (v2 != (__n128 *)1)
  {
    int v4 = *a2;
    long long v63 = (__int128)(*a2)[7];
    long long v64 = (__int128)(*a2)[8];
    long long v65 = (__int128)(*a2)[9];
    long long v61 = (__int128)(*a2)[5];
    __n128 v62 = (*a2)[6];
    uint64_t v5 = (uint64_t)&(*a2)[5 * (void)v2];
    uint64_t v7 = *(void *)(v5 - 80);
    uint64_t v6 = *(void *)(v5 - 72);
    __n128 v71 = *(__n128 *)(v5 - 64);
    __n128 v72 = *(__n128 *)(v5 - 48);
    unsigned int v8 = *(_DWORD *)(v5 - 32);
    float v9 = *(float *)(v5 - 28);
    unsigned __int32 v10 = *(_DWORD *)(v5 - 24);
    float v11 = *(float *)(v5 - 20);
    unsigned __int32 v12 = *(_DWORD *)(v5 - 16);
    unsigned __int8 v13 = *(unsigned char *)(v5 - 12);
    unsigned __int8 v14 = *(unsigned char *)(v5 - 11);
    unint64_t v15 = *(void *)(v5 - 10);
    LOWORD(v5) = *(_WORD *)(v5 - 2);
    v4[6] = v71;
    v4[7] = v72;
    unsigned __int8 v70 = v13;
    unsigned __int16 v80 = v5;
    unint64_t v79 = v15;
    v4[5].n128_u64[0] = v7;
    v4[5].n128_u64[1] = v6;
    v4[8].n128_u32[0] = v8;
    v4[8].n128_f32[1] = v9;
    v4[8].n128_u32[2] = v10;
    v4[8].n128_f32[3] = v11;
    v4[9].n128_u8[4] = v13;
    v4[9].n128_u32[0] = v12;
    v4[9].n128_u8[5] = v14;
    v4[9].n128_u16[7] = v80;
    *(unint64_t *)((char *)v4[9].n128_u64 + 6) = v15;
    uint64_t v17 = (uint64_t)a2[1];
    uint64_t v16 = (uint64_t)a2[2];
    a2[2] = (__n128 *)(v16 - 1);
    unsigned __int16 v78 = v80;
    uint64_t v18 = v17 >> 1;
    uint64_t v19 = 3;
    unint64_t v77 = v15;
    uint64_t v20 = 2;
    uint64_t v21 = 1;
    while (1)
    {
      uint64_t v22 = *a2;
      uint64_t v23 = (uint64_t)&(*a2)[5 * v20];
      uint64_t v24 = *(void *)v23;
      uint64_t v25 = *(void *)(v23 + 8);
      unsigned int v26 = *(_DWORD *)(v23 + 48);
      float v27 = *(float *)(v23 + 52);
      int v28 = *(_DWORD *)(v23 + 56);
      float v29 = *(float *)(v23 + 60);
      int v30 = *(unsigned __int8 *)(v23 + 69);
      uint64_t v31 = (uint64_t)&(*a2)[5 * v19];
      uint64_t v32 = *(void *)v31;
      uint64_t v33 = *(void *)(v31 + 8);
      long long v34 = *(_OWORD *)(v31 + 32);
      long long v75 = *(_OWORD *)(v31 + 16);
      long long v76 = v34;
      unsigned int v35 = *(_DWORD *)(v31 + 48);
      float v36 = *(float *)(v31 + 52);
      int v37 = *(_DWORD *)(v31 + 56);
      float v38 = *(float *)(v31 + 60);
      int v73 = *(_DWORD *)(v31 + 64);
      char v74 = *(unsigned char *)(v31 + 68);
      int v39 = *(unsigned __int8 *)(v31 + 69);
      uint64_t v40 = *(void *)(v31 + 70);
      __int16 v82 = *(_WORD *)(v31 + 78);
      uint64_t v81 = v40;
      if (v19 >= v16)
      {
        long long v75 = xmmword_1BDA7EFC0;
        long long v76 = unk_1BDA7EFD0;
        int v73 = 0;
        char v74 = 0;
        uint64_t v81 = 0;
        __int16 v82 = 0;
        if (v20 >= v16) {
          goto LABEL_3;
        }
        unsigned int v35 = 0;
        int v37 = 0;
        int v39 = 0;
        uint64_t v32 = -1;
        float v38 = 0.0;
        float v36 = 3.4028e38;
        uint64_t v33 = -1;
        if (!v30)
        {
LABEL_12:
          if (__PAIR128__(v25, v24) < __PAIR128__(v6, v7)) {
            goto LABEL_24;
          }
          if (v25 != v6 || v24 != v7)
          {
LABEL_47:
            if (!v39)
            {
              if (__PAIR128__(v33, v32) >= __PAIR128__(v6, v7))
              {
                BOOL v57 = v33 == v6 && v32 == v7;
                if (!v57 || v36 >= v9 && (v36 == v9 ? (BOOL v58 = v35 > v8) : (BOOL v58 = 0), !v58))
                {
LABEL_69:
                  _X8 = &v22[10 * v21];
                  __asm { PRFM            #1, [X8] }
                  goto LABEL_3;
                }
                LOBYTE(v30) = 0;
                uint64_t v45 = &v81;
                os_log_type_t v44 = &v73;
                int v43 = &v75;
                float v29 = v38;
                int v28 = v37;
                float v27 = v36;
                unsigned int v26 = v35;
                uint64_t v24 = v7;
                uint64_t v25 = v6;
                goto LABEL_34;
              }
              goto LABEL_32;
            }
            if (v38 >= v11)
            {
              if (v38 != v11) {
                goto LABEL_69;
              }
              if (v36 >= v9 && (v36 != v9 || v35 <= v8)) {
                goto LABEL_69;
              }
            }
            goto LABEL_30;
          }
          goto LABEL_18;
        }
      }
      else if (!v30)
      {
        goto LABEL_12;
      }
      if (v29 < v11) {
        goto LABEL_24;
      }
      if (v29 != v11) {
        goto LABEL_47;
      }
LABEL_18:
      if (v27 >= v9)
      {
        BOOL v42 = v27 == v9 && v26 > v8;
        if (!v42) {
          goto LABEL_47;
        }
      }
LABEL_24:
      int v43 = (long long *)(v23 + 16);
      os_log_type_t v44 = (int *)(v23 + 64);
      uint64_t v45 = (uint64_t *)(v23 + 70);
      if (!v39)
      {
        if (__PAIR128__(v33, v32) >= __PAIR128__(v25, v24))
        {
          BOOL v55 = v33 == v25 && v32 == v24;
          if (!v55 || v36 >= v27 && (v36 != v27 || v35 <= v26)) {
            goto LABEL_35;
          }
          LOBYTE(v30) = 0;
          uint64_t v45 = &v81;
          os_log_type_t v44 = &v73;
          int v43 = &v75;
          float v29 = v38;
          int v28 = v37;
          float v27 = v36;
          unsigned int v26 = v35;
          goto LABEL_34;
        }
LABEL_32:
        LOBYTE(v30) = 0;
        uint64_t v45 = &v81;
        os_log_type_t v44 = &v73;
        int v43 = &v75;
        goto LABEL_33;
      }
      if (v38 >= v29 && (v38 != v29 || v36 >= v27 && (v36 != v27 || v35 <= v26))) {
        goto LABEL_35;
      }
LABEL_30:
      uint64_t v45 = &v81;
      os_log_type_t v44 = &v73;
      int v43 = &v75;
      LOBYTE(v30) = v39;
LABEL_33:
      float v29 = v38;
      int v28 = v37;
      float v27 = v36;
      unsigned int v26 = v35;
      uint64_t v24 = v32;
      uint64_t v25 = v33;
LABEL_34:
      uint64_t v20 = v19;
LABEL_35:
      long long v68 = *v43;
      long long v69 = v43[1];
      int v66 = *v44;
      char v67 = *((unsigned char *)v44 + 4);
      unint64_t v77 = *v45;
      unsigned __int16 v78 = *((_WORD *)v45 + 4);
      _X5 = &v22[10 * v20];
      __asm { PRFM            #1, [X5] }
      if (v20 != v21)
      {
        unint64_t v51 = &v22[5 * v20];
        v51->n128_u64[0] = v7;
        v51->n128_u64[1] = v6;
        v51[1] = v71;
        v51[2] = v72;
        v51[3].n128_u32[0] = v8;
        v51[3].n128_f32[1] = v9;
        v51[3].n128_u32[2] = v10;
        v51[3].n128_f32[3] = v11;
        v51[4].n128_u32[0] = v12;
        v51[4].n128_u8[4] = v70;
        v51[4].n128_u8[5] = v14;
        v51[4].n128_u16[7] = v80;
        unint64_t v52 = v79;
        *(unint64_t *)((char *)v51[4].n128_u64 + 6) = v79;
        uint64_t v53 = (uint64_t)&(*a2)[5 * v21];
        *(_OWORD *)(v53 + 16) = v68;
        *(_OWORD *)(v53 + 32) = v69;
        *(float *)(v53 + 52) = v27;
        uint64_t v21 = v20;
        uint64_t v19 = (2 * v20) | 1;
        *(void *)uint64_t v53 = v24;
        *(void *)(v53 + 8) = v25;
        *(_DWORD *)(v53 + 48) = v26;
        *(_DWORD *)(v53 + 56) = v28;
        *(float *)(v53 + 60) = v29;
        *(_DWORD *)(v53 + 64) = v66;
        *(unsigned char *)(v53 + 68) = v67;
        *(unsigned char *)(v53 + 69) = v30;
        unint64_t v54 = v77;
        *(_WORD *)(v53 + 78) = v78;
        *(void *)(v53 + 70) = v54;
        unsigned __int16 v78 = v80;
        unint64_t v77 = v52;
        BOOL v42 = v20 < v18;
        v20 *= 2;
        if (v42) {
          continue;
        }
      }
      goto LABEL_3;
    }
  }
  long long v63 = xmmword_1BDA7F020;
  long long v64 = unk_1BDA7F030;
  long long v65 = xmmword_1BDA7F040;
  long long v61 = ZERO_RANKING_WRAPPED_BITS;
  __n128 v62 = *(__n128 *)algn_1BDA7F010;
LABEL_3:
  a1[2] = v63;
  a1[3] = v64;
  a1[4] = v65;
  __n128 result = v62;
  *a1 = v61;
  a1[1] = (__int128)v62;
  return result;
}

_DWORD *container_table_create(unsigned int a1)
{
  uint64_t v2 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 80 * a1 + 16, 0x6085D6BuLL);
  if (!v2) {
    _log_fault_for_malloc_failure();
  }
  *uint64_t v2 = a1;
  if (a1)
  {
    uint64_t v3 = a1;
    int v4 = v2 + 4;
    do
    {
      v4[2] = xmmword_1BDA88400;
      void v4[3] = unk_1BDA88410;
      void v4[4] = xmmword_1BDA88420;
      *int v4 = ZERO_RANKING_BITS;
      v4[1] = *(_OWORD *)algn_1BDA883F0;
      v4 += 5;
      --v3;
    }
    while (v3);
  }
  return v2;
}

uint64_t container_fetch_table_check_and_insert(_DWORD *a1, uint64_t a2)
{
  if (!*a1) {
    return 0;
  }
  uint64_t v2 = &a1[36 * ((*(_DWORD *)(a2 + 56) - 1) % *a1)];
  unint64_t v5 = *((void *)v2 + 2);
  uint64_t v3 = (float *)(v2 + 4);
  unint64_t v4 = v5;
  float v6 = v3[13];
  float v7 = *(float *)(a2 + 52);
  if (*((unsigned __int8 *)v3 + 69) | *(unsigned __int8 *)(a2 + 69))
  {
    float v10 = v3[15];
    float v11 = *(float *)(a2 + 60);
    BOOL v9 = v11 == v10;
    if (v11 > v10) {
      goto LABEL_18;
    }
  }
  else
  {
    unint64_t v8 = *((void *)v3 + 1);
    if (__PAIR128__(v8, v4) < *(_OWORD *)a2) {
      goto LABEL_18;
    }
    BOOL v9 = *(void *)(a2 + 8) == v8 && *(void *)a2 == v4;
  }
  if (!v9 || v7 <= v6 && (v7 == v6 ? (BOOL v12 = *(_DWORD *)(a2 + 48) >= *((_DWORD *)v3 + 12)) : (BOOL v12 = 1), v12))
  {
    if (*((_DWORD *)v3 + 14)) {
      return 0;
    }
  }
LABEL_18:
  *(_OWORD *)uint64_t v3 = *(_OWORD *)a2;
  long long v14 = *(_OWORD *)(a2 + 16);
  long long v15 = *(_OWORD *)(a2 + 32);
  long long v16 = *(_OWORD *)(a2 + 64);
  *((_OWORD *)v3 + 3) = *(_OWORD *)(a2 + 48);
  *((_OWORD *)v3 + 4) = v16;
  *((_OWORD *)v3 + 1) = v14;
  *((_OWORD *)v3 + 2) = v15;
  long long v17 = *(_OWORD *)(a2 + 80);
  long long v18 = *(_OWORD *)(a2 + 96);
  long long v19 = *(_OWORD *)(a2 + 128);
  *((_OWORD *)v3 + 7) = *(_OWORD *)(a2 + 112);
  *((_OWORD *)v3 + 8) = v19;
  *((_OWORD *)v3 + 5) = v17;
  *((_OWORD *)v3 + 6) = v18;
  return 1;
}

_DWORD *container_fetch_table_create(unsigned int a1)
{
  uint64_t v2 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 144 * a1 + 16, 0x6085D6BuLL);
  if (!v2) {
    _log_fault_for_malloc_failure();
  }
  *uint64_t v2 = a1;
  if (a1)
  {
    uint64_t v3 = a1;
    unint64_t v4 = v2 + 4;
    do
    {
      v4[6] = xmmword_1BDA872C0;
      v4[7] = unk_1BDA872D0;
      v4[8] = xmmword_1BDA872E0;
      v4[2] = xmmword_1BDA87280;
      void v4[3] = unk_1BDA87290;
      void v4[4] = xmmword_1BDA872A0;
      void v4[5] = unk_1BDA872B0;
      *unint64_t v4 = ZERO_FETCHINFO;
      v4[1] = *(_OWORD *)algn_1BDA87270;
      v4 += 9;
      --v3;
    }
    while (v3);
  }
  return v2;
}

uint64_t container_fetch_table_q2_check_and_insert(_DWORD *a1, uint64_t a2)
{
  if (!*a1) {
    return 0;
  }
  uint64_t v2 = &a1[36 * ((*(_DWORD *)(a2 + 56) - 1) % *a1)];
  uint64_t v3 = (float *)(v2 + 4);
  float v6 = v2 + 8;
  unint64_t v5 = *((void *)v2 + 4);
  unint64_t v4 = *((void *)v6 + 1);
  if (__PAIR128__(v4, v5) >= *(_OWORD *)(a2 + 16))
  {
    BOOL v7 = v4 == *(void *)(a2 + 24) && v5 == *(void *)(a2 + 16);
    if ((!v7 || v3[13] != *(float *)(a2 + 52) || *((_DWORD *)v3 + 12) <= *(_DWORD *)(a2 + 48)) && *((_DWORD *)v3 + 14)) {
      return 0;
    }
  }
  *(_OWORD *)uint64_t v3 = *(_OWORD *)a2;
  long long v9 = *(_OWORD *)(a2 + 16);
  long long v10 = *(_OWORD *)(a2 + 32);
  long long v11 = *(_OWORD *)(a2 + 64);
  *((_OWORD *)v3 + 3) = *(_OWORD *)(a2 + 48);
  *((_OWORD *)v3 + 4) = v11;
  *((_OWORD *)v3 + 1) = v9;
  *((_OWORD *)v3 + 2) = v10;
  long long v12 = *(_OWORD *)(a2 + 80);
  long long v13 = *(_OWORD *)(a2 + 96);
  long long v14 = *(_OWORD *)(a2 + 112);
  *((unsigned char *)v3 + 128) = *(unsigned char *)(a2 + 128);
  *((_OWORD *)v3 + 6) = v13;
  *((_OWORD *)v3 + 7) = v14;
  *((_OWORD *)v3 + 5) = v12;
  return 1;
}

_DWORD *container_fetch_table_q2_create(unsigned int a1)
{
  uint64_t v2 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 144 * a1 + 16, 0x6085D6BuLL);
  if (!v2) {
    _log_fault_for_malloc_failure();
  }
  *uint64_t v2 = a1;
  if (a1)
  {
    uint64_t v3 = a1;
    unint64_t v4 = v2 + 4;
    do
    {
      *((unsigned char *)v4 + 128) = 0;
      *((_OWORD *)v4 + 4) = xmmword_1BDA7EE80;
      *((_OWORD *)v4 + 5) = unk_1BDA7EE90;
      *((_OWORD *)v4 + 6) = xmmword_1BDA7EEA0;
      *((_OWORD *)v4 + 7) = unk_1BDA7EEB0;
      *(_OWORD *)unint64_t v4 = ZERO_FETCHINFO_Q2;
      *((_OWORD *)v4 + 1) = *(_OWORD *)algn_1BDA7EE50;
      *((_OWORD *)v4 + 2) = xmmword_1BDA7EE60;
      *((_OWORD *)v4 + 3) = unk_1BDA7EE70;
      v4 += 36;
      --v3;
    }
    while (v3);
  }
  return v2;
}

void *closeMF(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  fd_release(*(atomic_uint **)(a1 + 96));
  *(void *)(a1 + 96) = 0;
  int v2 = *__error();
  uint64_t v3 = _SILogForLogForCategory(10);
  os_log_type_t v4 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v3, v4))
  {
    unint64_t v5 = *(void *)(a1 + 24);
    double v6 = (double)*(unint64_t *)(a1 + 16) * 100.0 / (double)v5;
    int v8 = 134218240;
    unint64_t v9 = v5 >> 10;
    __int16 v10 = 2048;
    double v11 = v6;
    _os_log_impl(&dword_1BD672000, v3, v4, "Memsize: %luKB %f%% used", (uint8_t *)&v8, 0x16u);
  }
  *__error() = v2;
  __n128 result = *(void **)a1;
  if ((unint64_t)(*(void *)a1 + 1) >= 2)
  {
    __n128 result = (void *)munmap(result, *(void *)(a1 + 24));
    *(void *)a1 = 0;
  }
  return result;
}

uint64_t mfree(uint64_t result, unsigned int a2, uint64_t *a3)
{
  unsigned int v3 = *((_DWORD *)a3 + 2);
  BOOL v4 = a2 >= v3;
  unsigned int v5 = a2 - v3;
  if (v5 != 0 && v4)
  {
    unsigned int v6 = __clz(v5);
    BOOL v8 = (v5 & (v5 - 1)) != 0 || v5 == 0;
    int v9 = v8 - v6 + 28;
  }
  else
  {
    int v9 = 0;
  }
  if ((8 << v9) + result == a3[2])
  {
    a3[2] = (int)result;
  }
  else
  {
    uint64_t v10 = *a3;
    if (*((_DWORD *)a3 + 28) < v9) {
      *((_DWORD *)a3 + 28) = v9;
    }
    uint64_t v11 = (uint64_t)a3 + 4 * v9;
    *(_DWORD *)(v10 + result) = *(_DWORD *)(v11 + 32);
    *(_DWORD *)(v11 + 32) = result;
  }
  return result;
}

uint64_t mmalloc(unsigned int a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4)
{
  uint64_t v7 = *(unsigned int *)(a2 + 8);
  if (a1 <= v7)
  {
    signed int v13 = 0;
  }
  else
  {
    unsigned int v8 = __clz(a1 - v7);
    BOOL v10 = ((a1 - v7) & (a1 - v7 - 1)) != 0 || a1 == v7;
    int v11 = v10 - v8;
    if (v11 <= -31) {
      int v12 = 31;
    }
    else {
      int v12 = 28;
    }
    signed int v13 = v12 + v11;
  }
  uint64_t v14 = a2 + 4 * v13;
  unsigned int v17 = *(_DWORD *)(v14 + 32);
  long long v15 = (_DWORD *)(v14 + 32);
  uint64_t v16 = v17;
  if (v17)
  {
    uint64_t v18 = *(void *)a2;
    *long long v15 = *(_DWORD *)(*(void *)a2 + v16);
    v27[1] = 0x2000;
    v27[0] = *(unsigned int *)(v18 + v16);
    fd_read_advise(*(_DWORD **)(a2 + 96), (uint64_t)v27);
  }
  else
  {
    unsigned int v19 = takeBuddyPage((uint64_t *)a2, v13);
    if (v19)
    {
      return v19;
    }
    else
    {
      if (!*(void *)(a2 + 96))
      {
        uint64_t v22 = __si_assert_copy_extra_329();
        uint64_t v23 = v22;
        uint64_t v24 = "";
        if (v22) {
          uint64_t v24 = v22;
        }
        __message_assert("%s:%u: failed assertion '%s' %s NULL file reference", "MFMalloc.c", 311, "m->fdPtr", v24);
        free(v23);
        if (__valid_fs(-1)) {
          uint64_t v25 = 2989;
        }
        else {
          uint64_t v25 = 3072;
        }
        *(_DWORD *)uint64_t v25 = -559038737;
        abort();
      }
      uint64_t v16 = *(void *)(a2 + 16);
      unint64_t v20 = *(void *)(a2 + 24);
      if (v16 + v7 + (unint64_t)(16 << v13) + 8 >= v20)
      {
        while (1)
        {
          v27[0] = 0;
          if (expandUnsafeMapNew((void **)a2, *(void *)(a2 + 96), v20, 1uLL, v27, a3, a4)) {
            break;
          }
          size_t v26 = v27[0];
          *(void *)(a2 + 24) = v27[0];
          madvise(*(void **)a2, v26, *(_DWORD *)(a2 + 104));
          uint64_t v16 = *(void *)(a2 + 16);
          unint64_t v20 = *(void *)(a2 + 24);
          if (v16 + v7 + (unint64_t)(16 << v13) + 8 < v20) {
            goto LABEL_19;
          }
        }
        uint64_t v16 = 0;
        *__error() = -1;
      }
      else
      {
LABEL_19:
        *(void *)(a2 + 16) = v7 + (8 << v13) + v16;
      }
    }
  }
  return v16;
}

uint64_t takeBuddyPage(uint64_t *a1, unsigned int a2)
{
  if (a2 > 0xE) {
    return 0;
  }
  if (*((_DWORD *)a1 + 2) || *((_DWORD *)a1 + 28) <= a2) {
    return 0;
  }
  unsigned int v5 = (_DWORD *)a1 + a2 + 9;
  unsigned int v6 = (_DWORD *)a1 + a2 + 8;
  uint64_t result = *v5;
  int v7 = 8 << a2;
  if (result)
  {
    uint64_t v8 = *a1;
    *unsigned int v5 = *(_DWORD *)(*a1 + result);
    unsigned int v9 = result + v7;
    *unsigned int v6 = result + v7;
LABEL_11:
    *(_DWORD *)(v8 + v9) = 0;
    return result;
  }
  uint64_t result = takeBuddyPage(a1);
  if (result)
  {
    unsigned int v9 = result + v7;
    *unsigned int v6 = result + v7;
    uint64_t v8 = *a1;
    goto LABEL_11;
  }
  *((_DWORD *)a1 + 28) = a2;
  return result;
}

uint64_t restoreVInt32_2977(char **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if ((**a1 & 0x80000000) == 0)
  {
    uint64_t v3 = 1;
    goto LABEL_10;
  }
  int v4 = v1[1];
  if ((v1[1] & 0x80000000) == 0)
  {
    uint64_t v2 = v2 & 0x7F | (v4 << 7);
    uint64_t v3 = 2;
    goto LABEL_10;
  }
  int v5 = v1[2];
  if ((v1[2] & 0x80000000) == 0)
  {
    uint64_t v6 = ((v4 & 0x7F) << 7) | (v5 << 14) | (v2 & 0x7F);
    uint64_t v3 = 3;
LABEL_9:
    uint64_t v2 = v6;
    goto LABEL_10;
  }
  int v7 = v1[3];
  if ((v1[3] & 0x80000000) == 0)
  {
    uint64_t v6 = ((v5 & 0x7F) << 14) | (v7 << 21) | ((v4 & 0x7F) << 7) | (v2 & 0x7F);
    uint64_t v3 = 4;
    goto LABEL_9;
  }
  int v9 = v1[4];
  if (v9 < 0)
  {
    int v11 = __si_assert_copy_extra_329();
    int v12 = v11;
    signed int v13 = "";
    if (v11) {
      signed int v13 = v11;
    }
    __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v13);
    free(v12);
    if (__valid_fs(-1)) {
      uint64_t v14 = 2989;
    }
    else {
      uint64_t v14 = 3072;
    }
    *(_DWORD *)uint64_t v14 = -559038737;
    abort();
  }
  uint64_t v10 = ((v7 & 0x7F) << 21) | (v9 << 28) | ((v5 & 0x7F) << 14) | ((v4 & 0x7F) << 7) | (v2 & 0x7F);
  uint64_t v3 = 5;
  uint64_t v2 = v10;
LABEL_10:
  *a1 = &v1[v3];
  return v2;
}

void __si_indexingWatchdogInit_block_invoke(uint64_t a1)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 105) && !*(unsigned char *)(v1 + 16))
  {
    if (SIIsAppleInternal_onceToken != -1) {
      dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_5267);
    }
    if (!SIIsAppleInternal_internal
      || (pid_t v3 = getpid(),
          bzero(buf, 0x288uLL),
          *(void *)uint64_t v33 = 0xE00000001,
          int v34 = 1,
          pid_t v35 = v3,
          size_t v32 = 648,
          sysctl(v33, 4u, buf, &v32, 0, 0))
      || (v43 & 0x8000000) == 0)
    {
      int v4 = (thread_read_t *)MEMORY[0x1C1881CE0]();
      mach_port_name_t v5 = v4;
      v31[0] = (void (*)(void, void))MEMORY[0x1E4F143A8];
      v31[1] = (void (*)(void, void))0x40000000;
      v31[2] = (void (*)(void, void))__si_indexingWatchdogInit_block_invoke_2;
      void v31[3] = (void (*)(void, void))&__block_descriptor_tmp_2991;
      uint8_t v31[4] = *(void (**)(void, void))(a1 + 40);
      char v6 = _SISuspendThreadIfLocked(v4, v31);
      mach_port_deallocate(*MEMORY[0x1E4F14960], v5);
      uint64_t v7 = *(void *)(a1 + 32);
      if (!*(unsigned char *)(v7 + 105) && !*(unsigned char *)(v7 + 16))
      {
        if (pthread_mutex_trylock((pthread_mutex_t *)(*(void *)(a1 + 40) + 1704)))
        {
          int v8 = 4;
        }
        else
        {
          uint64_t v9 = *(void *)(a1 + 40);
          CFSetRef v10 = *(const __CFSet **)(v9 + 1768);
          int v8 = 4;
          if (v10)
          {
            if (CFSetGetCount(v10)) {
              int v8 = 40;
            }
            else {
              int v8 = 4;
            }
            uint64_t v9 = *(void *)(a1 + 40);
          }
          pthread_mutex_unlock((pthread_mutex_t *)(v9 + 1704));
        }
        uint64_t v11 = *(void *)(a1 + 32);
        int v12 = *(unsigned __int8 *)(v11 + 84);
        BOOL v13 = _gSystemStatusBool == 0;
        *(unsigned char *)(v11 + 84) = _gSystemStatusBool;
        if (v13) {
          char v14 = v6;
        }
        else {
          char v14 = 1;
        }
        if (v14) {
          goto LABEL_24;
        }
        unsigned int v15 = v8 + v12;
        unsigned int v16 = *(_DWORD *)(v11 + 80);
        if (v16 < v15)
        {
          *(_DWORD *)(v11 + 80) = v16 + 1;
          logPLIndexingWatchdogEvent();
          uint64_t v11 = *(void *)(a1 + 32);
LABEL_24:
          unsigned int v17 = *(NSObject **)v11;
          dispatch_time_t v18 = dispatch_time(0, 1000000000 * *(void *)(*(void *)(*(void *)(a1 + 40) + 64) + 40));
          dispatch_source_set_timer(v17, v18, 0xFFFFFFFFFFFFFFFFLL, 0);
          return;
        }
        unint64_t Current = (unint64_t)CFAbsoluteTimeGetCurrent();
        int v20 = *__error();
        uint64_t v21 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          uint64_t v22 = *(void *)(a1 + 32);
          uint64_t v23 = *(void *)(v22 + 96);
          uint64_t v24 = *(void *)(v22 + 40);
          uint64_t v25 = *(void *)(v22 + 48);
          uint64_t v26 = *(unsigned int *)(v22 + 72);
          uint64_t v27 = *(unsigned int *)(v22 + 76);
          uint64_t v28 = *(void *)(v22 + 112);
          LODWORD(v22) = *(_DWORD *)(v22 + 88);
          *(_DWORD *)statfs buf = 136317442;
          int v37 = "si_indexingWatchdogInit_block_invoke";
          __int16 v38 = 1024;
          int v39 = 191;
          __int16 v40 = 2048;
          uint64_t v41 = v23;
          __int16 v42 = 2048;
          uint64_t v43 = v24;
          __int16 v44 = 2048;
          uint64_t v45 = v25;
          __int16 v46 = 2048;
          uint64_t v47 = v26;
          __int16 v48 = 2048;
          uint64_t v49 = v27;
          __int16 v50 = 2048;
          uint64_t v51 = v28;
          __int16 v52 = 2048;
          unint64_t v53 = Current;
          __int16 v54 = 1024;
          int v55 = v22;
          _os_log_error_impl(&dword_1BD672000, v21, OS_LOG_TYPE_ERROR, "%s:%d: Indexing watchdog fired, thread:%p delta:%llus, startTime:%.3f, itemCount:%lu, perItemCost:%lu resumeTime:%.3f endtime:%lld protectionClass:%u", buf, 0x5Eu);
        }
        *__error() = v20;
        logPLIndexingWatchdogEvent();
        tailSpinCollect(*(void *)(a1 + 32), (double)Current);
        uint64_t v29 = abort_report_np();
        __si_indexingWatchdogInit_block_invoke_2(v29, v30);
      }
    }
  }
}

int *__si_indexingWatchdogInit_block_invoke_2(uint64_t a1, int a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  bzero(v16, 0x400uLL);
  int v4 = *__error();
  mach_port_name_t v5 = _SILogForLogForCategory(10);
  os_log_type_t v6 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    if (a2) {
      uint64_t v7 = "Suspend";
    }
    else {
      uint64_t v7 = "Resume";
    }
    int v8 = fcntl(*(_DWORD *)(*(void *)(a1 + 32) + 32), 50, v16);
    if (v16[0]) {
      BOOL v9 = v8 < 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9) {
      CFSetRef v10 = 0;
    }
    else {
      CFSetRef v10 = v16;
    }
    *(_DWORD *)statfs buf = 136315394;
    BOOL v13 = v7;
    __int16 v14 = 2080;
    unsigned int v15 = v10;
    _os_log_impl(&dword_1BD672000, v5, v6, "%s watchdog for %s", buf, 0x16u);
  }
  uint64_t result = __error();
  *uint64_t result = v4;
  return result;
}

void logPLIndexingWatchdogEvent()
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  if (PLShouldLogRegisteredEvent())
  {
    xpc_object_t values = @"1";
    keys[0] = @"indexingWatchdogFired";
    CFDictionaryRef v0 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    PLLogRegisteredEvent();
    CFRelease(v0);
  }
}

void tailSpinCollect(uint64_t a1, double a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  double v7 = a2;
  uint64_t v2 = a1 + 48;
  double valuePtr = (a2 - *(double *)(a1 + 48)) * 1000.0;
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFUUIDRef v4 = CFUUIDCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  long long v12 = *(_OWORD *)&off_1E63437F8;
  long long v13 = xmmword_1E6343808;
  long long v14 = *(_OWORD *)&off_1E6343818;
  long long v15 = xmmword_1E6343828;
  *(_OWORD *)keys = xmmword_1E63437E8;
  values[0] = CFNumberCreate(v3, kCFNumberDoubleType, &valuePtr);
  values[1] = CFNumberCreate(v3, kCFNumberSInt32Type, (const void *)(v2 + 24));
  values[2] = CFNumberCreate(v3, kCFNumberSInt64Type, (const void *)(v2 + 28));
  values[3] = CFNumberCreate(v3, kCFNumberSInt64Type, (const void *)(v2 + 32));
  values[4] = CFNumberCreate(v3, kCFNumberSInt64Type, (const void *)(v2 - 8));
  if (*(void *)(v2 - 16)) {
    mach_port_name_t v5 = *(__CFString **)(v2 - 16);
  }
  else {
    mach_port_name_t v5 = @"unknown";
  }
  values[5] = (void *)CFRetain(v5);
  values[6] = CFNumberCreate(v3, kCFNumberDoubleType, (const void *)v2);
  values[7] = CFNumberCreate(v3, kCFNumberDoubleType, (const void *)(v2 + 8));
  values[8] = CFNumberCreate(v3, kCFNumberDoubleType, (const void *)(v2 + 64));
  values[9] = CFNumberCreate(v3, kCFNumberDoubleType, &v7);
  CFRelease(v4);
  CFDictionaryCreate(v3, (const void **)keys, (const void **)values, 10, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (DRTailspinRequest())
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_debug_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG, "DiagnosticPipeline tailspin request successful.", buf, 2u);
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)statfs buf = 138412290;
    uint64_t v9 = 0;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "DiagnosticPipeline tailspin request failed with error: %@.", buf, 0xCu);
  }
}

void si_indexingWatchdogSuspend(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = (os_unfair_lock_s *)(a1 + 64);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
    int v3 = *(_DWORD *)(a1 + 68);
    *(_DWORD *)(a1 + 68) = v3 + 1;
    if (!v3)
    {
      uint64_t v4 = *(void *)(a1 + 40);
      if (v4)
      {
        uint64_t v5 = *(void *)(a1 + 48);
        double Current = CFAbsoluteTimeGetCurrent();
        double v7 = *(NSObject **)a1;
        if (gSILogLevels[0] >= 5)
        {
          uint64_t v10 = v5;
          long long v12 = *(NSObject **)a1;
          double v11 = Current;
          int v8 = *__error();
          uint64_t v9 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)statfs buf = 134218752;
            long long v14 = v12;
            __int16 v15 = 2048;
            uint64_t v16 = v4;
            __int16 v17 = 2048;
            uint64_t v18 = v10;
            __int16 v19 = 2048;
            double v20 = v11;
            _os_log_impl(&dword_1BD672000, v9, OS_LOG_TYPE_DEFAULT, "Suspending the indexing watchdog, timer:%p, delta:%llus, startTime:%.3f, suspendTime:%.3f", buf, 0x2Au);
          }
          *__error() = v8;
          double Current = v11;
          double v7 = v12;
        }
        *(double *)(a1 + 56) = Current;
        dispatch_suspend(v7);
      }
    }
    os_unfair_lock_unlock(v2);
  }
}

void si_indexingWatchdogResume(uint64_t a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = (os_unfair_lock_s *)(a1 + 64);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
    int v3 = *(_DWORD *)(a1 + 68) - 1;
    *(_DWORD *)(a1 + 68) = v3;
    if (!v3)
    {
      unint64_t v4 = *(void *)(a1 + 40);
      if (v4)
      {
        double v5 = *(double *)(a1 + 48);
        double v6 = *(double *)(a1 + 56);
        double v7 = v6 - v5;
        double v8 = (double)v4;
        if (v5 <= v6 && v7 < v8) {
          unint64_t v4 = (unint64_t)(v8 - v7);
        }
        if (v4 <= 0x3C) {
          uint64_t v10 = 60;
        }
        else {
          uint64_t v10 = v4;
        }
        double v11 = *(NSObject **)a1;
        if (gSILogLevels[0] >= 5)
        {
          uint64_t v16 = *(void *)(a1 + 48);
          uint64_t v17 = *(void *)(a1 + 56);
          uint64_t v18 = v10;
          int v14 = *__error();
          __int16 v15 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)statfs buf = 134218752;
            double v20 = v11;
            __int16 v21 = 2048;
            uint64_t v22 = v18;
            __int16 v23 = 2048;
            uint64_t v24 = v16;
            __int16 v25 = 2048;
            uint64_t v26 = v17;
            _os_log_impl(&dword_1BD672000, v15, OS_LOG_TYPE_DEFAULT, "Resuming the indexing watchdog, timer:%p, delta:%llus, startTime:%.3f, suspendTime:%.3f", buf, 0x2Au);
          }
          *__error() = v14;
          uint64_t v10 = v18;
        }
        *(void *)(a1 + 40) = v10;
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        *(CFAbsoluteTime *)(a1 + 48) = Current;
        *(CFAbsoluteTime *)(a1 + 112) = Current;
        *(unsigned char *)(a1 + 104) = 1;
        dispatch_time_t v13 = dispatch_time(0, 1000000000 * v10);
        dispatch_source_set_timer(v11, v13, 0xFFFFFFFFFFFFFFFFLL, 0);
        dispatch_resume(v11);
      }
    }
    os_unfair_lock_unlock(v2);
  }
}

void *MailQueryTree(__CFString *a1, const __CFDictionary *a2, uint64_t a3)
{
  uint64_t v320 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1CA20], "currentLocale"), "languageCode");
  if (v6) {
    double v7 = (__CFString *)v6;
  }
  else {
    double v7 = @"en";
  }
  if (*(unsigned char *)(a3 + 14))
  {
    double v8 = @"SpotlightUI";
  }
  else if (*(unsigned char *)(a3 + 16))
  {
    double v8 = @"SearchTool";
  }
  else
  {
    double v8 = @"Mail";
  }
  uint64_t v282 = (NSString *)[NSString stringWithFormat:@"[qid=%llu, rank=%d, rewrite=%d, lang: %@, bundle: %d, client: %@, class=%s]", *(void *)a3, *(unsigned __int8 *)(a3 + 12), *(unsigned __int8 *)(a3 + 17), v7, *(unsigned __int16 *)(a3 + 8), v8, *(void *)(a3 + 24)];
  unint64_t v9 = [(__CFString *)a1 length];
  std::string::size_type v10 = (std::string::size_type)a1;
  if (v9 >= 4) {
    std::string::size_type v10 = objc_msgSend(NSString, "stringWithFormat:", @"%c%c...%c<%lu chars>", -[__CFString characterAtIndex:](a1, "characterAtIndex:", 0), -[__CFString characterAtIndex:](a1, "characterAtIndex:", 1), -[__CFString characterAtIndex:](a1, "characterAtIndex:", v9 - 1), v9);
  }
  int v11 = *__error();
  long long v12 = _SILogForLogForCategory(19);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2112;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v10;
    _os_log_impl(&dword_1BD672000, v12, OS_LOG_TYPE_DEFAULT, "%@ Processing query: %@", (uint8_t *)&buf, 0x16u);
  }
  *__error() = v11;
  if (!a2) {
    goto LABEL_21;
  }
  if (!CFDictionaryContainsKey(a2, @"suggestionFilter")) {
    goto LABEL_21;
  }
  CFArrayRef Value = (void *)CFDictionaryGetValue(a2, @"suggestionFilter");
  if (!Value) {
    goto LABEL_21;
  }
  int v14 = *__error();
  __int16 v15 = _SILogForLogForCategory(19);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 138412290;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
    _os_log_impl(&dword_1BD672000, v15, OS_LOG_TYPE_DEFAULT, "%@ Query has suggestions", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v14;
  uint64_t v16 = (char *)[Value UTF8String];
  int v17 = *(unsigned __int8 *)(a3 + 12);
  query_node_with_anuint64_t n = db_make_query_node_with_ann(v16, 0);
  if (query_node_with_ann)
  {
    __int16 v19 = query_node_with_ann;
    unint64_t v278 = processNode((uint64_t)query_node_with_ann, v17 != 0);
    buf.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
    buf.__r_.__value_.__l.__size_ = 0x40000000;
    buf.__r_.__value_.__r.__words[2] = (std::string::size_type)__db_query_tree_apply_block_block_invoke;
    *(void *)v301 = &unk_1E6348598;
    *(void *)&v301[8] = &__block_literal_global_161;
    db_query_tree_apply_block_with_meta(v19, (uint64_t)&buf, 0);
    if (!a1) {
      goto LABEL_32;
    }
  }
  else
  {
LABEL_21:
    unint64_t v278 = 0;
    if (!a1)
    {
LABEL_32:
      int v25 = *__error();
      uint64_t v26 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412290;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
        _os_log_impl(&dword_1BD672000, v26, OS_LOG_TYPE_DEFAULT, "%@ Skipping query (Reason: it is empty)", (uint8_t *)&buf, 0xCu);
      }
      *__error() = v25;
      return v278;
    }
  }
  if (!CFStringGetLength(a1)) {
    goto LABEL_32;
  }
  CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef theString = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a1);
  CFLocaleRef v20 = CFLocaleCopyCurrent();
  CFStringLowercase(theString, v20);
  if (v20) {
    CFRelease(v20);
  }
  QueryTokens = (const __CFArray **)CreateQueryTokens(theString, 1);
  if (!QueryTokens)
  {
    int v31 = *__error();
    size_t v32 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 138412290;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
      _os_log_impl(&dword_1BD672000, v32, OS_LOG_TYPE_DEFAULT, "%@ Skipping query (Reason: Failed to tokenize)", (uint8_t *)&buf, 0xCu);
    }
    *__error() = v31;
    CFRelease(theString);
    return v278;
  }
  long long v273 = QueryTokens;
  CFArrayRef v22 = *QueryTokens;
  if (!v22 || (CFIndex Count = CFArrayGetCount(v22)) == 0)
  {
    int v29 = *__error();
    int v30 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 138412290;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
      _os_log_impl(&dword_1BD672000, v30, OS_LOG_TYPE_DEFAULT, "%@ Skipping query (Reason: No tokens in the query)", (uint8_t *)&buf, 0xCu);
    }
    *__error() = v29;
    freeQueryTokensContext((CFTypeRef *)v273);
    CFRelease(theString);
    return v278;
  }
  CFArrayRef theArray = *v273;
  CFArrayRef v276 = v273[2];
  CFArrayRef v277 = v273[1];
  uint64_t v263 = (void *)[MEMORY[0x1E4F1CA48] array];
  unsigned int v281 = (void *)[MEMORY[0x1E4F1CA48] array];
  uint64_t v262 = (void *)[MEMORY[0x1E4F1CA80] set];
  if (!a2 || !CFDictionaryContainsKey(a2, @"attributedParses"))
  {
    int v33 = *__error();
    int v34 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 138412290;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
      _os_log_impl(&dword_1BD672000, v34, OS_LOG_TYPE_DEFAULT, "%@ Skipping QP filters (Reason: QP output not present)", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_45;
  }
  __int16 v23 = (void *)CFDictionaryGetValue(a2, @"attributedParses");
  if ([v23 count] != 1)
  {
    if ((unint64_t)[v23 count] > 1)
    {
      uint64_t v24 = 1;
      goto LABEL_48;
    }
    int v33 = *__error();
    uint64_t v51 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 138412290;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
      _os_log_impl(&dword_1BD672000, v51, OS_LOG_TYPE_DEFAULT, "%@ Skipping QP filters (Reason: QP parse is empty array)", (uint8_t *)&buf, 0xCu);
    }
LABEL_45:
    *__error() = v33;
    goto LABEL_53;
  }
  uint64_t v24 = 0;
LABEL_48:
  pid_t v35 = (void *)[v23 objectAtIndexedSubscript:v24];
  *(void *)&long long v296 = 0;
  *((void *)&v296 + 1) = &v296;
  *(void *)&long long v297 = 0x3052000000;
  *((void *)&v297 + 1) = __Block_byref_object_copy__3057;
  *(void *)&long long v298 = __Block_byref_object_dispose__3058;
  *((void *)&v298 + 1) = 0;
  uint64_t v36 = [v35 length];
  buf.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
  buf.__r_.__value_.__l.__size_ = 3221225472;
  buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZL28MailPopulateFiltersFromParsePK14__CFDictionaryP14NSMutableArrayIP8NSStringEPS2_IP7NSValueEP12NSMutableSetIP8NSNumberES4__block_invoke;
  *(void *)v301 = &unk_1E6343840;
  *(void *)&v301[8] = v263;
  *(void *)&v301[16] = v281;
  unsigned int v302 = v262;
  unsigned int v303 = &v296;
  objc_msgSend(v35, "enumerateAttributesInRange:options:usingBlock:", 0, v36, 0, &buf);
  if ([v263 count])
  {
    int v37 = *__error();
    __int16 v38 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = [v263 count];
      uint64_t v40 = [v262 count];
      *(_DWORD *)statfs v318 = 138412802;
      *(void *)&v318[4] = v282;
      *(_WORD *)&v318[12] = 2048;
      *(void *)&v318[14] = v39;
      *(_WORD *)&v318[22] = 2048;
      *(void *)&v318[24] = v40;
      _os_log_impl(&dword_1BD672000, v38, OS_LOG_TYPE_DEFAULT, "%@ Populated %lu QP filters, special tokens: %lu", v318, 0x20u);
    }
    *__error() = v37;
  }
  _Block_object_dispose(&v296, 8);
LABEL_53:
  uint64_t v319 = 0;
  memset(v318, 0, sizeof(v318));
  std::string::basic_string[abi:nn180100]<0>(&buf, "kMDItemSubject");
  uint64_t v41 = (CFTypeRef *)v273;
  *(_DWORD *)v301 = 1056964608;
  std::string::basic_string[abi:nn180100]<0>(&v301[8], "kMDItemTextContent");
  LODWORD(v303) = 1036831949;
  std::string::basic_string[abi:nn180100]<0>(&v304, "kMDItemAuthors");
  int v305 = 1058642330;
  std::string::basic_string[abi:nn180100]<0>(v306, "kMDItemRecipients");
  int v307 = 0;
  std::string::basic_string[abi:nn180100]<0>(v308, "kMDItemEmailAddresses");
  int v309 = 0;
  std::string::basic_string[abi:nn180100]<0>(v310, "kMDItemAuthorEmailAddresses");
  int v311 = 0;
  std::string::basic_string[abi:nn180100]<0>(v312, "kMDItemRecipientEmailAddresses");
  int v313 = 0;
  std::string::basic_string[abi:nn180100]<0>(v314, "kMDItemAttachmentNames");
  int v315 = 0;
  std::string::basic_string[abi:nn180100]<0>(v316, "kMDItemAttachmentTypes");
  int v317 = 0;
  std::unordered_map<std::string,float>::unordered_map((uint64_t)v318, (uint64_t)&buf, 9);
  uint64_t v42 = 288;
  do
  {
    if (*((char *)&v299 + v42 + 7) < 0) {
      operator delete(*(void **)((char *)&v298 + v42));
    }
    v42 -= 32;
  }
  while (v42);
  uint64_t v295 = 0;
  long long v293 = 0u;
  long long v294 = 0u;
  std::string::basic_string[abi:nn180100]<0>(&buf, "kMDItemAuthors");
  *(_DWORD *)v301 = 1058642330;
  std::string::basic_string[abi:nn180100]<0>(&v301[8], "kMDItemSubject");
  LODWORD(v303) = 1056964608;
  std::unordered_map<std::string,float>::unordered_map((uint64_t)&v293, (uint64_t)&buf, 2);
  for (uint64_t i = 0; i != -64; i -= 32)
  {
    if (*((char *)&v302 + i + 7) < 0) {
      operator delete(*(void **)&v301[i + 8]);
    }
  }
  uint64_t v292 = 0;
  *(_OWORD *)int v290 = 0u;
  *(_OWORD *)int v291 = 0u;
  std::string::basic_string[abi:nn180100]<0>(&buf, "kMDItemSubject");
  *(_DWORD *)v301 = 1056964608;
  std::string::basic_string[abi:nn180100]<0>(&v301[8], "kMDItemTextContent");
  LODWORD(v303) = 1036831949;
  std::unordered_map<std::string,float>::unordered_map((uint64_t)v290, (uint64_t)&buf, 2);
  for (uint64_t j = 0; j != -64; j -= 32)
  {
    if (*((char *)&v302 + j + 7) < 0) {
      operator delete(*(void **)&v301[j + 8]);
    }
  }
  uint64_t v289 = 0;
  *(_OWORD *)std::string __p = 0u;
  *(_OWORD *)uint64_t v288 = 0u;
  std::string::basic_string[abi:nn180100]<0>(&buf, "*");
  *(_DWORD *)v301 = 1056964608;
  std::string::basic_string[abi:nn180100]<0>(&v301[8], "kMDItemTextContent");
  LODWORD(v303) = 1036831949;
  std::unordered_map<std::string,float>::unordered_map((uint64_t)__p, (uint64_t)&buf, 2);
  for (uint64_t k = 0; k != -64; k -= 32)
  {
    if (*((char *)&v302 + k + 7) < 0) {
      operator delete(*(void **)&v301[k + 8]);
    }
  }
  int v286 = -1;
  memset(v284, 0, sizeof(v284));
  uint64_t v285 = 1065353216;
  std::string::basic_string[abi:nn180100]<0>(&buf, "kMDItemAuthors");
  *(_DWORD *)v301 = 1058642330;
  std::string::basic_string[abi:nn180100]<0>(&v301[8], "kMDItemAuthorEmailAddresses");
  LODWORD(v303) = 1053609166;
  __int16 v46 = std::__hash_table<std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<std::string,float>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)v284, 0, &TOK_ID_FROM);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__assign_unique<std::pair<std::string const,float> const*>(v46 + 3, &buf, &v304);
  for (uint64_t m = 0; m != -64; m -= 32)
  {
    if (*((char *)&v302 + m + 7) < 0) {
      operator delete(*(void **)&v301[m + 8]);
    }
  }
  std::string::basic_string[abi:nn180100]<0>(&buf, "kMDItemRecipients");
  *(_DWORD *)v301 = 1057803469;
  std::string::basic_string[abi:nn180100]<0>(&v301[8], "kMDItemRecipientEmailAddresses");
  LODWORD(v303) = 1051931444;
  __int16 v48 = std::__hash_table<std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<std::string,float>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)v284, 1, &TOK_ID_TO);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__assign_unique<std::pair<std::string const,float> const*>(v48 + 3, &buf, &v304);
  for (uint64_t n = 0; n != -64; n -= 32)
  {
    if (*((char *)&v302 + n + 7) < 0) {
      operator delete(*(void **)&v301[n + 8]);
    }
  }
  obuint64_t j = (id)[MEMORY[0x1E4F1CA60] dictionary];
  if ([(__CFString *)v7 isEqualToString:@"en"])
  {
    [obj setObject:&unk_1F181C880 forKeyedSubscript:@"from"];
    [obj setObject:&unk_1F181C880 forKeyedSubscript:@"from:"];
    [obj setObject:&unk_1F181C898 forKeyedSubscript:@"to"];
    [obj setObject:&unk_1F181C898 forKeyedSubscript:@"to:"];
    [obj setObject:&unk_1F181C8B0 forKeyedSubscript:@"mail"];
    [obj setObject:&unk_1F181C8B0 forKeyedSubscript:@"mails"];
    [obj setObject:&unk_1F181C8B0 forKeyedSubscript:@"email"];
    [obj setObject:&unk_1F181C8B0 forKeyedSubscript:@"emails"];
    [obj setObject:&unk_1F181C8B0 forKeyedSubscript:@"message"];
    [obj setObject:&unk_1F181C8B0 forKeyedSubscript:@"messages"];
    [obj setObject:&unk_1F181C8B0 forKeyedSubscript:@"sent"];
    [obj setObject:&unk_1F181C8B0 forKeyedSubscript:@"date"];
    [obj setObject:&unk_1F181C8B0 forKeyedSubscript:@"date:"];
    [obj setObject:&unk_1F181C8C8 forKeyedSubscript:@"about"];
    [obj setObject:&unk_1F181C8C8 forKeyedSubscript:@"with"];
    [obj setObject:&unk_1F181C8E0 forKeyedSubscript:@"and"];
    [obj setObject:&unk_1F181C8F8 forKeyedSubscript:@"attachment"];
    __int16 v50 = @"attachments";
LABEL_90:
    [obj setObject:&unk_1F181C8F8 forKeyedSubscript:v50];
    goto LABEL_91;
  }
  if ([(__CFString *)v7 isEqualToString:@"fr"])
  {
    [obj setObject:&unk_1F181C880 forKeyedSubscript:@"de"];
    [obj setObject:&unk_1F181C880 forKeyedSubscript:@"de:"];
    [obj setObject:&unk_1F181C898 forKeyedSubscript:@""];
    [obj setObject:&unk_1F181C898 forKeyedSubscript:@":"];
    [obj setObject:&unk_1F181C8C8 forKeyedSubscript:@" propos"];
    [obj setObject:&unk_1F181C8C8 forKeyedSubscript:@"avec"];
    [obj setObject:&unk_1F181C8E0 forKeyedSubscript:@"et"];
    [obj setObject:&unk_1F181C8F8 forKeyedSubscript:@"pice jointe"];
    __int16 v50 = @"pices jointes";
    goto LABEL_90;
  }
  if ([(__CFString *)v7 isEqualToString:@"ja"])
  {
    [obj setObject:&unk_1F181C880 forKeyedSubscript:@""];
    [obj setObject:&unk_1F181C880 forKeyedSubscript:@":"];
    [obj setObject:&unk_1F181C898 forKeyedSubscript:@""];
    [obj setObject:&unk_1F181C898 forKeyedSubscript:@":"];
    [obj setObject:&unk_1F181C8C8 forKeyedSubscript:@""];
    [obj setObject:&unk_1F181C8C8 forKeyedSubscript:@""];
    [obj setObject:&unk_1F181C8E0 forKeyedSubscript:@""];
    __int16 v50 = @"";
    goto LABEL_90;
  }
  if ([(__CFString *)v7 isEqualToString:@"zh"])
  {
    [obj setObject:&unk_1F181C880 forKeyedSubscript:@""];
    [obj setObject:&unk_1F181C880 forKeyedSubscript:@":"];
    [obj setObject:&unk_1F181C898 forKeyedSubscript:@""];
    [obj setObject:&unk_1F181C898 forKeyedSubscript:@":"];
    [obj setObject:&unk_1F181C8C8 forKeyedSubscript:@""];
    [obj setObject:&unk_1F181C8C8 forKeyedSubscript:@""];
    [obj setObject:&unk_1F181C8E0 forKeyedSubscript:@""];
    [obj setObject:&unk_1F181C8E0 forKeyedSubscript:@""];
    __int16 v50 = @"";
    goto LABEL_90;
  }
  if ([(__CFString *)v7 isEqualToString:@"de"])
  {
    [obj setObject:&unk_1F181C880 forKeyedSubscript:@"von"];
    [obj setObject:&unk_1F181C880 forKeyedSubscript:@"von:"];
    [obj setObject:&unk_1F181C898 forKeyedSubscript:@"an"];
    [obj setObject:&unk_1F181C898 forKeyedSubscript:@"an:"];
    [obj setObject:&unk_1F181C8C8 forKeyedSubscript:@"ber"];
    [obj setObject:&unk_1F181C8C8 forKeyedSubscript:@"mit"];
    [obj setObject:&unk_1F181C8C8 forKeyedSubscript:@"um"];
    [obj setObject:&unk_1F181C8E0 forKeyedSubscript:@"und"];
    [obj setObject:&unk_1F181C8F8 forKeyedSubscript:@"Anhang"];
    __int16 v50 = @"Anhnge";
    goto LABEL_90;
  }
LABEL_91:
  uint64_t v260 = (void *)[MEMORY[0x1E4F28B88] characterSetWithCharactersInString:@"-~"];
  long long v271 = (void *)[MEMORY[0x1E4F28B88] characterSetWithCharactersInString:@"\"'"];
  CFIndex v270 = Count - 1;
  if (Count < 1)
  {
    uint64_t v265 = 0;
    long long v269 = 0;
    unint64_t v210 = 0;
    uint64_t v207 = (uint64_t)v278;
    goto LABEL_408;
  }
  CFIndex v52 = 0;
  uint64_t v264 = 0;
  uint64_t v265 = 0;
  long long v269 = 0;
  int range_8 = 0;
  int v256 = 0;
  int v261 = 0;
  char v257 = 0;
  LOBYTE(v53) = 0;
  uint64_t v258 = 0;
  float v54 = 0.0;
  uint64_t v259 = -1;
  CFIndex range = -1;
  do
  {
    uint64_t RangeAtIndex = getRangeAtIndex(v277, v276, v52);
    NSUInteger v57 = v56;
    if (RangeAtIndex == -1)
    {
      int v65 = *__error();
      int v66 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138413058;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2048;
        *(void *)v301 = -1;
        *(_WORD *)&v301[8] = 2048;
        *(void *)&v301[10] = v57;
        _os_log_impl(&dword_1BD672000, v66, OS_LOG_TYPE_DEFAULT, "%@ Token %lu skipped (Reason: it has invalid range (%ld, %ld))", (uint8_t *)&buf, 0x2Au);
      }
      *__error() = v65;
      goto LABEL_108;
    }
    NSUInteger v58 = RangeAtIndex;
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v52);
    long long v60 = (__CFString *)ValueAtIndex;
    if (!ValueAtIndex || !CFStringGetLength(ValueAtIndex))
    {
      int v62 = *__error();
      long long v63 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
        _os_log_impl(&dword_1BD672000, v63, OS_LOG_TYPE_DEFAULT, "%@ Token %lu skipped (Reason: it is zero-length)", (uint8_t *)&buf, 0x16u);
      }
LABEL_103:
      long long v64 = __error();
LABEL_104:
      int *v64 = v62;
      goto LABEL_108;
    }
    if (![(__CFString *)v60 length])
    {
      int v62 = *__error();
      char v67 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
        _os_log_impl(&dword_1BD672000, v67, OS_LOG_TYPE_DEFAULT, "%@ Token %lu skipped (Reason: token is empty)", (uint8_t *)&buf, 0x16u);
      }
      goto LABEL_103;
    }
    long long v61 = (char *)[(__CFString *)v60 UTF8String];
    if (![(__CFString *)v60 length] || !v61)
    {
      int v62 = *__error();
      long long v68 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
        _os_log_impl(&dword_1BD672000, v68, OS_LOG_TYPE_DEFAULT, "%@ Token %lu skipped (Reason: Unicode encoding failed)", (uint8_t *)&buf, 0x16u);
      }
      goto LABEL_103;
    }
    if ([obj objectForKeyedSubscript:v60]) {
      unsigned int range_12 = objc_msgSend((id)objc_msgSend(obj, "objectForKeyedSubscript:", v60), "intValue");
    }
    else {
      unsigned int range_12 = -1;
    }
    if ([v281 count])
    {
      uint64_t v69 = 0;
      while (1)
      {
        v322.locatiouint64_t n = objc_msgSend((id)objc_msgSend(v281, "objectAtIndexedSubscript:", v69), "rangeValue");
        v322.uint64_t length = v70;
        v321.locatiouint64_t n = v58;
        v321.uint64_t length = v57;
        if (NSIntersectionRange(v321, v322).length) {
          break;
        }
        if (++v69 >= (unint64_t)[v281 count]) {
          goto LABEL_121;
        }
      }
    }
    else
    {
LABEL_121:
      uint64_t v69 = -1;
    }
    int v71 = *__error();
    __n128 v72 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v73 = [(__CFString *)v60 length];
      LODWORD(buf.__r_.__value_.__l.__data_) = 138413314;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2048;
      *(void *)v301 = v73;
      *(_WORD *)&v301[8] = 1024;
      *(_DWORD *)&v301[10] = range_12;
      *(_WORD *)&v301[14] = 2048;
      *(void *)&v301[16] = v69;
      _os_log_impl(&dword_1BD672000, v72, OS_LOG_TYPE_DEFAULT, "%@ Token %lu <%lu chars>: type = %d, parseIdx = %ld", (uint8_t *)&buf, 0x30u);
    }
    *__error() = v71;
    if (objc_msgSend(v271, "characterIsMember:", -[__CFString characterAtIndex:](v60, "characterAtIndex:", -[__CFString rangeOfComposedCharacterSequenceAtIndex:](v60, "rangeOfComposedCharacterSequenceAtIndex:", 0))))
    {
      int v74 = *__error();
      long long v75 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
        _os_log_impl(&dword_1BD672000, v75, OS_LOG_TYPE_DEFAULT, "%@ Token %lu started double quote mode", (uint8_t *)&buf, 0x16u);
      }
      *__error() = v74;
      int range_8 = 1;
      CFIndex range = v58;
LABEL_129:
      int v76 = objc_msgSend(v271, "characterIsMember:", -[__CFString characterAtIndex:](v60, "characterAtIndex:", -[__CFString rangeOfComposedCharacterSequenceAtIndex:](v60, "rangeOfComposedCharacterSequenceAtIndex:", -[__CFString length](v60, "length") - 1)));
      if (v76)
      {
        int v77 = *__error();
        unsigned __int16 v78 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
          _os_log_impl(&dword_1BD672000, v78, OS_LOG_TYPE_DEFAULT, "%@ Token %lu ended double quote mode", (uint8_t *)&buf, 0x16u);
        }
        *__error() = v77;
      }
      else if (v52 != v270)
      {
        LOBYTE(v53) = 1;
        goto LABEL_108;
      }
      v323.locatiouint64_t n = range;
      v323.uint64_t length = v58 + v57 - range;
      unint64_t v79 = (__CFString *)CFStringCreateWithSubstring(alloc, theString, v323);
      unsigned __int16 v80 = v79;
      int v53 = v76 ^ 1;
      if (!v79) {
        goto LABEL_160;
      }
      if (![(__CFString *)v79 length]) {
        goto LABEL_145;
      }
      uint64_t v81 = [(__CFString *)v80 rangeOfComposedCharacterSequenceAtIndex:0];
      uint64_t v83 = v82;
      unsigned int v84 = v80;
      if (objc_msgSend(v271, "characterIsMember:", -[__CFString characterAtIndex:](v80, "characterAtIndex:", v81)))unsigned int v84 = (__CFString *)-[__CFString substringFromIndex:](v80, "substringFromIndex:", v81 + v83); {
      if ([(__CFString *)v84 length])
      }
      {
        uint64_t v85 = [(__CFString *)v84 rangeOfComposedCharacterSequenceAtIndex:[(__CFString *)v84 length] - 1];
        if (objc_msgSend(v271, "characterIsMember:", -[__CFString characterAtIndex:](v84, "characterAtIndex:", v85)))unsigned int v84 = (__CFString *)-[__CFString substringToIndex:](v84, "substringToIndex:", v85); {
      }
        }
      else
      {
LABEL_145:
        unsigned int v84 = 0;
      }
      CFRelease(v80);
      if (!v84)
      {
LABEL_160:
        int v62 = *__error();
        uint64_t v97 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
          _os_log_impl(&dword_1BD672000, v97, OS_LOG_TYPE_DEFAULT, "%@ Token %lu skipped (Reason: it is empty after quote stripping)", (uint8_t *)&buf, 0x16u);
        }
        goto LABEL_103;
      }
      unsigned int v88 = (char *)[(__CFString *)v84 UTF8String];
      if (!v88)
      {
        int v62 = *__error();
        uint64_t v98 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
          _os_log_impl(&dword_1BD672000, v98, OS_LOG_TYPE_DEFAULT, "%@ Token %lu skipped (Reason: quote stripped string not UTF8 encodable)", (uint8_t *)&buf, 0x16u);
        }
        goto LABEL_103;
      }
      int v89 = v286;
      if (v286 != -1)
      {
        int v90 = *__error();
        unint64_t v91 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 138412802;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
          *(_DWORD *)v301 = v89;
          _os_log_impl(&dword_1BD672000, v91, OS_LOG_TYPE_DEFAULT, "%@ Token %lu with quotes and cmd=%d added as a filter", (uint8_t *)&buf, 0x1Cu);
        }
        *__error() = v90;
        uint64_t v92 = std::__hash_table<std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<std::string,float>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)v284, v89, &v286)[5];
        if (*(unsigned char *)(a3 + 12))
        {
          if (v92)
          {
            unint64_t v93 = 0;
            do
            {
              float v94 = *(float *)(v92 + 40);
              if (v94 != 0.0)
              {
                unsigned int v95 = (const char *)(v92 + 16);
                if (*(char *)(v92 + 39) < 0) {
                  unsigned int v95 = *(const char **)v95;
                }
                QueryNode = createQueryNode(v95, v88, 112, 1, v53 << 31 >> 31, v94 + 0.0, 0.0);
                unint64_t v93 = makeOrNode((uint64_t)v93, (uint64_t)QueryNode);
              }
              uint64_t v92 = *(void *)v92;
            }
            while (v92);
            goto LABEL_250;
          }
        }
        else if (v92)
        {
          unint64_t v93 = 0;
          do
          {
            int v143 = (const char *)(v92 + 16);
            if (*(char *)(v92 + 39) < 0) {
              int v143 = *(const char **)v143;
            }
            uint64_t v144 = createQueryNode(v143, v88, 112, 1, v53 << 31 >> 31, 0.0, 0.0);
            unint64_t v93 = makeOrNode((uint64_t)v93, (uint64_t)v144);
            uint64_t v92 = *(void *)v92;
          }
          while (v92);
          goto LABEL_250;
        }
        unint64_t v93 = 0;
LABEL_250:
        long long v269 = makeAndNode((uint64_t)v269, (uint64_t)v93);
        int v286 = -1;
        goto LABEL_108;
      }
      int v127 = *__error();
      os_log_type_t v128 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
        _os_log_impl(&dword_1BD672000, v128, OS_LOG_TYPE_DEFAULT, "%@ Token: %lu with quotes added as bigram node with all attribs", (uint8_t *)&buf, 0x16u);
      }
      *__error() = v127;
      float v129 = MailAttribNode(*(unsigned char *)(a3 + 12), *(uint64_t **)&v318[16], v88, v53, 0.0);
      long long v269 = makeAndNode((uint64_t)v269, (uint64_t)v129);
      goto LABEL_108;
    }
    if (v53) {
      goto LABEL_129;
    }
    unsigned int v86 = v286;
    if (v69 == -1 && v286 == -1)
    {
      if (v52 == v270)
      {
        int v87 = -1;
      }
      else
      {
        if (range_12 > 1) {
          int v87 = -1;
        }
        else {
          int v87 = range_12;
        }
        int v286 = v87;
        if (range_12 < 2)
        {
          LOBYTE(v53) = 0;
          int v261 = 1;
          uint64_t v258 = v60;
          goto LABEL_108;
        }
      }
      unsigned int v255 = v87;
      int v283 = -1;
      long long v296 = 0u;
      long long v297 = 0u;
      long long v298 = 0u;
      long long v299 = 0u;
      uint64_t v99 = [obj countByEnumeratingWithState:&v296 objects:&buf count:16];
      if (v99)
      {
        uint64_t v100 = *(void *)v297;
LABEL_173:
        uint64_t v101 = 0;
        while (1)
        {
          if (*(void *)v297 != v100) {
            objc_enumerationMutation(obj);
          }
          unint64_t v102 = *(void **)(*((void *)&v296 + 1) + 8 * v101);
          unsigned int v103 = objc_msgSend((id)objc_msgSend(obj, "objectForKeyedSubscript:", v102), "intValue");
          if (v103 <= 1
            && [v102 hasSuffix:@":"]
            && ([(__CFString *)v60 hasPrefix:v102] & 1) != 0)
          {
            break;
          }
          if (v99 == ++v101)
          {
            uint64_t v99 = [obj countByEnumeratingWithState:&v296 objects:&buf count:16];
            if (v99) {
              goto LABEL_173;
            }
            goto LABEL_190;
          }
        }
        int v283 = v103;
        uint64_t v104 = (void *)-[__CFString substringFromIndex:](v60, "substringFromIndex:", [v102 length]);
        if (![v104 length]) {
          goto LABEL_190;
        }
        float v105 = (char *)[v104 UTF8String];
        if (v105)
        {
          int v106 = *__error();
          uint64_t v107 = _SILogForLogForCategory(19);
          if (os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf.__r_.__value_.__l.__data_) = 138412802;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
            HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
            *(_DWORD *)v301 = v103;
            _os_log_impl(&dword_1BD672000, v107, OS_LOG_TYPE_DEFAULT, "%@ Token %lu (cmd=%d with concat str) added as filter", (uint8_t *)&buf, 0x1Cu);
          }
          *__error() = v106;
          unint64_t v108 = std::__hash_table<std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<std::string,float>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)v284, v103, &v283);
          uint64_t v109 = MailAttribNode(*(unsigned char *)(a3 + 12), (uint64_t *)v108[5], v105, v52 == v270, 0.0);
          if (*(unsigned char *)(a3 + 12) && v52 == v270)
          {
            int v110 = std::__hash_table<std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<std::string,float>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)v284, v103, &v283);
            uint64_t v111 = MailAttribNode(*(unsigned char *)(a3 + 12), (uint64_t *)v110[5], v105, 0, 0.2);
            uint64_t v109 = makeOrNode((uint64_t)v109, (uint64_t)v111);
          }
          long long v269 = makeAndNode((uint64_t)v269, (uint64_t)v109);
        }
        else
        {
          int v173 = *__error();
          unsigned int v174 = _SILogForLogForCategory(19);
          if (os_log_type_enabled(v174, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf.__r_.__value_.__l.__data_) = 138413058;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
            HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
            *(_DWORD *)v301 = v103;
            *(_WORD *)&v301[4] = 2112;
            *(void *)&v301[6] = v60;
            _os_log_impl(&dword_1BD672000, v174, OS_LOG_TYPE_DEFAULT, "%@ Token %lu (cmd=%d with concat str) skipped (Reason: failed to get str from <%@>)", (uint8_t *)&buf, 0x26u);
          }
          *__error() = v173;
        }
        LOBYTE(v53) = 0;
        int v286 = -1;
        int v261 = 1;
        goto LABEL_303;
      }
LABEL_190:
      unsigned int v86 = v255;
    }
    if (v86 <= 1)
    {
      uint64_t v112 = std::__hash_table<std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<std::string,float>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)v284, v86, &v286);
      float v113 = (float)(v257 & 1);
      if (v52 == v270) {
        int v114 = -1;
      }
      else {
        int v114 = 0;
      }
      uint64_t v115 = v112[5];
      if (*(unsigned char *)(a3 + 12))
      {
        if (v115)
        {
          unint64_t v116 = 0;
          do
          {
            float v117 = *(float *)(v115 + 40);
            if (v117 != 0.0)
            {
              unint64_t v118 = (const char *)(v115 + 16);
              if (*(char *)(v115 + 39) < 0) {
                unint64_t v118 = *(const char **)v118;
              }
              BOOL v119 = createQueryNode(v118, v61, 112, 1, v114, v117 + v113, 0.0);
              unint64_t v116 = makeOrNode((uint64_t)v116, (uint64_t)v119);
            }
            uint64_t v115 = *(void *)v115;
          }
          while (v115);
          goto LABEL_226;
        }
LABEL_225:
        unint64_t v116 = 0;
        goto LABEL_226;
      }
      if (!v115) {
        goto LABEL_225;
      }
      unint64_t v116 = 0;
      do
      {
        uint64_t v131 = (const char *)(v115 + 16);
        if (*(char *)(v115 + 39) < 0) {
          uint64_t v131 = *(const char **)v131;
        }
        unsigned int v132 = createQueryNode(v131, v61, 112, 1, v114, 0.0, 0.0);
        unint64_t v116 = makeOrNode((uint64_t)v116, (uint64_t)v132);
        uint64_t v115 = *(void *)v115;
      }
      while (v115);
LABEL_226:
      if (*(unsigned char *)(a3 + 17))
      {
        if ((unint64_t)[(__CFString *)v60 length] >= 3)
        {
          int v133 = v286;
          unsigned int v134 = std::__hash_table<std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<std::string,float>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)v284, v286, &v286);
          unint64_t v135 = MailTokenRewriteNode(v60, a3, (uint64_t)(v134 + 3));
          if (v135)
          {
            int v136 = *__error();
            CFIndex v137 = _SILogForLogForCategory(19);
            if (os_log_type_enabled(v137, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf.__r_.__value_.__l.__data_) = 138412802;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
              WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
              *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
              HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
              *(_DWORD *)v301 = v133;
              _os_log_impl(&dword_1BD672000, v137, OS_LOG_TYPE_DEFAULT, "%@ Token %lu (cmd=%d) has rewrites", (uint8_t *)&buf, 0x1Cu);
            }
            *__error() = v136;
            unint64_t v116 = makeOrNode((uint64_t)v116, (uint64_t)v135);
          }
        }
      }
      if (*(unsigned char *)(a3 + 12) && v52 == v270)
      {
        uint64_t v138 = std::__hash_table<std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<std::string,float>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)v284, v286, &v286)[5];
        if (*(unsigned char *)(a3 + 12))
        {
          if (v138)
          {
            CFIndex v139 = 0;
            do
            {
              float v140 = *(float *)(v138 + 40);
              if (v140 != 0.0)
              {
                int v141 = (const char *)(v138 + 16);
                if (*(char *)(v138 + 39) < 0) {
                  int v141 = *(const char **)v141;
                }
                unint64_t v142 = createQueryNode(v141, v61, 112, 1, 0, (float)(v113 + 0.2) + v140, 0.0);
                CFIndex v139 = makeOrNode((uint64_t)v139, (uint64_t)v142);
              }
              uint64_t v138 = *(void *)v138;
            }
            while (v138);
            goto LABEL_270;
          }
LABEL_269:
          CFIndex v139 = 0;
          goto LABEL_270;
        }
        if (!v138) {
          goto LABEL_269;
        }
        CFIndex v139 = 0;
        do
        {
          unint64_t v151 = (const char *)(v138 + 16);
          if (*(char *)(v138 + 39) < 0) {
            unint64_t v151 = *(const char **)v151;
          }
          int v152 = createQueryNode(v151, v61, 112, 1, 0, 0.0, 0.0);
          CFIndex v139 = makeOrNode((uint64_t)v139, (uint64_t)v152);
          uint64_t v138 = *(void *)v138;
        }
        while (v138);
LABEL_270:
        unint64_t v116 = makeOrNode((uint64_t)v116, (uint64_t)v139);
      }
      if ([(__CFString *)v258 length] && [(__CFString *)v258 UTF8String])
      {
        if (v257)
        {
          BOOL v153 = (char *)[(__CFString *)v258 UTF8String];
          uint64_t v154 = MailAttribNode(*(unsigned char *)(a3 + 12), (uint64_t *)v291[0], v153, 0, 0.0);
          unint64_t v155 = MailAttribNode(*(unsigned char *)(a3 + 12), (uint64_t *)v291[0], v61, v52 == v270, 0.0);
          int v156 = makeAndNode((uint64_t)v154, (uint64_t)v155);
          unint64_t v116 = makeOrNode((uint64_t)v116, (uint64_t)v156);
          goto LABEL_280;
        }
        int v157 = (void *)[NSString stringWithFormat:@"%@ %@", v258, v60];
        if (![v157 length]) {
          goto LABEL_280;
        }
        double v158 = (char *)[v157 UTF8String];
        if (!v158) {
          goto LABEL_280;
        }
        uint64_t v159 = MailAttribNode(*(unsigned char *)(a3 + 12), (uint64_t *)v291[0], v158, v52 == v270, 0.0);
        int v160 = makeOrNode((uint64_t)v116, (uint64_t)v159);
        long long v269 = makeAndNode((uint64_t)v269, (uint64_t)v160);
        int v161 = *__error();
        unint64_t v162 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v162, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 138412802;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
          *(_DWORD *)v301 = v286;
          _os_log_impl(&dword_1BD672000, v162, OS_LOG_TYPE_DEFAULT, "%@ Token %lu (cmd=%d) added as filter + joint str", (uint8_t *)&buf, 0x1Cu);
        }
      }
      else
      {
LABEL_280:
        long long v269 = makeAndNode((uint64_t)v269, (uint64_t)v116);
        int v161 = *__error();
        unsigned int v163 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 138412802;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
          *(_DWORD *)v301 = v286;
          _os_log_impl(&dword_1BD672000, v163, OS_LOG_TYPE_DEFAULT, "%@ Token %lu (cmd=%d) added as filter only", (uint8_t *)&buf, 0x1Cu);
        }
      }
      *__error() = v161;
      if (v264)
      {
        if (v259 == -1)
        {
          int v169 = *__error();
          uint64_t v170 = _SILogForLogForCategory(19);
          if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
            _os_log_impl(&dword_1BD672000, v170, OS_LOG_TYPE_DEFAULT, "%@ Token %lu (cmd) led to optionalizing prev special node", (uint8_t *)&buf, 0x16u);
          }
          *__error() = v169;
          db_free_query_node(v264);
        }
        else
        {
          int v164 = *__error();
          unint64_t v165 = _SILogForLogForCategory(19);
          if (os_log_type_enabled(v165, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
            _os_log_impl(&dword_1BD672000, v165, OS_LOG_TYPE_DEFAULT, "%@ Token %lu led to committing prev special node", (uint8_t *)&buf, 0x16u);
          }
          *__error() = v164;
          unsigned int v166 = db_make_query_node_with_ann((char *)objc_msgSend((id)objc_msgSend(v263, "objectAtIndexedSubscript:", v259), "UTF8String"), 0);
          uint64_t v167 = (uint64_t)v166;
          if (*(unsigned char *)(a3 + 12))
          {
            buf.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
            buf.__r_.__value_.__l.__size_ = 3221225472;
            buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZL15MailNodeFromStrP9PRContextPKcf_block_invoke;
            *(void *)v301 = &__block_descriptor_36_e87__v16__0__query_node___query_node___query_node___query_piece_____v___v__v_SIb8b1b1b1Qf_8l;
            *(_DWORD *)&v301[8] = 1045220557;
            db_query_tree_apply_block(v166, &buf, 0);
          }
          uint64_t v168 = makeOrNode((uint64_t)v264, v167);
          long long v269 = makeAndNode((uint64_t)v269, (uint64_t)v168);
        }
      }
      LOBYTE(v53) = 0;
      uint64_t v264 = 0;
      float v54 = (float)(v113 + 1.0) + v54;
      int v286 = -1;
LABEL_303:
      int range_8 = 1;
      goto LABEL_108;
    }
    if (objc_msgSend(v260, "characterIsMember:", -[__CFString characterAtIndex:](v60, "characterAtIndex:", -[__CFString rangeOfComposedCharacterSequenceAtIndex:](v60, "rangeOfComposedCharacterSequenceAtIndex:", 0))))
    {
      int v120 = *__error();
      uint64_t v121 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
        _os_log_impl(&dword_1BD672000, v121, OS_LOG_TYPE_DEFAULT, "%@ Token %lu has a negation before it", (uint8_t *)&buf, 0x16u);
      }
      *__error() = v120;
      uint64_t v122 = [(__CFString *)v60 rangeOfComposedCharacterSequenceAtIndex:0];
      int64_t v124 = (void *)[(__CFString *)v60 substringFromIndex:v122 + v123];
      if ([v124 length])
      {
        int v125 = (char *)[v124 UTF8String];
        if (v125)
        {
          int v126 = MailAttribNegNode(*(unsigned char *)(a3 + 12), (uint64_t *)v288[0], v125, v52 == v270);
          long long v269 = makeAndNode((uint64_t)v269, (uint64_t)v126);
          LOBYTE(v53) = 0;
          goto LABEL_303;
        }
        int v171 = *__error();
        os_log_type_t v175 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v175, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
          _os_log_impl(&dword_1BD672000, v175, OS_LOG_TYPE_DEFAULT, "%@ Token: %lu skipped (Reason: neg removed str is not UTF8 encodable)", (uint8_t *)&buf, 0x16u);
        }
      }
      else
      {
        int v171 = *__error();
        unint64_t v172 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v172, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
          _os_log_impl(&dword_1BD672000, v172, OS_LOG_TYPE_DEFAULT, "%@ Token: %lu skipped (Reason: neg removed str is empty)", (uint8_t *)&buf, 0x16u);
        }
      }
      LOBYTE(v53) = 0;
      *__error() = v171;
      goto LABEL_303;
    }
    if (range_12 == 3)
    {
      if ((v52 == 0) | (v261 | v256) & 1 && v52 != v270)
      {
        int v62 = *__error();
        double v130 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
          _os_log_impl(&dword_1BD672000, v130, OS_LOG_TYPE_DEFAULT, "%@ Token %lu optionalized (Reason: follows a cmd)", (uint8_t *)&buf, 0x16u);
        }
LABEL_257:
        long long v64 = __error();
        LOBYTE(v53) = 0;
        goto LABEL_104;
      }
    }
    else if (v52 && range_12 == 4 && v52 != v270)
    {
      int v62 = *__error();
      os_log_type_t v145 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
        _os_log_impl(&dword_1BD672000, v145, OS_LOG_TYPE_DEFAULT, "%@ Token %lu optionalized (Reason: acts as BOOLean op.)", (uint8_t *)&buf, 0x16u);
      }
      goto LABEL_257;
    }
    if (!*(unsigned char *)(a3 + 12))
    {
      int v176 = *__error();
      uint64_t v177 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v177, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
        _os_log_impl(&dword_1BD672000, v177, OS_LOG_TYPE_DEFAULT, "%@ Token %lu added with all attribs", (uint8_t *)&buf, 0x16u);
      }
      *__error() = v176;
      BOOL v178 = v52 == v270;
      goto LABEL_310;
    }
    if (v52 != v270)
    {
      int v179 = *__error();
      uint64_t v180 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v180, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
        _os_log_impl(&dword_1BD672000, v180, OS_LOG_TYPE_DEFAULT, "%@ Token %lu added as word match node", (uint8_t *)&buf, 0x16u);
      }
      uint64_t v181 = __error();
      BOOL v178 = 0;
      *uint64_t v181 = v179;
LABEL_310:
      int v150 = MailAttribNode(*(unsigned char *)(a3 + 12), *(uint64_t **)&v318[16], v61, v178, 0.0);
      goto LABEL_311;
    }
    int v146 = *__error();
    uint64_t v147 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = Count - 1;
      _os_log_impl(&dword_1BD672000, v147, OS_LOG_TYPE_DEFAULT, "%@ Token %lu (last token) added as prefix + word match", (uint8_t *)&buf, 0x16u);
    }
    *__error() = v146;
    uint64_t v148 = MailAttribNode(*(unsigned char *)(a3 + 12), *(uint64_t **)&v318[16], v61, 1, 0.0);
    uint64_t v149 = MailAttribNode(*(unsigned char *)(a3 + 12), (uint64_t *)v294, v61, 0, 0.2);
    int v150 = makeOrNode((uint64_t)v148, (uint64_t)v149);
LABEL_311:
    unsigned int v182 = v150;
    if (range_12 == 5)
    {
      int v183 = *__error();
      uint64_t v184 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v184, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
        _os_log_impl(&dword_1BD672000, v184, OS_LOG_TYPE_DEFAULT, "%@ Token %lu added with attachment rule", (uint8_t *)&buf, 0x16u);
      }
      *__error() = v183;
      unsigned int v185 = MailNodeFromStr(a3, "(com_apple_mail_attachmentTypes=\"*\" || kMDItemAttachmentTypes=\"*\")");
      unsigned int v182 = makeOrNode((uint64_t)v182, (uint64_t)v185);
      int v261 = 1;
    }
    if (*(unsigned char *)(a3 + 17))
    {
      if ((unint64_t)[(__CFString *)v60 length] >= 3)
      {
        long long v186 = MailTokenRewriteNode(v60, a3, (uint64_t)v318);
        if (v186)
        {
          int v187 = *__error();
          long long v188 = _SILogForLogForCategory(19);
          if (os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
            _os_log_impl(&dword_1BD672000, v188, OS_LOG_TYPE_DEFAULT, "%@ Token %lu has rewrites", (uint8_t *)&buf, 0x16u);
          }
          *__error() = v187;
          unsigned int v182 = makeOrNode((uint64_t)v182, (uint64_t)v186);
        }
      }
    }
    float v54 = v54 + 1.0;
    if (range_12 == 2 || v69 != -1)
    {
      if (range_12 == 2
        || objc_msgSend(v262, "containsObject:", objc_msgSend(NSNumber, "numberWithLong:", v69)))
      {
        if (v264)
        {
          int v189 = *__error();
          long long v190 = _SILogForLogForCategory(19);
          if (os_log_type_enabled(v190, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
            _os_log_impl(&dword_1BD672000, v190, OS_LOG_TYPE_DEFAULT, "%@ Token %lu (special) led to optionalizing prev special node", (uint8_t *)&buf, 0x16u);
          }
          *__error() = v189;
          db_free_query_node(v264);
        }
        if (v259 == -1)
        {
          int v196 = *__error();
          long long v197 = _SILogForLogForCategory(19);
          if (os_log_type_enabled(v197, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
            _os_log_impl(&dword_1BD672000, v197, OS_LOG_TYPE_DEFAULT, "%@ Token %lu (type: special) has no preceding cmd", (uint8_t *)&buf, 0x16u);
          }
          LOBYTE(v53) = 0;
          *__error() = v196;
          int v256 = 1;
          uint64_t v259 = v69;
          uint64_t v264 = v182;
        }
        else
        {
          int v191 = *__error();
          uint64_t v192 = _SILogForLogForCategory(19);
          if (os_log_type_enabled(v192, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v193 = [v263 objectAtIndexedSubscript:v259];
            LODWORD(buf.__r_.__value_.__l.__data_) = 138412802;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
            HIWORD(buf.__r_.__value_.__r.__words[2]) = 2112;
            *(void *)v301 = v193;
            _os_log_impl(&dword_1BD672000, v192, OS_LOG_TYPE_DEFAULT, "%@ Token %lu (type: special) has prev QU parse: %@", (uint8_t *)&buf, 0x20u);
          }
          *__error() = v191;
          long long v194 = MailNodeFromStr(a3, (char *)objc_msgSend((id)objc_msgSend(v263, "objectAtIndexedSubscript:", v259), "UTF8String"));
          uint64_t v195 = makeOrNode((uint64_t)v182, (uint64_t)v194);
          long long v269 = makeAndNode((uint64_t)v269, (uint64_t)v195);
          LOBYTE(v53) = 0;
          uint64_t v264 = 0;
          int v256 = 1;
        }
      }
      else
      {
        if (v69 == -1) {
          goto LABEL_325;
        }
        int v198 = *__error();
        int v199 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v199, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v200 = [v263 objectAtIndexedSubscript:v69];
          LODWORD(buf.__r_.__value_.__l.__data_) = 138412802;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 2112;
          *(void *)v301 = v200;
          _os_log_impl(&dword_1BD672000, v199, OS_LOG_TYPE_DEFAULT, "%@ Token %lu has a QU parse: %@", (uint8_t *)&buf, 0x20u);
        }
        *__error() = v198;
        unsigned int v201 = MailNodeFromStr(a3, (char *)objc_msgSend((id)objc_msgSend(v263, "objectAtIndexedSubscript:", v69), "UTF8String"));
        int64_t v202 = makeOrNode((uint64_t)v182, (uint64_t)v201);
        long long v269 = makeAndNode((uint64_t)v269, (uint64_t)v202);
        if (v264)
        {
          int v203 = *__error();
          uint64_t v204 = _SILogForLogForCategory(19);
          if (os_log_type_enabled(v204, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf.__r_.__value_.__l.__data_) = 138412802;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v52;
            HIWORD(buf.__r_.__value_.__r.__words[2]) = 2048;
            *(void *)v301 = v69;
            _os_log_impl(&dword_1BD672000, v204, OS_LOG_TYPE_DEFAULT, "%@ Token %lu (with parse:%lu) led to committing prev special node", (uint8_t *)&buf, 0x20u);
          }
          *__error() = v203;
          uint64_t v205 = MailNodeFromStr(a3, (char *)objc_msgSend((id)objc_msgSend(v263, "objectAtIndexedSubscript:", v69), "UTF8String"));
          uint64_t v206 = makeOrNode((uint64_t)v264, (uint64_t)v205);
          long long v269 = makeAndNode((uint64_t)v269, (uint64_t)v206);
        }
        LOBYTE(v53) = 0;
        uint64_t v264 = 0;
        int v261 = 1;
        uint64_t v259 = v69;
      }
    }
    else
    {
      if (range_12 == 5)
      {
        long long v269 = makeAndNode((uint64_t)v269, (uint64_t)v182);
LABEL_325:
        LOBYTE(v53) = 0;
        goto LABEL_108;
      }
      uint64_t v265 = makeAndNode((uint64_t)v265, (uint64_t)v182);
      LOBYTE(v53) = 0;
      char v257 = 1;
    }
LABEL_108:
    ++v52;
  }
  while (v52 != Count);
  if (v264)
  {
    uint64_t v207 = (uint64_t)v278;
    uint64_t v41 = (CFTypeRef *)v273;
    if (v261)
    {
      int v208 = *__error();
      int v209 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v209, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412290;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
        _os_log_impl(&dword_1BD672000, v209, OS_LOG_TYPE_DEFAULT, "%@ Unhandled special node optionaled due to a seen rule", (uint8_t *)&buf, 0xCu);
      }
      *__error() = v208;
      db_free_query_node(v264);
    }
    else if (v259 == -1)
    {
      int v216 = *__error();
      CFIndex v217 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412290;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
        _os_log_impl(&dword_1BD672000, v217, OS_LOG_TYPE_DEFAULT, "%@ Unhandled special node added as metadata match", (uint8_t *)&buf, 0xCu);
      }
      *__error() = v216;
      uint64_t v265 = makeAndNode((uint64_t)v265, (uint64_t)v264);
    }
    else
    {
      int v211 = *__error();
      int v212 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v212, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412290;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
        _os_log_impl(&dword_1BD672000, v212, OS_LOG_TYPE_DEFAULT, "%@ Unhandled special node added as filter", (uint8_t *)&buf, 0xCu);
      }
      *__error() = v211;
      unint64_t v213 = db_make_query_node_with_ann((char *)objc_msgSend((id)objc_msgSend(v263, "objectAtIndexedSubscript:", v259), "UTF8String"), 0);
      uint64_t v214 = (uint64_t)v213;
      if (*(unsigned char *)(a3 + 12))
      {
        buf.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
        buf.__r_.__value_.__l.__size_ = 3221225472;
        buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZL15MailNodeFromStrP9PRContextPKcf_block_invoke;
        *(void *)v301 = &__block_descriptor_36_e87__v16__0__query_node___query_node___query_node___query_piece_____v___v__v_SIb8b1b1b1Qf_8l;
        *(_DWORD *)&v301[8] = 1045220557;
        db_query_tree_apply_block(v213, &buf, 0);
      }
      BOOL v215 = makeOrNode((uint64_t)v264, v214);
      long long v269 = makeAndNode((uint64_t)v269, (uint64_t)v215);
    }
  }
  else
  {
    uint64_t v207 = (uint64_t)v278;
    uint64_t v41 = (CFTypeRef *)v273;
  }
  BOOL v219 = Count < 2 || *(unsigned char *)(a3 + 12) == 0;
  if ((v219 | range_8))
  {
LABEL_371:
    unint64_t v210 = 0;
    goto LABEL_408;
  }
  unint64_t v210 = (char *)[(__CFString *)theString UTF8String];
  if (v210)
  {
    if (![(__CFString *)theString length]) {
      goto LABEL_371;
    }
    int v220 = *__error();
    uint64_t v221 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v221, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
      *(double *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v54;
      _os_log_impl(&dword_1BD672000, v221, OS_LOG_TYPE_DEFAULT, "%@ Added full query node with wt: %f", (uint8_t *)&buf, 0x16u);
    }
    *__error() = v220;
    if (Count == 2) {
      uint64_t v222 = 1610612848;
    }
    else {
      uint64_t v222 = 1073741936;
    }
    int v223 = (uint64_t *)v294;
    if (*(unsigned char *)(a3 + 12))
    {
      if ((void)v294)
      {
        CFBitVectorRef v224 = 0;
        do
        {
          float v225 = *((float *)v223 + 10);
          if (v225 != 0.0)
          {
            unint64_t v226 = (const char *)(v223 + 2);
            if (*((char *)v223 + 39) < 0) {
              unint64_t v226 = *(const char **)v226;
            }
            CFBit v227 = createQueryNode(v226, v210, v222, 1, -1, v54 + v225, 0.0);
            CFBitVectorRef v224 = makeOrNode((uint64_t)v224, (uint64_t)v227);
          }
          int v223 = (uint64_t *)*v223;
        }
        while (v223);
        goto LABEL_393;
      }
LABEL_405:
      CFBitVectorRef v224 = 0;
LABEL_406:
      CFBitVectorRef v232 = 0;
    }
    else
    {
      if (!(void)v294) {
        goto LABEL_405;
      }
      CFBitVectorRef v224 = 0;
      do
      {
        CFBitVectorRef v228 = (const char *)(v223 + 2);
        if (*((char *)v223 + 39) < 0) {
          CFBitVectorRef v228 = *(const char **)v228;
        }
        CFBitVectorRef v229 = createQueryNode(v228, v210, v222, 1, -1, 0.0, 0.0);
        CFBitVectorRef v224 = makeOrNode((uint64_t)v224, (uint64_t)v229);
        int v223 = (uint64_t *)*v223;
      }
      while (v223);
LABEL_393:
      unsigned int v230 = (uint64_t *)v294;
      if (Count == 2) {
        uint64_t v231 = 1610612784;
      }
      else {
        uint64_t v231 = 1073741872;
      }
      if (*(unsigned char *)(a3 + 12))
      {
        if (!(void)v294) {
          goto LABEL_406;
        }
        CFBitVectorRef v232 = 0;
        do
        {
          float v233 = *((float *)v230 + 10);
          if (v233 != 0.0)
          {
            uint64_t v234 = (const char *)(v230 + 2);
            if (*((char *)v230 + 39) < 0) {
              uint64_t v234 = *(const char **)v234;
            }
            CFBit v235 = createQueryNode(v234, v210, v231, 1, 0, (float)(v54 + 0.2) + v233, 0.0);
            CFBitVectorRef v232 = makeOrNode((uint64_t)v232, (uint64_t)v235);
          }
          unsigned int v230 = (uint64_t *)*v230;
        }
        while (v230);
      }
      else
      {
        if (!(void)v294) {
          goto LABEL_406;
        }
        CFBitVectorRef v232 = 0;
        do
        {
          int v253 = (const char *)(v230 + 2);
          if (*((char *)v230 + 39) < 0) {
            int v253 = *(const char **)v253;
          }
          int v254 = createQueryNode(v253, v210, v231, 1, 0, 0.0, 0.0);
          CFBitVectorRef v232 = makeOrNode((uint64_t)v232, (uint64_t)v254);
          unsigned int v230 = (uint64_t *)*v230;
        }
        while (v230);
      }
    }
    unint64_t v210 = (char *)makeOrNode((uint64_t)v224, (uint64_t)v232);
    uint64_t v207 = (uint64_t)v278;
    uint64_t v41 = (CFTypeRef *)v273;
  }
LABEL_408:
  freeQueryTokensContext(v41);
  CFRelease(theString);
  if (*(unsigned char *)(a3 + 12))
  {
    unsigned int v236 = makeAndNode((uint64_t)v265, (uint64_t)v269);
    CFBitVectorRef v237 = makeOrNode((uint64_t)v236, (uint64_t)v210);
    CFBitVectorRef v238 = makeAndNode((uint64_t)v237, v207);
    if (currentYear(void)::onceToken != -1) {
      dispatch_once(&currentYear(void)::onceToken, &__block_literal_global_3112);
    }
    unsigned int v239 = createQueryNode("_kMDItemContentCreationDateYear", (char *)currentYear(void)::currYear, 112, 4, 0, 0.0115, 0.01);
    CFBit v240 = createQueryNode("com_apple_mail_read", "1", 112, 4, 0, 0.0095, 0.01);
    uint64_t v241 = createQueryNode("com_apple_mail_flagged", "1", 112, 4, 0, 0.0135, 0.01);
    uint64_t v242 = makeAndNode((uint64_t)v240, (uint64_t)v241);
    uint64_t v243 = makeAndNode((uint64_t)v239, (uint64_t)v242);
    uint64_t v244 = (uint64_t)v238;
LABEL_421:
    uint64_t v27 = makeAndNode(v244, (uint64_t)v243);
  }
  else
  {
    __int16 v245 = makeAndNode((uint64_t)v269, v207);
    uint64_t v27 = v245;
    if (v265 || !v245)
    {
      if (*(unsigned char *)(a3 + 17)) {
        uint64_t v248 = 0;
      }
      else {
        uint64_t v248 = MailSemanticNode(*(const __CFDictionary **)(a3 + 32), *(unsigned __int8 *)(a3 + 13), v282);
      }
      uint64_t v243 = makeOrNode((uint64_t)v248, (uint64_t)v265);
      uint64_t v244 = (uint64_t)v27;
      goto LABEL_421;
    }
    int v246 = *__error();
    uint64_t v247 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v247, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 138412290;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v282;
      _os_log_impl(&dword_1BD672000, v247, OS_LOG_TYPE_DEFAULT, "%@ Skipping semantic node (Reason: query has only filters)", (uint8_t *)&buf, 0xCu);
    }
    *__error() = v246;
  }
  std::__hash_table<std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<std::string,float>>>>::~__hash_table((uint64_t)v284);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node((void **)v288[0]);
  uint64_t v249 = __p[0];
  __p[0] = 0;
  if (v249) {
    operator delete(v249);
  }
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node((void **)v291[0]);
  uint64_t v250 = v290[0];
  v290[0] = 0;
  if (v250) {
    operator delete(v250);
  }
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node((void **)v294);
  uint64_t v251 = (void *)v293;
  *(void *)&long long v293 = 0;
  if (v251) {
    operator delete(v251);
  }
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node(*(void ***)&v318[16]);
  int v252 = *(void **)v318;
  *(void *)statfs v318 = 0;
  if (v252) {
    operator delete(v252);
  }
  return v27;
}

void sub_1BD8786B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  std::__hash_table<std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<std::string,float>>>>::~__hash_table((uint64_t)&a55);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a61);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a67);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&STACK[0x200]);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v67 - 208);
  _Unwind_Resume(a1);
}

void *processNode(uint64_t a1, uint64_t a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(_OWORD *)a1 == 0)
  {
    if (*(_WORD *)(a1 + 48) != 4
      || (unint64_t v9 = *(void **)(a1 + 16)) == 0
      || !*v9
      || !*(unsigned char *)*v9
      || (std::string::size_type v10 = (char *)v9[9]) == 0
      || !*v10)
    {
      *(void *)std::string buf = MEMORY[0x1E4F143A8];
      uint64_t v34 = 0x40000000;
      pid_t v35 = __db_query_tree_apply_block_block_invoke;
      uint64_t v36 = &unk_1E6348598;
      int v37 = &__block_literal_global_21_12478;
      return (void *)db_query_tree_apply_block_with_meta((void *)a1, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
    }
    uint64_t v11 = v9[4];
    int is_double_star = query_node_is_double_star(a1);
    int NodeMatchingAnyField = isQueryNodeMatchingAnyField(a1);
    if ((v11 & 4) != 0)
    {
      size_t v18 = strlen(v10);
      CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v18);
      CFStringAppendCString(Mutable, *(const char **)(*(void *)(a1 + 16) + 72), 0x8000100u);
      QueryTokens = (const __CFArray **)CreateQueryTokens(Mutable, 1);
      if (QueryTokens)
      {
        __int16 v21 = (CFTypeRef *)QueryTokens;
        CFArrayRef v22 = *QueryTokens;
        if (v22)
        {
          CFIndex Count = CFArrayGetCount(v22);
          if (Count > 0)
          {
            CFIndex v24 = Count;
            int v31 = v21;
            CFMutableStringRef cf = Mutable;
            CFIndex v25 = 0;
            int v14 = 0;
            CFArrayRef v26 = (const __CFArray *)*v21;
            do
            {
              CFStringRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(v26, v25);
              if (CFStringGetLength(ValueAtIndex) >= 1)
              {
                uint64_t v28 = [(__CFString *)ValueAtIndex UTF8String];
                if (v28)
                {
                  int v29 = (char *)v28;
                  if ([(__CFString *)ValueAtIndex length])
                  {
                    int v30 = MailSuggestionNode(a1, v29, NodeMatchingAnyField, is_double_star, a2);
                    int v14 = makeAndNode((uint64_t)v14, (uint64_t)v30);
                  }
                }
              }
              ++v25;
            }
            while (v24 != v25);
            freeQueryTokensContext(v31);
            CFRelease(cf);
            return v14;
          }
        }
        freeQueryTokensContext(v21);
      }
      CFRelease(Mutable);
      return (void *)db_clone_query_node((void *)a1);
    }
    else
    {
      return MailSuggestionNode(a1, v10, NodeMatchingAnyField, is_double_star, a2);
    }
  }
  else
  {
    double v5 = (void *)((uint64_t (*)(void))processNode)();
    uint64_t v6 = (void *)processNode(v4, a2);
    int v7 = *(unsigned __int16 *)(a1 + 48);
    if (v7 != 2)
    {
      if (v7 == 1)
      {
        return makeOrNode((uint64_t)v5, (uint64_t)v6);
      }
      int v15 = *__error();
      uint64_t v16 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        int v17 = *(unsigned __int16 *)(a1 + 48);
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v17;
        _os_log_impl(&dword_1BD672000, v16, OS_LOG_TYPE_DEFAULT, "(ERROR) Failed to convert suggestion node properly: %hu", buf, 8u);
      }
      *__error() = v15;
      db_free_query_node(v5);
      db_free_query_node(v6);
      return 0;
    }
    return makeAndNode((uint64_t)v5, (uint64_t)v6);
  }
}

void __Block_byref_object_copy__3057(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__3058(uint64_t a1)
{
}

uint64_t ___ZL28MailPopulateFiltersFromParsePK14__CFDictionaryP14NSMutableArrayIP8NSStringEPS2_IP7NSValueEP12NSMutableSetIP8NSNumberES4__block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = [a2 count];
  if (result)
  {
    if ([a2 objectForKeyedSubscript:@"kQPDateExtension"])
    {
      if ([*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) length])
      {
        [*(id *)(a1 + 32) addObject:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)];
        objc_msgSend(*(id *)(a1 + 40), "addObject:", objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", a3, a4));
      }
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) = 0;
    }
    unint64_t v9 = (void *)[a2 objectForKeyedSubscript:@"kQPDescription"];
    uint64_t result = [v9 length];
    if (result)
    {
      std::string::size_type v10 = (void *)[a2 objectForKeyedSubscript:@"kQPDisplay"];
      if ([v10 hasPrefix:@"Messages"] && objc_msgSend(v9, "length"))
      {
        objc_msgSend(*(id *)(a1 + 48), "addObject:", objc_msgSend(NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(a1 + 32), "count")));
        [*(id *)(a1 + 32) addObject:v9];
        uint64_t v11 = *(void **)(a1 + 40);
        uint64_t v12 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", a3, a4);
        return [v11 addObject:v12];
      }
      else if ([a2 objectForKeyedSubscript:@"kQPDate"] {
             || [a2 objectForKeyedSubscript:@"kQPFlagColorAction"]
      }
             || [a2 objectForKeyedSubscript:@"kQPReadAction"] && objc_msgSend(v10, "length")
             || [a2 objectForKeyedSubscript:@"kQPAttached"]
             || [a2 objectForKeyedSubscript:@"kQPRepliedAction"]
             || [a2 objectForKeyedSubscript:@"kQPSentAction"]
             || [a2 objectForKeyedSubscript:@"kQPReceivedAction"]
             || (uint64_t result = [a2 objectForKeyedSubscript:@"kQPFlaggedAction"]) != 0)
      {
        [*(id *)(a1 + 32) addObject:v9];
        objc_msgSend(*(id *)(a1 + 40), "addObject:", objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", a3, a4));
        uint64_t result = [a2 objectForKeyedSubscript:@"kQPDate"];
        if (result) {
          *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) = v9;
        }
      }
    }
  }
  return result;
}

uint64_t std::unordered_map<std::string,float>::unordered_map(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 32 * a3;
    do
    {
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,float> const&>(a1, a2, a2);
      a2 += 32;
      v5 -= 32;
    }
    while (v5);
  }
  return a1;
}

void sub_1BD879154(_Unwind_Exception *a1)
{
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<std::string,float>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t a1, int a2, _DWORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    unint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return i;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  uint64_t v12 = (void *)(a1 + 16);
  v35[2] = 1;
  dispatch_time_t v13 = (char *)operator new(0x40uLL);
  v35[0] = v13;
  v35[1] = a1 + 16;
  *(void *)dispatch_time_t v13 = 0;
  *((void *)v13 + 1) = v5;
  *((_DWORD *)v13 + 4) = *a3;
  *(_OWORD *)(v13 + 24) = 0u;
  *(_OWORD *)(v13 + 40) = 0u;
  *((_DWORD *)v13 + 14) = 1065353216;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v6 || (float)(v15 * (float)v6) < v14)
  {
    BOOL v16 = 1;
    if (v6 >= 3) {
      BOOL v16 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v6);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      int8x8_t prime = (int8x8_t)v18;
    }
    else {
      int8x8_t prime = (int8x8_t)v17;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v6 = *(void *)(a1 + 8);
    }
    if (*(void *)&prime > v6) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v6)
    {
      unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v6 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }
      else
      {
        uint64_t v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }
      if (*(void *)&prime <= v26) {
        int8x8_t prime = (int8x8_t)v26;
      }
      if (*(void *)&prime >= v6)
      {
        unint64_t v6 = *(void *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          CFLocaleRef v20 = operator new(8 * *(void *)&prime);
          __int16 v21 = *(void **)a1;
          *(void *)a1 = v20;
          if (v21) {
            operator delete(v21);
          }
          uint64_t v22 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v22++) = 0;
          while (*(void *)&prime != v22);
          __int16 v23 = (void *)*v12;
          if (*v12)
          {
            unint64_t v24 = v23[1];
            uint8x8_t v25 = (uint8x8_t)vcnt_s8(prime);
            v25.i16[0] = vaddlv_u8(v25);
            if (v25.u32[0] > 1uLL)
            {
              if (v24 >= *(void *)&prime) {
                v24 %= *(void *)&prime;
              }
            }
            else
            {
              v24 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v24) = v12;
            int v29 = (void *)*v23;
            if (*v23)
            {
              do
              {
                unint64_t v30 = v29[1];
                if (v25.u32[0] > 1uLL)
                {
                  if (v30 >= *(void *)&prime) {
                    v30 %= *(void *)&prime;
                  }
                }
                else
                {
                  v30 &= *(void *)&prime - 1;
                }
                if (v30 != v24)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v30))
                  {
                    *(void *)(*(void *)a1 + 8 * v30) = v23;
                    goto LABEL_55;
                  }
                  *__int16 v23 = *v29;
                  *int v29 = **(void **)(*(void *)a1 + 8 * v30);
                  **(void **)(*(void *)a1 + 8 * v30) = v29;
                  int v29 = v23;
                }
                unint64_t v30 = v24;
LABEL_55:
                __int16 v23 = v29;
                int v29 = (void *)*v29;
                unint64_t v24 = v30;
              }
              while (v29);
            }
          }
          unint64_t v6 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v34 = *(void **)a1;
        *(void *)a1 = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v6 = 0;
        *(void *)(a1 + 8) = 0;
      }
    }
LABEL_59:
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  int v31 = *(void **)(*(void *)a1 + 8 * v8);
  uint64_t i = (uint64_t *)v35[0];
  if (v31)
  {
    *(void *)v35[0] = *v31;
LABEL_72:
    *int v31 = i;
    goto LABEL_73;
  }
  *(void *)v35[0] = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(*(void *)a1 + 8 * v8) = v12;
  if (*i)
  {
    unint64_t v32 = *(void *)(*i + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v32 >= v6) {
        v32 %= v6;
      }
    }
    else
    {
      v32 &= v6 - 1;
    }
    int v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  v35[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::unordered_map<std::string,float>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unordered_map<std::string,float>>,void *>>>>::reset[abi:nn180100]((uint64_t)v35);
  return i;
}

void sub_1BD87957C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::unordered_map<std::string,float>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unordered_map<std::string,float>>,void *>>>>::reset[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__assign_unique<std::pair<std::string const,float> const*>(void *a1, std::string *__str, std::string *a3)
{
  uint64_t v4 = __str;
  uint64_t v6 = a1[1];
  if (v6)
  {
    for (uint64_t i = 0; i != v6; ++i)
      *(void *)(*a1 + 8 * i) = 0;
    unint64_t v8 = (void **)a1[2];
    a1[2] = 0;
    a1[3] = 0;
    if (v8) {
      BOOL v9 = __str == a3;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9)
    {
      std::string::size_type v10 = v8;
    }
    else
    {
      do
      {
        std::string::operator=((std::string *)(v8 + 2), v4);
        *((_DWORD *)v8 + 10) = v4[1].__r_.__value_.__l.__data_;
        std::string::size_type v10 = (void **)*v8;
        int v11 = *((char *)v8 + 39);
        if (v11 >= 0) {
          uint64_t v12 = (uint64_t *)(v8 + 2);
        }
        else {
          uint64_t v12 = (uint64_t *)v8[2];
        }
        if (v11 >= 0) {
          unint64_t v13 = *((unsigned __int8 *)v8 + 39);
        }
        else {
          unint64_t v13 = (unint64_t)v8[3];
        }
        unint64_t v14 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v12, v13);
        v8[1] = (void *)v14;
        if (!std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__node_insert_unique_prepare[abi:nn180100]((uint64_t)a1, v14, (unsigned __int8 *)v8 + 16))std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__node_insert_unique_perform[abi:nn180100](a1, v8); {
        uint64_t v4 = (std::string *)((char *)v4 + 32);
        }
        if (!v10) {
          break;
        }
        unint64_t v8 = v10;
      }
      while (v4 != a3);
    }
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node(v10);
  }
  while (v4 != a3)
  {
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,float> const&>((uint64_t)a1, (uint64_t)v4, (uint64_t)v4);
    uint64_t v4 = (std::string *)((char *)v4 + 32);
  }
}

void *MailAttribNode(char a1, uint64_t *a2, char *__s, int a4, float a5)
{
  uint64_t v6 = a2;
  int v7 = a4 << 31 >> 31;
  if (a1)
  {
    if (a2)
    {
      BOOL v9 = 0;
      do
      {
        float v10 = *((float *)v6 + 10);
        if (v10 != 0.0)
        {
          int v11 = (const char *)(v6 + 2);
          if (*((char *)v6 + 39) < 0) {
            int v11 = *(const char **)v11;
          }
          QueryNode = createQueryNode(v11, __s, 112, 1, v7, v10 + a5, 0.0);
          BOOL v9 = makeOrNode((uint64_t)v9, (uint64_t)QueryNode);
        }
        uint64_t v6 = (uint64_t *)*v6;
      }
      while (v6);
      return v9;
    }
    return 0;
  }
  if (!a2) {
    return 0;
  }
  BOOL v9 = 0;
  do
  {
    unint64_t v13 = (const char *)(v6 + 2);
    if (*((char *)v6 + 39) < 0) {
      unint64_t v13 = *(const char **)v13;
    }
    unint64_t v14 = createQueryNode(v13, __s, 112, 1, v7, 0.0, 0.0);
    BOOL v9 = makeOrNode((uint64_t)v9, (uint64_t)v14);
    uint64_t v6 = (uint64_t *)*v6;
  }
  while (v6);
  return v9;
}

void *MailTokenRewriteNode(void *key, uint64_t a2, uint64_t a3)
{
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 40), key);
  if (Value)
  {
    CFArrayRef v6 = Value;
    CFIndex Count = CFArrayGetCount(Value);
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      CFIndex v9 = 0;
      float v10 = 0;
      while (1)
      {
        CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v6, v9);
        if (!ValueAtIndex) {
          goto LABEL_29;
        }
        uint64_t v12 = ValueAtIndex;
        CFStringRef v13 = (const __CFString *)[ValueAtIndex variation];
        if (!v13) {
          goto LABEL_29;
        }
        unint64_t v14 = (__CFString *)v13;
        if (!CFStringGetLength(v13)) {
          goto LABEL_29;
        }
        if (![(__CFString *)v14 length]) {
          goto LABEL_29;
        }
        uint64_t v15 = [(__CFString *)v14 UTF8String];
        if (!v15) {
          goto LABEL_29;
        }
        BOOL v16 = (char *)v15;
        if ([v12 type] == 1) {
          uint64_t v17 = 2155872368;
        }
        else {
          uint64_t v17 = 2147483760;
        }
        unint64_t v18 = *(uint64_t **)(a3 + 16);
        if (*(unsigned char *)(a2 + 12))
        {
          if (v18)
          {
            __int16 v19 = 0;
            do
            {
              float v20 = *((float *)v18 + 10);
              if (v20 != 0.0)
              {
                __int16 v21 = (const char *)(v18 + 2);
                if (*((char *)v18 + 39) < 0) {
                  __int16 v21 = *(const char **)v21;
                }
                QueryNode = createQueryNode(v21, v16, v17, 1, 0, v20 + 0.0, 0.0);
                __int16 v19 = makeOrNode((uint64_t)v19, (uint64_t)QueryNode);
              }
              unint64_t v18 = (uint64_t *)*v18;
            }
            while (v18);
            goto LABEL_28;
          }
        }
        else if (v18)
        {
          __int16 v19 = 0;
          do
          {
            __int16 v23 = (const char *)(v18 + 2);
            if (*((char *)v18 + 39) < 0) {
              __int16 v23 = *(const char **)v23;
            }
            unint64_t v24 = createQueryNode(v23, v16, v17, 1, 0, 0.0, 0.0);
            __int16 v19 = makeOrNode((uint64_t)v19, (uint64_t)v24);
            unint64_t v18 = (uint64_t *)*v18;
          }
          while (v18);
          goto LABEL_28;
        }
        __int16 v19 = 0;
LABEL_28:
        float v10 = makeOrNode((uint64_t)v10, (uint64_t)v19);
LABEL_29:
        if (++v9 == v8) {
          return v10;
        }
      }
    }
  }
  return 0;
}

uint64_t ___ZL15MailNodeFromStrP9PRContextPKcf_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 16);
    if (v2)
    {
      *(_DWORD *)(v2 + 52) = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(v2 + 56) = 0;
    }
  }
  return a2;
}

void *MailAttribNegNode(char a1, uint64_t *a2, char *__s, int a4)
{
  unint64_t v5 = a2;
  int v6 = a4 << 31 >> 31;
  if (a1)
  {
    if (a2)
    {
      int v7 = 0;
      do
      {
        float v8 = *((float *)v5 + 10);
        if (v8 != 0.0)
        {
          CFIndex v9 = (const char *)(v5 + 2);
          if (*((char *)v5 + 39) < 0) {
            CFIndex v9 = *(const char **)v9;
          }
          QueryNode = createQueryNode(v9, __s, 112, 5, v6, v8 + 0.0, 0.0);
          int v7 = makeAndNode((uint64_t)v7, (uint64_t)QueryNode);
        }
        unint64_t v5 = (uint64_t *)*v5;
      }
      while (v5);
      return v7;
    }
    return 0;
  }
  if (!a2) {
    return 0;
  }
  int v7 = 0;
  do
  {
    int v11 = (const char *)(v5 + 2);
    if (*((char *)v5 + 39) < 0) {
      int v11 = *(const char **)v11;
    }
    uint64_t v12 = createQueryNode(v11, __s, 112, 5, v6, 0.0, 0.0);
    int v7 = makeAndNode((uint64_t)v7, (uint64_t)v12);
    unint64_t v5 = (uint64_t *)*v5;
  }
  while (v5);
  return v7;
}

void *MailNodeFromStr(uint64_t a1, char *a2)
{
  query_node_with_anuint64_t n = db_make_query_node_with_ann(a2, 0);
  uint64_t v4 = query_node_with_ann;
  if (*(unsigned char *)(a1 + 12))
  {
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    v6[2] = ___ZL15MailNodeFromStrP9PRContextPKcf_block_invoke;
    void v6[3] = &__block_descriptor_36_e87__v16__0__query_node___query_node___query_node___query_piece_____v___v__v_SIb8b1b1b1Qf_8l;
    int v7 = 1045220557;
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    v8[2] = __db_query_tree_apply_block_block_invoke;
    void v8[3] = &unk_1E6348598;
    v8[4] = v6;
    db_query_tree_apply_block_with_meta(query_node_with_ann, (uint64_t)v8, 0);
  }
  return v4;
}

_WORD *MailSemanticNode(const __CFDictionary *a1, int a2, NSString *a3)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (!a1
    || !CFDictionaryContainsKey(a1, @"vec_dimensions")
    || !CFDictionaryContainsKey(a1, @"vec_data_format")
    || !CFDictionaryContainsKey(a1, @"vec_version"))
  {
    int v10 = *__error();
    int v11 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v41 = 138412290;
      uint64_t v42 = a3;
      uint64_t v12 = "%@ Skipping ANN node (ERROR: missing essential ann params)";
      goto LABEL_14;
    }
LABEL_15:
    CFStringRef v13 = 0;
    goto LABEL_16;
  }
  if (!CFDictionaryContainsKey(a1, @"vectors"))
  {
    int v10 = *__error();
    int v11 = _SILogForLogForCategory(19);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_15;
    }
    int v41 = 138412290;
    uint64_t v42 = a3;
    uint64_t v12 = "%@ Skipping ANN node (ERROR: missing vectors in ann params)";
    goto LABEL_14;
  }
  CFArrayRef Value = (void *)CFDictionaryGetValue(a1, @"vectors");
  if (!Value || (int v7 = Value, ![Value count]))
  {
    int v10 = *__error();
    int v11 = _SILogForLogForCategory(19);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_15;
    }
    int v41 = 138412290;
    uint64_t v42 = a3;
    uint64_t v12 = "%@ Skipping ANN node (ERROR: missing query embedding)";
    goto LABEL_14;
  }
  float v8 = (void *)[v7 objectAtIndexedSubscript:0];
  if (!v8 || (CFIndex v9 = v8, (unint64_t)[v8 length] <= 1))
  {
    int v10 = *__error();
    int v11 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v41 = 138412290;
      uint64_t v42 = a3;
      uint64_t v12 = "%@ Skipping ANN node (ERROR: embedding has 0 dimensionality)";
LABEL_14:
      _os_log_impl(&dword_1BD672000, v11, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v41, 0xCu);
      goto LABEL_15;
    }
    goto LABEL_15;
  }
  uint64_t v15 = (void *)CFDictionaryGetValue(a1, @"vec_dimensions");
  BOOL v16 = (void *)CFDictionaryGetValue(a1, @"vec_data_format");
  uint64_t v17 = (void *)CFDictionaryGetValue(a1, @"vec_version");
  if (a2) {
    float v18 = 0.91;
  }
  else {
    float v18 = 0.88;
  }
  uint64_t v19 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1CB18], "standardUserDefaults"), "valueForKey:", @"SpotlightL1MailThresh");
  if (v19)
  {
    float v20 = (void *)v19;
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      [v20 floatValue];
      float v18 = v21;
      int v22 = *__error();
      __int16 v23 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        int v41 = 138412546;
        uint64_t v42 = a3;
        __int16 v43 = 2048;
        double v44 = v18;
        _os_log_impl(&dword_1BD672000, v23, OS_LOG_TYPE_DEFAULT, "%@ Using user specified ann threshold: %f", (uint8_t *)&v41, 0x16u);
      }
      *__error() = v22;
    }
  }
  int v24 = [v17 intValue];
  char v25 = [v15 intValue];
  char v26 = [v16 intValue];
  unint64_t v27 = [v9 length];
  if (v27 <= 1)
  {
    int v28 = *__error();
    int v29 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      int v41 = 138412290;
      uint64_t v42 = a3;
      unint64_t v30 = "%@ Skipping ANN node (ERROR: embedding has 0 dimensionality)";
LABEL_50:
      _os_log_impl(&dword_1BD672000, v29, OS_LOG_TYPE_DEFAULT, v30, (uint8_t *)&v41, 0xCu);
      goto LABEL_51;
    }
    goto LABEL_51;
  }
  unint64_t v31 = v27;
  uint64_t v32 = [v9 bytes];
  if (!v32)
  {
    int v28 = *__error();
    int v29 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      int v41 = 138412290;
      uint64_t v42 = a3;
      unint64_t v30 = "%@ Skipping ANN node (ERROR: Failed to get bytes from embedding)";
      goto LABEL_50;
    }
LABEL_51:
    *__error() = v28;
LABEL_52:
    int v10 = *__error();
    int v11 = _SILogForLogForCategory(19);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_15;
    }
    int v41 = 138412290;
    uint64_t v42 = a3;
    uint64_t v12 = "%@ Skipping ANN node (ERROR: failed to create it)";
    goto LABEL_14;
  }
  uint64_t v33 = v32;
  if (*MEMORY[0x1E4F14B00] <= 0x12FuLL) {
    ++sTotal;
  }
  uint64_t v34 = (float *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x130uLL, 0x31F9A007uLL);
  if (!v34) {
    _log_fault_for_malloc_failure();
  }
  *(void *)uint64_t v34 = strdup("_kMDItemPrimaryTextEmbedding");
  *((_DWORD *)v34 + 6) = 15;
  _OWORD v34[16] = v18;
  *((_DWORD *)v34 + 15) = v25 & 3 | (4 * (v26 & 3)) | (v24 << 25) | 0x320;
  *((_DWORD *)v34 + 10) = 5;
  *((_DWORD *)v34 + 40) |= 0x10000u;
  pid_t v35 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v31 & 0xFFFFFFFFFFFFFFFELL, 0x6085D6BuLL);
  if (!v35) {
    _log_fault_for_malloc_failure();
  }
  uint64_t v36 = 0;
  *((void *)v34 + 37) = v35;
  if (v31 >> 1 <= 1) {
    uint64_t v37 = 1;
  }
  else {
    uint64_t v37 = v31 >> 1;
  }
  do
  {
    *(_WORD *)(*((void *)v34 + 37) + 2 * v36) = *(_WORD *)(v33 + 2 * v36);
    ++v36;
  }
  while (v37 != v36);
  if (*MEMORY[0x1E4F14B00] <= 0x4FuLL) {
    ++sTotal;
  }
  uint64_t v38 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x50uLL, 0x31F9A007uLL);
  if (!v38)
  {
    _log_fault_for_malloc_failure();
    MEMORY[0x30] = 4;
    MEMORY[0x10] = v34;
    goto LABEL_52;
  }
  CFStringRef v13 = v38;
  v38[24] = 4;
  *((void *)v38 + 2) = v34;
  int v10 = *__error();
  uint64_t v39 = _SILogForLogForCategory(19);
  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v40 = [v9 length];
    int v41 = 138413058;
    uint64_t v42 = a3;
    __int16 v43 = 2048;
    *(void *)&double v44 = v40 >> 1;
    __int16 v45 = 2048;
    double v46 = v18;
    __int16 v47 = 1024;
    int v48 = 50;
    _os_log_impl(&dword_1BD672000, v39, OS_LOG_TYPE_DEFAULT, "%@ Adding ANN node (dim: %lu, thresh: %f, num results: %d)", (uint8_t *)&v41, 0x26u);
  }
LABEL_16:
  *__error() = v10;
  return v13;
}

uint64_t std::__hash_table<std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<std::string,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<std::string,float>>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      int v3 = (void *)*v2;
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)(v2 + 3));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void ___ZL11currentYearv_block_invoke()
{
  CFDictionaryRef v0 = (void *)MEMORY[0x1C1881FD0]();
  uint64_t v1 = [MEMORY[0x1E4F1C9C8] date];
  asprintf((char **)&currentYear(void)::currYear, "%lu", objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1C9A8], "currentCalendar"), "component:fromDate:", 4, v1));
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::unordered_map<std::string,float>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unordered_map<std::string,float>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v1 + 24);
    }
    operator delete(v1);
  }
}

_WORD *MailSuggestionNode(uint64_t a1, char *__s, int a3, int a4, char a5)
{
  if (a5)
  {
    if (a4)
    {
      QueryNode = createQueryNode("kMDItemTextContent", __s, 48, 1, 0, 0.1, 0.0);
LABEL_8:
      float v8 = createQueryNode("kMDItemSubject", __s, 112, 1, 0, 0.5, 0.0);
      CFIndex v9 = createQueryNode("kMDItemAuthors", __s, 48, 1, 0, 0.6, 0.0);
      int v7 = makeOrNode((uint64_t)v8, (uint64_t)v9);
      goto LABEL_9;
    }
    if (a3)
    {
      QueryNode = 0;
      goto LABEL_8;
    }
    uint64_t v16 = *(void *)(a1 + 16);
    uint64_t v12 = *(const char **)v16;
    uint64_t v13 = *(void *)(v16 + 32);
    int v14 = *(_DWORD *)(v16 + 24);
    float v15 = 0.2;
  }
  else
  {
    if (a4)
    {
      QueryNode = createQueryNode("*", __s, 112, 1, 0, 0.0, 0.0);
      int v7 = createQueryNode("kMDItemTextContent", __s, 112, 1, 0, 0.0, 0.0);
LABEL_9:
      return makeOrNode((uint64_t)QueryNode, (uint64_t)v7);
    }
    uint64_t v11 = *(void *)(a1 + 16);
    uint64_t v12 = *(const char **)v11;
    uint64_t v13 = *(void *)(v11 + 32);
    int v14 = *(_DWORD *)(v11 + 24);
    float v15 = 0.0;
  }
  return createQueryNode(v12, __s, v13, v14, 0, v15, 0.0);
}

void oqsort_offset_with_meta_t(uint64_t a1)
{
  if (*(uint64_t *)(a1 + 24) >= 2)
  {
    qos_class_t v2 = qos_class_self();
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v4 = *(void *)(a1 + 24);
    if (v2 < 0x12) {
      _qsort_offset_with_meta_t(v3, 0, v4 - 1);
    }
    else {
      parallel_qsort_offset_with_meta_t(v3, v4);
    }
  }
  if (*(_DWORD *)(a1 + 48))
  {
    unint64_t v5 = __si_assert_copy_extra_329();
    int v6 = v5;
    int v7 = "";
    if (v5) {
      int v7 = v5;
    }
    __message_assert(v5, "OQueue.c", 13, "!queue->split", v7);
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
}

void parallel_qsort_offset_with_meta_t(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a2 > 2047)
  {
    uint64_t v4 = OSAtomicDequeue(&qsort_cached_allocations, 0);
    if (!v4) {
      uint64_t v4 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
    }
    unint64_t v5 = dispatch_group_create();
    void v4[3] = v5;
    void v4[4] = 0;
    v4[1] = 0;
    v4[2] = a2 - 1;
    *uint64_t v4 = a1;
    int v6 = thread_count;
    if (!thread_count)
    {
      *(void *)CFIndex v9 = 0x1900000006;
      size_t v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      int v6 = thread_count;
    }
    *((_DWORD *)v4 + 14) = v6;
    void v4[5] = (uint64_t)sqrt((double)a2) / 2;
    if (!v6)
    {
      *(void *)CFIndex v9 = 0x1900000006;
      size_t v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      int v6 = thread_count;
    }
    uint64_t v7 = a2 / (2 * v6);
    if (v7 <= 0x8000)
    {
      uint64_t v7 = 0x8000;
    }
    else if (!v6)
    {
      *(void *)CFIndex v9 = 0x1900000006;
      size_t v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      uint64_t v7 = a2 / (2 * thread_count);
    }
    v4[6] = v7;
    if ((uint64_t)v4[5] <= 2047) {
      void v4[5] = 2048;
    }
    _qsort_big_offset_with_meta_t(v4);
    dispatch_group_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v5);
  }
  else
  {
    _qsort_offset_with_meta_t(a1, 0, a2 - 1);
  }
}

void _qsort_offset_with_meta_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = malloc_type_malloc(0x800uLL, 0x1000040451B5BE8uLL);
  v6[1] = 0;
  *int v6 = 0;
  uint64_t v7 = 1;
  do
  {
    if (a3 > a2)
    {
      if (v7 <= 128) {
        uint64_t v9 = 128;
      }
      else {
        uint64_t v9 = v7;
      }
      uint64_t v10 = &v6[2 * v7 + 1];
      while (a3 - a2 > 16)
      {
        uint64_t v11 = _partition_offset_with_meta_t(a1, a2, a3);
        uint64_t v12 = v11 - a2;
        if (v11 < a2)
        {
          char v25 = __si_assert_copy_extra_329();
          char v26 = v25;
          unint64_t v27 = "";
          if (v25) {
            unint64_t v27 = v25;
          }
          __message_assert(v25, "OQueue.c", 13, "q>=left", v27);
          free(v26);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        if (v9 == v7)
        {
          heapsort_b((void *)(a1 + 16 * a2), a3 - a2 + 1, 0x10uLL, &__block_literal_global_3264);
          uint64_t v7 = v9;
          goto LABEL_3;
        }
        BOOL v13 = v12 <= a3 - v11;
        if (v12 <= a3 - v11) {
          uint64_t v14 = v11 - 1;
        }
        else {
          uint64_t v14 = a3;
        }
        if (v13) {
          uint64_t v15 = a2;
        }
        else {
          uint64_t v15 = v11;
        }
        if (v13) {
          a2 = v11;
        }
        else {
          a3 = v11 - 1;
        }
        *(v10 - 1) = v15;
        uint64_t *v10 = v14;
        ++v7;
        v10 += 2;
        if (a3 <= a2) {
          goto LABEL_3;
        }
      }
      uint64_t v16 = a1 + 24 + 16 * a2;
      uint64_t v17 = a2;
      do
      {
        uint64_t v18 = v17++;
        long long v19 = *(_OWORD *)(a1 + 16 * v17);
        unint64_t v20 = *(void *)(a1 + 16 * v17) & 0x3FFFFFFFFFFFFFFFLL;
        uint64_t v21 = *(void *)(a1 + 16 * v18);
        uint64_t v22 = v17;
        if ((v21 & 0x3FFFFFFFFFFFFFFFuLL) > v20)
        {
          __int16 v23 = (void *)v16;
          do
          {
            uint64_t v22 = v18;
            uint64_t v24 = *(v23 - 2);
            *(v23 - 1) = v21;
            *__int16 v23 = v24;
            if (v22 <= a2) {
              break;
            }
            uint64_t v21 = *(v23 - 5);
            uint64_t v18 = v22 - 1;
            v23 -= 2;
          }
          while ((v21 & 0x3FFFFFFFFFFFFFFFuLL) > v20);
        }
        *(_OWORD *)(a1 + 16 * v22) = v19;
        v16 += 16;
      }
      while (v17 != a3);
    }
LABEL_3:
    --v7;
    size_t v8 = &v6[2 * v7];
    a2 = *v8;
    a3 = v8[1];
  }
  while (v7);
  free(v6);
}

uint64_t _partition_offset_with_meta_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3 - a2;
  uint64_t v4 = (void *)(a1 + 16 * a2);
  unint64_t v5 = a3 - a2 + 2;
  if (a3 - a2 >= -1) {
    unint64_t v5 = v3 + 1;
  }
  int v6 = &v4[2 * (v5 >> 1)];
  uint64_t v7 = (void *)(a1 + 16 * a3);
  if (v3 < 1024)
  {
    uint64_t v22 = v6;
    char v25 = (void *)(a1 + 16 * a3);
  }
  else
  {
    unint64_t v8 = (unint64_t)(a3 - a2 + 1) >> 3;
    uint64_t v9 = &v4[2 * v8];
    unint64_t v10 = *v4 & 0x3FFFFFFFFFFFFFFFLL;
    unint64_t v11 = *v9 & 0x3FFFFFFFFFFFFFFFLL;
    if (v10 != v11)
    {
      uint64_t v12 = &v4[4 * v8];
      unint64_t v13 = *v12 & 0x3FFFFFFFFFFFFFFFLL;
      if (v10 >= v13) {
        uint64_t v14 = &v4[4 * v8];
      }
      else {
        uint64_t v14 = (void *)(a1 + 16 * a2);
      }
      if (v11 > v13) {
        uint64_t v14 = &v4[2 * v8];
      }
      if (v10 < v13) {
        v4 += 4 * v8;
      }
      if (v11 < v13) {
        uint64_t v4 = v9;
      }
      if (v10 >= v11) {
        uint64_t v4 = v14;
      }
      if (v13 == v10 || v13 == v11) {
        uint64_t v4 = v12;
      }
    }
    uint64_t v16 = 2 * v8;
    uint64_t v17 = -(uint64_t)v8;
    uint64_t v18 = 16 * v8;
    long long v19 = &v6[v18 / 0xFFFFFFFFFFFFFFF8];
    unint64_t v20 = v6[v18 / 0xFFFFFFFFFFFFFFF8] & 0x3FFFFFFFFFFFFFFFLL;
    unint64_t v21 = *v6 & 0x3FFFFFFFFFFFFFFFLL;
    if (v20 == v21)
    {
      uint64_t v22 = &v6[v18 / 0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      uint64_t v22 = &v6[(unint64_t)v18 / 8];
      unint64_t v23 = *v22 & 0x3FFFFFFFFFFFFFFFLL;
      if (v23 != v20 && v23 != v21)
      {
        if (v20 >= v21)
        {
          if (v20 < v23) {
            uint64_t v22 = v19;
          }
          if (v21 > v23) {
            uint64_t v22 = v6;
          }
        }
        else
        {
          if (v20 >= v23) {
            uint64_t v22 = v19;
          }
          if (v21 < v23) {
            uint64_t v22 = v6;
          }
        }
      }
    }
    char v25 = &v7[-2 * v16];
    char v26 = &v7[2 * v17];
    unint64_t v27 = *v25 & 0x3FFFFFFFFFFFFFFFLL;
    unint64_t v28 = *v26 & 0x3FFFFFFFFFFFFFFFLL;
    if (v27 != v28)
    {
      unint64_t v29 = *v7 & 0x3FFFFFFFFFFFFFFFLL;
      if (v27 >= v29) {
        unint64_t v30 = (void *)(a1 + 16 * a3);
      }
      else {
        unint64_t v30 = v25;
      }
      if (v28 > v29) {
        unint64_t v30 = v26;
      }
      if (v27 < v29) {
        char v25 = (void *)(a1 + 16 * a3);
      }
      if (v28 < v29) {
        char v25 = v26;
      }
      if (v27 >= v28) {
        char v25 = v30;
      }
      if (v29 == v28) {
        char v25 = (void *)(a1 + 16 * a3);
      }
      if (v29 == v27) {
        char v25 = (void *)(a1 + 16 * a3);
      }
    }
  }
  unint64_t v31 = *v4 & 0x3FFFFFFFFFFFFFFFLL;
  unint64_t v32 = *v22 & 0x3FFFFFFFFFFFFFFFLL;
  if (v31 == v32)
  {
    uint64_t v22 = v4;
  }
  else
  {
    unint64_t v33 = *v25 & 0x3FFFFFFFFFFFFFFFLL;
    if (v33 == v31 || v33 == v32)
    {
      uint64_t v22 = v25;
    }
    else if (v31 >= v32)
    {
      if (v32 <= v33)
      {
        if (v31 >= v33) {
          uint64_t v22 = v25;
        }
        else {
          uint64_t v22 = v4;
        }
      }
    }
    else if (v32 >= v33)
    {
      if (v31 >= v33) {
        uint64_t v22 = v4;
      }
      else {
        uint64_t v22 = v25;
      }
    }
  }
  long long v35 = *(_OWORD *)v22;
  *(_OWORD *)uint64_t v22 = *(_OWORD *)v7;
  *(_OWORD *)uint64_t v7 = v35;
  uint64_t v36 = a3 - a2;
  if (a3 > a2)
  {
    uint64_t v37 = (long long *)(a1 + 16 * a2);
    long long v39 = *v37;
    uint64_t v38 = v37 + 1;
    long long v40 = v39;
    unint64_t v41 = v35 & 0x3FFFFFFFFFFFFFFFLL;
    do
    {
      long long v42 = *v38;
      if (((unint64_t)v40 & 0x3FFFFFFFFFFFFFFFLL) <= v41)
      {
        *(v38 - 1) = *(_OWORD *)(a1 + 16 * a2);
        *(_OWORD *)(a1 + 16 * a2++) = v40;
      }
      ++v38;
      long long v40 = v42;
      --v36;
    }
    while (v36);
  }
  long long v43 = *(_OWORD *)(a1 + 16 * a2);
  *(_OWORD *)(a1 + 16 * a2) = *(_OWORD *)v7;
  *(_OWORD *)uint64_t v7 = v43;
  return a2;
}

uint64_t ___qsort_offset_with_meta_t_block_invoke(uint64_t a1, void *a2, void *a3)
{
  unint64_t v3 = *a2 & 0x3FFFFFFFFFFFFFFFLL;
  unint64_t v4 = *a3 & 0x3FFFFFFFFFFFFFFFLL;
  BOOL v5 = v3 > v4;
  if (v3 == v4) {
    unsigned int v6 = 0;
  }
  else {
    unsigned int v6 = -1;
  }
  if (v5) {
    return 1;
  }
  else {
    return v6;
  }
}

void _qsort_big_offset_with_meta_t(void *a1)
{
  uint64_t v1 = *((void *)a1 + 1);
  uint64_t v2 = *((void *)a1 + 2);
  unint64_t v3 = *((void *)a1 + 3);
  uint64_t v4 = *((void *)a1 + 4);
  uint64_t v5 = *((void *)a1 + 5);
  uint64_t v36 = *((void *)a1 + 6);
  uint64_t v37 = *(void *)a1;
  signed int v6 = *((_DWORD *)a1 + 14);
  int v35 = *((_DWORD *)a1 + 15);
  OSAtomicEnqueue(&qsort_cached_allocations, a1, 0);
  if (v2 > v1)
  {
    for (unint64_t i = v4 + 1; ; ++i)
    {
      uint64_t v10 = v2 - v1;
      if (v2 - v1 <= v5 || i > 9) {
        break;
      }
      if (v6 <= 1) {
        signed int v6 = 1;
      }
      uint64_t v12 = getSize_memSize;
      if (!getSize_memSize)
      {
        long long v42 = 0u;
        long long v43 = 0u;
        *(_OWORD *)host_info_out = 0u;
        host_t v13 = MEMORY[0x1C1881C90]();
        mach_msg_type_number_t host_info_outCnt = 12;
        mach_error_t v14 = host_info(v13, 1, host_info_out, &host_info_outCnt);
        if (v14)
        {
          mach_error("flushsize", v14);
          exit(1);
        }
        uint64_t v12 = *((void *)&v43 + 1);
        getSize_memSize = *((void *)&v43 + 1);
      }
      unint64_t v15 = 3 * v12 / 5uLL;
      uint64_t v16 = v3;
      if (16 * v10 > v15) {
        uint64_t v16 = dispatch_group_create();
      }
      if (v10 <= v36 || 16 * v10 >= v15)
      {
        uint64_t v19 = _partition_offset_with_meta_t(v37, v1, v2);
      }
      else
      {
        qos_class_t v17 = qos_class_self();
        global_queue = dispatch_get_global_queue(v17, 2uLL);
        uint64_t v19 = _big_partition_offset_with_meta_t(v37, v1, v2, global_queue, v6);
      }
      uint64_t v20 = v19;
      uint64_t v21 = v19 - v1;
      if (v19 < v1)
      {
        unint64_t v31 = __si_assert_copy_extra_329();
        unint64_t v32 = v31;
        unint64_t v33 = "";
        if (v31) {
          unint64_t v33 = v31;
        }
        __message_assert(v31, "OQueue.c", 13, "q>=left", v33, v39);
        free(v32);
        if (__valid_fs(-1)) {
          uint64_t v34 = 2989;
        }
        else {
          uint64_t v34 = 3072;
        }
        *(_DWORD *)uint64_t v34 = -559038737;
        abort();
      }
      uint64_t v22 = OSAtomicDequeue(&qsort_cached_allocations, 0);
      if (!v22) {
        uint64_t v22 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
      }
      *((void *)v22 + 4) = i;
      *((void *)v22 + 5) = v5;
      *((void *)v22 + 6) = v36;
      uint64_t v23 = v2 - v20;
      if (v21 <= v2 - v20)
      {
        uint64_t v24 = v20 - 1;
      }
      else
      {
        uint64_t v23 = v20 - 1 - v1;
        uint64_t v24 = v2;
      }
      if (v21 > v2 - v20) {
        uint64_t v25 = v20;
      }
      else {
        uint64_t v25 = v1;
      }
      if (v21 > v2 - v20) {
        uint64_t v2 = v20 - 1;
      }
      else {
        uint64_t v1 = v20;
      }
      *(void *)uint64_t v22 = v37;
      *((void *)v22 + 1) = v25;
      int v26 = (int)(float)((float)((float)(v23 + 1) * (float)v6) / (float)(v24 - v25 + 1));
      if (v26 <= 1) {
        int v27 = 1;
      }
      else {
        int v27 = v26;
      }
      if (v6 >= v26) {
        int v28 = v27;
      }
      else {
        int v28 = 0;
      }
      v22[14] = v6 - v28;
      v22[15] = v35;
      *((void *)v22 + 2) = v24;
      *((void *)v22 + 3) = v16;
      if (v16 == v3)
      {
        if (v6 >= v26) {
          signed int v6 = v27;
        }
        qos_class_t v8 = qos_class_self();
        uint64_t v9 = dispatch_get_global_queue(v8, 2uLL);
        dispatch_group_async_f(v3, v9, v22, (dispatch_function_t)_qsort_big_offset_with_meta_t);
      }
      else
      {
        v22[14] = v6;
        _qsort_big_offset_with_meta_t(v22);
        dispatch_group_wait(v16, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(v16);
        qos_class_t v29 = qos_class_self();
        unint64_t v30 = dispatch_get_global_queue(v29, 2uLL);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        v39[0] = ___qsort_big_offset_with_meta_t_block_invoke;
        v39[1] = &__block_descriptor_tmp_3269;
        v39[2] = v22;
        dispatch_async(v30, block);
      }
      if (v2 <= v1) {
        return;
      }
    }
    _qsort_offset_with_meta_t(v37, v1, v2);
  }
}

uint64_t _big_partition_offset_with_meta_t(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  uint64_t v7 = a3 - a2;
  BOOL v8 = __OFADD__(a3 - a2, 1);
  unint64_t v9 = a3 - a2 + 1;
  uint64_t v10 = (void *)(a1 + 16 * a2);
  unint64_t v11 = v7 + 2;
  if (((v9 & 0x8000000000000000) != 0) == v8) {
    unint64_t v11 = v7 + 1;
  }
  uint64_t v12 = &v10[2 * (v11 >> 1)];
  host_t v13 = (void *)(a1 + 16 * a3);
  if (v7 < 64)
  {
    qos_class_t v29 = &v10[2 * (v11 >> 1)];
    uint64_t v18 = v10;
  }
  else
  {
    unint64_t v14 = v9 >> 3;
    unint64_t v15 = &v10[2 * (v9 >> 3)];
    unint64_t v16 = *v10 & 0x3FFFFFFFFFFFFFFFLL;
    unint64_t v17 = *v15 & 0x3FFFFFFFFFFFFFFFLL;
    uint64_t v18 = v10;
    if (v16 != v17)
    {
      uint64_t v18 = &v10[4 * v14];
      unint64_t v19 = *v18 & 0x3FFFFFFFFFFFFFFFLL;
      if (v16 >= v19) {
        uint64_t v20 = &v10[4 * v14];
      }
      else {
        uint64_t v20 = v10;
      }
      if (v17 > v19) {
        uint64_t v20 = &v10[2 * (v9 >> 3)];
      }
      if (v16 >= v19) {
        uint64_t v21 = v10;
      }
      else {
        uint64_t v21 = &v10[4 * v14];
      }
      if (v17 >= v19) {
        unint64_t v15 = v21;
      }
      if (v16 >= v17) {
        unint64_t v15 = v20;
      }
      if (v19 != v16 && v19 != v17) {
        uint64_t v18 = v15;
      }
    }
    uint64_t v23 = 2 * v14;
    uint64_t v24 = -(uint64_t)v14;
    uint64_t v25 = 16 * v14;
    int v26 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
    unint64_t v27 = v12[v25 / 0xFFFFFFFFFFFFFFF8] & 0x3FFFFFFFFFFFFFFFLL;
    unint64_t v28 = *v12 & 0x3FFFFFFFFFFFFFFFLL;
    if (v27 == v28)
    {
      qos_class_t v29 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      qos_class_t v29 = &v12[(unint64_t)v25 / 8];
      unint64_t v30 = *v29 & 0x3FFFFFFFFFFFFFFFLL;
      if (v30 != v27 && v30 != v28)
      {
        if (v27 >= v28)
        {
          if (v27 < v30) {
            qos_class_t v29 = v26;
          }
          if (v28 > v30) {
            qos_class_t v29 = v12;
          }
        }
        else
        {
          if (v27 >= v30) {
            qos_class_t v29 = v26;
          }
          if (v28 < v30) {
            qos_class_t v29 = v12;
          }
        }
      }
    }
    unint64_t v32 = &v13[-2 * v23];
    unint64_t v33 = &v13[2 * v24];
    unint64_t v34 = *v32 & 0x3FFFFFFFFFFFFFFFLL;
    unint64_t v35 = *v33 & 0x3FFFFFFFFFFFFFFFLL;
    if (v34 == v35)
    {
      host_t v13 = v32;
    }
    else
    {
      unint64_t v36 = *v13 & 0x3FFFFFFFFFFFFFFFLL;
      if (v34 >= v36) {
        uint64_t v37 = v13;
      }
      else {
        uint64_t v37 = v32;
      }
      if (v35 > v36) {
        uint64_t v37 = v33;
      }
      if (v34 < v36) {
        unint64_t v32 = v13;
      }
      if (v35 < v36) {
        unint64_t v32 = v33;
      }
      if (v34 >= v35) {
        unint64_t v32 = v37;
      }
      if (v36 == v35) {
        unint64_t v32 = v13;
      }
      if (v36 != v34) {
        host_t v13 = v32;
      }
    }
  }
  unint64_t v38 = *v18 & 0x3FFFFFFFFFFFFFFFLL;
  unint64_t v39 = *v29 & 0x3FFFFFFFFFFFFFFFLL;
  if (v38 == v39)
  {
    qos_class_t v29 = v18;
  }
  else
  {
    unint64_t v40 = *v13 & 0x3FFFFFFFFFFFFFFFLL;
    if (v40 == v38 || v40 == v39)
    {
      qos_class_t v29 = v13;
    }
    else if (v38 >= v39)
    {
      if (v39 <= v40)
      {
        if (v38 >= v40) {
          qos_class_t v29 = v13;
        }
        else {
          qos_class_t v29 = v18;
        }
      }
    }
    else if (v39 >= v40)
    {
      if (v38 >= v40) {
        qos_class_t v29 = v18;
      }
      else {
        qos_class_t v29 = v13;
      }
    }
  }
  return parallel_partition_offset_with_meta_t(v10, v9, *v29 & 0x3FFFFFFFFFFFFFFFLL, a4, a5) + a2;
}

void ___qsort_big_offset_with_meta_t_block_invoke(uint64_t a1)
{
  madvise((void *)(**(void **)(a1 + 32) + 16 * *(void *)(*(void *)(a1 + 32) + 8)), 16 * (*(void *)(*(void *)(a1 + 32) + 16) - *(void *)(*(void *)(a1 + 32) + 8)), 4);
  uint64_t v2 = *(void **)(a1 + 32);
  OSAtomicEnqueue(&qsort_cached_allocations, v2, 0);
}

uint64_t parallel_partition_offset_with_meta_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  int v5 = a5;
  v17[1] = v17;
  context[9] = *MEMORY[0x1E4F143B8];
  context[6] = a1;
  size_t v10 = 8 * a5;
  MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)v17 - v11;
  bzero((char *)v17 - v11, v10);
  uint64_t v13 = (a2 / 0x4000) << 13;
  context[1] = v13;
  context[2] = a2;
  uint64_t v14 = a2 - v13;
  context[4] = 0;
  context[5] = 0;
  context[7] = a3;
  context[8] = v12;
  if (v5 >= 1) {
    memset(v12, 255, v10);
  }
  uint64_t v15 = v13 + 0x2000;
  if (v14 > v13 + 0x2000) {
    uint64_t v15 = a2 - v13;
  }
  context[3] = v14 + ((v15 - v14 + 0x1FFF) & 0xFFFFFFFFFFFFE000);
  context[0] = 0;
  if (16 * a2 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
    madvise(a1, 16 * a2, 3);
  }
  if (a2 / 0x4000 < v5) {
    int v5 = a2 / 0x4000;
  }
  dispatch_apply_f(v5, a4, context, (void (__cdecl *)(void *, size_t))partition_phase_offset_with_meta_t);
  return sequential_fixup_offset_with_meta_t((uint64_t)context, a2, v5);
}

uint64_t sequential_fixup_offset_with_meta_t(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = a3;
  qsort(*(void **)(a1 + 64), a3, 8uLL, (int (__cdecl *)(const void *, const void *))index_comp);
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v8 = a3 - 1;
  uint64_t v9 = 0;
  if (a3 < 1) {
    goto LABEL_111;
  }
  while (*(void *)(v7 + 8 * v9) == -1)
  {
    if (v6 == ++v9)
    {
      uint64_t v9 = v6;
      break;
    }
  }
  if (a3 == 1)
  {
    uint64_t v8 = 0;
    if (v9 >= 0) {
      goto LABEL_46;
    }
  }
  else
  {
LABEL_111:
    do
    {
      if (*(void *)(v7 + 8 * v8) != -1) {
        break;
      }
      --v8;
    }
    while (v8);
    if (v9 >= v8) {
      goto LABEL_46;
    }
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  do
  {
    uint64_t v13 = *(void *)(a1 + 48);
    unint64_t v12 = *(void *)(a1 + 56);
    uint64_t v14 = v13 + 16 * *(void *)(v7 + 8 * v9);
    uint64_t v15 = v13 + 16 * *(void *)(v7 + 8 * v8);
    while (1)
    {
      if (v10 < 0x2000)
      {
        unint64_t v16 = (uint64_t *)(v14 + 16 * v10);
        while (1)
        {
          uint64_t v17 = *v16;
          v16 += 2;
          if ((v17 & 0x3FFFFFFFFFFFFFFFuLL) > v12) {
            break;
          }
          if (++v10 == 0x2000)
          {
            uint64_t v18 = 0x2000;
            if (v11 < 0x2000) {
              goto LABEL_20;
            }
            goto LABEL_24;
          }
        }
      }
      uint64_t v18 = v10;
      if (v11 < 0x2000)
      {
LABEL_20:
        unint64_t v19 = (uint64_t *)(v15 + 16 * v11);
        while (1)
        {
          uint64_t v20 = *v19;
          v19 += 2;
          if ((v20 & 0x3FFFFFFFFFFFFFFFuLL) < v12) {
            break;
          }
          if (++v11 == 0x2000)
          {
            uint64_t v10 = v18;
            goto LABEL_28;
          }
        }
      }
LABEL_24:
      uint64_t v21 = v11;
      if (v18 == 0x2000 || v11 == 0x2000) {
        break;
      }
      long long v22 = *(_OWORD *)(v15 + 16 * v11);
      *(_OWORD *)(v15 + 16 * v11) = *(_OWORD *)(v14 + 16 * v18);
      *(_OWORD *)(v14 + 16 * v18) = v22;
      uint64_t v10 = v18 + 1;
      ++v11;
      if (v18 > 8190 || v21 >= 0x1FFF) {
        goto LABEL_28;
      }
    }
    uint64_t v10 = v18;
LABEL_28:
    if (v11 == 0x2000 && v10 == 0x2000) {
      int v24 = 2;
    }
    else {
      int v24 = v10 != 0x2000;
    }
    uint64_t v7 = *(void *)(a1 + 64);
    if ((v24 & 1) == 0)
    {
      uint64_t v25 = *(void *)(v7 + 8 * v9);
      if ((v25 & 0x8000000000000000) == 0 && v25 < *(void *)(a1 + 32))
      {
        *(void *)(v7 + 8 * v9) = -1;
        *(void *)(a1 + 32) += 0x2000;
      }
      uint64_t v10 = 0;
      ++v9;
      if ((v24 - 1) > 1) {
        continue;
      }
    }
    uint64_t v26 = *(void *)(v7 + 8 * v8);
    BOOL v27 = v26 >= a2 || v26 < a2 - *(void *)(a1 + 40);
    if (!v27)
    {
      *(void *)(v7 + 8 * v8) = -1;
      *(void *)(a1 + 40) += 0x2000;
    }
    uint64_t v11 = 0;
    --v8;
  }
  while (v9 < v8);
LABEL_46:
  unint64_t v29 = *(void *)(a1 + 32);
  uint64_t v28 = *(void *)(a1 + 40);
  unint64_t v30 = malloc_type_malloc(0x20000uLL, 0xDA5C7297uLL);
  if (a3 < 1)
  {
    uint64_t v46 = *(void *)a1;
    uint64_t v47 = *(void *)(a1 + 16) - 1;
  }
  else
  {
    uint64_t v31 = 0;
    unint64_t v32 = ~v28 + a2;
    uint64_t v33 = a3;
    unint64_t v34 = *(uint64_t **)(a1 + 64);
    uint64_t v35 = 8 * a3;
    do
    {
      unint64_t v36 = v34[v31];
      if (v36 != -1 && v32 <= v36) {
        break;
      }
      if (v36 != -1)
      {
        if (v29 <= v36) {
          break;
        }
        unint64_t v38 = *(void *)(a1 + 32);
        if (v38 > v36)
        {
          unint64_t v39 = 0;
          do
          {
            if (v34[v39 / 8] == v38)
            {
              v38 += 0x2000;
              *(void *)(a1 + 32) = v38;
            }
            v39 += 8;
          }
          while (v35 != v39);
          if ((int64_t)v38 >= *(void *)a1) {
            break;
          }
          memcpy(v30, (const void *)(*(void *)(a1 + 48) + 16 * v34[v31]), 0x20000uLL);
          memcpy((void *)(*(void *)(a1 + 48) + 16 * *(void *)(*(void *)(a1 + 64) + 8 * v31)), (const void *)(*(void *)(a1 + 48) + 16 * *(void *)(a1 + 32)), 0x20000uLL);
          memcpy((void *)(*(void *)(a1 + 48) + 16 * *(void *)(a1 + 32)), v30, 0x20000uLL);
          unint64_t v34 = *(uint64_t **)(a1 + 64);
          v34[v31] = *(void *)(a1 + 32);
          *(void *)(a1 + 32) += 0x2000;
        }
      }
      ++v31;
    }
    while (v31 != v33);
    uint64_t v40 = v33;
    do
    {
      unint64_t v41 = v34[(v40 - 1)];
      if (v29 > v41) {
        break;
      }
      if (v41 != -1)
      {
        if (v32 > v41) {
          break;
        }
        uint64_t v42 = (v40 - 1);
        uint64_t v43 = *(void *)(a1 + 40) + 0x2000;
        *(void *)(a1 + 40) = v43;
        uint64_t v44 = v33 + 1;
        do
        {
          if (v34[(v44 - 2)] == a2 - v43)
          {
            v43 += 0x2000;
            *(void *)(a1 + 40) = v43;
          }
          --v44;
        }
        while (v44 > 1);
        if ((unint64_t)(a2 - v43) < *(void *)(a1 + 16)) {
          break;
        }
        uint64_t v45 = v42;
        memcpy(v30, (const void *)(*(void *)(a1 + 48) + 16 * v34[v42]), 0x20000uLL);
        memcpy((void *)(*(void *)(a1 + 48) + 16 * *(void *)(*(void *)(a1 + 64) + v45 * 8)), (const void *)(*(void *)(a1 + 48) + 16 * (a2 - *(void *)(a1 + 40))), 0x20000uLL);
        memcpy((void *)(*(void *)(a1 + 48) + 16 * (a2 - *(void *)(a1 + 40))), v30, 0x20000uLL);
        unint64_t v34 = *(uint64_t **)(a1 + 64);
        v34[v45] = a2 - *(void *)(a1 + 40);
      }
      BOOL v27 = v40-- <= 1;
    }
    while (!v27);
    uint64_t v46 = *(void *)a1;
    uint64_t v47 = *(void *)(a1 + 16) - 1;
    do
    {
      uint64_t v49 = *v34++;
      uint64_t v48 = v49;
      if (v49 != -1)
      {
        if (v48 < v46) {
          uint64_t v46 = v48;
        }
        uint64_t v50 = v48 + 0x2000;
        uint64_t v51 = v48 + 0x1FFF;
        if (v50 > v47) {
          uint64_t v47 = v51;
        }
        if (v47 >= a2)
        {
          CFIndex v52 = __si_assert_copy_extra_329();
          int v53 = v52;
          float v54 = "";
          if (v52) {
            float v54 = v52;
          }
          __message_assert(v52, "OQueue.c", 13, "right < count", v54);
          free(v53);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
      }
      --v33;
    }
    while (v33);
  }
  free(v30);
  if (v46 >= v47)
  {
    uint64_t v55 = v46;
  }
  else
  {
    uint64_t v55 = v46;
    do
    {
      uint64_t v56 = *(void *)(a1 + 48);
      unint64_t v57 = *(void *)(a1 + 56);
      NSUInteger v58 = (uint64_t *)(v56 + 16 * v46);
      while (1)
      {
        uint64_t v59 = *v58;
        v58 += 2;
        if ((v59 & 0x3FFFFFFFFFFFFFFFuLL) >= v57) {
          break;
        }
        if (++v55 >= v47)
        {
          if (v47 <= v46 + 1) {
            uint64_t v55 = v46 + 1;
          }
          else {
            uint64_t v55 = v47;
          }
          goto LABEL_105;
        }
      }
      if (v55 < v47)
      {
        long long v60 = (uint64_t *)(v56 + 16 * v47);
        while (1)
        {
          uint64_t v61 = *v60;
          v60 -= 2;
          if ((v61 & 0x3FFFFFFFFFFFFFFFuLL) <= v57) {
            break;
          }
          if (v55 >= --v47) {
            goto LABEL_105;
          }
        }
        long long v62 = *(_OWORD *)(v56 + 16 * v47);
        *(_OWORD *)(v56 + 16 * v47) = *(_OWORD *)(v56 + 16 * v55);
        *(_OWORD *)(*(void *)(a1 + 48) + 16 * v55++) = v62;
        --v47;
      }
      uint64_t v46 = v55;
    }
    while (v55 < v47);
  }
LABEL_105:
  if ((*(void *)(*(void *)(a1 + 48) + 16 * v55) & 0x3FFFFFFFFFFFFFFFuLL) >= *(void *)(a1 + 56)) {
    return v55;
  }
  else {
    return v55 + 1;
  }
}

uint64_t index_comp(void *a1, void *a2)
{
  if (*a1 >= *a2) {
    unsigned int v2 = 0;
  }
  else {
    unsigned int v2 = -1;
  }
  if (*a1 > *a2) {
    return 1;
  }
  else {
    return v2;
  }
}

{
  unsigned int v2;

  if (*a1 >= *a2) {
    unsigned int v2 = 0;
  }
  else {
    unsigned int v2 = -1;
  }
  if (*a1 > *a2) {
    return 1;
  }
  else {
    return v2;
  }
}

atomic_ullong *partition_phase_offset_with_meta_t(atomic_ullong *result, uint64_t a2)
{
  atomic_ullong v2 = result[6];
  atomic_ullong v3 = result[1];
  if (*result < v3)
  {
    unint64_t add_explicit = atomic_fetch_add_explicit(result, 0x2000uLL, memory_order_relaxed);
    if ((uint64_t)(add_explicit + 0x2000) <= v3) {
      goto LABEL_5;
    }
    atomic_fetch_add_explicit(result, 0xFFFFFFFFFFFFE000, memory_order_relaxed);
  }
  unint64_t add_explicit = -1;
LABEL_5:
  int64_t v5 = result[3];
  if (result[2] <= v5)
  {
LABEL_8:
    uint64_t v7 = 0;
    if (add_explicit != -1)
    {
      uint64_t v8 = 0;
      goto LABEL_19;
    }
    int64_t v6 = -1;
    uint64_t v8 = 0;
LABEL_18:
    unint64_t add_explicit = v6;
    goto LABEL_19;
  }
  int64_t v6 = atomic_fetch_add_explicit(result + 2, 0xFFFFFFFFFFFFE000, memory_order_relaxed) - 0x2000;
  if (v6 < v5)
  {
    atomic_fetch_add_explicit(result + 2, 0x2000uLL, memory_order_relaxed);
    goto LABEL_8;
  }
  BOOL v9 = add_explicit != -1;
  if (v6 != -1 && add_explicit != -1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    while (1)
    {
      unint64_t v13 = v2 + 16 * add_explicit;
      unint64_t v14 = result[7];
      atomic_ullong v15 = v2 + 16 * v6;
      while (1)
      {
        if (v12 < 0x2000)
        {
          unint64_t v16 = (uint64_t *)(v13 + 16 * v12);
          while (1)
          {
            uint64_t v17 = *v16;
            v16 += 2;
            if ((v17 & 0x3FFFFFFFFFFFFFFFuLL) > v14) {
              break;
            }
            if (++v12 == 0x2000)
            {
              uint64_t v18 = 0x2000;
              if (v11 < 0x2000) {
                goto LABEL_28;
              }
              goto LABEL_32;
            }
          }
        }
        uint64_t v18 = v12;
        if (v11 < 0x2000)
        {
LABEL_28:
          unint64_t v19 = (uint64_t *)(v15 + 16 * v11);
          while (1)
          {
            uint64_t v20 = *v19;
            v19 += 2;
            if ((v20 & 0x3FFFFFFFFFFFFFFFuLL) < v14) {
              break;
            }
            if (++v11 == 0x2000)
            {
              uint64_t v12 = v18;
              goto LABEL_36;
            }
          }
        }
LABEL_32:
        uint64_t v21 = v11;
        if (v18 == 0x2000 || v11 == 0x2000) {
          break;
        }
        long long v22 = *(_OWORD *)(v15 + 16 * v11);
        *(_OWORD *)(v15 + 16 * v11) = *(_OWORD *)(v13 + 16 * v18);
        *(_OWORD *)(v13 + 16 * v18) = v22;
        uint64_t v12 = v18 + 1;
        ++v11;
        if (v18 > 8190 || v21 >= 0x1FFF) {
          goto LABEL_36;
        }
      }
      uint64_t v12 = v18;
LABEL_36:
      int v23 = v12 != 0x2000;
      if (v11 == 0x2000 && v12 == 0x2000) {
        int v23 = 2;
      }
      if (v23) {
        goto LABEL_47;
      }
      atomic_ullong v25 = result[1];
      if (*result < v25)
      {
        unint64_t add_explicit = atomic_fetch_add_explicit(result, 0x2000uLL, memory_order_relaxed);
        if ((uint64_t)(add_explicit + 0x2000) <= v25) {
          goto LABEL_46;
        }
        atomic_fetch_add_explicit(result, 0xFFFFFFFFFFFFE000, memory_order_relaxed);
      }
      unint64_t add_explicit = -1;
LABEL_46:
      uint64_t v12 = 0;
      ++v8;
      if ((v23 - 1) > 1) {
        goto LABEL_52;
      }
LABEL_47:
      int64_t v26 = result[3];
      if (result[2] <= v26) {
        goto LABEL_50;
      }
      int64_t v6 = atomic_fetch_add_explicit(result + 2, 0xFFFFFFFFFFFFE000, memory_order_relaxed) - 0x2000;
      if (v6 < v26)
      {
        atomic_fetch_add_explicit(result + 2, 0x2000uLL, memory_order_relaxed);
LABEL_50:
        int64_t v6 = -1;
      }
      uint64_t v11 = 0;
      ++v7;
LABEL_52:
      BOOL v9 = add_explicit != -1;
      if (v6 == -1 || add_explicit == -1) {
        goto LABEL_17;
      }
    }
  }
  uint64_t v8 = 0;
  uint64_t v7 = 0;
LABEL_17:
  if (!v9) {
    goto LABEL_18;
  }
LABEL_19:
  *(void *)(result[8] + 8 * a2) = add_explicit;
  atomic_fetch_add_explicit(result + 4, v8 << 13, memory_order_relaxed);
  atomic_fetch_add_explicit(result + 5, v7 << 13, memory_order_relaxed);
  return result;
}

uint64_t _big_split_offset_with_meta_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, signed int a5)
{
  uint64_t v5 = a2 + 1;
  if (a5 >= 3)
  {
    while (v5 < (uint64_t)((unint64_t)a5 << 13))
    {
      if (a5-- <= 3)
      {
        a5 = 2;
        return parallel_partition_offset_with_meta_t(a1, v5, a3, a4, a5);
      }
    }
  }
  return parallel_partition_offset_with_meta_t(a1, v5, a3, a4, a5);
}

void *oqinit_offset_t(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = a2;
  if (!a2)
  {
LABEL_5:
    uint64_t result = 0;
    goto LABEL_6;
  }
  uint64_t result = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * a2, 0x6085D6BuLL);
  if (!result)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", v4, 2u);
    }
    goto LABEL_5;
  }
LABEL_6:
  *(void *)(a1 + 8) = result;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0xFFFFFFFFLL;
  *(_DWORD *)a1 = 0;
  return result;
}

void _qsort_big_offset_t(void *a1)
{
  uint64_t v1 = *((void *)a1 + 1);
  uint64_t v2 = *((void *)a1 + 2);
  atomic_ullong v3 = *((void *)a1 + 3);
  uint64_t v4 = *((void *)a1 + 4);
  uint64_t v5 = *((void *)a1 + 5);
  uint64_t v36 = *((void *)a1 + 6);
  uint64_t v37 = *(void *)a1;
  signed int v6 = *((_DWORD *)a1 + 14);
  int v35 = *((_DWORD *)a1 + 15);
  OSAtomicEnqueue(&qsort_cached_allocations, a1, 0);
  if (v2 > v1)
  {
    for (unint64_t i = v4 + 1; ; ++i)
    {
      uint64_t v10 = v2 - v1;
      if (v2 - v1 <= v5 || i > 9) {
        break;
      }
      if (v6 <= 1) {
        signed int v6 = 1;
      }
      uint64_t v12 = getSize_memSize;
      if (!getSize_memSize)
      {
        long long v42 = 0u;
        long long v43 = 0u;
        *(_OWORD *)host_info_out = 0u;
        host_t v13 = MEMORY[0x1C1881C90]();
        mach_msg_type_number_t host_info_outCnt = 12;
        mach_error_t v14 = host_info(v13, 1, host_info_out, &host_info_outCnt);
        if (v14)
        {
          mach_error("flushsize", v14);
          exit(1);
        }
        uint64_t v12 = *((void *)&v43 + 1);
        getSize_memSize = *((void *)&v43 + 1);
      }
      unint64_t v15 = 3 * v12 / 5uLL;
      unint64_t v16 = v3;
      if (8 * v10 > v15) {
        unint64_t v16 = dispatch_group_create();
      }
      if (v10 <= v36 || 8 * v10 >= v15)
      {
        uint64_t v19 = _partition_offset_t(v37, v1, v2);
      }
      else
      {
        qos_class_t v17 = qos_class_self();
        global_queue = dispatch_get_global_queue(v17, 2uLL);
        uint64_t v19 = _big_partition_offset_t(v37, v1, v2, global_queue, v6);
      }
      uint64_t v20 = v19;
      uint64_t v21 = v19 - v1;
      if (v19 < v1)
      {
        uint64_t v31 = __si_assert_copy_extra_329();
        unint64_t v32 = v31;
        uint64_t v33 = "";
        if (v31) {
          uint64_t v33 = v31;
        }
        __message_assert(v31, "OQueue.c", 14, "q>=left", v33, v39);
        free(v32);
        if (__valid_fs(-1)) {
          uint64_t v34 = 2989;
        }
        else {
          uint64_t v34 = 3072;
        }
        *(_DWORD *)uint64_t v34 = -559038737;
        abort();
      }
      long long v22 = OSAtomicDequeue(&qsort_cached_allocations, 0);
      if (!v22) {
        long long v22 = malloc_type_malloc(0x40uLL, 0x10300409C00947AuLL);
      }
      *((void *)v22 + 4) = i;
      *((void *)v22 + 5) = v5;
      *((void *)v22 + 6) = v36;
      uint64_t v23 = v2 - v20;
      if (v21 <= v2 - v20)
      {
        uint64_t v24 = v20 - 1;
      }
      else
      {
        uint64_t v23 = v20 - 1 - v1;
        uint64_t v24 = v2;
      }
      if (v21 > v2 - v20) {
        uint64_t v25 = v20;
      }
      else {
        uint64_t v25 = v1;
      }
      if (v21 > v2 - v20) {
        uint64_t v2 = v20 - 1;
      }
      else {
        uint64_t v1 = v20;
      }
      *(void *)long long v22 = v37;
      *((void *)v22 + 1) = v25;
      int v26 = (int)(float)((float)((float)(v23 + 1) * (float)v6) / (float)(v24 - v25 + 1));
      if (v26 <= 1) {
        int v27 = 1;
      }
      else {
        int v27 = v26;
      }
      if (v6 >= v26) {
        int v28 = v27;
      }
      else {
        int v28 = 0;
      }
      v22[14] = v6 - v28;
      v22[15] = v35;
      *((void *)v22 + 2) = v24;
      *((void *)v22 + 3) = v16;
      if (v16 == v3)
      {
        if (v6 >= v26) {
          signed int v6 = v27;
        }
        qos_class_t v8 = qos_class_self();
        BOOL v9 = dispatch_get_global_queue(v8, 2uLL);
        dispatch_group_async_f(v3, v9, v22, (dispatch_function_t)_qsort_big_offset_t);
      }
      else
      {
        v22[14] = v6;
        _qsort_big_offset_t(v22);
        dispatch_group_wait(v16, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(v16);
        qos_class_t v29 = qos_class_self();
        unint64_t v30 = dispatch_get_global_queue(v29, 2uLL);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        v39[0] = ___qsort_big_offset_t_block_invoke;
        v39[1] = &__block_descriptor_tmp_23_3288;
        v39[2] = v22;
        dispatch_async(v30, block);
      }
      if (v2 <= v1) {
        return;
      }
    }
    _qsort_offset_t(v37, v1, v2);
  }
}

uint64_t _big_partition_offset_t(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  uint64_t v7 = a3 - a2;
  BOOL v8 = __OFADD__(a3 - a2, 1);
  unint64_t v9 = a3 - a2 + 1;
  uint64_t v10 = (void *)(a1 + 8 * a2);
  unint64_t v11 = v7 + 2;
  if (((v9 & 0x8000000000000000) != 0) == v8) {
    unint64_t v11 = v7 + 1;
  }
  uint64_t v12 = &v10[v11 >> 1];
  host_t v13 = (void *)(a1 + 8 * a3);
  if (v7 < 64)
  {
    qos_class_t v29 = &v10[v11 >> 1];
    uint64_t v18 = v10;
  }
  else
  {
    unint64_t v14 = v9 >> 3;
    unint64_t v15 = &v10[v9 >> 3];
    unint64_t v16 = *v10 & 0x3FFFFFFFFFFFFFFFLL;
    unint64_t v17 = *v15 & 0x3FFFFFFFFFFFFFFFLL;
    uint64_t v18 = v10;
    if (v16 != v17)
    {
      uint64_t v18 = &v10[2 * v14];
      unint64_t v19 = *v18 & 0x3FFFFFFFFFFFFFFFLL;
      if (v16 >= v19) {
        uint64_t v20 = &v10[2 * v14];
      }
      else {
        uint64_t v20 = v10;
      }
      if (v17 > v19) {
        uint64_t v20 = &v10[v9 >> 3];
      }
      if (v16 >= v19) {
        uint64_t v21 = v10;
      }
      else {
        uint64_t v21 = &v10[2 * v14];
      }
      if (v17 >= v19) {
        unint64_t v15 = v21;
      }
      if (v16 >= v17) {
        unint64_t v15 = v20;
      }
      if (v19 != v16 && v19 != v17) {
        uint64_t v18 = v15;
      }
    }
    uint64_t v23 = 2 * v14;
    uint64_t v24 = -(uint64_t)v14;
    uint64_t v25 = 8 * v14;
    int v26 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
    unint64_t v27 = v12[v25 / 0xFFFFFFFFFFFFFFF8] & 0x3FFFFFFFFFFFFFFFLL;
    unint64_t v28 = *v12 & 0x3FFFFFFFFFFFFFFFLL;
    if (v27 == v28)
    {
      qos_class_t v29 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      qos_class_t v29 = &v12[(unint64_t)v25 / 8];
      unint64_t v30 = *v29 & 0x3FFFFFFFFFFFFFFFLL;
      if (v30 != v27 && v30 != v28)
      {
        if (v27 >= v28)
        {
          if (v27 < v30) {
            qos_class_t v29 = v26;
          }
          if (v28 > v30) {
            qos_class_t v29 = v12;
          }
        }
        else
        {
          if (v27 >= v30) {
            qos_class_t v29 = v26;
          }
          if (v28 < v30) {
            qos_class_t v29 = v12;
          }
        }
      }
    }
    unint64_t v32 = &v13[-v23];
    uint64_t v33 = &v13[v24];
    unint64_t v34 = *v32 & 0x3FFFFFFFFFFFFFFFLL;
    unint64_t v35 = *v33 & 0x3FFFFFFFFFFFFFFFLL;
    if (v34 == v35)
    {
      host_t v13 = v32;
    }
    else
    {
      unint64_t v36 = *v13 & 0x3FFFFFFFFFFFFFFFLL;
      if (v34 >= v36) {
        uint64_t v37 = v13;
      }
      else {
        uint64_t v37 = v32;
      }
      if (v35 > v36) {
        uint64_t v37 = v33;
      }
      if (v34 < v36) {
        unint64_t v32 = v13;
      }
      if (v35 < v36) {
        unint64_t v32 = v33;
      }
      if (v34 >= v35) {
        unint64_t v32 = v37;
      }
      if (v36 == v35) {
        unint64_t v32 = v13;
      }
      if (v36 != v34) {
        host_t v13 = v32;
      }
    }
  }
  unint64_t v38 = *v18 & 0x3FFFFFFFFFFFFFFFLL;
  unint64_t v39 = *v29 & 0x3FFFFFFFFFFFFFFFLL;
  if (v38 == v39)
  {
    qos_class_t v29 = v18;
  }
  else
  {
    unint64_t v40 = *v13 & 0x3FFFFFFFFFFFFFFFLL;
    if (v40 == v38 || v40 == v39)
    {
      qos_class_t v29 = v13;
    }
    else if (v38 >= v39)
    {
      if (v39 <= v40)
      {
        if (v38 >= v40) {
          qos_class_t v29 = v13;
        }
        else {
          qos_class_t v29 = v18;
        }
      }
    }
    else if (v39 >= v40)
    {
      if (v38 >= v40) {
        qos_class_t v29 = v18;
      }
      else {
        qos_class_t v29 = v13;
      }
    }
  }
  return parallel_partition_offset_t(v10, v9, *v29 & 0x3FFFFFFFFFFFFFFFLL, a4, a5) + a2;
}

void ___qsort_big_offset_t_block_invoke(uint64_t a1)
{
  madvise((void *)(**(void **)(a1 + 32) + 8 * *(void *)(*(void *)(a1 + 32) + 8)), 8 * (*(void *)(*(void *)(a1 + 32) + 16) - *(void *)(*(void *)(a1 + 32) + 8)), 4);
  uint64_t v2 = *(void **)(a1 + 32);
  OSAtomicEnqueue(&qsort_cached_allocations, v2, 0);
}

uint64_t parallel_partition_offset_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  int v5 = a5;
  v17[1] = v17;
  context[9] = *MEMORY[0x1E4F143B8];
  context[6] = a1;
  size_t v10 = 8 * a5;
  MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)v17 - v11;
  bzero((char *)v17 - v11, v10);
  uint64_t v13 = (a2 / 0x4000) << 13;
  context[1] = v13;
  context[2] = a2;
  uint64_t v14 = a2 - v13;
  context[4] = 0;
  context[5] = 0;
  context[7] = a3;
  context[8] = v12;
  if (v5 >= 1) {
    memset(v12, 255, v10);
  }
  uint64_t v15 = v13 + 0x2000;
  if (v14 > v13 + 0x2000) {
    uint64_t v15 = a2 - v13;
  }
  context[3] = v14 + ((v15 - v14 + 0x1FFF) & 0xFFFFFFFFFFFFE000);
  context[0] = 0;
  if (8 * a2 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
    madvise(a1, 8 * a2, 3);
  }
  if (a2 / 0x4000 < v5) {
    int v5 = a2 / 0x4000;
  }
  dispatch_apply_f(v5, a4, context, (void (__cdecl *)(void *, size_t))partition_phase_offset_t);
  return sequential_fixup_offset_t((uint64_t)context, a2, v5);
}

uint64_t sequential_fixup_offset_t(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = a3;
  qsort(*(void **)(a1 + 64), a3, 8uLL, (int (__cdecl *)(const void *, const void *))index_comp);
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v8 = a3 - 1;
  uint64_t v9 = 0;
  if (a3 < 1) {
    goto LABEL_107;
  }
  while (*(void *)(v7 + 8 * v9) == -1)
  {
    if (v6 == ++v9)
    {
      uint64_t v9 = v6;
      break;
    }
  }
  if (a3 == 1)
  {
    uint64_t v8 = 0;
    if (v9 < 0)
    {
LABEL_9:
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = *(void *)(a1 + 48);
      while (1)
      {
        uint64_t v13 = *(void *)(v7 + 8 * v9);
        uint64_t v14 = v12 + 8 * v13;
        uint64_t v15 = *(void *)(v7 + 8 * v8);
        uint64_t v16 = v12 + 8 * v15;
        unint64_t v17 = *(void *)(a1 + 56);
        while (1)
        {
          if (v10 < 0x2000)
          {
            while ((*(void *)(v14 + 8 * v10) & 0x3FFFFFFFFFFFFFFFuLL) <= v17)
            {
              if (++v10 == 0x2000)
              {
                uint64_t v18 = 0x2000;
                if (v11 < 0x2000) {
                  goto LABEL_18;
                }
                goto LABEL_21;
              }
            }
          }
          uint64_t v18 = v10;
          if (v11 < 0x2000)
          {
LABEL_18:
            while ((*(void *)(v16 + 8 * v11) & 0x3FFFFFFFFFFFFFFFuLL) >= v17)
            {
              if (++v11 == 0x2000)
              {
                uint64_t v10 = v18;
                goto LABEL_25;
              }
            }
          }
LABEL_21:
          uint64_t v19 = v11;
          if (v18 == 0x2000 || v11 == 0x2000) {
            break;
          }
          uint64_t v20 = *(void *)(v16 + 8 * v11);
          *(void *)(v16 + 8 * v11) = *(void *)(v14 + 8 * v18);
          *(void *)(v14 + 8 * v18) = v20;
          uint64_t v10 = v18 + 1;
          ++v11;
          if (v18 > 8190 || v19 >= 0x1FFF) {
            goto LABEL_25;
          }
        }
        uint64_t v10 = v18;
LABEL_25:
        int v21 = v10 != 0x2000;
        if (v11 == 0x2000 && v10 == 0x2000) {
          int v21 = 2;
        }
        if (v21) {
          goto LABEL_36;
        }
        if ((v13 & 0x8000000000000000) == 0 && v13 < *(void *)(a1 + 32))
        {
          *(void *)(v7 + 8 * v9) = -1;
          *(void *)(a1 + 32) += 0x2000;
        }
        ++v9;
        if ((v21 - 1) > 1)
        {
          uint64_t v10 = 0;
          if (v9 >= v8) {
            break;
          }
        }
        else
        {
          uint64_t v10 = 0;
          uint64_t v15 = *(void *)(v7 + 8 * v8);
LABEL_36:
          if (v15 < a2 && v15 >= a2 - *(void *)(a1 + 40))
          {
            *(void *)(v7 + 8 * v8) = -1;
            *(void *)(a1 + 40) += 0x2000;
          }
          uint64_t v11 = 0;
          if (v9 >= --v8) {
            break;
          }
        }
      }
    }
  }
  else
  {
LABEL_107:
    do
    {
      if (*(void *)(v7 + 8 * v8) != -1) {
        break;
      }
      --v8;
    }
    while (v8);
    if (v9 < v8) {
      goto LABEL_9;
    }
  }
  unint64_t v24 = *(void *)(a1 + 32);
  uint64_t v23 = *(void *)(a1 + 40);
  uint64_t v25 = malloc_type_malloc(0x10000uLL, 0x3D422C00uLL);
  if (a3 < 1)
  {
    uint64_t v41 = *(void *)a1;
    uint64_t v42 = *(void *)(a1 + 16) - 1;
  }
  else
  {
    uint64_t v26 = 0;
    unint64_t v27 = ~v23 + a2;
    uint64_t v28 = a3;
    qos_class_t v29 = *(uint64_t **)(a1 + 64);
    uint64_t v30 = 8 * a3;
    do
    {
      unint64_t v31 = v29[v26];
      BOOL v32 = v31 == -1 || v27 > v31;
      if (!v32) {
        break;
      }
      if (v31 != -1)
      {
        if (v24 <= v31) {
          break;
        }
        unint64_t v33 = *(void *)(a1 + 32);
        if (v33 > v31)
        {
          unint64_t v34 = 0;
          do
          {
            if (v29[v34 / 8] == v33)
            {
              v33 += 0x2000;
              *(void *)(a1 + 32) = v33;
            }
            v34 += 8;
          }
          while (v30 != v34);
          if ((int64_t)v33 >= *(void *)a1) {
            break;
          }
          memcpy(v25, (const void *)(*(void *)(a1 + 48) + 8 * v29[v26]), 0x10000uLL);
          memcpy((void *)(*(void *)(a1 + 48) + 8 * *(void *)(*(void *)(a1 + 64) + 8 * v26)), (const void *)(*(void *)(a1 + 48) + 8 * *(void *)(a1 + 32)), 0x10000uLL);
          memcpy((void *)(*(void *)(a1 + 48) + 8 * *(void *)(a1 + 32)), v25, 0x10000uLL);
          qos_class_t v29 = *(uint64_t **)(a1 + 64);
          v29[v26] = *(void *)(a1 + 32);
          *(void *)(a1 + 32) += 0x2000;
        }
      }
      ++v26;
    }
    while (v26 != v28);
    uint64_t v35 = v28;
    do
    {
      unint64_t v36 = v29[(v35 - 1)];
      if (v24 > v36) {
        break;
      }
      if (v36 != -1)
      {
        if (v27 > v36) {
          break;
        }
        uint64_t v37 = (v35 - 1);
        uint64_t v38 = *(void *)(a1 + 40) + 0x2000;
        *(void *)(a1 + 40) = v38;
        uint64_t v39 = v28 + 1;
        do
        {
          if (v29[(v39 - 2)] == a2 - v38)
          {
            v38 += 0x2000;
            *(void *)(a1 + 40) = v38;
          }
          --v39;
        }
        while (v39 > 1);
        if ((unint64_t)(a2 - v38) < *(void *)(a1 + 16)) {
          break;
        }
        uint64_t v40 = v37;
        memcpy(v25, (const void *)(*(void *)(a1 + 48) + 8 * v29[v37]), 0x10000uLL);
        memcpy((void *)(*(void *)(a1 + 48) + 8 * *(void *)(*(void *)(a1 + 64) + v40 * 8)), (const void *)(*(void *)(a1 + 48) + 8 * (a2 - *(void *)(a1 + 40))), 0x10000uLL);
        memcpy((void *)(*(void *)(a1 + 48) + 8 * (a2 - *(void *)(a1 + 40))), v25, 0x10000uLL);
        qos_class_t v29 = *(uint64_t **)(a1 + 64);
        v29[v40] = a2 - *(void *)(a1 + 40);
      }
      BOOL v32 = v35-- <= 1;
    }
    while (!v32);
    uint64_t v41 = *(void *)a1;
    uint64_t v42 = *(void *)(a1 + 16) - 1;
    do
    {
      uint64_t v44 = *v29++;
      uint64_t v43 = v44;
      if (v44 != -1)
      {
        if (v43 < v41) {
          uint64_t v41 = v43;
        }
        uint64_t v45 = v43 + 0x2000;
        uint64_t v46 = v43 + 0x1FFF;
        if (v45 > v42) {
          uint64_t v42 = v46;
        }
        if (v42 >= a2)
        {
          uint64_t v47 = __si_assert_copy_extra_329();
          uint64_t v48 = v47;
          uint64_t v49 = "";
          if (v47) {
            uint64_t v49 = v47;
          }
          __message_assert(v47, "OQueue.c", 14, "right < count", v49);
          free(v48);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
      }
      --v28;
    }
    while (v28);
  }
  free(v25);
  uint64_t v50 = *(void *)(a1 + 48);
  if (v41 >= v42)
  {
    uint64_t v51 = v41;
  }
  else
  {
    uint64_t v51 = v41;
    do
    {
      unint64_t v52 = *(void *)(a1 + 56);
      while (1)
      {
        uint64_t v53 = *(void *)(v50 + 8 * v51);
        if ((v53 & 0x3FFFFFFFFFFFFFFFuLL) >= v52) {
          break;
        }
        if (++v51 >= v42)
        {
          if (v42 <= v41 + 1) {
            uint64_t v51 = v41 + 1;
          }
          else {
            uint64_t v51 = v42;
          }
          goto LABEL_101;
        }
      }
      if (v51 < v42)
      {
        while (1)
        {
          uint64_t v54 = *(void *)(v50 + 8 * v42);
          if ((v54 & 0x3FFFFFFFFFFFFFFFuLL) <= v52) {
            break;
          }
          if (v51 >= --v42) {
            goto LABEL_101;
          }
        }
        *(void *)(v50 + 8 * v42) = v53;
        *(void *)(v50 + 8 * v51++) = v54;
        --v42;
      }
      uint64_t v41 = v51;
    }
    while (v51 < v42);
  }
LABEL_101:
  if ((*(void *)(v50 + 8 * v51) & 0x3FFFFFFFFFFFFFFFuLL) >= *(void *)(a1 + 56)) {
    return v51;
  }
  else {
    return v51 + 1;
  }
}

atomic_ullong *partition_phase_offset_t(atomic_ullong *result, uint64_t a2)
{
  atomic_ullong v2 = result[6];
  atomic_ullong v3 = result[1];
  if (*result < v3)
  {
    unint64_t add_explicit = atomic_fetch_add_explicit(result, 0x2000uLL, memory_order_relaxed);
    if ((uint64_t)(add_explicit + 0x2000) <= v3) {
      goto LABEL_5;
    }
    atomic_fetch_add_explicit(result, 0xFFFFFFFFFFFFE000, memory_order_relaxed);
  }
  unint64_t add_explicit = -1;
LABEL_5:
  int64_t v5 = result[3];
  if (result[2] <= v5)
  {
LABEL_8:
    uint64_t v8 = 0;
    if (add_explicit != -1)
    {
      uint64_t v9 = 0;
      goto LABEL_19;
    }
    int64_t v7 = -1;
    uint64_t v9 = 0;
LABEL_18:
    unint64_t add_explicit = v7;
    goto LABEL_19;
  }
  unint64_t v6 = atomic_fetch_add_explicit(result + 2, 0xFFFFFFFFFFFFE000, memory_order_relaxed);
  int64_t v7 = v6 - 0x2000;
  if ((uint64_t)(v6 - 0x2000) < v5)
  {
    atomic_fetch_add_explicit(result + 2, 0x2000uLL, memory_order_relaxed);
    goto LABEL_8;
  }
  BOOL v10 = add_explicit != -1;
  if (v6 != 0x1FFF && add_explicit != -1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    while (1)
    {
      unint64_t v14 = v2 + 8 * add_explicit;
      unint64_t v15 = result[7];
      atomic_ullong v16 = v2 + 8 * v7;
      while (1)
      {
        if (v13 < 0x2000)
        {
          while ((*(void *)(v14 + 8 * v13) & 0x3FFFFFFFFFFFFFFFuLL) <= v15)
          {
            if (++v13 == 0x2000)
            {
              uint64_t v17 = 0x2000;
              if (v12 < 0x2000) {
                goto LABEL_27;
              }
              goto LABEL_30;
            }
          }
        }
        uint64_t v17 = v13;
        if (v12 < 0x2000)
        {
LABEL_27:
          while ((*(void *)(v16 + 8 * v12) & 0x3FFFFFFFFFFFFFFFuLL) >= v15)
          {
            if (++v12 == 0x2000)
            {
              uint64_t v13 = v17;
              goto LABEL_34;
            }
          }
        }
LABEL_30:
        uint64_t v18 = v12;
        if (v17 == 0x2000 || v12 == 0x2000) {
          break;
        }
        uint64_t v19 = *(void *)(v16 + 8 * v12);
        *(void *)(v16 + 8 * v12) = *(void *)(v14 + 8 * v17);
        *(void *)(v14 + 8 * v17) = v19;
        uint64_t v13 = v17 + 1;
        ++v12;
        if (v17 > 8190 || v18 >= 0x1FFF) {
          goto LABEL_34;
        }
      }
      uint64_t v13 = v17;
LABEL_34:
      int v20 = v13 != 0x2000;
      if (v12 == 0x2000 && v13 == 0x2000) {
        int v20 = 2;
      }
      if (v20) {
        goto LABEL_45;
      }
      if (*result < v3)
      {
        unint64_t add_explicit = atomic_fetch_add_explicit(result, 0x2000uLL, memory_order_relaxed);
        if ((uint64_t)(add_explicit + 0x2000) <= v3) {
          goto LABEL_44;
        }
        atomic_fetch_add_explicit(result, 0xFFFFFFFFFFFFE000, memory_order_relaxed);
      }
      unint64_t add_explicit = -1;
LABEL_44:
      uint64_t v13 = 0;
      ++v9;
      if ((v20 - 1) > 1) {
        goto LABEL_50;
      }
LABEL_45:
      if (result[2] <= v5) {
        goto LABEL_48;
      }
      int64_t v7 = atomic_fetch_add_explicit(result + 2, 0xFFFFFFFFFFFFE000, memory_order_relaxed) - 0x2000;
      if (v7 < v5)
      {
        atomic_fetch_add_explicit(result + 2, 0x2000uLL, memory_order_relaxed);
LABEL_48:
        int64_t v7 = -1;
      }
      uint64_t v12 = 0;
      ++v8;
LABEL_50:
      BOOL v10 = add_explicit != -1;
      if (v7 == -1 || add_explicit == -1) {
        goto LABEL_17;
      }
    }
  }
  uint64_t v9 = 0;
  uint64_t v8 = 0;
LABEL_17:
  if (!v10) {
    goto LABEL_18;
  }
LABEL_19:
  *(void *)(result[8] + 8 * a2) = add_explicit;
  atomic_fetch_add_explicit(result + 4, v9 << 13, memory_order_relaxed);
  atomic_fetch_add_explicit(result + 5, v8 << 13, memory_order_relaxed);
  return result;
}

uint64_t _big_split_offset_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, signed int a5)
{
  uint64_t v5 = a2 + 1;
  if (a5 >= 3)
  {
    while (v5 < (uint64_t)((unint64_t)a5 << 13))
    {
      if (a5-- <= 3)
      {
        a5 = 2;
        return parallel_partition_offset_t(a1, v5, a3, a4, a5);
      }
    }
  }
  return parallel_partition_offset_t(a1, v5, a3, a4, a5);
}

void oqdispose_JustPositionOffset_t(uint64_t a1)
{
  if (*(uint64_t *)(a1 + 24) >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 8;
    do
    {
      CFRelease(*(CFTypeRef *)(*(void *)(a1 + 8) + v3));
      ++v2;
      v3 += 16;
    }
    while (v2 < *(void *)(a1 + 24));
  }
  if (*(_DWORD *)(a1 + 48))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4 < *(void *)(a1 + 40))
    {
      uint64_t v5 = (16 * v4) | 8;
      do
      {
        CFRelease(*(CFTypeRef *)(*(void *)(a1 + 8) + v5));
        ++v4;
        v5 += 16;
      }
      while (v4 < *(void *)(a1 + 40));
    }
  }
  unint64_t v6 = *(void **)(a1 + 8);
  free(v6);
}

void parallel_qsort_JustPositionOffset_t(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a2 > 2047)
  {
    uint64_t v4 = OSAtomicDequeue(&qsort_cached_allocations, 0);
    if (!v4) {
      uint64_t v4 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
    }
    uint64_t v5 = dispatch_group_create();
    void v4[3] = v5;
    void v4[4] = 0;
    v4[1] = 0;
    v4[2] = a2 - 1;
    *uint64_t v4 = a1;
    int v6 = thread_count;
    if (!thread_count)
    {
      *(void *)uint64_t v9 = 0x1900000006;
      size_t v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      int v6 = thread_count;
    }
    *((_DWORD *)v4 + 14) = v6;
    void v4[5] = (uint64_t)sqrt((double)a2) / 2;
    if (!v6)
    {
      *(void *)uint64_t v9 = 0x1900000006;
      size_t v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      int v6 = thread_count;
    }
    uint64_t v7 = a2 / (2 * v6);
    if (v7 <= 0x8000)
    {
      uint64_t v7 = 0x8000;
    }
    else if (!v6)
    {
      *(void *)uint64_t v9 = 0x1900000006;
      size_t v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      uint64_t v7 = a2 / (2 * thread_count);
    }
    v4[6] = v7;
    if ((uint64_t)v4[5] <= 2047) {
      void v4[5] = 2048;
    }
    _qsort_big_JustPositionOffset_t(v4);
    dispatch_group_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v5);
  }
  else
  {
    _qsort_JustPositionOffset_t(a1, 0, a2 - 1);
  }
}

void _qsort_JustPositionOffset_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = malloc_type_malloc(0x800uLL, 0x1000040451B5BE8uLL);
  *int v6 = 0;
  v6[1] = 0;
  uint64_t v7 = 1;
  while (2)
  {
    if (a3 <= a2) {
      goto LABEL_3;
    }
    if (v7 <= 128) {
      uint64_t v9 = 128;
    }
    else {
      uint64_t v9 = v7;
    }
    while (1)
    {
      unint64_t v10 = a3 - a2;
      if (a3 - a2 <= 16) {
        break;
      }
      size_t v11 = v10 + 1;
      uint64_t v12 = (uint64x2_t *)(a1 + 16 * a2);
      uint64_t v13 = &v12[(v10 + 1) >> 1];
      unint64_t v14 = (unint64_t *)(a1 + 16 * a3);
      if (v10 < 0x400)
      {
        uint64_t v19 = (uint64x2_t *)(a1 + 16 * a2);
        long long v22 = v13;
LABEL_21:
        uint64_t v23 = (uint64x2_t *)(a1 + 16 * a3);
        goto LABEL_22;
      }
      size_t v15 = v11 >> 3;
      atomic_ullong v16 = &v12[v11 >> 3];
      unint64_t v17 = v12->i64[0];
      unint64_t v18 = v16->i64[0];
      uint64_t v19 = (uint64x2_t *)(a1 + 16 * a2);
      if (v12->i64[0] != v16->i64[0])
      {
        unint64_t v20 = v12[2 * v15].u64[0];
        BOOL v21 = v20 == v17 || v20 == v18;
        uint64_t v19 = &v12[2 * v15];
        if (!v21)
        {
          uint64_t v19 = &v12[v11 >> 3];
          if (v17 >= v18)
          {
            if (v18 <= v20)
            {
              if (v17 >= v20) {
                uint64_t v19 = &v12[2 * v15];
              }
              else {
                uint64_t v19 = (uint64x2_t *)(a1 + 16 * a2);
              }
            }
          }
          else if (v18 >= v20)
          {
            if (v17 >= v20) {
              uint64_t v19 = (uint64x2_t *)(a1 + 16 * a2);
            }
            else {
              uint64_t v19 = &v12[2 * v15];
            }
          }
        }
      }
      uint64_t v40 = (unint64_t *)&v13[-v15];
      unint64_t v41 = *v40;
      unint64_t v42 = v13->i64[0];
      if (*v40 == v13->i64[0])
      {
        long long v22 = &v13[-v15];
      }
      else
      {
        long long v22 = &v13[v15];
        unint64_t v43 = v22->i64[0];
        if (v22->i64[0] != v41 && v43 != v42)
        {
          if (v41 >= v43) {
            uint64_t v45 = &v13[v15];
          }
          else {
            uint64_t v45 = &v13[-v15];
          }
          if (v42 > v43) {
            uint64_t v45 = v13;
          }
          if (v41 >= v43) {
            long long v22 = &v13[-v15];
          }
          if (v42 < v43) {
            long long v22 = v13;
          }
          if (v41 >= v42) {
            long long v22 = v45;
          }
        }
      }
      uint64_t v46 = &v14[-4 * v15];
      uint64_t v23 = (uint64x2_t *)&v14[-2 * v15];
      unint64_t v47 = *v46;
      unint64_t v48 = v23->i64[0];
      if (*v46 == v23->i64[0])
      {
        uint64_t v23 = (uint64x2_t *)v46;
      }
      else
      {
        unint64_t v49 = *v14;
        if (*v14 == v47 || v49 == v48) {
          goto LABEL_21;
        }
        if (v47 >= v48)
        {
          if (v48 <= v49)
          {
            if (v47 >= v49) {
              uint64_t v23 = (uint64x2_t *)(a1 + 16 * a3);
            }
            else {
              uint64_t v23 = (uint64x2_t *)v46;
            }
          }
        }
        else if (v48 >= v49)
        {
          if (v47 >= v49) {
            uint64_t v23 = (uint64x2_t *)v46;
          }
          else {
            uint64_t v23 = (uint64x2_t *)(a1 + 16 * a3);
          }
        }
      }
LABEL_22:
      unint64_t v24 = v19->i64[0];
      unint64_t v25 = v22->i64[0];
      if (v19->i64[0] == v22->i64[0])
      {
        long long v22 = v19;
      }
      else
      {
        unint64_t v26 = v23->i64[0];
        if (v23->i64[0] == v24 || v26 == v25)
        {
          long long v22 = v23;
        }
        else if (v24 >= v25)
        {
          if (v25 <= v26)
          {
            if (v24 >= v26) {
              long long v22 = v23;
            }
            else {
              long long v22 = v19;
            }
          }
        }
        else if (v25 >= v26)
        {
          if (v24 >= v26) {
            long long v22 = v19;
          }
          else {
            long long v22 = v23;
          }
        }
      }
      uint64x2_t v28 = *v22;
      *long long v22 = *(uint64x2_t *)v14;
      *(uint64x2_t *)unint64_t v14 = v28;
      uint64x2_t v29 = *v12;
      uint64_t v30 = (uint64x2_t *)(a1 + 16 + 16 * a2);
      uint64_t v31 = a3;
      uint64_t v32 = a2;
      do
      {
        uint64x2_t v33 = *v30;
        if ((vmovn_s64((int64x2_t)vcgtq_u64(v29, v28)).u8[0] & 1) == 0)
        {
          v30[-1] = *(uint64x2_t *)(a1 + 16 * v32);
          *(uint64x2_t *)(a1 + 16 * v32++) = v29;
        }
        ++v30;
        --v31;
        uint64x2_t v29 = v33;
      }
      while (a2 != v31);
      long long v34 = *(_OWORD *)(a1 + 16 * v32);
      *(_OWORD *)(a1 + 16 * v32) = *(_OWORD *)v14;
      *(_OWORD *)unint64_t v14 = v34;
      uint64_t v35 = v32 - a2;
      if (v32 < a2)
      {
        long long v60 = __si_assert_copy_extra_329();
        uint64_t v61 = v60;
        long long v62 = "";
        if (v60) {
          long long v62 = v60;
        }
        __message_assert(v60, "OQueue.c", 16, "q>=left", v62);
        free(v61);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      if (v7 == v9)
      {
        heapsort_b(v12, v11, 0x10uLL, &__block_literal_global_31);
        uint64_t v7 = v9;
        goto LABEL_3;
      }
      BOOL v36 = v35 <= a3 - v32;
      if (v35 <= a3 - v32) {
        uint64_t v37 = v32 - 1;
      }
      else {
        uint64_t v37 = a3;
      }
      if (v36) {
        uint64_t v38 = a2;
      }
      else {
        uint64_t v38 = v32;
      }
      if (v36) {
        a2 = v32;
      }
      else {
        a3 = v32 - 1;
      }
      uint64_t v39 = &v6[2 * v7];
      void *v39 = v38;
      v39[1] = v37;
      ++v7;
      if (a3 <= a2) {
        goto LABEL_3;
      }
    }
    uint64_t v51 = a1 + 24 + 16 * a2;
    uint64_t v52 = a2;
    do
    {
      uint64_t v53 = v52++;
      long long v54 = *(_OWORD *)(a1 + 16 * v52);
      unint64_t v55 = *(void *)(a1 + 16 * v53);
      unint64_t v56 = *(void *)(a1 + 16 * v52);
      uint64_t v57 = v52;
      if (v55 > v56)
      {
        NSUInteger v58 = (void *)v51;
        do
        {
          uint64_t v57 = v53;
          uint64_t v59 = *(v58 - 2);
          *(v58 - 1) = v55;
          void *v58 = v59;
          if (v57 <= a2) {
            break;
          }
          unint64_t v55 = *(v58 - 5);
          uint64_t v53 = v57 - 1;
          v58 -= 2;
        }
        while (v55 > v56);
      }
      *(_OWORD *)(a1 + 16 * v57) = v54;
      v51 += 16;
    }
    while (v52 != a3);
LABEL_3:
    --v7;
    size_t v8 = &v6[2 * v7];
    a2 = *v8;
    a3 = v8[1];
    if (v7) {
      continue;
    }
    break;
  }
  free(v6);
}

void _qsort_big_JustPositionOffset_t(void *a1)
{
  uint64_t v1 = *(void *)a1;
  uint64_t v2 = *((void *)a1 + 1);
  uint64_t v3 = *((void *)a1 + 2);
  uint64_t v4 = *((void *)a1 + 3);
  unint64_t v5 = *((void *)a1 + 4);
  uint64_t v65 = *((void *)a1 + 6);
  uint64_t v66 = *((void *)a1 + 5);
  signed int v6 = *((_DWORD *)a1 + 14);
  int v64 = *((_DWORD *)a1 + 15);
  OSAtomicEnqueue(&qsort_cached_allocations, a1, 0);
  if (v3 > v2)
  {
    while (1)
    {
      ++v5;
      uint64_t v9 = v3 - v2;
      if (v3 - v2 <= v66 || v5 > 9)
      {
        _qsort_JustPositionOffset_t(v1, v2, v3);
        return;
      }
      if (v6 <= 1) {
        signed int v6 = 1;
      }
      uint64_t v11 = getSize_memSize;
      if (!getSize_memSize)
      {
        long long v70 = 0u;
        long long v71 = 0u;
        *(_OWORD *)host_info_out = 0u;
        host_t v12 = MEMORY[0x1C1881C90]();
        mach_msg_type_number_t host_info_outCnt = 12;
        mach_error_t v13 = host_info(v12, 1, host_info_out, &host_info_outCnt);
        if (v13)
        {
          mach_error("flushsize", v13);
          exit(1);
        }
        uint64_t v11 = *((void *)&v71 + 1);
        getSize_memSize = *((void *)&v71 + 1);
      }
      unint64_t v14 = 3 * v11 / 5uLL;
      size_t v15 = v4;
      if (16 * v9 > v14) {
        size_t v15 = dispatch_group_create();
      }
      if (v9 <= v65 || 16 * v9 >= v14) {
        break;
      }
      qos_class_t v16 = qos_class_self();
      global_queue = dispatch_get_global_queue(v16, 2uLL);
      uint64_t v18 = _big_partition_JustPositionOffset_t(v1, v2, v3, global_queue, v6);
LABEL_51:
      uint64_t v40 = v18 - v2;
      if (v18 < v2)
      {
        long long v60 = __si_assert_copy_extra_329();
        uint64_t v61 = v60;
        long long v62 = "";
        if (v60) {
          long long v62 = v60;
        }
        __message_assert(v60, "OQueue.c", 16, "q>=left", v62);
        free(v61);
        if (__valid_fs(-1)) {
          uint64_t v63 = 2989;
        }
        else {
          uint64_t v63 = 3072;
        }
        *(_DWORD *)uint64_t v63 = -559038737;
        abort();
      }
      unint64_t v41 = OSAtomicDequeue(&qsort_cached_allocations, 0);
      if (!v41) {
        unint64_t v41 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
      }
      *((void *)v41 + 4) = v5;
      *((void *)v41 + 5) = v66;
      *((void *)v41 + 6) = v65;
      uint64_t v42 = v3 - v18;
      if (v40 <= v3 - v18)
      {
        uint64_t v43 = v18 - 1;
      }
      else
      {
        uint64_t v42 = v18 - 1 - v2;
        uint64_t v43 = v3;
      }
      if (v40 > v3 - v18) {
        uint64_t v44 = v18;
      }
      else {
        uint64_t v44 = v2;
      }
      if (v40 > v3 - v18) {
        uint64_t v3 = v18 - 1;
      }
      else {
        uint64_t v2 = v18;
      }
      *(void *)unint64_t v41 = v1;
      *((void *)v41 + 1) = v44;
      int v45 = (int)(float)((float)((float)(v42 + 1) * (float)v6) / (float)(v43 - v44 + 1));
      if (v45 <= 1) {
        int v46 = 1;
      }
      else {
        int v46 = v45;
      }
      if (v6 >= v45) {
        int v47 = v46;
      }
      else {
        int v47 = 0;
      }
      v41[14] = v6 - v47;
      v41[15] = v64;
      *((void *)v41 + 2) = v43;
      *((void *)v41 + 3) = v15;
      if (v15 == v4)
      {
        if (v6 >= v45) {
          signed int v6 = v46;
        }
        qos_class_t v7 = qos_class_self();
        size_t v8 = dispatch_get_global_queue(v7, 2uLL);
        dispatch_group_async_f(v4, v8, v41, (dispatch_function_t)_qsort_big_JustPositionOffset_t);
        if (v3 <= v2) {
          return;
        }
      }
      else
      {
        v41[14] = v6;
        _qsort_big_JustPositionOffset_t(v41);
        dispatch_group_wait(v15, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(v15);
        qos_class_t v48 = qos_class_self();
        unint64_t v49 = dispatch_get_global_queue(v48, 2uLL);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        void block[2] = ___qsort_big_JustPositionOffset_t_block_invoke;
        block[3] = &__block_descriptor_tmp_28_3291;
        block[4] = v41;
        dispatch_async(v49, block);
        if (v3 <= v2) {
          return;
        }
      }
    }
    unint64_t v19 = v9 + 1;
    unint64_t v20 = (uint64x2_t *)(v1 + 16 * v2);
    unint64_t v21 = v9 + 2;
    if (v9 >= -1) {
      unint64_t v21 = v9 + 1;
    }
    long long v22 = &v20[v21 >> 1];
    uint64_t v23 = (unint64_t *)(v1 + 16 * v3);
    if (v9 < 1024)
    {
      uint64x2_t v28 = (uint64x2_t *)(v1 + 16 * v2);
      uint64_t v30 = v22;
    }
    else
    {
      unint64_t v24 = v19 >> 3;
      unint64_t v25 = &v20[v19 >> 3];
      unint64_t v26 = v20->i64[0];
      unint64_t v27 = v25->i64[0];
      uint64x2_t v28 = (uint64x2_t *)(v1 + 16 * v2);
      if (v20->i64[0] != v25->i64[0])
      {
        uint64x2_t v28 = &v20[2 * v24];
        unint64_t v29 = v28->i64[0];
        if (v28->i64[0] != v26 && v29 != v27)
        {
          if (v26 >= v27)
          {
            if (v26 < v29) {
              uint64x2_t v28 = (uint64x2_t *)(v1 + 16 * v2);
            }
            if (v27 > v29) {
              uint64x2_t v28 = v25;
            }
          }
          else
          {
            if (v26 >= v29) {
              uint64x2_t v28 = (uint64x2_t *)(v1 + 16 * v2);
            }
            if (v27 < v29) {
              uint64x2_t v28 = v25;
            }
          }
        }
      }
      uint64_t v50 = v24;
      uint64_t v51 = (unint64_t *)&v22[-v24];
      unint64_t v52 = *v51;
      unint64_t v53 = v22->i64[0];
      if (*v51 == v22->i64[0])
      {
        uint64_t v30 = &v22[-v24];
      }
      else
      {
        long long v54 = &v22[v50];
        unint64_t v55 = v22[v24].u64[0];
        if (v55 == v52)
        {
          uint64_t v30 = &v22[v50];
        }
        else
        {
          uint64_t v30 = &v22[v50];
          if (v55 != v53)
          {
            uint64_t v30 = v22;
            if (v52 >= v53)
            {
              if (v53 <= v55)
              {
                if (v52 >= v55) {
                  uint64_t v30 = v54;
                }
                else {
                  uint64_t v30 = &v22[-v24];
                }
              }
            }
            else if (v53 >= v55)
            {
              if (v52 >= v55) {
                uint64_t v30 = &v22[-v24];
              }
              else {
                uint64_t v30 = v54;
              }
            }
          }
        }
      }
      unint64_t v56 = &v23[-4 * v24];
      uint64_t v31 = (uint64x2_t *)&v23[-2 * v24];
      unint64_t v57 = *v56;
      unint64_t v58 = v31->i64[0];
      if (*v56 == v31->i64[0])
      {
        uint64_t v31 = (uint64x2_t *)v56;
        goto LABEL_34;
      }
      unint64_t v59 = *v23;
      if (*v23 != v57 && v59 != v58)
      {
        if (v57 >= v58)
        {
          if (v58 <= v59)
          {
            if (v57 >= v59) {
              uint64_t v31 = (uint64x2_t *)(v1 + 16 * v3);
            }
            else {
              uint64_t v31 = (uint64x2_t *)v56;
            }
          }
        }
        else if (v58 >= v59)
        {
          if (v57 >= v59) {
            uint64_t v31 = (uint64x2_t *)v56;
          }
          else {
            uint64_t v31 = (uint64x2_t *)(v1 + 16 * v3);
          }
        }
        goto LABEL_34;
      }
    }
    uint64_t v31 = (uint64x2_t *)(v1 + 16 * v3);
LABEL_34:
    unint64_t v32 = v28->i64[0];
    unint64_t v33 = v30->i64[0];
    if (v28->i64[0] == v30->i64[0])
    {
      uint64_t v30 = v28;
    }
    else
    {
      unint64_t v34 = v31->i64[0];
      if (v31->i64[0] == v32 || v34 == v33)
      {
        uint64_t v30 = v31;
      }
      else if (v32 >= v33)
      {
        if (v33 <= v34)
        {
          if (v32 >= v34) {
            uint64_t v30 = v31;
          }
          else {
            uint64_t v30 = v28;
          }
        }
      }
      else if (v33 >= v34)
      {
        if (v32 >= v34) {
          uint64_t v30 = v28;
        }
        else {
          uint64_t v30 = v31;
        }
      }
    }
    uint64x2_t v35 = *v30;
    *uint64_t v30 = *(uint64x2_t *)v23;
    *(uint64x2_t *)uint64_t v23 = v35;
    uint64x2_t v36 = *v20;
    uint64_t v37 = (uint64x2_t *)(v1 + 16 + 16 * v2);
    uint64_t v18 = v2;
    do
    {
      uint64x2_t v38 = *v37;
      if ((vmovn_s64((int64x2_t)vcgtq_u64(v36, v35)).u8[0] & 1) == 0)
      {
        v37[-1] = *(uint64x2_t *)(v1 + 16 * v18);
        *(uint64x2_t *)(v1 + 16 * v18++) = v36;
      }
      ++v37;
      uint64x2_t v36 = v38;
      --v9;
    }
    while (v9);
    long long v39 = *(_OWORD *)(v1 + 16 * v18);
    *(_OWORD *)(v1 + 16 * v18) = *(_OWORD *)v23;
    *(_OWORD *)uint64_t v23 = v39;
    goto LABEL_51;
  }
}

uint64_t _big_partition_JustPositionOffset_t(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  uint64_t v7 = a3 - a2;
  BOOL v8 = __OFADD__(a3 - a2, 1);
  unint64_t v9 = a3 - a2 + 1;
  unint64_t v10 = (uint64_t *)(a1 + 16 * a2);
  unint64_t v11 = v7 + 2;
  if (((v9 & 0x8000000000000000) != 0) == v8) {
    unint64_t v11 = v7 + 1;
  }
  host_t v12 = &v10[2 * (v11 >> 1)];
  mach_error_t v13 = (unint64_t *)(a1 + 16 * a3);
  if (v7 < 64)
  {
    unint64_t v29 = &v10[2 * (v11 >> 1)];
    uint64_t v18 = v10;
  }
  else
  {
    unint64_t v14 = v9 >> 3;
    size_t v15 = &v10[2 * (v9 >> 3)];
    unint64_t v16 = *v10;
    unint64_t v17 = *v15;
    uint64_t v18 = v10;
    if (*v10 != *v15)
    {
      uint64_t v18 = &v10[4 * v14];
      unint64_t v19 = *v18;
      if (v16 >= *v18) {
        unint64_t v20 = &v10[4 * v14];
      }
      else {
        unint64_t v20 = v10;
      }
      if (v17 > v19) {
        unint64_t v20 = &v10[2 * (v9 >> 3)];
      }
      if (v16 >= v19) {
        unint64_t v21 = v10;
      }
      else {
        unint64_t v21 = &v10[4 * v14];
      }
      if (v17 >= v19) {
        size_t v15 = v21;
      }
      if (v16 >= v17) {
        size_t v15 = v20;
      }
      if (v19 != v16 && v19 != v17) {
        uint64_t v18 = v15;
      }
    }
    uint64_t v23 = 2 * v14;
    uint64_t v24 = -(uint64_t)v14;
    uint64_t v25 = 16 * v14;
    unint64_t v26 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
    unint64_t v27 = v12[v25 / 0xFFFFFFFFFFFFFFF8];
    unint64_t v28 = *v12;
    if (v27 == *v12)
    {
      unint64_t v29 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      unint64_t v29 = &v12[(unint64_t)v25 / 8];
      unint64_t v30 = *v29;
      if (*v29 != v27 && v30 != v28)
      {
        if (v27 >= v30) {
          unint64_t v32 = v29;
        }
        else {
          unint64_t v32 = v26;
        }
        if (v28 > v30) {
          unint64_t v32 = v12;
        }
        if (v27 >= v30) {
          unint64_t v29 = v26;
        }
        if (v28 < v30) {
          unint64_t v29 = v12;
        }
        if (v27 >= v28) {
          unint64_t v29 = v32;
        }
      }
    }
    unint64_t v33 = &v13[-2 * v23];
    unint64_t v34 = &v13[2 * v24];
    unint64_t v35 = *v33;
    unint64_t v36 = *v34;
    if (*v33 == *v34)
    {
      mach_error_t v13 = v33;
    }
    else
    {
      unint64_t v37 = *v13;
      if (v35 >= *v13) {
        uint64x2_t v38 = v13;
      }
      else {
        uint64x2_t v38 = v33;
      }
      if (v36 > v37) {
        uint64x2_t v38 = v34;
      }
      if (v35 < v37) {
        unint64_t v33 = v13;
      }
      if (v36 < v37) {
        unint64_t v33 = v34;
      }
      if (v35 >= v36) {
        unint64_t v33 = v38;
      }
      if (v37 != v35 && v37 != v36) {
        mach_error_t v13 = v33;
      }
    }
  }
  unint64_t v40 = *v18;
  unint64_t v41 = *v29;
  if (*v18 == *v29)
  {
    unint64_t v29 = v18;
  }
  else
  {
    unint64_t v42 = *v13;
    if (*v13 == v40 || v42 == v41)
    {
      unint64_t v29 = (uint64_t *)v13;
    }
    else if (v40 >= v41)
    {
      if (v41 <= v42)
      {
        if (v40 >= v42) {
          unint64_t v29 = (uint64_t *)v13;
        }
        else {
          unint64_t v29 = v18;
        }
      }
    }
    else if (v41 >= v42)
    {
      if (v40 >= v42) {
        unint64_t v29 = v18;
      }
      else {
        unint64_t v29 = (uint64_t *)v13;
      }
    }
  }
  return parallel_partition_JustPositionOffset_t(v10, v9, *v29, a4, a5) + a2;
}

uint64_t parallel_partition_JustPositionOffset_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  int v5 = a5;
  v17[1] = v17;
  context[9] = *MEMORY[0x1E4F143B8];
  context[6] = a1;
  size_t v10 = 8 * a5;
  MEMORY[0x1F4188790](a1);
  host_t v12 = (char *)v17 - v11;
  bzero((char *)v17 - v11, v10);
  uint64_t v13 = (a2 / 0x4000) << 13;
  context[1] = v13;
  context[2] = a2;
  uint64_t v14 = a2 - v13;
  context[4] = 0;
  context[5] = 0;
  context[7] = a3;
  context[8] = v12;
  if (v5 >= 1) {
    memset(v12, 255, v10);
  }
  uint64_t v15 = v13 + 0x2000;
  if (v14 > v13 + 0x2000) {
    uint64_t v15 = a2 - v13;
  }
  context[3] = v14 + ((v15 - v14 + 0x1FFF) & 0xFFFFFFFFFFFFE000);
  context[0] = 0;
  if (16 * a2 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
    madvise(a1, 16 * a2, 3);
  }
  if (a2 / 0x4000 < v5) {
    int v5 = a2 / 0x4000;
  }
  dispatch_apply_f(v5, a4, context, (void (__cdecl *)(void *, size_t))partition_phase_JustPositionOffset_t);
  return sequential_fixup_JustPositionOffset_t((uint64_t)context, a2, v5);
}

uint64_t sequential_fixup_JustPositionOffset_t(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = a3;
  qsort(*(void **)(a1 + 64), a3, 8uLL, (int (__cdecl *)(const void *, const void *))index_comp);
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v8 = a3 - 1;
  uint64_t v9 = 0;
  if (a3 < 1) {
    goto LABEL_111;
  }
  while (*(void *)(v7 + 8 * v9) == -1)
  {
    if (v6 == ++v9)
    {
      uint64_t v9 = v6;
      break;
    }
  }
  if (a3 == 1)
  {
    uint64_t v8 = 0;
    if (v9 >= 0) {
      goto LABEL_46;
    }
  }
  else
  {
LABEL_111:
    do
    {
      if (*(void *)(v7 + 8 * v8) != -1) {
        break;
      }
      --v8;
    }
    while (v8);
    if (v9 >= v8) {
      goto LABEL_46;
    }
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  do
  {
    uint64_t v13 = *(void *)(a1 + 48);
    unint64_t v12 = *(void *)(a1 + 56);
    uint64_t v14 = v13 + 16 * *(void *)(v7 + 8 * v9);
    uint64_t v15 = v13 + 16 * *(void *)(v7 + 8 * v8);
    while (1)
    {
      if (v10 < 0x2000)
      {
        unint64_t v16 = (unint64_t *)(v14 + 16 * v10);
        while (1)
        {
          unint64_t v17 = *v16;
          v16 += 2;
          if (v17 > v12) {
            break;
          }
          if (++v10 == 0x2000)
          {
            uint64_t v18 = 0x2000;
            if (v11 < 0x2000) {
              goto LABEL_20;
            }
            goto LABEL_24;
          }
        }
      }
      uint64_t v18 = v10;
      if (v11 < 0x2000)
      {
LABEL_20:
        unint64_t v19 = (unint64_t *)(v15 + 16 * v11);
        while (1)
        {
          unint64_t v20 = *v19;
          v19 += 2;
          if (v20 < v12) {
            break;
          }
          if (++v11 == 0x2000)
          {
            uint64_t v10 = v18;
            goto LABEL_28;
          }
        }
      }
LABEL_24:
      uint64_t v21 = v11;
      if (v18 == 0x2000 || v11 == 0x2000) {
        break;
      }
      long long v22 = *(_OWORD *)(v15 + 16 * v11);
      *(_OWORD *)(v15 + 16 * v11) = *(_OWORD *)(v14 + 16 * v18);
      *(_OWORD *)(v14 + 16 * v18) = v22;
      uint64_t v10 = v18 + 1;
      ++v11;
      if (v18 > 8190 || v21 >= 0x1FFF) {
        goto LABEL_28;
      }
    }
    uint64_t v10 = v18;
LABEL_28:
    if (v11 == 0x2000 && v10 == 0x2000) {
      int v24 = 2;
    }
    else {
      int v24 = v10 != 0x2000;
    }
    uint64_t v7 = *(void *)(a1 + 64);
    if ((v24 & 1) == 0)
    {
      uint64_t v25 = *(void *)(v7 + 8 * v9);
      if ((v25 & 0x8000000000000000) == 0 && v25 < *(void *)(a1 + 32))
      {
        *(void *)(v7 + 8 * v9) = -1;
        *(void *)(a1 + 32) += 0x2000;
      }
      uint64_t v10 = 0;
      ++v9;
      if ((v24 - 1) > 1) {
        continue;
      }
    }
    uint64_t v26 = *(void *)(v7 + 8 * v8);
    BOOL v27 = v26 >= a2 || v26 < a2 - *(void *)(a1 + 40);
    if (!v27)
    {
      *(void *)(v7 + 8 * v8) = -1;
      *(void *)(a1 + 40) += 0x2000;
    }
    uint64_t v11 = 0;
    --v8;
  }
  while (v9 < v8);
LABEL_46:
  unint64_t v29 = *(void *)(a1 + 32);
  uint64_t v28 = *(void *)(a1 + 40);
  unint64_t v30 = malloc_type_malloc(0x20000uLL, 0xEF539176uLL);
  if (a3 < 1)
  {
    uint64_t v46 = *(void *)a1;
    uint64_t v47 = *(void *)(a1 + 16) - 1;
  }
  else
  {
    uint64_t v31 = 0;
    unint64_t v32 = ~v28 + a2;
    uint64_t v33 = a3;
    unint64_t v34 = *(uint64_t **)(a1 + 64);
    uint64_t v35 = 8 * a3;
    do
    {
      unint64_t v36 = v34[v31];
      if (v36 != -1 && v32 <= v36) {
        break;
      }
      if (v36 != -1)
      {
        if (v29 <= v36) {
          break;
        }
        unint64_t v38 = *(void *)(a1 + 32);
        if (v38 > v36)
        {
          unint64_t v39 = 0;
          do
          {
            if (v34[v39 / 8] == v38)
            {
              v38 += 0x2000;
              *(void *)(a1 + 32) = v38;
            }
            v39 += 8;
          }
          while (v35 != v39);
          if ((int64_t)v38 >= *(void *)a1) {
            break;
          }
          memcpy(v30, (const void *)(*(void *)(a1 + 48) + 16 * v34[v31]), 0x20000uLL);
          memcpy((void *)(*(void *)(a1 + 48) + 16 * *(void *)(*(void *)(a1 + 64) + 8 * v31)), (const void *)(*(void *)(a1 + 48) + 16 * *(void *)(a1 + 32)), 0x20000uLL);
          memcpy((void *)(*(void *)(a1 + 48) + 16 * *(void *)(a1 + 32)), v30, 0x20000uLL);
          unint64_t v34 = *(uint64_t **)(a1 + 64);
          v34[v31] = *(void *)(a1 + 32);
          *(void *)(a1 + 32) += 0x2000;
        }
      }
      ++v31;
    }
    while (v31 != v33);
    uint64_t v40 = v33;
    do
    {
      unint64_t v41 = v34[(v40 - 1)];
      if (v29 > v41) {
        break;
      }
      if (v41 != -1)
      {
        if (v32 > v41) {
          break;
        }
        uint64_t v42 = (v40 - 1);
        uint64_t v43 = *(void *)(a1 + 40) + 0x2000;
        *(void *)(a1 + 40) = v43;
        uint64_t v44 = v33 + 1;
        do
        {
          if (v34[(v44 - 2)] == a2 - v43)
          {
            v43 += 0x2000;
            *(void *)(a1 + 40) = v43;
          }
          --v44;
        }
        while (v44 > 1);
        if ((unint64_t)(a2 - v43) < *(void *)(a1 + 16)) {
          break;
        }
        uint64_t v45 = v42;
        memcpy(v30, (const void *)(*(void *)(a1 + 48) + 16 * v34[v42]), 0x20000uLL);
        memcpy((void *)(*(void *)(a1 + 48) + 16 * *(void *)(*(void *)(a1 + 64) + v45 * 8)), (const void *)(*(void *)(a1 + 48) + 16 * (a2 - *(void *)(a1 + 40))), 0x20000uLL);
        memcpy((void *)(*(void *)(a1 + 48) + 16 * (a2 - *(void *)(a1 + 40))), v30, 0x20000uLL);
        unint64_t v34 = *(uint64_t **)(a1 + 64);
        v34[v45] = a2 - *(void *)(a1 + 40);
      }
      BOOL v27 = v40-- <= 1;
    }
    while (!v27);
    uint64_t v46 = *(void *)a1;
    uint64_t v47 = *(void *)(a1 + 16) - 1;
    do
    {
      uint64_t v49 = *v34++;
      uint64_t v48 = v49;
      if (v49 != -1)
      {
        if (v48 < v46) {
          uint64_t v46 = v48;
        }
        uint64_t v50 = v48 + 0x2000;
        uint64_t v51 = v48 + 0x1FFF;
        if (v50 > v47) {
          uint64_t v47 = v51;
        }
        if (v47 >= a2)
        {
          unint64_t v52 = __si_assert_copy_extra_329();
          unint64_t v53 = v52;
          long long v54 = "";
          if (v52) {
            long long v54 = v52;
          }
          __message_assert(v52, "OQueue.c", 16, "right < count", v54);
          free(v53);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
      }
      --v33;
    }
    while (v33);
  }
  free(v30);
  if (v46 >= v47)
  {
    uint64_t v55 = v46;
  }
  else
  {
    uint64_t v55 = v46;
    do
    {
      uint64_t v56 = *(void *)(a1 + 48);
      unint64_t v57 = *(void *)(a1 + 56);
      unint64_t v58 = (unint64_t *)(v56 + 16 * v46);
      while (1)
      {
        unint64_t v59 = *v58;
        v58 += 2;
        if (v59 >= v57) {
          break;
        }
        if (++v55 >= v47)
        {
          if (v47 <= v46 + 1) {
            uint64_t v55 = v46 + 1;
          }
          else {
            uint64_t v55 = v47;
          }
          goto LABEL_105;
        }
      }
      if (v55 < v47)
      {
        long long v60 = (unint64_t *)(v56 + 16 * v47);
        while (1)
        {
          unint64_t v61 = *v60;
          v60 -= 2;
          if (v61 <= v57) {
            break;
          }
          if (v55 >= --v47) {
            goto LABEL_105;
          }
        }
        long long v62 = *(_OWORD *)(v56 + 16 * v47);
        *(_OWORD *)(v56 + 16 * v47) = *(_OWORD *)(v56 + 16 * v55);
        *(_OWORD *)(*(void *)(a1 + 48) + 16 * v55++) = v62;
        --v47;
      }
      uint64_t v46 = v55;
    }
    while (v55 < v47);
  }
LABEL_105:
  if (*(void *)(*(void *)(a1 + 48) + 16 * v55) >= *(void *)(a1 + 56)) {
    return v55;
  }
  else {
    return v55 + 1;
  }
}

atomic_ullong *partition_phase_JustPositionOffset_t(atomic_ullong *result, uint64_t a2)
{
  atomic_ullong v2 = result[6];
  atomic_ullong v3 = result[1];
  if (*result < v3)
  {
    unint64_t add_explicit = atomic_fetch_add_explicit(result, 0x2000uLL, memory_order_relaxed);
    if ((uint64_t)(add_explicit + 0x2000) <= v3) {
      goto LABEL_5;
    }
    atomic_fetch_add_explicit(result, 0xFFFFFFFFFFFFE000, memory_order_relaxed);
  }
  unint64_t add_explicit = -1;
LABEL_5:
  int64_t v5 = result[3];
  if (result[2] <= v5)
  {
LABEL_8:
    uint64_t v7 = 0;
    if (add_explicit != -1)
    {
      uint64_t v8 = 0;
      goto LABEL_19;
    }
    int64_t v6 = -1;
    uint64_t v8 = 0;
LABEL_18:
    unint64_t add_explicit = v6;
    goto LABEL_19;
  }
  int64_t v6 = atomic_fetch_add_explicit(result + 2, 0xFFFFFFFFFFFFE000, memory_order_relaxed) - 0x2000;
  if (v6 < v5)
  {
    atomic_fetch_add_explicit(result + 2, 0x2000uLL, memory_order_relaxed);
    goto LABEL_8;
  }
  BOOL v9 = add_explicit != -1;
  if (v6 != -1 && add_explicit != -1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    while (1)
    {
      unint64_t v13 = v2 + 16 * add_explicit;
      unint64_t v14 = result[7];
      atomic_ullong v15 = v2 + 16 * v6;
      while (1)
      {
        if (v12 < 0x2000)
        {
          unint64_t v16 = (unint64_t *)(v13 + 16 * v12);
          while (1)
          {
            unint64_t v17 = *v16;
            v16 += 2;
            if (v17 > v14) {
              break;
            }
            if (++v12 == 0x2000)
            {
              uint64_t v18 = 0x2000;
              if (v11 < 0x2000) {
                goto LABEL_28;
              }
              goto LABEL_32;
            }
          }
        }
        uint64_t v18 = v12;
        if (v11 < 0x2000)
        {
LABEL_28:
          unint64_t v19 = (unint64_t *)(v15 + 16 * v11);
          while (1)
          {
            unint64_t v20 = *v19;
            v19 += 2;
            if (v20 < v14) {
              break;
            }
            if (++v11 == 0x2000)
            {
              uint64_t v12 = v18;
              goto LABEL_36;
            }
          }
        }
LABEL_32:
        uint64_t v21 = v11;
        if (v18 == 0x2000 || v11 == 0x2000) {
          break;
        }
        long long v22 = *(_OWORD *)(v15 + 16 * v11);
        *(_OWORD *)(v15 + 16 * v11) = *(_OWORD *)(v13 + 16 * v18);
        *(_OWORD *)(v13 + 16 * v18) = v22;
        uint64_t v12 = v18 + 1;
        ++v11;
        if (v18 > 8190 || v21 >= 0x1FFF) {
          goto LABEL_36;
        }
      }
      uint64_t v12 = v18;
LABEL_36:
      int v23 = v12 != 0x2000;
      if (v11 == 0x2000 && v12 == 0x2000) {
        int v23 = 2;
      }
      if (v23) {
        goto LABEL_47;
      }
      atomic_ullong v25 = result[1];
      if (*result < v25)
      {
        unint64_t add_explicit = atomic_fetch_add_explicit(result, 0x2000uLL, memory_order_relaxed);
        if ((uint64_t)(add_explicit + 0x2000) <= v25) {
          goto LABEL_46;
        }
        atomic_fetch_add_explicit(result, 0xFFFFFFFFFFFFE000, memory_order_relaxed);
      }
      unint64_t add_explicit = -1;
LABEL_46:
      uint64_t v12 = 0;
      ++v8;
      if ((v23 - 1) > 1) {
        goto LABEL_52;
      }
LABEL_47:
      int64_t v26 = result[3];
      if (result[2] <= v26) {
        goto LABEL_50;
      }
      int64_t v6 = atomic_fetch_add_explicit(result + 2, 0xFFFFFFFFFFFFE000, memory_order_relaxed) - 0x2000;
      if (v6 < v26)
      {
        atomic_fetch_add_explicit(result + 2, 0x2000uLL, memory_order_relaxed);
LABEL_50:
        int64_t v6 = -1;
      }
      uint64_t v11 = 0;
      ++v7;
LABEL_52:
      BOOL v9 = add_explicit != -1;
      if (v6 == -1 || add_explicit == -1) {
        goto LABEL_17;
      }
    }
  }
  uint64_t v8 = 0;
  uint64_t v7 = 0;
LABEL_17:
  if (!v9) {
    goto LABEL_18;
  }
LABEL_19:
  *(void *)(result[8] + 8 * a2) = add_explicit;
  atomic_fetch_add_explicit(result + 4, v8 << 13, memory_order_relaxed);
  atomic_fetch_add_explicit(result + 5, v7 << 13, memory_order_relaxed);
  return result;
}

uint64_t _big_split_JustPositionOffset_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, signed int a5)
{
  uint64_t v5 = a2 + 1;
  if (a5 >= 3)
  {
    while (v5 < (uint64_t)((unint64_t)a5 << 13))
    {
      if (a5-- <= 3)
      {
        a5 = 2;
        return parallel_partition_JustPositionOffset_t(a1, v5, a3, a4, a5);
      }
    }
  }
  return parallel_partition_JustPositionOffset_t(a1, v5, a3, a4, a5);
}

void oqdispose_PositionOffsetWithMeta_t(uint64_t a1)
{
  if (*(uint64_t *)(a1 + 24) >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 8;
    do
    {
      CFRelease(*(CFTypeRef *)(*(void *)(a1 + 8) + v3));
      ++v2;
      v3 += 24;
    }
    while (v2 < *(void *)(a1 + 24));
  }
  if (*(_DWORD *)(a1 + 48))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4 < *(void *)(a1 + 40))
    {
      uint64_t v5 = 24 * v4 + 8;
      do
      {
        CFRelease(*(CFTypeRef *)(*(void *)(a1 + 8) + v5));
        ++v4;
        v5 += 24;
      }
      while (v4 < *(void *)(a1 + 40));
    }
  }
  int64_t v6 = *(void **)(a1 + 8);
  free(v6);
}

void parallel_qsort_PositionOffsetWithMeta_t(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a2 > 2047)
  {
    uint64_t v4 = OSAtomicDequeue(&qsort_cached_allocations, 0);
    if (!v4) {
      uint64_t v4 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
    }
    uint64_t v5 = dispatch_group_create();
    void v4[3] = v5;
    void v4[4] = 0;
    v4[1] = 0;
    v4[2] = a2 - 1;
    *uint64_t v4 = a1;
    int v6 = thread_count;
    if (!thread_count)
    {
      *(void *)BOOL v9 = 0x1900000006;
      size_t v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      int v6 = thread_count;
    }
    *((_DWORD *)v4 + 14) = v6;
    void v4[5] = (uint64_t)sqrt((double)a2) / 2;
    if (!v6)
    {
      *(void *)BOOL v9 = 0x1900000006;
      size_t v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      int v6 = thread_count;
    }
    uint64_t v7 = a2 / (2 * v6);
    if (v7 <= 0x8000)
    {
      uint64_t v7 = 0x8000;
    }
    else if (!v6)
    {
      *(void *)BOOL v9 = 0x1900000006;
      size_t v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      uint64_t v7 = a2 / (2 * thread_count);
    }
    v4[6] = v7;
    if ((uint64_t)v4[5] <= 2047) {
      void v4[5] = 2048;
    }
    _qsort_big_PositionOffsetWithMeta_t(v4);
    dispatch_group_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v5);
  }
  else
  {
    _qsort_PositionOffsetWithMeta_t(a1, 0, a2 - 1);
  }
}

void _qsort_PositionOffsetWithMeta_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = malloc_type_malloc(0x800uLL, 0x1000040451B5BE8uLL);
  *int v6 = 0;
  v6[1] = 0;
  uint64_t v7 = 1;
  do
  {
    if (a3 > a2)
    {
      if (v7 <= 128) {
        uint64_t v9 = 128;
      }
      else {
        uint64_t v9 = v7;
      }
      uint64_t v10 = &v6[2 * v7 + 1];
      while (a3 - a2 > 16)
      {
        uint64_t v11 = _partition_PositionOffsetWithMeta_t(a1, a2, a3);
        uint64_t v12 = v11 - a2;
        if (v11 < a2)
        {
          atomic_ullong v25 = __si_assert_copy_extra_329();
          int64_t v26 = v25;
          BOOL v27 = "";
          if (v25) {
            BOOL v27 = v25;
          }
          __message_assert(v25, "OQueue.c", 17, "q>=left", v27);
          free(v26);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        if (v9 == v7)
        {
          heapsort_b((void *)(a1 + 24 * a2), a3 - a2 + 1, 0x18uLL, &__block_literal_global_36_3293);
          uint64_t v7 = v9;
          goto LABEL_3;
        }
        BOOL v13 = v12 <= a3 - v11;
        if (v12 <= a3 - v11) {
          uint64_t v14 = v11 - 1;
        }
        else {
          uint64_t v14 = a3;
        }
        if (v13) {
          uint64_t v15 = a2;
        }
        else {
          uint64_t v15 = v11;
        }
        if (v13) {
          a2 = v11;
        }
        else {
          a3 = v11 - 1;
        }
        *(v10 - 1) = v15;
        uint64_t *v10 = v14;
        ++v7;
        v10 += 2;
        if (a3 <= a2) {
          goto LABEL_3;
        }
      }
      uint64_t v16 = a1 + 32 + 24 * a2;
      uint64_t v17 = a2;
      do
      {
        uint64_t v19 = v17++;
        uint64_t v20 = a1 + 24 * v19;
        unint64_t v21 = *(void *)(v20 + 24);
        unint64_t v22 = *(void *)v20;
        long long v28 = *(_OWORD *)(v20 + 8);
        long long v29 = *(_OWORD *)(v20 + 32);
        uint64_t v23 = v17;
        if (v22 > v21)
        {
          int v24 = (_OWORD *)v16;
          do
          {
            uint64_t v23 = v19;
            *((void *)v24 - 1) = v22;
            _OWORD *v24 = v28;
            if (v19 <= a2) {
              break;
            }
            unint64_t v22 = *((void *)v24 - 7);
            long long v28 = *(v24 - 3);
            int v24 = (_OWORD *)((char *)v24 - 24);
            --v19;
          }
          while (v22 > v21);
        }
        uint64_t v18 = a1 + 24 * v23;
        *(void *)uint64_t v18 = v21;
        *(_OWORD *)(v18 + 8) = v29;
        v16 += 24;
      }
      while (v17 != a3);
    }
LABEL_3:
    --v7;
    size_t v8 = &v6[2 * v7];
    a2 = *v8;
    a3 = v8[1];
  }
  while (v7);
  free(v6);
}

uint64_t _partition_PositionOffsetWithMeta_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3 - a2;
  unint64_t v4 = a3 - a2 + 1;
  uint64_t v5 = (uint64_t *)(a1 + 24 * a2);
  uint64_t v6 = a3 - a2 + 2;
  if (a3 - a2 >= -1) {
    uint64_t v6 = v3 + 1;
  }
  uint64_t v7 = &v5[3 * (v6 >> 1)];
  size_t v8 = (unint64_t *)(a1 + 24 * a3);
  if (v3 < 1024)
  {
    BOOL v13 = (unint64_t *)(a1 + 24 * a2);
    int64_t v26 = v7;
    BOOL v27 = (unint64_t *)(a1 + 24 * a3);
  }
  else
  {
    unint64_t v9 = v4 >> 3;
    uint64_t v10 = (unint64_t *)&v5[3 * (v4 >> 3)];
    unint64_t v11 = *v5;
    unint64_t v12 = *v10;
    BOOL v13 = (unint64_t *)(a1 + 24 * a2);
    if (*v5 != *v10)
    {
      BOOL v13 = (unint64_t *)&v5[6 * v9];
      unint64_t v14 = *v13;
      if (v11 >= *v13) {
        uint64_t v15 = &v5[6 * v9];
      }
      else {
        uint64_t v15 = (uint64_t *)(a1 + 24 * a2);
      }
      if (v12 > v14) {
        uint64_t v15 = (uint64_t *)v10;
      }
      if (v11 >= v14) {
        uint64_t v16 = (uint64_t *)(a1 + 24 * a2);
      }
      else {
        uint64_t v16 = &v5[6 * v9];
      }
      if (v12 >= v14) {
        uint64_t v10 = (unint64_t *)v16;
      }
      if (v11 >= v12) {
        uint64_t v10 = (unint64_t *)v15;
      }
      if (v14 != v11 && v14 != v12) {
        BOOL v13 = v10;
      }
    }
    uint64_t v18 = 2 * v9;
    uint64_t v19 = -(uint64_t)v9;
    uint64_t v20 = (unint64_t *)&v7[-3 * v9];
    unint64_t v21 = *v20;
    unint64_t v22 = *v7;
    if (*v20 == *v7)
    {
      int64_t v26 = &v7[-3 * v9];
    }
    else
    {
      uint64_t v23 = (unint64_t *)&v7[3 * v9];
      unint64_t v24 = *v23;
      BOOL v25 = *v23 == v21 || v24 == v22;
      int64_t v26 = &v7[3 * v9];
      if (!v25)
      {
        int64_t v26 = v7;
        if (v21 >= v22)
        {
          if (v22 <= v24)
          {
            if (v21 >= v24) {
              int64_t v26 = (uint64_t *)v23;
            }
            else {
              int64_t v26 = (uint64_t *)v20;
            }
          }
        }
        else if (v22 >= v24)
        {
          if (v21 >= v24) {
            int64_t v26 = (uint64_t *)v20;
          }
          else {
            int64_t v26 = (uint64_t *)v23;
          }
        }
      }
    }
    BOOL v27 = &v8[-3 * v18];
    long long v28 = &v8[3 * v19];
    unint64_t v29 = *v27;
    unint64_t v30 = *v28;
    if (*v27 != *v28)
    {
      unint64_t v31 = *v8;
      if (v29 >= *v8) {
        unint64_t v32 = (unint64_t *)(a1 + 24 * a3);
      }
      else {
        unint64_t v32 = v27;
      }
      if (v30 > v31) {
        unint64_t v32 = v28;
      }
      if (v29 < v31) {
        BOOL v27 = (unint64_t *)(a1 + 24 * a3);
      }
      if (v30 < v31) {
        BOOL v27 = v28;
      }
      if (v29 >= v30) {
        BOOL v27 = v32;
      }
      if (v31 == v29 || v31 == v30) {
        BOOL v27 = (unint64_t *)(a1 + 24 * a3);
      }
    }
  }
  unint64_t v34 = *v13;
  unint64_t v35 = *v26;
  if (*v13 == *v26)
  {
    int64_t v26 = (uint64_t *)v13;
  }
  else
  {
    unint64_t v36 = *v27;
    if (*v27 == v34 || v36 == v35)
    {
      int64_t v26 = (uint64_t *)v27;
    }
    else if (v34 >= v35)
    {
      if (v35 <= v36)
      {
        if (v34 >= v36) {
          int64_t v26 = (uint64_t *)v27;
        }
        else {
          int64_t v26 = (uint64_t *)v13;
        }
      }
    }
    else if (v35 >= v36)
    {
      if (v34 >= v36) {
        int64_t v26 = (uint64_t *)v13;
      }
      else {
        int64_t v26 = (uint64_t *)v27;
      }
    }
  }
  unint64_t v38 = *v26;
  long long v53 = *(_OWORD *)(v26 + 1);
  long long v39 = *(_OWORD *)v8;
  v26[2] = v8[2];
  *(_OWORD *)int64_t v26 = v39;
  *size_t v8 = v38;
  *(_OWORD *)(v8 + 1) = v53;
  unint64_t v40 = *v5;
  long long v52 = *(_OWORD *)(v5 + 1);
  uint64_t v41 = a3 - a2;
  if (a3 > a2)
  {
    uint64_t v42 = (_OWORD *)(a1 + 24 * a2 + 32);
    do
    {
      unint64_t v43 = *((void *)v42 - 1);
      long long v51 = v52;
      long long v52 = *v42;
      if (v40 <= v38)
      {
        uint64_t v44 = (long long *)(a1 + 24 * a2);
        long long v45 = *v44;
        *((void *)v42 - 2) = *((void *)v44 + 2);
        *(v42 - 2) = v45;
        *(void *)uint64_t v44 = v40;
        *(long long *)((char *)v44 + 8) = v51;
        ++a2;
      }
      uint64_t v42 = (_OWORD *)((char *)v42 + 24);
      unint64_t v40 = v43;
      --v41;
    }
    while (v41);
  }
  uint64_t v46 = (long long *)(a1 + 24 * a2);
  unint64_t v47 = *((void *)v46 + 2);
  long long v48 = *v46;
  unint64_t v49 = v8[2];
  *uint64_t v46 = *(_OWORD *)v8;
  *((void *)v46 + 2) = v49;
  *(_OWORD *)size_t v8 = v48;
  v8[2] = v47;
  return a2;
}

void _qsort_big_PositionOffsetWithMeta_t(void *a1)
{
  uint64_t v1 = *((void *)a1 + 1);
  uint64_t v2 = *((void *)a1 + 2);
  uint64_t v3 = *((void *)a1 + 3);
  uint64_t v4 = *((void *)a1 + 4);
  uint64_t v5 = *((void *)a1 + 5);
  uint64_t v36 = *((void *)a1 + 6);
  uint64_t v37 = *(void *)a1;
  signed int v6 = *((_DWORD *)a1 + 14);
  int v35 = *((_DWORD *)a1 + 15);
  OSAtomicEnqueue(&qsort_cached_allocations, a1, 0);
  if (v2 > v1)
  {
    for (unint64_t i = v4 + 1; ; ++i)
    {
      uint64_t v10 = v2 - v1;
      if (v2 - v1 <= v5 || i > 9) {
        break;
      }
      if (v6 <= 1) {
        signed int v6 = 1;
      }
      uint64_t v12 = getSize_memSize;
      if (!getSize_memSize)
      {
        long long v42 = 0u;
        long long v43 = 0u;
        *(_OWORD *)host_info_out = 0u;
        host_t v13 = MEMORY[0x1C1881C90]();
        mach_msg_type_number_t host_info_outCnt = 12;
        mach_error_t v14 = host_info(v13, 1, host_info_out, &host_info_outCnt);
        if (v14)
        {
          mach_error("flushsize", v14);
          exit(1);
        }
        uint64_t v12 = *((void *)&v43 + 1);
        getSize_memSize = *((void *)&v43 + 1);
      }
      unint64_t v15 = 3 * v12 / 5uLL;
      uint64_t v16 = v3;
      if (24 * v10 > v15) {
        uint64_t v16 = dispatch_group_create();
      }
      if (v10 <= v36 || 24 * v10 >= v15)
      {
        uint64_t v19 = _partition_PositionOffsetWithMeta_t(v37, v1, v2);
      }
      else
      {
        qos_class_t v17 = qos_class_self();
        global_queue = dispatch_get_global_queue(v17, 2uLL);
        uint64_t v19 = _big_partition_PositionOffsetWithMeta_t(v37, v1, v2, global_queue, v6);
      }
      uint64_t v20 = v19;
      uint64_t v21 = v19 - v1;
      if (v19 < v1)
      {
        unint64_t v31 = __si_assert_copy_extra_329();
        unint64_t v32 = v31;
        uint64_t v33 = "";
        if (v31) {
          uint64_t v33 = v31;
        }
        __message_assert(v31, "OQueue.c", 17, "q>=left", v33, v39);
        free(v32);
        if (__valid_fs(-1)) {
          uint64_t v34 = 2989;
        }
        else {
          uint64_t v34 = 3072;
        }
        *(_DWORD *)uint64_t v34 = -559038737;
        abort();
      }
      unint64_t v22 = OSAtomicDequeue(&qsort_cached_allocations, 0);
      if (!v22) {
        unint64_t v22 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
      }
      *((void *)v22 + 4) = i;
      *((void *)v22 + 5) = v5;
      *((void *)v22 + 6) = v36;
      uint64_t v23 = v2 - v20;
      if (v21 <= v2 - v20)
      {
        uint64_t v24 = v20 - 1;
      }
      else
      {
        uint64_t v23 = v20 - 1 - v1;
        uint64_t v24 = v2;
      }
      if (v21 > v2 - v20) {
        uint64_t v25 = v20;
      }
      else {
        uint64_t v25 = v1;
      }
      if (v21 > v2 - v20) {
        uint64_t v2 = v20 - 1;
      }
      else {
        uint64_t v1 = v20;
      }
      *(void *)unint64_t v22 = v37;
      *((void *)v22 + 1) = v25;
      int v26 = (int)(float)((float)((float)(v23 + 1) * (float)v6) / (float)(v24 - v25 + 1));
      if (v26 <= 1) {
        int v27 = 1;
      }
      else {
        int v27 = v26;
      }
      if (v6 >= v26) {
        int v28 = v27;
      }
      else {
        int v28 = 0;
      }
      v22[14] = v6 - v28;
      v22[15] = v35;
      *((void *)v22 + 2) = v24;
      *((void *)v22 + 3) = v16;
      if (v16 == v3)
      {
        if (v6 >= v26) {
          signed int v6 = v27;
        }
        qos_class_t v8 = qos_class_self();
        unint64_t v9 = dispatch_get_global_queue(v8, 2uLL);
        dispatch_group_async_f(v3, v9, v22, (dispatch_function_t)_qsort_big_PositionOffsetWithMeta_t);
      }
      else
      {
        v22[14] = v6;
        _qsort_big_PositionOffsetWithMeta_t(v22);
        dispatch_group_wait(v16, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(v16);
        qos_class_t v29 = qos_class_self();
        unint64_t v30 = dispatch_get_global_queue(v29, 2uLL);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        v39[0] = ___qsort_big_PositionOffsetWithMeta_t_block_invoke;
        v39[1] = &__block_descriptor_tmp_33_3296;
        v39[2] = v22;
        dispatch_async(v30, block);
      }
      if (v2 <= v1) {
        return;
      }
    }
    _qsort_PositionOffsetWithMeta_t(v37, v1, v2);
  }
}

uint64_t _big_partition_PositionOffsetWithMeta_t(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  uint64_t v7 = a3 - a2;
  BOOL v8 = __OFADD__(a3 - a2, 1);
  unint64_t v9 = a3 - a2 + 1;
  uint64_t v10 = (uint64_t *)(a1 + 24 * a2);
  uint64_t v11 = v7 + 2;
  if (((v9 & 0x8000000000000000) != 0) == v8) {
    uint64_t v11 = v7 + 1;
  }
  uint64_t v12 = &v10[3 * (v11 >> 1)];
  host_t v13 = (unint64_t *)(a1 + 24 * a3);
  if (v7 < 64)
  {
    unint64_t v30 = v12;
    uint64_t v18 = v10;
  }
  else
  {
    unint64_t v14 = v9 >> 3;
    unint64_t v15 = (unint64_t *)&v10[3 * (v9 >> 3)];
    unint64_t v16 = *v10;
    unint64_t v17 = *v15;
    uint64_t v18 = v10;
    if (*v10 != *v15)
    {
      uint64_t v18 = &v10[6 * v14];
      unint64_t v19 = *v18;
      if (*v18 != v16 && v19 != v17)
      {
        if (v16 >= v19) {
          uint64_t v21 = &v10[6 * v14];
        }
        else {
          uint64_t v21 = v10;
        }
        if (v17 > v19) {
          uint64_t v21 = &v10[3 * (v9 >> 3)];
        }
        if (v16 >= v19) {
          uint64_t v18 = v10;
        }
        if (v17 < v19) {
          uint64_t v18 = &v10[3 * (v9 >> 3)];
        }
        if (v16 >= v17) {
          uint64_t v18 = v21;
        }
      }
    }
    uint64_t v22 = 2 * v14;
    uint64_t v23 = -(uint64_t)v14;
    uint64_t v24 = &v12[-3 * v14];
    unint64_t v25 = *v24;
    unint64_t v26 = *v12;
    if (*v24 == *v12)
    {
      unint64_t v30 = &v12[-3 * v14];
    }
    else
    {
      int v27 = &v12[3 * v14];
      unint64_t v28 = *v27;
      BOOL v29 = *v27 == v25 || v28 == v26;
      unint64_t v30 = &v12[3 * v14];
      if (!v29)
      {
        unint64_t v30 = v12;
        if (v25 >= v26)
        {
          if (v26 <= v28)
          {
            if (v25 >= v28) {
              unint64_t v30 = v27;
            }
            else {
              unint64_t v30 = v24;
            }
          }
        }
        else if (v26 >= v28)
        {
          if (v25 >= v28) {
            unint64_t v30 = v24;
          }
          else {
            unint64_t v30 = v27;
          }
        }
      }
    }
    unint64_t v31 = &v13[-3 * v22];
    unint64_t v32 = &v13[3 * v23];
    unint64_t v33 = *v31;
    unint64_t v34 = *v32;
    if (*v31 == *v32)
    {
      host_t v13 = v31;
    }
    else
    {
      unint64_t v35 = *v13;
      if (v33 >= *v13) {
        uint64_t v36 = v13;
      }
      else {
        uint64_t v36 = v31;
      }
      if (v34 > v35) {
        uint64_t v36 = v32;
      }
      if (v33 < v35) {
        unint64_t v31 = v13;
      }
      if (v34 < v35) {
        unint64_t v31 = v32;
      }
      if (v33 >= v34) {
        unint64_t v31 = v36;
      }
      if (v35 != v33 && v35 != v34) {
        host_t v13 = v31;
      }
    }
  }
  unint64_t v38 = *v18;
  unint64_t v39 = *v30;
  if (*v18 == *v30)
  {
    unint64_t v30 = v18;
  }
  else
  {
    unint64_t v40 = *v13;
    if (*v13 == v38 || v40 == v39)
    {
      unint64_t v30 = (uint64_t *)v13;
    }
    else if (v38 >= v39)
    {
      if (v39 <= v40)
      {
        if (v38 >= v40) {
          unint64_t v30 = (uint64_t *)v13;
        }
        else {
          unint64_t v30 = v18;
        }
      }
    }
    else if (v39 >= v40)
    {
      if (v38 >= v40) {
        unint64_t v30 = v18;
      }
      else {
        unint64_t v30 = (uint64_t *)v13;
      }
    }
  }
  return parallel_partition_PositionOffsetWithMeta_t(v10, v9, *v30, a4, a5) + a2;
}

uint64_t parallel_partition_PositionOffsetWithMeta_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  int v5 = a5;
  v17[1] = v17;
  context[9] = *MEMORY[0x1E4F143B8];
  context[6] = a1;
  size_t v10 = 8 * a5;
  MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)v17 - v11;
  bzero((char *)v17 - v11, v10);
  uint64_t v13 = (a2 / 0x4000) << 13;
  context[1] = v13;
  context[2] = a2;
  uint64_t v14 = a2 - v13;
  context[4] = 0;
  context[5] = 0;
  context[7] = a3;
  context[8] = v12;
  if (v5 >= 1) {
    memset(v12, 255, v10);
  }
  uint64_t v15 = v13 + 0x2000;
  if (v14 > v13 + 0x2000) {
    uint64_t v15 = a2 - v13;
  }
  context[3] = v14 + ((v15 - v14 + 0x1FFF) & 0xFFFFFFFFFFFFE000);
  context[0] = 0;
  if (24 * a2 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
    madvise(a1, 24 * a2, 3);
  }
  if (a2 / 0x4000 < v5) {
    int v5 = a2 / 0x4000;
  }
  dispatch_apply_f(v5, a4, context, (void (__cdecl *)(void *, size_t))partition_phase_PositionOffsetWithMeta_t);
  return sequential_fixup_PositionOffsetWithMeta_t((uint64_t)context, a2, v5);
}

uint64_t sequential_fixup_PositionOffsetWithMeta_t(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = a3;
  qsort(*(void **)(a1 + 64), a3, 8uLL, (int (__cdecl *)(const void *, const void *))index_comp);
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v8 = a3 - 1;
  uint64_t v9 = 0;
  if (a3 < 1) {
    goto LABEL_111;
  }
  while (*(void *)(v7 + 8 * v9) == -1)
  {
    if (v6 == ++v9)
    {
      uint64_t v9 = v6;
      break;
    }
  }
  if (a3 == 1)
  {
    uint64_t v8 = 0;
    if (v9 >= 0) {
      goto LABEL_46;
    }
  }
  else
  {
LABEL_111:
    do
    {
      if (*(void *)(v7 + 8 * v8) != -1) {
        break;
      }
      --v8;
    }
    while (v8);
    if (v9 >= v8) {
      goto LABEL_46;
    }
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  do
  {
    uint64_t v13 = *(void *)(a1 + 48);
    unint64_t v12 = *(void *)(a1 + 56);
    uint64_t v14 = v13 + 24 * *(void *)(v7 + 8 * v9);
    uint64_t v15 = v13 + 24 * *(void *)(v7 + 8 * v8);
    while (1)
    {
      if (v11 < 0x2000)
      {
        unint64_t v16 = (unint64_t *)(v14 + 24 * v11);
        while (1)
        {
          unint64_t v17 = *v16;
          v16 += 3;
          if (v17 > v12) {
            break;
          }
          if (++v11 == 0x2000)
          {
            uint64_t v18 = 0x2000;
            if (v10 < 0x2000) {
              goto LABEL_20;
            }
            goto LABEL_24;
          }
        }
      }
      uint64_t v18 = v11;
      if (v10 < 0x2000)
      {
LABEL_20:
        unint64_t v19 = (unint64_t *)(v15 + 24 * v10);
        while (1)
        {
          unint64_t v20 = *v19;
          v19 += 3;
          if (v20 < v12) {
            break;
          }
          if (++v10 == 0x2000)
          {
            uint64_t v11 = v18;
            goto LABEL_28;
          }
        }
      }
LABEL_24:
      uint64_t v21 = v10;
      if (v18 == 0x2000 || v10 == 0x2000) {
        break;
      }
      uint64_t v22 = (long long *)(v15 + 24 * v10);
      uint64_t v23 = *((void *)v22 + 2);
      long long v24 = *v22;
      unint64_t v25 = (long long *)(v14 + 24 * v18);
      uint64_t v26 = *((void *)v25 + 2);
      *uint64_t v22 = *v25;
      *((void *)v22 + 2) = v26;
      *unint64_t v25 = v24;
      *((void *)v25 + 2) = v23;
      uint64_t v11 = v18 + 1;
      uint64_t v10 = v21 + 1;
      if (v18 > 8190 || v21 >= 0x1FFF) {
        goto LABEL_28;
      }
    }
    uint64_t v11 = v18;
LABEL_28:
    if (v10 == 0x2000 && v11 == 0x2000) {
      int v28 = 2;
    }
    else {
      int v28 = v11 != 0x2000;
    }
    uint64_t v7 = *(void *)(a1 + 64);
    if ((v28 & 1) == 0)
    {
      uint64_t v29 = *(void *)(v7 + 8 * v9);
      if ((v29 & 0x8000000000000000) == 0 && v29 < *(void *)(a1 + 32))
      {
        *(void *)(v7 + 8 * v9) = -1;
        *(void *)(a1 + 32) += 0x2000;
      }
      uint64_t v11 = 0;
      ++v9;
      if ((v28 - 1) > 1) {
        continue;
      }
    }
    uint64_t v30 = *(void *)(v7 + 8 * v8);
    BOOL v31 = v30 >= a2 || v30 < a2 - *(void *)(a1 + 40);
    if (!v31)
    {
      *(void *)(v7 + 8 * v8) = -1;
      *(void *)(a1 + 40) += 0x2000;
    }
    uint64_t v10 = 0;
    --v8;
  }
  while (v9 < v8);
LABEL_46:
  unint64_t v33 = *(void *)(a1 + 32);
  uint64_t v32 = *(void *)(a1 + 40);
  unint64_t v34 = malloc_type_malloc(0x30000uLL, 0xFE790DC3uLL);
  if (a3 < 1)
  {
    uint64_t v50 = *(void *)a1;
    uint64_t v51 = *(void *)(a1 + 16) - 1;
  }
  else
  {
    uint64_t v35 = 0;
    unint64_t v36 = ~v32 + a2;
    uint64_t v37 = a3;
    unint64_t v38 = *(uint64_t **)(a1 + 64);
    uint64_t v39 = 8 * a3;
    do
    {
      unint64_t v40 = v38[v35];
      if (v40 != -1 && v36 <= v40) {
        break;
      }
      if (v40 != -1)
      {
        if (v33 <= v40) {
          break;
        }
        unint64_t v42 = *(void *)(a1 + 32);
        if (v42 > v40)
        {
          unint64_t v43 = 0;
          do
          {
            if (v38[v43 / 8] == v42)
            {
              v42 += 0x2000;
              *(void *)(a1 + 32) = v42;
            }
            v43 += 8;
          }
          while (v39 != v43);
          if ((int64_t)v42 >= *(void *)a1) {
            break;
          }
          memcpy(v34, (const void *)(*(void *)(a1 + 48) + 24 * v38[v35]), 0x30000uLL);
          memcpy((void *)(*(void *)(a1 + 48) + 24 * *(void *)(*(void *)(a1 + 64) + 8 * v35)), (const void *)(*(void *)(a1 + 48) + 24 * *(void *)(a1 + 32)), 0x30000uLL);
          memcpy((void *)(*(void *)(a1 + 48) + 24 * *(void *)(a1 + 32)), v34, 0x30000uLL);
          unint64_t v38 = *(uint64_t **)(a1 + 64);
          v38[v35] = *(void *)(a1 + 32);
          *(void *)(a1 + 32) += 0x2000;
        }
      }
      ++v35;
    }
    while (v35 != v37);
    uint64_t v44 = v37;
    do
    {
      unint64_t v45 = v38[(v44 - 1)];
      if (v33 > v45) {
        break;
      }
      if (v45 != -1)
      {
        if (v36 > v45) {
          break;
        }
        uint64_t v46 = (v44 - 1);
        uint64_t v47 = *(void *)(a1 + 40) + 0x2000;
        *(void *)(a1 + 40) = v47;
        uint64_t v48 = v37 + 1;
        do
        {
          if (v38[(v48 - 2)] == a2 - v47)
          {
            v47 += 0x2000;
            *(void *)(a1 + 40) = v47;
          }
          --v48;
        }
        while (v48 > 1);
        if ((unint64_t)(a2 - v47) < *(void *)(a1 + 16)) {
          break;
        }
        uint64_t v49 = v46;
        memcpy(v34, (const void *)(*(void *)(a1 + 48) + 24 * v38[v46]), 0x30000uLL);
        memcpy((void *)(*(void *)(a1 + 48) + 24 * *(void *)(*(void *)(a1 + 64) + v49 * 8)), (const void *)(*(void *)(a1 + 48) + 24 * (a2 - *(void *)(a1 + 40))), 0x30000uLL);
        memcpy((void *)(*(void *)(a1 + 48) + 24 * (a2 - *(void *)(a1 + 40))), v34, 0x30000uLL);
        unint64_t v38 = *(uint64_t **)(a1 + 64);
        v38[v49] = a2 - *(void *)(a1 + 40);
      }
      BOOL v31 = v44-- <= 1;
    }
    while (!v31);
    uint64_t v50 = *(void *)a1;
    uint64_t v51 = *(void *)(a1 + 16) - 1;
    do
    {
      uint64_t v53 = *v38++;
      uint64_t v52 = v53;
      if (v53 != -1)
      {
        if (v52 < v50) {
          uint64_t v50 = v52;
        }
        uint64_t v54 = v52 + 0x2000;
        uint64_t v55 = v52 + 0x1FFF;
        if (v54 > v51) {
          uint64_t v51 = v55;
        }
        if (v51 >= a2)
        {
          uint64_t v56 = __si_assert_copy_extra_329();
          unint64_t v57 = v56;
          unint64_t v58 = "";
          if (v56) {
            unint64_t v58 = v56;
          }
          __message_assert(v56, "OQueue.c", 17, "right < count", v58);
          free(v57);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
      }
      --v37;
    }
    while (v37);
  }
  free(v34);
  if (v50 >= v51)
  {
    uint64_t v59 = v50;
  }
  else
  {
    uint64_t v59 = v50;
    do
    {
      uint64_t v61 = *(void *)(a1 + 48);
      unint64_t v60 = *(void *)(a1 + 56);
      long long v62 = (unint64_t *)(v61 + 24 * v50);
      while (*v62 < v60)
      {
        ++v59;
        v62 += 3;
        if (v59 >= v51)
        {
          if (v51 <= v50 + 1) {
            uint64_t v59 = v50 + 1;
          }
          else {
            uint64_t v59 = v51;
          }
          goto LABEL_105;
        }
      }
      if (v59 < v51)
      {
        uint64_t v63 = (unint64_t *)(v61 + 24 * v51);
        while (*v63 > v60)
        {
          --v51;
          v63 -= 3;
          if (v59 >= v51) {
            goto LABEL_105;
          }
        }
        unint64_t v64 = v63[2];
        long long v65 = *(_OWORD *)v63;
        unint64_t v66 = v62[2];
        *(_OWORD *)uint64_t v63 = *(_OWORD *)v62;
        void v63[2] = v66;
        uint64_t v67 = *(void *)(a1 + 48) + 24 * v59;
        *(_OWORD *)uint64_t v67 = v65;
        *(void *)(v67 + 16) = v64;
        ++v59;
        --v51;
      }
      uint64_t v50 = v59;
    }
    while (v59 < v51);
  }
LABEL_105:
  if (*(void *)(*(void *)(a1 + 48) + 24 * v59) >= *(void *)(a1 + 56)) {
    return v59;
  }
  else {
    return v59 + 1;
  }
}

atomic_ullong *partition_phase_PositionOffsetWithMeta_t(atomic_ullong *result, uint64_t a2)
{
  atomic_ullong v2 = result[6];
  atomic_ullong v3 = result[1];
  if (*result < v3)
  {
    unint64_t add_explicit = atomic_fetch_add_explicit(result, 0x2000uLL, memory_order_relaxed);
    if ((uint64_t)(add_explicit + 0x2000) <= v3) {
      goto LABEL_5;
    }
    atomic_fetch_add_explicit(result, 0xFFFFFFFFFFFFE000, memory_order_relaxed);
  }
  unint64_t add_explicit = -1;
LABEL_5:
  int64_t v5 = result[3];
  if (result[2] <= v5)
  {
LABEL_8:
    uint64_t v7 = 0;
    if (add_explicit != -1)
    {
      uint64_t v8 = 0;
      goto LABEL_19;
    }
    int64_t v6 = -1;
    uint64_t v8 = 0;
LABEL_18:
    unint64_t add_explicit = v6;
    goto LABEL_19;
  }
  int64_t v6 = atomic_fetch_add_explicit(result + 2, 0xFFFFFFFFFFFFE000, memory_order_relaxed) - 0x2000;
  if (v6 < v5)
  {
    atomic_fetch_add_explicit(result + 2, 0x2000uLL, memory_order_relaxed);
    goto LABEL_8;
  }
  BOOL v9 = add_explicit != -1;
  if (v6 != -1 && add_explicit != -1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    while (1)
    {
      unint64_t v13 = v2 + 24 * add_explicit;
      unint64_t v14 = result[7];
      atomic_ullong v15 = v2 + 24 * v6;
      while (1)
      {
        if (v12 < 0x2000)
        {
          unint64_t v16 = (unint64_t *)(v13 + 24 * v12);
          while (1)
          {
            unint64_t v17 = *v16;
            v16 += 3;
            if (v17 > v14) {
              break;
            }
            if (++v12 == 0x2000)
            {
              uint64_t v18 = 0x2000;
              if (v11 < 0x2000) {
                goto LABEL_28;
              }
              goto LABEL_32;
            }
          }
        }
        uint64_t v18 = v12;
        if (v11 < 0x2000)
        {
LABEL_28:
          unint64_t v19 = (unint64_t *)(v15 + 24 * v11);
          while (1)
          {
            unint64_t v20 = *v19;
            v19 += 3;
            if (v20 < v14) {
              break;
            }
            if (++v11 == 0x2000)
            {
              uint64_t v12 = v18;
              goto LABEL_36;
            }
          }
        }
LABEL_32:
        uint64_t v21 = v11;
        if (v18 == 0x2000 || v11 == 0x2000) {
          break;
        }
        uint64_t v22 = (long long *)(v15 + 24 * v11);
        uint64_t v23 = *((void *)v22 + 2);
        long long v24 = *v22;
        unint64_t v25 = v13 + 24 * v18;
        uint64_t v26 = *(void *)(v25 + 16);
        *uint64_t v22 = *(_OWORD *)v25;
        *((void *)v22 + 2) = v26;
        *(_OWORD *)unint64_t v25 = v24;
        *(void *)(v25 + 16) = v23;
        uint64_t v12 = v18 + 1;
        uint64_t v11 = v21 + 1;
        if (v18 > 8190 || v21 >= 0x1FFF) {
          goto LABEL_36;
        }
      }
      uint64_t v12 = v18;
LABEL_36:
      int v27 = v12 != 0x2000;
      if (v11 == 0x2000 && v12 == 0x2000) {
        int v27 = 2;
      }
      if (v27) {
        goto LABEL_47;
      }
      atomic_ullong v29 = result[1];
      if (*result < v29)
      {
        unint64_t add_explicit = atomic_fetch_add_explicit(result, 0x2000uLL, memory_order_relaxed);
        if ((uint64_t)(add_explicit + 0x2000) <= v29) {
          goto LABEL_46;
        }
        atomic_fetch_add_explicit(result, 0xFFFFFFFFFFFFE000, memory_order_relaxed);
      }
      unint64_t add_explicit = -1;
LABEL_46:
      uint64_t v12 = 0;
      ++v8;
      if ((v27 - 1) > 1) {
        goto LABEL_52;
      }
LABEL_47:
      int64_t v30 = result[3];
      if (result[2] <= v30) {
        goto LABEL_50;
      }
      int64_t v6 = atomic_fetch_add_explicit(result + 2, 0xFFFFFFFFFFFFE000, memory_order_relaxed) - 0x2000;
      if (v6 < v30)
      {
        atomic_fetch_add_explicit(result + 2, 0x2000uLL, memory_order_relaxed);
LABEL_50:
        int64_t v6 = -1;
      }
      uint64_t v11 = 0;
      ++v7;
LABEL_52:
      BOOL v9 = add_explicit != -1;
      if (v6 == -1 || add_explicit == -1) {
        goto LABEL_17;
      }
    }
  }
  uint64_t v8 = 0;
  uint64_t v7 = 0;
LABEL_17:
  if (!v9) {
    goto LABEL_18;
  }
LABEL_19:
  *(void *)(result[8] + 8 * a2) = add_explicit;
  atomic_fetch_add_explicit(result + 4, v8 << 13, memory_order_relaxed);
  atomic_fetch_add_explicit(result + 5, v7 << 13, memory_order_relaxed);
  return result;
}

uint64_t _big_split_PositionOffsetWithMeta_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, signed int a5)
{
  uint64_t v5 = a2 + 1;
  if (a5 >= 3)
  {
    while (v5 < (uint64_t)((unint64_t)a5 << 13))
    {
      if (a5-- <= 3)
      {
        a5 = 2;
        return parallel_partition_PositionOffsetWithMeta_t(a1, v5, a3, a4, a5);
      }
    }
  }
  return parallel_partition_PositionOffsetWithMeta_t(a1, v5, a3, a4, a5);
}

void storage_reader_destroy(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  if (v1)
  {
    _release_read_window(&availableReaders, v1);
    *(void *)(a1 + 8) = 0;
  }
}

void *_storage_reader_match_address(void *result, unint64_t a2)
{
  if (result)
  {
    uint64_t v2 = result[1];
    if (v2) {
      uint64_t v3 = v2 + 528;
    }
    else {
      uint64_t v3 = *result + 216;
    }
    return (void *)storage_windows_contains_address(v3, a2);
  }
  return result;
}

void _storage_reader_exception_cleanup(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2)
    {
      _release_read_window(&availableReaders, v2);
      *(void *)(a1 + 8) = 0;
    }
  }
}

BOOL _storage_match_address(uint64_t a1, unint64_t a2)
{
  return _windowsAddressOffset(a1 + 216, a2) != -1;
}

uint64_t _storage_exception_cleanup(uint64_t result)
{
  *(unsigned char *)(result + 4373) = 1;
  return result;
}

void storageMakeReadOnly(uint64_t a1)
{
  storageUnmap(a1);
  uint64_t v3 = *(void *)(a1 + 216);
  uint64_t v2 = a1 + 216;
  fd_make_readonly(v3);
  *(_DWORD *)(v2 + 4152) = 1;
  *(unsigned char *)(v2 + 36) = 1;
  _windowsMapInit(v2, 1);
}

void storageUnmap(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 252) && *(unsigned char *)(a1 + 254) && *(int *)(a1 + 248) >= 1)
  {
    uint64_t v2 = 0;
    do
      storageWindowSync(*(void *)(a1 + 272 + 8 * v2++), 0);
    while (v2 < *(int *)(a1 + 248));
  }
  storageWindowsUnmap(a1 + 216);
}

uint64_t *storageHeaderStore(uint64_t a1, uint64_t *a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 4);
  uint64_t v5 = (unsigned char *)*a2;
  if (v4 >> 28)
  {
    *uint64_t v5 = v4 | 0x80;
    v5[1] = (v4 >> 7) | 0x80;
    v5[2] = (v4 >> 14) | 0x80;
    void v5[3] = (v4 >> 21) | 0x80;
    v5[4] = v4 >> 28;
    uint64_t v6 = 5;
  }
  else if ((v4 & 0xFE00000) != 0)
  {
    *uint64_t v5 = v4 | 0x80;
    v5[1] = (v4 >> 7) | 0x80;
    v5[2] = (v4 >> 14) | 0x80;
    void v5[3] = (v4 & 0xFE00000) >> 21;
    uint64_t v6 = 4;
  }
  else if ((v4 & 0x1FC000) != 0)
  {
    *uint64_t v5 = v4 | 0x80;
    v5[1] = (v4 >> 7) | 0x80;
    v5[2] = (v4 & 0x1FC000) >> 14;
    uint64_t v6 = 3;
  }
  else if ((v4 & 0x3F80) != 0)
  {
    *uint64_t v5 = v4 | 0x80;
    v5[1] = (unsigned __int16)(v4 & 0x3F80) >> 7;
    uint64_t v6 = 2;
  }
  else
  {
    *uint64_t v5 = v4;
    uint64_t v6 = 1;
  }
  *a2 += v6;
  storeVInt64(a2, *(void *)(a1 + 232));
  uint64_t result = storeVInt64(a2, *(void *)(a1 + 224));
  for (uint64_t i = 0; i != 128; i += 8)
  {
    unint64_t v9 = *(void *)(a1 + 8 + i);
    if (v9)
    {
      if (v9 >= *(void *)(a1 + 232))
      {
        uint64_t v10 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
        uint64_t v11 = v10;
        uint64_t v12 = "";
        if (v10) {
          uint64_t v12 = v10;
        }
        __message_assert("%s:%u: failed assertion '%s' %s offset: 0x%lld, freeRegion: 0x%lld", "storage.c", 192, "(head==0) || (head < storage->_windows._freeRegion)", v12, v9, *(void *)(a1 + 232));
        free(v11);
        if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
          uint64_t v13 = 2989;
        }
        else {
          uint64_t v13 = 3072;
        }
        *(_DWORD *)uint64_t v13 = -559038737;
        abort();
      }
      uint64_t result = storeVInt64(a2, *(void *)(a1 + 8 + i));
    }
    else
    {
      *(unsigned char *)(*a2)++ = 0;
    }
  }
  return result;
}

BOOL storageHeaderRestore(uint64_t a1, char **a2)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  bzero((void *)a1, 0x1140uLL);
  unsigned int v4 = *a2;
  int v5 = **a2;
  if (**a2 < 0)
  {
    int v7 = v4[1];
    if (v4[1] < 0)
    {
      int v8 = v4[2];
      if (v4[2] < 0)
      {
        int v10 = v4[3];
        if (v4[3] < 0)
        {
          int v37 = v4[4];
          uint64_t v11 = v4 + 5;
          *a2 = v11;
          *(_DWORD *)(a1 + 4) = ((v10 & 0x7F) << 21) | (v37 << 28) | ((v8 & 0x7F) << 14) | ((v7 & 0x7F) << 7) | v5 & 0x7F;
          if ((v37 & 0x80000000) == 0) {
            goto LABEL_31;
          }
          goto LABEL_11;
        }
        int v9 = ((v8 & 0x7F) << 14) | (v10 << 21) | ((v7 & 0x7F) << 7) | v5 & 0x7F;
        uint64_t v6 = 4;
      }
      else
      {
        int v9 = ((v7 & 0x7F) << 7) | (v8 << 14) | v5 & 0x7F;
        uint64_t v6 = 3;
      }
      int v5 = v9;
    }
    else
    {
      int v5 = v5 & 0x7F | (v7 << 7);
      uint64_t v6 = 2;
    }
  }
  else
  {
    uint64_t v6 = 1;
  }
  uint64_t v11 = &v4[v6];
  *a2 = v11;
  *(_DWORD *)(a1 + 4) = v5;
LABEL_11:
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  do
  {
    unsigned __int8 v15 = v11[v13++];
    v14 |= (unint64_t)(v15 & 0x7F) << v12;
    if ((v15 & 0x80) == 0) {
      break;
    }
    BOOL v16 = v12 == 63;
    v12 += 7;
  }
  while (!v16);
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  unint64_t v20 = (unsigned __int8 *)&v11[v13];
  *a2 = &v11[v13];
  *(void *)(a1 + 232) = v14;
  do
  {
    uint64_t v21 = v18 + 1;
    unsigned __int8 v22 = v11[v18 + v13];
    v19 |= (unint64_t)(v22 & 0x7F) << v17;
    if ((v22 & 0x80) == 0) {
      break;
    }
    uint64_t v18 = v21;
    BOOL v16 = v17 == 63;
    v17 += 7;
  }
  while (!v16);
  uint64_t v23 = 0;
  long long v24 = (char *)&v20[v21];
  *a2 = (char *)&v20[v21];
  *(void *)(a1 + 224) = v19;
  while (1)
  {
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    unint64_t v27 = 0;
    do
    {
      uint64_t v28 = v26 + 1;
      unsigned __int8 v29 = v24[v26];
      v27 |= (unint64_t)(v29 & 0x7F) << v25;
      if ((v29 & 0x80) == 0) {
        break;
      }
      uint64_t v26 = v28;
      BOOL v16 = v25 == 63;
      v25 += 7;
    }
    while (!v16);
    v24 += v28;
    *a2 = v24;
    if (v27)
    {
      if (*(void *)(a1 + 232) <= v27) {
        break;
      }
    }
    *(void *)(a1 + 8 * v23++ + 8) = v27;
    if (v23 == 16) {
      return *(void *)(a1 + 224) >= *(void *)(a1 + 232);
    }
  }
  int v31 = *__error();
  uint64_t v32 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
  {
    uint64_t v36 = *(void *)(a1 + 232);
    int v38 = 136316162;
    uint64_t v39 = "_storeageSetFreeListHead";
    __int16 v40 = 1024;
    int v41 = 200;
    __int16 v42 = 1024;
    int v43 = v23;
    __int16 v44 = 2048;
    unint64_t v45 = v27;
    __int16 v46 = 2048;
    uint64_t v47 = v36;
    _os_log_error_impl(&dword_1BD672000, v32, OS_LOG_TYPE_ERROR, "%s:%d: %d: offset(%lld) < freeRegion (%lld)", (uint8_t *)&v38, 0x2Cu);
  }
  *__error() = v31;
LABEL_31:
  int v33 = *__error();
  unint64_t v34 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
  {
    int v38 = 136315394;
    uint64_t v39 = "storageHeaderRestore";
    __int16 v40 = 1024;
    int v41 = 357;
    _os_log_error_impl(&dword_1BD672000, v34, OS_LOG_TYPE_ERROR, "%s:%d: invalid storage data", (uint8_t *)&v38, 0x12u);
  }
  uint64_t v35 = __error();
  BOOL result = 0;
  *uint64_t v35 = v33;
  return result;
}

BOOL storageInit(uint64_t a1, off_t a2, unint64_t a3, uint64_t a4, int a5, int a6, char a7, int a8, void *aBlock)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    char v11 = a5;
    *(_DWORD *)a1 = a8;
    if (a5)
    {
      *(_DWORD *)(a1 + 196) = 0;
      *(_OWORD *)(a1 + 180) = 0u;
      *(_OWORD *)(a1 + 164) = 0u;
      *(_OWORD *)(a1 + 148) = 0u;
      *(_OWORD *)(a1 + 132) = 0u;
      *(_OWORD *)(a1 + 116) = 0u;
      *(_OWORD *)(a1 + 100) = 0u;
      *(_OWORD *)(a1 + 84) = 0u;
      *(_OWORD *)(a1 + 68) = 0u;
      *(_OWORD *)(a1 + 52) = 0u;
      *(_OWORD *)(a1 + 36) = 0u;
      *(_OWORD *)(a1 + 20) = 0u;
      *(_OWORD *)(a1 + 4) = 0u;
    }
    else
    {
      memset(&v26, 0, sizeof(v26));
      int v20 = fd_stat(a4, &v26);
      st_std::string::size_type size = *(void *)(a1 + 224);
      if (!st_size)
      {
        st_std::string::size_type size = v26.st_size;
        if (v20) {
          st_std::string::size_type size = a2;
        }
        *(_DWORD *)(a1 + 4) = 0;
      }
      a2 = st_size;
    }
    *(void *)(a1 + 216) = a4;
    *(unsigned char *)(a1 + 252) = a7;
    *(void *)(a1 + 224) = a2;
    *(_DWORD *)(a1 + 248) = 1;
    *(unsigned char *)(a1 + 253) = 0;
    if (aBlock) {
      unsigned __int8 v22 = _Block_copy(aBlock);
    }
    else {
      unsigned __int8 v22 = 0;
    }
    *(void *)(a1 + 256) = v22;
    *(unsigned char *)(a1 + 264) = 26;
    bzero((void *)(a1 + 272), 0x1000uLL);
    if (!*(void *)(a1 + 232))
    {
      uint64_t v23 = 8;
      if (a3 > 8) {
        uint64_t v23 = a3;
      }
      *(void *)(a1 + 232) = v23;
      *(void *)(a1 + 240) = v23;
    }
    *(_DWORD *)(a1 + 208) = a6;
    long long v24 = malloc_type_malloc(0xD0uLL, 0x1020040167D79A3uLL);
    *(void *)(a1 + 4408) = v24;
    _OWORD *v24 = 0u;
    v24[1] = 0u;
    int v24[2] = 0u;
    void v24[3] = 0u;
    uint8_t v24[4] = 0u;
    v24[5] = 0u;
    v24[6] = 0u;
    v24[7] = 0u;
    v24[8] = 0u;
    v24[9] = 0u;
    v24[10] = 0u;
    v24[11] = 0u;
    v24[12] = 0u;
    pthread_rwlock_init(*(pthread_rwlock_t **)(a1 + 4408), 0);
    *(unsigned char *)(a1 + 252) = a7;
    *(unsigned char *)(a1 + 254) = 0;
    *(_DWORD *)(a1 + 4400) = 0;
    _windowsMapInit(a1 + 216, 0);
    if (v11)
    {
      if (a7) {
        return 1;
      }
      fd_truncate(a4, 0);
      unint64_t v25 = *(void *)(a1 + 224);
    }
    else
    {
      unint64_t v25 = *(void *)(a1 + 224);
      if (*(void *)(a1 + 232) > v25) {
        return 0;
      }
      if (a7) {
        return 1;
      }
    }
    return !fd_truncate(a4, v25);
  }
  int v16 = *__error();
  uint64_t v17 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    v26.dev_t st_dev = 136315394;
    *(void *)&v26.st_mode = "storageInit";
    WORD2(v26.st_ino) = 1024;
    *(_DWORD *)((char *)&v26.st_ino + 6) = 400;
    _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: storageInit - inFdPtr == NULL", (uint8_t *)&v26, 0x12u);
  }
  uint64_t v18 = __error();
  BOOL result = 0;
  *uint64_t v18 = v16;
  return result;
}

void storageClose(uint64_t a1)
{
  uint64_t v2 = a1 + 216;
  storageWindowsUnmap(a1 + 216);
  storageWindowsClose(v2);
  uint64_t v3 = *(pthread_rwlock_t **)(a1 + 4408);
  if (v3)
  {
    pthread_rwlock_wrlock(v3);
    _release_read_window(&availableReaders, *(void **)(*(void *)(a1 + 4408) + 200));
    pthread_rwlock_unlock(*(pthread_rwlock_t **)(a1 + 4408));
    pthread_rwlock_destroy(*(pthread_rwlock_t **)(a1 + 4408));
    free(*(void **)(a1 + 4408));
    *(void *)(a1 + 4408) = 0;
  }
  *(unsigned char *)(a1 + 4372) = 1;
}

uint64_t storageSyncPages(uint64_t a1, uint64_t a2, size_t a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = (a3 + *(void *)(a1 + 232) - 1) / a3;
  double Current = CFAbsoluteTimeGetCurrent();
  if (!*(unsigned char *)(a1 + 252) && *(unsigned char *)(a1 + 254) && *(int *)(a1 + 248) >= 1)
  {
    uint64_t v14 = 0;
    do
      storageWindowSync(*(void *)(a1 + 272 + 8 * v14++), 0);
    while (v14 < *(int *)(a1 + 248));
  }
  if (!v6)
  {
    int v10 = 0;
    uint64_t v13 = 0;
    goto LABEL_26;
  }
  uint64_t v8 = 0;
  CFIndex v9 = 0;
  int v10 = 0;
  while (1)
  {
    if (*(void *)a2 <= v9 || !CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a2 + 16), v9))
    {
      uint64_t v13 = 0;
      goto LABEL_14;
    }
    uint64_t v11 = fd_mmap(*(void *)(a1 + 216));
    if (v11 == -1) {
      break;
    }
    uint64_t v12 = (void *)v11;
    fd_system_status_stall_if_busy();
    if (msync(v12, a3, 16)) {
      uint64_t v13 = *__error();
    }
    else {
      uint64_t v13 = 0;
    }
    if (munmap(v12, a3)) {
      uint64_t v13 = *__error();
    }
    ++v10;
    if (v13) {
      goto LABEL_26;
    }
LABEL_14:
    ++v9;
    v8 += a3;
    if (v9 >= (unint64_t)v6) {
      goto LABEL_26;
    }
  }
  uint64_t v13 = *__error();
  bzero(buf, 0x400uLL);
  unsigned __int8 v15 = fd_realpath(*(_DWORD **)(a1 + 216), buf);
  if (!v15) {
    unsigned __int8 v15 = fd_name(*(void *)(a1 + 216), (char *)buf, 0x400uLL);
  }
  int v16 = *__error();
  uint64_t v17 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    uint64_t v23 = "";
    int v24 = 136316418;
    unint64_t v25 = "storageSyncPages";
    __int16 v26 = 1024;
    if (v15) {
      uint64_t v23 = v15;
    }
    int v27 = 553;
    __int16 v28 = 1024;
    int v29 = a3;
    __int16 v30 = 2048;
    uint64_t v31 = v8;
    __int16 v32 = 1024;
    int v33 = v13;
    __int16 v34 = 2080;
    uint64_t v35 = v23;
    _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: mmap(%d, %lld) err:%d, %s", (uint8_t *)&v24, 0x32u);
  }
  *__error() = v16;
LABEL_26:
  int v18 = *__error();
  uint64_t v19 = _SILogForLogForCategory(10);
  os_log_type_t v20 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v19, v20))
  {
    float v21 = CFAbsoluteTimeGetCurrent() - Current;
    *(_DWORD *)std::string buf = 67109632;
    int v37 = v6;
    __int16 v38 = 1024;
    int v39 = v10;
    __int16 v40 = 2048;
    double v41 = v21;
    _os_log_impl(&dword_1BD672000, v19, v20, "sync pages (%d, %d) took %f seconds", buf, 0x18u);
  }
  *__error() = v18;
  return v13;
}

uint64_t storageInvalidate(uint64_t result, unint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(result + 248);
  if (v3 >= 1)
  {
    uint64_t v6 = result;
    uint64_t v7 = 0;
    unint64_t v8 = a3 + a2;
    uint64_t v9 = result + 272;
    do
    {
      int v10 = *(void **)(v9 + 8 * v7);
      if (v10)
      {
        unint64_t v11 = v10[2];
        BOOL v12 = a2 >= v11;
        unint64_t v13 = a2 - v11;
        if (v12)
        {
          unint64_t v14 = v10[3];
          uint64_t v15 = v10[1];
          if (v14 <= v8) {
            unint64_t v16 = 0;
          }
          else {
            unint64_t v16 = v13;
          }
          BOOL result = sync_invalidate_mapping((char *)(v15 + v16), a3);
          int v3 = *(_DWORD *)(v6 + 248);
        }
      }
      ++v7;
    }
    while (v7 < v3);
  }
  return result;
}

uint64_t storageDeactivateAll(uint64_t result, int a2)
{
  if (*(int *)(result + 248) >= 1)
  {
    uint64_t v3 = result;
    uint64_t v4 = 0;
    uint64_t v5 = result + 272;
    do
    {
      uint64_t v6 = *(void *)(v5 + 8 * v4);
      if (v6)
      {
        uint64_t v7 = *(void **)(v6 + 8);
        if (v7)
        {
          size_t v8 = *(void *)(v6 + 24) - *(void *)(v6 + 16);
          fd_system_status_stall_if_busy();
          if (a2)
          {
            msync(v7, v8, 16);
            BOOL result = madvise(*(void **)(v6 + 8), *(void *)(v6 + 24) - *(void *)(v6 + 16), 4);
          }
          else
          {
            BOOL result = msync(v7, v8, 8);
          }
        }
      }
      ++v4;
    }
    while (v4 < *(int *)(v3 + 248));
  }
  return result;
}

uint64_t storageAllocOffsetFromEnd(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = *(int *)(a1 + 4);
  if (a2 <= v3)
  {
    char v8 = 0;
  }
  else
  {
    unsigned int v4 = __clz(a2 - v3);
    BOOL v6 = ((a2 - v3) & (a2 - v3 - 1)) != 0 || a2 == v3;
    int v7 = v6 - v4;
    if (v7 <= -29) {
      char v8 = 0;
    }
    else {
      char v8 = v7 + 28;
    }
  }
  int v9 = 8 << v8;
  unint64_t v11 = *(void *)(a1 + 224);
  uint64_t result = *(void *)(a1 + 232);
  if (v3 + result + (16 << v8) + 8 < v11) {
    goto LABEL_13;
  }
  if (_storageExpand(a1, v9))
  {
    uint64_t result = *(void *)(a1 + 232);
LABEL_13:
    *(void *)(a1 + 232) = v3 + v9 + result;
    return result;
  }
  return 0;
}

uint64_t _storageExpand(uint64_t a1, int a2)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = *(void *)(a1 + 224);
  unint64_t v4 = (2 * a2) + *(void *)(a1 + 232) + *(int *)(a1 + 4) + 8;
  if (v3 >> 30)
  {
    LODWORD(v5) = 0;
    do
      uint64_t v5 = (v5 + 0x40000000);
    while (v4 >= v3 + v5);
  }
  else
  {
    if (v3) {
      unsigned int v6 = *(void *)(a1 + 224);
    }
    else {
      unsigned int v6 = 4096;
    }
    do
    {
      LODWORD(v5) = v6;
      unint64_t v7 = v3 + v6;
      v6 *= 2;
    }
    while (v4 >= v7);
  }
  int v8 = *(_DWORD *)(a1 + 248);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 272);
    if (v9)
    {
      if (*(void *)(v9 + 8) && v8 >= 1)
      {
        uint64_t v11 = 0;
        do
          storageWindowSync(*(void *)(a1 + 272 + 8 * v11++), 1);
        while (v11 < *(int *)(a1 + 248));
      }
    }
  }
  *__error() = 0;
  if (v5 && (unint64_t v12 = *(void *)(a1 + 224) + v5, v12 >= v4))
  {
    while (fd_truncate(*(void *)(a1 + 216), v12) == -1)
    {
      int v13 = *__error();
      unint64_t v14 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        int v15 = *__error();
        *(_DWORD *)std::string buf = 136315906;
        __int16 v34 = "_storageExpand";
        __int16 v35 = 1024;
        int v36 = 706;
        __int16 v37 = 2048;
        unint64_t v38 = v12;
        __int16 v39 = 1024;
        int v40 = v15;
        _os_log_error_impl(&dword_1BD672000, v14, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate(%lld) error:%d", buf, 0x22u);
      }
      *__error() = v13;
      if (v5 >= 2)
      {
        uint64_t v5 = v5 >> 1;
        unint64_t v12 = *(void *)(a1 + 224) + v5;
        if (v12 >= v4) {
          continue;
        }
      }
      goto LABEL_24;
    }
    *(void *)(a1 + 224) = v12;
    if (*(_DWORD *)(a1 + 248) == 1 && !*(unsigned char *)(a1 + 253)) {
      storageWindowRelease((atomic_uint **)(a1 + 272));
    }
    pthread_rwlock_wrlock(*(pthread_rwlock_t **)(a1 + 4408));
    os_log_type_t v20 = *(pthread_rwlock_t **)(a1 + 4408);
    sig = (void *)v20[1].__sig;
    v20[1].__sig = 0;
    pthread_rwlock_unlock(v20);
    _release_read_window(&availableReaders, sig);
    return 1;
  }
  else
  {
LABEL_24:
    bzero(buf, 0x400uLL);
    int v16 = *__error();
    uint64_t v17 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      unsigned __int8 v22 = fd_realpath(*(_DWORD **)(a1 + 216), buf);
      if (v22) {
        uint64_t v23 = v22;
      }
      else {
        uint64_t v23 = "";
      }
      int v24 = *__error();
      *(_DWORD *)unint64_t v25 = 136315906;
      __int16 v26 = "_storageExpand";
      __int16 v27 = 1024;
      int v28 = 702;
      __int16 v29 = 2080;
      __int16 v30 = v23;
      __int16 v31 = 1024;
      int v32 = v24;
      _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: _storageExpand %s error:%d", v25, 0x22u);
    }
    int v18 = __error();
    uint64_t result = 0;
    *int v18 = v16;
  }
  return result;
}

uint64_t storageTruncate(uint64_t *a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = fd_truncate(a1[27], a1[29]);
  if (v2 == -1)
  {
    uint64_t v3 = *__error();
    int v4 = *__error();
    uint64_t v5 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v7 = 136315650;
      int v8 = "storageTruncate";
      __int16 v9 = 1024;
      int v10 = 836;
      __int16 v11 = 1024;
      int v12 = v3;
      _os_log_error_impl(&dword_1BD672000, v5, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate error %d", (uint8_t *)&v7, 0x18u);
    }
    *__error() = v4;
  }
  else
  {
    uint64_t v3 = v2;
    a1[28] = a1[29];
  }
  return v3;
}

uint64_t storageTruncateAndMakeReadOnly(uint64_t a1)
{
  uint64_t result = storageTruncate((uint64_t *)a1);
  if (!result)
  {
    *(unsigned char *)(a1 + 252) = 1;
    uint64_t v3 = *(unsigned int *)(a1 + 248);
    if ((int)v3 >= 1)
    {
      uint64_t v4 = a1 + 272;
      do
      {
        if (*(void *)v4) {
          *(unsigned char *)(*(void *)v4 + 40) = 1;
        }
        v4 += 8;
        --v3;
      }
      while (v3);
    }
    uint64_t v5 = *(void *)(a1 + 216);
    return fd_make_readonly(v5);
  }
  return result;
}

unint64_t storageAllocOffset(uint64_t a1, unsigned int a2, uint64_t a3, int *a4)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(unsigned int *)(a1 + 4);
  unsigned int v8 = a2 - v7;
  if (a2 <= v7)
  {
    unsigned int v14 = 0;
    unsigned int v13 = 8;
  }
  else
  {
    unsigned int v9 = __clz(v8);
    BOOL v11 = (v8 & (v8 - 1)) != 0 || a2 == v7;
    int v12 = v11 - v9;
    unsigned int v13 = 8;
    if (v12 < -28)
    {
      unsigned int v14 = 0;
    }
    else
    {
      unsigned int v14 = v12 + 28;
      if ((v12 + 28) >= 0x18)
      {
        __int16 v31 = __si_assert_copy_extra(0);
        __int16 v27 = v31;
        int v32 = "";
        if (v31) {
          int v32 = v31;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 866, "idx < (24)", v32);
        goto LABEL_48;
      }
      unsigned int v13 = 8 << v14;
    }
  }
  if (v13 < v8)
  {
    __int16 v26 = __si_assert_copy_extra(0);
    __int16 v27 = v26;
    int v28 = "";
    if (v26) {
      int v28 = v26;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 867, "((uint32_t)8<<idx) >= inSize - baseSize", v28);
    goto LABEL_48;
  }
  if (v13 + v7 < a2)
  {
    __int16 v29 = __si_assert_copy_extra(0);
    __int16 v27 = v29;
    __int16 v30 = "";
    if (v29) {
      __int16 v30 = v29;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 868, "rsize+baseSize >= inSize", v30);
    goto LABEL_48;
  }
  *a4 = 0;
  uint64_t v15 = a1 + 8 * v14;
  unint64_t v18 = *(void *)(v15 + 8);
  uint64_t v17 = (unint64_t *)(v15 + 8);
  unint64_t v16 = v18;
  if (!v18)
  {
    unint64_t v16 = takeBuddyPage_3377(a1, v14);
    if (!v16)
    {
      unint64_t v16 = *(void *)(a1 + 232);
      if (v7 + (16 << v14) + v16 + 8 >= *(void *)(a1 + 224))
      {
        if (!_storageExpand(a1, v13)) {
          return 0;
        }
        unint64_t v16 = *(void *)(a1 + 232);
      }
      *(void *)(a1 + 232) = v7 + v13 + v16;
    }
    goto LABEL_23;
  }
  if (v16 >= *(void *)(a1 + 232))
  {
    __int16 v35 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
    int v36 = v35;
    __int16 v37 = "";
    if (v35) {
      __int16 v37 = v35;
    }
    __message_assert("%s:%u: failed assertion '%s' %s offset: 0x%lld, freeRegion: 0x%lld", "storage.c", 192, "(head==0) || (head < storage->_windows._freeRegion)", v37, v16, *(void *)(a1 + 232));
    free(v36);
    if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
      goto LABEL_49;
    }
    goto LABEL_44;
  }
  uint64_t v19 = (unint64_t *)storageResolvePtr(a1, v16, 8, 1);
  if (!v19)
  {
    __int16 v39 = __si_assert_copy_extra(0);
    __int16 v27 = v39;
    int v40 = "";
    if (v39) {
      int v40 = v39;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 874, "ptr", v40);
    goto LABEL_48;
  }
  unint64_t v20 = *v19;
  if (!*v19 || *(void *)(a1 + 232) > v20)
  {
    unint64_t *v17 = v20;
    uint64_t v21 = *a4;
    *a4 = v21 + 1;
    *(void *)(a3 + 8 * v21) = v16;
    *(void *)storageResolvePtr(a1, v16, 8, 1) = 0;
LABEL_23:
    if (v16 < *(void *)(a1 + 232)) {
      return v16;
    }
    int v33 = __si_assert_copy_extra(0);
    __int16 v27 = v33;
    __int16 v34 = "";
    if (v33) {
      __int16 v34 = v33;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 920, "result < inStorage->_windows._freeRegion", v34);
LABEL_48:
    free(v27);
    if (__valid_fs(-1))
    {
LABEL_49:
      uint64_t v38 = 2989;
LABEL_50:
      *(_DWORD *)uint64_t v38 = -559038737;
      abort();
    }
LABEL_44:
    uint64_t v38 = 3072;
    goto LABEL_50;
  }
  int v23 = *__error();
  int v24 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    uint64_t v25 = *(void *)(a1 + 232);
    *(_DWORD *)std::string buf = 136316162;
    uint64_t v42 = "_storeageSetFreeListHead";
    __int16 v43 = 1024;
    int v44 = 200;
    __int16 v45 = 1024;
    unsigned int v46 = v14;
    __int16 v47 = 2048;
    unint64_t v48 = v20;
    __int16 v49 = 2048;
    uint64_t v50 = v25;
    _os_log_error_impl(&dword_1BD672000, v24, OS_LOG_TYPE_ERROR, "%s:%d: %d: offset(%lld) < freeRegion (%lld)", buf, 0x2Cu);
  }
  unint64_t v16 = 0;
  *__error() = v23;
  return v16;
}

unint64_t takeBuddyPage_3377(uint64_t a1, unsigned int a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (a2 > 0x16 || *(_DWORD *)(a1 + 4) || *(void *)(a1 + 200) <= (unint64_t)a2) {
    return 0;
  }
  unsigned int v4 = 8 << a2;
  unsigned int v5 = a2 + 1;
  uint64_t v6 = a1 + 8 * (a2 + 1);
  unint64_t v9 = *(void *)(v6 + 8);
  unsigned int v8 = (unint64_t *)(v6 + 8);
  unint64_t v7 = v9;
  if (v9)
  {
    if (v7 >= *(void *)(a1 + 232))
    {
      unint64_t v20 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
      uint64_t v21 = v20;
      unsigned __int8 v22 = "";
      if (v20) {
        unsigned __int8 v22 = v20;
      }
      __message_assert("%s:%u: failed assertion '%s' %s offset: 0x%lld, freeRegion: 0x%lld", "storage.c", 192, "(head==0) || (head < storage->_windows._freeRegion)", v22, v7, *(void *)(a1 + 232));
      free(v21);
      if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
        uint64_t v23 = 2989;
      }
      else {
        uint64_t v23 = 3072;
      }
      *(_DWORD *)uint64_t v23 = -559038737;
      abort();
    }
    int v10 = (void *)storageResolvePtr(a1, v7, 8, 1);
    if (v10)
    {
      BOOL v11 = v10;
      unint64_t v12 = *v10;
      if (*v10 && *(void *)(a1 + 232) <= v12)
      {
        uint64_t v25 = *v10;
        int v26 = *__error();
        __int16 v27 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          uint64_t v28 = *(void *)(a1 + 232);
          *(_DWORD *)std::string buf = 136316162;
          __int16 v34 = "_storeageSetFreeListHead";
          __int16 v35 = 1024;
          int v36 = 200;
          __int16 v37 = 1024;
          unsigned int v38 = v5;
          __int16 v39 = 2048;
          uint64_t v40 = v25;
          __int16 v41 = 2048;
          uint64_t v42 = v28;
          _os_log_error_impl(&dword_1BD672000, v27, OS_LOG_TYPE_ERROR, "%s:%d: %d: offset(%lld) < freeRegion (%lld)", buf, 0x2Cu);
        }
        *__error() = v26;
        __int16 v29 = __si_assert_copy_extra(0);
        __int16 v30 = v29;
        __int16 v31 = "";
        if (v29) {
          __int16 v31 = v29;
        }
        __message_assert("%s:%u: failed assertion '%s' %s free idx %d offset %lld bs %d bl %lld", "storage.c", 634, "result", v31, a2, *v11, *(_DWORD *)(a1 + 4), *(void *)(a1 + 200));
        free(v30);
        if (__valid_fs(-1)) {
          uint64_t v32 = 2989;
        }
        else {
          uint64_t v32 = 3072;
        }
        *(_DWORD *)uint64_t v32 = -559038737;
        abort();
      }
      *unsigned int v8 = v12;
      void *v10 = 0;
      if ((_storeageSetFreeListHead(a1, a2, v7 + v4) & 1) == 0)
      {
        unsigned int v13 = __si_assert_copy_extra(0);
        unsigned int v14 = v13;
        uint64_t v15 = "";
        if (v13) {
          uint64_t v15 = v13;
        }
        __message_assert("%s:%u: failed assertion '%s' %s clear idx %d offset %lld bs %d bl %lld", "storage.c", 640, "result", v15, a2, *v11, *(_DWORD *)(a1 + 4), *(void *)(a1 + 200));
        unint64_t v16 = v14;
LABEL_25:
        free(v16);
        if (__valid_fs(-1)) {
          uint64_t v24 = 2989;
        }
        else {
          uint64_t v24 = 3072;
        }
        *(_DWORD *)uint64_t v24 = -559038737;
        abort();
      }
      return v7;
    }
    uint64_t v19 = __si_assert_copy_extra(0);
    __message_assert("%s:%u: failed assertion '%s' %s get node %lld idx %d bs %d bl %lld", "storage.c");
LABEL_24:
    unint64_t v16 = v19;
    goto LABEL_25;
  }
  uint64_t v18 = takeBuddyPage_3377(a1, a2 + 1);
  unint64_t v7 = v18;
  if (!v18)
  {
    *(void *)(a1 + 200) = a2;
    return v7;
  }
  if ((_storeageSetFreeListHead(a1, a2, v18 + v4) & 1) == 0)
  {
    uint64_t v19 = __si_assert_copy_extra(0);
    __message_assert("%s:%u: failed assertion '%s' %s free idx %d node %lld size %d bs %d bl %lld", "storage.c", 643);
    goto LABEL_24;
  }
  return v7;
}

uint64_t _storeageSetFreeListHead(uint64_t a1, unsigned int a2, unint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  unint64_t v16 = a3;
  if (a3 && *(void *)(a1 + 232) <= a3)
  {
    int v8 = *__error();
    unint64_t v9 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = *(void *)(a1 + 232);
      *(_DWORD *)std::string buf = 136316162;
      uint64_t v18 = "_storeageSetFreeListHead";
      __int16 v19 = 1024;
      int v20 = 200;
      __int16 v21 = 1024;
      unsigned int v22 = a2;
      __int16 v23 = 2048;
      unint64_t v24 = a3;
      __int16 v25 = 2048;
      uint64_t v26 = v11;
      _os_log_error_impl(&dword_1BD672000, v9, OS_LOG_TYPE_ERROR, "%s:%d: %d: offset(%lld) < freeRegion (%lld)", buf, 0x2Cu);
    }
    uint64_t v7 = 0;
    *__error() = v8;
  }
  else
  {
    uint64_t v6 = (void *)storageResolvePtr(a1, a3, 8, 1);
    if (!v6)
    {
      unint64_t v12 = __si_assert_copy_extra(0);
      unsigned int v13 = v12;
      unsigned int v14 = "";
      if (v12) {
        unsigned int v14 = v12;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 208, "ptr", v14);
      free(v13);
      if (__valid_fs(-1)) {
        uint64_t v15 = 2989;
      }
      else {
        uint64_t v15 = 3072;
      }
      *(_DWORD *)uint64_t v15 = -559038737;
      abort();
    }
    *uint64_t v6 = 0;
    uint64_t v7 = 1;
    dirtyStorageOffsets(a1, &v16, 1);
    *(void *)(a1 + 8 * a2 + 8) = a3;
  }
  return v7;
}

void dirtyStorageOffsets(uint64_t a1, unint64_t *a2, int a3)
{
  if (a3 >= 1)
  {
    unsigned int v4 = (void *)(a1 + 4376);
    uint64_t v5 = a3;
    do
    {
      unint64_t v7 = *a2++;
      unint64_t v6 = v7;
      bit_vector_set_3386(v4, (v7 >> 17));
      if ((v7 >> 17) != (v7 + 8) >> 17) {
        bit_vector_set_3386(v4, (v6 >> 17) + 1);
      }
      --v5;
    }
    while (v5);
  }
}

void bit_vector_set_3386(void *a1, CFIndex idx)
{
  CFIndex v4 = a1[1];
  if (v4 <= idx)
  {
    if (v4) {
      CFIndex v6 = a1[1];
    }
    else {
      CFIndex v6 = 32;
    }
    while (1)
    {
      v6 *= 2;
      if (v6 > idx) {
        break;
      }
      if (v6 <= v4)
      {
        unint64_t v7 = __si_assert_copy_extra(0);
        int v8 = v7;
        unint64_t v9 = "";
        if (v7) {
          unint64_t v9 = v7;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v9);
        goto LABEL_15;
      }
    }
    CFBitVectorRef v11 = (const __CFBitVector *)a1[2];
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (v11) {
      CFMutableStringRef MutableCopy = CFBitVectorCreateMutableCopy(v12, v6, v11);
    }
    else {
      CFMutableStringRef MutableCopy = CFBitVectorCreateMutable(v12, v6);
    }
    unsigned int v14 = MutableCopy;
    if (!MutableCopy)
    {
      unint64_t v16 = __si_assert_copy_extra(0);
      int v8 = v16;
      uint64_t v17 = "";
      if (v16) {
        uint64_t v17 = v16;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v17);
LABEL_15:
      free(v8);
      if (__valid_fs(-1)) {
        uint64_t v10 = 2989;
      }
      else {
        uint64_t v10 = 3072;
      }
      *(_DWORD *)uint64_t v10 = -559038737;
      abort();
    }
    CFBitVectorSetCount(MutableCopy, v6);
    uint64_t v15 = (const void *)a1[2];
    if (v15) {
      CFRelease(v15);
    }
    a1[1] = v6;
    a1[2] = v14;
  }
  if (*a1 <= idx) {
    *a1 = idx + 1;
  }
  uint64_t v5 = (__CFBitVector *)a1[2];
  CFBitVectorSetBitAtIndex(v5, idx, 1u);
}

void storageFreeOffset(uint64_t a1, unint64_t a2, unsigned int a3)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = *(_DWORD *)(a1 + 4);
  BOOL v6 = a3 >= v5;
  unsigned int v7 = a3 - v5;
  if (v7 != 0 && v6)
  {
    unsigned int v8 = __clz(v7);
    BOOL v10 = (v7 & (v7 - 1)) != 0 || v7 == 0;
    int v11 = v10 - v8;
    unsigned int v13 = 8;
    if (v11 < -28)
    {
      unsigned int v12 = 0;
    }
    else
    {
      unsigned int v12 = v11 + 28;
      if ((v11 + 28) >= 0x18)
      {
        __int16 v29 = __si_assert_copy_extra(0);
        uint64_t v27 = v29;
        __int16 v30 = "";
        if (v29) {
          __int16 v30 = v29;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 935, "idx < (24)", v30);
LABEL_42:
        free(v27);
        if (!__valid_fs(-1))
        {
LABEL_47:
          uint64_t v33 = 3072;
LABEL_48:
          *(_DWORD *)uint64_t v33 = -559038737;
          abort();
        }
LABEL_43:
        uint64_t v33 = 2989;
        goto LABEL_48;
      }
      unsigned int v13 = 8 << v12;
    }
  }
  else
  {
    unsigned int v12 = 0;
    unsigned int v13 = 8;
  }
  if (v7 > v13)
  {
    unsigned int v22 = __si_assert_copy_extra(0);
    __int16 v23 = v22;
    unint64_t v24 = "";
    if (v22) {
      unint64_t v24 = v22;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 936, "inSize - baseSize <= rsize", v24);
LABEL_28:
    free(v23);
    if (__valid_fs(-1)) {
      uint64_t v25 = 2989;
    }
    else {
      uint64_t v25 = 3072;
    }
    *(_DWORD *)uint64_t v25 = -559038737;
    abort();
  }
  if (*(void *)(a1 + 224) <= a2)
  {
    uint64_t v26 = __si_assert_copy_extra(0);
    uint64_t v27 = v26;
    uint64_t v28 = "";
    if (v26) {
      uint64_t v28 = v26;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 937, "inOffset < inStorage->_windows._size", v28);
    goto LABEL_42;
  }
  size_t v14 = v13;
  if (a2 + v13 == *(void *)(a1 + 232))
  {
    uint64_t v15 = (void *)storageResolvePtr(a1, a2, a3, 1);
    bzero(v15, v14);
    *(void *)(a1 + 232) = a2;
    return;
  }
  unint64_t v16 = (unint64_t *)storageResolvePtr(a1, a2, v13, 1);
  if (!v16)
  {
    __int16 v31 = __si_assert_copy_extra(0);
    uint64_t v27 = v31;
    uint64_t v32 = "";
    if (v31) {
      uint64_t v32 = v31;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 949, "ptr", v32);
    goto LABEL_42;
  }
  uint64_t v17 = v16;
  bzero(v16, v14);
  if (*(void *)(a1 + 200) < (unint64_t)v12) {
    *(void *)(a1 + 200) = v12;
  }
  uint64_t v18 = a1 + 8 * v12;
  unint64_t v21 = *(void *)(v18 + 8);
  __int16 v19 = (unint64_t *)(v18 + 8);
  unint64_t v20 = v21;
  if (v21 && v20 >= *(void *)(a1 + 232))
  {
    __int16 v34 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
    __int16 v35 = v34;
    int v36 = "";
    if (v34) {
      int v36 = v34;
    }
    __message_assert("%s:%u: failed assertion '%s' %s offset: 0x%lld, freeRegion: 0x%lld", "storage.c", 192, "(head==0) || (head < storage->_windows._freeRegion)", v36, v20, *(void *)(a1 + 232));
    free(v35);
    if (!__valid_fsp(*(_DWORD **)(a1 + 216))) {
      goto LABEL_47;
    }
    goto LABEL_43;
  }
  unint64_t v42 = v20;
  unint64_t *v17 = v20;
  dirtyStorageOffsets(a1, &v42, 1);
  if (a2 && *(void *)(a1 + 232) <= a2)
  {
    int v37 = *__error();
    unsigned int v38 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      uint64_t v39 = *(void *)(a1 + 232);
      *(_DWORD *)std::string buf = 136316162;
      int v44 = "_storeageSetFreeListHead";
      __int16 v45 = 1024;
      int v46 = 200;
      __int16 v47 = 1024;
      unsigned int v48 = v12;
      __int16 v49 = 2048;
      unint64_t v50 = a2;
      __int16 v51 = 2048;
      uint64_t v52 = v39;
      _os_log_error_impl(&dword_1BD672000, v38, OS_LOG_TYPE_ERROR, "%s:%d: %d: offset(%lld) < freeRegion (%lld)", buf, 0x2Cu);
    }
    *__error() = v37;
    uint64_t v40 = __si_assert_copy_extra(0);
    __int16 v23 = v40;
    __int16 v41 = "";
    if (v40) {
      __int16 v41 = v40;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 960, "success", v41);
    goto LABEL_28;
  }
  unint64_t *v19 = a2;
}

uint64_t storageExtendOffset(uint64_t a1, unint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  unint64_t v7 = a2 + a3;
  unint64_t v8 = *(void *)(a1 + 232);
  if (v7 == v8)
  {
    unint64_t v9 = a2 + a4;
    if (v9 <= *(void *)(a1 + 224))
    {
      *(void *)(a1 + 232) = v9;
      goto LABEL_25;
    }
    return 0;
  }
  if (a4 > 2 * a3) {
    return 0;
  }
  unsigned int v10 = *(_DWORD *)(a1 + 4);
  BOOL v21 = a3 >= v10;
  unsigned int v11 = a3 - v10;
  if (v11 != 0
    && v21
    && ((v12 = __clz(v11), (v11 & (v11 - 1)) == 0) ? (BOOL v13 = v11 == 0) : (BOOL v13 = 1),
        !v13 ? (int v14 = 0) : (int v14 = 1),
        int v15 = v14 - v12,
        v15 > -29))
  {
    unsigned int v16 = v15 + 28;
  }
  else
  {
    unsigned int v16 = 0;
  }
  uint64_t v17 = a1 + 8 * v16;
  unint64_t v20 = *(void *)(v17 + 8);
  __int16 v19 = (unint64_t *)(v17 + 8);
  unint64_t v18 = v20;
  if (v20) {
    BOOL v21 = v18 >= v8;
  }
  else {
    BOOL v21 = 0;
  }
  if (v21)
  {
    uint64_t v30 = v18;
    __int16 v31 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
    uint64_t v32 = v31;
    uint64_t v33 = "";
    if (v31) {
      uint64_t v33 = v31;
    }
    __message_assert("%s:%u: failed assertion '%s' %s offset: 0x%lld, freeRegion: 0x%lld", "storage.c", 192, "(head==0) || (head < storage->_windows._freeRegion)", v33, v30, *(void *)(a1 + 232));
    free(v32);
    if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
      uint64_t v34 = 2989;
    }
    else {
      uint64_t v34 = 3072;
    }
    *(_DWORD *)uint64_t v34 = -559038737;
    abort();
  }
  if (v18 != v7) {
    return 0;
  }
  uint64_t result = _windowsGetPtr(a1 + 216, v7, a3);
  if (result)
  {
    unint64_t v23 = *(void *)result;
    if (*(void *)result && v8 <= v23)
    {
      uint64_t v35 = *(void *)result;
      int v36 = *__error();
      int v37 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        uint64_t v38 = *(void *)(a1 + 232);
        *(_DWORD *)std::string buf = 136316162;
        unint64_t v42 = "_storeageSetFreeListHead";
        __int16 v43 = 1024;
        int v44 = 200;
        __int16 v45 = 1024;
        unsigned int v46 = v16;
        __int16 v47 = 2048;
        uint64_t v48 = v35;
        __int16 v49 = 2048;
        uint64_t v50 = v38;
        _os_log_error_impl(&dword_1BD672000, v37, OS_LOG_TYPE_ERROR, "%s:%d: %d: offset(%lld) < freeRegion (%lld)", buf, 0x2Cu);
      }
      *__error() = v36;
      uint64_t v39 = __si_assert_copy_extra(0);
      uint64_t v25 = v39;
      uint64_t v40 = "";
      if (v39) {
        uint64_t v40 = v39;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 984, "result", v40);
      goto LABEL_36;
    }
    unint64_t *v19 = v23;
    unint64_t v9 = *(void *)(a1 + 232);
LABEL_25:
    if (v9 <= a2)
    {
      unint64_t v24 = __si_assert_copy_extra(0);
      uint64_t v25 = v24;
      uint64_t v26 = "";
      if (v24) {
        uint64_t v26 = v24;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 990, "inOffset < inStorage->_windows._freeRegion", v26);
    }
    else
    {
      if (a2 + a4 <= v9) {
        return 1;
      }
      uint64_t v27 = __si_assert_copy_extra(0);
      uint64_t v25 = v27;
      uint64_t v28 = "";
      if (v27) {
        uint64_t v28 = v27;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 991, "inOffset+inNewSize <= inStorage->_windows._freeRegion", v28);
    }
LABEL_36:
    free(v25);
    if (__valid_fs(-1)) {
      uint64_t v29 = 2989;
    }
    else {
      uint64_t v29 = 3072;
    }
    *(_DWORD *)uint64_t v29 = -559038737;
    abort();
  }
  return result;
}

unint64_t storageGrowOffset(uint64_t a1, unint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5, int *a6)
{
  v36[1] = *MEMORY[0x1E4F143B8];
  unsigned int v12 = *(_DWORD *)(a1 + 4);
  unsigned int v13 = a3 - v12;
  if (a3 <= v12)
  {
    unsigned int v18 = 0;
  }
  else
  {
    unsigned int v14 = __clz(v13);
    BOOL v16 = (v13 & (v13 - 1)) != 0 || a3 == v12;
    int v17 = v16 - v14;
    if (v17 <= -29) {
      unsigned int v18 = 0;
    }
    else {
      unsigned int v18 = v17 + 28;
    }
  }
  BOOL v19 = a4 >= v12;
  unsigned int v20 = a4 - v12;
  if (v20 != 0
    && v19
    && ((v21 = __clz(v20), (v20 & (v20 - 1)) == 0) ? (BOOL v22 = v20 == 0) : (BOOL v22 = 1),
        !v22 ? (int v23 = 0) : (int v23 = 1),
        int v24 = v23 - v21,
        v24 > -29))
  {
    unsigned int v25 = v24 + 28;
  }
  else
  {
    unsigned int v25 = 0;
  }
  if (v18 > v25)
  {
    uint64_t v32 = __si_assert_copy_extra(0);
    uint64_t v33 = v32;
    uint64_t v34 = "";
    if (v32) {
      uint64_t v34 = v32;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1002, "oldIdx <= newIdx", v34);
    free(v33);
    if (__valid_fs(-1)) {
      uint64_t v35 = 2989;
    }
    else {
      uint64_t v35 = 3072;
    }
    *(_DWORD *)uint64_t v35 = -559038737;
    abort();
  }
  if (v25 == v18) {
    return a2;
  }
  size_t v27 = a3;
  MEMORY[0x1F4188790](a1);
  uint64_t v28 = (const void *)storageResolvePtr(a1, a2, a3, 1);
  memcpy((char *)v36 - ((v27 + 15) & 0x1FFFFFFF0), v28, a3);
  storageFreeOffset(a1, a2, a3);
  unint64_t v26 = storageAllocOffset(a1, a4, a5, a6);
  if (v26)
  {
    uint64_t v29 = (void *)storageResolvePtr(a1, v26, a4, 1);
    memcpy(v29, (char *)v36 - ((v27 + 15) & 0x1FFFFFFF0), v27);
  }
  uint64_t v30 = *a6;
  *(void *)(a5 + 8 * v30) = a2;
  *a6 = v30 + 1;
  return v26;
}

uint64_t freeListVerify(uint64_t a1, int a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *(void *)(a1 + 8 * a2 + 8);
  if (v2)
  {
    if (v2 >= *(void *)(a1 + 232))
    {
      BOOL v16 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
      int v17 = v16;
      unsigned int v18 = "";
      if (v16) {
        unsigned int v18 = v16;
      }
      __message_assert("%s:%u: failed assertion '%s' %s offset: 0x%lld, freeRegion: 0x%lld", "storage.c", 192, "(head==0) || (head < storage->_windows._freeRegion)", v18, v2, *(void *)(a1 + 232));
      free(v17);
      if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
        uint64_t v19 = 2989;
      }
      else {
        uint64_t v19 = 3072;
      }
      *(_DWORD *)uint64_t v19 = -559038737;
      abort();
    }
    char v4 = 0;
    unint64_t v5 = *(void *)(a1 + 8 * a2 + 8);
    while (1)
    {
      uint64_t result = storageResolvePtr(a1, v5, 8, 1);
      if (!result) {
        return result;
      }
      unint64_t v5 = *(void *)result;
      if (*(void *)result >= *(void *)(a1 + 232)) {
        break;
      }
      if (v4)
      {
        unint64_t v2 = *(void *)storageResolvePtr(a1, v2, 8, 1);
        if (v2 == v5)
        {
          int v7 = *__error();
          unsigned int v13 = _SILogForLogForCategory(4);
          if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
            goto LABEL_13;
          }
          uint64_t v15 = *(void *)(a1 + 232);
          *(_DWORD *)std::string buf = 136316162;
          unsigned int v21 = "freeListVerify";
          __int16 v22 = 1024;
          int v23 = 1103;
          __int16 v24 = 2048;
          unint64_t v25 = v5;
          __int16 v26 = 2048;
          unint64_t v27 = v5;
          __int16 v28 = 2048;
          uint64_t v29 = v15;
          unsigned int v10 = "%s:%d: Cycle in free-list: head:0x%llx, probe:0x%llx, freeRegion: 0x%llx";
          unsigned int v11 = v13;
          uint32_t v12 = 48;
          goto LABEL_16;
        }
      }
      ++v4;
      if (!v5) {
        return 1;
      }
    }
    int v7 = *__error();
    unint64_t v8 = _SILogForLogForCategory(4);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
LABEL_13:
      unsigned int v14 = __error();
      uint64_t result = 0;
      *unsigned int v14 = v7;
      return result;
    }
    unint64_t v9 = *(void *)(a1 + 232);
    *(_DWORD *)std::string buf = 136315906;
    unsigned int v21 = "freeListVerify";
    __int16 v22 = 1024;
    int v23 = 1095;
    __int16 v24 = 2048;
    unint64_t v25 = v5;
    __int16 v26 = 2048;
    unint64_t v27 = v9;
    unsigned int v10 = "%s:%d: head:0x%llx, freeRegion: 0x%llx";
    unsigned int v11 = v8;
    uint32_t v12 = 38;
LABEL_16:
    _os_log_error_impl(&dword_1BD672000, v11, OS_LOG_TYPE_ERROR, v10, buf, v12);
    goto LABEL_13;
  }
  return 1;
}

void dirtyStoragePage(uint64_t a1, unint64_t a2)
{
  int v3 = 64 << *(unsigned char *)(a2 + 2);
  unint64_t v4 = _windowsAddressOffset(a1 + 216, a2);
  unint64_t v5 = (void *)(a1 + 4376);
  CFIndex v6 = (v4 >> 17);
  bit_vector_set_3386(v5, v6);
  if (v6 != (v4 + v3) >> 17)
  {
    bit_vector_set_3386(v5, (v4 >> 17) + 1);
  }
}

char *storage_describe_windows(uint64_t a1, char *__str)
{
  int v4 = snprintf(__str, 0xFFuLL, "c:%d s:%lld", *(_DWORD *)(a1 + 248), *(void *)(a1 + 224));
  if (*(int *)(a1 + 248) >= 1 && v4 <= 0xFE)
  {
    uint64_t v5 = 0;
    CFIndex v6 = &__str[v4];
    size_t v7 = 255 - v4;
    do
    {
      snprintf(v6, v7, "%d:(mem:%p so:%lld eo:%lld)", v5, *(const void **)(*(void *)(a1 + 272 + 8 * v5) + 8), *(void *)(*(void *)(a1 + 272 + 8 * v5) + 16), *(void *)(*(void *)(a1 + 272 + 8 * v5) + 24));
      ++v5;
    }
    while (v5 < *(int *)(a1 + 248));
  }
  return __str;
}

BOOL uint32_map_init(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  bzero((void *)a1, 0x1140uLL);
  *(_DWORD *)(a1 + 4416) = a3;
  uint64_t v9 = 4 * a3;
  *(void *)(a1 + 224) = v9;
  *(void *)(a1 + 232) = v9;
  if (a5) {
    int v10 = 114;
  }
  else {
    int v10 = 102;
  }
  return storageInit(a1, 0, 4uLL, a2, 0, 0, 0, v10, 0);
}

uint64_t uint32_map_get(uint64_t a1, unsigned int a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (a2 && *(_DWORD *)(a1 + 4416) > a2) {
    return *(unsigned int *)storageResolvePtr(a1, 4 * a2, 4, 1);
  }
  uint64_t v5 = *(_DWORD **)(a1 + 216);
  if (v5) {
    int v6 = v5[11];
  }
  else {
    int v6 = -1;
  }
  if (!isExFat(v6) && !isMsDos(v6) && !isFat32(v6))
  {
    if (!a2 || *(_DWORD *)(a1 + 4416) <= a2)
    {
      int v10 = __si_assert_copy_extra(v5);
      unsigned int v11 = v10;
      uint32_t v12 = "";
      if (v10) {
        uint32_t v12 = v10;
      }
      __message_assert("%s:%u: failed assertion '%s' %s invalid map (%p) count:%d <= pos:%d", "storage.c", 1540, "position && position < inMap->count", v12, (const void *)a1, *(_DWORD *)(a1 + 4416), a2);
      free(v11);
      if (__valid_fsp(v5)) {
        uint64_t v13 = 2989;
      }
      else {
        uint64_t v13 = 3072;
      }
      *(_DWORD *)uint64_t v13 = -559038737;
      abort();
    }
    return *(unsigned int *)storageResolvePtr(a1, 4 * a2, 4, 1);
  }
  int v7 = *__error();
  unint64_t v8 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    int v14 = *(_DWORD *)(a1 + 4416);
    *(_DWORD *)std::string buf = 136316162;
    BOOL v16 = "uint32_map_get";
    __int16 v17 = 1024;
    int v18 = 1536;
    __int16 v19 = 2048;
    uint64_t v20 = a1;
    __int16 v21 = 1024;
    int v22 = v14;
    __int16 v23 = 1024;
    unsigned int v24 = a2;
    _os_log_error_impl(&dword_1BD672000, v8, OS_LOG_TYPE_ERROR, "%s:%d: invalid map (%p) count:%d <= pos:%d", buf, 0x28u);
  }
  uint64_t v9 = __error();
  uint64_t result = 0;
  *uint64_t v9 = v7;
  return result;
}

void __si_retain_service_connection_block_invoke_2(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v2 = *(void *)(a1 + 32);
    xpc_object_t v3 = gSIMachServicesNames_block_invoke_s_service_connections[*(unsigned int *)(a1 + 40)];
    int v5 = 136315394;
    uint64_t v6 = v2;
    __int16 v7 = 2048;
    xpc_object_t v8 = v3;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "### reset client connection %s %p", (uint8_t *)&v5, 0x16u);
  }
  int v4 = (_xpc_connection_s *)gSIMachServicesNames_block_invoke_s_service_connections[*(unsigned int *)(a1 + 40)];
  if (v4)
  {
    xpc_connection_cancel(v4);
    xpc_release(gSIMachServicesNames_block_invoke_s_service_connections[*(unsigned int *)(a1 + 40)]);
    gSIMachServicesNames_block_invoke_s_service_connections[*(unsigned int *)(a1 + 40)] = 0;
  }
}

void __si_xpc_setup_connection_block_invoke(uint64_t a1, _xpc_connection_s *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (is_valid_xpc_type(0, a2, MEMORY[0x1E4F14578]))
  {
    xpc_connection_set_target_queue(a2, *(dispatch_queue_t *)(a1 + 40));
    xpc_connection_set_event_handler(a2, &__block_literal_global_3447);
    xpc_connection_resume(a2);
  }
  else if (!is_valid_xpc_type(0, a2, MEMORY[0x1E4F14578]) && MEMORY[0x1C1882B80](a2) == MEMORY[0x1E4F145A8])
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 134217984;
      uint64_t v6 = a2;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "### Connection error %p", (uint8_t *)&v5, 0xCu);
    }
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4) {
      (*(void (**)(void))(v4 + 16))();
    }
  }
}

void __si_xpc_setup_connection_block_invoke_2(int a1, xpc_object_t xdict)
{
  remote_connectiouint64_t n = xpc_dictionary_get_remote_connection(xdict);
  if (is_valid_xpc_type((const char *)remote_connection, (const _xpc_type_s *)xdict, MEMORY[0x1E4F14590]))
  {
    xpc_dictionary_get_string(xdict, "command");
    if (remote_connection)
    {
      reply = xpc_dictionary_create_reply(xdict);
      if (reply)
      {
        int v5 = reply;
        xpc_dictionary_set_int64(reply, "status", -1);
        xpc_connection_send_message(remote_connection, v5);
        dispatch_release(v5);
      }
    }
  }
}

uint64_t _TermUpdateSetLock(uint64_t a1, int a2)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 304);
  if (a2)
  {
    HIDWORD(v5) = qos_class_self() - 9;
    LODWORD(v5) = HIDWORD(v5);
    unsigned int v4 = v5 >> 2;
    if (v4 > 6) {
      signed int v6 = 0;
    }
    else {
      signed int v6 = dword_1BDA87810[v4];
    }
    pthread_mutex_lock(v2);
    if (*(void *)(a1 + 488) || *(_DWORD *)(a1 + 500) || *(unsigned char *)(a1 + 516)) {
      goto LABEL_11;
    }
    if (v6 <= 5)
    {
      if (*(void *)(a1 + 16 * v6 + 368))
      {
LABEL_11:
        db_rwlock_wait((uint64_t)v2, v6, 2);
LABEL_12:
        return pthread_mutex_unlock(v2);
      }
      uint64_t v9 = v6 - 1;
      int v10 = (uint64_t *)(a1 + 16 * v6 + 384);
      while (v9 != 4)
      {
        uint64_t v11 = *v10;
        v10 += 2;
        ++v9;
        if (v11)
        {
          if (v9 <= 4) {
            goto LABEL_11;
          }
          break;
        }
      }
    }
    *(void *)(a1 + 488) = pthread_self();
    goto LABEL_12;
  }
  uint64_t v7 = a1 + 304;
  return db_read_lock(v7);
}

uint64_t _TermUpdateSetUnlock(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 304);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 304));
  *(_DWORD *)(a1 + 508) = 0;
  xpc_object_t v3 = *(pthread_override_s **)(a1 + 480);
  *(void *)(a1 + 480) = 0;
  *(void *)(a1 + 488) = 0;
  char v4 = *(_DWORD *)(a1 + 500) != 0;
  *(unsigned char *)(a1 + 516) = 0;
  db_rwlock_wakeup((uint64_t)v2, v4, 0);
  uint64_t result = pthread_mutex_unlock(v2);
  if (v3)
  {
    return pthread_override_qos_class_end_np(v3);
  }
  return result;
}

void *TermUpdateSetSetVectorStore(void *result, uint64_t a2)
{
  if (result)
  {
    result[6] = a2;
    xpc_object_t v3 = (void *)*result;
    char v4 = result + 1;
    if ((void *)*result != result + 1)
    {
      do
      {
        uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)v3[5] + 288))(v3[5], a2);
        unint64_t v5 = (void *)v3[1];
        if (v5)
        {
          do
          {
            signed int v6 = v5;
            unint64_t v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            signed int v6 = (void *)v3[2];
            BOOL v7 = *v6 == (void)v3;
            xpc_object_t v3 = v6;
          }
          while (!v7);
        }
        xpc_object_t v3 = v6;
      }
      while (v6 != v4);
    }
  }
  return result;
}

uint64_t _termUpdateSetProgress()
{
  return 0;
}

_DWORD *TermUpdateSetStore(_DWORD *result, uint64_t a2, void *a3, char a4)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  long long v52 = 0u;
  long long v53 = 0u;
  long long v51 = 0u;
  if (result)
  {
    BOOL v7 = result;
    double Current = CFAbsoluteTimeGetCurrent();
    db_read_lock((uint64_t)(v7 + 76));
    unsigned int v9 = atomic_load((unsigned int *)(*((void *)v7 + 3) + 16));
    uint64_t v10 = a3[5];
    if ((unint64_t)(a3[4] - v10) < 6)
    {
      *(void **)((char *)&__p[1] + 1) = 0;
      *(void **)((char *)__p + 1) = 0;
      __p[3] = 0;
      *(void **)((char *)&__p[2] + 1) = 0;
      LOBYTE(__p[0]) = 11;
      store_stream_write_bytes_2478((uint64_t)a3, (char *)__p, 1uLL);
    }
    else
    {
      *(unsigned char *)(a3[6] + v10) = 11;
      a3[5] = v10 + 1;
    }
    store_stream_write_vint32_2480(a3, v9);
    store_stream_write_vint32_2480(a3, v7[28]);
    unint64_t v11 = *((void *)v7 + 1);
    uint64_t v12 = a3[5];
    if ((unint64_t)(a3[4] - v12) < 0xB)
    {
      memset(__p, 0, 32);
      size_t v45 = writeVInt64((uint64_t)__p, 0, v11);
      store_stream_write_bytes_2478((uint64_t)a3, (char *)__p, v45);
    }
    else
    {
      a3[5] = writeVInt64(a3[6], v12, v11);
    }
    store_stream_write_vint32_2480(a3, v7[4]);
    store_stream_write_vint32_2480(a3, v7[42]);
    store_stream_write_vint32_2480(a3, v7[36]);
    store_stream_write_vint32_2480(a3, v7[30]);
    store_stream_write_vint32_2480(a3, v7[44]);
    store_stream_write_vint32_2480(a3, v7[38]);
    store_stream_write_vint32_2480(a3, v7[32]);
    store_stream_write_vint32_2480(a3, v7[54]);
    store_stream_write_vint32_2480(a3, v7[52]);
    store_stream_write_vint32_2480(a3, v7[34]);
    store_stream_write_vint32_2480(a3, v7[42]);
    store_stream_write_vint32_2480(a3, v7[50]);
    storeDirStoreUpdateSet(*((void *)v7 + 11), (uint64_t)(v7 + 12), a3);
    int v13 = v7[154];
    BYTE8(v53) = a4;
    LODWORD(v53) = 0;
    DWORD1(v53) = v13;
    uint64_t v14 = *((void *)v7 + 11);
    *(void *)&long long v52 = v7 + 60;
    *((void *)&v52 + 1) = a2;
    *(void *)&long long v51 = a3;
    *((void *)&v51 + 1) = v14;
    uint64_t v15 = *((void *)v7 + 3);
    v54[0] = 0;
    v54[1] = v54;
    int v56 = 0;
    uint64_t v55 = 0x2000000000;
    __p[0] = (void *)MEMORY[0x1E4F143A8];
    __p[1] = (void *)0x40000000;
    __p[2] = ___hashTableIterate_block_invoke_2;
    __p[3] = &unk_1E6343AC8;
    __p[5] = storeUpdateSetCallback;
    __p[6] = &v51;
    __p[4] = v54;
    _TermTrieWalkFatWithOptions(v15 + 32, 0, 0, 0, (uint64_t)__p, 0, 0);
    _Block_object_dispose(v54, 8);
    if (v9 != v53)
    {
      unsigned int v46 = __si_assert_copy_extra_329();
      __int16 v47 = v46;
      uint64_t v48 = "";
      if (v46) {
        uint64_t v48 = v46;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 909, "updateTermCount == ctx.termCount", v48);
      free(v47);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    uint64_t v50 = (pthread_mutex_t *)(v7 + 76);
    unsigned int v49 = v9;
    uint64_t v16 = *((void *)v7 + 10);
    if (v16)
    {
      uint64_t v17 = *((void *)v7 + 11);
      store_stream_write_vint32_2480(a3, *(_DWORD *)(v16 + 16));
      int v18 = *(void **)v16;
      if (*(void *)v16 != v16 + 8)
      {
        do
        {
          int v19 = *__error();
          uint64_t v20 = _SILogForLogForCategory(16);
          os_log_type_t v21 = 2 * (dword_1E9FC90E4 < 4);
          if (os_log_type_enabled(v20, v21))
          {
            uint64_t v22 = v18[5];
            HIBYTE(v55) = 3;
            LODWORD(v54[0]) = 4085052;
            (*(void (**)(void **__return_ptr))(*(void *)v22 + 312))(__p);
            __int16 v23 = __p;
            if (SHIBYTE(__p[2]) < 0) {
              __int16 v23 = (void **)__p[0];
            }
            *(_DWORD *)std::string buf = 134218242;
            uint64_t v59 = v16;
            __int16 v60 = 2080;
            uint64_t v61 = v23;
            _os_log_impl(&dword_1BD672000, v20, v21, "store <UpdateSet> %p %s", buf, 0x16u);
            if (SHIBYTE(__p[2]) < 0)
            {
              operator delete(__p[0]);
              if (SHIBYTE(v55) < 0) {
LABEL_37:
              }
                operator delete(v54[0]);
            }
            else if (SHIBYTE(v55) < 0)
            {
              goto LABEL_37;
            }
          }
          *__error() = v19;
          store_stream_write_vint32_2480(a3, *(_DWORD *)(v18[5] + 8) | ((*(unsigned char *)(v18[5] + 22) != 0) << 31));
          int v24 = *(_DWORD *)(v18[5] + 16);
          if (v24 == 2) {
            int v25 = 1;
          }
          else {
            int v25 = 3;
          }
          if (v24 == 4) {
            unsigned int v26 = 0;
          }
          else {
            unsigned int v26 = v25;
          }
          store_stream_write_vint32_2480(a3, v26);
          int v27 = *(_DWORD *)(v18[5] + 12);
          if (v27 == 512) {
            int v28 = 1;
          }
          else {
            int v28 = 3;
          }
          if (v27 == 768) {
            int v28 = 2;
          }
          if (v27 == 256) {
            unsigned int v29 = 0;
          }
          else {
            unsigned int v29 = v28;
          }
          store_stream_write_vint32_2480(a3, v29);
          store_stream_write_vint32_2480(a3, *(unsigned __int16 *)(v18[5] + 20));
          (*(void (**)(void, uint64_t, void *))(*(void *)v18[5] + 208))(v18[5], v17, a3);
          uint64_t v30 = (void *)v18[1];
          if (v30)
          {
            do
            {
              __int16 v31 = v30;
              uint64_t v30 = (void *)*v30;
            }
            while (v30);
          }
          else
          {
            do
            {
              __int16 v31 = (void *)v18[2];
              BOOL v32 = *v31 == (void)v18;
              int v18 = v31;
            }
            while (!v32);
          }
          int v18 = v31;
        }
        while (v31 != (void *)(v16 + 8));
      }
    }
    pthread_mutex_lock(v50);
    int v33 = v7[125] - 1;
    v7[125] = v33;
    if (!v33) {
      db_rwlock_wakeup((uint64_t)v50, 0, 0);
    }
    pthread_mutex_unlock(v50);
    int v34 = *__error();
    uint64_t v35 = _SILogForLogForCategory(10);
    os_log_type_t v36 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v35, v36))
    {
      int v37 = v7[28];
      unsigned int v38 = atomic_load(v7 + 25);
      CFAbsoluteTime v39 = CFAbsoluteTimeGetCurrent();
      LODWORD(__p[0]) = 67109888;
      HIDWORD(__p[0]) = v49;
      LOWORD(__p[1]) = 1024;
      *(_DWORD *)((char *)&__p[1] + 2) = v37;
      HIWORD(__p[1]) = 1024;
      LODWORD(__p[2]) = v38;
      WORD2(__p[2]) = 2048;
      *(double *)((char *)&__p[2] + 6) = v39 - Current;
      _os_log_impl(&dword_1BD672000, v35, v36, "Store Update Set (t %d, d %d, p %d) took %f seconds", (uint8_t *)__p, 0x1Eu);
    }
    uint64_t result = __error();
    *uint64_t result = v34;
  }
  else
  {
    uint64_t v40 = a3[5];
    if ((unint64_t)(a3[4] - v40) < 6)
    {
      *(void **)((char *)&__p[1] + 1) = 0;
      *(void **)((char *)__p + 1) = 0;
      __p[3] = 0;
      *(void **)((char *)&__p[2] + 1) = 0;
      LOBYTE(__p[0]) = 11;
      uint64_t result = (_DWORD *)store_stream_write_bytes_2478((uint64_t)a3, (char *)__p, 1uLL);
      uint64_t v41 = a3[5];
    }
    else
    {
      *(unsigned char *)(a3[6] + v40) = 11;
      uint64_t v41 = v40 + 1;
      a3[5] = v41;
    }
    if ((unint64_t)(a3[4] - v41) < 6)
    {
      memset(__p, 0, 32);
      uint64_t result = (_DWORD *)store_stream_write_bytes_2478((uint64_t)a3, (char *)__p, 1uLL);
      uint64_t v42 = a3[5];
    }
    else
    {
      *(unsigned char *)(a3[6] + v41) = 0;
      uint64_t v42 = v41 + 1;
      a3[5] = v42;
    }
    if ((unint64_t)(a3[4] - v42) < 6)
    {
      memset(__p, 0, 32);
      uint64_t result = (_DWORD *)store_stream_write_bytes_2478((uint64_t)a3, (char *)__p, 1uLL);
      uint64_t v43 = a3[5];
    }
    else
    {
      *(unsigned char *)(a3[6] + v42) = 0;
      uint64_t v43 = v42 + 1;
      a3[5] = v43;
    }
    if ((unint64_t)(a3[4] - v43) < 6)
    {
      memset(__p, 0, 32);
      uint64_t result = (_DWORD *)store_stream_write_bytes_2478((uint64_t)a3, (char *)__p, 1uLL);
      uint64_t v44 = a3[5];
    }
    else
    {
      *(unsigned char *)(a3[6] + v43) = 0;
      uint64_t v44 = v43 + 1;
      a3[5] = v44;
    }
    if ((unint64_t)(a3[4] - v44) < 6)
    {
      memset(__p, 0, 32);
      return (_DWORD *)store_stream_write_bytes_2478((uint64_t)a3, (char *)__p, 1uLL);
    }
    else
    {
      *(unsigned char *)(a3[6] + v44) = 0;
      a3[5] = v44 + 1;
    }
  }
  return result;
}

uint64_t ___hashTableIterate_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, void))(a1 + 40))(a2 + 16, *(void *)(a1 + 48));
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t storeUpdateSetCallback(uint64_t a1, uint64_t *a2)
{
  size_t v4 = *(unsigned __int16 *)(a1 + 16);
  unint64_t v5 = (char *)(a1 + 18);
  ++*((_DWORD *)a2 + 8);
  store_stream_write_vint32_2480((void *)*a2, v4);
  uint64_t v6 = *a2;
  while (1)
  {
    size_t v8 = *(void *)(v6 + 32);
    uint64_t v7 = *(void *)(v6 + 40);
    if (v7 + v4 < v8) {
      break;
    }
    size_t v9 = v8 - v7;
    memcpy((void *)(*(void *)(v6 + 48) + v7), v5, v8 - v7);
    *(void *)(v6 + 40) += v9;
    if (store_stream_flush((unsigned int *)v6, 0)) {
      goto LABEL_6;
    }
    v5 += v9;
    v4 -= v9;
  }
  memcpy((void *)(*(void *)(v6 + 48) + v7), v5, v4);
  *(void *)(v6 + 40) += v4;
LABEL_6:
  uint64_t v10 = *a2;
  uint64_t v11 = a2[1];
  uint64_t v12 = (uint64_t *)a2[2];
  unsigned int v13 = *(_DWORD *)(a1 + 12);
  int v14 = *((_DWORD *)a2 + 9);
  return CIWritePostings(v10, v11, v12, (unsigned int *)a1, v13, v14);
}

char *TermUpdateSetRestore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, const void *a11)
{
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  char v13 = v12;
  unsigned int v221 = v14;
  int v16 = v15;
  int v18 = v17;
  uint64_t v20 = v19;
  uint64_t v22 = v21;
  int v24 = v23;
  int v25 = (unsigned int *)v11;
  uint64_t v243 = *MEMORY[0x1E4F143B8];
  double Current = CFAbsoluteTimeGetCurrent();
  int v27 = TermUpdateSetCreate(v24, v22, 0, 0, v16 | 4u, a9, a10, a11);
  unsigned int vint32_2613 = store_stream_read_vint32_2613((uint64_t)v25);
  unsigned int v29 = vint32_2613;
  if (v13)
  {
    if (!vint32_2613)
    {
LABEL_241:
      int v163 = *__error();
      int v164 = _SILogForLogForCategory(10);
      os_log_type_t v165 = 2 * (dword_1E9FC90CC < 4);
      if (os_log_type_enabled(v164, v165))
      {
        unsigned int v166 = atomic_load((unsigned int *)(*((void *)v27 + 3) + 16));
        int v167 = *((_DWORD *)v27 + 28);
        unsigned int v168 = atomic_load((unsigned int *)v27 + 25);
        CFAbsoluteTime v169 = CFAbsoluteTimeGetCurrent();
        LODWORD(__dst[0]) = 67109888;
        DWORD1(__dst[0]) = v166;
        WORD4(__dst[0]) = 1024;
        *(_DWORD *)((char *)__dst + 10) = v167;
        HIWORD(__dst[0]) = 1024;
        LODWORD(__dst[1]) = v168;
        WORD2(__dst[1]) = 2048;
        *(double *)((char *)&__dst[1] + 6) = v169 - Current;
        _os_log_impl(&dword_1BD672000, v164, v165, "Restore Update Set (t %d, d %d, p %d) took %f seconds", (uint8_t *)__dst, 0x1Eu);
      }
      *__error() = v163;
      if ((v27[616] & 2) != 0) {
        return v27;
      }
      uint64_t v226 = 0;
      long long v224 = 0u;
      long long v225 = 0u;
      memset(__dst, 0, sizeof(__dst));
      _TermUpdateSetGetStats((uint64_t)v27, (uint64_t)__dst, 1);
      unint64_t v170 = *(void *)&__dst[1] + v224 + *(void *)&__dst[0];
      if (v170 < 0xFFFFFFFF)
      {
        atomic_fetch_add(gTotalCurrentUsage, v170);
        *((void *)v27 + 28) = *(void *)&__dst[1] + v224 + *(void *)&__dst[0];
        return v27;
      }
      unsigned int v185 = __si_assert_copy_extra_329();
      long long v186 = v185;
      int v187 = "";
      if (v185) {
        int v187 = v185;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 1261, "(stats.positionInfoUsed+stats.postingInfoUsed+stats.termInfoUsed) < 4294967295U", v187);
LABEL_278:
      free(v186);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    if (vint32_2613 != 11) {
      goto LABEL_16;
    }
  }
  else if (vint32_2613 - 7 >= 5)
  {
    if (vint32_2613)
    {
LABEL_16:
      int v36 = *__error();
      int v37 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        goto LABEL_17;
      }
      LODWORD(__dst[0]) = 136316162;
      *(void *)((char *)__dst + 4) = "TermUpdateSetRestore";
      WORD6(__dst[0]) = 1024;
      *(_DWORD *)((char *)__dst + 14) = 955;
      WORD1(__dst[1]) = 1024;
      DWORD1(__dst[1]) = v29;
      WORD4(__dst[1]) = 1024;
      *(_DWORD *)((char *)&__dst[1] + 10) = 8;
      HIWORD(__dst[1]) = 1024;
      LODWORD(v224) = 7;
      double v158 = "%s:%d: invalid store version %d, expected %d or %d";
      uint64_t v159 = (uint8_t *)__dst;
      int v160 = v37;
      uint32_t v161 = 36;
      goto LABEL_240;
    }
    goto LABEL_241;
  }
  int v211 = store_stream_read_vint32_2613((uint64_t)v25);
  *((_DWORD *)v27 + 28) = store_stream_read_vint32_2613((uint64_t)v25);
  size_t v30 = *((void *)v25 + 5);
  BOOL v219 = (size_t *)(v25 + 10);
  if (*((void *)v25 + 4) - v30 < 0xB)
  {
    int v180 = 0;
    uint64_t v32 = 0;
    LOBYTE(__dst[0]) = 0;
    while (store_stream_read_bytes_2616(v25, (char *)__dst, 1uLL) == 1)
    {
      v32 |= (unint64_t)(__dst[0] & 0x7F) << v180;
      v180 += 7;
      if ((__dst[0] & 0x80) == 0) {
        goto LABEL_12;
      }
    }
    uint64_t v32 = 0;
  }
  else
  {
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    do
    {
      char v33 = *(unsigned char *)(*((void *)v25 + 6) + v30++);
      v32 |= (unint64_t)(v33 & 0x7F) << v31;
      if ((v33 & 0x80) == 0) {
        break;
      }
      BOOL v34 = v31 == 63;
      v31 += 7;
    }
    while (!v34);
    *BOOL v219 = v30;
  }
LABEL_12:
  *((void *)v27 + 1) = v32;
  *((_DWORD *)v27 + 4) = store_stream_read_vint32_2613((uint64_t)v25);
  unsigned int v35 = store_stream_read_vint32_2613((uint64_t)v25);
  if (v29 < 9)
  {
    *((void *)v27 + 15) = v35;
    *((void *)v27 + 16) = store_stream_read_vint32_2613((uint64_t)v25);
    if (v29 == 8)
    {
      *((void *)v27 + 17) = store_stream_read_vint32_2613((uint64_t)v25);
      *((void *)v27 + 24) = store_stream_read_vint32_2613((uint64_t)v25);
    }
  }
  else
  {
    *((void *)v27 + 21) = v35;
    *((void *)v27 + 18) = store_stream_read_vint32_2613((uint64_t)v25);
    *((void *)v27 + 15) = store_stream_read_vint32_2613((uint64_t)v25);
    *((void *)v27 + 22) = store_stream_read_vint32_2613((uint64_t)v25);
    *((void *)v27 + 19) = store_stream_read_vint32_2613((uint64_t)v25);
    *((void *)v27 + 16) = store_stream_read_vint32_2613((uint64_t)v25);
    *((void *)v27 + 27) = store_stream_read_vint32_2613((uint64_t)v25);
    *((void *)v27 + 26) = store_stream_read_vint32_2613((uint64_t)v25);
    *((void *)v27 + 17) = store_stream_read_vint32_2613((uint64_t)v25);
    *((void *)v27 + 24) = store_stream_read_vint32_2613((uint64_t)v25);
    if (v29 != 9) {
      *((void *)v27 + 25) = store_stream_read_vint32_2613((uint64_t)v25);
    }
  }
  if (!*((_DWORD *)v27 + 28) && !*((void *)v27 + 1) && !*((_DWORD *)v27 + 4))
  {
    *((void *)v27 + 1) = v20;
    *((_DWORD *)v27 + 4) = v18;
  }
  char v218 = (void **)(v27 + 88);
  if ((restoreDirStoreUpdateSet((char **)v27 + 11, (long long *)v27 + 3, v25) & 1) == 0)
  {
    int v153 = *__error();
    uint64_t v154 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
    {
      LODWORD(__dst[0]) = 136315394;
      *(void *)((char *)__dst + 4) = "TermUpdateSetRestore";
      WORD6(__dst[0]) = 1024;
      *(_DWORD *)((char *)__dst + 14) = 1001;
      _os_log_error_impl(&dword_1BD672000, v154, OS_LOG_TYPE_ERROR, "%s:%d: Failed restoring update set for paths", (uint8_t *)__dst, 0x12u);
    }
    *__error() = v153;
    if (!v25[4]) {
      uint8_t v25[4] = -1;
    }
    goto LABEL_225;
  }
  bzero(__dst, 0x1000uLL);
  unint64_t v213 = v27 + 240;
  unsigned int v38 = atomic_load((unsigned int *)v27 + 62);
  unsigned int v39 = v38 + v211;
  unsigned int v40 = *((_DWORD *)v27 + 63);
  if (v39 >= v40)
  {
    do
    {
      if (v40) {
        int v41 = 2 * v40;
      }
      else {
        int v41 = 0x10000;
      }
      *((_DWORD *)v27 + 63) = v41;
      unsigned int v42 = atomic_load((unsigned int *)v27 + 62);
      unsigned int v43 = v42 + v211;
      unsigned int v40 = *((_DWORD *)v27 + 63);
    }
    while (v43 >= v40);
  }
  size_t v44 = 32 * v40;
  size_t v45 = mmap(0, v44, 3, 4098, -167772160, 0);
  *unint64_t v213 = v45;
  if (v45 == (void *)-1)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      int v193 = *__error();
      long long v194 = __error();
      uint64_t v195 = strerror(*v194);
      *(_DWORD *)CFBit v227 = 136317186;
      *(void *)&v227[4] = "slab_allocator.h";
      __int16 v228 = 1024;
      int v229 = 85;
      __int16 v230 = 2048;
      *(void *)uint64_t v231 = v44;
      *(_WORD *)&v231[8] = 1024;
      *(_DWORD *)CFBitVectorRef v232 = 3;
      *(_WORD *)&unsigned char v232[4] = 1024;
      int v233 = 4098;
      __int16 v234 = 1024;
      int v235 = -167772160;
      __int16 v236 = 1024;
      int v237 = -167772159;
      __int16 v238 = 1024;
      int v239 = v193;
      __int16 v240 = 2080;
      uint64_t v241 = v195;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s:%u: mmap failed for addr NULL, len 0x%08lx, prot 0x%04x, flags 0x%04x, fd 0x%04x, flags %u, errno %d(%s)", v227, 0x44u);
    }
    int v196 = __si_assert_copy_extra_329();
    long long v186 = v196;
    long long v197 = "";
    if (v196) {
      long long v197 = v196;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 1018, "kr == 0", v197);
    goto LABEL_278;
  }
  atomic_fetch_add_explicit(&qword_1EC02F008, v44, memory_order_relaxed);
  if (!v45)
  {
    uint64_t v181 = __si_assert_copy_extra_329();
    unsigned int v182 = v181;
    int v183 = "";
    if (v181) {
      int v183 = v181;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 1020, "positions->node_table", v183);
    free(v182);
    if (__valid_fs(-1)) {
      uint64_t v184 = 2989;
    }
    else {
      uint64_t v184 = 3072;
    }
    *(_DWORD *)uint64_t v184 = -559038737;
    abort();
  }
  uint64_t v222 = v27;
  if (!v211)
  {
LABEL_226:
    if (_os_feature_enabled_impl())
    {
      uint64_t v155 = *((void *)v27 + 10);
      if (v155) {
        freeVectorUpdates(v155);
      }
      operator new();
    }
    goto LABEL_241;
  }
  int v46 = 0;
  uint64_t v212 = 4 * (v29 != 11);
  while (1)
  {
    if (v25[4]) {
      goto LABEL_18;
    }
    int v208 = v46;
    unsigned int v47 = store_stream_read_vint32_2613((uint64_t)v25);
    unsigned int v48 = v47;
    if (v47 - 4097 <= 0xFFFFEFFF)
    {
      int v36 = *__error();
      BOOL v178 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v178, OS_LOG_TYPE_ERROR)) {
        goto LABEL_17;
      }
      *(_DWORD *)CFBit v227 = 136315650;
      *(void *)&v227[4] = "TermUpdateSetRestore";
      __int16 v228 = 1024;
      int v229 = 1032;
      __int16 v230 = 1024;
      *(_DWORD *)uint64_t v231 = v48;
      double v158 = "%s:%d: invalid termLen %d";
LABEL_269:
      uint64_t v159 = v227;
      int v160 = v178;
LABEL_233:
      uint32_t v161 = 24;
LABEL_240:
      _os_log_error_impl(&dword_1BD672000, v160, OS_LOG_TYPE_ERROR, v158, v159, v161);
      goto LABEL_17;
    }
    unsigned int v214 = v47;
    size_t v49 = v47;
    size_t v50 = *((void *)v25 + 4);
    size_t v51 = *((void *)v25 + 5);
    if (v51 + v47 > v50)
    {
      unint64_t v53 = v47;
      int v143 = (void *)*((void *)v25 + 6);
      size_t v144 = v50 - v51;
      if (v50 != v51)
      {
        __memcpy_chk();
        *BOOL v219 = v50;
        size_t v51 = v50;
      }
      unint64_t v145 = prot_pread(*v25, v143, v51, *((void *)v25 + 3));
      if (v145 == -1) {
        goto LABEL_220;
      }
      size_t v146 = v145;
      *((void *)v25 + 4) = v145;
      *((void *)v25 + 5) = 0;
      off_t v147 = *((void *)v25 + 3) + v145;
      *((void *)v25 + 3) = v147;
      int v27 = v222;
      uint64_t v54 = (uint64_t *)(v25 + 10);
      unsigned int v55 = v214;
      if (!v145) {
        goto LABEL_43;
      }
      long long v52 = (char *)__dst + v144;
      size_t v49 = v53 - v144;
      if (v49 > v145)
      {
        while (1)
        {
          unint64_t v151 = (void *)*((void *)v25 + 6);
          memcpy(v52, v151, v146);
          *((void *)v25 + 5) = v146;
          unint64_t v152 = prot_pread(*v25, v151, v146, v147);
          if (v152 == -1) {
            break;
          }
          *((void *)v25 + 4) = v152;
          *((void *)v25 + 5) = 0;
          off_t v147 = *((void *)v25 + 3) + v152;
          *((void *)v25 + 3) = v147;
          int v27 = v222;
          uint64_t v54 = (uint64_t *)(v25 + 10);
          if (!v152) {
            goto LABEL_42;
          }
          size_t v51 = 0;
          v52 += v146;
          v49 -= v146;
          size_t v146 = v152;
          if (v49 <= v152) {
            goto LABEL_40;
          }
        }
LABEL_220:
        uint8_t v25[4] = *__error();
        int v27 = v222;
        goto LABEL_41;
      }
      size_t v51 = 0;
      int v27 = v222;
    }
    else
    {
      long long v52 = (char *)__dst;
      unint64_t v53 = v47;
    }
LABEL_40:
    memcpy(v52, (const void *)(*((void *)v25 + 6) + v51), v49);
    *((void *)v25 + 5) = v51 + v49;
LABEL_41:
    uint64_t v54 = (uint64_t *)(v25 + 10);
LABEL_42:
    unsigned int v55 = v214;
    if (!v214)
    {
      char v57 = 1;
      goto LABEL_52;
    }
LABEL_43:
    if (v55 >= 2)
    {
      uint64_t v56 = v53 & 0xFFFFFFFE;
      unint64_t v58 = (char *)__dst + 1;
      uint64_t v59 = v56;
      do
      {
        char v60 = tcmr[*v58];
        *(v58 - 1) = tcmr[*(v58 - 1)];
        char *v58 = v60;
        v58 += 2;
        v59 -= 2;
      }
      while (v59);
      if (v56 == v53) {
        goto LABEL_51;
      }
    }
    else
    {
      uint64_t v56 = 0;
    }
    uint64_t v61 = v53 - v56;
    uint64_t v62 = (char *)__dst + v56;
    do
    {
      unsigned char *v62 = tcmr[*v62];
      ++v62;
      --v61;
    }
    while (v61);
LABEL_51:
    char v57 = 0;
LABEL_52:
    *((unsigned char *)__dst + v53) = 0;
    unsigned int v63 = store_stream_read_vint32_2613((uint64_t)v25);
    unint64_t v64 = *((void *)v25 + 4);
    unsigned int v220 = v63;
    if (v64 < v63)
    {
      int v36 = *__error();
      unint64_t v172 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v172, OS_LOG_TYPE_ERROR)) {
        goto LABEL_17;
      }
      uint64_t v173 = *((void *)v25 + 4);
      *(_DWORD *)CFBit v227 = 136315906;
      *(void *)&v227[4] = "TermUpdateSetRestore";
      __int16 v228 = 1024;
      int v229 = 1047;
      __int16 v230 = 1024;
      *(_DWORD *)uint64_t v231 = v220;
      *(_WORD *)&v231[4] = 1024;
      *(_DWORD *)&v231[6] = v173;
      double v158 = "%s:%d: invalid  postingCount %u > %u";
      uint64_t v159 = v227;
      int v160 = v172;
LABEL_249:
      uint32_t v161 = 30;
      goto LABEL_240;
    }
    unsigned int v65 = v63;
    if (v63)
    {
      char v206 = v57;
      unint64_t v66 = 0;
      int v67 = 0;
      unsigned int v216 = 0;
      uint64_t v68 = 0;
      uint64_t v209 = 0;
      unint64_t v202 = v53;
      unint64_t v204 = v53 - 1;
      while (1)
      {
        uint64_t v69 = *((void *)v25 + 5);
        if ((unint64_t)(*((void *)v25 + 4) - v69) < 0xB) {
          break;
        }
        uint64_t v70 = 0;
        unint64_t v71 = 0;
        do
        {
          char v72 = *(unsigned char *)(*((void *)v25 + 6) + v69++);
          v71 |= (unint64_t)(v72 & 0x7F) << v70;
          if ((v72 & 0x80) == 0) {
            break;
          }
          BOOL v34 = v70 == 63;
          v70 += 7;
        }
        while (!v34);
        *uint64_t v54 = v69;
LABEL_61:
        if (v25[4])
        {
          int v36 = *__error();
          int v156 = _SILogForLogForCategory(0);
          if (!os_log_type_enabled(v156, OS_LOG_TYPE_ERROR)) {
            goto LABEL_17;
          }
          unsigned int v157 = v25[4];
          *(_DWORD *)CFBit v227 = 136315650;
          *(void *)&v227[4] = "TermUpdateSetRestore";
          __int16 v228 = 1024;
          int v229 = 1056;
          __int16 v230 = 1024;
          *(_DWORD *)uint64_t v231 = v157;
          double v158 = "%s:%d: storeStream error %d";
LABEL_232:
          uint64_t v159 = v227;
          int v160 = v156;
          goto LABEL_233;
        }
        if (v66) {
          unint64_t v73 = v66 - (v71 >> 2);
        }
        else {
          unint64_t v73 = v71 >> 2;
        }
        if (v71)
        {
          int v75 = 1;
          if (v67)
          {
LABEL_67:
            if ((v71 & 2) != 0) {
              unsigned int v76 = 2;
            }
            else {
              unsigned int v76 = 1;
            }
            int v77 = v27;
            unsigned __int16 v78 = (unsigned int *)(v27 + 100);
            unsigned int v79 = atomic_load(v78);
            unsigned int v80 = v79 + v76;
            uint64_t v81 = *((unsigned int *)v77 + 24);
            if (v80 >= v81)
            {
              unsigned int v107 = 2 * v81;
              if (!v81) {
                unsigned int v107 = 0x4000;
              }
              *((_DWORD *)v222 + 24) = v107;
              int v108 = my_vm_reallocate(v218, 12 * v81, 12 * v107, 243, *((void *)v222 + 13));
              unsigned int v65 = v220;
              if (v108)
              {
                int v191 = __si_assert_copy_extra_329();
                long long v186 = v191;
                uint64_t v192 = "";
                if (v191) {
                  uint64_t v192 = v191;
                }
                __message_assert("%s:%u: failed assertion '%s' %s ", "DocPosting.h", 250, "0 == kr", v192);
                goto LABEL_278;
              }
            }
            unsigned int add = atomic_fetch_add((atomic_uint *volatile)v78, v76);
            if (v216) {
              uint64_t v68 = (uint64_t)*v218 + 12 * v216;
            }
            int v27 = v222;
            uint64_t v54 = (uint64_t *)(v25 + 10);
            if (!add)
            {
              *(_DWORD *)v68 &= 1u;
              int v36 = *__error();
              unint64_t v162 = _SILogForLogForCategory(0);
              if (!os_log_type_enabled(v162, OS_LOG_TYPE_ERROR)) {
                goto LABEL_17;
              }
              *(_DWORD *)CFBit v227 = 136315394;
              *(void *)&v227[4] = "TermUpdateSetRestore";
              __int16 v228 = 1024;
              int v229 = 1100;
              double v158 = "%s:%d: lastPosting==0";
LABEL_238:
              uint64_t v159 = v227;
              int v160 = v162;
              uint32_t v161 = 18;
              goto LABEL_240;
            }
            uint64_t v83 = *v218;
            *(_DWORD *)uint64_t v68 = *(_DWORD *)v68 & 1 | (2 * add);
            uint64_t v68 = (uint64_t)v83 + 12 * add;
            unsigned int v216 = add;
            goto LABEL_92;
          }
        }
        else
        {
          int v74 = store_stream_read_vint32_2613((uint64_t)v25);
          unsigned int v65 = v220;
          int v75 = v74;
          if (v67) {
            goto LABEL_67;
          }
        }
        unsigned int v84 = (uint64_t *)*((void *)v27 + 3);
        uint64_t v85 = (uint64_t)(v84 + 2);
        uint64_t v86 = *v84;
        v227[0] = 0;
        if (v86)
        {
          int v87 = (_DWORD *)(v86 + 0x4000);
          int v88 = *(_DWORD *)(v86 + 0x4000);
          if (v88 < 0)
          {
            uint64_t v68 = *(void *)v86;
            if ((v88 & 0x7FFFFFFF) != 0 || v214 != *(unsigned __int16 *)(v68 + 16)) {
              goto LABEL_88;
            }
            if ((v206 & 1) == 0)
            {
              int v90 = v84 + 270;
              if (*(unsigned __int8 *)(v68 + 18) == *((unsigned __int8 *)v90 + LOBYTE(__dst[0])))
              {
                unint64_t v91 = 0;
                unsigned int v65 = v220;
                while (v204 != v91)
                {
                  int v92 = *(unsigned __int8 *)(v68 + v91 + 19);
                  int v93 = *((unsigned __int8 *)v90 + *((unsigned __int8 *)__dst + ++v91));
                  if (v92 != v93)
                  {
                    if (v91 >= v202) {
                      goto LABEL_78;
                    }
                    goto LABEL_88;
                  }
                }
              }
              else
              {
LABEL_88:
                uint64_t v94 = TermTrieResolve(v85);
                uint64_t v95 = v68;
                uint64_t v68 = v94;
                unsigned int v65 = v220;
                if (*(void *)(v95 + 4) < *(void *)(v94 + 4))
                {
                  *(void *)uint64_t v86 = v94;
                  _DWORD *v87 = 0x80000000;
                }
              }
              uint64_t v54 = (uint64_t *)(v25 + 10);
              goto LABEL_91;
            }
          }
          else
          {
            uint64_t v68 = TermTrieResolve(v85);
            *(void *)uint64_t v86 = v68;
            _DWORD *v87 = 0x80000000;
          }
LABEL_78:
          uint64_t v54 = (uint64_t *)(v25 + 10);
          unsigned int v65 = v220;
        }
        else
        {
          uint64_t v89 = TermTrieResolve(v85);
          unsigned int v65 = v220;
          uint64_t v68 = v89;
        }
LABEL_91:
        *(_DWORD *)(v68 + 12) = 0;
        uint64_t v209 = v68;
        int v27 = v222;
LABEL_92:
        *(_DWORD *)v68 &= 1u;
        if ((v71 & 2) != 0)
        {
          *(_DWORD *)uint64_t v68 = 1;
          *(void *)(v68 + 8) = v71 >> 2;
        }
        else
        {
          if (v221 && v73 > v221)
          {
            int v175 = *__error();
            int v176 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v176, OS_LOG_TYPE_ERROR))
            {
              int v190 = *((_DWORD *)v27 + 4);
              *(_DWORD *)CFBit v227 = 136316162;
              *(void *)&v227[4] = "TermUpdateSetRestore";
              __int16 v228 = 1024;
              int v229 = 1112;
              __int16 v230 = 1024;
              *(_DWORD *)uint64_t v231 = v73;
              *(_WORD *)&v231[4] = 1024;
              *(_DWORD *)&v231[6] = v221;
              *(_WORD *)CFBitVectorRef v232 = 1024;
              *(_DWORD *)&v232[2] = v190;
              _os_log_error_impl(&dword_1BD672000, v176, OS_LOG_TYPE_ERROR, "%s:%d: invalid doc id %d exceeded (%d, %d)", v227, 0x24u);
            }
            *__error() = v175;
            uint8_t v25[4] = 22;
            if (!v27) {
              return v27;
            }
LABEL_225:
            TermUpdateSetRelease((uint64_t)v27);
            return 0;
          }
          *(_DWORD *)uint64_t v68 = 0;
          *(_DWORD *)(v68 + 8) = v73;
          unint64_t v66 = v73;
        }
        *(_DWORD *)(v68 + 4) = v75;
        if (++v67 == v65)
        {
          unint64_t v64 = *((void *)v25 + 4);
          uint64_t v109 = v209;
          goto LABEL_128;
        }
      }
      int v96 = 0;
      unint64_t v71 = 0;
      v227[0] = 0;
      while (1)
      {
        size_t v98 = *((void *)v25 + 4);
        uint64_t v97 = *((void *)v25 + 5);
        if (v97 + 1 <= v98)
        {
          size_t v99 = 0;
          uint64_t v100 = v227;
          size_t v101 = 1;
LABEL_101:
          memcpy(v100, (const void *)(*((void *)v25 + 6) + v97), v101);
          *((void *)v25 + 5) = v97 + v101;
          size_t v102 = v99;
          size_t v99 = v101;
          goto LABEL_102;
        }
        unsigned int v103 = (void *)*((void *)v25 + 6);
        size_t v99 = v98 - v97;
        if (v98 != v97)
        {
          __memcpy_chk();
          *BOOL v219 = v98;
        }
        __uint64_t n = prot_pread(*v25, v103, v98, *((void *)v25 + 3));
        if (__n == -1)
        {
          size_t v99 = 0;
        }
        else
        {
          off_t v104 = *((void *)v25 + 3) + __n;
          *((void *)v25 + 4) = __n;
          *((void *)v25 + 5) = 0;
          off_t v199 = v104;
          *((void *)v25 + 3) = v104;
          if (!__n)
          {
            size_t v102 = 0;
            goto LABEL_114;
          }
          uint64_t v100 = &v227[v99];
          size_t v101 = 1 - v99;
          if (1 - v99 <= __n)
          {
            uint64_t v97 = 0;
            int v27 = v222;
            goto LABEL_101;
          }
          while (1)
          {
            int v198 = (void *)*((void *)v25 + 6);
            float v105 = v100;
            memcpy(v100, v198, __n);
            *((void *)v25 + 5) = __n;
            unint64_t v106 = prot_pread(*v25, v198, __n, v199);
            if (v106 == -1) {
              break;
            }
            *((void *)v25 + 4) = v106;
            *((void *)v25 + 5) = 0;
            off_t v199 = *((void *)v25 + 3) + v106;
            *((void *)v25 + 3) = v199;
            if (!v106)
            {
              size_t v102 = v99;
              size_t v99 = __n;
              goto LABEL_114;
            }
            uint64_t v97 = 0;
            uint64_t v100 = &v105[__n];
            v101 -= __n;
            v99 += __n;
            __uint64_t n = v106;
            int v27 = v222;
            if (v101 <= v106) {
              goto LABEL_101;
            }
          }
        }
        uint8_t v25[4] = *__error();
        size_t v102 = v99;
        size_t v99 = 0;
LABEL_114:
        int v27 = v222;
LABEL_102:
        uint64_t v54 = (uint64_t *)(v25 + 10);
        unsigned int v65 = v220;
        if (v99 + v102 != 1)
        {
          unint64_t v71 = 0;
          goto LABEL_61;
        }
        v71 |= (unint64_t)(v227[0] & 0x7F) << v96;
        v96 += 7;
        if ((v227[0] & 0x80) == 0) {
          goto LABEL_61;
        }
      }
    }
    uint64_t v109 = 0;
LABEL_128:
    if (v64 - *v54 < 0xA)
    {
      *(_WORD *)&v227[8] = 0;
      *(void *)CFBit v227 = 0;
      size_t bytes_2616 = store_stream_read_bytes_2616(v25, v227, 1uLL);
      unint64_t VInt64_2086 = 0;
      if (bytes_2616 == 1)
      {
        char v149 = v2_vInt64DataSize(v227[0]);
        if (v149 == 1
          || store_stream_read_bytes_2616(v25, &v227[1], (v149 - 1)) == (v149 - 1))
        {
          *(void *)uint64_t v242 = 0;
          unint64_t VInt64_2086 = v2_readVInt64_2086((uint64_t)v227, (uint64_t *)v242);
        }
        else
        {
          unint64_t VInt64_2086 = 0;
        }
        int v27 = v222;
        uint64_t v54 = (uint64_t *)(v25 + 10);
      }
    }
    else
    {
      unint64_t VInt64_2086 = v2_readVInt64_2086(*((void *)v25 + 6), v54);
    }
    if (VInt64_2086) {
      break;
    }
LABEL_195:
    int v46 = v208 + 1;
    if (v208 + 1 == v211) {
      goto LABEL_226;
    }
  }
  if (!v109)
  {
    int v188 = *__error();
    int v189 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v189, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)CFBit v227 = 136315394;
      *(void *)&v227[4] = "TermUpdateSetRestore";
      __int16 v228 = 1024;
      int v229 = 1127;
      _os_log_error_impl(&dword_1BD672000, v189, OS_LOG_TYPE_ERROR, "%s:%d: value==0", v227, 0x12u);
    }
    *__error() = v188;
    int v27 = v222;
    if (!v222) {
      return v27;
    }
    goto LABEL_225;
  }
  uint64_t v111 = atomic_fetch_add((atomic_uint *volatile)v27 + 62, 1u);
  *(_DWORD *)(v109 + 12) = v111;
  uint64_t v203 = *((void *)v27 + 30);
  uint64_t v205 = v111;
  uint64_t v112 = v203 + 32 * v111;
  *(void *)(v112 + 16) = VInt64_2086 >> 1;
  uint64_t v207 = (void *)(v112 + 16);
  if (*((void *)v25 + 4) - *((void *)v25 + 5) < 0xAuLL)
  {
    *(_WORD *)&v227[8] = 0;
    *(void *)CFBit v227 = 0;
    unint64_t v114 = 0;
    if (store_stream_read_bytes_2616(v25, v227, 1uLL) == 1)
    {
      char v150 = v2_vInt64DataSize(v227[0]);
      if (v150 == 1
        || store_stream_read_bytes_2616(v25, &v227[1], (v150 - 1)) == (v150 - 1))
      {
        *(void *)uint64_t v242 = 0;
        unint64_t v114 = v2_readVInt64_2086((uint64_t)v227, (uint64_t *)v242);
      }
      else
      {
        unint64_t v114 = 0;
      }
    }
    int v27 = v222;
    uint64_t v54 = (uint64_t *)(v25 + 10);
    if (v114) {
      goto LABEL_134;
    }
    goto LABEL_195;
  }
  unint64_t v113 = v2_readVInt64_2086(*((void *)v25 + 6), v54);
  LODWORD(v114) = v113;
  if (!v113) {
    goto LABEL_195;
  }
LABEL_134:
  int v115 = 0;
  unsigned int v210 = 0;
  unint64_t v116 = 0;
  unint64_t v117 = 0;
  while (2)
  {
    uint64_t v118 = v114;
    unsigned int v119 = positionInfoAlloc((uint64_t)v213, v114 + v212 + 8);
    if (!v119)
    {
      int v36 = *__error();
      unint64_t v162 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v162, OS_LOG_TYPE_ERROR)) {
        goto LABEL_17;
      }
      *(_DWORD *)CFBit v227 = 136315394;
      *(void *)&v227[4] = "TermUpdateSetRestore";
      __int16 v228 = 1024;
      int v229 = 1167;
      double v158 = "%s:%d: posPtrStart==0";
      goto LABEL_238;
    }
    unsigned int v120 = v119;
    unint64_t v215 = v117;
    int v217 = v115;
    uint64_t v121 = (_DWORD *)(*((void *)v27 + 32) + 8 * v119);
    *uint64_t v121 = v114;
    uint64_t v122 = (char *)(v121 + 1);
    size_t v123 = *((void *)v25 + 4);
    uint64_t v124 = *((void *)v25 + 5);
    if (v124 + (unint64_t)v114 <= v123)
    {
      size_t v125 = 0;
      int v126 = v122;
      size_t v127 = v114;
      goto LABEL_138;
    }
    size_t v125 = v123 - v124;
    if (v123 != v124)
    {
      memcpy(v122, (const void *)(*((void *)v25 + 6) + v124), v123 - v124);
      size_t v123 = *((void *)v25 + 4);
      *((void *)v25 + 5) += v125;
    }
    unint64_t v137 = prot_pread(*v25, *((void **)v25 + 6), v123, *((void *)v25 + 3));
    if (v137 == -1)
    {
      size_t v125 = 0;
LABEL_173:
      uint8_t v25[4] = *__error();
      size_t v128 = v125;
      size_t v125 = 0;
    }
    else
    {
      *((void *)v25 + 4) = v137;
      *((void *)v25 + 5) = 0;
      *((void *)v25 + 3) += v137;
      if (v137)
      {
        int v126 = &v122[v125];
        size_t v127 = v114 - v125;
        if (v127 > v137)
        {
          size_t __na = v137;
          while (1)
          {
            memcpy(v126, *((const void **)v25 + 6), __na);
            float v140 = (void *)*((void *)v25 + 6);
            *((void *)v25 + 5) += __na;
            unint64_t v141 = prot_pread(*v25, v140, *((void *)v25 + 4), *((void *)v25 + 3));
            if (v141 == -1)
            {
              int v27 = v222;
              uint64_t v54 = (uint64_t *)(v25 + 10);
              goto LABEL_173;
            }
            *((void *)v25 + 4) = v141;
            *((void *)v25 + 5) = 0;
            *((void *)v25 + 3) += v141;
            if (!v141) {
              break;
            }
            uint64_t v124 = 0;
            v126 += __na;
            v127 -= __na;
            v125 += __na;
            size_t __na = v141;
            uint64_t v54 = (uint64_t *)(v25 + 10);
            if (v127 <= v141) {
              goto LABEL_138;
            }
          }
          size_t v128 = v125;
          size_t v125 = __na;
          int v27 = v222;
          uint64_t v54 = (uint64_t *)(v25 + 10);
        }
        else
        {
          uint64_t v124 = 0;
LABEL_138:
          memcpy(v126, (const void *)(*((void *)v25 + 6) + v124), v127);
          *((void *)v25 + 5) += v127;
          size_t v128 = v125;
          size_t v125 = v127;
          int v27 = v222;
        }
      }
      else
      {
        size_t v128 = 0;
      }
    }
    if (v114 != v125 + v128)
    {
      int v36 = *__error();
      int v156 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v156, OS_LOG_TYPE_ERROR)) {
        goto LABEL_17;
      }
      unsigned int v177 = v25[4];
      *(_DWORD *)CFBit v227 = 136315650;
      *(void *)&v227[4] = "TermUpdateSetRestore";
      __int16 v228 = 1024;
      int v229 = 1177;
      __int16 v230 = 1024;
      *(_DWORD *)uint64_t v231 = v177;
      double v158 = "%s:%d: read error %d";
      goto LABEL_232;
    }
    uint64_t v129 = (v114 - 1);
    if (v122[v129])
    {
      int v36 = *__error();
      BOOL v178 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v178, OS_LOG_TYPE_ERROR)) {
        goto LABEL_17;
      }
      int v179 = v122[v129];
      *(_DWORD *)CFBit v227 = 136315650;
      *(void *)&v227[4] = "TermUpdateSetRestore";
      __int16 v228 = 1024;
      int v229 = 1185;
      __int16 v230 = 1024;
      *(_DWORD *)uint64_t v231 = v179;
      double v158 = "%s:%d: posStart[len-1]: %d";
      goto LABEL_269;
    }
    *(_DWORD *)&v122[v114] = 0;
    unint64_t v114 = *((void *)v27 + 32);
    if (v116)
    {
      double v130 = &v116[v114 - v215];
      if (v215 == v114) {
        double v130 = v116;
      }
      *(_DWORD *)double v130 = v120;
    }
    else
    {
      unsigned int v210 = v120;
    }
    int v131 = v217;
    uint64_t v132 = *((void *)v25 + 5);
    if ((unint64_t)(*((void *)v25 + 4) - v132) >= 6)
    {
      uint64_t v133 = *((void *)v25 + 6);
      uint64_t v134 = v132 + 1;
      unsigned int VInt32 = *(unsigned __int8 *)(v133 + v132);
      if (*(char *)(v133 + v132) < 0)
      {
        unsigned int v136 = v220;
        if (VInt32 > 0xBF)
        {
          if (VInt32 > 0xDF)
          {
            if (VInt32 > 0xEF)
            {
              unsigned int VInt32 = *(_DWORD *)(v133 + v134);
              *uint64_t v54 = v132 + 5;
              if (!VInt32) {
                goto LABEL_192;
              }
            }
            else
            {
              unsigned int VInt32 = ((VInt32 & 0xF) << 24) | (*(unsigned __int8 *)(v133 + v134) << 16) | (*(unsigned __int8 *)(v132 + v133 + 2) << 8) | *(unsigned __int8 *)(v132 + v133 + 3);
              *uint64_t v54 = v132 + 4;
              if (!VInt32) {
                goto LABEL_192;
              }
            }
          }
          else
          {
            unsigned int VInt32 = ((VInt32 & 0x1F) << 16) | (*(unsigned __int8 *)(v133 + v134) << 8) | *(unsigned __int8 *)(v132 + v133 + 2);
            *uint64_t v54 = v132 + 3;
            if (!VInt32) {
              goto LABEL_192;
            }
          }
        }
        else
        {
          unsigned int VInt32 = *(unsigned __int8 *)(v133 + v134) | ((VInt32 & 0x3F) << 8);
          *uint64_t v54 = v132 + 2;
          if (!VInt32) {
            goto LABEL_192;
          }
        }
      }
      else
      {
        unsigned int v136 = v220;
        *uint64_t v54 = v134;
        if (!VInt32) {
          goto LABEL_192;
        }
      }
LABEL_160:
      if (v131 == v136)
      {
        int v36 = *__error();
        unsigned int v174 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v174, OS_LOG_TYPE_ERROR)) {
          goto LABEL_17;
        }
        *(_DWORD *)CFBit v227 = 136315906;
        *(void *)&v227[4] = "TermUpdateSetRestore";
        __int16 v228 = 1024;
        int v229 = 1232;
        __int16 v230 = 1024;
        *(_DWORD *)uint64_t v231 = v220;
        *(_WORD *)&v231[4] = 1024;
        *(_DWORD *)&v231[6] = v220;
        double v158 = "%s:%d: invalid position data %d %d";
        goto LABEL_262;
      }
      int v115 = v131 + 1;
      unint64_t v116 = &v122[v118];
      unint64_t v117 = v114;
      LODWORD(v114) = VInt32;
      continue;
    }
    break;
  }
  *(_WORD *)&v227[8] = 0;
  *(void *)CFBit v227 = 0;
  size_t v138 = store_stream_read_bytes_2616(v25, v227, 1uLL);
  unsigned int VInt32 = 0;
  if (v138 != 1)
  {
LABEL_183:
    unsigned int v136 = v220;
    if (!VInt32) {
      goto LABEL_192;
    }
    goto LABEL_160;
  }
  if ((v227[0] & 0x80000000) == 0
    || (v227[0] >= 0xC0u
      ? (v227[0] >= 0xE0u
       ? (v227[0] < 0xF0u
        ? (size_t v139 = 3)
        : (size_t v139 = 4))
       : (size_t v139 = 2))
      : (size_t v139 = 1),
        BOOL v34 = store_stream_read_bytes_2616(v25, &v227[1], v139) == v139,
        int v27 = v222,
        uint64_t v54 = (uint64_t *)(v25 + 10),
        int v131 = v217,
        v34))
  {
    *(void *)uint64_t v242 = 0;
    unsigned int VInt32 = v2_readVInt32((uint64_t)v227, (uint64_t *)v242);
    goto LABEL_183;
  }
  unsigned int v136 = v220;
LABEL_192:
  if (*v207 || (int v142 = v131 + 1, v142 == v136))
  {
    *(_DWORD *)(v203 + 32 * v205 + 4) = v210;
    goto LABEL_195;
  }
  int v36 = *__error();
  unsigned int v174 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v174, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)CFBit v227 = 136315906;
    *(void *)&v227[4] = "TermUpdateSetRestore";
    __int16 v228 = 1024;
    int v229 = 1222;
    __int16 v230 = 1024;
    *(_DWORD *)uint64_t v231 = v142;
    *(_WORD *)&v231[4] = 1024;
    *(_DWORD *)&v231[6] = v220;
    double v158 = "%s:%d: invalid position data %d %d";
LABEL_262:
    uint64_t v159 = v227;
    int v160 = v174;
    goto LABEL_249;
  }
LABEL_17:
  *__error() = v36;
LABEL_18:
  if (v27) {
    goto LABEL_225;
  }
  return v27;
}

uint64_t v2_vInt64DataSize(unsigned int a1)
{
  if (a1 == 255) {
    char v1 = 9;
  }
  else {
    char v1 = 8;
  }
  if (a1 >= 0xFE) {
    char v2 = v1;
  }
  else {
    char v2 = 7;
  }
  if (a1 >= 0xFC) {
    char v3 = v2;
  }
  else {
    char v3 = 6;
  }
  if (a1 >= 0xF8) {
    char v4 = v3;
  }
  else {
    char v4 = 5;
  }
  if (a1 >= 0xF0) {
    char v5 = v4;
  }
  else {
    char v5 = 4;
  }
  if (a1 >= 0xE0) {
    char v6 = v5;
  }
  else {
    char v6 = 3;
  }
  if (a1 >= 0xC0) {
    unsigned __int8 v7 = v6;
  }
  else {
    unsigned __int8 v7 = 2;
  }
  if ((a1 & 0x80) != 0) {
    return v7;
  }
  else {
    return 1;
  }
}

uint64_t TermUpdateSetRemoveFromAccounting(uint64_t result)
{
  unint64_t v1 = *(void *)(result + 224);
  unint64_t v2 = atomic_load((unint64_t *)gTotalCurrentUsage);
  if (v1 > v2)
  {
    char v3 = __si_assert_copy_extra_329();
    char v4 = v3;
    char v5 = "";
    if (v3) {
      char v5 = v3;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 1423, "termUpdateSet->reportedSize <= gTotalCurrentUsage", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  atomic_fetch_add(gTotalCurrentUsage, -*(void *)(result + 224));
  *(void *)(result + 224) = 0;
  return result;
}

uint64_t TermUpdateSetUpdateDocumentInfo(uint64_t a1, unsigned int a2, uint64_t a3, const __CFDictionary *a4, const __CFDictionary *a5, int a6, uint64_t a7, int a8, uint64_t a9, int a10, unsigned __int8 a11)
{
  if (!a3)
  {
    unsigned int v35 = __si_assert_copy_extra_329();
    int v36 = v35;
    int v37 = "";
    if (v35) {
      int v37 = v35;
    }
    __message_assert("%s:%u: failed assertion '%s' %s Expected non-zero docID", "TermUpdateSet.c", 2278, "docID", v37);
    free(v36);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  poslock(*(pthread_rwlock_t **)(a1 + 280));
  HIDWORD(v18) = qos_class_self() - 9;
  LODWORD(v18) = HIDWORD(v18);
  unsigned int v17 = v18 >> 2;
  if (v17 > 6) {
    signed int v19 = 0;
  }
  else {
    signed int v19 = dword_1BDA87810[v17];
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 304));
  if (*(void *)(a1 + 488) || *(_DWORD *)(a1 + 500) || *(unsigned char *)(a1 + 516)) {
    goto LABEL_8;
  }
  if (v19 <= 5)
  {
    if (*(void *)(a1 + 16 * v19 + 368))
    {
LABEL_8:
      db_rwlock_wait(a1 + 304, v19, 2);
      goto LABEL_9;
    }
    uint64_t v32 = v19 - 1;
    char v33 = (uint64_t *)(a1 + 16 * v19 + 384);
    while (v32 != 4)
    {
      uint64_t v34 = *v33;
      v33 += 2;
      ++v32;
      if (v34)
      {
        if (v32 <= 4) {
          goto LABEL_8;
        }
        break;
      }
    }
  }
  *(void *)(a1 + 488) = pthread_self();
LABEL_9:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 304));
  ++*(_DWORD *)(a1 + 112);
  switch(a6)
  {
    case 0:
      uint64_t v20 = (void *)(a1 + 128);
      goto LABEL_19;
    case 1:
      uint64_t v20 = (void *)(a1 + 168);
      goto LABEL_19;
    case 2:
      uint64_t v20 = (void *)(a1 + 144);
      goto LABEL_19;
    case 3:
      uint64_t v20 = (void *)(a1 + 120);
      goto LABEL_19;
    case 6:
      uint64_t v20 = (void *)(a1 + 136);
      goto LABEL_19;
    case 7:
      uint64_t v20 = (void *)(a1 + 192);
      goto LABEL_19;
    case 9:
      uint64_t v20 = (void *)(a1 + 200);
      goto LABEL_19;
    case 10:
      uint64_t v20 = (void *)(a1 + 208);
      goto LABEL_19;
    case 11:
      uint64_t v20 = (void *)(a1 + 216);
LABEL_19:
      ++*v20;
      break;
    default:
      break;
  }
  uint64_t v43 = 0;
  CFAllocatorRef v21 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFTypeRef cf = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &stringUnqBuffSetCallBacks);
  CFTypeRef Mutable = CFSetCreateMutable(v21, 0, &stringUnqBuffSetCallBacks);
  size_t v44 = 0;
  uint64_t v22 = (size_t *)MEMORY[0x1E4F14B00];
  uint64_t v23 = *MEMORY[0x1E4F14B00];
  int v24 = 0;
  if (!my_vm_allocate((void **)&v44, *MEMORY[0x1E4F14B00], 1u))
  {
    int v24 = v44;
    int v25 = v44 + 24;
    *(void *)size_t v44 = 0;
    v24[1] = v25;
    int v24[2] = (char *)v24 + v23;
    madvise(v25, *v22, 3);
  }
  unsigned int v40 = v24;
  unsigned int v26 = CIRetainIndexingTokenizer(a2);
  if (a5) {
    termUpdateSetProcessFields(a1, (uint64_t)&v40, (uint64_t)v26, a3, 0, a5, 2u, a11);
  }
  if (a4) {
    termUpdateSetProcessFields(a1, (uint64_t)&v40, (uint64_t)v26, a3, 0, a4, 1u, a11);
  }
  termUpdateSetProcessWildCardFields(a1, a3, (CFSetRef)Mutable, 2);
  termUpdateSetProcessWildCardFields(a1, a3, (CFSetRef)cf, 1);
  CIReleaseIndexingTokenizer((uint64_t)v26);
  CFRelease(cf);
  CFRelease(Mutable);
  int v27 = v40;
  if (v40)
  {
    do
    {
      int v28 = (void *)*v27;
      munmap(v27, v27[2] - (void)v27);
      int v27 = v28;
    }
    while (v28);
  }
  if (a8) {
    doChildFile(a1 + 88, (void *)(a1 + 48), a8, a7, a3, 1);
  }
  if (a10) {
    doChildFile(a1 + 88, (void *)(a1 + 48), a10, a9, a3, 2);
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 304));
  *(_DWORD *)(a1 + 508) = 0;
  unsigned int v29 = *(pthread_override_s **)(a1 + 480);
  *(void *)(a1 + 480) = 0;
  *(void *)(a1 + 488) = 0;
  char v30 = *(_DWORD *)(a1 + 500) != 0;
  *(unsigned char *)(a1 + 516) = 0;
  db_rwlock_wakeup(a1 + 304, v30, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 304));
  if (v29) {
    pthread_override_qos_class_end_np(v29);
  }
  return poswriteunlock(*(pthread_rwlock_t **)(a1 + 280));
}

CFIndex termUpdateSetProcessWildCardFields(uint64_t a1, uint64_t a2, CFSetRef theSet, int a4)
{
  v15[1] = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFSetGetCount(theSet);
  MEMORY[0x1F4188790](Count);
  uint64_t v10 = (const void **)((char *)v15 - v9);
  bzero((char *)v15 - v9, v11);
  CFSetGetValues(theSet, v10);
  if (Count >= 1)
  {
    CFIndex v12 = Count;
    do
    {
      char v13 = (unsigned __int8 *)*v10++;
      pushPropertyTerm(a1, *(__int16 *)v13, v13 + 2, a2, 0, a4, 1);
      --v12;
    }
    while (v12);
  }
  return Count;
}

unint64_t termUpdateSetProcessSingleVector(uint64_t a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFNumberRef number = 0;
  value = 0;
  unint64_t result = CFDictionaryGetValueIfPresent(theDict, @"vec_data", (const void **)&value);
  if (result)
  {
    unint64_t result = CFDictionaryGetValueIfPresent(theDict, @"vec_id", (const void **)&number);
    if (result)
    {
      uint64_t v31 = 0;
      unsigned int valuePtr = 0;
      CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr);
      if (CFDictionaryGetValueIfPresent(theDict, @"vec_dim", (const void **)&number))
      {
        CFTypeID v11 = CFGetTypeID(number);
        if (v11 == CFNumberGetTypeID()) {
          CFNumberGetValue(number, kCFNumberSInt8Type, &v31);
        }
      }
      if (CFDictionaryGetValueIfPresent(theDict, @"vec_format", (const void **)&number))
      {
        CFTypeID v12 = CFGetTypeID(number);
        if (v12 == CFNumberGetTypeID()) {
          CFNumberGetValue(number, kCFNumberSInt8Type, (char *)&v31 + 4);
        }
      }
      unsigned __int16 v29 = 0;
      if (CFDictionaryGetValueIfPresent(theDict, @"vec_version", (const void **)&number))
      {
        CFTypeID v13 = CFGetTypeID(number);
        if (v13 == CFNumberGetTypeID()) {
          CFNumberGetValue(number, kCFNumberSInt16Type, &v29);
        }
      }
      unint64_t v14 = -1;
      if (v31 <= 2 && HIDWORD(v31) <= 2) {
        unint64_t v14 = (vector_dimension_vec_sizes_12485[v31]
      }
                           * vector_size_elem_sizes_12484[HIDWORD(v31)]);
      unint64_t result = CFDataGetLength((CFDataRef)value);
      if (v14 <= result)
      {
        uint64_t v15 = *(void *)(a1 + 80);
        uint64_t v16 = v29;
        uint64_t v17 = valuePtr;
        BytePtr = CFDataGetBytePtr((CFDataRef)value);
        uint64_t v19 = v31;
        uint64_t v20 = HIDWORD(v31);
        if (__THREAD_SLOT_KEY)
        {
          unint64_t v21 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
          if (!v21) {
            goto LABEL_33;
          }
        }
        else
        {
          makeThreadId();
          unint64_t v21 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
          if (!v21) {
            goto LABEL_33;
          }
        }
        if (v21 < 0x801)
        {
          int v22 = 0;
LABEL_20:
          if (v21 <= 0x800)
          {
            uint64_t v23 = &threadData[18 * v21];
            int v22 = *(v23 - 11);
            *(v23 - 11) = 1;
          }
LABEL_22:
          int v28 = v22;
          if (!v17)
          {
            int v25 = __si_assert_copy_extra_329();
            unsigned int v26 = v25;
            int v27 = "";
            if (v25) {
              int v27 = v25;
            }
            __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndex.cpp", 275, "vectorId > 0", v27);
            free(v26);
            if (__valid_fs(-1))
            {
              MEMORY[0xBAD] = -559038737;
              abort();
            }
            MEMORY[0xC00] = -559038737;
            abort();
          }
          IVFVectorIndexUpdateSet::getOrCreateVectorIndex(&v34, v15, a5, v16, v19, v20, 0);
          (*(void (**)(uint64_t, uint64_t, uint64_t, const UInt8 *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v34 + 64))(v34, a5, v17, BytePtr, v19, v20, a3, a4, a1 + 88);
          int v24 = v35;
          if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
            std::__shared_weak_count::__release_weak(v24);
          }
          if (__THREAD_SLOT_KEY)
          {
            unint64_t result = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
            if (!result) {
              goto LABEL_40;
            }
          }
          else
          {
            makeThreadId();
            unint64_t result = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
            if (!result) {
              goto LABEL_40;
            }
          }
          if (result < 0x801)
          {
LABEL_29:
            if (result <= 0x800) {
              threadData[18 * result - 11] = v28;
            }
            return result;
          }
LABEL_40:
          makeThreadId();
          unint64_t result = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
          if (!result) {
            return result;
          }
          goto LABEL_29;
        }
LABEL_33:
        makeThreadId();
        unint64_t v21 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
        int v22 = 0;
        if (!v21) {
          goto LABEL_22;
        }
        goto LABEL_20;
      }
    }
  }
  return result;
}

void pushPropertyTermForWildCard(void **a1, size_t a2, const void *a3, int a4)
{
  v19[1] = *MEMORY[0x1E4F143B8];
  size_t v8 = a2 + 2;
  MEMORY[0x1F4188790](a1);
  uint64_t v10 = (_WORD *)((char *)v19 - ((v9 + 17) & 0xFFFFFFFFFFFFFFF0));
  bzero(v10, v8);
  _WORD *v10 = a2;
  memcpy(v10 + 1, a3, a2);
  uint64_t v11 = 1;
  if (a4 == 2) {
    uint64_t v11 = 2;
  }
  CFTypeID v12 = (__CFSet *)a1[v11];
  if (!CFSetContainsValue(v12, v10))
  {
    CFTypeID v13 = *a1;
    while (2)
    {
      for (unint64_t i = atomic_load(v13 + 1); i + v8 + 8 >= v13[2]; unint64_t i = atomic_load(v16))
      {
        os_unfair_lock_lock(&_slablock);
        CFTypeID v13 = *a1;
        uint64_t v16 = *a1 + 1;
        unint64_t v17 = atomic_load(v16);
        if (v17 + v8 + 8 >= v13[2])
        {
          unint64_t i = (unint64_t)slab_new_slab(a1, v8, -1);
          os_unfair_lock_unlock(&_slablock);
LABEL_11:
          madvise((void *)((i & 0xFFFFFFFFFFFC0000) + 0x40000), 0x40000uLL, 3);
          goto LABEL_12;
        }
        os_unfair_lock_unlock(&_slablock);
      }
      unint64_t v14 = i;
      atomic_compare_exchange_strong(v13 + 1, &v14, i + v8);
      if (v14 != i) {
        continue;
      }
      break;
    }
    unint64_t v18 = atomic_load(v13 + 1);
    if ((v18 ^ i) >= 0x40000) {
      goto LABEL_11;
    }
LABEL_12:
    memcpy((void *)i, v10, v8);
    CFSetAddValue(v12, (const void *)i);
  }
}

uint64_t _getContentRankedSubTokensCallback(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = 0;
  v16[1] = *MEMORY[0x1E4F143B8];
  if (a2 <= 1044)
  {
    unsigned int v7 = *(_DWORD *)(a4 + 32);
    if (v7 && v7 <= 5)
    {
      uint64_t v9 = a2 + 3;
      MEMORY[0x1F4188790](0);
      uint64_t v11 = (char *)v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
      size_t v13 = 2 * v12;
      if (v10 <= 2 * v12) {
        size_t v14 = 0;
      }
      else {
        size_t v14 = 6;
      }
      uint64_t v15 = &v11[v13];
      bzero(&v11[v13], v14);
      memcpy(v11, a1, v13);
      *(_WORD *)uint64_t v15 = 1;
      *((_WORD *)v15 + 1) = v7;
      *((_WORD *)v15 + 2) = 5;
      return getContentTokensCallback(v11, v9, 1, a4);
    }
  }
  return result;
}

uint64_t decode_prefix(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3)
{
  unint64_t v4 = (unint64_t)tcmr[*a1] >> 4;
  uint64_t v5 = utf8_byte_length(unsigned char)::utf8_len_table[v4];
  if ((v4 & 0xC) != 8)
  {
    char v6 = a1;
    unsigned int v7 = a3;
    uint64_t v8 = v5;
    do
    {
      int v9 = *v6++;
      *v7++ = tcmr[v9];
      --v8;
    }
    while (v8);
  }
  unint64_t v10 = &a3[v5];
  if (v5 >= a2)
  {
    LODWORD(v21) = a3 + v5;
    return (v21 - a3);
  }
  uint64_t v11 = &a1[v5];
  uint64_t v12 = &a1[a2];
  unint64_t v13 = (unint64_t)tcmr[a1[v5]] >> 4;
  uint64_t v14 = utf8_byte_length(unsigned char)::utf8_len_table[v13];
  if ((v13 & 0xC) != 8)
  {
    uint64_t v15 = &a1[v5];
    uint64_t v16 = &a3[v5];
    uint64_t v17 = v14;
    do
    {
      int v18 = *v15++;
      *v16++ = tcmr[v18];
      --v17;
    }
    while (v17);
  }
  uint64_t v19 = &v11[v14];
  if (&v11[v14] >= v12) {
    goto LABEL_70;
  }
  int v20 = (char)*v10;
  if ((v20 & 0x80000000) == 0) {
    goto LABEL_10;
  }
  uint64_t v22 = utf8_byte_length(unsigned char)::utf8_len_table[(unint64_t)*v10 >> 4];
  int v23 = (utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v22] & *v10);
  if ((~((unint64_t)*v10 >> 4) & 0xC) != 0) {
    goto LABEL_24;
  }
  uint64_t v24 = v22 <= 2 ? 2 : utf8_byte_length(unsigned char)::utf8_len_table[(unint64_t)*v10 >> 4];
  uint64_t v25 = v24 - 1;
  unsigned int v26 = &a3[v5 + 1];
  do
  {
    char v27 = *v26++;
    int v23 = v27 & 0x3F | (v23 << 6);
    --v25;
  }
  while (v25);
  if (v23 < 0x10000)
  {
LABEL_24:
    BOOL v28 = (v23 - 12441) >= 4 && (v23 - 65438) >= 2;
    if (v28 && !unicode_combinable((unsigned __int16)v23)) {
      goto LABEL_10;
    }
  }
  else
  {
    unsigned int v41 = v23 - 917760;
    unsigned int v42 = v23 - 127995;
    if (v41 >= 0xF0 && v42 > 4) {
      goto LABEL_10;
    }
  }
  v10 += v14;
  unint64_t v29 = (unint64_t)tcmr[*v19] >> 4;
  uint64_t v14 = utf8_byte_length(unsigned char)::utf8_len_table[v29];
  if ((v29 & 0xC) != 8)
  {
    char v30 = v19;
    uint64_t v31 = v10;
    uint64_t v32 = v14;
    do
    {
      int v33 = *v30++;
      *v31++ = tcmr[v33];
      --v32;
    }
    while (v32);
  }
  v19 += v14;
  if (v19 >= v12) {
    goto LABEL_70;
  }
  LOBYTE(v20) = *v10;
LABEL_10:
  if (v20 != 45)
  {
    if (v20 == 239)
    {
      if (v10[1] != 188 || v10[2] != 189) {
        goto LABEL_54;
      }
    }
    else if (v20 != 226 || v10[1] != 128 || (v10[2] & 0xFE) != 0x90)
    {
      goto LABEL_54;
    }
  }
  unint64_t v34 = *a3;
  if ((char)*a3 < 0)
  {
    uint64_t v35 = utf8_byte_length(unsigned char)::utf8_len_table[v34 >> 4];
    int v36 = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v35] & v34;
    if ((~(v34 >> 4) & 0xC) != 0)
    {
      LODWORD(v34) = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v35] & v34;
    }
    else
    {
      if (v35 <= 2) {
        uint64_t v37 = 2;
      }
      else {
        uint64_t v37 = utf8_byte_length(unsigned char)::utf8_len_table[v34 >> 4];
      }
      uint64_t v38 = v37 - 1;
      unsigned int v39 = (char *)(a3 + 1);
      do
      {
        char v40 = *v39++;
        LODWORD(v34) = v40 & 0x3F | (v36 << 6);
        int v36 = v34;
        --v38;
      }
      while (v38);
    }
  }
  if (((1 << u_charType(v34)) & 0xE3E) != 0)
  {
    v10 += v14;
    unint64_t v44 = (unint64_t)tcmr[*v19] >> 4;
    uint64_t v14 = utf8_byte_length(unsigned char)::utf8_len_table[v44];
    if ((v44 & 0xC) != 8)
    {
      size_t v45 = v19;
      int v46 = v10;
      uint64_t v47 = v14;
      do
      {
        int v48 = *v45++;
        *v46++ = tcmr[v48];
        --v47;
      }
      while (v47);
    }
    v19 += v14;
    if (v19 >= v12)
    {
LABEL_70:
      LODWORD(v21) = v10 + v14;
      return (v21 - a3);
    }
  }
LABEL_54:
  uint64_t v49 = v14;
  unint64_t v21 = (char *)&v10[v14];
  unint64_t v50 = (unint64_t)tcmr[*v19] >> 4;
  uint64_t v51 = utf8_byte_length(unsigned char)::utf8_len_table[v50];
  if ((v50 & 0xC) != 8)
  {
    long long v52 = v21;
    uint64_t v53 = v51;
    do
    {
      int v54 = *v19++;
      *v52++ = tcmr[v54];
      --v53;
    }
    while (v53);
  }
  if (*v21 < 0)
  {
    unint64_t v55 = *v21;
    unint64_t v56 = v55 >> 4;
    uint64_t v57 = utf8_byte_length(unsigned char)::utf8_len_table[v55 >> 4];
    int v58 = v55 & utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v57];
    if ((~(_BYTE)v56 & 0xC) != 0) {
      goto LABEL_65;
    }
    uint64_t v57 = v57 <= 2 ? 2 : v57;
    uint64_t v59 = v57 - 1;
    char v60 = (char *)&v10[v49 + 1];
    do
    {
      char v61 = *v60++;
      int v58 = v61 & 0x3F | (v58 << 6);
      --v59;
    }
    while (v59);
    if (v58 < 0x10000)
    {
LABEL_65:
      BOOL v62 = (v58 - 12441) >= 4 && (v58 - 65438) >= 2;
      if (v62 && !unicode_combinable((unsigned __int16)v58)) {
        return (v21 - a3);
      }
LABEL_69:
      LODWORD(v21) = v21 + v51;
      return (v21 - a3);
    }
    unsigned int v64 = v58 - 917760;
    unsigned int v65 = v58 - 127995;
    if (v64 < 0xF0 || v65 <= 4) {
      goto LABEL_69;
    }
  }
  return (v21 - a3);
}

uint64_t _getContentRankedTokensCallback(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (a2 < 1)
  {
LABEL_5:
    uint64_t result = 0;
    if (a2 <= 1044)
    {
      unsigned int v8 = *(_DWORD *)(a4 + 32);
      if (v8 && v8 <= 5)
      {
        uint64_t v10 = a2 + 3;
        MEMORY[0x1F4188790](0);
        uint64_t v12 = &buf[-((v11 + 15) & 0xFFFFFFFFFFFFFFF0)];
        size_t v14 = 2 * v13;
        if (v11 <= 2 * v13) {
          size_t v15 = 0;
        }
        else {
          size_t v15 = 6;
        }
        uint64_t v16 = &v12[v14];
        bzero(&v12[v14], v15);
        memcpy(v12, a1, v14);
        *(_WORD *)uint64_t v16 = 1;
        *((_WORD *)v16 + 1) = v8;
        *((_WORD *)v16 + 2) = 5;
        return getContentTokensCallback((char *)v12, v10, 0, a4);
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    while (a1[v6] > 5u)
    {
      if (a2 == ++v6) {
        goto LABEL_5;
      }
    }
    if (_getContentRankedTokensCallback_logCount <= 49)
    {
      ++_getContentRankedTokensCallback_logCount;
      int v17 = *__error();
      int v18 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        int v19 = a1[v6];
        int v20 = (const char *)__si_error_str_key;
        if (__si_error_str_key) {
          int v20 = (const char *)pthread_getspecific(__si_error_str_key);
        }
        unint64_t v21 = "";
        *(_DWORD *)std::string buf = 136315906;
        int v23 = "_getContentRankedTokensCallback";
        __int16 v24 = 1024;
        if (v20) {
          unint64_t v21 = v20;
        }
        int v25 = 1845;
        __int16 v26 = 1024;
        int v27 = v19;
        __int16 v28 = 2080;
        unint64_t v29 = v21;
        _os_log_error_impl(&dword_1BD672000, v18, OS_LOG_TYPE_ERROR, "%s:%d: invalid content token (%d) for %s", buf, 0x22u);
      }
      *__error() = v17;
    }
    return 1;
  }
  return result;
}

void pushPrefixTermsForWildCard(void **a1, uint64_t a2, char *a3, unsigned int a4, const void *a5, int a6)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = utf8_byte_length(unsigned char)::utf8_len_table[(unint64_t)*a3 >> 4];
  if (v6 > a2) {
    return;
  }
  unint64_t v11 = (unsigned __int8 *)&a3[a2];
  size_t v12 = a4;
  uint64_t v13 = &a3[v6];
  if (v6 < a2 && *v13 < 0)
  {
    unint64_t v14 = *v13;
    unint64_t v15 = v14 >> 4;
    uint64_t v16 = utf8_byte_length(unsigned char)::utf8_len_table[v14 >> 4];
    int v17 = v14 & utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v16];
    if ((~(_BYTE)v15 & 0xC) != 0) {
      goto LABEL_11;
    }
    uint64_t v18 = v16 <= 2 ? 2 : v16;
    uint64_t v19 = v18 - 1;
    int v20 = (unsigned __int8 *)&a3[v6 + 1];
    do
    {
      char v21 = *v20++;
      int v17 = v21 & 0x3F | (v17 << 6);
      --v19;
    }
    while (v19);
    if (v17 < 0x10000)
    {
LABEL_11:
      BOOL v22 = (v17 - 12441) >= 4 && (v17 - 65438) >= 2;
      if (v22 && !unicode_combinable((unsigned __int16)v17)) {
        goto LABEL_16;
      }
LABEL_15:
      v13 += v16;
      goto LABEL_16;
    }
    unsigned int v38 = v17 - 917760;
    unsigned int v39 = v17 - 127995;
    if (v38 < 0xF0 || v39 <= 4) {
      goto LABEL_15;
    }
  }
LABEL_16:
  int64_t v23 = v13 - a3;
  if ((unint64_t)(v13 - a3) <= 0x1F) {
    size_t v24 = 32 - (v13 - a3);
  }
  else {
    size_t v24 = 0;
  }
  bzero(&__dst[v23], v24);
  memcpy(__dst, a3, v13 - a3);
  memcpy(&__dst[v23], a5, v12);
  pushPropertyTermForWildCard(a1, v23 + v12, __dst, a6);
  uint64_t v25 = utf8_byte_length(unsigned char)::utf8_len_table[(unint64_t)*v13 >> 4];
  __int16 v26 = &v13[v25];
  if (&v13[v25] <= (char *)v11)
  {
    if (&v13[v25] < (char *)v11 && *v26 < 0)
    {
      unint64_t v27 = *v26;
      unint64_t v28 = v27 >> 4;
      uint64_t v29 = utf8_byte_length(unsigned char)::utf8_len_table[v27 >> 4];
      int v30 = v27 & utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v29];
      if ((~(_BYTE)v28 & 0xC) != 0) {
        goto LABEL_29;
      }
      uint64_t v31 = v29 <= 2 ? 2 : v29;
      uint64_t v32 = v31 - 1;
      int v33 = (unsigned __int8 *)&v13[v25 + 1];
      do
      {
        char v34 = *v33++;
        int v30 = v34 & 0x3F | (v30 << 6);
        --v32;
      }
      while (v32);
      if (v30 < 0x10000)
      {
LABEL_29:
        BOOL v35 = (v30 - 12441) >= 4 && (v30 - 65438) >= 2;
        if (v35 && !unicode_combinable((unsigned __int16)v30)) {
          goto LABEL_34;
        }
      }
      else
      {
        unsigned int v41 = v30 - 917760;
        unsigned int v42 = v30 - 127995;
        if (v41 >= 0xF0 && v42 >= 5) {
          goto LABEL_34;
        }
      }
      v26 += v29;
    }
LABEL_34:
    size_t v36 = v26 - a3;
    if (v36 <= 0x1F) {
      size_t v37 = 32 - v36;
    }
    else {
      size_t v37 = 0;
    }
    bzero(&__dst[v36], v37);
    memcpy(__dst, a3, v36);
    memcpy(&__dst[v36], a5, v12);
    pushPropertyTermForWildCard(a1, v36 + v12, __dst, a6);
  }
}

CFTypeID __termUpdateSetProcessVector_block_invoke()
{
  termUpdateSetProcessVector_sArrayCFTypeID TypeID = CFArrayGetTypeID();
  CFTypeID result = CFDictionaryGetTypeID();
  termUpdateSetProcessVector_sDictionaryCFTypeID TypeID = result;
  return result;
}

uint64_t stringUnqBuffHashCallback(__int16 *a1)
{
  int v1 = -1759636613;
  unsigned int v2 = *a1;
  char v3 = (unsigned __int8 *)a1 + (int)((__int16)(*a1 + ((v2 >> 29) & 3)) & 0xFFFFFFFC) + 2;
  if (v2 + 3 >= 7)
  {
    uint64_t v6 = -((__int16)(v2 + ((v2 >> 29) & 3)) >> 2);
    int v7 = -1789642873;
    int v8 = 718793509;
    do
    {
      int v7 = 5 * v7 + 2071795100;
      int v8 = 5 * v8 + 1808688022;
      HIDWORD(v9) = v7 * *(_DWORD *)&v3[4 * v6];
      LODWORD(v9) = HIDWORD(v9);
      int v10 = (v9 >> 21) * v8;
      HIDWORD(v9) = v1;
      LODWORD(v9) = v1;
      int v1 = v10 ^ (5 * (v9 >> 19) + 1390208809);
    }
    while (!__CFADD__(v6++, 1));
    int v5 = 5 * v7 + 2071795100;
    int v4 = 5 * v8 + 1808688022;
  }
  else
  {
    int v4 = 1107688271;
    int v5 = 1713515327;
  }
  int v12 = 0;
  int v13 = v2 & 3;
  switch(v13)
  {
    case 1:
      goto LABEL_12;
    case 2:
LABEL_11:
      v12 |= *((unsigned __int8 *)a1 + (int)((__int16)(*a1 + ((*a1 >> 29) & 3)) & 0xFFFFFFFC) + 3) << 8;
LABEL_12:
      HIDWORD(v14) = (v12 ^ *v3) * v5;
      LODWORD(v14) = HIDWORD(v14);
      int v15 = (v14 >> 21) * v4;
      HIDWORD(v14) = v1;
      LODWORD(v14) = v1;
      int v1 = v15 ^ (5 * (v14 >> 19) + 1390208809);
      break;
    case 3:
      int v12 = *((unsigned __int8 *)a1 + (int)((__int16)(*a1 + ((*a1 >> 29) & 3)) & 0xFFFFFFFC) + 4) << 16;
      goto LABEL_11;
  }
  unsigned int v16 = (-2048144789 * (v1 ^ v2)) ^ ((-2048144789 * (v1 ^ v2)) >> 13);
  return ((53 * v16) ^ ((-1028477387 * v16) >> 16));
}

BOOL stringUnqBuffEqualCallback(unsigned __int16 *a1, unsigned __int16 *a2)
{
  int v2 = *a1;
  return v2 == *a2 && memcmp(a1 + 1, a2 + 1, (__int16)v2) == 0;
}

uint64_t ___hashTableIterate_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 40);
  uint64_t v3 = *(void *)(*(void *)(result + 32) + 8);
  uint64_t v4 = *(unsigned int *)(v3 + 24);
  *(_DWORD *)(v3 + 24) = v4 + 1;
  *(void *)(v2 + 8 * v4) = a2 + 16;
  return result;
}

uint64_t termUpdateSetApplier(uint64_t a1, uint64_t (**a2)(void))
{
  if (*(unsigned __int16 *)(a1 + 16) >= 0x415u)
  {
    uint64_t v4 = __si_assert_copy_extra_329();
    int v5 = v4;
    uint64_t v6 = "";
    if (v4) {
      uint64_t v6 = v4;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 2374, "tu->termLen <= (1024+20)", v6);
    free(v5);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v2 = *a2;
  return v2();
}

void SIUserCtxSetArgumentDictionary(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    uint64_t v4 = *(const void **)(a1 + 168);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 168) = 0;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 168) = cf;
  }
}

uint64_t SIUserCtxGetEntitlements(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 176);
  }
  return result;
}

uint64_t SISetDefaultSchemaData(void *a1, size_t a2)
{
  if (gDefaultSchema)
  {
    return munmap(a1, a2);
  }
  else
  {
    uint64_t result = _MDPlistContainerCreateWithBytes();
    gDefaultSchema = result;
  }
  return result;
}

_DWORD *TokenDataCreate(const char *a1, int a2)
{
  int64_t v4 = strlen(a1);
  int v5 = 0;
  if (v4)
  {
    int64_t v6 = v4;
    if (v4 <= 1022)
    {
      if (v4 >= 2 && a1[v4 - 1] == 42)
      {
        int v7 = a1[v4 - 2];
        a2 |= v7 != 92;
        if (v7 != 92) {
          int64_t v6 = v4 - 1;
        }
      }
      if (v6 <= utf8_byte_length_noerror(unsigned char)::utf8_len_table[(unint64_t)*(unsigned __int8 *)a1 >> 4])
      {
        return 0;
      }
      else
      {
        if (*MEMORY[0x1E4F14B00] <= 0x2FuLL) {
          ++sTotal_3666;
        }
        int v5 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x30uLL, 0x31F9A007uLL);
        if (!v5) {
          _log_fault_for_malloc_failure();
        }
        *int v5 = 0;
        void v5[5] = v6;
        *((void *)v5 + 1) = strndup(a1, v6);
        v5[4] = a2;
      }
    }
  }
  return v5;
}

uint64_t TokenDataAddRange(uint64_t a1, int a2)
{
  if (!a1) {
    return 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  int64_t v4 = *(char **)(a1 + 32);
  uint64_t v6 = *(int *)(a1 + 40);
  uint64_t v5 = *(int *)(a1 + 44);
  unint64_t v7 = (unint64_t)(v6 - v5) >> 2;
  if ((int)v7 < 1)
  {
    int v11 = 0;
    __int16 v14 = 0;
LABEL_15:
    if (v11 >= (int)v7 || v14 <= 0) {
      int v17 = v11;
    }
    else {
      int v17 = v11 + 1;
    }
    if ((int)v5 <= 3)
    {
      int v18 = 2 * v6;
      if (!v6) {
        int v18 = 128;
      }
      do
      {
        int v19 = v18;
        v18 *= 2;
      }
      while (v19 < 4);
      int v20 = (char *)malloc_type_malloc(v19, 0xA1AE6110uLL);
      int64_t v4 = v20;
      int v21 = v6 - v5;
      if (v21)
      {
        memcpy(&v20[v19 - v21], (const void *)(*(void *)(a1 + 32) + *(int *)(a1 + 40) - v21), v21);
        free(*(void **)(a1 + 32));
      }
      *(void *)(a1 + 32) = v4;
      *(_DWORD *)(a1 + 40) = v19;
      LODWORD(v5) = v19 - v21;
    }
    uint64_t v22 = (int)v5 - 4;
    *(_DWORD *)(a1 + 44) = v22;
    if (v17)
    {
      uint64_t v23 = v17;
      memmove(&v4[v22], &v4[(int)v5], 4 * v17);
      int64_t v4 = *(char **)(a1 + 32);
      LODWORD(v22) = *(_DWORD *)(a1 + 44);
    }
    else
    {
      uint64_t v23 = 0;
    }
    *(_DWORD *)&v4[4 * v23 + (int)v22] = a2;
    if ((a2 >> 16) + (__int16)a2 == *(_DWORD *)(a1 + 20)) {
      ++*(_DWORD *)(a1 + 24);
    }
    uint64_t v15 = 1;
  }
  else
  {
    int v8 = 0;
    unint64_t v9 = (unint64_t)(v6 - v5) >> 2;
    while (1)
    {
      int v10 = v9 + v8;
      if ((int)v9 + v8 < 0 != __OFADD__(v9, v8)) {
        ++v10;
      }
      int v11 = v10 >> 1;
      int v12 = &v4[4 * v11 + v5];
      __int16 v13 = *((_WORD *)v12 + 1);
      __int16 v14 = HIWORD(a2) + a2 - (*(_WORD *)v12 + v13);
      if (!v14)
      {
        __int16 v14 = HIWORD(a2) - v13;
        if (HIWORD(a2) == v13) {
          break;
        }
      }
      if (v14 >= 0) {
        int v8 = v11 + 1;
      }
      else {
        LODWORD(v9) = v11;
      }
      if (v8 >= (int)v9) {
        goto LABEL_15;
      }
    }
    uint64_t v15 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  return v15;
}

uint64_t TokenDataGetTokens(uint64_t result, uint64_t a2)
{
  v11[8] = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(result + 24))
  {
    uint64_t v3 = result;
    uint64_t v4 = *(int *)(result + 44);
    uint64_t v5 = *(void *)(result + 32) + v4;
    unsigned int v6 = (*(_DWORD *)(result + 40) - v4) >> 2;
    MEMORY[0x1F4188790](result);
    int v8 = (char *)&v11[-1] - ((v7 + 15) & 0x3FFFFFFF0);
    bzero(v8, v7);
    int v9 = *(__int16 *)(v3 + 20);
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 0x40000000;
    v11[2] = __TokenDataGetTokens_block_invoke;
    void v11[3] = &unk_1E6343AF0;
    v11[4] = a2;
    v11[5] = v5;
    v11[6] = v8;
    v11[7] = v3;
    return TokenDataProcessStrings(v5, (__int16)(v6 - 1), v9, (uint64_t)v8, 0, (uint64_t)v11);
  }
  return result;
}

uint64_t __TokenDataGetTokens_block_invoke(void *a1, unsigned __int16 a2)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (char *)v10 - ((4 * a2 + 15) & 0x7FFF0);
  bzero(v4, 4 * a2);
  if (((a2 - 1) & 0x8000) == 0)
  {
    uint64_t v5 = a1[5];
    uint64_t v6 = a1[6];
    uint64_t v7 = 2 * (unsigned __int16)(a2 - 1);
    int v8 = v4;
    do
    {
      *v8++ = *(_DWORD *)(v5 + 4 * *(__int16 *)(v6 + v7));
      v7 -= 2;
    }
    while (v7 != -2);
  }
  return (*(uint64_t (**)(void))(a1[4] + 16))();
}

uint64_t TokenDataProcessStrings(uint64_t result, int a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  if ((a2 & 0x80000000) == 0)
  {
    int v9 = a2;
    uint64_t v10 = result;
    uint64_t v11 = a5;
    uint64_t v12 = (__int16)(a5 + 1);
    do
    {
      while (1)
      {
        __int16 v13 = (unsigned __int16 *)(v10 + 4 * (unsigned __int16)v9);
        int v14 = *v13;
        unsigned __int16 v15 = v13[1] + v14;
        if (v15 != (unsigned __int16)a3) {
          break;
        }
        *(_WORD *)(a4 + 2 * v11) = v9;
        if (v14)
        {
          int v16 = v9 - 1;
          uint64_t result = TokenDataProcessStrings(v10, (__int16)(v9 - 1), (__int16)v14, a4, v12, a6);
        }
        else
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 16))(a6, v12);
          int v16 = v9 - 1;
        }
        int v18 = (__int16)v9;
        int v9 = v16;
        if (v18 <= 0) {
          return result;
        }
      }
    }
    while ((__int16)v15 >= a3 && (__int16)v9-- > 0);
  }
  return result;
}

void TokenDataDispose(void **a1)
{
  if (a1)
  {
    free(a1[1]);
    free(a1[4]);
    free(a1);
  }
}

void _qsort_offset_triple(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = malloc_type_malloc(0x800uLL, 0x1000040451B5BE8uLL);
  *uint64_t v6 = 0;
  v6[1] = 0;
  uint64_t v7 = 1;
  do
  {
    if (a3 > a2)
    {
      if (v7 <= 128) {
        uint64_t v8 = 128;
      }
      else {
        uint64_t v8 = v7;
      }
      int v9 = &v6[2 * v7 + 1];
      while (a3 - a2 > 16)
      {
        uint64_t v10 = _partition_offset_triple(a1, a2, a3);
        uint64_t v11 = v10 - a2;
        if (v10 < a2)
        {
          uint64_t v25 = __si_assert_copy_extra(0);
          __int16 v26 = v25;
          unint64_t v27 = "";
          if (v25) {
            unint64_t v27 = v25;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1311, "q>=left", v27);
          free(v26);
          if (__valid_fs(-1)) {
            uint64_t v28 = 2989;
          }
          else {
            uint64_t v28 = 3072;
          }
          *(_DWORD *)uint64_t v28 = -559038737;
          abort();
        }
        if (v8 == v7)
        {
          heapsort_b((void *)(a1 + 24 * a2), a3 - a2 + 1, 0x18uLL, &__block_literal_global_3686);
          uint64_t v7 = v8;
          goto LABEL_27;
        }
        BOOL v12 = v11 <= a3 - v10;
        if (v11 <= a3 - v10) {
          uint64_t v13 = v10 - 1;
        }
        else {
          uint64_t v13 = a3;
        }
        if (v12) {
          uint64_t v14 = a2;
        }
        else {
          uint64_t v14 = v10;
        }
        if (v12) {
          a2 = v10;
        }
        else {
          a3 = v10 - 1;
        }
        *(v9 - 1) = v14;
        *int v9 = v13;
        ++v7;
        v9 += 2;
        if (a3 <= a2) {
          goto LABEL_27;
        }
      }
      uint64_t v15 = a1 + 32 + 24 * a2;
      uint64_t v16 = a2;
      do
      {
        uint64_t v17 = v16++;
        uint64_t v18 = a1 + 24 * v17;
        unint64_t v19 = *(void *)(v18 + 24);
        unint64_t v20 = *(void *)v18;
        long long v29 = *(_OWORD *)(v18 + 8);
        long long v30 = *(_OWORD *)(v18 + 32);
        uint64_t v21 = v16;
        if (v20 > v19)
        {
          uint64_t v22 = (_OWORD *)v15;
          do
          {
            uint64_t v21 = v17;
            *((void *)v22 - 1) = v20;
            *uint64_t v22 = v29;
            if (v17 <= a2) {
              break;
            }
            unint64_t v20 = *((void *)v22 - 7);
            long long v29 = *(v22 - 3);
            uint64_t v22 = (_OWORD *)((char *)v22 - 24);
            --v17;
          }
          while (v20 > v19);
        }
        uint64_t v23 = a1 + 24 * v21;
        *(void *)uint64_t v23 = v19;
        *(_OWORD *)(v23 + 8) = v30;
        v15 += 24;
      }
      while (v16 != a3);
    }
LABEL_27:
    --v7;
    size_t v24 = &v6[2 * v7];
    a2 = *v24;
    a3 = v24[1];
  }
  while (v7);
  free(v6);
}

uint64_t _partition_offset_triple(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3 - a2;
  unint64_t v4 = a3 - a2 + 1;
  uint64_t v5 = (uint64_t *)(a1 + 24 * a2);
  uint64_t v6 = a3 - a2 + 2;
  if (a3 - a2 >= -1) {
    uint64_t v6 = v3 + 1;
  }
  uint64_t v7 = &v5[3 * (v6 >> 1)];
  uint64_t v8 = (unint64_t *)(a1 + 24 * a3);
  if (v3 < 1024)
  {
    uint64_t v13 = (unint64_t *)(a1 + 24 * a2);
    __int16 v26 = v7;
    unint64_t v27 = (unint64_t *)(a1 + 24 * a3);
  }
  else
  {
    unint64_t v9 = v4 >> 3;
    uint64_t v10 = (unint64_t *)&v5[3 * (v4 >> 3)];
    unint64_t v11 = *v5;
    unint64_t v12 = *v10;
    uint64_t v13 = (unint64_t *)(a1 + 24 * a2);
    if (*v5 != *v10)
    {
      uint64_t v13 = (unint64_t *)&v5[6 * v9];
      unint64_t v14 = *v13;
      if (v11 >= *v13) {
        uint64_t v15 = &v5[6 * v9];
      }
      else {
        uint64_t v15 = (uint64_t *)(a1 + 24 * a2);
      }
      if (v12 > v14) {
        uint64_t v15 = (uint64_t *)v10;
      }
      if (v11 >= v14) {
        uint64_t v16 = (uint64_t *)(a1 + 24 * a2);
      }
      else {
        uint64_t v16 = &v5[6 * v9];
      }
      if (v12 >= v14) {
        uint64_t v10 = (unint64_t *)v16;
      }
      if (v11 >= v12) {
        uint64_t v10 = (unint64_t *)v15;
      }
      if (v14 != v11 && v14 != v12) {
        uint64_t v13 = v10;
      }
    }
    uint64_t v18 = 2 * v9;
    uint64_t v19 = -(uint64_t)v9;
    unint64_t v20 = (unint64_t *)&v7[-3 * v9];
    unint64_t v21 = *v20;
    unint64_t v22 = *v7;
    if (*v20 == *v7)
    {
      __int16 v26 = &v7[-3 * v9];
    }
    else
    {
      uint64_t v23 = (unint64_t *)&v7[3 * v9];
      unint64_t v24 = *v23;
      BOOL v25 = *v23 == v21 || v24 == v22;
      __int16 v26 = &v7[3 * v9];
      if (!v25)
      {
        __int16 v26 = v7;
        if (v21 >= v22)
        {
          if (v22 <= v24)
          {
            if (v21 >= v24) {
              __int16 v26 = (uint64_t *)v23;
            }
            else {
              __int16 v26 = (uint64_t *)v20;
            }
          }
        }
        else if (v22 >= v24)
        {
          if (v21 >= v24) {
            __int16 v26 = (uint64_t *)v20;
          }
          else {
            __int16 v26 = (uint64_t *)v23;
          }
        }
      }
    }
    unint64_t v27 = &v8[-3 * v18];
    uint64_t v28 = &v8[3 * v19];
    unint64_t v29 = *v27;
    unint64_t v30 = *v28;
    if (*v27 != *v28)
    {
      unint64_t v31 = *v8;
      if (v29 >= *v8) {
        uint64_t v32 = (unint64_t *)(a1 + 24 * a3);
      }
      else {
        uint64_t v32 = v27;
      }
      if (v30 > v31) {
        uint64_t v32 = v28;
      }
      if (v29 < v31) {
        unint64_t v27 = (unint64_t *)(a1 + 24 * a3);
      }
      if (v30 < v31) {
        unint64_t v27 = v28;
      }
      if (v29 >= v30) {
        unint64_t v27 = v32;
      }
      if (v31 == v29 || v31 == v30) {
        unint64_t v27 = (unint64_t *)(a1 + 24 * a3);
      }
    }
  }
  unint64_t v34 = *v13;
  unint64_t v35 = *v26;
  if (*v13 == *v26)
  {
    __int16 v26 = (uint64_t *)v13;
  }
  else
  {
    unint64_t v36 = *v27;
    if (*v27 == v34 || v36 == v35)
    {
      __int16 v26 = (uint64_t *)v27;
    }
    else if (v34 >= v35)
    {
      if (v35 <= v36)
      {
        if (v34 >= v36) {
          __int16 v26 = (uint64_t *)v27;
        }
        else {
          __int16 v26 = (uint64_t *)v13;
        }
      }
    }
    else if (v35 >= v36)
    {
      if (v34 >= v36) {
        __int16 v26 = (uint64_t *)v13;
      }
      else {
        __int16 v26 = (uint64_t *)v27;
      }
    }
  }
  unint64_t v38 = *v26;
  long long v53 = *(_OWORD *)(v26 + 1);
  long long v39 = *(_OWORD *)v8;
  v26[2] = v8[2];
  *(_OWORD *)__int16 v26 = v39;
  *uint64_t v8 = v38;
  *(_OWORD *)(v8 + 1) = v53;
  unint64_t v40 = *v5;
  long long v52 = *(_OWORD *)(v5 + 1);
  uint64_t v41 = a3 - a2;
  if (a3 > a2)
  {
    unsigned int v42 = (_OWORD *)(a1 + 24 * a2 + 32);
    do
    {
      unint64_t v43 = *((void *)v42 - 1);
      long long v51 = v52;
      long long v52 = *v42;
      if (v40 <= v38)
      {
        unint64_t v44 = (long long *)(a1 + 24 * a2);
        long long v45 = *v44;
        *((void *)v42 - 2) = *((void *)v44 + 2);
        *(v42 - 2) = v45;
        *(void *)unint64_t v44 = v40;
        *(long long *)((char *)v44 + 8) = v51;
        ++a2;
      }
      unsigned int v42 = (_OWORD *)((char *)v42 + 24);
      unint64_t v40 = v43;
      --v41;
    }
    while (v41);
  }
  int v46 = (long long *)(a1 + 24 * a2);
  unint64_t v47 = *((void *)v46 + 2);
  long long v48 = *v46;
  unint64_t v49 = v8[2];
  *int v46 = *(_OWORD *)v8;
  *((void *)v46 + 2) = v49;
  *(_OWORD *)uint64_t v8 = v48;
  v8[2] = v47;
  return a2;
}

uint64_t ___qsort_offset_triple_block_invoke(uint64_t a1, void *a2, void *a3)
{
  if (*a2 == *a3) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = -1;
  }
  if (*a2 > *a3) {
    return 1;
  }
  else {
    return v3;
  }
}

void _qsort_big_offset_triple(void *a1)
{
  uint64_t v1 = *((void *)a1 + 1);
  uint64_t v2 = *((void *)a1 + 2);
  unsigned int v3 = *((void *)a1 + 3);
  uint64_t v4 = *((void *)a1 + 4);
  uint64_t v5 = *((void *)a1 + 5);
  uint64_t v37 = *((void *)a1 + 6);
  uint64_t v38 = *(void *)a1;
  signed int v6 = *((_DWORD *)a1 + 14);
  int v36 = *((_DWORD *)a1 + 15);
  OSAtomicEnqueue(&qsort_cached_allocations_3690, a1, 0);
  if (v2 > v1)
  {
    for (unint64_t i = v4 + 1; ; ++i)
    {
      uint64_t v8 = v2 - v1;
      if (v2 - v1 <= v5 || i > 9) {
        break;
      }
      if (v6 <= 1) {
        signed int v6 = 1;
      }
      uint64_t v10 = getSize_memSize_3692;
      if (!getSize_memSize_3692)
      {
        long long v42 = 0u;
        long long v43 = 0u;
        *(_OWORD *)host_info_out = 0u;
        host_t v11 = MEMORY[0x1C1881C90]();
        mach_msg_type_number_t host_info_outCnt = 12;
        mach_error_t v12 = host_info(v11, 1, host_info_out, &host_info_outCnt);
        if (v12)
        {
          mach_error("flushsize", v12);
          exit(1);
        }
        uint64_t v10 = *((void *)&v43 + 1);
        getSize_memSize_3692 = *((void *)&v43 + 1);
      }
      unint64_t v13 = 3 * v10;
      unint64_t v14 = (v13 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64;
      uint64_t v15 = v3;
      if (24 * v8 > v13 / 5) {
        uint64_t v15 = dispatch_group_create();
      }
      if (v8 <= v37 || 24 * v8 >= v14 >> 2)
      {
        uint64_t v18 = _partition_offset_triple(v38, v1, v2);
      }
      else
      {
        qos_class_t v16 = qos_class_self();
        global_queue = dispatch_get_global_queue(v16, 2uLL);
        uint64_t v18 = _big_partition_offset_triple(v38, v1, v2, global_queue, v6);
      }
      uint64_t v19 = v18;
      uint64_t v20 = v18 - v1;
      if (v18 < v1)
      {
        uint64_t v32 = __si_assert_copy_extra(0);
        int v33 = v32;
        unint64_t v34 = "";
        if (v32) {
          unint64_t v34 = v32;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1311, "q>=left", v34);
        free(v33);
        if (__valid_fs(-1)) {
          uint64_t v35 = 2989;
        }
        else {
          uint64_t v35 = 3072;
        }
        *(_DWORD *)uint64_t v35 = -559038737;
        abort();
      }
      unint64_t v21 = OSAtomicDequeue(&qsort_cached_allocations_3690, 0);
      if (!v21) {
        unint64_t v21 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
      }
      *((void *)v21 + 4) = i;
      *((void *)v21 + 5) = v5;
      *((void *)v21 + 6) = v37;
      uint64_t v22 = v2 - v19;
      if (v20 <= v2 - v19)
      {
        uint64_t v23 = v19 - 1;
      }
      else
      {
        uint64_t v22 = v19 - 1 - v1;
        uint64_t v23 = v2;
      }
      if (v20 > v2 - v19) {
        uint64_t v24 = v19;
      }
      else {
        uint64_t v24 = v1;
      }
      if (v20 > v2 - v19) {
        uint64_t v2 = v19 - 1;
      }
      else {
        uint64_t v1 = v19;
      }
      *(void *)unint64_t v21 = v38;
      *((void *)v21 + 1) = v24;
      int v25 = (int)(float)((float)((float)(v22 + 1) / (float)(v23 - v24 + 1)) * (float)v6);
      if (v25 <= 1) {
        int v26 = 1;
      }
      else {
        int v26 = v25;
      }
      if (v6 >= v25) {
        int v27 = v26;
      }
      else {
        int v27 = 0;
      }
      v21[14] = v6 - v27;
      v21[15] = v36;
      *((void *)v21 + 2) = v23;
      *((void *)v21 + 3) = v15;
      if (v15 == v3)
      {
        if (v6 >= v25) {
          signed int v6 = v26;
        }
        qos_class_t v30 = qos_class_self();
        unint64_t v31 = dispatch_get_global_queue(v30, 2uLL);
        dispatch_group_async_f(v3, v31, v21, (dispatch_function_t)_qsort_big_offset_triple);
      }
      else
      {
        v21[14] = v6;
        _qsort_big_offset_triple(v21);
        dispatch_group_wait(v15, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(v15);
        qos_class_t v28 = qos_class_self();
        unint64_t v29 = dispatch_get_global_queue(v28, 2uLL);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        void block[2] = ___qsort_big_offset_triple_block_invoke;
        block[3] = &__block_descriptor_tmp_62;
        block[4] = v21;
        dispatch_async(v29, block);
      }
      if (v2 <= v1) {
        return;
      }
    }
    _qsort_offset_triple(v38, v1, v2);
  }
}

uint64_t _big_partition_offset_triple(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  uint64_t v7 = a3 - a2;
  BOOL v8 = __OFADD__(a3 - a2, 1);
  unint64_t v9 = a3 - a2 + 1;
  uint64_t v10 = (uint64_t *)(a1 + 24 * a2);
  uint64_t v11 = v7 + 2;
  if (((v9 & 0x8000000000000000) != 0) == v8) {
    uint64_t v11 = v7 + 1;
  }
  mach_error_t v12 = &v10[3 * (v11 >> 1)];
  unint64_t v13 = (unint64_t *)(a1 + 24 * a3);
  if (v7 < 64)
  {
    qos_class_t v30 = v12;
    uint64_t v18 = v10;
  }
  else
  {
    unint64_t v14 = v9 >> 3;
    uint64_t v15 = (unint64_t *)&v10[3 * (v9 >> 3)];
    unint64_t v16 = *v10;
    unint64_t v17 = *v15;
    uint64_t v18 = v10;
    if (*v10 != *v15)
    {
      uint64_t v18 = &v10[6 * v14];
      unint64_t v19 = *v18;
      if (*v18 != v16 && v19 != v17)
      {
        if (v16 >= v19) {
          unint64_t v21 = &v10[6 * v14];
        }
        else {
          unint64_t v21 = v10;
        }
        if (v17 > v19) {
          unint64_t v21 = &v10[3 * (v9 >> 3)];
        }
        if (v16 >= v19) {
          uint64_t v18 = v10;
        }
        if (v17 < v19) {
          uint64_t v18 = &v10[3 * (v9 >> 3)];
        }
        if (v16 >= v17) {
          uint64_t v18 = v21;
        }
      }
    }
    uint64_t v22 = 2 * v14;
    uint64_t v23 = -(uint64_t)v14;
    uint64_t v24 = &v12[-3 * v14];
    unint64_t v25 = *v24;
    unint64_t v26 = *v12;
    if (*v24 == *v12)
    {
      qos_class_t v30 = &v12[-3 * v14];
    }
    else
    {
      int v27 = &v12[3 * v14];
      unint64_t v28 = *v27;
      BOOL v29 = *v27 == v25 || v28 == v26;
      qos_class_t v30 = &v12[3 * v14];
      if (!v29)
      {
        qos_class_t v30 = v12;
        if (v25 >= v26)
        {
          if (v26 <= v28)
          {
            if (v25 >= v28) {
              qos_class_t v30 = v27;
            }
            else {
              qos_class_t v30 = v24;
            }
          }
        }
        else if (v26 >= v28)
        {
          if (v25 >= v28) {
            qos_class_t v30 = v24;
          }
          else {
            qos_class_t v30 = v27;
          }
        }
      }
    }
    unint64_t v31 = &v13[-3 * v22];
    uint64_t v32 = &v13[3 * v23];
    unint64_t v33 = *v31;
    unint64_t v34 = *v32;
    if (*v31 == *v32)
    {
      unint64_t v13 = v31;
    }
    else
    {
      unint64_t v35 = *v13;
      if (v33 >= *v13) {
        int v36 = v13;
      }
      else {
        int v36 = v31;
      }
      if (v34 > v35) {
        int v36 = v32;
      }
      if (v33 < v35) {
        unint64_t v31 = v13;
      }
      if (v34 < v35) {
        unint64_t v31 = v32;
      }
      if (v33 >= v34) {
        unint64_t v31 = v36;
      }
      if (v35 != v33 && v35 != v34) {
        unint64_t v13 = v31;
      }
    }
  }
  unint64_t v38 = *v18;
  unint64_t v39 = *v30;
  if (*v18 == *v30)
  {
    qos_class_t v30 = v18;
  }
  else
  {
    unint64_t v40 = *v13;
    if (*v13 == v38 || v40 == v39)
    {
      qos_class_t v30 = (uint64_t *)v13;
    }
    else if (v38 >= v39)
    {
      if (v39 <= v40)
      {
        if (v38 >= v40) {
          qos_class_t v30 = (uint64_t *)v13;
        }
        else {
          qos_class_t v30 = v18;
        }
      }
    }
    else if (v39 >= v40)
    {
      if (v38 >= v40) {
        qos_class_t v30 = v18;
      }
      else {
        qos_class_t v30 = (uint64_t *)v13;
      }
    }
  }
  return parallel_partition_offset_triple(v10, v9, *v30, a4, a5) + a2;
}

void ___qsort_big_offset_triple_block_invoke(uint64_t a1)
{
  madvise((void *)(**(void **)(a1 + 32) + 24 * *(void *)(*(void *)(a1 + 32) + 8)), 24 * (*(void *)(*(void *)(a1 + 32) + 16) - *(void *)(*(void *)(a1 + 32) + 8)), 4);
  uint64_t v2 = *(void **)(a1 + 32);
  OSAtomicEnqueue(&qsort_cached_allocations_3690, v2, 0);
}

uint64_t parallel_partition_offset_triple(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  int v5 = a5;
  v17[1] = v17;
  context[9] = *MEMORY[0x1E4F143B8];
  context[6] = a1;
  size_t v10 = 8 * a5;
  MEMORY[0x1F4188790](a1);
  mach_error_t v12 = (char *)v17 - v11;
  bzero((char *)v17 - v11, v10);
  uint64_t v13 = (a2 / 0x4000) << 13;
  context[1] = v13;
  context[2] = a2;
  context[4] = 0;
  context[5] = 0;
  uint64_t v14 = a2 - v13;
  context[7] = a3;
  context[8] = v12;
  if (v5 >= 1) {
    memset(v12, 255, v10);
  }
  uint64_t v15 = v13 + 0x2000;
  if (v14 > v13 + 0x2000) {
    uint64_t v15 = a2 - ((a2 / 0x4000) << 13);
  }
  context[3] = v14 + ((v15 - v14 + 0x1FFF) & 0xFFFFFFFFFFFFE000);
  context[0] = 0;
  if (24 * a2 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
    madvise(a1, 24 * a2, 3);
  }
  if (a2 / 0x4000 < v5) {
    int v5 = a2 / 0x4000;
  }
  dispatch_apply_f(v5, a4, context, (void (__cdecl *)(void *, size_t))partition_phase_offset_triple);
  return sequential_fixup_offset_triple((uint64_t)context, a2, v5);
}

uint64_t sequential_fixup_offset_triple(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = a3;
  qsort(*(void **)(a1 + 64), a3, 8uLL, (int (__cdecl *)(const void *, const void *))index_comp_3697);
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v8 = a3 - 1;
  uint64_t v9 = 0;
  if (a3 < 1) {
    goto LABEL_91;
  }
  while (*(void *)(v7 + 8 * v9) == -1)
  {
    if (v6 == ++v9)
    {
      uint64_t v9 = v6;
      break;
    }
  }
  if (a3 == 1)
  {
    uint64_t v8 = 0;
  }
  else
  {
LABEL_91:
    do
    {
      if (*(void *)(v7 + 8 * v8) != -1) {
        break;
      }
      --v8;
    }
    while (v8);
  }
  while (v9 < v8)
  {
    int v10 = neutralize_offset_triple(*(void *)(a1 + 48) + 24 * *(void *)(v7 + 8 * v9), *(void *)(a1 + 48) + 24 * *(void *)(v7 + 8 * v8), *(void *)(a1 + 56), &v51, &v52);
    uint64_t v7 = *(void *)(a1 + 64);
    if ((v10 & 1) == 0)
    {
      uint64_t v11 = *(void *)(v7 + 8 * v9);
      if ((v11 & 0x8000000000000000) == 0 && v11 < *(void *)(a1 + 32))
      {
        *(void *)(v7 + 8 * v9) = -1;
        *(void *)(a1 + 32) += 0x2000;
      }
      ++v9;
      uint64_t v51 = 0;
      if ((v10 - 1) > 1) {
        continue;
      }
    }
    uint64_t v12 = *(void *)(v7 + 8 * v8);
    BOOL v13 = v12 >= a2 || v12 < a2 - *(void *)(a1 + 40);
    if (!v13)
    {
      *(void *)(v7 + 8 * v8) = -1;
      *(void *)(a1 + 40) += 0x2000;
    }
    --v8;
    uint64_t v52 = 0;
  }
  unint64_t v15 = *(void *)(a1 + 32);
  uint64_t v14 = *(void *)(a1 + 40);
  unint64_t v16 = malloc_type_malloc(0x30000uLL, 0x7C61995FuLL);
  if (a3 < 1)
  {
    uint64_t v31 = *(void *)a1;
    uint64_t v32 = *(void *)(a1 + 16) - 1;
  }
  else
  {
    uint64_t v17 = 0;
    unint64_t v18 = ~v14 + a2;
    uint64_t v19 = a3;
    uint64_t v20 = *(uint64_t **)(a1 + 64);
    uint64_t v21 = 8 * a3;
    do
    {
      unint64_t v22 = v20[v17];
      if (v22 != -1 && v18 <= v22) {
        break;
      }
      if (v22 != -1)
      {
        if (v15 <= v22) {
          break;
        }
        unint64_t v24 = *(void *)(a1 + 32);
        if (v24 > v22)
        {
          unint64_t v25 = 0;
          do
          {
            if (v20[v25 / 8] == v24)
            {
              v24 += 0x2000;
              *(void *)(a1 + 32) = v24;
            }
            v25 += 8;
          }
          while (v21 != v25);
          if ((int64_t)v24 >= *(void *)a1) {
            break;
          }
          memcpy(v16, (const void *)(*(void *)(a1 + 48) + 24 * v20[v17]), 0x30000uLL);
          memcpy((void *)(*(void *)(a1 + 48) + 24 * *(void *)(*(void *)(a1 + 64) + 8 * v17)), (const void *)(*(void *)(a1 + 48) + 24 * *(void *)(a1 + 32)), 0x30000uLL);
          memcpy((void *)(*(void *)(a1 + 48) + 24 * *(void *)(a1 + 32)), v16, 0x30000uLL);
          uint64_t v20 = *(uint64_t **)(a1 + 64);
          v20[v17] = *(void *)(a1 + 32);
          *(void *)(a1 + 32) += 0x2000;
        }
      }
      ++v17;
    }
    while (v17 != v19);
    uint64_t v26 = v19;
    do
    {
      unint64_t v27 = v20[(v26 - 1)];
      if (v15 > v27) {
        break;
      }
      if (v27 != -1)
      {
        if (v18 > v27) {
          break;
        }
        uint64_t v28 = (v26 - 1);
        uint64_t v29 = *(void *)(a1 + 40) + 0x2000;
        *(void *)(a1 + 40) = v29;
        uint64_t v30 = v19 + 1;
        do
        {
          if (v20[(v30 - 2)] == a2 - v29)
          {
            v29 += 0x2000;
            *(void *)(a1 + 40) = v29;
          }
          --v30;
        }
        while (v30 > 1);
        if ((unint64_t)(a2 - v29) < *(void *)(a1 + 16)) {
          break;
        }
        memcpy(v16, (const void *)(*(void *)(a1 + 48) + 24 * v20[v28]), 0x30000uLL);
        memcpy((void *)(*(void *)(a1 + 48) + 24 * *(void *)(*(void *)(a1 + 64) + 8 * v28)), (const void *)(*(void *)(a1 + 48) + 24 * (a2 - *(void *)(a1 + 40))), 0x30000uLL);
        memcpy((void *)(*(void *)(a1 + 48) + 24 * (a2 - *(void *)(a1 + 40))), v16, 0x30000uLL);
        uint64_t v20 = *(uint64_t **)(a1 + 64);
        v20[v28] = a2 - *(void *)(a1 + 40);
      }
      BOOL v13 = v26-- <= 1;
    }
    while (!v13);
    uint64_t v31 = *(void *)a1;
    uint64_t v32 = *(void *)(a1 + 16) - 1;
    do
    {
      uint64_t v34 = *v20++;
      uint64_t v33 = v34;
      if (v34 != -1)
      {
        if (v33 < v31) {
          uint64_t v31 = v33;
        }
        uint64_t v35 = v33 + 0x2000;
        uint64_t v36 = v33 + 0x1FFF;
        if (v35 > v32) {
          uint64_t v32 = v36;
        }
        if (v32 >= a2)
        {
          unint64_t v47 = __si_assert_copy_extra(0);
          long long v48 = v47;
          unint64_t v49 = "";
          if (v47) {
            unint64_t v49 = v47;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1311, "right < count", v49);
          free(v48);
          if (__valid_fs(-1)) {
            uint64_t v50 = 2989;
          }
          else {
            uint64_t v50 = 3072;
          }
          *(_DWORD *)uint64_t v50 = -559038737;
          abort();
        }
      }
      --v19;
    }
    while (v19);
  }
  free(v16);
  if (v31 >= v32)
  {
    uint64_t v37 = v31;
  }
  else
  {
    uint64_t v37 = v31;
    do
    {
      uint64_t v39 = *(void *)(a1 + 48);
      unint64_t v38 = *(void *)(a1 + 56);
      unint64_t v40 = (unint64_t *)(v39 + 24 * v31);
      while (*v40 < v38)
      {
        ++v37;
        v40 += 3;
        if (v37 >= v32)
        {
          if (v32 <= v31 + 1) {
            uint64_t v37 = v31 + 1;
          }
          else {
            uint64_t v37 = v32;
          }
          goto LABEL_80;
        }
      }
      if (v37 < v32)
      {
        uint64_t v41 = (unint64_t *)(v39 + 24 * v32);
        while (*v41 > v38)
        {
          --v32;
          v41 -= 3;
          if (v37 >= v32) {
            goto LABEL_80;
          }
        }
        unint64_t v42 = v41[2];
        long long v43 = *(_OWORD *)v41;
        unint64_t v44 = v40[2];
        *(_OWORD *)uint64_t v41 = *(_OWORD *)v40;
        v41[2] = v44;
        uint64_t v45 = *(void *)(a1 + 48) + 24 * v37;
        *(_OWORD *)uint64_t v45 = v43;
        *(void *)(v45 + 16) = v42;
        ++v37;
        --v32;
      }
      uint64_t v31 = v37;
    }
    while (v37 < v32);
  }
LABEL_80:
  if (*(void *)(*(void *)(a1 + 48) + 24 * v37) >= *(void *)(a1 + 56)) {
    return v37;
  }
  else {
    return v37 + 1;
  }
}

uint64_t neutralize_offset_triple(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = *a4;
  uint64_t v6 = *a5;
  while (1)
  {
    if (v5 < 0x2000)
    {
      uint64_t v7 = (unint64_t *)(a1 + 24 * v5);
      while (1)
      {
        unint64_t v8 = *v7;
        v7 += 3;
        if (v8 > a3) {
          break;
        }
        if (++v5 == 0x2000)
        {
          uint64_t v9 = 0x2000;
          goto LABEL_8;
        }
      }
    }
    uint64_t v9 = v5;
LABEL_8:
    if (v6 < 0x2000)
    {
      int v10 = (unint64_t *)(a2 + 24 * v6);
      while (1)
      {
        unint64_t v11 = *v10;
        v10 += 3;
        if (v11 < a3) {
          break;
        }
        if (++v6 == 0x2000)
        {
          uint64_t v5 = v9;
          goto LABEL_17;
        }
      }
    }
    uint64_t v12 = v6;
    if (v9 == 0x2000 || v6 == 0x2000) {
      break;
    }
    BOOL v13 = (long long *)(a2 + 24 * v6);
    uint64_t v14 = *((void *)v13 + 2);
    long long v15 = *v13;
    unint64_t v16 = (long long *)(a1 + 24 * v9);
    uint64_t v17 = *((void *)v16 + 2);
    *BOOL v13 = *v16;
    *((void *)v13 + 2) = v17;
    long long *v16 = v15;
    *((void *)v16 + 2) = v14;
    uint64_t v5 = v9 + 1;
    uint64_t v6 = v12 + 1;
    if (v9 > 8190 || v12 >= 0x1FFF) {
      goto LABEL_17;
    }
  }
  uint64_t v5 = v9;
LABEL_17:
  *a4 = v5;
  *a5 = v6;
  if (v6 == 0x2000 && v5 == 0x2000) {
    return 2;
  }
  else {
    return v5 != 0x2000;
  }
}

uint64_t index_comp_3697(void *a1, void *a2)
{
  if (*a1 >= *a2) {
    unsigned int v2 = 0;
  }
  else {
    unsigned int v2 = -1;
  }
  if (*a1 > *a2) {
    return 1;
  }
  else {
    return v2;
  }
}

int64_t partition_phase_offset_triple(OSAtomic_int64_aligned64_t *a1, uint64_t a2)
{
  OSAtomic_int64_aligned64_t v4 = a1[6];
  int64_t Left_Block_offset_triple = Get_Left_Block_offset_triple(a1);
  int64_t Right_Block_offset_triple = Get_Right_Block_offset_triple((uint64_t)a1);
  uint64_t v7 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  BOOL v8 = Left_Block_offset_triple != -1;
  if (Right_Block_offset_triple == -1 || Left_Block_offset_triple == -1)
  {
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v7 = 0;
    do
    {
      int v10 = neutralize_offset_triple(v4 + 24 * Left_Block_offset_triple, v4 + 24 * Right_Block_offset_triple, a1[7], &v15, &v14);
      if ((v10 & 1) != 0
        || (int v11 = v10,
            int64_t Left_Block_offset_triple = Get_Left_Block_offset_triple(a1),
            uint64_t v15 = 0,
            ++v7,
            (v11 - 1) <= 1))
      {
        int64_t Right_Block_offset_triple = Get_Right_Block_offset_triple((uint64_t)a1);
        uint64_t v14 = 0;
        ++v9;
      }
      BOOL v8 = Left_Block_offset_triple != -1;
    }
    while (Right_Block_offset_triple != -1 && Left_Block_offset_triple != -1);
  }
  if (v8) {
    int64_t v12 = Left_Block_offset_triple;
  }
  else {
    int64_t v12 = Right_Block_offset_triple;
  }
  *(void *)(a1[8] + 8 * a2) = v12;
  OSAtomicAdd64(v7 << 13, a1 + 4);
  return OSAtomicAdd64(v9 << 13, a1 + 5);
}

int64_t Get_Left_Block_offset_triple(OSAtomic_int64_aligned64_t *__theValue)
{
  if (*__theValue >= __theValue[1]) {
    return -1;
  }
  int64_t v2 = OSAtomicAdd64(0x2000, __theValue);
  if (v2 > __theValue[1])
  {
    OSAtomicAdd64(-8192, __theValue);
    return -1;
  }
  return v2 - 0x2000;
}

int64_t Get_Right_Block_offset_triple(uint64_t a1)
{
  uint64_t v1 = (OSAtomic_int64_aligned64_t *)(a1 + 16);
  if (*(void *)(a1 + 16) > *(void *)(a1 + 24))
  {
    int64_t result = OSAtomicAdd64(-8192, v1);
    if (result >= *(void *)(a1 + 24)) {
      return result;
    }
    OSAtomicAdd64(0x2000, v1);
  }
  return -1;
}

void pqinit_offset_ptr(uint64_t a1)
{
  *(_OWORD *)(a1 + 8) = xmmword_1BDA82330;
  int64_t v2 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x220uLL, 0x6085D6BuLL);
  if (!v2) {
    _log_fault_for_malloc_failure();
  }
  *(void *)a1 = v2;
  *int64_t v2 = 0;
  v2[1] = 0;
}

void __directoryStoreGetFileListOffsets_block_invoke(uint64_t a1, int a2, unint64_t *a3)
{
}

void _directoryStoreGetFileListOffsets(uint64_t *a1, unsigned __int16 *a2, uint64_t a3, int a4, unint64_t *a5, uint64_t a6, int a7, unint64_t a8, uint64_t a9)
{
  BOOL v113 = 0;
  DirectoryWithint Path = (unint64_t *)directoryStoreReaderGetDirectoryWithPath(a1, a2, a4 - 1, (uint64_t)a5);
  if (!DirectoryWithPath) {
    return;
  }
  unint64_t v13 = DirectoryWithPath[1];
  if ((v13 & 0x8000000000000000) == 0)
  {
    if (!v13) {
      return;
    }
    if (a7)
    {
      uint64_t ptr = 0;
      uint64_t v111 = 0;
      unint64_t v112 = 0;
      unint64_t v14 = *DirectoryWithPath;
      pqinit_offset_ptr((uint64_t)&ptr);
      uint64_t v16 = v111;
      unint64_t v15 = v112;
      uint64_t v17 = ptr;
      if ((uint64_t)(v112 + 2) >= v111)
      {
        if (v111 >= 4) {
          uint64_t v16 = 2 * v111;
        }
        else {
          uint64_t v16 = 4;
        }
        uint64_t v111 = v16;
        if (ptr) {
          unint64_t v18 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, ptr, 16 * v16 + 32, 0xECA6AA46uLL);
        }
        else {
          unint64_t v18 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v16 + 32, 0x8DDAA030uLL);
        }
        uint64_t v17 = v18;
        if (!v18) {
          _log_fault_for_malloc_failure();
        }
        uint64_t ptr = v17;
        void *v17 = 0;
        v17[1] = 0;
      }
      int64_t v31 = v15 + 1;
      unint64_t v112 = v15 + 1;
      uint64_t v32 = &v17[2 * v15];
      *uint64_t v32 = v13;
      v32[1] = v14;
      if ((uint64_t)v15 >= 2)
      {
        do
        {
          uint64_t v33 = &v17[2 * v15];
          uint64_t v34 = &v17[2 * (v15 >> 1)];
          if ((*v33 & 0x3FFFFFFFFFFFFFFFuLL) > (*v34 & 0x3FFFFFFFFFFFFFFFuLL)) {
            break;
          }
          long long v114 = *(_OWORD *)v33;
          *(_OWORD *)uint64_t v33 = *(_OWORD *)v34;
          *(_OWORD *)uint64_t v34 = v114;
          BOOL v35 = v15 > 3;
          v15 >>= 1;
        }
        while (v35);
        uint64_t v16 = v111;
        int64_t v31 = v112;
        uint64_t v17 = ptr;
      }
      while (1)
      {
        unint64_t v36 = v31 - 1;
        if (v31 == 1)
        {
          unint64_t v37 = 0;
          uint64_t v38 = 0;
          unint64_t v36 = 1;
LABEL_93:
          Page = _directoryStoreReaderGetPage(a1, v37, &v113);
          unint64_t Size = directoryTreePageGetSize(*Page, *((unsigned char *)Page + 2), v76);
          if (!Size) {
            goto LABEL_112;
          }
          unint64_t v78 = Size;
          uint64_t v79 = 0;
          unsigned int v80 = 0;
          while (1)
          {
            uint64_t v81 = *(void *)&Page[4 * v79 + 4];
            if (v81 < 0) {
              break;
            }
            if (v81)
            {
              if ((uint64_t)(v36 + 2) >= v16)
              {
                if (v16 >= 4) {
                  v16 *= 2;
                }
                else {
                  uint64_t v16 = 4;
                }
                if (v17) {
                  uint64_t v82 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v17, 16 * v16 + 32, 0xECA6AA46uLL);
                }
                else {
                  uint64_t v82 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v16 + 32, 0x8DDAA030uLL);
                }
                uint64_t v17 = v82;
                if (!v82) {
                  _log_fault_for_malloc_failure();
                }
                void *v17 = 0;
                v17[1] = 0;
              }
              unint64_t v83 = v36 + 1;
              unsigned int v84 = &v17[2 * v36];
              *unsigned int v84 = v81;
              v84[1] = v38;
              if ((uint64_t)v36 >= 2)
              {
                do
                {
                  uint64_t v85 = &v17[2 * v36];
                  uint64_t v86 = &v17[2 * (v36 >> 1)];
                  if ((*v85 & 0x3FFFFFFFFFFFFFFFuLL) > (*v86 & 0x3FFFFFFFFFFFFFFFuLL)) {
                    break;
                  }
                  long long v114 = *(_OWORD *)v85;
                  *(_OWORD *)uint64_t v85 = *(_OWORD *)v86;
                  *(_OWORD *)uint64_t v86 = v114;
                  BOOL v35 = v36 > 3;
                  v36 >>= 1;
                }
                while (v35);
              }
              unint64_t v36 = v83;
            }
            uint64_t v79 = ++v80;
            if (v78 <= v80) {
              goto LABEL_112;
            }
          }
          int v87 = __si_assert_copy_extra(0);
          int v88 = v87;
          uint64_t v89 = "";
          if (v87) {
            uint64_t v89 = v87;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1742, "!(offset & (1ull << 63))", v89);
LABEL_118:
          int v90 = v88;
LABEL_119:
          free(v90);
          if (__valid_fs(-1)) {
            uint64_t v91 = 2989;
          }
          else {
            uint64_t v91 = 3072;
          }
          *(_DWORD *)uint64_t v91 = -559038737;
          abort();
        }
        unint64_t v37 = v17[2];
        uint64_t v38 = v17[3];
        long long v39 = *(_OWORD *)&v17[2 * v36];
        uint64_t v40 = v17[2 * v36];
        *((_OWORD *)v17 + 1) = v39;
        unint64_t v112 = v31 - 1;
        unint64_t v41 = v40 & 0x3FFFFFFFFFFFFFFFLL;
        uint64_t v42 = 1;
        uint64_t v43 = 2;
        uint64_t v44 = 3;
        while (1)
        {
          int8x16_t v45 = *(int8x16_t *)&v17[2 * v43];
          if (v44 >= v31)
          {
            int8x16_t v46 = (int8x16_t)xmmword_1BDA82320;
            if (v43 >= v31) {
              goto LABEL_62;
            }
          }
          else
          {
            int8x16_t v46 = *(int8x16_t *)&v17[2 * v44];
          }
          unint64_t v47 = v45.i64[0] & 0x3FFFFFFFFFFFFFFFLL;
          unint64_t v48 = v46.i64[0] & 0x3FFFFFFFFFFFFFFFLL;
          if ((v45.i64[0] & 0x3FFFFFFFFFFFFFFFuLL) < v41)
          {
            int32x2_t v49 = vdup_n_s32(v48 < v47);
            v50.i64[0] = v49.u32[0];
            v50.i64[1] = v49.u32[1];
            int8x16_t v46 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v50, 0x3FuLL)), v46, v45);
            if (v48 >= v47) {
              uint64_t v44 = v43;
            }
            goto LABEL_55;
          }
          if (v48 >= v41) {
            break;
          }
LABEL_55:
          _X13 = &v17[4 * v44];
          __asm { PRFM            #1, [X13] }
          if (v44 != v42)
          {
            uint64_t v43 = 2 * v44;
            *(_OWORD *)&v17[2 * v44] = v39;
            *(int8x16_t *)&v17[2 * v42] = v46;
            uint64_t v42 = v44;
            BOOL v35 = v44 < v16 >> 1;
            uint64_t v44 = (2 * v44) | 1;
            if (v35) {
              continue;
            }
          }
          goto LABEL_62;
        }
        _X8 = &v17[4 * v42];
        __asm { PRFM            #1, [X8] }
LABEL_62:
        if (v37 >> 62 != 1) {
          goto LABEL_93;
        }
        uint64_t v59 = _directoryStoreReaderGetPage(a1, v37, &v113);
        directoryStorePageGetSize(v59, v60);
        if (v61)
        {
          unint64_t v63 = v61;
          uint64_t v64 = 0;
          for (unsigned int i = 0; i < v63; v64 = ++i)
          {
            uint64_t v66 = *(void *)&v59[8 * v64 + 4];
            if (v66 >= 2)
            {
              if (!a3
                || (LODWORD(v114) = 0, (uint64_t Child = negativeFindChild(a3 + 440, v66, &v114)) == 0)
                || *(void *)(Child + 8) != v38)
              {
                uint64_t v68 = *(void *)&v59[8 * v64 + 8];
                if (v68 < 0)
                {
                  unint64_t v70 = v68 & 0x7FFFFFFFFFFFFFFFLL;
                  if ((v68 & 0x7FFFFFFFFFFFFFFFuLL) < a8)
                  {
                    if (!a9 || HIDWORD(v70))
                    {
LABEL_132:
                      size_t v98 = __si_assert_copy_extra(0);
                      uint64_t v23 = v98;
                      size_t v99 = "";
                      if (v98) {
                        size_t v99 = v98;
                      }
                      __message_assert("%s:%u: failed assertion '%s' %s invalid posting 0x%llx for 0x%llx", "FileTree.c", 1723, "postingOffset", v99, v68, a8);
                      goto LABEL_135;
                    }
                    v70 |= a9;
                  }
                  if (!v70) {
                    goto LABEL_132;
                  }
                  oqpush_3711(a6, v70, v62);
                }
                else if (v68)
                {
                  if ((uint64_t)(v36 + 2) >= v16)
                  {
                    if (v16 >= 4) {
                      v16 *= 2;
                    }
                    else {
                      uint64_t v16 = 4;
                    }
                    if (v17) {
                      uint64_t v69 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v17, 16 * v16 + 32, 0xECA6AA46uLL);
                    }
                    else {
                      uint64_t v69 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v16 + 32, 0x8DDAA030uLL);
                    }
                    uint64_t v17 = v69;
                    if (!v69) {
                      _log_fault_for_malloc_failure();
                    }
                    void *v17 = 0;
                    v17[1] = 0;
                  }
                  unint64_t v71 = v36 + 1;
                  char v72 = &v17[2 * v36];
                  *char v72 = v68;
                  v72[1] = v66;
                  if ((uint64_t)v36 >= 2)
                  {
                    do
                    {
                      unint64_t v73 = &v17[2 * v36];
                      int v74 = &v17[2 * (v36 >> 1)];
                      if ((*v73 & 0x3FFFFFFFFFFFFFFFuLL) > (*v74 & 0x3FFFFFFFFFFFFFFFuLL)) {
                        break;
                      }
                      long long v114 = *(_OWORD *)v73;
                      *(_OWORD *)unint64_t v73 = *(_OWORD *)v74;
                      *(_OWORD *)int v74 = v114;
                      BOOL v35 = v36 > 3;
                      v36 >>= 1;
                    }
                    while (v35);
                  }
                  unint64_t v36 = v71;
                }
              }
            }
          }
        }
LABEL_112:
        uint64_t v111 = v16;
        unint64_t v112 = v36;
        int64_t v31 = v36;
        uint64_t ptr = v17;
        if (v36 == 1)
        {
          free(v17);
          return;
        }
      }
    }
    if ((v13 & 0x4000000000000000) == 0)
    {
      Itemunint64_t Offset = directoryStoreReaderTreeFindItemOffset(a1, v13, *a5, 0);
      if (!ItemOffset) {
        return;
      }
      int64_t v21 = ItemOffset[1];
      if ((v21 & 0x8000000000000000) == 0)
      {
        int v92 = __si_assert_copy_extra(0);
        int v88 = v92;
        int v93 = "";
        if (v92) {
          int v93 = v92;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1772, "(offset & (1ull << 63))", v93);
        goto LABEL_118;
      }
      unint64_t v19 = v21 & 0x7FFFFFFFFFFFFFFFLL;
      if ((v21 & 0x7FFFFFFFFFFFFFFFuLL) < a8)
      {
        if (!a9 || HIDWORD(v19)) {
          goto LABEL_27;
        }
        v19 |= a9;
      }
      if (!v19)
      {
LABEL_27:
        unint64_t v22 = __si_assert_copy_extra(0);
        uint64_t v23 = v22;
        unint64_t v24 = "";
        if (v22) {
          unint64_t v24 = v22;
        }
        __message_assert("%s:%u: failed assertion '%s' %s invalid posting 0x%llx for 0x%llx", "FileTree.c", 1774, "postingOffset", v24, v21, a8);
LABEL_135:
        int v90 = v23;
        goto LABEL_119;
      }
      goto LABEL_16;
    }
    unint64_t v25 = _directoryStoreReaderGetPage(a1, v13, &v113);
    if (!v25) {
      return;
    }
    LODWORD(ptr) = 0;
    unint64_t v27 = directoryStorePageFindItemOffset(*(_DWORD **)(*a1 + 216), (uint64_t)v25, *a5, (unsigned int *)&ptr, 0, v26);
    if (!v27) {
      return;
    }
    int64_t v29 = v27[1];
    if ((v29 & 0x8000000000000000) == 0)
    {
      uint64_t v94 = __si_assert_copy_extra(0);
      uint64_t v95 = v94;
      int v96 = "";
      if (v94) {
        int v96 = v94;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1761, "(offset & (1ull << 63))", v96);
      free(v95);
      if (__valid_fs(-1)) {
        uint64_t v97 = 2989;
      }
      else {
        uint64_t v97 = 3072;
      }
      *(_DWORD *)uint64_t v97 = -559038737;
      abort();
    }
    unint64_t v30 = v29 & 0x7FFFFFFFFFFFFFFFLL;
    if ((v29 & 0x7FFFFFFFFFFFFFFFuLL) < a8)
    {
      if (!a9 || HIDWORD(v30)) {
        goto LABEL_139;
      }
      v30 |= a9;
    }
    if (v30)
    {
      oqpush_3711(a6, v30, v28);
      return;
    }
LABEL_139:
    size_t v102 = __si_assert_copy_extra(0);
    unsigned int v103 = v102;
    off_t v104 = "";
    if (v102) {
      off_t v104 = v102;
    }
    __message_assert("%s:%u: failed assertion '%s' %s invalid posting 0x%llx for 0x%llx", "FileTree.c", 1763, "postingOffset", v104, v29, a8);
    free(v103);
    if (__valid_fs(-1)) {
      uint64_t v105 = 2989;
    }
    else {
      uint64_t v105 = 3072;
    }
    *(_DWORD *)uint64_t v105 = -559038737;
    abort();
  }
  unint64_t v19 = v13 & 0x7FFFFFFFFFFFFFFFLL;
  if ((v13 & 0x7FFFFFFFFFFFFFFFLL) < a8)
  {
    if (!a9 || HIDWORD(v19)) {
      goto LABEL_136;
    }
    v19 |= a9;
  }
  if (!v19)
  {
LABEL_136:
    uint64_t v100 = __si_assert_copy_extra(0);
    uint64_t v23 = v100;
    size_t v101 = "";
    if (v100) {
      size_t v101 = v100;
    }
    __message_assert("%s:%u: failed assertion '%s' %s invalid posting 0x%llx for 0x%llx", "FileTree.c", 1700, "postingOffset", v101, v13, a8);
    goto LABEL_135;
  }
LABEL_16:
  oqpush_3711(a6, v19, v12);
}

uint64_t directoryStoreReaderGetDirectoryWithPath(uint64_t *a1, unsigned __int16 *Page, int a3, uint64_t a4)
{
  if (a3 != -1)
  {
    uint64_t v14 = v4;
    uint64_t v15 = v5;
    BOOL v13 = 0;
    int64_t v6 = *((void *)Page + 1);
    if (v6 < 1)
    {
      return 0;
    }
    else
    {
      Page = _directoryStoreReaderGetPage(a1, *((void *)Page + 1), &v13);
      if (Page)
      {
        if (v13) {
          Itemunint64_t Offset = directoryStorePageFindItemOffset(*(_DWORD **)(*a1 + 216), (uint64_t)Page, *(void *)(a4 + 8 * a3), 0, 0, v10);
        }
        else {
          Itemunint64_t Offset = directoryStoreReaderTreeFindItemOffset(a1, v6, *(void *)(a4 + 8 * a3), 0);
        }
        Page = (unsigned __int16 *)ItemOffset;
        if (ItemOffset) {
          return directoryStoreReaderGetDirectoryWithPath(a1, ItemOffset, (a3 - 1), a4);
        }
      }
    }
  }
  return (uint64_t)Page;
}

void oqpush_3711(uint64_t a1, uint64_t a2, size_t size)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v17 = __si_assert_copy_extra(0);
    uint64_t v7 = v17;
    unint64_t v18 = "";
    if (v17) {
      unint64_t v18 = v17;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 327, "!oqueue->has_meta", v18);
LABEL_25:
    free(v7);
    if (__valid_fs(-1)) {
      uint64_t v20 = 2989;
    }
    else {
      uint64_t v20 = 3072;
    }
    *(_DWORD *)uint64_t v20 = -559038737;
    abort();
  }
  if (*(_DWORD *)(a1 + 56))
  {
    if (*(void *)(a1 + 64) < (a2 & 0x3FFFFFFFFFFFFFFFuLL))
    {
      unint64_t v19 = __si_assert_copy_extra(0);
      uint64_t v7 = v19;
      BOOL v8 = "";
      if (v19) {
        BOOL v8 = v19;
      }
      uint64_t v9 = "!queue->split || queue->splitPoint >= offset_t_GET_VALUE(value)";
      goto LABEL_24;
    }
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5 >= *(void *)(a1 + 24))
    {
      int64_t v6 = __si_assert_copy_extra(0);
      uint64_t v7 = v6;
      BOOL v8 = "";
      if (v6) {
        BOOL v8 = v6;
      }
      uint64_t v9 = "!queue->split";
LABEL_24:
      __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 247, v9, v8);
      goto LABEL_25;
    }
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 24);
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5 >= v10)
    {
      uint64_t v11 = 2 * v10;
      if (!v10) {
        uint64_t v11 = 4;
      }
      *(void *)(a1 + 24) = v11;
      size_t v12 = *(void **)(a1 + 16);
      size_t v13 = 8 * v11;
      if (v12) {
        uint64_t v14 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v12, v13, 0xECA6AA46uLL);
      }
      else {
        uint64_t v14 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v13, 0x8DDAA030uLL);
      }
      uint64_t v15 = v14;
      if (!v14) {
        _log_fault_for_malloc_failure();
      }
      *(void *)(a1 + 16) = v15;
      uint64_t v5 = *(void *)(a1 + 32);
    }
  }
  uint64_t v16 = *(void *)(a1 + 16);
  *(void *)(a1 + 32) = v5 + 1;
  *(void *)(v16 + 8 * v5) = a2;
}

unsigned __int16 *_directoryStoreReaderGetPage(uint64_t *a1, unint64_t a2, BOOL *a3)
{
  *a3 = a2 >> 62 == 1;
  unint64_t v4 = a2 & 0x3FFFFFFFFFFFFFFFLL;
  uint64_t v5 = *a1;
  if ((a2 & 0x3FFFFFFFFFFFFFFFLL) >= *(void *)(v5 + 232)) {
    return 0;
  }
  uint64_t ptr = storage_reader_get_ptr(v5, a1[1], v4, 8);
  if (ptr == -1) {
    return 0;
  }
  int64_t result = (unsigned __int16 *)storage_reader_get_ptr(*a1, a1[1], v4, 64 << *(unsigned char *)(ptr + 2));
  if ((unint64_t)result + 1 < 2) {
    return 0;
  }
  if ((64 << *((unsigned char *)result + 2)) - 8 < *result)
  {
    BOOL v8 = result;
    uint64_t v9 = __si_assert_copy_extra(0);
    uint64_t v10 = v9;
    uint64_t v11 = "";
    if (v9) {
      uint64_t v11 = v9;
    }
    __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d", "FileTree.c", 254, "storePageEnd((StorePageRef)page) <= storePageDataSize((StorePageRef)page) && storePageDataSize((StorePageRef)page)", v11, *v8, (64 << *((unsigned char *)v8 + 2)) - 8);
    free(v10);
    if (__valid_fs(-1)) {
      uint64_t v12 = 2989;
    }
    else {
      uint64_t v12 = 3072;
    }
    *(_DWORD *)uint64_t v12 = -559038737;
    abort();
  }
  return result;
}

int64_t *directoryStoreReaderTreeFindItemOffset(uint64_t *a1, unint64_t a2, unint64_t a3, int a4)
{
  while (1)
  {
    int v4 = a4;
    unint64_t v5 = a3;
    int64_t v6 = a1;
    BOOL v20 = 0;
    int64_t result = (int64_t *)_directoryStoreReaderGetPage(a1, a2, &v20);
    if (!result) {
      return result;
    }
    if (v20)
    {
      size_t v13 = __si_assert_copy_extra(0);
      uint64_t v14 = v13;
      uint64_t v15 = "";
      if (v13) {
        uint64_t v15 = v13;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 847, "!flat", v15);
LABEL_19:
      free(v14);
      if (__valid_fs(-1)) {
        uint64_t v18 = 2989;
      }
      else {
        uint64_t v18 = 3072;
      }
      *(_DWORD *)uint64_t v18 = -559038737;
      abort();
    }
    uint64_t v9 = result;
    if (*((unsigned __int16 *)result + 3) != v4)
    {
      uint64_t v16 = __si_assert_copy_extra(0);
      uint64_t v14 = v16;
      uint64_t v17 = "";
      if (v16) {
        uint64_t v17 = v16;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 849, "getNum16(page->depth)==(unsigned)pageDepth", v17);
      goto LABEL_19;
    }
    unint64_t Size = directoryTreePageGetSize(*(_WORD *)result, *((unsigned char *)result + 2), v8);
    int v11 = v4 + 1;
    a2 = v9[getHash(v5, Size, 0, v11, 0, 0) + 1];
    if (!a2) {
      return 0;
    }
    if (a2 >> 62 == 1) {
      break;
    }
    a1 = v6;
    a3 = v5;
    a4 = v11;
  }
  int64_t result = (int64_t *)_directoryStoreReaderGetPage(v6, a2, &v20);
  if (result)
  {
    unsigned int v19 = 0;
    return directoryStorePageFindItemOffset(*(_DWORD **)(*v6 + 216), (uint64_t)result, v5, &v19, v11, v12);
  }
  return result;
}

uint64_t directoryStoreValidate(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 8);
    if (*(_DWORD *)(result + 4400) && v2 >= 1)
    {
      uint64_t v4 = v2 & 0x3FFFFFFFFFFFFFFFLL;
      if ((v2 & 0x3FFFFFFFFFFFFFFFuLL) >= *(void *)(result + 232))
      {
        uint64_t v5 = result;
        int64_t v6 = __si_assert_copy_extra(*(_DWORD **)(result + 216));
        uint64_t v7 = v6;
        int8x8_t v8 = "";
        if (v6) {
          int8x8_t v8 = v6;
        }
        __message_assert("%s:%u: failed assertion '%s' %s Expected offset (%llx) to be less than free region (%llx)", "FileTree.c", 1507, "CHILDLESS(offset) || MASKPAGE(offset) <storageGetCount(store)", v8, v4, *(void *)(v5 + 232));
        free(v7);
        if (__valid_fsp(*(_DWORD **)(v5 + 216))) {
          uint64_t v9 = 2989;
        }
        else {
          uint64_t v9 = 3072;
        }
        *(_DWORD *)uint64_t v9 = -559038737;
        abort();
      }
    }
  }
  return result;
}

unsigned __int16 *directoryStoreGetDirectoryWithPath(unsigned __int16 *result, uint64_t a2, unint64_t *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = result;
  if (a4 == -1)
  {
    if (a7)
    {
      unint64_t v18 = a3[1];
      if (v18)
      {
        *(_DWORD *)(a7 + 112) = 1603;
        *(void *)(a7 + 104) = v18;
        int64_t result = _directoryStoreGetPageInner(a2, v18, (BOOL *)v37);
        if (*(_DWORD *)(a7 + 96) != result[3])
        {
          int8x8_t v26 = __si_assert_copy_extra(0);
          unint64_t v27 = v26;
          size_t v28 = "";
          if (v26) {
            size_t v28 = v26;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1607, "refPage->pathDepth==getNum16(page->depth)", v28);
          free(v27);
          if (__valid_fs(-1)) {
            uint64_t v29 = 2989;
          }
          else {
            uint64_t v29 = 3072;
          }
          *(_DWORD *)uint64_t v29 = -559038737;
          abort();
        }
      }
    }
    *(_OWORD *)uint64_t v10 = *(_OWORD *)a3;
    *((void *)v10 + 2) = a3[2];
  }
  else
  {
    uint64_t v38 = 0;
    memset(v37, 0, sizeof(v37));
    if (a7) {
      uint64_t v14 = (_OWORD *)a7;
    }
    else {
      uint64_t v14 = v37;
    }
    BOOL v36 = 0;
    unint64_t v15 = a3[1];
    int64_t v16 = *(void *)(*a3 + 8);
    if (v15)
    {
      int64_t result = _directoryStoreGetPageInner(a2, v15, &v36);
      uint64_t v17 = result;
      *a3 = (unint64_t)&result[8 * *((unsigned int *)a3 + 4) + 4];
    }
    else
    {
      uint64_t v17 = 0;
    }
    unsigned int v35 = 0;
    if (v16 <= 0)
    {
      if (a6)
      {
LABEL_28:
        unint64_t v25 = *(void *)(a5 + 8 * a4);
        char v32 = 0;
        long long v33 = 0uLL;
        unint64_t v34 = 0;
        long long v30 = *(_OWORD *)a3;
        unint64_t v31 = a3[2];
        insertDirectory_3757((uint64_t)&v33, a2, &v30, v35, v25, v25, 0, &v32, (uint64_t)v14);
        uint64_t v21 = (a4 - 1);
        long long v30 = v33;
        unint64_t v31 = v34;
        unint64_t v24 = &v30;
        return (unsigned __int16 *)directoryStoreGetDirectoryWithPath(v10, a2, v24, v21, a5, a6, v14);
      }
    }
    else
    {
      PageInner = _directoryStoreGetPageInner(a2, v16, &v36);
      if (v36)
      {
        int64_t result = (unsigned __int16 *)directoryStorePageFindItemOffset(*(_DWORD **)(a2 + 216), (uint64_t)PageInner, *(void *)(a5 + 8 * a4), &v35, 0, v20);
        if (result)
        {
          *((void *)v14 + 14) = 0;
          v14[5] = 0u;
          v14[6] = 0u;
          void v14[3] = 0u;
          v14[4] = 0u;
          v14[1] = 0u;
          void v14[2] = 0u;
          *uint64_t v14 = 0u;
          uint64_t v21 = (a4 - 1);
          *(void *)&long long v33 = result;
          *((void *)&v33 + 1) = v16;
          LODWORD(v34) = v35;
LABEL_24:
          HIDWORD(v34) = 0;
          unint64_t v24 = &v33;
          return (unsigned __int16 *)directoryStoreGetDirectoryWithPath(v10, a2, v24, v21, a5, a6, v14);
        }
      }
      else
      {
        int64_t result = (unsigned __int16 *)directoryStoreTreeFindItemOffset(a2, v16, *(void *)(a5 + 8 * a4), (uint64_t)v14, &v35, 0, a6);
        if (result)
        {
          unint64_t v22 = v37;
          if (a7) {
            unint64_t v22 = (_OWORD *)a7;
          }
          uint64_t v23 = *((void *)v22 + 13);
          if (a4)
          {
            *((void *)v14 + 14) = 0;
            v14[5] = 0u;
            v14[6] = 0u;
            void v14[3] = 0u;
            v14[4] = 0u;
            v14[1] = 0u;
            void v14[2] = 0u;
            *uint64_t v14 = 0u;
          }
          uint64_t v21 = (a4 - 1);
          *(void *)&long long v33 = result;
          *((void *)&v33 + 1) = v23;
          LODWORD(v34) = v35;
          goto LABEL_24;
        }
      }
      if (a6)
      {
        if (v17) {
          *a3 = (unint64_t)&_directoryStoreGetPageInner(a2, a3[1], &v36)[8 * *((unsigned int *)a3 + 4) + 4];
        }
        goto LABEL_28;
      }
    }
    *(void *)uint64_t v10 = 0;
    *((void *)v10 + 1) = 0;
    *((void *)v10 + 2) = 0;
  }
  return result;
}

unint64_t shiftEntriesForDelete(uint64_t a1, uint64_t a2, unint64_t a3, char a4)
{
  uint64_t v8 = a2 + 1;
  if (a2 + 1 >= a3)
  {
LABEL_6:
    if (!a2)
    {
LABEL_11:
      unint64_t v15 = __si_assert_copy_extra(0);
      int64_t v16 = v15;
      if (v15) {
        uint64_t v17 = v15;
      }
      else {
        uint64_t v17 = "";
      }
      __message_assert("%s:%u: Unexpected code path %s ", "FileTree.c", 1110, v17);
      free(v16);
      goto LABEL_25;
    }
    unint64_t v12 = 0;
    unint64_t v10 = a3 - 1;
    size_t v13 = (unint64_t *)(a1 + 8);
    while (1)
    {
      unint64_t result = *v13;
      if (*v13 <= 1) {
        break;
      }
      unint64_t result = getHash(result, a3, *(unsigned char *)(a1 + 2), a4, 10, 0);
      if (v12 == result) {
        goto LABEL_20;
      }
      long long v14 = *(_OWORD *)v13;
      v13 += 2;
      *(_OWORD *)(a1 + 16 * v10 + 8) = v14;
      unint64_t v10 = v12++;
      if (a2 == v12) {
        goto LABEL_11;
      }
    }
    if (*v13 != 1) {
      goto LABEL_20;
    }
    unint64_t v18 = __si_assert_copy_extra(0);
    unsigned int v19 = v18;
    int8x8_t v20 = "";
    if (v18) {
      int8x8_t v20 = v18;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1089, "!(page->items[i].fileId.storeOID==markerOid.storeOID)", v20);
LABEL_24:
    free(v19);
    if (!__valid_fs(-1))
    {
      uint64_t v24 = 3072;
LABEL_27:
      *(_DWORD *)uint64_t v24 = -559038737;
      abort();
    }
LABEL_25:
    uint64_t v24 = 2989;
    goto LABEL_27;
  }
  uint64_t v9 = (unint64_t *)(a1 + 16 * a2 + 24);
  while (1)
  {
    unint64_t v10 = v8 - 1;
    unint64_t result = *v9;
    if (*v9 <= 1) {
      break;
    }
    unint64_t result = getHash(result, a3, *(unsigned char *)(a1 + 2), a4, 10, 0);
    if (v8 == result) {
      goto LABEL_20;
    }
    *((_OWORD *)v9 - 1) = *(_OWORD *)v9;
    ++v8;
    v9 += 2;
    if (a3 == v8) {
      goto LABEL_6;
    }
  }
  if (*v9 == 1)
  {
    unint64_t v22 = __si_assert_copy_extra(0);
    unsigned int v19 = v22;
    uint64_t v23 = "";
    if (v22) {
      uint64_t v23 = v22;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1058, "!(page->items[i].fileId.storeOID==markerOid.storeOID)", v23);
    goto LABEL_24;
  }
LABEL_20:
  uint64_t v21 = a1 + 16 * v10;
  *(void *)(v21 + 8) = 0;
  *(void *)(v21 + 16) = 0;
  return result;
}

unint64_t directoryStoreEnsurePage(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unsigned char *a5, BOOL *a6, unsigned int a7, uint64_t a8)
{
  unsigned int v123 = a7;
  uint64_t v138 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = *(void *)a2;
  unint64_t v15 = *(void *)(v14 + 8);
  *a6 = 1;
  *a5 = 0;
  int64_t v16 = *(void *)(v14 + 8);
  if (v16 <= 0)
  {
    directoryStoreValidate(a1, v14);
    unint64_t v23 = *(void *)(a2 + 8);
    if (v23)
    {
      PageInner = _directoryStoreGetPageInner(a1, v23, a6);
      unint64_t v25 = (int64_t *)&PageInner[8 * *(unsigned int *)(a2 + 16) + 4];
      *(void *)a2 = v25;
    }
    else
    {
      PageInner = 0;
      unint64_t v25 = *(int64_t **)a2;
    }
    *a5 = 1;
    if (a4) {
      uint64_t v26 = ((unint64_t)v16 >> 63) + 1;
    }
    else {
      uint64_t v26 = a3;
    }
    int64_t v27 = *v25;
    uint64_t v28 = v16 & (v16 >> 63) & 0x7FFFFFFFFFFFFFFFLL;
    if ((unint64_t)(16 * v26) <= 0x4000)
    {
      uint64_t v29 = v123;
      if (a8) {
        *(_DWORD *)(a8 + 96) = v123;
      }
      unsigned int v30 = 16 * v26;
      int v31 = 64;
      do
      {
        unsigned int v32 = v31;
        v31 *= 2;
      }
      while (v32 < v30);
      long long v136 = 0u;
      long long v137 = 0u;
      long long v134 = 0u;
      long long v135 = 0u;
      long long v132 = 0u;
      long long v133 = 0u;
      long long v130 = 0u;
      long long v131 = 0u;
      long long v129 = 0u;
      long long v128 = 0u;
      long long v127 = 0u;
      long long v126 = 0u;
      unsigned int v124 = 0;
      unint64_t v33 = storageAllocOffset(a1, v32, (uint64_t)&v126, (int *)&v124);
      if (v124) {
        dirtyStorageOffsets(a1, (unint64_t *)&v126, v124);
      }
      if (v33)
      {
        unint64_t v34 = (_WORD *)storageResolvePtr(a1, v33, v32, 1);
        uint64_t v29 = v123;
        bzero(v34, v32);
        *unint64_t v34 = 0;
        char v35 = __clz(__rbit32(v32 >> 6));
        if (!v32) {
          char v35 = -1;
        }
        *((unsigned char *)v34 + 2) = v35;
        void v34[3] = v29;
        v34[2] = 668;
        *((unsigned char *)v34 + 3) = 0;
        dirtyStoragePage(a1, (unint64_t)v34);
      }
      unint64_t v15 = v33 | 0x4000000000000000;
      if (!v28) {
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v29 = v123;
      unint64_t v15 = directoryStoreNewTreePage(a1, v123, 663, 0);
      *a6 = 0;
      if (!v28)
      {
LABEL_31:
        unint64_t v43 = *(void *)(a2 + 8);
        if (v43)
        {
          PageInner = _directoryStoreGetPageInner(a1, v43, a6);
          *(void *)a2 = &PageInner[8 * *(unsigned int *)(a2 + 16) + 4];
        }
        if (PageInner) {
          dirtyStoragePage(a1, (unint64_t)PageInner);
        }
        goto LABEL_89;
      }
    }
    unsigned int v124 = 0;
    BOOL v36 = _directoryStoreGetPageInner(a1, v15, a6);
    if (*a6)
    {
      uint64_t v38 = v36;
      if (!directoryStorePageFindItemOffset(*(_DWORD **)(a1 + 216), (uint64_t)v36, v27, &v124, v29, v37))
      {
LABEL_28:
        uint64_t v40 = v124;
        if (*(void *)&v38[8 * v124 + 4] >= 2uLL)
        {
          directoryStorePageGetSize(v38, v39);
          shiftEntries((uint64_t)v38, v40, v41);
          uint64_t v40 = v124;
        }
        uint64_t v42 = &v38[8 * v40];
        *((void *)v42 + 1) = v27;
        *((void *)v42 + 2) = v28 | 0x8000000000000000;
        *v38 += 16;
        goto LABEL_31;
      }
    }
    else
    {
      *(void *)&long long v133 = 0;
      long long v131 = 0u;
      long long v132 = 0u;
      long long v129 = 0u;
      long long v130 = 0u;
      long long v128 = 0u;
      long long v127 = 0u;
      long long v126 = 0u;
      Itemunint64_t Offset = directoryStoreTreeFindItemOffset(a1, v15, v27, &v126, &v124, v29, 1);
      uint64_t v38 = _directoryStoreGetPageInner(a1, *((unint64_t *)&v132 + 1), &v125);
      if (!ItemOffset) {
        goto LABEL_28;
      }
    }
    uint64_t v64 = __si_assert_copy_extra(0);
    unsigned int v65 = v64;
    uint64_t v66 = "";
    if (v64) {
      uint64_t v66 = v64;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 686, "element==0", v66);
    goto LABEL_111;
  }
  if ((v16 & 0x4000000000000000) == 0) {
    return v15;
  }
  directoryStoreValidate(a1, v14);
  uint64_t v17 = _directoryStoreGetPageInner(a1, v16, a6);
  unsigned int v19 = v17;
  int v20 = *v17;
  if (a4)
  {
    int v21 = (64 << *((unsigned char *)v17 + 2)) - 8;
    if (v21 < v20) {
      goto LABEL_107;
    }
    a3 = (v20 >> 4) + 1;
  }
  else
  {
    int v21 = (64 << *((unsigned char *)v17 + 2)) - 8;
  }
  if (v21 < v20)
  {
    size_t v101 = __si_assert_copy_extra(0);
    unsigned int v65 = v101;
    size_t v102 = "";
    if (v101) {
      size_t v102 = v101;
    }
    int v103 = *v19;
    int v104 = 64 << *((unsigned char *)v19 + 2);
    goto LABEL_110;
  }
  unint64_t v44 = v20 >> 4;
  if (a3 >= v44) {
    unint64_t v45 = a3;
  }
  else {
    unint64_t v45 = (v44 + 1);
  }
  if (v45 >= 3) {
    unint64_t v46 = v45;
  }
  else {
    unint64_t v46 = v45 + 1;
  }
  int8x8_t Size = (int8x8_t)directoryStorePageGetSize(v17, v18);
  if (5 * v46 < 4 * v48) {
    return v15;
  }
  *a5 = 1;
  directoryStorePageGetSize(v19, Size);
  if (v49 != 1023 && (5 * v46) < 0xFFDuLL)
  {
    unint64_t v50 = *(void *)(a2 + 8);
    if (v50)
    {
      uint64_t v51 = _directoryStoreGetPageInner(a1, v50, a6);
      *(void *)a2 = &v51[8 * *(unsigned int *)(a2 + 16) + 4];
      dirtyStoragePage(a1, (unint64_t)v51);
    }
    unint64_t v15 = *(void *)(*(void *)a2 + 8);
    uint64_t v52 = _directoryStoreGetPageInner(a1, v15, &v125);
    long long v53 = v52;
    unsigned int v54 = 64 << *((unsigned char *)v52 + 2);
    unint64_t v55 = ((20 * v46) & 0xFFFFFFF0) + 16;
    LODWORD(v46) = v54;
    do
      unint64_t v46 = (2 * v46);
    while (v55 > v46);
    if ((int)(v54 - 8) < *v52)
    {
      unsigned int v107 = __si_assert_copy_extra(0);
      unsigned int v65 = v107;
      int v108 = "";
      if (v107) {
        int v108 = v107;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 587, "storePageEnd((StorePageRef)page) <= storePageDataSize((StorePageRef)page)", v108);
    }
    else
    {
      dirtyStoragePage(a1, (unint64_t)v52);
      directoryStorePageGetSize(v53, v56);
      uint64_t v58 = v57;
      if (storageExtendOffset(a1, v15, v54, v46))
      {
        uint64_t v59 = _directoryStoreGetPageInner(a1, v15, (BOOL *)&v126);
        char v60 = __clz(__rbit32(v46 >> 6));
        if (!v46) {
          char v60 = -1;
        }
        *((unsigned char *)v59 + 2) = v60;
        dirtyStoragePage(a1, (unint64_t)v59);
        if (*(void *)(a1 + 232) > v15)
        {
          unint64_t v61 = _directoryStoreGetPageInner(a1, v15, &v125);
          rehashPage(a1, (uint64_t)v61, v58, v123, v62);
          dirtyStoragePage(a1, (unint64_t)v61);
          if (!v15) {
            return v15;
          }
          goto LABEL_86;
        }
        uint64_t v111 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
        unint64_t v112 = v111;
        BOOL v113 = "";
        if (v111) {
          BOOL v113 = v111;
        }
        __message_assert("%s:%u: failed assertion '%s' %s file tree", "FileTree.c", 595, "getOffset(info) < storageGetCount(store)", v113);
        goto LABEL_134;
      }
      long long v136 = 0u;
      long long v137 = 0u;
      long long v134 = 0u;
      long long v135 = 0u;
      long long v132 = 0u;
      long long v133 = 0u;
      long long v130 = 0u;
      long long v131 = 0u;
      long long v129 = 0u;
      long long v128 = 0u;
      long long v127 = 0u;
      long long v126 = 0u;
      unsigned int v124 = 0;
      if (v46 <= 0x4000)
      {
        unint64_t v84 = storageGrowOffset(a1, v15 & 0x3FFFFFFFFFFFFFFFLL, v54, v46, (uint64_t)&v126, (int *)&v124);
        if (v84)
        {
          unint64_t v15 = v84;
          storageResolvePtr(a1, v84, v46, 1);
          if (v124) {
            dirtyStorageOffsets(a1, (unint64_t *)&v126, v124);
          }
          int v85 = v123;
          if (v15 < *(void *)(a1 + 232))
          {
            uint64_t v86 = _directoryStoreGetPageInner(a1, v15, &v125);
            unint64_t v88 = (unint64_t)v86;
            v86[3] = v123;
            void v86[2] = 808;
            char v89 = __clz(__rbit32(v46 >> 6));
            if (!v46) {
              char v89 = -1;
            }
            *((unsigned char *)v86 + 2) = v89;
            rehashPage(a1, (uint64_t)v86, v58, v85, v87);
            dirtyStoragePage(a1, v88);
LABEL_86:
            unint64_t v90 = *(void *)(a2 + 8);
            if (v90)
            {
              uint64_t v91 = _directoryStoreGetPageInner(a1, v90, a6);
              *(void *)a2 = &v91[8 * *(unsigned int *)(a2 + 16) + 4];
              dirtyStoragePage(a1, (unint64_t)v91);
            }
            v15 |= 0x4000000000000000uLL;
LABEL_89:
            *(void *)(*(void *)a2 + 8) = v15;
            return v15;
          }
          unsigned int v119 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
          unint64_t v112 = v119;
          unsigned int v120 = "";
          if (v119) {
            unsigned int v120 = v119;
          }
          __message_assert("%s:%u: failed assertion '%s' %s file tree", "FileTree.c", 617, "getOffset(*newOffset) < storageGetCount(store)", v120);
        }
        else
        {
          unint64_t v116 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
          unint64_t v112 = v116;
          if (v116) {
            unint64_t v117 = v116;
          }
          else {
            unint64_t v117 = "";
          }
          uint64_t v118 = __error();
          __message_assert("%s:%u: failed assertion '%s' %s error %d expanding from old:%d new:%d", "FileTree.c", 323, "newRealOffset", v117, *v118, v54, v46);
        }
LABEL_134:
        free(v112);
        if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
          uint64_t v121 = 2989;
        }
        else {
          uint64_t v121 = 3072;
        }
        *(_DWORD *)uint64_t v121 = -559038737;
        abort();
      }
      long long v114 = __si_assert_copy_extra(0);
      unsigned int v65 = v114;
      int v115 = "";
      if (v114) {
        int v115 = v114;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 609, "reSize<=((1<<(10))* sizeof(CIDirectory_t))", v115);
    }
LABEL_111:
    free(v65);
    if (__valid_fs(-1)) {
      uint64_t v106 = 2989;
    }
    else {
      uint64_t v106 = 3072;
    }
    *(_DWORD *)uint64_t v106 = -559038737;
    abort();
  }
  if ((64 << *((unsigned char *)v19 + 2)) - 8 < *v19)
  {
LABEL_107:
    uint64_t v105 = __si_assert_copy_extra(0);
    unsigned int v65 = v105;
    size_t v102 = "";
    if (v105) {
      size_t v102 = v105;
    }
    int v103 = *v19;
    int v104 = 64 << *((unsigned char *)v19 + 2);
LABEL_110:
    __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d", "FileTree.c", 287, "storePageEnd((StorePageRef)page) <= storePageDataSize((StorePageRef)page)", v102, v103, v104 - 8);
    goto LABEL_111;
  }
  MEMORY[0x1F4188790](v49);
  uint64_t v68 = &v122[-v67];
  bzero(&v122[-v67], v67);
  directoryStorePageGetSize(v19, v69);
  int v71 = *((unsigned __int8 *)v19 + 3);
  uint64_t v72 = 0;
  if (v70)
  {
    unint64_t v73 = v19 + 4;
    do
    {
      if (*(uint64_t *)v73 >= 2) {
        *(_OWORD *)&v68[2 * v72++] = *v73;
      }
      ++v73;
      --v70;
    }
    while (v70);
  }
  *(void *)&long long v126 = v16 & 0x3FFFFFFFFFFFFFFFLL;
  storageFreeOffset(a1, v16 & 0x3FFFFFFFFFFFFFFFLL, 64 << *((unsigned char *)v19 + 2));
  dirtyStorageOffsets(a1, (unint64_t *)&v126, 1);
  uint64_t v74 = v123;
  unint64_t v15 = directoryStoreNewTreePage(a1, v123, 749, v71);
  if (v72)
  {
    while (1)
    {
      unsigned int v124 = 0;
      *(void *)&long long v133 = 0;
      long long v131 = 0u;
      long long v132 = 0u;
      long long v129 = 0u;
      long long v130 = 0u;
      long long v128 = 0u;
      long long v127 = 0u;
      long long v126 = 0u;
      int v75 = _directoryStoreGetPageInner(a1, v15, a6);
      dirtyStoragePage(a1, (unint64_t)v75);
      if (*a6) {
        break;
      }
      directoryStoreTreeFindItemOffset(a1, v15, *v68, &v126, &v124, v74, 1);
      int8x8_t v76 = _directoryStoreGetPageInner(a1, *((unint64_t *)&v132 + 1), a6);
      if (!*a6)
      {
        uint64_t v95 = __si_assert_copy_extra(0);
        int v96 = v95;
        uint64_t v97 = "";
        if (v95) {
          uint64_t v97 = v95;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 762, "*flat", v97);
LABEL_100:
        free(v96);
        if (__valid_fs(-1)) {
          uint64_t v100 = 2989;
        }
        else {
          uint64_t v100 = 3072;
        }
        *(_DWORD *)uint64_t v100 = -559038737;
        abort();
      }
      if (*((void *)&v132 + 1) == v15)
      {
        size_t v98 = __si_assert_copy_extra(0);
        int v96 = v98;
        size_t v99 = "";
        if (v98) {
          size_t v99 = v98;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 763, "l_outPage.leafPageOffset != getOffset(newChildPage)", v99);
        goto LABEL_100;
      }
      unint64_t v78 = v76;
      uint64_t v79 = v124;
      if (*(void *)&v76[8 * v124 + 4] >= 2uLL)
      {
        directoryStorePageGetSize(v76, v77);
        shiftEntries((uint64_t)v78, v79, v80);
        uint64_t v79 = v124;
      }
      long long v81 = *(_OWORD *)v68;
      v68 += 2;
      *(_OWORD *)&v78[8 * v79 + 4] = v81;
      *v78 += 16;
      dirtyStoragePage(a1, (unint64_t)v78);
      if (!--v72) {
        goto LABEL_74;
      }
    }
    int v93 = __si_assert_copy_extra(0);
    unsigned int v65 = v93;
    uint64_t v94 = "";
    if (v93) {
      uint64_t v94 = v93;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 759, "*flat==0", v94);
    goto LABEL_111;
  }
LABEL_74:
  unint64_t v82 = *(void *)(a2 + 8);
  if (v82)
  {
    unint64_t v83 = _directoryStoreGetPageInner(a1, v82, a6);
    *(void *)a2 = &v83[8 * *(unsigned int *)(a2 + 16) + 4];
    dirtyStoragePage(a1, (unint64_t)v83);
  }
  *(void *)(*(void *)a2 + 8) = v15;
  *a6 = 0;
  if (!_directoryStoreGetPageInner(a1, v15, a6))
  {
    uint64_t v109 = __si_assert_copy_extra(0);
    int v96 = v109;
    int v110 = "";
    if (v109) {
      int v110 = v109;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 796, "page", v110);
    goto LABEL_100;
  }
  return v15;
}

unint64_t directoryStoreNewTreePage(uint64_t a1, __int16 a2, __int16 a3, int a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    int v11 = __si_assert_copy_extra(0);
    unint64_t v12 = v11;
    size_t v13 = "";
    if (v11) {
      size_t v13 = v11;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 371, "specialBits == 0", v13);
LABEL_13:
    free(v12);
    if (__valid_fs(-1)) {
      uint64_t v16 = 2989;
    }
    else {
      uint64_t v16 = 3072;
    }
    *(_DWORD *)uint64_t v16 = -559038737;
    abort();
  }
  memset(v19, 0, sizeof(v19));
  int v18 = 0;
  unint64_t v7 = storageAllocOffset(a1, 0x800u, (uint64_t)v19, &v18);
  unint64_t v17 = v7;
  if (v18) {
    dirtyStorageOffsets(a1, (unint64_t *)v19, v18);
  }
  if (v7)
  {
    uint64_t v8 = storageResolvePtr(a1, v7, 2048, 1);
    bzero((void *)v8, 0x800uLL);
    *(unsigned char *)(v8 + 2) = 5;
    *(_WORD *)(v8 + 6) = a2;
    *(_WORD *)(v8 + 4) = a3;
    directoryTreePageGetSize(0, 5, v9);
    dirtyStorageOffsets(a1, &v17, 1);
    if (v7 >> 62 == 1)
    {
      uint64_t v14 = __si_assert_copy_extra(0);
      unint64_t v12 = v14;
      unint64_t v15 = "";
      if (v14) {
        unint64_t v15 = v14;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 407, "!(((realOffset & (1ull << 63)) ==0) && (realOffset & (1ull << 62))==(1ull << 62))", v15);
      goto LABEL_13;
    }
  }
  return v7;
}

uint64_t shiftEntries(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = result + 16 * a2;
  uint64_t v6 = *(void *)(v3 + 8);
  uint64_t v4 = v3 + 8;
  uint64_t v5 = v6;
  if (!v6)
  {
    int v18 = __si_assert_copy_extra(0);
    unsigned int v19 = v18;
    uint64_t v20 = "";
    if (v18) {
      uint64_t v20 = v18;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1196, "dir.fileId.storeOID!=0", v20);
LABEL_36:
    free(v19);
    if (!__valid_fs(-1))
    {
      uint64_t v27 = 3072;
LABEL_39:
      *(_DWORD *)uint64_t v27 = -559038737;
      abort();
    }
LABEL_37:
    uint64_t v27 = 2989;
    goto LABEL_39;
  }
  if (v5 == 1)
  {
    int v21 = __si_assert_copy_extra(0);
    unsigned int v19 = v21;
    unint64_t v22 = "";
    if (v21) {
      unint64_t v22 = v21;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1197, "getStoreOID(dir.fileId)!=1", v22);
    goto LABEL_36;
  }
  uint64_t v7 = *(void *)(v4 + 8);
  uint64_t v8 = a2 + 1;
  if (a2 + 1 < a3)
  {
    int8x8_t v9 = (uint64_t *)(result + 16 * a2 + 24);
    while (1)
    {
      uint64_t v10 = *v9;
      if ((unint64_t)*v9 <= 1) {
        break;
      }
      uint64_t v11 = v9[1];
      ++v8;
      *int8x8_t v9 = v5;
      v9[1] = v7;
      v9 += 2;
      uint64_t v5 = v10;
      uint64_t v7 = v11;
      if (a3 == v8) {
        goto LABEL_9;
      }
    }
    if (*(void *)(result + 16 * v8 + 16))
    {
      uint64_t v28 = __si_assert_copy_extra(0);
      uint64_t v29 = v28;
      unsigned int v30 = "";
      if (v28) {
        unsigned int v30 = v28;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1203, "page->items[i].childPage.offset==0", v30);
    }
    else
    {
      if (v10 != 1)
      {
        *int8x8_t v9 = v5;
        goto LABEL_23;
      }
      int v31 = __si_assert_copy_extra(0);
      uint64_t v29 = v31;
      unsigned int v32 = "";
      if (v31) {
        unsigned int v32 = v31;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1204, "page->items[i].fileId.storeOID!=markerOid.storeOID", v32);
    }
    free(v29);
    if (__valid_fs(-1)) {
      uint64_t v33 = 2989;
    }
    else {
      uint64_t v33 = 3072;
    }
    *(_DWORD *)uint64_t v33 = -559038737;
    abort();
  }
  uint64_t v11 = v7;
  uint64_t v10 = v5;
LABEL_9:
  if (!a2)
  {
LABEL_13:
    unint64_t v15 = __si_assert_copy_extra(0);
    uint64_t v16 = v15;
    if (v15) {
      unint64_t v17 = v15;
    }
    else {
      unint64_t v17 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "FileTree.c", 1226, v17);
    free(v16);
    goto LABEL_37;
  }
  uint64_t v8 = 0;
  unint64_t v12 = (uint64_t *)(result + 8);
  while (1)
  {
    uint64_t v13 = *v12;
    if ((unint64_t)*v12 <= 1) {
      break;
    }
    uint64_t v14 = v12[1];
    ++v8;
    uint64_t *v12 = v10;
    v12[1] = v11;
    v12 += 2;
    uint64_t v10 = v13;
    uint64_t v11 = v14;
    if (a2 == v8) {
      goto LABEL_13;
    }
  }
  if (*v12 == 1)
  {
    unint64_t v23 = __si_assert_copy_extra(0);
    unsigned int v19 = v23;
    uint64_t v24 = "";
    if (v23) {
      uint64_t v24 = v23;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1215, "page->items[i].fileId.storeOID!=markerOid.storeOID", v24);
    goto LABEL_36;
  }
  if (*(void *)(result + 16 * v8 + 16))
  {
    unint64_t v25 = __si_assert_copy_extra(0);
    unsigned int v19 = v25;
    uint64_t v26 = "";
    if (v25) {
      uint64_t v26 = v25;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1216, "page->items[i].childPage.offset==0", v26);
    goto LABEL_36;
  }
  uint64_t *v12 = v10;
  uint64_t v7 = v11;
LABEL_23:
  *(void *)(result + 16 * v8 + 16) = v7;
  return result;
}

void rehashPage(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int8x8_t a5)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  directoryStorePageGetSize((unsigned __int16 *)a2, a5);
  if (*(unsigned __int16 *)(a2 + 6) != a4)
  {
    unint64_t v23 = __si_assert_copy_extra(0);
    uint64_t v24 = v23;
    unint64_t v25 = "";
    if (v23) {
      unint64_t v25 = v23;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 459, "getNum16(page->depth)==(unsigned)depth", v25);
    free(v24);
    if (__valid_fs(-1)) {
      uint64_t v26 = 2989;
    }
    else {
      uint64_t v26 = 3072;
    }
    *(_DWORD *)uint64_t v26 = -559038737;
    abort();
  }
  unint64_t v10 = v9;
  unsigned int v29 = 0;
  bzero((void *)(a2 + 16 * a3 + 8), 16 * (v9 - a3));
  MEMORY[0x1F4188790](v11);
  unint64_t v12 = &v28[-2 * a3 - 1];
  bzero(v12, 16 * a3);
  if (a3)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 8;
    do
    {
      uint64_t v15 = a2 + v14;
      uint64_t v16 = *(void *)(a2 + v14);
      if (v16)
      {
        if (v16 != 1) {
          *(_OWORD *)&v12[2 * v13++] = *(_OWORD *)v15;
        }
        *(void *)uint64_t v15 = 0;
        *(void *)(v15 + 8) = 0;
      }
      v14 += 16;
      --a3;
    }
    while (a3);
    for (*(_WORD *)a2 = 0; v13; --v13)
    {
      long long v17 = *(_OWORD *)v12;
      v28[0] = 0;
      char v18 = *(unsigned char *)(a2 + 2);
      long long v27 = v17;
      int64_t v19 = v17;
      unsigned int Hash = getHash(v17, v10, v18, a4, 10, v28);
      unsigned int v29 = Hash;
      if (*(void *)(a2 + 16 * Hash + 8))
      {
        directoryStorePageFindItemOffset(*(_DWORD **)(a1 + 216), a2, v19, &v29, a4, v21);
        uint64_t v22 = v29;
        if (*(void *)(a2 + 16 * v29 + 8))
        {
          shiftEntries(a2, v29, v10);
          uint64_t v22 = v29;
        }
      }
      else
      {
        uint64_t v22 = Hash;
      }
      *(_OWORD *)(a2 + 16 * v22 + 8) = v27;
      *(_WORD *)a2 += 16;
      v12 += 2;
    }
  }
  else
  {
    *(_WORD *)a2 = 0;
  }
}

void insertDirectory_3757(uint64_t a1, uint64_t a2, long long *a3, unsigned int a4, unint64_t a5, uint64_t a6, uint64_t a7, unsigned char *a8, uint64_t a9)
{
  unsigned int v56 = a4;
  if (a6 <= 1)
  {
    char v35 = __si_assert_copy_extra(0);
LABEL_28:
    __message_assert("%s:%u: failed assertion '%s' %s ");
LABEL_29:
    free(v35);
    if (__valid_fs(-1)) {
      uint64_t v36 = 2989;
    }
    else {
      uint64_t v36 = 3072;
    }
    *(_DWORD *)uint64_t v36 = -559038737;
    abort();
  }
  BOOL v55 = 0;
  unint64_t v16 = *((void *)a3 + 1);
  if (v16) {
    *(void *)a3 = &_directoryStoreGetPageInner(a2, v16, &v55)[8 * *((unsigned int *)a3 + 4) + 4];
  }
  long long v47 = *a3;
  *(void *)&long long v48 = *((void *)a3 + 2);
  unint64_t v17 = directoryStoreEnsurePage(a2, (uint64_t)&v47, 0, 1, a8, &v55, 0, a9);
  if (a6 != a5)
  {
LABEL_27:
    char v35 = __si_assert_copy_extra(0);
    goto LABEL_28;
  }
  unint64_t v18 = v17;
  unint64_t v19 = v17 & 0xC000000000000000;
  if (!*a8)
  {
    unint64_t v25 = v17;
    if (v19 == 0x4000000000000000) {
      goto LABEL_17;
    }
    uint64_t v54 = 0;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v47 = 0u;
    if (directoryStoreTreeFindItemOffset(a2, v17, a5, (uint64_t)&v47, &v56, 0, 1))
    {
      uint64_t v42 = __si_assert_copy_extra(0);
      uint64_t v38 = v42;
      unint64_t v43 = "";
      if (v42) {
        unint64_t v43 = v42;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1274, "elem==0", v43);
    }
    else
    {
      PageInner = _directoryStoreGetPageInner(a2, *((unint64_t *)&v53 + 1), &v55);
      if (v55)
      {
        uint64_t v22 = PageInner;
        unint64_t v25 = *((void *)&v53 + 1);
        goto LABEL_16;
      }
      unint64_t v44 = __si_assert_copy_extra(0);
      uint64_t v38 = v44;
      unint64_t v45 = "";
      if (v44) {
        unint64_t v45 = v44;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1277, "flat", v45);
    }
    goto LABEL_45;
  }
  if (v19 == 0x4000000000000000)
  {
    uint64_t v20 = _directoryStoreGetPageInner(a2, v17, &v55);
    if (v55)
    {
      uint64_t v22 = v20;
      Itemunint64_t Offset = directoryStorePageFindItemOffset(*(_DWORD **)(a2 + 216), (uint64_t)v20, a5, &v56, 0, v21);
      unint64_t v25 = v18;
      goto LABEL_15;
    }
    int8x8_t v37 = __si_assert_copy_extra(0);
    uint64_t v38 = v37;
    int8x8_t v39 = "";
    if (v37) {
      int8x8_t v39 = v37;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1259, "flat", v39);
LABEL_45:
    free(v38);
    if (__valid_fs(-1)) {
      uint64_t v46 = 2989;
    }
    else {
      uint64_t v46 = 3072;
    }
    *(_DWORD *)uint64_t v46 = -559038737;
    abort();
  }
  Itemunint64_t Offset = directoryStoreTreeFindItemOffset(a2, v17, a5, a9, &v56, 0, 1);
  long long v27 = _directoryStoreGetPageInner(a2, *(void *)(a9 + 104), &v55);
  if (!v55)
  {
    uint64_t v40 = __si_assert_copy_extra(0);
    uint64_t v38 = v40;
    unint64_t v41 = "";
    if (v40) {
      unint64_t v41 = v40;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1266, "flat", v41);
    goto LABEL_45;
  }
  uint64_t v22 = v27;
  unint64_t v25 = *(void *)(a9 + 104);
LABEL_15:
  if (ItemOffset) {
    goto LABEL_27;
  }
LABEL_16:
  if (v22) {
    goto LABEL_19;
  }
LABEL_17:
  uint64_t v28 = _directoryStoreGetPageInner(a2, v18, &v55);
  if (!v55) {
    goto LABEL_27;
  }
  uint64_t v22 = v28;
LABEL_19:
  uint64_t v29 = v56;
  if (*(void *)&v22[8 * v56 + 4] >= 2uLL)
  {
    directoryStorePageGetSize(v22, v24);
    shiftEntries((uint64_t)v22, v29, v30);
    uint64_t v29 = v56;
  }
  int v31 = &v22[8 * v29];
  *((void *)v31 + 1) = a5;
  *((void *)v31 + 2) = a7;
  *v22 += 16;
  directoryStorePageGetSize(v22, v24);
  unint64_t v33 = *v22;
  if ((64 << *((unsigned char *)v22 + 2)) - 8 < (int)v33)
  {
    char v35 = __si_assert_copy_extra(0);
    __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d");
    goto LABEL_29;
  }
  if (5 * (v33 >> 4) >= 4 * v32) {
    goto LABEL_27;
  }
  dirtyStoragePage(a2, (unint64_t)v22);
  unsigned int v34 = v56;
  *(void *)a1 = &v22[8 * v56 + 4];
  *(void *)(a1 + 8) = v25;
  *(_DWORD *)(a1 + 16) = v34;
}

uint64_t directoryStoreMoveDirectory(uint64_t result, int a2, unint64_t *a3, int a4, uint64_t a5)
{
  if (result)
  {
    uint64_t v9 = result;
    unint64_t v10 = (uint64_t *)(result + 4424);
    int v11 = setCrashStateTarget(3);
    *(unsigned char *)uint64_t v9 = 1;
    if (a2)
    {
      if (a3[a2 - 1] == *v10) {
        int v12 = a2 - 1;
      }
      else {
        int v12 = a2;
      }
      if (a4) {
        goto LABEL_7;
      }
    }
    else
    {
      int v12 = 0;
      if (a4)
      {
LABEL_7:
        if (*(void *)(a5 + 8 * (a4 - 1)) == *v10) {
          int v13 = a4 - 1;
        }
        else {
          int v13 = a4;
        }
        uint64_t v14 = *v10;
LABEL_13:
        if (v14 != 2)
        {
          BOOL v55 = __si_assert_copy_extra(0);
          __message_assert("%s:%u: failed assertion '%s' %s ");
          goto LABEL_64;
        }
        uint64_t v15 = v9 + 8;
        BOOL v85 = 0;
        char v84 = 1;
        if (!storageResolvePtr(v9 + 8, 0, 1, 1)) {
          goto LABEL_60;
        }
        int32_t v16 = OSAtomicIncrement32(exceptionSequenceNum);
        unint64_t v83 = 0;
        unint64_t v82 = 0;
        uint64_t v17 = *(void *)(v9 + 224);
        int v64 = v11;
        if (v17) {
          int v18 = *(_DWORD *)(v17 + 44);
        }
        else {
          int v18 = -1;
        }
        unint64_t v19 = setThreadIdAndInfo(v18, sStorageExceptionCallbacks, v9 + 8, 1, v16);
        unint64_t v83 = __PAIR64__(v19, HIDWORD(v19));
        unint64_t v82 = __PAIR64__(v20, v21);
        uint64_t v22 = *(void *)&threadData[18 * v19 + 2];
        uint64_t v23 = v22 + 320 * HIDWORD(v19);
        int v63 = *(_DWORD *)(v23 + 312);
        int8x8_t v24 = *(void (**)(void))(v23 + 224);
        if (v24) {
          v24(*(void *)(v22 + 320 * HIDWORD(v19) + 288));
        }
        unint64_t v81 = v83;
        unint64_t v80 = v82;
        if (_setjmp((int *)v23))
        {
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
          }
          *(_DWORD *)(v23 + 312) = v63;
          CIOnThreadCleanUpReset(v80);
          dropThreadId(HIDWORD(v81), 1, v16);
          CICleanUpReset(HIDWORD(v81), HIDWORD(v80));
LABEL_59:
          int v11 = v64;
LABEL_60:
          unint64_t result = setCrashStateTarget(v11);
          if (v84) {
            return result;
          }
          unint64_t result = directoryStoreValidate(v15, (uint64_t)v10);
          if (*v10 == 2) {
            return result;
          }
          uint64_t v57 = __si_assert_copy_extra(0);
          uint64_t v58 = v57;
          uint64_t v59 = "";
          if (v57) {
            uint64_t v59 = v57;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2083, "getStoreOID(root->fileId)==2", v59);
LABEL_71:
          free(v58);
          if (__valid_fs(-1)) {
            uint64_t v60 = 2989;
          }
          else {
            uint64_t v60 = 3072;
          }
          *(_DWORD *)uint64_t v60 = -559038737;
          abort();
        }
        directoryStoreValidate(v9 + 8, (uint64_t)v10);
        uint64_t v25 = 0;
        *(void *)&uint8_t buf[8] = 0;
        *(void *)&long long v87 = 0;
        v67[0] = 0;
        long long v69 = 0uLL;
        *(void *)&long long v70 = 0;
        *(void *)std::string buf = v10;
        directoryStoreGetDirectoryWithPath((unsigned __int16 *)&v69, v9 + 8, (unint64_t *)buf, v12 - 2, (uint64_t)(a3 + 1), 0, 0);
        if (!(void)v69) {
          goto LABEL_30;
        }
        int64_t v26 = *(void *)(v69 + 8);
        if (v26 >= 1)
        {
          if ((v26 & 0x4000000000000000) == 0)
          {
            uint64_t v25 = 0;
            uint64_t v93 = 0;
            long long v91 = 0u;
            long long v92 = 0u;
            long long v89 = 0u;
            long long v90 = 0u;
            long long v87 = 0u;
            long long v88 = 0u;
            *(_OWORD *)std::string buf = 0u;
            LODWORD(v78) = 0;
            Itemunint64_t Offset = directoryStoreTreeFindItemOffset(v9 + 8, v26, *a3, (uint64_t)buf, (unsigned int *)&v78, 0, 0);
            if (ItemOffset)
            {
              unint64_t v28 = *ItemOffset;
              uint64_t v29 = ItemOffset[1];
              *Itemunint64_t Offset = 0;
              ItemOffset[1] = 0;
              PageInner = _directoryStoreGetPageInner(v9 + 8, *((unint64_t *)&v92 + 1), v67);
              *PageInner -= 16;
              uint64_t v31 = v78;
              directoryStorePageGetSize(PageInner, v32);
              shiftEntriesForDelete((uint64_t)PageInner, v31, v33, v92);
              if (!v67[0])
              {
                unint64_t v61 = __si_assert_copy_extra(0);
                uint64_t v58 = v61;
                int8x8_t v62 = "";
                if (v61) {
                  int8x8_t v62 = v61;
                }
                __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1888, "flat", v62);
                goto LABEL_71;
              }
              uint64_t v25 = v29;
              dirtyStoragePage(v9 + 8, (unint64_t)PageInner);
              goto LABEL_33;
            }
LABEL_30:
            unint64_t v34 = 0;
LABEL_35:
            directoryStoreValidate(v9 + 8, (uint64_t)v10);
            if (!v34)
            {
LABEL_56:
              char v84 = 0;
              uint64_t v51 = *(void *)&threadData[18 * HIDWORD(v81) + 2];
              unsigned int v52 = v81;
              uint64_t v53 = v51 + 320 * v81;
              *(_DWORD *)(v53 + 312) = v63;
              uint64_t v54 = *(void (**)(void))(v53 + 232);
              if (v54) {
                v54(*(void *)(v51 + 320 * v52 + 288));
              }
              dropThreadId(HIDWORD(v81), 0, v16);
              goto LABEL_59;
            }
            uint64_t v93 = 0;
            long long v91 = 0u;
            long long v92 = 0u;
            long long v89 = 0u;
            long long v90 = 0u;
            long long v87 = 0u;
            long long v88 = 0u;
            *(_OWORD *)std::string buf = 0u;
            long long v78 = 0uLL;
            uint64_t v79 = 0;
            *(void *)&long long v70 = 0;
            long long v69 = (unint64_t)v10;
            directoryStoreGetDirectoryWithPath((unsigned __int16 *)&v78, v9 + 8, (unint64_t *)&v69, v13 - 1, a5, 1, (uint64_t)buf);
            if (*((void *)&v78 + 1))
            {
              unint64_t v41 = _directoryStoreGetPageInner(v9 + 8, *((unint64_t *)&v78 + 1), &v85);
              if (v41)
              {
                *(void *)&long long v78 = &v41[8 * v79 + 4];
                char v42 = 0;
              }
              else
              {
                char v42 = 1;
              }
            }
            else
            {
              char v42 = 1;
            }
            unsigned int v77 = 0;
            int64_t v43 = *(void *)(v78 + 8);
            if (v43 < 1)
            {
              char v68 = 0;
              unsigned int v48 = 0;
LABEL_55:
              uint64_t v76 = 0;
              long long v74 = 0u;
              long long v75 = 0u;
              long long v72 = 0u;
              long long v73 = 0u;
              long long v70 = 0u;
              long long v71 = 0u;
              long long v69 = 0u;
              long long v65 = v78;
              uint64_t v66 = v79;
              insertDirectory_3757((uint64_t)v67, v15, &v65, v48, v34, v34, v25, &v68, (uint64_t)&v69);
              goto LABEL_56;
            }
            unint64_t v44 = _directoryStoreGetPageInner(v9 + 8, v43, &v85);
            if (v85)
            {
              uint64_t v46 = directoryStorePageFindItemOffset(*(_DWORD **)(v9 + 224), (uint64_t)v44, v34, &v77, 0, v45);
              if (!v46)
              {
                BOOL v47 = 0;
                goto LABEL_51;
              }
              if (*v46 == v34)
              {
                BOOL v47 = 1;
LABEL_51:
                if ((v42 & 1) == 0)
                {
                  long long v50 = _directoryStoreGetPageInner(v15, *((unint64_t *)&v78 + 1), &v85);
                  *(void *)&long long v78 = &v50[8 * v79 + 4];
                }
                char v68 = 0;
                if (v47) {
                  goto LABEL_56;
                }
                unsigned int v48 = v77;
                goto LABEL_55;
              }
            }
            else
            {
              uint64_t v76 = 0;
              long long v74 = 0u;
              long long v75 = 0u;
              long long v72 = 0u;
              long long v73 = 0u;
              long long v70 = 0u;
              long long v71 = 0u;
              long long v69 = 0u;
              long long v49 = directoryStoreTreeFindItemOffset(v9 + 8, *(void *)(v78 + 8), v34, (uint64_t)&v69, &v77, 0, 0);
              if (!v49 || *v49 == v34)
              {
                BOOL v47 = v49 != 0;
                goto LABEL_51;
              }
            }
            BOOL v55 = __si_assert_copy_extra(0);
            __message_assert("%s:%u: failed assertion '%s' %s %lld != %lld");
LABEL_64:
            free(v55);
            if (__valid_fs(-1)) {
              uint64_t v56 = 2989;
            }
            else {
              uint64_t v56 = 3072;
            }
            *(_DWORD *)uint64_t v56 = -559038737;
            abort();
          }
          char v35 = _directoryStoreGetPageInner(v9 + 8, v26, v67);
          *(_DWORD *)std::string buf = 0;
          int8x8_t v37 = directoryStorePageFindItemOffset(*(_DWORD **)(v9 + 224), (uint64_t)v35, *a3, (unsigned int *)buf, 0, v36);
          if (v37)
          {
            unint64_t v28 = *v37;
            uint64_t v38 = v37[1];
            *(_OWORD *)int8x8_t v37 = xmmword_1BDA82440;
            *v35 -= 16;
            uint64_t v39 = *(unsigned int *)buf;
            directoryStorePageGetSize(v35, (int8x8_t)1);
            shiftEntriesForDelete((uint64_t)v35, v39, v40, 0);
            dirtyStoragePage(v9 + 8, (unint64_t)v35);
            uint64_t v25 = v38;
LABEL_33:
            unint64_t v34 = v28;
            goto LABEL_35;
          }
        }
        uint64_t v25 = 0;
        unint64_t v34 = 0;
        goto LABEL_35;
      }
    }
    uint64_t v14 = *v10;
    int v13 = 0;
    goto LABEL_13;
  }
  return result;
}

uint64_t directoryStoreMergeUpdateSet(uint64_t a1, void *a2, uint64_t a3)
{
  int v6 = setCrashStateTarget(3);
  if (storageResolvePtr(a1 + 8, 0, 1, 1))
  {
    int32_t v7 = OSAtomicIncrement32(exceptionSequenceNum);
    uint64_t v8 = *(void *)(a1 + 224);
    if (v8) {
      int v9 = *(_DWORD *)(v8 + 44);
    }
    else {
      int v9 = -1;
    }
    unint64_t v10 = setThreadIdAndInfo(v9, sStorageExceptionCallbacks, a1 + 8, 1, v7);
    unsigned int v33 = HIDWORD(v10);
    unsigned int v34 = v10;
    unint64_t v32 = __PAIR64__(v11, v12);
    uint64_t v13 = *(void *)&threadData[18 * v10 + 2];
    uint64_t v14 = v13 + 320 * HIDWORD(v10);
    int v15 = *(_DWORD *)(v14 + 312);
    int32_t v16 = *(void (**)(void))(v14 + 224);
    if (v16) {
      v16(*(void *)(v13 + 320 * HIDWORD(v10) + 288));
    }
    unsigned int v31 = v34;
    unsigned int v30 = v33;
    unint64_t v29 = v32;
    if (_setjmp((int *)v14))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)&buf, 2u);
      }
      *(_DWORD *)(v14 + 312) = v15;
      CIOnThreadCleanUpReset(v29);
      dropThreadId(v31, 1, v7);
      CICleanUpReset(v31, HIDWORD(v29));
    }
    else
    {
      *(unsigned char *)a1 = 1;
      uint64_t v17 = *(void *)(a1 + 4424);
      if (!v17)
      {
        uint64_t v17 = 2;
        *(void *)(a1 + 4424) = 2;
      }
      if (*a2 != v17)
      {
        uint64_t v23 = __si_assert_copy_extra(0);
        int8x8_t v24 = v23;
        uint64_t v25 = "";
        if (v23) {
          uint64_t v25 = v23;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2306, "rootDirectory->fileid == getStoreOID(root.directory->fileId)", v25);
        free(v24);
        if (__valid_fs(-1)) {
          uint64_t v26 = 2989;
        }
        else {
          uint64_t v26 = 3072;
        }
        *(_DWORD *)uint64_t v26 = -559038737;
        abort();
      }
      uint64_t v28 = 0;
      long long buf = (unint64_t)(a1 + 4424);
      mergeOne(a1 + 8, &buf, (uint64_t)a2, a3);
      uint64_t v18 = *(void *)&threadData[18 * v31 + 2];
      unsigned int v19 = v30;
      uint64_t v20 = v18 + 320 * v30;
      *(_DWORD *)(v20 + 312) = v15;
      unsigned int v21 = *(void (**)(void))(v20 + 232);
      if (v21) {
        v21(*(void *)(v18 + 320 * v19 + 288));
      }
      dropThreadId(v31, 0, v7);
    }
  }
  return setCrashStateTarget(v6);
}

uint64_t mergeOne(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4)
{
  BOOL v48 = 0;
  unint64_t v8 = *((void *)a2 + 1);
  if (v8)
  {
    int v9 = &_directoryStoreGetPageInner(a1, v8, &v48)[8 * *((unsigned int *)a2 + 4) + 4];
    *(void *)a2 = v9;
  }
  else
  {
    int v9 = *(unsigned __int16 **)a2;
  }
  directoryStoreValidate(a1, (uint64_t)v9);
  unint64_t v10 = *((void *)a2 + 1);
  if (*(void *)(a3 + 8))
  {
    if (v10)
    {
      unsigned int v11 = &_directoryStoreGetPageInner(a1, v10, &v48)[8 * *((unsigned int *)a2 + 4) + 4];
      *(void *)a2 = v11;
    }
    else
    {
      unsigned int v11 = *(unsigned __int16 **)a2;
    }
    directoryStoreValidate(a1, (uint64_t)v11);
    unint64_t v12 = *((void *)a2 + 1);
    if (v12) {
      *(void *)a2 = &_directoryStoreGetPageInner(a1, v12, &v48)[8 * *((unsigned int *)a2 + 4) + 4];
    }
    __int16 v47 = 0;
    unint64_t v13 = **(void **)(a3 + 8);
    long long v37 = *a2;
    *(void *)&long long v38 = *((void *)a2 + 2);
    directoryStoreEnsurePage(a1, (uint64_t)&v37, v13, 0, &v47, (BOOL *)&v47 + 1, 0, 0);
    unint64_t v14 = *((void *)a2 + 1);
    if (v14) {
      *(void *)a2 = &_directoryStoreGetPageInner(a1, v14, (BOOL *)&v47 + 1)[8 * *((unsigned int *)a2 + 4) + 4];
    }
    uint64_t v46 = 0;
    long long v45 = 0uLL;
    uint64_t v15 = *(void *)(a3 + 8);
    if (*(void *)(v15 + 8))
    {
      unint64_t v16 = 0;
      uint64_t v17 = 16;
      do
      {
        if (*(uint64_t *)(v15 + v17) >= 2)
        {
          unint64_t v18 = *((void *)a2 + 1);
          if (v18)
          {
            *(void *)a2 = &_directoryStoreGetPageInner(a1, v18, (BOOL *)&v47 + 1)[8 * *((unsigned int *)a2 + 4) + 4];
            uint64_t v15 = *(void *)(a3 + 8);
          }
          uint64_t v19 = v15 + v17;
          uint64_t v44 = 0;
          long long v42 = 0u;
          long long v43 = 0u;
          long long v40 = 0u;
          long long v41 = 0u;
          long long v38 = 0u;
          long long v39 = 0u;
          long long v37 = 0u;
          long long v35 = *a2;
          uint64_t v36 = *((void *)a2 + 2);
          directoryStoreGetDirectoryWithPath((unsigned __int16 *)&v45, a1, (unint64_t *)&v35, 0, v15 + v17, 1, (uint64_t)&v37);
          long long v35 = v45;
          uint64_t v36 = v46;
          mergeOne(a1, &v35, v19, a4);
          uint64_t v15 = *(void *)(a3 + 8);
        }
        ++v16;
        v17 += 32;
      }
      while (v16 < *(void *)(v15 + 8));
    }
    unint64_t v10 = *((void *)a2 + 1);
  }
  if (v10)
  {
    uint64_t v20 = &_directoryStoreGetPageInner(a1, v10, &v48)[8 * *((unsigned int *)a2 + 4) + 4];
    *(void *)a2 = v20;
  }
  else
  {
    uint64_t v20 = *(unsigned __int16 **)a2;
  }
  directoryStoreValidate(a1, (uint64_t)v20);
  unint64_t v21 = *((void *)a2 + 1);
  if (v21) {
    *(void *)a2 = &_directoryStoreGetPageInner(a1, v21, &v48)[8 * *((unsigned int *)a2 + 4) + 4];
  }
  if (*(_DWORD *)(a3 + 24))
  {
    unint64_t v22 = *(void *)(a4 + 16);
    unint64_t v23 = *(void *)(a4 + 8) + 1;
    if (v23 >= v22)
    {
      if (!v22)
      {
        unint64_t v22 = 1024;
        *(void *)(a4 + 16) = 1024;
      }
      if (v23 >= v22)
      {
        do
        {
          BOOL v24 = v23 >= 2 * v22;
          v22 *= 2;
        }
        while (v24);
        *(void *)(a4 + 16) = v22;
      }
      *(void *)a4 = malloc_type_realloc(*(void **)a4, 24 * v22, 0x10200409F4E64B8uLL);
    }
    uint64_t v25 = *(unsigned __int16 **)a2;
    uint64_t v26 = *(void *)(*(void *)a2 + 8);
    if (v26 < 0) {
      goto LABEL_38;
    }
    if (v26)
    {
      uint64_t v44 = 0;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v37 = 0u;
      long long v45 = 0uLL;
      uint64_t v46 = 0;
      long long v35 = *a2;
      uint64_t v36 = *((void *)a2 + 2);
      directoryStoreGetDirectoryWithPath((unsigned __int16 *)&v45, a1, (unint64_t *)&v35, 0, a3, 1, (uint64_t)&v37);
      uint64_t v25 = (unsigned __int16 *)v45;
      uint64_t v26 = *(void *)(v45 + 8);
      if (v26 < 0)
      {
LABEL_38:
        long long v27 = *(_DWORD **)a4;
        uint64_t v28 = *(void *)(a4 + 8);
        v27[6 * v28] = v26;
        *(void *)&v27[6 * v28 + 2] = a3 + 16;
        *(void *)(a4 + 8) = v28 + 1;
        goto LABEL_39;
      }
      if (v26)
      {
        unint64_t v32 = __si_assert_copy_extra(0);
        unsigned int v33 = v32;
        if (v32) {
          unsigned int v34 = v32;
        }
        else {
          unsigned int v34 = "";
        }
        __message_assert("%s:%u: Unexpected code path %s ", "FileTree.c", 2249, v34);
        free(v33);
        MEMORY[0xBAD] = -559038737;
        abort();
      }
    }
    uint64_t v26 = (*(_DWORD *)(a4 + 24) + 1);
    *(_DWORD *)(a4 + 24) = v26;
    *((void *)v25 + 1) = v26 | 0x8000000000000000;
    goto LABEL_38;
  }
LABEL_39:
  unint64_t v29 = *((void *)a2 + 1);
  if (v29)
  {
    unsigned int v30 = &_directoryStoreGetPageInner(a1, v29, &v48)[8 * *((unsigned int *)a2 + 4) + 4];
    *(void *)a2 = v30;
  }
  else
  {
    unsigned int v30 = *(unsigned __int16 **)a2;
  }
  return directoryStoreValidate(a1, (uint64_t)v30);
}

void freeForwardDirectoryStore(void *a1)
{
  storageClose((uint64_t)(a1 + 1));
  uint64_t v2 = (const void *)a1[550];
  if (v2) {
    CFRelease(v2);
  }
  free(a1);
}

BOOL dirStoreInit(uint64_t a1, _DWORD *a2, int a3, char a4, void *aBlock)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = a1 + 8;
  BOOL v68 = 0;
  if (!a3)
  {
    bzero(buf, 0x400uLL);
    uint64_t v15 = fd_pread(a2, buf, 0x400uLL, 64);
    if (v15 == 1024)
    {
      unint64_t v61 = (char *)buf + 8;
      BOOL v68 = storageHeaderRestore(v9, &v61);
      BOOL v16 = v68;
      if (v68) {
        BOOL v16 = storageInit(v9, 0x10000, 0x40uLL, (uint64_t)a2, 0, 1, a4, 102, aBlock);
      }
      BOOL v68 = v16;
      if (v16)
      {
        unint64_t v22 = v61;
        unint64_t v23 = 0;
        uint64_t v24 = 0;
        do
        {
          uint64_t v25 = v24;
          unint64_t v26 = ((unint64_t)(*v22 & 0x7F) << v24) | v23;
          long long v27 = v22 + 1;
          if ((*v22 & 0x80) == 0) {
            break;
          }
          v24 += 7;
          ++v22;
          unint64_t v23 = v26;
        }
        while (v25 != 63);
        *(void *)(a1 + 4432) = v26;
        unint64_t v28 = 0;
        uint64_t v29 = 0;
        do
        {
          uint64_t v30 = v29;
          unint64_t v31 = ((unint64_t)(*v27 & 0x7F) << v29) | v28;
          if ((*v27 & 0x80) == 0) {
            break;
          }
          ++v27;
          v29 += 7;
          unint64_t v28 = v31;
        }
        while (v30 != 63);
        *(void *)(a1 + 4424) = v31;
        CFAllocatorRef v32 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        *(_OWORD *)(a1 + 4384) = xmmword_1BDA82360;
        CFTypeRef Mutable = CFBitVectorCreateMutable(v32, 0x2000);
        *(void *)(a1 + 4400) = Mutable;
        CFBitVectorSetCount(Mutable, 0x2000);
        if (*(void *)(a1 + 4400)) {
          goto LABEL_43;
        }
        goto LABEL_20;
      }
      bzero(v77, 0x400uLL);
      int v18 = *__error();
      uint64_t v19 = _SILogForLogForCategory(6);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
LABEL_26:
        *__error() = v18;
        goto LABEL_43;
      }
      unsigned int v52 = fd_realpath(a2, v77);
      *(_DWORD *)long long v69 = 136315650;
      long long v70 = "dirStoreInit";
      __int16 v71 = 1024;
      int v72 = 2368;
      __int16 v73 = 2080;
      long long v74 = v52;
      uint64_t v20 = "%s:%d: init storage failed %s";
      uint32_t v21 = 28;
    }
    else
    {
      uint64_t v17 = v15;
      bzero(v77, 0x400uLL);
      int v18 = *__error();
      uint64_t v19 = _SILogForLogForCategory(6);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        goto LABEL_26;
      }
      *(_DWORD *)long long v69 = 136315906;
      long long v70 = "dirStoreInit";
      __int16 v71 = 1024;
      int v72 = 2377;
      __int16 v73 = 2080;
      long long v74 = fd_realpath(a2, v77);
      __int16 v75 = 2048;
      uint64_t v76 = v17;
      uint64_t v20 = "%s:%d: init storage failed %s; could not read header got %ld bytes";
      uint32_t v21 = 38;
    }
    _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, v20, v69, v21);
    goto LABEL_26;
  }
  BOOL v68 = storageInit(a1 + 8, 0x10000, 0x40uLL, (uint64_t)a2, 1, 1, a4, 102, aBlock);
  CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  *(_OWORD *)(a1 + 4384) = xmmword_1BDA82360;
  unsigned int v11 = CFBitVectorCreateMutable(v10, 0x2000);
  *(void *)(a1 + 4400) = v11;
  CFBitVectorSetCount(v11, 0x2000);
  if (!*(void *)(a1 + 4400))
  {
LABEL_20:
    unsigned int v34 = __si_assert_copy_extra(0);
    long long v35 = v34;
    uint64_t v36 = "";
    if (v34) {
      uint64_t v36 = v34;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 47, "bv->_cfbv", v36);
    goto LABEL_23;
  }
  if (!v68) {
    goto LABEL_43;
  }
  BOOL v68 = 0;
  if (!storageResolvePtr(v9, 0, 1, 1)) {
    goto LABEL_43;
  }
  int32_t v12 = OSAtomicIncrement32(exceptionSequenceNum);
  uint64_t v13 = *(void *)(a1 + 224);
  if (v13) {
    int v14 = *(_DWORD *)(v13 + 44);
  }
  else {
    int v14 = -1;
  }
  unint64_t v38 = setThreadIdAndInfo(v14, sStorageExceptionCallbacks, v9, 1, v12);
  *(_DWORD *)long long v69 = HIDWORD(v38);
  v77[0] = v38;
  LODWORD(v61) = v39;
  unsigned int v67 = v40;
  uint64_t v41 = *(void *)&threadData[18 * v38 + 2];
  uint64_t v42 = v41 + 320 * HIDWORD(v38);
  int v43 = *(_DWORD *)(v42 + 312);
  uint64_t v44 = *(void (**)(void))(v42 + 224);
  if (v44) {
    v44(*(void *)(v41 + 320 * HIDWORD(v38) + 288));
  }
  unsigned int v66 = v77[0];
  unsigned int v65 = *(_DWORD *)v69;
  unsigned int v64 = v61;
  unsigned int v63 = v67;
  if (_setjmp((int *)v42))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf[0]) = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)buf, 2u);
    }
    *(_DWORD *)(v42 + 312) = v43;
    CIOnThreadCleanUpReset(v63);
    dropThreadId(v66, 1, v12);
    CICleanUpReset(v66, v64);
    goto LABEL_43;
  }
  memset(buf, 0, 192);
  int v62 = 0;
  unint64_t v45 = storageAllocOffset(v9, 0x400u, (uint64_t)buf, &v62);
  if (v62) {
    dirtyStorageOffsets(v9, (unint64_t *)buf, v62);
  }
  if (v68)
  {
    uint64_t v57 = __si_assert_copy_extra(0);
    long long v35 = v57;
    uint64_t v58 = "";
    if (v57) {
      uint64_t v58 = v57;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2340, "!result", v58);
    goto LABEL_23;
  }
  if (v45)
  {
    if (v45 == 64)
    {
      unint64_t v46 = storageResolvePtr(v9, 0x40uLL, 1024, 1);
      bzero((void *)v46, 0x400uLL);
      *(unsigned char *)(v46 + 2) = 4;
      dirtyStoragePage(v9, v46);
      *(_DWORD *)(v46 + 4) = 0;
      goto LABEL_40;
    }
    uint64_t v59 = __si_assert_copy_extra(0);
    long long v35 = v59;
    uint64_t v60 = "";
    if (v59) {
      uint64_t v60 = v59;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2342, "realOffset==(64)", v60);
LABEL_23:
    free(v35);
    if (__valid_fs(-1)) {
      uint64_t v37 = 2989;
    }
    else {
      uint64_t v37 = 3072;
    }
    *(_DWORD *)uint64_t v37 = -559038737;
    abort();
  }
LABEL_40:
  BOOL v68 = 1;
  uint64_t v47 = *(void *)&threadData[18 * v66 + 2];
  unsigned int v48 = v65;
  uint64_t v49 = v47 + 320 * v65;
  *(_DWORD *)(v49 + 312) = v43;
  long long v50 = *(void (**)(void))(v49 + 232);
  if (v50) {
    v50(*(void *)(v47 + 320 * v48 + 288));
  }
  dropThreadId(v66, 0, v12);
LABEL_43:
  *(_DWORD *)(a1 + 4408) = 1;
  if (v68 && !*(void *)(a1 + 224))
  {
    uint64_t v53 = __si_assert_copy_extra(0);
    uint64_t v54 = v53;
    BOOL v55 = "";
    if (v53) {
      BOOL v55 = v53;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2382, "storageFdPtr(&dirStore->store)!=0", v55);
    free(v54);
    if (__valid_fs(-1)) {
      uint64_t v56 = 2989;
    }
    else {
      uint64_t v56 = 3072;
    }
    *(_DWORD *)uint64_t v56 = -559038737;
    abort();
  }
  return v68;
}

uint64_t flushForwardStore(uint64_t result, uint64_t a2)
{
  uint64_t v2 = (void *)result;
  if (*(void *)(result + 240) == *(void *)(result + 248))
  {
    *(unsigned char *)unint64_t result = 0;
    return result;
  }
  if (*(unsigned char *)result)
  {
    int v4 = setCrashStateTarget(3);
    if (!storageResolvePtr((uint64_t)(v2 + 1), 0, 1, 1)) {
      return setCrashStateTarget(v4);
    }
    int32_t v5 = OSAtomicIncrement32(exceptionSequenceNum);
    uint64_t v6 = v2[28];
    if (v6) {
      int v7 = *(_DWORD *)(v6 + 44);
    }
    else {
      int v7 = -1;
    }
    unint64_t v8 = setThreadIdAndInfo(v7, sStorageExceptionCallbacks, (uint64_t)(v2 + 1), 1, v5);
    unsigned int v54 = HIDWORD(v8);
    unsigned int v55 = v8;
    unint64_t v53 = __PAIR64__(v9, v10);
    uint64_t v11 = *(void *)&threadData[18 * v8 + 2];
    uint64_t v12 = v11 + 320 * HIDWORD(v8);
    int v13 = *(_DWORD *)(v12 + 312);
    int v14 = *(void (**)(void))(v12 + 224);
    if (v14) {
      v14(*(void *)(v11 + 320 * HIDWORD(v8) + 288));
    }
    unsigned int v52 = v55;
    unsigned int v51 = v54;
    unint64_t v50 = v53;
    if (_setjmp((int *)v12))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        LOWORD(v49) = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)&v49, 2u);
      }
      *(_DWORD *)(v12 + 312) = v13;
      CIOnThreadCleanUpReset(v50);
      dropThreadId(v52, 1, v5);
      CICleanUpReset(v52, HIDWORD(v50));
      return setCrashStateTarget(v4);
    }
    *(void *)storageResolvePtr((uint64_t)(v2 + 1), 0, 8, 1) = a2;
    unint64_t v15 = storageResolvePtr((uint64_t)(v2 + 1), 0x40uLL, 1024, 1);
    uint64_t v49 = (int8x8_t *)(v15 + 8);
    storageHeaderStore((uint64_t)(v2 + 1), (uint64_t *)&v49);
    BOOL v16 = v49;
    uint64_t v17 = v49;
    unint64_t v18 = v2[554];
    LOBYTE(v19) = v18;
    if (HIDWORD(v18))
    {
      if ((v18 & 0x8000000000000000) != 0)
      {
        uint64x2_t v23 = (uint64x2_t)vdupq_n_s64(v18);
        v24.i32[0] = v2[554];
        v24.i32[1] = v18 >> 7;
        *uint64_t v49 = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v24, (int64x2_t)vshlq_u64(v23, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v23, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v23, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
        v17[1].i8[0] = HIBYTE(v18) | 0x80;
        LOBYTE(v19) = 1;
        unint64_t v20 = 9;
      }
      else if ((v18 & 0x7F00000000000000) != 0)
      {
        uint64x2_t v21 = (uint64x2_t)vdupq_n_s64(v18);
        v22.i32[0] = v2[554];
        v22.i32[1] = v18 >> 7;
        *uint64_t v49 = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v22, (int64x2_t)vshlq_u64(v21, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v21, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v21, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
        unint64_t v19 = (v18 & 0x7F00000000000000) >> 56;
        unint64_t v20 = 8;
      }
      else
      {
        __int8 v25 = v18 | 0x80;
        if ((v18 & 0xFE000000000000) != 0)
        {
          v49->i8[0] = v25;
          uint64x2_t v26 = (uint64x2_t)vdupq_n_s64(v18);
          int16x8_t v27 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v26, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v26, (uint64x2_t)xmmword_1BDA822E0));
          v27.i64[0] = *(void *)&vmovn_s32((int32x4_t)v27) | 0x80008000800080;
          *(__int32 *)((char *)v17->i32 + 1) = vmovn_s16(v27).u32[0];
          v17->i8[5] = (v18 >> 35) | 0x80;
          v17->i8[6] = (v18 >> 42) | 0x80;
          unint64_t v19 = (v18 & 0xFE000000000000) >> 49;
          unint64_t v20 = 7;
        }
        else
        {
          v49->i8[0] = v25;
          uint64x2_t v28 = (uint64x2_t)vdupq_n_s64(v18);
          int16x8_t v29 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v28, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v28, (uint64x2_t)xmmword_1BDA822E0));
          v29.i64[0] = *(void *)&vmovn_s32((int32x4_t)v29) | 0x80008000800080;
          *(__int32 *)((char *)v17->i32 + 1) = vmovn_s16(v29).u32[0];
          if ((v18 & 0x1FC0000000000) != 0)
          {
            v17->i8[5] = (v18 >> 35) | 0x80;
            unint64_t v19 = (v18 & 0x1FC0000000000) >> 42;
            unint64_t v20 = 6;
          }
          else
          {
            unint64_t v19 = (v18 >> 35) & 0x7F;
            unint64_t v20 = 5;
          }
        }
      }
    }
    else if ((v18 & 0x7F0000000) != 0)
    {
      v49->i8[0] = v18 | 0x80;
      v17->i8[1] = (v18 >> 7) | 0x80;
      v17->i8[2] = (v18 >> 14) | 0x80;
      v17->i8[3] = (v18 >> 21) | 0x80;
      unint64_t v19 = (v18 & 0x7F0000000) >> 28;
      unint64_t v20 = 4;
    }
    else if ((v18 & 0xFE00000) != 0)
    {
      v49->i8[0] = v18 | 0x80;
      v17->i8[1] = (v18 >> 7) | 0x80;
      v17->i8[2] = (v18 >> 14) | 0x80;
      unint64_t v19 = (v18 & 0xFE00000) >> 21;
      unint64_t v20 = 3;
    }
    else if ((v18 & 0x1FC000) != 0)
    {
      v49->i8[0] = v18 | 0x80;
      v17->i8[1] = (v18 >> 7) | 0x80;
      unint64_t v19 = (v18 & 0x1FC000) >> 14;
      unint64_t v20 = 2;
    }
    else
    {
      unint64_t v20 = v18 & 0x3F80;
      if (v20)
      {
        v49->i8[0] = v19 | 0x80;
        unint64_t v19 = v20 >> 7;
        unint64_t v20 = 1;
      }
    }
    v17->i8[v20] = v19;
    unint64_t v30 = v20 + 1;
    unint64_t v31 = v2[553];
    if (HIDWORD(v31))
    {
      if ((v31 & 0x8000000000000000) != 0)
      {
        uint64x2_t v36 = (uint64x2_t)vdupq_n_s64(v31);
        v37.i32[0] = v2[553];
        v37.i32[1] = v31 >> 7;
        *(int8x8_t *)((char *)v17 + v30) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v37, (int64x2_t)vshlq_u64(v36, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v36, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v36, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
        unint64_t v30 = v20 + 10;
        v16[1].i8[v20 + 1] = HIBYTE(v31) | 0x80;
        LOBYTE(v16) = 1;
        goto LABEL_51;
      }
      if ((v31 & 0x7F00000000000000) != 0)
      {
        uint64x2_t v33 = (uint64x2_t)vdupq_n_s64(v31);
        v34.i32[0] = v2[553];
        v34.i32[1] = v31 >> 7;
        *(int8x8_t *)((char *)v17 + v30) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v34, (int64x2_t)vshlq_u64(v33, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v33, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v33, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
        unint64_t v30 = v20 + 9;
        BOOL v16 = (int8x8_t *)((v31 & 0x7F00000000000000) >> 56);
        goto LABEL_51;
      }
      __int8 v38 = v31 | 0x80;
      if ((v31 & 0xFE000000000000) != 0)
      {
        v17->i8[v30] = v38;
        uint64x2_t v39 = (uint64x2_t)vdupq_n_s64(v31);
        int16x8_t v40 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_1BDA822E0));
        v40.i64[0] = *(void *)&vmovn_s32((int32x4_t)v40) | 0x80008000800080;
        uint64_t v41 = (char *)v16 + v20;
        *(_DWORD *)(v41 + 2) = vmovn_s16(v40).u32[0];
        v41[6] = (v31 >> 35) | 0x80;
        unint64_t v30 = v20 + 8;
        v41[7] = (v31 >> 42) | 0x80;
        BOOL v16 = (int8x8_t *)((v31 & 0xFE000000000000) >> 49);
        goto LABEL_51;
      }
      v17->i8[v30] = v38;
      uint64x2_t v42 = (uint64x2_t)vdupq_n_s64(v31);
      unint64_t v30 = v20 + 6;
      int16x8_t v43 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v42, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v42, (uint64x2_t)xmmword_1BDA822E0));
      v43.i64[0] = *(void *)&vmovn_s32((int32x4_t)v43) | 0x80008000800080;
      *(__int32 *)((char *)v16->i32 + v20 + 2) = vmovn_s16(v43).u32[0];
      if ((v31 & 0x1FC0000000000) == 0)
      {
        BOOL v16 = (int8x8_t *)((v31 >> 35) & 0x7F);
        goto LABEL_51;
      }
      unint64_t v44 = v20 + 7;
      v17->i8[v30] = (v31 >> 35) | 0x80;
      BOOL v16 = (int8x8_t *)((v31 & 0x1FC0000000000) >> 42);
    }
    else
    {
      if ((v31 & 0x7F0000000) != 0)
      {
        v17->i8[v30] = v31 | 0x80;
        CFAllocatorRef v32 = (char *)v16 + v20;
        v32[2] = (v31 >> 7) | 0x80;
        void v32[3] = (v31 >> 14) | 0x80;
        unint64_t v30 = v20 + 5;
        v32[4] = (v31 >> 21) | 0x80;
        BOOL v16 = (int8x8_t *)((v31 & 0x7F0000000) >> 28);
LABEL_51:
        v17->i8[v30] = (char)v16;
        dirtyStoragePage((uint64_t)(v2 + 1), v15);
        storageSyncPages((uint64_t)(v2 + 1), (uint64_t)(v2 + 548), 0x20000uLL);
        uint64_t v45 = *(void *)&threadData[18 * v52 + 2];
        unsigned int v46 = v51;
        uint64_t v47 = v45 + 320 * v51;
        *(_DWORD *)(v47 + 312) = v13;
        unsigned int v48 = *(void (**)(void))(v47 + 232);
        if (v48) {
          v48(*(void *)(v45 + 320 * v46 + 288));
        }
        dropThreadId(v52, 0, v5);
        return setCrashStateTarget(v4);
      }
      if ((v31 & 0xFE00000) != 0)
      {
        v17->i8[v30] = v31 | 0x80;
        long long v35 = (char *)v16 + v20;
        v35[2] = (v31 >> 7) | 0x80;
        unint64_t v30 = v20 + 4;
        void v35[3] = (v31 >> 14) | 0x80;
        BOOL v16 = (int8x8_t *)((v31 & 0xFE00000) >> 21);
        goto LABEL_51;
      }
      if ((v31 & 0x1FC000) != 0)
      {
        v17->i8[v30] = v31 | 0x80;
        unint64_t v30 = v20 + 3;
        v16->i8[v20 + 2] = (v31 >> 7) | 0x80;
        BOOL v16 = (int8x8_t *)((v31 & 0x1FC000) >> 14);
        goto LABEL_51;
      }
      if ((v31 & 0x3F80) == 0)
      {
        BOOL v16 = (int8x8_t *)v2[553];
        goto LABEL_51;
      }
      unint64_t v44 = v20 + 2;
      v17->i8[v30] = v2[553] | 0x80;
      BOOL v16 = (int8x8_t *)((v31 & 0x3F80) >> 7);
    }
    unint64_t v30 = v44;
    goto LABEL_51;
  }
  return result;
}

void bit_vector_init_3787(uint64_t a1)
{
  if (!a1)
  {
    int v4 = __si_assert_copy_extra(0);
    int32_t v5 = v4;
    uint64_t v6 = "";
    if (v4) {
      uint64_t v6 = v4;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 41, "bv", v6);
LABEL_10:
    free(v5);
    if (__valid_fs(-1)) {
      uint64_t v9 = 2989;
    }
    else {
      uint64_t v9 = 3072;
    }
    *(_DWORD *)uint64_t v9 = -559038737;
    abort();
  }
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  *(_OWORD *)a1 = xmmword_1BDA82360;
  CFTypeRef Mutable = CFBitVectorCreateMutable(v2, 0x2000);
  *(void *)(a1 + 16) = Mutable;
  CFBitVectorSetCount(Mutable, 0x2000);
  if (!*(void *)(a1 + 16))
  {
    int v7 = __si_assert_copy_extra(0);
    int32_t v5 = v7;
    unint64_t v8 = "";
    if (v7) {
      unint64_t v8 = v7;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 47, "bv->_cfbv", v8);
    goto LABEL_10;
  }
}

void *createForwardStore(int a1, const char *a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = malloc_type_calloc(1uLL, 0x1168uLL, 0x10A00405F7FA039uLL);
  bzero(v14, 0x400uLL);
  __sprintf_chk(v14, 0, 0x400uLL, "%s%s", a2, "directoryStoreFile");
  int v7 = fd_create_protected(a1, v14, 1538, 3u);
  if (dirStoreInit((uint64_t)v6, v7, 1, 0, a3))
  {
    int v8 = *__error();
    uint64_t v9 = _SILogForLogForCategory(0);
    os_log_type_t v10 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v9, v10))
    {
      *(_DWORD *)long long buf = 136315138;
      int v13 = v14;
      _os_log_impl(&dword_1BD672000, v9, v10, "createForwardStore:%s", buf, 0xCu);
    }
    *__error() = v8;
    v6[554] = 0;
    v6[553] = 2;
    flushForwardStore((uint64_t)v6, 0);
    *(unsigned char *)uint64_t v6 = 1;
  }
  else
  {
    freeForwardDirectoryStore(v6);
    return 0;
  }
  return v6;
}

uint64_t recoverForwardStore(uint64_t a1, const char *a2, _DWORD *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  bzero(v13, 0x400uLL);
  __sprintf_chk(v13, 0, 0x400uLL, "%s%s", a2, "directoryStoreFile");
  bzero(v12, 0x400uLL);
  __sprintf_chk(v12, 0, 0x400uLL, "%s%s", a2, "directoryStoreFile.shadow");
  int v6 = *__error();
  int v7 = _SILogForLogForCategory(0);
  os_log_type_t v8 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v7, v8))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v11 = v13;
    _os_log_impl(&dword_1BD672000, v7, v8, "recoverForwardStore:%s", buf, 0xCu);
  }
  *__error() = v6;
  return copyFileFallback(a1, v12, a1, v13, a3, 1, 1);
}

void *openForwardStore(int a1, const char *a2, int a3, int a4, int a5, void *a6)
{
  uint64_t v174 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = malloc_type_calloc(1uLL, 0x1168uLL, 0x10A00405F7FA039uLL);
  *(void *)unint64_t v162 = v11;
  bzero(v171, 0x400uLL);
  uint64_t v12 = "directoryStoreFile";
  if (a5) {
    uint64_t v12 = "directoryStoreFile.shadow";
  }
  int v13 = a5 | a4;
  char v14 = a5 | a4;
  __sprintf_chk(v171, 0, 0x400uLL, "%s%s", a2, v12);
  int v15 = *__error();
  BOOL v16 = _SILogForLogForCategory(0);
  os_log_type_t v17 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v16, v17))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v171;
    _os_log_impl(&dword_1BD672000, v16, v17, "openForwardStore:%s", buf, 0xCu);
  }
  *__error() = v15;
  if (v13) {
    int v18 = 0;
  }
  else {
    int v18 = 2;
  }
  unint64_t v19 = fd_create_protected(a1, v171, v18, 3u);
  unint64_t v20 = v11;
  if (dirStoreInit((uint64_t)v11, v19, 0, v14, a6))
  {
    if ((v14 & 1) == 0)
    {
      char v169 = 0;
      if (storageResolvePtr((uint64_t)(v11 + 1), 0, 1, 1))
      {
        int32_t v21 = OSAtomicIncrement32(exceptionSequenceNum);
        *(_DWORD *)long long buf = 0;
        v173[0] = 0;
        LODWORD(v170) = 0;
        unsigned int v168 = 0;
        uint64_t v22 = v11[28];
        if (v22) {
          int v23 = *(_DWORD *)(v22 + 44);
        }
        else {
          int v23 = -1;
        }
        unint64_t v27 = setThreadIdAndInfo(v23, sStorageExceptionCallbacks, (uint64_t)(v11 + 1), 1, v21);
        v173[0] = HIDWORD(v27);
        *(_DWORD *)long long buf = v27;
        LODWORD(v170) = v28;
        unsigned int v168 = v29;
        uint64_t v30 = *(void *)&threadData[18 * v27 + 2];
        uint64_t v31 = v30 + 320 * HIDWORD(v27);
        int v32 = *(_DWORD *)(v31 + 312);
        uint64x2_t v33 = *(void (**)(void))(v31 + 224);
        if (v33) {
          v33(*(void *)(v30 + 320 * HIDWORD(v27) + 288));
        }
        unsigned int v167 = *(_DWORD *)buf;
        unsigned int v166 = v173[0];
        unsigned int v165 = v170;
        unsigned int v164 = v168;
        if (_setjmp((int *)v31))
        {
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)int v163 = 0;
            _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v163, 2u);
          }
          *(_DWORD *)(v31 + 312) = v32;
          CIOnThreadCleanUpReset(v164);
          dropThreadId(v167, 1, v21);
          CICleanUpReset(v167, v165);
          unint64_t v20 = v11;
        }
        else
        {
          for (int i = 0; i != 24; ++i)
            freeListVerify((uint64_t)(v11 + 1), i);
          char v169 = 1;
          uint64_t v35 = *(void *)&threadData[18 * v167 + 2];
          unsigned int v36 = v166;
          uint64_t v37 = v35 + 320 * v166;
          *(_DWORD *)(v37 + 312) = v32;
          __int8 v38 = *(void (**)(void))(v37 + 232);
          unint64_t v20 = v11;
          if (v38) {
            v38(*(void *)(v35 + 320 * v36 + 288));
          }
          dropThreadId(v167, 0, v21);
        }
      }
      if (!v169)
      {
        int v24 = *__error();
        __int8 v25 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = "openForwardStore";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&uint8_t buf[14] = 2511;
          goto LABEL_43;
        }
        goto LABEL_14;
      }
    }
    v20[553] = 2;
    if (a3)
    {
      uint64_t v39 = v20[554];
      uint64_t v40 = v39;
      uint64_t v41 = (uint64_t)(v11 + 1);
      for (uint64_t j = 2; j != 26; ++j)
      {
        if (!freeListVerify(v41, (int)j - 2)) {
          v20[j] = 0;
        }
      }
      if (*((_DWORD *)v20 + 1102) && v39 > 0)
      {
        if ((v39 & 0x3FFFFFFFFFFFFFFFuLL) >= v20[30]) {
          goto LABEL_164;
        }
        int16x8_t v43 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x300uLL, 0x6085D6BuLL);
        if (!v43) {
          _log_fault_for_malloc_failure();
        }
        memset(buf, 0, 24);
        pqinit_offset_ptr((uint64_t)buf);
        uint64_t v44 = v39 & 0x3F;
        uint64_t v45 = *(void *)&buf[16];
        if (*(void *)&buf[16] + 2 >= *(uint64_t *)&buf[8])
        {
          uint64_t v47 = 4;
          if (*(uint64_t *)&buf[8] >= 4) {
            uint64_t v47 = 2 * *(void *)&buf[8];
          }
          *(void *)&uint8_t buf[8] = v47;
          size_t v48 = 16 * v47 + 32;
          if (*(void *)buf) {
            uint64_t v49 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, *(void **)buf, v48, 0xECA6AA46uLL);
          }
          else {
            uint64_t v49 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v48, 0x8DDAA030uLL);
          }
          unint64_t v50 = v49;
          if (!v49) {
            _log_fault_for_malloc_failure();
          }
          *(void *)long long buf = v50;
          *unint64_t v50 = 0;
          v50[1] = 0;
          unsigned int v46 = v50;
        }
        else
        {
          unsigned int v46 = *(void **)buf;
        }
        *(void *)&uint8_t buf[16] = v45 + 1;
        unsigned int v51 = &v46[2 * v45];
        uint64_t *v51 = v40;
        v51[1] = 0;
        if (v45 >= 2)
        {
          unint64_t v52 = v45;
          do
          {
            unint64_t v53 = v52;
            unsigned int v54 = &v46[2 * v52];
            unsigned int v55 = &v46[2 * (v53 >> 1)];
            if ((*v54 & 0x3FFFFFFFFFFFFFFFuLL) > (*v55 & 0x3FFFFFFFFFFFFFFFuLL)) {
              break;
            }
            *(_OWORD *)uint64_t v173 = *(_OWORD *)v54;
            *(_OWORD *)unsigned int v54 = *(_OWORD *)v55;
            *(_OWORD *)unsigned int v55 = *(_OWORD *)v173;
            unint64_t v52 = v53 >> 1;
          }
          while (v53 > 3);
        }
        if (v44)
        {
          free(*(void **)buf);
          free(v43);
          goto LABEL_164;
        }
        uint64_t v161 = v41;
        uint64_t v56 = *(void *)&buf[16];
        uint64_t v57 = 32;
        uint64_t v58 = 0;
        uint64_t v59 = v43;
        while (1)
        {
          uint64_t v60 = v59;
          uint64_t v61 = v57;
          uint64_t v62 = v56 - 1;
          if (v56 == 1)
          {
            unint64_t v63 = 0;
            uint64_t v56 = 1;
            goto LABEL_75;
          }
          uint64_t v64 = *(void *)buf;
          unint64_t v63 = *(void *)(*(void *)buf + 16);
          long long v65 = *(_OWORD *)(*(void *)buf + 16 * v62);
          uint64_t v66 = *(uint64_t *)&buf[8] >> 1;
          uint64_t v67 = *(void *)(*(void *)buf + 16 * v62);
          *(_OWORD *)(*(void *)buf + 16) = v65;
          *(void *)&uint8_t buf[16] = v56 - 1;
          unint64_t v68 = v67 & 0x3FFFFFFFFFFFFFFFLL;
          uint64_t v69 = 3;
          uint64_t v70 = 2;
          uint64_t v71 = 1;
          while (1)
          {
            uint64_t v72 = v69;
            int8x16_t v73 = *(int8x16_t *)(v64 + 16 * v70);
            if (v69 >= v56)
            {
              int8x16_t v74 = (int8x16_t)xmmword_1BDA82320;
              if (v70 >= v56) {
                goto LABEL_74;
              }
            }
            else
            {
              int8x16_t v74 = *(int8x16_t *)(v64 + 16 * v69);
            }
            unint64_t v75 = v73.i64[0] & 0x3FFFFFFFFFFFFFFFLL;
            unint64_t v76 = v74.i64[0] & 0x3FFFFFFFFFFFFFFFLL;
            if ((v73.i64[0] & 0x3FFFFFFFFFFFFFFFuLL) < v68)
            {
              int32x2_t v77 = vdup_n_s32(v76 < v75);
              v78.i64[0] = v77.u32[0];
              v78.i64[1] = v77.u32[1];
              int8x16_t v79 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v78, 0x3FuLL)), v74, v73);
              if (v76 >= v75) {
                uint64_t v72 = v70;
              }
              goto LABEL_67;
            }
            int8x16_t v79 = v74;
            if (v76 >= v68) {
              break;
            }
LABEL_67:
            _X15 = v64 + 32 * v72;
            __asm { PRFM            #1, [X15] }
            if (v72 != v71)
            {
              uint64_t v70 = 2 * v72;
              uint64_t v69 = (2 * v72) | 1;
              *(_OWORD *)(v64 + 16 * v72) = v65;
              *(int8x16_t *)(v64 + 16 * v71) = v79;
              uint64_t v71 = v72;
              if (v72 < v66) {
                continue;
              }
            }
            goto LABEL_74;
          }
          _X8 = v64 + 32 * v71;
          __asm { PRFM            #1, [X8] }
LABEL_74:
          --v56;
LABEL_75:
          uint64_t v88 = (v63 & 0x3F) == 0;
          LOBYTE(v170) = 0;
          unint64_t v159 = v63;
          PageInner = _directoryStoreGetPageInner(v161, v63, (BOOL *)&v170);
          long long v91 = PageInner;
          if ((_BYTE)v170)
          {
            directoryStorePageGetSize(PageInner, v90);
            unint64_t v93 = v92;
            uint64_t v94 = *(void **)buf;
            if (v93)
            {
              uint64_t v95 = v60;
              uint64_t v96 = v61;
              uint64_t v97 = v58;
              uint64_t v98 = 0;
              uint64_t v99 = v88;
              LODWORD(v100) = 0;
              uint64_t v101 = v56;
              uint64_t v102 = *(void *)&buf[8];
              int v103 = *(void **)buf;
              unint64_t v158 = v93;
              while (1)
              {
                uint64_t v88 = v102;
                int v104 = v100;
                uint64_t v60 = v95;
                if (*(uint64_t *)&v91[8 * v98 + 4] < 2 || !*((_DWORD *)v20 + 1102)) {
                  goto LABEL_112;
                }
                uint64_t v105 = v98;
                uint64_t v106 = *(void *)&v91[8 * v98 + 8];
                if (v106 < 0) {
                  break;
                }
                if (v106)
                {
                  uint64_t v107 = *(void *)&v91[8 * v98 + 8];
                  unsigned int v108 = v99 & ((v106 & 0x3FFFFFFFFFFFFFFFuLL) < v20[30]);
                  if ((v106 & 0x3F) != 0) {
                    uint64_t v109 = 0;
                  }
                  else {
                    uint64_t v109 = v108;
                  }
                  if (v101 + 2 >= v102)
                  {
                    if (v102 >= 4) {
                      uint64_t v88 = 2 * v102;
                    }
                    else {
                      uint64_t v88 = 4;
                    }
                    if (v103) {
                      int v110 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v103, 16 * v88 + 32, 0xECA6AA46uLL);
                    }
                    else {
                      int v110 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v88 + 32, 0x8DDAA030uLL);
                    }
                    int v103 = v110;
                    unint64_t v93 = v158;
                    if (!v110)
                    {
                      _log_fault_for_malloc_failure();
                      unint64_t v93 = v158;
                    }
                    void *v103 = 0;
                    v103[1] = 0;
                  }
                  uint64_t v117 = v101 + 1;
                  uint64_t v118 = &v103[2 * v101];
                  *uint64_t v118 = v107;
                  v118[1] = 0;
                  if (v101 >= 2)
                  {
                    do
                    {
                      unint64_t v119 = v101;
                      unsigned int v120 = &v103[2 * v101];
                      uint64_t v101 = (unint64_t)v101 >> 1;
                      uint64_t v121 = &v103[2 * v101];
                      if ((*v120 & 0x3FFFFFFFFFFFFFFFuLL) > (*v121 & 0x3FFFFFFFFFFFFFFFuLL)) {
                        break;
                      }
                      *(_OWORD *)uint64_t v173 = *(_OWORD *)v120;
                      *(_OWORD *)unsigned int v120 = *(_OWORD *)v121;
                      *(_OWORD *)uint64_t v121 = *(_OWORD *)v173;
                    }
                    while (v119 > 3);
                  }
                  uint64_t v101 = v117;
                  uint64_t v99 = v109;
LABEL_111:
                  unint64_t v20 = *(void **)v162;
                }
LABEL_112:
                uint64_t v102 = v88;
                uint64_t v95 = v60;
                unint64_t v100 = (v104 + 1);
                uint64_t v57 = v96;
                uint64_t v123 = v97;
                uint64_t v98 = v100;
                LOBYTE(v88) = v99;
                uint64_t v56 = v101;
                uint64_t v124 = v102;
                BOOL v125 = v103;
                if (v93 <= v100) {
                  goto LABEL_141;
                }
              }
              uint64_t v111 = v106 & 0x7FFFFFFFFFFFFFFFLL;
              unint64_t v112 = v60;
              uint64_t v113 = v97;
              if (v97 >= 1)
              {
                do
                {
                  uint64_t v114 = *v112;
                  v112 += 3;
                  uint64_t v99 = v99 & (v114 != v111);
                  --v113;
                }
                while (v113);
              }
              uint64_t v115 = v99;
              if (v97 >= v96)
              {
                unsigned int v156 = v99;
                if (v96) {
                  v96 *= 2;
                }
                else {
                  uint64_t v96 = 4;
                }
                unint64_t v116 = v60
                     ? malloc_type_zone_realloc((malloc_zone_t *)queryZone, v60, 24 * v96, 0xECA6AA46uLL)
                     : malloc_type_zone_malloc((malloc_zone_t *)queryZone, 24 * v96, 0x8DDAA030uLL);
                uint64_t v60 = v116;
                unint64_t v93 = v158;
                uint64_t v115 = v156;
                if (!v116)
                {
                  _log_fault_for_malloc_failure();
                  uint64_t v115 = v156;
                  unint64_t v93 = v158;
                }
              }
              uint64_t v122 = &v60[3 * v97];
              *uint64_t v122 = v111;
              v122[1] = v159;
              v122[2] = v105;
              ++v97;
              uint64_t v99 = v115;
              goto LABEL_111;
            }
            uint64_t v57 = v61;
            uint64_t v123 = v58;
            uint64_t v124 = *(void *)&buf[8];
          }
          else
          {
            unsigned int v157 = v60;
            unint64_t Size = directoryTreePageGetSize(*PageInner, *((unsigned char *)PageInner + 2), v90);
            uint64_t v94 = *(void **)buf;
            uint64_t v124 = *(void *)&buf[8];
            if (Size)
            {
              uint64_t v127 = 0;
              uint64_t v128 = v88;
              unsigned int v129 = 0;
              uint64_t v130 = v56;
              uint64_t v131 = *(void *)&buf[8];
              long long v132 = *(void **)buf;
              do
              {
                uint64_t v56 = v130;
                uint64_t v133 = *(void *)&v91[4 * v127 + 4];
                if (v133)
                {
                  if ((v133 & 0x3F) != 0) {
                    uint64_t v134 = 0;
                  }
                  else {
                    uint64_t v134 = v128 & ((v133 & 0x3FFFFFFFFFFFFFFFuLL) < v20[30]);
                  }
                  if (v130 + 2 >= v131)
                  {
                    if (v131 >= 4) {
                      uint64_t v138 = 2 * v131;
                    }
                    else {
                      uint64_t v138 = 4;
                    }
                    if (v132) {
                      size_t v139 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v132, 16 * v138 + 32, 0xECA6AA46uLL);
                    }
                    else {
                      size_t v139 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v138 + 32, 0x8DDAA030uLL);
                    }
                    long long v135 = v139;
                    if (!v139) {
                      _log_fault_for_malloc_failure();
                    }
                    void *v135 = 0;
                    v135[1] = 0;
                    uint64_t v136 = v138;
                    unint64_t v20 = *(void **)v162;
                  }
                  else
                  {
                    long long v135 = v132;
                    uint64_t v136 = v131;
                  }
                  uint64_t v140 = v56 + 1;
                  unint64_t v141 = &v135[2 * v56];
                  void *v141 = v133;
                  v141[1] = 0;
                  if (v56 >= 2)
                  {
                    do
                    {
                      int v142 = &v135[2 * v56];
                      int v143 = &v135[2 * ((unint64_t)v56 >> 1)];
                      if ((*v142 & 0x3FFFFFFFFFFFFFFFuLL) > (*v143 & 0x3FFFFFFFFFFFFFFFuLL)) {
                        break;
                      }
                      unint64_t v144 = v56;
                      *(_OWORD *)uint64_t v173 = *(_OWORD *)v142;
                      *(_OWORD *)int v142 = *(_OWORD *)v143;
                      *(_OWORD *)int v143 = *(_OWORD *)v173;
                      uint64_t v56 = (unint64_t)v56 >> 1;
                    }
                    while (v144 > 3);
                  }
                  BOOL v125 = v135;
                  uint64_t v124 = v136;
                  uint64_t v56 = v140;
                  uint64_t v137 = v134;
                }
                else
                {
                  BOOL v125 = v132;
                  uint64_t v124 = v131;
                  uint64_t v137 = v128;
                }
                uint64_t v128 = v137;
                uint64_t v127 = ++v129;
                uint64_t v130 = v56;
                uint64_t v131 = v124;
                long long v132 = v125;
              }
              while (Size > v129);
              uint64_t v57 = v61;
              uint64_t v123 = v58;
              uint64_t v60 = v157;
              LOBYTE(v88) = v137;
              goto LABEL_141;
            }
            uint64_t v57 = v61;
            uint64_t v123 = v58;
          }
          BOOL v125 = v94;
LABEL_141:
          unint64_t v145 = v125;
          *(void *)&uint8_t buf[8] = v124;
          *(void *)&uint8_t buf[16] = v56;
          *(void *)long long buf = v125;
          char v146 = v88 & 1;
          if (v56 != 1)
          {
            uint64_t v58 = v123;
            uint64_t v59 = v60;
            if (v88) {
              continue;
            }
          }
          free(v145);
          if (v123 >= 2)
          {
            if (qos_class_self() >= 0x12 && v123 > 2047)
            {
              off_t v147 = OSAtomicDequeue(&qsort_cached_allocations_3690, 0);
              if (!v147) {
                off_t v147 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
              }
              uint64_t v148 = dispatch_group_create();
              v147[3] = v148;
              v147[4] = 0;
              v147[1] = 0;
              v147[2] = v123 - 1;
              *off_t v147 = v60;
              int v149 = thread_count_3691;
              if (!thread_count_3691)
              {
                *(void *)uint64_t v173 = 0x1900000006;
                size_t v170 = 4;
                sysctl(v173, 2u, &thread_count_3691, &v170, 0, 0);
                int v149 = thread_count_3691;
              }
              *((_DWORD *)v147 + 14) = v149;
              v147[5] = (uint64_t)sqrt((double)v123) / 2;
              if (!v149)
              {
                *(void *)uint64_t v173 = 0x1900000006;
                size_t v170 = 4;
                sysctl(v173, 2u, &thread_count_3691, &v170, 0, 0);
                int v149 = thread_count_3691;
              }
              uint64_t v150 = v123 / (2 * v149);
              if (v150 <= 0x8000)
              {
                uint64_t v150 = 0x8000;
              }
              else if (!v149)
              {
                *(void *)uint64_t v173 = 0x1900000006;
                size_t v170 = 4;
                sysctl(v173, 2u, &thread_count_3691, &v170, 0, 0);
                uint64_t v150 = v123 / (2 * thread_count_3691);
              }
              v147[6] = v150;
              if ((uint64_t)v147[5] <= 2047) {
                v147[5] = 2048;
              }
              _qsort_big_offset_triple(v147);
              dispatch_group_wait(v148, 0xFFFFFFFFFFFFFFFFLL);
              dispatch_release(v148);
            }
            else
            {
              _qsort_offset_triple((uint64_t)v60, 0, v123 - 1);
            }
            unint64_t v151 = v60 + 3;
            uint64_t v152 = *v60;
            uint64_t v153 = v123 - 1;
            char v154 = v146;
            do
            {
              uint64_t v155 = *v151;
              v151 += 3;
              v154 &= v155 != v152;
              uint64_t v152 = v155;
              char v146 = v154;
              --v153;
            }
            while (v153);
          }
          free(v60);
          if (v146) {
            return v20;
          }
LABEL_164:
          int v24 = *__error();
          __int8 v25 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = "openForwardStore";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&uint8_t buf[14] = 2526;
LABEL_43:
            _os_log_error_impl(&dword_1BD672000, v25, OS_LOG_TYPE_ERROR, "%s:%d: Failed to open dir store", buf, 0x12u);
          }
          goto LABEL_14;
        }
      }
    }
    return v20;
  }
  else
  {
    int v24 = *__error();
    __int8 v25 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "openForwardStore";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&uint8_t buf[14] = 2483;
      goto LABEL_43;
    }
LABEL_14:
    *__error() = v24;
    freeForwardDirectoryStore(v20);
    return 0;
  }
}

void shadowForwardStore(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)a1) {
    BOOL v3 = 0;
  }
  else {
    BOOL v3 = a2 == 0;
  }
  if (v3) {
    return;
  }
  char v5 = a2;
  memset(v91, 0, 255);
  memset(v90, 0, 255);
  int v7 = fd_name(*(void *)(a1 + 224), (char *)v91, 0xFFuLL);
  if (!v7)
  {
    int v11 = *__error();
    uint64_t v12 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v66 = 136315394;
      *(void *)&v66[4] = "shadowForwardStore";
      *(_WORD *)&v66[12] = 1024;
      *(_DWORD *)&v66[14] = 2572;
      _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: no path for shadow", v66, 0x12u);
    }
    *__error() = v11;
    return;
  }
  os_log_type_t v8 = v7;
  __strlcpy_chk();
  strlcat(v8, ".shadow", 0xFFuLL);
  uint64_t v9 = *(void *)(a1 + 224);
  if (v9) {
    uint64_t v10 = *(unsigned int *)(v9 + 44);
  }
  else {
    uint64_t v10 = 0xFFFFFFFFLL;
  }
  if (isRegisteredForCloning(v10) && (copyFileFallback(v10, (const char *)v90, v10, v8, a3, 0, 1) & 1) != 0)
  {
    bit_vector_set_bits_3829((CFIndex *)(a1 + 4384), 0, *(void *)(a1 + 4384));
    return;
  }
  int v13 = *(_DWORD *)(a1 + 240);
  directoryStoreValidate(a1 + 8, a1 + 4424);
  long long v88 = 0u;
  long long v89 = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v67 = 0u;
  memset(v66, 0, sizeof(v66));
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  sibling_protected = (atomic_uint *)fd_create_sibling_protected(*(void *)(a1 + 224), v8, 514, 0);
  fd_no_cache((uint64_t)sibling_protected);
  if (!sibling_protected)
  {
    int v20 = *__error();
    int v21 = *__error();
    uint64_t v22 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315906;
      uint64_t v59 = "shadowForwardStore";
      __int16 v60 = 1024;
      int v61 = 2607;
      __int16 v62 = 1024;
      int v63 = v20;
      __int16 v64 = 2080;
      long long v65 = v8;
      _os_log_error_impl(&dword_1BD672000, v22, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", buf, 0x22u);
    }
    os_log_type_t v17 = 0;
    goto LABEL_68;
  }
  uint64_t v15 = (v13 + 0x1FFFF) >> 17;
  if ((v5 & 1) == 0 && v15 >= *(void *)(a1 + 4384)) {
    uint64_t v15 = *(void *)(a1 + 4384);
  }
  BOOL v16 = malloc_type_malloc(0x20000uLL, 0x50C9AEC5uLL);
  if (!v16)
  {
    uint64_t v45 = __si_assert_copy_extra(0);
    unsigned int v46 = v45;
    uint64_t v47 = "";
    if (v45) {
      uint64_t v47 = v45;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2617, "readBuffer", v47);
    free(v46);
    if (__valid_fs(-1)) {
      uint64_t v48 = 2989;
    }
    else {
      uint64_t v48 = 3072;
    }
    *(_DWORD *)uint64_t v48 = -559038737;
    abort();
  }
  os_log_type_t v17 = v16;
  size_t v18 = *(void *)(a1 + 240);
  unint64_t v19 = *(_DWORD **)(a1 + 224);
  if (v18 >> 17)
  {
    int v23 = _fd_acquire_fd((uint64_t)v19, &v56);
    if (v23 != -1)
    {
      LODWORD(v24) = v23;
      int v25 = _fd_acquire_fd((uint64_t)sibling_protected, &v57);
      if (v25 == -1)
      {
        int v39 = *__error();
        int v21 = *__error();
        uint64_t v40 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136315650;
          uint64_t v59 = "shadowForwardStore";
          __int16 v60 = 1024;
          int v61 = 2640;
          __int16 v62 = 1024;
          int v63 = v39;
          _os_log_error_impl(&dword_1BD672000, v40, OS_LOG_TYPE_ERROR, "%s:%d: fd_open err: %d", buf, 0x18u);
        }
        int v26 = -1;
      }
      else
      {
        int v26 = v25;
        if (v15 < 1)
        {
LABEL_59:
          _fd_release_fd(*(_DWORD **)(a1 + 224), v24, 0, v56);
          _fd_release_fd(sibling_protected, v26, 0, v57);
          goto LABEL_60;
        }
        unsigned int v54 = v25;
        unsigned int __fd = v24;
        CFIndex v27 = 0;
        unsigned int v28 = 0;
        unint64_t v53 = (CFIndex *)(a1 + 4384);
        while (v28 != 100)
        {
LABEL_43:
          if ((v5 & 1) != 0 || *v53 > v27 && CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a1 + 4400), v27)) {
            *(_DWORD *)&v66[4 * v28++] = v27;
          }
          if (++v27 == v15)
          {
            int v26 = v54;
            uint64_t v24 = v24;
            if (v28)
            {
              uint64_t v31 = v28;
              int v32 = v66;
              while (1)
              {
                if (*a3 == 1 || *a3 == -1 && (v5 & 1) != 0) {
                  goto LABEL_70;
                }
                CFIndex v33 = *(unsigned int *)v32;
                if (prot_pread(v24, v17, 0x20000uLL, v33 << 17) == -1) {
                  break;
                }
                if (*a3 == 1 || *a3 == -1 && (v5 & 1) != 0) {
                  goto LABEL_75;
                }
                if (prot_pwrite_guarded(v54, (uint64_t)&v57, (uint64_t)v17, 0x20000uLL, v33 << 17) == -1)
                {
                  int v52 = *__error();
                  int v21 = *__error();
                  unint64_t v50 = _SILogForLogForCategory(0);
                  if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_89;
                  }
                  *(_DWORD *)long long buf = 136315650;
                  uint64_t v59 = "shadowForwardStore";
                  __int16 v60 = 1024;
                  int v61 = 2699;
                  __int16 v62 = 1024;
                  int v63 = v52;
                  unsigned int v51 = "%s:%d: pwrite err: %d";
                  goto LABEL_93;
                }
                bit_vector_internal_touch_for_set_3822(v53, v33);
                CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4400), v33, 0);
                v32 += 4;
                --v31;
                int v26 = v54;
                uint64_t v24 = __fd;
                if (!v31) {
                  goto LABEL_59;
                }
              }
              int v49 = *__error();
              int v21 = *__error();
              unint64_t v50 = _SILogForLogForCategory(0);
              if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
              {
LABEL_89:
                LODWORD(v24) = __fd;
                goto LABEL_81;
              }
              *(_DWORD *)long long buf = 136315650;
              uint64_t v59 = "shadowForwardStore";
              __int16 v60 = 1024;
              int v61 = 2690;
              __int16 v62 = 1024;
              int v63 = v49;
              unsigned int v51 = "%s:%d: pread err: %d";
LABEL_93:
              _os_log_error_impl(&dword_1BD672000, v50, OS_LOG_TYPE_ERROR, v51, buf, 0x18u);
              goto LABEL_89;
            }
            goto LABEL_59;
          }
        }
        uint64_t v29 = 0;
        while (1)
        {
          if (*a3 == 1 || *a3 == -1 && (v5 & 1) != 0)
          {
LABEL_75:
            int v26 = v54;
            LODWORD(v24) = __fd;
            goto LABEL_70;
          }
          CFIndex v30 = *(unsigned int *)&v66[v29];
          if (prot_pread(v24, v17, 0x20000uLL, v30 << 17) == -1)
          {
            int v41 = *__error();
            int v21 = *__error();
            uint64x2_t v42 = _SILogForLogForCategory(0);
            int v26 = v54;
            if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 136315650;
              uint64_t v59 = "shadowForwardStore";
              __int16 v60 = 1024;
              int v61 = 2653;
              __int16 v62 = 1024;
              int v63 = v41;
              _os_log_error_impl(&dword_1BD672000, v42, OS_LOG_TYPE_ERROR, "%s:%d: read err: %d", buf, 0x18u);
            }
            goto LABEL_69;
          }
          if (*a3 == 1 || *a3 == -1 && (v5 & 1) != 0) {
            goto LABEL_75;
          }
          if (prot_pwrite_guarded(v54, (uint64_t)&v57, (uint64_t)v17, 0x20000uLL, v30 << 17) == -1) {
            break;
          }
          bit_vector_internal_touch_for_set_3822(v53, v30);
          CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4400), v30, 0);
          v29 += 4;
          if (v29 == 400)
          {
            unsigned int v28 = 0;
            goto LABEL_43;
          }
        }
        int v43 = *__error();
        int v21 = *__error();
        uint64_t v44 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136315650;
          uint64_t v59 = "shadowForwardStore";
          __int16 v60 = 1024;
          int v61 = 2662;
          __int16 v62 = 1024;
          int v63 = v43;
          _os_log_error_impl(&dword_1BD672000, v44, OS_LOG_TYPE_ERROR, "%s:%d: pwrite err: %d", buf, 0x18u);
        }
LABEL_81:
        int v26 = v54;
      }
      goto LABEL_69;
    }
    int v37 = *__error();
    int v21 = *__error();
    uint64_t v35 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      uint64_t v59 = "shadowForwardStore";
      __int16 v60 = 1024;
      int v61 = 2634;
      __int16 v62 = 1024;
      int v63 = v37;
      unsigned int v36 = "%s:%d: fd_open err: %d";
      goto LABEL_67;
    }
  }
  else
  {
    if (fd_pread(v19, v17, v18, 0) != -1)
    {
      if (fd_pwrite((uint64_t)sibling_protected, (uint64_t)v17, *(void *)(a1 + 240), 0) != -1)
      {
        bit_vector_internal_touch_for_set_3822((CFIndex *)(a1 + 4384), 0);
        CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4400), 0, 0);
LABEL_60:
        fd_release(sibling_protected);
        free(v17);
        return;
      }
      int v38 = *__error();
      int v21 = *__error();
      uint64_t v35 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
        goto LABEL_68;
      }
      *(_DWORD *)long long buf = 136315650;
      uint64_t v59 = "shadowForwardStore";
      __int16 v60 = 1024;
      int v61 = 2626;
      __int16 v62 = 1024;
      int v63 = v38;
      unsigned int v36 = "%s:%d: pwrite err: %d";
      goto LABEL_67;
    }
    int v34 = *__error();
    int v21 = *__error();
    uint64_t v35 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      uint64_t v59 = "shadowForwardStore";
      __int16 v60 = 1024;
      int v61 = 2621;
      __int16 v62 = 1024;
      int v63 = v34;
      unsigned int v36 = "%s:%d: read err: %d";
LABEL_67:
      _os_log_error_impl(&dword_1BD672000, v35, OS_LOG_TYPE_ERROR, v36, buf, 0x18u);
    }
  }
LABEL_68:
  int v26 = -1;
  LODWORD(v24) = -1;
LABEL_69:
  *__error() = v21;
LABEL_70:
  free(v17);
  _fd_release_fd(*(_DWORD **)(a1 + 224), v24, 0, v56);
  _fd_release_fd(sibling_protected, v26, 0, v57);
  fd_release(sibling_protected);
}

void bit_vector_internal_touch_for_set_3822(CFIndex *a1, CFIndex a2)
{
  CFIndex v4 = a1[1];
  if (v4 <= a2)
  {
    if (v4) {
      CFIndex v5 = a1[1];
    }
    else {
      CFIndex v5 = 32;
    }
    while (1)
    {
      v5 *= 2;
      if (v5 > a2) {
        break;
      }
      if (v5 <= v4)
      {
        int v6 = __si_assert_copy_extra(0);
        int v7 = v6;
        os_log_type_t v8 = "";
        if (v6) {
          os_log_type_t v8 = v6;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v8);
        goto LABEL_13;
      }
    }
    CFBitVectorRef v10 = (const __CFBitVector *)a1[2];
    CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (v10) {
      CFMutableStringRef MutableCopy = CFBitVectorCreateMutableCopy(v11, v5, v10);
    }
    else {
      CFMutableStringRef MutableCopy = CFBitVectorCreateMutable(v11, v5);
    }
    int v13 = MutableCopy;
    if (!MutableCopy)
    {
      uint64_t v15 = __si_assert_copy_extra(0);
      int v7 = v15;
      BOOL v16 = "";
      if (v15) {
        BOOL v16 = v15;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v16);
LABEL_13:
      free(v7);
      if (__valid_fs(-1)) {
        uint64_t v9 = 2989;
      }
      else {
        uint64_t v9 = 3072;
      }
      *(_DWORD *)uint64_t v9 = -559038737;
      abort();
    }
    CFBitVectorSetCount(MutableCopy, v5);
    char v14 = (const void *)a1[2];
    if (v14) {
      CFRelease(v14);
    }
    a1[1] = v5;
    a1[2] = (CFIndex)v13;
  }
  if (*a1 <= a2) {
    *a1 = a2 + 1;
  }
}

void bit_vector_set_bits_3829(CFIndex *a1, CFIndex a2, CFIndex a3)
{
  if (a2 < 0)
  {
    os_log_type_t v8 = __si_assert_copy_extra(0);
    uint64_t v9 = v8;
    CFBitVectorRef v10 = "";
    if (v8) {
      CFBitVectorRef v10 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 151, "range.location >= 0", v10);
    free(v9);
    if (__valid_fs(-1)) {
      uint64_t v11 = 2989;
    }
    else {
      uint64_t v11 = 3072;
    }
    *(_DWORD *)uint64_t v11 = -559038737;
    abort();
  }
  if (a3 >= 1)
  {
    bit_vector_internal_touch_for_set_3822(a1, a3 + a2 - 1);
    int v6 = (__CFBitVector *)a1[2];
    v7.locatiouint64_t n = a2;
    v7.uint64_t length = a3;
    CFBitVectorSetBits(v6, v7, 0);
  }
}

uint64_t directoryStoreMakePathWithPostingsOffset(uint64_t a1, int a2, void *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v10 = a1 + 8;
  unsigned __int8 v70 = 0;
  int v11 = setCrashStateTarget(3);
  if (!storageResolvePtr(v10, 0, 1, 1)) {
    goto LABEL_40;
  }
  int32_t v12 = OSAtomicIncrement32(exceptionSequenceNum);
  unint64_t v69 = 0;
  unint64_t v68 = 0;
  uint64_t v13 = *(void *)(a1 + 224);
  if (v13) {
    int v14 = *(_DWORD *)(v13 + 44);
  }
  else {
    int v14 = -1;
  }
  unint64_t v15 = setThreadIdAndInfo(v14, sStorageExceptionCallbacks, v10, 1, v12);
  unint64_t v69 = __PAIR64__(v15, HIDWORD(v15));
  unint64_t v68 = __PAIR64__(v16, v17);
  uint64_t v18 = *(void *)&threadData[18 * v15 + 2];
  uint64_t v19 = v18 + 320 * HIDWORD(v15);
  int v51 = *(_DWORD *)(v19 + 312);
  int v20 = *(void (**)(void))(v19 + 224);
  if (v20) {
    v20(*(void *)(v18 + 320 * HIDWORD(v15) + 288));
  }
  unint64_t v67 = v69;
  unint64_t v66 = v68;
  if (_setjmp((int *)v19))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v19 + 312) = v51;
    CIOnThreadCleanUpReset(v66);
    dropThreadId(HIDWORD(v67), 1, v12);
    CICleanUpReset(HIDWORD(v67), HIDWORD(v66));
    goto LABEL_40;
  }
  *(unsigned char *)a1 = 1;
  if (a4 >= 0x7FFFFFFFFFFFFFFFLL)
  {
    int v39 = __si_assert_copy_extra(0);
    unsigned int v28 = v39;
    uint64_t v40 = "";
    if (v39) {
      uint64_t v40 = v39;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2763, "postings<9223372036854775807", v40);
LABEL_53:
    free(v28);
    if (__valid_fs(-1)) {
      uint64_t v47 = 2989;
    }
    else {
      uint64_t v47 = 3072;
    }
    *(_DWORD *)uint64_t v47 = -559038737;
    abort();
  }
  int v21 = (void *)(a1 + 4424);
  if (*v21 != 2)
  {
    int v41 = __si_assert_copy_extra(0);
    uint64_t v31 = v41;
    uint64x2_t v42 = "";
    if (v41) {
      uint64x2_t v42 = v41;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2765, "getStoreOID(root.directory->fileId)==2", v42);
    goto LABEL_60;
  }
  if (a2)
  {
    int v22 = a2 - 1;
    if (a3[a2 - 1] != 2) {
      int v22 = a2;
    }
    if (v22 < 2)
    {
      BOOL v24 = 0;
      a2 = v22;
    }
    else
    {
      uint64_t v23 = a3[1];
      BOOL v24 = *a3 == v23;
      if (*a3 == v23)
      {
        ++a3;
        a2 = v22 - 1;
      }
      else
      {
        a2 = v22;
      }
    }
  }
  else
  {
    BOOL v24 = 0;
  }
  directoryStoreValidate(v10, (uint64_t)v21);
  uint64_t v65 = 0;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  *(_OWORD *)long long buf = 0u;
  long long v56 = 0uLL;
  uint64_t v57 = 0;
  uint64_t v55 = 0;
  long long v54 = (unint64_t)v21;
  directoryStoreGetDirectoryWithPath((unsigned __int16 *)&v56, v10, (unint64_t *)&v54, a2 - 1, (uint64_t)a3, 1, (uint64_t)buf);
  uint64_t v25 = v56;
  if (!a4)
  {
    if ((void)v56) {
      goto LABEL_35;
    }
    CFIndex v30 = __si_assert_copy_extra(0);
    uint64_t v31 = v30;
    int v32 = "";
    if (v30) {
      int v32 = v30;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2849, "target.directory", v32);
LABEL_60:
    free(v31);
    if (__valid_fs(-1)) {
      uint64_t v50 = 2989;
    }
    else {
      uint64_t v50 = 3072;
    }
    *(_DWORD *)uint64_t v50 = -559038737;
    abort();
  }
  uint64_t v26 = *(void *)(v56 + 8);
  if (v24)
  {
    if (v26)
    {
      uint64_t v65 = 0;
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      *(_OWORD *)long long buf = 0u;
      long long v52 = v56;
      uint64_t v53 = v57;
      directoryStoreGetDirectoryWithPath((unsigned __int16 *)&v54, v10, (unint64_t *)&v52, 0, (uint64_t)a3, 1, (uint64_t)buf);
      long long v56 = v54;
      uint64_t v57 = v55;
      uint64_t v25 = v54;
      if (*(void *)(v54 + 8))
      {
        CFIndex v27 = __si_assert_copy_extra(0);
        unsigned int v28 = v27;
        uint64_t v29 = "";
        if (v27) {
          uint64_t v29 = v27;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2842, "!target.directory->childPage.offset", v29);
        goto LABEL_53;
      }
    }
    goto LABEL_34;
  }
  if (v26)
  {
    uint64_t v48 = __si_assert_copy_extra(0);
    uint64_t v31 = v48;
    int v49 = "";
    if (v48) {
      int v49 = v48;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2844, "!target.directory->childPage.offset", v49);
    goto LABEL_60;
  }
LABEL_34:
  *(void *)(v25 + 8) = a4 | 0x8000000000000000;
LABEL_35:
  directoryStoreValidate(v10, (uint64_t)v21);
  if (*v21 != 2)
  {
    int v43 = __si_assert_copy_extra(0);
    uint64_t v31 = v43;
    uint64_t v44 = "";
    if (v43) {
      uint64_t v44 = v43;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2851, "getStoreOID(root.directory->fileId)==2", v44);
    goto LABEL_60;
  }
  memcpy((void *)a5, a3, 8 * a2);
  *(void *)(a5 + 4096) = a2;
  uint64_t v33 = *(void *)buf;
  *(void *)(a5 + 4104) = *((void *)&v64 + 1);
  *(void *)(a5 + 4112) = v33;
  if (v33 < 0)
  {
    uint64_t v45 = __si_assert_copy_extra(0);
    unsigned int v28 = v45;
    unsigned int v46 = "";
    if (v45) {
      unsigned int v46 = v45;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2857, "!((refPage.pageOffset[0] & (1ull << 63)) || refPage.pageOffset[0]==0)", v46);
    goto LABEL_53;
  }
  *(_DWORD *)(a5 + 4120) = v64;
  unsigned __int8 v70 = 1;
  uint64_t v34 = *(void *)&threadData[18 * HIDWORD(v67) + 2];
  unsigned int v35 = v67;
  uint64_t v36 = v34 + 320 * v67;
  *(_DWORD *)(v36 + 312) = v51;
  int v37 = *(void (**)(void))(v36 + 232);
  if (v37) {
    v37(*(void *)(v34 + 320 * v35 + 288));
  }
  dropThreadId(HIDWORD(v67), 0, v12);
LABEL_40:
  setCrashStateTarget(v11);
  return v70;
}

void dumpDirectoryStore(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  CFIndex v5 = v4;
  int v7 = v6;
  os_log_type_t v8 = (void *)v1;
  v106[1] = *MEMORY[0x1E4F143B8];
  bzero(v104, 0x1000uLL);
  int v103 = 0;
  bzero(&v101, 0x6038uLL);
  uint64_t v98 = 0;
  __new = 0;
  uint64_t v100 = 0;
  storage_reader_init((uint64_t)(v8 + 1), (uint64_t)&v98);
  char v97 = 0;
  int v9 = setCrashStateTarget(3);
  if ((_BYTE)v100)
  {
    int32_t v10 = OSAtomicIncrement32(exceptionSequenceNum);
    unint64_t v11 = setThreadIdAndInfo(-1, sStorageReaderExceptionCallbacks, (uint64_t)&v98, 0, v10);
    unsigned int v95 = HIDWORD(v11);
    *(_DWORD *)long long buf = v11;
    unsigned int v93 = v13;
    unsigned int v94 = v12;
    uint64_t v14 = *(void *)&threadData[18 * v11 + 2];
    uint64_t v15 = v14 + 320 * HIDWORD(v11);
    int v16 = *(_DWORD *)(v15 + 312);
    unsigned int v17 = *(void (**)(void))(v15 + 224);
    if (v17) {
      v17(*(void *)(v14 + 320 * HIDWORD(v11) + 288));
    }
    unsigned int v92 = *(_DWORD *)buf;
    unsigned int v91 = v95;
    unint64_t v90 = __PAIR64__(v94, v93);
    if (_setjmp((int *)v15))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long v89 = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v89, 2u);
      }
      *(_DWORD *)(v15 + 312) = v16;
      CIOnThreadCleanUpReset(v90);
      dropThreadId(v92, 1, v10);
      CICleanUpReset(v92, HIDWORD(v90));
      goto LABEL_84;
    }
    uint64_t v18 = (uint64_t)CICleanUpThreadLoc();
    unsigned int v86 = threadData[18 * v18 + 8];
    uint64_t v87 = v18;
    CICleanUpPush(v18, (uint64_t)cleanup, (uint64_t)&v101);
    v106[0] = 2;
    unint64_t v19 = v8[554];
    unint64_t v20 = v8[555];
    unint64_t v21 = v8[556];
    BOOL v22 = v21 - v20 < 0x100000001 && v21 > v20;
    unint64_t v23 = v21 & 0xFFFFFFFF00000000;
    if (v22) {
      unint64_t v24 = v23;
    }
    else {
      unint64_t v24 = 0;
    }
    int v88 = v16;
    unint64_t v85 = v20;
    if ((v19 & 0x8000000000000000) == 0)
    {
      if (v19)
      {
        int v25 = v103 + 1;
        if ((v19 & 0x4000000000000000) == 0)
        {
          int v26 = v101;
          CFIndex v27 = &v102[48 * v101];
          *(_DWORD *)CFIndex v27 = v25;
          *(void *)(v27 + 12) = 0x200000000;
          *(void *)(v27 + 4) = 0;
          *(void *)(v27 + 20) = 0;
          *(void *)(v27 + 28) = 0;
          *(void *)(v27 + 36) = 0;
          *((_DWORD *)v27 + 11) = 0;
          *((void *)v27 + 3) = v19;
          int v28 = v26 + 1;
          int v101 = v26 + 1;
          if (v26 == -1)
          {
LABEL_81:
            CICleanUpReset(v87, v86);
            uint64_t v74 = *(void *)&threadData[18 * v92 + 2];
            unsigned int v75 = v91;
            uint64_t v76 = v74 + 320 * v91;
            *(_DWORD *)(v76 + 312) = v88;
            long long v77 = *(void (**)(void))(v76 + 232);
            if (v77) {
              v77(*(void *)(v74 + 320 * v75 + 288));
            }
            dropThreadId(v92, 0, v10);
            goto LABEL_84;
          }
          while (1)
          {
LABEL_29:
            if (v97 || *v5) {
              goto LABEL_81;
            }
            int v31 = v28 - 1;
            int v32 = *(_DWORD *)&v102[48 * (v28 - 1) + 16];
            if (v32 != 2) {
              break;
            }
            if (!*v5)
            {
              v89[0] = 0;
              unsigned int v46 = &v102[48 * v31];
              Page = _directoryStoreReaderGetPage(&v98, *((void *)v46 + 3), (BOOL *)v89);
              if (Page)
              {
                if (v89[0])
                {
                  long long v80 = __si_assert_copy_extra(0);
                  __message_assert("%s:%u: failed assertion '%s' %s ");
                  goto LABEL_93;
                }
                int v49 = Page;
                unint64_t Size = directoryTreePageGetSize(*Page, *((unsigned char *)Page + 2), v48);
                int v51 = &v102[48 * v31];
                unint64_t v54 = *((void *)v51 + 1);
                long long v52 = v51 + 8;
                unint64_t v53 = v54;
                if (v54 >= Size)
                {
LABEL_45:
                  int v58 = v101 - 1;
LABEL_46:
                  int v101 = v58;
                }
                else
                {
                  unint64_t v55 = v53;
                  *long long v52 = v53 + 1;
                  int v56 = *(_DWORD *)v46;
                  while (!*v5)
                  {
                    int64_t v57 = *(void *)&v49[4 * v55 + 4];
                    if (v57 >= 1)
                    {
                      if ((v57 & 0x4000000000000000) == 0)
                      {
                        int v68 = v101;
                        unint64_t v69 = &v102[48 * v101];
                        *(_DWORD *)unint64_t v69 = v56;
                        *(void *)(v69 + 4) = 0;
                        *(void *)(v69 + 20) = 0;
                        *(void *)(v69 + 28) = 0;
                        *(void *)(v69 + 36) = 0;
                        *(void *)(v69 + 12) = 0x200000000;
                        *((_DWORD *)v69 + 11) = 0;
                        *((void *)v69 + 3) = v57;
                        int v58 = v68 + 1;
                        goto LABEL_46;
                      }
                      dumpDirectoryStorePage(&v98, v5, v57, v56, &v101, (uint64_t)v102);
                      break;
                    }
                    *long long v52 = v55 + 2;
                    if (Size == ++v55) {
                      goto LABEL_45;
                    }
                  }
                }
              }
            }
LABEL_65:
            int v28 = v101;
            if (!v101) {
              goto LABEL_81;
            }
          }
          if (v32 != 1)
          {
            long long v82 = __si_assert_copy_extra(0);
            long long v83 = v82;
            if (v82) {
              long long v84 = v82;
            }
            else {
              long long v84 = "";
            }
            __message_assert("%s:%u: Unexpected code path %s ", "FileTree.c", 3171, v84);
            free(v83);
            goto LABEL_89;
          }
          uint64_t v33 = (unsigned int *)&v102[48 * v31];
          uint64_t v34 = *v33;
          unsigned int v35 = v33;
          int v37 = v33 + 2;
          uint64_t v36 = *((void *)v33 + 1);
          uint64_t v38 = *((void *)v33 + 5);
          unsigned int v39 = *v33;
          unsigned int v40 = *v33;
          int v43 = *((unsigned __int8 *)v35 + 24);
          int v41 = v35 + 6;
          int v42 = v43;
          if (v36 == v38)
          {
            if (v42 || (v7 & 1) != 0)
            {
              free(*((void **)v41 + 1));
              --v101;
              char v64 = 0;
LABEL_64:
              char v97 = v64;
              goto LABEL_65;
            }
            uint64_t v44 = 0;
            void *v37 = 0;
            *(unsigned char *)int v41 = 1;
            uint64_t v45 = *((void *)v41 + 1);
          }
          else
          {
            uint64_t v59 = *((void *)v41 + 1);
            if (!v42)
            {
              uint64_t v65 = *(void *)(v59 + 24 * v36 + 8);
              if (v65 < 2) {
                goto LABEL_62;
              }
              int64_t v66 = *(void *)(v59 + 24 * v36 + 16);
              int64_t v61 = v66;
              v104[511 - v40] = v65;
              if (v66 < 0)
              {
                unint64_t v70 = v66 & 0x7FFFFFFFFFFFFFFFLL;
                uint64_t v71 = v66 & 0x7FFFFFFFFFFFFFFFLL;
                if ((v66 & 0x7FFFFFFFFFFFFFFFuLL) < v85)
                {
                  if (!v24 || HIDWORD(v70))
                  {
LABEL_102:
                    long long v80 = __si_assert_copy_extra(0);
                    __message_assert("%s:%u: failed assertion '%s' %s invalid posting 0x%llx for 0x%llx");
LABEL_93:
                    free(v80);
                    if (__valid_fs(-1)) {
                      uint64_t v81 = 2989;
                    }
                    else {
                      uint64_t v81 = 3072;
                    }
                    *(_DWORD *)uint64_t v81 = -559038737;
                    abort();
                  }
                  uint64_t v71 = v70 | v24;
                }
                if (!v71) {
                  goto LABEL_102;
                }
                if ((int)v34 < 1 || v65 == v104[512 - v39])
                {
                  uint64_t v72 = (v34 + 1);
                  long long v73 = &v106[-(int)v34];
                }
                else
                {
                  v104[510 - (int)v34] = v65;
                  uint64_t v72 = v40 + 2;
                  long long v73 = &v106[-v34 - 1];
                }
                char v67 = (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(v3 + 16))(v3, v72, v73, v71);
                goto LABEL_63;
              }
              if (!v66) {
                goto LABEL_62;
              }
              if ((v7 & 1) == 0)
              {
                char v67 = (*(uint64_t (**)(uint64_t, void, void *, void))(v3 + 16))(v3, v40 + 1, &v106[-(int)v34], 0);
                goto LABEL_63;
              }
              int v62 = v34 + 1;
              if ((v66 & 0x4000000000000000) == 0)
              {
LABEL_54:
                long long v63 = &v102[48 * v28];
                *(_DWORD *)long long v63 = v62;
                *(void *)(v63 + 4) = 0;
                *(void *)(v63 + 20) = 0;
                *(void *)(v63 + 28) = 0;
                *(void *)(v63 + 36) = 0;
                *(void *)(v63 + 12) = 0x200000000;
                *((_DWORD *)v63 + 11) = 0;
                *((void *)v63 + 3) = v61;
                int v101 = v28 + 1;
LABEL_62:
                char v67 = 0;
LABEL_63:
                ++*v37;
                char v64 = v67;
                goto LABEL_64;
              }
LABEL_61:
              dumpDirectoryStorePage(&v98, v5, v61, v62, &v101, (uint64_t)v102);
              goto LABEL_62;
            }
            uint64_t v45 = *((void *)v41 + 1);
            uint64_t v44 = v36;
          }
          if (v7)
          {
            long long v78 = __si_assert_copy_extra(0);
            __message_assert("%s:%u: failed assertion '%s' %s ");
            goto LABEL_88;
          }
          uint64_t v60 = *(void *)(v45 + 24 * v44 + 8);
          if (v60 < 2) {
            goto LABEL_62;
          }
          int64_t v61 = *(void *)(v45 + 24 * v44 + 16);
          if (v61 < 1) {
            goto LABEL_62;
          }
          v104[511 - (int)v34] = v60;
          int v62 = v40 + 1;
          if ((v61 & 0x4000000000000000) == 0) {
            goto LABEL_54;
          }
          goto LABEL_61;
        }
        dumpDirectoryStorePage(&v98, v5, v19, v25, &v101, (uint64_t)v102);
      }
LABEL_28:
      int v28 = v101;
      if (v101) {
        goto LABEL_29;
      }
      goto LABEL_81;
    }
    unint64_t v29 = v19 & 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v30 = v29;
    if (v29 < v20)
    {
      if (HIDWORD(v29) || !v24) {
        goto LABEL_101;
      }
      unint64_t v30 = v24 | v29;
    }
    if (v30)
    {
      uint64_t v105 = 2;
      (*(void (**)(uint64_t))(v3 + 16))(v3);
      goto LABEL_28;
    }
LABEL_101:
    long long v78 = __si_assert_copy_extra(0);
    __message_assert("%s:%u: failed assertion '%s' %s invalid posting 0x%llx for 0x%llx");
LABEL_88:
    free(v78);
    if (__valid_fs(-1)) {
LABEL_89:
    }
      uint64_t v79 = 2989;
    else {
      uint64_t v79 = 3072;
    }
    *(_DWORD *)uint64_t v79 = -559038737;
    abort();
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
  }
LABEL_84:
  setCrashStateTarget(v9);
  if (__new) {
    _release_read_window(&availableReaders, __new);
  }
}

void dumpDirectoryStorePage(uint64_t *a1, _DWORD *a2, unint64_t a3, int a4, _DWORD *a5, uint64_t a6)
{
  BOOL v31 = 0;
  Page = _directoryStoreReaderGetPage(a1, a3, &v31);
  if (Page)
  {
    if (!v31)
    {
      int v26 = __si_assert_copy_extra(0);
      unint64_t v24 = v26;
      CFIndex v27 = "";
      if (v26) {
        CFIndex v27 = v26;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3032, "flat", v27);
LABEL_21:
      free(v24);
      if (__valid_fs(-1)) {
        uint64_t v28 = 2989;
      }
      else {
        uint64_t v28 = 3072;
      }
      *(_DWORD *)uint64_t v28 = -559038737;
      abort();
    }
    if (!*a2)
    {
      unsigned int v12 = Page;
      unint64_t v13 = *Page;
      if ((64 << *((unsigned char *)Page + 2)) - 8 < (int)v13)
      {
        unint64_t v29 = __si_assert_copy_extra(0);
        __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d");
      }
      else
      {
        directoryStorePageGetSize(Page, v11);
        if (v13 < 0x10) {
          return;
        }
        uint64_t v15 = v14;
        size_t v16 = v13 >> 4;
        unsigned int v17 = (char *)malloc_type_malloc(24 * (v13 >> 4), 0x1000040504FFAC1uLL);
        uint64_t v18 = 0;
        if (v15)
        {
          unint64_t v19 = v12 + 4;
          do
          {
            if (*(void *)v19)
            {
              unint64_t v20 = (unint64_t *)&v17[24 * v18];
              *(_OWORD *)(v20 + 1) = *(_OWORD *)v19;
              *unint64_t v20 = hash64(v20[1]);
              ++v18;
            }
            else if (*((void *)v19 + 1))
            {
              unint64_t v23 = __si_assert_copy_extra(0);
              unint64_t v24 = v23;
              int v25 = "";
              if (v23) {
                int v25 = v23;
              }
              __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3010, "page->items[i].childPage.offset==0", v25);
              goto LABEL_21;
            }
            v19 += 8;
            --v15;
          }
          while (v15);
        }
        if (v18 == v16)
        {
          qsort_b(v17, v16, 0x18uLL, &__block_literal_global_125);
          uint64_t v21 = a6 + 48 * *a5;
          *(_DWORD *)uint64_t v21 = a4;
          *(void *)(v21 + 4) = 0;
          *(void *)(v21 + 12) = 0x100000000;
          *(void *)(v21 + 20) = 0;
          *(_DWORD *)(v21 + 44) = 0;
          *(void *)(v21 + 36) = 0;
          *(void *)(v21 + 28) = 0;
          LODWORD(v21) = *a5;
          uint64_t v22 = a6 + 48 * *a5;
          *(unsigned char *)(v22 + 24) = 0;
          *(void *)(v22 + 32) = v17;
          *(void *)(v22 + 40) = v16;
          *a5 = v21 + 1;
          return;
        }
        unint64_t v29 = __si_assert_copy_extra(0);
        __message_assert("%s:%u: failed assertion '%s' %s ");
      }
      free(v29);
      if (__valid_fs(-1)) {
        uint64_t v30 = 2989;
      }
      else {
        uint64_t v30 = 3072;
      }
      *(_DWORD *)uint64_t v30 = -559038737;
      abort();
    }
  }
}

uint64_t __dumpSpecialDirectoryStorePage_block_invoke(uint64_t a1, void *a2, void *a3)
{
  if (*a2 < *a3) {
    return 0xFFFFFFFFLL;
  }
  if (*a2 > *a3) {
    return 1;
  }
  if (a2[1] < a3[1]) {
    return 0xFFFFFFFFLL;
  }
  return 1;
}

void cleanup(unsigned int *a1)
{
  unint64_t v1 = *a1;
  if (v1)
  {
    unint64_t v3 = 0;
    CFIndex v4 = (void **)(a1 + 10);
    do
    {
      if (*((_DWORD *)v4 - 4) == 1)
      {
        free(*v4);
        unint64_t v1 = *a1;
      }
      ++v3;
      v4 += 6;
    }
    while (v3 < v1);
  }
}

void compactForwardDirectoryStore(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  unint64_t v3 = v2;
  uint64_t v5 = v4;
  uint64_t v6 = v1;
  bzero(v7, 0x1020uLL);
  dumpDirectoryStore(v6);
  if (!*v3) {
    flushForwardStore(v5, 0);
  }
}

uint64_t __compactForwardDirectoryStore_block_invoke(uint64_t a1, int a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    if (v7)
    {
      unsigned int v8 = uint32_map_get(v7, a4);
      a4 = *(void *)storageResolvePtr(*(void *)(a1 + 40), 8 * v8, 8, 1);
    }
  }
  if (!directoryStoreMakePathWithPostingsOffset(*(void *)(a1 + 48), a2, a3, a4, *(void *)(a1 + 56))
    || **(_DWORD **)(a1 + 64))
  {
    return 1;
  }
  int8x8_t v11 = *(uint64_t (**)(uint64_t))(a1 + 88);
  uint64_t v10 = *(void *)(a1 + 96);
  return v11(v10);
}

void subvertForwardDirectoryStore(void *a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  memset(v17, 0, 255);
  uint64_t v4 = fd_name(a1[28], (char *)v17, 0xFFuLL);
  memset(v16, 0, 255);
  uint64_t v5 = fd_name(a1[28], (char *)v16, 0xFFuLL);
  uint64_t v6 = v5;
  if (v5)
  {
    strlcat(v5, ".shadow", 0xFFuLL);
    sibling_protected = (atomic_uint *)fd_create_sibling_protected(a1[28], v6, 0, 0);
    if (sibling_protected)
    {
      unsigned int v8 = sibling_protected;
      _fd_unlink_with_origin((uint64_t)sibling_protected, 0);
      fd_release(v8);
    }
  }
  _fd_unlink_with_origin(a1[28], 0);
  freeForwardDirectoryStore(a1);
  if (strstr(v6, ".shadow.shadow"))
  {
    int8x8_t v11 = __si_assert_copy_extra(0);
    unsigned int v12 = v11;
    unint64_t v13 = "";
    if (v11) {
      unint64_t v13 = v11;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3225, "0==strstr(shadowpathPtr, \".shadow.shadow\")", v13);
    free(v12);
    if (__valid_fs(-1)) {
      uint64_t v14 = 2989;
    }
    else {
      uint64_t v14 = 3072;
    }
    *(_DWORD *)uint64_t v14 = -559038737;
    abort();
  }
  memset(v15, 0, 255);
  int v9 = fd_name(*(void *)(a2 + 224), (char *)v15, 0xFFuLL);
  strlcat(v9, ".shadow", 0xFFuLL);
  uint64_t v10 = (atomic_uint *)fd_create_sibling_protected(*(void *)(a2 + 224), v9, 0, 0);
  fd_rename(*(void *)(a2 + 224), v4);
  if (v10)
  {
    fd_rename((uint64_t)v10, v6);
    fd_release(v10);
  }
}

uint64_t unlinkDirectoryStore(const char *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s%s", a1, "directoryStoreFile");
  return unlink(__str);
}

uint64_t unlinkDirectoryStoreShadow(const char *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s%s.shadow", a1, "directoryStoreFile");
  return unlink(__str);
}

int64_t directoryStoreGetParent(uint64_t a1, unint64_t a2)
{
  int v4 = setCrashStateTarget(2);
  uint64_t v5 = a1 + 4424;
  db_read_lock(a1 + 4424);
  uint64_t v29 = 0;
  __new = 0;
  uint64_t v31 = 0;
  storage_reader_init(a1, (uint64_t)&v29);
  if (!(_BYTE)v31)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
    }
    goto LABEL_10;
  }
  int32_t v6 = OSAtomicIncrement32(exceptionSequenceNum);
  unint64_t v7 = setThreadIdAndInfo(-1, sStorageReaderExceptionCallbacks, (uint64_t)&v29, 0, v6);
  unsigned int v27 = HIDWORD(v7);
  *(_DWORD *)long long buf = v7;
  unint64_t v26 = __PAIR64__(v8, v9);
  uint64_t v10 = *(void *)&threadData[18 * v7 + 2];
  uint64_t v11 = v10 + 320 * HIDWORD(v7);
  int v12 = *(_DWORD *)(v11 + 312);
  unint64_t v13 = *(void (**)(void))(v11 + 224);
  if (v13) {
    v13(*(void *)(v10 + 320 * HIDWORD(v7) + 288));
  }
  unsigned int v25 = *(_DWORD *)buf;
  unsigned int v24 = v27;
  unint64_t v23 = v26;
  if (_setjmp((int *)v11))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      v22[0] = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)v22, 2u);
    }
    *(_DWORD *)(v11 + 312) = v12;
    CIOnThreadCleanUpReset(v23);
    dropThreadId(v25, 1, v6);
    CICleanUpReset(v25, HIDWORD(v23));
LABEL_10:
    int64_t v14 = 0;
    goto LABEL_17;
  }
  Itemunint64_t Offset = directoryStoreReaderTreeFindItemOffset(&v29, 0x440uLL, a2, 0);
  if (ItemOffset) {
    int64_t v16 = ItemOffset[1];
  }
  else {
    int64_t v16 = 0;
  }
  uint64_t v17 = *(void *)&threadData[18 * v25 + 2];
  unsigned int v18 = v24;
  uint64_t v19 = v17 + 320 * v24;
  *(_DWORD *)(v19 + 312) = v12;
  unint64_t v20 = *(void (**)(void))(v19 + 232);
  if (v20) {
    v20(*(void *)(v17 + 320 * v18 + 288));
  }
  dropThreadId(v25, 0, v6);
  int64_t v14 = v16;
LABEL_17:
  db_read_unlock(v5);
  if (__new)
  {
    _release_read_window(&availableReaders, __new);
    __new = 0;
  }
  setCrashStateTarget(v4);
  return v14;
}

uint64_t directoryStoreGetPath(uint64_t a1, unint64_t a2, uint64_t a3)
{
  int v6 = setCrashStateTarget(2);
  uint64_t v7 = a1 + 4424;
  db_read_lock(a1 + 4424);
  uint64_t v35 = 0;
  __new = 0;
  uint64_t v37 = 0;
  storage_reader_init(a1, (uint64_t)&v35);
  if (!(_BYTE)v37)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      uint64_t v16 = 0;
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
      goto LABEL_21;
    }
    goto LABEL_10;
  }
  int32_t v8 = OSAtomicIncrement32(exceptionSequenceNum);
  unint64_t v9 = setThreadIdAndInfo(-1, sStorageReaderExceptionCallbacks, (uint64_t)&v35, 0, v8);
  unsigned int v33 = HIDWORD(v9);
  *(_DWORD *)long long buf = v9;
  unint64_t v32 = __PAIR64__(v10, v11);
  uint64_t v12 = *(void *)&threadData[18 * v9 + 2];
  uint64_t v13 = v12 + 320 * HIDWORD(v9);
  int v14 = *(_DWORD *)(v13 + 312);
  uint64_t v15 = *(void (**)(void))(v13 + 224);
  if (v15) {
    v15(*(void *)(v12 + 320 * HIDWORD(v9) + 288));
  }
  unsigned int v31 = *(_DWORD *)buf;
  unsigned int v30 = v33;
  unint64_t v29 = v32;
  if (_setjmp((int *)v13))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v28 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v28, 2u);
    }
    *(_DWORD *)(v13 + 312) = v14;
    CIOnThreadCleanUpReset(v29);
    dropThreadId(v31, 1, v8);
    CICleanUpReset(v31, HIDWORD(v29));
LABEL_10:
    uint64_t v16 = 0;
    goto LABEL_21;
  }
  if (a2 == 2)
  {
    uint64_t v17 = 0;
  }
  else
  {
    uint64_t v18 = 0;
    unint64_t v19 = a2;
    do
    {
      uint64_t v20 = v18;
      Itemunint64_t Offset = directoryStoreReaderTreeFindItemOffset(&v35, 0x440uLL, v19, 0);
      if (!ItemOffset) {
        break;
      }
      int64_t v22 = ItemOffset[1];
      if (!v22) {
        break;
      }
      unint64_t v19 = ItemOffset[1];
      uint64_t v18 = v20 + 1;
      *(void *)(a3 + 8 * v20++) = v22;
    }
    while (v22 != 2);
    uint64_t v17 = v20;
  }
  uint64_t v23 = *(void *)&threadData[18 * v31 + 2];
  unsigned int v24 = v30;
  uint64_t v25 = v23 + 320 * v30;
  *(_DWORD *)(v25 + 312) = v14;
  unint64_t v26 = *(void (**)(void))(v25 + 232);
  if (v26) {
    v26(*(void *)(v23 + 320 * v24 + 288));
  }
  dropThreadId(v31, 0, v8);
  uint64_t v16 = v17;
LABEL_21:
  db_read_unlock(v7);
  if (__new)
  {
    _release_read_window(&availableReaders, __new);
    __new = 0;
  }
  setCrashStateTarget(v6);
  return v16;
}

int64_t directoryStoreWriterGetParent(uint64_t a1, unint64_t a2)
{
  int v4 = setCrashStateTarget(2);
  _db_write_lock(a1 + 4424);
  int64_t v5 = 0;
  if (storageResolvePtr(a1, 0, 1, 1))
  {
    int32_t v6 = OSAtomicIncrement32(exceptionSequenceNum);
    uint64_t v7 = *(void *)(a1 + 216);
    if (v7) {
      int v8 = *(_DWORD *)(v7 + 44);
    }
    else {
      int v8 = -1;
    }
    unint64_t v9 = setThreadIdAndInfo(v8, sStorageExceptionCallbacks, a1, 1, v6);
    unsigned int v27 = HIDWORD(v9);
    unsigned int v28 = v9;
    unint64_t v26 = __PAIR64__(v10, v11);
    uint64_t v12 = *(void *)&threadData[18 * v9 + 2];
    uint64_t v13 = v12 + 320 * HIDWORD(v9);
    int v14 = *(_DWORD *)(v13 + 312);
    uint64_t v15 = *(void (**)(void))(v13 + 224);
    if (v15) {
      v15(*(void *)(v12 + 320 * HIDWORD(v9) + 288));
    }
    unsigned int v25 = v28;
    unsigned int v24 = v27;
    unint64_t v23 = v26;
    if (_setjmp((int *)v13))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        v22[0] = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)v22, 2u);
      }
      *(_DWORD *)(v13 + 312) = v14;
      CIOnThreadCleanUpReset(v23);
      dropThreadId(v25, 1, v6);
      CICleanUpReset(v25, HIDWORD(v23));
      int64_t v5 = 0;
    }
    else
    {
      int64_t Parent = _directoryStoreGetParent(a1, a2);
      uint64_t v17 = *(void *)&threadData[18 * v25 + 2];
      unsigned int v18 = v24;
      uint64_t v19 = v17 + 320 * v24;
      *(_DWORD *)(v19 + 312) = v14;
      uint64_t v20 = *(void (**)(void))(v19 + 232);
      if (v20) {
        v20(*(void *)(v17 + 320 * v18 + 288));
      }
      dropThreadId(v25, 0, v6);
      int64_t v5 = Parent;
    }
  }
  db_write_unlock(a1 + 4424);
  setCrashStateTarget(v4);
  return v5;
}

uint64_t dirtyStore(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4416))
  {
    uint64_t v2 = *(void *)(a1 + 4640);
    if (v2) {
      (*(void (**)(void))(v2 + 16))();
    }
    unint64_t v3 = storageResolvePtr(a1, 0x40uLL, 1024, 1);
    *(_DWORD *)(v3 + 4) = 0;
    dirtyStoragePage(a1, v3);
    int v4 = (void *)(v3 & ~*MEMORY[0x1E4F14AF0]);
    fd_system_status_stall_if_busy();
    msync(v4, 0x1000uLL, 16);
    uint64_t result = fd_sync(*(void *)(a1 + 216), 1);
    *(_DWORD *)(a1 + 4416) = 0;
  }
  else
  {
    if (*(void *)(a1 + 232) <= 0x43FuLL) {
      storageAllocOffsetFromEnd(a1, *(_DWORD *)(a1 + 224) + 960);
    }
    uint64_t result = storageResolvePtr(a1, 0x40uLL, 1024, 1);
    *(_DWORD *)(result + 4) = 0;
  }
  return result;
}

uint64_t directoryStoreSetParentForMove(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  unsigned int v48 = 0;
  uint64_t v47 = 0;
  long long v46 = 0u;
  memset(v45, 0, sizeof(v45));
  int v6 = setCrashStateTarget(2);
  if (!a3)
  {
    uint64_t v35 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
    uint64_t v36 = v35;
    uint64_t v37 = "";
    if (v35) {
      uint64_t v37 = v35;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3492, "parent", v37);
    free(v36);
    if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
      uint64_t v38 = 2989;
    }
    else {
      uint64_t v38 = 3072;
    }
    *(_DWORD *)uint64_t v38 = -559038737;
    abort();
  }
  int v7 = v6;
  _db_write_lock(a1 + 4424);
  if (storageResolvePtr(a1, 0, 1, 1))
  {
    int32_t v8 = OSAtomicIncrement32(exceptionSequenceNum);
    uint64_t v9 = *(void *)(a1 + 216);
    if (v9) {
      int v10 = *(_DWORD *)(v9 + 44);
    }
    else {
      int v10 = -1;
    }
    unint64_t v11 = setThreadIdAndInfo(v10, sStorageExceptionCallbacks, a1, 1, v8);
    unsigned int v43 = HIDWORD(v11);
    unsigned int v44 = v11;
    unsigned int v41 = v13;
    unsigned int v42 = v12;
    uint64_t v14 = *(void *)&threadData[18 * v11 + 2];
    uint64_t v15 = v14 + 320 * HIDWORD(v11);
    int v16 = *(_DWORD *)(v15 + 312);
    uint64_t v17 = *(void (**)(void))(v15 + 224);
    if (v17) {
      v17(*(void *)(v14 + 320 * HIDWORD(v11) + 288));
    }
    if (_setjmp((int *)v15))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
      }
      *(_DWORD *)(v15 + 312) = v16;
      CIOnThreadCleanUpReset(v41);
      dropThreadId(v44, 1, v8);
      CICleanUpReset(v44, v42);
    }
    else
    {
      if (dword_1E9FC90BC >= 5)
      {
        int v39 = *__error();
        unsigned int v40 = _SILogForLogForCategory(6);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 134218240;
          unint64_t v50 = a2;
          __int16 v51 = 2048;
          uint64_t v52 = a3;
          _os_log_impl(&dword_1BD672000, v40, OS_LOG_TYPE_DEFAULT, "Move %llx/%llx", buf, 0x16u);
        }
        *__error() = v39;
      }
      dirtyStore(a1);
      Itemunint64_t Offset = directoryStoreTreeFindItemOffset(a1, 0x440uLL, a2, (uint64_t)v45, &v48, 0, 1);
      PageInner = _directoryStoreGetPageInner(a1, *((unint64_t *)&v46 + 1), (BOOL *)buf);
      uint64_t v21 = PageInner;
      int64_t v22 = PageInner;
      if (ItemOffset)
      {
        if (*ItemOffset != a2 || (uint64_t v23 = v48, &PageInner[8 * v48 + 4] != (unsigned __int16 *)ItemOffset))
        {
          unsigned int v24 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
          unsigned int v25 = v24;
          unint64_t v26 = "";
          if (v24) {
            unint64_t v26 = v24;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3513, "(getStoreOID(element->fileId)==item && &page->items[slot]==element)", v26);
          free(v25);
          if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
            uint64_t v27 = 2989;
          }
          else {
            uint64_t v27 = 3072;
          }
          *(_DWORD *)uint64_t v27 = -559038737;
          abort();
        }
      }
      else
      {
        uint64_t v28 = v48;
        if (*(void *)&PageInner[8 * v48 + 4] >= 2uLL)
        {
          directoryStorePageGetSize(PageInner, v20);
          shiftEntries((uint64_t)v22, v28, v29);
          uint64_t v28 = v48;
        }
        *v22 += 16;
        uint64_t v23 = v28;
      }
      unsigned int v30 = &v21[8 * v23];
      *((void *)v30 + 1) = a2;
      *((void *)v30 + 2) = a3;
      dirtyStoragePage(a1, (unint64_t)v22);
      uint64_t v31 = *(void *)&threadData[18 * v44 + 2];
      uint64_t v32 = v31 + 320 * v43;
      *(_DWORD *)(v32 + 312) = v16;
      unsigned int v33 = *(void (**)(void))(v32 + 232);
      if (v33) {
        v33(*(void *)(v31 + 320 * v43 + 288));
      }
      dropThreadId(v44, 0, v8);
    }
  }
  db_write_unlock(a1 + 4424);
  return setCrashStateTarget(v7);
}