void CVAViewpointCorrectionCreate()
{
  NSObject *v0;
  uint8_t buf[8];
  uint64_t v2;

  v2 = *MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  v0 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1D0DBD000, v0, OS_LOG_TYPE_INFO, "CVAViewpointCorrectionCreate", buf, 2u);
  }

  operator new();
}

void sub_1D0DBFD40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1D0DCA278((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t CVAViewpointCorrectionProcess(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2) {
      operator new();
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    v2 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v2, OS_LOG_TYPE_ERROR, "invalid argument for params.", buf, 2u);
    }
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    v2 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v2, OS_LOG_TYPE_ERROR, "invalid argument for handle.", buf, 2u);
    }
  }

  return 4294944343;
}

void sub_1D0DC1900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  sub_1D0DCA2C0(v41 - 240);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)&a41);
  sub_1D0DCA2C0((uint64_t)&a37);
  sub_1D0DCA2C0((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t CVANetPipeGetTypeID()
{
  if (qword_1EA6434E0 != -1) {
    dispatch_once(&qword_1EA6434E0, &unk_1F26F5548);
  }
  return qword_1EA6434E8;
}

uint64_t sub_1D0DC1A74()
{
  qword_1EA6434F0 = 0;
  *(void *)algn_1EA6434F8 = "CVANetPipe";
  qword_1EA643500 = (uint64_t)nullsub_2;
  unk_1EA643508 = 0;
  qword_1EA643518 = 0;
  unk_1EA643520 = 0;
  qword_1EA643510 = (uint64_t)nullsub_1;
  qword_1EA643528 = (uint64_t)sub_1D0DC1B3C;
  qword_1EA643530 = (uint64_t)sub_1D0DC1AEC;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EA6434E8 = result;
  return result;
}

CFStringRef sub_1D0DC1AEC(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CVANetPipe %p [%p]>", a1, v3);
}

CFStringRef sub_1D0DC1B3C(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CVANetPipe %p [%p]>", a1, v3);
}

uint64_t CVANetPipeCopyProperty()
{
  return 4294944344;
}

uint64_t CVANetPipeSetProperty()
{
  return 4294944344;
}

uint64_t CVANetPipeCreate()
{
  return 4294944344;
}

uint64_t CVANetPipeAddNetwork()
{
  return 4294944344;
}

uint64_t CVANetPipeRemoveNetwork()
{
  return 4294944344;
}

uint64_t CVANetPipeAllocateResources()
{
  return 4294944344;
}

uint64_t CVANetPipeFreeResources()
{
  return 4294944344;
}

uint64_t CVANetPipeProcessNetwork()
{
  return 4294944344;
}

uint64_t CVANetPipeShutdown()
{
  return 4294944343;
}

uint64_t CVAFaceTrackingLiteGetTypeID()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA643558, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA643558))
  {
    qword_1EA643550 = sub_1D0DC1C50();
    __cxa_guard_release(&qword_1EA643558);
  }
  return qword_1EA643550;
}

void sub_1D0DC1C38(_Unwind_Exception *a1)
{
}

uint64_t sub_1D0DC1C50()
{
  qword_1EA643568 = 0;
  unk_1EA643570 = "CVAFaceTrackingLite";
  qword_1EA643578 = (uint64_t)sub_1D0DC1DBC;
  unk_1EA643580 = 0;
  qword_1EA643590 = 0;
  unk_1EA643598 = 0;
  qword_1EA643588 = (uint64_t)sub_1D0DC1D4C;
  qword_1EA6435A0 = (uint64_t)sub_1D0DC1CFC;
  qword_1EA6435A8 = (uint64_t)sub_1D0DC1CAC;
  return _CFRuntimeRegisterClass();
}

CFStringRef sub_1D0DC1CAC(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CVAFaceTrackingLite %p [%p]>", a1, v3);
}

CFStringRef sub_1D0DC1CFC(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CVAFaceTrackingLite %p [%p]>", a1, v3);
}

uint64_t sub_1D0DC1D4C(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFAllocatorRef v2 = *(uint64_t ***)(result + 16);
    if (v2)
    {
      CFAllocatorRef v3 = *v2;
      NSObject *v2 = 0;
      if (v3)
      {
        v4 = sub_1D0E3C36C(v3);
        MEMORY[0x1D25F16B0](v4, 0x20C4093837F09);
      }
      uint64_t result = MEMORY[0x1D25F16B0](v2, 0x20C4093837F09);
    }
    *(void *)(v1 + 16) = 0;
  }
  return result;
}

uint64_t sub_1D0DC1DBC(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t CVAFaceTrackingLiteGetAPIVersion()
{
  return 7;
}

double CVAFaceTrackingLiteGetDefaultCreateOptions@<D0>(uint64_t a1@<X8>)
{
  *(_WORD *)a1 = 257;
  *(unsigned char *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 4) = 3;
  *(unsigned char *)(a1 + 2) = 0;
  *(_DWORD *)(a1 + 20) = 1117782016;
  *(void *)&double result = 1065353216;
  *(void *)(a1 + 12) = 1065353216;
  return result;
}

uint64_t CVAFaceTrackingLiteCreate(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a3) {
    return 4294944343;
  }
  uint64_t v3 = 4294944343;
  if (a2 && !*a3)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA643558, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA643558))
    {
      qword_1EA643550 = sub_1D0DC1C50();
      __cxa_guard_release(&qword_1EA643558);
    }
    Instance = (void *)_CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v5 = operator new(8uLL, MEMORY[0x1E4FBA2D0]);
      if (v5)
      {
        *uint64_t v5 = 0;
        Instance[2] = v5;
        v6 = (void *)MEMORY[0x1D25F1DA0]();
        v7 = [MEMORY[0x1E4F28B50] bundleForClass:objc_opt_class()];
        v8 = [v7 resourcePath];

        if (!v8)
        {
          memset(&__dst, 0, sizeof(__dst));
          goto LABEL_23;
        }
        cva::Path::Path((cva::Path *)buf, (const char *)[v8 cStringUsingEncoding:4]);
        cva::Path::Path((cva::Path *)&v15, "resources_facekit/");
        cva::Path::append();
        cva::Path::~Path((cva::Path *)&v15);
        uint64_t v9 = cva::Path::string((cva::Path *)buf);
        if (*(char *)(v9 + 23) < 0)
        {
          sub_1D0DCB370(&__dst, *(void **)v9, *(void *)(v9 + 8));
        }
        else
        {
          long long v10 = *(_OWORD *)v9;
          __dst.__r_.__value_.__r.__words[2] = *(void *)(v9 + 16);
          *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v10;
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::size_type size = __dst.__r_.__value_.__l.__size_;
          if (__dst.__r_.__value_.__l.__size_)
          {
            p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
LABEL_20:
            if (p_dst->__r_.__value_.__s.__data_[size - 1] != 47) {
              std::string::push_back(&__dst, 47);
            }
          }
        }
        else
        {
          std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          if (*((unsigned char *)&__dst.__r_.__value_.__s + 23))
          {
            p_dst = &__dst;
            goto LABEL_20;
          }
        }
        cva::Path::~Path((cva::Path *)buf);
LABEL_23:

        operator new();
      }
      Instance[2] = 0;
      CFRelease(Instance);
    }
    return 4294944342;
  }
  return v3;
}

void sub_1D0DC379C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37)
{
  __cxa_guard_abort(&qword_1EB9F1618);
  std::mutex::unlock(&stru_1EB9F15B8);
  kdebug_trace();
  if (v37)
  {
    if (!atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
      _Unwind_Resume(a1);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t CVAFaceTrackingLiteSetColorImage(uint64_t a1, CVPixelBufferRef pixelBuffer, uint64_t a3)
{
  uint64_t result = 4294944343;
  if (a1)
  {
    uint64_t v5 = pixelBuffer;
    if (pixelBuffer)
    {
      if (a3)
      {
        texture[0] = 0;
        texture[1] = (CVPixelBufferRef)&unk_1F26F4478;
        uint64_t v24 = 0x100000001;
        *(void *)&v25[4] = 0;
        *(void *)&v25[12] = 0x3F80000000000000;
        *(void *)&v25[20] = 0;
        *(_DWORD *)v25 = 1065353216;
        *(_DWORD *)&v25[28] = 0;
        *(void *)&v26[8] = 0;
        *(void *)&v26[16] = 0x3F80000000000000;
        *(void *)&v26[24] = 0;
        *(void *)&v26[32] = 0x3F80000000000000;
        __asm { FMOV            V1.2S, #1.0 }
        *(void *)v26 = _D1;
        *(void *)&v26[40] = 0;
        *(_DWORD *)&v26[48] = 0;
        LODWORD(v16) = CVPixelBufferGetWidth(pixelBuffer);
        HIDWORD(v16) = CVPixelBufferGetHeight(v5);
        LODWORD(v17) = *(_DWORD *)(a3 + 48);
        DWORD1(v17) = *(_DWORD *)(a3 + 60);
        DWORD2(v17) = *(_DWORD *)(a3 + 72);
        HIDWORD(v17) = *(_DWORD *)(a3 + 52);
        LODWORD(v18) = *(_DWORD *)(a3 + 64);
        DWORD1(v18) = *(_DWORD *)(a3 + 76);
        DWORD2(v18) = *(_DWORD *)(a3 + 56);
        HIDWORD(v18) = *(_DWORD *)(a3 + 68);
        int v19 = *(_DWORD *)(a3 + 80);
        LODWORD(v20) = *(_DWORD *)a3;
        DWORD1(v20) = *(_DWORD *)(a3 + 12);
        DWORD2(v20) = *(_DWORD *)(a3 + 24);
        HIDWORD(v20) = *(_DWORD *)(a3 + 4);
        LODWORD(v21) = *(_DWORD *)(a3 + 16);
        DWORD1(v21) = *(_DWORD *)(a3 + 28);
        DWORD2(v21) = *(_DWORD *)(a3 + 8);
        HIDWORD(v21) = *(_DWORD *)(a3 + 20);
        long long v22 = *(_OWORD *)(a3 + 32);
        uint64_t v24 = v16;
        *(_OWORD *)&v25[16] = v18;
        *(_OWORD *)v25 = v17;
        *(_DWORD *)v26 = v19;
        *(_OWORD *)&v26[36] = v22;
        *(_OWORD *)&v26[20] = v21;
        *(_OWORD *)&v26[4] = v20;
        CVPixelBufferRetain(v5);
        texture[0] = v5;
        uint64_t v12 = ***(void ***)(a1 + 16);
        v13 = (CVPixelBufferRef *)(v12 + 88);
        if (*v13)
        {
          CVPixelBufferRelease(*v13);
          CVPixelBufferRef *v13 = 0;
          uint64_t v5 = texture[0];
        }
        *(void *)(v12 + 88) = v5;
        texture[0] = 0;
        *(void *)(v12 + 104) = v24;
        if (v13 != texture)
        {
          long long v14 = *(_OWORD *)&v25[16];
          *(_OWORD *)(v12 + 112) = *(_OWORD *)v25;
          *(_OWORD *)(v12 + 128) = v14;
          long long v15 = *(_OWORD *)&v26[20];
          *(_OWORD *)(v12 + 148) = *(_OWORD *)&v26[4];
          *(_DWORD *)(v12 + 144) = *(_DWORD *)v26;
          *(_OWORD *)(v12 + 164) = v15;
          *(_DWORD *)(v12 + 180) = *(_DWORD *)&v26[36];
          *(void *)(v12 + 184) = *(void *)&v26[40];
          *(_DWORD *)(v12 + 192) = *(_DWORD *)&v26[48];
        }
        return 0;
      }
    }
  }
  return result;
}

void sub_1D0DC3CF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,CVPixelBufferRef texture)
{
  if (texture) {
    CVPixelBufferRelease(texture);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CVAFaceTrackingLiteSetTimestamp(uint64_t a1, double a2)
{
  uint64_t result = 4294944343;
  if (a1)
  {
    uint64_t result = 0;
    uint64_t v4 = ***(void ***)(a1 + 16);
    *(double *)(v4 + 24) = a2;
    *(_DWORD *)(v4 + 48) = 0;
  }
  return result;
}

uint64_t CVAFaceTrackingLiteSetDetectedFaces(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t result = 4294944343;
  if (a1 && (a2 & 0x80000000) == 0 && (!a2 || a3))
  {
    v7 = ***(void ****)(a1 + 16);
    v8 = (void *)v7[41];
    v7[42] = v8;
    uint64_t v9 = a2;
    if (a2 > (unint64_t)((uint64_t)(v7[43] - (void)v8) >> 5))
    {
      long long v10 = (char *)operator new(32 * a2);
      v7[41] = v10;
      v7[42] = v10;
      v7[43] = &v10[32 * a2];
      if (v8) {
        operator delete(v8);
      }
    }
    if ((int)a2 >= 1)
    {
      uint64_t v11 = 0;
      do
      {
        long long v15 = (char *)v7[42];
        unint64_t v14 = v7[43];
        if ((unint64_t)v15 < v14)
        {
          *(_OWORD *)long long v15 = 0u;
          *((_OWORD *)v15 + 1) = 0u;
          uint64_t v12 = v15 + 32;
        }
        else
        {
          uint64_t v16 = (unsigned char *)v7[41];
          uint64_t v17 = (v15 - v16) >> 5;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 59) {
            abort();
          }
          uint64_t v19 = v14 - (void)v16;
          if (v19 >> 4 > v18) {
            unint64_t v18 = v19 >> 4;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v20 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            if (v20 >> 59) {
              sub_1D0DE8CE0();
            }
            long long v21 = (char *)operator new(32 * v20);
          }
          else
          {
            long long v21 = 0;
          }
          long long v22 = &v21[32 * v17];
          *(_OWORD *)long long v22 = 0u;
          *((_OWORD *)v22 + 1) = 0u;
          v23 = v22;
          if (v15 != v16)
          {
            do
            {
              uint64_t v24 = *((void *)v15 - 4);
              v15 -= 32;
              int v25 = *((_DWORD *)v15 + 2);
              *((void *)v23 - 4) = v24;
              v23 -= 2;
              *((_DWORD *)v23 + 2) = v25;
              *(void *)((char *)v23 + 12) = *(void *)(v15 + 12);
              *(void *)((char *)v23 + 20) = *(void *)(v15 + 20);
            }
            while (v15 != v16);
            long long v15 = (char *)v7[41];
          }
          uint64_t v12 = v22 + 32;
          v7[41] = v23;
          v7[42] = v22 + 32;
          v7[43] = &v21[32 * v20];
          if (v15) {
            operator delete(v15);
          }
        }
        v7[42] = v12;
        uint64_t v13 = a3 + 20 * v11;
        *(_OWORD *)((char *)v12 - 20) = *(_OWORD *)v13;
        *((_DWORD *)v12 - 6) = *(_DWORD *)(v13 + 16);
        *((void *)v12 - 4) = 0;
        ++v11;
      }
      while (v11 != v9);
    }
    return 0;
  }
  return result;
}

uint64_t CVAFaceTrackingLiteSetLuxLevel(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    return 4294944343;
  }
  uint64_t v2 = ***(void ***)(a1 + 16);
  unint64_t v3 = *(void *)(v2 + 368) & 0xFFFFFF0000000000 | 0x100000000;
  if (!*(unsigned char *)(v2 + 376)) {
    unint64_t v3 = 0x100000000;
  }
  unint64_t v4 = v3 | a2;
  if (!*(unsigned char *)(v2 + 376)) {
    *(unsigned char *)(v2 + 376) = 1;
  }
  uint64_t result = 0;
  *(void *)(v2 + 368) = v4;
  return result;
}

uint64_t CVAFaceTrackingLiteProcess(uint64_t a1)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 4294944343;
  }
  uint64_t v1 = *(uint64_t ***)(a1 + 16);
  uint64_t v2 = *v1;
  int v3 = sub_1D0E39E1C(**v1);
  __asm { FMOV            V0.2S, #1.0 }
  unint64_t v33 = _D0;
  if (v3) {
    operator new();
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  long long v10 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
  {
    LOWORD(time[0].value) = 0;
    _os_log_error_impl(&dword_1D0DBD000, v10, OS_LOG_TYPE_ERROR, "invalid FaceKit input parameters", (uint8_t *)time, 2u);
  }
  uint64_t v11 = *v2;
  if (*(unsigned char *)(*v2 + 440))
  {
    uint64_t v12 = *(std::__shared_weak_count **)(v11 + 424);
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    *(unsigned char *)(v11 + 440) = 0;
    uint64_t v11 = *v2;
  }
  if (*(unsigned char *)(v11 + 592)) {
    *(unsigned char *)(v11 + 592) = 0;
  }
  memset(v39, 0, 168);
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  memset(v36, 0, sizeof(v36));
  memset(time, 0, sizeof(time));
  cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)&time[0].timescale);
  LODWORD(time[2].value) = 0;
  time[1].value = 0x7FF8000000000000;
  memset(&time[2].timescale, 0, 40);
  *(void *)&long long v35 = &unk_1F26F4478;
  *((void *)&v35 + 1) = 0x100000001;
  *(void *)((char *)v36 + 4) = 0;
  *(void *)((char *)v36 + 12) = 0x3F80000000000000;
  *(void *)((char *)&v36[1] + 4) = 0;
  LODWORD(v36[0]) = 1065353216;
  HIDWORD(v36[1]) = 0;
  v36[3] = 0x3F80000000000000uLL;
  v36[4] = 0x3F80000000000000uLL;
  v36[2] = v33;
  LODWORD(v37) = 0;
  *((void *)&v37 + 1) = 0;
  *(void *)&long long v38 = &unk_1F26F4478;
  *((void *)&v38 + 1) = 0x100000001;
  *(void *)((char *)v39 + 4) = 0;
  *(void *)((char *)v39 + 12) = 0x3F80000000000000;
  *(void *)((char *)&v39[1] + 4) = 0;
  LODWORD(v39[0]) = 1065353216;
  HIDWORD(v39[1]) = 0;
  v39[3] = 0x3F80000000000000uLL;
  v39[4] = 0x3F80000000000000uLL;
  v39[2] = v33;
  LODWORD(v39[5]) = 0;
  BYTE8(v39[9]) = 0;
  BYTE12(v39[9]) = 0;
  BYTE14(v39[9]) = 0;
  memset((char *)&v39[6] + 4, 0, 45);
  LOWORD(v39[10]) = 1;
  BYTE2(v39[10]) = 0;
  *(void *)uint64_t v11 = time[0].value;
  cva::DictionaryHandler::operator=();
  long long v13 = *(_OWORD *)&time[1].epoch;
  *(_OWORD *)(v11 + 24) = *(_OWORD *)&time[1].value;
  *(_OWORD *)(v11 + 40) = v13;
  long long v14 = *(_OWORD *)&time[2].timescale;
  time[2].epoch = 0;
  *(void *)&time[2].timescale = 0;
  long long v15 = *(std::__shared_weak_count **)(v11 + 64);
  *(_OWORD *)(v11 + 56) = v14;
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  long long v16 = *(_OWORD *)&time[3].value;
  *(void *)&time[3].timescale = 0;
  time[3].value = 0;
  uint64_t v17 = *(std::__shared_weak_count **)(v11 + 80);
  *(_OWORD *)(v11 + 72) = v16;
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  unint64_t v18 = *(__CVBuffer **)(v11 + 88);
  if (v18)
  {
    CVPixelBufferRelease(v18);
    *(void *)(v11 + 88) = 0;
  }
  *(void *)(v11 + 88) = time[3].epoch;
  time[3].epoch = 0;
  *(void *)(v11 + 104) = *((void *)&v35 + 1);
  if ((CMTime *)v11 != time)
  {
    long long v19 = v36[0];
    long long v20 = v36[1];
    *(_DWORD *)(v11 + 144) = v36[2];
    *(_OWORD *)(v11 + 112) = v19;
    *(_OWORD *)(v11 + 128) = v20;
    long long v21 = *(_OWORD *)((char *)&v36[2] + 4);
    long long v22 = *(_OWORD *)((char *)&v36[3] + 4);
    *(_DWORD *)(v11 + 180) = DWORD1(v36[4]);
    *(_OWORD *)(v11 + 164) = v22;
    *(_OWORD *)(v11 + 148) = v21;
    uint64_t v23 = *((void *)&v36[4] + 1);
    *(_DWORD *)(v11 + 192) = v37;
    *(void *)(v11 + 184) = v23;
  }
  uint64_t v24 = *(__CVBuffer **)(v11 + 200);
  if (v24)
  {
    CVPixelBufferRelease(v24);
    *(void *)(v11 + 200) = 0;
  }
  *(void *)(v11 + 200) = *((void *)&v37 + 1);
  *((void *)&v37 + 1) = 0;
  *(void *)(v11 + 216) = *((void *)&v38 + 1);
  if ((CMTime *)v11 != time)
  {
    long long v25 = v39[0];
    long long v26 = v39[1];
    *(_DWORD *)(v11 + 256) = v39[2];
    *(_OWORD *)(v11 + 224) = v25;
    *(_OWORD *)(v11 + 240) = v26;
    long long v27 = *(_OWORD *)((char *)&v39[2] + 4);
    long long v28 = *(_OWORD *)((char *)&v39[3] + 4);
    *(_DWORD *)(v11 + 292) = DWORD1(v39[4]);
    *(_OWORD *)(v11 + 276) = v28;
    *(_OWORD *)(v11 + 260) = v27;
    uint64_t v29 = *((void *)&v39[4] + 1);
    *(_DWORD *)(v11 + 304) = v39[5];
    *(void *)(v11 + 296) = v29;
  }
  *(_OWORD *)(v11 + 312) = *(_OWORD *)((char *)&v39[5] + 8);
  v30 = *(void **)(v11 + 328);
  if (v30)
  {
    *(void *)(v11 + 336) = v30;
    operator delete(v30);
    *(void *)(v11 + 328) = 0;
    *(void *)(v11 + 336) = 0;
    *(void *)(v11 + 344) = 0;
  }
  *(void *)(v11 + 328) = *((void *)&v39[6] + 1);
  *(_OWORD *)(v11 + 336) = v39[7];
  memset((char *)&v39[6] + 8, 0, 40);
  v31 = *(std::__shared_weak_count **)(v11 + 360);
  *(_OWORD *)(v11 + 352) = v39[8];
  if (v31)
  {
    if (!atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  long long v32 = v39[9];
  *(_DWORD *)(v11 + 383) = *(_DWORD *)((char *)&v39[9] + 15);
  *(_OWORD *)(v11 + 368) = v32;
  sub_1D0E399B4((uint64_t)time);
  return 4294944346;
}

void sub_1D0DC5AD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  sub_1D0E399B4(v31);
  MEMORY[0x1D25F16B0](a31, 0x10E0C40B4202082);
  _Unwind_Resume(a1);
}

uint64_t CVAFaceTrackingLiteProcessSecondary(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 4294944343;
  }
  uint64_t v1 = **(void **)(a1 + 16);
  unsigned int v2 = atomic_exchange((atomic_uint *volatile)(*(void *)v1 + 648), 0);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  int v3 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v2;
    _os_log_impl(&dword_1D0DBD000, v3, OS_LOG_TYPE_INFO, "processSecondary called after %u frame(s)", buf, 8u);
  }
  uint64_t v4 = *(void *)(*(void *)v1 + 392);
  *(void *)buf = 0;
  uint64_t v12 = 0;
  uint64_t v5 = v4 + 8;
  while ((sub_1D0E743F8(v5, buf, 0, 0) & 1) != 0)
  {
    uint64_t v9 = 0;
    long long v10 = 0;
    (*(void (**)(void, uint64_t *))(**(void **)buf + 16))(*(void *)buf, &v9);
    v6 = v10;
    if (v10)
    {
      if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  v7 = v12;
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return 0;
}

uint64_t CVAFaceTrackingLiteGetOutput(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = ***(void ***)(result + 16);
    if (*(unsigned char *)(v1 + 592)) {
      return v1 + 448;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CVAFaceTrackingLiteGetOpaqueOutput(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = ***(void ***)(result + 16);
    if (*(unsigned char *)(v1 + 440)) {
      return v1 + 416;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CVAFaceTrackingLiteCopyDecodedOutput(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t result = 4294944343;
  if (a1 && a2 && a3 && !*a2)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)v9, Mutable);
    cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)&v11);
    int v5 = *(_DWORD *)(a1 + 12);
    *(void *)&v12.timescale = 8;
    memptr[0] = 0;
    uint64_t v6 = *(void *)(a1 + 4);
    malloc_type_posix_memalign(memptr, 0x20uLL, 0x20uLL, 0x49090899uLL);
    v7 = memptr[0];
    v12.value = (CMTimeValue)memptr[0];
    LODWORD(v12.epoch) = 3;
    *(void *)memptr[0] = v6;
    v7[2] = v5;
    cva::ItemHandler::createVector<unsigned int>();
  }
  return result;
}

uint64_t CVAFaceTrackingGetTypeID()
{
  if (qword_1EB9F1628 != -1) {
    dispatch_once(&qword_1EB9F1628, &unk_1F26F5568);
  }
  return qword_1EB9F1638;
}

uint64_t sub_1D0DC6B1C()
{
  qword_1EB9F1640 = 0;
  *(void *)algn_1EB9F1648 = "CVAFaceTracking";
  qword_1EB9F1650 = (uint64_t)sub_1D0DC72A0;
  unk_1EB9F1658 = 0;
  qword_1EB9F1668 = 0;
  unk_1EB9F1670 = 0;
  qword_1EB9F1660 = (uint64_t)sub_1D0DC6C34;
  qword_1EB9F1678 = (uint64_t)sub_1D0DC6BE4;
  qword_1EB9F1680 = (uint64_t)sub_1D0DC6B94;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EB9F1638 = result;
  return result;
}

CFStringRef sub_1D0DC6B94(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CVAFaceTracking %p [%p]>", a1, v3);
}

CFStringRef sub_1D0DC6BE4(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CVAFaceTracking %p [%p]>", a1, v3);
}

void sub_1D0DC6C34(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  CFAllocatorRef v2 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = 134217984;
    uint64_t v4 = a1;
    _os_log_impl(&dword_1D0DBD000, v2, OS_LOG_TYPE_DEFAULT, "Finalizing FaceTracking (%p).", (uint8_t *)&v3, 0xCu);
  }
  if (a1)
  {
    *(void *)(a1 + 16) = 0;
    operator new();
  }
}

uint64_t sub_1D0DC6DB0(uint64_t a1)
{
  CFAllocatorRef v2 = std::__thread_local_data();
  int v3 = *(const void **)a1;
  *(void *)a1 = 0;
  pthread_setspecific(v2->__key_, v3);
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    uint64_t v5 = (id)qword_1EB9F1620;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v24 = 0;
      _os_log_impl(&dword_1D0DBD000, v5, OS_LOG_TYPE_DEFAULT, "~FaceKit", v24, 2u);
    }

    uint64_t v6 = *v4;
    uint64_t *v4 = 0;
    if (v6)
    {
      std::mutex::lock((std::mutex *)(v6 + 56));
      *(unsigned char *)(v6 + 168) = 1;
      std::mutex::unlock((std::mutex *)(v6 + 56));
      uint64_t v7 = *(void *)(v6 + 8);
      uint64_t v8 = **(void **)(v7 + 8);
      std::mutex::lock((std::mutex *)(v8 + 16));
      *(unsigned char *)(v8 + 128) = 1;
      std::mutex::unlock((std::mutex *)(v8 + 16));
      unint64_t v9 = *(void *)(*(void *)(v7 + 8) + 24) - *(void *)(*(void *)(v7 + 8) + 16);
      if ((int)(v9 >> 4) >= 1)
      {
        uint64_t v10 = 0;
        uint64_t v11 = v9 & 0xFFFFFFFF0;
        do
        {
          sub_1D0E78DA0(*(void *)(*(void *)(*(void *)(v7 + 8) + 16) + v10), 1);
          v10 += 16;
        }
        while (v11 != v10);
      }
      *(void *)(v6 + 40) = &unk_1F26F37F8;
      if (*(void *)(v6 + 192))
      {
        uint64_t v12 = *(void *)(v6 + 176);
        uint64_t v13 = *(uint64_t **)(v6 + 184);
        uint64_t v14 = *v13;
        *(void *)(v14 + 8) = *(void *)(v12 + 8);
        **(void **)(v12 + 8) = v14;
        *(void *)(v6 + 192) = 0;
        if (v13 != (uint64_t *)(v6 + 176))
        {
          do
          {
            long long v15 = (uint64_t *)v13[1];
            long long v16 = (std::__shared_weak_count *)v13[3];
            if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
              std::__shared_weak_count::__release_weak(v16);
            }
            operator delete(v13);
            uint64_t v13 = v15;
          }
          while (v15 != (uint64_t *)(v6 + 176));
        }
      }
      std::condition_variable::~condition_variable((std::condition_variable *)(v6 + 120));
      std::mutex::~mutex((std::mutex *)(v6 + 56));
      uint64_t v17 = *(std::__shared_weak_count **)(v6 + 32);
      if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
      unint64_t v18 = *(std::__shared_weak_count **)(v6 + 16);
      if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
      long long v19 = *(uint64_t **)v6;
      *(void *)uint64_t v6 = 0;
      if (v19)
      {
        long long v20 = sub_1D0E09C1C(v19);
        MEMORY[0x1D25F16B0](v20, 0x20C4093837F09);
      }
      MEMORY[0x1D25F16B0](v6, 0x10A0C401DB96910);
    }
    MEMORY[0x1D25F16B0](v4, 0x20C4093837F09);
  }
  long long v21 = *(const void **)a1;
  *(void *)a1 = 0;
  if (v21)
  {
    uint64_t v22 = MEMORY[0x1D25F1470]();
    MEMORY[0x1D25F16B0](v22, 0x20C4093837F09);
  }
  MEMORY[0x1D25F16B0](a1, 0x20C40A4A59CD2);
  return 0;
}

void sub_1D0DC711C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) = &unk_1F26F37F8;
  if (*(void *)(v1 + 192))
  {
    uint64_t v4 = *(void *)(v1 + 176);
    uint64_t v5 = *(uint64_t **)(v1 + 184);
    uint64_t v6 = *v5;
    *(void *)(v6 + 8) = *(void *)(v4 + 8);
    **(void **)(v4 + 8) = v6;
    *(void *)(v1 + 192) = 0;
    if (v5 != (uint64_t *)(v1 + 176))
    {
      do
      {
        uint64_t v11 = (uint64_t *)v5[1];
        uint64_t v12 = (std::__shared_weak_count *)v5[3];
        if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
        operator delete(v5);
        uint64_t v5 = v11;
      }
      while (v11 != (uint64_t *)(v1 + 176));
    }
  }
  std::condition_variable::~condition_variable((std::condition_variable *)(v1 + 120));
  std::mutex::~mutex(v2);
  uint64_t v7 = *(std::__shared_weak_count **)(v1 + 32);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(v1 + 16);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  unint64_t v9 = *(uint64_t **)v1;
  *(void *)uint64_t v1 = 0;
  if (v9)
  {
    uint64_t v10 = sub_1D0E09C1C(v9);
    MEMORY[0x1D25F16B0](v10, 0x20C4093837F09);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DC72A0(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t CVAFaceTrackingGetAPIVersion()
{
  return 38;
}

uint64_t CVAFaceTrackingCreate(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    if (qword_1EB9F1628 != -1) {
      dispatch_once(&qword_1EB9F1628, &unk_1F26F5568);
    }
    if (_CFRuntimeCreateInstance())
    {
      if (!a2)
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1610))
        {
          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
          __cxa_guard_release(&qword_1EB9F1610);
        }
        uint64_t v12 = qword_1EB9F1620;
        if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1D0DBD000, v12, OS_LOG_TYPE_DEFAULT, "Creating FaceKit with *default* options (user has given no options).", buf, 2u);
        }
LABEL_64:
        operator new();
      }
      CFStringRef v4 = CFCopyDescription(a2);
      CStringPtr = CFStringGetCStringPtr(v4, 0x8000100u);
      size_t v6 = strlen(CStringPtr);
      if (v6 >= 0x7FFFFFFFFFFFFFF8) {
LABEL_67:
      }
        abort();
      size_t v7 = v6;
      if (v6 >= 0x17)
      {
        uint64_t v13 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v6 | 7) != 0x17) {
          uint64_t v13 = v6 | 7;
        }
        uint64_t v14 = v13 + 1;
        uint64_t v8 = operator new(v13 + 1);
        size_t v36 = v7;
        int64_t v37 = v14 | 0x8000000000000000;
        *(void *)buf = v8;
      }
      else
      {
        HIBYTE(v37) = v6;
        uint64_t v8 = buf;
        if (!v6)
        {
LABEL_24:
          v8[v7] = 0;
          unint64_t v15 = HIBYTE(v37);
          char v16 = HIBYTE(v37);
          unint64_t v18 = *(uint8_t **)buf;
          size_t v17 = v36;
          if (v37 >= 0) {
            long long v19 = buf;
          }
          else {
            long long v19 = *(uint8_t **)buf;
          }
          if (v37 >= 0) {
            size_t v20 = HIBYTE(v37);
          }
          else {
            size_t v20 = v36;
          }
          long long v21 = memchr(v19, 10, v20);
          if (v21) {
            unint64_t v22 = (unint64_t)v21;
          }
          else {
            unint64_t v22 = (unint64_t)&v19[v20];
          }
          if (v22 - (void)v19 == v20 || (uint64_t v23 = (unsigned __int8 *)(v22 + 1), (uint8_t *)(v22 + 1) == &v19[v20]))
          {
            unint64_t v25 = 0x1EB9F1000;
          }
          else
          {
            uint64_t v24 = &v19[v20 + ~v22];
            unint64_t v25 = 0x1EB9F1000uLL;
            do
            {
              int v26 = *v23;
              if (v26 != 10) {
                *(unsigned char *)v22++ = v26;
              }
              ++v23;
              --v24;
            }
            while (v24);
            unint64_t v15 = HIBYTE(v37);
            unint64_t v18 = *(uint8_t **)buf;
            size_t v17 = v36;
            char v16 = HIBYTE(v37);
          }
          if (v16 >= 0) {
            long long v27 = &buf[v15];
          }
          else {
            long long v27 = &v18[v17];
          }
          if (v16 >= 0) {
            long long v28 = buf;
          }
          else {
            long long v28 = v18;
          }
          if (v16 >= 0) {
            unint64_t v29 = v15;
          }
          else {
            unint64_t v29 = v17;
          }
          uint64_t v30 = v22 - (void)v28;
          if (v29 >= v22 - (unint64_t)v28)
          {
            if (&v27[-v22] == (uint8_t *)-1)
            {
              CFStringRef v31 = v4;
              if (v16 < 0)
              {
                size_t v36 = v22 - (void)v28;
              }
              else
              {
                HIBYTE(v37) = v30 & 0x7F;
                unint64_t v18 = buf;
              }
              v18[v30] = 0;
            }
            else
            {
              sub_1D0DC8350(buf, v30, (unint64_t)&v27[-v22]);
              CFStringRef v31 = v4;
            }
            CFRelease(v31);
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EB9F1610))
            {
              *(void *)(v25 + 1568) = os_log_create("com.apple.AppleCVA", "FaceKit");
              __cxa_guard_release(&qword_1EB9F1610);
            }
            long long v32 = *(NSObject **)(v25 + 1568);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              unint64_t v33 = buf;
              if (v37 < 0) {
                unint64_t v33 = *(uint8_t **)buf;
              }
              *(_DWORD *)v34 = 136315138;
              *(void *)&v34[4] = v33;
              _os_log_impl(&dword_1D0DBD000, v32, OS_LOG_TYPE_DEFAULT, "Creating FaceKit with options: %s", v34, 0xCu);
            }
            if (SHIBYTE(v37) < 0) {
              operator delete(*(void **)buf);
            }
            goto LABEL_64;
          }
          goto LABEL_67;
        }
      }
      memmove(v8, CStringPtr, v7);
      goto LABEL_24;
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    uint64_t v11 = qword_1EB9F1620;
    if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v11, OS_LOG_TYPE_ERROR, "out of memory when creating instance.", buf, 2u);
    }
    return 4294944342;
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    unint64_t v9 = qword_1EB9F1620;
    if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v9, OS_LOG_TYPE_ERROR, "invalid argument for handle.", buf, 2u);
    }
    return 4294944343;
  }
}

void sub_1D0DC819C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)&a57);
  cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)&a17);
  sub_1D0E3698C(a11);
  sub_1D0DCA2C0(a16);
  sub_1D0DCA2C0(a12);
  sub_1D0E36A84(v57);
  MEMORY[0x1D25F16B0](v57, 0x10A0C401DB96910);
  _Unwind_Resume(a1);
}

void *sub_1D0DC8350(void *result, uint64_t a2, unint64_t a3)
{
  if (a3)
  {
    int v3 = result;
    int v4 = *((char *)result + 23);
    if (v4 < 0)
    {
      size_t v6 = (void *)*result;
      uint64_t v5 = result[1];
    }
    else
    {
      uint64_t v5 = *((unsigned __int8 *)result + 23);
      size_t v6 = result;
    }
    if (v5 - a2 >= a3) {
      unint64_t v7 = a3;
    }
    else {
      unint64_t v7 = v5 - a2;
    }
    if (v5 - a2 > a3)
    {
      uint64_t result = memmove((char *)v6 + a2, (char *)v6 + a2 + v7, v5 - a2 - v7);
      LOBYTE(v4) = *((unsigned char *)v3 + 23);
    }
    uint64_t v8 = v5 - v7;
    if ((v4 & 0x80) != 0) {
      v3[1] = v8;
    }
    else {
      *((unsigned char *)v3 + 23) = v8 & 0x7F;
    }
    *((unsigned char *)v6 + v8) = 0;
  }
  return result;
}

uint64_t CVAFaceTrackingProcess(uint64_t a1, const __CFDictionary *a2)
{
  if (!a1)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    int v3 = qword_1EB9F1620;
    if (!os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR)) {
      return 4294944343;
    }
    __int16 v9 = 0;
    int v4 = "invalid argument for handle.";
    uint64_t v5 = (uint8_t *)&v9;
    goto LABEL_16;
  }
  if (!a2)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    int v3 = qword_1EB9F1620;
    if (!os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR)) {
      return 4294944343;
    }
    *(_WORD *)buf = 0;
    int v4 = "invalid argument for params.";
    uint64_t v5 = buf;
LABEL_16:
    _os_log_error_impl(&dword_1D0DBD000, v3, OS_LOG_TYPE_ERROR, v4, v5, 2u);
    return 4294944343;
  }
  if (sub_1D0E378E0(*(unsigned char *****)(a1 + 16), a2)) {
    return 0;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  size_t v6 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)unint64_t v7 = 0;
    _os_log_error_impl(&dword_1D0DBD000, v6, OS_LOG_TYPE_ERROR, "frame was not processed.", v7, 2u);
  }
  return 4294944346;
}

uint64_t CVAFaceTrackingCopySemantics(__CFDictionary *a1, void *a2)
{
  if (a2)
  {
    cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)buf, a1);
    sub_1D0E252F0(v9, (cva::DictionaryHandler *)buf);
    int v3 = (std::__shared_weak_count *)v9[1];
    if (v9[0])
    {
      Dictionary = (const void *)cva::DictionaryHandler::getDictionary(v9[0]);
      *a2 = Dictionary;
      CFRetain(Dictionary);
      uint64_t v5 = 0;
      if (!v3)
      {
LABEL_15:
        cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)buf);
        return v5;
      }
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
      unint64_t v7 = qword_1EB9F1620;
      if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v9[0]) = 0;
        _os_log_error_impl(&dword_1D0DBD000, v7, OS_LOG_TYPE_ERROR, "error while creating semantics.", (uint8_t *)v9, 2u);
      }
      uint64_t v5 = 4294944346;
      if (!v3) {
        goto LABEL_15;
      }
    }
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    goto LABEL_15;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  size_t v6 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1D0DBD000, v6, OS_LOG_TYPE_ERROR, "invalid argument for output.", buf, 2u);
  }
  return 4294944343;
}

uint64_t CVAFaceTrackingPostProcessRecordingExt(const __CFDictionary *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9)
{
  int v9 = 0;
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (a3)
    {
      if (a4)
      {
        if (a6)
        {
          if (a7)
          {
            if (a8)
            {
              unint64_t v15 = a5;
              int v9 = (int)a9;
              if (!a5 || a9)
              {
                context = (void *)MEMORY[0x1D25F1DA0]();
                cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)v75, a1);
                id v18 = a2;
                id v19 = a3;
                id v73 = a4;
                id v72 = v15;
                id v20 = a6;
                id v70 = a7;
                id v71 = a8;
                id v69 = a9;
                unint64_t v21 = (int)[v18 length];
                unint64_t v22 = v21 >> 3;
                if ((int)(v21 >> 3) <= 0)
                {
                  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                    && __cxa_guard_acquire(&qword_1EB9F1610))
                  {
                    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                    __cxa_guard_release(&qword_1EB9F1610);
                  }
                  long long v35 = (id)qword_1EB9F1620;
                  if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
                  {
                    int v36 = [v18 length];
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)&buf[4] = v36;
                    _os_log_error_impl(&dword_1D0DBD000, v35, OS_LOG_TYPE_ERROR, "invalid recording (timestamp array incorrect: %d)", buf, 8u);
                  }
                }
                else
                {
                  unint64_t v23 = (int)[v20 length];
                  unint64_t v24 = v23 >> 3;
                  if ((int)(v23 >> 3) <= 0)
                  {
                    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                      && __cxa_guard_acquire(&qword_1EB9F1610))
                    {
                      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                      __cxa_guard_release(&qword_1EB9F1610);
                    }
                    v34 = (id)qword_1EB9F1620;
                    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_error_impl(&dword_1D0DBD000, v34, OS_LOG_TYPE_ERROR, "invalid recording (filtered timestamp array incorrect)", buf, 2u);
                    }
                  }
                  else if ((int)[v18 length] == 8 * v22)
                  {
                    uint64_t v25 = (v21 >> 3);
                    if ((int)[v19 length] == v25 << 6)
                    {
                      if (204 * v25 == (int)[v73 length])
                      {
                        if (v15 && 4 * v25 != (int)[v72 length])
                        {
                          v34 = sub_1D0E53388();
                          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                          {
                            *(_WORD *)buf = 0;
                            _os_log_error_impl(&dword_1D0DBD000, v34, OS_LOG_TYPE_ERROR, "incorrect size of tongue", buf, 2u);
                          }
                        }
                        else
                        {
                          if ((int)[v20 length] == 8 * v24)
                          {
                            uint64_t v26 = [v18 bytes];
                            uint64_t v27 = v26;
                            uint64_t v28 = 0;
                            uint64_t v29 = (v23 >> 3);
                            if ((int)v22 <= 2) {
                              int v30 = 2;
                            }
                            else {
                              int v30 = v22;
                            }
                            uint64_t v31 = 8 * (v30 - 1) - 8;
                            while (v31 != v28)
                            {
                              double v32 = *(double *)(v26 + v28 + 8);
                              if (v32 > *(double *)(v26 + v28))
                              {
                                double v33 = *(double *)(v26 + v28 + 16);
                                v28 += 8;
                                if (v32 < v33) {
                                  continue;
                                }
                              }
                              v34 = sub_1D0E53388();
                              if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                              {
                                *(_WORD *)buf = 0;
                                _os_log_error_impl(&dword_1D0DBD000, v34, OS_LOG_TYPE_ERROR, "invalid timestamps", buf, 2u);
                              }
                              goto LABEL_51;
                            }
                            uint64_t v67 = [v20 bytes];
                            uint64_t v39 = 0;
                            if ((int)v24 <= 2) {
                              int v40 = 2;
                            }
                            else {
                              int v40 = v24;
                            }
                            uint64_t v41 = 8 * (v40 - 1) - 8;
                            while (v41 != v39)
                            {
                              double v42 = *(double *)(v67 + v39 + 8);
                              if (v42 > *(double *)(v67 + v39))
                              {
                                double v43 = *(double *)(v67 + v39 + 16);
                                v39 += 8;
                                if (v42 < v43) {
                                  continue;
                                }
                              }
                              v34 = sub_1D0E53388();
                              if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                              {
                                *(_WORD *)buf = 0;
                                _os_log_error_impl(&dword_1D0DBD000, v34, OS_LOG_TYPE_ERROR, "invalid timestamps", buf, 2u);
                              }
                              goto LABEL_51;
                            }
                            [v70 setLength:v29 << 6];
                            [v71 setLength:(uint64_t)(0x3300000000 * v24) >> 30];
                            [v69 setLength:4 * v29];
                            uint64_t v44 = [v19 bytes];
                            uint64_t v65 = [v73 bytes];
                            if (v15) {
                              unint64_t v15 = (void *)[v72 bytes];
                            }
                            uint64_t v64 = [v70 mutableBytes];
                            uint64_t v63 = [v71 mutableBytes];
                            if (a9) {
                              uint64_t v62 = [v69 mutableBytes];
                            }
                            else {
                              uint64_t v62 = 0;
                            }
                            sub_1D0E22538();
                            sub_1D0E2276C();
                            uint64_t v45 = (uint64_t)v15;
                            uint64_t v61 = v44;
                            sub_1D0E22538();
                            int v46 = *(_DWORD *)(qword_1EB9F15F8 + 236);
                            sub_1D0E22538();
                            double v47 = *(double *)(qword_1EB9F15F8 + 240);
                            sub_1D0E22538();
                            float v48 = *(float *)(qword_1EB9F15F8 + 248);
                            sub_1D0E22538();
                            float v49 = *(float *)(qword_1EB9F15F8 + 252);
                            sub_1D0E22538();
                            float v50 = *(float *)(qword_1EB9F15F8 + 256);
                            sub_1D0E22538();
                            float v51 = *(float *)(qword_1EB9F15F8 + 260);
                            sub_1D0E22538();
                            float v52 = *(float *)(qword_1EB9F15F8 + 264);
                            sub_1D0E22538();
                            float v53 = *(float *)(qword_1EB9F15F8 + 268);
                            if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)v75, @"postprocessing_rotation_std"))
                            {
                              cva::DictionaryHandler::item((uint64_t *)buf, (cva::DictionaryHandler *)v75, @"postprocessing_rotation_std");
                              cva::ItemHandler::getValue<float>();
                            }
                            float v54 = (float)(v52 / 180.0) * 3.1416;
                            if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)v75, @"postprocessing_translation_std"))
                            {
                              cva::DictionaryHandler::item((uint64_t *)buf, (cva::DictionaryHandler *)v75, @"postprocessing_translation_std");
                              cva::ItemHandler::getValue<float>();
                            }
                            if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)v75, @"postprocessing_blendshape_std"))
                            {
                              cva::DictionaryHandler::item((uint64_t *)buf, (cva::DictionaryHandler *)v75, @"postprocessing_blendshape_std");
                              cva::ItemHandler::getValue<float>();
                            }
                            if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)v75, @"postprocessing_blendshape_brow_multiplier"))
                            {
                              cva::DictionaryHandler::item((uint64_t *)buf, (cva::DictionaryHandler *)v75, @"postprocessing_blendshape_brow_multiplier");
                              cva::ItemHandler::getValue<float>();
                            }
                            if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)v75, @"postprocessing_blendshape_eye_multiplier"))
                            {
                              cva::DictionaryHandler::item((uint64_t *)buf, (cva::DictionaryHandler *)v75, @"postprocessing_blendshape_eye_multiplier");
                              cva::ItemHandler::getValue<float>();
                            }
                            if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)v75, @"postprocessing_blendshape_mouth_multiplier"))
                            {
                              cva::DictionaryHandler::item((uint64_t *)buf, (cva::DictionaryHandler *)v75, @"postprocessing_blendshape_mouth_multiplier");
                              cva::ItemHandler::getValue<float>();
                            }
                            if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)v75, @"postprocessing_time_std"))
                            {
                              cva::DictionaryHandler::item((uint64_t *)buf, (cva::DictionaryHandler *)v75, @"postprocessing_time_std");
                              cva::ItemHandler::getValue<double>();
                            }
                            if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)v75, @"postprocessing_kernel_size"))
                            {
                              cva::DictionaryHandler::item((uint64_t *)buf, (cva::DictionaryHandler *)v75, @"postprocessing_kernel_size");
                              cva::ItemHandler::getValue<int>();
                            }
                            *(void *)buf = 0;
                            uint64_t v77 = 0;
                            int v78 = 0;
                            sub_1D0E2CD48(v74);
                            sub_1D0E2BFA0(v74, (uint64_t)buf, v49, v50, v51);
                            sub_1D0DCA2C0((uint64_t)v74);
                            uint64_t v55 = 0;
                            if (v46 >= 0) {
                              int v56 = v46;
                            }
                            else {
                              int v56 = v46 + 1;
                            }
                            uint64_t v57 = (v56 >> 1);
                            v58 = *(char **)buf;
                            uint64_t v66 = v27;
                            do
                            {
                              uint64_t v59 = v57;
                              v60 = v58;
                              sub_1D0E210F4(v66, v65 + v55, v22, 0x33u, v57 * vcvtps_s32_f32(*(float *)&v58[v55]), v24, v67, 0x33u, v47 * *(float *)&v58[v55], v48, v63 + v55);
                              uint64_t v57 = v59;
                              v58 = v60;
                              v55 += 4;
                            }
                            while (v55 != 204);
                            if (v45 && v62)
                            {
                              sub_1D0E210F4(v66, v45, v22, 1u, v59, v24, v67, 1u, v47, v48, v62);
                              LODWORD(v57) = v59;
                            }
                            sub_1D0E21350(v66, v61, v22, v57, v24, v67, v64, v47, v54, v53);
                            free(v60);
                            int v9 = 1;
                            goto LABEL_53;
                          }
                          v34 = sub_1D0E53388();
                          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                          {
                            *(_WORD *)buf = 0;
                            _os_log_error_impl(&dword_1D0DBD000, v34, OS_LOG_TYPE_ERROR, "incorrect size of filtered timestamps", buf, 2u);
                          }
                        }
                      }
                      else
                      {
                        v34 = sub_1D0E53388();
                        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                        {
                          *(_WORD *)buf = 0;
                          _os_log_error_impl(&dword_1D0DBD000, v34, OS_LOG_TYPE_ERROR, "incorrect size of blendshapes", buf, 2u);
                        }
                      }
                    }
                    else
                    {
                      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                        && __cxa_guard_acquire(&qword_1EB9F1610))
                      {
                        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                        __cxa_guard_release(&qword_1EB9F1610);
                      }
                      v34 = (id)qword_1EB9F1620;
                      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_error_impl(&dword_1D0DBD000, v34, OS_LOG_TYPE_ERROR, "incorrect size of pose", buf, 2u);
                      }
                    }
                  }
                  else
                  {
                    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                      && __cxa_guard_acquire(&qword_1EB9F1610))
                    {
                      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                      __cxa_guard_release(&qword_1EB9F1610);
                    }
                    v34 = (id)qword_1EB9F1620;
                    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_error_impl(&dword_1D0DBD000, v34, OS_LOG_TYPE_ERROR, "incorrect size of timestamps", buf, 2u);
                    }
                  }
LABEL_51:
                }
                int v9 = 0;
LABEL_53:

                cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)v75);
              }
            }
          }
        }
      }
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  int64_t v37 = qword_1EB9F1620;
  if (v9)
  {
    uint64_t result = os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO);
    if (result)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1D0DBD000, v37, OS_LOG_TYPE_INFO, "Postprocessing was successful.", buf, 2u);
      return 0;
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v37, OS_LOG_TYPE_ERROR, "Postprocessing was not successful.", buf, 2u);
    }
    return 4294944346;
  }
  return result;
}

void sub_1D0DC935C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,void *a22,void *a23,void *a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,char a29)
{
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)&a29);

  cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)&a27);
  _Unwind_Resume(a1);
}

id CVAFaceTrackingTransformData(void *a1, void *a2)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  context = (void *)MEMORY[0x1D25F1DA0]();
  id v25 = a2;
  id v30 = a1;
  id v29 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  id obj = [v30 allKeys];
  uint64_t v26 = [obj countByEnumeratingWithState:&v43 objects:v55 count:16];
  if (v26)
  {
    uint64_t v28 = *(void *)v44;
    do
    {
      for (uint64_t i = 0; i != v26; ++i)
      {
        if (*(void *)v44 != v28) {
          objc_enumerationMutation(obj);
        }
        double v32 = *(void **)(*((void *)&v43 + 1) + 8 * i);
        if (objc_msgSend(v32, "isEqualToString:", @"DetectedFacesArray", context, v25))
        {
          id v33 = [v30 objectForKeyedSubscript:v32];
          int v40 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA48]), "initWithCapacity:", objc_msgSend(v33, "count"));
          long long v53 = 0u;
          long long v54 = 0u;
          long long v51 = 0u;
          long long v52 = 0u;
          id v34 = v33;
          uint64_t v38 = [v34 countByEnumeratingWithState:&v51 objects:v57 count:16];
          if (!v38) {
            goto LABEL_61;
          }
          uint64_t v36 = *(void *)v52;
          while (1)
          {
            for (uint64_t j = 0; j != v38; ++j)
            {
              if (*(void *)v52 != v36) {
                objc_enumerationMutation(v34);
              }
              int v4 = *(void **)(*((void *)&v51 + 1) + 8 * j);
              id v5 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
              long long v49 = 0u;
              long long v50 = 0u;
              long long v47 = 0u;
              long long v48 = 0u;
              size_t v6 = [v4 allKeys];
              uint64_t v7 = [v6 countByEnumeratingWithState:&v47 objects:v56 count:16];
              if (v7)
              {
                uint64_t v8 = *(void *)v48;
                do
                {
                  for (uint64_t k = 0; k != v7; ++k)
                  {
                    if (*(void *)v48 != v8) {
                      objc_enumerationMutation(v6);
                    }
                    uint64_t v10 = *(void **)(*((void *)&v47 + 1) + 8 * k);
                    if ([v10 isEqualToString:@"AngleInfoRoll"])
                    {
                      id v11 = [v4 objectForKeyedSubscript:@"AngleInfoRoll"];
                      [v11 floatValue];
                      uint64_t v12 = objc_msgSend(NSNumber, "numberWithFloat:");

                      [v5 setObject:v12 forKeyedSubscript:@"AngleInfoRoll"];
LABEL_21:

                      goto LABEL_23;
                    }
                    if ([v10 isEqualToString:@"Rect"])
                    {
                      id v11 = [v4 objectForKeyedSubscript:@"Rect"];
                      uint64_t v12 = (void *)[v11 copy];
                      [v5 setObject:v12 forKeyedSubscript:@"Rect"];
                      goto LABEL_21;
                    }
                    id v11 = [v4 objectForKeyedSubscript:v10];
                    [v5 setObject:v11 forKeyedSubscript:v10];
LABEL_23:
                  }
                  uint64_t v7 = [v6 countByEnumeratingWithState:&v47 objects:v56 count:16];
                }
                while (v7);
              }

              [v40 addObject:v5];
            }
            uint64_t v38 = [v34 countByEnumeratingWithState:&v51 objects:v57 count:16];
            if (!v38)
            {
LABEL_61:

              [v29 setObject:v40 forKeyedSubscript:v32];
              goto LABEL_63;
            }
          }
        }
        if ([v32 isEqualToString:@"tracked_faces"])
        {
          id v35 = [v30 objectForKeyedSubscript:v32];
          int v40 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA48]), "initWithCapacity:", objc_msgSend(v35, "count"));
          long long v53 = 0u;
          long long v54 = 0u;
          long long v51 = 0u;
          long long v52 = 0u;
          id v34 = v35;
          uint64_t v39 = [v34 countByEnumeratingWithState:&v51 objects:v57 count:16];
          if (!v39) {
            goto LABEL_61;
          }
          uint64_t v37 = *(void *)v52;
          while (1)
          {
            for (uint64_t m = 0; m != v39; ++m)
            {
              if (*(void *)v52 != v37) {
                objc_enumerationMutation(v34);
              }
              uint64_t v13 = *(void **)(*((void *)&v51 + 1) + 8 * m);
              id v14 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
              long long v49 = 0u;
              long long v50 = 0u;
              long long v47 = 0u;
              long long v48 = 0u;
              unint64_t v15 = [v13 allKeys];
              uint64_t v16 = [v15 countByEnumeratingWithState:&v47 objects:v56 count:16];
              if (v16)
              {
                uint64_t v17 = *(void *)v48;
                do
                {
                  uint64_t v18 = 0;
                  do
                  {
                    if (*(void *)v48 != v17) {
                      objc_enumerationMutation(v15);
                    }
                    id v19 = *(void **)(*((void *)&v47 + 1) + 8 * v18);
                    if ([v19 isEqualToString:@"AngleInfoRoll"])
                    {
                      id v20 = [v13 objectForKeyedSubscript:@"AngleInfoRoll"];
                      [v20 floatValue];
                      objc_msgSend(NSNumber, "numberWithFloat:");
                      id v21 = (id)objc_claimAutoreleasedReturnValue();

                      [v14 setObject:v21 forKeyedSubscript:@"AngleInfoRoll"];
LABEL_50:

                      goto LABEL_51;
                    }
                    if ([v19 isEqualToString:@"Rect"])
                    {
                      id v20 = [v13 objectForKeyedSubscript:@"Rect"];
                      id v21 = (id)[v20 copy];
                      [v14 setObject:v21 forKeyedSubscript:@"Rect"];
                      goto LABEL_50;
                    }
                    if ([v19 isEqualToString:@"raw_data"])
                    {
                      id v20 = [v13 objectForKeyedSubscript:@"raw_data"];
                      sub_1D0E4F11C(v20);
                      id v21 = (id)objc_claimAutoreleasedReturnValue();
                      [v14 setObject:v21 forKeyedSubscript:@"raw_data"];
                      goto LABEL_50;
                    }
                    if ([v19 isEqualToString:@"smooth_data"])
                    {
                      id v20 = [v13 objectForKeyedSubscript:@"smooth_data"];
                      sub_1D0E4F11C(v20);
                      id v21 = (id)objc_claimAutoreleasedReturnValue();
                      [v14 setObject:v21 forKeyedSubscript:@"smooth_data"];
                      goto LABEL_50;
                    }
                    if ([v19 isEqualToString:@"rgb_camera"])
                    {
                      id v21 = [v13 objectForKeyedSubscript:@"rgb_camera"];
                      [v14 setObject:v21 forKeyedSubscript:@"rgb_camera"];
LABEL_49:
                      id v20 = v21;
                      goto LABEL_50;
                    }
                    if (![v19 isEqualToString:@"identity_coefficients"]
                      && [v19 isEqualToString:@"debug"])
                    {
                      id v21 = [v13 objectForKeyedSubscript:@"debug"];
                      [v14 setObject:v21 forKeyedSubscript:@"debug"];
                      goto LABEL_49;
                    }
                    id v20 = [v13 objectForKeyedSubscript:v19];
                    [v14 setObject:v20 forKeyedSubscript:v19];
LABEL_51:

                    ++v18;
                  }
                  while (v16 != v18);
                  uint64_t v22 = [v15 countByEnumeratingWithState:&v47 objects:v56 count:16];
                  uint64_t v16 = v22;
                }
                while (v22);
              }

              [v40 addObject:v14];
            }
            uint64_t v39 = [v34 countByEnumeratingWithState:&v51 objects:v57 count:16];
            if (!v39) {
              goto LABEL_61;
            }
          }
        }
        id v34 = [v30 objectForKeyedSubscript:v32];
        objc_msgSend(v29, "setObject:forKeyedSubscript:");
LABEL_63:
      }
      uint64_t v26 = [obj countByEnumeratingWithState:&v43 objects:v55 count:16];
    }
    while (v26);
  }

  return v29;
}

void sub_1D0DC9C80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t CVAFaceTrackingMaximumNumberOfTrackedFaces()
{
  return 3;
}

uint64_t CVAViewpointCorrectionGetTypeID()
{
  if (qword_1EA6435C8 != -1) {
    dispatch_once(&qword_1EA6435C8, &unk_1F26F3778);
  }
  return qword_1EA6435D0;
}

uint64_t sub_1D0DC9EF4()
{
  qword_1EA6435D8 = 0;
  unk_1EA6435E0 = "CVAViewpointCorrection";
  qword_1EA6435E8 = (uint64_t)sub_1D0DCA270;
  unk_1EA6435F0 = 0;
  qword_1EA643600 = 0;
  unk_1EA643608 = 0;
  qword_1EA6435F8 = (uint64_t)sub_1D0DCA00C;
  qword_1EA643610 = (uint64_t)sub_1D0DC9FBC;
  qword_1EA643618 = (uint64_t)sub_1D0DC9F6C;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EA6435D0 = result;
  return result;
}

CFStringRef sub_1D0DC9F6C(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CVAViewpointCorrection %p [%p]>", a1, v3);
}

CFStringRef sub_1D0DC9FBC(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CVAViewpointCorrection %p [%p]>", a1, v3);
}

uint64_t sub_1D0DCA00C(uint64_t result)
{
  if (result)
  {
    *(void *)(result + 16) = 0;
    operator new();
  }
  return result;
}

void sub_1D0DCA0D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::thread a10)
{
}

uint64_t sub_1D0DCA150(uint64_t a1)
{
  CFAllocatorRef v2 = std::__thread_local_data();
  CFAllocatorRef v3 = *(const void **)a1;
  *(void *)a1 = 0;
  pthread_setspecific(v2->__key_, v3);
  int v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    id v5 = sub_1D0DE9D48(v4);
    MEMORY[0x1D25F16B0](v5, 0x10A0C40D750F2E3);
  }
  size_t v6 = *(const void **)a1;
  *(void *)a1 = 0;
  if (v6)
  {
    uint64_t v7 = MEMORY[0x1D25F1470]();
    MEMORY[0x1D25F16B0](v7, 0x20C4093837F09);
  }
  MEMORY[0x1D25F16B0](a1, 0x20C40A4A59CD2);
  return 0;
}

void sub_1D0DCA1F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1D0DCA204((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t **sub_1D0DCA204(uint64_t **a1)
{
  CFAllocatorRef v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *v2;
    uint64_t *v2 = 0;
    if (v3)
    {
      uint64_t v4 = MEMORY[0x1D25F1470]();
      MEMORY[0x1D25F16B0](v4, 0x20C4093837F09);
    }
    MEMORY[0x1D25F16B0](v2, 0x20C40A4A59CD2);
  }
  return a1;
}

uint64_t sub_1D0DCA270(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t **sub_1D0DCA278(uint64_t **a1)
{
  CFAllocatorRef v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = sub_1D0DE9D48(v2);
    MEMORY[0x1D25F16B0](v3, 0x10A0C40D750F2E3);
  }
  return a1;
}

uint64_t sub_1D0DCA2C0(uint64_t a1)
{
  CFAllocatorRef v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_1D0DCA330(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    CFAllocatorRef v2 = *(void **)(v1 + 160);
    if (v2)
    {
      *(void *)(v1 + 168) = v2;
      operator delete(v2);
    }
    uint64_t v3 = *(void **)(v1 + 136);
    if (v3)
    {
      *(void *)(v1 + 144) = v3;
      operator delete(v3);
    }
    cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)(v1 + 16));

    JUMPOUT(0x1D25F16B0);
  }
  return result;
}

void sub_1D0DCA3B4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

uint64_t CVAViewpointCorrectionGetAPIVersion()
{
  return 13;
}

uint64_t CVAFaceTrackingLiteFilterGetTypeID()
{
  unint64_t v0 = 0x1EA643000uLL;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA643640, memory_order_acquire) & 1) == 0)
  {
    int v2 = __cxa_guard_acquire(&qword_1EA643640);
    unint64_t v0 = 0x1EA643000;
    if (v2)
    {
      qword_1EA643638 = sub_1D0DCA458();
      __cxa_guard_release(&qword_1EA643640);
      unint64_t v0 = 0x1EA643000;
    }
  }
  return *(void *)(v0 + 1592);
}

uint64_t sub_1D0DCA458()
{
  qword_1EA643650 = 0;
  *(void *)algn_1EA643658 = "CVAFaceTrackingLiteFilter";
  qword_1EA643660 = (uint64_t)sub_1D0DCA5F0;
  unk_1EA643668 = 0;
  qword_1EA643678 = 0;
  unk_1EA643680 = 0;
  qword_1EA643670 = (uint64_t)sub_1D0DCA554;
  qword_1EA643688 = (uint64_t)sub_1D0DCA504;
  qword_1EA643690 = (uint64_t)sub_1D0DCA4B4;
  return _CFRuntimeRegisterClass();
}

CFStringRef sub_1D0DCA4B4(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CVAFaceTrackingLiteFilter %p [%p]>", a1, v3);
}

CFStringRef sub_1D0DCA504(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CVAFaceTrackingLiteFilter %p [%p]>", a1, v3);
}

uint64_t sub_1D0DCA554(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFAllocatorRef v2 = *(uint64_t **)(result + 16);
    if (v2)
    {
      uint64_t v3 = *v2;
      if (*v2)
      {
        uint64_t v4 = *(id **)(v3 + 272);
        if (v4)
        {

          MEMORY[0x1D25F16B0](v4, 0x80C40B8603338);
        }
        MEMORY[0x1D25F16B0](v3, 0x1020C40C68083FBLL);
      }
      uint64_t result = MEMORY[0x1D25F16B0](v2, 0x20C4093837F09);
    }
    *(void *)(v1 + 16) = 0;
  }
  return result;
}

uint64_t sub_1D0DCA5F0(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t CVAFaceTrackingLiteFilterGetAPIVersion()
{
  return 2;
}

uint64_t CVAFaceTrackingLiteFilterCreate(uint64_t a1, void *a2)
{
  if (!a2 || *a2) {
    return 4294944343;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA643640, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA643640))
  {
    qword_1EA643638 = sub_1D0DCA458();
    __cxa_guard_release(&qword_1EA643640);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    return 4294944342;
  }
  uint64_t v4 = (void *)Instance;
  id v5 = operator new(8uLL, MEMORY[0x1E4FBA2D0]);
  if (v5)
  {
    *id v5 = 0;
    operator new();
  }
  v4[2] = 0;
  CFRelease(v4);
  return 4294944342;
}

void sub_1D0DCA764(_Unwind_Exception *a1)
{
  MEMORY[0x1D25F16B0](v1, 0x80C40B8603338);
  _Unwind_Resume(a1);
}

uint64_t CVAFaceTrackingLiteFilterProcess(uint64_t a1, uint64_t a2)
{
  uint64_t result = 4294944343;
  if (a1 && a2)
  {
    if (sub_1D0E4E1E4(*(uint64_t **)(a1 + 16), *(cva::DictionaryHandler **)a2, *(unsigned char *)(a2 + 16))) {
      return 0;
    }
    else {
      return 4294944346;
    }
  }
  return result;
}

uint64_t CVAFaceTrackingLiteFilterProcessVanilla(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v2 = 4294944343;
  if (a1 && a2)
  {
    cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)v5, a2);
    if (sub_1D0E4E1E4(*(uint64_t **)(a1 + 16), (cva::DictionaryHandler *)v5, 0)) {
      uint64_t v2 = 0;
    }
    else {
      uint64_t v2 = 4294944346;
    }
    cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)v5);
  }
  return v2;
}

uint64_t CVAFaceTrackingLiteFilterGetOutput(uint64_t result)
{
  if (result)
  {
    if (*(unsigned char *)(**(void **)(result + 16) + 264)) {
      return **(void **)(result + 16);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CVAFaceTrackingLiteFilterCopyDecodedOutput(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t result = 4294944343;
  if (a1 && a2 && a3 && !*a2)
  {
    cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)v9);
    cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)v8);
    cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)v11);
    int v5 = *((_DWORD *)a1 + 2);
    *(void *)&v12.timescale = 8;
    memptr[0] = 0;
    uint64_t v6 = *a1;
    malloc_type_posix_memalign(memptr, 0x20uLL, 0x20uLL, 0x49090899uLL);
    uint64_t v7 = memptr[0];
    v12.value = (CMTimeValue)memptr[0];
    LODWORD(v12.epoch) = 3;
    *(void *)memptr[0] = v6;
    v7[2] = v5;
    cva::ItemHandler::createVector<unsigned int>();
  }
  return result;
}

uint64_t CVAFaceTrackingLiteFilterClientAccessibilityGetTypeID()
{
  unint64_t v0 = 0x1EA643000uLL;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6436B8, memory_order_acquire) & 1) == 0)
  {
    int v2 = __cxa_guard_acquire(&qword_1EA6436B8);
    unint64_t v0 = 0x1EA643000;
    if (v2)
    {
      qword_1EA6436B0 = sub_1D0DCB070();
      __cxa_guard_release(&qword_1EA6436B8);
      unint64_t v0 = 0x1EA643000;
    }
  }
  return *(void *)(v0 + 1712);
}

uint64_t sub_1D0DCB070()
{
  qword_1EA6436C0 = 0;
  *(void *)algn_1EA6436C8 = "CVAFaceTrackingLiteFilterClientAccessibility";
  qword_1EA6436D0 = (uint64_t)sub_1D0DCB1E8;
  unk_1EA6436D8 = 0;
  qword_1EA6436E8 = 0;
  unk_1EA6436F0 = 0;
  qword_1EA6436E0 = (uint64_t)sub_1D0DCB16C;
  qword_1EA6436F8 = (uint64_t)sub_1D0DCB11C;
  qword_1EA643700 = (uint64_t)sub_1D0DCB0CC;
  return _CFRuntimeRegisterClass();
}

CFStringRef sub_1D0DCB0CC(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CVAFaceTrackingLiteFilterClientAccessibility %p [%p]>", a1, v3);
}

CFStringRef sub_1D0DCB11C(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CVAFaceTrackingLiteFilterClientAccessibility %p [%p]>", a1, v3);
}

uint64_t sub_1D0DCB16C(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFAllocatorRef v2 = *(id ***)(result + 16);
    if (v2)
    {
      CFAllocatorRef v3 = *v2;
      if (*v2)
      {

        MEMORY[0x1D25F16B0](v3, 0x80C40B8603338);
      }
      uint64_t result = MEMORY[0x1D25F16B0](v2, 0x20C4093837F09);
    }
    *(void *)(v1 + 16) = 0;
  }
  return result;
}

uint64_t sub_1D0DCB1E8(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t CVAFaceTrackingLiteFilterClientAccessibilityGetAPIVersion()
{
  return 1;
}

uint64_t CVAFaceTrackingLiteFilterClientAccessibilityCreate(uint64_t a1, void *a2)
{
  if (!a2 || *a2) {
    return 4294944343;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6436B8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6436B8))
  {
    qword_1EA6436B0 = sub_1D0DCB070();
    __cxa_guard_release(&qword_1EA6436B8);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    return 4294944342;
  }
  uint64_t v4 = (void *)Instance;
  int v5 = operator new(8uLL, MEMORY[0x1E4FBA2D0]);
  if (v5)
  {
    *int v5 = 0;
    operator new();
  }
  v4[2] = 0;
  CFRelease(v4);
  return 4294944342;
}

void sub_1D0DCB308(_Unwind_Exception *a1)
{
  MEMORY[0x1D25F16B0](v1, 0x80C40B8603338);
  _Unwind_Resume(a1);
}

uint64_t CVAFaceTrackingLiteFilterClientAccessibilityProcess(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 4294944343;
  if (a1 && a2)
  {
    if (a3)
    {
      sub_1D0E35F28(*(void ****)(a1 + 16), a2, a3);
      return 0;
    }
  }
  return result;
}

uint64_t CVAFaceTrackingLiteFilterClientAccessibilityCopyDecodedOutput(uint64_t a1)
{
  if (a1) {
    return (uint64_t)sub_1D0E36600(a1);
  }
  return a1;
}

void *sub_1D0DCB370(unsigned char *__dst, void *__src, unint64_t a3)
{
  int v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    uint64_t v6 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v6 = a3 | 7;
    }
    uint64_t v7 = v6 + 1;
    uint64_t v8 = operator new(v6 + 1);
    v5[1] = a3;
    v5[2] = v7 | 0x8000000000000000;
    *int v5 = v8;
    int v5 = v8;
  }
  else
  {
    __dst[23] = a3;
  }
  return memmove(v5, __src, a3 + 1);
}

uint64_t CVASegmentationGetTypeID()
{
  if (qword_1EA643720 != -1) {
    dispatch_once(&qword_1EA643720, &unk_1F26F3798);
  }
  return qword_1EA643728;
}

uint64_t sub_1D0DCB450()
{
  qword_1EA643730 = 0;
  *(void *)algn_1EA643738 = "CVASegmentation";
  qword_1EA643740 = (uint64_t)sub_1D0DCB958;
  unk_1EA643748 = 0;
  qword_1EA643758 = 0;
  unk_1EA643760 = 0;
  qword_1EA643750 = (uint64_t)sub_1D0DCB568;
  qword_1EA643768 = (uint64_t)sub_1D0DCB518;
  qword_1EA643770 = (uint64_t)sub_1D0DCB4C8;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EA643728 = result;
  return result;
}

CFStringRef sub_1D0DCB4C8(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CVASegmentation %p [%p]>", a1, v3);
}

CFStringRef sub_1D0DCB518(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CVASegmentation %p [%p]>", a1, v3);
}

uint64_t sub_1D0DCB568(uint64_t result)
{
  if (result)
  {
    *(void *)(result + 16) = 0;
    operator new();
  }
  return result;
}

uint64_t sub_1D0DCB624(uint64_t a1)
{
  CFAllocatorRef v2 = std::__thread_local_data();
  CFAllocatorRef v3 = *(const void **)a1;
  *(void *)a1 = 0;
  pthread_setspecific(v2->__key_, v3);
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    int v5 = (id)qword_1EA6437A0;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)unint64_t v23 = 0;
      _os_log_debug_impl(&dword_1D0DBD000, v5, OS_LOG_TYPE_DEBUG, "~Segmentation", v23, 2u);
    }

    uint64_t v6 = *v4;
    uint64_t *v4 = 0;
    if (v6)
    {
      uint64_t v7 = *(void *)(v6 + 8);
      uint64_t v8 = **(void **)(v7 + 8);
      std::mutex::lock((std::mutex *)(v8 + 16));
      *(unsigned char *)(v8 + 128) = 1;
      std::mutex::unlock((std::mutex *)(v8 + 16));
      unint64_t v9 = *(void *)(*(void *)(v7 + 8) + 24) - *(void *)(*(void *)(v7 + 8) + 16);
      if ((int)(v9 >> 4) >= 1)
      {
        uint64_t v10 = 0;
        uint64_t v11 = v9 & 0xFFFFFFFF0;
        do
        {
          sub_1D0E78DA0(*(void *)(*(void *)(*(void *)(v7 + 8) + 16) + v10), 1);
          v10 += 16;
        }
        while (v11 != v10);
      }
      *(void *)(v6 + 24) = &unk_1F26F4598;
      if (*(void *)(v6 + 176))
      {
        uint64_t v12 = *(void *)(v6 + 160);
        uint64_t v13 = *(uint64_t **)(v6 + 168);
        uint64_t v14 = *v13;
        *(void *)(v14 + 8) = *(void *)(v12 + 8);
        **(void **)(v12 + 8) = v14;
        *(void *)(v6 + 176) = 0;
        if (v13 != (uint64_t *)(v6 + 160))
        {
          do
          {
            unint64_t v15 = (uint64_t *)v13[1];
            uint64_t v16 = (std::__shared_weak_count *)v13[3];
            if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
              std::__shared_weak_count::__release_weak(v16);
            }
            operator delete(v13);
            uint64_t v13 = v15;
          }
          while (v15 != (uint64_t *)(v6 + 160));
        }
      }
      std::condition_variable::~condition_variable((std::condition_variable *)(v6 + 104));
      std::mutex::~mutex((std::mutex *)(v6 + 40));
      uint64_t v17 = *(std::__shared_weak_count **)(v6 + 16);
      if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
      uint64_t v18 = *(uint64_t **)v6;
      *(void *)uint64_t v6 = 0;
      if (v18)
      {
        uint64_t v19 = *v18;
        *uint64_t v18 = 0;
        if (v19)
        {
          sub_1D0DCE830(*(void **)(v19 + 8));
          MEMORY[0x1D25F16B0](v19, 0x1020C4062D53EE8);
        }
        MEMORY[0x1D25F16B0](v18, 0x20C4093837F09);
      }
      MEMORY[0x1D25F16B0](v6, 0x10A0C40F9FBC3BELL);
    }
    MEMORY[0x1D25F16B0](v4, 0x20C4093837F09);
  }
  id v20 = *(const void **)a1;
  *(void *)a1 = 0;
  if (v20)
  {
    uint64_t v21 = MEMORY[0x1D25F1470]();
    MEMORY[0x1D25F16B0](v21, 0x20C4093837F09);
  }
  MEMORY[0x1D25F16B0](a1, 0x20C40A4A59CD2);
  return 0;
}

uint64_t sub_1D0DCB958(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t CVASegmentationGetAPIVersion()
{
  return 7;
}

uint64_t CVASegmentationCreate(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (qword_1EA643720 != -1) {
    dispatch_once(&qword_1EA643720, &unk_1F26F3798);
  }
  if (_CFRuntimeCreateInstance()) {
    operator new();
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437A8))
  {
    qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
    __cxa_guard_release(&qword_1EA6437A8);
  }
  uint64_t v4 = qword_1EA6437A0;
  if (os_log_type_enabled((os_log_t)qword_1EA6437A0, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1D0DBD000, v4, OS_LOG_TYPE_ERROR, "out of memory when creating instance.", buf, 2u);
    if (!a3) {
      return 0;
    }
    goto LABEL_8;
  }
  if (a3) {
LABEL_8:
  }
    *a3 = -22954;
  return 0;
}

void sub_1D0DCC84C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  __cxa_guard_abort(&qword_1EA643798);
  if (a24 < 0) {
    operator delete(__p);
  }
  sub_1D0DCA2C0((uint64_t)&a26);
  if (a33 < 0) {
    operator delete(a28);
  }
  std::mutex::unlock(&stru_1EA6434A0);
  kdebug_trace();
  cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)&a15);
  sub_1D0DD2A48(a10);
  sub_1D0DCA2C0(a11);
  sub_1D0DD2B40(v33);
  MEMORY[0x1D25F16B0](v33, 0x10A0C40F9FBC3BELL);
  _Unwind_Resume(a1);
}

uint64_t CVASegmentationCreateOutputInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    uint64_t v19 = qword_1EA6437A0;
    if (os_log_type_enabled((os_log_t)qword_1EA6437A0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v19, OS_LOG_TYPE_ERROR, "invalid argument for handle.", buf, 2u);
      if (!a5) {
        return 0;
      }
    }
    else if (!a5)
    {
      return 0;
    }
    uint64_t v18 = 0;
    *a5 = -22953;
    return v18;
  }
  uint64_t v6 = *(uint64_t ****)(a1 + 16);
  if (!v6)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    id v20 = qword_1EA6437A0;
    if (os_log_type_enabled((os_log_t)qword_1EA6437A0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v20, OS_LOG_TYPE_ERROR, "invalid state for handle.", buf, 2u);
      if (!a5) {
        return 0;
      }
LABEL_27:
      uint64_t v18 = 0;
      *a5 = -22961;
      return v18;
    }
    if (a5) {
      goto LABEL_27;
    }
    return 0;
  }
  if (a5) {
    *a5 = 0;
  }
  uint64_t v8 = *v6;
  if (!v8)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    uint64_t v21 = (id)qword_1EA6437A0;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v21, OS_LOG_TYPE_ERROR, "Segmentation is not properly initialized", buf, 2u);
    }
    goto LABEL_35;
  }
  unint64_t v9 = *v8;
  if (!*v8)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    uint64_t v21 = (id)qword_1EA6437A0;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v21, OS_LOG_TYPE_ERROR, "Segmentation does nto support the camera type", buf, 2u);
    }
LABEL_35:

    return 0;
  }
  std::mutex::lock(&stru_1EA6434A0);
  uint64_t v10 = *v9;
  if (!*(void *)(*v9 + 16)) {
    goto LABEL_18;
  }
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v11 = v10 + 8;
  uint64_t v12 = v13;
  if (!v13) {
    goto LABEL_18;
  }
  uint64_t v14 = v11;
  do
  {
    int v15 = *(_DWORD *)(v12 + 32);
    BOOL v16 = v15 < (int)a2;
    if (v15 >= (int)a2) {
      uint64_t v17 = (uint64_t *)v12;
    }
    else {
      uint64_t v17 = (uint64_t *)(v12 + 8);
    }
    if (!v16) {
      uint64_t v14 = v12;
    }
    uint64_t v12 = *v17;
  }
  while (*v17);
  if (v14 != v11 && *(_DWORD *)(v14 + 32) <= (int)a2)
  {
    unint64_t v23 = *(uint64_t **)(v14 + 40);
    unint64_t v24 = *(std::__shared_weak_count **)(v14 + 48);
    if (v24) {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v25 = *v23;
    v33[0] = @"camera_type";
    uint64_t v26 = [NSNumber numberWithInt:a2];
    *(void *)buf = v26;
    v33[1] = @"width";
    uint64_t v27 = [NSNumber numberWithInt:*(unsigned int *)(v25 + 16)];
    id v35 = v27;
    v33[2] = @"height";
    uint64_t v28 = [NSNumber numberWithInt:*(unsigned int *)(v25 + 20)];
    uint64_t v36 = v28;
    v33[3] = @"foreground_pixelformat";
    id v29 = [NSNumber numberWithUnsignedInt:*(unsigned int *)(v25 + 24)];
    uint64_t v37 = v29;
    v33[4] = @"segmentation_pixelformat";
    id v30 = [NSNumber numberWithUnsignedInt:*(unsigned int *)(v25 + 28)];
    uint64_t v38 = v30;
    v33[5] = @"requires_depth";
    uint64_t v31 = [NSNumber numberWithBool:*(unsigned __int8 *)(v25 + 32)];
    uint64_t v39 = v31;
    v33[6] = @"supports_foreground";
    double v32 = [NSNumber numberWithBool:*(unsigned __int8 *)(v25 + 33)];
    int v40 = v32;
    uint64_t v18 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:buf forKeys:v33 count:7];

    if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  else
  {
LABEL_18:
    uint64_t v18 = 0;
  }
  std::mutex::unlock(&stru_1EA6434A0);
  return v18;
}

void sub_1D0DCCFE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_1D0DCA2C0((uint64_t)va);
  std::mutex::unlock(&stru_1EA6434A0);
  _Unwind_Resume(a1);
}

uint64_t CVASegmentationProcess(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    uint64_t v4 = qword_1EA6437A0;
    if (!os_log_type_enabled((os_log_t)qword_1EA6437A0, OS_LOG_TYPE_ERROR)) {
      return 4294944343;
    }
    *(_WORD *)buf = 0;
    int v5 = "invalid argument for handle.";
    goto LABEL_24;
  }
  if (!a2)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    uint64_t v4 = qword_1EA6437A0;
    if (!os_log_type_enabled((os_log_t)qword_1EA6437A0, OS_LOG_TYPE_ERROR)) {
      return 4294944343;
    }
    *(_WORD *)buf = 0;
    int v5 = "invalid argument for params.";
LABEL_24:
    _os_log_error_impl(&dword_1D0DBD000, v4, OS_LOG_TYPE_ERROR, v5, buf, 2u);
    return 4294944343;
  }
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    if (*(void *)v2 && *(void *)(***(void ***)v2 + 16))
    {
      CFAllocatorRef v3 = operator new(0x20uLL);
      v3[1] = 0;
      v3[2] = 0;
      *CFAllocatorRef v3 = &unk_1F26F4B48;
      operator new();
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    uint64_t v7 = (id)qword_1EA6437A0;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v7, OS_LOG_TYPE_ERROR, "Segmentation is not properly initialized", buf, 2u);
    }

    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0)
    {
      if (__cxa_guard_acquire(&qword_1EA6437A8))
      {
        qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
        __cxa_guard_release(&qword_1EA6437A8);
      }
    }
    uint64_t v8 = qword_1EA6437A0;
    if (!os_log_type_enabled((os_log_t)qword_1EA6437A0, OS_LOG_TYPE_ERROR)) {
      return 4294944346;
    }
    *(_WORD *)buf = 0;
    unint64_t v9 = "frame was not processed.";
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    uint64_t v8 = qword_1EA6437A0;
    if (!os_log_type_enabled((os_log_t)qword_1EA6437A0, OS_LOG_TYPE_ERROR)) {
      return 4294944346;
    }
    *(_WORD *)buf = 0;
    unint64_t v9 = "invalid segmentation module.";
  }
  _os_log_error_impl(&dword_1D0DBD000, v8, OS_LOG_TYPE_ERROR, v9, buf, 2u);
  return 4294944346;
}

void sub_1D0DCE6A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va2, a7);
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  sub_1D0DCA2C0(v7 - 80);
  sub_1D0DCA2C0((uint64_t)va2);
  sub_1D0DCA2C0((uint64_t)va);
  sub_1D0DCA2C0((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t CVASegmentationDestroy(const void *a1)
{
  if (a1)
  {
    CFRelease(a1);
    return 0;
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    uint64_t v2 = qword_1EA6437A0;
    if (os_log_type_enabled((os_log_t)qword_1EA6437A0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFAllocatorRef v3 = 0;
      _os_log_error_impl(&dword_1D0DBD000, v2, OS_LOG_TYPE_ERROR, "invalid argument for handle.", v3, 2u);
    }
    return 4294944343;
  }
}

void sub_1D0DCE830(void *a1)
{
  if (a1)
  {
    sub_1D0DCE830(*a1);
    sub_1D0DCE830(a1[1]);
    uint64_t v2 = (std::__shared_weak_count *)a1[6];
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete(a1);
  }
}

void sub_1D0DCE8C4(void *a1)
{
  uint64_t v2 = operator new(0x28uLL);
  v2[1] = 0;
  v2[2] = 0;
  void *v2 = &unk_1F26F4B80;
  cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)(v2 + 3));
  *a1 = v2 + 3;
  a1[1] = v2;
  cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)v4);
  uint64_t v6 = 8;
  memptr = 0;
  malloc_type_posix_memalign(&memptr, 0x20uLL, 0x20uLL, 0x49090899uLL);
  CFAllocatorRef v3 = memptr;
  int v5 = memptr;
  int v7 = 3;
  *(void *)memptr = 7;
  v3[2] = 0;
  cva::ItemHandler::createVector<int>();
}

void sub_1D0DCEB28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *a13)
{
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)&a13);
  sub_1D0DCA2C0((uint64_t)&a9);
  cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)&a11);
  sub_1D0DCA2C0(v13);
  _Unwind_Resume(a1);
}

void sub_1D0DCEBB0()
{
}

void sub_1D0DCEBB8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1D0DCEBD4(uint64_t a1)
{
}

void sub_1D0DCEBDC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4B80;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0DCEC30(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4B80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void **sub_1D0DCEC50(void **a1, char *__s)
{
  size_t v4 = strlen(__s);
  return sub_1D0DCEE38(a1, __s, v4);
}

uint64_t *sub_1D0DCEC98(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = a2[2];
      if (*(unsigned char *)(v2 + 24)) {
        break;
      }
      CFAllocatorRef v3 = *(uint64_t **)(v2 + 16);
      uint64_t v4 = *v3;
      if (*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), int v5 = (unsigned char *)(v7 + 24), v8))
        {
          if (*(uint64_t **)v2 == a2)
          {
            uint64_t v9 = (uint64_t *)a2[2];
          }
          else
          {
            uint64_t v9 = *(uint64_t **)(v2 + 8);
            uint64_t v10 = *v9;
            *(void *)(v2 + 8) = *v9;
            if (v10)
            {
              *(void *)(v10 + 16) = v2;
              CFAllocatorRef v3 = *(uint64_t **)(v2 + 16);
            }
            v9[2] = (uint64_t)v3;
            *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = v9;
            *uint64_t v9 = v2;
            *(void *)(v2 + 16) = v9;
            CFAllocatorRef v3 = (uint64_t *)v9[2];
            uint64_t v2 = *v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v14 = *(void *)(v2 + 8);
          *CFAllocatorRef v3 = v14;
          if (v14) {
            *(void *)(v14 + 16) = v3;
          }
          *(void *)(v2 + 16) = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          *(void *)(v2 + 8) = v3;
          v3[2] = v2;
          return result;
        }
      }
      else if (!v4 || (v6 = *(unsigned __int8 *)(v4 + 24), int v5 = (unsigned char *)(v4 + 24), v6))
      {
        if (*(uint64_t **)v2 == a2)
        {
          uint64_t v11 = a2[1];
          *(void *)uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            CFAllocatorRef v3 = *(uint64_t **)(v2 + 16);
          }
          a2[2] = (uint64_t)v3;
          *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = a2;
          a2[1] = v2;
          *(void *)(v2 + 16) = a2;
          CFAllocatorRef v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v12 = (uint64_t *)v3[1];
        uint64_t v13 = *v12;
        v3[1] = *v12;
        if (v13) {
          *(void *)(v13 + 16) = v3;
        }
        v12[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v12;
        *uint64_t v12 = (uint64_t)v3;
        v3[2] = (uint64_t)v12;
        return result;
      }
      *(unsigned char *)(v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *int v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void **sub_1D0DCEE38(void **__dst, void *__src, size_t __len)
{
  LODWORD(v6) = *((char *)__dst + 23);
  if ((v6 & 0x80000000) != 0)
  {
    unint64_t v10 = (unint64_t)__dst[2];
    unint64_t v8 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (__len > v8)
    {
      size_t v11 = 0x7FFFFFFFFFFFFFF7;
      if (0x7FFFFFFFFFFFFFF7 - (v10 & 0x7FFFFFFFFFFFFFFFLL) >= __len - v8)
      {
        uint64_t v9 = *__dst;
        if (v8 > 0x3FFFFFFFFFFFFFF2)
        {
LABEL_15:
          uint64_t v7 = operator new(v11);
          memcpy(v7, __src, __len);
          if (v8 != 22) {
            operator delete(v9);
          }
          __dst[2] = (void *)(v11 | 0x8000000000000000);
          *std::string __dst = v7;
LABEL_23:
          __dst[1] = (void *)__len;
          goto LABEL_24;
        }
LABEL_8:
        unint64_t v12 = 2 * v8;
        if (__len > 2 * v8) {
          unint64_t v12 = __len;
        }
        uint64_t v13 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v12 | 7) != 0x17) {
          uint64_t v13 = v12 | 7;
        }
        if (v12 >= 0x17) {
          size_t v11 = v13 + 1;
        }
        else {
          size_t v11 = 23;
        }
        goto LABEL_15;
      }
LABEL_25:
      abort();
    }
    unint64_t v6 = HIBYTE(v10);
    uint64_t v7 = *__dst;
  }
  else
  {
    uint64_t v7 = __dst;
    if (__len > 0x16)
    {
      if (__len - 0x7FFFFFFFFFFFFFF7 >= 0x800000000000001FLL)
      {
        unint64_t v8 = 22;
        uint64_t v9 = __dst;
        goto LABEL_8;
      }
      goto LABEL_25;
    }
  }
  if (__len)
  {
    memmove(v7, __src, __len);
    LOBYTE(v6) = *((unsigned char *)__dst + 23);
  }
  if ((v6 & 0x80) != 0) {
    goto LABEL_23;
  }
  *((unsigned char *)__dst + 23) = __len & 0x7F;
LABEL_24:
  *((unsigned char *)v7 + __len) = 0;
  return __dst;
}

uint64_t sub_1D0DCEF98(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  *(void *)(result + 24) = 0;
  if (v1)
  {
    uint64_t v2 = *(void **)(v1 + 216);
    if (v2)
    {
      free(v2);
      *(void *)(v1 + 216) = 0;
    }
    CFAllocatorRef v3 = *(__CVBuffer **)(v1 + 184);
    if (v3) {
      CVPixelBufferRelease(v3);
    }
    uint64_t v4 = *(__CVBuffer **)(v1 + 176);
    if (v4) {
      CVPixelBufferRelease(v4);
    }
    int v5 = *(__CVBuffer **)(v1 + 168);
    if (v5) {
      CVPixelBufferRelease(v5);
    }
    unint64_t v6 = *(__CVBuffer **)(v1 + 160);
    if (v6) {
      CVPixelBufferRelease(v6);
    }
    uint64_t v7 = *(__CVBuffer **)(v1 + 152);
    if (v7) {
      CVPixelBufferRelease(v7);
    }
    free(*(void **)(v1 + 128));
    free(*(void **)(v1 + 104));
    *(void *)(v1 + 88) = &unk_1F26F3E28;
    unint64_t v8 = *(OpaqueVTPixelTransferSession **)(v1 + 96);
    if (v8)
    {
      VTPixelTransferSessionInvalidate(v8);
      CFRelease(*(CFTypeRef *)(v1 + 96));
    }
    uint64_t v9 = *(void *)(v1 + 72);
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
    uint64_t v10 = *(void *)(v1 + 80);
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
    size_t v11 = *(__CVBuffer **)(v1 + 64);
    if (v11) {
      CVPixelBufferRelease(v11);
    }
    uint64_t v12 = *(void *)(v1 + 48);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
    uint64_t v13 = *(void *)(v1 + 56);
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    }
    uint64_t v14 = *(__CVBuffer **)(v1 + 40);
    if (v14) {
      CVPixelBufferRelease(v14);
    }
    int v15 = *(std::__shared_weak_count **)(v1 + 8);
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    JUMPOUT(0x1D25F16B0);
  }
  return result;
}

void sub_1D0DCF190(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4B10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0DCF1E4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4B10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0DCF204(void *a1, uint64_t *a2, __CVBuffer ****a3)
{
  uint64_t v264 = *MEMORY[0x1E4F143B8];
  if (!*a3)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    uint64_t v10 = (id)qword_1EA6437A0;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v10, OS_LOG_TYPE_ERROR, "nextData should never be nullptr", buf, 2u);
    }

    sub_1D0DD1828(a1);
  }
  std::mutex::lock(&stru_1EA6434A0);
  unint64_t v6 = *a3;
  uint64_t v7 = **a3;
  unint64_t v8 = *v7;
  if (!*v7)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    size_t v11 = (id)qword_1EA6437A0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v11, OS_LOG_TYPE_ERROR, "color should never be nullptr", buf, 2u);
    }

    sub_1D0DD1828(a1);
  }
  uint64_t v9 = *a2;
  if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)(v7 + 5), @"camera_type"))
  {
    cva::DictionaryHandler::item((uint64_t *)buf, (cva::DictionaryHandler *)(*v6 + 5), @"camera_type");
    cva::ItemHandler::getValue<int>();
  }
  uint64_t v14 = *(void *)(v9 + 8);
  uint64_t v13 = v9 + 8;
  uint64_t v12 = v14;
  if (!v14) {
    goto LABEL_23;
  }
  uint64_t v15 = v13;
  do
  {
    int v16 = *(_DWORD *)(v12 + 32);
    BOOL v17 = v16 < -1;
    if (v16 >= -1) {
      uint64_t v18 = (uint64_t *)v12;
    }
    else {
      uint64_t v18 = (uint64_t *)(v12 + 8);
    }
    if (!v17) {
      uint64_t v15 = v12;
    }
    uint64_t v12 = *v18;
  }
  while (*v18);
  if (v15 == v13 || *(int *)(v15 + 32) > -1) {
LABEL_23:
  }
    uint64_t v15 = v13;
  if (v15 == *a2 + 8)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    unint64_t v24 = (id)qword_1EA6437A0;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v24, OS_LOG_TYPE_ERROR, "segmentation processor should not be called for unsupported camera type", buf, 2u);
    }

    sub_1D0DD1828(a1);
  }
  kdebug_trace();
  CVPixelBufferGetWidth(v8);
  CVPixelBufferGetHeight(v8);
  id v20 = *(__CVBuffer **)(v15 + 40);
  uint64_t v19 = *(atomic_ullong **)(v15 + 48);
  pixelBufferOut[1] = v20;
  pixelBufferOut[2] = (CVPixelBufferRef)v19;
  if (v19) {
    atomic_fetch_add_explicit(v19 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v21 = *(uint64_t **)v20;
  pixelBufferOut[0] = 0;
  uint64_t v22 = *a3;
  unint64_t v23 = (**a3)[2];
  CVPixelBufferRef texture = 0;
  pixelBufferOut[0] = v23;
  CVPixelBufferRef texture = (*v22)[3];
  if (v23)
  {
    CVPixelBufferRetain(v23);
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    uint64_t v25 = (id)qword_1EA6437A0;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl(&dword_1D0DBD000, v25, OS_LOG_TYPE_DEBUG, "segmentation algorithm supports segmentation output, but no segmentation buffer available - creating buffer locally", buf, 2u);
    }

    CVPixelBufferCreate(0, *((int *)v21 + 4), *((int *)v21 + 5), *((_DWORD *)v21 + 7), 0, pixelBufferOut);
    IOSurface = CVPixelBufferGetIOSurface(pixelBufferOut[0]);
    if (IOSurface) {
      IOSurfaceSetValue(IOSurface, (CFStringRef)*MEMORY[0x1E4F2F128], @"AppleCVA:Seg:OutputSeg");
    }
  }
  if (texture)
  {
    CVPixelBufferRetain(texture);
  }
  else
  {
    uint64_t v36 = **(void **)v20;
    if (v36 && *(unsigned char *)(v36 + 65))
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437A8))
      {
        qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
        __cxa_guard_release(&qword_1EA6437A8);
      }
      uint64_t v37 = (id)qword_1EA6437A0;
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_debug_impl(&dword_1D0DBD000, v37, OS_LOG_TYPE_DEBUG, "segmentation algorithm supports foreground color, but no foreground buffer available - creating buffer locally", buf, 2u);
      }

      CVPixelBufferCreate(0, *((int *)v21 + 4), *((int *)v21 + 5), *((_DWORD *)v21 + 6), 0, &texture);
      uint64_t v38 = CVPixelBufferGetIOSurface(texture);
      if (v38) {
        IOSurfaceSetValue(v38, (CFStringRef)*MEMORY[0x1E4F2F128], @"AppleCVA:Seg:OutputFG");
      }
    }
  }
  *a1 = 0;
  a1[1] = 0;
  uint64_t v28 = (uint64_t *)*a3;
  uint64_t v27 = (std::__shared_weak_count *)a3[1];
  uint64_t v252 = (uint64_t)*a3;
  v253 = v27;
  if (v27) {
    atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v28)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    id v35 = (id)qword_1EA6437A0;
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v35, OS_LOG_TYPE_ERROR, "no valid input data", buf, 2u);
    }
    goto LABEL_87;
  }
  id v29 = *(__CVBuffer **)*v28;
  if (!v29)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    id v35 = (id)qword_1EA6437A0;
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v35, OS_LOG_TYPE_ERROR, "no valid buffer for color input", buf, 2u);
    }
    goto LABEL_87;
  }
  destinationBuffer = texture;
  id v30 = *(__CVBuffer **)(*v28 + 8);
  uint64_t v31 = *(uint64_t **)v20;
  uint64_t v32 = **(void **)v20;
  if (v32)
  {
    BOOL v33 = v30 != 0;
    if (*(unsigned char *)(v32 + 64)) {
      BOOL v34 = v30 == 0;
    }
    else {
      BOOL v34 = 0;
    }
    if (v34)
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437A8))
      {
        qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
        __cxa_guard_release(&qword_1EA6437A8);
      }
      id v35 = (id)qword_1EA6437A0;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1D0DBD000, v35, OS_LOG_TYPE_ERROR, "no valid buffer for depth input", buf, 2u);
      }
      goto LABEL_87;
    }
  }
  else
  {
    BOOL v33 = v30 != 0;
  }
  if (pixelBufferOut[0])
  {
    int v40 = *((_DWORD *)v31 + 4);
    int v39 = *((_DWORD *)v31 + 5);
    pixelBuffer = pixelBufferOut[0];
    if (v40 == CVPixelBufferGetWidth(pixelBufferOut[0])
      && v39 == CVPixelBufferGetHeight(pixelBuffer))
    {
      if (!destinationBuffer
        || (int v42 = *(_DWORD *)(*(void *)v20 + 16),
            int v41 = *(_DWORD *)(*(void *)v20 + 20),
            v42 == CVPixelBufferGetWidth(destinationBuffer))
        && v41 == CVPixelBufferGetHeight(destinationBuffer))
      {
        unint64_t v43 = 0x3F80000000000000;
        switch(*(_DWORD *)(*(void *)v20 + 36))
        {
          case 0:
            if (v33) {
              sub_1D0DD249C(v28);
            }
            unsigned int v248 = 0;
            goto LABEL_116;
          case 1:
            unint64_t v43 = 1065353216;
            goto LABEL_105;
          case 3:
            unint64_t v43 = 3212836864;
            goto LABEL_105;
          case 4:
            unint64_t v43 = 0xBF80000000000000;
            goto LABEL_105;
          default:
LABEL_105:
            unsigned int v248 = sub_1D0DD20D4(v28, *(double *)&v43);
            if (v33)
            {
              int v51 = *(_DWORD *)(*(void *)v20 + 36);
              switch(v51)
              {
                case 4:
                  unint64_t v52 = 0xBF80000000000000;
                  break;
                case 3:
                  unint64_t v52 = 3212836864;
                  break;
                case 1:
                  unint64_t v52 = 1065353216;
                  break;
                default:
                  unint64_t v52 = 0x3F80000000000000;
                  break;
              }
              sub_1D0DD2700(v28, *(double *)&v52);
            }
LABEL_116:
            long long v53 = *(CVPixelBufferRef **)v20;
            long long v54 = **(_DWORD ***)v20;
            int v55 = v54[14];
            uint64_t v56 = *(void *)(*(void *)v54 + 8);
            uint64_t v57 = v56 + 40 * v55;
            if (*(char *)(v57 + 23) < 0)
            {
              sub_1D0DCB370(buf, *(void **)v57, *(void *)(v57 + 8));
              long long v53 = *(CVPixelBufferRef **)v20;
            }
            else
            {
              *(_OWORD *)buf = *(_OWORD *)v57;
              *(void *)v263 = *(void *)(v57 + 16);
            }
            *(_OWORD *)&v263[8] = *(_OWORD *)(v56 + 40 * v55 + 24);
            uint64_t v58 = *(unsigned int *)&v263[16];
            uint64_t v59 = *(unsigned int *)&v263[20];
            if (sub_1D0DD6124(v53 + 20, (cva *)*(unsigned int *)&v263[20], *(unsigned int *)&v263[16], 1111970369) == 2)sub_1D0DD6260(*(__CVBuffer **)(*(void *)v20 + 160), @"AppleCVA:Seg:InputTransform"); {
            uint64_t v60 = **(void **)v20;
            }
            if (*(unsigned char *)(v60 + 64))
            {
              sub_1D0DD6EE4((char *)__dst, v60);
              uint64_t v241 = (uint64_t)__dst[0];
              char v244 = HIBYTE(v257);
              int v61 = v258;
              int v62 = DWORD1(v258);
              int v245 = DWORD2(v258);
              uint64_t v246 = HIDWORD(v258);
            }
            else
            {
              uint64_t v241 = 0x796D6D7564;
              char v244 = 5;
              int v245 = -1;
              uint64_t v246 = 0xFFFFFFFFLL;
              int v62 = -1;
              int v61 = -1;
            }
            switch(v248)
            {
              case 3u:
                char v247 = 0;
                int v63 = 1;
                break;
              case 2u:
                char v247 = 0;
                int v63 = 2;
                break;
              case 1u:
                char v247 = 0;
                int v63 = 3;
                break;
              default:
                unsigned int v242 = 0;
                char v247 = 1;
LABEL_132:
                uint64_t v243 = v58;
                uint64_t v64 = *(uint64_t **)v20;
                unsigned int v65 = *(_DWORD *)&v263[16] * *(_DWORD *)&v263[8] * *(_DWORD *)&v263[20] * *(_DWORD *)&v263[12];
                if (*(_DWORD *)(*(void *)v20 + 120) != v65)
                {
                  int v66 = v62;
                  int v67 = v61;
                  sub_1D0DD62B4((uint64_t)(v64 + 13), v65);
                  uint64_t v64 = *(uint64_t **)v20;
                  int v61 = v67;
                  int v62 = v66;
                }
                if (*v64)
                {
                  if (*(unsigned char *)(*v64 + 64) && v33)
                  {
                    unsigned int v69 = v245 * v246 * v62 * v61;
                    if (*((_DWORD *)v64 + 36) != v69)
                    {
                      sub_1D0DD62B4((uint64_t)(v64 + 16), v69);
                      __dst[0] = 0;
                      CVPixelBufferCreateWithBytes(0, (int)v246, v245, 0x66646570u, *(void **)(*(void *)v20 + 128), 4 * (int)v246, 0, 0, 0, __dst);
                      sub_1D0DD6260(__dst[0], @"AppleCVA:Seg:NetworkInputDepth");
                      CVPixelBufferRef v70 = __dst[0];
                      if (__dst[0]) {
                        CVPixelBufferRetain(__dst[0]);
                      }
                      id v71 = *(uint64_t **)v20;
                      id v72 = *(__CVBuffer **)(*(void *)v20 + 152);
                      if (v72)
                      {
                        CVPixelBufferRelease(v72);
                        v71[19] = 0;
                      }
                      v71[19] = (uint64_t)v70;
                      CVPixelBufferRelease(__dst[0]);
                    }
                  }
                }
                kdebug_trace();
                int v44 = sub_1D0DD7AFC((CVPixelBufferRef *)(*(void *)v20 + 40), v248, v29, *(__CVBuffer **)(*(void *)v20 + 160));
                if ((v44 & 1) == 0)
                {
                  id v73 = sub_1D0DD3B1C();
                  if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
                  {
                    LOWORD(__dst[0]) = 0;
                    _os_log_error_impl(&dword_1D0DBD000, v73, OS_LOG_TYPE_ERROR, "invalid image rotation", (uint8_t *)__dst, 2u);
                  }
                }
                kdebug_trace();
                kdebug_trace();
                CVPixelBufferLockBaseAddress(*(CVPixelBufferRef *)(*(void *)v20 + 160), 1uLL);
                BaseAddress = (const char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(*(void *)v20 + 160));
                size_t BytesPerRow = CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(*(void *)v20 + 160));
                int v78 = *(uint64_t **)v20;
                unint64_t v79 = *(void *)(*(void *)v20 + 104);
                BOOL v81 = (int)v243 > 0 && (int)v59 > 0;
                if (*(unsigned char *)(*(void *)v20 + 224))
                {
                  if (v81)
                  {
                    uint64_t v82 = 0;
                    uint64_t v83 = (v59 - 1);
                    uint64_t v84 = 12 * v83 + 12;
                    uint64_t v85 = (4 * v83) | 3;
                    uint64_t v86 = v59 & 0xF;
                    if ((v59 & 0xF) == 0) {
                      uint64_t v86 = 16;
                    }
                    uint64_t v87 = v59 - v86;
                    v88 = BaseAddress;
                    do
                    {
                      if (v59 >= 0x11
                        && (v79 < (unint64_t)&BaseAddress[v85 + BytesPerRow * v82]
                          ? (BOOL v89 = (unint64_t)v88 >= v79 + v84)
                          : (BOOL v89 = 1),
                            v89))
                      {
                        v90 = &v88[4 * v87];
                        v91 = v88;
                        v92 = (float *)v79;
                        uint64_t v93 = v87;
                        do
                        {
                          int8x16x4_t v279 = vld4q_s8(v91);
                          v91 += 64;
                          v270.val[0] = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v279.val[2], (int8x16_t)xmmword_1D0E81410));
                          v270.val[1] = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v279.val[1], (int8x16_t)xmmword_1D0E81410));
                          v270.val[2] = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v279.val[0], (int8x16_t)xmmword_1D0E81410));
                          v274.val[0] = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v279.val[2], (int8x16_t)xmmword_1D0E81400));
                          v274.val[1] = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v279.val[1], (int8x16_t)xmmword_1D0E81400));
                          v274.val[2] = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v279.val[0], (int8x16_t)xmmword_1D0E81400));
                          v94 = v92;
                          vst3q_f32(v94, v274);
                          v94 += 12;
                          vst3q_f32(v94, v270);
                          v265.val[0] = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v279.val[2], (int8x16_t)xmmword_1D0E81420));
                          v265.val[1] = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v279.val[1], (int8x16_t)xmmword_1D0E81420));
                          v265.val[2] = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v279.val[0], (int8x16_t)xmmword_1D0E81420));
                          v95 = v92 + 24;
                          vst3q_f32(v95, v265);
                          v265.val[0] = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v279.val[2], (int8x16_t)xmmword_1D0E81430));
                          v265.val[1] = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v279.val[1], (int8x16_t)xmmword_1D0E81430));
                          v96 = v92 + 36;
                          uint32x4_t v76 = (uint32x4_t)vqtbl1q_s8(v279.val[0], (int8x16_t)xmmword_1D0E81430);
                          v265.val[2] = vcvtq_f32_u32(v76);
                          vst3q_f32(v96, v265);
                          v92 += 48;
                          v93 -= 16;
                        }
                        while (v93);
                        v79 += 12 * v87;
                        int v97 = v87;
                      }
                      else
                      {
                        int v97 = 0;
                        v90 = v88;
                      }
                      int v98 = v59 - v97;
                      v99 = (__int8 *)(v90 + 2);
                      do
                      {
                        v76.i8[0] = *v99;
                        float v100 = (float)v76.u32[0];
                        *(float *)unint64_t v79 = v100;
                        LOBYTE(v100) = *(v99 - 1);
                        float v101 = (float)LODWORD(v100);
                        *(float *)(v79 + 4) = v101;
                        LOBYTE(v101) = *(v99 - 2);
                        *(float *)v76.i32 = (float)LODWORD(v101);
                        *(_DWORD *)(v79 + 8) = v76.i32[0];
                        v79 += 12;
                        v99 += 4;
                        --v98;
                      }
                      while (v98);
                      ++v82;
                      v88 += BytesPerRow;
                    }
                    while (v82 != v243);
                  }
                }
                else if (v81)
                {
                  uint64_t v102 = 0;
                  uint64_t v103 = (v59 - 1);
                  uint64_t v104 = 12 * v103 + 12;
                  uint64_t v105 = (4 * v103) | 3;
                  uint64_t v106 = v59 & 0xF;
                  if ((v59 & 0xF) == 0) {
                    uint64_t v106 = 16;
                  }
                  uint64_t v107 = v59 - v106;
                  float32x4_t v108 = (float32x4_t)vdupq_n_s32(0x3B808081u);
                  v109 = BaseAddress;
                  do
                  {
                    if (v59 >= 0x11
                      && (v79 < (unint64_t)&BaseAddress[v105 + BytesPerRow * v102]
                        ? (BOOL v110 = (unint64_t)v109 >= v79 + v104)
                        : (BOOL v110 = 1),
                          v110))
                    {
                      v111 = &v109[4 * v107];
                      v112 = v109;
                      v113 = (float *)v79;
                      uint64_t v114 = v107;
                      do
                      {
                        int8x16x4_t v283 = vld4q_s8(v112);
                        v112 += 64;
                        v271.val[0] = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v283.val[2], (int8x16_t)xmmword_1D0E81400)), v108);
                        v271.val[1] = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v283.val[1], (int8x16_t)xmmword_1D0E81400)), v108);
                        v271.val[2] = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v283.val[0], (int8x16_t)xmmword_1D0E81400)), v108);
                        v115 = v113;
                        vst3q_f32(v115, v271);
                        v115 += 12;
                        v271.val[0] = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v283.val[2], (int8x16_t)xmmword_1D0E81430)), v108);
                        v275.val[0] = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v283.val[2], (int8x16_t)xmmword_1D0E81420)), v108);
                        v278.val[0] = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v283.val[2], (int8x16_t)xmmword_1D0E81410)), v108);
                        v278.val[1] = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v283.val[1], (int8x16_t)xmmword_1D0E81410)), v108);
                        v278.val[2] = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v283.val[0], (int8x16_t)xmmword_1D0E81410)), v108);
                        vst3q_f32(v115, v278);
                        v275.val[1] = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v283.val[1], (int8x16_t)xmmword_1D0E81420)), v108);
                        v275.val[2] = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v283.val[0], (int8x16_t)xmmword_1D0E81420)), v108);
                        v116 = v113 + 24;
                        vst3q_f32(v116, v275);
                        v271.val[1] = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v283.val[1], (int8x16_t)xmmword_1D0E81430)), v108);
                        v117 = v113 + 36;
                        float32x4_t v77 = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v283.val[0], (int8x16_t)xmmword_1D0E81430));
                        v271.val[2] = vmulq_f32(v77, v108);
                        vst3q_f32(v117, v271);
                        v113 += 48;
                        v114 -= 16;
                      }
                      while (v114);
                      v79 += 12 * v107;
                      int v118 = v107;
                    }
                    else
                    {
                      int v118 = 0;
                      v111 = v109;
                    }
                    int v119 = v59 - v118;
                    v120 = (__int8 *)(v111 + 2);
                    do
                    {
                      v77.i8[0] = *v120;
                      *(float *)&unsigned int v121 = (float)v77.u32[0] * 0.0039216;
                      *(float *)unint64_t v79 = *(float *)&v121;
                      LOBYTE(v121) = *(v120 - 1);
                      *(float *)&unsigned int v122 = (float)v121 * 0.0039216;
                      *(float *)(v79 + 4) = *(float *)&v122;
                      LOBYTE(v122) = *(v120 - 2);
                      v77.f32[0] = (float)v122 * 0.0039216;
                      *(_DWORD *)(v79 + 8) = v77.i32[0];
                      v79 += 12;
                      v120 += 4;
                      --v119;
                    }
                    while (v119);
                    ++v102;
                    v109 += BytesPerRow;
                  }
                  while (v102 != v243);
                }
                CVPixelBufferUnlockBaseAddress((CVPixelBufferRef)v78[20], 1uLL);
                kdebug_trace();
                if (!*(unsigned char *)(**(void **)v20 + 64)) {
                  goto LABEL_202;
                }
                kdebug_trace();
                uint64_t v123 = *(void *)(*(void *)v20 + 128);
                __dst[0] = 0;
                LODWORD(__dst[1]) = v246;
                HIDWORD(__dst[1]) = v245;
                uint64_t v257 = (v246 << 34) | 4;
                *(void *)&long long v258 = v123;
                if (sub_1D0DD1E30(v252))
                {
                  float v124 = sub_1D0DD1F28(v252);
                  float v125 = sub_1D0DD1FB8(v252);
                  __int16 v126 = sub_1D0DD2048(v252);
                  __p = (void *)__PAIR64__(LODWORD(v125), LODWORD(v124));
                  LOWORD(v260) = v126;
                  if (sub_1D0DD6340(v30))
                  {
LABEL_201:
                    kdebug_trace();
LABEL_202:
                    kdebug_trace();
                    v130 = *(uint64_t **)v20;
                    v131 = **(void ***)v20;
                    int v132 = *((unsigned __int8 *)v131 + 64);
                    if (*((unsigned char *)v131 + 64)) {
                      size_t v133 = 16;
                    }
                    else {
                      size_t v133 = 8;
                    }
                    v134 = (__CVBuffer *)operator new(v133);
                    __dst[0] = v134;
                    uint64_t v257 = (uint64_t)v134 + v133;
                    bzero(v134, v133);
                    __dst[1] = (__CVBuffer *)((char *)v134 + v133);
                    *((void *)v134 + *((int *)v131 + 14)) = v130[13];
                    if (v132) {
                      *((void *)v134 + *((int *)v131 + 15)) = v130[16];
                    }
                    int v135 = *((unsigned __int8 *)v131 + 65);
                    if (*((unsigned char *)v131 + 65)) {
                      size_t v136 = 2;
                    }
                    else {
                      size_t v136 = 1;
                    }
                    v137 = operator new(v136 * 8);
                    __p = v137;
                    v261 = &v137[v136];
                    bzero(v137, v136 * 8);
                    v260 = &v137[v136];
                    if (v135)
                    {
                      uint64_t v138 = v131[4];
                      v137[1] = v131[1];
                    }
                    else
                    {
                      uint64_t v138 = v131[1];
                    }
                    void *v137 = v138;
                    (*(void (**)(void, CVPixelBufferRef *, void **, uint64_t))(*(void *)*v131 + 16))(*v131, __dst, &__p, 1);
                    if (__p)
                    {
                      v260 = __p;
                      operator delete(__p);
                    }
                    if (__dst[0])
                    {
                      __dst[1] = __dst[0];
                      operator delete(__dst[0]);
                    }
                    kdebug_trace();
                    uint64_t v139 = **(void **)v20;
                    uint64_t v140 = *(void *)(*(void *)v139 + 32);
                    if (*(unsigned char *)(v139 + 65))
                    {
                      if (*(char *)(v140 + 63) < 0)
                      {
                        sub_1D0DCB370(__dst, *(void **)(v140 + 40), *(void *)(v140 + 48));
                      }
                      else
                      {
                        *(_OWORD *)std::string __dst = *(_OWORD *)(v140 + 40);
                        uint64_t v257 = *(void *)(v140 + 56);
                      }
                      unsigned int v141 = 1;
                    }
                    else if (*(char *)(v140 + 23) < 0)
                    {
                      sub_1D0DCB370(__dst, *(void **)v140, *(void *)(v140 + 8));
                      unsigned int v141 = 0;
                    }
                    else
                    {
                      unsigned int v141 = 0;
                      *(_OWORD *)std::string __dst = *(_OWORD *)v140;
                      uint64_t v257 = *(void *)(v140 + 16);
                    }
                    long long v258 = *(_OWORD *)(v140 + 40 * v141 + 24);
                    uint64_t v142 = SDWORD1(v258);
                    if (SHIBYTE(v257) < 0) {
                      operator delete(__dst[0]);
                    }
                    v143 = (CVPixelBufferRef *)(*(void *)v20 + 168);
                    *(void *)v249 = v142;
                    if (v247)
                    {
                      v144 = pixelBuffer;
                      if (*v143)
                      {
                        CVPixelBufferRelease(*v143);
                        CVPixelBufferRef *v143 = 0;
                        v144 = pixelBuffer;
                      }
                    }
                    else
                    {
                      if (sub_1D0DD6124(v143, (cva *)*(unsigned int *)(*(void *)v20 + 16), *(unsigned int *)(*(void *)v20 + 20), *(unsigned int *)(*(void *)v20 + 28)) == 2)sub_1D0DD6260(*(__CVBuffer **)(*(void *)v20 + 168), @"AppleCVA:Seg:NetworkOutputSeg"); {
                      v144 = *(__CVBuffer **)(*(void *)v20 + 168);
                      }
                    }
                    kdebug_trace();
                    CVPixelBufferLockBaseAddress(v144, 0);
                    int Width = CVPixelBufferGetWidth(v144);
                    int Height = CVPixelBufferGetHeight(v144);
                    unsigned int v147 = CVPixelBufferGetBytesPerRow(v144);
                    v148 = CVPixelBufferGetBaseAddress(v144);
                    v149 = *(float **)(v139 + 8);
                    if (*(unsigned char *)(*(void *)v20 + 224))
                    {
                      v150 = pixelBuffer;
                      if (Height && Width)
                      {
                        for (int i = 0; i != Height; ++i)
                        {
                          v152 = v148;
                          do
                          {
                            float v153 = 255.0;
                            if (*v149 <= 255.0) {
                              float v153 = *v149;
                            }
                            if (*v149 >= 0.0) {
                              float v154 = v153;
                            }
                            else {
                              float v154 = 0.0;
                            }
                            *v152++ = (int)v154;
                            v149 += *(void *)v249;
                          }
                          while (v152 < &v148[Width]);
                          v148 += v147;
                        }
                      }
                    }
                    else
                    {
                      v150 = pixelBuffer;
                      if (Height && Width)
                      {
                        for (int j = 0; j != Height; ++j)
                        {
                          v156 = v148;
                          do
                          {
                            float v157 = 255.0;
                            float v158 = *v149 * 255.0;
                            if (v158 <= 255.0) {
                              float v157 = *v149 * 255.0;
                            }
                            if (v158 >= 0.0) {
                              float v159 = v157;
                            }
                            else {
                              float v159 = 0.0;
                            }
                            *v156++ = (int)v159;
                            v149 += *(void *)v249;
                          }
                          while (v156 < &v148[Width]);
                          v148 += v147;
                        }
                      }
                    }
                    CVPixelBufferUnlockBaseAddress(v144, 0);
                    if ((v247 & 1) == 0
                      && (sub_1D0DD7AFC((CVPixelBufferRef *)(*(void *)v20 + 64), v242, v144, v150) & 1) == 0)
                    {
                      v160 = sub_1D0DD3B1C();
                      if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR))
                      {
                        LOWORD(__dst[0]) = 0;
                        _os_log_error_impl(&dword_1D0DBD000, v160, OS_LOG_TYPE_ERROR, "invalid image rotation", (uint8_t *)__dst, 2u);
                      }

                      int v44 = 0;
                    }
                    kdebug_trace();
                    if (!destinationBuffer || !*(unsigned char *)(**(void **)v20 + 65))
                    {
LABEL_370:
                      if (v244 < 0)
                      {
                        operator delete((void *)v241);
                        if ((v263[7] & 0x80000000) != 0) {
LABEL_374:
                        }
                          operator delete(*(void **)buf);
                      }
                      else if ((v263[7] & 0x80000000) != 0)
                      {
                        goto LABEL_374;
                      }
LABEL_88:
                      if (v253 && !atomic_fetch_add(&v253->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v253->__on_zero_shared)(v253);
                        std::__shared_weak_count::__release_weak(v253);
                        if (v44)
                        {
LABEL_91:
                          kdebug_trace();
                          long long v45 = a3[1];
                          if (v45) {
                            atomic_fetch_add_explicit((atomic_ullong *volatile)v45 + 1, 1uLL, memory_order_relaxed);
                          }
                          sub_1D0DCE8C4(buf);
                        }
                      }
                      else if (v44)
                      {
                        goto LABEL_91;
                      }
                      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
                        && __cxa_guard_acquire(&qword_1EA6437A8))
                      {
                        qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
                        __cxa_guard_release(&qword_1EA6437A8);
                      }
                      long long v46 = (id)qword_1EA6437A0;
                      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_error_impl(&dword_1D0DBD000, v46, OS_LOG_TYPE_ERROR, "segmentation failed", buf, 2u);
                      }

                      sub_1D0DD1828(buf);
                    }
                    kdebug_trace();
                    uint64_t v161 = **(void **)v20;
                    sub_1D0DD7024((char *)__dst, (unsigned char *)v161);
                    uint64_t v162 = HIDWORD(v258);
                    if (SHIBYTE(v257) < 0) {
                      operator delete(__dst[0]);
                    }
                    sub_1D0DD7024((char *)__dst, **(unsigned char ***)v20);
                    uint64_t v163 = DWORD2(v258);
                    if (SHIBYTE(v257) < 0) {
                      operator delete(__dst[0]);
                    }
                    sub_1D0DD7024((char *)__dst, **(unsigned char ***)v20);
                    int v164 = DWORD1(v258);
                    if (SHIBYTE(v257) < 0) {
                      operator delete(__dst[0]);
                    }
                    if (v164 != 3)
                    {
                      v195 = sub_1D0DD3B1C();
                      if (os_log_type_enabled(v195, OS_LOG_TYPE_ERROR))
                      {
                        LOWORD(__dst[0]) = 0;
                        _os_log_error_impl(&dword_1D0DBD000, v195, OS_LOG_TYPE_ERROR, "unsupported number of output color channels", (uint8_t *)__dst, 2u);
                      }
                      goto LABEL_368;
                    }
                    sub_1D0DD6D94((void *)(*(void *)v20 + 192), v162, v163);
                    v165 = *(float **)(v161 + 32);
                    BOOL v167 = (int)v163 > 0 && (int)v162 > 0;
                    if (*(unsigned char *)(*(void *)v20 + 224))
                    {
                      if (v167)
                      {
                        int v168 = 0;
                        float32x4_t v169 = (float32x4_t)vdupq_n_s32(0x437F0000u);
                        *(void *)&long long v170 = -1;
                        *((void *)&v170 + 1) = -1;
                        while (1)
                        {
                          uint64_t v171 = *(void *)(*(void *)v20 + 216);
                          uint64_t v172 = (*(_DWORD *)(*(void *)v20 + 212) * v168);
                          v173 = (float *)(v171 + v172);
                          if (v162 < 0x10) {
                            break;
                          }
                          if (v173 < &v165[3 * (v162 - 1) + 3]
                            && (unint64_t)v165 < v171 + 4 * (unint64_t)(v162 - 1) + 4 + v172)
                          {
                            break;
                          }
                          v173 += v162 & 0xFFFFFFF0;
                          v175 = (char *)(v171 + v172);
                          v176 = v165;
                          uint64_t v177 = v162 & 0xFFFFFFF0;
                          do
                          {
                            v178 = v176;
                            float32x4x3_t v266 = vld3q_f32(v178);
                            v178 += 12;
                            v179 = v176 + 24;
                            v180 = v176 + 36;
                            float32x4x3_t v272 = vld3q_f32(v179);
                            float32x4x3_t v276 = vld3q_f32(v180);
                            float32x4x3_t v268 = vld3q_f32(v178);
                            v281.val[0] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v266.val[0], v169), (int8x16_t)v169, (int8x16_t)v266.val[0]), (int8x16_t)vcltzq_f32(v266.val[0])));
                            v281.val[3] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v276.val[0], v169), (int8x16_t)v169, (int8x16_t)v276.val[0]), (int8x16_t)vcltzq_f32(v276.val[0])));
                            v281.val[2] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v272.val[0], v169), (int8x16_t)v169, (int8x16_t)v272.val[0]), (int8x16_t)vcltzq_f32(v272.val[0])));
                            int8x16_t v181 = vbslq_s8((int8x16_t)vcgtq_f32(v266.val[2], v169), (int8x16_t)v169, (int8x16_t)v266.val[2]);
                            v266.val[0] = (float32x4_t)vcltzq_f32(v266.val[2]);
                            v281.val[1] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v268.val[0], v169), (int8x16_t)v169, (int8x16_t)v268.val[0]), (int8x16_t)vcltzq_f32(v268.val[0])));
                            v284.val[0] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v266.val[1], v169), (int8x16_t)v169, (int8x16_t)v266.val[1]), (int8x16_t)vcltzq_f32(v266.val[1])));
                            v284.val[3] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v276.val[1], v169), (int8x16_t)v169, (int8x16_t)v276.val[1]), (int8x16_t)vcltzq_f32(v276.val[1])));
                            v284.val[2] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v272.val[1], v169), (int8x16_t)v169, (int8x16_t)v272.val[1]), (int8x16_t)vcltzq_f32(v272.val[1])));
                            v284.val[1] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v268.val[1], v169), (int8x16_t)v169, (int8x16_t)v268.val[1]), (int8x16_t)vcltzq_f32(v268.val[1])));
                            int8x16_t v182 = vqtbl4q_s8(v281, (int8x16_t)xmmword_1D0E81440);
                            v266.val[2] = (float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v268.val[2], v169), (int8x16_t)v169, (int8x16_t)v268.val[2]), (int8x16_t)vcltzq_f32(v268.val[2]));
                            int8x16_t v183 = vqtbl4q_s8(v284, (int8x16_t)xmmword_1D0E81440);
                            v268.val[0] = (float32x4_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(v181, (int8x16_t)v266.val[0]));
                            v272.val[0] = (float32x4_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v276.val[2], v169), (int8x16_t)v169, (int8x16_t)v276.val[2]), (int8x16_t)vcltzq_f32(v276.val[2])));
                            v268.val[2] = (float32x4_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v272.val[2], v169), (int8x16_t)v169, (int8x16_t)v272.val[2]), (int8x16_t)vcltzq_f32(v272.val[2])));
                            v268.val[1] = (float32x4_t)vcvtq_u32_f32(v266.val[2]);
                            int8x16_t v184 = vqtbl4q_s8(*(int8x16x4_t *)v272.val[0].f32, (int8x16_t)xmmword_1D0E81440);
                            vst4q_s8(v175, *(int8x16x4_t *)&v170);
                            v175 += 64;
                            v176 += 48;
                            v177 -= 16;
                          }
                          while (v177);
                          v165 += 3 * (v162 & 0xFFFFFFF0);
                          int v185 = v162 & 0xFFFFFFF0;
                          if ((v162 & 0xFFFFFFF0) != v162) {
                            goto LABEL_292;
                          }
LABEL_280:
                          if (++v168 == v163) {
                            goto LABEL_349;
                          }
                        }
                        int v185 = 0;
LABEL_292:
                        int v186 = v162 - v185;
                        do
                        {
                          *(unsigned char *)v173 = -1;
                          float v187 = 255.0;
                          if (*v165 <= 255.0) {
                            float v188 = *v165;
                          }
                          else {
                            float v188 = 255.0;
                          }
                          if (*v165 >= 0.0) {
                            float v189 = v188;
                          }
                          else {
                            float v189 = 0.0;
                          }
                          *((unsigned char *)v173 + 1) = (int)v189;
                          float v190 = v165[1];
                          if (v190 <= 255.0) {
                            float v191 = v165[1];
                          }
                          else {
                            float v191 = 255.0;
                          }
                          if (v190 >= 0.0) {
                            float v192 = v191;
                          }
                          else {
                            float v192 = 0.0;
                          }
                          *((unsigned char *)v173 + 2) = (int)v192;
                          float v193 = v165[2];
                          if (v193 <= 255.0) {
                            float v187 = v165[2];
                          }
                          if (v193 >= 0.0) {
                            float v194 = v187;
                          }
                          else {
                            float v194 = 0.0;
                          }
                          *((unsigned char *)v173 + 3) = (int)v194;
                          v165 += 3;
                          ++v173;
                          --v186;
                        }
                        while (v186);
                        goto LABEL_280;
                      }
                      goto LABEL_349;
                    }
                    if (!v167)
                    {
LABEL_349:
                      v235 = (CVPixelBufferRef *)(*(void *)v20 + 176);
                      if (v247)
                      {
                        v236 = destinationBuffer;
                        if (*v235)
                        {
                          CVPixelBufferRelease(*v235);
                          CVPixelBufferRef *v235 = 0;
                          v236 = destinationBuffer;
                        }
                      }
                      else
                      {
                        if (sub_1D0DD6124((CVPixelBufferRef *)(*(void *)v20 + 176), (cva *)*(unsigned int *)(*(void *)v20 + 16), *(unsigned int *)(*(void *)v20 + 20), *(unsigned int *)(*(void *)v20 + 24)) == 2)sub_1D0DD6260(*(__CVBuffer **)(*(void *)v20 + 176), @"AppleCVA:Seg:NetworkOutputFG"); {
                        v236 = *(__CVBuffer **)(*(void *)v20 + 176);
                        }
                      }
                      CVPixelBufferLockBaseAddress(v236, 0);
                      cva::pixelBufferConvertARGBToYpCbCr();
                      CVPixelBufferUnlockBaseAddress(v236, 0);
                      if (v247) {
                        goto LABEL_369;
                      }
                      double v237 = *(double *)(*(void *)v20 + 16);
                      double v238 = COERCE_DOUBLE(vrev64_s32(*(int32x2_t *)&v237));
                      if ((v242 | 2) == 3) {
                        double v237 = v238;
                      }
                      if (sub_1D0DD6124((CVPixelBufferRef *)(*(void *)v20 + 184), (cva *)LODWORD(v237), HIDWORD(v237), *(unsigned int *)(*(void *)v20 + 24)) == 2)sub_1D0DD6260(*(__CVBuffer **)(*(void *)v20 + 184), @"AppleCVA:Seg:FGInverseTransform"); {
                      if ((sub_1D0DD7AFC((CVPixelBufferRef *)(*(void *)v20 + 64), v242, v236, *(__CVBuffer **)(*(void *)v20 + 184)) & 1) == 0)
                      }
                      {
                        v239 = sub_1D0DD3B1C();
                        if (os_log_type_enabled(v239, OS_LOG_TYPE_ERROR))
                        {
                          LOWORD(__dst[0]) = 0;
                          _os_log_error_impl(&dword_1D0DBD000, v239, OS_LOG_TYPE_ERROR, "invalid image rotation for foreground", (uint8_t *)__dst, 2u);
                        }

                        int v44 = 0;
                      }
                      v240 = *(OpaqueVTPixelTransferSession **)(*(void *)v20 + 96);
                      if (v240)
                      {
                        if (!VTPixelTransferSessionTransferImage(v240, *(CVPixelBufferRef *)(*(void *)v20 + 184), destinationBuffer))goto LABEL_369; {
                      }
                        }
                      v195 = sub_1D0DD3B1C();
                      if (os_log_type_enabled(v195, OS_LOG_TYPE_ERROR))
                      {
                        LOWORD(__dst[0]) = 0;
                        _os_log_error_impl(&dword_1D0DBD000, v195, OS_LOG_TYPE_ERROR, "invalid image scaling for foreground", (uint8_t *)__dst, 2u);
                      }
LABEL_368:

                      int v44 = 0;
LABEL_369:
                      kdebug_trace();
                      goto LABEL_370;
                    }
                    int v196 = 0;
                    long long v197 = xmmword_1D0E81440;
                    float32x4_t v198 = (float32x4_t)vdupq_n_s32(0x437F0000u);
                    *(void *)&long long v199 = -1;
                    *((void *)&v199 + 1) = -1;
                    while (1)
                    {
                      uint64_t v200 = *(void *)(*(void *)v20 + 216);
                      uint64_t v201 = (*(_DWORD *)(*(void *)v20 + 212) * v196);
                      v202 = (float *)(v200 + v201);
                      if (v162 < 0x10) {
                        break;
                      }
                      if (v202 < &v165[3 * (v162 - 1) + 3]
                        && (unint64_t)v165 < v200 + 4 * (unint64_t)(v162 - 1) + 4 + v201)
                      {
                        break;
                      }
                      v202 += v162 & 0xFFFFFFF0;
                      v204 = (char *)(v200 + v201);
                      v205 = v165;
                      uint64_t v206 = v162 & 0xFFFFFFF0;
                      do
                      {
                        v207 = v205;
                        float32x4x3_t v267 = vld3q_f32(v207);
                        v207 += 12;
                        v208 = v205 + 24;
                        v209 = v205 + 36;
                        float32x4x3_t v269 = vld3q_f32(v208);
                        float32x4x3_t v273 = vld3q_f32(v209);
                        int8x16_t v210 = (int8x16_t)v197;
                        float32x4x3_t v277 = vld3q_f32(v207);
                        float32x4_t v211 = vmulq_f32(v269.val[0], v198);
                        float32x4_t v212 = vmulq_f32(v267.val[0], v198);
                        float32x4_t v213 = vmulq_f32(v273.val[0], v198);
                        float32x4_t v214 = vmulq_f32(v277.val[0], v198);
                        int8x16_t v215 = (int8x16_t)vcltzq_f32(v214);
                        v280.val[0] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v212, v198), (int8x16_t)v198, (int8x16_t)v212), (int8x16_t)vcltzq_f32(v212)));
                        v280.val[3] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v213, v198), (int8x16_t)v198, (int8x16_t)v213), (int8x16_t)vcltzq_f32(v213)));
                        float32x4_t v216 = vmulq_f32(v277.val[1], v198);
                        float32x4_t v217 = vmulq_f32(v269.val[1], v198);
                        v280.val[2] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v211, v198), (int8x16_t)v198, (int8x16_t)v211), (int8x16_t)vcltzq_f32(v211)));
                        float32x4_t v218 = vmulq_f32(v273.val[1], v198);
                        float32x4_t v219 = vmulq_f32(v267.val[1], v198);
                        int8x16_t v220 = vbslq_s8((int8x16_t)vcgtq_f32(v214, v198), (int8x16_t)v198, (int8x16_t)v214);
                        v282.val[0] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v219, v198), (int8x16_t)v198, (int8x16_t)v219), (int8x16_t)vcltzq_f32(v219)));
                        v282.val[3] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v218, v198), (int8x16_t)v198, (int8x16_t)v218), (int8x16_t)vcltzq_f32(v218)));
                        v282.val[2] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v217, v198), (int8x16_t)v198, (int8x16_t)v217), (int8x16_t)vcltzq_f32(v217)));
                        v277.val[0] = vmulq_f32(v277.val[2], v198);
                        long long v197 = (__int128)v210;
                        v269.val[0] = vmulq_f32(v269.val[2], v198);
                        v269.val[1] = vmulq_f32(v273.val[2], v198);
                        v267.val[0] = vmulq_f32(v267.val[2], v198);
                        v280.val[1] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(v220, v215));
                        v282.val[1] = (int8x16_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v216, v198), (int8x16_t)v198, (int8x16_t)v216), (int8x16_t)vcltzq_f32(v216)));
                        int8x16_t v221 = vqtbl4q_s8(v280, v210);
                        int8x16_t v222 = vqtbl4q_s8(v282, v210);
                        v269.val[2] = (float32x4_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v267.val[0], v198), (int8x16_t)v198, (int8x16_t)v267.val[0]), (int8x16_t)vcltzq_f32(v267.val[0])));
                        v273.val[2] = (float32x4_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v269.val[1], v198), (int8x16_t)v198, (int8x16_t)v269.val[1]), (int8x16_t)vcltzq_f32(v269.val[1])));
                        v273.val[1] = (float32x4_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v269.val[0], v198), (int8x16_t)v198, (int8x16_t)v269.val[0]), (int8x16_t)vcltzq_f32(v269.val[0])));
                        v273.val[0] = (float32x4_t)vcvtq_u32_f32((float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v277.val[0], v198), (int8x16_t)v198, (int8x16_t)v277.val[0]), (int8x16_t)vcltzq_f32(v277.val[0])));
                        int8x16_t v223 = vqtbl4q_s8(*(int8x16x4_t *)v269.val[2].f32, v210);
                        vst4q_s8(v204, *(int8x16x4_t *)&v199);
                        v204 += 64;
                        v205 += 48;
                        v206 -= 16;
                      }
                      while (v206);
                      v165 += 3 * (v162 & 0xFFFFFFF0);
                      int v224 = v162 & 0xFFFFFFF0;
                      if ((v162 & 0xFFFFFFF0) != v162) {
                        goto LABEL_329;
                      }
LABEL_317:
                      if (++v196 == v163) {
                        goto LABEL_349;
                      }
                    }
                    int v224 = 0;
LABEL_329:
                    int v225 = v162 - v224;
                    do
                    {
                      *(unsigned char *)v202 = -1;
                      float v226 = 255.0;
                      float v227 = *v165 * 255.0;
                      if (v227 <= 255.0) {
                        float v228 = *v165 * 255.0;
                      }
                      else {
                        float v228 = 255.0;
                      }
                      if (v227 >= 0.0) {
                        float v229 = v228;
                      }
                      else {
                        float v229 = 0.0;
                      }
                      *((unsigned char *)v202 + 1) = (int)v229;
                      float v230 = v165[1] * 255.0;
                      if (v230 <= 255.0) {
                        float v231 = v165[1] * 255.0;
                      }
                      else {
                        float v231 = 255.0;
                      }
                      if (v230 >= 0.0) {
                        float v232 = v231;
                      }
                      else {
                        float v232 = 0.0;
                      }
                      *((unsigned char *)v202 + 2) = (int)v232;
                      float v233 = v165[2] * 255.0;
                      if (v233 <= 255.0) {
                        float v226 = v165[2] * 255.0;
                      }
                      if (v233 >= 0.0) {
                        float v234 = v226;
                      }
                      else {
                        float v234 = 0.0;
                      }
                      *((unsigned char *)v202 + 3) = (int)v234;
                      v165 += 3;
                      ++v202;
                      --v225;
                    }
                    while (v225);
                    goto LABEL_317;
                  }
                  v127 = sub_1D0DD3B1C();
                  if (!os_log_type_enabled(v127, OS_LOG_TYPE_ERROR))
                  {
LABEL_200:

                    int v44 = 0;
                    goto LABEL_201;
                  }
                  LOWORD(__p) = 0;
                }
                else
                {
                  float v128 = sub_1D0DD1E98(v252);
                  float v129 = 1.0 / *(float *)(*(void *)v20 + 232);
                  if (*(unsigned char *)(*(void *)v20 + 224)) {
                    float v129 = v129 * 255.0;
                  }
                  __p = (void *)__PAIR64__(*(_DWORD *)(*(void *)v20 + 228), LODWORD(v128));
                  *(float *)&v260 = v129;
                  if (sub_1D0DD6890(v30)) {
                    goto LABEL_201;
                  }
                  v127 = sub_1D0DD3B1C();
                  if (!os_log_type_enabled(v127, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_200;
                  }
                  LOWORD(__p) = 0;
                }
                _os_log_error_impl(&dword_1D0DBD000, v127, OS_LOG_TYPE_ERROR, "invalid depth resampling", (uint8_t *)&__p, 2u);
                goto LABEL_200;
            }
            unsigned int v242 = v63;
            goto LABEL_132;
        }
      }
      id v35 = sub_1D0DD3B1C();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1D0DBD000, v35, OS_LOG_TYPE_ERROR, "invalid foreground buffer size", buf, 2u);
      }
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437A8))
      {
        qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
        __cxa_guard_release(&qword_1EA6437A8);
      }
      id v35 = (id)qword_1EA6437A0;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        int v47 = CVPixelBufferGetWidth(pixelBuffer);
        int v48 = CVPixelBufferGetHeight(pixelBuffer);
        int v50 = *(_DWORD *)(*(void *)v20 + 16);
        int v49 = *(_DWORD *)(*(void *)v20 + 20);
        *(_DWORD *)buf = 67109888;
        *(_DWORD *)&buf[4] = v47;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v48;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)v263 = v50;
        *(_WORD *)&v263[4] = 1024;
        *(_DWORD *)&v263[6] = v49;
        _os_log_error_impl(&dword_1D0DBD000, v35, OS_LOG_TYPE_ERROR, "invalid segmentation buffer size (%d %d vs %d %d)", buf, 0x1Au);
      }
    }
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    id v35 = (id)qword_1EA6437A0;
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v35, OS_LOG_TYPE_ERROR, "no valid buffer for segmentation output", buf, 2u);
    }
  }
LABEL_87:

  int v44 = 0;
  goto LABEL_88;
}

void sub_1D0DD15C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, int a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (v29)
  {
    CVPixelBufferRelease(v29);
    if (a15 < 0)
    {
LABEL_3:
      operator delete(__p);
      if ((*(char *)(v30 - 185) & 0x80000000) == 0) {
        goto LABEL_8;
      }
LABEL_7:
      operator delete(*(void **)(v30 - 208));
LABEL_8:
      sub_1D0DCA2C0((uint64_t)&a24);
      sub_1D0DCA2C0(v28);
      sub_1D0DCA2C0((uint64_t)&a28);
      kdebug_trace();
      std::mutex::unlock(&stru_1EA6434A0);
      _Unwind_Resume(a1);
    }
  }
  else if (a15 < 0)
  {
    goto LABEL_3;
  }
  if ((*(char *)(v30 - 185) & 0x80000000) == 0) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

void sub_1D0DD1828(void *a1)
{
  uint64_t v2 = operator new(0x28uLL);
  v2[1] = 0;
  v2[2] = 0;
  void *v2 = &unk_1F26F4B80;
  cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)(v2 + 3));
  *a1 = v2 + 3;
  a1[1] = v2;
  cva::ItemHandler::createValue<std::string>();
}

void sub_1D0DD18F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)&a16);
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1D0DCA2C0(v16);
  _Unwind_Resume(a1);
}

void sub_1D0DD1928(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

__n128 sub_1D0DD1940(uint64_t a1)
{
  cva::DictionaryHandler::item(v6, (cva::DictionaryHandler *)(a1 + 40), @"color_camera_x_direction");
  CFDataRef Data = (const __CFData *)cva::ItemHandler::getData((cva::ItemHandler *)v6);
  CFDataRef v2 = Data;
  long long v5 = 0u;
  if (Data)
  {
    if (CFDataGetLength(Data) == 16)
    {
      *(_DWORD *)&buffer[8] = 0;
      *(void *)buffer = 0;
      v8.location = 0;
      v8.length = 16;
      CFDataGetBytes(v2, v8, buffer);
      long long v5 = *(_OWORD *)buffer;
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437A8))
      {
        qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
        __cxa_guard_release(&qword_1EA6437A8);
      }
      CFAllocatorRef v3 = (id)qword_1EA6437A0;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buffer = 0;
        _os_log_error_impl(&dword_1D0DBD000, v3, OS_LOG_TYPE_ERROR, "direction size should be of std::string::size_type size = sizeof(vector_float3)", buffer, 2u);
      }
    }
  }
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v6);
  return (__n128)v5;
}

void sub_1D0DD1A68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)va);
  _Unwind_Resume(a1);
}

__n128 sub_1D0DD1A7C(uint64_t a1)
{
  cva::DictionaryHandler::item(v6, (cva::DictionaryHandler *)(a1 + 40), @"color_camera_y_direction");
  CFDataRef Data = (const __CFData *)cva::ItemHandler::getData((cva::ItemHandler *)v6);
  CFDataRef v2 = Data;
  long long v5 = 0u;
  if (Data)
  {
    if (CFDataGetLength(Data) == 16)
    {
      *(_DWORD *)&buffer[8] = 0;
      *(void *)buffer = 0;
      v8.location = 0;
      v8.length = 16;
      CFDataGetBytes(v2, v8, buffer);
      long long v5 = *(_OWORD *)buffer;
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437A8))
      {
        qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
        __cxa_guard_release(&qword_1EA6437A8);
      }
      CFAllocatorRef v3 = (id)qword_1EA6437A0;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buffer = 0;
        _os_log_error_impl(&dword_1D0DBD000, v3, OS_LOG_TYPE_ERROR, "direction size should be of std::string::size_type size = sizeof(vector_float3)", buffer, 2u);
      }
    }
  }
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v6);
  return (__n128)v5;
}

void sub_1D0DD1BA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)va);
  _Unwind_Resume(a1);
}

__n128 sub_1D0DD1BB8(uint64_t a1)
{
  cva::DictionaryHandler::item(v6, (cva::DictionaryHandler *)(a1 + 40), @"depth_camera_x_direction");
  CFDataRef Data = (const __CFData *)cva::ItemHandler::getData((cva::ItemHandler *)v6);
  CFDataRef v2 = Data;
  long long v5 = 0u;
  if (Data)
  {
    if (CFDataGetLength(Data) == 16)
    {
      *(_DWORD *)&buffer[8] = 0;
      *(void *)buffer = 0;
      v8.location = 0;
      v8.length = 16;
      CFDataGetBytes(v2, v8, buffer);
      long long v5 = *(_OWORD *)buffer;
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437A8))
      {
        qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
        __cxa_guard_release(&qword_1EA6437A8);
      }
      CFAllocatorRef v3 = (id)qword_1EA6437A0;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buffer = 0;
        _os_log_error_impl(&dword_1D0DBD000, v3, OS_LOG_TYPE_ERROR, "direction size should be of std::string::size_type size = sizeof(vector_float3)", buffer, 2u);
      }
    }
  }
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v6);
  return (__n128)v5;
}

void sub_1D0DD1CE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)va);
  _Unwind_Resume(a1);
}

__n128 sub_1D0DD1CF4(uint64_t a1)
{
  cva::DictionaryHandler::item(v6, (cva::DictionaryHandler *)(a1 + 40), @"depth_camera_y_direction");
  CFDataRef Data = (const __CFData *)cva::ItemHandler::getData((cva::ItemHandler *)v6);
  CFDataRef v2 = Data;
  long long v5 = 0u;
  if (Data)
  {
    if (CFDataGetLength(Data) == 16)
    {
      *(_DWORD *)&buffer[8] = 0;
      *(void *)buffer = 0;
      v8.location = 0;
      v8.length = 16;
      CFDataGetBytes(v2, v8, buffer);
      long long v5 = *(_OWORD *)buffer;
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437A8))
      {
        qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
        __cxa_guard_release(&qword_1EA6437A8);
      }
      CFAllocatorRef v3 = (id)qword_1EA6437A0;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buffer = 0;
        _os_log_error_impl(&dword_1D0DBD000, v3, OS_LOG_TYPE_ERROR, "direction size should be of std::string::size_type size = sizeof(vector_float3)", buffer, 2u);
      }
    }
  }
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v6);
  return (__n128)v5;
}

void sub_1D0DD1E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DD1E30(uint64_t a1)
{
  if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)(*(void *)a1 + 40), @"depth")) {
    return 0;
  }
  CFAllocatorRef v3 = (cva::DictionaryHandler *)(*(void *)a1 + 40);
  return cva::DictionaryHandler::hasKey(v3, @"normalized_disparity");
}

float sub_1D0DD1E98(uint64_t a1)
{
  if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)(*(void *)a1 + 40), @"depth_unit"))
  {
    cva::DictionaryHandler::item(&v3, (cva::DictionaryHandler *)(*(void *)a1 + 40), @"depth_unit");
    cva::ItemHandler::getValue<float>();
  }
  return 1.0;
}

void sub_1D0DD1F14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

float sub_1D0DD1F28(uint64_t a1)
{
  if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)(*(void *)a1 + 40), @"disparity_normalization_offset"))
  {
    cva::DictionaryHandler::item(&v3, (cva::DictionaryHandler *)(*(void *)a1 + 40), @"disparity_normalization_offset");
    cva::ItemHandler::getValue<float>();
  }
  return 1.0;
}

void sub_1D0DD1FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

float sub_1D0DD1FB8(uint64_t a1)
{
  if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)(*(void *)a1 + 40), @"disparity_normalization_multiplier"))
  {
    cva::DictionaryHandler::item(&v3, (cva::DictionaryHandler *)(*(void *)a1 + 40), @"disparity_normalization_multiplier");
    cva::ItemHandler::getValue<float>();
  }
  return 1.0;
}

void sub_1D0DD2034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1D0DD2048(uint64_t a1)
{
  if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)(*(void *)a1 + 40), @"disparity_invalid_value"))
  {
    cva::DictionaryHandler::item(&v3, (cva::DictionaryHandler *)(*(void *)a1 + 40), @"disparity_invalid_value");
    cva::ItemHandler::getValue<int>();
  }
  return 0x1FFFLL;
}

void sub_1D0DD20C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1D0DD20D4(uint64_t *a1, double a2)
{
  __n128 v34 = sub_1D0DD1940(*a1);
  __n128 v36 = sub_1D0DD1A7C(*a1);
  cva::DictionaryHandler::item(v41, (cva::DictionaryHandler *)(*a1 + 40), @"gravity_direction");
  CFDataRef Data = (const __CFData *)cva::ItemHandler::getData((cva::ItemHandler *)v41);
  CFDataRef v4 = Data;
  float32x4_t v39 = 0u;
  if (Data)
  {
    if (CFDataGetLength(Data) == 16)
    {
      *(void *)&buffer[4] = 0;
      *(_DWORD *)buffer = 0;
      v43.location = 0;
      v43.length = 16;
      CFDataGetBytes(v4, v43, buffer);
      float32x4_t v39 = *(float32x4_t *)buffer;
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437A8))
      {
        qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
        __cxa_guard_release(&qword_1EA6437A8);
      }
      long long v5 = (id)qword_1EA6437A0;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buffer = 0;
        _os_log_error_impl(&dword_1D0DBD000, v5, OS_LOG_TYPE_ERROR, "direction size should be of std::string::size_type size = sizeof(vector_float3)", buffer, 2u);
      }
    }
  }
  int32x4_t v6 = (int32x4_t)vmulq_f32((float32x4_t)v34, (float32x4_t)v34);
  v6.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v6, 2), vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v6.i8, 1))).u32[0];
  float32x2_t v7 = vrsqrte_f32((float32x2_t)v6.u32[0]);
  float32x2_t v8 = vmul_f32(v7, vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v7, v7)));
  v6.i32[0] = vmul_f32(v8, vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v8, v8))).u32[0];
  int32x4_t v9 = (int32x4_t)vmulq_f32((float32x4_t)v36, (float32x4_t)v36);
  v9.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v9, 2), vadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v9.i8, 1))).u32[0];
  float32x4_t v10 = vmulq_n_f32((float32x4_t)v34, *(float *)v6.i32);
  *(float32x2_t *)v6.i8 = vrsqrte_f32((float32x2_t)v9.u32[0]);
  *(float32x2_t *)v6.i8 = vmul_f32(*(float32x2_t *)v6.i8, vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(*(float32x2_t *)v6.i8, *(float32x2_t *)v6.i8)));
  float32x4_t v32 = vmulq_n_f32((float32x4_t)v36, vmul_f32(*(float32x2_t *)v6.i8, vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(*(float32x2_t *)v6.i8, *(float32x2_t *)v6.i8))).f32[0]);
  int32x4_t v11 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v32, (int32x4_t)v32), (int8x16_t)v32, 0xCuLL), vnegq_f32(v10)), v32, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v10, (int32x4_t)v10), (int8x16_t)v10, 0xCuLL));
  float32x4_t v35 = v10;
  float32x4_t v37 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v11, v11), (int8x16_t)v11, 0xCuLL);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v41);
  int32x4_t v12 = (int32x4_t)vmulq_f32(v39, v39);
  v12.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v12, 2), vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v12.i8, 1))).u32[0];
  float32x2_t v13 = vrsqrte_f32((float32x2_t)v12.u32[0]);
  float32x2_t v14 = vmul_f32(v13, vrsqrts_f32((float32x2_t)v12.u32[0], vmul_f32(v13, v13)));
  float32x4_t v15 = vmulq_n_f32(v39, vmul_f32(v14, vrsqrts_f32((float32x2_t)v12.u32[0], vmul_f32(v14, v14))).f32[0]);
  float32x4_t v16 = vmulq_f32(v15, v37);
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1))).f32[0]) > 0.75)return 0; {
  float32x4_t v17 = vmulq_f32(v32, v15);
  }
  float32x4_t v18 = vmulq_f32(v35, v15);
  LODWORD(v38) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).u32[0];
  LODWORD(v40) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).u32[0];
  float v19 = atan2f(*((float *)&a2 + 1), *(float *)&a2) / 3.14159265 * 180.0;
  float v20 = fmodf(v19, 360.0);
  float v21 = fmodf(v20 + 360.0, 360.0);
  float v22 = atan2f(v40, v38) / 3.14159265 * 180.0;
  float v23 = fmodf(v22, 360.0);
  float v24 = fmodf(v23 + 360.0, 360.0);
  float v25 = fmodf(v21 - v24, 360.0);
  float v26 = fmodf(v25 + 360.0, 360.0);
  if (v26 < 45.0 || v26 >= 315.0) {
    return 0;
  }
  if (v26 >= 45.0 && v26 < 135.0) {
    return 1;
  }
  if (v26 >= 135.0 && v26 < 225.0) {
    return 2;
  }
  if (v26 >= 315.0 || v26 < 225.0) {
    return 0;
  }
  else {
    return 3;
  }
}

void sub_1D0DD2488(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DD249C(uint64_t *a1)
{
  __n128 v2 = sub_1D0DD1940(*a1);
  int32x4_t v3 = (int32x4_t)vmulq_f32((float32x4_t)v2, (float32x4_t)v2);
  v3.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v3, 2), vadd_f32(*(float32x2_t *)v3.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v3.i8, 1))).u32[0];
  float32x2_t v4 = vrsqrte_f32((float32x2_t)v3.u32[0]);
  float32x2_t v5 = vmul_f32(v4, vrsqrts_f32((float32x2_t)v3.u32[0], vmul_f32(v4, v4)));
  float32x4_t v25 = vmulq_n_f32((float32x4_t)v2, vmul_f32(v5, vrsqrts_f32((float32x2_t)v3.u32[0], vmul_f32(v5, v5))).f32[0]);
  __n128 v6 = sub_1D0DD1A7C(*a1);
  int32x4_t v7 = (int32x4_t)vmulq_f32((float32x4_t)v6, (float32x4_t)v6);
  v7.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v7, 2), vadd_f32(*(float32x2_t *)v7.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 1))).u32[0];
  float32x2_t v8 = vrsqrte_f32((float32x2_t)v7.u32[0]);
  float32x2_t v9 = vmul_f32(v8, vrsqrts_f32((float32x2_t)v7.u32[0], vmul_f32(v8, v8)));
  float32x4_t v24 = vmulq_n_f32((float32x4_t)v6, vmul_f32(v9, vrsqrts_f32((float32x2_t)v7.u32[0], vmul_f32(v9, v9))).f32[0]);
  __n128 v10 = sub_1D0DD1BB8(*a1);
  int32x4_t v11 = (int32x4_t)vmulq_f32((float32x4_t)v10, (float32x4_t)v10);
  v11.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v11, 2), vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v11.i8, 1))).u32[0];
  float32x2_t v12 = vrsqrte_f32((float32x2_t)v11.u32[0]);
  float32x2_t v13 = vmul_f32(v12, vrsqrts_f32((float32x2_t)v11.u32[0], vmul_f32(v12, v12)));
  float32x4_t v14 = vmulq_n_f32((float32x4_t)v10, vmul_f32(v13, vrsqrts_f32((float32x2_t)v11.u32[0], vmul_f32(v13, v13))).f32[0]);
  float32x4_t v15 = vmulq_f32(v25, v14);
  float32x4_t v16 = vmulq_f32(v24, v14);
  float v17 = atan2f(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1))).f32[0], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).f32[0])/ 3.14159265* 180.0;
  float v18 = fmodf(v17, 360.0);
  float v19 = fmodf(v18 + 360.0, 360.0);
  float v20 = fabsf(fmodf(v19, 90.0));
  float v21 = vabds_f32(90.0, v20);
  BOOL v22 = v20 < 0.001 || v21 < 0.001;
  if (!v22 || fabsf(v19) < 0.001) {
    return 0;
  }
  if (fabsf(v19 + -90.0) < 0.001) {
    return 1;
  }
  if (fabsf(v19 + -180.0) < 0.001) {
    return 2;
  }
  if (fabsf(v19 + -270.0) >= 0.001 && fabsf(v19 + 180.0) >= 0.001) {
    return 0;
  }
  return 3;
}

uint64_t sub_1D0DD2700(uint64_t *a1, double a2)
{
  int v3 = sub_1D0DD20D4(a1, a2);
  __n128 v4 = sub_1D0DD1940(*a1);
  int32x4_t v5 = (int32x4_t)vmulq_f32((float32x4_t)v4, (float32x4_t)v4);
  v5.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v5, 2), vadd_f32(*(float32x2_t *)v5.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.i8, 1))).u32[0];
  float32x2_t v6 = vrsqrte_f32((float32x2_t)v5.u32[0]);
  float32x2_t v7 = vmul_f32(v6, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v6, v6)));
  float32x4_t v28 = vmulq_n_f32((float32x4_t)v4, vmul_f32(v7, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v7, v7))).f32[0]);
  __n128 v8 = sub_1D0DD1A7C(*a1);
  int32x4_t v9 = (int32x4_t)vmulq_f32((float32x4_t)v8, (float32x4_t)v8);
  v9.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v9, 2), vadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v9.i8, 1))).u32[0];
  float32x2_t v10 = vrsqrte_f32((float32x2_t)v9.u32[0]);
  float32x2_t v11 = vmul_f32(v10, vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(v10, v10)));
  float32x4_t v27 = vmulq_n_f32((float32x4_t)v8, vmul_f32(v11, vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(v11, v11))).f32[0]);
  __n128 v12 = sub_1D0DD1BB8(*a1);
  int32x4_t v13 = (int32x4_t)vmulq_f32((float32x4_t)v12, (float32x4_t)v12);
  v13.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2), vadd_f32(*(float32x2_t *)v13.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v13.i8, 1))).u32[0];
  float32x2_t v14 = vrsqrte_f32((float32x2_t)v13.u32[0]);
  float32x2_t v15 = vmul_f32(v14, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(v14, v14)));
  float32x4_t v16 = vmulq_n_f32((float32x4_t)v12, vmul_f32(v15, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(v15, v15))).f32[0]);
  float32x4_t v17 = vmulq_f32(v28, v16);
  float32x4_t v18 = vmulq_f32(v27, v16);
  float v19 = atan2f(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).f32[0], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0])/ 3.14159265* 180.0;
  float v20 = fmodf(v19, 360.0);
  float v21 = fmodf(v20 + 360.0, 360.0);
  float v22 = fabsf(fmodf(v21, 90.0));
  float v23 = vabds_f32(90.0, v22);
  BOOL v24 = v22 < 0.001 || v23 < 0.001;
  if (v24 && fabsf(v21) >= 0.001)
  {
    if (fabsf(v21 + -90.0) < 0.001)
    {
      int v25 = 1;
      return (v3 + v25) & 3;
    }
    if (fabsf(v21 + -180.0) < 0.001)
    {
      int v25 = 2;
      return (v3 + v25) & 3;
    }
    if (fabsf(v21 + -270.0) < 0.001 || fabsf(v21 + 180.0) < 0.001)
    {
      int v25 = 3;
      return (v3 + v25) & 3;
    }
  }
  int v25 = 0;
  return (v3 + v25) & 3;
}

void sub_1D0DD2974()
{
}

void sub_1D0DD29F4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1;
  uint64_t v4 = *(void *)(v1 + 1936);
  *(void *)(v3 + 1936) = 0;
  if (v4)
  {
    if (*(char *)(v4 + 55) < 0) {
      operator delete(*(void **)(v4 + 32));
    }
    if (*(char *)(v4 + 31) < 0) {
      operator delete(*(void **)(v4 + 8));
    }
    MEMORY[0x1D25F16B0](v4, 0x1012C400F58515BLL);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D0DD2A48(uint64_t a1)
{
  *(void *)a1 = &unk_1F26F4598;
  if (*(void *)(a1 + 152))
  {
    __n128 v2 = (uint64_t *)(a1 + 136);
    uint64_t v3 = *(void *)(a1 + 136);
    uint64_t v4 = *(uint64_t **)(a1 + 144);
    uint64_t v5 = *v4;
    *(void *)(v5 + 8) = *(void *)(v3 + 8);
    **(void **)(v3 + 8) = v5;
    *(void *)(a1 + 152) = 0;
    if (v4 != (uint64_t *)(a1 + 136))
    {
      do
      {
        float32x2_t v6 = (uint64_t *)v4[1];
        float32x2_t v7 = (std::__shared_weak_count *)v4[3];
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        operator delete(v4);
        uint64_t v4 = v6;
      }
      while (v6 != v2);
    }
  }
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 80));
  std::mutex::~mutex((std::mutex *)(a1 + 16));
  return a1;
}

uint64_t **sub_1D0DD2B40(uint64_t **a1)
{
  __n128 v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *v2;
    uint64_t *v2 = 0;
    if (v3)
    {
      sub_1D0DCE830(*(void **)(v3 + 8));
      MEMORY[0x1D25F16B0](v3, 0x1020C4062D53EE8);
    }
    MEMORY[0x1D25F16B0](v2, 0x20C4093837F09);
  }
  return a1;
}

uint64_t sub_1D0DD2BBC(uint64_t a1)
{
  __n128 v2 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v3 = *(unsigned int *)(a1 + 152);
  std::mutex::unlock(v2);
  return v3;
}

void sub_1D0DD2BF8(uint64_t a1)
{
  __n128 v2 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  if (*(void *)(a1 + 152))
  {
    uint64_t v3 = (uint64_t *)(a1 + 136);
    uint64_t v4 = *(void *)(a1 + 136);
    uint64_t v5 = *(uint64_t **)(a1 + 144);
    uint64_t v6 = *v5;
    *(void *)(v6 + 8) = *(void *)(v4 + 8);
    **(void **)(v4 + 8) = v6;
    *(void *)(a1 + 152) = 0;
    if (v5 != (uint64_t *)(a1 + 136))
    {
      do
      {
        float32x2_t v7 = (uint64_t *)v5[1];
        __n128 v8 = (std::__shared_weak_count *)v5[3];
        if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
        operator delete(v5);
        uint64_t v5 = v7;
      }
      while (v7 != v3);
    }
  }
  std::mutex::unlock(v2);
}

BOOL sub_1D0DD2CE0(uint64_t a1, void *a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  int v5 = *(unsigned __int8 *)(a1 + 128);
  if (*(unsigned char *)(a1 + 128))
  {
    std::mutex::unlock(v4);
  }
  else
  {
    uint64_t v6 = operator new(0x20uLL);
    uint64_t v7 = a2[1];
    uint64_t v6[2] = *a2;
    v6[3] = v7;
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = *(void *)(a1 + 136);
    void *v6 = v8;
    v6[1] = a1 + 136;
    *(void *)(v8 + 8) = v6;
    *(void *)(a1 + 136) = v6;
    uint64_t v9 = *(void *)(a1 + 152) + 1;
    *(void *)(a1 + 152) = v9;
    int v10 = *(_DWORD *)(a1 + 8);
    if (v10 < (int)v9 && (v10 & 0x80000000) == 0)
    {
      do
      {
        float32x2_t v11 = *(uint64_t **)(a1 + 144);
        uint64_t v12 = *v11;
        *(void *)(v12 + 8) = v11[1];
        *(void *)v11[1] = v12;
        *(void *)(a1 + 152) = v9 - 1;
        int32x4_t v13 = (std::__shared_weak_count *)v11[3];
        if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
        operator delete(v11);
        uint64_t v9 = *(void *)(a1 + 152);
        int v14 = *(_DWORD *)(a1 + 8);
      }
      while (v14 < (int)v9 && (v14 & 0x80000000) == 0);
    }
    std::mutex::unlock(v4);
    std::condition_variable::notify_one((std::condition_variable *)(a1 + 80));
  }
  return v5 == 0;
}

void sub_1D0DD2E1C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1D0DD2E30(uint64_t a1, void *a2, int a3, uint64_t a4)
{
  v20.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 16);
  v20.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 16));
  BOOL v8 = 0;
  uint64_t v9 = *(void *)(a1 + 152);
  if (a3 < 1 || v9) {
    goto LABEL_18;
  }
  BOOL v8 = a4 != 0;
  if (a4)
  {
    if (!*(unsigned char *)(a4 + 8)) {
      goto LABEL_37;
    }
    std::mutex::unlock(*(std::mutex **)a4);
    *(unsigned char *)(a4 + 8) = 0;
  }
  std::chrono::steady_clock::now();
  v10.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  if (!v10.__d_.__rep_)
  {
    uint64_t v11 = 0;
    goto LABEL_14;
  }
  if (v10.__d_.__rep_ < 1)
  {
    if ((unint64_t)v10.__d_.__rep_ < 0xFFDF3B645A1CAC09)
    {
      uint64_t v11 = 0x8000000000000000;
      goto LABEL_14;
    }
LABEL_13:
    uint64_t v11 = 1000 * v10.__d_.__rep_;
    goto LABEL_14;
  }
  if ((unint64_t)v10.__d_.__rep_ <= 0x20C49BA5E353F7) {
    goto LABEL_13;
  }
  uint64_t v11 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_14:
  if (v11 <= ((1000000 * a3) ^ 0x7FFFFFFFFFFFFFFFLL)) {
    v12.__d_.__rep_ = v11 + 1000000 * a3;
  }
  else {
    v12.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
  }
  std::condition_variable::__do_timed_wait((std::condition_variable *)(a1 + 80), &v20, v12);
  std::chrono::steady_clock::now();
  uint64_t v9 = *(void *)(a1 + 152);
LABEL_18:
  if (v9)
  {
    uint64_t v13 = *(void *)(a1 + 144);
    uint64_t v15 = *(void *)(v13 + 16);
    uint64_t v14 = *(void *)(v13 + 24);
    if (v14) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
    }
    float32x4_t v16 = (std::__shared_weak_count *)a2[1];
    *a2 = v15;
    a2[1] = v14;
    if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
    float32x4_t v17 = *(uint64_t **)(a1 + 144);
    uint64_t v18 = *v17;
    *(void *)(v18 + 8) = v17[1];
    *(void *)v17[1] = v18;
    --*(void *)(a1 + 152);
    float v19 = (std::__shared_weak_count *)v17[3];
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    operator delete(v17);
  }
  if (v20.__owns_) {
    std::mutex::unlock(v20.__m_);
  }
  if (v8)
  {
    if (*(void *)a4)
    {
      if (!*(unsigned char *)(a4 + 8))
      {
        std::mutex::lock(*(std::mutex **)a4);
        *(unsigned char *)(a4 + 8) = 1;
        return;
      }
    }
    else
    {
      std::__throw_system_error(1, "unique_lock::lock: references null mutex");
    }
    std::__throw_system_error(11, "unique_lock::lock: already locked");
LABEL_37:
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    __break(1u);
  }
}

void sub_1D0DD30AC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1D0DD30C0(uint64_t a1@<X0>, void *a2@<X8>)
{
  v9.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 16);
  v9.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 16));
  for (uint64_t i = *(void *)(a1 + 152); !i; uint64_t i = *(void *)(a1 + 152))
    std::condition_variable::wait((std::condition_variable *)(a1 + 80), &v9);
  int v5 = *(uint64_t **)(a1 + 144);
  uint64_t v6 = v5[3];
  *a2 = v5[2];
  a2[1] = v6;
  if (v6)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    int v5 = *(uint64_t **)(a1 + 144);
    uint64_t i = *(void *)(a1 + 152);
    uint64_t v7 = (std::__shared_weak_count *)v5[3];
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *v5;
  *(void *)(v8 + 8) = v5[1];
  *(void *)v5[1] = v8;
  *(void *)(a1 + 152) = i - 1;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  operator delete(v5);
  if (v9.__owns_) {
    std::mutex::unlock(v9.__m_);
  }
}

void sub_1D0DD31C8(uint64_t a1)
{
  *(void *)a1 = &unk_1F26F4598;
  if (*(void *)(a1 + 152))
  {
    __n128 v2 = (uint64_t *)(a1 + 136);
    uint64_t v3 = *(void *)(a1 + 136);
    uint64_t v4 = *(uint64_t **)(a1 + 144);
    uint64_t v5 = *v4;
    *(void *)(v5 + 8) = *(void *)(v3 + 8);
    **(void **)(v3 + 8) = v5;
    *(void *)(a1 + 152) = 0;
    if (v4 != (uint64_t *)(a1 + 136))
    {
      do
      {
        uint64_t v6 = (uint64_t *)v4[1];
        uint64_t v7 = (std::__shared_weak_count *)v4[3];
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        operator delete(v4);
        uint64_t v4 = v6;
      }
      while (v6 != v2);
    }
  }
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 80));
  std::mutex::~mutex((std::mutex *)(a1 + 16));
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0DD32E0(void *a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_1D0DCB370(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a3;
    uint64_t v5 = *(void *)(a3 + 16);
  }
  char v6 = 0;
  char v7 = 0;
  char v8 = 0;
  char v9 = 0;
  __int16 v10 = 0;
  char v11 = 0;
  char v12 = 0;
  sub_1D0E79AF8(a1);
}

uint64_t sub_1D0DD3374(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64))
  {
    __n128 v2 = *(std::__shared_weak_count **)(a1 + 56);
    if (v2)
    {
      if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
        if ((*(char *)(a1 + 23) & 0x80000000) == 0) {
          return a1;
        }
        goto LABEL_5;
      }
    }
  }
  if (*(char *)(a1 + 23) < 0) {
LABEL_5:
  }
    operator delete(*(void **)a1);
  return a1;
}

uint64_t sub_1D0DD3408(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1D0DD342C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F5050;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0DD3480(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F5050;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0DD34A0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  __n128 v2 = (void *)MEMORY[0x1D25F1DA0]();
  std::mutex::lock((std::mutex *)(v1 + 40));
  int v3 = *(_DWORD *)(v1 + 176);
  std::mutex::unlock((std::mutex *)(v1 + 40));
  long long v11 = 0uLL;
  sub_1D0DD2E30(v1 + 24, &v11, 0, 0);
  if (v4)
  {
    uint64_t v5 = v11;
    if ((void)v11)
    {
      if (v3 != 1 && (!*(void *)(*(void *)v11 + 8) || v3 > 10))
      {
        uint64_t v7 = *((void *)&v11 + 1);
        if (*((void *)&v11 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v11 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        std::mutex::lock(&stru_1EA6434A0);
        v12[0] = v5;
        v12[1] = v7;
        if (v7) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
        }
        sub_1D0DCE8C4(&v10);
      }
      char v8 = *(uint64_t **)v1;
      long long v10 = v11;
      if (*((void *)&v11 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v11 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      sub_1D0DCF204(v12, v8, (__CVBuffer ****)&v10);
    }
  }
  char v9 = (std::__shared_weak_count *)*((void *)&v11 + 1);
  if (*((void *)&v11 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v11 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
}

void sub_1D0DD37AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  std::mutex::unlock(&stru_1EA6434A0);
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  if (a14)
  {
    if (!atomic_fetch_add(&a14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a14->__on_zero_shared)(a14);
      std::__shared_weak_count::__release_weak(a14);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DD391C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F26F4940;
  a2[1] = v2;
  return result;
}

void *sub_1D0DD3940(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F26F4940;
  result[1] = v3;
  return result;
}

void sub_1D0DD3988()
{
}

uint64_t sub_1D0DD39A4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1D0DD39C8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4F00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0DD3A1C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4F00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_1D0DD3A40(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  *(void *)(result + 24) = 0;
  if (v1)
  {
    cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)(v1 + 40));

    JUMPOUT(0x1D25F16B0);
  }
  return result;
}

void sub_1D0DD3AA8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4B48;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0DD3AFC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4B48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_1D0DD3B1C()
{
  unint64_t v0 = 0x1EA643000uLL;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0)
  {
    int v2 = __cxa_guard_acquire(&qword_1EA6437A8);
    unint64_t v0 = 0x1EA643000;
    if (v2)
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
      unint64_t v0 = 0x1EA643000;
    }
  }
  return *(void *)(v0 + 1952);
}

uint64_t sub_1D0DD3B8C(char *a1, int *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  strcpy((char *)__p, "Undefined");
  if (cva::utils::string::iequals())
  {
    *a2 = 0;
    return 1;
  }
  strcpy((char *)__p, "PositiveX");
  if (cva::utils::string::iequals())
  {
    uint64_t result = 1;
    *a2 = 1;
    return result;
  }
  strcpy((char *)__p, "PositiveY");
  if (cva::utils::string::iequals())
  {
    int v5 = 2;
LABEL_11:
    *a2 = v5;
    return 1;
  }
  strcpy((char *)__p, "NegativeX");
  if (cva::utils::string::iequals())
  {
    int v5 = 3;
    goto LABEL_11;
  }
  char v9 = 9;
  strcpy((char *)__p, "NegativeY");
  if (cva::utils::string::iequals())
  {
    int v5 = 4;
    goto LABEL_11;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437A8))
  {
    qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
    __cxa_guard_release(&qword_1EA6437A8);
  }
  char v6 = (id)qword_1EA6437A0;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    if (a1[23] >= 0) {
      uint64_t v7 = a1;
    }
    else {
      uint64_t v7 = *(char **)a1;
    }
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = v7;
    _os_log_error_impl(&dword_1D0DBD000, v6, OS_LOG_TYPE_ERROR, "invalid string for gravity direction: %s", (uint8_t *)__p, 0xCu);
  }

  return 0;
}

void sub_1D0DD3E34(_Unwind_Exception *exception_object)
{
}

void sub_1D0DD3E40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1D0DD3E6C()
{
}

void sub_1D0DD3F34(_Unwind_Exception *a1)
{
  sub_1D0DD7A74(v2);
  int v4 = *(std::__shared_weak_count **)(v1 + 8);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  MEMORY[0x1D25F16B0](v1, 0x10A0C407A79CA5DLL);
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DD3FB0(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a2 + 8);
  }
  if (v3) {
    operator new();
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437A8))
  {
    qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
    __cxa_guard_release(&qword_1EA6437A8);
  }
  int v4 = (id)qword_1EA6437A0;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl(&dword_1D0DBD000, v4, OS_LOG_TYPE_ERROR, "cannot find resources", (uint8_t *)__p, 2u);
  }

  kdebug_trace();
  return 0;
}

void sub_1D0DD5A08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, int a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)&a36);
  sub_1D0DD5F80(*(char **)(v41 - 120));
  sub_1D0DD5FDC(&a19);
  sub_1D0DCA2C0((uint64_t)&a11);
  cva::Path::~Path((cva::Path *)&a13);
  cva::Path::~Path((cva::Path *)&a15);
  if (a30 < 0) {
    operator delete(__p);
  }
  kdebug_trace();
  _Unwind_Resume(a1);
}

uint64_t *sub_1D0DD5B9C(uint64_t *result, uint64_t a2, const void **a3, uint64_t a4)
{
  uint64_t v7 = result;
  char v8 = (uint64_t **)(result + 1);
  if (result + 1 == (uint64_t *)a2) {
    goto LABEL_23;
  }
  int v9 = *((char *)a3 + 23);
  if (v9 >= 0) {
    uint64_t v10 = a3;
  }
  else {
    uint64_t v10 = *a3;
  }
  if (v9 >= 0) {
    size_t v11 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v11 = (size_t)a3[1];
  }
  int v12 = *(char *)(a2 + 55);
  if (v12 >= 0) {
    uint64_t v13 = (const void *)(a2 + 32);
  }
  else {
    uint64_t v13 = *(const void **)(a2 + 32);
  }
  if (v12 >= 0) {
    size_t v14 = *(unsigned __int8 *)(a2 + 55);
  }
  else {
    size_t v14 = *(void *)(a2 + 40);
  }
  if (v14 >= v11) {
    size_t v15 = v11;
  }
  else {
    size_t v15 = v14;
  }
  uint64_t result = (uint64_t *)memcmp(v10, v13, v15);
  if (result)
  {
    if ((result & 0x80000000) == 0) {
      goto LABEL_19;
    }
LABEL_23:
    uint64_t v16 = *(void *)a2;
    if (*v7 == a2)
    {
      uint64_t v18 = a2;
    }
    else
    {
      if (v16)
      {
        uint64_t v17 = *(void *)a2;
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = *(void *)(v17 + 8);
        }
        while (v17);
      }
      else
      {
        uint64_t v19 = a2;
        do
        {
          uint64_t v18 = *(void *)(v19 + 16);
          BOOL v37 = *(void *)v18 == v19;
          uint64_t v19 = v18;
        }
        while (v37);
      }
      int v20 = *(char *)(v18 + 55);
      if (v20 >= 0) {
        float v21 = (const void *)(v18 + 32);
      }
      else {
        float v21 = *(const void **)(v18 + 32);
      }
      if (v20 >= 0) {
        size_t v22 = *(unsigned __int8 *)(v18 + 55);
      }
      else {
        size_t v22 = *(void *)(v18 + 40);
      }
      int v23 = *((char *)a3 + 23);
      if (v23 >= 0) {
        BOOL v24 = a3;
      }
      else {
        BOOL v24 = *a3;
      }
      if (v23 >= 0) {
        size_t v25 = *((unsigned __int8 *)a3 + 23);
      }
      else {
        size_t v25 = (size_t)a3[1];
      }
      if (v25 >= v22) {
        size_t v26 = v22;
      }
      else {
        size_t v26 = v25;
      }
      uint64_t result = (uint64_t *)memcmp(v21, v24, v26);
      if (result)
      {
        if ((result & 0x80000000) == 0) {
          goto LABEL_48;
        }
      }
      else if (v22 >= v25)
      {
LABEL_48:
        float32x4_t v27 = *v8;
        if (!*v8) {
          goto LABEL_49;
        }
        while (1)
        {
          float32x4_t v28 = (uint64_t **)v27;
          uint64_t v31 = (const void *)v27[4];
          id v29 = v27 + 4;
          uint64_t v30 = v31;
          int v32 = *((char *)v29 + 23);
          if (v32 >= 0) {
            BOOL v33 = v29;
          }
          else {
            BOOL v33 = v30;
          }
          if (v32 >= 0) {
            size_t v34 = *((unsigned __int8 *)v29 + 23);
          }
          else {
            size_t v34 = v29[1];
          }
          if (v34 >= v25) {
            size_t v35 = v25;
          }
          else {
            size_t v35 = v34;
          }
          int v36 = memcmp(v24, v33, v35);
          if (v36)
          {
            if (v36 < 0) {
              goto LABEL_50;
            }
LABEL_64:
            uint64_t result = (uint64_t *)memcmp(v33, v24, v35);
            if (result)
            {
              if ((result & 0x80000000) == 0) {
                goto LABEL_128;
              }
            }
            else if (v34 >= v25)
            {
LABEL_128:
              float v38 = v8;
              goto LABEL_77;
            }
            char v8 = v28 + 1;
            float32x4_t v27 = v28[1];
            if (!v27) {
              goto LABEL_78;
            }
          }
          else
          {
            if (v25 >= v34) {
              goto LABEL_64;
            }
LABEL_50:
            float32x4_t v27 = *v28;
            char v8 = v28;
            if (!*v28) {
              goto LABEL_78;
            }
          }
        }
      }
    }
    BOOL v37 = v16 == 0;
    if (v16) {
      float32x4_t v28 = (uint64_t **)v18;
    }
    else {
      float32x4_t v28 = (uint64_t **)a2;
    }
    if (v37) {
      float v38 = (uint64_t **)a2;
    }
    else {
      float v38 = (uint64_t **)(v18 + 8);
    }
LABEL_77:
    char v8 = v38;
    if (*v38) {
      return result;
    }
    goto LABEL_78;
  }
  if (v11 < v14) {
    goto LABEL_23;
  }
LABEL_19:
  uint64_t result = (uint64_t *)memcmp(v13, v10, v15);
  if (result)
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v14 >= v11)
  {
    return result;
  }
  float v38 = (uint64_t **)(a2 + 8);
  int v42 = *(uint64_t **)(a2 + 8);
  if (v42)
  {
    do
    {
      float v38 = (uint64_t **)v42;
      int v42 = (uint64_t *)*v42;
      float32x4_t v28 = v38;
      CFRange v43 = v38;
    }
    while (v42);
    if (v38 == v8) {
      goto LABEL_77;
    }
  }
  else
  {
    CFRange v43 = (uint64_t **)a2;
    do
    {
      int v44 = (uint64_t *)v43;
      CFRange v43 = (uint64_t **)v43[2];
    }
    while (*v43 != v44);
    float32x4_t v28 = (uint64_t **)a2;
    if (v43 == v8) {
      goto LABEL_77;
    }
  }
  int v47 = v43[4];
  long long v45 = (uint64_t *)(v43 + 4);
  long long v46 = v47;
  int v48 = *((char *)v45 + 23);
  if (v48 >= 0) {
    int v49 = v45;
  }
  else {
    int v49 = v46;
  }
  if (v48 >= 0) {
    size_t v50 = *((unsigned __int8 *)v45 + 23);
  }
  else {
    size_t v50 = v45[1];
  }
  if (v50 >= v11) {
    size_t v51 = v11;
  }
  else {
    size_t v51 = v50;
  }
  uint64_t result = (uint64_t *)memcmp(v10, v49, v51);
  if (result)
  {
    if ((result & 0x80000000) != 0) {
      goto LABEL_77;
    }
  }
  else if (v11 < v50)
  {
    goto LABEL_77;
  }
  unint64_t v52 = *v8;
  if (*v8)
  {
    while (1)
    {
      float32x4_t v28 = (uint64_t **)v52;
      int v55 = (const void *)v52[4];
      long long v53 = v52 + 4;
      long long v54 = v55;
      int v56 = *((char *)v53 + 23);
      if (v56 >= 0) {
        uint64_t v57 = v53;
      }
      else {
        uint64_t v57 = v54;
      }
      if (v56 >= 0) {
        size_t v58 = *((unsigned __int8 *)v53 + 23);
      }
      else {
        size_t v58 = v53[1];
      }
      if (v58 >= v11) {
        size_t v59 = v11;
      }
      else {
        size_t v59 = v58;
      }
      int v60 = memcmp(v10, v57, v59);
      if (v60)
      {
        if (v60 < 0) {
          goto LABEL_108;
        }
LABEL_122:
        uint64_t result = (uint64_t *)memcmp(v57, v10, v59);
        if (result)
        {
          if ((result & 0x80000000) == 0) {
            goto LABEL_128;
          }
        }
        else if (v58 >= v11)
        {
          goto LABEL_128;
        }
        char v8 = v28 + 1;
        unint64_t v52 = v28[1];
        if (!v52) {
          goto LABEL_78;
        }
      }
      else
      {
        if (v11 >= v58) {
          goto LABEL_122;
        }
LABEL_108:
        unint64_t v52 = *v28;
        char v8 = v28;
        if (!*v28) {
          goto LABEL_78;
        }
      }
    }
  }
LABEL_49:
  float32x4_t v28 = v8;
LABEL_78:
  float32x4_t v39 = (uint64_t *)operator new(0x38uLL);
  float v40 = v39 + 4;
  if (*(char *)(a4 + 23) < 0)
  {
    sub_1D0DCB370(v40, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)float v40 = *(_OWORD *)a4;
    v39[6] = *(void *)(a4 + 16);
  }
  *float32x4_t v39 = 0;
  v39[1] = 0;
  v39[2] = (uint64_t)v28;
  uint64_t *v8 = v39;
  uint64_t v41 = *(void *)*v7;
  if (v41)
  {
    uint64_t *v7 = v41;
    float32x4_t v39 = *v8;
  }
  uint64_t result = sub_1D0DCEC98((uint64_t *)v7[1], v39);
  ++v7[2];
  return result;
}

void sub_1D0DD5F6C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1D0DD5F80(char *a1)
{
  if (a1)
  {
    sub_1D0DD5F80(*(void *)a1);
    sub_1D0DD5F80(*((void *)a1 + 1));
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

void **sub_1D0DD5FDC(void **a1)
{
  uint64_t v2 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    int v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((char *)v3 - 1) < 0) {
          operator delete(*(v3 - 3));
        }
        v3 -= 3;
      }
      while (v3 != v2);
      int v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_1D0DD6054(uint64_t result)
{
  uint64_t v1 = *(uint64_t **)(result + 24);
  if (v1)
  {
    free((void *)v1[4]);
    free((void *)v1[1]);
    uint64_t v2 = *v1;
    *uint64_t v1 = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    JUMPOUT(0x1D25F16B0);
  }
  return result;
}

void sub_1D0DD60E8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

uint64_t sub_1D0DD6124(CVPixelBufferRef *a1, cva *this, uint64_t a3, uint64_t a4)
{
  char v8 = *a1;
  if (*a1)
  {
    int IsPlanar = CVPixelBufferIsPlanar(*a1);
    if (CVPixelBufferGetWidth(v8) == this
      && CVPixelBufferGetHeight(v8) == a3
      && CVPixelBufferGetPixelFormatType(v8) == a4)
    {
      if (IsPlanar)
      {
        size_t v10 = 0;
        BOOL v11 = 1;
        while (v10 < CVPixelBufferGetPlaneCount(v8))
          BOOL v11 = v11 && (CVPixelBufferGetBytesPerRowOfPlane(v8, v10++) & 0xF) == 0;
        if (v11) {
          return 1;
        }
      }
      else if ((CVPixelBufferGetBytesPerRow(v8) & 0xF) == 0)
      {
        return 1;
      }
    }
    if (*a1)
    {
      CVPixelBufferRelease(*a1);
      *a1 = 0;
    }
  }
  cva::pixelBufferCreate(this, a3, a4, (uint64_t)a1, (__CVBuffer **)0x10, 0x10u, 0, 1u, 0, v13);
  return 2 * (*a1 != 0);
}

void sub_1D0DD6260(__CVBuffer *a1, const void *a2)
{
  IOSurface = CVPixelBufferGetIOSurface(a1);
  if (IOSurface)
  {
    CFStringRef v4 = (const __CFString *)*MEMORY[0x1E4F2F128];
    IOSurfaceSetValue(IOSurface, v4, a2);
  }
}

void sub_1D0DD62B4(uint64_t a1, unsigned int a2)
{
  *(_DWORD *)(a1 + 16) = a2;
  if (a2)
  {
    uint64_t v3 = a2;
    if (*(void *)(a1 + 8) < (unint64_t)a2)
    {
      free(*(void **)a1);
      size_t v4 = (4 * v3 + 31) & 0x7FFFFFFE0;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = v4 >> 2;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v4, 0x49090899uLL);
      *(void *)a1 = memptr;
    }
  }
  else
  {
    free(*(void **)a1);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
  }
}

uint64_t sub_1D0DD6340(__CVBuffer *a1)
{
  if (a1)
  {
    CVPixelBufferLockBaseAddress(a1, 1uLL);
    signed int PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
    if (PixelFormatType <= 1278226533)
    {
      if (PixelFormatType != 825306677 && PixelFormatType != 825437747)
      {
LABEL_12:
        CVPixelBufferUnlockBaseAddress(a1, 1uLL);
        return 0;
      }
    }
    else
    {
      if (PixelFormatType == 1278226534 || PixelFormatType == 1717855600) {
        cva::imageViewFromPixelBuffer<float>();
      }
      if (PixelFormatType != 1647392359) {
        goto LABEL_12;
      }
    }
    cva::imageViewFromPixelBuffer<unsigned short>();
  }
  return 0;
}

uint64_t sub_1D0DD6890(__CVBuffer *a1)
{
  if (a1)
  {
    CVPixelBufferLockBaseAddress(a1, 1uLL);
    signed int PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
    if (PixelFormatType <= 1278226533)
    {
      if (PixelFormatType != 825306677 && PixelFormatType != 825437747)
      {
LABEL_12:
        CVPixelBufferUnlockBaseAddress(a1, 1uLL);
        return 0;
      }
    }
    else
    {
      if (PixelFormatType == 1278226534 || PixelFormatType == 1717855600) {
        cva::imageViewFromPixelBuffer<float>();
      }
      if (PixelFormatType != 1647392359) {
        goto LABEL_12;
      }
    }
    cva::imageViewFromPixelBuffer<unsigned short>();
  }
  return 0;
}

void *sub_1D0DD6D94(void *result, unsigned int a2, uint64_t a3)
{
  unsigned int v3 = a3;
  int v5 = result;
  if (*((_DWORD *)result + 2) >= a2 && *((_DWORD *)result + 3) >= a3)
  {
    *uint64_t result = 0;
    result[1] = a2 | (unint64_t)(a3 << 32);
  }
  else
  {
    uint64_t v7 = (void *)result[3];
    if (v7)
    {
      free(v7);
      v5[3] = 0;
    }
    *int v5 = 0;
    v5[1] = a2 | ((unint64_t)v3 << 32);
    v5[2] = ((unint64_t)(((4 * a2 + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
    unint64_t size = ((4 * a2 + 15) & 0xFFFFFFF0) * (unint64_t)v3;
    if (size) {
      uint64_t result = malloc_type_malloc(size, 0xA153FF5uLL);
    }
    else {
      uint64_t result = 0;
    }
    v5[3] = result;
  }
  return result;
}

float *sub_1D0DD6E58(float *result, float **a2)
{
  uint64_t v2 = result;
  unsigned int v3 = *a2;
  if (*a2 == result || (size_t v4 = a2[1], v4 == result))
  {
    uint64_t v5 = 0;
    uint64_t result = (float *)sub_1D0DD6E58(&v5);
    *(void *)uint64_t v2 = v5;
  }
  else
  {
    *uint64_t result = (float)((float)(*v3 * *v4) + 0.0) + (float)(v3[2] * v4[1]);
    result[1] = (float)((float)(v3[1] * *v4) + 0.0) + (float)(v3[3] * v4[1]);
  }
  return result;
}

__n128 sub_1D0DD6EE4(char *__dst, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 64))
  {
    int v3 = *(_DWORD *)(a2 + 60);
    uint64_t v4 = *(void *)(*(void *)a2 + 8);
    uint64_t v5 = v4 + 40 * v3;
    if (*(char *)(v5 + 23) < 0)
    {
      sub_1D0DCB370(__dst, *(void **)v5, *(void *)(v5 + 8));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)v5;
      *((void *)__dst + 2) = *(void *)(v5 + 16);
    }
    __n128 result = *(__n128 *)(v4 + 40 * v3 + 24);
    *(__n128 *)(__dst + 24) = result;
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    char v6 = qword_1EA6437A0;
    if (os_log_type_enabled((os_log_t)qword_1EA6437A0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v8 = 0;
      _os_log_error_impl(&dword_1D0DBD000, v6, OS_LOG_TYPE_ERROR, "no depth support in regressor", v8, 2u);
    }
    *(void *)std::string __dst = 0;
    *((void *)__dst + 1) = 0;
    *((void *)__dst + 2) = 0;
    *((void *)__dst + 3) = -1;
    __dst[23] = 5;
    *(_DWORD *)std::string __dst = 1835890020;
    __dst[4] = 121;
    *((void *)__dst + 4) = -1;
  }
  return result;
}

__n128 sub_1D0DD7024(char *__dst, unsigned char *a2)
{
  if (a2[65])
  {
    uint64_t v3 = *(void *)(*(void *)a2 + 32);
    if (*(char *)(v3 + 23) < 0)
    {
      sub_1D0DCB370(__dst, *(void **)v3, *(void *)(v3 + 8));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)v3;
      *((void *)__dst + 2) = *(void *)(v3 + 16);
    }
    __n128 result = *(__n128 *)(v3 + 24);
    *(__n128 *)(__dst + 24) = result;
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    uint64_t v4 = qword_1EA6437A0;
    if (os_log_type_enabled((os_log_t)qword_1EA6437A0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v6 = 0;
      _os_log_error_impl(&dword_1D0DBD000, v4, OS_LOG_TYPE_ERROR, "no foreground color support in regressor", v6, 2u);
    }
    *(void *)std::string __dst = 0;
    *((void *)__dst + 1) = 0;
    *((void *)__dst + 2) = 0;
    *((void *)__dst + 3) = -1;
    __dst[23] = 5;
    *(_DWORD *)std::string __dst = 1835890020;
    __dst[4] = 121;
    *((void *)__dst + 4) = -1;
  }
  return result;
}

OpaqueVTPixelTransferSession *sub_1D0DD7148(uint64_t a1, __CVBuffer *a2, __CVBuffer *a3)
{
  __n128 result = *(OpaqueVTPixelTransferSession **)(a1 + 8);
  if (result) {
    return (OpaqueVTPixelTransferSession *)(VTPixelTransferSessionTransferImage(result, a2, a3) == 0);
  }
  return result;
}

BOOL sub_1D0DD7170(uint64_t a1)
{
  return *(void *)(a1 + 8) || VTPixelTransferSessionCreate(0, (VTPixelTransferSessionRef *)(a1 + 8)) == 0;
}

void sub_1D0DD71AC(uint64_t a1)
{
  *(void *)a1 = &unk_1F26F3E28;
  uint64_t v2 = *(OpaqueVTPixelTransferSession **)(a1 + 8);
  if (v2)
  {
    VTPixelTransferSessionInvalidate(v2);
    CFRelease(*(CFTypeRef *)(a1 + 8));
  }
  JUMPOUT(0x1D25F16B0);
}

uint64_t sub_1D0DD7220(uint64_t a1)
{
  *(void *)a1 = &unk_1F26F3E28;
  uint64_t v2 = *(OpaqueVTPixelTransferSession **)(a1 + 8);
  if (v2)
  {
    VTPixelTransferSessionInvalidate(v2);
    CFRelease(*(CFTypeRef *)(a1 + 8));
  }
  return a1;
}

uint64_t sub_1D0DD7274(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  propertyValueOut[1] = *(CFBooleanRef *)MEMORY[0x1E4F143B8];
  char v6 = (CFTypeRef *)(a1 + 8);
  if (!*(void *)(a1 + 8))
  {
LABEL_9:
    int v10 = VTImageRotationSessionCreate();
    if (v10)
    {
      int v11 = v10;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437A8))
      {
        qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
        __cxa_guard_release(&qword_1EA6437A8);
      }
      int v12 = (id)qword_1EA6437A0;
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        goto LABEL_28;
      }
      LODWORD(propertyValueOut[0]) = 67109120;
      HIDWORD(propertyValueOut[0]) = v11;
      BOOL v13 = "failed creating rotation session (%d)";
      size_t v14 = (uint8_t *)propertyValueOut;
      size_t v15 = v12;
      uint32_t v16 = 8;
    }
    else
    {
      VTSessionSetProperty(*(VTSessionRef *)(a1 + 8), (CFStringRef)*MEMORY[0x1E4F44FF0], (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
      *(_DWORD *)(a1 + 16) = a4;
      propertyValueOut[0] = 0;
      if (VTSessionCopyProperty(*(VTSessionRef *)(a1 + 8), (CFStringRef)*MEMORY[0x1E4F45008], (CFAllocatorRef)*MEMORY[0x1E4F1CF80], propertyValueOut))
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EA6437A8))
        {
          qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
          __cxa_guard_release(&qword_1EA6437A8);
        }
        int v12 = (id)qword_1EA6437A0;
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          goto LABEL_28;
        }
        __int16 v19 = 0;
        BOOL v13 = "could not get scaling property";
      }
      else if (propertyValueOut[0])
      {
        int Value = CFBooleanGetValue(propertyValueOut[0]);
        CFRelease(propertyValueOut[0]);
        propertyValueOut[0] = 0;
        if (Value) {
          goto LABEL_3;
        }
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EA6437A8))
        {
          qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
          __cxa_guard_release(&qword_1EA6437A8);
        }
        int v12 = (id)qword_1EA6437A0;
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
LABEL_28:

          return 0;
        }
        __int16 v19 = 0;
        BOOL v13 = "scaling is not supported in for VTImageRotationSessionTransferImage";
      }
      else
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EA6437A8))
        {
          qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
          __cxa_guard_release(&qword_1EA6437A8);
        }
        int v12 = (id)qword_1EA6437A0;
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          goto LABEL_28;
        }
        __int16 v19 = 0;
        BOOL v13 = "could not get scaling property";
      }
      size_t v14 = (uint8_t *)&v19;
      size_t v15 = v12;
      uint32_t v16 = 2;
    }
    _os_log_error_impl(&dword_1D0DBD000, v15, OS_LOG_TYPE_ERROR, v13, v14, v16);
    goto LABEL_28;
  }
  if (*(_DWORD *)(a1 + 16) != a4)
  {
    MEMORY[0x1D25F0CB0]();
    CFRelease(*v6);
    CFTypeRef *v6 = 0;
    goto LABEL_9;
  }
LABEL_3:
  int v7 = MEMORY[0x1D25F0CC0]();
  if (!v7) {
    return 1;
  }
  int v8 = v7;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437A8))
  {
    qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
    __cxa_guard_release(&qword_1EA6437A8);
  }
  int v9 = (id)qword_1EA6437A0;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LODWORD(propertyValueOut[0]) = 67109120;
    HIDWORD(propertyValueOut[0]) = v8;
    _os_log_error_impl(&dword_1D0DBD000, v9, OS_LOG_TYPE_ERROR, "failed rotating the image(%d)", (uint8_t *)propertyValueOut, 8u);
  }

  return 0;
}

uint64_t sub_1D0DD7698()
{
  return 1;
}

void sub_1D0DD76A0(uint64_t a1)
{
  *(void *)a1 = &unk_1F26F3E58;
  if (*(void *)(a1 + 8))
  {
    MEMORY[0x1D25F0CB0]();
    CFRelease(*(CFTypeRef *)(a1 + 8));
  }
  JUMPOUT(0x1D25F16B0);
}

uint64_t sub_1D0DD7714(uint64_t a1)
{
  *(void *)a1 = &unk_1F26F3E58;
  if (*(void *)(a1 + 8))
  {
    MEMORY[0x1D25F0CB0]();
    CFRelease(*(CFTypeRef *)(a1 + 8));
  }
  return a1;
}

void sub_1D0DD7768(void *a1)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437A8))
  {
    qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
    __cxa_guard_release(&qword_1EA6437A8);
  }
  uint64_t v1 = (id)qword_1EA6437A0;
  if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
  {
    v2[0] = 67109120;
    v2[1] = 0;
    _os_log_impl(&dword_1D0DBD000, v1, OS_LOG_TYPE_INFO, "Rotation helper type %i", (uint8_t *)v2, 8u);
  }

  operator new();
}

void sub_1D0DD7A48(_Unwind_Exception *exception_object)
{
}

void sub_1D0DD7A54(_Unwind_Exception *exception_object)
{
  if (!*v1) {
    _Unwind_Resume(exception_object);
  }
  CVPixelBufferRelease(*v1);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D0DD7A74(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  if (*(void *)a1) {
    CVPixelBufferRelease(*(CVPixelBufferRef *)a1);
  }
  return a1;
}

uint64_t sub_1D0DD7AFC(CVPixelBufferRef *a1, uint64_t a2, CVPixelBufferRef pixelBuffer, __CVBuffer *a4)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (!pixelBuffer || !a4)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    float32x4_t v39 = (id)qword_1EA6437A0;
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      goto LABEL_89;
    }
    LOWORD(src.data) = 0;
    float v40 = "invalid call";
LABEL_85:
    long long v45 = v39;
    uint32_t v46 = 2;
LABEL_86:
    _os_log_error_impl(&dword_1D0DBD000, v45, OS_LOG_TYPE_ERROR, v40, (uint8_t *)&src, v46);
LABEL_89:

    return 0;
  }
  uint64_t v5 = pixelBuffer;
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
  OSType v9 = CVPixelBufferGetPixelFormatType(a4);
  BOOL v11 = PixelFormatType != 1278226488 && v9 != 1278226488;
  size_t Width = CVPixelBufferGetWidth(v5);
  size_t Height = CVPixelBufferGetHeight(v5);
  unsigned int v14 = CVPixelBufferGetWidth(a4);
  unsigned int v15 = CVPixelBufferGetHeight(a4);
  if (!Width || !Height || !v14 || (unsigned int v16 = v15) == 0)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    float32x4_t v39 = (id)qword_1EA6437A0;
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      goto LABEL_89;
    }
    LOWORD(src.data) = 0;
    float v40 = "zero width or height";
    goto LABEL_85;
  }
  size_t v48 = Height;
  size_t v49 = Width;
  unsigned int v50 = PixelFormatType;
  size_t v17 = CVPixelBufferGetWidth(v5);
  size_t v18 = CVPixelBufferGetHeight(v5);
  size_t v19 = CVPixelBufferGetWidth(a4);
  size_t v20 = CVPixelBufferGetHeight(a4);
  float v21 = 1.0;
  if (!v17 || !v18)
  {
LABEL_23:
    if (v11) {
      goto LABEL_77;
    }
    goto LABEL_24;
  }
  if (a2 <= 4)
  {
    float v22 = (float)v19;
    float v23 = (float)v19 / (float)v17;
    if ((float)((float)v20 / (float)v18) < v23) {
      float v23 = (float)v20 / (float)v18;
    }
    float v21 = (float)v20 / (float)v17;
    if ((float)(v22 / (float)v18) < v21) {
      float v21 = v22 / (float)v18;
    }
    if (((1 << a2) & 0x15) != 0) {
      float v21 = v23;
    }
    if (v21 < 0.25) {
      goto LABEL_25;
    }
    goto LABEL_23;
  }
  if (v11) {
    goto LABEL_77;
  }
LABEL_24:
  if (fabsf(v21 + -1.0) <= 0.000001) {
    goto LABEL_77;
  }
LABEL_25:
  double v24 = COERCE_DOUBLE(vrev64_s32((int32x2_t)__PAIR64__(v16, v14)));
  if ((a2 | 2) != 3) {
    double v24 = COERCE_DOUBLE(__PAIR64__(v16, v14));
  }
  size_t v25 = (cva *)LODWORD(v24);
  if (!v11)
  {
    uint64_t v36 = HIDWORD(v24);
    uint64_t v32 = v50;
    int v29 = v48;
    int v28 = v49;
    goto LABEL_72;
  }
  float v26 = (float)SLODWORD(v24);
  float v27 = (float)SHIDWORD(v24);
  int v29 = v48;
  int v28 = v49;
  int v30 = v49 + 3;
  if ((v49 & 0x80000000) == 0) {
    int v30 = v49;
  }
  int v31 = v48 + 3;
  if ((v48 & 0x80000000) == 0) {
    int v31 = v48;
  }
  uint64_t v32 = v50;
  if ((v49 & 3) == 0 && (v48 & 3) == 0)
  {
    unint64_t v35 = (v30 >> 2);
    if ((int)v35 >= (int)v25)
    {
      uint64_t v36 = (v31 >> 2);
      if ((int)v36 >= SHIDWORD(v24))
      {
        float v41 = v26 / (float)(int)v35;
        if ((float)(v27 / (float)(int)v36) < v41) {
          float v41 = v27 / (float)(int)v36;
        }
        if (v41 >= 0.25) {
          goto LABEL_62;
        }
      }
    }
  }
  int v33 = (v49 & 0x80000000) == 0 ? v49 : (int)v49 + 1;
  int v34 = (v48 & 0x80000000) == 0 ? v48 : (int)v48 + 1;
  if (v49) {
    goto LABEL_46;
  }
  if (v48) {
    goto LABEL_46;
  }
  unint64_t v35 = (v33 >> 1);
  if ((int)v35 < (int)v25) {
    goto LABEL_46;
  }
  uint64_t v36 = (v34 >> 1);
  if ((int)v36 < SHIDWORD(v24)) {
    goto LABEL_46;
  }
  float v37 = v26 / (float)(int)v35;
  float v38 = v27 / (float)(int)v36;
  if (v38 < v37) {
    float v37 = v38;
  }
  if (v37 < 0.25)
  {
LABEL_46:
    size_t v25 = (cva *)v49;
    uint64_t v36 = v48;
  }
  else
  {
LABEL_62:
    size_t v25 = (cva *)v35;
  }
  if ((int)v50 > 875704949)
  {
    if (v50 != 875704950 && v50 != 2037741171)
    {
      int v42 = 2037741158;
LABEL_70:
      if (v50 != v42) {
        goto LABEL_72;
      }
    }
  }
  else if (v50 != 875704422 && v50 != 875704438)
  {
    int v42 = 875704934;
    goto LABEL_70;
  }
  size_t v25 = (cva *)((v25 & 1) + v25);
  uint64_t v36 = (v36 & 1) + v36;
LABEL_72:
  if (sub_1D0DD6124(a1, v25, v36, v32) == 2)
  {
    IOSurface = CVPixelBufferGetIOSurface(*a1);
    if (IOSurface) {
      IOSurfaceSetValue(IOSurface, (CFStringRef)*MEMORY[0x1E4F2F128], @"AppleCVA:Seg:RotationHelper");
    }
  }
  if (((*(uint64_t (**)(CVPixelBufferRef, __CVBuffer *, CVPixelBufferRef))(*(void *)a1[2] + 24))(a1[2], v5, *a1) & 1) == 0)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    float32x4_t v39 = (id)qword_1EA6437A0;
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      goto LABEL_89;
    }
    LODWORD(src.data) = 67110400;
    HIDWORD(src.data) = v28;
    LOWORD(src.height) = 1024;
    *(_DWORD *)((char *)&src.height + 2) = v29;
    HIWORD(src.height) = 1024;
    LODWORD(src.width) = v32;
    WORD2(src.width) = 1024;
    *(_DWORD *)((char *)&src.width + 6) = v25;
    WORD1(src.rowBytes) = 1024;
    HIDWORD(src.rowBytes) = v36;
    __int16 v52 = 1024;
    int v53 = v32;
    float v40 = "failed to scale image (%ux%u 0x%x -> %ux%u 0x%x)";
    long long v45 = v39;
    uint32_t v46 = 38;
    goto LABEL_86;
  }
  uint64_t v5 = *a1;
LABEL_77:
  if (CVPixelBufferGetPixelFormatType(v5) == 1278226488 && CVPixelBufferGetPixelFormatType(a4) == 1278226488)
  {
    CVPixelBufferLockBaseAddress(v5, 1uLL);
    CVPixelBufferLockBaseAddress(a4, 0);
    cva::imageViewFromPixelBuffer<unsigned char>();
  }
  if (((*(uint64_t (**)(CVPixelBufferRef, __CVBuffer *, __CVBuffer *, uint64_t))(*(void *)a1[1] + 24))(a1[1], v5, a4, a2) & 1) == 0)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437A8))
    {
      qword_1EA6437A0 = (uint64_t)os_log_create("com.apple.AppleCVA", "Segmentation");
      __cxa_guard_release(&qword_1EA6437A8);
    }
    float32x4_t v39 = (id)qword_1EA6437A0;
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      goto LABEL_89;
    }
    LOWORD(src.data) = 0;
    float v40 = "Error rotating/scaling buffer";
    goto LABEL_85;
  }
  return 1;
}

uint64_t sub_1D0DD8230(uint64_t a1, long long *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)a2 + 12) & 1) == 0)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0)
    {
      if (__cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
    }
    uint64_t v2 = qword_1EA6437C0;
    if (!os_log_type_enabled((os_log_t)qword_1EA6437C0, OS_LOG_TYPE_ERROR)) {
      return 1;
    }
    LOWORD(v17.value) = 0;
    OSType v9 = "Precondition violated: CMTIME_IS_VALID(timestamp)";
    int v10 = &v17;
    BOOL v11 = v2;
    uint32_t v12 = 2;
    goto LABEL_15;
  }
  memset(&v17, 0, sizeof(v17));
  CMTime lhs = *(CMTime *)a2;
  CMTime rhs = *(CMTime *)a1;
  CMTimeSubtract(&v17, &lhs, &rhs);
  if ((v17.flags & 1) == 0)
  {
    if (*(unsigned char *)(a1 + 32)) {
      *(unsigned char *)(a1 + 32) = 0;
    }
    goto LABEL_13;
  }
  CMTime v14 = v17;
  double Seconds = CMTimeGetSeconds(&v14);
  double v7 = Seconds;
  if (Seconds >= 0.0)
  {
    *(double *)(a1 + 24) = Seconds;
    *(unsigned char *)(a1 + 32) = 1;
LABEL_13:
    uint64_t result = 0;
    long long v13 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v13;
    return result;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  uint64_t v8 = qword_1EA6437C0;
  if (!os_log_type_enabled((os_log_t)qword_1EA6437C0, OS_LOG_TYPE_ERROR)) {
    return 1;
  }
  int v18 = 134217984;
  double v19 = v7;
  OSType v9 = "Timestamps must be increasing, got a diff of %f";
  int v10 = (CMTime *)&v18;
  BOOL v11 = v8;
  uint32_t v12 = 12;
LABEL_15:
  _os_log_error_impl(&dword_1D0DBD000, v11, OS_LOG_TYPE_ERROR, v9, (uint8_t *)v10, v12);
  return 1;
}

void *sub_1D0DD845C(void *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1[31];
  a1[31] = 0;
  if (v2)
  {
    int v3 = e5rt_execution_stream_operation_release();
    if (v3)
    {
      int v19 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        int v22 = v19;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  uint64_t v4 = a1[30];
  a1[30] = 0;
  if (v4)
  {
    int v5 = e5rt_execution_stream_release();
    if (v5)
    {
      int v20 = v5;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        int v22 = v20;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  char v6 = (void **)a1[27];
  if (v6)
  {
    do
    {
      unsigned int v15 = (void **)*v6;
      if (*((char *)v6 + 39) < 0) {
        operator delete(v6[2]);
      }
      operator delete(v6);
      char v6 = v15;
    }
    while (v15);
  }
  double v7 = (void *)a1[25];
  a1[25] = 0;
  if (v7) {
    operator delete(v7);
  }
  uint64_t v8 = (void **)a1[22];
  if (v8)
  {
    do
    {
      unsigned int v16 = (void **)*v8;
      if (*((char *)v8 + 39) < 0) {
        operator delete(v8[2]);
      }
      operator delete(v8);
      uint64_t v8 = v16;
    }
    while (v16);
  }
  OSType v9 = (void *)a1[20];
  a1[20] = 0;
  if (v9) {
    operator delete(v9);
  }
  int v10 = (id *)a1[17];
  if (v10)
  {
    do
    {
      CMTime v17 = (id *)*v10;

      if (*((char *)v10 + 39) < 0) {
        operator delete(v10[2]);
      }
      operator delete(v10);
      int v10 = v17;
    }
    while (v17);
  }
  BOOL v11 = (void *)a1[15];
  a1[15] = 0;
  if (v11) {
    operator delete(v11);
  }
  uint32_t v12 = (id *)a1[12];
  if (v12)
  {
    do
    {
      int v18 = (id *)*v12;

      if (*((char *)v12 + 39) < 0) {
        operator delete(v12[2]);
      }
      operator delete(v12);
      uint32_t v12 = v18;
    }
    while (v18);
  }
  long long v13 = (void *)a1[10];
  a1[10] = 0;
  if (v13) {
    operator delete(v13);
  }
  sub_1D0DD8820((uint64_t)(a1 + 5));
  sub_1D0DD8820((uint64_t)a1);
  return a1;
}

uint64_t sub_1D0DD86BC(uint64_t *a1)
{
  if (*a1)
  {
    uint64_t v5 = *a1;
    uint64_t v2 = a1[4];
    if (!v2)
    {
      uint64_t result = sub_1D0DD8808();
      __break(1u);
      return result;
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v5);
    *a1 = 0;
  }
  int v3 = (uint64_t *)a1[4];
  if (v3 == a1 + 1)
  {
    (*(void (**)(uint64_t *))(a1[1] + 32))(a1 + 1);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t *))(*v3 + 40))(v3);
  }
  return (uint64_t)a1;
}

void sub_1D0DD8794(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 32);
  if (v3 == v1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(v1 + 8) + 32))(v1 + 8);
    _Unwind_Resume(exception_object);
  }
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D0DD8808()
{
  std::__libcpp_verbose_abort("bad_function_call was thrown in -fno-exceptions mode");
  return sub_1D0DD8820(v0);
}

uint64_t sub_1D0DD8820(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(char **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = MEMORY[0x1E4F14500];
    do
    {
      uint64_t v4 = *(char **)v2;
      uint64_t v5 = *((void *)v2 + 5);
      *((void *)v2 + 5) = 0;
      if (v5)
      {
        int v6 = e5rt_io_port_release();
        if (v6)
        {
          int v7 = v6;
          if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            int v11 = v7;
            _os_log_error_impl(&dword_1D0DBD000, v3, OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
          }
        }
      }
      if (v2[39] < 0) {
        operator delete(*((void **)v2 + 2));
      }
      operator delete(v2);
      uint64_t v2 = v4;
    }
    while (v4);
  }
  uint64_t v8 = *(void **)a1;
  *(void *)a1 = 0;
  if (v8) {
    operator delete(v8);
  }
  return a1;
}

uint64_t sub_1D0DD8954(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1280))
  {
    uint64_t v2 = *(void **)(a1 + 984);
    if (v2)
    {
      *(void *)(a1 + 992) = v2;
      operator delete(v2);
    }
  }

  uint64_t v3 = *(void *)(a1 + 304);
  *(void *)(a1 + 304) = 0;
  if (v3)
  {
    uint64_t v4 = sub_1D0DF011C(v3);
    MEMORY[0x1D25F16B0](v4, 0x10A2C40AC51AD7DLL);
  }
  uint64_t v5 = *(void **)(a1 + 296);
  *(void *)(a1 + 296) = 0;
  if (v5)
  {
    int v6 = sub_1D0DD845C(v5);
    MEMORY[0x1D25F16B0](v6, 0x10A0C4041783943);
  }
  if (*(unsigned char *)(a1 + 288)) {

  }
  if (*(unsigned char *)(a1 + 264)) {
  uint64_t v7 = *(void *)(a1 + 240);
  }
  *(void *)(a1 + 240) = 0;
  if (v7)
  {
    sub_1D0DD86BC((uint64_t *)(v7 + 8));

    MEMORY[0x1D25F16B0](v7, 0x10A0C40079592F6);
  }
  uint64_t v8 = *(id **)(a1 + 232);
  *(void *)(a1 + 232) = 0;
  if (v8)
  {

    MEMORY[0x1D25F16B0](v8, 0x80C4018A671A6);
  }

  return a1;
}

uint64_t sub_1D0DD8B08(uint64_t a1, uint64_t a2, unsigned char *a3, void *a4)
{
  uint64_t v519 = *MEMORY[0x1E4F143B8];
  *a3 = 0;
  uint64_t v7 = *(void **)(a1 + 208);
  if (!v7)
  {
    uint64_t v8 = [MEMORY[0x1E4F351E0] sharedCaptureManager];
    uint64_t v9 = [v8 newCaptureScopeWithCommandQueue:*(void *)(a1 + 184)];
    int v10 = *(void **)(a1 + 208);
    *(void *)(a1 + 208) = v9;

    [*(id *)(a1 + 208) setLabel:@"ViewpointCorrectionProcessor"];
    uint64_t v7 = *(void **)(a1 + 208);
  }
  [v7 beginScope];
  int v11 = *(void **)(a1 + 208);
  v505[0] = &unk_1F26F3AB0;
  v506 = v505;
  id v12 = v11;
  id v507 = v12;
  v508[3] = v508;
  sub_1D0DE2BAC((uint64_t)v505, v508);

  if (v506 == v505)
  {
    (*(void (**)(void *))(v505[0] + 32))(v505);
    if (!*(_DWORD *)(a2 + 32)) {
      goto LABEL_10;
    }
  }
  else
  {
    if (v506) {
      (*(void (**)(void *))(*v506 + 40))(v506);
    }
    if (!*(_DWORD *)(a2 + 32)) {
      goto LABEL_10;
    }
  }
  if (!*(unsigned char *)(a1 + 1280)) {
    goto LABEL_267;
  }
LABEL_10:
  if (*(unsigned char *)(a1 + 1336))
  {
    *(_OWORD *)time1 = *(_OWORD *)(a1 + 1312);
    *(void *)&time1[16] = *(void *)(a1 + 1328);
    *(_OWORD *)time2 = *(_OWORD *)(a2 + 36);
    *(void *)&time2[16] = *(void *)(a2 + 52);
    if (CMTimeCompare((CMTime *)time1, (CMTime *)time2) < 0)
    {
      if (*(unsigned char *)(a1 + 1336)) {
        *(unsigned char *)(a1 + 1336) = 0;
      }
    }
  }
  long long v13 = (float32x4_t *)(a1 + 1288);
  CMTime v14 = *(float **)(a2 + 160);
  unsigned int v15 = *(float **)(a2 + 168);
  if (v14 == v15)
  {
    if (*(unsigned char *)(a1 + 1336))
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      size_t v51 = (id)qword_1EA6437C0;
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
      {
        buf.columns[0].i16[0] = 0;
        _os_log_debug_impl(&dword_1D0DBD000, v51, OS_LOG_TYPE_DEBUG, "Input data has no face detection, use cached data.", (uint8_t *)&buf, 2u);
      }

      int v52 = 0;
      uint64_t v447 = *(void *)(a1 + 1304);
      float32x4_t v452 = *v13;
      goto LABEL_83;
    }
    char v67 = 0;
    float32x4_t v452 = 0u;
  }
  else
  {
    if (*(unsigned char *)(a1 + 1280))
    {
      float v16 = *(float *)(a1 + 728);
      float v17 = *(float *)(a1 + 732);
      float v18 = *(float *)(a1 + 736);
      float v19 = *(float *)(a1 + 740);
      int v20 = v14 + 6;
      if (v14 + 6 != v15)
      {
        float v21 = v18 * v19;
        float v22 = v18 + v16;
        float v23 = v19 + v17;
        do
        {
          float v24 = v14[2];
          float v25 = 0.0;
          if (v24 >= 0.0)
          {
            float v26 = v14[3];
            if (v26 >= 0.0)
            {
              float v27 = v24 * v26;
              if ((float)(v24 * v26) > 0.0 && v18 >= 0.0 && v19 >= 0.0 && v21 > 0.0)
              {
                float v28 = *v14;
                float v29 = v14[1];
                float v30 = v24 + *v14;
                float v31 = v26 + v29;
                if (v22 < v30) {
                  float v30 = v18 + v16;
                }
                if (v28 < v16) {
                  float v28 = *(float *)(a1 + 728);
                }
                float v32 = fmaxf(v30 - v28, 0.0);
                if (v23 >= v31) {
                  float v33 = v31;
                }
                else {
                  float v33 = v19 + v17;
                }
                if (v29 >= v17) {
                  float v34 = v14[1];
                }
                else {
                  float v34 = *(float *)(a1 + 732);
                }
                float v35 = v32 * fmaxf(v33 - v34, 0.0);
                float v25 = v35 / (float)((float)(v27 + v21) - v35);
              }
            }
          }
          float v36 = v20[2];
          float v37 = 0.0;
          if (v36 >= 0.0)
          {
            float v38 = v20[3];
            if (v38 >= 0.0)
            {
              float v39 = v36 * v38;
              if ((float)(v36 * v38) > 0.0 && v18 >= 0.0 && v19 >= 0.0 && v21 > 0.0)
              {
                float v40 = *v20;
                float v41 = v20[1];
                float v42 = v36 + *v20;
                float v43 = v38 + v41;
                if (v22 < v42) {
                  float v42 = v18 + v16;
                }
                if (v40 < v16) {
                  float v40 = *(float *)(a1 + 728);
                }
                float v44 = fmaxf(v42 - v40, 0.0);
                if (v23 >= v43) {
                  float v45 = v43;
                }
                else {
                  float v45 = v19 + v17;
                }
                if (v41 >= v17) {
                  float v46 = v20[1];
                }
                else {
                  float v46 = *(float *)(a1 + 732);
                }
                float v47 = v44 * fmaxf(v45 - v46, 0.0);
                float v37 = v47 / (float)((float)(v39 + v21) - v47);
              }
            }
          }
          if (v25 < v37) {
            CMTime v14 = v20;
          }
          v20 += 6;
        }
        while (v20 != v15);
      }
      float v48 = v14[2];
      float v49 = 0.0;
      if (v48 >= 0.0)
      {
        float v50 = v14[3];
        if (v50 >= 0.0)
        {
          float v88 = v48 * v50;
          if ((float)(v48 * v50) > 0.0 && v18 >= 0.0 && v19 >= 0.0)
          {
            float v89 = v18 * v19;
            if ((float)(v18 * v19) > 0.0)
            {
              float v90 = v14[1];
              float v91 = v48 + *v14;
              float v92 = v50 + v90;
              float v93 = v18 + v16;
              float v94 = v19 + v17;
              if (v93 >= v91) {
                float v93 = v91;
              }
              if (*v14 >= v16) {
                float v16 = *v14;
              }
              float v95 = fmaxf(v93 - v16, 0.0);
              if (v94 >= v92) {
                float v94 = v92;
              }
              if (v90 >= v17) {
                float v17 = v14[1];
              }
              float v96 = v95 * fmaxf(v94 - v17, 0.0);
              float v49 = v96 / (float)((float)(v88 + v89) - v96);
            }
          }
        }
      }
      if (v49 <= 0.3) {
        CMTime v14 = *(float **)(a2 + 168);
      }
    }
    else
    {
      for (uint64_t i = v14 + 6; i != v15; i += 6)
      {
        float v54 = v14[2];
        float v55 = v14[3];
        float v56 = i[2];
        float v57 = i[3];
        _NF = v55 < 0.0 || v54 < 0.0;
        float v59 = v54 * v55;
        if (_NF) {
          float v59 = 0.0;
        }
        BOOL v60 = v57 < 0.0 || v56 < 0.0;
        float v61 = v56 * v57;
        if (v60) {
          float v61 = 0.0;
        }
        if (v59 < v61) {
          CMTime v14 = i;
        }
      }
    }
    if (v14 != v15)
    {
      uint64_t v62 = *(void *)v14;
      uint64_t v63 = *((void *)v14 + 1);
      uint64_t v64 = *((void *)v14 + 2);
      lhs.columns[0] = *(simd_float3 *)(a2 + 36);
      lhs.columns[1].i64[0] = *(void *)(a2 + 52);
      buf.columns[0].i64[0] = v62;
      buf.columns[0].i64[1] = v63;
      buf.columns[1].i64[0] = v64;
      CMTimeMakeWithSeconds((CMTime *)rhs, 0.0500000007, 1000);
      CMTimeAdd((CMTime *)&buf.columns[1].u32[2], (CMTime *)&lhs, (CMTime *)rhs);
      v65.i64[0] = v62;
      uint64_t v447 = v64;
      int v66 = *(unsigned __int8 *)(a1 + 1336);
      float32x4_t *v13 = (float32x4_t)buf.columns[0];
      *(void *)(a1 + 1304) = buf.columns[1].i64[0];
      *(simd_float3 *)(a1 + 1312) = *(simd_float3 *)((char *)&buf.columns[1] + 8);
      *(void *)(a1 + 1328) = buf.columns[2].i64[1];
      if (!v66) {
        *(unsigned char *)(a1 + 1336) = 1;
      }
      int v52 = 0;
      v65.i64[1] = v63;
      float32x4_t v452 = v65;
LABEL_83:
      char v67 = 1;
      goto LABEL_88;
    }
    float32x4_t v452 = 0u;
    char v67 = 0;
    if (*(unsigned char *)(a1 + 1336)) {
      *(unsigned char *)(a1 + 1336) = 0;
    }
  }
  int v52 = 1;
  uint64_t v447 = 0;
LABEL_88:
  v68 = (float32x4_t *)(a1 + 728);
  if (!*(unsigned char *)(a1 + 1280))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    unsigned int v69 = (id)qword_1EA6437C0;
    CVPixelBufferRef v70 = v69;
    if (v52)
    {
      if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
      {
        buf.columns[0].i16[0] = 0;
        _os_log_debug_impl(&dword_1D0DBD000, v70, OS_LOG_TYPE_DEBUG, "No face to track.", (uint8_t *)&buf, 2u);
      }

      goto LABEL_94;
    }
    if (os_log_type_enabled(v69, OS_LOG_TYPE_INFO))
    {
      buf.columns[0].i16[0] = 0;
      _os_log_impl(&dword_1D0DBD000, v70, OS_LOG_TYPE_INFO, "Tracking a new face.", (uint8_t *)&buf, 2u);
    }

    if (*(unsigned char *)(a1 + 1280))
    {
      uint64_t v82 = *(void **)(a1 + 984);
      if (v82)
      {
        *(void *)(a1 + 992) = v82;
        operator delete(v82);
      }
      *(unsigned char *)(a1 + 1280) = 0;
    }
    *(void *)(a1 + 744) = 0x3FD3333333333333;
    *(unsigned char *)(a1 + 776) = 0;
    *(unsigned char *)(a1 + 784) = 0;
    v68->i64[0] = 0;
    *(void *)(a1 + 736) = 0;
    uint64_t v83 = (long long *)MEMORY[0x1E4F1F9F8];
    long long v84 = *MEMORY[0x1E4F1F9F8];
    *(_OWORD *)(a1 + 752) = *MEMORY[0x1E4F1F9F8];
    uint64_t v85 = *((void *)v83 + 2);
    *(void *)(a1 + 768) = v85;
    *(void *)(a1 + 792) = 0;
    *(void *)(a1 + 896) = 0x3FA999999999999ALL;
    *(unsigned char *)(a1 + 928) = 0;
    *(unsigned char *)(a1 + 936) = 0;
    *(_OWORD *)(a1 + 800) = 0u;
    *(_OWORD *)(a1 + 816) = 0u;
    *(_OWORD *)(a1 + 832) = 0u;
    *(_OWORD *)(a1 + 848) = 0u;
    *(_OWORD *)(a1 + 864) = 0u;
    *(_OWORD *)(a1 + 880) = 0u;
    *(void *)(a1 + 920) = v85;
    *(_OWORD *)(a1 + 904) = v84;
    *(unsigned char *)(a1 + 944) = 1;
    *(_DWORD *)(a1 + 976) = 0;
    *(void *)(a1 + 952) = 0x3FF0000000000000;
    *(_OWORD *)(a1 + 984) = 0u;
    *(_OWORD *)(a1 + 1000) = 0u;
    sub_1D0DF3F48((void **)(a1 + 984), 0x25uLL);
    unint64_t v86 = *(void *)(a1 + 984);
    int64x2_t v87 = vshrq_n_s64(vsubq_s64(*(int64x2_t *)(a1 + 992), vdupq_n_s64(v86)), 4uLL);
    v87.i64[0] *= 0xAAAAAAAAAAAAAAABLL;
    if (0xAAAAAAAAAAAAAAABLL * v87.i64[1] <= v87.i64[0])
    {
      if (0xAAAAAAAAAAAAAAABLL * v87.i64[1] < v87.i64[0]) {
        *(void *)(a1 + 992) = v86 + 16 * v87.i64[1];
      }
    }
    else
    {
      sub_1D0DF3F48((void **)(a1 + 984), 0xAAAAAAAAAAAAAAABLL * v87.i64[1] - v87.i64[0]);
    }
    *(void *)(a1 + 1016) = 0x400000003EAAAAABLL;
    *(void *)(a1 + 1024) = 0;
    long long v97 = *v83;
    *(_OWORD *)(a1 + 1032) = *v83;
    uint64_t v98 = *((void *)v83 + 2);
    *(void *)(a1 + 1048) = v98;
    *(unsigned char *)(a1 + 1056) = 0;
    *(unsigned char *)(a1 + 1064) = 0;
    *(_DWORD *)(a1 + 1072) = 0;
    *(void *)(a1 + 1088) = 0x3FF0000000000000;
    *(unsigned char *)(a1 + 1120) = 0;
    *(unsigned char *)(a1 + 1128) = 0;
    *(_DWORD *)(a1 + 1080) = 0;
    *(_OWORD *)(a1 + 1096) = v97;
    *(void *)(a1 + 1112) = v98;
    *(_OWORD *)(a1 + 1136) = v97;
    *(void *)(a1 + 1152) = v98;
    *(unsigned char *)(a1 + 1160) = 0;
    *(unsigned char *)(a1 + 1168) = 0;
    *(_WORD *)(a1 + 1176) = 256;
    *(unsigned char *)(a1 + 1180) = 0;
    *(unsigned char *)(a1 + 1204) = 0;
    *(_DWORD *)(a1 + 1208) = 0;
    *(void *)(a1 + 1224) = 0x3FE0000000000000;
    *(unsigned char *)(a1 + 1256) = 0;
    *(unsigned char *)(a1 + 1264) = 0;
    *(_DWORD *)(a1 + 1216) = 0;
    *(_OWORD *)(a1 + 1232) = *v83;
    *(void *)(a1 + 1248) = *((void *)v83 + 2);
    *(_DWORD *)(a1 + 1272) = 1065353216;
    *(unsigned char *)(a1 + 1280) = 1;
  }
  float32x2_t v99 = *(float32x2_t *)(a2 + 64);
  float32x2_t v100 = vneg_f32(v99);
  float v101 = atan2f(v100.f32[0], v100.f32[1]);
  if (*(unsigned char *)(a1 + 1341)) {
    float v102 = sqrtf(vaddv_f32(vmul_f32(v99, v99))) / 0.069;
  }
  else {
    float v102 = 1.0;
  }
  int v103 = *(_DWORD *)(a2 + 32);
  simd_float3 v465 = *(simd_float3 *)(a2 + 36);
  uint64_t v466 = *(void *)(a2 + 52);
  if (!*(unsigned char *)(a1 + 1177))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    float32x4_t v108 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v108, OS_LOG_TYPE_ERROR)) {
      goto LABEL_150;
    }
    buf.columns[0].i16[0] = 0;
    v109 = "Precondition violated: isValid()";
    goto LABEL_241;
  }
  if (v102 <= 0.0)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    float32x4_t v108 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v108, OS_LOG_TYPE_ERROR)) {
      goto LABEL_150;
    }
    buf.columns[0].i16[0] = 0;
    v109 = "Precondition violated: faceDistanceFadeoutThresholdsMultiplier > 0.f";
LABEL_241:
    _os_log_error_impl(&dword_1D0DBD000, v108, OS_LOG_TYPE_ERROR, v109, (uint8_t *)&buf, 2u);
LABEL_150:

    unsigned int v110 = 1;
    uint64_t v80 = 2;
    goto LABEL_151;
  }
  if (v52)
  {
    int v104 = *(unsigned __int8 *)(a1 + 1204);
    goto LABEL_135;
  }
  *(void *)(a1 + 744) = 0x3FD3333333333333;
  buf.columns[0] = v465;
  buf.columns[1].i64[0] = v466;
  int v113 = sub_1D0DD8230(a1 + 752, (long long *)&buf);
  BOOL v115 = v113 != 0;
  if (v113)
  {
    int v116 = v113;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v80 = (2 * v115);
    v117 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR))
    {
      float v229 = off_1E689A510[v116 - 1];
      if ((v80 - 1) > 6) {
        float v230 = "Success, no error";
      }
      else {
        float v230 = off_1E689A510[(v80 - 1)];
      }
      *(_DWORD *)v509 = 136315394;
      *(void *)&v509[4] = v229;
      *(_WORD *)&v509[12] = 2080;
      *(void *)&v509[14] = v230;
      _os_log_error_impl(&dword_1D0DBD000, v117, OS_LOG_TYPE_ERROR, "Running m_timeDiff.update(timestamp) failed with %s, returning %s", v509, 0x16u);
    }

    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    int v118 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
    {
      float v231 = off_1E689A510[(v80 - 1)];
      buf.columns[0].i32[0] = 136315394;
      *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v231;
      buf.columns[0].i16[6] = 2080;
      *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v231;
      _os_log_error_impl(&dword_1D0DBD000, v118, OS_LOG_TYPE_ERROR, "Running m_normalizedPosition.update(face->normalizedPosition, timestamp) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
    }
    goto LABEL_237;
  }
  if (*(unsigned char *)(a1 + 784))
  {
    double v139 = *(double *)(a1 + 744);
    float v140 = 1.0;
    if (v139 > 0.0) {
      float v140 = 1.0 - exp(-*(double *)(a1 + 776) / v139);
    }
    float32x4_t v141 = v452;
    float32x4_t v142 = vaddq_f32(vmulq_n_f32(*v68, 1.0 - v140), vmulq_n_f32(v452, v140));
  }
  else
  {
    float32x4_t v141 = v452;
    float32x4_t v142 = v452;
  }
  float32x4_t *v68 = v142;
  *(void *)(a1 + 1224) = 0x3FE0000000000000;
  v114.f32[0] = v141.f32[0] + vmuls_lane_f32(0.5, v141, 2);
  float32x4_t v157 = v114;
  v157.i32[1] = v141.i32[1];
  *(float32x4_t *)logc = v157;
  v114.f32[1] = v141.f32[1] + v141.f32[3];
  float32x4_t v453 = v114;
  __asm { FMOV            V0.4S, #1.0 }
  v159.i64[1] = _Q0.i64[1];
  v159.i32[0] = v141.i32[0];
  *(float *)&unsigned int v160 = v141.f32[0] + v141.f32[2];
  v159.f32[1] = v141.f32[1] + vmuls_lane_f32(0.5, v141, 3);
  int32x4_t v161 = (int32x4_t)vmulq_f32(v159, v159);
  v161.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v161, 2), vadd_f32(*(float32x2_t *)v161.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v161.i8, 1))).u32[0];
  float32x2_t v162 = vrsqrte_f32((float32x2_t)v161.u32[0]);
  float32x2_t v163 = vmul_f32(v162, vrsqrts_f32((float32x2_t)v161.u32[0], vmul_f32(v162, v162)));
  _Q0.i64[0] = __PAIR64__(v159.u32[1], v160);
  int32x4_t v164 = (int32x4_t)vmulq_f32(_Q0, _Q0);
  v164.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v164, 2), vadd_f32(*(float32x2_t *)v164.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v164.i8, 1))).u32[0];
  float32x2_t v165 = vrsqrte_f32((float32x2_t)v164.u32[0]);
  float32x2_t v166 = vmul_f32(v165, vrsqrts_f32((float32x2_t)v164.u32[0], vmul_f32(v165, v165)));
  float32x4_t v167 = vmulq_f32(vmulq_n_f32(v159, vmul_f32(v163, vrsqrts_f32((float32x2_t)v161.u32[0], vmul_f32(v163, v163))).f32[0]), vmulq_n_f32(_Q0, vmul_f32(v166, vrsqrts_f32((float32x2_t)v164.u32[0], vmul_f32(v166, v166))).f32[0]));
  float v168 = acosf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v167, 2), vaddq_f32(v167, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v167.f32, 1))).f32[0]);
  float32x4_t v169 = *(float32x4_t *)logc;
  v169.i32[2] = 1.0;
  int32x4_t v170 = (int32x4_t)vmulq_f32(v169, v169);
  float32x4_t v171 = v169;
  v170.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v170, 2), vadd_f32(*(float32x2_t *)v170.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v170.i8, 1))).u32[0];
  *(float32x2_t *)v169.f32 = vrsqrte_f32((float32x2_t)v170.u32[0]);
  *(float32x2_t *)v169.f32 = vmul_f32(*(float32x2_t *)v169.f32, vrsqrts_f32((float32x2_t)v170.u32[0], vmul_f32(*(float32x2_t *)v169.f32, *(float32x2_t *)v169.f32)));
  float32x4_t v172 = vmulq_n_f32(v171, vmul_f32(*(float32x2_t *)v169.f32, vrsqrts_f32((float32x2_t)v170.u32[0], vmul_f32(*(float32x2_t *)v169.f32, *(float32x2_t *)v169.f32))).f32[0]);
  float32x4_t v173 = v453;
  v173.i32[2] = 1.0;
  int32x4_t v174 = (int32x4_t)vmulq_f32(v173, v173);
  float32x4_t v175 = v173;
  v174.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v174, 2), vadd_f32(*(float32x2_t *)v174.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v174.i8, 1))).u32[0];
  *(float32x2_t *)v173.f32 = vrsqrte_f32((float32x2_t)v174.u32[0]);
  *(float32x2_t *)v173.f32 = vmul_f32(*(float32x2_t *)v173.f32, vrsqrts_f32((float32x2_t)v174.u32[0], vmul_f32(*(float32x2_t *)v173.f32, *(float32x2_t *)v173.f32)));
  float32x4_t v176 = vmulq_f32(v172, vmulq_n_f32(v175, vmul_f32(*(float32x2_t *)v173.f32, vrsqrts_f32((float32x2_t)v174.u32[0], vmul_f32(*(float32x2_t *)v173.f32, *(float32x2_t *)v173.f32))).f32[0]));
  float v177 = acosf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v176, 2), vaddq_f32(v176, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v176.f32, 1))).f32[0]);
  if (v168 >= v177) {
    float v177 = v168;
  }
  *(_DWORD *)v509 = fminf(10.0 / tanf(v177 * 0.5), 1000.0);
  lhs.columns[0] = v465;
  lhs.columns[1].i64[0] = v466;
  unsigned int v178 = sub_1D0DF47F4(a1 + 1216, (float *)v509, (uint64_t)&lhs);
  unsigned int v179 = v178 - 1;
  if (v178 == 1) {
    uint64_t v80 = 2;
  }
  else {
    uint64_t v80 = v178;
  }
  if (!v178)
  {
    *(simd_float3 *)CMTime rhs = v465;
    *(void *)&rhs[16] = v466;
    int v182 = sub_1D0DD8230(a1 + 1136, (long long *)rhs);
    if (v182)
    {
      uint64_t v80 = 2 * (v182 != 0);
      int v118 = sub_1D0DF4E04();
      if (!os_log_type_enabled(v118, OS_LOG_TYPE_ERROR)) {
        goto LABEL_237;
      }
      if ((v80 - 1) > 6) {
        char v244 = "Success, no error";
      }
      else {
        char v244 = off_1E689A510[(v80 - 1)];
      }
      buf.columns[0].i32[0] = 136315394;
      *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)"Precondition was violated";
      buf.columns[0].i16[6] = 2080;
      *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v244;
      uint64_t v243 = "Running m_timeDiff.update(timestamp) failed with %s, returning %s";
      goto LABEL_349;
    }
    if (*(unsigned char *)(a1 + 1168))
    {
      for (float j = *(float *)(a1 + 792) - *(float *)&v447; j > 180.0; float j = j + -360.0)
        ;
      for (; j < -180.0; float j = j + 360.0)
        ;
      float v227 = fabsf(j);
      if (v227 > 75.0)
      {
        float v228 = sub_1D0DF4E04();
        if (os_log_type_enabled(v228, OS_LOG_TYPE_DEFAULT))
        {
          buf.columns[0].i32[0] = 134218240;
          *(double *)((char *)buf.columns[0].i64 + 4) = v227;
          buf.columns[0].i16[6] = 2048;
          *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = 0x4052C00000000000;
          _os_log_impl(&dword_1D0DBD000, v228, OS_LOG_TYPE_DEFAULT, "Roll angle diff (%f) was larger than expected (%f)", (uint8_t *)&buf, 0x16u);
        }

        int v104 = 1;
        if (!*(unsigned char *)(a1 + 1204))
        {
          *(simd_float3 *)(a1 + 1180) = v465;
          *(void *)(a1 + 1196) = v466;
          *(unsigned char *)(a1 + 1204) = 1;
        }
        goto LABEL_135;
      }
      if (*(unsigned char *)(a1 + 1204)) {
        *(unsigned char *)(a1 + 1204) = 0;
      }
    }
    else if (*(unsigned char *)(a1 + 1204))
    {
      int v104 = 1;
      goto LABEL_135;
    }
    int v104 = 0;
    *(void *)(a1 + 792) = v447;
LABEL_135:
    if (v104)
    {
      if (!*(unsigned char *)(a1 + 1176))
      {
        simd_float3 v486 = v465;
        *(void *)v487 = v466;
        *(_OWORD *)v483 = *(_OWORD *)(a1 + 1180);
        *(void *)&v483[16] = *(void *)(a1 + 1196);
        CMTimeSubtract((CMTime *)time, (CMTime *)&v486, (CMTime *)v483);
        if (CMTimeGetSeconds((CMTime *)time) >= 0.25)
        {
          uint64_t v105 = sub_1D0DF4E04();
          if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
          {
            buf.columns[0].i16[0] = 0;
            _os_log_impl(&dword_1D0DBD000, v105, OS_LOG_TYPE_DEFAULT, "Roll angle did not recover. Disabling correction.", (uint8_t *)&buf, 2u);
          }

          *(unsigned char *)(a1 + 1176) = 1;
        }
      }
    }
    *(float *)(a1 + 1208) = roundf((float)(v101 / 0.017453) / 90.0) * 90.0;
    *(float *)(a1 + 1272) = v102;
    char v106 = v67 ^ 1;
    if (v103) {
      char v106 = 1;
    }
    BOOL v107 = (v106 & 1) == 0 && *(unsigned char *)(a1 + 1176) == 0;
    buf.columns[0] = v465;
    buf.columns[1].i64[0] = v466;
    if (sub_1D0DD8230(a1 + 1032, (long long *)&buf))
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      int v119 = qword_1EA6437C0;
      if (os_log_type_enabled((os_log_t)qword_1EA6437C0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v509 = 136315394;
        *(void *)&v509[4] = "Precondition was violated";
        *(_WORD *)&v509[12] = 2080;
        *(void *)&v509[14] = "Assertion failed";
        _os_log_error_impl(&dword_1D0DBD000, v119, OS_LOG_TYPE_ERROR, "Running m_timeDiff.update(timestamp) failed with %s, returning %s", v509, 0x16u);
        if (atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire)) {
          goto LABEL_168;
        }
      }
      else if (atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire))
      {
LABEL_168:
        v120 = (id)qword_1EA6437C0;
        if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
        {
          buf.columns[0].i32[0] = 136315394;
          *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)"Assertion failed";
          buf.columns[0].i16[6] = 2080;
          *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)"Assertion failed";
          _os_log_error_impl(&dword_1D0DBD000, v120, OS_LOG_TYPE_ERROR, "Running m_trackingTimedSmoothStep.update(successfulTracking, timestamp) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
        }

        uint64_t v80 = 2;
        unsigned int v110 = 2;
        goto LABEL_151;
      }
      if (__cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      goto LABEL_168;
    }
    if (*(unsigned char *)(a1 + 1064))
    {
      float v122 = *(double *)(a1 + 1056);
      float v123 = 0.0;
      if (v107) {
        float v123 = *(float *)(a1 + 1024) + v122;
      }
      *(float *)(a1 + 1024) = v123;
      float v124 = v122 / *(float *)(a1 + 1020);
      float v125 = *(float *)(a1 + 1028);
      float v126 = fmaxf(v125 - v124, 0.0);
      float v127 = fminf(v124 + v125, 1.0);
      if (v123 >= *(float *)(a1 + 1016)) {
        float v126 = v127;
      }
      *(float *)(a1 + 1028) = v126;
    }
    if (*(unsigned char *)(a1 + 1176))
    {
      float v128 = sub_1D0DF40DC((float *)(a1 + 728));
      int v130 = *(_DWORD *)(a1 + 1012);
      if (v130)
      {
        if (v130 < 1)
        {
          float32x4_t v133 = 0uLL;
        }
        else
        {
          int v131 = *(_DWORD *)(a1 + 1008);
          uint64_t v132 = *(void *)(a1 + 984);
          float32x4_t v133 = 0uLL;
          int v134 = *(_DWORD *)(a1 + 1012);
          do
          {
            float32x4_t v129 = *(float32x4_t *)(v132 + 48 * v131);
            float32x4_t v133 = vaddq_f32(v133, v129);
            int v131 = (v131 + 1) % (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 992) - v132) >> 4));
            --v134;
          }
          while (v134);
        }
        v129.f32[0] = (float)v130;
        float32x4_t v183 = vdivq_f32(v133, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v129.f32, 0));
      }
      else
      {
        v183.i64[0] = 0;
        v183.i32[2] = 0;
      }
      float v187 = (float)(fabsf(v183.f32[2]) + -30.0) / 15.0;
      float v188 = 1.0 - v187;
      if (v187 > 1.0) {
        float v188 = 0.0;
      }
      float32x2_t v189 = vdiv_f32(vadd_f32(vabs_f32(*(float32x2_t *)v183.f32), (float32x2_t)0xC1600000C1F00000), (float32x2_t)0x4160000041700000);
      __asm { FMOV            V7.2S, #1.0 }
      float32x2_t v191 = (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v189), (int8x8_t)_D7, vbic_s8((int8x8_t)vsub_f32(_D7, v189), (int8x8_t)vcgt_f32(v189, _D7)));
      LODWORD(v192) = vmul_lane_f32(v191, v191, 1).u32[0];
      if (v187 >= 0.0) {
        float v193 = v188;
      }
      else {
        float v193 = 1.0;
      }
      float v194 = v128 * (float)(v193 * v192);
      float v195 = (float)(*(float *)(a1 + 1080) + -0.1875) * 8.0;
      float v196 = 1.0 - v195;
      if (v195 > 1.0) {
        float v196 = 0.0;
      }
      if (v195 >= 0.0) {
        float v197 = v196;
      }
      else {
        float v197 = 1.0;
      }
      float v186 = v194 * v197;
    }
    else
    {
      if (v107)
      {
        *(unsigned char *)(a1 + 1177) = 1;
        goto LABEL_94;
      }
      float v184 = *(float *)(a1 + 1028) + *(float *)(a1 + 1028);
      _NF = v184 < 1.0;
      float v185 = (float)((float)((float)(v184 + -1.0) * (float)((float)(v184 + -1.0) + -2.0)) + -1.0) * -0.5;
      float v186 = v184 * (float)(v184 * 0.5);
      if (!_NF) {
        float v186 = v185;
      }
    }
    *(unsigned char *)(a1 + 1177) = v186 > 0.0;
    if (v186 > 0.0)
    {
LABEL_94:
      if (*(unsigned char *)(a1 + 1280))
      {
        if (!*(unsigned char *)(a1 + 1177))
        {
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EA6437C8))
          {
            qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
            __cxa_guard_release(&qword_1EA6437C8);
          }
          unsigned int v121 = (id)qword_1EA6437C0;
          if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR))
          {
            buf.columns[0].i16[0] = 0;
            _os_log_error_impl(&dword_1D0DBD000, v121, OS_LOG_TYPE_ERROR, "Assertion failed: m_trackedFace->isValid()", (uint8_t *)&buf, 2u);
          }

          goto LABEL_175;
        }
        float32x4_t v71 = *(float32x4_t *)(a2 + 80);
        float32x4_t v72 = *(float32x4_t *)(a2 + 96);
        long long v73 = *(_OWORD *)(a2 + 112);
        float32x2_t v74 = vadd_f32(*(float32x2_t *)&v73, (float32x2_t)*(_OWORD *)&vmlaq_lane_f32(vmulq_n_f32(v71, COERCE_FLOAT(*v68)), v72, *(float32x2_t *)v68->f32, 1));
        float32x2_t v75 = vsub_f32(vadd_f32(*(float32x2_t *)&v73, (float32x2_t)*(_OWORD *)&vmlaq_lane_f32(vmulq_n_f32(v71, vaddq_f32(*v68, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v68, 2)).f32[0]), v72, (float32x2_t)*(_OWORD *)&vaddq_f32(*v68, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v68, 3)), 1)), v74);
        float32x2_t v76 = vadd_f32(v74, (float32x2_t)0x3F0000003F000000);
        float32x2_t v459 = v76;
        float32x2_t v460 = v75;
        if (sub_1D0DF40DC((float *)(a1 + 728)) > 0.0)
        {
          kdebug_trace();
          unsigned int v77 = sub_1D0DDD9C8((void *)a1, (CVPixelBufferRef *)a2);
          unsigned int v78 = v77;
          unsigned int v79 = v77 - 1;
          if (v77 == 1) {
            uint64_t v80 = 2;
          }
          else {
            uint64_t v80 = v77;
          }
          if (v77)
          {
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EA6437C8))
            {
              qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
              __cxa_guard_release(&qword_1EA6437C8);
            }
            BOOL v81 = (id)qword_1EA6437C0;
            if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
            {
              if (v78 > 7) {
                v236 = "Success, no error";
              }
              else {
                v236 = off_1E689A510[v79];
              }
              if (v80 > 7) {
                uint64_t v241 = "Success, no error";
              }
              else {
                uint64_t v241 = off_1E689A510[(v80 - 1)];
              }
              buf.columns[0].i32[0] = 136315394;
              *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v236;
              buf.columns[0].i16[6] = 2080;
              *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v241;
              _os_log_error_impl(&dword_1D0DBD000, v81, OS_LOG_TYPE_ERROR, "Running setupYCrCbTextures(data) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
            }

LABEL_375:
            kdebug_trace();
            goto LABEL_317;
          }
          kdebug_trace();
          int v146 = [*(id *)(a1 + 712) width];
          int v147 = v146;
          uint64_t v148 = *(unsigned __int8 *)(a1 + 1340);
          float v149 = *(float *)(a1 + 792);
          *(void *)CMTime rhs = &unk_1F26F4478;
          float32x2_t v150 = v75;
          *(void *)&v492[16] = 0x3F80000000000000;
          *(void *)&v492[8] = 0;
          *(void *)&v492[24] = 0;
          *(void *)&v492[32] = 0x3F80000000000000;
          __asm { FMOV            V8.2S, #1.0 }
          *(void *)v492 = _D8;
          uint64_t v493 = 0;
          float v494 = 0.0;
          *(void *)&rhs[8] = *(void *)(a2 + 184);
          long long v155 = *(_OWORD *)(a2 + 80);
          HIDWORD(v155) = *(_OWORD *)(a2 + 96);
          int8x16_t v156 = vextq_s8(vextq_s8(*(int8x16_t *)(a2 + 96), *(int8x16_t *)(a2 + 96), 0xCuLL), *(int8x16_t *)(a2 + 112), 8uLL);
          *(_DWORD *)v492 = *(void *)(a2 + 120);
          *(_OWORD *)&rhs[16] = v155;
          int8x16_t v491 = v156;
          v483[28] = 0;
          LOBYTE(v484) = 0;
          *(void *)&v485[4] = 0;
          *(_DWORD *)v483 = 0;
          *(float32x2_t *)&long long v155 = vadd_f32(v76, (float32x2_t)0xBF000000BF000000);
          *((float32x2_t *)&v155 + 1) = v150;
          *(_OWORD *)&v483[4] = v155;
          *(float *)&v483[20] = -v149;
          v483[24] = 1;
          buf.columns[0].i64[0] = (uint64_t)&unk_1F26F4478;
          buf.columns[0].i64[1] = 0x100000001;
          *(uint64_t *)((char *)buf.columns[1].i64 + 4) = 0;
          *(uint64_t *)((char *)&buf.columns[1].i64[1] + 4) = 0x3F80000000000000;
          *(uint64_t *)((char *)buf.columns[2].i64 + 4) = 0;
          buf.columns[1].i32[0] = 1065353216;
          buf.columns[2].i32[3] = 0;
          *(void *)&v512[16] = 0x3F80000000000000;
          *(void *)&v512[8] = 0;
          *(void *)&v512[24] = 0;
          *(void *)&v512[32] = 0x3F80000000000000;
          *(void *)v512 = _D8;
          *(void *)&v512[40] = 0;
          float v513 = 0.0;
          *(_DWORD *)&time1[12] = 0;
          *(void *)&time1[4] = 0;
          *(void *)&time1[20] = 0;
          uint64_t v472 = 0x3F80000000000000;
          *(_DWORD *)time1 = 1065353216;
          *(_DWORD *)&time1[16] = 1065353216;
          *(_DWORD *)&time2[12] = 0;
          *(void *)&time2[4] = 0;
          *(void *)&time2[20] = 0;
          uint64_t v470 = 0x3F80000000000000;
          *(_DWORD *)time2 = 1065353216;
          *(_DWORD *)&time2[16] = 1065353216;
          uint64_t v448 = v148;
          *(void *)&CMTime time[4] = 0;
          *(_DWORD *)time = 1065353216;
          *(_OWORD *)&time[12] = xmmword_1D0E81450;
          if (v148) {
            sub_1D0E6520C(v146, (uint64_t)v483, (uint64_t)time, rhs, (uint64_t)&buf, (uint64_t)time1, (uint64_t)time2);
          }
          else {
            sub_1D0E64C14(v146, (uint64_t)v483, (uint64_t)time, (uint64_t)rhs, (uint64_t)&buf, (uint64_t)time1, (uint64_t)time2, COERCE_DOUBLE(1065353216));
          }
          simd_float3 v465 = (simd_float3)xmmword_1D0E81460;
          uint64_t v466 = 0;
          float v467 = (float)(v147 - 1);
          uint64_t v468 = 0x3F80000000000000;
          *(_OWORD *)v509 = xmmword_1D0E81470;
          *(_OWORD *)&v509[16] = xmmword_1D0E81480;
          int v510 = 1065353216;
          v463[0] = xmmword_1D0E81470;
          v463[1] = xmmword_1D0E81490;
          int v464 = 1065353216;
          *(void *)&v474[0] = v463;
          *((void *)&v474[0] + 1) = time1;
          v486.i64[0] = (uint64_t)v474;
          v486.i64[1] = (uint64_t)&v465;
          *(void *)time = &v486;
          *(void *)&time[8] = v509;
          memset(v461, 0, sizeof(v461));
          __int32 v462 = 0;
          sub_1D0DF6238((uint64_t)v461, (uint64_t *)time);
          __int32 v200 = buf.columns[1].i32[0];
          buf.columns[1].i32[0] = buf.columns[2].i32[0];
          buf.columns[2].i32[0] = v200;
          int32x2_t v201 = vrev64_s32(*(int32x2_t *)&buf.columns[0].u32[2]);
          buf.columns[2].i64[1] = __PAIR64__((float)(buf.columns[0].i32[2] - 1) - buf.columns[2].f32[2], buf.columns[2].u32[3]);
          *(int32x2_t *)&buf.columns[0].u32[2] = v201;
          *(_DWORD *)&time[20] = 0;
          *(_DWORD *)&time[8] = 0;
          *(void *)&time[24] = 0;
          long long v476 = 0x3F800000uLL;
          *(void *)time = 0xBF80000000000000;
          *(void *)&time[12] = 1065353216;
          simd_float3 v486 = (simd_float3)0x3F800000uLL;
          *(void *)&v487[4] = 0;
          *(void *)&v487[12] = 0x3F80000000000000;
          *(_DWORD *)v487 = 1065353216;
          float32x2_t v488 = 0;
          float v489 = 0.0;
          *(void *)&v474[0] = time;
          *((void *)&v474[0] + 1) = &v512[4];
          sub_1D0DF1BF0((uint64_t)&v486, (float **)v474);
          v473[0] = (float *)time;
          v473[1] = (float *)&v512[40];
          *(void *)((char *)v474 + 4) = 0;
          HIDWORD(v474[0]) = 0;
          sub_1D0DF1DA0((float *)v474 + 1, v473);
          float32x2_t v488 = vadd_f32(*(float32x2_t *)((char *)v474 + 4), 0);
          float v489 = *((float *)v474 + 3) + 0.0;
          *(simd_float3 *)&v512[4] = v486;
          *(_OWORD *)&v512[20] = *(_OWORD *)v487;
          *(_DWORD *)&v512[36] = *(_DWORD *)&v487[16];
          *(float32x2_t *)&v512[40] = v488;
          float v513 = *((float *)v474 + 3) + 0.0;
          v202.i64[0] = *((void *)&v461[1] + 1);
          v202.i32[2] = v462;
          lhs.columns[0] = (simd_float3)v461[0];
          lhs.columns[1] = *(simd_float3 *)((char *)v461 + 12);
          lhs.columns[2] = v202;
          v496 = &unk_1F26F4478;
          int32x2_t v497 = v201;
          simd_float3 v499 = buf.columns[2];
          simd_float3 v498 = buf.columns[1];
          int v500 = *(_DWORD *)v512;
          int v502 = *(_DWORD *)&v487[16];
          v501[1] = *(_OWORD *)v487;
          v501[0] = v486;
          float v504 = *((float *)v474 + 3) + 0.0;
          float32x2_t v503 = v488;
          kdebug_trace();
          if (*(unsigned char *)(a1 + 1280))
          {
            if (*(void *)(a1 + 192))
            {
              v203 = [*(id *)(a1 + 184) commandBuffer];
              [v203 setLabel:@"ViewpointCorrectionProcessor::performCrops"];
              if (v203)
              {
                v204 = v203;
                uint64_t v205 = a1 + 8 * v448;
                v207 = *(void **)(v205 + 216);
                uint64_t v206 = (id *)(v205 + 216);
                id v208 = v207;
                if (v208)
                {
                  v209 = v208;
                  uint64_t v210 = *(void *)(a1 + 192);
                  uint64_t v211 = *(void *)(a1 + 712);
                  buf.columns[0] = (simd_float3)xmmword_1D0E814A0;
                  objc_msgSend(v208, "encodeToCommandBuffer:sourceTexture:transform:destinationTexture:destinationBoundingBox:", v204, v210, v211, &buf, *(double *)lhs.columns[0].i64, *(double *)lhs.columns[1].i64, *(double *)lhs.columns[2].i64);

                  float32x4_t v212 = *(id **)(a1 + 232);
                  float32x4_t v213 = *(void **)(a1 + 712);
                  id v214 = *(id *)(a1 + 720);
                  v454 = v204;
                  id v215 = v214;
                  id v216 = v213;
                  float32x4_t v217 = v216;
                  if (v215)
                  {
                    if (v216)
                    {
                      if ([v215 pixelFormat] == 25)
                      {
                        if ([v217 pixelFormat] == 25)
                        {
                          uint64_t v218 = [v217 height];
                          if (v218 == 2 * [v212[3] height])
                          {
                            uint64_t v219 = [v217 width];
                            if (v219 == [v212[3] width])
                            {
                              v449 = [v454 computeCommandEncoder];
                              if (v449)
                              {
                                *(void *)[v212[1] contents] = 0x3DCCCCCD00000005;
                                [v449 setComputePipelineState:v212[2]];
                                [v449 setBuffer:v212[1] offset:0 atIndex:0];
                                [v449 setTexture:v217 atIndex:0];
                                [v449 setTexture:v215 atIndex:1];
                                [v449 setTexture:v212[3] atIndex:2];
                                unint64_t logd = [v212[2] threadExecutionWidth];
                                unint64_t v436 = [v212[2] maxTotalThreadsPerThreadgroup];
                                uint64_t v432 = [v215 width];
                                uint64_t v220 = [v215 height];
                                buf.columns[0].i64[0] = v432;
                                buf.columns[0].i64[1] = v220;
                                buf.columns[1].i64[0] = 1;
                                *(void *)CMTime rhs = logd;
                                *(void *)&rhs[8] = v436 / logd;
                                *(void *)&rhs[16] = 1;
                                [v449 dispatchThreads:&buf threadsPerThreadgroup:rhs];
                                [v449 endEncoding];
                                log = [v454 blitCommandEncoder];
                                uint64_t v221 = [v212[3] height];
                                uint64_t v437 = [v212[3] width];
                                uint64_t v433 = [v212[3] height];
                                uint64_t v222 = [v212[3] depth];
                                id v223 = v212[3];
                                memset(time, 0, 24);
                                v486.i64[0] = v437;
                                v486.i64[1] = v433;
                                *(void *)v487 = v222;
                                *(void *)v483 = 0;
                                *(void *)&v483[8] = v221;
                                *(void *)&v483[16] = 0;
                                [log copyFromTexture:v223 sourceSlice:0 sourceLevel:0 sourceOrigin:time sourceSize:&v486 toTexture:v217 destinationSlice:0 destinationLevel:0 destinationOrigin:v483];
                                [log endEncoding];
                                uint64_t v224 = 0;
                              }
                              else
                              {
                                log = sub_1D0DF4E04();
                                if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
                                {
                                  *(_WORD *)time1 = 0;
                                  uint64_t v224 = 2;
                                  _os_log_error_impl(&dword_1D0DBD000, log, OS_LOG_TYPE_ERROR, "Assertion failed: encoder", time1, 2u);
                                }
                                else
                                {
                                  uint64_t v224 = 2;
                                }
                              }

                              uint64_t v80 = v224;
                              if (!v224)
                              {
                                if (*(unsigned char *)(a1 + 944))
                                {
                                  float32x2_t v253 = vmla_f32(v459, v460, *(float32x2_t *)(a1 + 808));
                                  float32x2_t v254 = vmla_f32(v459, v460, *(float32x2_t *)(a1 + 816));
                                  float32x2_t v255 = vmla_f32(v459, v460, *(float32x2_t *)(a1 + 824));
                                  float32x2_t v256 = vmla_f32(v459, v460, *(float32x2_t *)(a1 + 832));
                                  float32x2_t v257 = vmla_f32(v459, v460, *(float32x2_t *)(a1 + 840));
                                  float32x2_t v258 = vmla_f32(v459, v460, *(float32x2_t *)(a1 + 848));
                                  float32x2_t v259 = vmla_f32(v459, v460, *(float32x2_t *)(a1 + 856));
                                  float32x2_t v260 = vmla_f32(v459, v460, *(float32x2_t *)(a1 + 864));
                                  float32x2_t v261 = vmla_f32(v459, v460, *(float32x2_t *)(a1 + 872));
                                  float32x2_t v262 = vmla_f32(v459, v460, *(float32x2_t *)(a1 + 880));
                                  float32x2_t v263 = vmla_f32(v459, v460, *(float32x2_t *)(a1 + 888));
                                  *(float32x2_t *)time = vmla_f32(v459, v460, *(float32x2_t *)(a1 + 800));
                                  *(float32x2_t *)&time[8] = v253;
                                  *(float32x2_t *)&time[16] = v254;
                                  *(float32x2_t *)&time[24] = v255;
                                  *(float32x2_t *)&long long v476 = v256;
                                  *((float32x2_t *)&v476 + 1) = v257;
                                  float32x2_t v477 = v258;
                                  float32x2_t v478 = v259;
                                  float32x2_t v479 = v260;
                                  float32x2_t v480 = v261;
                                  float32x2_t v481 = v262;
                                  float32x2_t v482 = v263;
                                  float32x2_t v264 = *(float32x2_t *)(a2 + 64);
                                  v420 = v454;
                                  id v419 = *v206;
                                  if (!v419)
                                  {
                                    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EA6437C8))
                                    {
                                      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                                      __cxa_guard_release(&qword_1EA6437C8);
                                    }
                                    v369 = (id)qword_1EA6437C0;
                                    if (os_log_type_enabled(v369, OS_LOG_TYPE_ERROR))
                                    {
                                      buf.columns[0].i16[0] = 0;
                                      _os_log_error_impl(&dword_1D0DBD000, v369, OS_LOG_TYPE_ERROR, "Assertion failed: sampler", (uint8_t *)&buf, 2u);
                                    }

                                    uint64_t v80 = 2;
                                    int v370 = 2;
                                    goto LABEL_431;
                                  }
                                  simd_float3x3 v520 = __invert_f3(lhs);
                                  float32x4_t v438 = (float32x4_t)v520.columns[0];
                                  float32x4_t loga = (float32x4_t)v520.columns[2];
                                  float32x4_t v450 = (float32x4_t)v520.columns[1];
                                  float32x4x3_t v265 = (char *)operator new(0x60uLL);
                                  uint64_t v266 = 0;
                                  *(_OWORD *)float32x4x3_t v265 = 0u;
                                  *((_OWORD *)v265 + 1) = 0u;
                                  *((_OWORD *)v265 + 2) = 0u;
                                  *((_OWORD *)v265 + 3) = 0u;
                                  *((_OWORD *)v265 + 4) = 0u;
                                  *((_OWORD *)v265 + 5) = 0u;
                                  do
                                  {
                                    int32x4_t v267 = (int32x4_t)vaddq_f32(loga, vmlaq_lane_f32(vmulq_n_f32(v438, COERCE_FLOAT(*(void *)&time[v266])), v450, *(float32x2_t *)&time[v266], 1));
                                    *(float32x2_t *)&v265[v266] = vdiv_f32(*(float32x2_t *)v267.i8, (float32x2_t)vdup_laneq_s32(v267, 2));
                                    v266 += 8;
                                  }
                                  while (v266 != 96);
                                  __p = v265;
                                  *(float *)v268.i32 = (float)(int)[*(id *)(a1 + 712) width] * 0.5;
                                  float32x2_t v269 = (float32x2_t)vdupq_lane_s32(v268, 0).u64[0];
                                  int32x4_t v270 = (int32x4_t)vaddq_f32((float32x4_t)lhs.columns[2], vmlaq_n_f32(vmulq_n_f32((float32x4_t)lhs.columns[0], *(float *)v268.i32), (float32x4_t)lhs.columns[1], *(float *)v268.i32));
                                  float32x2_t v271 = vmul_f32(v264, v264);
                                  v271.i32[0] = vadd_f32(v271, (float32x2_t)vdup_lane_s32((int32x2_t)v271, 1)).u32[0];
                                  float32x2_t v272 = vrsqrte_f32((float32x2_t)v271.u32[0]);
                                  float32x2_t v273 = vmul_f32(v272, vrsqrts_f32((float32x2_t)v271.u32[0], vmul_f32(v272, v272)));
                                  *(float32x2_t *)v270.i8 = vadd_f32(vdiv_f32(*(float32x2_t *)v270.i8, (float32x2_t)vdup_laneq_s32(v270, 2)), vmul_n_f32(v264, vmul_f32(v273, vrsqrts_f32((float32x2_t)v271.u32[0], vmul_f32(v273, v273))).f32[0]));
                                  int32x4_t v274 = (int32x4_t)vaddq_f32(loga, vmlaq_lane_f32(vmulq_n_f32(v438, *(float *)v270.i32), v450, *(float32x2_t *)v270.i8, 1));
                                  float32x2_t v275 = vsub_f32(vdiv_f32(*(float32x2_t *)v274.i8, (float32x2_t)vdup_laneq_s32(v274, 2)), v269);
                                  float v276 = atan2f(v275.f32[1], v275.f32[0]);
                                  char v277 = 0;
                                  uint64_t v278 = 0;
                                  float v279 = *(float *)(a1 + 696);
                                  float v280 = v279 - v276;
                                  float v281 = (float)(v279 - v276) + (float)(v279 * -2.0);
                                  v465.i16[0] = 1;
                                  while (1)
                                  {
                                    char v430 = v277;
                                    int v282 = v465.u8[v278];
                                    uint64_t v283 = 320;
                                    if (!v465.i8[v278]) {
                                      uint64_t v283 = 496;
                                    }
                                    uint64_t v431 = v283;
                                    uint64_t v284 = a1 + 320;
                                    if (!v465.i8[v278]) {
                                      uint64_t v284 = a1 + 496;
                                    }
                                    uint64_t v451 = v284;
                                    id v285 = *(id *)(v284 + 160);
                                    int v286 = [v285 width];

                                    id v287 = *(id *)(v451 + 160);
                                    uint64_t v288 = [v287 width];
                                    id v289 = *(id *)(v451 + 160);
                                    uint64_t v416 = [v289 height];
                                    uint64_t v417 = v288;

                                    if (v288 != v416) {
                                      break;
                                    }
                                    if (v282) {
                                      uint64_t v290 = 0;
                                    }
                                    else {
                                      uint64_t v290 = 48;
                                    }
                                    if (v282) {
                                      float v291 = v281;
                                    }
                                    else {
                                      float v291 = v280;
                                    }
                                    unint64_t v292 = (unint64_t)__sincosf_stret(v291);
                                    v293 = (float32x2_t *)operator new(0x30uLL);
                                    v294 = v293;
                                    uint64_t v295 = 0;
                                    float32x4_t v296 = (float32x4_t)HIDWORD(v292);
                                    v296.i32[1] = v292;
                                    float32x4_t v297 = (float32x4_t)COERCE_UNSIGNED_INT(-*(float *)&v292);
                                    v297.i32[1] = HIDWORD(v292);
                                    float32x4_t v298 = v296;
                                    v298.i32[3] = v423;
                                    int8x16_t v299 = (int8x16_t)v297;
                                    v299.i32[3] = v422;
                                    int8x16_t v300 = (int8x16_t)xmmword_1D0E814B0;
                                    v300.i32[3] = v421;
                                    float32x2_t v301 = *(float32x2_t *)&__p[v290];
                                    float32x2_t v302 = *(float32x2_t *)&__p[v290 + 8];
                                    float32x2_t v303 = vadd_f32((float32x2_t)*(_OWORD *)&vmlaq_lane_f32(vmulq_n_f32(v296, v301.f32[0]), v297, v301, 1), 0);
                                    *(float32x2_t *)&long long v304 = v303;
                                    *((float32x2_t *)&v304 + 1) = vadd_f32((float32x2_t)*(_OWORD *)&vmlaq_lane_f32(vmulq_n_f32(v296, v302.f32[0]), v297, v302, 1), 0);
                                    float32x2_t v305 = *(float32x2_t *)&__p[v290 + 16];
                                    float32x2_t v306 = *(float32x2_t *)&__p[v290 + 24];
                                    *(float32x2_t *)&long long v307 = vadd_f32((float32x2_t)*(_OWORD *)&vmlaq_lane_f32(vmulq_n_f32(v296, v305.f32[0]), v297, v305, 1), 0);
                                    float32x2_t v308 = vadd_f32((float32x2_t)*(_OWORD *)&vmlaq_lane_f32(vmulq_n_f32(v296, v306.f32[0]), v297, v306, 1), 0);
                                    float32x2_t v309 = vminnm_f32(vminnm_f32(v303, *(float32x2_t *)((char *)&v304 + 8)), *(float32x2_t *)&v307);
                                    float32x2_t v310 = vmaxnm_f32(vmaxnm_f32(v303, *(float32x2_t *)((char *)&v304 + 8)), *(float32x2_t *)&v307);
                                    *((float32x2_t *)&v307 + 1) = v308;
                                    *(_OWORD *)v293->f32 = v304;
                                    *(_OWORD *)v293[2].f32 = v307;
                                    float32x2_t v311 = *(float32x2_t *)&__p[v290 + 32];
                                    float32x2_t v312 = *(float32x2_t *)&__p[v290 + 40];
                                    *(float32x2_t *)&long long v307 = vadd_f32((float32x2_t)*(_OWORD *)&vmlaq_lane_f32(vmulq_n_f32(v296, v311.f32[0]), v297, v311, 1), 0);
                                    *((float32x2_t *)&v307 + 1) = vadd_f32((float32x2_t)*(_OWORD *)&vmlaq_lane_f32(vmulq_n_f32(v296, v312.f32[0]), v297, v312, 1), 0);
                                    *(_OWORD *)v293[4].f32 = v307;
                                    float32x2_t v313 = vsub_f32(vmaxnm_f32(vmaxnm_f32(vmaxnm_f32(v310, v308), *(float32x2_t *)&v307), *(float32x2_t *)((char *)&v307 + 8)), vminnm_f32(vminnm_f32(vminnm_f32(v309, v308), *(float32x2_t *)&v307), *(float32x2_t *)((char *)&v307 + 8)));
                                    if (v313.f32[0] < v313.f32[1]) {
                                      v313.f32[0] = v313.f32[1];
                                    }
                                    float v314 = 0.0;
                                    do
                                    {
                                      float32x2_t v315 = *(float32x2_t *)&__p[v290 + v295];
                                      float32x2_t v316 = vsub_f32(v315, v301);
                                      float v317 = sqrtf(vaddv_f32(vmul_f32(v316, v316)));
                                      if (v314 < v317) {
                                        float v314 = v317;
                                      }
                                      float32x2_t v318 = vsub_f32(v315, v302);
                                      float v319 = sqrtf(vaddv_f32(vmul_f32(v318, v318)));
                                      if (v314 < v319) {
                                        float v314 = v319;
                                      }
                                      float32x2_t v320 = vsub_f32(v315, v305);
                                      float v321 = sqrtf(vaddv_f32(vmul_f32(v320, v320)));
                                      if (v314 < v321) {
                                        float v314 = v321;
                                      }
                                      float32x2_t v322 = vsub_f32(v315, v306);
                                      float v323 = sqrtf(vaddv_f32(vmul_f32(v322, v322)));
                                      if (v314 < v323) {
                                        float v314 = v323;
                                      }
                                      float32x2_t v324 = vsub_f32(v315, v311);
                                      float v325 = sqrtf(vaddv_f32(vmul_f32(v324, v324)));
                                      if (v314 < v325) {
                                        float v314 = v325;
                                      }
                                      float32x2_t v326 = vsub_f32(v315, v312);
                                      float v327 = sqrtf(vaddv_f32(vmul_f32(v326, v326)));
                                      if (v314 < v327) {
                                        float v314 = v327;
                                      }
                                      v295 += 8;
                                    }
                                    while (v295 != 48);
                                    float32x2_t v328 = v293[1];
                                    float32x2_t v329 = v293[2];
                                    float32x2_t v330 = vminnm_f32(v303, v328);
                                    float32x2_t v331 = vmaxnm_f32(v303, v328);
                                    float32x2_t v332 = vminnm_f32(v330, v329);
                                    float32x2_t v333 = vmaxnm_f32(v331, v329);
                                    float32x2_t v334 = v293[3];
                                    float32x2_t v335 = v293[4];
                                    float32x2_t v336 = vminnm_f32(vminnm_f32(v332, v334), v335);
                                    float32x2_t v337 = vmaxnm_f32(vmaxnm_f32(v333, v334), v335);
                                    float32x2_t v338 = v293[5];
                                    float32x2_t v339 = vminnm_f32(v336, v338);
                                    float32x2_t v340 = vsub_f32(vmaxnm_f32(v337, v338), v339);
                                    float v341 = v340.f32[1];
                                    if (v340.f32[0] >= v340.f32[1]) {
                                      float v341 = v340.f32[0];
                                    }
                                    v301.f32[0] = (float)((float)(v314 / v313.f32[0]) + (float)(v314 / v313.f32[0]))
                                                * v341;
                                    float32x2_t v342 = vadd_f32(v339, vmul_f32(vsub_f32((float32x2_t)vdup_lane_s32((int32x2_t)v301, 0), v340), (float32x2_t)0xBF000000BF000000));
                                    if (v282) {
                                      float v343 = (float)((float)(v314 / v313.f32[0]) + (float)(v314 / v313.f32[0])) * v341;
                                    }
                                    else {
                                      float v343 = 0.0;
                                    }
                                    float32x4_t v344 = (float32x4_t)HIDWORD(v292);
                                    v344.f32[1] = -*(float *)&v292;
                                    v345.i32[0] = 0;
                                    v345.f32[1] = v343;
                                    float32x2_t v346 = vadd_f32(v342, v345);
                                    float32x2_t v347 = (float32x2_t)vaddq_f32(vmlaq_lane_f32(vmulq_n_f32(v344, v346.f32[0]), (float32x4_t)v292, v346, 1), (float32x4_t)0).u64[0];
                                    float v348 = (float)v286 / v301.f32[0];
                                    float v349 = -v348;
                                    if (!v282) {
                                      float v349 = v348;
                                    }
                                    LODWORD(v350) = 0;
                                    *((float *)&v350 + 1) = v349;
                                    float32x4_t v351 = vaddq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)LODWORD(v348), *((float *)&v292 + 1)), (float32x4_t)v350, *(float32x2_t *)v296.f32, 1), (float32x4_t)0);
                                    float32x4_t v352 = vaddq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)LODWORD(v348), -*(float *)&v292), (float32x4_t)v350, *(float32x2_t *)v297.f32, 1), (float32x4_t)0);
                                    float32x4_t v353 = vaddq_f32(vmlaq_f32((float32x4_t)COERCE_UNSIGNED_INT(v348 * 0.0), (float32x4_t)0, (float32x4_t)v350), (float32x4_t)xmmword_1D0E814B0);
                                    float32x4_t v354 = vnegq_f32(vaddq_f32(v353, vmlaq_lane_f32(vmulq_n_f32(v351, v347.f32[0]), v352, v347, 1)));
                                    float32x4_t v355 = *(float32x4_t *)(MEMORY[0x1E4F14998] + 16);
                                    v354.i32[2] = *(_DWORD *)(MEMORY[0x1E4F14998] + 40);
                                    float32x4_t v356 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*MEMORY[0x1E4F14998], v351.f32[0]), v355, *(float32x2_t *)v351.f32, 1), v354, v351, 2);
                                    float32x4_t v357 = vmulq_n_f32(v356, v499.f32[2] + 0.5);
                                    v356.i32[3] = v423;
                                    *(float32x4_t *)loge = v356;
                                    float32x4_t v358 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*MEMORY[0x1E4F14998], v352.f32[0]), v355, *(float32x2_t *)v352.f32, 1), v354, v352, 2);
                                    v357.i64[0] = vmlaq_n_f32(v357, v358, *(float *)&v499.i32[3] + 0.5).u64[0];
                                    v358.i32[3] = v422;
                                    float32x4_t v359 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*MEMORY[0x1E4F14998], v353.f32[0]), v355, *(float32x2_t *)v353.f32, 1), v354, v353, 2);
                                    v359.i32[3] = v421;
                                    simd_float3 v434 = (simd_float3)v359;
                                    simd_float3 v439 = (simd_float3)v358;
                                    *(void *)CMTime rhs = &unk_1F26F4478;
                                    *(void *)&v492[16] = 0x3F80000000000000;
                                    *(void *)&v492[24] = 0;
                                    *(void *)&v492[32] = 0x3F80000000000000;
                                    *(void *)&v492[8] = 0;
                                    uint64_t v493 = 0;
                                    float v494 = 0.0;
                                    *(_DWORD *)&rhs[8] = v286;
                                    *(_DWORD *)&rhs[12] = v286;
                                    *(float *)&rhs[16] = v348 * v498.f32[0];
                                    *(void *)&rhs[20] = 0;
                                    *(_DWORD *)&rhs[28] = 0;
                                    *(float *)v491.i32 = v348 * v498.f32[0];
                                    v491.i32[1] = 0;
                                    *(_DWORD *)&v492[4] = HIDWORD(_D8);
                                    v491.u64[1] = (unint64_t)vadd_f32(vadd_f32(*(float32x2_t *)v359.f32, *(float32x2_t *)v357.f32), (float32x2_t)0xBF000000BF000000);
                                    *(_DWORD *)v492 = 1065353216;
                                    float32x4_t v360 = v298;
                                    v360.i32[3] = v299.i32[0];
                                    simd_float3 v486 = (simd_float3)v360;
                                    *(int8x16_t *)v487 = vextq_s8(vextq_s8(v299, v299, 0xCuLL), v300, 8uLL);
                                    *(_DWORD *)&v487[16] = 1065353216;
                                    float32x2_t v488 = 0;
                                    float v489 = 0.0;
                                    *(_DWORD *)&v483[28] = 0;
                                    *(_DWORD *)&v483[12] = 0;
                                    *(void *)&v483[20] = 0;
                                    *(void *)&v483[4] = 0;
                                    *(_DWORD *)v483 = 1065353216;
                                    *(_DWORD *)&v483[16] = 1065353216;
                                    int v484 = 1065353216;
                                    memset(v485, 0, sizeof(v485));
                                    *(void *)time1 = &v486;
                                    *(void *)&time1[8] = v501;
                                    sub_1D0DF1BF0((uint64_t)v483, (float **)time1);
                                    *(void *)time2 = &v486;
                                    *(void *)&time2[8] = &v503;
                                    *(void *)&time1[4] = 0;
                                    *(_DWORD *)&time1[12] = 0;
                                    sub_1D0DF1DA0((float *)&time1[4], (float **)time2);
                                    *(float32x2_t *)v485 = vadd_f32(*(float32x2_t *)&time1[4], 0);
                                    *(float *)&v485[8] = *(float *)&time1[12] + 0.0;
                                    *(_OWORD *)&v492[4] = *(_OWORD *)v483;
                                    *(_OWORD *)&v492[20] = *(_OWORD *)&v483[16];
                                    *(_DWORD *)&v492[36] = v484;
                                    uint64_t v493 = *(void *)v485;
                                    float v494 = *(float *)&time1[12] + 0.0;
                                    buf.columns[0] = *(simd_float3 *)loge;
                                    buf.columns[1] = v439;
                                    buf.columns[2] = v434;
                                    *(void *)v512 = &unk_1F26F4478;
                                    *(void *)&v512[8] = *(void *)&rhs[8];
                                    *(_OWORD *)&v512[16] = *(_OWORD *)&rhs[16];
                                    *(int8x16_t *)&v512[32] = v491;
                                    float v513 = *(float *)v492;
                                    long long v514 = *(_OWORD *)v483;
                                    long long v515 = *(_OWORD *)&v483[16];
                                    int v516 = v484;
                                    float v518 = *(float *)&time1[12] + 0.0;
                                    uint64_t v517 = *(void *)v485;
                                    operator delete(v294);
                                    simd_float3x3 v521 = __invert_f3(buf);
                                    float32x4_t v361 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)lhs.columns[0], v521.columns[0].f32[0]), (float32x4_t)lhs.columns[1], *(float32x2_t *)v521.columns[0].f32, 1), (float32x4_t)lhs.columns[2], (float32x4_t)v521.columns[0], 2);
                                    float32x4_t v362 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)lhs.columns[0], v521.columns[1].f32[0]), (float32x4_t)lhs.columns[1], *(float32x2_t *)v521.columns[1].f32, 1), (float32x4_t)lhs.columns[2], (float32x4_t)v521.columns[1], 2);
                                    float32x4_t v363 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)lhs.columns[0], v521.columns[2].f32[0]), (float32x4_t)lhs.columns[1], *(float32x2_t *)v521.columns[2].f32, 1), (float32x4_t)lhs.columns[2], (float32x4_t)v521.columns[2], 2);
                                    v361.i32[3] = v426;
                                    v362.i32[3] = v425;
                                    v363.i32[3] = v424;
                                    float32x4_t v440 = v362;
                                    *(float32x4_t *)logb = v361;
                                    v521.columns[0] = (simd_float3)v361;
                                    v521.columns[1] = (simd_float3)v362;
                                    float32x4_t v435 = v363;
                                    v521.columns[2] = (simd_float3)v363;
                                    simd_float3x3 v522 = __invert_f3(v521);
                                    simd_float3 v364 = v522.columns[0];
                                    v364.i32[3] = v429;
                                    v522.columns[1].i32[3] = v428;
                                    v522.columns[2].i32[3] = v427;
                                    *(simd_float3 *)(a1 + v431) = v364;
                                    *(simd_float3 *)(v451 + 16) = v522.columns[1];
                                    *(simd_float3 *)(v451 + 32) = v522.columns[2];
                                    *(void *)(v451 + 56) = *(void *)&v512[8];
                                    if ((unsigned char *)(v451 + 48) != v512)
                                    {
                                      long long v365 = *(_OWORD *)&v512[32];
                                      *(_OWORD *)(v451 + 64) = *(_OWORD *)&v512[16];
                                      *(_OWORD *)(v451 + 80) = v365;
                                      long long v366 = v515;
                                      *(_OWORD *)(v451 + 100) = v514;
                                      *(float *)(v451 + 96) = v513;
                                      *(_OWORD *)(v451 + 116) = v366;
                                      *(_DWORD *)(v451 + 132) = v516;
                                      *(void *)(v451 + 136) = v517;
                                      *(float *)(v451 + 144) = v518;
                                    }
                                    uint64_t v367 = *(void *)(a1 + 192);
                                    id v368 = *(id *)(v451 + 160);
                                    *(_OWORD *)CMTime rhs = xmmword_1D0E814C0;
                                    objc_msgSend(v419, "encodeToCommandBuffer:sourceTexture:transform:destinationTexture:destinationBoundingBox:", v420, v367, v368, rhs, *(double *)logb, *(double *)v440.i64, *(double *)v435.i64);

                                    char v277 = 1;
                                    uint64_t v278 = 1;
                                    __int32 v425 = v440.i32[3];
                                    __int32 v426 = HIDWORD(logb[1]);
                                    __int32 v424 = v435.i32[3];
                                    if (v430)
                                    {
                                      uint64_t v80 = 0;
                                      goto LABEL_430;
                                    }
                                  }
                                  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EA6437C8))
                                  {
                                    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                                    __cxa_guard_release(&qword_1EA6437C8);
                                  }
                                  v371 = (id)qword_1EA6437C0;
                                  if (os_log_type_enabled(v371, OS_LOG_TYPE_ERROR))
                                  {
                                    buf.columns[0].i16[0] = 0;
                                    _os_log_error_impl(&dword_1D0DBD000, v371, OS_LOG_TYPE_ERROR, "Precondition violated: eyeCropData.crop.texture().width == eyeCropData.crop.texture().height", (uint8_t *)&buf, 2u);
                                  }

                                  uint64_t v80 = 2;
LABEL_430:
                                  int v370 = v417 != v416;
                                  operator delete(__p);

                                  if (v417 != v416)
                                  {
LABEL_431:
                                    v372 = sub_1D0DF4E04();
                                    if (os_log_type_enabled(v372, OS_LOG_TYPE_ERROR))
                                    {
                                      v394 = off_1E689A510[v370 - 1];
                                      v395 = off_1E689A510[(v80 - 1)];
                                      buf.columns[0].i32[0] = 136315394;
                                      *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v394;
                                      buf.columns[0].i16[6] = 2080;
                                      *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v395;
                                      _os_log_error_impl(&dword_1D0DBD000, v372, OS_LOG_TYPE_ERROR, "Running cropEyes(commandBuffer, normalizedLandmarksToImage(**m_trackedFace->normalizedLandmarks(), bbox), data.virtualCameraOffset(), faceCropToImage, faceCropCamera, samplerMode) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
                                    }

                                    int v232 = v80;
                                    if (!v80) {
                                      goto LABEL_438;
                                    }
LABEL_372:
                                    char v247 = sub_1D0DF4E04();
                                    if (os_log_type_enabled(v247, OS_LOG_TYPE_ERROR))
                                    {
                                      unsigned int v248 = off_1E689A510[v232 - 1];
                                      v249 = off_1E689A510[(v80 - 1)];
                                      buf.columns[0].i32[0] = 136315394;
                                      *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v248;
                                      buf.columns[0].i16[6] = 2080;
                                      *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v249;
                                      _os_log_error_impl(&dword_1D0DBD000, v247, OS_LOG_TYPE_ERROR, "Running scheduleCrops(data, bbox, faceCropToImage, faceCropCamera, mode) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
                                    }

                                    goto LABEL_375;
                                  }
                                }
                                if (([v454 commitAndWaitUntilSubmitted] & 1) == 0) {
                                  [v454 waitUntilScheduled];
                                }

LABEL_438:
                                kdebug_trace();
                                if (*(unsigned char *)(a1 + 944))
                                {
                                  kdebug_trace();
                                  sub_1D0DDF28C(a1, v373);
                                  kdebug_trace();
                                }
                                if (*(unsigned char *)(*(void *)(a1 + 296) + 257))
                                {
                                  kdebug_trace();
                                  buf.columns[0].i64[0] = *(void *)(a2 + 64);
                                  if (sub_1D0DDF810(a1, (float32x2_t *)&buf))
                                  {
                                    v374 = sub_1D0DF4E04();
                                    if (os_log_type_enabled(v374, OS_LOG_TYPE_ERROR))
                                    {
                                      buf.columns[0].i32[0] = 136315394;
                                      *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)"Precondition was violated";
                                      buf.columns[0].i16[6] = 2080;
                                      *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)"Assertion failed";
                                      _os_log_error_impl(&dword_1D0DBD000, v374, OS_LOG_TYPE_ERROR, "Running writeCorrectionIntensitySurface(data.virtualCameraOffset()) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
                                    }

                                    kdebug_trace();
LABEL_175:
                                    uint64_t v80 = 2;
                                    goto LABEL_317;
                                  }
                                  kdebug_trace();
                                }
                                if (*(unsigned char *)(a1 + 944))
                                {
                                  v375 = [*(id *)(a1 + 184) commandBuffer];
                                  v376 = v375;
                                  if (!v375)
                                  {
                                    v385 = sub_1D0DF4E04();
                                    if (os_log_type_enabled(v385, OS_LOG_TYPE_ERROR))
                                    {
                                      buf.columns[0].i16[0] = 0;
                                      _os_log_error_impl(&dword_1D0DBD000, v385, OS_LOG_TYPE_ERROR, "Assertion failed: commandBuffer = [m_queue commandBuffer]", (uint8_t *)&buf, 2u);
                                    }

                                    v376 = 0;
                                    uint64_t v80 = 2;
                                    goto LABEL_468;
                                  }
                                  [v375 setLabel:@"ViewpointCorrectionProcessor::executeMetalOperationsEyes"];
                                  uint64_t v377 = *(void *)(a1 + 304);
                                  v378 = *(void **)(a1 + 192);
                                  v379 = *(void **)(a1 + 200);
                                  char v380 = sub_1D0DEFF78(a2);
                                  unsigned int v381 = sub_1D0DF0264(v377, v376, v378, v379, (long long *)(a1 + 496), (long long *)(a1 + 320), v380);
                                  unsigned int v382 = v381 - 1;
                                  if (v381 == 1) {
                                    uint64_t v80 = 2;
                                  }
                                  else {
                                    uint64_t v80 = v381;
                                  }
                                  if (v381)
                                  {
                                    v383 = sub_1D0DF4E04();
                                    if (os_log_type_enabled(v383, OS_LOG_TYPE_ERROR))
                                    {
                                      v404 = off_1E689A510[v382];
                                      v405 = off_1E689A510[(v80 - 1)];
                                      buf.columns[0].i32[0] = 136315394;
                                      *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v404;
                                      buf.columns[0].i16[6] = 2080;
                                      *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v405;
                                      _os_log_error_impl(&dword_1D0DBD000, v383, OS_LOG_TYPE_ERROR, "Running m_flowWarper->startEncoding(commandBuffer, m_textureY, m_textureCbCr, m_leftEye.imageToCropTransform, m_rightEye.imageToCropTransform, data.debugFlowEnabled()) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
                                    }

                                    goto LABEL_468;
                                  }
                                  v384 = v376;
                                }
                                else
                                {
                                  v384 = 0;
                                }
                                kdebug_trace();
                                unsigned int v386 = sub_1D0DDFA5C(a1, a2, &v459, (float32x4_t *)&lhs);
                                unsigned int v387 = v386 - 1;
                                if (v386 == 1) {
                                  uint64_t v80 = 2;
                                }
                                else {
                                  uint64_t v80 = v386;
                                }
                                if (v386)
                                {
                                  v388 = sub_1D0DF4E04();
                                  if (os_log_type_enabled(v388, OS_LOG_TYPE_ERROR))
                                  {
                                    v402 = off_1E689A510[v387];
                                    v403 = off_1E689A510[(v80 - 1)];
                                    buf.columns[0].i32[0] = 136315394;
                                    *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v402;
                                    buf.columns[0].i16[6] = 2080;
                                    *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v403;
                                    _os_log_error_impl(&dword_1D0DBD000, v388, OS_LOG_TYPE_ERROR, "Running runEyeNetwork(data, bbox, faceCropToImage) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
                                  }

                                  kdebug_trace();
                                  goto LABEL_467;
                                }
                                kdebug_trace();
                                if (v384)
                                {
                                  float v389 = sub_1D0DF433C(a1 + 728);
                                  unsigned int v390 = sub_1D0DF14BC(*(void *)(a1 + 304), v389);
                                  unsigned int v391 = v390;
                                  unsigned int v392 = v390 - 1;
                                  if (v390 == 1) {
                                    uint64_t v80 = 2;
                                  }
                                  else {
                                    uint64_t v80 = v390;
                                  }
                                  if (v390)
                                  {
                                    v393 = sub_1D0DF4E04();
                                    if (os_log_type_enabled(v393, OS_LOG_TYPE_ERROR))
                                    {
                                      if (v391 > 7) {
                                        v408 = "Success, no error";
                                      }
                                      else {
                                        v408 = off_1E689A510[v392];
                                      }
                                      if (v80 > 7) {
                                        v411 = "Success, no error";
                                      }
                                      else {
                                        v411 = off_1E689A510[(v80 - 1)];
                                      }
                                      buf.columns[0].i32[0] = 136315394;
                                      *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v408;
                                      buf.columns[0].i16[6] = 2080;
                                      *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v411;
                                      _os_log_error_impl(&dword_1D0DBD000, v393, OS_LOG_TYPE_ERROR, "Running m_flowWarper->endEncoding(fadeout) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
                                    }

                                    goto LABEL_467;
                                  }
                                  if (v389 > 0.0)
                                  {
                                    kdebug_trace();
                                    *a3 = 1;
                                    [v384 commit];
                                    [v384 waitUntilCompleted];
                                    kdebug_trace();
                                  }
                                }
                                uint64_t v396 = a4[1];
                                v456[0] = *a4;
                                v456[1] = v396;
                                if (v396) {
                                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v396 + 8), 1uLL, memory_order_relaxed);
                                }
                                unsigned int v397 = sub_1D0DDE6E0(a1, v456, (uint64_t)&v459, 1);
                                sub_1D0DCA2C0((uint64_t)v456);
                                if (v397 == 1) {
                                  uint64_t v80 = 2;
                                }
                                else {
                                  uint64_t v80 = v397;
                                }
                                if (v397)
                                {
                                  v398 = sub_1D0DF4E04();
                                  if (os_log_type_enabled(v398, OS_LOG_TYPE_ERROR))
                                  {
                                    v409 = off_1E689A510[v397 - 1];
                                    v410 = off_1E689A510[(v80 - 1)];
                                    buf.columns[0].i32[0] = 136315394;
                                    *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v409;
                                    buf.columns[0].i16[6] = 2080;
                                    *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v410;
                                    _os_log_error_impl(&dword_1D0DBD000, v398, OS_LOG_TYPE_ERROR, "Running writeDebugData(debugDictionary, bbox, true) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
                                  }
LABEL_513:

LABEL_467:
                                  v376 = v384;
LABEL_468:

                                  goto LABEL_317;
                                }
                                if (sub_1D0DEFFFC(a2))
                                {
                                  unsigned int v399 = sub_1D0DDDFA8(a1, a2);
                                  unsigned int v400 = v399;
                                  unsigned int v401 = v399 - 1;
                                  if (v399 == 1) {
                                    uint64_t v80 = 2;
                                  }
                                  else {
                                    uint64_t v80 = v399;
                                  }
                                  if (v399)
                                  {
                                    v398 = sub_1D0DF4E04();
                                    if (os_log_type_enabled(v398, OS_LOG_TYPE_ERROR))
                                    {
                                      if (v400 > 7) {
                                        v412 = "Success, no error";
                                      }
                                      else {
                                        v412 = off_1E689A510[v401];
                                      }
                                      if (v80 > 7) {
                                        v413 = "Success, no error";
                                      }
                                      else {
                                        v413 = off_1E689A510[(v80 - 1)];
                                      }
                                      buf.columns[0].i32[0] = 136315394;
                                      *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v412;
                                      buf.columns[0].i16[6] = 2080;
                                      *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v413;
                                      _os_log_error_impl(&dword_1D0DBD000, v398, OS_LOG_TYPE_ERROR, "Running drawInputData(data) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
                                    }
                                    goto LABEL_513;
                                  }
                                  unsigned int v406 = sub_1D0DE087C(a1, &v459);
                                  unsigned int v407 = v406 - 1;
                                  if (v406 == 1) {
                                    uint64_t v80 = 2;
                                  }
                                  else {
                                    uint64_t v80 = v406;
                                  }
                                  if (v406)
                                  {
                                    v398 = sub_1D0DF4E04();
                                    if (os_log_type_enabled(v398, OS_LOG_TYPE_ERROR))
                                    {
                                      v414 = off_1E689A510[v407];
                                      v415 = off_1E689A510[(v80 - 1)];
                                      buf.columns[0].i32[0] = 136315394;
                                      *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v414;
                                      buf.columns[0].i16[6] = 2080;
                                      *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v415;
                                      _os_log_error_impl(&dword_1D0DBD000, v398, OS_LOG_TYPE_ERROR, "Running drawDebugData(bbox) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
                                    }
                                    goto LABEL_513;
                                  }
                                }
                                uint64_t v80 = 0;
                                goto LABEL_467;
                              }
                              goto LABEL_363;
                            }
                            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
                              && __cxa_guard_acquire(&qword_1EA6437C8))
                            {
                              qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                              __cxa_guard_release(&qword_1EA6437C8);
                            }
                            v239 = (id)qword_1EA6437C0;
                            if (!os_log_type_enabled(v239, OS_LOG_TYPE_ERROR))
                            {
LABEL_362:

                              uint64_t v80 = 2;
                              LODWORD(v224) = 1;
LABEL_363:
                              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
                                && __cxa_guard_acquire(&qword_1EA6437C8))
                              {
                                qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                                __cxa_guard_release(&qword_1EA6437C8);
                              }
                              int v245 = (id)qword_1EA6437C0;
                              if (os_log_type_enabled(v245, OS_LOG_TYPE_ERROR))
                              {
                                v250 = off_1E689A510[(v224 - 1)];
                                v251 = off_1E689A510[(v80 - 1)];
                                buf.columns[0].i32[0] = 136315394;
                                *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v250;
                                buf.columns[0].i16[6] = 2080;
                                *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v251;
                                _os_log_error_impl(&dword_1D0DBD000, v245, OS_LOG_TYPE_ERROR, "Running m_imageAugmenter->encodeToCommandBuffer(commandBuffer, m_faceCropNoise.texture(), jitterOffset, maxLumaChange, m_faceCrop.texture()) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
                              }

                              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
                                && __cxa_guard_acquire(&qword_1EA6437C8))
                              {
                                qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                                __cxa_guard_release(&qword_1EA6437C8);
                              }
                              uint64_t v246 = (id)qword_1EA6437C0;
                              if (os_log_type_enabled(v246, OS_LOG_TYPE_ERROR))
                              {
                                uint64_t v252 = off_1E689A510[(v80 - 1)];
                                buf.columns[0].i32[0] = 136315394;
                                *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v252;
                                buf.columns[0].i16[6] = 2080;
                                *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v252;
                                _os_log_error_impl(&dword_1D0DBD000, v246, OS_LOG_TYPE_ERROR, "Running augmentFace(commandBuffer) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
                              }

                              v203 = v454;
                              goto LABEL_370;
                            }
                            *(_WORD *)time1 = 0;
                            v240 = "Precondition violated: ioTexture.width == m_intermediateTexture.width";
                          }
                          else
                          {
                            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
                              && __cxa_guard_acquire(&qword_1EA6437C8))
                            {
                              qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                              __cxa_guard_release(&qword_1EA6437C8);
                            }
                            v239 = (id)qword_1EA6437C0;
                            if (!os_log_type_enabled(v239, OS_LOG_TYPE_ERROR)) {
                              goto LABEL_362;
                            }
                            *(_WORD *)time1 = 0;
                            v240 = "Precondition violated: ioTexture.height == 2 * m_intermediateTexture.height";
                          }
                        }
                        else
                        {
                          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
                            && __cxa_guard_acquire(&qword_1EA6437C8))
                          {
                            qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                            __cxa_guard_release(&qword_1EA6437C8);
                          }
                          v239 = (id)qword_1EA6437C0;
                          if (!os_log_type_enabled(v239, OS_LOG_TYPE_ERROR)) {
                            goto LABEL_362;
                          }
                          *(_WORD *)time1 = 0;
                          v240 = "Precondition violated: ioTexture.pixelFormat == MTLPixelFormatR16Float";
                        }
                      }
                      else
                      {
                        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
                          && __cxa_guard_acquire(&qword_1EA6437C8))
                        {
                          qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                          __cxa_guard_release(&qword_1EA6437C8);
                        }
                        v239 = (id)qword_1EA6437C0;
                        if (!os_log_type_enabled(v239, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_362;
                        }
                        *(_WORD *)time1 = 0;
                        v240 = "Precondition violated: noiseTexture.pixelFormat == MTLPixelFormatR16Float";
                      }
                    }
                    else
                    {
                      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
                        && __cxa_guard_acquire(&qword_1EA6437C8))
                      {
                        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                        __cxa_guard_release(&qword_1EA6437C8);
                      }
                      v239 = (id)qword_1EA6437C0;
                      if (!os_log_type_enabled(v239, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_362;
                      }
                      *(_WORD *)time1 = 0;
                      v240 = "Precondition violated: ioTexture";
                    }
                  }
                  else
                  {
                    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
                      && __cxa_guard_acquire(&qword_1EA6437C8))
                    {
                      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                      __cxa_guard_release(&qword_1EA6437C8);
                    }
                    v239 = (id)qword_1EA6437C0;
                    if (!os_log_type_enabled(v239, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_362;
                    }
                    *(_WORD *)time1 = 0;
                    v240 = "Precondition violated: noiseTexture";
                  }
                  _os_log_error_impl(&dword_1D0DBD000, v239, OS_LOG_TYPE_ERROR, v240, time1, 2u);
                  goto LABEL_362;
                }
                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
                  && __cxa_guard_acquire(&qword_1EA6437C8))
                {
                  qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                  __cxa_guard_release(&qword_1EA6437C8);
                }
                double v238 = (id)qword_1EA6437C0;
                if (os_log_type_enabled(v238, OS_LOG_TYPE_ERROR))
                {
                  buf.columns[0].i16[0] = 0;
                  _os_log_error_impl(&dword_1D0DBD000, v238, OS_LOG_TYPE_ERROR, "Assertion failed: sampler", (uint8_t *)&buf, 2u);
                }

                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
                  && __cxa_guard_acquire(&qword_1EA6437C8))
                {
                  qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                  __cxa_guard_release(&qword_1EA6437C8);
                }
                float v233 = (id)qword_1EA6437C0;
                if (os_log_type_enabled(v233, OS_LOG_TYPE_ERROR))
                {
                  buf.columns[0].i32[0] = 136315394;
                  *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)"Assertion failed";
                  buf.columns[0].i16[6] = 2080;
                  *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)"Assertion failed";
                  _os_log_error_impl(&dword_1D0DBD000, v233, OS_LOG_TYPE_ERROR, "Running cropFace(commandBuffer, faceCropToImage, samplerMode) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
                }
                uint64_t v80 = 2;
              }
              else
              {
                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
                  && __cxa_guard_acquire(&qword_1EA6437C8))
                {
                  qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                  __cxa_guard_release(&qword_1EA6437C8);
                }
                float v233 = (id)qword_1EA6437C0;
                if (os_log_type_enabled(v233, OS_LOG_TYPE_ERROR))
                {
                  buf.columns[0].i16[0] = 0;
                  _os_log_error_impl(&dword_1D0DBD000, v233, OS_LOG_TYPE_ERROR, "Could not create command buffer", (uint8_t *)&buf, 2u);
                }
                uint64_t v80 = 6;
              }

LABEL_370:
              int v232 = v80;
              goto LABEL_371;
            }
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EA6437C8))
            {
              qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
              __cxa_guard_release(&qword_1EA6437C8);
            }
            v203 = (id)qword_1EA6437C0;
            if (!os_log_type_enabled(v203, OS_LOG_TYPE_ERROR)) {
              goto LABEL_302;
            }
            buf.columns[0].i16[0] = 0;
            int v225 = "Precondition violated: m_textureY";
          }
          else
          {
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EA6437C8))
            {
              qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
              __cxa_guard_release(&qword_1EA6437C8);
            }
            v203 = (id)qword_1EA6437C0;
            if (!os_log_type_enabled(v203, OS_LOG_TYPE_ERROR))
            {
LABEL_302:
              int v232 = 1;
              uint64_t v80 = 2;
LABEL_371:

              goto LABEL_372;
            }
            buf.columns[0].i16[0] = 0;
            int v225 = "Precondition violated: m_trackedFace";
          }
          uint64_t v80 = 2;
          _os_log_error_impl(&dword_1D0DBD000, v203, OS_LOG_TYPE_ERROR, v225, (uint8_t *)&buf, 2u);
          int v232 = 1;
          goto LABEL_371;
        }
        if (*(unsigned char *)(a1 + 944)) {
          *(unsigned char *)(a1 + 944) = 0;
        }
        int v135 = (std::__shared_weak_count *)a4[1];
        uint64_t v457 = *a4;
        v458 = v135;
        if (v135) {
          atomic_fetch_add_explicit(&v135->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        unsigned int v136 = sub_1D0DDE6E0(a1, &v457, (uint64_t)&v459, 0);
        v137 = v458;
        if (v458 && !atomic_fetch_add(&v458->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v137->__on_zero_shared)(v137);
          std::__shared_weak_count::__release_weak(v137);
        }
        if (v136 == 1) {
          uint64_t v80 = 2;
        }
        else {
          uint64_t v80 = v136;
        }
        if (v136)
        {
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EA6437C8))
          {
            qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
            __cxa_guard_release(&qword_1EA6437C8);
          }
          uint64_t v138 = (id)qword_1EA6437C0;
          if (os_log_type_enabled(v138, OS_LOG_TYPE_ERROR))
          {
            float v234 = off_1E689A510[v136 - 1];
            v235 = off_1E689A510[(v80 - 1)];
            buf.columns[0].i32[0] = 136315394;
            *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v234;
            buf.columns[0].i16[6] = 2080;
            *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v235;
            _os_log_error_impl(&dword_1D0DBD000, v138, OS_LOG_TYPE_ERROR, "Running writeDebugData(debugDictionary, bbox, false) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
          }

          goto LABEL_317;
        }
        if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)(a2 + 16), @"DrawDebugLandmarksAndBBoxes"))
        {
          cva::DictionaryHandler::item((uint64_t *)&buf, (cva::DictionaryHandler *)(a2 + 16), @"DrawDebugLandmarksAndBBoxes");
          cva::ItemHandler::getValue<BOOL>();
        }
LABEL_316:
        uint64_t v80 = 0;
        goto LABEL_317;
      }
LABEL_267:
      if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)(a2 + 16), @"DrawDebugLandmarksAndBBoxes"))
      {
        cva::DictionaryHandler::item((uint64_t *)&buf, (cva::DictionaryHandler *)(a2 + 16), @"DrawDebugLandmarksAndBBoxes");
        cva::ItemHandler::getValue<BOOL>();
      }
      goto LABEL_316;
    }
LABEL_260:
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    float32x4_t v198 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v198, OS_LOG_TYPE_INFO))
    {
      buf.columns[0].i16[0] = 0;
      _os_log_impl(&dword_1D0DBD000, v198, OS_LOG_TYPE_INFO, "Deleting tracked face.", (uint8_t *)&buf, 2u);
    }

    if (*(unsigned char *)(a1 + 1280))
    {
      long long v199 = *(void **)(a1 + 984);
      if (v199)
      {
        *(void *)(a1 + 992) = v199;
        operator delete(v199);
      }
      *(unsigned char *)(a1 + 1280) = 0;
    }
    goto LABEL_267;
  }
  unsigned int v180 = v178;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  int v118 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
  {
    if (v180 > 7) {
      int8x16_t v181 = "Success, no error";
    }
    else {
      int8x16_t v181 = off_1E689A510[v179];
    }
    if (v80 > 7) {
      unsigned int v242 = "Success, no error";
    }
    else {
      unsigned int v242 = off_1E689A510[(v80 - 1)];
    }
    buf.columns[0].i32[0] = 136315394;
    *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v181;
    buf.columns[0].i16[6] = 2080;
    *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v242;
    uint64_t v243 = "Running m_distanceCm.update(distance_cm, timestamp) failed with %s, returning %s";
LABEL_349:
    _os_log_error_impl(&dword_1D0DBD000, v118, OS_LOG_TYPE_ERROR, v243, (uint8_t *)&buf, 0x16u);
  }
LABEL_237:

  unsigned int v110 = v80;
  if (!v80)
  {
    if (*(unsigned char *)(a1 + 1177)) {
      goto LABEL_94;
    }
    goto LABEL_260;
  }
LABEL_151:
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  v111 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
  {
    if (v110 > 7) {
      v143 = "Success, no error";
    }
    else {
      v143 = off_1E689A510[v110 - 1];
    }
    if (v80 > 7) {
      v145 = "Success, no error";
    }
    else {
      v145 = off_1E689A510[(v80 - 1)];
    }
    buf.columns[0].i32[0] = 136315394;
    *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v143;
    buf.columns[0].i16[6] = 2080;
    *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v145;
    _os_log_error_impl(&dword_1D0DBD000, v111, OS_LOG_TYPE_ERROR, "Running m_trackedFace->update(facePosition, data.correctionEnabled(), uprightFaceRollAngle, distanceThresholdsMultiplier, data.timestamp()) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
  }

  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  v112 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
  {
    if (v80 > 7) {
      v144 = "Success, no error";
    }
    else {
      v144 = off_1E689A510[(v80 - 1)];
    }
    buf.columns[0].i32[0] = 136315394;
    *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)v144;
    buf.columns[0].i16[6] = 2080;
    *(uint64_t *)((char *)&buf.columns[0].i64[1] + 6) = (uint64_t)v144;
    _os_log_error_impl(&dword_1D0DBD000, v112, OS_LOG_TYPE_ERROR, "Running updateFacePositionAndFadeout(data) failed with %s, returning %s", (uint8_t *)&buf, 0x16u);
  }

LABEL_317:
  sub_1D0DE118C((uint64_t)&v507);
  return v80;
}

void sub_1D0DDCDD4(_Unwind_Exception *a1)
{
  sub_1D0DE118C((uint64_t)&STACK[0x528]);
  _Unwind_Resume(a1);
}

void sub_1D0DDD038(void *a1, uint64_t *a2, int a3, uint64_t a4, cva::DictionaryHandler **a5)
{
  v24[4] = *MEMORY[0x1E4F143B8];
  v23[0] = @"Timestamp";
  cva::DictionaryHandler::item(v22, (cva::DictionaryHandler *)(a2 + 2), @"Timestamp");
  cva::ItemHandler::getDictionary((uint64_t *)&v20, (cva::ItemHandler *)v22);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v22);
  uint64_t Dictionary = cva::DictionaryHandler::getDictionary(v20);
  uint64_t v11 = *a2;
  v24[0] = Dictionary;
  v24[1] = v11;
  v23[1] = @"CorrectedImage";
  v23[2] = @"Status";
  if ((a3 - 1) > 6) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = dword_1D0E81900[a3 - 1];
  }
  long long v13 = [NSNumber numberWithInt:v12];
  v24[2] = v13;
  v23[3] = @"ModificationStatus";
  CMTime v14 = [NSNumber numberWithBool:a4];
  v24[3] = v14;
  unsigned int v15 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v24 forKeys:v23 count:4];
  float v16 = (void *)[v15 mutableCopy];

  float v17 = v21;
  if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
    float v18 = *a5;
    if (!*a5) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  float v18 = *a5;
  if (*a5) {
LABEL_7:
  }
    [v16 setObject:cva::DictionaryHandler::getDictionary(v18) forKeyedSubscript:@"DebugMetadata"];
LABEL_8:
  float v19 = operator new(0x28uLL);
  v19[1] = 0;
  v19[2] = 0;
  *float v19 = &unk_1F26F4B80;
  *a1 = cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)(v19 + 3), (const __CFDictionary *)v16);
  a1[1] = v19;
}

void sub_1D0DDD23C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  std::__shared_weak_count::~__shared_weak_count(v12);
  operator delete(v15);

  _Unwind_Resume(a1);
}

void sub_1D0DDD2B8(uint64_t a1, uint64_t a2, int a3, int a4, CMTime *a5)
{
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  memset(&v51, 0, sizeof(v51));
  HostTimeClocuint64_t k = CMClockGetHostTimeClock();
  CMClockGetTime(&v51, HostTimeClock);
  CMTime lhs = v51;
  CMTime rhs = *a5;
  CMTimeSubtract(&time, &lhs, &rhs);
  double Seconds = CMTimeGetSeconds(&time);
  if (Seconds < 0.0)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v12 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      CMTime v47 = *a5;
      Float64 v13 = CMTimeGetSeconds(&v47);
      CMTime v46 = v51;
      Float64 v14 = CMTimeGetSeconds(&v46);
      int buf = 134218496;
      *(double *)int v53 = Seconds;
      *(_WORD *)&v53[8] = 2048;
      *(Float64 *)float v54 = v13;
      *(_WORD *)&v54[8] = 2048;
      *(Float64 *)float v55 = v14;
      _os_log_impl(&dword_1D0DBD000, v12, OS_LOG_TYPE_DEFAULT, "Negative latency %f. Start time %f, end time %f.", (uint8_t *)&buf, 0x20u);
    }
  }
  if (a3 == 7)
  {
    ++*(_DWORD *)(a1 + 32);
    ++*(_DWORD *)(a1 + 48);
    *(double *)(a1 + 40) = Seconds + *(double *)(a1 + 40);
    unsigned int v15 = (double *)(a1 + 56);
  }
  else if (a3)
  {
    ++*(_DWORD *)(a1 + 64);
    ++*(_DWORD *)(a1 + 80);
    *(double *)(a1 + 72) = Seconds + *(double *)(a1 + 72);
    unsigned int v15 = (double *)(a1 + 88);
  }
  else
  {
    ++*(_DWORD *)a1;
    ++*(_DWORD *)(a1 + 16);
    *(double *)(a1 + 8) = Seconds + *(double *)(a1 + 8);
    unsigned int v15 = (double *)(a1 + 24);
  }
  *unsigned int v15 = Seconds + *v15;
  if (a4)
  {
    ++*(_DWORD *)(a1 + 96);
    ++*(_DWORD *)(a1 + 112);
    *(double *)(a1 + 104) = Seconds + *(double *)(a1 + 104);
    *(double *)(a1 + 120) = Seconds + *(double *)(a1 + 120);
  }
  if (*(_DWORD *)(a2 + 32) == 2)
  {
    ++*(_DWORD *)(a1 + 128);
    ++*(_DWORD *)(a1 + 144);
    *(double *)(a1 + 136) = Seconds + *(double *)(a1 + 136);
    *(double *)(a1 + 152) = Seconds + *(double *)(a1 + 152);
  }
  float v16 = (_OWORD *)(a1 + 160);
  if ((*(unsigned char *)(a1 + 172) & 1) == 0
    || (CMTime v44 = v51,
        *(_OWORD *)&v43.value = *v16,
        v43.epoch = *(void *)(a1 + 176),
        CMTimeSubtract(&v45, &v44, &v43),
        CMTimeGetSeconds(&v45) >= 5.0))
  {
    OSType PixelFormatType = CVPixelBufferGetPixelFormatType(*(CVPixelBufferRef *)a2);
    v42[0] = HIBYTE(PixelFormatType);
    v42[1] = BYTE2(PixelFormatType);
    v42[2] = BYTE1(PixelFormatType);
    v42[3] = PixelFormatType;
    v42[4] = 0;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    float v18 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      int v19 = *(_DWORD *)(a2 + 184);
      int v20 = *(_DWORD *)(a2 + 188);
      int buf = 67109634;
      *(_DWORD *)int v53 = v19;
      *(_WORD *)&v53[4] = 1024;
      *(_DWORD *)&v53[6] = v20;
      *(_WORD *)float v54 = 2080;
      *(void *)&v54[2] = v42;
      _os_log_impl(&dword_1D0DBD000, v18, OS_LOG_TYPE_DEFAULT, "ViewpointCorrection last frame: %dx%d %s", (uint8_t *)&buf, 0x18u);
    }

    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    float v21 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v22 = *(_DWORD *)a1;
      unsigned int v23 = *(_DWORD *)(a1 + 16);
      double v24 = 0.0;
      double v25 = 0.0;
      if (*(_DWORD *)a1) {
        double v25 = *(double *)(a1 + 8) / (double)v22 * 1000.0;
      }
      if (v23) {
        double v24 = *(double *)(a1 + 24) / (double)v23 * 1000.0;
      }
      unsigned int v26 = *(_DWORD *)(a1 + 32);
      unsigned int v27 = *(_DWORD *)(a1 + 48);
      double v28 = 0.0;
      double v29 = 0.0;
      if (v26) {
        double v29 = *(double *)(a1 + 40) / (double)v26 * 1000.0;
      }
      if (v27) {
        double v28 = *(double *)(a1 + 56) / (double)v27 * 1000.0;
      }
      unsigned int v30 = *(_DWORD *)(a1 + 64);
      unsigned int v31 = *(_DWORD *)(a1 + 80);
      double v32 = 0.0;
      double v33 = 0.0;
      if (v30) {
        double v33 = *(double *)(a1 + 72) / (double)v30 * 1000.0;
      }
      if (v31) {
        double v32 = *(double *)(a1 + 88) / (double)v31 * 1000.0;
      }
      unsigned int v34 = *(_DWORD *)(a1 + 96);
      unsigned int v35 = *(_DWORD *)(a1 + 112);
      double v36 = 0.0;
      double v37 = 0.0;
      if (v34) {
        double v37 = *(double *)(a1 + 104) / (double)v34 * 1000.0;
      }
      if (v35) {
        double v36 = *(double *)(a1 + 120) / (double)v35 * 1000.0;
      }
      unsigned int v38 = *(_DWORD *)(a1 + 128);
      unsigned int v39 = *(_DWORD *)(a1 + 144);
      double v40 = 0.0;
      double v41 = 0.0;
      if (v38) {
        double v41 = *(double *)(a1 + 136) / (double)v38 * 1000.0;
      }
      if (v39) {
        double v40 = *(double *)(a1 + 152) / (double)v39 * 1000.0;
      }
      int buf = 67113984;
      *(_DWORD *)int v53 = v22;
      *(_WORD *)&v53[4] = 1024;
      *(_DWORD *)&v53[6] = v23;
      *(_WORD *)float v54 = 2048;
      *(double *)&v54[2] = v25;
      *(_WORD *)float v55 = 2048;
      *(double *)&v55[2] = v24;
      __int16 v56 = 1024;
      unsigned int v57 = v26;
      __int16 v58 = 1024;
      unsigned int v59 = v27;
      __int16 v60 = 2048;
      double v61 = v29;
      __int16 v62 = 2048;
      double v63 = v28;
      __int16 v64 = 1024;
      unsigned int v65 = v30;
      __int16 v66 = 1024;
      unsigned int v67 = v31;
      __int16 v68 = 2048;
      double v69 = v33;
      __int16 v70 = 2048;
      double v71 = v32;
      __int16 v72 = 1024;
      unsigned int v73 = v34;
      __int16 v74 = 1024;
      unsigned int v75 = v35;
      __int16 v76 = 2048;
      double v77 = v37;
      __int16 v78 = 2048;
      double v79 = v36;
      __int16 v80 = 1024;
      unsigned int v81 = v38;
      __int16 v82 = 1024;
      unsigned int v83 = v39;
      __int16 v84 = 2048;
      double v85 = v41;
      __int16 v86 = 2048;
      double v87 = v40;
      _os_log_impl(&dword_1D0DBD000, v21, OS_LOG_TYPE_DEFAULT, "ViewpointCorrection # frames: success (%i (+%i), %.1f ms (%.1f ms)), dropped (%i (+%i), %.1f ms (%.1f ms)), error (%i (+%i), %.1f ms (%.1f ms)), modified (%i (+%i), %.1f ms (%.1f ms)), skipped due to fisheye strength (%i (+%i), %.1f ms (%.1f ms))", (uint8_t *)&buf, 0xA2u);
    }

    *(_DWORD *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
    *(_DWORD *)(a1 + 112) = 0;
    *(void *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 144) = 0;
    *(void *)(a1 + 152) = 0;
    *float v16 = *(_OWORD *)&v51.value;
    *(void *)(a1 + 176) = v51.epoch;
  }
}

void sub_1D0DDD9B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DDD9C8(void *a1, CVPixelBufferRef *a2)
{
  v31[4] = *MEMORY[0x1E4F143B8];
  v29[0] = &unk_1F26F4670;
  v29[3] = v29;
  v31[3] = v31;
  CVMetalTextureRef v30 = 0;
  v31[0] = &unk_1F26F4670;
  v26[0] = &unk_1F26F4670;
  v26[3] = v26;
  CVMetalTextureRef image = 0;
  v28[3] = v28;
  v28[0] = &unk_1F26F4670;
  signed int PixelFormatType = CVPixelBufferGetPixelFormatType(*a2);
  signed int v5 = PixelFormatType;
  if (PixelFormatType > 792229423)
  {
    if (PixelFormatType <= 875704437)
    {
      if (PixelFormatType != 792229424 && PixelFormatType != 875704422) {
        goto LABEL_37;
      }
    }
    else if (PixelFormatType != 875704438 && PixelFormatType != 2084070960 && PixelFormatType != 2084075056)
    {
      goto LABEL_37;
    }
  }
  else if (PixelFormatType <= 758670895)
  {
    if (PixelFormatType != 641230384 && PixelFormatType != 641234480) {
      goto LABEL_37;
    }
  }
  else if (PixelFormatType != 758670896 && PixelFormatType != 758674992 && PixelFormatType != 792225328)
  {
LABEL_37:
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v9 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v22 = 67109120;
      LODWORD(v23) = v5;
      _os_log_error_impl(&dword_1D0DBD000, v9, OS_LOG_TYPE_ERROR, "Unsupported pixel format %d", (uint8_t *)&v22, 8u);
    }
    uint64_t v8 = 1;
    goto LABEL_45;
  }
  if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)(a2 + 2), @"DrawDebugLandmarksAndBBoxes"))
  {
    cva::DictionaryHandler::item((uint64_t *)&v22, (cva::DictionaryHandler *)(a2 + 2), @"DrawDebugLandmarksAndBBoxes");
    cva::ItemHandler::getValue<BOOL>();
  }
  unsigned int v6 = sub_1D0DF31C4(a1[30], *a2, MTLPixelFormatR8Unorm, 0, 3, (uint64_t)&v30);
  unsigned int v7 = v6 - 1;
  if (v6 == 1) {
    uint64_t v8 = 2;
  }
  else {
    uint64_t v8 = v6;
  }
  if (v6)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v9 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      goto LABEL_45;
    }
    int v10 = off_1E689A510[v7];
    uint64_t v11 = off_1E689A510[(v8 - 1)];
    int v22 = 136315394;
    unsigned int v23 = v10;
    __int16 v24 = 2080;
    double v25 = v11;
    uint64_t v12 = "Running m_metalHelpers->createTextureFrom(data.image(), MTLPixelFormatR8Unorm, 0, textureUsage, Y) failed with"
          " %s, returning %s";
    goto LABEL_33;
  }
  unsigned int v13 = sub_1D0DF31C4(a1[30], *a2, MTLPixelFormatRG8Unorm, 1uLL, 3, (uint64_t)&image);
  unsigned int v14 = v13 - 1;
  if (v13 == 1) {
    uint64_t v8 = 2;
  }
  else {
    uint64_t v8 = v13;
  }
  if (v13)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v9 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      goto LABEL_45;
    }
    unsigned int v15 = off_1E689A510[v14];
    float v16 = off_1E689A510[(v8 - 1)];
    int v22 = 136315394;
    unsigned int v23 = v15;
    __int16 v24 = 2080;
    double v25 = v16;
    uint64_t v12 = "Running m_metalHelpers->createTextureFrom(data.image(), MTLPixelFormatRG8Unorm, 1, textureUsage, CbCr) failed "
          "with %s, returning %s";
LABEL_33:
    _os_log_error_impl(&dword_1D0DBD000, v9, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&v22, 0x16u);
LABEL_45:

    goto LABEL_46;
  }
  uint64_t v17 = CVMetalTextureGetTexture(v30);
  float v18 = (void *)a1[24];
  a1[24] = v17;

  uint64_t v19 = CVMetalTextureGetTexture(image);
  int v20 = (void *)a1[25];
  a1[25] = v19;

  if (!a1[24] || !a1[25])
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v9 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v22) = 0;
      _os_log_error_impl(&dword_1D0DBD000, v9, OS_LOG_TYPE_ERROR, "Could not convert pixel buffer to metal textures in get", (uint8_t *)&v22, 2u);
    }
    uint64_t v8 = 6;
    goto LABEL_45;
  }
  uint64_t v8 = 0;
LABEL_46:
  sub_1D0DE29C8((uint64_t *)&image);
  sub_1D0DE29C8((uint64_t *)&v30);
  return v8;
}

void sub_1D0DDDF6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_1D0DE29C8((uint64_t *)va);
  sub_1D0DE29C8((uint64_t *)(v8 - 96));
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DDDFA8(uint64_t a1, uint64_t a2)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 200))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    unsigned int v6 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v6, OS_LOG_TYPE_ERROR, "Precondition violated: m_textureCbCr", buf, 2u);
    }
    uint64_t v7 = 1;
    goto LABEL_41;
  }
  if (*(unsigned char *)(a1 + 288))
  {
LABEL_18:
    uint64_t v9 = [*(id *)(a1 + 184) commandBuffer];
    [v9 setLabel:@"ViewpointCorrectionProcessor::drawInputData"];
    int v10 = *(void **)(a1 + 200);
    unsigned int v6 = v9;
    id v11 = v10;
    if ([v11 pixelFormat] == 30)
    {
      unsigned int v12 = [v11 width];
      unsigned int v13 = [v11 height];
      uint64_t v14 = *(void *)(a2 + 136);
      uint64_t v15 = *(void *)(a2 + 144);
      if (v14 == v15)
      {
LABEL_24:

        [v6 commit];
        [v6 waitUntilCompleted];
        uint64_t v7 = 0;
LABEL_41:

        return v7;
      }
      float v16 = (void *)(a1 + 272);
      float32x2_t v40 = vcvt_f32_s32((int32x2_t)__PAIR64__(v13, v12));
      __asm { FMOV            V12.2S, #1.5 }
      while (1)
      {
        float v22 = *(float *)(v14 + 12) * v40.f32[1];
        float32x2_t v23 = vadd_f32(vmul_f32(*(float32x2_t *)v14, v40), (float32x2_t)0xBF000000BF000000);
        float v43 = *(float *)(v14 + 8) * v40.f32[0];
        *(float *)&uint64_t v24 = v23.f32[0] + v43;
        HIDWORD(v25) = v23.i32[1];
        *(float *)&uint64_t v25 = v23.f32[0] + v43;
        *(float32x2_t *)int buf = v23;
        *(void *)&uint8_t buf[8] = v25;
        float v41 = v22;
        float32x2_t v42 = v23;
        *((float *)&v24 + 1) = v23.f32[1] + v22;
        LODWORD(v26) = v23.i32[0];
        *((float *)&v26 + 1) = v23.f32[1] + v22;
        *(void *)&uint8_t buf[16] = v24;
        uint64_t v50 = v26;
        float32x2_t v51 = v23;
        int v27 = sub_1D0DF2BF4(v16, (uint64_t)buf, 5u, 2, v11, v6, (__n128)xmmword_1D0E814D0);
        if (v27) {
          break;
        }
        float v28 = *(double *)(v14 + 16) / 57.2957795;
        __float2 v30 = __sincosf_stret(v28);
        v29.f32[0] = v30.__sinval;
        v29.f32[1] = -v30.__cosval;
        float32x2_t v31 = vmul_f32((float32x2_t)__PAIR64__(LODWORD(v41), LODWORD(v43)), (float32x2_t)0x3F0000003F000000);
        float32x2_t v32 = vadd_f32(v31, v42);
        v44[0] = vmla_f32(v32, v29, v31);
        v44[1] = vmla_f32(v32, _D12, vmul_f32(v31, v29));
        if (sub_1D0DF2BF4(v16, (uint64_t)v44, 2u, 2, v11, v6, (__n128)xmmword_1D0E814D0))
        {
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EA6437C8))
          {
            qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
            __cxa_guard_release(&qword_1EA6437C8);
          }
          unsigned int v35 = (id)qword_1EA6437C0;
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)CMTime v45 = 136315394;
            CMTime v46 = "Precondition was violated";
            __int16 v47 = 2080;
            float v48 = "Assertion failed";
            _os_log_error_impl(&dword_1D0DBD000, v35, OS_LOG_TYPE_ERROR, "Running renderer.encode(segment, PrimitiveTypeLineStrip, destination, commandBuffer, kRedColor) failed with %s, returning %s", v45, 0x16u);
          }
          goto LABEL_36;
        }
        v14 += 32;
        if (v14 == v15) {
          goto LABEL_24;
        }
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      unsigned int v35 = (id)qword_1EA6437C0;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        unsigned int v39 = off_1E689A510[v27 - 1];
        *(_DWORD *)CMTime v45 = 136315394;
        CMTime v46 = v39;
        __int16 v47 = 2080;
        float v48 = "Assertion failed";
        _os_log_error_impl(&dword_1D0DBD000, v35, OS_LOG_TYPE_ERROR, "Running renderer.encode(bboxVertices, PrimitiveTypeLineStrip, destination, commandBuffer, kRedColor) failed with %s, returning %s", v45, 0x16u);
      }
LABEL_36:

      uint64_t v34 = 1;
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      double v33 = (id)qword_1EA6437C0;
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int buf = 0;
        _os_log_error_impl(&dword_1D0DBD000, v33, OS_LOG_TYPE_ERROR, "Precondition violated: destination.pixelFormat == MTLPixelFormatRG8Unorm", buf, 2u);
      }

      uint64_t v34 = 0;
    }

    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    double v36 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      unsigned int v38 = off_1E689A510[v34];
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = v38;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "Assertion failed";
      _os_log_error_impl(&dword_1D0DBD000, v36, OS_LOG_TYPE_ERROR, "Running drawInputFaceDetections(*m_debugRendererCbCr, commandBuffer, m_textureCbCr, data.inputFaceDetections()) failed with %s, returning %s", buf, 0x16u);
    }

    uint64_t v7 = 2;
    goto LABEL_41;
  }
  id v4 = **(id **)(a1 + 240);
  sub_1D0DE1328((uint64_t)buf, v4, [*(id *)(a1 + 200) pixelFormat]);

  if (*(_DWORD *)&buf[16] == 1)
  {
    int v5 = *(unsigned __int8 *)(a1 + 288);
    *(void *)(a1 + 272) = *(void *)buf;
    if (v5)
    {
      objc_storeStrong((id *)(a1 + 280), *(id *)&buf[8]);
    }
    else
    {
      *(void *)(a1 + 280) = *(id *)&buf[8];
      *(unsigned char *)(a1 + 288) = 1;
    }
    sub_1D0DE181C((uint64_t)v45, (uint64_t)buf);
    goto LABEL_18;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  uint64_t v8 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)CMTime v45 = 0;
    _os_log_error_impl(&dword_1D0DBD000, v8, OS_LOG_TYPE_ERROR, "Assertion failed: std::holds_alternative<DebugRenderer>(rendererOrError)", v45, 2u);
  }

  if (*(_DWORD *)&buf[16] != -1) {
    ((void (*)(uint8_t *, unsigned char *))off_1F26F5598[*(unsigned int *)&buf[16]])(v45, buf);
  }
  return 2;
}

void sub_1D0DDE69C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D0DDE6AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DDE6E0(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  if (*a2)
  {
    sub_1D0DF40DC((float *)(a1 + 728));
    if (a4)
    {
      if (*(int *)(a1 + 1012) > 0)
      {
        int v6 = *(_DWORD *)(a1 + 1008);
        uint64_t v7 = *(void *)(a1 + 984);
        float32x4_t v8 = 0uLL;
        int v9 = *(_DWORD *)(a1 + 1012);
        do
        {
          float32x4_t v8 = vaddq_f32(v8, *(float32x4_t *)(v7 + 48 * v6));
          int v6 = (v6 + 1) % (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 992) - v7) >> 4));
          --v9;
        }
        while (v9);
      }
      __asm { FMOV            V7.2S, #1.0 }
    }
    cva::ItemHandler::createValue<float>();
  }
  return 0;
}

void sub_1D0DDF20C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DDF28C(uint64_t a1, int32x2_t a2)
{
  float v3 = *(float *)(a1 + 384);
  a2.i32[0] = *(_DWORD *)(a1 + 408);
  int32x2_t v85 = a2;
  float v4 = *(float *)(a1 + 412);
  unsigned int v5 = [*(id *)(a1 + 488) width];
  uint64_t v6 = [*(id *)(a1 + 488) height];
  if (v6 >= 0) {
    unint64_t v7 = v6;
  }
  else {
    unint64_t v7 = v6 + 1;
  }
  int v8 = [*(id *)(a1 + 488) bytesPerRow];
  [*(id *)(a1 + 488) lockWithOptions:0 seed:0];
  int v9 = (float16x8_t *)[*(id *)(a1 + 488) baseAddress];
  if ((int)v5 >= 1)
  {
    unint64_t v11 = v7 >> 1;
    if ((int)(v7 >> 1) >= 1)
    {
      uint64_t v12 = 2 * (int)v5;
      uint64_t v13 = v8 - v12;
      unint64_t v14 = v5 - (unint64_t)(v5 & 0xF);
      float v15 = 1.0 / v3;
      if (v5 > 0xFuLL)
      {
        _Q1 = (float32x4_t)vdupq_lane_s32(v85, 0);
        int v23 = 0;
        if ((v5 & 0xF) != 0)
        {
          v24.i64[0] = 0x800000008;
          v24.i64[1] = 0x800000008;
          v25.i64[0] = 0x1000000010;
          v25.i64[1] = 0x1000000010;
          do
          {
            uint64_t v26 = v9 + 1;
            unint64_t v27 = v5 - (unint64_t)(v5 & 0xF);
            int32x4_t v28 = (int32x4_t)xmmword_1D0E814F0;
            int32x4_t v29 = (int32x4_t)xmmword_1D0E814E0;
            do
            {
              v26[-1] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(v28), _Q1), v15)), vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(v29), _Q1), v15));
              *uint64_t v26 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(vaddq_s32(v28, v24)), _Q1), v15)), vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(vaddq_s32(v29, v24)), _Q1), v15));
              int32x4_t v28 = vaddq_s32(v28, v25);
              int32x4_t v29 = vaddq_s32(v29, v25);
              v26 += 2;
              v27 -= 16;
            }
            while (v27);
            __float2 v30 = &v9->i16[v14];
            int v31 = -(v5 & 0xF);
            do
            {
              _S6 = v15 * (float)((float)(int)(v5 + v31) - *(float *)v85.i32);
              __asm { FCVT            H6, S6 }
              *v30++ = LOWORD(_S6);
              _CF = __CFADD__(v31++, 1);
            }
            while (!_CF);
            int v9 = (float16x8_t *)((char *)v30 + v13);
            ++v23;
          }
          while (v23 != v11);
        }
        else
        {
          double v33 = v9 + 1;
          uint64_t v34 = v8 + 2 * v5 - v12;
          v35.i64[0] = 0x800000008;
          v35.i64[1] = 0x800000008;
          v36.i64[0] = 0x1000000010;
          v36.i64[1] = 0x1000000010;
          do
          {
            double v37 = v33;
            unint64_t v38 = v5 - (unint64_t)(v5 & 0xF);
            int32x4_t v39 = (int32x4_t)xmmword_1D0E814F0;
            int32x4_t v40 = (int32x4_t)xmmword_1D0E814E0;
            do
            {
              v37[-1] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(v39), _Q1), v15)), vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(v40), _Q1), v15));
              float16x8_t *v37 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(vaddq_s32(v39, v35)), _Q1), v15)), vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(vaddq_s32(v40, v35)), _Q1), v15));
              int32x4_t v39 = vaddq_s32(v39, v36);
              int32x4_t v40 = vaddq_s32(v40, v36);
              v37 += 2;
              v38 -= 16;
            }
            while (v38);
            int v9 = (float16x8_t *)((char *)v9 + v14 * 2 + v13);
            ++v23;
            double v33 = (float16x8_t *)((char *)v33 + v34);
          }
          while (v23 != v11);
        }
      }
      else
      {
        int v16 = 0;
        do
        {
          for (int i = 0; i != v5; ++i)
          {
            _S1 = v15 * (float)((float)i - *(float *)v85.i32);
            __asm { FCVT            H1, S1 }
            v9->i16[0] = LOWORD(_S1);
            int v9 = (float16x8_t *)((char *)v9 + 2);
          }
          int v9 = (float16x8_t *)((char *)v9 + v13);
          ++v16;
        }
        while (v16 != v11);
      }
      if (v5 >= 0x10uLL)
      {
        int v69 = 0;
        do
        {
          _Q1.f32[0] = v15 * (float)((float)v69 - v4);
          __asm { FCVT            H1, S1 }
          int16x8_t v70 = vdupq_lane_s16(*(int16x4_t *)_Q1.f32, 0);
          double v71 = (int16x8_t *)&v9[1];
          unint64_t v72 = v5 - (unint64_t)(v5 & 0xF);
          do
          {
            v71[-1] = v70;
            *double v71 = v70;
            v71 += 2;
            v72 -= 16;
          }
          while (v72);
          unsigned int v73 = &v9->i16[v14];
          if ((v5 & 0xF) != 0)
          {
            int v74 = v5 & 0xF;
            do
            {
              *v73++ = _Q1.i16[0];
              --v74;
            }
            while (v74);
          }
          int v9 = (float16x8_t *)((char *)v73 + v13);
          ++v69;
        }
        while (v69 != v11);
      }
      else
      {
        int v41 = 0;
        do
        {
          _S1 = v15 * (float)((float)v41 - v4);
          __asm { FCVT            H1, S1 }
          unsigned int v44 = v5;
          do
          {
            v9->i16[0] = _H1;
            int v9 = (float16x8_t *)((char *)v9 + 2);
            --v44;
          }
          while (v44);
          int v9 = (float16x8_t *)((char *)v9 + v13);
          ++v41;
        }
        while (v41 != v11);
      }
    }
  }
  [*(id *)(a1 + 488) unlockWithOptions:0 seed:0];
  float v45 = *(float *)(a1 + 560);
  v46.i32[0] = *(_DWORD *)(a1 + 584);
  int32x2_t v86 = v46;
  float v47 = *(float *)(a1 + 588);
  unsigned int v48 = [*(id *)(a1 + 664) width];
  uint64_t v49 = [*(id *)(a1 + 664) height];
  if (v49 >= 0) {
    unint64_t v50 = v49;
  }
  else {
    unint64_t v50 = v49 + 1;
  }
  int v51 = [*(id *)(a1 + 664) bytesPerRow];
  [*(id *)(a1 + 664) lockWithOptions:0 seed:0];
  uint64_t v52 = (float16x8_t *)[*(id *)(a1 + 664) baseAddress];
  if ((int)v48 >= 1)
  {
    unint64_t v54 = v50 >> 1;
    if ((int)(v50 >> 1) >= 1)
    {
      uint64_t v55 = v51 - 2 * (int)v48;
      unint64_t v56 = v48 - (unint64_t)(v48 & 0xF);
      float v57 = 1.0 / v45;
      if (v48 >= 0x10uLL)
      {
        int v75 = 0;
        _Q1 = (float32x4_t)vdupq_lane_s32(v86, 0);
        v76.i64[0] = 0x800000008;
        v76.i64[1] = 0x800000008;
        v77.i64[0] = 0x1000000010;
        v77.i64[1] = 0x1000000010;
        do
        {
          __int16 v78 = v52 + 1;
          unint64_t v79 = v48 - (unint64_t)(v48 & 0xF);
          int32x4_t v80 = (int32x4_t)xmmword_1D0E814F0;
          int32x4_t v81 = (int32x4_t)xmmword_1D0E814E0;
          do
          {
            v78[-1] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(v80), _Q1), v57)), vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(v81), _Q1), v57));
            *__int16 v78 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(vaddq_s32(v80, v76)), _Q1), v57)), vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(vaddq_s32(v81, v76)), _Q1), v57));
            int32x4_t v80 = vaddq_s32(v80, v77);
            int32x4_t v81 = vaddq_s32(v81, v77);
            v78 += 2;
            v79 -= 16;
          }
          while (v79);
          __int16 v82 = &v52->i16[v56];
          if ((v48 & 0xF) != 0)
          {
            int v83 = -(v48 & 0xF);
            do
            {
              _S6 = v57 * (float)((float)(int)(v48 + v83) - *(float *)v86.i32);
              __asm { FCVT            H6, S6 }
              *v82++ = LOWORD(_S6);
              _CF = __CFADD__(v83++, 1);
            }
            while (!_CF);
          }
          uint64_t v52 = (float16x8_t *)((char *)v82 + v55);
          ++v75;
        }
        while (v75 != v54);
      }
      else
      {
        int v58 = 0;
        do
        {
          for (int j = 0; j != v48; ++j)
          {
            _S1 = v57 * (float)((float)j - *(float *)v86.i32);
            __asm { FCVT            H1, S1 }
            v52->i16[0] = LOWORD(_S1);
            uint64_t v52 = (float16x8_t *)((char *)v52 + 2);
          }
          uint64_t v52 = (float16x8_t *)((char *)v52 + v55);
          ++v58;
        }
        while (v58 != v54);
      }
      for (int k = 0; k != v54; ++k)
      {
        _Q1.f32[0] = v57 * (float)((float)k - v47);
        __asm { FCVT            H1, S1 }
        if (v48 >= 0x10uLL)
        {
          int16x8_t v63 = vdupq_lane_s16(*(int16x4_t *)_Q1.f32, 0);
          __int16 v64 = (int16x8_t *)&v52[1];
          unint64_t v65 = v48 - (unint64_t)(v48 & 0xF);
          do
          {
            v64[-1] = v63;
            *__int16 v64 = v63;
            v64 += 2;
            v65 -= 16;
          }
          while (v65);
          uint64_t v52 = (float16x8_t *)((char *)v52 + v56 * 2);
          unsigned int v62 = v48 - (v48 & 0xF);
          if ((v48 & 0xF) == 0) {
            goto LABEL_41;
          }
        }
        else
        {
          unsigned int v62 = 0;
        }
        unsigned int v66 = v48 - v62;
        do
        {
          v52->i16[0] = _Q1.i16[0];
          uint64_t v52 = (float16x8_t *)((char *)v52 + 2);
          --v66;
        }
        while (v66);
LABEL_41:
        uint64_t v52 = (float16x8_t *)((char *)v52 + v55);
      }
    }
  }
  unsigned int v67 = *(void **)(a1 + 664);
  return [v67 unlockWithOptions:0 seed:0];
}

uint64_t sub_1D0DDF810(uint64_t a1, float32x2_t *a2)
{
  if (!*(unsigned char *)(*(void *)(a1 + 296) + 257))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v12 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    __int16 v17 = 0;
    uint64_t v13 = "Precondition violated: m_regressor->supportsConfigurableCorrectionIntensity()";
    unint64_t v14 = (uint8_t *)&v17;
    goto LABEL_16;
  }
  float v3 = *(void **)(a1 + 672);
  if (!v3)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v12 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    *(_WORD *)int buf = 0;
    uint64_t v13 = "Precondition violated: m_correctionIntensitySurface";
    unint64_t v14 = buf;
    goto LABEL_16;
  }
  if ([v3 width] == 1 && objc_msgSend(*(id *)(a1 + 672), "height") == 1)
  {
    _S0 = sqrtf(vaddv_f32(vmul_f32(*a2, *a2)));
    __asm { FCVT            H8, S0 }
    [*(id *)(a1 + 672) lockWithOptions:0 seed:0];
    *(_WORD *)[*(id *)(a1 + 672) baseAddress] = _H8;
    [*(id *)(a1 + 672) unlockWithOptions:0 seed:0];
    return 0;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
  }
  uint64_t v12 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    __int16 v15 = 0;
    uint64_t v13 = "Precondition violated: m_correctionIntensitySurface.width == 1 && m_correctionIntensitySurface.height == 1";
    unint64_t v14 = (uint8_t *)&v15;
LABEL_16:
    _os_log_error_impl(&dword_1D0DBD000, v12, OS_LOG_TYPE_ERROR, v13, v14, 2u);
  }
LABEL_14:

  return 1;
}

uint64_t sub_1D0DDFA5C(uint64_t a1, uint64_t a2, float32x2_t *a3, float32x4_t *a4)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 296);
  if (*(unsigned char *)(v4 + 256))
  {
    if (*(void *)(v4 + 240))
    {
      if (*(void *)(v4 + 248))
      {
        if (e5rt_execution_stream_encode_operation())
        {
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EA6437C8))
          {
            qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
            __cxa_guard_release(&qword_1EA6437C8);
          }
          int v9 = (id)qword_1EA6437C0;
          if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
            goto LABEL_26;
          }
          *(_WORD *)int buf = 0;
          int v10 = "Assertion failed: isSuccess(e5rt_execution_stream_encode_operation(m_stream.get(), m_operation.get()))";
LABEL_25:
          _os_log_error_impl(&dword_1D0DBD000, v9, OS_LOG_TYPE_ERROR, v10, buf, 2u);
LABEL_26:
          uint64_t v12 = 1;
          goto LABEL_27;
        }
        if (e5rt_execution_stream_execute_sync())
        {
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EA6437C8))
          {
            qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
            __cxa_guard_release(&qword_1EA6437C8);
          }
          int v9 = (id)qword_1EA6437C0;
          if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
            goto LABEL_26;
          }
          *(_WORD *)int buf = 0;
          int v10 = "Assertion failed: isSuccess(e5rt_execution_stream_execute_sync(m_stream.get()))";
          goto LABEL_25;
        }
        if (e5rt_execution_stream_reset())
        {
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EA6437C8))
          {
            qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
            __cxa_guard_release(&qword_1EA6437C8);
          }
          int v9 = (id)qword_1EA6437C0;
          if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
            goto LABEL_26;
          }
          *(_WORD *)int buf = 0;
          int v10 = "Assertion failed: isSuccess(e5rt_execution_stream_reset(m_stream.get()))";
          goto LABEL_25;
        }
        id v17 = *(id *)(a1 + 680);
        float v18 = v17;
        if (v17)
        {
          if ([v17 width] == 1)
          {
            if ([v18 height] == 48)
            {
              if ([v18 bytesPerElement] == 2)
              {
                if ([v18 bytesPerRow] == 64)
                {
                  [v18 lockWithOptions:1 seed:0];
                  id v19 = v18;
                  int v20 = (__int16 *)[v19 baseAddress];
                  v21.i16[0] = *v20;
                  v21.i16[1] = v20[32];
                  *(void *)&long long v22 = vcvtq_f32_f16(v21).u64[0];
                  v23.i16[0] = v20[64];
                  v23.i16[1] = v20[96];
                  float16x4_t v24 = (float16x4_t)vcvtq_f32_f16(v23).u64[0];
                  *((float16x4_t *)&v22 + 1) = v24;
                  *(_OWORD *)int buf = v22;
                  LOWORD(v22) = v20[768];
                  WORD1(v22) = v20[800];
                  *(void *)&long long v22 = vcvtq_f32_f16(*(float16x4_t *)&v22).u64[0];
                  v24.i16[0] = v20[832];
                  v24.i16[1] = v20[864];
                  float16x4_t v25 = (float16x4_t)vcvtq_f32_f16(v24).u64[0];
                  *((float16x4_t *)&v22 + 1) = v25;
                  v25.i16[0] = v20[128];
                  v25.i16[1] = v20[160];
                  long long v102 = v22;
                  *(void *)&long long v22 = vcvtq_f32_f16(v25).u64[0];
                  v25.i16[0] = v20[192];
                  v25.i16[1] = v20[224];
                  *(void *)&long long v26 = vcvtq_f32_f16(v25).u64[0];
                  v27.i16[0] = v20[256];
                  v27.i16[1] = v20[288];
                  float16x4_t v28 = (float16x4_t)vcvtq_f32_f16(v27).u64[0];
                  *((float16x4_t *)&v26 + 1) = v28;
                  v28.i16[0] = v20[960];
                  v28.i16[1] = v20[992];
                  long long v95 = v26;
                  *(void *)&long long v26 = vcvtq_f32_f16(v28).u64[0];
                  v28.i16[0] = v20[1024];
                  v28.i16[1] = v20[1056];
                  float16x4_t v29 = (float16x4_t)vcvtq_f32_f16(v28).u64[0];
                  *((float16x4_t *)&v26 + 1) = v29;
                  long long v104 = v26;
                  LOWORD(v26) = v20[320];
                  WORD1(v26) = v20[352];
                  v29.i16[0] = v20[384];
                  v29.i16[1] = v20[416];
                  *(void *)&long long v26 = vcvtq_f32_f16(*(float16x4_t *)&v26).u64[0];
                  float16x4_t v30 = (float16x4_t)vcvtq_f32_f16(v29).u64[0];
                  *((float16x4_t *)&v26 + 1) = v30;
                  v30.i16[0] = v20[896];
                  v30.i16[1] = v20[928];
                  float16x4_t v31 = (float16x4_t)vcvtq_f32_f16(v30).u64[0];
                  long long v96 = v26;
                  LOWORD(v26) = v20[1088];
                  WORD1(v26) = v20[1120];
                  unint64_t v32 = vcvtq_f32_f16(*(float16x4_t *)&v26).u64[0];
                  float16x4_t v103 = v31;
                  LOWORD(v26) = v20[1152];
                  WORD1(v26) = v20[1184];
                  *(void *)&long long v26 = vcvtq_f32_f16(*(float16x4_t *)&v26).u64[0];
                  v31.i16[0] = v20[448];
                  v31.i16[1] = v20[480];
                  unint64_t v33 = vcvtq_f32_f16(v31).u64[0];
                  *(void *)&uint8_t buf[16] = v22;
                  LOWORD(v22) = v20[1216];
                  WORD1(v22) = v20[1248];
                  unint64_t v34 = vcvtq_f32_f16(*(float16x4_t *)&v22).u64[0];
                  unint64_t v105 = v32;
                  uint64_t v106 = v26;
                  LOWORD(v22) = v20[512];
                  WORD1(v22) = v20[544];
                  *(void *)&long long v22 = vcvtq_f32_f16(*(float16x4_t *)&v22).u64[0];
                  LOWORD(v26) = v20[1280];
                  WORD1(v26) = v20[1312];
                  *(void *)&long long v26 = vcvtq_f32_f16(*(float16x4_t *)&v26).u64[0];
                  v31.i16[0] = v20[576];
                  v31.i16[1] = v20[608];
                  unint64_t v35 = vcvtq_f32_f16(v31).u64[0];
                  unint64_t v97 = v33;
                  uint64_t v98 = v22;
                  LOWORD(v22) = v20[1344];
                  WORD1(v22) = v20[1376];
                  unint64_t v36 = vcvtq_f32_f16(*(float16x4_t *)&v22).u64[0];
                  unint64_t v107 = v34;
                  uint64_t v108 = v26;
                  LOWORD(v22) = v20[640];
                  WORD1(v22) = v20[672];
                  *(void *)&long long v22 = vcvtq_f32_f16(*(float16x4_t *)&v22).u64[0];
                  LOWORD(v26) = v20[1408];
                  WORD1(v26) = v20[1440];
                  v31.i16[0] = v20[704];
                  v31.i16[1] = v20[736];
                  unint64_t v99 = v35;
                  uint64_t v100 = v22;
                  unint64_t v101 = vcvtq_f32_f16(v31).u64[0];
                  LOWORD(v22) = v20[1472];
                  WORD1(v22) = v20[1504];
                  unint64_t v109 = v36;
                  unint64_t v110 = vcvtq_f32_f16(*(float16x4_t *)&v26).u64[0];
                  unint64_t v111 = vcvtq_f32_f16(*(float16x4_t *)&v22).u64[0];
                  [v19 unlockWithOptions:1 seed:0];

                  id v37 = *(id *)(a1 + 688);
                  unint64_t v38 = v37;
                  if (v37)
                  {
                    if ([v37 width] == 1)
                    {
                      if ([v38 height] == 6)
                      {
                        if ([v38 bytesPerElement] == 2)
                        {
                          if ([v38 bytesPerRow] == 64)
                          {
                            [v38 lockWithOptions:1 seed:0];
                            id v39 = v38;
                            int32x4_t v40 = (__int16 *)[v39 baseAddress];
                            v41.i16[0] = *v40;
                            v41.i16[1] = v40[32];
                            float16x4_t v78 = v41;
                            _H8 = v40[64];
                            [v39 unlockWithOptions:1 seed:0];

                            unint64_t v43 = [*(id *)(a1 + 712) width];
                            uint64_t v44 = 0;
                            float32x4_t v79 = vcvtq_f32_f16(v78);
                            __asm { FCVT            S8, H8 }
                            float32x2_t v50 = *a3;
                            float32x2_t v51 = a3[1];
                            float32x4_t v52 = *a4;
                            float32x4_t v53 = a4[1];
                            __asm { FMOV            V5.2S, #1.0 }
                            float32x4_t v55 = a4[2];
                            do
                            {
                              float32x2_t v56 = vmul_n_f32(vmul_f32(vadd_f32(*(float32x2_t *)&buf[v44], _D5), (float32x2_t)0x3F0000003F000000), (float)v43);
                              int32x4_t v57 = (int32x4_t)vaddq_f32(v55, vmlaq_lane_f32(vmulq_n_f32(v52, v56.f32[0]), v53, v56, 1));
                              *(float32x2_t *)&v90[v44] = vdiv_f32(vsub_f32(vdiv_f32(*(float32x2_t *)v57.i8, (float32x2_t)vdup_laneq_s32(v57, 2)), v50), v51);
                              v44 += 8;
                            }
                            while (v44 != 96);
                            long long v84 = *(_OWORD *)(a2 + 36);
                            uint64_t v85 = *(void *)(a2 + 52);
                            unsigned int v58 = sub_1D0DF4478(a1 + 728, (float32x2_t *)v90, (uint64_t)&v84);
                            unsigned int v62 = v58 - 1;
                            if (v58 == 1) {
                              uint64_t v14 = 2;
                            }
                            else {
                              uint64_t v14 = v58;
                            }
                            if (v58)
                            {
                              int16x8_t v63 = sub_1D0DF4E04();
                              if (!os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
                              {
LABEL_91:

                                return v14;
                              }
                              __int16 v64 = off_1E689A510[v62];
                              unint64_t v65 = off_1E689A510[(v14 - 1)];
                              *(_DWORD *)int32x2_t v86 = 136315394;
                              double v87 = v64;
                              __int16 v88 = 2080;
                              float v89 = v65;
                              unsigned int v66 = "Running m_trackedFace->updateLandmarks(transformedLandmarks, data.timestamp()) faile"
                                    "d with %s, returning %s";
                            }
                            else
                            {
                              LODWORD(v59) = -1011613696;
                              float32x4_t v72 = v79;
                              v72.f32[2] = (float)((float)((float)(*(float *)(a1 + 792) + -90.0)
                                                         + (float)(floorf((float)((float)(*(float *)(a1 + 792) + -90.0)+ 180.0)/ 360.0)* -360.0))/ 57.296)+ _S8;
                              float32x4_t v82 = *(float32x4_t *)(a2 + 36);
                              uint64_t v83 = *(void *)(a2 + 52);
                              sub_1D0DF49BC(a1 + 728, &v82, vdivq_f32(v72, (float32x4_t)vdupq_n_s32(0x3C8EFA35u)), *(double *)v82.i64, v59, v60, v61);
                              long long v80 = *(_OWORD *)(a2 + 36);
                              uint64_t v81 = *(void *)(a2 + 52);
                              unsigned int v73 = sub_1D0DE1834(a1, (float32x2_t *)buf, (uint64_t)&v80);
                              unsigned int v74 = v73;
                              unsigned int v75 = v73 - 1;
                              if (v73 == 1) {
                                uint64_t v14 = 2;
                              }
                              else {
                                uint64_t v14 = v73;
                              }
                              if (!v73) {
                                return 0;
                              }
                              int16x8_t v63 = sub_1D0DF4E04();
                              if (!os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
                                goto LABEL_91;
                              }
                              if (v74 > 7) {
                                int32x4_t v76 = "Success, no error";
                              }
                              else {
                                int32x4_t v76 = off_1E689A510[v75];
                              }
                              if (v14 > 7) {
                                int32x4_t v77 = "Success, no error";
                              }
                              else {
                                int32x4_t v77 = off_1E689A510[(v14 - 1)];
                              }
                              *(_DWORD *)int32x2_t v86 = 136315394;
                              double v87 = (void *)v76;
                              __int16 v88 = 2080;
                              float v89 = (void *)v77;
                              unsigned int v66 = "Running updateJitterValue(landmarks, jitterOffset, data.timestamp()) failed with %s, returning %s";
                            }
                            _os_log_error_impl(&dword_1D0DBD000, v63, OS_LOG_TYPE_ERROR, v66, v86, 0x16u);
                            goto LABEL_91;
                          }
                          int v69 = sub_1D0DF4E04();
                          if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                          {
                            *(_WORD *)float v90 = 0;
                            int16x8_t v70 = "Precondition violated: surface.bytesPerRow == 64";
                            goto LABEL_82;
                          }
LABEL_83:

                          double v71 = sub_1D0DF4E04();
                          if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)float v90 = 136315394;
                            float v91 = "Precondition was violated";
                            __int16 v92 = 2080;
                            float v93 = "Assertion failed";
                            _os_log_error_impl(&dword_1D0DBD000, v71, OS_LOG_TYPE_ERROR, "Running readAnglesFromIOSurface(m_anglesSurface, rigidPoseAngles) failed with %s, returning %s", v90, 0x16u);
                          }

                          return 2;
                        }
                        int v69 = sub_1D0DF4E04();
                        if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_83;
                        }
                        *(_WORD *)float v90 = 0;
                        int16x8_t v70 = "Precondition violated: surface.bytesPerElement == 2";
                      }
                      else
                      {
                        int v69 = sub_1D0DF4E04();
                        if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_83;
                        }
                        *(_WORD *)float v90 = 0;
                        int16x8_t v70 = "Precondition violated: surface.height == 2 * 3";
                      }
                    }
                    else
                    {
                      int v69 = sub_1D0DF4E04();
                      if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_83;
                      }
                      *(_WORD *)float v90 = 0;
                      int16x8_t v70 = "Precondition violated: surface.width == 1";
                    }
                  }
                  else
                  {
                    int v69 = sub_1D0DF4E04();
                    if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_83;
                    }
                    *(_WORD *)float v90 = 0;
                    int16x8_t v70 = "Precondition violated: surface";
                  }
LABEL_82:
                  _os_log_error_impl(&dword_1D0DBD000, v69, OS_LOG_TYPE_ERROR, v70, v90, 2u);
                  goto LABEL_83;
                }
                unsigned int v67 = sub_1D0DF4E04();
                if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
                {
LABEL_68:

                  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
                    && __cxa_guard_acquire(&qword_1EA6437C8))
                  {
                    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                    __cxa_guard_release(&qword_1EA6437C8);
                  }
                  uint64_t v13 = (id)qword_1EA6437C0;
                  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)int buf = 136315394;
                    *(void *)&uint8_t buf[4] = "Precondition was violated";
                    *(_WORD *)&buf[12] = 2080;
                    *(void *)&buf[14] = "Assertion failed";
                    _os_log_error_impl(&dword_1D0DBD000, v13, OS_LOG_TYPE_ERROR, "Running readLandmarksFromIOSurface(m_landmarksSurface, landmarks) failed with %s, returning %s", buf, 0x16u);
                  }
                  goto LABEL_30;
                }
                *(_WORD *)int buf = 0;
                __int16 v68 = "Precondition violated: surface.bytesPerRow == 64";
              }
              else
              {
                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
                  && __cxa_guard_acquire(&qword_1EA6437C8))
                {
                  qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                  __cxa_guard_release(&qword_1EA6437C8);
                }
                unsigned int v67 = (id)qword_1EA6437C0;
                if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_68;
                }
                *(_WORD *)int buf = 0;
                __int16 v68 = "Precondition violated: surface.bytesPerElement == 2";
              }
            }
            else
            {
              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&qword_1EA6437C8))
              {
                qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
                __cxa_guard_release(&qword_1EA6437C8);
              }
              unsigned int v67 = (id)qword_1EA6437C0;
              if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
                goto LABEL_68;
              }
              *(_WORD *)int buf = 0;
              __int16 v68 = "Precondition violated: surface.height == 2 * 2 * TrackedFace::kLandmarkCount";
            }
          }
          else
          {
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EA6437C8))
            {
              qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
              __cxa_guard_release(&qword_1EA6437C8);
            }
            unsigned int v67 = (id)qword_1EA6437C0;
            if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
              goto LABEL_68;
            }
            *(_WORD *)int buf = 0;
            __int16 v68 = "Precondition violated: surface.width == 1";
          }
        }
        else
        {
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EA6437C8))
          {
            qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
            __cxa_guard_release(&qword_1EA6437C8);
          }
          unsigned int v67 = (id)qword_1EA6437C0;
          if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
            goto LABEL_68;
          }
          *(_WORD *)int buf = 0;
          __int16 v68 = "Precondition violated: surface";
        }
        _os_log_error_impl(&dword_1D0DBD000, v67, OS_LOG_TYPE_ERROR, v68, buf, 2u);
        goto LABEL_68;
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      int v9 = (id)qword_1EA6437C0;
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
LABEL_16:
        uint64_t v12 = 0;
        goto LABEL_27;
      }
      *(_WORD *)int buf = 0;
      unint64_t v11 = "Precondition violated: m_operation";
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      int v9 = (id)qword_1EA6437C0;
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        goto LABEL_16;
      }
      *(_WORD *)int buf = 0;
      unint64_t v11 = "Precondition violated: m_stream";
    }
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    int v9 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      goto LABEL_16;
    }
    *(_WORD *)int buf = 0;
    unint64_t v11 = "Precondition violated: m_surfacesSet";
  }
  _os_log_error_impl(&dword_1D0DBD000, v9, OS_LOG_TYPE_ERROR, v11, buf, 2u);
  uint64_t v12 = 0;
LABEL_27:

  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  uint64_t v13 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    int v16 = off_1E689A510[v12];
    *(_DWORD *)int buf = 136315394;
    *(void *)&uint8_t buf[4] = v16;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "Assertion failed";
    _os_log_error_impl(&dword_1D0DBD000, v13, OS_LOG_TYPE_ERROR, "Running m_regressor->runNetwork() failed with %s, returning %s", buf, 0x16u);
  }
LABEL_30:

  return 2;
}

void sub_1D0DE0854(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DE087C(uint64_t a1, float32x2_t *a2)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 192))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v6 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v6, OS_LOG_TYPE_ERROR, "Precondition violated: m_textureY", buf, 2u);
    }
    uint64_t v7 = 1;
    goto LABEL_38;
  }
  if (*(unsigned char *)(a1 + 264)) {
    goto LABEL_18;
  }
  id v4 = **(id **)(a1 + 240);
  sub_1D0DE1328((uint64_t)buf, v4, [*(id *)(a1 + 192) pixelFormat]);

  if (*(_DWORD *)&buf[16] == 1)
  {
    int v5 = *(unsigned __int8 *)(a1 + 264);
    *(void *)(a1 + 248) = *(void *)buf;
    if (v5)
    {
      objc_storeStrong((id *)(a1 + 256), *(id *)&buf[8]);
    }
    else
    {
      *(void *)(a1 + 256) = *(id *)&buf[8];
      *(unsigned char *)(a1 + 264) = 1;
    }
    sub_1D0DE181C((uint64_t)v55, (uint64_t)buf);
LABEL_18:
    uint64_t v6 = [*(id *)(a1 + 184) commandBuffer];
    [v6 setLabel:@"ViewpointCorrectionProcessor::drawDebugData"];
    if (!*(unsigned char *)(a1 + 944)) {
      goto LABEL_34;
    }
    float32x2_t v9 = a2[1];
    float32x2_t v10 = vmla_f32(*a2, v9, *(float32x2_t *)(a1 + 808));
    float32x2_t v11 = vmla_f32(*a2, v9, *(float32x2_t *)(a1 + 816));
    float32x2_t v12 = vmla_f32(*a2, v9, *(float32x2_t *)(a1 + 824));
    float32x2_t v13 = vmla_f32(*a2, v9, *(float32x2_t *)(a1 + 832));
    float32x2_t v14 = vmla_f32(*a2, v9, *(float32x2_t *)(a1 + 840));
    float32x2_t v15 = vmla_f32(*a2, v9, *(float32x2_t *)(a1 + 848));
    float32x2_t v16 = vmla_f32(*a2, v9, *(float32x2_t *)(a1 + 856));
    float32x2_t v17 = vmla_f32(*a2, v9, *(float32x2_t *)(a1 + 864));
    float32x2_t v18 = vmla_f32(*a2, v9, *(float32x2_t *)(a1 + 872));
    float32x2_t v19 = vmla_f32(*a2, v9, *(float32x2_t *)(a1 + 880));
    float32x2_t v20 = vmla_f32(*a2, v9, *(float32x2_t *)(a1 + 888));
    *(float32x2_t *)int buf = vmla_f32(*a2, v9, *(float32x2_t *)(a1 + 800));
    *(float32x2_t *)&uint8_t buf[8] = v10;
    *(float32x2_t *)&uint8_t buf[16] = v11;
    float32x2_t v57 = v12;
    float32x2_t v58 = v13;
    float32x2_t v59 = v14;
    float32x2_t v60 = v15;
    float32x2_t v61 = v16;
    float32x2_t v62 = v17;
    float32x2_t v63 = v18;
    float32x2_t v64 = v19;
    float32x2_t v65 = v20;
    __asm { FMOV            V0.4S, #1.0 }
    int v26 = sub_1D0DF2BF4((void *)(a1 + 248), (uint64_t)buf, 0xCu, 0, *(void **)(a1 + 192), v6, _Q0);
    if (v26)
    {
      uint64_t v7 = 2 * (v26 != 0);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      float16x4_t v27 = (id)qword_1EA6437C0;
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        goto LABEL_37;
      }
      if ((v7 - 1) > 6) {
        float16x4_t v28 = "Success, no error";
      }
      else {
        float16x4_t v28 = off_1E689A510[(v7 - 1)];
      }
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = "Precondition was violated";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v28;
      unint64_t v54 = "Running draw(normalizedLandmarksToImage(**m_trackedFace->normalizedLandmarks(), bbox), PrimitiveTypePoints) "
            "failed with %s, returning %s";
      goto LABEL_51;
    }
    id v29 = *(id *)(a1 + 656);
    unint64_t v30 = [v29 width];
    unint64_t v31 = [*(id *)(a1 + 656) height];

    simd_float3x3 v67 = __invert_f3(*(simd_float3x3 *)(a1 + 496));
    float32x4_t v32 = vmulq_f32((float32x4_t)v67.columns[0], (float32x4_t)0);
    int32x4_t v33 = (int32x4_t)vaddq_f32((float32x4_t)v67.columns[2], vmlaq_f32(v32, (float32x4_t)0, (float32x4_t)v67.columns[1]));
    int32x4_t v34 = (int32x4_t)vaddq_f32((float32x4_t)v67.columns[2], vmlaq_n_f32(v32, (float32x4_t)v67.columns[1], (float)v31));
    v67.columns[0] = (simd_float3)vmulq_n_f32((float32x4_t)v67.columns[0], (float)v30);
    int32x4_t v35 = (int32x4_t)vaddq_f32((float32x4_t)v67.columns[2], vmlaq_n_f32((float32x4_t)v67.columns[0], (float32x4_t)v67.columns[1], (float)v31));
    v67.columns[0] = (simd_float3)vaddq_f32((float32x4_t)v67.columns[2], vmlaq_f32((float32x4_t)v67.columns[0], (float32x4_t)0, (float32x4_t)v67.columns[1]));
    *(float32x2_t *)int buf = vdiv_f32(*(float32x2_t *)v33.i8, (float32x2_t)vdup_laneq_s32(v33, 2));
    *(float32x2_t *)&uint8_t buf[8] = vdiv_f32(*(float32x2_t *)v34.i8, (float32x2_t)vdup_laneq_s32(v34, 2));
    *(float32x2_t *)&uint8_t buf[16] = vdiv_f32(*(float32x2_t *)v35.i8, (float32x2_t)vdup_laneq_s32(v35, 2));
    float32x2_t v57 = vdiv_f32(*(float32x2_t *)v67.columns[0].f32, (float32x2_t)vdup_laneq_s32((int32x4_t)v67.columns[0], 2));
    float32x2_t v58 = *(float32x2_t *)buf;
    __asm { FMOV            V0.4S, #1.0 }
    int v36 = sub_1D0DF2BF4((void *)(a1 + 248), (uint64_t)buf, 5u, 2, *(void **)(a1 + 192), v6, (__n128)v67.columns[0]);
    if (v36)
    {
      uint64_t v7 = 2 * (v36 != 0);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      float16x4_t v27 = (id)qword_1EA6437C0;
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        goto LABEL_37;
      }
      if ((v7 - 1) > 6) {
        id v37 = "Success, no error";
      }
      else {
        id v37 = off_1E689A510[(v7 - 1)];
      }
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = "Precondition was violated";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v37;
      unint64_t v54 = "Running draw(linePoints(m_leftEye.cropCorners()), PrimitiveTypeLineStrip) failed with %s, returning %s";
      goto LABEL_51;
    }
    id v38 = *(id *)(a1 + 480);
    unint64_t v39 = [v38 width];
    unint64_t v40 = [*(id *)(a1 + 480) height];

    simd_float3x3 v68 = __invert_f3(*(simd_float3x3 *)(a1 + 320));
    float32x4_t v41 = vmulq_f32((float32x4_t)v68.columns[0], (float32x4_t)0);
    int32x4_t v42 = (int32x4_t)vaddq_f32((float32x4_t)v68.columns[2], vmlaq_f32(v41, (float32x4_t)0, (float32x4_t)v68.columns[1]));
    int32x4_t v43 = (int32x4_t)vaddq_f32((float32x4_t)v68.columns[2], vmlaq_n_f32(v41, (float32x4_t)v68.columns[1], (float)v40));
    v68.columns[0] = (simd_float3)vmulq_n_f32((float32x4_t)v68.columns[0], (float)v39);
    int32x4_t v44 = (int32x4_t)vaddq_f32((float32x4_t)v68.columns[2], vmlaq_n_f32((float32x4_t)v68.columns[0], (float32x4_t)v68.columns[1], (float)v40));
    v68.columns[0] = (simd_float3)vaddq_f32((float32x4_t)v68.columns[2], vmlaq_f32((float32x4_t)v68.columns[0], (float32x4_t)0, (float32x4_t)v68.columns[1]));
    *(float32x2_t *)int buf = vdiv_f32(*(float32x2_t *)v42.i8, (float32x2_t)vdup_laneq_s32(v42, 2));
    *(float32x2_t *)&uint8_t buf[8] = vdiv_f32(*(float32x2_t *)v43.i8, (float32x2_t)vdup_laneq_s32(v43, 2));
    *(float32x2_t *)&uint8_t buf[16] = vdiv_f32(*(float32x2_t *)v44.i8, (float32x2_t)vdup_laneq_s32(v44, 2));
    float32x2_t v57 = vdiv_f32(*(float32x2_t *)v68.columns[0].f32, (float32x2_t)vdup_laneq_s32((int32x4_t)v68.columns[0], 2));
    float32x2_t v58 = *(float32x2_t *)buf;
    __asm { FMOV            V0.4S, #1.0 }
    int v45 = sub_1D0DF2BF4((void *)(a1 + 248), (uint64_t)buf, 5u, 2, *(void **)(a1 + 192), v6, (__n128)v68.columns[0]);
    if (v45)
    {
      uint64_t v7 = 2 * (v45 != 0);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      float16x4_t v27 = (id)qword_1EA6437C0;
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        goto LABEL_37;
      }
      if ((v7 - 1) > 6) {
        int32x2_t v46 = "Success, no error";
      }
      else {
        int32x2_t v46 = off_1E689A510[(v7 - 1)];
      }
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = "Precondition was violated";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v46;
      unint64_t v54 = "Running draw(linePoints(m_rightEye.cropCorners()), PrimitiveTypeLineStrip) failed with %s, returning %s";
    }
    else
    {
LABEL_34:
      *((float *)&v47 + 1) = COERCE_FLOAT(HIDWORD(*(unint64_t *)a2)) + a2[1].f32[1];
      v48.f32[0] = a2->f32[0] + a2[1].f32[0];
      *(float *)&uint64_t v49 = v48.f32[0];
      *((float *)&v49 + 1) = *((float *)&v47 + 1);
      v48.i32[1] = a2->i32[1];
      *(float32x2_t *)int buf = *a2;
      LODWORD(v47) = *(_DWORD *)buf;
      *(void *)&uint8_t buf[8] = v47;
      *(void *)&uint8_t buf[16] = v49;
      float32x2_t v57 = v48;
      float32x2_t v58 = *(float32x2_t *)buf;
      __asm { FMOV            V0.4S, #1.0 }
      int v51 = sub_1D0DF2BF4((void *)(a1 + 248), (uint64_t)buf, 5u, 2, *(void **)(a1 + 192), v6, _Q0);
      if (!v51)
      {
        [v6 commit];
        [v6 waitUntilCompleted];
        uint64_t v7 = 0;
        goto LABEL_38;
      }
      uint64_t v7 = 2 * (v51 != 0);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      float16x4_t v27 = (id)qword_1EA6437C0;
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
LABEL_37:

LABEL_38:
        return v7;
      }
      if ((v7 - 1) > 6) {
        float32x4_t v53 = "Success, no error";
      }
      else {
        float32x4_t v53 = off_1E689A510[(v7 - 1)];
      }
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = "Precondition was violated";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v53;
      unint64_t v54 = "Running draw(linePoints(boundingBoxCorners(bbox)), PrimitiveTypeLineStrip) failed with %s, returning %s";
    }
LABEL_51:
    _os_log_error_impl(&dword_1D0DBD000, v27, OS_LOG_TYPE_ERROR, v54, buf, 0x16u);
    goto LABEL_37;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  int v8 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)float32x4_t v55 = 0;
    _os_log_error_impl(&dword_1D0DBD000, v8, OS_LOG_TYPE_ERROR, "Assertion failed: std::holds_alternative<DebugRenderer>(rendererOrError)", v55, 2u);
  }

  if (*(_DWORD *)&buf[16] != -1) {
    ((void (*)(uint8_t *, unsigned char *))off_1F26F5598[*(unsigned int *)&buf[16]])(v55, buf);
  }
  return 2;
}

void sub_1D0DE1130(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DE118C(uint64_t a1)
{
  if (*(void *)a1)
  {
    id v6 = *(id *)a1;
    uint64_t v2 = *(void *)(a1 + 32);
    if (!v2)
    {
      uint64_t result = sub_1D0DD8808();
      __break(1u);
      return result;
    }
    (*(void (**)(uint64_t, id *))(*(void *)v2 + 48))(v2, &v6);

    id v3 = *(id *)a1;
    *(void *)a1 = 0;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
  }

  return a1;
}

void sub_1D0DE1280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  sub_1D0DE12A4((void *)(v10 + 8));
  _Unwind_Resume(a1);
}

void *sub_1D0DE12A4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1D0DE1328(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  *(void *)int buf = 0;
  id v6 = +[VPCMetalLib metalLibraryWithDevice:v5 error:buf];
  id v7 = *(id *)buf;
  if (v6)
  {
    int v8 = (void *)[v6 newFunctionWithName:@"debugRendererVertex"];
    uint64_t v9 = [v6 newFunctionWithName:@"debugRendererFragment"];
    uint64_t v10 = (void *)v9;
    if (v8) {
      BOOL v11 = v9 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (v11)
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      float32x2_t v12 = (id)qword_1EA6437C0;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v28) = 0;
        _os_log_error_impl(&dword_1D0DBD000, v12, OS_LOG_TYPE_ERROR, "Could not find required metal functions.", (uint8_t *)&v28, 2u);
      }

      LODWORD(v28) = 2;
      int v29 = 0;
    }
    else
    {
      float32x2_t v14 = objc_opt_new();
      [v14 setVertexFunction:v8];
      [v14 setFragmentFunction:v10];
      float32x2_t v15 = [v14 colorAttachments];
      float32x2_t v16 = [v15 objectAtIndexedSubscript:0];
      [v16 setPixelFormat:a3];

      id v26 = v7;
      float32x2_t v17 = (void *)[v5 newRenderPipelineStateWithDescriptor:v14 error:&v26];
      id v18 = v26;

      if (v17)
      {
        id v19 = v17;
        *(void *)&long long v28 = a3;
        *((void *)&v28 + 1) = v19;
        int v20 = 1;
      }
      else
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EA6437C8))
        {
          qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
          __cxa_guard_release(&qword_1EA6437C8);
        }
        float16x4_t v21 = (id)qword_1EA6437C0;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          LODWORD(v28) = 138412290;
          *(void *)((char *)&v28 + 4) = v18;
          _os_log_error_impl(&dword_1D0DBD000, v21, OS_LOG_TYPE_ERROR, "Could not create render pipeline state: %@", (uint8_t *)&v28, 0xCu);
        }

        int v20 = 0;
        LODWORD(v28) = 2;
      }
      int v29 = v20;

      id v7 = v18;
    }
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    float32x2_t v13 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v28) = 138412290;
      *(void *)((char *)&v28 + 4) = v7;
      _os_log_error_impl(&dword_1D0DBD000, v13, OS_LOG_TYPE_ERROR, "Could not get metal library: %@", (uint8_t *)&v28, 0xCu);
    }

    LODWORD(v28) = 2;
    int v29 = 0;
  }

  if (v29 == 1)
  {
    uint64_t v22 = v28;
    id v23 = *((id *)&v28 + 1);
    *(void *)a1 = v22;
    *(void *)(a1 + 8) = v23;
    int v24 = 1;
    *(_DWORD *)(a1 + 16) = 1;
LABEL_29:
    ((void (*)(uint8_t *, long long *))off_1F26F5588[v24])(buf, &v28);
    return;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  float16x4_t v25 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    _os_log_error_impl(&dword_1D0DBD000, v25, OS_LOG_TYPE_ERROR, "Assertion failed: std::holds_alternative<Config>(configOrError)", buf, 2u);
  }

  *(_DWORD *)a1 = 2;
  int v24 = v29;
  *(_DWORD *)(a1 + 16) = 0;
  if (v24 != -1) {
    goto LABEL_29;
  }
}

void sub_1D0DE17B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D0DE181C(uint64_t a1, uint64_t a2)
{
}

void sub_1D0DE1828(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1D0DE1834(uint64_t a1, float32x2_t *a2, uint64_t a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v6 = (void *)(*(void *)(a1 + 296) + 160);
  id v7 = (char *)operator new(0x20uLL);
  *(void *)int buf = v7;
  *(_OWORD *)&uint8_t buf[8] = xmmword_1D0E81500;
  strcpy(v7, "input_face_crop_image_low_res");
  int v8 = sub_1D0DE1C1C(v6, (uint64_t)buf);
  if (!v8) {
    abort();
  }
  long long v33 = *((_OWORD *)v8 + 3);
  operator delete(v7);
  v9.i32[1] = DWORD1(v33);
  if (v33 != DWORD2(v33))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    int v29 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v29, OS_LOG_TYPE_ERROR, "Precondition violated: w == h", buf, 2u);
    }
    uint64_t v28 = 1;
    goto LABEL_16;
  }
  *(float *)v9.i32 = 10.0 / (float)(int)v33;
  float32x2_t v10 = (float32x2_t)vdup_lane_s32(v9, 0);
  float32x2_t v11 = vsub_f32(a2[1], a2[13]);
  float v12 = (float)(vaddv_f32(vabd_f32(vsub_f32(*a2, a2[12]), v10)) + vabds_f32(v11.f32[0], *(float *)v9.i32))
      + vabds_f32(v11.f32[1], *(float *)v9.i32);
  float32x2_t v13 = vsub_f32(a2[2], a2[14]);
  float v14 = (float)(v12 + vabds_f32(v13.f32[0], *(float *)v9.i32)) + vabds_f32(v13.f32[1], *(float *)v9.i32);
  float32x2_t v15 = vsub_f32(a2[3], a2[15]);
  float v16 = (float)(v14 + vabds_f32(v15.f32[0], *(float *)v9.i32)) + vabds_f32(v15.f32[1], *(float *)v9.i32);
  float32x2_t v17 = vsub_f32(a2[4], a2[16]);
  float v18 = (float)(v16 + vabds_f32(v17.f32[0], *(float *)v9.i32)) + vabds_f32(v17.f32[1], *(float *)v9.i32);
  float32x2_t v19 = vsub_f32(a2[5], a2[17]);
  float v20 = fmaxf((float)(v18 + vabds_f32(v19.f32[0], *(float *)v9.i32)) + vabds_f32(v19.f32[1], *(float *)v9.i32), 0.0);
  v19.f32[0] = vaddv_f32(vabd_f32(vsub_f32(a2[6], a2[18]), v10));
  float32x2_t v21 = vsub_f32(a2[7], a2[19]);
  v19.f32[0] = (float)(v19.f32[0] + vabds_f32(v21.f32[0], *(float *)v9.i32)) + vabds_f32(v21.f32[1], *(float *)v9.i32);
  float32x2_t v22 = vsub_f32(a2[8], a2[20]);
  v19.f32[0] = (float)(v19.f32[0] + vabds_f32(v22.f32[0], *(float *)v9.i32)) + vabds_f32(v22.f32[1], *(float *)v9.i32);
  float32x2_t v23 = vsub_f32(a2[9], a2[21]);
  v19.f32[0] = (float)(v19.f32[0] + vabds_f32(v23.f32[0], *(float *)v9.i32)) + vabds_f32(v23.f32[1], *(float *)v9.i32);
  float32x2_t v24 = vsub_f32(a2[10], a2[22]);
  v19.f32[0] = (float)(v19.f32[0] + vabds_f32(v24.f32[0], *(float *)v9.i32)) + vabds_f32(v24.f32[1], *(float *)v9.i32);
  float32x2_t v25 = vsub_f32(a2[11], a2[23]);
  *(float *)v9.i32 = (float)(v19.f32[0] + vabds_f32(v25.f32[0], *(float *)v9.i32))
                   + vabds_f32(v25.f32[1], *(float *)v9.i32);
  *(_OWORD *)int buf = *(_OWORD *)a3;
  if (v20 >= *(float *)v9.i32) {
    *(float *)v9.i32 = v20;
  }
  *(void *)&uint8_t buf[16] = *(void *)(a3 + 16);
  *(_DWORD *)(a1 + 1072) = v9.i32[0];
  unsigned int v26 = sub_1D0DF47F4(a1 + 1080, (float *)(a1 + 1072), (uint64_t)buf);
  unsigned int v27 = v26 - 1;
  if (v26 == 1) {
    uint64_t v28 = 2;
  }
  else {
    uint64_t v28 = v26;
  }
  if (v26)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    int v29 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      uint64_t v30 = off_1E689A510[v27];
      unint64_t v31 = off_1E689A510[(v28 - 1)];
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = v30;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v31;
      _os_log_error_impl(&dword_1D0DBD000, v29, OS_LOG_TYPE_ERROR, "Running m_trackedFace->updateLandmarksJitter(sum, timestamp) failed with %s, returning %s", buf, 0x16u);
    }
LABEL_16:
  }
  return v28;
}

void sub_1D0DE1C08(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1D0DE1C1C(void *a1, uint64_t a2)
{
  int v3 = *(char *)(a2 + 23);
  if (v3 >= 0) {
    uint64_t v4 = (uint64_t *)a2;
  }
  else {
    uint64_t v4 = *(uint64_t **)a2;
  }
  if (v3 >= 0) {
    unint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v5 = *(void *)(a2 + 8);
  }
  unint64_t v6 = sub_1D0DE1DF8(v4, v5);
  int8x8_t v7 = (int8x8_t)a1[1];
  if (v7)
  {
    unint64_t v8 = v6;
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = v6;
      if (v6 >= *(void *)&v7) {
        unint64_t v10 = v6 % *(void *)&v7;
      }
    }
    else
    {
      unint64_t v10 = (*(void *)&v7 - 1) & v6;
    }
    float32x2_t v11 = *(uint64_t ***)(*a1 + 8 * v10);
    if (v11)
    {
      float v12 = *v11;
      if (*v11)
      {
        if (v9.u32[0] < 2uLL)
        {
          uint64_t v13 = *(void *)&v7 - 1;
          while (1)
          {
            uint64_t v19 = v12[1];
            if (v8 == v19)
            {
              uint64_t v20 = *((unsigned __int8 *)v12 + 39);
              if ((v20 & 0x80u) == 0) {
                uint64_t v21 = *((unsigned __int8 *)v12 + 39);
              }
              else {
                uint64_t v21 = v12[3];
              }
              if (v21 == v5)
              {
                if ((v20 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v12[2], v4, v12[3])) {
                    return v12;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v12 + 39)) {
                    return v12;
                  }
                  uint64_t v22 = 0;
                  while (*((unsigned __int8 *)v12 + v22 + 16) == *((unsigned __int8 *)v4 + v22))
                  {
                    if (v20 == ++v22) {
                      return v12;
                    }
                  }
                }
              }
            }
            else if ((v19 & v13) != v10)
            {
              return 0;
            }
            uint64_t result = 0;
            float v12 = (uint64_t *)*v12;
            if (!v12) {
              return result;
            }
          }
        }
        while (1)
        {
          unint64_t v15 = v12[1];
          if (v8 == v15)
          {
            uint64_t v16 = *((unsigned __int8 *)v12 + 39);
            if ((v16 & 0x80u) == 0) {
              uint64_t v17 = *((unsigned __int8 *)v12 + 39);
            }
            else {
              uint64_t v17 = v12[3];
            }
            if (v17 == v5)
            {
              if ((v16 & 0x80) != 0)
              {
                if (!memcmp((const void *)v12[2], v4, v12[3])) {
                  return v12;
                }
              }
              else
              {
                if (!*((unsigned char *)v12 + 39)) {
                  return v12;
                }
                uint64_t v18 = 0;
                while (*((unsigned __int8 *)v12 + v18 + 16) == *((unsigned __int8 *)v4 + v18))
                {
                  if (v16 == ++v18) {
                    return v12;
                  }
                }
              }
            }
          }
          else
          {
            if (v15 >= *(void *)&v7) {
              v15 %= *(void *)&v7;
            }
            if (v15 != v10) {
              return 0;
            }
          }
          uint64_t result = 0;
          float v12 = (uint64_t *)*v12;
          if (!v12) {
            return result;
          }
        }
      }
    }
  }
  return 0;
}

unint64_t sub_1D0DE1DF8(uint64_t *a1, unint64_t a2)
{
  if (a2 > 0x20)
  {
    if (a2 <= 0x40)
    {
      uint64_t v5 = *(uint64_t *)((char *)a1 + a2 - 16);
      uint64_t v6 = *a1 - 0x3C5A37A36834CED9 * (v5 + a2);
      uint64_t v8 = a1[2];
      uint64_t v7 = a1[3];
      uint64_t v9 = __ROR8__(v6 + v7, 52);
      uint64_t v10 = v6 + a1[1];
      uint64_t v11 = __ROR8__(v10, 7);
      uint64_t v12 = v10 + v8;
      uint64_t v13 = *(uint64_t *)((char *)a1 + a2 - 32) + v8;
      uint64_t v14 = *(uint64_t *)((char *)a1 + a2 - 8) + v7;
      uint64_t v15 = __ROR8__(v14 + v13, 52);
      uint64_t v16 = v11 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v5 + a2), 37) + v9;
      uint64_t v17 = __ROR8__(v13, 37);
      uint64_t v18 = *(uint64_t *)((char *)a1 + a2 - 24) + v13;
      uint64_t v19 = __ROR8__(v18, 7);
      uint64_t v20 = v16 + __ROR8__(v12, 31);
      uint64_t v21 = v18 + v5;
      uint64_t v22 = v21 + v14;
      unint64_t v23 = 0x9AE16A3B2F90404FLL;
      unint64_t v24 = 0xC3A5C85C97CB3127 * (v22 + v20) - 0x651E95C4D06FBFB1 * (v12 + v7 + v17 + v19 + v15 + __ROR8__(v21, 31));
      unint64_t v25 = v20 - 0x3C5A37A36834CED9 * (v24 ^ (v24 >> 47));
      return (v25 ^ (v25 >> 47)) * v23;
    }
    unint64_t v32 = 0x9DDFEA08EB382D69;
    uint64_t v33 = *(uint64_t *)((char *)a1 + a2 - 48);
    uint64_t v34 = *(uint64_t *)((char *)a1 + a2 - 40);
    uint64_t v35 = *(uint64_t *)((char *)a1 + a2 - 24);
    uint64_t v37 = *(uint64_t *)((char *)a1 + a2 - 64);
    uint64_t v36 = *(uint64_t *)((char *)a1 + a2 - 56);
    uint64_t v38 = *(uint64_t *)((char *)a1 + a2 - 16);
    uint64_t v39 = *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v40 = v36 + v38;
    unint64_t v41 = 0x9DDFEA08EB382D69
        * (v35 ^ ((0x9DDFEA08EB382D69 * (v35 ^ (v33 + a2))) >> 47) ^ (0x9DDFEA08EB382D69 * (v35 ^ (v33 + a2))));
    unint64_t v42 = 0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47));
    unint64_t v43 = v37 + a2 + v36 + v33;
    uint64_t v44 = v43 + v34;
    unint64_t v45 = __ROR8__(v43, 44) + v37 + a2 + __ROR8__(v34 + v37 + a2 - 0x622015F714C7D297 * (v41 ^ (v41 >> 47)), 21);
    uint64_t v46 = v36 + v38 + *(uint64_t *)((char *)a1 + a2 - 32) - 0x4B6D499041670D8DLL;
    uint64_t v47 = v46 + v35 + v38;
    uint64_t v48 = __ROR8__(v47, 44);
    uint64_t v49 = v47 + v39;
    uint64_t v50 = v48 + v46 + __ROR8__(v46 + v34 + v39, 21);
    uint64_t v52 = *a1;
    int v51 = a1 + 4;
    unint64_t v53 = v52 - 0x4B6D499041670D8DLL * v34;
    uint64_t v54 = -(uint64_t)((a2 - 1) & 0xFFFFFFFFFFFFFFC0);
    do
    {
      uint64_t v55 = *(v51 - 3);
      uint64_t v56 = v53 + v44 + v40 + v55;
      uint64_t v57 = v51[2];
      uint64_t v58 = v51[3];
      uint64_t v59 = v51[1];
      unint64_t v40 = v59 + v44 - 0x4B6D499041670D8DLL * __ROR8__(v40 + v45 + v57, 42);
      uint64_t v60 = v42 + v49;
      uint64_t v61 = *(v51 - 2);
      uint64_t v62 = *(v51 - 1);
      uint64_t v63 = *(v51 - 4) - 0x4B6D499041670D8DLL * v45;
      uint64_t v64 = v63 + v49 + v62;
      uint64_t v65 = v63 + v55 + v61;
      uint64_t v44 = v65 + v62;
      uint64_t v66 = __ROR8__(v65, 44) + v63;
      unint64_t v67 = (0xB492B66FBE98F273 * __ROR8__(v56, 37)) ^ v50;
      unint64_t v53 = 0xB492B66FBE98F273 * __ROR8__(v60, 33);
      unint64_t v45 = v66 + __ROR8__(v64 + v67, 21);
      unint64_t v68 = v53 + v50 + *v51;
      uint64_t v49 = v68 + v59 + v57 + v58;
      uint64_t v50 = __ROR8__(v68 + v59 + v57, 44) + v68 + __ROR8__(v40 + v61 + v68 + v58, 21);
      v51 += 8;
      unint64_t v42 = v67;
      v54 += 64;
    }
    while (v54);
    unint64_t v69 = v53
        - 0x622015F714C7D297
        * ((0x9DDFEA08EB382D69
          * (v50 ^ ((0x9DDFEA08EB382D69 * (v50 ^ v45)) >> 47) ^ (0x9DDFEA08EB382D69 * (v50 ^ v45)))) ^ ((0x9DDFEA08EB382D69 * (v50 ^ ((0x9DDFEA08EB382D69 * (v50 ^ v45)) >> 47) ^ (0x9DDFEA08EB382D69 * (v50 ^ v45)))) >> 47));
    unint64_t v70 = 0x9DDFEA08EB382D69
        * (v69 ^ (v67
                - 0x4B6D499041670D8DLL * (v40 ^ (v40 >> 47))
                - 0x622015F714C7D297
                * ((0x9DDFEA08EB382D69
                  * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) ^ ((0x9DDFEA08EB382D69 * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) >> 47))));
    unint64_t v71 = 0x9DDFEA08EB382D69 * (v69 ^ (v70 >> 47) ^ v70);
    goto LABEL_13;
  }
  if (a2 > 0x10)
  {
    uint64_t v26 = a1[1];
    unint64_t v27 = 0xB492B66FBE98F273 * *a1;
    uint64_t v28 = __ROR8__(0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8), 30) + __ROR8__(v27 - v26, 43);
    unint64_t v29 = v27 + a2 + __ROR8__(v26 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v23 = 0x9DDFEA08EB382D69;
    unint64_t v30 = 0x9DDFEA08EB382D69 * ((v28 - 0x3C5A37A36834CED9 * *(uint64_t *)((char *)a1 + a2 - 16)) ^ v29);
    unint64_t v31 = v29 ^ (v30 >> 47) ^ v30;
LABEL_8:
    unint64_t v25 = 0x9DDFEA08EB382D69 * v31;
    return (v25 ^ (v25 >> 47)) * v23;
  }
  if (a2 >= 9)
  {
    uint64_t v2 = *(uint64_t *)((char *)a1 + a2 - 8);
    uint64_t v3 = __ROR8__(v2 + a2, a2);
    return (0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) >> 47))) ^ v2;
  }
  if (a2 >= 4)
  {
    uint64_t v72 = *(unsigned int *)((char *)a1 + a2 - 4);
    unint64_t v23 = 0x9DDFEA08EB382D69;
    unint64_t v73 = 0x9DDFEA08EB382D69 * (((8 * *(_DWORD *)a1) + a2) ^ v72);
    unint64_t v31 = v72 ^ (v73 >> 47) ^ v73;
    goto LABEL_8;
  }
  unint64_t v32 = 0x9AE16A3B2F90404FLL;
  if (a2)
  {
    unint64_t v71 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                   * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
LABEL_13:
    v32 *= v71 ^ (v71 >> 47);
  }
  return v32;
}

void sub_1D0DE222C()
{
}

void sub_1D0DE223C(std::exception *a1)
{
  std::exception::~exception(a1);
  JUMPOUT(0x1D25F16B0);
}

id sub_1D0DE2278(void *a1)
{
  uint64_t v1 = [a1 iosurface];
  return v1;
}

uint64_t sub_1D0DE22A4(uint64_t a1, void *a2, void *a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  id v4 = a2;
  id v5 = a3;
  id v6 = v4;
  id v7 = v5;
  uint64_t v8 = [v6 width];
  if (v8 != [v7 width])
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    unint64_t v25 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_34;
    }
    *(_WORD *)int buf = 0;
    uint64_t v26 = "Precondition violated: xSurface.width == ySurface.width";
LABEL_33:
    _os_log_error_impl(&dword_1D0DBD000, v25, OS_LOG_TYPE_ERROR, v26, buf, 2u);
    goto LABEL_34;
  }
  uint64_t v9 = [v6 height];
  if (v9 != [v7 height])
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    unint64_t v25 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_34;
    }
    *(_WORD *)int buf = 0;
    uint64_t v26 = "Precondition violated: xSurface.height == ySurface.height";
    goto LABEL_33;
  }
  uint64_t v10 = [v6 bytesPerRow];
  if (v10 != [v7 bytesPerRow])
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    unint64_t v25 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_34;
    }
    *(_WORD *)int buf = 0;
    uint64_t v26 = "Precondition violated: xSurface.bytesPerRow == ySurface.bytesPerRow";
    goto LABEL_33;
  }
  uint64_t v11 = [v6 bytesPerElement];
  if (v11 != [v7 bytesPerElement])
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    unint64_t v25 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_34;
    }
    *(_WORD *)int buf = 0;
    uint64_t v26 = "Precondition violated: xSurface.bytesPerElement == ySurface.bytesPerElement";
    goto LABEL_33;
  }
  if ([v6 bytesPerElement] != 2)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    unint64_t v25 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_34;
    }
    *(_WORD *)int buf = 0;
    uint64_t v26 = "Precondition violated: xSurface.bytesPerElement == sizeof(_Float16)";
    goto LABEL_33;
  }
  uint64_t v12 = [v6 bytesPerRow];
  uint64_t v13 = [v6 bytesPerElement];
  uint64_t v14 = [v6 bytesPerElement];
  uint64_t v15 = v12 / v13;
  if (v14 * (v12 / v13) != [v6 bytesPerRow])
  {
    unint64_t v25 = sub_1D0DF4E04();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_34;
    }
    *(_WORD *)int buf = 0;
    uint64_t v26 = "Precondition violated: elementsPerRow * xSurface.bytesPerElement == xSurface.bytesPerRow";
    goto LABEL_33;
  }
  uint64_t v16 = [v7 bytesPerElement];
  if (v16 * v15 == [v7 bytesPerRow])
  {
    [v6 lockWithOptions:1 seed:0];
    [v7 lockWithOptions:1 seed:0];
    id v17 = v6;
    uint64_t v18 = [v17 baseAddress];
    id v19 = v7;
    uint64_t v20 = [v19 baseAddress];
    id v32 = v19;
    uint64_t v21 = 0;
    uint64_t v22 = 2 * v15;
    float v23 = 0.0;
    for (uint64_t i = objc_msgSend(v17, "height", v32); i > v21; uint64_t i = objc_msgSend(v17, "height", v33))
    {
      for (uint64_t j = 0; [v17 width] > j; ++j)
      {
        v28.i16[0] = *(_WORD *)(v18 + 2 * j);
        v28.i16[1] = *(_WORD *)(v20 + 2 * j);
        float32x2_t v29 = (float32x2_t)vcvtq_f32_f16(v28).u64[0];
        float v23 = v23 + sqrtf(vaddv_f32(vmul_f32(v29, v29)));
      }
      ++v21;
      v20 += v22;
      v18 += v22;
    }
    [v33 unlockWithOptions:1 seed:0];
    [v17 unlockWithOptions:1 seed:0];
    [v17 width];
    [v17 height];

    cva::ItemHandler::createValue<float>();
  }
  unint64_t v25 = sub_1D0DF4E04();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    uint64_t v26 = "Precondition violated: elementsPerRow * ySurface.bytesPerElement == ySurface.bytesPerRow";
    goto LABEL_33;
  }
LABEL_34:

  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  unint64_t v30 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)int buf = 136315394;
    uint64_t v35 = "Precondition was violated";
    __int16 v36 = 2080;
    uint64_t v37 = "Assertion failed";
    _os_log_error_impl(&dword_1D0DBD000, v30, OS_LOG_TYPE_ERROR, "Running computeWarpFieldAverageIntensity(xSurface, ySurface, averageWarpFieldIntensity) failed with %s, returning %s", buf, 0x16u);
  }

  return 2;
}

void sub_1D0DE2978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)va);

  _Unwind_Resume(a1);
}

uint64_t sub_1D0DE29C8(uint64_t *a1)
{
  if (*a1)
  {
    uint64_t v5 = *a1;
    uint64_t v2 = a1[4];
    if (!v2)
    {
      uint64_t result = sub_1D0DD8808();
      __break(1u);
      return result;
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v5);
    *a1 = 0;
  }
  uint64_t v3 = (uint64_t *)a1[4];
  if (v3 == a1 + 1)
  {
    (*(void (**)(uint64_t *))(a1[1] + 32))(a1 + 1);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t *))(*v3 + 40))(v3);
  }
  return (uint64_t)a1;
}

void sub_1D0DE2AA0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 32);
  if (v3 == v1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(v1 + 8) + 32))(v1 + 8);
    _Unwind_Resume(exception_object);
  }
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1D0DE2B14(uint64_t a1, CFTypeRef *a2)
{
  if (*a2) {
    CFRelease(*a2);
  }
}

void sub_1D0DE2B2C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26F4670;
}

void *sub_1D0DE2B4C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F26F4670;
  return result;
}

void sub_1D0DE2B84()
{
}

uint64_t sub_1D0DE2B9C(uint64_t a1, void *a2)
{
  return MEMORY[0x1F4181798](*a2, sel_endScope);
}

void sub_1D0DE2BAC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26F3AB0;
}

void *sub_1D0DE2BCC()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F26F3AB0;
  return result;
}

void sub_1D0DE2C04()
{
}

uint64_t *sub_1D0DE2C1C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = sub_1D0DF011C(v2);
    MEMORY[0x1D25F16B0](v3, 0x10A2C40AC51AD7DLL);
  }
  return a1;
}

void **sub_1D0DE2C64(void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = sub_1D0DD845C(v2);
    MEMORY[0x1D25F16B0](v3, 0x10A0C4041783943);
  }
  return a1;
}

id **sub_1D0DE2CAC(id **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {

    MEMORY[0x1D25F16B0](v2, 0x80C4018A671A6);
  }
  return a1;
}

uint64_t sub_1D0DE2D14(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id v2 = MTLCreateSystemDefaultDevice();
  if (v2)
  {
    uint64_t v3 = objc_opt_new();
    [v3 setCommitSynchronously:1];
    inactive = dispatch_workloop_create_inactive("com.apple.applecva.viewpointcorrection.metal.workloop");
    if (inactive)
    {
      dispatch_workloop_set_scheduler_priority();
      dispatch_activate(inactive);
      uint64_t v5 = dispatch_queue_create_with_target_V2("com.apple.applecva.viewpointcorrection.metal.queue", 0, inactive);
      [v3 setCompletionQueue:v5];
      if (v5)
      {
        uint64_t v6 = [v2 newCommandQueueWithDescriptor:v3];
        id v7 = *(void **)(a1 + 184);
        *(void *)(a1 + 184) = v6;

        if (v6) {
          operator new();
        }
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EA6437C8))
        {
          qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
          __cxa_guard_release(&qword_1EA6437C8);
        }
        uint64_t v10 = (id)qword_1EA6437C0;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)int buf = 0;
          _os_log_error_impl(&dword_1D0DBD000, v10, OS_LOG_TYPE_ERROR, "Assertion failed: m_queue = [device newCommandQueueWithDescriptor:queueDescriptor]", buf, 2u);
        }

        uint64_t v8 = 6;
      }
      else
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EA6437C8))
        {
          qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
          __cxa_guard_release(&qword_1EA6437C8);
        }
        uint64_t v9 = (id)qword_1EA6437C0;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)int buf = 0;
          _os_log_error_impl(&dword_1D0DBD000, v9, OS_LOG_TYPE_ERROR, "Assertion failed: queueDescriptor.completionQueue = completionQueue", buf, 2u);
        }

        uint64_t v5 = 0;
        uint64_t v8 = 2;
      }
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      uint64_t v5 = (id)qword_1EA6437C0;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int buf = 0;
        uint64_t v8 = 2;
        _os_log_error_impl(&dword_1D0DBD000, v5, OS_LOG_TYPE_ERROR, "Assertion failed: completionWorkloop", buf, 2u);
      }
      else
      {
        uint64_t v8 = 2;
      }
    }
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v3 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v3, OS_LOG_TYPE_ERROR, "Assertion failed: device = (id<MTLDeviceSPI>)MTLCreateSystemDefaultDevice()", buf, 2u);
    }
    uint64_t v8 = 6;
  }

  return v8;
}

void sub_1D0DE532C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,void *__p,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,char a48,uint64_t a49,uint64_t a50,void *a51)
{
  operator delete(__p);
  if (a24) {
    operator delete(a24);
  }
  if (a37) {
    operator delete(a37);
  }
  sub_1D0DE2C64(&a51);
  if (a47 < 0) {
    operator delete(a42);
  }
  cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)&a48);

  uint64_t v55 = (void *)a50;
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DE56CC()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437B8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437B8))
  {
    byte_1EA6437B0 = sub_1D0DE9490();
    __cxa_guard_release(&qword_1EA6437B8);
  }
  return byte_1EA6437B0;
}

void sub_1D0DE5728(_Unwind_Exception *a1)
{
}

uint64_t sub_1D0DE5740(uint64_t a1)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  id v2 = (void *)(*(void *)(a1 + 296) + 80);
  uint64_t v3 = (char *)operator new(0x20uLL);
  *(void *)int buf = v3;
  *(_OWORD *)&uint8_t buf[8] = xmmword_1D0E81500;
  strcpy(v3, "left_eye_input_images_low_res");
  id v4 = sub_1D0DE1C1C(v2, (uint64_t)buf);
  if (!v4) {
    abort();
  }
  id v5 = (id)v4[5];
  operator delete(v3);
  strcpy(buf, "left_eye_face_location");
  buf[23] = 22;
  uint64_t v6 = sub_1D0DE1C1C(v2, (uint64_t)buf);
  if (!v6) {
    abort();
  }
  id v7 = (id)v6[5];
  uint64_t v8 = (char *)operator new(0x20uLL);
  *(void *)int buf = v8;
  *(_OWORD *)&uint8_t buf[8] = xmmword_1D0E81510;
  strcpy(v8, "right_eye_input_images_low_res");
  uint64_t v9 = sub_1D0DE1C1C(v2, (uint64_t)buf);
  if (!v9) {
    abort();
  }
  id v10 = (id)v9[5];
  operator delete(v8);
  uint64_t v11 = (char *)operator new(0x19uLL);
  *(void *)int buf = v11;
  *(_OWORD *)&uint8_t buf[8] = xmmword_1D0E81520;
  strcpy(v11, "right_eye_face_location");
  uint64_t v12 = sub_1D0DE1C1C(v2, (uint64_t)buf);
  if (!v12) {
    abort();
  }
  id v13 = (id)v12[5];
  operator delete(v11);
  if ([v5 isEqualToDictionary:v10])
  {
    if ([v7 isEqualToDictionary:v13])
    {
      v40[0] = v2;
      v40[1] = a1;
      unsigned int v14 = sub_1D0DE9024((uint64_t)v40, @"leftEye", a1 + 496);
      unsigned int v15 = v14 - 1;
      if (v14 == 1) {
        uint64_t v16 = 2;
      }
      else {
        uint64_t v16 = v14;
      }
      if (v14)
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EA6437C8))
        {
          qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
          __cxa_guard_release(&qword_1EA6437C8);
        }
        id v17 = (id)qword_1EA6437C0;
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          goto LABEL_40;
        }
        uint64_t v18 = off_1E689A510[v15];
        id v19 = off_1E689A510[(v16 - 1)];
        *(_DWORD *)int buf = 136315394;
        *(void *)&uint8_t buf[4] = v18;
        *(_WORD *)&uint8_t buf[12] = 2080;
        *(void *)&buf[14] = v19;
        uint64_t v20 = "Running setupCropData(@\"leftEye\", m_leftEye) failed with %s, returning %s";
        goto LABEL_29;
      }
      unsigned int v22 = sub_1D0DE9024((uint64_t)v40, @"rightEye", a1 + 320);
      unsigned int v23 = v22 - 1;
      if (v22 == 1) {
        uint64_t v16 = 2;
      }
      else {
        uint64_t v16 = v22;
      }
      if (v22)
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EA6437C8))
        {
          qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
          __cxa_guard_release(&qword_1EA6437C8);
        }
        id v17 = (id)qword_1EA6437C0;
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          goto LABEL_40;
        }
        unint64_t v24 = off_1E689A510[v23];
        unint64_t v25 = off_1E689A510[(v16 - 1)];
        *(_DWORD *)int buf = 136315394;
        *(void *)&uint8_t buf[4] = v24;
        *(_WORD *)&uint8_t buf[12] = 2080;
        *(void *)&buf[14] = v25;
        uint64_t v20 = "Running setupCropData(@\"rightEye\", m_rightEye) failed with %s, returning %s";
        goto LABEL_29;
      }
      uint64_t v26 = (char *)operator new(0x20uLL);
      *(void *)int buf = v26;
      *(_OWORD *)&uint8_t buf[8] = xmmword_1D0E81500;
      strcpy(v26, "input_face_crop_image_low_res");
      unint64_t v27 = sub_1D0DE1C1C(v2, (uint64_t)buf);
      if (!v27) {
        abort();
      }
      float16x4_t v28 = v27;
      operator delete(v26);
      uint64_t v29 = [objc_alloc(MEMORY[0x1E4F2EF78]) initWithProperties:v28[5]];
      unint64_t v30 = *(void **)(a1 + 312);
      *(void *)(a1 + 312) = v29;

      unint64_t v31 = *(void **)(a1 + 312);
      if (v31)
      {
        unsigned int v32 = sub_1D0DF3804(*(id **)(a1 + 240), v31, 7, 0, (id *)(a1 + 712));
        unsigned int v33 = v32 - 1;
        if (v32 == 1) {
          uint64_t v16 = 2;
        }
        else {
          uint64_t v16 = v32;
        }
        if (v32)
        {
          id v17 = sub_1D0DF4E04();
          if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
            goto LABEL_40;
          }
          uint64_t v34 = off_1E689A510[v33];
          uint64_t v35 = off_1E689A510[(v16 - 1)];
          *(_DWORD *)int buf = 136315394;
          *(void *)&uint8_t buf[4] = v34;
          *(_WORD *)&uint8_t buf[12] = 2080;
          *(void *)&buf[14] = v35;
          uint64_t v20 = "Running m_metalHelpers->setupTextureBuffer(m_faceCropSurface, MTLTextureUsageShaderRead | MTLTextureUsag"
                "eShaderWrite | MTLTextureUsageRenderTarget, false, m_faceCrop) failed with %s, returning %s";
LABEL_29:
          _os_log_error_impl(&dword_1D0DBD000, v17, OS_LOG_TYPE_ERROR, v20, buf, 0x16u);
LABEL_40:

          goto LABEL_41;
        }
        [*(id *)(a1 + 712) setLabel:@"faceCrop.texture"];
        if (!*(unsigned char *)(*(void *)(a1 + 296) + 257))
        {
          uint64_t v16 = 0;
          goto LABEL_41;
        }
        sub_1D0DE8604(buf, "camera_offset");
        uint64_t v37 = sub_1D0DE1C1C(v2, (uint64_t)buf);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        if (v37)
        {
          uint64_t v38 = [objc_alloc(MEMORY[0x1E4F2EF78]) initWithProperties:v37[5]];
          uint64_t v16 = 0;
          id v17 = *(NSObject **)(a1 + 672);
          *(void *)(a1 + 672) = v38;
          goto LABEL_40;
        }
        id v17 = sub_1D0DF4E04();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)int buf = 0;
          uint64_t v39 = "Assertion failed: it != inputSurfaceProps.end()";
LABEL_51:
          uint64_t v16 = 2;
          _os_log_error_impl(&dword_1D0DBD000, v17, OS_LOG_TYPE_ERROR, v39, buf, 2u);
          goto LABEL_40;
        }
      }
      else
      {
        id v17 = sub_1D0DF4E04();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)int buf = 0;
          uint64_t v39 = "Assertion failed: m_faceCropSurface";
          goto LABEL_51;
        }
      }
      uint64_t v16 = 2;
      goto LABEL_40;
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v21 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v21, OS_LOG_TYPE_ERROR, "Assertion failed: [leftRayfieldProps isEqualToDictionary:rightRayfieldProps]", buf, 2u);
    }
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v21 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v21, OS_LOG_TYPE_ERROR, "Assertion failed: [leftCropProps isEqualToDictionary:rightCropProps]", buf, 2u);
    }
  }

  uint64_t v16 = 2;
LABEL_41:

  return v16;
}

void sub_1D0DE5E50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DE5EF0(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 296);
  char v18 = 9;
  strcpy((char *)buf, "landmarks");
  uint64_t v3 = sub_1D0DE1C1C((void *)(v2 + 200), (uint64_t)buf);
  if (!v3) {
    abort();
  }
  if (v3[8] == 24)
  {
    id v4 = (void *)(v2 + 120);
    char v18 = 21;
    strcpy((char *)buf, "left_eye_warp_field_X");
    id v5 = sub_1D0DE1C1C((void *)(v2 + 120), (uint64_t)buf);
    if (!v5) {
      abort();
    }
    uint64_t v6 = v5;
    char v18 = 21;
    strcpy((char *)buf, "left_eye_warp_field_Y");
    id v7 = sub_1D0DE1C1C(v4, (uint64_t)buf);
    if (!v7) {
      abort();
    }
    uint64_t v8 = v7;
    strcpy((char *)buf, "right_eye_warp_field_X");
    char v18 = 22;
    uint64_t v9 = sub_1D0DE1C1C(v4, (uint64_t)buf);
    if (!v9) {
      abort();
    }
    id v10 = v9;
    strcpy((char *)buf, "right_eye_warp_field_Y");
    char v18 = 22;
    uint64_t v11 = sub_1D0DE1C1C(v4, (uint64_t)buf);
    if (!v11) {
      abort();
    }
    uint64_t v12 = v11;
    if ([(id)v6[5] isEqualToDictionary:v8[5]])
    {
      if ([(id)v6[5] isEqualToDictionary:v10[5]])
      {
        if ([(id)v6[5] isEqualToDictionary:v12[5]])
        {
          [*(id *)(a1 + 184) commandBuffer];
          objc_claimAutoreleasedReturnValue();
          operator new();
        }
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EA6437C8))
        {
          qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
          __cxa_guard_release(&qword_1EA6437C8);
        }
        id v13 = (id)qword_1EA6437C0;
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
LABEL_23:
          uint64_t v14 = 2;
          goto LABEL_24;
        }
        *(_WORD *)int buf = 0;
        unsigned int v15 = "Assertion failed: [leftWarpSurfacePropsX isEqualToDictionary:rightWarpSurfacePropsY]";
      }
      else
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EA6437C8))
        {
          qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
          __cxa_guard_release(&qword_1EA6437C8);
        }
        id v13 = (id)qword_1EA6437C0;
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          goto LABEL_23;
        }
        *(_WORD *)int buf = 0;
        unsigned int v15 = "Assertion failed: [leftWarpSurfacePropsX isEqualToDictionary:rightWarpSurfacePropsX]";
      }
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      id v13 = (id)qword_1EA6437C0;
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      *(_WORD *)int buf = 0;
      unsigned int v15 = "Assertion failed: [leftWarpSurfacePropsX isEqualToDictionary:leftWarpSurfacePropsY]";
    }
    uint64_t v14 = 2;
    _os_log_error_impl(&dword_1D0DBD000, v13, OS_LOG_TYPE_ERROR, v15, buf, 2u);
    goto LABEL_24;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  id v13 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    _os_log_error_impl(&dword_1D0DBD000, v13, OS_LOG_TYPE_ERROR, "Precondition violated: outputDims.at(ViewpointCorrectionRegressor::kOutputNameLandmarks)[2] == 2 * TrackedFace::kLandmarkCount", buf, 2u);
  }
  uint64_t v14 = 1;
LABEL_24:

  return v14;
}

void sub_1D0DE7730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DE783C(uint64_t a1)
{
  v50[9] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void **)(a1 + 312);
  if (v2)
  {
    v49[0] = *MEMORY[0x1E4F2EF70];
    uint64_t v3 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(v2, "width"));
    v50[0] = v3;
    v49[1] = *MEMORY[0x1E4F2EF28];
    id v4 = NSNumber;
    uint64_t v5 = [*(id *)(a1 + 312) height];
    if (v5 >= 0) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = v5 + 1;
    }
    id v7 = [v4 numberWithInteger:v6 >> 1];
    v50[1] = v7;
    v49[2] = *MEMORY[0x1E4F2EF10];
    uint64_t v8 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(*(id *)(a1 + 312), "bytesPerElement"));
    v50[2] = v8;
    v49[3] = *MEMORY[0x1E4F2EF18];
    uint64_t v9 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(*(id *)(a1 + 312), "bytesPerRow"));
    v50[3] = v9;
    v49[4] = *MEMORY[0x1E4F2EF30];
    id v10 = objc_msgSend(NSNumber, "numberWithUnsignedInt:", objc_msgSend(*(id *)(a1 + 312), "pixelFormat"));
    v50[4] = v10;
    uint64_t v11 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v50 forKeys:v49 count:5];

    uint64_t v12 = [objc_alloc(MEMORY[0x1E4F2EF78]) initWithProperties:v11];
    id v13 = *(void **)(a1 + 704);
    *(void *)(a1 + 704) = v12;

    uint64_t v14 = *(void **)(a1 + 704);
    if (v14)
    {
      unsigned int v15 = (id *)(a1 + 720);
      unsigned int v16 = sub_1D0DF3804(*(id **)(a1 + 240), v14, 1, 0, (id *)(a1 + 720));
      unsigned int v17 = v16 - 1;
      if (v16 == 1) {
        uint64_t v18 = 2;
      }
      else {
        uint64_t v18 = v16;
      }
      if (v16)
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EA6437C8))
        {
          qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
          __cxa_guard_release(&qword_1EA6437C8);
        }
        uint64_t v19 = (id)qword_1EA6437C0;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          unint64_t v40 = off_1E689A510[v17];
          unint64_t v41 = off_1E689A510[(v18 - 1)];
          *(_DWORD *)int buf = 136315394;
          uint64_t v46 = v40;
          __int16 v47 = 2080;
          uint64_t v48 = v41;
          _os_log_error_impl(&dword_1D0DBD000, v19, OS_LOG_TYPE_ERROR, "Running m_metalHelpers->setupTextureBuffer(m_faceCropNoiseSurface, MTLTextureUsageShaderRead, false, m_faceCropNoise) failed with %s, returning %s", buf, 0x16u);
        }
      }
      else
      {
        [*v15 setLabel:@"faceCropNoise.texture"];
        unsigned int v21 = 42;
        *(_DWORD *)int buf = 42;
        for (uint64_t i = 1; i != 624; ++i)
        {
          unsigned int v21 = i + 1812433253 * (v21 ^ (v21 >> 30));
          *(_DWORD *)&buf[4 * i] = v21;
        }
        if ([*v15 iosurface])
        {
          unsigned int v23 = [*v15 iosurface];
          [v23 lockWithOptions:0 seed:0];
          id v24 = v23;
          unint64_t v25 = (_WORD *)[v24 baseAddress];
          v50[5] = &unk_1F26F4988;
          v50[6] = v24;
          uint64_t v44 = v43;
          uint64_t v42 = v25;
          v43[0] = &unk_1F26F4988;
          v43[1] = v24;
        }
        else
        {
          unint64_t v25 = 0;
          uint64_t v44 = v43;
          uint64_t v42 = 0;
          v43[0] = &unk_1F26F49D0;
        }
        uint64_t v26 = [*(id *)(a1 + 704) height];
        unint64_t v27 = [*(id *)(a1 + 704) bytesPerRow] * v26;
        if (v27 >= 2)
        {
          uint64_t v28 = 0;
          uint64_t v29 = 2 * (v27 >> 1);
          do
          {
            uint64_t v30 = 4 * v28;
            unint64_t v31 = v28 + 397;
            if (v28 == 623) {
              uint64_t v28 = 0;
            }
            else {
              ++v28;
            }
            unsigned int v32 = *(_DWORD *)&buf[4 * (v31 % 0x270)] ^ ((*(_DWORD *)&buf[4 * v28] & 0x7FFFFFFE | *(_DWORD *)&buf[v30] & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)&buf[4 * v28] << 31) >> 31) & 0x9908B0DF;
            unsigned int v33 = ((v32 ^ (v32 >> 11)) << 7) & 0x9D2C5680 ^ v32 ^ (v32 >> 11);
            *(_DWORD *)&buf[v30] = v32;
            _S2 = (float)((float)((float)((v33 << 15) & 0xEFC60000 ^ v33 ^ (((v33 << 15) & 0xEFC60000 ^ v33) >> 18))
                                * 2.3283e-10)
                        * 2.0)
                + -1.0;
            __asm { FCVT            H2, S2 }
            *v25++ = LOWORD(_S2);
            v29 -= 2;
          }
          while (v29);
        }
        sub_1D0DE8CF0((uint64_t *)&v42);
        uint64_t v18 = 0;
      }
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      uint64_t v20 = (id)qword_1EA6437C0;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int buf = 0;
        _os_log_error_impl(&dword_1D0DBD000, v20, OS_LOG_TYPE_ERROR, "Assertion failed: m_faceCropNoiseSurface", buf, 2u);
      }

      uint64_t v18 = 2;
    }
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v11 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v11, OS_LOG_TYPE_ERROR, "Precondition violated: m_faceCropSurface", buf, 2u);
    }
    uint64_t v18 = 1;
  }

  return v18;
}

void sub_1D0DE7E3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D0DE7EC8()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1D0DE85AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_1D0DE2CAC((id **)va);
  _Unwind_Resume(a1);
}

void *sub_1D0DE8604(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

unsigned __int8 *sub_1D0DE86B4(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(char *)(a2 + 23);
  if (v6 >= 0) {
    uint64_t v7 = (uint64_t *)a2;
  }
  else {
    uint64_t v7 = *(uint64_t **)a2;
  }
  if (v6 >= 0) {
    unint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v8 = *(void *)(a2 + 8);
  }
  unint64_t v9 = sub_1D0DE1DF8(v7, v8);
  unint64_t v10 = v9;
  unint64_t v11 = a1[1];
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v3 = v9;
      if (v9 >= v11) {
        unint64_t v3 = v9 % v11;
      }
    }
    else
    {
      unint64_t v3 = (v11 - 1) & v9;
    }
    id v13 = *(void ***)(*a1 + 8 * v3);
    if (v13)
    {
      uint64_t v14 = (unsigned __int8 *)*v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v19 = *((void *)v14 + 1);
            if (v19 == v10)
            {
              uint64_t v20 = v14[39];
              if ((v20 & 0x80u) == 0) {
                uint64_t v21 = v14[39];
              }
              else {
                uint64_t v21 = *((void *)v14 + 3);
              }
              if (v21 == v8)
              {
                if ((v20 & 0x80) != 0)
                {
                  if (!memcmp(*((const void **)v14 + 2), v7, *((void *)v14 + 3))) {
                    return v14;
                  }
                }
                else
                {
                  if (!v14[39]) {
                    return v14;
                  }
                  uint64_t v22 = 0;
                  while (v14[v22 + 16] == *((unsigned __int8 *)v7 + v22))
                  {
                    if (v20 == ++v22) {
                      return v14;
                    }
                  }
                }
              }
            }
            else if ((v19 & (v11 - 1)) != v3)
            {
              goto LABEL_49;
            }
            uint64_t v14 = *(unsigned __int8 **)v14;
            if (!v14) {
              goto LABEL_49;
            }
          }
        }
        do
        {
          unint64_t v15 = *((void *)v14 + 1);
          if (v15 == v10)
          {
            uint64_t v16 = v14[39];
            if ((v16 & 0x80u) == 0) {
              uint64_t v17 = v14[39];
            }
            else {
              uint64_t v17 = *((void *)v14 + 3);
            }
            if (v17 == v8)
            {
              if ((v16 & 0x80) != 0)
              {
                if (!memcmp(*((const void **)v14 + 2), v7, *((void *)v14 + 3))) {
                  return v14;
                }
              }
              else
              {
                if (!v14[39]) {
                  return v14;
                }
                uint64_t v18 = 0;
                while (v14[v18 + 16] == *((unsigned __int8 *)v7 + v18))
                {
                  if (v16 == ++v18) {
                    return v14;
                  }
                }
              }
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v3) {
              break;
            }
          }
          uint64_t v14 = *(unsigned __int8 **)v14;
        }
        while (v14);
      }
    }
  }
LABEL_49:
  unsigned int v23 = a1 + 2;
  uint64_t v14 = (unsigned __int8 *)operator new(0x30uLL);
  *(void *)uint64_t v14 = 0;
  *((void *)v14 + 1) = v10;
  *((_OWORD *)v14 + 1) = *(_OWORD *)a3;
  uint64_t v24 = *(void *)(a3 + 16);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *((void *)v14 + 4) = v24;
  *((void *)v14 + 5) = 0;
  float v25 = (float)(unint64_t)(a1[3] + 1);
  float v26 = *((float *)a1 + 8);
  if (!v11 || (float)(v26 * (float)v11) < v25)
  {
    BOOL v27 = 1;
    if (v11 >= 3) {
      BOOL v27 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v28 = v27 | (2 * v11);
    unint64_t v29 = vcvtps_u32_f32(v25 / v26);
    if (v28 <= v29) {
      size_t prime = v29;
    }
    else {
      size_t prime = v28;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v11 = a1[1];
    if (prime <= v11)
    {
      if (prime >= v11) {
        goto LABEL_86;
      }
      unint64_t v41 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v11 < 3 || (uint8x8_t v42 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v42.i16[0] = vaddlv_u8(v42), v42.u32[0] > 1uLL))
      {
        unint64_t v41 = std::__next_prime(v41);
      }
      else
      {
        uint64_t v43 = 1 << -(char)__clz(v41 - 1);
        if (v41 >= 2) {
          unint64_t v41 = v43;
        }
      }
      if (prime <= v41) {
        size_t prime = v41;
      }
      if (prime >= v11)
      {
        unint64_t v11 = a1[1];
LABEL_86:
        if ((v11 & (v11 - 1)) != 0)
        {
          if (v10 >= v11) {
            unint64_t v3 = v10 % v11;
          }
          else {
            unint64_t v3 = v10;
          }
        }
        else
        {
          unint64_t v3 = (v11 - 1) & v10;
        }
        goto LABEL_99;
      }
      if (!prime)
      {
        int v51 = (void *)*a1;
        *a1 = 0;
        if (v51) {
          operator delete(v51);
        }
        unint64_t v11 = 0;
        a1[1] = 0;
        goto LABEL_86;
      }
    }
    if (prime >> 61) {
      sub_1D0DE8CE0();
    }
    unint64_t v31 = operator new(8 * prime);
    unsigned int v32 = (void *)*a1;
    *a1 = (uint64_t)v31;
    if (v32) {
      operator delete(v32);
    }
    uint64_t v33 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v33++) = 0;
    while (prime != v33);
    uint64_t v34 = (void *)*v23;
    if (!*v23)
    {
LABEL_85:
      unint64_t v11 = prime;
      goto LABEL_86;
    }
    size_t v35 = v34[1];
    size_t v36 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v37 = v35 & v36;
      *(void *)(*a1 + 8 * v37) = v23;
      for (uint64_t i = (void *)*v34; *v34; uint64_t i = (void *)*v34)
      {
        size_t v39 = i[1] & v36;
        if (v39 == v37)
        {
          uint64_t v34 = i;
        }
        else if (*(void *)(*a1 + 8 * v39))
        {
          void *v34 = *i;
          uint64_t v40 = 8 * v39;
          *uint64_t i = **(void **)(*a1 + v40);
          **(void **)(*a1 + v40) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v39) = v34;
          uint64_t v34 = i;
          size_t v37 = v39;
        }
      }
      goto LABEL_85;
    }
    if (v35 >= prime) {
      v35 %= prime;
    }
    *(void *)(*a1 + 8 * v35) = v23;
    uint64_t v44 = (void *)*v34;
    if (!*v34) {
      goto LABEL_85;
    }
    while (1)
    {
      size_t v46 = v44[1];
      if (v46 >= prime) {
        v46 %= prime;
      }
      if (v46 != v35)
      {
        if (!*(void *)(*a1 + 8 * v46))
        {
          *(void *)(*a1 + 8 * v46) = v34;
          goto LABEL_90;
        }
        void *v34 = *v44;
        uint64_t v45 = 8 * v46;
        *uint64_t v44 = **(void **)(*a1 + v45);
        **(void **)(*a1 + v45) = v44;
        uint64_t v44 = v34;
      }
      size_t v46 = v35;
LABEL_90:
      uint64_t v34 = v44;
      uint64_t v44 = (void *)*v44;
      size_t v35 = v46;
      if (!v44) {
        goto LABEL_85;
      }
    }
  }
LABEL_99:
  uint64_t v47 = *a1;
  uint64_t v48 = *(void **)(*a1 + 8 * v3);
  if (v48)
  {
    *(void *)uint64_t v14 = *v48;
LABEL_107:
    *uint64_t v48 = v14;
    goto LABEL_108;
  }
  *(void *)uint64_t v14 = *v23;
  void *v23 = v14;
  *(void *)(v47 + 8 * v3) = v23;
  if (*(void *)v14)
  {
    unint64_t v49 = *(void *)(*(void *)v14 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v49 >= v11) {
        v49 %= v11;
      }
    }
    else
    {
      v49 &= v11 - 1;
    }
    uint64_t v48 = (void *)(*a1 + 8 * v49);
    goto LABEL_107;
  }
LABEL_108:
  ++a1[3];
  return v14;
}

void sub_1D0DE8C00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1D0DE8C88((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DE8C14(uint64_t a1)
{
  uint64_t v2 = *(id **)(a1 + 16);
  if (v2)
  {
    do
    {
      size_t v5 = (id *)*v2;

      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  unint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

uint64_t *sub_1D0DE8C88(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {

      if (*(char *)(v2 + 39) < 0) {
        operator delete(*(void **)(v2 + 16));
      }
    }
    operator delete((void *)v2);
  }
  return a1;
}

void sub_1D0DE8CE0()
{
}

uint64_t sub_1D0DE8CF0(uint64_t *a1)
{
  if (*a1)
  {
    uint64_t v5 = *a1;
    uint64_t v2 = a1[4];
    if (!v2)
    {
      uint64_t result = sub_1D0DD8808();
      __break(1u);
      return result;
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v5);
    *a1 = 0;
  }
  unint64_t v3 = (uint64_t *)a1[4];
  if (v3 == a1 + 1)
  {
    (*(void (**)(uint64_t *))(a1[1] + 32))(a1 + 1);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t *))(*v3 + 40))(v3);
  }
  return (uint64_t)a1;
}

void sub_1D0DE8DC8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 32);
  if (v3 == v1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(v1 + 8) + 32))(v1 + 8);
    _Unwind_Resume(exception_object);
  }
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1D0DE8E48(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26F49D0;
}

void *sub_1D0DE8E68()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F26F49D0;
  return result;
}

void sub_1D0DE8EA0()
{
}

uint64_t sub_1D0DE8EB8(uint64_t a1)
{
  return [*(id *)(a1 + 8) unlockWithOptions:0 seed:0];
}

void sub_1D0DE8EC8(id *a1)
{
  operator delete(a1);
}

void sub_1D0DE8F04(uint64_t a1)
{
}

id sub_1D0DE8F0C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26F4988;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void *sub_1D0DE8F54(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = &unk_1F26F4988;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

void sub_1D0DE8FAC(uint64_t a1)
{
  JUMPOUT(0x1D25F16B0);
}

uint64_t sub_1D0DE8FF8(uint64_t a1)
{
  return a1;
}

uint64_t sub_1D0DE9024(uint64_t a1, void *a2, uint64_t a3)
{
  v30[3] = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  int v6 = *(void **)a1;
  uint64_t v7 = *(void *)(a1 + 8);
  strcpy((char *)v30, "left_eye_face_location");
  HIBYTE(v30[2]) = 22;
  unint64_t v8 = sub_1D0DE1C1C(v6, (uint64_t)v30);
  if (!v8) {
    abort();
  }
  uint64_t v9 = [objc_alloc(MEMORY[0x1E4F2EF78]) initWithProperties:v8[5]];
  unint64_t v10 = *(void **)(a3 + 168);
  *(void *)(a3 + 168) = v9;

  if (!*(void *)(a3 + 168))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    unsigned int v23 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    LOWORD(v30[0]) = 0;
    float v26 = "Assertion failed: data.rayfieldSurface";
    goto LABEL_25;
  }
  unint64_t v11 = *(void **)a1;
  uint8x8_t v12 = (char *)operator new(0x20uLL);
  v30[0] = v12;
  *(_OWORD *)&v30[1] = xmmword_1D0E81500;
  strcpy(v12, "left_eye_input_images_low_res");
  id v13 = sub_1D0DE1C1C(v11, (uint64_t)v30);
  if (!v13) {
    abort();
  }
  uint64_t v14 = v13;
  operator delete(v12);
  uint64_t v15 = [objc_alloc(MEMORY[0x1E4F2EF78]) initWithProperties:v14[5]];
  uint64_t v16 = *(void **)(a3 + 152);
  *(void *)(a3 + 152) = v15;

  uint64_t v17 = *(void **)(a3 + 152);
  if (!v17)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    unsigned int v23 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    LOWORD(v30[0]) = 0;
    float v26 = "Assertion failed: data.cropSurface";
    goto LABEL_25;
  }
  uint64_t v18 = [v17 width];
  if (v18 != [*(id *)(a3 + 152) height])
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    unsigned int v23 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
LABEL_21:
      uint64_t v22 = 2;
      goto LABEL_22;
    }
    LOWORD(v30[0]) = 0;
    float v26 = "Currently we only support square crops.";
LABEL_25:
    uint64_t v22 = 2;
    BOOL v27 = v23;
    uint32_t v28 = 2;
    goto LABEL_26;
  }
  uint64_t v19 = (id *)(a3 + 160);
  unsigned int v20 = sub_1D0DF3804(*(id **)(v7 + 240), *(void **)(a3 + 152), 4, 1, (id *)(a3 + 160));
  unsigned int v21 = v20 - 1;
  if (v20 == 1) {
    uint64_t v22 = 2;
  }
  else {
    uint64_t v22 = v20;
  }
  if (v20)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    unsigned int v23 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      uint64_t v24 = off_1E689A510[v21];
      float v25 = off_1E689A510[(v22 - 1)];
      LODWORD(v30[0]) = 136315394;
      *(void *)((char *)v30 + 4) = v24;
      WORD2(v30[1]) = 2080;
      *(void *)((char *)&v30[1] + 6) = v25;
      float v26 = "Running m_metalHelpers->setupTextureBuffer(data.cropSurface, MTLTextureUsageRenderTarget, true, data.crop) f"
            "ailed with %s, returning %s";
      BOOL v27 = v23;
      uint32_t v28 = 22;
LABEL_26:
      _os_log_error_impl(&dword_1D0DBD000, v27, OS_LOG_TYPE_ERROR, v26, (uint8_t *)v30, v28);
    }
  }
  else
  {
    unsigned int v23 = [v5 stringByAppendingPathExtension:@"luma"];
    [*v19 setLabel:v23];
    uint64_t v22 = 0;
  }
LABEL_22:

  return v22;
}

void sub_1D0DE9450(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DE9490()
{
  uint64_t v0 = (void *)MGGetStringAnswer();
  uint64_t v1 = [v0 isEqualToString:@"iPhone"];

  return v1;
}

void sub_1D0DE94D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *sub_1D0DE94E4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = sub_1D0DD8954(v2);
    MEMORY[0x1D25F16B0](v3, 0x10A0C409CFA2790);
  }
  return a1;
}

uint64_t sub_1D0DE952C(uint64_t a1)
{
  *(void *)a1 = &unk_1F26F45E0;
  if (*(void *)(a1 + 152))
  {
    uint64_t v2 = (uint64_t *)(a1 + 136);
    uint64_t v3 = *(void *)(a1 + 136);
    size_t v4 = *(uint64_t **)(a1 + 144);
    uint64_t v5 = *v4;
    *(void *)(v5 + 8) = *(void *)(v3 + 8);
    **(void **)(v3 + 8) = v5;
    *(void *)(a1 + 152) = 0;
    if (v4 != (uint64_t *)(a1 + 136))
    {
      do
      {
        int v6 = (uint64_t *)v4[1];
        uint64_t v7 = (std::__shared_weak_count *)v4[3];
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        operator delete(v4);
        size_t v4 = v6;
      }
      while (v6 != v2);
    }
  }
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 80));
  std::mutex::~mutex((std::mutex *)(a1 + 16));
  return a1;
}

uint64_t sub_1D0DE9624(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v3 = *(unsigned int *)(a1 + 152);
  std::mutex::unlock(v2);
  return v3;
}

void sub_1D0DE9660(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  if (*(void *)(a1 + 152))
  {
    uint64_t v3 = (uint64_t *)(a1 + 136);
    uint64_t v4 = *(void *)(a1 + 136);
    uint64_t v5 = *(uint64_t **)(a1 + 144);
    uint64_t v6 = *v5;
    *(void *)(v6 + 8) = *(void *)(v4 + 8);
    **(void **)(v4 + 8) = v6;
    *(void *)(a1 + 152) = 0;
    if (v5 != (uint64_t *)(a1 + 136))
    {
      do
      {
        uint64_t v7 = (uint64_t *)v5[1];
        unint64_t v8 = (std::__shared_weak_count *)v5[3];
        if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
        operator delete(v5);
        uint64_t v5 = v7;
      }
      while (v7 != v3);
    }
  }
  std::mutex::unlock(v2);
}

BOOL sub_1D0DE9748(uint64_t a1, void *a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  int v5 = *(unsigned __int8 *)(a1 + 128);
  if (*(unsigned char *)(a1 + 128))
  {
    std::mutex::unlock(v4);
  }
  else
  {
    uint64_t v6 = operator new(0x20uLL);
    uint64_t v7 = a2[1];
    uint64_t v6[2] = *a2;
    v6[3] = v7;
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = *(void *)(a1 + 136);
    void *v6 = v8;
    v6[1] = a1 + 136;
    *(void *)(v8 + 8) = v6;
    *(void *)(a1 + 136) = v6;
    uint64_t v9 = *(void *)(a1 + 152) + 1;
    *(void *)(a1 + 152) = v9;
    int v10 = *(_DWORD *)(a1 + 8);
    if (v10 < (int)v9 && (v10 & 0x80000000) == 0)
    {
      do
      {
        unint64_t v11 = *(uint64_t **)(a1 + 144);
        uint64_t v12 = *v11;
        *(void *)(v12 + 8) = v11[1];
        *(void *)v11[1] = v12;
        *(void *)(a1 + 152) = v9 - 1;
        id v13 = (std::__shared_weak_count *)v11[3];
        if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
        operator delete(v11);
        uint64_t v9 = *(void *)(a1 + 152);
        int v14 = *(_DWORD *)(a1 + 8);
      }
      while (v14 < (int)v9 && (v14 & 0x80000000) == 0);
    }
    std::mutex::unlock(v4);
    std::condition_variable::notify_one((std::condition_variable *)(a1 + 80));
  }
  return v5 == 0;
}

void sub_1D0DE9884(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1D0DE9898(uint64_t a1, void *a2, int a3, uint64_t a4)
{
  v20.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 16);
  v20.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 16));
  BOOL v8 = 0;
  uint64_t v9 = *(void *)(a1 + 152);
  if (a3 < 1 || v9) {
    goto LABEL_18;
  }
  BOOL v8 = a4 != 0;
  if (a4)
  {
    if (!*(unsigned char *)(a4 + 8)) {
      goto LABEL_37;
    }
    std::mutex::unlock(*(std::mutex **)a4);
    *(unsigned char *)(a4 + 8) = 0;
  }
  std::chrono::steady_clock::now();
  v10.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  if (!v10.__d_.__rep_)
  {
    uint64_t v11 = 0;
    goto LABEL_14;
  }
  if (v10.__d_.__rep_ < 1)
  {
    if ((unint64_t)v10.__d_.__rep_ < 0xFFDF3B645A1CAC09)
    {
      uint64_t v11 = 0x8000000000000000;
      goto LABEL_14;
    }
LABEL_13:
    uint64_t v11 = 1000 * v10.__d_.__rep_;
    goto LABEL_14;
  }
  if ((unint64_t)v10.__d_.__rep_ <= 0x20C49BA5E353F7) {
    goto LABEL_13;
  }
  uint64_t v11 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_14:
  if (v11 <= ((1000000 * a3) ^ 0x7FFFFFFFFFFFFFFFLL)) {
    v12.__d_.__rep_ = v11 + 1000000 * a3;
  }
  else {
    v12.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
  }
  std::condition_variable::__do_timed_wait((std::condition_variable *)(a1 + 80), &v20, v12);
  std::chrono::steady_clock::now();
  uint64_t v9 = *(void *)(a1 + 152);
LABEL_18:
  if (v9)
  {
    uint64_t v13 = *(void *)(a1 + 144);
    uint64_t v15 = *(void *)(v13 + 16);
    uint64_t v14 = *(void *)(v13 + 24);
    if (v14) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v16 = (std::__shared_weak_count *)a2[1];
    *a2 = v15;
    a2[1] = v14;
    if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
    uint64_t v17 = *(uint64_t **)(a1 + 144);
    uint64_t v18 = *v17;
    *(void *)(v18 + 8) = v17[1];
    *(void *)v17[1] = v18;
    --*(void *)(a1 + 152);
    uint64_t v19 = (std::__shared_weak_count *)v17[3];
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    operator delete(v17);
  }
  if (v20.__owns_) {
    std::mutex::unlock(v20.__m_);
  }
  if (v8)
  {
    if (*(void *)a4)
    {
      if (!*(unsigned char *)(a4 + 8))
      {
        std::mutex::lock(*(std::mutex **)a4);
        *(unsigned char *)(a4 + 8) = 1;
        return;
      }
    }
    else
    {
      std::__throw_system_error(1, "unique_lock::lock: references null mutex");
    }
    std::__throw_system_error(11, "unique_lock::lock: already locked");
LABEL_37:
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    __break(1u);
  }
}

void sub_1D0DE9B14(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1D0DE9B28(uint64_t a1@<X0>, void *a2@<X8>)
{
  v9.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 16);
  v9.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 16));
  for (uint64_t i = *(void *)(a1 + 152); !i; uint64_t i = *(void *)(a1 + 152))
    std::condition_variable::wait((std::condition_variable *)(a1 + 80), &v9);
  int v5 = *(uint64_t **)(a1 + 144);
  uint64_t v6 = v5[3];
  *a2 = v5[2];
  a2[1] = v6;
  if (v6)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    int v5 = *(uint64_t **)(a1 + 144);
    uint64_t i = *(void *)(a1 + 152);
    uint64_t v7 = (std::__shared_weak_count *)v5[3];
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *v5;
  *(void *)(v8 + 8) = v5[1];
  *(void *)v5[1] = v8;
  *(void *)(a1 + 152) = i - 1;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  operator delete(v5);
  if (v9.__owns_) {
    std::mutex::unlock(v9.__m_);
  }
}

void sub_1D0DE9C30(uint64_t a1)
{
  *(void *)a1 = &unk_1F26F45E0;
  if (*(void *)(a1 + 152))
  {
    uint64_t v2 = (uint64_t *)(a1 + 136);
    uint64_t v3 = *(void *)(a1 + 136);
    uint64_t v4 = *(uint64_t **)(a1 + 144);
    uint64_t v5 = *v4;
    *(void *)(v5 + 8) = *(void *)(v3 + 8);
    **(void **)(v3 + 8) = v5;
    *(void *)(a1 + 152) = 0;
    if (v4 != (uint64_t *)(a1 + 136))
    {
      do
      {
        uint64_t v6 = (uint64_t *)v4[1];
        uint64_t v7 = (std::__shared_weak_count *)v4[3];
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        operator delete(v4);
        uint64_t v4 = v6;
      }
      while (v6 != v2);
    }
  }
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 80));
  std::mutex::~mutex((std::mutex *)(a1 + 16));
  JUMPOUT(0x1D25F16B0);
}

uint64_t *sub_1D0DE9D48(uint64_t *a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 3);
  std::mutex::lock((std::mutex *)(a1 + 3));
  *((unsigned char *)a1 + 136) = 1;
  std::mutex::unlock(v2);
  uint64_t v3 = *a1;
  uint64_t v4 = **(void **)(*a1 + 8);
  std::mutex::lock((std::mutex *)(v4 + 16));
  *(unsigned char *)(v4 + 128) = 1;
  std::mutex::unlock((std::mutex *)(v4 + 16));
  unint64_t v5 = *(void *)(*(void *)(v3 + 8) + 24) - *(void *)(*(void *)(v3 + 8) + 16);
  if ((int)(v5 >> 4) >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = v5 & 0xFFFFFFFF0;
    do
    {
      sub_1D0E78DA0(*(void *)(*(void *)(*(void *)(v3 + 8) + 16) + v6), 1);
      v6 += 16;
    }
    while (v7 != v6);
  }
  uint64_t v8 = a1[21];
  a1[21] = 0;
  if (v8)
  {
    uint64_t v9 = sub_1D0DD8954(v8);
    MEMORY[0x1D25F16B0](v9, 0x10A0C409CFA2790);
  }
  a1[1] = (uint64_t)&unk_1F26F45E0;
  if (a1[20])
  {
    uint64_t v10 = a1[18];
    uint64_t v11 = (uint64_t *)a1[19];
    uint64_t v12 = *v11;
    *(void *)(v12 + 8) = *(void *)(v10 + 8);
    **(void **)(v10 + 8) = v12;
    a1[20] = 0;
    if (v11 != a1 + 18)
    {
      do
      {
        uint64_t v13 = (uint64_t *)v11[1];
        uint64_t v14 = (std::__shared_weak_count *)v11[3];
        if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
        operator delete(v11);
        uint64_t v11 = v13;
      }
      while (v13 != a1 + 18);
    }
  }
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 11));
  std::mutex::~mutex(v2);
  uint64_t v15 = *a1;
  *a1 = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  return a1;
}

void sub_1D0DE9F20(_Unwind_Exception *a1)
{
  uint64_t v4 = v1[21];
  v1[21] = 0;
  if (v4)
  {
    uint64_t v5 = sub_1D0DD8954(v4);
    MEMORY[0x1D25F16B0](v5, 0x10A0C409CFA2790);
  }
  v1[1] = (uint64_t)&unk_1F26F45E0;
  if (v1[20])
  {
    uint64_t v6 = v1[18];
    uint64_t v7 = (uint64_t *)v1[19];
    uint64_t v8 = *v7;
    *(void *)(v8 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v8;
    v1[20] = 0;
    if (v7 != v1 + 18)
    {
      do
      {
        uint64_t v10 = (uint64_t *)v7[1];
        uint64_t v11 = (std::__shared_weak_count *)v7[3];
        if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
        operator delete(v7);
        uint64_t v7 = v10;
      }
      while (v10 != v1 + 18);
    }
  }
  std::condition_variable::~condition_variable((std::condition_variable *)(v1 + 11));
  std::mutex::~mutex(v2);
  uint64_t v9 = *v1;
  *uint64_t v1 = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DEA044(void *a1)
{
  uint64_t v1 = a1[2];
  uint64_t v2 = (uint64_t (*)(void *))a1[1];
  uint64_t v3 = (void *)(a1[3] + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

__n128 sub_1D0DEA074(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F26F47D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1D0DEA0A4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F26F47D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_1D0DEA0F8()
{
}

void sub_1D0DEA110(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)MEMORY[0x1D25F1DA0]();
  unint64_t v29 = 0;
  uint64_t v30 = 0;
  sub_1D0DE9898(a1 + 8, &v29, 0, 0);
  if ((v3 & 1) == 0)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v12 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v37.value) = 0;
      _os_log_error_impl(&dword_1D0DBD000, v12, OS_LOG_TYPE_ERROR, "We call process once for each input item - so there should always be at least one item in the queue", (uint8_t *)&v37, 2u);
    }
    goto LABEL_11;
  }
  uint64_t v4 = v29;
  if (!v29)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v12 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v37.value) = 0;
      _os_log_error_impl(&dword_1D0DBD000, v12, OS_LOG_TYPE_ERROR, "The queue should not contain nullptr", (uint8_t *)&v37, 2u);
    }
LABEL_11:

    goto LABEL_36;
  }
  std::mutex::lock((std::mutex *)(a1 + 24));
  uint64_t v5 = *(unsigned int *)(a1 + 160);
  std::mutex::unlock((std::mutex *)(a1 + 24));
  kdebug_trace();
  CMTime time = *(CMTime *)((char *)v4 + 36);
  Float64 Seconds = CMTimeGetSeconds(&time);
  v27[0] = 0;
  v27[1] = 0;
  unsigned __int8 explicit = atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire);
  if (v5)
  {
    if ((explicit & 1) == 0 && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v8 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(v37.value) = 134217984;
      *(Float64 *)((char *)&v37.value + 4) = Seconds;
      _os_log_debug_impl(&dword_1D0DBD000, v8, OS_LOG_TYPE_DEBUG, "Dropping frame with timestamp %.4f", (uint8_t *)&v37, 0xCu);
    }

    kdebug_trace();
    uint64_t v9 = *(void *)(a1 + 168);
    uint64_t v10 = v29;
    memset(&v37, 0, sizeof(v37));
    HostTimeClocint k = CMClockGetHostTimeClock();
    CMClockGetTime(&v37, HostTimeClock);
    size_t v35 = 0;
    size_t v36 = 0;
    sub_1D0DDD038(&v32, v10, 7, 0, &v35);
    CMTime v34 = v37;
    sub_1D0DDD2B8(v9, (uint64_t)v10, 7, 0, &v34);
    *(_OWORD *)BOOL v27 = v32;
  }
  else
  {
    if ((explicit & 1) == 0 && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v13 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(v37.value) = 134217984;
      *(Float64 *)((char *)&v37.value + 4) = Seconds;
      _os_log_debug_impl(&dword_1D0DBD000, v13, OS_LOG_TYPE_DEBUG, "Processing frame with timestamp %.4f", (uint8_t *)&v37, 0xCu);
    }

    kdebug_trace();
    uint64_t v14 = *(void *)(a1 + 168);
    uint64_t v15 = v29;
    memset(&v37, 0, sizeof(v37));
    uint64_t v16 = CMClockGetHostTimeClock();
    CMClockGetTime(&v37, v16);
    unsigned __int8 v33 = 0;
    if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)(v15 + 2), @"ReturnDebugMetadata"))
    {
      cva::DictionaryHandler::item(&v34.value, (cva::DictionaryHandler *)(v15 + 2), @"ReturnDebugMetadata");
      cva::ItemHandler::getValue<BOOL>();
    }
    size_t v35 = 0;
    size_t v36 = 0;
    long long v32 = 0uLL;
    int v17 = sub_1D0DD8B08(v14, (uint64_t)v15, &v33, &v32);
    int v18 = v33;
    uint64_t v19 = (std::__shared_weak_count *)v36;
    v31[0] = v35;
    v31[1] = (cva::DictionaryHandler *)v36;
    if (v36) {
      atomic_fetch_add_explicit(v36 + 1, 1uLL, memory_order_relaxed);
    }
    sub_1D0DDD038(&v26, v15, v17, v18 != 0, v31);
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    CMTime v34 = v37;
    sub_1D0DDD2B8(v14, (uint64_t)v15, v17, v33, &v34);
    std::unique_lock<std::mutex> v20 = (std::__shared_weak_count *)v36;
    if (v36 && !atomic_fetch_add(v36 + 1, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
    *(_OWORD *)BOOL v27 = v26;
    uint64_t v10 = v29;
  }
  kdebug_trace();
  unsigned int v21 = (void (**)(void, void))MEMORY[0x1D25F1F10](v10[1]);
  uint64_t v22 = v30;
  unint64_t v29 = 0;
  uint64_t v30 = 0;
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t Dictionary = cva::DictionaryHandler::getDictionary(v27[0]);
  v21[2](v21, Dictionary);

  uint64_t v24 = (std::__shared_weak_count *)v27[1];
  if (v27[1] && !atomic_fetch_add((atomic_ullong *volatile)v27[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
LABEL_36:
  float v25 = v30;
  if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
}

void sub_1D0DEA874(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  std::__shared_weak_count::~__shared_weak_count(v25);
  operator delete(v27);
  kdebug_trace();
  sub_1D0DCA2C0((uint64_t)&a11);
  sub_1D0DCA2C0((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DEA954(uint64_t a1, uint64_t *a2)
{
  if (a2[3] == *(unsigned __int8 *)(a1 + 257) + 11)
  {
    uint64_t v4 = *(void **)(a1 + 16);
    if (v4)
    {
      while (sub_1D0DEABF4(*a2, a2[1], (uint64_t)(v4 + 2)))
      {
        sub_1D0DEADCC(a1, (uint64_t)(v4 + 2));
        sub_1D0DEB150();
        uint64_t v4 = (void *)*v4;
        if (!v4) {
          goto LABEL_5;
        }
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      uint64_t v8 = (id)qword_1EA6437C0;
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        goto LABEL_18;
      }
      __int16 v11 = 0;
      uint64_t v9 = (uint8_t *)&v11;
    }
    else
    {
LABEL_5:
      uint64_t v5 = *(void **)(a1 + 56);
      if (!v5)
      {
LABEL_8:
        uint64_t result = 0;
        *(unsigned char *)(a1 + 256) = 1;
        return result;
      }
      while (sub_1D0DEABF4(*a2, a2[1], (uint64_t)(v5 + 2)))
      {
        sub_1D0DEADCC(a1 + 40, (uint64_t)(v5 + 2));
        sub_1D0DEB150();
        uint64_t v5 = (void *)*v5;
        if (!v5) {
          goto LABEL_8;
        }
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0)
      {
        if (__cxa_guard_acquire(&qword_1EA6437C8))
        {
          qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
          __cxa_guard_release(&qword_1EA6437C8);
        }
      }
      uint64_t v8 = (id)qword_1EA6437C0;
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        goto LABEL_18;
      }
      __int16 v10 = 0;
      uint64_t v9 = (uint8_t *)&v10;
    }
    _os_log_error_impl(&dword_1D0DBD000, v8, OS_LOG_TYPE_ERROR, "Assertion failed: surfaceIt != surfaces.end()", v9, 2u);
LABEL_18:

    return 2;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  uint64_t v7 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    _os_log_error_impl(&dword_1D0DBD000, v7, OS_LOG_TYPE_ERROR, "Precondition violated: surfaces.size() == expectedSurfacesSize", buf, 2u);
  }

  return 1;
}

uint64_t *sub_1D0DEABF4(uint64_t a1, unint64_t a2, uint64_t a3)
{
  int v5 = *(char *)(a3 + 23);
  if (v5 >= 0) {
    uint64_t v6 = (uint64_t *)a3;
  }
  else {
    uint64_t v6 = *(uint64_t **)a3;
  }
  if (v5 >= 0) {
    unint64_t v7 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    unint64_t v7 = *(void *)(a3 + 8);
  }
  unint64_t v8 = sub_1D0DE1DF8(v6, v7);
  if (a2)
  {
    unint64_t v9 = v8;
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v11 = v8;
      if (v8 >= a2) {
        unint64_t v11 = v8 % a2;
      }
    }
    else
    {
      unint64_t v11 = (a2 - 1) & v8;
    }
    uint64_t v12 = *(uint64_t ***)(a1 + 8 * v11);
    if (v12)
    {
      uint64_t v13 = *v12;
      if (*v12)
      {
        if (v10.u32[0] < 2uLL)
        {
          unint64_t v14 = a2 - 1;
          while (1)
          {
            uint64_t v20 = v13[1];
            if (v20 == v9)
            {
              uint64_t v21 = *((unsigned __int8 *)v13 + 39);
              if ((v21 & 0x80u) == 0) {
                uint64_t v22 = *((unsigned __int8 *)v13 + 39);
              }
              else {
                uint64_t v22 = v13[3];
              }
              if (v22 == v7)
              {
                if ((v21 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v13[2], v6, v13[3])) {
                    return v13;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v13 + 39)) {
                    return v13;
                  }
                  uint64_t v23 = 0;
                  while (*((unsigned __int8 *)v13 + v23 + 16) == *((unsigned __int8 *)v6 + v23))
                  {
                    if (v21 == ++v23) {
                      return v13;
                    }
                  }
                }
              }
            }
            else if ((v20 & v14) != v11)
            {
              return 0;
            }
            uint64_t result = 0;
            uint64_t v13 = (uint64_t *)*v13;
            if (!v13) {
              return result;
            }
          }
        }
        while (1)
        {
          unint64_t v16 = v13[1];
          if (v16 == v9)
          {
            uint64_t v17 = *((unsigned __int8 *)v13 + 39);
            if ((v17 & 0x80u) == 0) {
              uint64_t v18 = *((unsigned __int8 *)v13 + 39);
            }
            else {
              uint64_t v18 = v13[3];
            }
            if (v18 == v7)
            {
              if ((v17 & 0x80) != 0)
              {
                if (!memcmp((const void *)v13[2], v6, v13[3])) {
                  return v13;
                }
              }
              else
              {
                if (!*((unsigned char *)v13 + 39)) {
                  return v13;
                }
                uint64_t v19 = 0;
                while (*((unsigned __int8 *)v13 + v19 + 16) == *((unsigned __int8 *)v6 + v19))
                {
                  if (v17 == ++v19) {
                    return v13;
                  }
                }
              }
            }
          }
          else
          {
            if (v16 >= a2) {
              v16 %= a2;
            }
            if (v16 != v11) {
              return 0;
            }
          }
          uint64_t result = 0;
          uint64_t v13 = (uint64_t *)*v13;
          if (!v13) {
            return result;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t sub_1D0DEADCC(uint64_t a1, uint64_t a2)
{
  int v5 = *(char *)(a2 + 23);
  uint64_t v6 = *(void **)a2;
  unint64_t v7 = *(void *)(a2 + 8);
  if (v5 >= 0) {
    unint64_t v8 = (uint64_t *)a2;
  }
  else {
    unint64_t v8 = *(uint64_t **)a2;
  }
  if (v5 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = sub_1D0DE1DF8(v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a1 + 8);
  __vImage_Buffer src = v6;
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v2 = v10;
      if (v10 >= v12) {
        unint64_t v2 = v10 % v12;
      }
    }
    else
    {
      unint64_t v2 = (v12 - 1) & v10;
    }
    unint64_t v14 = *(uint64_t **)(*(void *)a1 + 8 * v2);
    if (v14)
    {
      uint64_t v15 = *v14;
      if (*v14)
      {
        if (v13.u32[0] < 2uLL)
        {
          unint64_t v16 = v12 - 1;
          while (1)
          {
            uint64_t v21 = *(void *)(v15 + 8);
            if (v21 == v11)
            {
              uint64_t v22 = *(unsigned __int8 *)(v15 + 39);
              if ((v22 & 0x80u) == 0) {
                uint64_t v23 = *(unsigned __int8 *)(v15 + 39);
              }
              else {
                uint64_t v23 = *(void *)(v15 + 24);
              }
              if (v23 == v9)
              {
                if ((v22 & 0x80) != 0)
                {
                  unint64_t v37 = v16;
                  int v25 = memcmp(*(const void **)(v15 + 16), v8, *(void *)(v15 + 24));
                  unint64_t v16 = v37;
                  if (!v25) {
                    return v15 + 40;
                  }
                }
                else
                {
                  if (!*(unsigned char *)(v15 + 39)) {
                    return v15 + 40;
                  }
                  uint64_t v24 = 0;
                  while (*(unsigned __int8 *)(v15 + v24 + 16) == *((unsigned __int8 *)v8 + v24))
                  {
                    if (v22 == ++v24) {
                      return v15 + 40;
                    }
                  }
                }
              }
            }
            else if ((v21 & v16) != v2)
            {
              goto LABEL_49;
            }
            uint64_t v15 = *(void *)v15;
            if (!v15) {
              goto LABEL_49;
            }
          }
        }
        do
        {
          unint64_t v17 = *(void *)(v15 + 8);
          if (v17 == v11)
          {
            uint64_t v18 = *(unsigned __int8 *)(v15 + 39);
            if ((v18 & 0x80u) == 0) {
              uint64_t v19 = *(unsigned __int8 *)(v15 + 39);
            }
            else {
              uint64_t v19 = *(void *)(v15 + 24);
            }
            if (v19 == v9)
            {
              if ((v18 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)(v15 + 16), v8, *(void *)(v15 + 24))) {
                  return v15 + 40;
                }
              }
              else
              {
                if (!*(unsigned char *)(v15 + 39)) {
                  return v15 + 40;
                }
                uint64_t v20 = 0;
                while (*(unsigned __int8 *)(v15 + v20 + 16) == *((unsigned __int8 *)v8 + v20))
                {
                  if (v18 == ++v20) {
                    return v15 + 40;
                  }
                }
              }
            }
          }
          else
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
            if (v17 != v2) {
              break;
            }
          }
          uint64_t v15 = *(void *)v15;
        }
        while (v15);
      }
    }
  }
LABEL_49:
  long long v26 = operator new(0x30uLL);
  v39[0] = (uint64_t)v26;
  v39[1] = a1 + 16;
  char v40 = 0;
  BOOL v27 = v26 + 2;
  *long long v26 = 0;
  v26[1] = v11;
  if (v5 < 0)
  {
    sub_1D0DCB370(v27, __src, v7);
  }
  else
  {
    *(_OWORD *)BOOL v27 = *(_OWORD *)a2;
    void v26[4] = *(void *)(a2 + 16);
  }
  v26[5] = 0;
  char v40 = 1;
  float v28 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v29 = *(float *)(a1 + 32);
  if (!v12 || (float)(v29 * (float)v12) < v28)
  {
    BOOL v30 = 1;
    if (v12 >= 3) {
      BOOL v30 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v31 = v30 | (2 * v12);
    unint64_t v32 = vcvtps_u32_f32(v28 / v29);
    if (v31 <= v32) {
      size_t v33 = v32;
    }
    else {
      size_t v33 = v31;
    }
    sub_1D0DEB5B0(a1, v33);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v2 = v11 % v12;
      }
      else {
        unint64_t v2 = v11;
      }
    }
    else
    {
      unint64_t v2 = (v12 - 1) & v11;
    }
  }
  CMTime v34 = *(void **)(*(void *)a1 + 8 * v2);
  if (v34)
  {
    *(void *)v39[0] = *v34;
    void *v34 = v39[0];
  }
  else
  {
    *(void *)v39[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v39[0];
    *(void *)(*(void *)a1 + 8 * v2) = a1 + 16;
    if (*(void *)v39[0])
    {
      unint64_t v35 = *(void *)(*(void *)v39[0] + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v35 >= v12) {
          v35 %= v12;
        }
      }
      else
      {
        v35 &= v12 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v35) = v39[0];
    }
  }
  uint64_t v15 = v39[0];
  v39[0] = 0;
  ++*(void *)(a1 + 24);
  sub_1D0DEB4B4(v39);
  return v15 + 40;
}

void sub_1D0DEB138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1D0DEB4B4((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1D0DEB150()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  int v0 = e5rt_buffer_object_create_from_iosurface();
  if (v0)
  {
    snprintf(__str, 0x40uLL, "e5rt::EnsureSuccess failed with error code %d.", v0);
    int v1 = _os_crash();
    __break(1u);
    goto LABEL_5;
  }
  while (1)
  {
    int v1 = e5rt_io_port_bind_buffer_object();
    if (!v1) {
      break;
    }
LABEL_5:
    snprintf(__str, 0x40uLL, "e5rt::EnsureSuccess failed with error code %d.", v1);
    int v2 = _os_crash();
    __break(1u);
    int v3 = v2;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__str = 67109120;
      int v5 = v3;
      _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", (uint8_t *)__str, 8u);
    }
  }
}

void sub_1D0DEB2FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1D0DEB3EC((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t **sub_1D0DEB320(uint64_t **a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **a1;
  **a1 = (uint64_t)a1[1];
  if (v2)
  {
    int v3 = e5rt_buffer_object_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t *sub_1D0DEB3EC(uint64_t *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    int v3 = e5rt_buffer_object_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t *sub_1D0DEB4B4(uint64_t *a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      uint64_t v3 = *(void *)(v2 + 40);
      *(void *)(v2 + 40) = 0;
      if (v3)
      {
        int v4 = e5rt_io_port_release();
        if (v4)
        {
          int v6 = v4;
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 67109120;
            int v8 = v6;
            _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
          }
        }
      }
      if (*(char *)(v2 + 39) < 0) {
        operator delete(*(void **)(v2 + 16));
      }
    }
    operator delete((void *)v2);
  }
  return a1;
}

void sub_1D0DEB5B0(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v16 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v17 = (uint8x8_t)vcnt_s8(v4), v17.i16[0] = vaddlv_u8(v17), v17.u32[0] > 1uLL))
    {
      unint64_t v16 = std::__next_prime(v16);
    }
    else
    {
      uint64_t v18 = 1 << -(char)__clz(v16 - 1);
      if (v16 >= 2) {
        unint64_t v16 = v18;
      }
    }
    if (prime <= v16) {
      size_t prime = v16;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      uint64_t v22 = *(void **)a1;
      *(void *)a1 = 0;
      if (v22) {
        operator delete(v22);
      }
      *(void *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    sub_1D0DE8CE0();
  }
  int v5 = operator new(8 * prime);
  int v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  uint64_t v9 = a1 + 16;
  int v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v10 = v8[1];
    size_t v11 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v12 = v10 & v11;
      *(void *)(*(void *)a1 + 8 * v12) = v9;
      while (1)
      {
        uint8x8_t v13 = (void *)*v8;
        if (!*v8) {
          break;
        }
        size_t v14 = v13[1] & v11;
        if (v14 == v12)
        {
          int v8 = (void *)*v8;
        }
        else if (*(void *)(*(void *)a1 + 8 * v14))
        {
          void *v8 = *v13;
          uint64_t v15 = 8 * v14;
          void *v13 = **(void **)(*(void *)a1 + v15);
          **(void **)(*(void *)a1 + v15) = v13;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v14) = v8;
          int v8 = v13;
          size_t v12 = v14;
        }
      }
      return;
    }
    if (v10 >= prime) {
      v10 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v10) = v9;
    uint64_t v19 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v21 = v19[1];
        if (v21 >= prime) {
          v21 %= prime;
        }
        if (v21 != v10)
        {
          if (!*(void *)(*(void *)a1 + 8 * v21))
          {
            *(void *)(*(void *)a1 + 8 * v21) = v8;
            goto LABEL_32;
          }
          void *v8 = *v19;
          uint64_t v20 = 8 * v21;
          *uint64_t v19 = **(void **)(*(void *)a1 + v20);
          **(void **)(*(void *)a1 + v20) = v19;
          uint64_t v19 = v8;
        }
        size_t v21 = v10;
LABEL_32:
        int v8 = v19;
        uint64_t v19 = (void *)*v19;
        size_t v10 = v21;
      }
      while (v19);
    }
  }
}

uint64_t **sub_1D0DEB7F8(uint64_t **a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **a1;
  **a1 = (uint64_t)a1[1];
  if (v2)
  {
    int v3 = e5rt_execution_stream_operation_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t **sub_1D0DEB8C4(uint64_t **a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **a1;
  **a1 = (uint64_t)a1[1];
  if (v2)
  {
    int v3 = e5rt_io_port_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t sub_1D0DEB990(uint64_t a1, uint64_t a2)
{
  int v5 = *(char *)(a2 + 23);
  if (v5 >= 0) {
    int v6 = (uint64_t *)a2;
  }
  else {
    int v6 = *(uint64_t **)a2;
  }
  if (v5 >= 0) {
    unint64_t v7 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v7 = *(void *)(a2 + 8);
  }
  unint64_t v8 = sub_1D0DE1DF8(v6, v7);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v2 = v8;
      if (v8 >= v10) {
        unint64_t v2 = v8 % v10;
      }
    }
    else
    {
      unint64_t v2 = (v10 - 1) & v8;
    }
    size_t v12 = *(uint64_t **)(*(void *)a1 + 8 * v2);
    if (v12)
    {
      uint64_t v13 = *v12;
      if (*v12)
      {
        if (v11.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v18 = *(void *)(v13 + 8);
            if (v18 == v9)
            {
              uint64_t v19 = *(unsigned __int8 *)(v13 + 39);
              if ((v19 & 0x80u) == 0) {
                uint64_t v20 = *(unsigned __int8 *)(v13 + 39);
              }
              else {
                uint64_t v20 = *(void *)(v13 + 24);
              }
              if (v20 == v7)
              {
                if ((v19 & 0x80) != 0)
                {
                  if (!memcmp(*(const void **)(v13 + 16), v6, *(void *)(v13 + 24))) {
                    return v13 + 40;
                  }
                }
                else
                {
                  if (!*(unsigned char *)(v13 + 39)) {
                    return v13 + 40;
                  }
                  uint64_t v21 = 0;
                  while (*(unsigned __int8 *)(v13 + v21 + 16) == *((unsigned __int8 *)v6 + v21))
                  {
                    if (v19 == ++v21) {
                      return v13 + 40;
                    }
                  }
                }
              }
            }
            else if ((v18 & (v10 - 1)) != v2)
            {
              goto LABEL_49;
            }
            uint64_t v13 = *(void *)v13;
            if (!v13) {
              goto LABEL_49;
            }
          }
        }
        do
        {
          unint64_t v14 = *(void *)(v13 + 8);
          if (v14 == v9)
          {
            uint64_t v15 = *(unsigned __int8 *)(v13 + 39);
            if ((v15 & 0x80u) == 0) {
              uint64_t v16 = *(unsigned __int8 *)(v13 + 39);
            }
            else {
              uint64_t v16 = *(void *)(v13 + 24);
            }
            if (v16 == v7)
            {
              if ((v15 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)(v13 + 16), v6, *(void *)(v13 + 24))) {
                  return v13 + 40;
                }
              }
              else
              {
                if (!*(unsigned char *)(v13 + 39)) {
                  return v13 + 40;
                }
                uint64_t v17 = 0;
                while (*(unsigned __int8 *)(v13 + v17 + 16) == *((unsigned __int8 *)v6 + v17))
                {
                  if (v15 == ++v17) {
                    return v13 + 40;
                  }
                }
              }
            }
          }
          else
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
            if (v14 != v2) {
              break;
            }
          }
          uint64_t v13 = *(void *)v13;
        }
        while (v13);
      }
    }
  }
LABEL_49:
  uint64_t v22 = operator new(0x30uLL);
  v33[0] = (uint64_t)v22;
  v33[1] = a1 + 16;
  *uint64_t v22 = 0;
  v22[1] = v9;
  *((_OWORD *)v22 + 1) = *(_OWORD *)a2;
  uint64_t v23 = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  v22[4] = v23;
  v22[5] = 0;
  char v34 = 1;
  float v24 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v25 = *(float *)(a1 + 32);
  if (!v10 || (float)(v25 * (float)v10) < v24)
  {
    BOOL v26 = 1;
    if (v10 >= 3) {
      BOOL v26 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v27 = v26 | (2 * v10);
    unint64_t v28 = vcvtps_u32_f32(v24 / v25);
    if (v27 <= v28) {
      size_t v29 = v28;
    }
    else {
      size_t v29 = v27;
    }
    sub_1D0DEB5B0(a1, v29);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v2 = v9 % v10;
      }
      else {
        unint64_t v2 = v9;
      }
    }
    else
    {
      unint64_t v2 = (v10 - 1) & v9;
    }
  }
  BOOL v30 = *(void **)(*(void *)a1 + 8 * v2);
  if (v30)
  {
    *(void *)v33[0] = *v30;
    void *v30 = v33[0];
  }
  else
  {
    *(void *)v33[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v33[0];
    *(void *)(*(void *)a1 + 8 * v2) = a1 + 16;
    if (*(void *)v33[0])
    {
      unint64_t v31 = *(void *)(*(void *)v33[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v31 >= v10) {
          v31 %= v10;
        }
      }
      else
      {
        v31 &= v10 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v31) = v33[0];
    }
  }
  uint64_t v13 = v33[0];
  v33[0] = 0;
  ++*(void *)(a1 + 24);
  sub_1D0DEB4B4(v33);
  return v13 + 40;
}

void sub_1D0DEBCD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1D0DEB4B4((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1D0DEBCE8(uint64_t *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    int v3 = e5rt_io_port_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

void sub_1D0DEBDB0(int64x2_t *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint8x8_t v11 = (uint64_t *)&v13;
  int v2 = e5rt_io_port_retain_tensor_desc();
  if (v2)
  {
    snprintf(__str, 0x40uLL, "e5rt::EnsureSuccess failed with error code %d.", v2);
    int shape = _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v3 = *v11;
  *uint8x8_t v11 = v12;
  if (v3)
  {
    uint64_t v14 = v3;
    int v4 = e5rt_tensor_desc_release();
    if (v4) {
      goto LABEL_10;
    }
  }
  while (1)
  {
    uint8x8_t v11 = 0;
    uint64_t v14 = 0;
    int shape = e5rt_tensor_desc_get_shape();
    if (!shape) {
      break;
    }
LABEL_9:
    snprintf(__str, 0x40uLL, "e5rt::EnsureSuccess failed with error code %d.", shape);
    int v4 = _os_crash();
    __break(1u);
LABEL_10:
    int v9 = v4;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__str = 67109120;
      int v16 = v9;
      _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", (uint8_t *)__str, 8u);
    }
  }
  int64x2_t v6 = vdupq_n_s64(1uLL);
  *a1 = v6;
  a1[1] = v6;
  int v7 = v13;
  uint64_t v13 = 0;
  if (v7)
  {
    uint8x8_t v11 = v7;
    int v8 = e5rt_tensor_desc_release();
    if (v8)
    {
      int v10 = v8;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__str = 67109120;
        int v16 = v10;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", (uint8_t *)__str, 8u);
      }
    }
  }
}

void sub_1D0DEBFCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_1D0DED4C8((uint64_t *)va);
  _Unwind_Resume(a1);
}

char *sub_1D0DEBFF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(char *)(a2 + 23);
  if (v6 >= 0) {
    int v7 = (uint64_t *)a2;
  }
  else {
    int v7 = *(uint64_t **)a2;
  }
  if (v6 >= 0) {
    unint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v8 = *(void *)(a2 + 8);
  }
  unint64_t v9 = sub_1D0DE1DF8(v7, v8);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v3 = v9;
      if (v9 >= v11) {
        unint64_t v3 = v9 % v11;
      }
    }
    else
    {
      unint64_t v3 = (v11 - 1) & v9;
    }
    uint64_t v13 = *(char ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      uint64_t v14 = *v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v19 = *((void *)v14 + 1);
            if (v19 == v10)
            {
              uint64_t v20 = v14[39];
              if ((v20 & 0x80u) == 0) {
                uint64_t v21 = v14[39];
              }
              else {
                uint64_t v21 = *((void *)v14 + 3);
              }
              if (v21 == v8)
              {
                if ((v20 & 0x80) != 0)
                {
                  if (!memcmp(*((const void **)v14 + 2), v7, *((void *)v14 + 3))) {
                    return v14;
                  }
                }
                else
                {
                  if (!v14[39]) {
                    return v14;
                  }
                  uint64_t v22 = 0;
                  while (v14[v22 + 16] == *((unsigned char *)v7 + v22))
                  {
                    if (v20 == ++v22) {
                      return v14;
                    }
                  }
                }
              }
            }
            else if ((v19 & (v11 - 1)) != v3)
            {
              goto LABEL_49;
            }
            uint64_t v14 = *(char **)v14;
            if (!v14) {
              goto LABEL_49;
            }
          }
        }
        do
        {
          unint64_t v15 = *((void *)v14 + 1);
          if (v15 == v10)
          {
            uint64_t v16 = v14[39];
            if ((v16 & 0x80u) == 0) {
              uint64_t v17 = v14[39];
            }
            else {
              uint64_t v17 = *((void *)v14 + 3);
            }
            if (v17 == v8)
            {
              if ((v16 & 0x80) != 0)
              {
                if (!memcmp(*((const void **)v14 + 2), v7, *((void *)v14 + 3))) {
                  return v14;
                }
              }
              else
              {
                if (!v14[39]) {
                  return v14;
                }
                uint64_t v18 = 0;
                while (v14[v18 + 16] == *((unsigned char *)v7 + v18))
                {
                  if (v16 == ++v18) {
                    return v14;
                  }
                }
              }
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v3) {
              break;
            }
          }
          uint64_t v14 = *(char **)v14;
        }
        while (v14);
      }
    }
  }
LABEL_49:
  uint64_t v23 = (void *)(a1 + 16);
  float v24 = (char *)operator new(0x50uLL);
  *(void *)float v24 = 0;
  *((void *)v24 + 1) = v10;
  float v25 = v24 + 16;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_1D0DCB370(v25, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)float v25 = *(_OWORD *)a3;
    *((void *)v24 + 4) = *(void *)(a3 + 16);
  }
  *((_OWORD *)v24 + 3) = 0u;
  *((_OWORD *)v24 + 4) = 0u;
  float v26 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v27 = *(float *)(a1 + 32);
  if (!v11 || (float)(v27 * (float)v11) < v26)
  {
    BOOL v28 = 1;
    if (v11 >= 3) {
      BOOL v28 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v29 = v28 | (2 * v11);
    unint64_t v30 = vcvtps_u32_f32(v26 / v27);
    if (v29 <= v30) {
      size_t prime = v30;
    }
    else {
      size_t prime = v29;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    if (prime <= v11)
    {
      if (prime >= v11) {
        goto LABEL_89;
      }
      unint64_t v42 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (uint8x8_t v43 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v43.i16[0] = vaddlv_u8(v43), v43.u32[0] > 1uLL))
      {
        unint64_t v42 = std::__next_prime(v42);
      }
      else
      {
        uint64_t v44 = 1 << -(char)__clz(v42 - 1);
        if (v42 >= 2) {
          unint64_t v42 = v44;
        }
      }
      if (prime <= v42) {
        size_t prime = v42;
      }
      if (prime >= v11)
      {
        unint64_t v11 = *(void *)(a1 + 8);
LABEL_89:
        if ((v11 & (v11 - 1)) != 0)
        {
          if (v10 >= v11) {
            unint64_t v3 = v10 % v11;
          }
          else {
            unint64_t v3 = v10;
          }
        }
        else
        {
          unint64_t v3 = (v11 - 1) & v10;
        }
        goto LABEL_102;
      }
      if (!prime)
      {
        int v51 = *(void **)a1;
        *(void *)a1 = 0;
        if (v51) {
          operator delete(v51);
        }
        unint64_t v11 = 0;
        *(void *)(a1 + 8) = 0;
        goto LABEL_89;
      }
    }
    if (prime >> 61) {
      sub_1D0DE8CE0();
    }
    unint64_t v32 = operator new(8 * prime);
    size_t v33 = *(void **)a1;
    *(void *)a1 = v32;
    if (v33) {
      operator delete(v33);
    }
    uint64_t v34 = 0;
    *(void *)(a1 + 8) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v34++) = 0;
    while (prime != v34);
    unint64_t v35 = (void *)*v23;
    if (!*v23)
    {
LABEL_88:
      unint64_t v11 = prime;
      goto LABEL_89;
    }
    size_t v36 = v35[1];
    size_t v37 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v38 = v36 & v37;
      *(void *)(*(void *)a1 + 8 * v38) = v23;
      for (uint64_t i = (void *)*v35; *v35; uint64_t i = (void *)*v35)
      {
        size_t v40 = i[1] & v37;
        if (v40 == v38)
        {
          unint64_t v35 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v40))
        {
          *unint64_t v35 = *i;
          uint64_t v41 = 8 * v40;
          *uint64_t i = **(void **)(*(void *)a1 + v41);
          **(void **)(*(void *)a1 + v41) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v40) = v35;
          unint64_t v35 = i;
          size_t v38 = v40;
        }
      }
      goto LABEL_88;
    }
    if (v36 >= prime) {
      v36 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v36) = v23;
    uint64_t v45 = (void *)*v35;
    if (!*v35) {
      goto LABEL_88;
    }
    while (1)
    {
      size_t v47 = v45[1];
      if (v47 >= prime) {
        v47 %= prime;
      }
      if (v47 != v36)
      {
        if (!*(void *)(*(void *)a1 + 8 * v47))
        {
          *(void *)(*(void *)a1 + 8 * v47) = v35;
          goto LABEL_93;
        }
        *unint64_t v35 = *v45;
        uint64_t v46 = 8 * v47;
        *uint64_t v45 = **(void **)(*(void *)a1 + v46);
        **(void **)(*(void *)a1 + v46) = v45;
        uint64_t v45 = v35;
      }
      size_t v47 = v36;
LABEL_93:
      unint64_t v35 = v45;
      uint64_t v45 = (void *)*v45;
      size_t v36 = v47;
      if (!v45) {
        goto LABEL_88;
      }
    }
  }
LABEL_102:
  uint64_t v48 = *(void **)(*(void *)a1 + 8 * v3);
  if (v48)
  {
    *(void *)float v24 = *v48;
    *uint64_t v48 = v24;
  }
  else
  {
    *(void *)float v24 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v24;
    *(void *)(*(void *)a1 + 8 * v3) = v23;
    if (*(void *)v24)
    {
      unint64_t v49 = *(void *)(*(void *)v24 + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v49 >= v11) {
          v49 %= v11;
        }
      }
      else
      {
        v49 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v49) = v24;
    }
  }
  uint64_t v14 = v24;
  ++*(void *)(a1 + 24);
  return v14;
}

void sub_1D0DEC56C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1D0DED590((uint64_t *)va);
  _Unwind_Resume(a1);
}

id sub_1D0DEC584()
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v52 = 0;
  uint64_t v48 = (uint64_t *)&v52;
  uint64_t v49 = 0;
  int v0 = e5rt_io_port_retain_tensor_desc();
  if (v0)
  {
    snprintf(__str, 0x40uLL, "e5rt::EnsureSuccess failed with error code %d.", v0);
    int shape = _os_crash();
    __break(1u);
    goto LABEL_32;
  }
  uint64_t v1 = *v48;
  *uint64_t v48 = v49;
  if (v1)
  {
    uint64_t v54 = v1;
    int v2 = e5rt_tensor_desc_release();
    if (v2) {
      goto LABEL_39;
    }
  }
  while (1)
  {
    uint64_t v48 = 0;
    uint64_t v54 = 0;
    int shape = e5rt_tensor_desc_get_shape();
    if (shape)
    {
LABEL_32:
      snprintf(__str, 0x40uLL, "e5rt::EnsureSuccess failed with error code %d.", shape);
      int v10 = _os_crash();
      __break(1u);
LABEL_33:
      snprintf(__str, 0x40uLL, "e5rt::EnsureSuccess failed with error code %d.", v10);
      component_unint64_t size = _os_crash();
      __break(1u);
LABEL_34:
      snprintf(__str, 0x40uLL, "e5rt::EnsureSuccess failed with error code %d.", component_size);
      element_unint64_t size = _os_crash();
      __break(1u);
LABEL_35:
      snprintf(__str, 0x40uLL, "e5rt::EnsureSuccess failed with error code %d.", element_size);
      int num_components = _os_crash();
      __break(1u);
LABEL_36:
      snprintf(__str, 0x40uLL, "e5rt::EnsureSuccess failed with error code %d.", num_components);
      int component_dtype = _os_crash();
      __break(1u);
LABEL_37:
      snprintf(__str, 0x40uLL, "e5rt::EnsureSuccess failed with error code %d.", component_dtype);
      int strides = _os_crash();
      __break(1u);
      goto LABEL_38;
    }
    int v4 = v48;
    if (v48)
    {
      int v5 = 0;
      int v6 = (uint64_t *)(v54 + 8 * (void)v48 - 8);
      int64x2_t v7 = vdupq_n_s64(1uLL);
      int64x2_t v8 = v7;
      do
      {
        uint64_t v9 = *v6--;
        int64x2_t v46 = v7;
        int64x2_t v47 = v8;
        v46.i64[v5 & 3] = v9;
        int64x2_t v7 = v46;
        int64x2_t v8 = v47;
        int v5 = (uint64_t *)((char *)v5 + 1);
      }
      while (v4 != v5);
    }
    else
    {
      int64x2_t v7 = vdupq_n_s64(1uLL);
      int64x2_t v8 = v7;
    }
    int64x2_t v42 = v8;
    int64x2_t v43 = v7;
    int v51 = 0;
    uint64_t v48 = (uint64_t *)&v51;
    uint64_t v49 = 0;
    int v10 = e5rt_tensor_desc_retain_dtype();
    if (v10) {
      goto LABEL_33;
    }
    uint64_t v11 = *v48;
    *uint64_t v48 = v49;
    if (v11)
    {
      uint64_t v54 = v11;
      int v12 = e5rt_tensor_desc_dtype_release();
      if (v12)
      {
        int v38 = v12;
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__str = 67109120;
          int v58 = v38;
          _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", (uint8_t *)__str, 8u);
        }
      }
    }
    uint64_t v49 = 0;
    uint64_t v50 = 0;
    uint64_t v48 = 0;
    component_unint64_t size = e5rt_tensor_desc_dtype_get_component_size();
    if (component_size) {
      goto LABEL_34;
    }
    element_unint64_t size = e5rt_tensor_desc_dtype_get_element_size();
    if (element_size) {
      goto LABEL_35;
    }
    int num_components = e5rt_tensor_desc_dtype_get_num_components();
    if (num_components) {
      goto LABEL_36;
    }
    int component_dtype = e5rt_tensor_desc_dtype_get_component_dtype();
    if (component_dtype) {
      goto LABEL_37;
    }
    unint64_t v53 = 0;
    uint64_t v54 = 0;
    int strides = e5rt_tensor_desc_get_strides();
    if (!strides) {
      break;
    }
LABEL_38:
    snprintf(__str, 0x40uLL, "e5rt::EnsureSuccess failed with error code %d.", strides);
    int v2 = _os_crash();
    __break(1u);
LABEL_39:
    int v37 = v2;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__str = 67109120;
      int v58 = v37;
      _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", (uint8_t *)__str, 8u);
    }
  }
  uint64_t v19 = v53;
  uint64_t v18 = v54;
  float64x2_t v20 = vld1q_dup_f64(v19);
  if (v54)
  {
    uint64_t v21 = 0;
    uint64_t v22 = &v53[v54 - 1];
    float64x2_t v23 = v20;
    do
    {
      float64_t v24 = *v22--;
      float64x2_t v44 = v20;
      float64x2_t v45 = v23;
      v44.f64[v21 & 3] = v24;
      float64x2_t v20 = v44;
      float64x2_t v23 = v45;
      ++v21;
    }
    while (v18 != v21);
  }
  float64_t v41 = v20.f64[1];
  v55[0] = *MEMORY[0x1E4F2EF70];
  float v25 = [NSNumber numberWithUnsignedLong:v43.i64[0]];
  v56[0] = v25;
  v55[1] = *MEMORY[0x1E4F2EF28];
  float v26 = [NSNumber numberWithUnsignedLong:v43.i64[1] * v42.i64[0] * v42.i64[1]];
  v56[1] = v26;
  v55[2] = *MEMORY[0x1E4F2EF10];
  float v27 = [NSNumber numberWithUnsignedLong:v49];
  v56[2] = v27;
  v55[3] = *MEMORY[0x1E4F2EF18];
  BOOL v28 = [NSNumber numberWithLong:*(void *)&v41];
  v56[3] = v28;
  v55[4] = *MEMORY[0x1E4F2EF30];
  if (v49 == 2) {
    uint64_t v29 = 1278226536;
  }
  else {
    uint64_t v29 = 1278226534;
  }
  unint64_t v30 = [NSNumber numberWithUnsignedInt:v29];
  v56[4] = v30;
  unint64_t v31 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v56 forKeys:v55 count:5];

  unint64_t v32 = v51;
  int v51 = 0;
  if (v32)
  {
    uint64_t v48 = v32;
    int v33 = e5rt_tensor_desc_dtype_release();
    if (v33)
    {
      int v39 = v33;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__str = 67109120;
        int v58 = v39;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", (uint8_t *)__str, 8u);
      }
    }
  }
  uint64_t v34 = v52;
  uint64_t v52 = 0;
  if (v34)
  {
    uint64_t v48 = v34;
    int v35 = e5rt_tensor_desc_release();
    if (v35)
    {
      int v40 = v35;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__str = 67109120;
        int v58 = v40;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", (uint8_t *)__str, 8u);
      }
    }
  }
  return v31;
}

void sub_1D0DECB84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  sub_1D0DED400(&a29);
  sub_1D0DED4C8(&a30);
  _Unwind_Resume(a1);
}

void *sub_1D0DECC0C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(char *)(a2 + 23);
  if (v6 >= 0) {
    int64x2_t v7 = (uint64_t *)a2;
  }
  else {
    int64x2_t v7 = *(uint64_t **)a2;
  }
  if (v6 >= 0) {
    unint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v8 = *(void *)(a2 + 8);
  }
  unint64_t v9 = sub_1D0DE1DF8(v7, v8);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v3 = v9;
      if (v9 >= v11) {
        unint64_t v3 = v9 % v11;
      }
    }
    else
    {
      unint64_t v3 = (v11 - 1) & v9;
    }
    uint64_t v13 = *(void **)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      uint64_t v14 = (void *)*v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v19 = v14[1];
            if (v19 == v10)
            {
              uint64_t v20 = *((unsigned __int8 *)v14 + 39);
              if ((v20 & 0x80u) == 0) {
                uint64_t v21 = *((unsigned __int8 *)v14 + 39);
              }
              else {
                uint64_t v21 = v14[3];
              }
              if (v21 == v8)
              {
                if ((v20 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v14[2], v7, v14[3])) {
                    return v14;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v14 + 39)) {
                    return v14;
                  }
                  uint64_t v22 = 0;
                  while (*((unsigned __int8 *)v14 + v22 + 16) == *((unsigned __int8 *)v7 + v22))
                  {
                    if (v20 == ++v22) {
                      return v14;
                    }
                  }
                }
              }
            }
            else if ((v19 & (v11 - 1)) != v3)
            {
              goto LABEL_49;
            }
            uint64_t v14 = (void *)*v14;
            if (!v14) {
              goto LABEL_49;
            }
          }
        }
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v10)
          {
            uint64_t v16 = *((unsigned __int8 *)v14 + 39);
            if ((v16 & 0x80u) == 0) {
              uint64_t v17 = *((unsigned __int8 *)v14 + 39);
            }
            else {
              uint64_t v17 = v14[3];
            }
            if (v17 == v8)
            {
              if ((v16 & 0x80) != 0)
              {
                if (!memcmp((const void *)v14[2], v7, v14[3])) {
                  return v14;
                }
              }
              else
              {
                if (!*((unsigned char *)v14 + 39)) {
                  return v14;
                }
                uint64_t v18 = 0;
                while (*((unsigned __int8 *)v14 + v18 + 16) == *((unsigned __int8 *)v7 + v18))
                {
                  if (v16 == ++v18) {
                    return v14;
                  }
                }
              }
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v3) {
              break;
            }
          }
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_49:
  float64x2_t v23 = (void *)(a1 + 16);
  float64_t v24 = operator new(0x30uLL);
  *float64_t v24 = 0;
  v24[1] = v10;
  float v25 = v24 + 2;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_1D0DCB370(v25, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)float v25 = *(_OWORD *)a3;
    v24[4] = *(void *)(a3 + 16);
  }
  void v24[5] = 0;
  float v26 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v27 = *(float *)(a1 + 32);
  if (!v11 || (float)(v27 * (float)v11) < v26)
  {
    BOOL v28 = 1;
    if (v11 >= 3) {
      BOOL v28 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v29 = v28 | (2 * v11);
    unint64_t v30 = vcvtps_u32_f32(v26 / v27);
    if (v29 <= v30) {
      size_t prime = v30;
    }
    else {
      size_t prime = v29;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    if (prime <= v11)
    {
      if (prime >= v11) {
        goto LABEL_89;
      }
      unint64_t v42 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (uint8x8_t v43 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v43.i16[0] = vaddlv_u8(v43), v43.u32[0] > 1uLL))
      {
        unint64_t v42 = std::__next_prime(v42);
      }
      else
      {
        uint64_t v44 = 1 << -(char)__clz(v42 - 1);
        if (v42 >= 2) {
          unint64_t v42 = v44;
        }
      }
      if (prime <= v42) {
        size_t prime = v42;
      }
      if (prime >= v11)
      {
        unint64_t v11 = *(void *)(a1 + 8);
LABEL_89:
        if ((v11 & (v11 - 1)) != 0)
        {
          if (v10 >= v11) {
            unint64_t v3 = v10 % v11;
          }
          else {
            unint64_t v3 = v10;
          }
        }
        else
        {
          unint64_t v3 = (v11 - 1) & v10;
        }
        goto LABEL_102;
      }
      if (!prime)
      {
        int v51 = *(void **)a1;
        *(void *)a1 = 0;
        if (v51) {
          operator delete(v51);
        }
        unint64_t v11 = 0;
        *(void *)(a1 + 8) = 0;
        goto LABEL_89;
      }
    }
    if (prime >> 61) {
      sub_1D0DE8CE0();
    }
    unint64_t v32 = operator new(8 * prime);
    int v33 = *(void **)a1;
    *(void *)a1 = v32;
    if (v33) {
      operator delete(v33);
    }
    uint64_t v34 = 0;
    *(void *)(a1 + 8) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v34++) = 0;
    while (prime != v34);
    int v35 = (void *)*v23;
    if (!*v23)
    {
LABEL_88:
      unint64_t v11 = prime;
      goto LABEL_89;
    }
    size_t v36 = v35[1];
    size_t v37 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v38 = v36 & v37;
      *(void *)(*(void *)a1 + 8 * v38) = v23;
      for (uint64_t i = (void *)*v35; *v35; uint64_t i = (void *)*v35)
      {
        size_t v40 = i[1] & v37;
        if (v40 == v38)
        {
          int v35 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v40))
        {
          *int v35 = *i;
          uint64_t v41 = 8 * v40;
          *uint64_t i = **(void **)(*(void *)a1 + v41);
          **(void **)(*(void *)a1 + v41) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v40) = v35;
          int v35 = i;
          size_t v38 = v40;
        }
      }
      goto LABEL_88;
    }
    if (v36 >= prime) {
      v36 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v36) = v23;
    float64x2_t v45 = (void *)*v35;
    if (!*v35) {
      goto LABEL_88;
    }
    while (1)
    {
      size_t v47 = v45[1];
      if (v47 >= prime) {
        v47 %= prime;
      }
      if (v47 != v36)
      {
        if (!*(void *)(*(void *)a1 + 8 * v47))
        {
          *(void *)(*(void *)a1 + 8 * v47) = v35;
          goto LABEL_93;
        }
        *int v35 = *v45;
        uint64_t v46 = 8 * v47;
        *float64x2_t v45 = **(void **)(*(void *)a1 + v46);
        **(void **)(*(void *)a1 + v46) = v45;
        float64x2_t v45 = v35;
      }
      size_t v47 = v36;
LABEL_93:
      int v35 = v45;
      float64x2_t v45 = (void *)*v45;
      size_t v36 = v47;
      if (!v45) {
        goto LABEL_88;
      }
    }
  }
LABEL_102:
  uint64_t v48 = *(void **)(*(void *)a1 + 8 * v3);
  if (v48)
  {
    *float64_t v24 = *v48;
    *uint64_t v48 = v24;
  }
  else
  {
    *float64_t v24 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v24;
    *(void *)(*(void *)a1 + 8 * v3) = v23;
    if (*v24)
    {
      unint64_t v49 = *(void *)(*v24 + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v49 >= v11) {
          v49 %= v11;
        }
      }
      else
      {
        v49 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v49) = v24;
    }
  }
  uint64_t v14 = v24;
  ++*(void *)(a1 + 24);
  return v14;
}

void sub_1D0DED184(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1D0DE8C88((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t **sub_1D0DED19C(uint64_t **a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **a1;
  **a1 = (uint64_t)a1[1];
  if (v2)
  {
    int v3 = e5rt_execution_stream_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t **sub_1D0DED268(uint64_t **a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **a1;
  **a1 = (uint64_t)a1[1];
  if (v2)
  {
    int v3 = e5rt_tensor_desc_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t **sub_1D0DED334(uint64_t **a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **a1;
  **a1 = (uint64_t)a1[1];
  if (v2)
  {
    int v3 = e5rt_tensor_desc_dtype_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t *sub_1D0DED400(uint64_t *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    int v3 = e5rt_tensor_desc_dtype_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t *sub_1D0DED4C8(uint64_t *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    int v3 = e5rt_tensor_desc_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t *sub_1D0DED590(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16) && *(char *)(v2 + 39) < 0) {
      operator delete(*(void **)(v2 + 16));
    }
    operator delete((void *)v2);
  }
  return a1;
}

uint64_t sub_1D0DED5E0(uint64_t result, const char **a2, uint64_t a3, char a4)
{
  int v7 = (const char **)result;
  while (2)
  {
    uint64_t v8 = a2;
    float v140 = a2 - 1;
    unint64_t v9 = v7;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v10 = (char *)v8 - (char *)v9;
          uint64_t v11 = v8 - v9;
          if (v5 || !v4)
          {
            switch(v11)
            {
              case 0:
              case 1:
                return result;
              case 2:
                double v87 = *v140;
                __int16 v88 = *v9;
                uint64_t result = strcmp(*v140, *v9);
                if ((result & 0x80000000) != 0)
                {
                  *unint64_t v9 = v87;
                  *float v140 = v88;
                }
                return result;
              case 3:
                uint64_t v83 = *v9;
                long long v84 = v9[1];
                int v85 = strcmp(v84, *v9);
                int32x2_t v86 = *v140;
                uint64_t result = strcmp(*v140, v84);
                if (v85 < 0)
                {
                  if ((result & 0x80000000) != 0)
                  {
                    *unint64_t v9 = v86;
                  }
                  else
                  {
                    *unint64_t v9 = v84;
                    v9[1] = v83;
                    unsigned int v136 = *v140;
                    uint64_t result = strcmp(*v140, v83);
                    if ((result & 0x80000000) == 0) {
                      return result;
                    }
                    v9[1] = v136;
                  }
                  *float v140 = v83;
                }
                else if ((result & 0x80000000) != 0)
                {
                  v9[1] = v86;
                  *float v140 = v84;
                  uint64_t v132 = *v9;
                  int v131 = v9[1];
                  uint64_t result = strcmp(v131, *v9);
                  if ((result & 0x80000000) != 0)
                  {
                    *unint64_t v9 = v131;
                    v9[1] = v132;
                  }
                }
                break;
              case 4:
                return sub_1D0DEE080(v9, v9 + 1, v9 + 2, v140);
              case 5:
                return sub_1D0DEE1BC(v9, v9 + 1, v9 + 2, v9 + 3, v140);
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v10 <= 191)
          {
            float v89 = v9 + 1;
            BOOL v91 = v9 == v8 || v89 == v8;
            if (a4)
            {
              if (!v91)
              {
                uint64_t v92 = 8;
                float v93 = v9;
                do
                {
                  long long v96 = *v93;
                  long long v95 = v93[1];
                  float v93 = v89;
                  uint64_t result = strcmp(v95, v96);
                  if ((result & 0x80000000) != 0)
                  {
                    uint64_t v97 = v92;
                    do
                    {
                      *(const char **)((char *)v9 + v97) = v96;
                      uint64_t v98 = v97 - 8;
                      if (v97 == 8)
                      {
                        float v94 = v9;
                        goto LABEL_119;
                      }
                      long long v96 = *(const char **)((char *)v9 + v97 - 16);
                      uint64_t result = strcmp(v95, v96);
                      uint64_t v97 = v98;
                    }
                    while ((result & 0x80000000) != 0);
                    float v94 = (const char **)((char *)v9 + v98);
LABEL_119:
                    float *v94 = v95;
                  }
                  float v89 = v93 + 1;
                  v92 += 8;
                }
                while (v93 + 1 != a2);
              }
            }
            else if (!v91)
            {
              do
              {
                int v134 = *v9;
                float32x4_t v133 = v9[1];
                unint64_t v9 = v89;
                uint64_t result = strcmp(v133, v134);
                if ((result & 0x80000000) != 0)
                {
                  int v135 = v9;
                  do
                  {
                    *int v135 = v134;
                    int v134 = *(v135 - 2);
                    uint64_t result = strcmp(v133, v134);
                    --v135;
                  }
                  while ((result & 0x80000000) != 0);
                  *int v135 = v133;
                }
                float v89 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          float32x4_t v142 = v9;
          if (!a3)
          {
            if (v9 != v8)
            {
              int64_t v99 = (unint64_t)(v11 - 2) >> 1;
              int64_t v141 = v99;
              do
              {
                int64_t v100 = v99;
                if (v141 >= v99)
                {
                  uint64_t v101 = (2 * v99) | 1;
                  long long v102 = &v9[v101];
                  float16x4_t v103 = *v102;
                  if (2 * v99 + 2 < v11)
                  {
                    long long v104 = v102[1];
                    if (strcmp(*v102, v104) < 0)
                    {
                      float16x4_t v103 = v104;
                      ++v102;
                      uint64_t v101 = 2 * v100 + 2;
                    }
                  }
                  unint64_t v105 = &v9[v100];
                  uint64_t v106 = *v105;
                  uint64_t result = strcmp(v103, *v105);
                  if ((result & 0x80000000) == 0)
                  {
                    int64_t v138 = v100;
                    do
                    {
                      unint64_t v107 = v102;
                      *unint64_t v105 = v103;
                      if (v141 < v101) {
                        break;
                      }
                      uint64_t v108 = (2 * v101) | 1;
                      long long v102 = &v9[v108];
                      uint64_t v109 = 2 * v101 + 2;
                      float16x4_t v103 = *v102;
                      if (v109 < v11)
                      {
                        unint64_t v110 = v102[1];
                        int v111 = strcmp(*v102, v110);
                        if (v111 < 0)
                        {
                          float16x4_t v103 = v110;
                          ++v102;
                        }
                        unint64_t v9 = v142;
                        if (v111 < 0) {
                          uint64_t v108 = v109;
                        }
                      }
                      uint64_t result = strcmp(v103, v106);
                      unint64_t v105 = v107;
                      uint64_t v101 = v108;
                    }
                    while ((result & 0x80000000) == 0);
                    *unint64_t v107 = v106;
                    int64_t v100 = v138;
                  }
                }
                int64_t v99 = v100 - 1;
              }
              while (v100);
              uint64_t v112 = (unint64_t)v10 >> 3;
              do
              {
                uint64_t v114 = 0;
                BOOL v115 = *v9;
                int v116 = v9;
                do
                {
                  v117 = &v116[v114];
                  v120 = v117[1];
                  int v119 = v117 + 1;
                  int v118 = v120;
                  uint64_t v121 = (2 * v114) | 1;
                  uint64_t v122 = 2 * v114 + 2;
                  if (v122 < v112)
                  {
                    float v123 = v119[1];
                    uint64_t result = strcmp(v118, v123);
                    if ((int)result < 0)
                    {
                      int v118 = v123;
                      ++v119;
                      uint64_t v121 = v122;
                    }
                  }
                  float *v116 = v118;
                  int v116 = v119;
                  uint64_t v114 = v121;
                }
                while (v121 <= (uint64_t)((unint64_t)(v112 - 2) >> 1));
                float v124 = a2 - 1;
                BOOL v5 = v119 == --a2;
                if (v5)
                {
                  *int v119 = v115;
                  unint64_t v9 = v142;
                }
                else
                {
                  *int v119 = *v124;
                  *float v124 = v115;
                  unint64_t v9 = v142;
                  uint64_t v125 = (char *)v119 - (char *)v142 + 8;
                  if (v125 >= 9)
                  {
                    unint64_t v126 = (((unint64_t)v125 >> 3) - 2) >> 1;
                    float v127 = &v142[v126];
                    float v128 = *v127;
                    float32x4_t v129 = *v119;
                    uint64_t result = strcmp(*v127, *v119);
                    if ((result & 0x80000000) != 0)
                    {
                      do
                      {
                        int v130 = v127;
                        *int v119 = v128;
                        if (!v126) {
                          break;
                        }
                        unint64_t v126 = (v126 - 1) >> 1;
                        float v127 = &v142[v126];
                        float v128 = *v127;
                        uint64_t result = strcmp(*v127, v129);
                        int v119 = v130;
                      }
                      while ((result & 0x80000000) != 0);
                      uint64_t *v130 = v129;
                    }
                  }
                }
              }
              while (v112-- > 2);
            }
            return result;
          }
          unint64_t v12 = (unint64_t)v11 >> 1;
          uint64_t v13 = &v9[(unint64_t)v11 >> 1];
          uint64_t v14 = *v140;
          if ((unint64_t)v10 >= 0x401)
          {
            unint64_t v15 = *v13;
            uint64_t v16 = *v9;
            int v17 = strcmp(*v13, *v9);
            int v18 = strcmp(v14, v15);
            if (v17 < 0)
            {
              if (v18 < 0)
              {
                uint64_t v19 = v142;
                *float32x4_t v142 = v14;
              }
              else
              {
                uint64_t v19 = v142;
                *float32x4_t v142 = v15;
                void *v13 = v16;
                unint64_t v29 = *v140;
                if ((strcmp(*v140, v16) & 0x80000000) == 0) {
                  goto LABEL_23;
                }
                void *v13 = v29;
              }
              *float v140 = v16;
            }
            else
            {
              uint64_t v19 = v142;
              if (v18 < 0)
              {
                void *v13 = v14;
                *float v140 = v15;
                float v25 = *v13;
                float v26 = *v142;
                if (strcmp(*v13, *v142) < 0)
                {
                  *float32x4_t v142 = v25;
                  void *v13 = v26;
                }
              }
            }
LABEL_23:
            unint64_t v30 = &v19[v12];
            int v33 = *(v30 - 1);
            unint64_t v32 = v30 - 1;
            unint64_t v31 = v33;
            uint64_t v34 = v19[1];
            int v35 = strcmp(v33, v34);
            size_t v36 = *(v8 - 2);
            int v37 = strcmp(v36, v33);
            if (v35 < 0)
            {
              if (v37 < 0)
              {
                size_t v38 = v142;
                v142[1] = v36;
              }
              else
              {
                size_t v38 = v142;
                v142[1] = v31;
                *unint64_t v32 = v34;
                unint64_t v42 = *(v8 - 2);
                if ((strcmp(v42, v34) & 0x80000000) == 0) {
                  goto LABEL_34;
                }
                *unint64_t v32 = v42;
              }
              *(v8 - 2) = v34;
            }
            else
            {
              size_t v38 = v142;
              if (v37 < 0)
              {
                *unint64_t v32 = v36;
                *(v8 - 2) = v31;
                int v39 = *v32;
                size_t v40 = v142[1];
                if (strcmp(*v32, v40) < 0)
                {
                  v142[1] = v39;
                  *unint64_t v32 = v40;
                }
              }
            }
LABEL_34:
            uint8x8_t v43 = &v38[v12];
            uint64_t v46 = v43[1];
            uint64_t v44 = v43 + 1;
            float64x2_t v45 = v46;
            size_t v47 = v38[2];
            int v48 = strcmp(v46, v47);
            unint64_t v49 = *(v8 - 3);
            int v50 = strcmp(v49, v46);
            if (v48 < 0)
            {
              if (v50 < 0)
              {
                v142[2] = v49;
              }
              else
              {
                v142[2] = v45;
                *uint64_t v44 = v47;
                unint64_t v53 = *(v8 - 3);
                if ((strcmp(v53, v47) & 0x80000000) == 0) {
                  goto LABEL_43;
                }
                *uint64_t v44 = v53;
              }
              *(v8 - 3) = v47;
            }
            else if (v50 < 0)
            {
              *uint64_t v44 = v49;
              *(v8 - 3) = v45;
              int v51 = *v44;
              uint64_t v52 = v142[2];
              if (strcmp(*v44, v52) < 0)
              {
                v142[2] = v51;
                *uint64_t v44 = v52;
              }
            }
LABEL_43:
            uint64_t v54 = *v13;
            uint64_t v55 = *v32;
            int v56 = strcmp(*v13, *v32);
            uint64_t v57 = *v44;
            int v58 = strcmp(*v44, v54);
            if (v56 < 0)
            {
              if (v58 < 0)
              {
                float64_t v24 = v142;
              }
              else
              {
                *unint64_t v32 = v54;
                void *v13 = v55;
                unint64_t v32 = v13;
                uint64_t v54 = v57;
                float64_t v24 = v142;
                if ((strcmp(v57, v55) & 0x80000000) == 0)
                {
                  uint64_t v54 = v55;
                  goto LABEL_53;
                }
              }
            }
            else
            {
              if ((v58 & 0x80000000) == 0)
              {
                float64_t v24 = v142;
                goto LABEL_53;
              }
              void *v13 = v57;
              *uint64_t v44 = v54;
              uint64_t v44 = v13;
              uint64_t v54 = v55;
              float64_t v24 = v142;
              if ((strcmp(v57, v55) & 0x80000000) == 0)
              {
                uint64_t v54 = v57;
LABEL_53:
                uint64_t v59 = *v24;
                *float64_t v24 = v54;
                void *v13 = v59;
                goto LABEL_54;
              }
            }
            *unint64_t v32 = v57;
            *uint64_t v44 = v55;
            goto LABEL_53;
          }
          uint64_t v20 = *v9;
          uint64_t v21 = *v13;
          int v22 = strcmp(*v9, *v13);
          int v23 = strcmp(v14, v20);
          if (v22 < 0)
          {
            if (v23 < 0)
            {
              void *v13 = v14;
              float64_t v24 = v142;
              *float v140 = v21;
            }
            else
            {
              void *v13 = v20;
              float64_t v24 = v142;
              *float32x4_t v142 = v21;
              uint64_t v41 = *v140;
              if (strcmp(*v140, v21) < 0)
              {
                *float32x4_t v142 = v41;
                *float v140 = v21;
              }
            }
          }
          else
          {
            float64_t v24 = v142;
            if (v23 < 0)
            {
              *float32x4_t v142 = v14;
              *float v140 = v20;
              float v27 = *v142;
              BOOL v28 = *v13;
              if (strcmp(*v142, *v13) < 0)
              {
                void *v13 = v27;
                *float32x4_t v142 = v28;
              }
            }
          }
LABEL_54:
          --a3;
          uint64_t v60 = *v24;
          uint64_t v61 = v24;
          if (a4) {
            break;
          }
          uint64_t v61 = v24;
          if (strcmp(*(v24 - 1), *v24) < 0) {
            break;
          }
          uint64_t result = strcmp(v60, *v140);
          if ((result & 0x80000000) != 0)
          {
            unint64_t v9 = v24;
            do
            {
              unsigned int v74 = v9[1];
              ++v9;
              uint64_t result = strcmp(v60, v74);
            }
            while ((result & 0x80000000) == 0);
          }
          else
          {
            unsigned int v75 = v24 + 1;
            do
            {
              unint64_t v9 = v75;
              if (v75 >= a2) {
                break;
              }
              ++v75;
              uint64_t result = strcmp(v60, *v9);
            }
            while ((result & 0x80000000) == 0);
          }
          uint64_t v8 = a2;
          int32x4_t v76 = a2;
          if (v9 < a2)
          {
            int32x4_t v76 = a2;
            do
            {
              int32x4_t v77 = *--v76;
              uint64_t result = strcmp(v60, v77);
            }
            while ((result & 0x80000000) != 0);
          }
          if (v9 < v76)
          {
            float16x4_t v78 = *v9;
            float32x4_t v79 = *v76;
            do
            {
              *unint64_t v9 = v79;
              *int32x4_t v76 = v78;
              do
              {
                long long v80 = v9[1];
                ++v9;
                float16x4_t v78 = v80;
              }
              while ((strcmp(v60, v80) & 0x80000000) == 0);
              do
              {
                uint64_t v81 = *--v76;
                float32x4_t v79 = v81;
                uint64_t result = strcmp(v60, v81);
              }
              while ((result & 0x80000000) != 0);
            }
            while (v9 < v76);
          }
          float32x4_t v82 = v9 - 1;
          BOOL v4 = v9 - 1 >= v24;
          BOOL v5 = v9 - 1 == v24;
          if (v9 - 1 != v24) {
            *float64_t v24 = *v82;
          }
          a4 = 0;
          *float32x4_t v82 = v60;
        }
        do
        {
          uint64_t v62 = v61;
          uint64_t v64 = v61[1];
          ++v61;
          uint64_t v63 = v64;
        }
        while (strcmp(v64, v60) < 0);
        uint64_t v65 = v8;
        if (v62 == v24)
        {
          uint64_t v65 = v8;
          do
          {
            if (v61 >= v65) {
              break;
            }
            unint64_t v67 = *--v65;
          }
          while ((strcmp(v67, v60) & 0x80000000) == 0);
        }
        else
        {
          do
            uint64_t v66 = *--v65;
          while ((strcmp(v66, v60) & 0x80000000) == 0);
        }
        if (v61 < v65)
        {
          unint64_t v68 = *v65;
          unint64_t v69 = v61;
          unint64_t v70 = v65;
          do
          {
            *unint64_t v69 = v68;
            *unint64_t v70 = v63;
            do
            {
              uint64_t v62 = v69;
              unint64_t v71 = v69[1];
              ++v69;
              uint64_t v63 = v71;
            }
            while (strcmp(v71, v60) < 0);
            do
            {
              uint64_t v72 = *--v70;
              unint64_t v68 = v72;
            }
            while ((strcmp(v72, v60) & 0x80000000) == 0);
          }
          while (v69 < v70);
        }
        int v7 = v142;
        if (v62 != v142) {
          *float32x4_t v142 = *v62;
        }
        *uint64_t v62 = v60;
        uint64_t v8 = a2;
        if (v61 >= v65) {
          break;
        }
LABEL_74:
        uint64_t result = sub_1D0DED5E0(v142, v62, a3, a4 & 1);
        a4 = 0;
        unint64_t v9 = v62 + 1;
      }
      BOOL v73 = sub_1D0DEE288(v142, v62);
      unint64_t v9 = v62 + 1;
      uint64_t result = sub_1D0DEE288(v62 + 1, a2);
      if (result) {
        break;
      }
      if (!v73) {
        goto LABEL_74;
      }
    }
    a2 = v62;
    if (!v73) {
      continue;
    }
    return result;
  }
}

uint64_t sub_1D0DEE080(const char **a1, const char **a2, const char **a3, const char **a4)
{
  uint64_t v8 = *a2;
  unint64_t v9 = *a1;
  int v10 = strcmp(*a2, *a1);
  uint64_t v11 = *a3;
  int v12 = strcmp(*a3, v8);
  if (v10 < 0)
  {
    if (v12 < 0)
    {
      *a1 = v11;
LABEL_9:
      *a3 = v9;
      uint64_t v8 = v9;
      goto LABEL_11;
    }
    *a1 = v8;
    *a2 = v9;
    uint64_t v8 = *a3;
    if (strcmp(*a3, v9) < 0)
    {
      *a2 = v8;
      goto LABEL_9;
    }
  }
  else if (v12 < 0)
  {
    *a2 = v11;
    *a3 = v8;
    uint64_t v13 = *a2;
    uint64_t v14 = *a1;
    if (strcmp(*a2, *a1) < 0)
    {
      *a1 = v13;
      *a2 = v14;
      uint64_t v8 = *a3;
    }
  }
  else
  {
    uint64_t v8 = v11;
  }
LABEL_11:
  unint64_t v15 = *a4;
  uint64_t result = strcmp(*a4, v8);
  if ((result & 0x80000000) != 0)
  {
    *a3 = v15;
    *a4 = v8;
    int v17 = *a3;
    int v18 = *a2;
    uint64_t result = strcmp(*a3, *a2);
    if ((result & 0x80000000) != 0)
    {
      *a2 = v17;
      *a3 = v18;
      uint64_t v19 = *a2;
      uint64_t v20 = *a1;
      uint64_t result = strcmp(*a2, *a1);
      if ((result & 0x80000000) != 0)
      {
        *a1 = v19;
        *a2 = v20;
      }
    }
  }
  return result;
}

uint64_t sub_1D0DEE1BC(const char **a1, const char **a2, const char **a3, const char **a4, const char **a5)
{
  sub_1D0DEE080(a1, a2, a3, a4);
  int v10 = *a5;
  uint64_t v11 = *a4;
  uint64_t result = strcmp(*a5, *a4);
  if ((result & 0x80000000) != 0)
  {
    *a4 = v10;
    *a5 = v11;
    uint64_t v13 = *a4;
    uint64_t v14 = *a3;
    uint64_t result = strcmp(*a4, *a3);
    if ((result & 0x80000000) != 0)
    {
      *a3 = v13;
      *a4 = v14;
      unint64_t v15 = *a3;
      uint64_t v16 = *a2;
      uint64_t result = strcmp(*a3, *a2);
      if ((result & 0x80000000) != 0)
      {
        *a2 = v15;
        *a3 = v16;
        int v17 = *a2;
        int v18 = *a1;
        uint64_t result = strcmp(*a2, *a1);
        if ((result & 0x80000000) != 0)
        {
          *a1 = v17;
          *a2 = v18;
        }
      }
    }
  }
  return result;
}

BOOL sub_1D0DEE288(const char **a1, const char **a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v6 = *(a2 - 1);
      int v7 = *a1;
      if (strcmp(v6, *a1) < 0)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return 1;
    case 3:
      uint64_t v8 = *a1;
      unint64_t v9 = a1[1];
      int v10 = strcmp(v9, *a1);
      uint64_t v11 = *(a2 - 1);
      int v12 = strcmp(v11, v9);
      if (v10 < 0)
      {
        if (v12 < 0)
        {
          *a1 = v11;
        }
        else
        {
          *a1 = v9;
          a1[1] = v8;
          uint64_t v34 = *(a2 - 1);
          if ((strcmp(v34, v8) & 0x80000000) == 0) {
            return 1;
          }
          a1[1] = v34;
        }
        *(a2 - 1) = v8;
      }
      else if (v12 < 0)
      {
        a1[1] = v11;
        *(a2 - 1) = v9;
        int v23 = *a1;
        int v22 = a1[1];
        if (strcmp(v22, *a1) < 0)
        {
          *a1 = v22;
          a1[1] = v23;
        }
      }
      return 1;
    case 4:
      sub_1D0DEE080(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      sub_1D0DEE1BC(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v13 = a1[1];
      uint64_t v14 = *a1;
      int v15 = strcmp(v13, *a1);
      int v17 = a1 + 2;
      uint64_t v16 = a1[2];
      int v18 = strcmp(v16, v13);
      if (v15 < 0)
      {
        uint64_t v19 = a1;
        uint64_t v20 = a1 + 2;
        if ((v18 & 0x80000000) == 0)
        {
          *a1 = v13;
          a1[1] = v14;
          int v21 = strcmp(v16, v14);
          uint64_t v19 = a1 + 1;
          uint64_t v20 = a1 + 2;
          if ((v21 & 0x80000000) == 0) {
            goto LABEL_19;
          }
        }
LABEL_18:
        *uint64_t v19 = v16;
        *uint64_t v20 = v14;
        goto LABEL_19;
      }
      if (v18 < 0)
      {
        a1[1] = v16;
        *int v17 = v13;
        int v24 = strcmp(v16, v14);
        uint64_t v19 = a1;
        uint64_t v20 = a1 + 1;
        if (v24 < 0) {
          goto LABEL_18;
        }
      }
LABEL_19:
      float v25 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v26 = 0;
      for (uint64_t i = 24; ; i += 8)
      {
        unint64_t v29 = *v25;
        unint64_t v30 = *v17;
        if (strcmp(*v25, *v17) < 0)
        {
          uint64_t v31 = i;
          do
          {
            *(const char **)((char *)a1 + v31) = v30;
            uint64_t v32 = v31 - 8;
            if (v31 == 8)
            {
              BOOL v28 = a1;
              goto LABEL_22;
            }
            unint64_t v30 = *(const char **)((char *)a1 + v31 - 16);
            int v33 = strcmp(v29, v30);
            uint64_t v31 = v32;
          }
          while (v33 < 0);
          BOOL v28 = (const char **)((char *)a1 + v32);
LABEL_22:
          *BOOL v28 = v29;
          if (++v26 == 8) {
            break;
          }
        }
        int v17 = v25++;
        if (v25 == a2) {
          return 1;
        }
      }
      return v25 + 1 == a2;
  }
}

uint64_t sub_1D0DEE514(uint64_t result, const char **a2, uint64_t a3, char a4)
{
  int v7 = (const char **)result;
  while (2)
  {
    uint64_t v8 = a2;
    float v140 = a2 - 1;
    unint64_t v9 = v7;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v10 = (char *)v8 - (char *)v9;
          uint64_t v11 = v8 - v9;
          if (v5 || !v4)
          {
            switch(v11)
            {
              case 0:
              case 1:
                return result;
              case 2:
                double v87 = *v140;
                __int16 v88 = *v9;
                BOOL result = strcmp(*v140, *v9);
                if ((result & 0x80000000) != 0)
                {
                  *unint64_t v9 = v87;
                  *float v140 = v88;
                }
                return result;
              case 3:
                uint64_t v83 = *v9;
                long long v84 = v9[1];
                int v85 = strcmp(v84, *v9);
                int32x2_t v86 = *v140;
                BOOL result = strcmp(*v140, v84);
                if (v85 < 0)
                {
                  if ((result & 0x80000000) != 0)
                  {
                    *unint64_t v9 = v86;
                  }
                  else
                  {
                    *unint64_t v9 = v84;
                    v9[1] = v83;
                    unsigned int v136 = *v140;
                    BOOL result = strcmp(*v140, v83);
                    if ((result & 0x80000000) == 0) {
                      return result;
                    }
                    v9[1] = v136;
                  }
                  *float v140 = v83;
                }
                else if ((result & 0x80000000) != 0)
                {
                  v9[1] = v86;
                  *float v140 = v84;
                  uint64_t v132 = *v9;
                  int v131 = v9[1];
                  BOOL result = strcmp(v131, *v9);
                  if ((result & 0x80000000) != 0)
                  {
                    *unint64_t v9 = v131;
                    v9[1] = v132;
                  }
                }
                break;
              case 4:
                return sub_1D0DEE080(v9, v9 + 1, v9 + 2, v140);
              case 5:
                return sub_1D0DEE1BC(v9, v9 + 1, v9 + 2, v9 + 3, v140);
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v10 <= 191)
          {
            float v89 = v9 + 1;
            BOOL v91 = v9 == v8 || v89 == v8;
            if (a4)
            {
              if (!v91)
              {
                uint64_t v92 = 8;
                float v93 = v9;
                do
                {
                  long long v96 = *v93;
                  long long v95 = v93[1];
                  float v93 = v89;
                  BOOL result = strcmp(v95, v96);
                  if ((result & 0x80000000) != 0)
                  {
                    uint64_t v97 = v92;
                    do
                    {
                      *(const char **)((char *)v9 + v97) = v96;
                      uint64_t v98 = v97 - 8;
                      if (v97 == 8)
                      {
                        float v94 = v9;
                        goto LABEL_119;
                      }
                      long long v96 = *(const char **)((char *)v9 + v97 - 16);
                      BOOL result = strcmp(v95, v96);
                      uint64_t v97 = v98;
                    }
                    while ((result & 0x80000000) != 0);
                    float v94 = (const char **)((char *)v9 + v98);
LABEL_119:
                    float *v94 = v95;
                  }
                  float v89 = v93 + 1;
                  v92 += 8;
                }
                while (v93 + 1 != a2);
              }
            }
            else if (!v91)
            {
              do
              {
                int v134 = *v9;
                float32x4_t v133 = v9[1];
                unint64_t v9 = v89;
                BOOL result = strcmp(v133, v134);
                if ((result & 0x80000000) != 0)
                {
                  int v135 = v9;
                  do
                  {
                    *int v135 = v134;
                    int v134 = *(v135 - 2);
                    BOOL result = strcmp(v133, v134);
                    --v135;
                  }
                  while ((result & 0x80000000) != 0);
                  *int v135 = v133;
                }
                float v89 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          float32x4_t v142 = v9;
          if (!a3)
          {
            if (v9 != v8)
            {
              int64_t v99 = (unint64_t)(v11 - 2) >> 1;
              int64_t v141 = v99;
              do
              {
                int64_t v100 = v99;
                if (v141 >= v99)
                {
                  uint64_t v101 = (2 * v99) | 1;
                  long long v102 = &v9[v101];
                  float16x4_t v103 = *v102;
                  if (2 * v99 + 2 < v11)
                  {
                    long long v104 = v102[1];
                    if (strcmp(*v102, v104) < 0)
                    {
                      float16x4_t v103 = v104;
                      ++v102;
                      uint64_t v101 = 2 * v100 + 2;
                    }
                  }
                  unint64_t v105 = &v9[v100];
                  uint64_t v106 = *v105;
                  BOOL result = strcmp(v103, *v105);
                  if ((result & 0x80000000) == 0)
                  {
                    int64_t v138 = v100;
                    do
                    {
                      unint64_t v107 = v102;
                      *unint64_t v105 = v103;
                      if (v141 < v101) {
                        break;
                      }
                      uint64_t v108 = (2 * v101) | 1;
                      long long v102 = &v9[v108];
                      uint64_t v109 = 2 * v101 + 2;
                      float16x4_t v103 = *v102;
                      if (v109 < v11)
                      {
                        unint64_t v110 = v102[1];
                        int v111 = strcmp(*v102, v110);
                        if (v111 < 0)
                        {
                          float16x4_t v103 = v110;
                          ++v102;
                        }
                        unint64_t v9 = v142;
                        if (v111 < 0) {
                          uint64_t v108 = v109;
                        }
                      }
                      BOOL result = strcmp(v103, v106);
                      unint64_t v105 = v107;
                      uint64_t v101 = v108;
                    }
                    while ((result & 0x80000000) == 0);
                    *unint64_t v107 = v106;
                    int64_t v100 = v138;
                  }
                }
                int64_t v99 = v100 - 1;
              }
              while (v100);
              uint64_t v112 = (unint64_t)v10 >> 3;
              do
              {
                uint64_t v114 = 0;
                BOOL v115 = *v9;
                int v116 = v9;
                do
                {
                  v117 = &v116[v114];
                  v120 = v117[1];
                  int v119 = v117 + 1;
                  int v118 = v120;
                  uint64_t v121 = (2 * v114) | 1;
                  uint64_t v122 = 2 * v114 + 2;
                  if (v122 < v112)
                  {
                    float v123 = v119[1];
                    BOOL result = strcmp(v118, v123);
                    if ((int)result < 0)
                    {
                      int v118 = v123;
                      ++v119;
                      uint64_t v121 = v122;
                    }
                  }
                  float *v116 = v118;
                  int v116 = v119;
                  uint64_t v114 = v121;
                }
                while (v121 <= (uint64_t)((unint64_t)(v112 - 2) >> 1));
                float v124 = a2 - 1;
                BOOL v5 = v119 == --a2;
                if (v5)
                {
                  *int v119 = v115;
                  unint64_t v9 = v142;
                }
                else
                {
                  *int v119 = *v124;
                  *float v124 = v115;
                  unint64_t v9 = v142;
                  uint64_t v125 = (char *)v119 - (char *)v142 + 8;
                  if (v125 >= 9)
                  {
                    unint64_t v126 = (((unint64_t)v125 >> 3) - 2) >> 1;
                    float v127 = &v142[v126];
                    float v128 = *v127;
                    float32x4_t v129 = *v119;
                    BOOL result = strcmp(*v127, *v119);
                    if ((result & 0x80000000) != 0)
                    {
                      do
                      {
                        int v130 = v127;
                        *int v119 = v128;
                        if (!v126) {
                          break;
                        }
                        unint64_t v126 = (v126 - 1) >> 1;
                        float v127 = &v142[v126];
                        float v128 = *v127;
                        BOOL result = strcmp(*v127, v129);
                        int v119 = v130;
                      }
                      while ((result & 0x80000000) != 0);
                      uint64_t *v130 = v129;
                    }
                  }
                }
              }
              while (v112-- > 2);
            }
            return result;
          }
          unint64_t v12 = (unint64_t)v11 >> 1;
          uint64_t v13 = &v9[(unint64_t)v11 >> 1];
          uint64_t v14 = *v140;
          if ((unint64_t)v10 >= 0x401)
          {
            int v15 = *v13;
            uint64_t v16 = *v9;
            int v17 = strcmp(*v13, *v9);
            int v18 = strcmp(v14, v15);
            if (v17 < 0)
            {
              if (v18 < 0)
              {
                uint64_t v19 = v142;
                *float32x4_t v142 = v14;
              }
              else
              {
                uint64_t v19 = v142;
                *float32x4_t v142 = v15;
                const char *v13 = v16;
                unint64_t v29 = *v140;
                if ((strcmp(*v140, v16) & 0x80000000) == 0) {
                  goto LABEL_23;
                }
                const char *v13 = v29;
              }
              *float v140 = v16;
            }
            else
            {
              uint64_t v19 = v142;
              if (v18 < 0)
              {
                const char *v13 = v14;
                *float v140 = v15;
                float v25 = *v13;
                int v26 = *v142;
                if (strcmp(*v13, *v142) < 0)
                {
                  *float32x4_t v142 = v25;
                  const char *v13 = v26;
                }
              }
            }
LABEL_23:
            unint64_t v30 = &v19[v12];
            int v33 = *(v30 - 1);
            uint64_t v32 = v30 - 1;
            uint64_t v31 = v33;
            uint64_t v34 = v19[1];
            int v35 = strcmp(v33, v34);
            size_t v36 = *(v8 - 2);
            int v37 = strcmp(v36, v33);
            if (v35 < 0)
            {
              if (v37 < 0)
              {
                size_t v38 = v142;
                v142[1] = v36;
              }
              else
              {
                size_t v38 = v142;
                v142[1] = v31;
                *uint64_t v32 = v34;
                unint64_t v42 = *(v8 - 2);
                if ((strcmp(v42, v34) & 0x80000000) == 0) {
                  goto LABEL_34;
                }
                *uint64_t v32 = v42;
              }
              *(v8 - 2) = v34;
            }
            else
            {
              size_t v38 = v142;
              if (v37 < 0)
              {
                *uint64_t v32 = v36;
                *(v8 - 2) = v31;
                int v39 = *v32;
                size_t v40 = v142[1];
                if (strcmp(*v32, v40) < 0)
                {
                  v142[1] = v39;
                  *uint64_t v32 = v40;
                }
              }
            }
LABEL_34:
            uint8x8_t v43 = &v38[v12];
            uint64_t v46 = v43[1];
            uint64_t v44 = v43 + 1;
            float64x2_t v45 = v46;
            size_t v47 = v38[2];
            int v48 = strcmp(v46, v47);
            unint64_t v49 = *(v8 - 3);
            int v50 = strcmp(v49, v46);
            if (v48 < 0)
            {
              if (v50 < 0)
              {
                v142[2] = v49;
              }
              else
              {
                v142[2] = v45;
                *uint64_t v44 = v47;
                unint64_t v53 = *(v8 - 3);
                if ((strcmp(v53, v47) & 0x80000000) == 0) {
                  goto LABEL_43;
                }
                *uint64_t v44 = v53;
              }
              *(v8 - 3) = v47;
            }
            else if (v50 < 0)
            {
              *uint64_t v44 = v49;
              *(v8 - 3) = v45;
              int v51 = *v44;
              uint64_t v52 = v142[2];
              if (strcmp(*v44, v52) < 0)
              {
                v142[2] = v51;
                *uint64_t v44 = v52;
              }
            }
LABEL_43:
            uint64_t v54 = *v13;
            uint64_t v55 = *v32;
            int v56 = strcmp(*v13, *v32);
            uint64_t v57 = *v44;
            int v58 = strcmp(*v44, v54);
            if (v56 < 0)
            {
              if (v58 < 0)
              {
                int v24 = v142;
              }
              else
              {
                *uint64_t v32 = v54;
                const char *v13 = v55;
                uint64_t v32 = v13;
                uint64_t v54 = v57;
                int v24 = v142;
                if ((strcmp(v57, v55) & 0x80000000) == 0)
                {
                  uint64_t v54 = v55;
                  goto LABEL_53;
                }
              }
            }
            else
            {
              if ((v58 & 0x80000000) == 0)
              {
                int v24 = v142;
                goto LABEL_53;
              }
              const char *v13 = v57;
              *uint64_t v44 = v54;
              uint64_t v44 = v13;
              uint64_t v54 = v55;
              int v24 = v142;
              if ((strcmp(v57, v55) & 0x80000000) == 0)
              {
                uint64_t v54 = v57;
LABEL_53:
                uint64_t v59 = *v24;
                *int v24 = v54;
                const char *v13 = v59;
                goto LABEL_54;
              }
            }
            *uint64_t v32 = v57;
            *uint64_t v44 = v55;
            goto LABEL_53;
          }
          uint64_t v20 = *v9;
          int v21 = *v13;
          int v22 = strcmp(*v9, *v13);
          int v23 = strcmp(v14, v20);
          if (v22 < 0)
          {
            if (v23 < 0)
            {
              const char *v13 = v14;
              int v24 = v142;
              *float v140 = v21;
            }
            else
            {
              const char *v13 = v20;
              int v24 = v142;
              *float32x4_t v142 = v21;
              uint64_t v41 = *v140;
              if (strcmp(*v140, v21) < 0)
              {
                *float32x4_t v142 = v41;
                *float v140 = v21;
              }
            }
          }
          else
          {
            int v24 = v142;
            if (v23 < 0)
            {
              *float32x4_t v142 = v14;
              *float v140 = v20;
              float v27 = *v142;
              BOOL v28 = *v13;
              if (strcmp(*v142, *v13) < 0)
              {
                const char *v13 = v27;
                *float32x4_t v142 = v28;
              }
            }
          }
LABEL_54:
          --a3;
          uint64_t v60 = *v24;
          uint64_t v61 = v24;
          if (a4) {
            break;
          }
          uint64_t v61 = v24;
          if (strcmp(*(v24 - 1), *v24) < 0) {
            break;
          }
          BOOL result = strcmp(v60, *v140);
          if ((result & 0x80000000) != 0)
          {
            unint64_t v9 = v24;
            do
            {
              unsigned int v74 = v9[1];
              ++v9;
              BOOL result = strcmp(v60, v74);
            }
            while ((result & 0x80000000) == 0);
          }
          else
          {
            unsigned int v75 = v24 + 1;
            do
            {
              unint64_t v9 = v75;
              if (v75 >= a2) {
                break;
              }
              ++v75;
              BOOL result = strcmp(v60, *v9);
            }
            while ((result & 0x80000000) == 0);
          }
          uint64_t v8 = a2;
          int32x4_t v76 = a2;
          if (v9 < a2)
          {
            int32x4_t v76 = a2;
            do
            {
              int32x4_t v77 = *--v76;
              BOOL result = strcmp(v60, v77);
            }
            while ((result & 0x80000000) != 0);
          }
          if (v9 < v76)
          {
            float16x4_t v78 = *v9;
            float32x4_t v79 = *v76;
            do
            {
              *unint64_t v9 = v79;
              *int32x4_t v76 = v78;
              do
              {
                long long v80 = v9[1];
                ++v9;
                float16x4_t v78 = v80;
              }
              while ((strcmp(v60, v80) & 0x80000000) == 0);
              do
              {
                uint64_t v81 = *--v76;
                float32x4_t v79 = v81;
                BOOL result = strcmp(v60, v81);
              }
              while ((result & 0x80000000) != 0);
            }
            while (v9 < v76);
          }
          float32x4_t v82 = v9 - 1;
          BOOL v4 = v9 - 1 >= v24;
          BOOL v5 = v9 - 1 == v24;
          if (v9 - 1 != v24) {
            *int v24 = *v82;
          }
          a4 = 0;
          *float32x4_t v82 = v60;
        }
        do
        {
          uint64_t v62 = v61;
          uint64_t v64 = v61[1];
          ++v61;
          uint64_t v63 = v64;
        }
        while (strcmp(v64, v60) < 0);
        uint64_t v65 = v8;
        if (v62 == v24)
        {
          uint64_t v65 = v8;
          do
          {
            if (v61 >= v65) {
              break;
            }
            unint64_t v67 = *--v65;
          }
          while ((strcmp(v67, v60) & 0x80000000) == 0);
        }
        else
        {
          do
            uint64_t v66 = *--v65;
          while ((strcmp(v66, v60) & 0x80000000) == 0);
        }
        if (v61 < v65)
        {
          unint64_t v68 = *v65;
          unint64_t v69 = v61;
          unint64_t v70 = v65;
          do
          {
            *unint64_t v69 = v68;
            *unint64_t v70 = v63;
            do
            {
              uint64_t v62 = v69;
              unint64_t v71 = v69[1];
              ++v69;
              uint64_t v63 = v71;
            }
            while (strcmp(v71, v60) < 0);
            do
            {
              uint64_t v72 = *--v70;
              unint64_t v68 = v72;
            }
            while ((strcmp(v72, v60) & 0x80000000) == 0);
          }
          while (v69 < v70);
        }
        int v7 = v142;
        if (v62 != v142) {
          *float32x4_t v142 = *v62;
        }
        *uint64_t v62 = v60;
        uint64_t v8 = a2;
        if (v61 >= v65) {
          break;
        }
LABEL_74:
        BOOL result = sub_1D0DEE514(v142, v62, a3, a4 & 1);
        a4 = 0;
        unint64_t v9 = v62 + 1;
      }
      BOOL v73 = sub_1D0DEEFB4(v142, v62);
      unint64_t v9 = v62 + 1;
      BOOL result = sub_1D0DEEFB4(v62 + 1, a2);
      if (result) {
        break;
      }
      if (!v73) {
        goto LABEL_74;
      }
    }
    a2 = v62;
    if (!v73) {
      continue;
    }
    return result;
  }
}

BOOL sub_1D0DEEFB4(const char **a1, const char **a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v6 = *(a2 - 1);
      int v7 = *a1;
      if (strcmp(v6, *a1) < 0)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return 1;
    case 3:
      uint64_t v8 = *a1;
      unint64_t v9 = a1[1];
      int v10 = strcmp(v9, *a1);
      uint64_t v11 = *(a2 - 1);
      int v12 = strcmp(v11, v9);
      if (v10 < 0)
      {
        if (v12 < 0)
        {
          *a1 = v11;
        }
        else
        {
          *a1 = v9;
          a1[1] = v8;
          uint64_t v34 = *(a2 - 1);
          if ((strcmp(v34, v8) & 0x80000000) == 0) {
            return 1;
          }
          a1[1] = v34;
        }
        *(a2 - 1) = v8;
      }
      else if (v12 < 0)
      {
        a1[1] = v11;
        *(a2 - 1) = v9;
        int v23 = *a1;
        int v22 = a1[1];
        if (strcmp(v22, *a1) < 0)
        {
          *a1 = v22;
          a1[1] = v23;
        }
      }
      return 1;
    case 4:
      sub_1D0DEE080(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      sub_1D0DEE1BC(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v13 = a1[1];
      uint64_t v14 = *a1;
      int v15 = strcmp(v13, *a1);
      int v17 = a1 + 2;
      uint64_t v16 = a1[2];
      int v18 = strcmp(v16, v13);
      if (v15 < 0)
      {
        uint64_t v19 = a1;
        uint64_t v20 = a1 + 2;
        if ((v18 & 0x80000000) == 0)
        {
          *a1 = v13;
          a1[1] = v14;
          int v21 = strcmp(v16, v14);
          uint64_t v19 = a1 + 1;
          uint64_t v20 = a1 + 2;
          if ((v21 & 0x80000000) == 0) {
            goto LABEL_19;
          }
        }
LABEL_18:
        *uint64_t v19 = v16;
        *uint64_t v20 = v14;
        goto LABEL_19;
      }
      if (v18 < 0)
      {
        a1[1] = v16;
        *int v17 = v13;
        int v24 = strcmp(v16, v14);
        uint64_t v19 = a1;
        uint64_t v20 = a1 + 1;
        if (v24 < 0) {
          goto LABEL_18;
        }
      }
LABEL_19:
      float v25 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v26 = 0;
      for (uint64_t i = 24; ; i += 8)
      {
        unint64_t v29 = *v25;
        unint64_t v30 = *v17;
        if (strcmp(*v25, *v17) < 0)
        {
          uint64_t v31 = i;
          do
          {
            *(const char **)((char *)a1 + v31) = v30;
            uint64_t v32 = v31 - 8;
            if (v31 == 8)
            {
              BOOL v28 = a1;
              goto LABEL_22;
            }
            unint64_t v30 = *(const char **)((char *)a1 + v31 - 16);
            int v33 = strcmp(v29, v30);
            uint64_t v31 = v32;
          }
          while (v33 < 0);
          BOOL v28 = (const char **)((char *)a1 + v32);
LABEL_22:
          *BOOL v28 = v29;
          if (++v26 == 8) {
            break;
          }
        }
        int v17 = v25++;
        if (v25 == a2) {
          return 1;
        }
      }
      return v25 + 1 == a2;
  }
}

uint64_t sub_1D0DEF240(uint64_t a1)
{
  v116[4] = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v2 = (const __CFDictionary *)CVBufferCopyAttachment(*(CVBufferRef *)a1, @"MetadataDictionary", 0);
  v114[0] = &unk_1F26F3618;
  v114[3] = v114;
  CFDictionaryRef theDict = v2;
  v116[3] = v116;
  v116[0] = &unk_1F26F3618;
  if (!v2) {
    goto LABEL_8;
  }
  CFTypeID v3 = CFGetTypeID(v2);
  if (v3 != CFDictionaryGetTypeID())
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    int v23 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(rect.origin.x) = 0;
      _os_log_error_impl(&dword_1D0DBD000, v23, OS_LOG_TYPE_ERROR, "Precondition violated: CFGetTypeID(*pixelBufferMetadata) == CFDictionaryGetTypeID()", (uint8_t *)&rect, 2u);
    }
    goto LABEL_12;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"DetectedFacesArray");
  CFArrayRef v5 = Value;
  if (!Value)
  {
LABEL_8:
    uint64_t v22 = 0;
    goto LABEL_170;
  }
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFArrayGetTypeID())
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    int v23 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(rect.origin.x) = 0;
      _os_log_error_impl(&dword_1D0DBD000, v23, OS_LOG_TYPE_ERROR, "Precondition violated: CFGetTypeID(faceArray) == CFArrayGetTypeID()", (uint8_t *)&rect, 2u);
    }
LABEL_12:

    goto LABEL_169;
  }
  unint64_t Count = CFArrayGetCount(v5);
  unint64_t v8 = Count;
  if (!Count) {
    goto LABEL_8;
  }
  if (Count >> 59) {
    abort();
  }
  uint64_t v9 = 2 * Count;
  int v10 = (float32x4_t *)operator new(32 * Count);
  bzero(v10, 32 * v8);
  __p = v10;
  uint64_t v11 = (char *)operator new(24 * v8);
  CFIndex v12 = 0;
  float16x4_t v103 = (char *)&v10[v9];
  long long v104 = (char *)&v10[2 * v8];
  unint64_t v110 = &v11[24 * v8];
  __asm { FMOV            V9.2S, #1.0 }
  float32x2_t v17 = (float32x2_t)vdup_n_s32(0x43340000u);
  float32x2_t v18 = (float32x2_t)vdup_n_s32(0x43B40000u);
  float32x2_t v19 = (float32x2_t)vdup_n_s32(0xC3B40000);
  float64x2_t v106 = (float64x2_t)vdupq_n_s64(0x3FF6666666666666uLL);
  float64x2_t v107 = (float64x2_t)vdupq_n_s64(0xBFD9999999999998);
  __asm { FMOV            V0.2D, #0.5 }
  float64x2_t v105 = _Q0;
  int v21 = v11;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v5, v12);
    CFDictionaryRef v31 = ValueAtIndex;
    if (!ValueAtIndex || (CFTypeID v32 = CFGetTypeID(ValueAtIndex), v32 != CFDictionaryGetTypeID()))
    {
      uint64_t v98 = sub_1D0DF4E04();
      if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
      {
        LOWORD(rect.origin.x) = 0;
        _os_log_error_impl(&dword_1D0DBD000, v98, OS_LOG_TYPE_ERROR, "Precondition violated: faceDictionary && CFGetTypeID(faceDictionary) == CFDictionaryGetTypeID()", (uint8_t *)&rect, 2u);
      }
      goto LABEL_162;
    }
    CFNumberRef v33 = (const __CFNumber *)CFDictionaryGetValue(v31, @"AngleInfoRoll");
    CFNumberRef v34 = v33;
    if (!v33 || (CFTypeID v35 = CFGetTypeID(v33), v35 != CFNumberGetTypeID()))
    {
      uint64_t v98 = sub_1D0DF4E04();
      if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
      {
        LOWORD(rect.origin.x) = 0;
        _os_log_error_impl(&dword_1D0DBD000, v98, OS_LOG_TYPE_ERROR, "Precondition violated: rollAngle && CFGetTypeID(rollAngle) == CFNumberGetTypeID()", (uint8_t *)&rect, 2u);
      }
      goto LABEL_162;
    }
    if (!CFNumberGetValue(v34, kCFNumberDoubleType, &__p[2 * v12 + 1]))
    {
      uint64_t v98 = sub_1D0DF4E04();
      if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
      {
        LOWORD(rect.origin.x) = 0;
        _os_log_error_impl(&dword_1D0DBD000, v98, OS_LOG_TYPE_ERROR, "Precondition violated: CFNumberGetValue(rollAngle, kCFNumberDoubleType, &inputFace.rollAngle)", (uint8_t *)&rect, 2u);
      }
      goto LABEL_162;
    }
    CFNumberRef v36 = (const __CFNumber *)CFDictionaryGetValue(v31, @"AngleInfoYaw");
    CFNumberRef v37 = v36;
    if (!v36 || (CFTypeID v38 = CFGetTypeID(v36), v38 != CFNumberGetTypeID()))
    {
      uint64_t v98 = sub_1D0DF4E04();
      if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
      {
        LOWORD(rect.origin.x) = 0;
        _os_log_error_impl(&dword_1D0DBD000, v98, OS_LOG_TYPE_ERROR, "Precondition violated: yawAngle && CFGetTypeID(yawAngle) == CFNumberGetTypeID()", (uint8_t *)&rect, 2u);
      }
      goto LABEL_162;
    }
    if (!CFNumberGetValue(v37, kCFNumberDoubleType, &__p[2 * v12 + 1].u32[2]))
    {
      uint64_t v98 = sub_1D0DF4E04();
      if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
      {
        LOWORD(rect.origin.x) = 0;
        _os_log_error_impl(&dword_1D0DBD000, v98, OS_LOG_TYPE_ERROR, "Precondition violated: CFNumberGetValue(yawAngle, kCFNumberDoubleType, &inputFace.yawAngle)", (uint8_t *)&rect, 2u);
      }
      goto LABEL_162;
    }
    CFDictionaryRef v39 = (const __CFDictionary *)CFDictionaryGetValue(v31, @"Rect");
    CFDictionaryRef v40 = v39;
    if (!v39 || (CFTypeID v41 = CFGetTypeID(v39), v41 != CFDictionaryGetTypeID()))
    {
      uint64_t v98 = sub_1D0DF4E04();
      if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
      {
        LOWORD(rect.origin.x) = 0;
        _os_log_error_impl(&dword_1D0DBD000, v98, OS_LOG_TYPE_ERROR, "Precondition violated: rectDict && CFGetTypeID(rectDict) == CFDictionaryGetTypeID()", (uint8_t *)&rect, 2u);
      }
LABEL_162:

      goto LABEL_166;
    }
    if (!CGRectMakeWithDictionaryRepresentation(v40, &rect)) {
      break;
    }
    float32x2_t v42 = vcvt_f32_f64((float64x2_t)rect.origin);
    float32x2_t v43 = vcvt_f32_f64((float64x2_t)rect.size);
    __p[2 * v12] = vcvt_hight_f32_f64((int32x2_t)v42, (float64x2_t)rect.size);
    int32x2_t v44 = (int32x2_t)vsub_f32(vminnm_f32(vadd_f32(v42, v43), _D9), vmaxnm_f32(v42, 0));
    float32x2_t v45 = (float32x2_t)vzip1_s32(v44, (int32x2_t)v43);
    float32x2_t v46 = (float32x2_t)vzip2_s32(v44, (int32x2_t)v43);
    float32x2_t v47 = (float32x2_t)vbic_s8((int8x8_t)vmul_f32(v45, v46), vorr_s8((int8x8_t)vcltz_f32(v45), (int8x8_t)vcltz_f32(v46)));
    if (vdiv_f32(v47, (float32x2_t)vdup_lane_s32((int32x2_t)v47, 1)).f32[0] >= 0.5)
    {
      if (v11 >= v110)
      {
        int64_t v48 = v11 - v21;
        unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v11 - v21) >> 3) + 1;
        if (v49 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        if (0x5555555555555556 * ((v110 - v21) >> 3) > v49) {
          unint64_t v49 = 0x5555555555555556 * ((v110 - v21) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v110 - v21) >> 3) >= 0x555555555555555) {
          unint64_t v50 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v50 = v49;
        }
        if (v50)
        {
          if (v50 > 0xAAAAAAAAAAAAAAALL) {
            sub_1D0DE8CE0();
          }
          int v51 = (char *)operator new(24 * v50);
        }
        else
        {
          int v51 = 0;
        }
        uint64_t v52 = &v51[8 * ((v11 - v21) >> 3)];
        *(void *)uint64_t v52 = 0;
        *((void *)v52 + 1) = 0;
        *((void *)v52 + 2) = 0;
        if (v11 == v21)
        {
          int v21 = &v51[8 * ((v11 - v21) >> 3)];
          goto LABEL_51;
        }
        unint64_t v53 = v11 - v21 - 24;
        if (v53 < 0x7F8) {
          goto LABEL_47;
        }
        unint64_t v57 = v53 / 0x18;
        int v58 = v51 - 24;
        if (&v51[v48 - 24 + -24 * v57] > &v51[v48 - 24]) {
          goto LABEL_47;
        }
        unint64_t v59 = (unint64_t)&v51[v48 - 16];
        if (v59 - 24 * v57 > v59) {
          goto LABEL_47;
        }
        unint64_t v60 = (unint64_t)&v51[v48 - 8];
        if (v60 - 24 * v57 > v60) {
          goto LABEL_47;
        }
        unint64_t v61 = (unint64_t)&v11[-24 * v57 - 24];
        if (v61 > (unint64_t)(v11 - 24)) {
          goto LABEL_47;
        }
        uint64_t v62 = v11 - 16;
        unint64_t v63 = (unint64_t)&v11[-24 * v57 - 16];
        if (v63 > (unint64_t)(v11 - 16)) {
          goto LABEL_47;
        }
        uint64_t v64 = v11 - 8;
        unint64_t v65 = (unint64_t)&v11[-24 * v57 - 8];
        if (v65 > (unint64_t)(v11 - 8)) {
          goto LABEL_47;
        }
        unint64_t v66 = -24 * v57 + v48;
        unint64_t v67 = (unint64_t)&v58[v66];
        unint64_t v68 = &v51[v66 - 16];
        unint64_t v69 = &v51[v66 - 8];
        _CF = &v58[v66] >= v52 || (unint64_t)v69 >= v59;
        BOOL v71 = !_CF;
        BOOL v72 = v67 >= (unint64_t)v62 || v61 >= v59;
        BOOL v73 = !v72;
        BOOL v74 = v67 >= (unint64_t)v64 || v63 >= v59;
        BOOL v75 = !v74;
        BOOL v76 = v67 >= (unint64_t)v11 || v65 >= v59;
        BOOL v77 = !v76;
        BOOL v78 = v68 >= v52 || (unint64_t)v69 >= v60;
        BOOL v79 = !v78;
        BOOL v80 = v68 >= v62 || v61 >= v60;
        BOOL v81 = !v80;
        BOOL v82 = v68 >= v64 || v63 >= v60;
        BOOL v83 = !v82;
        BOOL v84 = v68 >= v11 || v65 >= v60;
        BOOL v85 = !v84;
        BOOL v86 = v69 >= v62 || v61 >= (unint64_t)v52;
        BOOL v87 = !v86;
        BOOL v88 = v69 >= v64 || v63 >= (unint64_t)v52;
        BOOL v89 = !v88;
        BOOL v90 = v69 >= v11 || v65 >= (unint64_t)v52;
        BOOL v91 = !v90;
        BOOL v92 = (unint64_t)v68 >= v59 || v67 >= v60;
        if (!v92 || v71 || v73 || v75 || v77 || v79 || v81 || v83 || v85 || v87 || v89 || v91)
        {
LABEL_47:
          uint64_t v54 = v11;
          uint64_t v55 = &v51[8 * ((v11 - v21) >> 3)];
        }
        else
        {
          unint64_t v93 = v57 + 1;
          uint64_t v94 = (v57 + 1) & 0x1FFFFFFFFFFFFFFELL;
          uint64_t v54 = &v11[-24 * v94];
          long long v95 = (const double *)(v11 - 48);
          long long v96 = (double *)(v52 - 48);
          uint64_t v97 = v94;
          do
          {
            float64x2x3_t v118 = vld3q_f64(v95);
            vst3q_f64(v96, v118);
            v96 -= 6;
            v95 -= 6;
            v97 -= 2;
          }
          while (v97);
          uint64_t v55 = &v52[-24 * v94];
          if (v93 == v94)
          {
LABEL_49:
            uint64_t v11 = v21;
            int v21 = v55;
LABEL_51:
            unint64_t v110 = &v51[24 * v50];
            int v24 = v52 + 24;
            if (v11) {
              operator delete(v11);
            }
LABEL_18:
            float32x2_t v25 = vcvt_f32_f64((float64x2_t)__p[2 * v12 + 1]);
            *((float32x2_t *)v24 - 1) = vneg_f32(vmla_f32(v25, v19, vrndm_f32(vdiv_f32(vadd_f32(v25, v17), v18))));
            rect.origin = (CGPoint)vaddq_f64((float64x2_t)rect.origin, vmulq_f64(vmulq_f64((float64x2_t)rect.size, v107), v105));
            rect.unint64_t size = (CGSize)vmulq_f64((float64x2_t)rect.size, v106);
            float32x2_t v28 = vcvt_f32_s32(*(int32x2_t *)(a1 + 184));
            float32x2_t v26 = vmul_f32(vcvt_f32_f64((float64x2_t)rect.size), v28);
            float32x2_t v27 = vadd_f32(vmul_f32(vcvt_f32_f64((float64x2_t)rect.origin), v28), (float32x2_t)0xBF000000BF000000);
            v28.i32[0] = v26.i32[1];
            if (v26.f32[0] >= v26.f32[1]) {
              v28.f32[0] = v26.f32[0];
            }
            float v109 = v28.f32[0];
            float32x2_t v108 = vadd_f32(v27, vmul_f32(vsub_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 0), v26), (float32x2_t)0xBF000000BF000000));
            simd_float3x3 v117 = __invert_f3(*(simd_float3x3 *)(a1 + 80));
            float32x2_t v29 = (float32x2_t)vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v117.columns[0], v108.f32[0]), (float32x4_t)v117.columns[1], v108, 1).u64[0];
            v117.columns[0].i64[0] = vmlaq_n_f32(vmulq_n_f32((float32x4_t)v117.columns[0], v108.f32[0] + v109), (float32x4_t)v117.columns[1], v108.f32[1] + v109).u64[0];
            *(float32x2_t *)v117.columns[1].f32 = vadd_f32(*(float32x2_t *)v117.columns[2].f32, v29);
            *(float32x2_t *)&v117.columns[1].u32[2] = vsub_f32(vadd_f32(*(float32x2_t *)v117.columns[2].f32, *(float32x2_t *)v117.columns[0].f32), *(float32x2_t *)v117.columns[1].f32);
            *(simd_float3 *)(v24 - 24) = v117.columns[1];
            uint64_t v11 = v24;
            goto LABEL_21;
          }
        }
        do
        {
          uint64_t v56 = *((void *)v54 - 3);
          v54 -= 24;
          *((void *)v55 - 3) = v56;
          v55 -= 24;
          *((void *)v55 + 1) = *((void *)v54 + 1);
          *((void *)v55 + 2) = *((void *)v54 + 2);
        }
        while (v54 != v21);
        goto LABEL_49;
      }
      *(void *)uint64_t v11 = 0;
      *((void *)v11 + 1) = 0;
      int v24 = v11 + 24;
      *((void *)v11 + 2) = 0;
      goto LABEL_18;
    }
LABEL_21:
    if (++v12 == v8)
    {
      uint64_t v101 = *(void **)(a1 + 136);
      if (v101)
      {
        *(void *)(a1 + 144) = v101;
        operator delete(v101);
        *(void *)(a1 + 136) = 0;
        *(void *)(a1 + 144) = 0;
        *(void *)(a1 + 152) = 0;
      }
      long long v102 = *(void **)(a1 + 160);
      *(void *)(a1 + 136) = __p;
      *(void *)(a1 + 144) = v103;
      *(void *)(a1 + 152) = v104;
      if (v102)
      {
        *(void *)(a1 + 168) = v102;
        operator delete(v102);
        *(void *)(a1 + 160) = 0;
        *(void *)(a1 + 168) = 0;
        *(void *)(a1 + 176) = 0;
      }
      uint64_t v22 = 0;
      *(void *)(a1 + 160) = v21;
      *(void *)(a1 + 168) = v11;
      *(void *)(a1 + 176) = v110;
      goto LABEL_170;
    }
  }
  int64_t v99 = sub_1D0DF4E04();
  if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    _os_log_error_impl(&dword_1D0DBD000, v99, OS_LOG_TYPE_ERROR, "Precondition violated: CGRectMakeWithDictionaryRepresentation(rectDict, &bbox)", buf, 2u);
  }

LABEL_166:
  if (v21) {
    operator delete(v21);
  }
  operator delete(__p);
LABEL_169:
  uint64_t v22 = 1;
LABEL_170:
  sub_1D0DEFD50((uint64_t *)&theDict);
  return v22;
}

void sub_1D0DEFCF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
  if (v34) {
    operator delete(v34);
  }
  operator delete(__p);
  sub_1D0DEFD50(&a34);
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DEFD50(uint64_t *a1)
{
  if (*a1)
  {
    uint64_t v5 = *a1;
    uint64_t v2 = a1[4];
    if (!v2)
    {
      uint64_t result = sub_1D0DD8808();
      __break(1u);
      return result;
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v5);
    *a1 = 0;
  }
  CFTypeID v3 = (uint64_t *)a1[4];
  if (v3 == a1 + 1)
  {
    (*(void (**)(uint64_t *))(a1[1] + 32))(a1 + 1);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t *))(*v3 + 40))(v3);
  }
  return (uint64_t)a1;
}

void sub_1D0DEFE28(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 32);
  if (v3 == v1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(v1 + 8) + 32))(v1 + 8);
    _Unwind_Resume(exception_object);
  }
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1D0DEFE9C(uint64_t a1, CFTypeRef *a2)
{
  if (*a2) {
    CFRelease(*a2);
  }
}

void sub_1D0DEFEB4(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26F3618;
}

void *sub_1D0DEFED4()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F26F3618;
  return result;
}

void sub_1D0DEFF0C()
{
}

uint64_t sub_1D0DEFF24(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 160);
  if (v2)
  {
    *(void *)(a1 + 168) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 136);
  if (v3)
  {
    *(void *)(a1 + 144) = v3;
    operator delete(v3);
  }
  cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)(a1 + 16));

  return a1;
}

uint64_t sub_1D0DEFF78(uint64_t a1)
{
  uint64_t v1 = (cva::DictionaryHandler *)(a1 + 16);
  if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)(a1 + 16), @"DrawDebugFlow"))
  {
    cva::DictionaryHandler::item(&v3, v1, @"DrawDebugFlow");
    cva::ItemHandler::getValue<BOOL>();
  }
  return 0;
}

void sub_1D0DEFFE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1D0DEFFFC(uint64_t a1)
{
  uint64_t v1 = (cva::DictionaryHandler *)(a1 + 16);
  if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)(a1 + 16), @"DrawDebugLandmarksAndBBoxes"))
  {
    cva::DictionaryHandler::item(&v3, v1, @"DrawDebugLandmarksAndBBoxes");
    cva::ItemHandler::getValue<BOOL>();
  }
  return 0;
}

void sub_1D0DF006C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_1D0DF0080(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {

    uint64_t v3 = *(void *)(v2 + 8);
    *(void *)(v2 + 8) = 0;
    if (v3)
    {
      sub_1D0DD86BC((uint64_t *)(v3 + 8));

      MEMORY[0x1D25F16B0](v3, 0x10A0C40079592F6);
    }

    MEMORY[0x1D25F16B0](v2, 0xA0C40069AE433);
  }
  return a1;
}

uint64_t sub_1D0DF011C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    sub_1D0E79664(a1, 0);
  }

  if (*(unsigned char *)(a1 + 80)) {
  if (*(unsigned char *)(a1 + 48))
  }

  uint64_t v2 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v2)
  {

    uint64_t v3 = *(void *)(v2 + 8);
    *(void *)(v2 + 8) = 0;
    if (v3)
    {
      sub_1D0DD86BC((uint64_t *)(v3 + 8));

      MEMORY[0x1D25F16B0](v3, 0x10A0C40079592F6);
    }

    MEMORY[0x1D25F16B0](v2, 0xA0C40069AE433);
  }
  uint64_t v4 = *(atomic_ullong **)(a1 + 24);
  if (v4 && !atomic_fetch_add(v4 + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(atomic_ullong *))(*v4 + 16))(v4);
    if (!*(unsigned char *)(a1 + 16)) {
      return a1;
    }
    goto LABEL_14;
  }
  if (*(unsigned char *)(a1 + 16)) {
LABEL_14:
  }
    sub_1D0E797B4(a1);
  return a1;
}

uint64_t sub_1D0DF0264(uint64_t a1, void *a2, void *a3, void *a4, long long *a5, long long *a6, char a7)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  id v13 = a2;
  id v14 = a3;
  id v15 = a4;
  if (!*(void *)(a1 + 24))
  {
    if (!*(unsigned char *)(a1 + 16))
    {
      *(void *)int buf = operator new(0x30uLL);
      long long v34 = xmmword_1D0E81530;
      strcpy(*(char **)buf, "com.apple.applecva.viewpointcorrection.2");
      sub_1D0DD32E0((void *)a1, 1, (uint64_t)buf);
    }
    *(void *)int buf = a1;
    LOBYTE(v34) = a7;
    id v17 = v14;
    *((void *)&v34 + 1) = v17;
    id v18 = v15;
    id v35 = v18;
    long long v19 = a5[1];
    long long v36 = *a5;
    long long v37 = v19;
    long long v20 = *a6;
    long long v21 = a6[1];
    long long v38 = a5[2];
    long long v39 = v20;
    long long v22 = a6[2];
    long long v40 = v21;
    long long v41 = v22;
    id v23 = v13;
    id v42 = v23;
    int v24 = operator new(0x48uLL);
    v24[1] = 0;
    v24[2] = 0;
    *int v24 = &unk_1F26F4F38;
    v24[3] = &unk_1F26F4188;
    id v25 = v17;
    id v26 = v18;
    id v27 = v23;
    v24[7] = 0;
    float32x2_t v28 = operator new(0xA0uLL);
    *float32x2_t v28 = &unk_1F26F36A8;
    v28[2] = *(void *)buf;
    *((unsigned char *)v28 + 24) = v34;
    void v28[4] = v25;
    v28[5] = v26;
    long long v29 = v39;
    *((_OWORD *)v28 + 5) = v38;
    *((_OWORD *)v28 + 6) = v29;
    long long v30 = v41;
    *((_OWORD *)v28 + 7) = v40;
    *((_OWORD *)v28 + 8) = v30;
    long long v31 = v37;
    *((_OWORD *)v28 + 3) = v36;
    *((_OWORD *)v28 + 4) = v31;
    v28[18] = v27;
    v24[7] = v28;
    operator new();
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  uint64_t v16 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    _os_log_error_impl(&dword_1D0DBD000, v16, OS_LOG_TYPE_ERROR, "Precondition violated: !m_encodingResult.valid()", buf, 2u);
  }

  return 1;
}

void sub_1D0DF07F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15)
{
  operator delete(v17);

  _Unwind_Resume(a1);
}

uint64_t sub_1D0DF0920()
{
  return sub_1D0DF0938();
}

id *sub_1D0DF0938(id *a1)
{
  return a1;
}

uint64_t sub_1D0DF0974(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 8))();
}

void sub_1D0DF0998(uint64_t a1)
{
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  uint64_t v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0DF0A18(uint64_t a1)
{
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  uint64_t v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

uint64_t sub_1D0DF0A84(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = (void *)MEMORY[0x1D25F1DA0]();
  kdebug_trace();
  char v4 = *(unsigned char *)(a1 + 24);
  *(unsigned char *)([*(id *)(v2 + 40) contents] + 120) = v4;
  uint64_t v5 = *(void ***)(v2 + 32);
  CFTypeID v6 = *(void **)(a1 + 32);
  int v7 = *(void **)(a1 + 40);
  id v8 = *(id *)(v2 + 56);
  id v9 = *(id *)(v2 + 64);
  unsigned int v10 = sub_1D0DF58AC(v5, v6, v7, v8, v9, (simd_float3x3 *)(a1 + 48), *(id *)(v2 + 40), *(void **)(a1 + 144));

  if (v10) {
    goto LABEL_3;
  }
  char v11 = *(unsigned char *)(a1 + 24);
  *(unsigned char *)([*(id *)(v2 + 72) contents] + 120) = v11;
  CFIndex v12 = *(void ***)(v2 + 32);
  id v13 = *(void **)(a1 + 32);
  id v14 = *(void **)(a1 + 40);
  id v15 = *(id *)(v2 + 88);
  id v16 = *(id *)(v2 + 96);
  unsigned int v10 = sub_1D0DF58AC(v12, v13, v14, v15, v16, (simd_float3x3 *)(a1 + 96), *(id *)(v2 + 72), *(void **)(a1 + 144));

  if (v10)
  {
LABEL_3:
    if (v10 == 1) {
      uint64_t v17 = 2;
    }
    else {
      uint64_t v17 = v10;
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    id v18 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      long long v20 = off_1E689A510[v10 - 1];
      long long v21 = off_1E689A510[(v17 - 1)];
      int v22 = 136315394;
      id v23 = v20;
      __int16 v24 = 2080;
      id v25 = v21;
      _os_log_error_impl(&dword_1D0DBD000, v18, OS_LOG_TYPE_ERROR, "Running m_flowWarper->apply(textureY, textureCbCr, eye.warpfieldX.texture(), eye.warpfieldY.texture(), leftEye(eye) ? transformLeft : transformRight, *eye.warpParams, commandBuffer) failed with %s, returning %s", (uint8_t *)&v22, 0x16u);
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  kdebug_trace();
  return v17;
}

void sub_1D0DF0D00(_Unwind_Exception *a1)
{
  kdebug_trace();
  _Unwind_Resume(a1);
}

void sub_1D0DF0D3C(id *a1)
{
  operator delete(a1);
}

void sub_1D0DF0D88(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
}

id sub_1D0DF0DCC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F26F36A8;
  uint64_t v4 = *(void *)(a1 + 16);
  *(unsigned char *)(a2 + 24) = *(unsigned char *)(a1 + 24);
  *(void *)(a2 + 16) = v4;
  *(void *)(a2 + 32) = *(id *)(a1 + 32);
  *(void *)(a2 + 40) = *(id *)(a1 + 40);
  long long v5 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(a2 + 48) = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(a2 + 64) = v5;
  long long v6 = *(_OWORD *)(a1 + 128);
  long long v8 = *(_OWORD *)(a1 + 80);
  long long v7 = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(a2 + 112) = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(a2 + 128) = v6;
  *(_OWORD *)(a2 + 80) = v8;
  *(_OWORD *)(a2 + 96) = v7;
  id result = *(id *)(a1 + 144);
  *(void *)(a2 + 144) = result;
  return result;
}

void *sub_1D0DF0E58(uint64_t a1)
{
  uint64_t v2 = operator new(0xA0uLL);
  void *v2 = &unk_1F26F36A8;
  _DWORD v2[2] = *(void *)(a1 + 16);
  *((unsigned char *)v2 + 24) = *(unsigned char *)(a1 + 24);
  v2[4] = *(id *)(a1 + 32);
  v2[5] = *(id *)(a1 + 40);
  long long v3 = *(_OWORD *)(a1 + 96);
  *((_OWORD *)v2 + 5) = *(_OWORD *)(a1 + 80);
  *((_OWORD *)v2 + 6) = v3;
  long long v4 = *(_OWORD *)(a1 + 128);
  *((_OWORD *)v2 + 7) = *(_OWORD *)(a1 + 112);
  *((_OWORD *)v2 + 8) = v4;
  long long v5 = *(_OWORD *)(a1 + 64);
  *((_OWORD *)v2 + 3) = *(_OWORD *)(a1 + 48);
  *((_OWORD *)v2 + 4) = v5;
  v2[18] = *(id *)(a1 + 144);
  return v2;
}

void sub_1D0DF0EF0(id *a1)
{
  JUMPOUT(0x1D25F16B0);
}

id *sub_1D0DF0F4C(id *a1)
{
  return a1;
}

uint64_t sub_1D0DF0F88(void *a1)
{
  uint64_t result = a1[4];
  if (!result)
  {
    a1[4] = 0;
    return result;
  }
  unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)result + 48))(result);
  uint64_t v5 = a1[5];
  if (!v5)
  {
LABEL_12:
    long long v8 = (_Unwind_Exception *)sub_1D0DF0920();
    std::mutex::unlock(v1);
    _Unwind_Resume(v8);
  }
  unsigned int v6 = v4;
  uint64_t v1 = (std::mutex *)(v5 + 24);
  std::mutex::lock((std::mutex *)(v5 + 24));
  if ((*(unsigned char *)(v5 + 136) & 1) != 0
    || (v9.__ptr_ = 0, uint64_t v7 = *(void *)(v5 + 16), std::exception_ptr::~exception_ptr(&v9), v7))
  {
    sub_1D0DF0920();
    __break(1u);
    goto LABEL_12;
  }
  *(void *)(v5 + 140) = v6 | 0x100000000;
  *(_DWORD *)(v5 + 136) |= 5u;
  std::condition_variable::notify_all((std::condition_variable *)(v5 + 88));
  std::mutex::unlock((std::mutex *)(v5 + 24));
  uint64_t result = a1[4];
  a1[4] = 0;
  if ((void *)result == a1 + 1) {
    return (*(uint64_t (**)(void *))(a1[1] + 32))(a1 + 1);
  }
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

void sub_1D0DF10DC(void *a1)
{
  sub_1D0DF1114(a1);
  JUMPOUT(0x1D25F16B0);
}

void *sub_1D0DF1114(void *a1)
{
  *a1 = &unk_1F26F4188;
  uint64_t v2 = a1 + 1;
  if (a1[4])
  {
    uint64_t v3 = a1[5];
    if (v3)
    {
      std::mutex::lock((std::mutex *)(v3 + 24));
      if ((*(unsigned char *)(v3 + 136) & 1) == 0)
      {
        v10[0].__ptr_ = 0;
        uint64_t v4 = *(void *)(v3 + 16);
        std::exception_ptr::~exception_ptr(v10);
        if (!v4)
        {
          *(void *)(v3 + 140) = 0;
          *(_DWORD *)(v3 + 136) |= 5u;
          std::condition_variable::notify_all((std::condition_variable *)(v3 + 88));
          std::mutex::unlock((std::mutex *)(v3 + 24));
          goto LABEL_6;
        }
      }
      sub_1D0DF0920();
    }
    else
    {
      sub_1D0DF0920();
    }
    __break(1u);
    goto LABEL_20;
  }
LABEL_6:
  uint64_t v5 = a1[5];
  if (!v5) {
    goto LABEL_12;
  }
  if ((*(unsigned char *)(v5 + 136) & 1) == 0)
  {
    v10[0].__ptr_ = 0;
    uint64_t v6 = *(void *)(v5 + 16);
    std::exception_ptr::~exception_ptr(v10);
    uint64_t v5 = a1[5];
    if (!v6 && *(uint64_t *)(v5 + 8) >= 1)
    {
LABEL_20:
      std::exception_ptr v9 = std::future_category();
      MEMORY[0x1D25F1310](v10, 4, v9);
      abort();
    }
  }
  if (!atomic_fetch_add((atomic_ullong *volatile)(v5 + 8), 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
  }
LABEL_12:
  uint64_t v7 = (void *)a1[4];
  if (v7 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v7)
  {
    (*(void (**)(void *))(*v7 + 40))(v7);
  }
  return a1;
}

void sub_1D0DF12C0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v3);
  sub_1D0DF12EC(v2);
  sub_1D0DF1398(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1D0DF12EC(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    if ((*(unsigned char *)(v2 + 136) & 1) == 0)
    {
      v6[0].__ptr_ = 0;
      uint64_t v3 = *(void *)(v2 + 16);
      std::exception_ptr::~exception_ptr(v6);
      uint64_t v2 = *a1;
      if (!v3 && *(uint64_t *)(v2 + 8) >= 1)
      {
        uint64_t v5 = std::future_category();
        MEMORY[0x1D25F1310](v6, 4, v5);
        abort();
      }
    }
    if (!atomic_fetch_add((atomic_ullong *volatile)(v2 + 8), 0xFFFFFFFFFFFFFFFFLL)) {
      (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
    }
  }
  return a1;
}

void *sub_1D0DF1398(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1D0DF1424(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1D0DF1448(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4F38;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0DF149C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4F38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_1D0DF14BC(uint64_t a1, float a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    uint64_t v4 = (id *)a1;
    *(void *)(a1 + 24) = 0;
    *(void *)__lint k = v2 + 24;
    __lk[8] = 1;
    std::mutex::lock((std::mutex *)(v2 + 24));
    std::__assoc_sub_state::__sub_wait((std::__assoc_sub_state *)v2, (std::unique_lock<std::mutex> *)__lk);
    int v5 = v2 + 16;
    uint64_t v6 = *(void *)(v2 + 16);
    v14.__ptr_ = 0;
    std::exception_ptr::~exception_ptr(&v14);
    if (v6)
    {
      std::exception_ptr::exception_ptr(&v14, (const std::exception_ptr *)(v2 + 16));
      v13.__ptr_ = &v14;
      std::rethrow_exception(v13);
      __break(1u);
    }
    else
    {
      uint64_t v7 = *(void *)(v2 + 140);
      if (__lk[8]) {
        std::mutex::unlock(*(std::mutex **)__lk);
      }
      if (!atomic_fetch_add((atomic_ullong *volatile)(v2 + 8), 0xFFFFFFFFFFFFFFFFLL)) {
        (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
      }
      if ((v7 & 0xFF00000000) != 0) {
        LODWORD(v6) = v7;
      }
      else {
        LODWORD(v6) = 2;
      }
      int v5 = v6 - 1;
      if (v6 == 1) {
        uint64_t v2 = 2;
      }
      else {
        uint64_t v2 = v6;
      }
      if (!v6)
      {
        *(float *)([v4[5] contents] + 112) = a2;
        uint64_t v2 = 0;
        *(float *)([v4[9] contents] + 112) = a2;
        return v2;
      }
      uint64_t v4 = (id *)0x1EA643000;
      if (atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire)) {
        goto LABEL_15;
      }
    }
    if (__cxa_guard_acquire(&qword_1EA6437C8))
    {
      v4[248] = os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
LABEL_15:
    long long v8 = v4[248];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      if (v6 > 7) {
        char v11 = "Success, no error";
      }
      else {
        char v11 = off_1E689A510[v5];
      }
      if (v2 > 7) {
        CFIndex v12 = "Success, no error";
      }
      else {
        CFIndex v12 = off_1E689A510[(v2 - 1)];
      }
      *(_DWORD *)__lint k = 136315394;
      *(void *)&__lk[4] = v11;
      *(_WORD *)&__lk[12] = 2080;
      *(void *)&__lk[14] = v12;
      _os_log_error_impl(&dword_1D0DBD000, v8, OS_LOG_TYPE_ERROR, "Running m_encodingResult.get().value_or(ViewpointStatus::AssertionFailed) failed with %s, returning %s", __lk, 0x16u);
    }

    return v2;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  std::exception_ptr v9 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)__lint k = 0;
    _os_log_error_impl(&dword_1D0DBD000, v9, OS_LOG_TYPE_ERROR, "Precondition violated: m_encodingResult.valid()", __lk, 2u);
  }

  return 1;
}

void sub_1D0DF1790(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10, std::mutex *a11, char a12)
{
  std::exception_ptr::~exception_ptr(&a10);
  if (a12) {
    std::mutex::unlock(a11);
  }
  if (!atomic_fetch_add(v12 + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(atomic_ullong *))(*v12 + 16))(v12);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1D0DF1B2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float32x4_t sub_1D0DF1B84(float32x2_t *a1, float a2, float a3)
{
  float32x4_t v3 = *(float32x4_t *)(MEMORY[0x1E4F14998] + 16);
  float32x4_t v4 = *(float32x4_t *)(MEMORY[0x1E4F14998] + 32);
  v4.i64[0] = __PAIR64__(LODWORD(a3), LODWORD(a2));
  float32x4_t v5 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*MEMORY[0x1E4F14998], COERCE_FLOAT(*(_OWORD *)a1->f32)), v3, *a1, 1), v4, *(float32x4_t *)a1->f32, 2);
  float32x4_t result = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*MEMORY[0x1E4F14998], COERCE_FLOAT(*(_OWORD *)a1[2].f32)), v3, a1[2], 1), v4, *(float32x4_t *)a1[2].f32, 2);
  float32x4_t v7 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*MEMORY[0x1E4F14998], COERCE_FLOAT(*(_OWORD *)a1[4].f32)), v3, a1[4], 1), v4, *(float32x4_t *)a1[4].f32, 2);
  a1[1].i32[0] = v5.i32[2];
  *a1 = *(float32x2_t *)v5.f32;
  a1[3].i32[0] = result.i32[2];
  a1[2] = *(float32x2_t *)result.f32;
  a1[5].i32[0] = v7.i32[2];
  a1[4] = *(float32x2_t *)v7.f32;
  return result;
}

__n64 sub_1D0DF1BF0(uint64_t a1, float **a2)
{
  float32x4_t v3 = *a2;
  if (*a2 == (float *)a1 || (float32x4_t v4 = a2[1], v4 == (float *)a1))
  {
    int v9 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    sub_1D0DF1BF0(&v7);
    result.n64_u64[0] = v7;
    long long v6 = v8;
    *(_OWORD *)a1 = v7;
    *(_OWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 32) = v9;
  }
  else
  {
    result.n64_u32[1] = 0;
    *(float *)a1 = (float)((float)((float)(*v3 * *v4) + 0.0) + (float)(v3[3] * v4[1])) + (float)(v3[6] * v4[2]);
    *(float *)(a1 + 4) = (float)((float)((float)(v3[1] * *v4) + 0.0) + (float)(v3[4] * v4[1])) + (float)(v3[7] * v4[2]);
    *(float *)(a1 + 8) = (float)((float)((float)(v3[2] * *v4) + 0.0) + (float)(v3[5] * v4[1])) + (float)(v3[8] * v4[2]);
    *(float *)(a1 + 12) = (float)((float)((float)(*v3 * v4[3]) + 0.0) + (float)(v3[3] * v4[4])) + (float)(v3[6] * v4[5]);
    *(float *)(a1 + 16) = (float)((float)((float)(v3[1] * v4[3]) + 0.0) + (float)(v3[4] * v4[4]))
                        + (float)(v3[7] * v4[5]);
    *(float *)(a1 + 20) = (float)((float)((float)(v3[2] * v4[3]) + 0.0) + (float)(v3[5] * v4[4]))
                        + (float)(v3[8] * v4[5]);
    *(float *)(a1 + 24) = (float)((float)((float)(*v3 * v4[6]) + 0.0) + (float)(v3[3] * v4[7])) + (float)(v3[6] * v4[8]);
    *(float *)(a1 + 28) = (float)((float)((float)(v3[1] * v4[6]) + 0.0) + (float)(v3[4] * v4[7]))
                        + (float)(v3[7] * v4[8]);
    result.n64_f32[0] = (float)((float)((float)(v3[2] * v4[6]) + 0.0) + (float)(v3[5] * v4[7])) + (float)(v3[8] * v4[8]);
    *(_DWORD *)(a1 + 32) = result.n64_u32[0];
  }
  return result;
}

float *sub_1D0DF1DA0(float *result, float **a2)
{
  uint64_t v2 = result;
  float32x4_t v3 = *a2;
  if (*a2 == result || (float32x4_t v4 = a2[1], v4 == result))
  {
    int v6 = 0;
    uint64_t v5 = 0;
    __n64 result = (float *)sub_1D0DF1DA0(&v5);
    *(void *)uint64_t v2 = v5;
    *((_DWORD *)v2 + 2) = v6;
  }
  else
  {
    *__n64 result = (float)((float)((float)(*v3 * *v4) + 0.0) + (float)(v3[3] * v4[1])) + (float)(v3[6] * v4[2]);
    result[1] = (float)((float)((float)(v3[1] * *v4) + 0.0) + (float)(v3[4] * v4[1])) + (float)(v3[7] * v4[2]);
    result[2] = (float)((float)((float)(v3[2] * *v4) + 0.0) + (float)(v3[5] * v4[1])) + (float)(v3[8] * v4[2]);
  }
  return result;
}

void sub_1D0DF1E74()
{
}

float32x2_t sub_1D0DF1E8C(uint64_t a1, float32x2_t *a2, float32x2_t result, double a4, double a5)
{
  if (a1)
  {
    if (a1 <= 0) {
      sub_1D0DE222C();
    }
    float32x2_t v6 = *a2;
    uint64_t v5 = a2 + 1;
    float32x2_t v7 = v6;
    float32x2_t v8 = v6;
    uint64_t v9 = a1 - 1;
    if (a1 != 1)
    {
      do
      {
        float32x2_t v10 = *v5++;
        HIDWORD(a5) = v10.i32[1];
        float32x2_t v7 = vminnm_f32(v7, v10);
        float32x2_t v8 = vmaxnm_f32(v8, v10);
        --v9;
      }
      while (v9);
    }
    float32x2_t v11 = vsub_f32(v8, v7);
    LODWORD(a5) = v11.i32[1];
    if (v11.f32[0] >= v11.f32[1]) {
      *(float *)&a5 = v11.f32[0];
    }
    return vadd_f32(v7, vmul_f32(vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0), v11), (float32x2_t)0xBF000000BF000000));
  }
  return result;
}

uint64_t sub_1D0DF1F0C(const __CFString *a1, void *a2, cva::DictionaryHandler *a3)
{
  uint64_t v5 = a2;
  size_t Width = IOSurfaceGetWidth(v5);
  size_t Height = IOSurfaceGetHeight(v5);
  OSType PixelFormat = IOSurfaceGetPixelFormat(v5);
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int valuePtr = IOSurfaceGetBytesPerRow(v5);
  CFNumberRef v11 = CFNumberCreate(v9, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24C98], v11);
  CFRelease(v11);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24D40], (const void *)*MEMORY[0x1E4F1CFD0]);
  pixelBuffer[0] = 0;
  if (CVPixelBufferCreate(v9, Width, Height, PixelFormat, Mutable, pixelBuffer)) {
    goto LABEL_20;
  }
  CVPixelBufferLockBaseAddress(pixelBuffer[0], 0);
  IOSurfaceLock(v5, 1u, 0);
  BaseAddress = IOSurfaceGetBaseAddress(v5);
  uint64_t v16 = CVPixelBufferGetBaseAddress(pixelBuffer[0]);
  memcpy(v16, BaseAddress, Height * valuePtr);
  IOSurfaceUnlock(v5, 1u, 0);
  CVPixelBufferUnlockBaseAddress(pixelBuffer[0], 0);
  uint64_t v17 = pixelBuffer[0];
  if (!pixelBuffer[0])
  {
LABEL_20:
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    CFIndex v12 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_4;
    }
    LOWORD(pixelBuffer[0]) = 0;
    long long v19 = "Assertion failed: pixelBuffer";
    goto LABEL_13;
  }
  cva::ItemHandler::ItemHandler((cva::ItemHandler *)pixelBuffer, pixelBuffer[0]);
  char v18 = cva::DictionaryHandler::setItem(a3, a1, (const cva::ItemHandler *)pixelBuffer);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)pixelBuffer);
  if (v18)
  {
    CVPixelBufferRelease(v17);
    uint64_t v13 = 0;
    goto LABEL_5;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  CFIndex v12 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    LOWORD(pixelBuffer[0]) = 0;
    long long v19 = "Assertion failed: dictionary.setItem(key, cva::ItemHandler(pixelBuffer, false))";
LABEL_13:
    _os_log_error_impl(&dword_1D0DBD000, v12, OS_LOG_TYPE_ERROR, v19, (uint8_t *)pixelBuffer, 2u);
  }
LABEL_4:

  uint64_t v13 = 2;
LABEL_5:

  return v13;
}

void sub_1D0DF21F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)&a9);

  _Unwind_Resume(a1);
}

uint64_t sub_1D0DF2218(uint64_t a1, int a2, cva::DictionaryHandler *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  BOOL v5 = a2 == 0;
  if (a2) {
    float32x2_t v6 = "cropLeft";
  }
  else {
    float32x2_t v6 = "cropRight";
  }
  if (v5) {
    size_t v7 = 9;
  }
  else {
    size_t v7 = 8;
  }
  char v26 = v7;
  memcpy(__dst, v6, v7);
  *((unsigned char *)__dst + v7) = 0;
  id v8 = *(id *)(a1 + 160);
  unint64_t v9 = [v8 width];
  float v22 = (float)(unint64_t)[*(id *)(a1 + 160) height];

  simd_float3x3 v31 = __invert_f3(*(simd_float3x3 *)a1);
  float32x4_t v10 = vmulq_f32((float32x4_t)v31.columns[0], (float32x4_t)0);
  int32x4_t v11 = (int32x4_t)vaddq_f32((float32x4_t)v31.columns[2], vmlaq_f32(v10, (float32x4_t)0, (float32x4_t)v31.columns[1]));
  int32x4_t v12 = (int32x4_t)vaddq_f32((float32x4_t)v31.columns[2], vmlaq_n_f32(v10, (float32x4_t)v31.columns[1], v22));
  v31.columns[0] = (simd_float3)vmulq_n_f32((float32x4_t)v31.columns[0], (float)v9);
  int32x4_t v13 = (int32x4_t)vaddq_f32((float32x4_t)v31.columns[2], vmlaq_n_f32((float32x4_t)v31.columns[0], (float32x4_t)v31.columns[1], v22));
  v31.columns[0] = (simd_float3)vaddq_f32((float32x4_t)v31.columns[2], vmlaq_f32((float32x4_t)v31.columns[0], (float32x4_t)0, (float32x4_t)v31.columns[1]));
  *(float32x2_t *)int buf = vdiv_f32(*(float32x2_t *)v11.i8, (float32x2_t)vdup_laneq_s32(v11, 2));
  *(float32x2_t *)&uint8_t buf[8] = vdiv_f32(*(float32x2_t *)v12.i8, (float32x2_t)vdup_laneq_s32(v12, 2));
  *(float32x2_t *)&uint8_t buf[16] = vdiv_f32(*(float32x2_t *)v13.i8, (float32x2_t)vdup_laneq_s32(v13, 2));
  float32x2_t v29 = vdiv_f32(*(float32x2_t *)v31.columns[0].f32, (float32x2_t)vdup_laneq_s32((int32x4_t)v31.columns[0], 2));
  unsigned int v14 = sub_1D0DF27D4((uint64_t)__dst, 4, (uint64_t *)buf, a3);
  if (v26 < 0) {
    operator delete(__dst[0]);
  }
  if (v14 == 1) {
    uint64_t v15 = 2;
  }
  else {
    uint64_t v15 = v14;
  }
  if (!v14)
  {
    int8x16_t v23 = *(int8x16_t *)(a1 + 16);
    int8x16_t v24 = *(int8x16_t *)a1;
    long long v21 = *(_OWORD *)(a1 + 32);
    *(void *)&uint8_t buf[8] = 16;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, 0x40uLL, 0x49090899uLL);
    long long v19 = (int32x2_t *)memptr;
    *(void *)int buf = memptr;
    *(void *)&uint8_t buf[16] = 0x300000003;
    *(int32x2_t *)memptr = vzip1_s32(*(int32x2_t *)v24.i8, *(int32x2_t *)v23.i8);
    v19[1] = (int32x2_t)__PAIR64__(v24.u32[1], v21);
    v19[2] = vzip2_s32(*(int32x2_t *)v23.i8, *(int32x2_t *)&v21);
    v19[3] = vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL));
    v19[4].i32[0] = DWORD2(v21);
    cva::ItemHandler::createMatrix<float>();
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA6437C8))
  {
    qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
    __cxa_guard_release(&qword_1EA6437C8);
  }
  uint64_t v16 = (id)qword_1EA6437C0;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    uint64_t v17 = off_1E689A510[v14 - 1];
    char v18 = off_1E689A510[(v15 - 1)];
    *(_DWORD *)int buf = 136315394;
    *(void *)&uint8_t buf[4] = v17;
    *(_WORD *)&uint8_t buf[12] = 2080;
    *(void *)&buf[14] = v18;
    _os_log_error_impl(&dword_1D0DBD000, v16, OS_LOG_TYPE_ERROR, "Running addPoints(isLeftEye ? \"cropLeft\" : \"cropRight\", eyeCrop.cropCorners(), dictionary) failed with %s, returning %s", buf, 0x16u);
  }

  return v15;
}

void sub_1D0DF2768(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)va);
  _Unwind_Resume(a1);
}

void sub_1D0DF2788(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
}

void sub_1D0DF279C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D0DF27D4(uint64_t a1, uint64_t a2, uint64_t *a3, cva::DictionaryHandler *a4)
{
  cva::ArrayHandler::ArrayHandler((cva::ArrayHandler *)v14);
  if (a2)
  {
    uint64_t v8 = *a3;
    uint64_t v16 = 8;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, 0x20uLL, 0x49090899uLL);
    *(void *)int buf = memptr;
    int v17 = 2;
    *(void *)memptr = v8;
    cva::ItemHandler::createVector<float>();
  }
  cva::ItemHandler::ItemHandler();
  if (*(char *)(a1 + 23) >= 0) {
    unint64_t v9 = (const char *)a1;
  }
  else {
    unint64_t v9 = *(const char **)a1;
  }
  char v10 = cva::DictionaryHandler::setItem(a4, v9, (const cva::ItemHandler *)buf);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)buf);
  if (v10)
  {
    uint64_t v11 = 0;
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    int32x4_t v12 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v12, OS_LOG_TYPE_ERROR, "Assertion failed: dictionary.setItem(name, cva::ItemHandler(pointsHandler))", buf, 2u);
    }

    uint64_t v11 = 2;
  }
  cva::ArrayHandler::~ArrayHandler((cva::ArrayHandler *)v14);
  return v11;
}

void sub_1D0DF2A10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *a13)
{
}

uint64_t sub_1D0DF2A58(uint64_t a1, uint64_t *a2, cva::DictionaryHandler *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  char v13 = 9;
  strcpy(__p, "landmarks");
  unsigned int v3 = sub_1D0DF27D4((uint64_t)__p, a1, a2, a3);
  if (v13 < 0) {
    operator delete(*(void **)__p);
  }
  unsigned int v4 = v3 - 1;
  if (v3 == 1) {
    uint64_t v5 = 2;
  }
  else {
    uint64_t v5 = v3;
  }
  if (v3)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    float32x2_t v6 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = off_1E689A510[v4];
      unint64_t v9 = off_1E689A510[(v5 - 1)];
      *(_DWORD *)__p = 136315394;
      *(void *)&__p[4] = v8;
      __int16 v11 = 2080;
      int32x4_t v12 = v9;
      _os_log_error_impl(&dword_1D0DBD000, v6, OS_LOG_TYPE_ERROR, "Running addPoints(\"landmarks\", landmarks, dictionary) failed with %s, returning %s", __p, 0x16u);
    }
  }
  return v5;
}

void sub_1D0DF2BCC(_Unwind_Exception *exception_object)
{
}

void sub_1D0DF2BD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D0DF2BF4(void *a1, uint64_t a2, unsigned int a3, uint64_t a4, void *a5, void *a6, __n128 a7)
{
  uint64_t v29 = a4;
  id v11 = a5;
  id v12 = a6;
  __n128 v28 = a7;
  if (!v12)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    int8x16_t v23 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_13;
    }
    *(_WORD *)int buf = 0;
    int8x16_t v24 = "No command buffer provided.";
    goto LABEL_22;
  }
  if (!v11 || ![v11 width] || !objc_msgSend(v11, "height"))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    int8x16_t v23 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_13;
    }
    *(_WORD *)int buf = 0;
    int8x16_t v24 = "No or empty texture provided.";
    goto LABEL_22;
  }
  if ([v11 pixelFormat] != *a1)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    int8x16_t v23 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_13;
    }
    *(_WORD *)int buf = 0;
    int8x16_t v24 = "Mismatching texture pixel format.";
    goto LABEL_22;
  }
  if (!a2)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    int8x16_t v23 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_13;
    }
    *(_WORD *)int buf = 0;
    int8x16_t v24 = "Null or 0 vertices provided.";
LABEL_22:
    _os_log_error_impl(&dword_1D0DBD000, v23, OS_LOG_TYPE_ERROR, v24, buf, 2u);
LABEL_13:

    uint64_t v22 = 1;
    goto LABEL_14;
  }
  unint64_t v13 = [v11 width];
  unint64_t v14 = [v11 height];
  *(float *)&uint64_t v15 = (float)v13;
  *((float *)&v15 + 1) = (float)v14;
  *(void *)int buf = v15;
  uint64_t v16 = objc_opt_new();
  int v17 = [v16 colorAttachments];
  char v18 = [v17 objectAtIndexedSubscript:0];
  [v18 setLoadAction:1];

  long long v19 = [v16 colorAttachments];
  long long v20 = [v19 objectAtIndexedSubscript:0];
  [v20 setTexture:v11];

  long long v21 = [v12 renderCommandEncoderWithDescriptor:v16];
  [v21 setLabel:@"DebugRenderer"];
  [v21 setRenderPipelineState:a1[1]];
  [v21 setVertexBytes:a2 length:8 * a3 atIndex:0];
  [v21 setVertexBytes:buf length:8 atIndex:1];
  [v21 setVertexBytes:&v29 length:8 atIndex:2];
  [v21 setFragmentBytes:&v29 length:8 atIndex:2];
  [v21 setFragmentBytes:&v28 length:16 atIndex:3];
  [v21 drawPrimitives:v29 vertexStart:0 vertexCount:a3];
  [v21 endEncoding];

  uint64_t v22 = 0;
LABEL_14:

  return v22;
}

void sub_1D0DF3008(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D0DF305C(id *a1, void *a2, id *a3)
{
  id v5 = a2;
  uint64_t v6 = [v5 pixelFormat];
  id v12 = v5;
  if (!*a3
    || (uint64_t v7 = [*a3 width], v7 != objc_msgSend(v12, "width"))
    || (uint64_t v8 = [*a3 height], v8 != objc_msgSend(v12, "height"))
    || [*a3 pixelFormat] != v6
    || [*a3 usage] != 3)
  {
    unint64_t v9 = objc_msgSend(MEMORY[0x1E4F35330], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", v6, objc_msgSend(v12, "width"), objc_msgSend(v12, "height"), 0);
    [v9 setUsage:3];
    [v9 setStorageMode:2];
    uint64_t v10 = [*a1 newTextureWithDescriptor:v9];
    id v11 = *a3;
    *a3 = (id)v10;
  }
}

void sub_1D0DF3194(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DF31C4(uint64_t a1, CVPixelBufferRef pixelBuffer, MTLPixelFormat a3, size_t planeIndex, uint64_t a5, uint64_t a6)
{
  v38[1] = *MEMORY[0x1E4F143B8];
  size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(pixelBuffer, planeIndex);
  size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(pixelBuffer, planeIndex);
  if (!WidthOfPlane || (size_t v14 = HeightOfPlane) == 0)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v16 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(textureOut) = 0;
      _os_log_error_impl(&dword_1D0DBD000, v16, OS_LOG_TYPE_ERROR, "Precondition violated: width && height", (uint8_t *)&textureOut, 2u);
    }
    uint64_t v22 = 1;
    goto LABEL_20;
  }
  uint64_t v37 = *MEMORY[0x1E4F24C88];
  uint64_t v15 = [NSNumber numberWithUnsignedInteger:a5];
  v38[0] = v15;
  uint64_t v16 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v38 forKeys:&v37 count:1];

  v33[0] = &unk_1F26F4670;
  v33[3] = v33;
  CVMetalTextureRef textureOut = 0;
  long long v36 = v35;
  v35[0] = &unk_1F26F4670;
  int v17 = *(__CVMetalTextureCache **)(a1 + 8);
  if (!v17)
  {
    if (CVMetalTextureCacheCreate(0, 0, *(id *)a1, 0, (CVMetalTextureCacheRef *)(a1 + 8)))
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      int8x16_t v23 = (id)qword_1EA6437C0;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int buf = 0;
        _os_log_error_impl(&dword_1D0DBD000, v23, OS_LOG_TYPE_ERROR, "Assertion failed: CVMetalTextureCacheCreate(NULL, NULL, m_device, NULL, m_metalTextureCache.fill()) == kCVReturnSuccess", buf, 2u);
      }

      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
      char v18 = (id)qword_1EA6437C0;
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        goto LABEL_18;
      }
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = "Error running operation on the GPU";
      __int16 v31 = 2080;
      CFTypeID v32 = "Error running operation on the GPU";
      long long v19 = "Running createMetalTextureCache() failed with %s, returning %s";
      long long v20 = v18;
      uint32_t v21 = 22;
      goto LABEL_43;
    }
    int v17 = *(__CVMetalTextureCache **)(a1 + 8);
    if (textureOut)
    {
      *(void *)int buf = textureOut;
      if (!v36) {
        goto LABEL_52;
      }
      (*(void (**)(void *, unsigned char *))(*v36 + 48))(v36, buf);
      CVMetalTextureRef textureOut = 0;
    }
  }
  if (CVMetalTextureCacheCreateTextureFromImage(0, v17, pixelBuffer, (CFDictionaryRef)v16, a3, WidthOfPlane, v14, planeIndex, &textureOut))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0)
    {
      if (__cxa_guard_acquire(&qword_1EA6437C8))
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
      }
    }
    char v18 = (id)qword_1EA6437C0;
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_18;
    }
    *(_WORD *)int buf = 0;
    long long v19 = "Could not create texture from image";
    long long v20 = v18;
    uint32_t v21 = 2;
LABEL_43:
    _os_log_error_impl(&dword_1D0DBD000, v20, OS_LOG_TYPE_ERROR, v19, buf, v21);
LABEL_18:

    uint64_t v22 = 6;
LABEL_19:
    sub_1D0DE29C8((uint64_t *)&textureOut);
LABEL_20:

    return v22;
  }
  if (&textureOut == (CVMetalTextureRef *)a6) {
    goto LABEL_41;
  }
  if (!*(void *)a6)
  {
LABEL_25:
    *(void *)a6 = textureOut;
    uint64_t v26 = a6 + 8;
    uint64_t v27 = *(void *)(a6 + 32);
    *(void *)(a6 + 32) = 0;
    if (v27 == a6 + 8)
    {
      (*(void (**)(uint64_t))(*(void *)v26 + 32))(a6 + 8);
      __n128 v28 = v36;
      if (v36)
      {
LABEL_29:
        if (v28 != v35)
        {
          uint64_t v22 = 0;
          *(void *)(a6 + 32) = v28;
LABEL_36:
          CVMetalTextureRef textureOut = 0;
          long long v36 = 0;
          goto LABEL_19;
        }
        *(void *)(a6 + 32) = v26;
        (*(void (**)(void *, uint64_t))(v35[0] + 24))(v35, a6 + 8);
        uint64_t v29 = v36;
        CVMetalTextureRef textureOut = 0;
        long long v36 = 0;
        if (v29 == v35)
        {
          (*(void (**)(void *))(v35[0] + 32))(v35);
        }
        else if (v29)
        {
          (*(void (**)(void *))(*v29 + 40))(v29);
        }
LABEL_41:
        uint64_t v22 = 0;
        goto LABEL_19;
      }
    }
    else
    {
      if (v27) {
        (*(void (**)(uint64_t))(*(void *)v27 + 40))(v27);
      }
      __n128 v28 = v36;
      if (v36) {
        goto LABEL_29;
      }
    }
    uint64_t v22 = 0;
    *(void *)(a6 + 32) = 0;
    goto LABEL_36;
  }
  *(void *)int buf = *(void *)a6;
  uint64_t v25 = *(void *)(a6 + 32);
  if (v25)
  {
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v25 + 48))(v25, buf);
    *(void *)a6 = 0;
    goto LABEL_25;
  }
LABEL_52:
  uint64_t result = sub_1D0DD8808();
  __break(1u);
  return result;
}

void sub_1D0DF37D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  sub_1D0DE29C8((uint64_t *)va);

  _Unwind_Resume(a1);
}

uint64_t sub_1D0DF3804(id *a1, void *a2, uint64_t a3, int a4, id *a5)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v9 = a2;
  uint64_t v10 = v9;
  if (v9)
  {
    if (a4)
    {
      [v9 lockWithOptions:0 seed:0];
      id v11 = v10;
      bzero((void *)[v11 baseAddress], objc_msgSend(v11, "allocationSize"));
      [v11 unlockWithOptions:0 seed:0];
    }
    int v12 = [v10 pixelFormat];
    if (v12 == 1278226536)
    {
      uint64_t v13 = 25;
      goto LABEL_12;
    }
    if (v12 == 1278226534)
    {
      uint64_t v13 = 55;
LABEL_12:
      uint64_t v16 = [v10 width];
      uint64_t v17 = [v10 height];
      size_t v14 = [MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:v13 width:v16 height:v17 mipmapped:0];
      [v14 setUsage:a3];
      char v18 = (void *)[*a1 newTextureWithDescriptor:v14 iosurface:v10 plane:0];
      long long v19 = v18;
      if (v18)
      {
        long long v20 = v18;
        if ([v20 iosurface])
        {
          objc_storeStrong(a5, v19);
          uint64_t v15 = 0;
        }
        else
        {
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EA6437C8))
          {
            qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
            __cxa_guard_release(&qword_1EA6437C8);
          }
          uint32_t v21 = (id)qword_1EA6437C0;
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v23) = 0;
            _os_log_error_impl(&dword_1D0DBD000, v21, OS_LOG_TYPE_ERROR, "Precondition violated: texture.iosurface", (uint8_t *)&v23, 2u);
          }

          uint64_t v15 = 1;
        }
      }
      else
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EA6437C8))
        {
          qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
          __cxa_guard_release(&qword_1EA6437C8);
        }
        long long v20 = (id)qword_1EA6437C0;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v23) = 0;
          uint64_t v15 = 2;
          _os_log_error_impl(&dword_1D0DBD000, v20, OS_LOG_TYPE_ERROR, "Assertion failed: texture", (uint8_t *)&v23, 2u);
        }
        else
        {
          uint64_t v15 = 2;
        }
      }

      goto LABEL_27;
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    size_t v14 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      int v23 = 136315394;
      int8x16_t v24 = "Operation is not implemented yet";
      __int16 v25 = 2080;
      uint64_t v26 = "Operation is not implemented yet";
      _os_log_error_impl(&dword_1D0DBD000, v14, OS_LOG_TYPE_ERROR, "Running MTLPixelFormatFromCVPixelFormat(surface.pixelFormat, format) failed with %s, returning %s", (uint8_t *)&v23, 0x16u);
    }
    uint64_t v15 = 4;
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    size_t v14 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v23) = 0;
      _os_log_error_impl(&dword_1D0DBD000, v14, OS_LOG_TYPE_ERROR, "Precondition violated: surface", (uint8_t *)&v23, 2u);
    }
    uint64_t v15 = 1;
  }
LABEL_27:

  return v15;
}

void sub_1D0DF3C24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DF3C68(void *a1, void *a2, int a3, int a4)
{
  id v7 = a1;
  id v8 = a2;
  unint64_t v9 = [v8 threadExecutionWidth];
  unint64_t v10 = [v8 maxTotalThreadsPerThreadgroup];
  if (v9 - 1 >= v10)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    int v12 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v12, OS_LOG_TYPE_ERROR, "threadsPerGroup looks strange", buf, 2u);
    }

    uint64_t v11 = 2;
  }
  else
  {
    v15[0] = a3;
    v15[1] = a4;
    v15[2] = 1;
    v14[0] = v9;
    v14[1] = v10 / v9;
    v14[2] = 1;
    [v7 dispatchThreads:v15 threadsPerThreadgroup:v14];
    uint64_t v11 = 0;
  }

  return v11;
}

void sub_1D0DF3DB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D0DF3DCC(uint64_t a1, CFTypeRef *a2)
{
  if (*a2) {
    CFRelease(*a2);
  }
}

void sub_1D0DF3DE4(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26F46B8;
}

void *sub_1D0DF3E04()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F26F46B8;
  return result;
}

void sub_1D0DF3E3C()
{
}

uint64_t sub_1D0DF3E54(id *a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    objc_storeStrong(a1, a2);
    uint64_t v5 = 0;
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v6 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v8 = 0;
      _os_log_error_impl(&dword_1D0DBD000, v6, OS_LOG_TYPE_ERROR, "Precondition violated: device", v8, 2u);
    }

    uint64_t v5 = 1;
  }

  return v5;
}

void sub_1D0DF3F48(void **a1, unint64_t a2)
{
  id v4 = a1[1];
  uint64_t v5 = a1[2];
  if (0xAAAAAAAAAAAAAAABLL * ((v5 - (unsigned char *)v4) >> 4) >= a2)
  {
    if (a2)
    {
      uint64_t v11 = &v4[3 * a2];
      do
      {
        v4[1] = 0uLL;
        v4[2] = 0uLL;
        _OWORD *v4 = 0uLL;
        *((void *)v4 + 2) = 0x7FF8000000000000;
        v4 += 3;
      }
      while (v4 != v11);
      id v4 = v11;
    }
    a1[1] = v4;
  }
  else
  {
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * (((char *)v4 - (unsigned char *)*a1) >> 4);
    unint64_t v7 = v6 + a2;
    if (v6 + a2 > 0x555555555555555) {
      abort();
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (unsigned char *)*a1) >> 4);
    if (2 * v8 > v7) {
      unint64_t v7 = 2 * v8;
    }
    if (v8 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v9 = 0x555555555555555;
    }
    else {
      unint64_t v9 = v7;
    }
    if (v9)
    {
      if (v9 > 0x555555555555555) {
        sub_1D0DE8CE0();
      }
      unint64_t v10 = (char *)operator new(48 * v9);
    }
    else
    {
      unint64_t v10 = 0;
    }
    int v12 = &v10[48 * v6];
    uint64_t v13 = &v12[48 * a2];
    size_t v14 = v12;
    do
    {
      *((_OWORD *)v14 + 1) = 0uLL;
      *((_OWORD *)v14 + 2) = 0uLL;
      *(_OWORD *)size_t v14 = 0uLL;
      *((void *)v14 + 2) = 0x7FF8000000000000;
      v14 += 48;
    }
    while (v14 != v13);
    uint64_t v15 = &v10[48 * v9];
    uint64_t v17 = (char *)*a1;
    uint64_t v16 = (char *)a1[1];
    if (v16 != *a1)
    {
      do
      {
        long long v18 = *((_OWORD *)v16 - 3);
        long long v19 = *((_OWORD *)v16 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v16 - 2);
        *((_OWORD *)v12 - 1) = v19;
        *((_OWORD *)v12 - 3) = v18;
        v12 -= 48;
        v16 -= 48;
      }
      while (v16 != v17);
      uint64_t v16 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v13;
    a1[2] = v15;
    if (v16)
    {
      operator delete(v16);
    }
  }
}

float sub_1D0DF40DC(float *a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  float v1 = a1[75] + a1[75];
  float v2 = 1.0;
  BOOL v10 = v1 < 1.0;
  float v3 = (float)((float)((float)(v1 + -1.0) * (float)((float)(v1 + -1.0) + -2.0)) + -1.0) * -0.5;
  float v4 = v1 * (float)(v1 * 0.5);
  if (v10) {
    float v5 = v4;
  }
  else {
    float v5 = v3;
  }
  float v6 = a1[16] - a1[120];
  if (fabsf(v6 + (float)(floorf((float)(v6 + 180.0) / 360.0) * -360.0)) >= 60.0 || fabsf(a1[17]) >= 90.0) {
    float v2 = 0.0;
  }
  float v7 = a1[136];
  float v8 = v7 * 22.0;
  float v9 = v7 * 17.0;
  BOOL v10 = (float)(v7 * 17.0) < (float)(v7 * 22.0) && v8 < 180.0;
  if (v10)
  {
    float v13 = a1[122];
    float v14 = (float)(v13 - v9) / (float)(v8 - v9);
    if (v14 <= 1.0) {
      float v15 = (float)(v13 - v9) / (float)(v8 - v9);
    }
    else {
      float v15 = 1.0;
    }
    BOOL v10 = v14 < 0.0;
    float v16 = 0.0;
    if (v10) {
      float v15 = 0.0;
    }
    float v17 = (float)(v13 + -180.0) / 20.0;
    if (v17 <= 1.0) {
      float v16 = 1.0 - v17;
    }
    if (v17 >= 0.0) {
      float v12 = v16;
    }
    else {
      float v12 = 1.0;
    }
    if (v12 >= v15) {
      float v12 = v15;
    }
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v11 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v19 = 134218752;
      double v20 = v9;
      __int16 v21 = 2048;
      double v22 = v8;
      __int16 v23 = 2048;
      uint64_t v24 = 0x4066800000000000;
      __int16 v25 = 2048;
      uint64_t v26 = 0x4069000000000000;
      _os_log_impl(&dword_1D0DBD000, v11, OS_LOG_TYPE_DEFAULT, "Face distance fadeout thresholds (%f, %f), (%f %f) should be in increasing order.", (uint8_t *)&v19, 0x2Au);
    }

    float v12 = 0.0;
  }
  return v5 * (float)(v2 * v12);
}

float sub_1D0DF433C(uint64_t a1)
{
  float v2 = sub_1D0DF40DC((float *)a1);
  int v4 = *(_DWORD *)(a1 + 284);
  if (v4)
  {
    if (v4 < 1)
    {
      float32x4_t v7 = 0uLL;
    }
    else
    {
      int v5 = *(_DWORD *)(a1 + 280);
      uint64_t v6 = *(void *)(a1 + 256);
      float32x4_t v7 = 0uLL;
      int v8 = *(_DWORD *)(a1 + 284);
      do
      {
        float32x4_t v3 = *(float32x4_t *)(v6 + 48 * v5);
        float32x4_t v7 = vaddq_f32(v7, v3);
        int v5 = (v5 + 1) % (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 264) - v6) >> 4));
        --v8;
      }
      while (v8);
    }
    v3.f32[0] = (float)v4;
    float32x4_t v9 = vdivq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 0));
  }
  else
  {
    v9.i64[0] = 0;
    v9.i32[2] = 0;
  }
  float v10 = (float)(fabsf(v9.f32[2]) + -30.0) / 15.0;
  float v11 = 1.0 - v10;
  if (v10 > 1.0) {
    float v11 = 0.0;
  }
  float32x2_t v12 = vdiv_f32(vadd_f32(vabs_f32(*(float32x2_t *)v9.f32), (float32x2_t)0xC1600000C1F00000), (float32x2_t)0x4160000041700000);
  __asm { FMOV            V7.2S, #1.0 }
  float32x2_t v18 = (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v12), (int8x8_t)_D7, vbic_s8((int8x8_t)vsub_f32(_D7, v12), (int8x8_t)vcgt_f32(v12, _D7)));
  LODWORD(v19) = vmul_lane_f32(v18, v18, 1).u32[0];
  if (v10 >= 0.0) {
    float v20 = v11;
  }
  else {
    float v20 = 1.0;
  }
  float v21 = v2 * (float)(v20 * v19);
  float v22 = (float)(*(float *)(a1 + 352) + -0.1875) * 8.0;
  float v23 = 1.0 - v22;
  if (v22 > 1.0) {
    float v23 = 0.0;
  }
  if (v22 >= 0.0) {
    float v24 = v23;
  }
  else {
    float v24 = 1.0;
  }
  return v21 * v24;
}

uint64_t sub_1D0DF4478(uint64_t a1, float32x2_t *a2, uint64_t a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  int v5 = (_OWORD *)(a1 + 72);
  if (!*(unsigned char *)(a1 + 216))
  {
    *(unsigned char *)(a1 + 200) = 0;
    *(unsigned char *)(a1 + 208) = 0;
    *int v5 = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 136) = 0u;
    *(_OWORD *)(a1 + 152) = 0u;
    uint64_t v6 = MEMORY[0x1E4F1F9F8];
    *(_OWORD *)(a1 + 176) = *MEMORY[0x1E4F1F9F8];
    *(void *)(a1 + 192) = *(void *)(v6 + 16);
    *(unsigned char *)(a1 + 216) = 1;
  }
  *(void *)(a1 + 168) = 0x3FA999999999999ALL;
  *(_OWORD *)int buf = *(_OWORD *)a3;
  *(void *)&uint8_t buf[16] = *(void *)(a3 + 16);
  int v7 = sub_1D0DD8230(a1 + 176, (long long *)buf);
  BOOL v8 = v7 != 0;
  if (v7)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0)
    {
      BOOL v32 = v7 != 0;
      int v33 = __cxa_guard_acquire(&qword_1EA6437C8);
      BOOL v8 = v32;
      if (v33)
      {
        qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
        __cxa_guard_release(&qword_1EA6437C8);
        BOOL v8 = v32;
      }
    }
    uint64_t v9 = (2 * v8);
    float v10 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      if ((v9 - 1) > 6) {
        uint64_t v30 = "Success, no error";
      }
      else {
        uint64_t v30 = off_1E689A510[(v9 - 1)];
      }
      int v34 = 136315394;
      id v35 = "Precondition was violated";
      __int16 v36 = 2080;
      uint64_t v37 = v30;
      _os_log_error_impl(&dword_1D0DBD000, v10, OS_LOG_TYPE_ERROR, "Running m_timeDiff.update(timestamp) failed with %s, returning %s", (uint8_t *)&v34, 0x16u);
    }

    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    float v11 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      __int16 v31 = off_1E689A510[(v9 - 1)];
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = v31;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v31;
      _os_log_error_impl(&dword_1D0DBD000, v11, OS_LOG_TYPE_ERROR, "Running m_normalizedLandmarks->update(landmarks, timestamp) failed with %s, returning %s", buf, 0x16u);
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 208))
    {
      double v12 = *(double *)(a1 + 168);
      float v13 = 1.0;
      if (v12 > 0.0) {
        float v13 = 1.0 - exp(-*(double *)(a1 + 200) / v12);
      }
      float32x2_t v14 = vmla_n_f32(*(float32x2_t *)(a1 + 80), vsub_f32(a2[1], *(float32x2_t *)(a1 + 80)), v13);
      float32x2_t v15 = vmla_n_f32(*(float32x2_t *)(a1 + 88), vsub_f32(a2[2], *(float32x2_t *)(a1 + 88)), v13);
      float32x2_t v16 = vmla_n_f32(*(float32x2_t *)(a1 + 96), vsub_f32(a2[3], *(float32x2_t *)(a1 + 96)), v13);
      float32x2_t v17 = vmla_n_f32(*(float32x2_t *)(a1 + 104), vsub_f32(a2[4], *(float32x2_t *)(a1 + 104)), v13);
      float32x2_t v18 = vmla_n_f32(*(float32x2_t *)(a1 + 112), vsub_f32(a2[5], *(float32x2_t *)(a1 + 112)), v13);
      float32x2_t v19 = vmla_n_f32(*(float32x2_t *)(a1 + 120), vsub_f32(a2[6], *(float32x2_t *)(a1 + 120)), v13);
      float32x2_t v20 = vmla_n_f32(*(float32x2_t *)(a1 + 128), vsub_f32(a2[7], *(float32x2_t *)(a1 + 128)), v13);
      float32x2_t v21 = vmla_n_f32(*(float32x2_t *)(a1 + 136), vsub_f32(a2[8], *(float32x2_t *)(a1 + 136)), v13);
      float32x2_t v22 = vmla_n_f32(*(float32x2_t *)(a1 + 144), vsub_f32(a2[9], *(float32x2_t *)(a1 + 144)), v13);
      float32x2_t v23 = vmla_n_f32(*(float32x2_t *)(a1 + 152), vsub_f32(a2[10], *(float32x2_t *)(a1 + 152)), v13);
      float32x2_t v24 = vmla_n_f32(*(float32x2_t *)(a1 + 160), vsub_f32(a2[11], *(float32x2_t *)(a1 + 160)), v13);
      *(float32x2_t *)(a1 + 72) = vmla_n_f32(*(float32x2_t *)(a1 + 72), vsub_f32(*a2, *(float32x2_t *)(a1 + 72)), v13);
      *(float32x2_t *)(a1 + 80) = v14;
      *(float32x2_t *)(a1 + 88) = v15;
      *(float32x2_t *)(a1 + 96) = v16;
      *(float32x2_t *)(a1 + 104) = v17;
      *(float32x2_t *)(a1 + 112) = v18;
      *(float32x2_t *)(a1 + 120) = v19;
      *(float32x2_t *)(a1 + 128) = v20;
      *(float32x2_t *)(a1 + 136) = v21;
      *(float32x2_t *)(a1 + 144) = v22;
      *(float32x2_t *)(a1 + 152) = v23;
      *(float32x2_t *)(a1 + 160) = v24;
    }
    else
    {
      long long v25 = *(_OWORD *)a2[2].f32;
      *int v5 = *(_OWORD *)a2->f32;
      v5[1] = v25;
      long long v26 = *(_OWORD *)a2[4].f32;
      long long v27 = *(_OWORD *)a2[6].f32;
      long long v28 = *(_OWORD *)a2[10].f32;
      v5[4] = *(_OWORD *)a2[8].f32;
      v5[5] = v28;
      v5[2] = v26;
      v5[3] = v27;
    }
    return 0;
  }
  return v9;
}

uint64_t sub_1D0DF47F4(uint64_t a1, float *a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  long long v14 = *(_OWORD *)a3;
  uint64_t v15 = *(void *)(a3 + 16);
  int v5 = sub_1D0DD8230(a1 + 16, &v14);
  BOOL v6 = v5 != 0;
  if (v5)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    uint64_t v7 = (2 * v6);
    BOOL v8 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      if ((v7 - 1) > 6) {
        float v13 = "Success, no error";
      }
      else {
        float v13 = off_1E689A510[(v7 - 1)];
      }
      *(_DWORD *)int buf = 136315394;
      float32x2_t v17 = "Precondition was violated";
      __int16 v18 = 2080;
      float32x2_t v19 = v13;
      _os_log_error_impl(&dword_1D0DBD000, v8, OS_LOG_TYPE_ERROR, "Running m_timeDiff.update(timestamp) failed with %s, returning %s", buf, 0x16u);
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 48))
    {
      double v9 = *(double *)(a1 + 8);
      float v10 = 1.0;
      if (v9 > 0.0) {
        float v10 = 1.0 - exp(-*(double *)(a1 + 40) / v9);
      }
      uint64_t v7 = 0;
      float v11 = *(float *)a1 + (float)(v10 * (float)(*a2 - *(float *)a1));
    }
    else
    {
      uint64_t v7 = 0;
      float v11 = *a2;
    }
    *(float *)a1 = v11;
  }
  return v7;
}

void sub_1D0DF49BC(uint64_t a1, float32x4_t *a2, float32x4_t a3, double a4, double a5, double a6, float32x4_t a7)
{
  a7.i32[0] = 1127481344;
  float32x4_t v7 = a7;
  v7.i32[1] = 0;
  v7.i32[2] = *(_DWORD *)(a1 + 480);
  float32x4_t v46 = *a2;
  v47.i64[0] = a2[1].i64[0];
  v47.i32[2] = 1;
  if ((v46.i8[12] & 1) == 0) {
    return;
  }
  double v9 = (Float64 *)(a1 + 224);
  int v10 = *(_DWORD *)(a1 + 248);
  if (v10)
  {
    if (v10 != 1)
    {
      sub_1D0E221E0();
      sub_1D0DF4E04();
      return;
    }
    if ((*(unsigned char *)(a1 + 236) & 1) == 0)
    {
      int v45 = 0;
      v44.value = 0x7FF8000000000000;
      goto LABEL_9;
    }
    float32x4_t v36 = v7;
    float32x4_t v37 = a3;
    *(float32x4_t *)&v41.value = *a2;
    v41.epoch = a2[1].i64[0];
    v51.value = 0;
    *(void *)&v51.timescale = 0;
    *(_OWORD *)&v51.value = *(_OWORD *)v9;
    v51.epoch = *(void *)(a1 + 240);
  }
  else
  {
    float32x4_t v36 = v7;
    float32x4_t v37 = a3;
    *(float32x4_t *)&v41.value = *a2;
    v41.epoch = a2[1].i64[0];
    memset(&v51, 0, sizeof(v51));
    CMTimeMakeWithSeconds(&v51, *v9, 1000000);
  }
  memset(&v50, 0, sizeof(v50));
  CMTime lhs = v41;
  CMTime rhs = v51;
  CMTimeSubtract(&v50, &lhs, &rhs);
  CMTime v44 = v50;
  int v45 = 1;
  a3 = v37;
  float32x4_t v7 = v36;
LABEL_9:
  float32x4_t v11 = vsubq_f32(a3, v7);
  *(float32x2_t *)v11.f32 = vmla_f32(*(float32x2_t *)v11.f32, (float32x2_t)vdup_n_s32(0xC3B40000), vrndm_f32(vdiv_f32(vadd_f32(*(float32x2_t *)v11.f32, (float32x2_t)vdup_n_s32(0x43340000u)), (float32x2_t)vdup_n_s32(0x43B40000u))));
  float32x4_t v39 = v11;
  float v38 = v11.f32[2] + (float)(floorf((float)(v11.f32[2] + 180.0) / 360.0) * -360.0);
  int v12 = *(_DWORD *)(a1 + 284);
  if (v12 >= 1)
  {
    int v13 = *(_DWORD *)(a1 + 280);
    uint64_t v14 = *(void *)(a1 + 256);
    while (1)
    {
      unsigned __int8 v15 = sub_1D0E75EF8(v14 + 48 * v13 + 16, (uint64_t)&v44);
      if (v15 == 129 || ((char)v15 & 0x80000000) == 0) {
        break;
      }
      uint64_t v14 = *(void *)(a1 + 256);
      int v13 = (*(int *)(a1 + 280) + 1) % (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 264) - v14) >> 4));
      *(_DWORD *)(a1 + 280) = v13;
      int v16 = *(_DWORD *)(a1 + 284);
      BOOL v17 = __OFSUB__(v16, 1);
      int v12 = v16 - 1;
      *(_DWORD *)(a1 + 284) = v12;
      if ((v12 < 0) ^ v17 | (v12 == 0)) {
        goto LABEL_15;
      }
    }
    int v12 = *(_DWORD *)(a1 + 284);
    if (!v12) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }
LABEL_15:
  if (v12)
  {
LABEL_18:
    if (v12 >= 1)
    {
      unint64_t v18 = *(int *)(a1 + 280) + (uint64_t)v12;
      uint64_t v19 = *(void *)(a1 + 256);
      unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 264) - v19) >> 4);
      unint64_t v21 = (v20 + (int)(~(v18 / v20 * v20) + v18)) % v20;
      do
      {
        unsigned __int8 v22 = sub_1D0E75EF8((uint64_t)&v46, v19 + 48 * (int)v21 + 16);
        int v12 = *(_DWORD *)(a1 + 284);
        if (v22 == 129) {
          break;
        }
        if (((char)v22 & 0x80000000) == 0) {
          break;
        }
        uint64_t v19 = *(void *)(a1 + 256);
        unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 264) - v19) >> 4);
        unint64_t v21 = (v23 + ((uint64_t)((v21 << 32) - 0x100000000) >> 32)) % v23;
        BOOL v17 = __OFSUB__(v12--, 1);
        *(_DWORD *)(a1 + 284) = v12;
      }
      while (!((v12 < 0) ^ v17 | (v12 == 0)));
    }
  }
LABEL_24:
  float32x4_t v24 = v39;
  v24.f32[2] = v38;
  float32x4_t v40 = v24;
  uint64_t v25 = v12;
  uint64_t v26 = *(void *)(a1 + 256);
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 264) - v26) >> 4);
  if (v27 == v12)
  {
    BOOL v28 = __CFADD__(v12, 1);
    int v29 = v12 + 1;
    if (v28)
    {
      uint64_t v31 = v26 + 48 * v29;
      *(void *)(a1 + 264) = v31;
    }
    else
    {
      sub_1D0DF3F48((void **)(a1 + 256), v29 - v25);
      uint64_t v26 = *(void *)(a1 + 256);
      uint64_t v31 = *(void *)(a1 + 264);
    }
    unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 272) - v26) >> 4);
    unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * ((v31 - v26) >> 4);
    if (v32 <= v33)
    {
      if (v32 < v33)
      {
        uint64_t v31 = v26 + 16 * ((*(void *)(a1 + 272) - v26) >> 4);
        *(void *)(a1 + 264) = v31;
      }
    }
    else
    {
      sub_1D0DF3F48((void **)(a1 + 256), v32 - v33);
      uint64_t v26 = *(void *)(a1 + 256);
      uint64_t v31 = *(void *)(a1 + 264);
    }
    int v30 = *(_DWORD *)(a1 + 280);
    int v12 = *(_DWORD *)(a1 + 284);
    if (v30)
    {
      if (v12 == v30)
      {
        int v12 = *(_DWORD *)(a1 + 280);
      }
      else
      {
        size_t v34 = 48 * v12 - 48 * v30;
        memmove((void *)(v31 - v34), (const void *)(v26 + 48 * v30), v34);
        uint64_t v26 = *(void *)(a1 + 256);
        uint64_t v31 = *(void *)(a1 + 264);
        int v12 = *(_DWORD *)(a1 + 284);
        int v30 = *(_DWORD *)(a1 + 280);
      }
      unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v31 - v26) >> 4);
      int v30 = v30 - v12 + v27;
      *(_DWORD *)(a1 + 280) = v30;
    }
    else
    {
      unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v31 - v26) >> 4);
    }
  }
  else
  {
    int v30 = *(_DWORD *)(a1 + 280);
  }
  float32x4_t v42 = v46;
  float32x4_t v43 = v47;
  id v35 = (float32x4_t *)(v26 + 48 * (int)((v12 + v30) % v27));
  *id v35 = v40;
  v35[1] = v42;
  v35[2] = v43;
  ++*(_DWORD *)(a1 + 284);
}

uint64_t sub_1D0DF4E04()
{
  unint64_t v0 = 0x1EA643000uLL;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0)
  {
    int v2 = __cxa_guard_acquire(&qword_1EA6437C8);
    unint64_t v0 = 0x1EA643000;
    if (v2)
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
      unint64_t v0 = 0x1EA643000;
    }
  }
  return *(void *)(v0 + 1984);
}

void sub_1D0DF5294(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D0DF56C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D0DF5888(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1D0DF58AC(void **a1, void *a2, void *a3, void *a4, void *a5, simd_float3x3 *a6, void *a7, void *a8)
{
  v88[4] = *(float32x2_t *)MEMORY[0x1E4F143B8];
  id v15 = a2;
  id v16 = a3;
  id v17 = a4;
  id v18 = a5;
  id v19 = a8;
  unint64_t v20 = v19;
  if (!v15 || !v16 || !v17 || !v18 || !v19)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    unint64_t v67 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      v86.columns[0].i16[0] = 0;
      _os_log_error_impl(&dword_1D0DBD000, v67, OS_LOG_TYPE_ERROR, "Inputs must not be nil", (uint8_t *)&v86, 2u);
    }
    goto LABEL_44;
  }
  if (![v15 width]
    || ![v15 height]
    || (uint64_t v21 = [v15 width], v21 != 2 * objc_msgSend(v16, "width"))
    || (uint64_t v22 = [v15 height], v22 != 2 * objc_msgSend(v16, "height")))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    unint64_t v67 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      v86.columns[0].i16[0] = 0;
      _os_log_error_impl(&dword_1D0DBD000, v67, OS_LOG_TYPE_ERROR, "YCBCr texture sizes invalid / not matching", (uint8_t *)&v86, 2u);
    }
    goto LABEL_44;
  }
  if (![v17 width]
    || ![v17 height]
    || (uint64_t v23 = [v17 width], v23 != objc_msgSend(v18, "width"))
    || (uint64_t v24 = [v17 height], v24 != objc_msgSend(v18, "height")))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6437C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA6437C8))
    {
      qword_1EA6437C0 = (uint64_t)os_log_create("com.apple.AppleCVA", "ViewpointCorrection");
      __cxa_guard_release(&qword_1EA6437C8);
    }
    unint64_t v67 = (id)qword_1EA6437C0;
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      v86.columns[0].i16[0] = 0;
      _os_log_error_impl(&dword_1D0DBD000, v67, OS_LOG_TYPE_ERROR, "Flow texture sizes invalid / not matching", (uint8_t *)&v86, 2u);
    }
    goto LABEL_44;
  }
  uint64_t v25 = [v17 width];
  if (v25 != [v17 height])
  {
    unint64_t v67 = sub_1D0DF4E04();
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      v86.columns[0].i16[0] = 0;
      _os_log_error_impl(&dword_1D0DBD000, v67, OS_LOG_TYPE_ERROR, "Currently we only support square flows", (uint8_t *)&v86, 2u);
    }
LABEL_44:

    uint64_t v62 = 1;
    goto LABEL_45;
  }
  simd_float3x3 v86 = __invert_f3(*a6);
  uint64_t v26 = (_OWORD *)[a7 contents];
  simd_float3 v27 = a6->columns[0];
  simd_float3 v28 = a6->columns[2];
  v26[2] = a6->columns[1];
  v26[3] = v28;
  v26[1] = v27;
  uint64_t v29 = [a7 contents];
  simd_float3 v30 = v86.columns[1];
  *(simd_float3 *)(v29 + 64) = v86.columns[0];
  *(simd_float3 *)(v29 + 80) = v30;
  *(simd_float3 *)(v29 + 96) = v86.columns[2];
  v88[0] = 0;
  unint64_t v31 = [v17 height];
  v32.i32[0] = 0;
  v32.f32[1] = (float)v31;
  v88[1] = v32;
  unint64_t v33 = [v17 width];
  unint64_t v34 = [v17 height];
  v35.f32[0] = (float)v33;
  v35.f32[1] = (float)v34;
  v88[2] = v35;
  v88[3] = (float32x2_t)COERCE_UNSIGNED_INT((float)(unint64_t)[v17 width]);
  sub_1D0DF650C((float32x2_t **)buf, 4uLL, v88, (float32x4_t *)&v86);
  float32x4_t v36 = *(void **)buf;
  sub_1D0DF61E0(v85, *(unint64_t *)buf, *(uint64_t *)&buf[8]);
  *(float32x2_t *)&double v40 = sub_1D0DF1E8C(v85[0], (float32x2_t *)v85[1], v37, v38, v39);
  uint64_t v42 = v41;
  float v44 = v43;
  if (v36) {
    operator delete(v36);
  }
  unsigned int v45 = objc_msgSend(v15, "width", v40);
  float v46 = floorf(fmaxf(*(float *)&v42, 0.0) * 0.5);
  LODWORD(v47) = (float)(v46 + v46);
  if (v45 >= v47) {
    uint64_t v47 = v47;
  }
  else {
    uint64_t v47 = v45;
  }
  uint64_t v76 = v47;
  unsigned int v48 = [v15 height];
  float v49 = *((float *)&v42 + 1);
  float v50 = floorf(fmaxf(*((float *)&v42 + 1), 0.0) * 0.5);
  unsigned int v51 = (float)(v50 + v50);
  if (v48 >= v51) {
    uint64_t v52 = v51;
  }
  else {
    uint64_t v52 = v48;
  }
  *(void *)[a7 contents] = __PAIR64__(v52, v76);
  int v53 = [v15 width];
  float v54 = ceilf(fmaxf((float)(*(float *)&v42 + v44) - (float)v76, 0.0) * 0.5);
  unsigned int v55 = (float)(v54 + v54);
  if (v53 - (int)v76 >= v55) {
    uint64_t v56 = v55;
  }
  else {
    uint64_t v56 = (v53 - v76);
  }
  int v57 = [v15 height];
  float v58 = ceilf(fmaxf((float)(v44 + v49) - (float)v52, 0.0) * 0.5);
  LODWORD(v59) = (float)(v58 + v58);
  if (v57 - (int)v52 >= v59) {
    uint64_t v59 = v59;
  }
  else {
    uint64_t v59 = (v57 - v52);
  }
  uint64_t v75 = v59;
  if (v59 * v56)
  {
    BOOL v73 = (uint64_t *)(a1 + 2);
    sub_1D0DF305C((id *)a1[1], v15, a1 + 2);
    BOOL v72 = (uint64_t *)(a1 + 3);
    sub_1D0DF305C((id *)a1[1], v16, a1 + 3);
    unint64_t v60 = [v20 computeCommandEncoder];
    [v60 setLabel:@"FlowWarper"];
    if (v60)
    {
      [v60 setComputePipelineState:*a1];
      [v60 setTexture:v15 atIndex:0];
      [v60 setTexture:v16 atIndex:1];
      [v60 setTexture:*v73 atIndex:2];
      [v60 setTexture:*v72 atIndex:3];
      [v60 setTexture:v17 atIndex:4];
      [v60 setTexture:v18 atIndex:5];
      [v60 setBuffer:a7 offset:0 atIndex:0];
      uint64_t v71 = v56;
      unsigned int v61 = sub_1D0DF3C68(v60, *a1, v56, v75);
      if (v61 == 1) {
        uint64_t v62 = 2;
      }
      else {
        uint64_t v62 = v61;
      }
      if (v61)
      {
        unsigned int v63 = v61 - 1;
        uint64_t v64 = sub_1D0DF4E04();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
        {
          unint64_t v65 = off_1E689A510[v63];
          unint64_t v66 = off_1E689A510[(v62 - 1)];
          *(_DWORD *)int buf = 136315394;
          *(void *)&uint8_t buf[4] = v65;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v66;
          _os_log_error_impl(&dword_1D0DBD000, v64, OS_LOG_TYPE_ERROR, "Running m_metalHelpers->runComputeEncoder(computeEncoder, m_pipeline, cropWidth, cropHeight) failed with %s, returning %s", buf, 0x16u);
        }
        goto LABEL_59;
      }
      [v60 endEncoding];
      uint64_t v64 = [v20 blitCommandEncoder];
      [v64 setLabel:@"TextureCopy"];
      if (v64)
      {
        uint64_t v69 = *v73;
        v84[0] = v76;
        v84[1] = v52;
        v84[2] = 0;
        v83[0] = v71;
        v83[1] = v75;
        v83[2] = [v15 depth];
        v82[0] = v76;
        v82[1] = v52;
        v82[2] = 0;
        [v64 copyFromTexture:v69 sourceSlice:0 sourceLevel:0 sourceOrigin:v84 sourceSize:v83 toTexture:v15 destinationSlice:0 destinationLevel:0 destinationOrigin:v82];
        uint64_t v74 = *v72;
        uint64_t v79 = v76 >> 1;
        uint64_t v80 = v52 >> 1;
        uint64_t v81 = 0;
        v78[0] = v71 >> 1;
        v78[1] = v75 >> 1;
        v78[2] = [v16 depth];
        v77[0] = v79;
        v77[1] = v80;
        v77[2] = 0;
        [v64 copyFromTexture:v74 sourceSlice:0 sourceLevel:0 sourceOrigin:&v79 sourceSize:v78 toTexture:v16 destinationSlice:0 destinationLevel:0 destinationOrigin:v77];
        [v64 endEncoding];
        uint64_t v62 = 0;
        goto LABEL_59;
      }
      unint64_t v70 = sub_1D0DF4E04();
      if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int buf = 0;
        _os_log_error_impl(&dword_1D0DBD000, v70, OS_LOG_TYPE_ERROR, "Could not create blitCommandEncoder", buf, 2u);
      }

      uint64_t v64 = 0;
    }
    else
    {
      uint64_t v64 = sub_1D0DF4E04();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int buf = 0;
        _os_log_error_impl(&dword_1D0DBD000, v64, OS_LOG_TYPE_ERROR, "Could not create computeCommandEncoder", buf, 2u);
      }
    }
    uint64_t v62 = 6;
LABEL_59:

    goto LABEL_45;
  }
  uint64_t v62 = 0;
LABEL_45:

  return v62;
}

void sub_1D0DF6170(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t *sub_1D0DF61E0(unint64_t *result, unint64_t a2, uint64_t a3)
{
  if ((uint64_t)(a3 - a2) < 0 || (*uint64_t result = (a3 - a2) >> 3, (result[1] = a2) == 0) && a3) {
    sub_1D0DE222C();
  }
  return result;
}

__n64 sub_1D0DF6238(uint64_t a1, uint64_t *a2)
{
  if (a2[1] == a1)
  {
    float v14 = 0.0;
    long long v12 = 0u;
    long long v13 = 0u;
    sub_1D0DF6238(&v12, a2);
    result.n64_u64[0] = v12;
    long long v11 = v13;
    *(_OWORD *)a1 = v12;
    *(_OWORD *)(a1 + 16) = v11;
    *(float *)(a1 + 32) = v14;
  }
  else
  {
    uint64_t v4 = *a2;
    long long v12 = 0u;
    long long v13 = 0u;
    float v14 = 0.0;
    sub_1D0DF63A8((uint64_t)&v12, v4);
    int v5 = (float *)a2[1];
    result.n64_u32[1] = 0;
    long long v6 = v12;
    uint64_t v7 = *((void *)&v13 + 1);
    *(float *)a1 = (float)((float)((float)(*(float *)&v12 * *v5) + 0.0) + (float)(*((float *)&v12 + 3) * v5[1]))
                 + (float)(*((float *)&v13 + 2) * v5[2]);
    uint64_t v8 = v13;
    *(float *)(a1 + 4) = (float)((float)((float)(*((float *)&v6 + 1) * *v5) + 0.0) + (float)(*(float *)&v13 * v5[1]))
                       + (float)(*((float *)&v7 + 1) * v5[2]);
    float v9 = v14;
    *(float *)(a1 + 8) = (float)((float)((float)(*((float *)&v6 + 2) * *v5) + 0.0) + (float)(*((float *)&v8 + 1) * v5[1]))
                       + (float)(v14 * v5[2]);
    *(float *)(a1 + 12) = (float)((float)((float)(*(float *)&v6 * v5[3]) + 0.0) + (float)(*((float *)&v6 + 3) * v5[4]))
                        + (float)(*(float *)&v7 * v5[5]);
    *(float *)(a1 + 16) = (float)((float)((float)(*((float *)&v6 + 1) * v5[3]) + 0.0) + (float)(*(float *)&v8 * v5[4]))
                        + (float)(*((float *)&v7 + 1) * v5[5]);
    *(float *)(a1 + 20) = (float)((float)((float)(*((float *)&v6 + 2) * v5[3]) + 0.0)
                                + (float)(*((float *)&v8 + 1) * v5[4]))
                        + (float)(v9 * v5[5]);
    *(float *)(a1 + 24) = (float)((float)((float)(*(float *)&v6 * v5[6]) + 0.0) + (float)(*((float *)&v6 + 3) * v5[7]))
                        + (float)(*(float *)&v7 * v5[8]);
    *(float *)(a1 + 28) = (float)((float)((float)(*((float *)&v6 + 1) * v5[6]) + 0.0) + (float)(*(float *)&v8 * v5[7]))
                        + (float)(*((float *)&v7 + 1) * v5[8]);
    result.n64_f32[0] = (float)((float)((float)(*((float *)&v6 + 2) * v5[6]) + 0.0)
                              + (float)(*((float *)&v8 + 1) * v5[7]))
                      + (float)(v9 * v5[8]);
    *(_DWORD *)(a1 + 32) = result.n64_u32[0];
  }
  return result;
}

__n64 sub_1D0DF63A8(uint64_t a1, uint64_t a2)
{
  float32x4_t v3 = *(float **)(a2 + 8);
  if (v3 == (float *)a1)
  {
    float v13 = 0.0;
    long long v11 = 0u;
    long long v12 = 0u;
    sub_1D0DF63A8(&v11);
    result.n64_u64[0] = v11;
    long long v10 = v12;
    *(_OWORD *)a1 = v11;
    *(_OWORD *)(a1 + 16) = v10;
    *(float *)(a1 + 32) = v13;
  }
  else
  {
    uint64_t v4 = *(float ***)a2;
    long long v11 = 0u;
    long long v12 = 0u;
    float v13 = 0.0;
    sub_1D0DF1BF0((uint64_t)&v11, v4);
    result.n64_u32[1] = 0;
    long long v5 = v11;
    uint64_t v6 = *((void *)&v12 + 1);
    *(float *)a1 = (float)((float)((float)(*(float *)&v11 * *v3) + 0.0) + (float)(*((float *)&v11 + 3) * v3[1]))
                 + (float)(*((float *)&v12 + 2) * v3[2]);
    uint64_t v7 = v12;
    *(float *)(a1 + 4) = (float)((float)((float)(*((float *)&v5 + 1) * *v3) + 0.0) + (float)(*(float *)&v12 * v3[1]))
                       + (float)(*((float *)&v6 + 1) * v3[2]);
    float v8 = v13;
    *(float *)(a1 + 8) = (float)((float)((float)(*((float *)&v5 + 2) * *v3) + 0.0) + (float)(*((float *)&v7 + 1) * v3[1]))
                       + (float)(v13 * v3[2]);
    *(float *)(a1 + 12) = (float)((float)((float)(*(float *)&v5 * v3[3]) + 0.0) + (float)(*((float *)&v5 + 3) * v3[4]))
                        + (float)(*(float *)&v6 * v3[5]);
    *(float *)(a1 + 16) = (float)((float)((float)(*((float *)&v5 + 1) * v3[3]) + 0.0) + (float)(*(float *)&v7 * v3[4]))
                        + (float)(*((float *)&v6 + 1) * v3[5]);
    *(float *)(a1 + 20) = (float)((float)((float)(*((float *)&v5 + 2) * v3[3]) + 0.0)
                                + (float)(*((float *)&v7 + 1) * v3[4]))
                        + (float)(v8 * v3[5]);
    *(float *)(a1 + 24) = (float)((float)((float)(*(float *)&v5 * v3[6]) + 0.0) + (float)(*((float *)&v5 + 3) * v3[7]))
                        + (float)(*(float *)&v6 * v3[8]);
    *(float *)(a1 + 28) = (float)((float)((float)(*((float *)&v5 + 1) * v3[6]) + 0.0) + (float)(*(float *)&v7 * v3[7]))
                        + (float)(*((float *)&v6 + 1) * v3[8]);
    result.n64_f32[0] = (float)((float)((float)(*((float *)&v5 + 2) * v3[6]) + 0.0)
                              + (float)(*((float *)&v7 + 1) * v3[7]))
                      + (float)(v8 * v3[8]);
    *(_DWORD *)(a1 + 32) = result.n64_u32[0];
  }
  return result;
}

void sub_1D0DF650C(float32x2_t **a1, unint64_t a2, float32x2_t *a3, float32x4_t *a4)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    unint64_t v4 = a2;
    if (a2 >> 61) {
      abort();
    }
    uint64_t v8 = a2;
    float v9 = (float32x2_t *)operator new(8 * a2);
    *a1 = v9;
    a1[2] = &v9[v8];
    bzero(v9, 8 * v4);
    a1[1] = &v9[v8];
    float32x4_t v10 = *a4;
    float32x4_t v11 = a4[1];
    float32x4_t v12 = a4[2];
    do
    {
      float32x2_t v13 = *a3++;
      int32x4_t v14 = (int32x4_t)vaddq_f32(v12, vmlaq_lane_f32(vmulq_n_f32(v10, v13.f32[0]), v11, v13, 1));
      *v9++ = vdiv_f32(*(float32x2_t *)v14.i8, (float32x2_t)vdup_laneq_s32(v14, 2));
      --v4;
    }
    while (v4);
  }
}

void sub_1D0DF65BC(void ***a1, uint64_t *a2)
{
  float32x4_t v3 = *a1;
  unint64_t v4 = (char *)**a1;
  long long v5 = (char *)(*a1)[1];
  unint64_t v6 = (v5 - v4) >> 4;
  if (v6 >= *((unsigned int *)*a1 + 6))
  {
    DWORD2(v35) = 0;
    *(void *)&long long v34 = 0x7FF8000000000000;
    if (v5 != v4)
    {
      uint64_t v11 = 0;
      unint64_t v12 = 0;
      unint64_t v13 = 0;
      long long v5 = v4;
      while (1)
      {
        uint64_t v15 = **(void **)&v5[v11];
        if (*(void *)(v15 + 24) != *(void *)(v15 + 32))
        {
          id v16 = (long long *)(v15 + 88);
          if (DWORD2(v35))
          {
            if (DWORD2(v35) != 1)
            {
              sub_1D0E221E0();
LABEL_45:
              abort();
            }
            if ((BYTE12(v34) & 1) == 0) {
              goto LABEL_8;
            }
          }
          unsigned __int8 v17 = sub_1D0E75EF8((uint64_t)v16, (uint64_t)&v34);
          if (v17 != 129 && (char)v17 < 0)
          {
LABEL_8:
            long long v14 = v16[1];
            long long v34 = *v16;
            long long v35 = v14;
            unint64_t v12 = v13;
          }
        }
        ++v13;
        long long v5 = (char *)**a1;
        v11 += 16;
        if (v13 >= ((unsigned char *)(*a1)[1] - v5) >> 4) {
          goto LABEL_34;
        }
      }
    }
    unint64_t v12 = 0;
LABEL_34:
    simd_float3 v30 = &v5[16 * v12];
    uint64_t v32 = *a2;
    uint64_t v31 = a2[1];
    if (v31) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v33 = (std::__shared_weak_count *)*((void *)v30 + 1);
    *(void *)simd_float3 v30 = v32;
    *((void *)v30 + 1) = v31;
    if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  else
  {
    uint64_t v7 = (char *)v3[2];
    if (v5 >= v7)
    {
      unint64_t v18 = v6 + 1;
      if ((v6 + 1) >> 60) {
        goto LABEL_45;
      }
      uint64_t v19 = v7 - v4;
      if (v19 >> 3 > v18) {
        unint64_t v18 = v19 >> 3;
      }
      BOOL v20 = (unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0;
      unint64_t v21 = 0xFFFFFFFFFFFFFFFLL;
      if (!v20) {
        unint64_t v21 = v18;
      }
      if (v21 >> 60) {
        sub_1D0DE8CE0();
      }
      uint64_t v22 = 16 * v21;
      uint64_t v23 = (char *)operator new(16 * v21);
      uint64_t v24 = &v23[16 * v6];
      long long v25 = *(_OWORD *)a2;
      *(_OWORD *)uint64_t v24 = *(_OWORD *)a2;
      if (*((void *)&v25 + 1))
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v25 + 1) + 8), 1uLL, memory_order_relaxed);
        unint64_t v4 = (char *)*v3;
        long long v5 = (char *)v3[1];
      }
      uint64_t v26 = &v23[v22];
      float v9 = v24 + 16;
      if (v5 == v4)
      {
        *float32x4_t v3 = v24;
        v3[1] = v9;
        v3[2] = v26;
      }
      else
      {
        do
        {
          long long v27 = *((_OWORD *)v5 - 1);
          v5 -= 16;
          *((_OWORD *)v24 - 1) = v27;
          v24 -= 16;
          *(void *)long long v5 = 0;
          *((void *)v5 + 1) = 0;
        }
        while (v5 != v4);
        unint64_t v4 = (char *)*v3;
        simd_float3 v28 = (char *)v3[1];
        *float32x4_t v3 = v24;
        v3[1] = v9;
        for (v3[2] = v26; v28 != v4; v28 -= 16)
        {
          uint64_t v29 = (std::__shared_weak_count *)*((void *)v28 - 1);
          if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
            std::__shared_weak_count::__release_weak(v29);
          }
        }
      }
      if (v4) {
        operator delete(v4);
      }
    }
    else
    {
      *(void *)long long v5 = *a2;
      uint64_t v8 = a2[1];
      *((void *)v5 + 1) = v8;
      if (v8) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
      }
      float v9 = v5 + 16;
    }
    v3[1] = v9;
  }
}

void sub_1D0DF688C(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
LABEL_1:
  unint64_t v10 = a2;
LABEL_2:
  uint64_t v11 = (void *)a1;
  uint64_t v12 = a1 + 16;
  uint64_t v13 = a1 + 32;
  uint64_t v117 = a1;
  while (1)
  {
    uint64_t v14 = v10 - (void)v11;
    unint64_t v15 = (uint64_t)(v10 - (void)v11) >> 4;
    if (v5 || !v4)
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if ((char)sub_1D0E75EF8(**(void **)(v10 - 16) + 88, *(void *)*v11 + 88) >= 1)
          {
            float v50 = (void *)*v11;
            *uint64_t v11 = *(void *)(v10 - 16);
            *(void *)(v10 - 16) = v50;
            uint64_t v51 = v11[1];
            v11[1] = *(void *)(v10 - 8);
            *(void *)(v10 - 8) = v51;
          }
          break;
        case 3uLL:
          sub_1D0DF7770((uint64_t)v11, v12, v10 - 16);
          break;
        case 4uLL:
          sub_1D0DF78E4((uint64_t)v11, v12, v13, v10 - 16);
          break;
        case 5uLL:
          sub_1D0DF79F4((uint64_t)v11, v12, v13, (uint64_t)(v11 + 6), v10 - 16);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 383) {
      break;
    }
    if (!a3)
    {
      if (v11 == (void *)v10) {
        return;
      }
      int64_t v67 = (v15 - 2) >> 1;
      int64_t v114 = v67;
      do
      {
        int64_t v68 = v67;
        if (v114 >= v67)
        {
          uint64_t v69 = (2 * v67) | 1;
          unint64_t v70 = &v11[2 * v69];
          if (2 * v67 + 2 < (uint64_t)v15 && (char)sub_1D0E75EF8(*(void *)*v70 + 88, *(void *)v70[2] + 88) > 0)
          {
            v70 += 2;
            uint64_t v69 = 2 * v68 + 2;
          }
          uint64_t v71 = &v11[2 * v68];
          if ((char)sub_1D0E75EF8(*(void *)*v70 + 88, *(void *)*v71 + 88) <= 0)
          {
            long long v72 = *(_OWORD *)v71;
            *uint64_t v71 = 0;
            v71[1] = 0;
            long long v112 = v72;
            BOOL v73 = (void *)v72;
            do
            {
              uint64_t v74 = v70;
              long long v75 = *(_OWORD *)v70;
              *unint64_t v70 = 0;
              v70[1] = 0;
              uint64_t v76 = (std::__shared_weak_count *)v71[1];
              *(_OWORD *)uint64_t v71 = v75;
              if (v76 && !atomic_fetch_add(&v76->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
                std::__shared_weak_count::__release_weak(v76);
              }
              if (v114 < v69) {
                break;
              }
              uint64_t v77 = (2 * v69) | 1;
              unint64_t v70 = (void *)(v117 + 16 * v77);
              if (2 * v69 + 2 < (uint64_t)v15
                && (char)sub_1D0E75EF8(*(void *)*v70 + 88, *(void *)v70[2] + 88) > 0)
              {
                v70 += 2;
                uint64_t v77 = 2 * v69 + 2;
              }
              uint64_t v71 = v74;
              uint64_t v69 = v77;
            }
            while ((char)sub_1D0E75EF8(*(void *)*v70 + 88, *v73 + 88) < 1);
            BOOL v78 = (std::__shared_weak_count *)v74[1];
            *(_OWORD *)uint64_t v74 = v112;
            uint64_t v11 = (void *)v117;
            if (v78 && !atomic_fetch_add(&v78->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
              std::__shared_weak_count::__release_weak(v78);
            }
          }
        }
        int64_t v67 = v68 - 1;
      }
      while (v68);
      uint64_t v79 = (unint64_t)v14 >> 4;
      while (2)
      {
        uint64_t v81 = 0;
        unint64_t v82 = v10;
        BOOL v83 = (void *)*v11;
        uint64_t v115 = v11[1];
        *uint64_t v11 = 0;
        v11[1] = 0;
        BOOL v84 = v11;
        do
        {
          BOOL v85 = v84;
          v84 += 2 * v81 + 2;
          uint64_t v86 = 2 * v81;
          uint64_t v81 = (2 * v81) | 1;
          uint64_t v87 = v86 + 2;
          if (v86 + 2 < v79 && (char)sub_1D0E75EF8(*(void *)*v84 + 88, *(void *)v84[2] + 88) > 0)
          {
            v84 += 2;
            uint64_t v81 = v87;
          }
          long long v88 = *(_OWORD *)v84;
          *BOOL v84 = 0;
          v84[1] = 0;
          BOOL v89 = (std::__shared_weak_count *)v85[1];
          *(_OWORD *)BOOL v85 = v88;
          if (v89 && !atomic_fetch_add(&v89->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
            std::__shared_weak_count::__release_weak(v89);
          }
        }
        while (v81 <= (uint64_t)((unint64_t)(v79 - 2) >> 1));
        if (v84 == (void *)(v82 - 16))
        {
          unint64_t v91 = v82 - 16;
          long long v102 = (std::__shared_weak_count *)v84[1];
          *BOOL v84 = v83;
          v84[1] = v115;
          uint64_t v11 = (void *)v117;
          if (!v102) {
            goto LABEL_118;
          }
        }
        else
        {
          long long v90 = *(_OWORD *)(v82 - 16);
          *(void *)(v82 - 16) = 0;
          *(void *)(v82 - 8) = 0;
          unint64_t v91 = v82 - 16;
          BOOL v92 = (std::__shared_weak_count *)v84[1];
          *(_OWORD *)BOOL v84 = v90;
          if (v92 && !atomic_fetch_add(&v92->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
            std::__shared_weak_count::__release_weak(v92);
          }
          unint64_t v93 = *(std::__shared_weak_count **)(v82 - 8);
          *(void *)(v82 - 16) = v83;
          *(void *)(v82 - 8) = v115;
          uint64_t v11 = (void *)v117;
          if (v93 && !atomic_fetch_add(&v93->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v93->__on_zero_shared)(v93);
            std::__shared_weak_count::__release_weak(v93);
          }
          uint64_t v94 = (uint64_t)v84 - v117 + 16;
          if (v94 < 17) {
            goto LABEL_118;
          }
          unint64_t v95 = (((unint64_t)v94 >> 4) - 2) >> 1;
          unint64_t v96 = v117 + 16 * v95;
          if ((char)sub_1D0E75EF8(**(void **)v96 + 88, *(void *)*v84 + 88) < 1) {
            goto LABEL_118;
          }
          long long v97 = *(_OWORD *)v84;
          *BOOL v84 = 0;
          v84[1] = 0;
          long long v116 = v97;
          uint64_t v98 = (void *)v97;
          do
          {
            unint64_t v99 = v96;
            long long v100 = *(_OWORD *)v96;
            *(void *)unint64_t v96 = 0;
            *(void *)(v96 + 8) = 0;
            uint64_t v101 = (std::__shared_weak_count *)v84[1];
            *(_OWORD *)BOOL v84 = v100;
            if (v101 && !atomic_fetch_add(&v101->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
              std::__shared_weak_count::__release_weak(v101);
            }
            if (!v95) {
              break;
            }
            unint64_t v95 = (v95 - 1) >> 1;
            unint64_t v96 = v117 + 16 * v95;
            BOOL v84 = (void *)v99;
          }
          while ((char)sub_1D0E75EF8(**(void **)v96 + 88, *v98 + 88) > 0);
          long long v102 = *(std::__shared_weak_count **)(v99 + 8);
          *(_OWORD *)unint64_t v99 = v116;
          if (!v102)
          {
LABEL_118:
            BOOL v80 = v79-- <= 2;
            unint64_t v10 = v91;
            if (v80) {
              return;
            }
            continue;
          }
        }
        break;
      }
      if (!atomic_fetch_add(&v102->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v102->__on_zero_shared)(v102);
        std::__shared_weak_count::__release_weak(v102);
      }
      goto LABEL_118;
    }
    id v16 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 < 0x801)
    {
      sub_1D0DF7770((uint64_t)&v11[2 * (v15 >> 1)], (uint64_t)v11, v10 - 16);
      --a3;
      if (a4) {
        goto LABEL_12;
      }
    }
    else
    {
      sub_1D0DF7770((uint64_t)v11, (uint64_t)&v11[2 * (v15 >> 1)], v10 - 16);
      sub_1D0DF7770(v12, (uint64_t)(v16 - 1), v10 - 32);
      sub_1D0DF7770(v13, (uint64_t)(v16 + 1), v10 - 48);
      uint64_t v17 = (uint64_t)&v11[2 * (v15 >> 1)];
      uint64_t v11 = (void *)v117;
      sub_1D0DF7770((uint64_t)(v16 - 1), v17, (uint64_t)(v16 + 1));
      long long v18 = *(_OWORD *)v117;
      *(_OWORD *)uint64_t v117 = *v16;
      *id v16 = v18;
      --a3;
      if (a4) {
        goto LABEL_12;
      }
    }
    if ((char)sub_1D0E75EF8(*(void *)*(v11 - 2) + 88, *(void *)*v11 + 88) <= 0)
    {
      long long v36 = *(_OWORD *)v11;
      *uint64_t v11 = 0;
      v11[1] = 0;
      long long v118 = v36;
      float32x2_t v37 = (void *)v36;
      if ((char)sub_1D0E75EF8(*(void *)v36 + 88, **(void **)(v10 - 16) + 88) <= 0)
      {
        double v39 = v11 + 2;
        do
        {
          a1 = (unint64_t)v39;
          if ((unint64_t)v39 >= v10) {
            break;
          }
          v39 += 2;
        }
        while ((char)sub_1D0E75EF8(*v37 + 88, **(void **)a1 + 88) < 1);
      }
      else
      {
        a1 = (unint64_t)v11;
        do
        {
          double v38 = *(void **)(a1 + 16);
          a1 += 16;
        }
        while ((char)sub_1D0E75EF8(*v37 + 88, *v38 + 88) <= 0);
      }
      double v40 = (void *)v10;
      if (a1 < v10)
      {
        double v40 = (void *)v10;
        do
        {
          uint64_t v41 = (void *)*(v40 - 2);
          v40 -= 2;
        }
        while ((char)sub_1D0E75EF8(*v37 + 88, *v41 + 88) > 0);
      }
      while (a1 < (unint64_t)v40)
      {
        uint64_t v42 = *(void **)a1;
        *(void *)a1 = *v40;
        *double v40 = v42;
        uint64_t v43 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = v40[1];
        v40[1] = v43;
        do
        {
          float v44 = *(void **)(a1 + 16);
          a1 += 16;
        }
        while ((char)sub_1D0E75EF8(*v37 + 88, *v44 + 88) < 1);
        do
        {
          unsigned int v45 = (void *)*(v40 - 2);
          v40 -= 2;
        }
        while ((char)sub_1D0E75EF8(*v37 + 88, *v45 + 88) > 0);
      }
      a2 = v10;
      float v46 = (long long *)(a1 - 16);
      BOOL v4 = a1 - 16 >= (unint64_t)v11;
      BOOL v5 = a1 - 16 == (void)v11;
      if ((void *)(a1 - 16) != v11)
      {
        long long v47 = *v46;
        *(void *)float v46 = 0;
        *(void *)(a1 - 8) = 0;
        unsigned int v48 = (std::__shared_weak_count *)v11[1];
        *(_OWORD *)uint64_t v11 = v47;
        if (v48)
        {
          if (!atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
            std::__shared_weak_count::__release_weak(v48);
          }
        }
      }
      a4 = 0;
      float v49 = *(std::__shared_weak_count **)(a1 - 8);
      *(_OWORD *)(a1 - 16) = v118;
      if (v49)
      {
        a4 = 0;
        if (!atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
          std::__shared_weak_count::__release_weak(v49);
          a4 = 0;
        }
      }
      goto LABEL_1;
    }
LABEL_12:
    long long v19 = *(_OWORD *)v11;
    *uint64_t v11 = 0;
    v11[1] = 0;
    long long v113 = v19;
    BOOL v20 = (void *)v19;
    do
    {
      unint64_t v21 = v11;
      uint64_t v22 = (void *)v11[2];
      v11 += 2;
    }
    while ((char)sub_1D0E75EF8(*v22 + 88, *v20 + 88) > 0);
    uint64_t v23 = (void *)v10;
    if (v21 == (void *)v117)
    {
      uint64_t v23 = (void *)v10;
      do
      {
        if (v11 >= v23) {
          break;
        }
        long long v25 = (void *)*(v23 - 2);
        v23 -= 2;
      }
      while ((char)sub_1D0E75EF8(*v25 + 88, *v20 + 88) <= 0);
    }
    else
    {
      do
      {
        uint64_t v24 = (void *)*(v23 - 2);
        v23 -= 2;
      }
      while ((char)sub_1D0E75EF8(*v24 + 88, *v20 + 88) < 1);
    }
    a1 = (unint64_t)v11;
    if (v11 < v23)
    {
      uint64_t v26 = v23;
      do
      {
        long long v27 = *(void **)a1;
        *(void *)a1 = *v26;
        *uint64_t v26 = v27;
        uint64_t v28 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = v26[1];
        v26[1] = v28;
        do
        {
          uint64_t v29 = *(void **)(a1 + 16);
          a1 += 16;
        }
        while ((char)sub_1D0E75EF8(*v29 + 88, *v20 + 88) > 0);
        do
        {
          simd_float3 v30 = (void *)*(v26 - 2);
          v26 -= 2;
        }
        while ((char)sub_1D0E75EF8(*v30 + 88, *v20 + 88) < 1);
      }
      while (a1 < (unint64_t)v26);
    }
    uint64_t v31 = (long long *)(a1 - 16);
    if (a1 - 16 != v117)
    {
      long long v32 = *v31;
      *(void *)uint64_t v31 = 0;
      *(void *)(a1 - 8) = 0;
      unint64_t v33 = *(std::__shared_weak_count **)(v117 + 8);
      *(_OWORD *)uint64_t v117 = v32;
      if (v33)
      {
        if (!atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
      }
    }
    long long v34 = *(std::__shared_weak_count **)(a1 - 8);
    *(_OWORD *)(a1 - 16) = v113;
    if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
    BOOL v4 = v11 >= v23;
    uint64_t v11 = (void *)v117;
    if (!v4) {
      goto LABEL_39;
    }
    BOOL v35 = sub_1D0DF7B58(v117, a1 - 16);
    if (!sub_1D0DF7B58(a1, v10))
    {
      if (v35) {
        goto LABEL_2;
      }
LABEL_39:
      a2 = v10;
      sub_1D0DF688C(v117, a1 - 16, a3, a4 & 1);
      a4 = 0;
      goto LABEL_1;
    }
    unint64_t v10 = a1 - 16;
    if (v35) {
      return;
    }
  }
  BOOL v53 = v11 == (void *)v10 || v12 == v10;
  if (a4)
  {
    if (!v53)
    {
      uint64_t v54 = 0;
      unsigned int v55 = v11;
      do
      {
        uint64_t v56 = (void *)v55[2];
        int v57 = (void *)*v55;
        unsigned int v55 = (void *)v12;
        if ((char)sub_1D0E75EF8(*v56 + 88, *v57 + 88) >= 1)
        {
          long long v58 = *(_OWORD *)v12;
          *(void *)uint64_t v12 = 0;
          *(void *)(v12 + 8) = 0;
          long long v119 = v58;
          uint64_t v59 = (void *)v58;
          uint64_t v60 = v54;
          while (1)
          {
            unsigned int v61 = (char *)v11 + v60;
            long long v62 = *(_OWORD *)((char *)v11 + v60);
            *(void *)unsigned int v61 = 0;
            *((void *)v61 + 1) = 0;
            unsigned int v63 = *(std::__shared_weak_count **)((char *)v11 + v60 + 24);
            *((_OWORD *)v61 + 1) = v62;
            if (v63 && !atomic_fetch_add(&v63->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
              std::__shared_weak_count::__release_weak(v63);
            }
            if (!v60) {
              break;
            }
            char v64 = sub_1D0E75EF8(*v59 + 88, **(void **)((char *)v11 + v60 - 16) + 88);
            v60 -= 16;
            if (v64 <= 0)
            {
              uint64_t v65 = (uint64_t)v11 + v60 + 16;
              goto LABEL_93;
            }
          }
          uint64_t v65 = (uint64_t)v11;
LABEL_93:
          unint64_t v66 = *(std::__shared_weak_count **)(v65 + 8);
          *(_OWORD *)uint64_t v65 = v119;
          if (v66 && !atomic_fetch_add(&v66->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
            std::__shared_weak_count::__release_weak(v66);
          }
        }
        uint64_t v12 = (uint64_t)(v55 + 2);
        v54 += 16;
      }
      while (v55 + 2 != (void *)v10);
    }
  }
  else if (!v53)
  {
    do
    {
      float16x4_t v103 = (void *)v11[2];
      long long v104 = (void *)*v11;
      uint64_t v11 = (void *)v12;
      if ((char)sub_1D0E75EF8(*v103 + 88, *v104 + 88) >= 1)
      {
        long long v105 = *(_OWORD *)v12;
        *(void *)uint64_t v12 = 0;
        *(void *)(v12 + 8) = 0;
        long long v120 = v105;
        float64x2_t v106 = (void *)v105;
        float64x2_t v107 = v11;
        do
        {
          long long v109 = *((_OWORD *)v107 - 1);
          *(v107 - 2) = 0;
          *(v107 - 1) = 0;
          unint64_t v110 = (std::__shared_weak_count *)v107[1];
          *(_OWORD *)float64x2_t v107 = v109;
          if (v110 && !atomic_fetch_add(&v110->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v110->__on_zero_shared)(v110);
            std::__shared_weak_count::__release_weak(v110);
          }
          char v108 = sub_1D0E75EF8(*v106 + 88, *(void *)*(v107 - 4) + 88);
          v107 -= 2;
        }
        while (v108 > 0);
        int v111 = (std::__shared_weak_count *)v107[1];
        *(_OWORD *)float64x2_t v107 = v120;
        if (v111 && !atomic_fetch_add(&v111->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v111->__on_zero_shared)(v111);
          std::__shared_weak_count::__release_weak(v111);
        }
      }
      uint64_t v12 = (uint64_t)(v11 + 2);
    }
    while (v11 + 2 != (void *)v10);
  }
}

void **sub_1D0DF76BC(void **a1)
{
  int v2 = (char *)*a1;
  if (*a1)
  {
    float32x4_t v3 = (char *)a1[1];
    BOOL v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        BOOL v5 = (std::__shared_weak_count *)*((void *)v3 - 1);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      BOOL v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_1D0DF7770(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (char)sub_1D0E75EF8(**(void **)a2 + 88, **(void **)a1 + 88);
  uint64_t result = sub_1D0E75EF8(**(void **)a3 + 88, **(void **)a2 + 88);
  if (v6 > 0)
  {
    uint64_t v8 = *(void **)a1;
    if ((char)result < 1)
    {
      *(void *)a1 = *(void *)a2;
      *(void *)a2 = v8;
      uint64_t v15 = *(void *)(a1 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)(a2 + 8) = v15;
      uint64_t result = sub_1D0E75EF8(**(void **)a3 + 88, **(void **)a2 + 88);
      if ((char)result < 1) {
        return result;
      }
      id v16 = *(void **)a2;
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v16;
      float v9 = (uint64_t *)(a3 + 8);
      unint64_t v10 = (uint64_t *)(a2 + 8);
    }
    else
    {
      *(void *)a1 = *(void *)a3;
      *(void *)a3 = v8;
      float v9 = (uint64_t *)(a3 + 8);
      unint64_t v10 = (uint64_t *)(a1 + 8);
    }
    uint64_t v13 = v9;
    goto LABEL_10;
  }
  if ((char)result >= 1)
  {
    uint64_t v11 = *(void **)a2;
    *(void *)a2 = *(void *)a3;
    *(void *)a3 = v11;
    uint64_t v13 = (uint64_t *)(a2 + 8);
    uint64_t v12 = *(void *)(a2 + 8);
    *(void *)(a2 + 8) = *(void *)(a3 + 8);
    *(void *)(a3 + 8) = v12;
    uint64_t result = sub_1D0E75EF8(**(void **)a2 + 88, **(void **)a1 + 88);
    if ((char)result >= 1)
    {
      uint64_t v14 = *(void **)a1;
      *(void *)a1 = *(void *)a2;
      unint64_t v10 = (uint64_t *)(a1 + 8);
      *(void *)a2 = v14;
LABEL_10:
      uint64_t v17 = *v10;
      *unint64_t v10 = *v13;
      uint64_t *v13 = v17;
    }
  }
  return result;
}

uint64_t sub_1D0DF78E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1D0DF7770(a1, a2, a3);
  uint64_t result = sub_1D0E75EF8(**(void **)a4 + 88, **(void **)a3 + 88);
  if ((char)result >= 1)
  {
    float v9 = *(void **)a3;
    *(void *)a3 = *(void *)a4;
    *(void *)a4 = v9;
    uint64_t v10 = *(void *)(a3 + 8);
    *(void *)(a3 + 8) = *(void *)(a4 + 8);
    *(void *)(a4 + 8) = v10;
    uint64_t result = sub_1D0E75EF8(**(void **)a3 + 88, **(void **)a2 + 88);
    if ((char)result >= 1)
    {
      uint64_t v11 = *(void **)a2;
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v11;
      uint64_t v12 = *(void *)(a2 + 8);
      *(void *)(a2 + 8) = *(void *)(a3 + 8);
      *(void *)(a3 + 8) = v12;
      uint64_t result = sub_1D0E75EF8(**(void **)a2 + 88, **(void **)a1 + 88);
      if ((char)result >= 1)
      {
        uint64_t v13 = *(void **)a1;
        *(void *)a1 = *(void *)a2;
        *(void *)a2 = v13;
        uint64_t v14 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = *(void *)(a2 + 8);
        *(void *)(a2 + 8) = v14;
      }
    }
  }
  return result;
}

uint64_t sub_1D0DF79F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_1D0DF78E4(a1, a2, a3, a4);
  uint64_t result = sub_1D0E75EF8(**(void **)a5 + 88, **(void **)a4 + 88);
  if ((char)result >= 1)
  {
    uint64_t v11 = *(void **)a4;
    *(void *)a4 = *(void *)a5;
    *(void *)a5 = v11;
    uint64_t v12 = *(void *)(a4 + 8);
    *(void *)(a4 + 8) = *(void *)(a5 + 8);
    *(void *)(a5 + 8) = v12;
    uint64_t result = sub_1D0E75EF8(**(void **)a4 + 88, **(void **)a3 + 88);
    if ((char)result >= 1)
    {
      uint64_t v13 = *(void **)a3;
      *(void *)a3 = *(void *)a4;
      *(void *)a4 = v13;
      uint64_t v14 = *(void *)(a3 + 8);
      *(void *)(a3 + 8) = *(void *)(a4 + 8);
      *(void *)(a4 + 8) = v14;
      uint64_t result = sub_1D0E75EF8(**(void **)a3 + 88, **(void **)a2 + 88);
      if ((char)result >= 1)
      {
        uint64_t v15 = *(void **)a2;
        *(void *)a2 = *(void *)a3;
        *(void *)a3 = v15;
        uint64_t v16 = *(void *)(a2 + 8);
        *(void *)(a2 + 8) = *(void *)(a3 + 8);
        *(void *)(a3 + 8) = v16;
        uint64_t result = sub_1D0E75EF8(**(void **)a2 + 88, **(void **)a1 + 88);
        if ((char)result >= 1)
        {
          uint64_t v17 = *(void **)a1;
          *(void *)a1 = *(void *)a2;
          *(void *)a2 = v17;
          uint64_t v18 = *(void *)(a1 + 8);
          *(void *)(a1 + 8) = *(void *)(a2 + 8);
          *(void *)(a2 + 8) = v18;
        }
      }
    }
  }
  return result;
}

BOOL sub_1D0DF7B58(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if ((char)sub_1D0E75EF8(**(void **)(a2 - 16) + 88, **(void **)a1 + 88) < 1) {
        return 1;
      }
      int v6 = *(void **)a1;
      *(void *)a1 = *(void *)(a2 - 16);
      *(void *)(a2 - 16) = v6;
      uint64_t v7 = *(void *)(a1 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 - 8);
      *(void *)(a2 - 8) = v7;
      return 1;
    case 3:
      sub_1D0DF7770(a1, a1 + 16, a2 - 16);
      return 1;
    case 4:
      sub_1D0DF78E4(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      sub_1D0DF79F4(a1, a1 + 16, a1 + 32, a1 + 48, a2 - 16);
      return 1;
    default:
      uint64_t v8 = (void **)(a1 + 32);
      sub_1D0DF7770(a1, a1 + 16, a1 + 32);
      uint64_t v9 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    if ((char)sub_1D0E75EF8(**(void **)v9 + 88, **v8 + 88) >= 1)
    {
      long long v12 = *(_OWORD *)v9;
      *(void *)uint64_t v9 = 0;
      *(void *)(v9 + 8) = 0;
      long long v21 = v12;
      uint64_t v13 = (void *)v12;
      uint64_t v14 = v10;
      while (1)
      {
        uint64_t v15 = a1 + v14;
        long long v16 = *(_OWORD *)(a1 + v14 + 32);
        *(void *)(v15 + 32) = 0;
        *(void *)(v15 + 40) = 0;
        uint64_t v17 = *(std::__shared_weak_count **)(a1 + v14 + 56);
        *(_OWORD *)(v15 + 48) = v16;
        if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
        if (v14 == -32) {
          break;
        }
        char v18 = sub_1D0E75EF8(*v13 + 88, **(void **)(a1 + v14 + 16) + 88);
        v14 -= 16;
        if (v18 <= 0)
        {
          uint64_t v19 = a1 + v14 + 48;
          goto LABEL_17;
        }
      }
      uint64_t v19 = a1;
LABEL_17:
      BOOL v20 = *(std::__shared_weak_count **)(v19 + 8);
      *(_OWORD *)uint64_t v19 = v21;
      if (v20)
      {
        if (!atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
      if (++v11 == 8) {
        return v9 + 16 == a2;
      }
    }
    uint64_t v8 = (void **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2) {
      return 1;
    }
  }
}

void *sub_1D0DF7E18(uint64_t a1, unint64_t a2, void *a3)
{
  if (!a2) {
    return 0;
  }
  unint64_t v3 = a3[1] ^ *a3;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = a3[1] ^ *a3;
    if (v3 >= a2) {
      unint64_t v5 = v3 % a2;
    }
  }
  else
  {
    unint64_t v5 = (a2 - 1) & v3;
  }
  int v6 = *(void **)(a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  BOOL result = (void *)*v6;
  if (*v6)
  {
    if (v4.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v11 = result[1];
        if (v3 == v11)
        {
          if (result[2] == *a3 && result[3] == a3[1]) {
            return result;
          }
        }
        else if ((v11 & (a2 - 1)) != v5)
        {
          return 0;
        }
        BOOL result = (void *)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v9 = result[1];
      if (v3 == v9)
      {
        if (result[2] == *a3 && result[3] == a3[1]) {
          return result;
        }
      }
      else
      {
        if (v9 >= a2) {
          v9 %= a2;
        }
        if (v9 != v5) {
          return 0;
        }
      }
      BOOL result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void sub_1D0DF7EFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v3 = a2;
    uint64_t v5 = a3;
    uint64_t v6 = *(void *)(a1 + 8);
    if (a3 != v6)
    {
      uint64_t v7 = 16 * ((a3 - a2) >> 4);
      do
      {
        uint64_t v8 = (void *)(v3 + v7);
        long long v9 = *(_OWORD *)(v3 + v7);
        void *v8 = 0;
        v8[1] = 0;
        uint64_t v10 = *(std::__shared_weak_count **)(v3 + 8);
        *(_OWORD *)uint64_t v3 = v9;
        if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        v3 += 16;
      }
      while (v3 + v7 != v6);
      uint64_t v5 = *(void *)(a1 + 8);
    }
    for (; v5 != v3; v5 -= 16)
    {
      uint64_t v11 = *(std::__shared_weak_count **)(v5 - 8);
      if (v11)
      {
        if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
    }
    *(void *)(a1 + 8) = v3;
  }
}

void sub_1D0DF8034(const unsigned __int8 **a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (!(*a1)[16])
  {
    MEMORY[0x1D25F21B0](out);
    int v2 = *a1;
    int v3 = (*a1)[16];
    *(_OWORD *)*a1 = *(_OWORD *)out;
    if (!v3) {
      *((unsigned char *)v2 + 16) = 1;
    }
    uint8x8_t v4 = *a1;
    uint64_t v5 = (char *)(*a1 + 160);
    if ((*a1)[16])
    {
      memset(out, 0, sizeof(out));
      uuid_unparse_upper(v4, out);
      uint64_t v6 = operator new(0x28uLL);
      long long v7 = *(_OWORD *)&out[16];
      _OWORD *v6 = *(_OWORD *)out;
      v6[1] = v7;
      *((_DWORD *)v6 + 8) = *(_DWORD *)&out[32];
      *((unsigned char *)v6 + 36) = 0;
      snprintf(v5, 0x40uLL, "(%p uuid=%s)", a1, (const char *)v6);
      operator delete(v6);
    }
    else
    {
      snprintf(v5, 0x40uLL, "(%p uuid=%s)", a1, "unset");
    }
  }
}

void *sub_1D0DF8148(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1[1] - *a1;
  uint64_t v3 = v2 >> 3;
  unint64_t v4 = (v2 >> 3) + 1;
  if (v4 >> 61) {
    abort();
  }
  uint64_t v7 = a1[2] - *a1;
  if (v7 >> 2 > v4) {
    unint64_t v4 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v4;
  }
  if (v8)
  {
    if (v8 >> 61) {
      sub_1D0DE8CE0();
    }
    uint64_t v9 = (char *)operator new(8 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v10 = &v9[8 * v3];
  uint64_t v11 = &v9[8 * v8];
  uint64_t v12 = *a2;
  *a2 = 0;
  *(void *)uint64_t v10 = v12;
  uint64_t v13 = v10 + 8;
  uint64_t v14 = (char *)*a1;
  uint64_t v15 = (char *)a1[1];
  if (v15 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
  }
  else
  {
    unint64_t v16 = (unint64_t)&v15[-*a1 - 8];
    if (v16 < 0x78 || &v15[-(v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v10 && &v9[v2 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v15) {
      goto LABEL_31;
    }
    uint64_t v17 = (v16 >> 3) + 1;
    uint64_t v18 = 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v19 = &v15[-v18];
    v10 -= v18;
    BOOL v20 = &v9[8 * v3 - 16];
    long long v21 = v15 - 16;
    uint64_t v22 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v24 = *((_OWORD *)v21 - 1);
      long long v23 = *(_OWORD *)v21;
      *((_OWORD *)v21 - 1) = 0uLL;
      *(_OWORD *)long long v21 = 0uLL;
      *((_OWORD *)v20 - 1) = v24;
      *(_OWORD *)BOOL v20 = v23;
      v20 -= 32;
      v21 -= 32;
      v22 -= 4;
    }
    while (v22);
    uint64_t v15 = v19;
    if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_31:
      do
      {
        uint64_t v25 = *((void *)v15 - 1);
        v15 -= 8;
        *(void *)uint64_t v15 = 0;
        *((void *)v10 - 1) = v25;
        v10 -= 8;
      }
      while (v15 != v14);
    }
    uint64_t v15 = (char *)*a1;
    uint64_t v26 = (char *)a1[1];
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
    while (v26 != v15)
    {
      uint64_t v28 = (void **)*((void *)v26 - 1);
      v26 -= 8;
      long long v27 = v28;
      *(void *)uint64_t v26 = 0;
      if (v28)
      {
        free(v27[3]);
        free(*v27);
        MEMORY[0x1D25F16B0](v27, 0x1080C407C7A2332);
      }
    }
  }
  if (v15) {
    operator delete(v15);
  }
  return v13;
}

uint64_t sub_1D0DF8300(uint64_t a1)
{
  *(unsigned char *)a1 = 0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1618))
  {
    sub_1D0E225B4();
  }
  *(_WORD *)(a1 + 1) = *(unsigned __int8 *)(qword_1EB9F15F8 + 106);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1618))
  {
    sub_1D0E225B4();
  }
  *(unsigned char *)(a1 + 3) = *(unsigned char *)(qword_1EB9F15F8 + 108);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1618))
  {
    sub_1D0E225B4();
  }
  *(unsigned char *)(a1 + 4) = *(unsigned char *)(qword_1EB9F15F8 + 216);
  *(_DWORD *)(a1 + 5) = 0;
  *(unsigned char *)(a1 + 9) = 0;
  *(_DWORD *)(a1 + 12) = 1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1618))
  {
    sub_1D0E225B4();
  }
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(qword_1EB9F15F8 + 312);
  sub_1D0E533F8((std::string *)(a1 + 24), "resources_facekit/");
  *(void *)(a1 + 48) = 0x100000000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1618))
  {
    sub_1D0E225B4();
  }
  uint64_t v2 = qword_1EB9F15F8;
  long long v4 = *(_OWORD *)(qword_1EB9F15F8 + 16);
  long long v3 = *(_OWORD *)(qword_1EB9F15F8 + 32);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)qword_1EB9F15F8;
  *(_OWORD *)(a1 + 72) = v4;
  *(_OWORD *)(a1 + 88) = v3;
  long long v6 = *(_OWORD *)(v2 + 64);
  long long v5 = *(_OWORD *)(v2 + 80);
  uint64_t v7 = *(void *)(v2 + 96);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(v2 + 48);
  *(void *)(a1 + 152) = v7;
  *(_OWORD *)(a1 + 136) = v5;
  *(_OWORD *)(a1 + 120) = v6;
  return a1;
}

void sub_1D0DF84AC(_Unwind_Exception *a1)
{
}

double sub_1D0DF84D4(unsigned __int8 *a1)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v2 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    int v3 = *a1;
    int v45 = 67109120;
    LODWORD(v46) = v3;
    _os_log_impl(&dword_1D0DBD000, v2, OS_LOG_TYPE_INFO, "using rgb only: %d", (uint8_t *)&v45, 8u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  long long v4 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    int v5 = a1[1];
    int v45 = 67109120;
    LODWORD(v46) = v5;
    _os_log_impl(&dword_1D0DBD000, v4, OS_LOG_TYPE_INFO, "using recognition: %d", (uint8_t *)&v45, 8u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  long long v6 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    int v7 = a1[2];
    int v45 = 67109120;
    LODWORD(v46) = v7;
    _os_log_impl(&dword_1D0DBD000, v6, OS_LOG_TYPE_INFO, "using force CPU: %d", (uint8_t *)&v45, 8u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  unint64_t v8 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    int v9 = a1[3];
    int v45 = 67109120;
    LODWORD(v46) = v9;
    _os_log_impl(&dword_1D0DBD000, v8, OS_LOG_TYPE_INFO, "using tongue: %d", (uint8_t *)&v45, 8u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v10 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    int v11 = a1[4];
    int v45 = 67109120;
    LODWORD(v46) = v11;
    _os_log_impl(&dword_1D0DBD000, v10, OS_LOG_TYPE_INFO, "using robust tongue: %d", (uint8_t *)&v45, 8u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v12 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    int v13 = *((_DWORD *)a1 + 12);
    int v45 = 67109120;
    LODWORD(v46) = v13;
    _os_log_impl(&dword_1D0DBD000, v12, OS_LOG_TYPE_INFO, "using pyramid behavior: %d", (uint8_t *)&v45, 8u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v14 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    int v15 = a1[5];
    int v45 = 67109120;
    LODWORD(v46) = v15;
    _os_log_impl(&dword_1D0DBD000, v14, OS_LOG_TYPE_INFO, "running deterministically: %d", (uint8_t *)&v45, 8u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  unint64_t v16 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    int v17 = *((_DWORD *)a1 + 3);
    int v45 = 67109120;
    LODWORD(v46) = v17;
    _os_log_impl(&dword_1D0DBD000, v16, OS_LOG_TYPE_INFO, "running with #faces: %d", (uint8_t *)&v45, 8u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v18 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    int v19 = *((_DWORD *)a1 + 4);
    int v45 = 67109120;
    LODWORD(v46) = v19;
    _os_log_impl(&dword_1D0DBD000, v18, OS_LOG_TYPE_INFO, "using recognition update period: %d", (uint8_t *)&v45, 8u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  BOOL v20 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    long long v21 = a1 + 24;
    if ((char)a1[47] < 0) {
      long long v21 = (void *)*v21;
    }
    int v45 = 136315138;
    double v46 = *(double *)&v21;
    _os_log_impl(&dword_1D0DBD000, v20, OS_LOG_TYPE_INFO, "using resource path: %s", (uint8_t *)&v45, 0xCu);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v22 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    int v23 = a1[6];
    int v45 = 67109120;
    LODWORD(v46) = v23;
    _os_log_impl(&dword_1D0DBD000, v22, OS_LOG_TYPE_INFO, "using face detector: %d", (uint8_t *)&v45, 8u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  long long v24 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    int v25 = a1[7];
    int v45 = 67109120;
    LODWORD(v46) = v25;
    _os_log_impl(&dword_1D0DBD000, v24, OS_LOG_TYPE_INFO, "using key points: %d", (uint8_t *)&v45, 8u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v26 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    int v27 = a1[8];
    int v45 = 67109120;
    LODWORD(v46) = v27;
    _os_log_impl(&dword_1D0DBD000, v26, OS_LOG_TYPE_INFO, "using pose refinement: %d", (uint8_t *)&v45, 8u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v28 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    int v29 = a1[9];
    int v45 = 67109120;
    LODWORD(v46) = v29;
    _os_log_impl(&dword_1D0DBD000, v28, OS_LOG_TYPE_INFO, "using caranet_plus: %d", (uint8_t *)&v45, 8u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  simd_float3 v30 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    int v31 = *((_DWORD *)a1 + 13);
    int v45 = 67109120;
    LODWORD(v46) = v31;
    _os_log_impl(&dword_1D0DBD000, v30, OS_LOG_TYPE_INFO, "using depth source: %d", (uint8_t *)&v45, 8u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  long long v32 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    double v33 = *((float *)a1 + 15);
    int v45 = 134217984;
    double v46 = v33;
    _os_log_impl(&dword_1D0DBD000, v32, OS_LOG_TYPE_INFO, "using failure threshold: %f", (uint8_t *)&v45, 0xCu);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  long long v34 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    double v35 = *((float *)a1 + 17);
    int v45 = 134217984;
    double v46 = v35;
    _os_log_impl(&dword_1D0DBD000, v34, OS_LOG_TYPE_INFO, "using bounding box tolerance: %f", (uint8_t *)&v45, 0xCu);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  long long v36 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    double v37 = *((float *)a1 + 35);
    int v45 = 134217984;
    double v46 = v37;
    _os_log_impl(&dword_1D0DBD000, v36, OS_LOG_TYPE_INFO, "using max angle: %f", (uint8_t *)&v45, 0xCu);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  double v38 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    double v39 = *((float *)a1 + 39);
    int v45 = 134217984;
    double v46 = v39;
    _os_log_impl(&dword_1D0DBD000, v38, OS_LOG_TYPE_INFO, "using max distance for tracking: %f mm", (uint8_t *)&v45, 0xCu);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  double v40 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    double v41 = *((float *)a1 + 37);
    int v45 = 134217984;
    double v46 = v41;
    _os_log_impl(&dword_1D0DBD000, v40, OS_LOG_TYPE_INFO, "using max distance for fitting: %f mm", (uint8_t *)&v45, 0xCu);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v42 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
  {
    double v44 = *((float *)a1 + 29);
    int v45 = 134217984;
    double v46 = v44;
    _os_log_impl(&dword_1D0DBD000, v42, OS_LOG_TYPE_INFO, "using max angle for recognition: %f", (uint8_t *)&v45, 0xCu);
  }
  return result;
}

uint64_t sub_1D0DF909C(unsigned int *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1618))
  {
    sub_1D0E225B4();
  }
  if (*(unsigned char *)(qword_1EB9F15F8 + 105)) {
    unsigned int v2 = 3;
  }
  else {
    unsigned int v2 = 1;
  }
  if (*((unsigned char *)a1 + 4)) {
    uint64_t v3 = *a1;
  }
  else {
    uint64_t v3 = v2;
  }
  if ((v3 - 4) <= 0xFFFFFFFC)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    long long v4 = qword_1EB9F1620;
    if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEFAULT))
    {
      v7[0] = 67109376;
      v7[1] = v3;
      __int16 v8 = 1024;
      int v9 = 3;
      _os_log_impl(&dword_1D0DBD000, v4, OS_LOG_TYPE_DEFAULT, "Unsupported number of faces: %i, limiting to range [1, %i]", (uint8_t *)v7, 0xEu);
    }
    if ((int)v3 >= 3) {
      int v5 = 3;
    }
    else {
      int v5 = v3;
    }
    if (v5 <= 1) {
      return 1;
    }
    else {
      return v5;
    }
  }
  return v3;
}

void sub_1D0DF9214(_Unwind_Exception *a1)
{
}

void *sub_1D0DF922C(void *__dst, void *__src, size_t __len)
{
  if (__len > 0x16)
  {
    if (__len - 0x7FFFFFFFFFFFFFF7 <= 0x800000000000001ELL) {
      abort();
    }
    size_t v7 = 44;
    if (__len > 0x2C) {
      size_t v7 = __len;
    }
    size_t v8 = (v7 | 7) + 1;
    long long v6 = operator new(v8);
    memcpy(v6, __src, __len);
    __dst[1] = __len;
    CVPixelBufferRef __dst[2] = v8 | 0x8000000000000000;
    *std::string __dst = v6;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    long long v6 = __dst;
    if (__len)
    {
      memmove(__dst, __src, __len);
      long long v6 = __dst;
    }
  }
  *((unsigned char *)v6 + __len) = 0;
  return __dst;
}

void **sub_1D0DF92F0(void **a1, void *__src, size_t __len)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t v7 = v6 & 0x7FFFFFFFFFFFFFFFLL;
  if ((v6 & 0x7FFFFFFFFFFFFFFFLL) <= __len)
  {
    size_t v9 = 0x7FFFFFFFFFFFFFF7;
    if (0x7FFFFFFFFFFFFFF7 - v7 < __len - v7 + 1) {
      abort();
    }
    unint64_t v10 = v7 - 1;
    int v11 = a1;
    if ((v6 & 0x8000000000000000) != 0) {
      int v11 = *a1;
    }
    if (v10 <= 0x3FFFFFFFFFFFFFF2)
    {
      unint64_t v12 = 2 * v10;
      if (__len > 2 * v10) {
        unint64_t v12 = __len;
      }
      uint64_t v13 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v12 | 7) != 0x17) {
        uint64_t v13 = v12 | 7;
      }
      if (v12 >= 0x17) {
        size_t v9 = v13 + 1;
      }
      else {
        size_t v9 = 23;
      }
    }
    uint64_t v14 = operator new(v9);
    size_t v8 = v14;
    if (__len) {
      memcpy(v14, __src, __len);
    }
    if (v10 != 22) {
      operator delete(v11);
    }
    a1[1] = (void *)__len;
    a1[2] = (void *)(v9 | 0x8000000000000000);
    *a1 = v8;
  }
  else
  {
    size_t v8 = *a1;
    a1[1] = (void *)__len;
    if (__len) {
      memmove(v8, __src, __len);
    }
  }
  *((unsigned char *)v8 + __len) = 0;
  return a1;
}

void sub_1D0DF9410(uint64_t a1, float *a2, uint64_t a3, unint64_t a4, float *a5, uint64_t a6, float a7)
{
  if (a4 >= 2)
  {
    if (a4 == 2)
    {
      float v9 = *(float *)(a1 + 16);
      if (*(a2 - 2) > v9)
      {
        unint64_t v10 = a2 - 6;
        long long v11 = *(_OWORD *)a1;
        *(void *)a1 = 0;
        *(void *)(a1 + 8) = 0;
        long long v12 = *(_OWORD *)(a2 - 6);
        *(void *)unint64_t v10 = 0;
        *((void *)v10 + 1) = 0;
        uint64_t v13 = *(std::__shared_weak_count **)(a1 + 8);
        *(_OWORD *)a1 = v12;
        if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          long long v53 = v11;
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
          long long v11 = v53;
        }
        *(float *)(a1 + 16) = *(a2 - 2);
        uint64_t v14 = (std::__shared_weak_count *)*((void *)a2 - 2);
        *(_OWORD *)(a2 - 6) = v11;
        if (v14)
        {
          if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
        }
        *(a2 - 2) = v9;
      }
    }
    else if ((uint64_t)a4 <= 0)
    {
      if ((float *)a1 != a2)
      {
        uint64_t v22 = a1 + 24;
        if ((float *)(a1 + 24) != a2)
        {
          uint64_t v23 = 0;
          uint64_t v24 = a1;
          do
          {
            uint64_t v25 = v22;
            if (*(float *)(v24 + 40) > *(float *)(v24 + 16))
            {
              long long v54 = *(_OWORD *)v22;
              *(void *)uint64_t v22 = 0;
              *(void *)(v22 + 8) = 0;
              float v26 = *(float *)(v24 + 40);
              uint64_t v27 = v23;
              while (1)
              {
                uint64_t v28 = a1 + v27;
                long long v29 = *(_OWORD *)(a1 + v27);
                *(void *)uint64_t v28 = 0;
                *(void *)(v28 + 8) = 0;
                simd_float3 v30 = *(std::__shared_weak_count **)(a1 + v27 + 32);
                *(_OWORD *)(v28 + 24) = v29;
                if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
                  std::__shared_weak_count::__release_weak(v30);
                }
                *(_DWORD *)(v28 + 40) = *(_DWORD *)(v28 + 16);
                if (!v27) {
                  break;
                }
                float v31 = *(float *)(a1 + v27 - 8);
                v27 -= 24;
                if (v26 <= v31)
                {
                  uint64_t v32 = a1 + v27 + 24;
                  goto LABEL_31;
                }
              }
              uint64_t v32 = a1;
LABEL_31:
              double v33 = *(std::__shared_weak_count **)(v32 + 8);
              *(_OWORD *)uint64_t v32 = v54;
              if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
                std::__shared_weak_count::__release_weak(v33);
              }
              *(float *)(v32 + 16) = v26;
            }
            uint64_t v22 = v25 + 24;
            v23 += 24;
            uint64_t v24 = v25;
          }
          while ((float *)(v25 + 24) != a2);
        }
      }
    }
    else
    {
      uint64_t v19 = a4 >> 1;
      BOOL v20 = (long long *)(a1 + 24 * (a4 >> 1));
      if ((uint64_t)a4 <= a6)
      {
        float v34 = sub_1D0DF9F44((float *)a1, (float *)(a1 + 24 * (a4 >> 1)), a3, a4 >> 1, (uint64_t)a5, a7);
        unint64_t v35 = a4 - v19;
        uint64_t v36 = (uint64_t)&a5[6 * v19];
        v37.n128_f32[0] = sub_1D0DF9F44((float *)(a1 + 24 * (a4 >> 1)), a2, a3, v35, v36, v34);
        double v38 = &a5[6 * a4];
        unint64_t v55 = a4;
        uint64_t v39 = a1 + 8;
        double v40 = (__n128 *)v36;
        double v41 = (__n128 *)a5;
        while (v40 != (__n128 *)v38)
        {
          if (v40[1].n128_f32[0] <= v41[1].n128_f32[0])
          {
            __n128 v37 = *v41;
            v41->n128_u64[0] = 0;
            v41->n128_u64[1] = 0;
            uint64_t v43 = *(std::__shared_weak_count **)v39;
            *(__n128 *)(v39 - 8) = v37;
            if (v43 && !atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
              std::__shared_weak_count::__release_weak(v43);
            }
            v37.n128_u32[0] = v41[1].n128_u32[0];
            *(_DWORD *)(v39 + 8) = v37.n128_u32[0];
            double v41 = (__n128 *)((char *)v41 + 24);
          }
          else
          {
            __n128 v37 = *v40;
            v40->n128_u64[0] = 0;
            v40->n128_u64[1] = 0;
            uint64_t v42 = *(std::__shared_weak_count **)v39;
            *(__n128 *)(v39 - 8) = v37;
            if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
              std::__shared_weak_count::__release_weak(v42);
            }
            v37.n128_u32[0] = v40[1].n128_u32[0];
            *(_DWORD *)(v39 + 8) = v37.n128_u32[0];
            double v40 = (__n128 *)((char *)v40 + 24);
          }
          v39 += 24;
          if (v41 == (__n128 *)v36)
          {
            if (v40 != (__n128 *)v38)
            {
              uint64_t v47 = 0;
              do
              {
                unsigned int v48 = (char *)v40 + v47;
                __n128 v37 = *(__n128 *)((char *)v40 + v47);
                *(void *)unsigned int v48 = 0;
                *((void *)v48 + 1) = 0;
                float v49 = *(std::__shared_weak_count **)(v39 + v47);
                *(__n128 *)(v39 + v47 - 8) = v37;
                if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
                  std::__shared_weak_count::__release_weak(v49);
                }
                v37.n128_u32[0] = *((_DWORD *)v48 + 4);
                *(_DWORD *)(v39 + v47 + 8) = v37.n128_u32[0];
                v47 += 24;
              }
              while (v48 + 24 != (char *)v38);
            }
            goto LABEL_58;
          }
        }
        if (v41 != (__n128 *)v36)
        {
          uint64_t v44 = 0;
          do
          {
            int v45 = (char *)v41 + v44;
            __n128 v37 = *(__n128 *)((char *)v41 + v44);
            *(void *)int v45 = 0;
            *((void *)v45 + 1) = 0;
            double v46 = *(std::__shared_weak_count **)(v39 + v44);
            *(__n128 *)(v39 + v44 - 8) = v37;
            if (v46 && !atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
              std::__shared_weak_count::__release_weak(v46);
            }
            v37.n128_u32[0] = *((_DWORD *)v45 + 4);
            *(_DWORD *)(v39 + v44 + 8) = v37.n128_u32[0];
            v44 += 24;
          }
          while (v45 + 24 != (char *)v36);
        }
LABEL_58:
        if (a5)
        {
          unint64_t v50 = 0;
          uint64_t v51 = (std::__shared_weak_count **)(a5 + 2);
          do
          {
            uint64_t v52 = *v51;
            if (*v51 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *, __n128))v52->__on_zero_shared)(v52, v37);
              std::__shared_weak_count::__release_weak(v52);
            }
            ++v50;
            v51 += 3;
          }
          while (v50 < v55);
        }
      }
      else
      {
        sub_1D0DF9410(a1, a1 + 24 * (a4 >> 1), a3, a4 >> 1, a5, a6);
        uint64_t v21 = a4 - v19;
        sub_1D0DF9410(v20, a2, a3, v21, a5, a6);
        sub_1D0DFA36C((long long *)a1, v20, (char *)a2, a3, v19, v21, a5, a6);
      }
    }
  }
}

void sub_1D0DF9A0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1D0DFA2B4((uint64_t *)va);
  _Unwind_Resume(a1);
}

__n128 *sub_1D0DF9A20(uint64_t a1, __n128 a2)
{
  unsigned int v2 = *(__n128 **)a1;
  uint64_t v3 = *(__n128 **)(a1 + 8);
  uint64_t v4 = ((uint64_t)v3 - *(void *)a1) >> 4;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60) {
    abort();
  }
  uint64_t v7 = *(void *)(a1 + 16) - (void)v2;
  if (v7 >> 3 > v5) {
    unint64_t v5 = v7 >> 3;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v5 = 0xFFFFFFFFFFFFFFFLL;
  }
  if (v5 >> 60) {
    sub_1D0DE8CE0();
  }
  uint64_t v8 = 16 * v5;
  float v9 = (char *)operator new(16 * v5);
  unint64_t v10 = (__n128 *)&v9[16 * v4];
  *unint64_t v10 = a2;
  if (a2.n128_u64[1])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a2.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
    unsigned int v2 = *(__n128 **)a1;
    uint64_t v3 = *(__n128 **)(a1 + 8);
  }
  long long v11 = &v9[v8];
  long long v12 = v10 + 1;
  if (v3 == v2)
  {
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v12;
    *(void *)(a1 + 16) = v11;
  }
  else
  {
    do
    {
      __n128 v13 = v3[-1];
      --v3;
      v10[-1] = v13;
      --v10;
      v3->n128_u64[0] = 0;
      v3->n128_u64[1] = 0;
    }
    while (v3 != v2);
    unsigned int v2 = *(__n128 **)a1;
    uint64_t v14 = *(__n128 **)(a1 + 8);
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v12;
    for (*(void *)(a1 + 16) = v11; v14 != v2; --v14)
    {
      int v15 = (std::__shared_weak_count *)v14[-1].n128_u64[1];
      if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
  if (v2) {
    operator delete(v2);
  }
  return v12;
}

uint64_t sub_1D0DF9B88(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  *(void *)(result + 24) = 0;
  if (v1)
  {
    unsigned int v2 = *(std::__shared_weak_count **)(v1 + 152);
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    free(*(void **)(v1 + 120));
    uint64_t v3 = *(void **)(v1 + 24);
    if (v3)
    {
      uint64_t v4 = *(void **)(v1 + 32);
      unint64_t v5 = *(void **)(v1 + 24);
      if (v4 != v3)
      {
        do
        {
          uint64_t v7 = (void **)*--v4;
          unint64_t v6 = v7;
          void *v4 = 0;
          if (v7)
          {
            free(v6[3]);
            free(*v6);
            MEMORY[0x1D25F16B0](v6, 0x1080C407C7A2332);
          }
        }
        while (v4 != v3);
        unint64_t v5 = *(void **)(v1 + 24);
      }
      *(void *)(v1 + 32) = v3;
      operator delete(v5);
    }
    JUMPOUT(0x1D25F16B0);
  }
  return result;
}

void sub_1D0DF9CA4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4BF0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0DF9CF8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4BF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_1D0DF9D1C(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 24);
  *(void *)(result + 24) = 0;
  if (v1)
  {
    uint64_t v2 = v1[19];
    v1[19] = 0;
    if (v2)
    {
      uint64_t v3 = sub_1D0E3EEE4(v2);
      MEMORY[0x1D25F16B0](v3, 0x10E0C4016A603E8);
    }
    uint64_t v4 = (std::__shared_weak_count *)v1[18];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    unint64_t v5 = (void **)(v1 + 11);
    sub_1D0E3F1C8(v1 + 11);
    unint64_t v6 = (void **)v1[12];
    uint64_t v7 = (void **)v1[13];
    if (v6 != v7)
    {
      do
      {
        uint64_t v8 = *v6++;
        operator delete(v8);
      }
      while (v6 != v7);
      uint64_t v10 = v1[12];
      uint64_t v9 = v1[13];
      if (v9 != v10) {
        v1[13] = v9 + ((v10 - v9 + 7) & 0xFFFFFFFFFFFFFFF8);
      }
    }
    if (*v5) {
      operator delete(*v5);
    }
    long long v11 = (std::__shared_weak_count *)v1[4];
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    long long v12 = (std::__shared_weak_count *)v1[2];
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    JUMPOUT(0x1D25F16B0);
  }
  return result;
}

void sub_1D0DF9ED0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4C60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0DF9F24(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4C60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

float sub_1D0DF9F44(float *a1, float *a2, uint64_t a3, unint64_t a4, uint64_t a5, float result)
{
  if (a4)
  {
    uint64_t v6 = a5;
    uint64_t v9 = (long long *)a1;
    if (a4 == 2)
    {
      float v12 = *(a2 - 2);
      __n128 v13 = a2 - 6;
      uint64_t v10 = a1 + 4;
      float v14 = a1[4];
      long long v11 = (_DWORD *)(a5 + 40);
      if (v12 <= v14)
      {
        *(_OWORD *)a5 = *(_OWORD *)a1;
        *(void *)a1 = 0;
        *((void *)a1 + 1) = 0;
        *(float *)(a5 + 16) = v14;
        *(_OWORD *)(a5 + 24) = *(_OWORD *)v13;
        *(void *)__n128 v13 = 0;
        *((void *)a2 - 2) = 0;
        uint64_t v10 = a2 - 2;
      }
      else
      {
        *(_OWORD *)a5 = *(_OWORD *)v13;
        *(void *)__n128 v13 = 0;
        *((void *)a2 - 2) = 0;
        *(float *)(a5 + 16) = v12;
        *(_OWORD *)(a5 + 24) = *(_OWORD *)a1;
        *(void *)a1 = 0;
        *((void *)a1 + 1) = 0;
      }
      goto LABEL_27;
    }
    if (a4 == 1)
    {
      *(_OWORD *)a5 = *(_OWORD *)a1;
      *(void *)a1 = 0;
      *((void *)a1 + 1) = 0;
      uint64_t v10 = a1 + 4;
      long long v11 = (_DWORD *)(a5 + 16);
LABEL_27:
      double result = *v10;
      *long long v11 = *(_DWORD *)v10;
      return result;
    }
    if ((uint64_t)a4 > 8)
    {
      unint64_t v28 = a4 >> 1;
      uint64_t v29 = 24 * (a4 >> 1);
      simd_float3 v30 = (long long *)&a1[(unint64_t)v29 / 4];
      sub_1D0DF9410(a1, &a1[(unint64_t)v29 / 4], a3, a4 >> 1, a5, a4 >> 1);
      sub_1D0DF9410((char *)v9 + v29, a2, a3, a4 - v28, v6 + v29, a4 - v28);
      uint64_t v31 = (uint64_t)v9 + v29;
      while ((float *)v31 != a2)
      {
        double result = *(float *)(v31 + 16);
        float v32 = *((float *)v9 + 4);
        if (result <= v32)
        {
          *(_OWORD *)uint64_t v6 = *v9;
          *(void *)uint64_t v9 = 0;
          *((void *)v9 + 1) = 0;
          uint64_t v9 = (long long *)((char *)v9 + 24);
          double result = v32;
        }
        else
        {
          *(_OWORD *)uint64_t v6 = *(_OWORD *)v31;
          *(void *)uint64_t v31 = 0;
          *(void *)(v31 + 8) = 0;
          v31 += 24;
        }
        *(float *)(v6 + 16) = result;
        v6 += 24;
        if (v9 == v30)
        {
          if ((float *)v31 != a2)
          {
            uint64_t v36 = 0;
            do
            {
              __n128 v37 = (void *)(v31 + v36);
              uint64_t v38 = v6 + v36;
              *(_OWORD *)uint64_t v38 = *(_OWORD *)(v31 + v36);
              void *v37 = 0;
              v37[1] = 0;
              double result = *(float *)(v31 + v36 + 16);
              *(float *)(v38 + 16) = result;
              v36 += 24;
            }
            while (v37 + 3 != (void *)a2);
          }
          return result;
        }
      }
      if (v9 != v30)
      {
        uint64_t v33 = 0;
        do
        {
          uint64_t v34 = v6 + v33;
          unint64_t v35 = (void *)((char *)v9 + v33);
          *(_OWORD *)uint64_t v34 = *(long long *)((char *)v9 + v33);
          *unint64_t v35 = 0;
          v35[1] = 0;
          double result = *(float *)((char *)v9 + v33 + 16);
          *(float *)(v34 + 16) = result;
          v33 += 24;
        }
        while (v35 + 3 != (void *)v30);
      }
    }
    else if (a1 != a2)
    {
      *(_OWORD *)a5 = *(_OWORD *)a1;
      *(void *)a1 = 0;
      *((void *)a1 + 1) = 0;
      double result = a1[4];
      *(float *)(a5 + 16) = result;
      int v15 = (long long *)(a1 + 6);
      if (a1 + 6 != a2)
      {
        uint64_t v16 = 0;
        uint64_t v17 = a5;
        do
        {
          uint64_t v18 = v15;
          double result = *((float *)v9 + 10);
          float v19 = *(float *)(v17 + 16);
          if (result <= v19)
          {
            *(_OWORD *)(v17 + 24) = *v15;
            *(void *)int v15 = 0;
            *((void *)v15 + 1) = 0;
            *(float *)(v17 + 40) = result;
          }
          else
          {
            *(_OWORD *)(v17 + 24) = *(_OWORD *)v17;
            *(void *)uint64_t v17 = 0;
            *(void *)(v17 + 8) = 0;
            *(float *)(v17 + 40) = v19;
            uint64_t v20 = v6;
            if (v17 != v6)
            {
              uint64_t v21 = v16;
              while (1)
              {
                uint64_t v20 = v6 + v21;
                if (*((float *)v9 + 10) <= *(float *)(v6 + v21 - 8)) {
                  break;
                }
                uint64_t v22 = (void *)(v20 - 24);
                long long v23 = *(_OWORD *)(v20 - 24);
                *uint64_t v22 = 0;
                v22[1] = 0;
                uint64_t v24 = *(std::__shared_weak_count **)(v20 + 8);
                *(_OWORD *)uint64_t v20 = v23;
                if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
                  std::__shared_weak_count::__release_weak(v24);
                }
                *(_DWORD *)(v6 + v21 + 16) = *(_DWORD *)(v20 - 8);
                v21 -= 24;
                if (!v21)
                {
                  uint64_t v20 = v6;
                  break;
                }
              }
            }
            long long v25 = *v18;
            *(void *)uint64_t v18 = 0;
            *((void *)v18 + 1) = 0;
            float v26 = *(std::__shared_weak_count **)(v20 + 8);
            *(_OWORD *)uint64_t v20 = v25;
            if (v26)
            {
              if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
                std::__shared_weak_count::__release_weak(v26);
              }
            }
            double result = *((float *)v9 + 10);
            *(float *)(v20 + 16) = result;
          }
          v17 += 24;
          int v15 = (long long *)((char *)v18 + 24);
          v16 += 24;
          uint64_t v9 = v18;
        }
        while ((float *)((char *)v18 + 24) != a2);
      }
    }
  }
  return result;
}

uint64_t *sub_1D0DFA2B4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)a1[1];
    if (*v3)
    {
      unint64_t v4 = 0;
      unint64_t v5 = (std::__shared_weak_count **)(v2 + 8);
      do
      {
        uint64_t v6 = *v5;
        if (*v5 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
        ++v4;
        v5 += 3;
      }
      while (v4 < *v3);
    }
  }
  return a1;
}

void sub_1D0DFA36C(long long *a1, long long *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, float *a7, uint64_t a8)
{
  if (!a6) {
    return;
  }
  long long v11 = a2;
  while (a6 > a8 && a5 > a8)
  {
    if (!a5) {
      return;
    }
    while (1)
    {
      float v13 = *((float *)a1 + 4);
      if (*((float *)v11 + 4) > v13) {
        break;
      }
      a1 = (long long *)((char *)a1 + 24);
      if (!--a5) {
        return;
      }
    }
    uint64_t v102 = a6;
    if (a5 >= a6)
    {
      if (a5 == 1)
      {
        long long v80 = *a1;
        *(void *)a1 = 0;
        *((void *)a1 + 1) = 0;
        long long v81 = *v11;
        *(void *)long long v11 = 0;
        *((void *)v11 + 1) = 0;
        unint64_t v82 = (std::__shared_weak_count *)*((void *)a1 + 1);
        *a1 = v81;
        if (v82 && !atomic_fetch_add(&v82->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          long long v106 = v80;
          ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
          std::__shared_weak_count::__release_weak(v82);
          long long v80 = v106;
        }
        *((_DWORD *)a1 + 4) = *((_DWORD *)v11 + 4);
        BOOL v83 = (std::__shared_weak_count *)*((void *)v11 + 1);
        *long long v11 = v80;
        if (v83 && !atomic_fetch_add(&v83->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
          std::__shared_weak_count::__release_weak(v83);
        }
        *((float *)v11 + 4) = v13;
        return;
      }
      if (a5 >= 0) {
        uint64_t v33 = a5;
      }
      else {
        uint64_t v33 = a5 + 1;
      }
      uint64_t v23 = v33 >> 1;
      uint64_t v22 = (char *)v11;
      if (v11 != (long long *)a3)
      {
        unint64_t v34 = 0xAAAAAAAAAAAAAAABLL * ((a3 - (char *)v11) >> 3);
        uint64_t v22 = (char *)v11;
        do
        {
          unint64_t v35 = v34 >> 1;
          uint64_t v36 = &v22[24 * (v34 >> 1)];
          float v37 = *((float *)v36 + 4);
          uint64_t v38 = v36 + 24;
          v34 += ~(v34 >> 1);
          if (v37 > *((float *)a1 + 6 * v23 + 4)) {
            uint64_t v22 = v38;
          }
          else {
            unint64_t v34 = v35;
          }
        }
        while (v34);
      }
      uint64_t v16 = (long long *)((char *)a1 + 24 * v23);
      uint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v22 - (char *)v11) >> 3);
      if (v16 != v11)
      {
LABEL_20:
        if (v22 == (char *)v11)
        {
          uint64_t v24 = (char *)v16;
        }
        else
        {
          uint64_t v96 = v15;
          uint64_t v97 = v23;
          uint64_t v98 = a4;
          uint64_t v99 = a8;
          long long v100 = a3;
          uint64_t v101 = a7;
          uint64_t v24 = (char *)v16 + 24;
          long long v25 = (long long *)((char *)v16 + 24);
          float v26 = (char *)v11;
          while (1)
          {
            uint64_t v27 = (void *)v25 - 3;
            long long v28 = *(long long *)((char *)v25 - 24);
            *uint64_t v27 = 0;
            v27[1] = 0;
            int v29 = *((_DWORD *)v25 - 2);
            long long v30 = *(_OWORD *)v26;
            *(void *)float v26 = 0;
            *((void *)v26 + 1) = 0;
            uint64_t v31 = (std::__shared_weak_count *)*((void *)v25 - 2);
            *(_OWORD *)uint64_t v27 = v30;
            if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              long long v103 = v28;
              ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
              std::__shared_weak_count::__release_weak(v31);
              long long v28 = v103;
            }
            *((_DWORD *)v25 - 2) = *((_DWORD *)v26 + 4);
            float v32 = (std::__shared_weak_count *)*((void *)v26 + 1);
            *(_OWORD *)float v26 = v28;
            if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
              std::__shared_weak_count::__release_weak(v32);
            }
            *((_DWORD *)v26 + 4) = v29;
            v26 += 24;
            if (v26 == v22) {
              break;
            }
            if (v25 == v11) {
              long long v11 = (long long *)v26;
            }
            long long v25 = (long long *)((char *)v25 + 24);
            v24 += 24;
          }
          if (v25 != v11)
          {
            uint64_t v39 = (char *)v11;
            a8 = v99;
            while (1)
            {
              long long v41 = *v25;
              *(void *)long long v25 = 0;
              *((void *)v25 + 1) = 0;
              int v42 = *((_DWORD *)v25 + 4);
              long long v43 = *(_OWORD *)v39;
              *(void *)uint64_t v39 = 0;
              *((void *)v39 + 1) = 0;
              uint64_t v44 = (std::__shared_weak_count *)*((void *)v25 + 1);
              *long long v25 = v43;
              if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                long long v104 = v41;
                ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
                std::__shared_weak_count::__release_weak(v44);
                long long v41 = v104;
              }
              *((_DWORD *)v25 + 4) = *((_DWORD *)v39 + 4);
              int v45 = (std::__shared_weak_count *)*((void *)v39 + 1);
              *(_OWORD *)uint64_t v39 = v41;
              if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
                std::__shared_weak_count::__release_weak(v45);
              }
              *((_DWORD *)v39 + 4) = v42;
              long long v25 = (long long *)((char *)v25 + 24);
              v39 += 24;
              BOOL v40 = v25 == v11;
              if (v39 == v22)
              {
                if (v25 == v11)
                {
LABEL_65:
                  a3 = v100;
                  a7 = v101;
                  goto LABEL_68;
                }
                uint64_t v39 = (char *)v11 + 24;
                while (1)
                {
                  long long v46 = *v25;
                  *(void *)long long v25 = 0;
                  *((void *)v25 + 1) = 0;
                  int v47 = *((_DWORD *)v25 + 4);
                  long long v48 = *v11;
                  *(void *)long long v11 = 0;
                  *((void *)v11 + 1) = 0;
                  float v49 = (std::__shared_weak_count *)*((void *)v25 + 1);
                  *long long v25 = v48;
                  if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    long long v105 = v46;
                    ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
                    std::__shared_weak_count::__release_weak(v49);
                    long long v46 = v105;
                  }
                  *((_DWORD *)v25 + 4) = *((_DWORD *)v11 + 4);
                  unint64_t v50 = (std::__shared_weak_count *)*((void *)v11 + 1);
                  *long long v11 = v46;
                  if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
                    std::__shared_weak_count::__release_weak(v50);
                  }
                  *((_DWORD *)v11 + 4) = v47;
                  long long v25 = (long long *)((char *)v25 + 24);
                  BOOL v40 = v25 == v11;
                  if (v39 != v22) {
                    break;
                  }
                  if (v25 == v11) {
                    goto LABEL_65;
                  }
                }
              }
              if (v40) {
                long long v11 = (long long *)v39;
              }
            }
          }
          a3 = v100;
          a7 = v101;
          a8 = v99;
LABEL_68:
          uint64_t v23 = v97;
          a4 = v98;
          uint64_t v15 = v96;
        }
        goto LABEL_69;
      }
    }
    else
    {
      if (a6 >= 0) {
        uint64_t v14 = a6;
      }
      else {
        uint64_t v14 = a6 + 1;
      }
      uint64_t v15 = v14 >> 1;
      uint64_t v16 = v11;
      if (v11 != a1)
      {
        unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * (((char *)v11 - (char *)a1) >> 3);
        uint64_t v16 = a1;
        do
        {
          unint64_t v18 = v17 >> 1;
          float v19 = (void *)v16 + 3 * (v17 >> 1);
          float v20 = *((float *)v19 + 4);
          uint64_t v21 = (long long *)(v19 + 3);
          v17 += ~(v17 >> 1);
          if (*((float *)v11 + 6 * v15 + 4) > v20) {
            unint64_t v17 = v18;
          }
          else {
            uint64_t v16 = v21;
          }
        }
        while (v17);
      }
      uint64_t v22 = (char *)v11 + 24 * v15;
      uint64_t v23 = 0xAAAAAAAAAAAAAAABLL * (((char *)v16 - (char *)a1) >> 3);
      if (v16 != v11) {
        goto LABEL_20;
      }
    }
    uint64_t v24 = v22;
LABEL_69:
    a5 -= v23;
    uint64_t v51 = v102 - v15;
    if (v23 + v15 >= a5 + v102 - v15)
    {
      unint64_t v55 = v22;
      uint64_t v56 = a5;
      a5 = v23;
      uint64_t v57 = v15;
      long long v54 = a7;
      sub_1D0DFA36C(v24, v55, a3, a4, v56, v102 - v15, a7, a8);
      long long v11 = v16;
      a6 = v57;
      a3 = v24;
    }
    else
    {
      uint64_t v52 = v16;
      long long v53 = a3;
      long long v54 = a7;
      sub_1D0DFA36C(a1, v52, v24, a4, v23, v15, a7, a8);
      a3 = v53;
      a1 = (long long *)v24;
      long long v11 = (long long *)v22;
      a6 = v51;
    }
    a7 = v54;
    if (!a6) {
      return;
    }
  }
  long long v58 = a7;
  if (a5 > a6)
  {
    if (a3 == (char *)v11) {
      return;
    }
    uint64_t v59 = 0;
    uint64_t v60 = 0;
    do
    {
      unsigned int v61 = &a7[v59];
      long long v62 = (void *)((char *)v11 + v59 * 4);
      *(_OWORD *)unsigned int v61 = *(long long *)((char *)v11 + v59 * 4);
      *long long v62 = 0;
      v62[1] = 0;
      v61[4] = *(float *)((char *)v11 + v59 * 4 + 16);
      ++v60;
      v59 += 6;
    }
    while (v62 + 3 != (void *)a3);
    unsigned int v63 = &a7[v59];
    if (&a7[v59] == a7) {
      goto LABEL_124;
    }
    while (2)
    {
      if (v11 == a1)
      {
        unint64_t v84 = 0;
        do
        {
          BOOL v85 = &v63[v84];
          uint64_t v86 = (float *)&a3[v84 * 4];
          long long v87 = *(_OWORD *)&v63[v84 - 6];
          *((void *)v85 - 3) = 0;
          *((void *)v85 - 2) = 0;
          long long v88 = *(std::__shared_weak_count **)&a3[v84 * 4 - 16];
          *(_OWORD *)&a3[v84 * 4 - 24] = v87;
          if (v88 && !atomic_fetch_add(&v88->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            BOOL v89 = a3;
            ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
            std::__shared_weak_count::__release_weak(v88);
            a3 = v89;
            a7 = v58;
          }
          *(v86 - 2) = *(v85 - 2);
          v84 -= 6;
        }
        while (&v63[v84] != a7);
        goto LABEL_124;
      }
      uint64_t v65 = (_DWORD *)v11 - 2;
      char v64 = v63 - 2;
      if (*(v63 - 2) <= *((float *)v11 - 2))
      {
        v63 -= 6;
        long long v69 = *((_OWORD *)v64 - 1);
        *(void *)unsigned int v63 = 0;
        *((void *)v63 + 1) = 0;
        int64_t v67 = (std::__shared_weak_count *)*((void *)a3 - 2);
        *(_OWORD *)(a3 - 24) = v69;
        if (v67 && !atomic_fetch_add(&v67->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          int64_t v68 = a3;
LABEL_90:
          ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
          std::__shared_weak_count::__release_weak(v67);
          a7 = v58;
          a3 = v68;
        }
      }
      else
      {
        long long v11 = (long long *)((char *)v11 - 24);
        long long v66 = *((_OWORD *)v65 - 1);
        *(void *)long long v11 = 0;
        *((void *)v11 + 1) = 0;
        int64_t v67 = (std::__shared_weak_count *)*((void *)a3 - 2);
        *(_OWORD *)(a3 - 24) = v66;
        if (v67 && !atomic_fetch_add(&v67->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          int64_t v68 = a3;
          char v64 = (float *)v65;
          goto LABEL_90;
        }
        char v64 = (float *)v65;
      }
      *((float *)a3 - 2) = *v64;
      a3 -= 24;
      if (v63 == a7) {
        goto LABEL_124;
      }
      continue;
    }
  }
  if (a1 != v11)
  {
    uint64_t v70 = 0;
    uint64_t v60 = 0;
    do
    {
      uint64_t v71 = &a7[v70];
      long long v72 = (void *)((char *)a1 + v70 * 4);
      *(_OWORD *)uint64_t v71 = *(long long *)((char *)a1 + v70 * 4);
      *long long v72 = 0;
      v72[1] = 0;
      v71[4] = *(float *)((char *)a1 + v70 * 4 + 16);
      ++v60;
      v70 += 6;
    }
    while (v72 + 3 != (void *)v11);
    BOOL v73 = (long long *)&a7[v70];
    if (&a7[v70] == a7) {
      goto LABEL_124;
    }
    uint64_t v74 = (long long *)a7;
    long long v75 = a3;
    while (v11 != (long long *)a3)
    {
      if (*((float *)v11 + 4) <= *((float *)v74 + 4))
      {
        long long v78 = *v74;
        *(void *)uint64_t v74 = 0;
        *((void *)v74 + 1) = 0;
        uint64_t v79 = (std::__shared_weak_count *)*((void *)a1 + 1);
        *a1 = v78;
        if (v79 && !atomic_fetch_add(&v79->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
          std::__shared_weak_count::__release_weak(v79);
          a3 = v75;
          a7 = v58;
        }
        *((_DWORD *)a1 + 4) = *((_DWORD *)v74 + 4);
        uint64_t v74 = (long long *)((char *)v74 + 24);
      }
      else
      {
        long long v76 = *v11;
        *(void *)long long v11 = 0;
        *((void *)v11 + 1) = 0;
        uint64_t v77 = (std::__shared_weak_count *)*((void *)a1 + 1);
        *a1 = v76;
        if (v77 && !atomic_fetch_add(&v77->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
          std::__shared_weak_count::__release_weak(v77);
          a3 = v75;
          a7 = v58;
        }
        *((_DWORD *)a1 + 4) = *((_DWORD *)v11 + 4);
        long long v11 = (long long *)((char *)v11 + 24);
      }
      a1 = (long long *)((char *)a1 + 24);
      if (v74 == v73) {
        goto LABEL_124;
      }
    }
    uint64_t v90 = 0;
    do
    {
      uint64_t v91 = (uint64_t)v74 + v90;
      long long v92 = *(long long *)((char *)v74 + v90);
      *(void *)uint64_t v91 = 0;
      *(void *)(v91 + 8) = 0;
      unint64_t v93 = *(std::__shared_weak_count **)((char *)a1 + v90 + 8);
      *(long long *)((char *)a1 + v90) = v92;
      if (v93 && !atomic_fetch_add(&v93->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v93->__on_zero_shared)(v93);
        std::__shared_weak_count::__release_weak(v93);
        a7 = v58;
      }
      *(_DWORD *)((char *)a1 + v90 + 16) = *(_DWORD *)(v91 + 16);
      v90 += 24;
    }
    while ((long long *)v91 != (long long *)((char *)v73 - 24));
LABEL_124:
    if (a7 && v60)
    {
      uint64_t v94 = (std::__shared_weak_count **)(a7 + 2);
      do
      {
        unint64_t v95 = *v94;
        if (*v94 && !atomic_fetch_add(&v95->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, long long *, char *))v95->__on_zero_shared)(v95, a2, a3);
          std::__shared_weak_count::__release_weak(v95);
        }
        v94 += 3;
        --v60;
      }
      while (v60);
    }
  }
}

void sub_1D0DFAD70(void *a1)
{
  *a1 = &unk_1F26F3EB0;
  uint64_t v2 = a1[7];
  if (v2)
  {
    uint64_t v3 = a1[8];
    unint64_t v4 = (void *)a1[7];
    if (v3 != v2)
    {
      do
      {
        unint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      unint64_t v4 = (void *)a1[7];
    }
    a1[8] = v2;
    operator delete(v4);
  }
  uint64_t v6 = (std::__shared_weak_count *)a1[6];
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  *a1 = &unk_1F26F4078;
  uint64_t v7 = (std::__shared_weak_count *)a1[4];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    uint64_t v8 = (std::__shared_weak_count *)a1[2];
    if (!v8) {
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v8 = (std::__shared_weak_count *)a1[2];
    if (!v8) {
      goto LABEL_19;
    }
  }
  if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
LABEL_19:
  JUMPOUT(0x1D25F16B0);
}

void *sub_1D0DFAF60(void *a1)
{
  *a1 = &unk_1F26F3EB0;
  uint64_t v2 = a1[7];
  if (v2)
  {
    uint64_t v3 = a1[8];
    unint64_t v4 = (void *)a1[7];
    if (v3 != v2)
    {
      do
      {
        unint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      unint64_t v4 = (void *)a1[7];
    }
    a1[8] = v2;
    operator delete(v4);
  }
  uint64_t v6 = (std::__shared_weak_count *)a1[6];
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  *a1 = &unk_1F26F4078;
  uint64_t v7 = (std::__shared_weak_count *)a1[4];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    uint64_t v8 = (std::__shared_weak_count *)a1[2];
    if (!v8) {
      return a1;
    }
  }
  else
  {
    uint64_t v8 = (std::__shared_weak_count *)a1[2];
    if (!v8) {
      return a1;
    }
  }
  if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  return a1;
}

void sub_1D0DFB130(void *a1, uint64_t **a2, char a3)
{
  uint64_t v439 = *MEMORY[0x1E4F143B8];
  v402 = *a2;
  v403 = a2[1];
  kdebug_trace();
  uint64_t v8 = *a2;
  v412 = (uint64_t *)a2;
  v413 = a2[1];
  if (*a2 != v413)
  {
    uint64_t v9 = (int8x16_t *)&unk_1D0E81000;
    do
    {
      uint64_t v10 = *v8;
      uint64_t v11 = *(void *)(*v8 + 48);
      float v12 = *(std::__shared_weak_count **)(*v8 + 56);
      uint64_t v13 = *v8;
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v13 = *v8;
      }
      uint64_t v14 = *(void *)(v13 + 64);
      uint64_t v15 = *(std::__shared_weak_count **)(v13 + 72);
      if (v15) {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unint64_t v16 = *(void *)(v10 + 40);
      unint64_t v17 = *(float **)(v11 + 8);
      if (v16) {
        _ZF = v17 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        uint64_t v19 = (*(_DWORD *)(v11 + 4) * *(_DWORD *)v11);
        if ((v16 & 0xF) != 0) {
          float v20 = 0;
        }
        else {
          float v20 = *(int8x16_t **)(v10 + 40);
        }
        if ((v17 & 0xF) != 0) {
          uint64_t v21 = 0;
        }
        else {
          uint64_t v21 = *(void *)(v11 + 8);
        }
        if (((*(unsigned char *)(v11 + 4) * *(unsigned char *)v11) & 0xF) == 0
          && ((v17 | v16) & 0xF) == 0)
        {
          if ((int)v19 >= 16)
          {
            uint64_t v24 = v19 >> 4;
            do
            {
              int8x16_t v25 = *v20++;
              int8x16_t v26 = (int8x16_t)vdupq_n_s32(0x4B400000u);
              float32x4_t v27 = (float32x4_t)vorrq_s8(vqtbl1q_s8(v25, (int8x16_t)xmmword_1D0E81430), v26);
              float32x4_t v28 = (float32x4_t)vorrq_s8(vqtbl1q_s8(v25, (int8x16_t)xmmword_1D0E81420), v26);
              float32x4_t v6 = (float32x4_t)vorrq_s8(vqtbl1q_s8(v25, (int8x16_t)xmmword_1D0E81410), v26);
              float32x4_t v29 = (float32x4_t)vorrq_s8(vqtbl1q_s8(v25, v9[64]), v26);
              float32x4_t v30 = (float32x4_t)vdupq_n_s32(0xCB400000);
              float32x4_t v5 = vaddq_f32(v29, v30);
              float32x4_t v7 = vaddq_f32(v28, v30);
              *(float32x4_t *)(v21 + 32) = v7;
              *(float32x4_t *)(v21 + 48) = vaddq_f32(v27, v30);
              int8x16_t v4 = (int8x16_t)vaddq_f32(v6, v30);
              *(float32x4_t *)uint64_t v21 = v5;
              *(int8x16_t *)(v21 + 16) = v4;
              v21 += 64;
              --v24;
            }
            while (v24);
            unint64_t v17 = *(float **)(v11 + 8);
          }
        }
        else
        {
          if ((int)v19 < 1) {
            goto LABEL_40;
          }
          if (v19 < 8)
          {
            uint64_t i = 0;
            goto LABEL_39;
          }
          if ((unint64_t)v17 < v16 + v19 && v16 < (unint64_t)&v17[v19])
          {
            for (uint64_t i = 0; i != v19; ++i)
            {
LABEL_39:
              v4.i8[0] = *(unsigned char *)(v16 + i);
              *(float *)v4.i32 = (float)v4.u32[0];
              v17[i] = *(float *)v4.i32;
            }
            goto LABEL_40;
          }
          if (v19 >= 0x10)
          {
            uint64_t i = v19 & 0x7FFFFFF0;
            long long v104 = *(int8x16_t **)(v10 + 40);
            long long v105 = *(int8x16_t **)(v11 + 8);
            uint64_t v106 = v19 & 0xFFFFFFF0;
            do
            {
              int8x16_t v107 = *v104++;
              int8x16_t v4 = (int8x16_t)vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v107, v9[64]));
              float32x4_t v7 = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v107, (int8x16_t)xmmword_1D0E81410));
              float32x4_t v6 = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v107, (int8x16_t)xmmword_1D0E81420));
              float32x4_t v5 = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v107, (int8x16_t)xmmword_1D0E81430));
              v105[2] = (int8x16_t)v6;
              v105[3] = (int8x16_t)v5;
              *long long v105 = v4;
              v105[1] = (int8x16_t)v7;
              v105 += 4;
              v106 -= 16;
            }
            while (v106);
            if (i == v19) {
              goto LABEL_40;
            }
            if ((v19 & 8) == 0) {
              goto LABEL_39;
            }
          }
          else
          {
            uint64_t i = 0;
          }
          uint64_t v32 = i;
          uint64_t i = v19 & 0xFFFFFFF8;
          uint64_t v33 = v32 - i;
          uint64_t v34 = v32;
          unint64_t v35 = (uint64_t *)(v16 + v32);
          do
          {
            uint64_t v36 = *v35++;
            v4.i64[0] = v36;
            uint32x4_t v37 = (uint32x4_t)vqtbl1q_s8(v4, (int8x16_t)xmmword_1D0E81410);
            float32x4_t v6 = (float32x4_t)v9[64];
            int8x16_t v4 = (int8x16_t)vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v4, (int8x16_t)v6));
            float32x4_t v5 = vcvtq_f32_u32(v37);
            uint64_t v38 = (int8x16_t *)&v17[v34];
            *uint64_t v38 = v4;
            v38[1] = (int8x16_t)v5;
            v34 += 8;
            v33 += 8;
          }
          while (v33);
          if (i != v19) {
            goto LABEL_39;
          }
        }
      }
LABEL_40:
      uint64_t v39 = *(unsigned int *)(v11 + 24);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1618))
      {
        sub_1D0E225B4();
      }
      v4.i32[0] = *(_DWORD *)(qword_1EB9F15F8 + 112);
      uint64_t v40 = *(unsigned int *)(v11 + 24);
      long long v41 = *(float32x4_t **)(v11 + 8);
      if ((v41 & 0xF) != 0) {
        int v42 = 0;
      }
      else {
        int v42 = *(float32x4_t **)(v11 + 8);
      }
      if ((v17 & 0xF) != 0) {
        long long v43 = 0;
      }
      else {
        long long v43 = (float32x4_t *)v17;
      }
      if (v42) {
        BOOL v44 = v43 == 0;
      }
      else {
        BOOL v44 = 1;
      }
      if (!v44 && (*(_DWORD *)(v11 + 24) & 3) == 0)
      {
        float32x4_t v51 = *v42;
        float32x4_t v52 = vmulq_f32(v51, v51);
        uint64_t v53 = ((int)v40 / 4);
        if ((int)v40 >= 8)
        {
          if ((int)v53 <= 2) {
            uint64_t v54 = 2;
          }
          else {
            uint64_t v54 = v53;
          }
          uint64_t v55 = v54 - 1;
          uint64_t v56 = v42 + 1;
          do
          {
            float32x4_t v57 = *v56++;
            float32x4_t v51 = vaddq_f32(v51, v57);
            float32x4_t v52 = vmlaq_f32(v52, v57, v57);
            --v55;
          }
          while (v55);
        }
        float32x4_t v7 = (float32x4_t)vextq_s8((int8x16_t)v51, (int8x16_t)v51, 8uLL);
        float32x2_t v58 = vadd_f32(*(float32x2_t *)v51.f32, *(float32x2_t *)v7.f32);
        *(float32x2_t *)v7.f32 = vadd_f32(v58, (float32x2_t)vdup_lane_s32((int32x2_t)v58, 1));
        float32x2_t v59 = vadd_f32(*(float32x2_t *)v52.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v52, (int8x16_t)v52, 8uLL));
        *(float32x2_t *)v7.f32 = vmul_f32(*(float32x2_t *)v7.f32, *(float32x2_t *)v7.f32);
        v7.f32[0] = (float)(vaddv_f32(v59) - (float)(v7.f32[0] / (float)(int)v40)) / (float)(v40 - 1);
        v59.f32[0] = vaddv_f32(v58) / (float)(int)v40;
        float32x4_t v5 = (float32x4_t)vdupq_lane_s32((int32x2_t)v59, 0);
        v58.f32[0] = sqrtf(v7.f32[0]);
        v7.f32[0] = 1.0 / v58.f32[0];
        _NF = v58.f32[0] < 0.001;
        float v60 = 1000.0;
        if (!_NF) {
          float v60 = v7.f32[0];
        }
        if (*(float *)v4.i32 <= 0.0)
        {
          if ((int)v40 >= 4)
          {
            do
            {
              float32x4_t v63 = *v42++;
              *v43++ = vmulq_n_f32(vsubq_f32(v63, v5), v60);
              --v53;
            }
            while (v53);
          }
        }
        else if ((int)v40 >= 4)
        {
          v7.f32[0] = -*(float *)v4.i32;
          float32x4_t v7 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 0);
          float32x4_t v61 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.i8, 0);
          do
          {
            float32x4_t v62 = *v42++;
            *v43++ = vminnmq_f32(vmaxnmq_f32(vmulq_n_f32(vsubq_f32(v62, v5), v60), v7), v61);
            --v53;
          }
          while (v53);
        }
        goto LABEL_115;
      }
      if (!v40)
      {
        v6.i64[0] = 0;
        goto LABEL_80;
      }
      v6.i32[0] = v41->i32[0];
      if (v40 == 1) {
        goto LABEL_80;
      }
      long long v46 = &v41->f32[1];
      if (((v40 + 0x3FFFFFFFFFFFFFFELL) & 0x3FFFFFFFFFFFFFFFLL) == 0) {
        goto LABEL_61;
      }
      uint64_t v47 = ((v40 + 0x3FFFFFFFFFFFFFFELL) & 0x3FFFFFFFFFFFFFFFLL) + 1;
      long long v48 = &v41->f32[2];
      uint64_t v49 = v47 & 0x7FFFFFFFFFFFFFFELL;
      do
      {
        v6.f32[0] = (float)(v6.f32[0] + *(v48 - 1)) + *v48;
        v48 += 2;
        v49 -= 2;
      }
      while (v49);
      if (v47 != (v47 & 0x7FFFFFFFFFFFFFFELL))
      {
        v46 += v47 & 0x7FFFFFFFFFFFFFFELL;
        do
        {
LABEL_61:
          float v50 = *v46++;
          v6.f32[0] = v6.f32[0] + v50;
        }
        while (v46 != &v41->f32[v40]);
      }
LABEL_80:
      if (!v39) {
        goto LABEL_115;
      }
      float v64 = (float)v40;
      v6.f32[0] = v6.f32[0] / (float)v40;
      uint64_t v65 = &v17[v39];
      unint64_t v66 = (v39 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      unint64_t v67 = v66 + 1;
      if (v66 < 7)
      {
        int64_t v68 = v17;
        do
        {
LABEL_88:
          float v74 = v41->f32[0];
          long long v41 = (float32x4_t *)((char *)v41 + 4);
          *v68++ = v74 - v6.f32[0];
        }
        while (v68 != v65);
        goto LABEL_89;
      }
      int64_t v68 = v17;
      if ((unint64_t)((char *)v17 - (char *)v41) < 0x20) {
        goto LABEL_88;
      }
      uint64_t v69 = v67 & 0x7FFFFFFFFFFFFFF8;
      int64_t v68 = &v17[v69];
      float32x4_t v7 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 0);
      uint64_t v70 = v41 + 1;
      uint64_t v71 = (float32x4_t *)(v17 + 4);
      uint64_t v72 = v67 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        float32x4_t v73 = vsubq_f32(*v70, v7);
        v71[-1] = vsubq_f32(v70[-1], v7);
        *uint64_t v71 = v73;
        v70 += 2;
        v71 += 2;
        v72 -= 8;
      }
      while (v72);
      if (v67 != (v67 & 0x7FFFFFFFFFFFFFF8))
      {
        long long v41 = (float32x4_t *)((char *)v41 + v69 * 4);
        goto LABEL_88;
      }
LABEL_89:
      float v75 = *v17 * *v17;
      if (v39 == 1) {
        goto LABEL_96;
      }
      long long v76 = v17 + 1;
      unint64_t v77 = (v39 + 0x3FFFFFFFFFFFFFFELL) & 0x3FFFFFFFFFFFFFFFLL;
      if (v77 < 7) {
        goto LABEL_95;
      }
      unint64_t v78 = v77 + 1;
      uint64_t v79 = (float32x4_t *)(v17 + 5);
      uint64_t v80 = v78 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        float32x4_t v7 = vmulq_f32(v79[-1], v79[-1]);
        float32x4_t v81 = vmulq_f32(*v79, *v79);
        float v75 = (float)((float)((float)((float)((float)((float)((float)(v75 + v7.f32[0]) + v7.f32[1]) + v7.f32[2])
                                            + v7.f32[3])
                                    + v81.f32[0])
                            + v81.f32[1])
                    + v81.f32[2])
            + v81.f32[3];
        v79 += 2;
        v80 -= 8;
      }
      while (v80);
      if (v78 != (v78 & 0x7FFFFFFFFFFFFFF8))
      {
        v76 += v78 & 0x7FFFFFFFFFFFFFF8;
        do
        {
LABEL_95:
          float v82 = *v76++;
          float v75 = v75 + (float)(v82 * v82);
        }
        while (v76 != v65);
      }
LABEL_96:
      v5.f32[0] = sqrtf(v75 / v64);
      if (v5.f32[0] < 0.001) {
        v5.f32[0] = 0.001;
      }
      BOOL v83 = v17;
      if (v66 >= 7)
      {
        float32x4_t v84 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 0);
        BOOL v85 = (float32x4_t *)(v17 + 4);
        uint64_t v86 = v67 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          float32x4_t v7 = vdivq_f32(v85[-1], v84);
          float32x4_t v87 = vdivq_f32(*v85, v84);
          v85[-1] = v7;
          *BOOL v85 = v87;
          v85 += 2;
          v86 -= 8;
        }
        while (v86);
        if (v67 == (v67 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_104;
        }
        BOOL v83 = &v17[v67 & 0x7FFFFFFFFFFFFFF8];
      }
      do
      {
        *BOOL v83 = *v83 / v5.f32[0];
        ++v83;
      }
      while (v83 != v65);
LABEL_104:
      if (*(float *)v4.i32 <= 0.0) {
        goto LABEL_115;
      }
      v5.f32[0] = -*(float *)v4.i32;
      if (v66 >= 7)
      {
        float32x4_t v88 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.i8, 0);
        float32x4_t v7 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 0);
        BOOL v89 = (float32x4_t *)(v17 + 4);
        uint64_t v90 = v67 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          float32x4_t v91 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v88, v89[-1]), (int8x16_t)v89[-1], (int8x16_t)v88);
          float32x4_t v92 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v88, *v89), *(int8x16_t *)v89, (int8x16_t)v88);
          v89[-1] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v91, v7), (int8x16_t)v91, (int8x16_t)v7);
          *(int8x16_t *)BOOL v89 = vbslq_s8((int8x16_t)vcgtq_f32(v92, v7), (int8x16_t)v92, (int8x16_t)v7);
          v89 += 2;
          v90 -= 8;
        }
        while (v90);
        if (v67 == (v67 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_115;
        }
        v17 += v67 & 0x7FFFFFFFFFFFFFF8;
      }
      do
      {
        float v93 = *v17;
        if (*v17 >= *(float *)v4.i32) {
          float v93 = *(float *)v4.i32;
        }
        if (v93 <= v5.f32[0]) {
          float v93 = -*(float *)v4.i32;
        }
        *v17++ = v93;
      }
      while (v17 != v65);
LABEL_115:
      long long v437 = 0uLL;
      *(void *)uint64_t v14 = 0;
      *(_DWORD *)(v14 + 8) = 0;
      *(void *)(v14 + 12) = *(void *)((char *)&v437 + 4);
      *(_DWORD *)(v14 + 20) = HIDWORD(v437);
      uint64_t v94 = *(unsigned int *)(v14 + 40);
      if (v94) {
        bzero(*(void **)(v14 + 24), 4 * v94);
      }
      *(_DWORD *)(v14 + 80) = 0;
      *(_OWORD *)(v14 + 48) = 0u;
      *(_OWORD *)(v14 + 64) = 0u;
      uint64_t v9 = (int8x16_t *)&unk_1D0E81000;
      if (2 * *(_DWORD *)(v14 + 208)) {
        bzero(*(void **)(v14 + 192), 4 * (2 * *(_DWORD *)(v14 + 208)));
      }
      int v95 = *(_DWORD *)(v14 + 232);
      if (v95) {
        bzero(*(void **)(v14 + 216), 4 * (3 * v95));
      }
      *(void *)(v14 + 240) = 0;
      *(void *)(v14 + 248) = 0;
      *(void *)(v14 + 256) = 0;
      v5.f32[0] = (float)(*(_DWORD *)v11 - 1);
      float v96 = (float)(*(float *)v10 * 200.0) / v5.f32[0];
      *(float32x2_t *)v7.f32 = vmul_f32(vsub_f32((float32x2_t)0x3F0000003F000000, vdiv_f32(*(float32x2_t *)(v10 + 4), (float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.f32, 0))), (float32x2_t)vdup_n_s32(0x43480000u));
      float v97 = 1.0
          / sqrtf((float)(vmul_f32(*(float32x2_t *)v7.f32, *(float32x2_t *)v7.f32).f32[0]+ vmuls_lane_f32(v7.f32[1], *(float32x2_t *)v7.f32, 1))+ (float)(v96 * v96));
      float32x4_t v416 = v7;
      float v98 = -(float)(v7.f32[0] * v97);
      float v99 = -(float)(v96 * v97);
      float v100 = sqrtf((float)(v98 * v98) + (float)(v99 * v99));
      float v101 = (float)-(float)(v97 * (float)-v96) / v100;
      float v102 = v98 / v100;
      float v103 = atan2f(-(float)((float)(v98 * -0.0) + (float)(v101 * (float)-(float)(v7.f32[1] * v97))), v99);
      *(float *)uint64_t v14 = v103;
      *(float *)(v14 + 4) = asinf(v102);
      *(float *)(v14 + 8) = atan2f(-0.0, v101);
      if (v103 < 0.0) {
        *(float *)uint64_t v14 = v103 + 6.2832;
      }
      int8x16_t v4 = (int8x16_t)v416;
      *(void *)(v14 + 12) = v416.i64[0];
      *(float *)(v14 + 20) = v96;
      if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
        if (v12)
        {
LABEL_126:
          if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
            std::__shared_weak_count::__release_weak(v12);
          }
        }
      }
      else if (v12)
      {
        goto LABEL_126;
      }
      v8 += 2;
    }
    while (v8 != v413);
  }
  kdebug_trace();
  kdebug_trace();
  unint64_t v108 = v412[1] - *v412;
  unint64_t v109 = v108 >> 4;
  uint64_t v431 = 0;
  uint64_t v432 = 0;
  char v430 = &v431;
  if ((int)(v108 >> 4) < 1) {
    goto LABEL_242;
  }
  uint64_t v110 = 0;
  uint64_t v410 = (v108 >> 4);
  int v111 = 1;
  do
  {
    uint64_t v112 = *(void *)(*v412 + 16 * v110);
    uint64_t v114 = *(void *)(v112 + 64);
    long long v113 = *(std::__shared_weak_count **)(v112 + 72);
    if (v113
      && (atomic_fetch_add_explicit(&v113->__shared_owners_, 1uLL, memory_order_relaxed),
          !atomic_fetch_add(&v113->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
    {
      ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
      std::__shared_weak_count::__release_weak(v113);
      uint64_t v115 = *(void *)(v112 + 48);
      long long v116 = *(std::__shared_weak_count **)(v112 + 56);
      if (!v116) {
        goto LABEL_146;
      }
    }
    else
    {
      uint64_t v115 = *(void *)(v112 + 48);
      long long v116 = *(std::__shared_weak_count **)(v112 + 56);
      if (!v116) {
        goto LABEL_146;
      }
    }
    atomic_fetch_add_explicit(&v116->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!atomic_fetch_add(&v116->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v116->__on_zero_shared)(v116);
      std::__shared_weak_count::__release_weak(v116);
    }
LABEL_146:
    sub_1D0DFD5D4((uint64_t)&v436, (uint64_t)a1, v110, v109);
    uint64_t v117 = v436;
    if (!v436)
    {
      int v111 = 0;
      float32x4_t v172 = (std::__shared_weak_count *)v437;
      if (!(void)v437) {
        goto LABEL_139;
      }
LABEL_175:
      if (!atomic_fetch_add(&v172->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v172->__on_zero_shared)(v172);
        std::__shared_weak_count::__release_weak(v172);
      }
      goto LABEL_139;
    }
    int v118 = DWORD2(v437);
    long long v119 = *(int **)(v114 + 160);
    float v120 = *(float *)v112;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1618))
    {
      sub_1D0E225B4();
    }
    if (v118 < 0 || v117[8] <= v118)
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
      uint64_t v163 = qword_1EB9F1620;
      if (!os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR)) {
        goto LABEL_159;
      }
      LOWORD(memptr) = 0;
      int32x4_t v174 = v163;
      float32x4_t v175 = "invalid batch index";
      goto LABEL_183;
    }
    if (*(_DWORD *)(v115 + 24) != 0x4000)
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
      uint64_t v173 = qword_1EB9F1620;
      if (!os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR)) {
        goto LABEL_159;
      }
      LOWORD(memptr) = 0;
      int32x4_t v174 = v173;
      float32x4_t v175 = "image input size is not correct";
LABEL_183:
      _os_log_error_impl(&dword_1D0DBD000, v174, OS_LOG_TYPE_ERROR, v175, (uint8_t *)&memptr, 2u);
LABEL_159:
      int v164 = 0;
      goto LABEL_160;
    }
    memcpy((void *)(*((void *)v117 + 5) + 4 * (49152 * v118)), *(const void **)(v115 + 8), 0x10000uLL);
    uint64_t v121 = 0;
    float v122 = 1.0 / v120;
    LODWORD(v409) = HIDWORD(*(void *)(v112 + 4));
    float32x4_t v123 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(v112 + 4), 0);
    float32x4_t v414 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81550, v123), v122);
    float32x4_t v417 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81540, v123), v122);
    float32x4_t v124 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81560, v123), v122);
    float32x4_t v125 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81570, v123), v122);
    float32x4_t v126 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81580, v123), v122);
    float32x4_t v127 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81590, v123), v122);
    float32x4_t v128 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E815A0, v123), v122);
    float32x4_t v129 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E815B0, v123), v122);
    float32x4_t v130 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E815C0, v123), v122);
    float32x4_t v131 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E815D0, v123), v122);
    uint64_t v132 = *((void *)v117 + 5) + 4 * (49152 * v118 + 0x4000);
    float32x4_t v133 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E815E0, v123), v122);
    float32x4_t v134 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E815F0, v123), v122);
    float32x4_t v135 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81600, v123), v122);
    float32x4_t v136 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81610, v123), v122);
    float32x4_t v137 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81620, v123), v122);
    float32x4_t v138 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81630, v123), v122);
    float32x4_t v139 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81640, v123), v122);
    float32x4_t v140 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81650, v123), v122);
    float32x4_t v141 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81660, v123), v122);
    float32x4_t v142 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81670, v123), v122);
    float32x4_t v143 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81680, v123), v122);
    float32x4_t v144 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81690, v123), v122);
    float32x4_t v145 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E816A0, v123), v122);
    float32x4_t v146 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E816B0, v123), v122);
    float32x4_t v147 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E816C0, v123), v122);
    float32x4_t v148 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E816D0, v123), v122);
    float32x4_t v149 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E816E0, v123), v122);
    float32x4_t v150 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E816F0, v123), v122);
    float32x4_t v151 = vsubq_f32((float32x4_t)xmmword_1D0E81710, v123);
    float32x4_t v152 = vsubq_f32((float32x4_t)xmmword_1D0E81720, v123);
    float32x4_t v153 = vsubq_f32((float32x4_t)xmmword_1D0E81730, v123);
    float32x4_t v154 = vmulq_n_f32(vsubq_f32((float32x4_t)xmmword_1D0E81700, v123), v122);
    float32x4_t v155 = vmulq_n_f32(v151, v122);
    float32x4_t v156 = vmulq_n_f32(v152, v122);
    float32x4_t v157 = vmulq_n_f32(v153, v122);
    do
    {
      float v158 = (float32x4_t *)(v132 + v121);
      *float v158 = v417;
      v158[1] = v414;
      v158[2] = v124;
      v158[3] = v125;
      v158[4] = v126;
      v158[5] = v127;
      v158[6] = v128;
      v158[7] = v129;
      v158[8] = v130;
      v158[9] = v131;
      v158[10] = v133;
      v158[11] = v134;
      v158[12] = v135;
      v158[13] = v136;
      v158[14] = v137;
      v158[15] = v138;
      v158[16] = v139;
      v158[17] = v140;
      v158[18] = v141;
      v158[19] = v142;
      v158[20] = v143;
      v158[21] = v144;
      v158[22] = v145;
      v158[23] = v146;
      v158[24] = v147;
      v158[25] = v148;
      v158[26] = v149;
      v158[27] = v150;
      v158[28] = v154;
      v158[29] = v155;
      v158[30] = v156;
      v121 += 512;
      v158[31] = v157;
    }
    while (v121 != 0x10000);
    int v159 = 0;
    unsigned int v160 = (float32x4_t *)(v132 + v121);
    do
    {
      v157.f32[0] = v122 * (float)((float)v159 - v409);
      float32x4_t v157 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v157.f32, 0);
      float32x4_t *v160 = v157;
      v160[1] = v157;
      v160[2] = v157;
      v160[3] = v157;
      v160[4] = v157;
      v160[5] = v157;
      v160[6] = v157;
      v160[7] = v157;
      v160[8] = v157;
      v160[9] = v157;
      v160[10] = v157;
      v160[11] = v157;
      v160[12] = v157;
      v160[13] = v157;
      v160[14] = v157;
      v160[15] = v157;
      v160[16] = v157;
      v160[17] = v157;
      v160[18] = v157;
      v160[19] = v157;
      v160[20] = v157;
      v160[21] = v157;
      v160[22] = v157;
      v160[23] = v157;
      v160[24] = v157;
      v160[25] = v157;
      v160[26] = v157;
      v160[27] = v157;
      v160[28] = v157;
      v160[29] = v157;
      v160[30] = v157;
      v160[31] = v157;
      ++v159;
      v160 += 32;
    }
    while (v159 != 128);
    int32x4_t v161 = (int *)*((void *)v117 + 8);
    float32x2_t v162 = &v161[10 * v118];
    if (v119 == v161)
    {
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, 0x40uLL, 0x49090899uLL);
      float32x4_t v176 = memptr;
      int v177 = *v119;
      *(_DWORD *)memptr = *v119;
      v176[1] = v119[1];
      v176[2] = v119[2];
      v176[3] = v119[3];
      v176[4] = v119[4];
      v176[5] = v119[5];
      v176[6] = v119[6];
      v176[7] = v119[7];
      v176[8] = v119[8];
      v176[9] = v119[9];
      *float32x2_t v162 = v177;
      v162[1] = v176[1];
      v162[2] = v176[2];
      v162[3] = v176[3];
      v162[4] = v176[4];
      v162[5] = v176[5];
      v162[6] = v176[6];
      v162[7] = v176[7];
      v162[8] = v176[8];
      v162[9] = v176[9];
      free(v176);
    }
    else
    {
      *float32x2_t v162 = *v119;
      v162[1] = v119[1];
      v162[2] = v119[2];
      v162[3] = v119[3];
      v162[4] = v119[4];
      v162[5] = v119[5];
      v162[6] = v119[6];
      v162[7] = v119[7];
      v162[8] = v119[8];
      v162[9] = v119[9];
    }
    int v164 = 1;
LABEL_160:
    v111 &= v164;
    float32x2_t v165 = v431;
    float32x2_t v166 = &v431;
    float32x4_t v167 = &v431;
    if (v431)
    {
      while (1)
      {
        while (1)
        {
          float32x4_t v167 = (uint64_t **)v165;
          unint64_t v168 = v165[4];
          if ((unint64_t)v117 >= v168) {
            break;
          }
          float32x2_t v165 = *v167;
          float32x2_t v166 = v167;
          if (!*v167) {
            goto LABEL_167;
          }
        }
        if (v168 >= (unint64_t)v117) {
          break;
        }
        float32x2_t v165 = v167[1];
        if (!v165)
        {
          float32x2_t v166 = v167 + 1;
          goto LABEL_167;
        }
      }
    }
    else
    {
LABEL_167:
      float32x4_t v169 = (uint64_t *)operator new(0x30uLL);
      int32x4_t v170 = v169;
      uint64_t v171 = v437;
      v169[4] = (uint64_t)v117;
      v169[5] = v171;
      if (v171) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v171 + 8), 1uLL, memory_order_relaxed);
      }
      *float32x4_t v169 = 0;
      v169[1] = 0;
      v169[2] = (uint64_t)v167;
      *float32x2_t v166 = v169;
      if (*v430)
      {
        char v430 = (uint64_t **)*v430;
        int32x4_t v170 = *v166;
      }
      sub_1D0DCEC98(v431, v170);
      ++v432;
    }
    float32x4_t v172 = (std::__shared_weak_count *)v437;
    if ((void)v437) {
      goto LABEL_175;
    }
LABEL_139:
    ++v110;
  }
  while (v110 != v410);
  unsigned int v178 = (uint64_t *)v430;
  if (v430 == &v431) {
    int v179 = 0;
  }
  else {
    int v179 = v111;
  }
  if (v179 == 1)
  {
    do
    {
      unsigned int v180 = (void *)v178[4];
      int8x16_t v181 = operator new(0x10uLL);
      *(void *)&long long v437 = v181 + 2;
      *((void *)&v437 + 1) = v181 + 2;
      *int8x16_t v181 = 0;
      v181[1] = 0;
      unint64_t v436 = v181;
      uint64_t v182 = v180[5];
      float32x4_t v183 = sub_1D0DFE8D8((void *)v180[2], (unint64_t)"network_inputs_image_2_0_bridge");
      if (v183) {
        uint64_t v184 = *((int *)v183 + 6);
      }
      else {
        uint64_t v184 = -1;
      }
      v181[v184] = v182;
      uint64_t v185 = v180[8];
      float v186 = sub_1D0DFE8D8((void *)v180[2], (unint64_t)"network_inputs_var_0_bridge");
      if (v186) {
        uint64_t v187 = *((int *)v186 + 6);
      }
      else {
        uint64_t v187 = -1;
      }
      v181[v187] = v185;
      float v188 = sub_1D0DFE8D8((void *)v180[3], (unint64_t)"tongue_logits_output");
      if (v188) {
        int v189 = *((_DWORD *)v188 + 6);
      }
      else {
        int v189 = -1;
      }
      uint64_t v190 = 5;
      if (v189 != -1) {
        uint64_t v190 = 6;
      }
      size_t v191 = 8 * (v190 + 2 * *((unsigned __int8 *)v180 + 292));
      float v192 = (char *)operator new(v191);
      memptr = v192;
      unint64_t v435 = (unint64_t)&v192[v191];
      bzero(v192, v191);
      simd_float3 v434 = &v192[v191];
      uint64_t v193 = v180[23];
      float v194 = sub_1D0DFE8D8((void *)v180[3], (unint64_t)"angles_output");
      if (v194) {
        uint64_t v195 = *((int *)v194 + 6);
      }
      else {
        uint64_t v195 = -1;
      }
      *(void *)&v192[8 * v195] = v193;
      uint64_t v196 = v180[26];
      float v197 = sub_1D0DFE8D8((void *)v180[3], (unint64_t)"translation_output");
      if (v197) {
        uint64_t v198 = *((int *)v197 + 6);
      }
      else {
        uint64_t v198 = -1;
      }
      *(void *)&v192[8 * v198] = v196;
      uint64_t v199 = v180[11];
      __int32 v200 = sub_1D0DFE8D8((void *)v180[3], (unint64_t)"bs_latent_output");
      if (v200) {
        uint64_t v201 = *((int *)v200 + 6);
      }
      else {
        uint64_t v201 = -1;
      }
      *(void *)&v192[8 * v201] = v199;
      uint64_t v202 = v180[29];
      v203 = sub_1D0DFE8D8((void *)v180[3], (unint64_t)"gaze_output");
      if (v203) {
        uint64_t v204 = *((int *)v203 + 6);
      }
      else {
        uint64_t v204 = -1;
      }
      *(void *)&v192[8 * v204] = v202;
      uint64_t v205 = v180[20];
      uint64_t v206 = sub_1D0DFE8D8((void *)v180[3], (unint64_t)"failure_logit_output");
      if (v206) {
        uint64_t v207 = *((int *)v206 + 6);
      }
      else {
        uint64_t v207 = -1;
      }
      *(void *)&v192[8 * v207] = v205;
      if (*((unsigned char *)v180 + 292))
      {
        id v208 = sub_1D0DFE8D8((void *)v180[3], (unint64_t)"basic_ens_output");
        if (v208) {
          uint64_t v209 = *((int *)v208 + 6);
        }
        else {
          uint64_t v209 = -1;
        }
        *(void *)&v192[8 * v209] = v180[17];
        uint64_t v210 = sub_1D0DFE8D8((void *)v180[3], (unint64_t)"kas_output");
        if (v210) {
          uint64_t v211 = *((int *)v210 + 6);
        }
        else {
          uint64_t v211 = -1;
        }
        *(void *)&v192[8 * v211] = v180[14];
      }
      if (v189 != -1) {
        *(void *)&v192[8 * v189] = v180[32];
      }
      (*(void (**)(void, void **, void **, void))(*(void *)*v180 + 16))(*v180, &v436, &memptr, 0);
      if (memptr)
      {
        simd_float3 v434 = (char *)memptr;
        operator delete(memptr);
      }
      if (v436)
      {
        *(void *)&long long v437 = v436;
        operator delete(v436);
      }
      float32x4_t v212 = (uint64_t *)v178[1];
      if (v212)
      {
        do
        {
          float32x4_t v213 = (uint64_t **)v212;
          float32x4_t v212 = (uint64_t *)*v212;
        }
        while (v212);
      }
      else
      {
        do
        {
          float32x4_t v213 = (uint64_t **)v178[2];
          _ZF = *v213 == v178;
          unsigned int v178 = (uint64_t *)v213;
        }
        while (!_ZF);
      }
      unsigned int v178 = (uint64_t *)v213;
    }
    while (v213 != &v431);
  }
LABEL_242:
  unint64_t v214 = (unint64_t)((char *)v403 - (char *)v402) >> 4;
  sub_1D0DFE844(v431);
  kdebug_trace();
  kdebug_trace();
  if ((int)v214 >= 1)
  {
    uint64_t v215 = 0;
    for (uint64_t j = 0; ((unint64_t)((char *)v403 - (char *)v402) >> 4) != j; ++j)
    {
      uint64_t v217 = *(void *)(*v412 + v215);
      uint64_t v219 = *(void *)(v217 + 64);
      uint64_t v218 = *(std::__shared_weak_count **)(v217 + 72);
      if (v218)
      {
        atomic_fetch_add_explicit(&v218->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_1D0DFD5D4((uint64_t)&v436, (uint64_t)a1, j, v214);
        atomic_fetch_add_explicit(&v218->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v220 = v218;
      }
      else
      {
        sub_1D0DFD5D4((uint64_t)&v436, (uint64_t)a1, j, v214);
        uint64_t v220 = 0;
      }
      uint64_t v421 = v219;
      __int32 v422 = v220;
      uint64_t v221 = (std::__shared_weak_count *)v437;
      v420[0] = (uint64_t)v436;
      v420[1] = v437;
      if ((void)v437)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v437 + 8), 1uLL, memory_order_relaxed);
        sub_1D0DFD75C((uint64_t)a1, (uint64_t)&v421, v420, DWORD2(v437));
        if (!atomic_fetch_add(&v221->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v221->__on_zero_shared)(v221);
          std::__shared_weak_count::__release_weak(v221);
        }
        uint64_t v222 = v422;
        if (!v422)
        {
LABEL_255:
          id v223 = (std::__shared_weak_count *)v437;
          if ((void)v437) {
            goto LABEL_256;
          }
          goto LABEL_259;
        }
      }
      else
      {
        sub_1D0DFD75C((uint64_t)a1, (uint64_t)&v421, v420, DWORD2(v437));
        uint64_t v222 = v422;
        if (!v422) {
          goto LABEL_255;
        }
      }
      if (atomic_fetch_add(&v222->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_255;
      }
      ((void (*)(std::__shared_weak_count *))v222->__on_zero_shared)(v222);
      std::__shared_weak_count::__release_weak(v222);
      id v223 = (std::__shared_weak_count *)v437;
      if ((void)v437)
      {
LABEL_256:
        if (!atomic_fetch_add(&v223->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v223->__on_zero_shared)(v223);
          std::__shared_weak_count::__release_weak(v223);
        }
      }
LABEL_259:
      if (v218 && !atomic_fetch_add(&v218->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v218->__on_zero_shared)(v218);
        std::__shared_weak_count::__release_weak(v218);
      }
      v215 += 16;
    }
  }
  kdebug_trace();
  kdebug_trace();
  uint64_t v224 = (uint64_t *)*v412;
  v404 = (uint64_t *)v412[1];
  if ((uint64_t *)*v412 != v404)
  {
    __asm { FMOV            V12.2S, #12.5 }
    while (1)
    {
      uint64_t v227 = *v224;
      uint64_t v229 = *(void *)(*v224 + 64);
      float v228 = *(std::__shared_weak_count **)(*v224 + 72);
      if (v228)
      {
        atomic_fetch_add_explicit(&v228->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v227 = *v224;
        atomic_fetch_add_explicit(&v228->__shared_owners_, 1uLL, memory_order_relaxed);
        v411 = v228;
      }
      else
      {
        v411 = 0;
      }
      v415 = v228;
      uint64_t v231 = a1[1];
      float v230 = (std::__shared_weak_count *)a1[2];
      if (v230) {
        atomic_fetch_add_explicit(&v230->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v408 = v230;
      uint64_t v418 = a1[5];
      int v232 = *(_DWORD *)(v229 + 40);
      uint64_t v233 = *(void *)(v229 + 24);
      int v234 = *(_DWORD *)(v229 + 336);
      uint64_t v235 = *(void *)(v229 + 320);
      v236 = *(int **)(v229 + 424);
      char v430 = *(uint64_t ***)(v229 + 464);
      uint64_t v431 = *(uint64_t **)(v229 + 448);
      uint64_t v432 = v430;
      int v237 = (int)v430;
      double v238 = *(int **)(v229 + 472);
      v427[0] = *(void *)(v229 + 512);
      v427[1] = *(void *)(v229 + 496);
      int v428 = v427[0];
      int v429 = 0;
      int v423 = v232 - 2;
      uint64_t v424 = v233;
      int v425 = v232;
      int v426 = 0;
      float v239 = *(float *)v227;
      uint64_t v240 = (3 * ((int)v430 / 3));
      uint64_t v241 = *(char **)(v229 + 216);
      unsigned int v407 = *(uint64_t **)(v231 + 144);
      uint64_t v406 = v231;
      int v405 = v234;
      if (v236 == (int *)v241)
      {
        unint64_t v436 = 0;
        malloc_type_posix_memalign(&v436, 0x20uLL, (4 * v240 + 31) & 0x7FFFFFFE0, 0x49090899uLL);
        v250 = (char *)v436;
        unsigned int v242 = v237 + 2;
        if (v242 >= 5)
        {
          unint64_t v251 = (v240 - 1) & 0x3FFFFFFFFFFFFFFFLL;
          unint64_t v252 = v251 + 1;
          float32x2_t v253 = v236;
          float32x2_t v254 = (char *)v436;
          if (v251 < 7 || (float32x2_t v253 = v236, v254 = (char *)v436, (unint64_t)((unsigned char *)v436 - (unsigned char *)v236) < 0x20))
          {
            do
            {
LABEL_285:
              int v260 = *v253++;
              *(_DWORD *)float32x2_t v254 = v260;
              v254 += 4;
            }
            while (v254 != &v250[4 * v240]);
          }
          else
          {
            uint64_t v255 = v252 & 0x7FFFFFFFFFFFFFF8;
            float32x2_t v253 = &v236[v255];
            float32x2_t v256 = (char *)v436 + 16;
            float32x2_t v257 = (long long *)(v236 + 4);
            uint64_t v258 = v252 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v259 = *v257;
              *(v256 - 1) = *(v257 - 1);
              *float32x2_t v256 = v259;
              v256 += 2;
              v257 += 2;
              v258 -= 8;
            }
            while (v258);
            if (v252 != (v252 & 0x7FFFFFFFFFFFFFF8))
            {
              float32x2_t v254 = &v250[v255 * 4];
              goto LABEL_285;
            }
          }
          if (v251 < 7)
          {
            float32x2_t v261 = v250;
            float32x2_t v262 = v236;
            goto LABEL_296;
          }
          float32x2_t v261 = v250;
          float32x2_t v262 = v236;
          if ((unint64_t)(v241 - v250) < 0x20)
          {
            do
            {
LABEL_296:
              int v269 = *(_DWORD *)v261;
              v261 += 4;
              *v262++ = v269;
            }
            while (v262 != &v236[v240]);
          }
          else
          {
            uint64_t v263 = v252 & 0x7FFFFFFFFFFFFFF8;
            float32x2_t v261 = &v250[v263 * 4];
            float32x2_t v264 = v236 + 4;
            float32x4x3_t v265 = (long long *)(v250 + 16);
            uint64_t v266 = v252 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v267 = *v265;
              *(v264 - 1) = *(v265 - 1);
              *float32x2_t v264 = v267;
              v264 += 2;
              v265 += 2;
              v266 -= 8;
            }
            while (v266);
            if (v252 != (v252 & 0x7FFFFFFFFFFFFFF8))
            {
              float32x2_t v262 = &v236[v263];
              goto LABEL_296;
            }
          }
        }
        free(v250);
        goto LABEL_298;
      }
      unsigned int v242 = v430 + 2;
      if ((v430 + 2) < 5) {
        goto LABEL_298;
      }
      unint64_t v243 = (v240 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v243 < 7) {
        break;
      }
      char v244 = *(char **)(v229 + 216);
      if ((unint64_t)(v241 - (char *)v236) < 0x20) {
        goto LABEL_293;
      }
      uint64_t v245 = (v243 + 1) & 0x7FFFFFFFFFFFFFF8;
      uint64_t v246 = v241 + 16;
      char v247 = (long long *)(v236 + 4);
      uint64_t v248 = v245;
      do
      {
        long long v249 = *v247;
        *(v246 - 1) = *(v247 - 1);
        *uint64_t v246 = v249;
        v246 += 2;
        v247 += 2;
        v248 -= 8;
      }
      while (v248);
      if (v243 + 1 != v245)
      {
        char v244 = &v241[4 * v245];
        v236 += v245;
        goto LABEL_293;
      }
LABEL_298:
      LODWORD(memptr) = v240;
      simd_float3 v434 = v241;
      unint64_t v435 = v240;
      *(void *)&long long v437 = &v430;
      *((void *)&v437 + 1) = &v423;
      int v438 = 1065353216;
      sub_1D0E3C074((unsigned int *)&memptr, (uint64_t)&v436);
      int32x4_t v270 = (float32x2_t *)(v235 + 4 * (v405 - 6));
      float v271 = v270[1].f32[0];
      float v272 = *(float *)(v229 + 56) - v271;
      float32x2_t v273 = vsub_f32(*(float32x2_t *)(v229 + 48), *v270);
      float v274 = 1.0 / sqrtf(vaddv_f32(vmul_f32(v273, v273)) + (float)(v272 * v272));
      *((float32x2_t *)v241 + 9) = vadd_f32(*v270, vmul_f32(vmul_n_f32(v273, v274), _D12));
      *((float *)v241 + 20) = v271 + (float)((float)(v272 * v274) * 12.5);
      float32x2_t v275 = (float32x2_t *)(v235 + 4 * (v405 - 3));
      float v276 = v275[1].f32[0];
      float v277 = *(float *)(v229 + 56) - v276;
      float32x2_t v278 = vsub_f32(*(float32x2_t *)(v229 + 48), *v275);
      float v279 = 1.0 / sqrtf(vaddv_f32(vmul_f32(v278, v278)) + (float)(v277 * v277));
      *(float32x2_t *)(v241 + 156) = vadd_f32(*v275, vmul_f32(vmul_n_f32(v278, v279), _D12));
      *((float *)v241 + 41) = v276 + (float)((float)(v277 * v279) * 12.5);
      __float2 v280 = __sincosf_stret(*(float *)v229);
      __float2 v281 = __sincosf_stret(*(float *)(v229 + 4));
      __float2 v283 = __sincosf_stret(*(float *)(v229 + 8));
      if (v242 >= 5)
      {
        unsigned int v284 = 0;
        v282.i64[0] = *(void *)(v229 + 12);
        v282.i32[2] = *(_DWORD *)(v229 + 20);
        v286.i64[0] = __PAIR64__((float)((float)-(float)(v280.__sinval * v281.__sinval) * v283.__sinval)+ (float)(v280.__cosval * v283.__cosval), -(float)(v281.__cosval * v283.__sinval));
        v287.i32[3] = 0;
        v287.i32[0] = LODWORD(v281.__sinval);
        do
        {
          uint64_t v288 = 4 * v284;
          id v289 = (float *)&v241[4 * v284 + 8];
          v287.f32[2] = v280.__cosval * v281.__cosval;
          v287.f32[1] = -(float)(v281.__cosval * v280.__sinval);
          v285.i64[1] = COERCE_UNSIGNED_INT((float)(v281.__sinval * (float)-(float)(v280.__cosval * v283.__cosval))+ (float)(v280.__sinval * v283.__sinval));
          v286.i64[1] = COERCE_UNSIGNED_INT((float)((float)(v280.__cosval * v281.__sinval) * v283.__sinval)+ (float)(v283.__cosval * v280.__sinval));
          v285.f32[1] = (float)(v281.__sinval * (float)(v280.__sinval * v283.__cosval))
                      + (float)(v280.__cosval * v283.__sinval);
          v285.f32[0] = v281.__cosval * v283.__cosval;
          float32x4_t v290 = vaddq_f32(v282, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v286, *(float *)&v241[4 * v284 + 4]), v285, *(float *)&v241[v288]), v287, *v289));
          *(void *)&v241[v288] = v290.i64[0];
          *id v289 = v290.f32[2];
          v284 += 3;
        }
        while (v284 < v240);
      }
      float v291 = *(int **)v418;
      int v292 = *(_DWORD *)(v418 + 16);
      uint64_t v293 = (3 * v292);
      if (v238 == *(int **)v418)
      {
        unint64_t v436 = 0;
        malloc_type_posix_memalign(&v436, 0x20uLL, (4 * v293 + 31) & 0x7FFFFFFE0, 0x49090899uLL);
        float32x2_t v301 = (char *)v436;
        if (v292)
        {
          unint64_t v302 = (v293 - 1) & 0x3FFFFFFFFFFFFFFFLL;
          unint64_t v303 = v302 + 1;
          long long v304 = v238;
          float32x2_t v305 = (char *)v436;
          if (v302 < 7 || (long long v304 = v238, v305 = (char *)v436, (unint64_t)((unsigned char *)v436 - (unsigned char *)v238) < 0x20))
          {
            do
            {
LABEL_316:
              int v311 = *v304++;
              *(_DWORD *)float32x2_t v305 = v311;
              v305 += 4;
            }
            while (v305 != &v301[4 * v293]);
          }
          else
          {
            uint64_t v306 = v303 & 0x7FFFFFFFFFFFFFF8;
            long long v304 = &v238[v306];
            long long v307 = (char *)v436 + 16;
            float32x2_t v308 = (long long *)(v238 + 4);
            uint64_t v309 = v303 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v310 = *v308;
              *(v307 - 1) = *(v308 - 1);
              *long long v307 = v310;
              v307 += 2;
              v308 += 2;
              v309 -= 8;
            }
            while (v309);
            if (v303 != (v303 & 0x7FFFFFFFFFFFFFF8))
            {
              float32x2_t v305 = &v301[v306 * 4];
              goto LABEL_316;
            }
          }
          if (v302 < 7)
          {
            float32x2_t v312 = v301;
            float32x2_t v313 = v238;
            goto LABEL_327;
          }
          float32x2_t v312 = v301;
          float32x2_t v313 = v238;
          if ((unint64_t)((char *)v291 - v301) < 0x20)
          {
            do
            {
LABEL_327:
              int v320 = *(_DWORD *)v312;
              v312 += 4;
              *v313++ = v320;
            }
            while (v313 != &v238[v293]);
          }
          else
          {
            uint64_t v314 = v303 & 0x7FFFFFFFFFFFFFF8;
            float32x2_t v312 = &v301[v314 * 4];
            float32x2_t v315 = v238 + 4;
            float32x2_t v316 = (long long *)(v301 + 16);
            uint64_t v317 = v303 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v318 = *v316;
              *(v315 - 1) = *(v316 - 1);
              *float32x2_t v315 = v318;
              v315 += 2;
              v316 += 2;
              v317 -= 8;
            }
            while (v317);
            if (v303 != (v303 & 0x7FFFFFFFFFFFFFF8))
            {
              float32x2_t v313 = &v238[v314];
              goto LABEL_327;
            }
          }
        }
        free(v301);
        goto LABEL_329;
      }
      if (!v292) {
        goto LABEL_329;
      }
      unint64_t v294 = (v293 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v294 < 7)
      {
        uint64_t v295 = *(int **)v418;
        do
        {
LABEL_324:
          int v319 = *v238++;
          *v295++ = v319;
        }
        while (v295 != &v291[v293]);
        goto LABEL_329;
      }
      uint64_t v295 = *(int **)v418;
      if ((unint64_t)((char *)v291 - (char *)v238) < 0x20) {
        goto LABEL_324;
      }
      uint64_t v296 = (v294 + 1) & 0x7FFFFFFFFFFFFFF8;
      float32x4_t v297 = v291 + 4;
      float32x4_t v298 = (long long *)(v238 + 4);
      uint64_t v299 = v296;
      do
      {
        long long v300 = *v298;
        *(v297 - 1) = *(v298 - 1);
        *float32x4_t v297 = v300;
        v297 += 2;
        v298 += 2;
        v299 -= 8;
      }
      while (v299);
      if (v294 + 1 != v296)
      {
        uint64_t v295 = &v291[v296];
        v238 += v296;
        goto LABEL_324;
      }
LABEL_329:
      LODWORD(memptr) = 3 * v292;
      simd_float3 v434 = (char *)v291;
      unint64_t v435 = v293;
      *(void *)&long long v437 = v427;
      *((void *)&v437 + 1) = &v423;
      int v438 = 1065353216;
      sub_1D0E3C074((unsigned int *)&memptr, (uint64_t)&v436);
      __float2 v321 = __sincosf_stret(*(float *)v229);
      __float2 v322 = __sincosf_stret(*(float *)(v229 + 4));
      __float2 v326 = __sincosf_stret(*(float *)(v229 + 8));
      v324.n128_f32[0] = v326.__cosval;
      v323.n128_f32[0] = v326.__sinval;
      if (v292)
      {
        unsigned int v327 = 0;
        v325.i64[0] = *(void *)(v229 + 12);
        v325.i32[2] = *(_DWORD *)(v229 + 20);
        v323.n128_f32[0] = v322.__cosval * v326.__cosval;
        v323.n128_f32[1] = (float)(v322.__sinval * (float)(v321.__sinval * v326.__cosval))
                         + (float)(v321.__cosval * v326.__sinval);
        v323.n128_u64[1] = COERCE_UNSIGNED_INT((float)(v322.__sinval * (float)-(float)(v321.__cosval * v326.__cosval))+ (float)(v321.__sinval * v326.__sinval));
        v324.n128_u64[0] = __PAIR64__((float)((float)-(float)(v321.__sinval * v322.__sinval) * v326.__sinval)+ (float)(v321.__cosval * v326.__cosval), -(float)(v322.__cosval * v326.__sinval));
        v324.n128_u64[1] = COERCE_UNSIGNED_INT((float)((float)(v321.__cosval * v322.__sinval) * v326.__sinval)+ (float)(v326.__cosval * v321.__sinval));
        v328.i32[3] = 0;
        v328.i32[0] = LODWORD(v322.__sinval);
        do
        {
          uint64_t v329 = v327;
          float32x2_t v330 = (float *)&v291[v327 + 2];
          v328.f32[2] = v321.__cosval * v322.__cosval;
          v328.f32[1] = -(float)(v322.__cosval * v321.__sinval);
          float32x4_t v331 = vaddq_f32(v325, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)v324, *(float *)&v291[v327 + 1]), (float32x4_t)v323, *(float *)&v291[v329]), v328, *v330));
          *(void *)&v291[v329] = v331.i64[0];
          *float32x2_t v330 = v331.f32[2];
          v327 += 3;
        }
        while (v327 < v293);
      }
      uint64_t v332 = *(unsigned int *)(v406 + 104);
      if (v332)
      {
        uint64_t v333 = 0;
        uint64_t v334 = *(void *)(v406 + 88);
        float32x2_t v335 = *(int **)v418;
        uint64_t v336 = 3 * v332;
        uint64_t v337 = *(void *)(v418 + 24);
        do
        {
          uint64_t v338 = 4 * v333;
          float32x2_t v339 = (float *)&v335[3 * *(_DWORD *)(v334 + v338)];
          float v340 = *v339;
          float v341 = v339[1];
          float v342 = v339[2];
          float v343 = (float *)&v335[3 * *(_DWORD *)(v334 + 4 * (v333 + 1))];
          float32x4_t v344 = (float *)&v335[3 * *(_DWORD *)(v334 + 4 * (v333 + 2))];
          float v345 = *v343 - v340;
          float v346 = v343[1] - v341;
          float v347 = v343[2] - v342;
          float v348 = *v344 - v340;
          float v349 = v344[1] - v341;
          float v350 = v344[2] - v342;
          float v351 = (float)(v346 * v350) - (float)(v347 * v349);
          float v352 = (float)(v347 * v348) - (float)(v345 * v350);
          float v353 = (float)(v345 * v349) - (float)(v346 * v348);
          uint64_t v354 = v337 + v338;
          v324.n128_f32[0] = sqrtf((float)(v353 * v353) + (float)((float)(v351 * v351) + (float)(v352 * v352)));
          if (v324.n128_f32[0] < 1.0e-12) {
            v324.n128_f32[0] = 1.0e-12;
          }
          *(float *)uint64_t v354 = v351 / v324.n128_f32[0];
          *(float *)(v354 + 4) = v352 / v324.n128_f32[0];
          v323.n128_f32[0] = v353 / v324.n128_f32[0];
          *(_DWORD *)(v354 + 8) = v323.n128_u32[0];
          v333 += 3;
        }
        while (v336 != v333);
      }
      int v355 = *((_DWORD *)v407 + 4);
      if (v355 >= 10)
      {
        int v356 = 0;
        uint64_t v357 = 0;
        uint64_t v358 = (v355 / 10);
        uint64_t v359 = *(void *)(v229 + 216);
        uint64_t v360 = *v407;
        float32x4_t v361 = *(int **)v418;
        uint64_t v362 = v407[3];
        uint64_t v363 = *(void *)(v418 + 24);
        do
        {
          int v364 = 0;
          uint64_t v365 = v359 + 4 * (3 * v357 + v240);
          v323.n128_u32[0] = 1.0;
          do
          {
            uint64_t v366 = 4 * (v356 + v364);
            uint64_t v367 = (float32x2_t *)&v361[3 * *(_DWORD *)(v360 + v366)];
            id v368 = (float32x2_t *)&v361[3 * *(_DWORD *)(v360 + v366 + 4)];
            v369 = (float32x2_t *)&v361[3 * *(_DWORD *)(v360 + v366 + 8)];
            float v370 = *(float *)(v362 + v366);
            float v371 = *(float *)(v362 + v366 + 4);
            float v372 = *(float *)(v362 + v366 + 8);
            v324.n128_u64[0] = (unint64_t)vadd_f32(vadd_f32(vmul_n_f32(*v367, v370), vmul_n_f32(*v368, v371)), vmul_n_f32(*v369, v372));
            float v373 = (float)((float)(v370 * v367[1].f32[0]) + (float)(v371 * v368[1].f32[0]))
                 + (float)(v372 * v369[1].f32[0]);
            float v374 = sqrtf((float)(vmul_f32((float32x2_t)v324.n128_u64[0], (float32x2_t)v324.n128_u64[0]).f32[0]+ vmuls_lane_f32(v324.n128_f32[1], (float32x2_t)v324.n128_u64[0], 1))+ (float)(v373 * v373));
            float v375 = 1.0e-12;
            if (v374 < 1.0e-12) {
              float v374 = 1.0e-12;
            }
            v376 = (float *)(v363 + v366);
            float v377 = *v376;
            float v378 = v376[1];
            float v379 = v376[2];
            float v380 = sqrtf((float)((float)(v377 * v377) + (float)(v378 * v378)) + (float)(v379 * v379));
            if (v380 >= 1.0e-12) {
              float v375 = v380;
            }
            float v381 = (float)((float)((float)(v377 * v324.n128_f32[0])
                                 + vmuls_lane_f32(v378, (float32x2_t)v324.n128_u64[0], 1))
                         + (float)(v373 * v379))
                 / (float)(v374 * v375);
            float v382 = fabsf(v381);
            _NF = v381 < 0.0 || v382 < v323.n128_f32[0];
            if (_NF)
            {
              if (v382 < v323.n128_f32[0]) {
                v323.n128_f32[0] = v382;
              }
              *(void *)uint64_t v365 = v324.n128_u64[0];
              *(float *)(v365 + 8) = v373;
            }
            v364 += 3;
          }
          while (v364 != 30);
          ++v357;
          v356 += 30;
        }
        while (v357 != v358);
      }
      if (*(_DWORD *)(v229 + 208))
      {
        unsigned int v384 = 0;
        uint64_t v385 = 0;
        unint64_t v386 = 0;
        do
        {
          unsigned int v387 = (float *)(*(void *)(v229 + 216) + 4 * v384);
          float v389 = v387[1];
          float v388 = v387[2];
          float v390 = *v387;
          if (v388 < 1.0) {
            float v388 = 1.0;
          }
          uint64_t v391 = *(void *)(v229 + 192) + 4 * (v385 & 0xFFFFFFFE);
          *(float *)uint64_t v391 = *(float *)(v227 + 4) + (float)((float)(v390 * v239) / v388);
          v324.n128_u32[0] = *(_DWORD *)(v227 + 8);
          v323.n128_f32[0] = (float)((float)(v389 * v239) / v388) + v324.n128_f32[0];
          *(_DWORD *)(v391 + 4) = v323.n128_u32[0];
          ++v386;
          v385 += 2;
          v384 += 3;
        }
        while (v386 < *(unsigned int *)(v229 + 208));
      }
      if (v408 && !atomic_fetch_add(&v408->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *, __n128, __n128))v408->__on_zero_shared)(v408, v323, v324);
        std::__shared_weak_count::__release_weak(v408);
        unsigned int v392 = v411;
        if (v411)
        {
LABEL_362:
          if (!atomic_fetch_add(&v392->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *, __n128, __n128))v392->__on_zero_shared)(v392, v323, v324);
            std::__shared_weak_count::__release_weak(v392);
          }
        }
      }
      else
      {
        unsigned int v392 = v411;
        if (v411) {
          goto LABEL_362;
        }
      }
      if (v415 && !atomic_fetch_add(&v415->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *, __n128, __n128))v415->__on_zero_shared)(v415, v323, v324);
        std::__shared_weak_count::__release_weak(v415);
      }
      v224 += 2;
      if (v224 == v404) {
        goto LABEL_368;
      }
    }
    char v244 = *(char **)(v229 + 216);
    do
    {
LABEL_293:
      int v268 = *v236++;
      *(_DWORD *)char v244 = v268;
      v244 += 4;
    }
    while (v244 != &v241[4 * v240]);
    goto LABEL_298;
  }
LABEL_368:
  kdebug_trace();
  uint64_t v393 = *v412;
  uint64_t v394 = v412[1];
  if (*v412 != v394)
  {
    if (a3)
    {
      do
      {
        uint64_t v396 = *(void *)(*(void *)v393 + 64);
        unsigned int v397 = *(std::__shared_weak_count **)(*(void *)v393 + 72);
        if (v397)
        {
          atomic_fetch_add_explicit(&v397->__shared_owners_, 1uLL, memory_order_relaxed);
          v398 = (uint64_t *)(v396 + 24);
          sub_1D0E3BC68(0x33u, 0x34u, (uint64_t *)(v396 + 24));
          sub_1D0E3BC68(0, 1u, v398);
          sub_1D0E3BC68(2u, 3u, v398);
          sub_1D0E3BC68(8u, 9u, v398);
          sub_1D0E3BC68(0xEu, 0xFu, v398);
          float v399 = sub_1D0E3BC68(0x11u, 0x12u, v398);
          if (!atomic_fetch_add(&v397->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *, float))v397->__on_zero_shared)(v397, v399);
            std::__shared_weak_count::__release_weak(v397);
          }
        }
        else
        {
          v395 = (uint64_t *)(v396 + 24);
          sub_1D0E3BC68(0x33u, 0x34u, (uint64_t *)(v396 + 24));
          sub_1D0E3BC68(0, 1u, v395);
          sub_1D0E3BC68(2u, 3u, v395);
          sub_1D0E3BC68(8u, 9u, v395);
          sub_1D0E3BC68(0xEu, 0xFu, v395);
          sub_1D0E3BC68(0x11u, 0x12u, v395);
        }
        v393 += 16;
      }
      while (v393 != v394);
    }
    else
    {
      do
      {
        unsigned int v400 = *(std::__shared_weak_count **)(*(void *)v393 + 72);
        if (v400)
        {
          atomic_fetch_add_explicit(&v400->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v400->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v400->__on_zero_shared)(v400);
            std::__shared_weak_count::__release_weak(v400);
          }
        }
        v393 += 16;
      }
      while (v393 != v394);
    }
  }
}

void sub_1D0DFD5B8(_Unwind_Exception *a1)
{
}

void sub_1D0DFD5D4(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (a3 < 0 || a3 >= a4)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    float32x4_t v6 = qword_1EB9F1620;
    if (!os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR)) {
      goto LABEL_9;
    }
    *(_WORD *)int buf = 0;
    float32x4_t v7 = "invalid face index";
    uint64_t v8 = buf;
    goto LABEL_15;
  }
  uint64_t v5 = *(void *)(a2 + 56);
  if ((int)((unint64_t)(*(void *)(a2 + 64) - v5) >> 4) < a4)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0)
    {
      if (__cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
    }
    float32x4_t v6 = qword_1EB9F1620;
    if (!os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR)) {
      goto LABEL_9;
    }
    __int16 v10 = 0;
    float32x4_t v7 = "too many faces";
    uint64_t v8 = (uint8_t *)&v10;
LABEL_15:
    _os_log_error_impl(&dword_1D0DBD000, v6, OS_LOG_TYPE_ERROR, v7, v8, 2u);
LABEL_9:
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = -1;
    return;
  }
  long long v9 = *(_OWORD *)(v5 + 16 * (a4 - 1));
  *(_OWORD *)a1 = v9;
  if (*((void *)&v9 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v9 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 16) = a3;
}

void sub_1D0DFD75C(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned int a4)
{
  uint64_t v275 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a3;
  uint64_t v246 = 3 * a4;
  float32x4_t v6 = (float32x2_t *)(*(void *)(*a3 + 184) + 4 * v246);
  float v7 = v6[1].f32[0];
  uint64_t v8 = *(float32x2_t **)a2;
  float32x2_t *v8 = vadd_f32(*v6, **(float32x2_t **)a2);
  v8[1].f32[0] = v7 + v8[1].f32[0];
  long long v9 = (float32x2_t *)(*(void *)(v5 + 208) + 4 * v246);
  float v10 = v9[1].f32[0];
  *(float32x2_t *)((char *)v8 + 12) = vadd_f32(vmul_f32(*v9, (float32x2_t)vdup_n_s32(0x42C80000u)), *(float32x2_t *)((char *)v8 + 12));
  v8[2].f32[1] = (float)(v10 * 100.0) + v8[2].f32[1];
  unint64_t v11 = *(unsigned int *)(v5 + 284);
  uint64_t v12 = v11 * a4;
  uint64_t v13 = *(char **)(v5 + 136);
  uint64_t v14 = &v13[4 * v12];
  uint64_t v15 = (char *)v8[14];
  if (v11 == v8[16].i32[0]) {
    goto LABEL_12;
  }
  if (v13 == v15)
  {
    size_t v17 = (4 * v11 + 31) & 0x7FFFFFFE0;
    memptr[0] = 0;
    malloc_type_posix_memalign(memptr, 0x20uLL, v17, 0x49090899uLL);
    unint64_t v18 = (char *)memptr[0];
    if (v13 != memptr[0])
    {
      if (v11)
      {
        unint64_t v19 = (v11 - 1) & 0x3FFFFFFFFFFFFFFFLL;
        if (v19 >= 7)
        {
          float v20 = (char *)memptr[0];
          if ((void *)((char *)memptr[0] - (char *)&v13[4 * v12]) >= (void *)0x20)
          {
            uint64_t v44 = 0;
            uint64_t v45 = (v19 + 1) & 0x7FFFFFFFFFFFFFF8;
            uint64_t v46 = v45;
            do
            {
              uint64_t v47 = &v18[v44];
              long long v48 = *(_OWORD *)&v14[v44 + 16];
              *(_OWORD *)uint64_t v47 = *(_OWORD *)&v14[v44];
              *((_OWORD *)v47 + 1) = v48;
              v44 += 32;
              v46 -= 8;
            }
            while (v46);
            if (v19 + 1 == v45) {
              goto LABEL_50;
            }
            float v20 = &v18[4 * v45];
            v14 += 4 * v45;
          }
        }
        else
        {
          float v20 = (char *)memptr[0];
        }
        do
        {
          int v49 = *(_DWORD *)v14;
          v14 += 4;
          *(_DWORD *)float v20 = v49;
          v20 += 4;
        }
        while (v20 != &v18[4 * v11]);
      }
LABEL_50:
      long long v41 = (void *)v8[14];
      v8[14] = (float32x2_t)v18;
      v8[15] = (float32x2_t)(v17 >> 2);
      goto LABEL_51;
    }
    memptr[0] = 0;
    malloc_type_posix_memalign(memptr, 0x20uLL, v17, 0x49090899uLL);
    unint64_t v18 = (char *)memptr[0];
    if (v11)
    {
      unint64_t v42 = (v11 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v42 >= 7)
      {
        long long v43 = (char *)memptr[0];
        if ((unint64_t)((char *)memptr[0] - (char *)v13 - 4 * v12) >= 0x20)
        {
          uint64_t v50 = (v42 + 1) & 0x7FFFFFFFFFFFFFF8;
          v14 += 4 * v50;
          float32x4_t v51 = (char *)memptr[0] + 16;
          float32x4_t v52 = &v13[4 * v12 + 16];
          uint64_t v53 = v50;
          do
          {
            long long v54 = *(_OWORD *)v52;
            *(v51 - 1) = *((_OWORD *)v52 - 1);
            *float32x4_t v51 = v54;
            v51 += 2;
            v52 += 32;
            v53 -= 8;
          }
          while (v53);
          if (v42 + 1 == v50) {
            goto LABEL_49;
          }
          long long v43 = &v18[4 * v50];
        }
      }
      else
      {
        long long v43 = (char *)memptr[0];
      }
      do
      {
        int v55 = *(_DWORD *)v14;
        v14 += 4;
        *(_DWORD *)long long v43 = v55;
        v43 += 4;
      }
      while (v43 != &v18[4 * v11]);
    }
LABEL_49:
    free(v13);
    goto LABEL_50;
  }
  v8[16].i32[0] = v11;
  if (v11)
  {
    if (*(void *)&v8[15] < v11)
    {
      free(v15);
      size_t v16 = (4 * v11 + 31) & 0x7FFFFFFE0;
      v8[14] = 0;
      v8[15] = (float32x2_t)(v16 >> 2);
      memptr[0] = 0;
      malloc_type_posix_memalign(memptr, 0x20uLL, v16, 0x49090899uLL);
      uint64_t v15 = (char *)memptr[0];
      v8[14] = (float32x2_t)memptr[0];
    }
  }
  else
  {
    free(v15);
    uint64_t v15 = 0;
    v8[14] = 0;
    v8[15] = 0;
  }
  LODWORD(v11) = v8[16].i32[0];
LABEL_12:
  if (v13 == v15)
  {
    size_t v23 = (4 * v11 + 31) & 0x7FFFFFFE0;
    size_t v24 = v23 >> 2;
    memptr[0] = 0;
    malloc_type_posix_memalign(memptr, 0x20uLL, v23, 0x49090899uLL);
    int8x16_t v25 = (char *)memptr[0];
    if (v11)
    {
      unint64_t v26 = (v11 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v26 >= 7)
      {
        float32x4_t v27 = (char *)memptr[0];
        if ((unint64_t)((char *)memptr[0] - (char *)v13 - 4 * v12) >= 0x20)
        {
          uint64_t v35 = (v26 + 1) & 0x7FFFFFFFFFFFFFF8;
          v14 += 4 * v35;
          uint64_t v36 = (char *)memptr[0] + 16;
          uint32x4_t v37 = &v13[4 * v12 + 16];
          uint64_t v38 = v35;
          do
          {
            long long v39 = *(_OWORD *)v37;
            *(v36 - 1) = *((_OWORD *)v37 - 1);
            *uint64_t v36 = v39;
            v36 += 2;
            v37 += 32;
            v38 -= 8;
          }
          while (v38);
          if (v26 + 1 == v35) {
            goto LABEL_32;
          }
          float32x4_t v27 = &v25[4 * v35];
        }
      }
      else
      {
        float32x4_t v27 = (char *)memptr[0];
      }
      do
      {
        int v40 = *(_DWORD *)v14;
        v14 += 4;
        *(_DWORD *)float32x4_t v27 = v40;
        v27 += 4;
      }
      while (v27 != &v25[4 * v11]);
    }
LABEL_32:
    long long v41 = (void *)v8[14];
    v8[14] = (float32x2_t)v25;
    v8[15] = (float32x2_t)v24;
LABEL_51:
    v8[16].i32[0] = v11;
    free(v41);
    goto LABEL_52;
  }
  if (!v11) {
    goto LABEL_52;
  }
  unint64_t v21 = (v11 - 1) & 0x3FFFFFFFFFFFFFFFLL;
  if (v21 < 7)
  {
    uint64_t v22 = v15;
    goto LABEL_24;
  }
  float32x4_t v28 = &v13[4 * v12];
  uint64_t v22 = v15;
  if ((unint64_t)(v15 - v28) < 0x20)
  {
    do
    {
LABEL_24:
      int v34 = *(_DWORD *)v14;
      v14 += 4;
      *(_DWORD *)uint64_t v22 = v34;
      v22 += 4;
    }
    while (v22 != &v15[4 * v11]);
    goto LABEL_52;
  }
  uint64_t v29 = (v21 + 1) & 0x7FFFFFFFFFFFFFF8;
  v14 += 4 * v29;
  float32x4_t v30 = v15 + 16;
  uint64_t v31 = (long long *)(v28 + 16);
  uint64_t v32 = v29;
  do
  {
    long long v33 = *v31;
    *(v30 - 1) = *(v31 - 1);
    _OWORD *v30 = v33;
    v30 += 2;
    v31 += 2;
    v32 -= 8;
  }
  while (v32);
  if (v21 + 1 != v29)
  {
    uint64_t v22 = &v15[4 * v29];
    goto LABEL_24;
  }
LABEL_52:
  unint64_t v56 = *(unsigned int *)(*a3 + 288);
  uint64_t v57 = v56 * a4;
  float32x2_t v58 = *(char **)(*a3 + 112);
  float32x2_t v59 = &v58[4 * v57];
  float v60 = *(float32x2_t **)a2;
  uint64_t v62 = *(void *)a2 + 88;
  float32x4_t v61 = *(char **)v62;
  if (v56 == *(_DWORD *)(*(void *)a2 + 104)) {
    goto LABEL_63;
  }
  if (v58 == v61)
  {
    size_t v64 = (4 * v56 + 31) & 0x7FFFFFFE0;
    memptr[0] = 0;
    malloc_type_posix_memalign(memptr, 0x20uLL, v64, 0x49090899uLL);
    uint64_t v65 = (char *)memptr[0];
    if (v58 != memptr[0])
    {
      if (v56)
      {
        unint64_t v66 = (v56 - 1) & 0x3FFFFFFFFFFFFFFFLL;
        if (v66 >= 7)
        {
          unint64_t v67 = (char *)memptr[0];
          if ((void *)((char *)memptr[0] - (char *)&v58[4 * v57]) >= (void *)0x20)
          {
            uint64_t v91 = 0;
            uint64_t v92 = (v66 + 1) & 0x7FFFFFFFFFFFFFF8;
            uint64_t v93 = v92;
            do
            {
              uint64_t v94 = &v65[v91];
              long long v95 = *(_OWORD *)&v59[v91 + 16];
              *(_OWORD *)uint64_t v94 = *(_OWORD *)&v59[v91];
              *((_OWORD *)v94 + 1) = v95;
              v91 += 32;
              v93 -= 8;
            }
            while (v93);
            if (v66 + 1 == v92) {
              goto LABEL_101;
            }
            unint64_t v67 = &v65[4 * v92];
            v59 += 4 * v92;
          }
        }
        else
        {
          unint64_t v67 = (char *)memptr[0];
        }
        do
        {
          int v96 = *(_DWORD *)v59;
          v59 += 4;
          *(_DWORD *)unint64_t v67 = v96;
          v67 += 4;
        }
        while (v67 != &v65[4 * v56]);
      }
LABEL_101:
      float32x4_t v88 = (void *)v60[11];
      v60[11] = (float32x2_t)v65;
      v60[12] = (float32x2_t)(v64 >> 2);
      goto LABEL_102;
    }
    memptr[0] = 0;
    malloc_type_posix_memalign(memptr, 0x20uLL, v64, 0x49090899uLL);
    uint64_t v65 = (char *)memptr[0];
    if (v56)
    {
      unint64_t v89 = (v56 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v89 >= 7)
      {
        uint64_t v90 = (char *)memptr[0];
        if ((unint64_t)((char *)memptr[0] - (char *)v58 - 4 * v57) >= 0x20)
        {
          uint64_t v97 = (v89 + 1) & 0x7FFFFFFFFFFFFFF8;
          v59 += 4 * v97;
          float v98 = (char *)memptr[0] + 16;
          float v99 = &v58[4 * v57 + 16];
          uint64_t v100 = v97;
          do
          {
            long long v101 = *(_OWORD *)v99;
            *(v98 - 1) = *((_OWORD *)v99 - 1);
            *float v98 = v101;
            v98 += 2;
            v99 += 32;
            v100 -= 8;
          }
          while (v100);
          if (v89 + 1 == v97) {
            goto LABEL_100;
          }
          uint64_t v90 = &v65[4 * v97];
        }
      }
      else
      {
        uint64_t v90 = (char *)memptr[0];
      }
      do
      {
        int v102 = *(_DWORD *)v59;
        v59 += 4;
        *(_DWORD *)uint64_t v90 = v102;
        v90 += 4;
      }
      while (v90 != &v65[4 * v56]);
    }
LABEL_100:
    free(v58);
    goto LABEL_101;
  }
  v60[13].i32[0] = v56;
  if (v56)
  {
    if (*(void *)&v60[12] < v56)
    {
      free(v61);
      size_t v63 = (4 * v56 + 31) & 0x7FFFFFFE0;
      v60[11] = 0;
      v60[12] = (float32x2_t)(v63 >> 2);
      memptr[0] = 0;
      malloc_type_posix_memalign(memptr, 0x20uLL, v63, 0x49090899uLL);
      float32x4_t v61 = (char *)memptr[0];
      v60[11] = (float32x2_t)memptr[0];
    }
  }
  else
  {
    free(v61);
    float32x4_t v61 = 0;
    *(void *)uint64_t v62 = 0;
    *(void *)(v62 + 8) = 0;
  }
  LODWORD(v56) = v60[13].i32[0];
LABEL_63:
  if (v58 == v61)
  {
    size_t v70 = (4 * v56 + 31) & 0x7FFFFFFE0;
    size_t v71 = v70 >> 2;
    memptr[0] = 0;
    malloc_type_posix_memalign(memptr, 0x20uLL, v70, 0x49090899uLL);
    uint64_t v72 = (char *)memptr[0];
    if (v56)
    {
      unint64_t v73 = (v56 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v73 >= 7)
      {
        float v74 = (char *)memptr[0];
        if ((unint64_t)((char *)memptr[0] - (char *)v58 - 4 * v57) >= 0x20)
        {
          uint64_t v82 = (v73 + 1) & 0x7FFFFFFFFFFFFFF8;
          v59 += 4 * v82;
          BOOL v83 = (char *)memptr[0] + 16;
          float32x4_t v84 = &v58[4 * v57 + 16];
          uint64_t v85 = v82;
          do
          {
            long long v86 = *(_OWORD *)v84;
            *(v83 - 1) = *((_OWORD *)v84 - 1);
            *BOOL v83 = v86;
            v83 += 2;
            v84 += 32;
            v85 -= 8;
          }
          while (v85);
          if (v73 + 1 == v82) {
            goto LABEL_83;
          }
          float v74 = &v72[4 * v82];
        }
      }
      else
      {
        float v74 = (char *)memptr[0];
      }
      do
      {
        int v87 = *(_DWORD *)v59;
        v59 += 4;
        *(_DWORD *)float v74 = v87;
        v74 += 4;
      }
      while (v74 != &v72[4 * v56]);
    }
LABEL_83:
    float32x4_t v88 = (void *)v60[11];
    v60[11] = (float32x2_t)v72;
    v60[12] = (float32x2_t)v71;
LABEL_102:
    v60[13].i32[0] = v56;
    free(v88);
    goto LABEL_103;
  }
  if (!v56) {
    goto LABEL_103;
  }
  unint64_t v68 = (v56 - 1) & 0x3FFFFFFFFFFFFFFFLL;
  if (v68 < 7)
  {
    uint64_t v69 = v61;
    goto LABEL_75;
  }
  float v75 = &v58[4 * v57];
  uint64_t v69 = v61;
  if ((unint64_t)(v61 - v75) < 0x20)
  {
    do
    {
LABEL_75:
      int v81 = *(_DWORD *)v59;
      v59 += 4;
      *(_DWORD *)uint64_t v69 = v81;
      v69 += 4;
    }
    while (v69 != &v61[4 * v56]);
    goto LABEL_103;
  }
  uint64_t v76 = (v68 + 1) & 0x7FFFFFFFFFFFFFF8;
  v59 += 4 * v76;
  unint64_t v77 = v61 + 16;
  unint64_t v78 = (long long *)(v75 + 16);
  uint64_t v79 = v76;
  do
  {
    long long v80 = *v78;
    *(v77 - 1) = *(v78 - 1);
    *unint64_t v77 = v80;
    v77 += 2;
    v78 += 2;
    v79 -= 8;
  }
  while (v79);
  if (v68 + 1 != v76)
  {
    uint64_t v69 = &v61[4 * v76];
    goto LABEL_75;
  }
LABEL_103:
  float v103 = (float32x2_t **)a2;
  long long v104 = *(float32x2_t **)a2;
  uint64_t v105 = *(unsigned int *)(*(void *)a2 + 104);
  if (!v105) {
    goto LABEL_113;
  }
  float32x2_t v106 = v104[11];
  unint64_t v107 = (v105 - 1) & 0x3FFFFFFFFFFFFFFFLL;
  if (v107 > 2)
  {
    unint64_t v109 = v107 + 1;
    uint64_t v110 = (v107 + 1) & 0x7FFFFFFFFFFFFFFCLL;
    __asm { FMOV            V0.4S, #1.0 }
    float32x4_t v253 = _Q0;
    float32x4_t v255 = (float32x4_t)vdupq_n_s32(0x2B8CBCCCu);
    int8x16_t v251 = (int8x16_t)vdupq_n_s32(0x5368D4A5u);
    long long v116 = (float32x4_t *)v104[11];
    uint64_t v117 = v110;
    do
    {
      float32x4_t v263 = vnegq_f32(*v116);
      float v257 = expf(v263.f32[1]);
      v118.f32[0] = expf(v263.f32[0]);
      v118.f32[1] = v257;
      float32x4_t v258 = v118;
      float v119 = expf(v263.f32[2]);
      float32x4_t v120 = v258;
      v120.f32[2] = v119;
      float32x4_t v259 = v120;
      float v121 = expf(v263.f32[3]);
      float32x4_t v122 = v259;
      v122.f32[3] = v121;
      float32x4_t v123 = vaddq_f32(v122, v253);
      *(int8x16_t *)v116++ = vbslq_s8((int8x16_t)vcgtq_f32(v255, v123), v251, (int8x16_t)vdivq_f32(v253, v123));
      v117 -= 4;
    }
    while (v117);
    float v103 = (float32x2_t **)a2;
    if (v109 == v110) {
      goto LABEL_113;
    }
    unint64_t v108 = (float *)(*(void *)&v106 + 4 * v110);
  }
  else
  {
    unint64_t v108 = (float *)v104[11];
  }
  do
  {
    float v124 = expf(-*v108) + 1.0;
    float v125 = 1.0 / v124;
    _NF = v124 < 1.0e-12;
    float v126 = 1.0e12;
    if (!_NF) {
      float v126 = v125;
    }
    *v108++ = v126;
  }
  while (v108 != (float *)(*(void *)&v106 + 4 * v105));
LABEL_113:
  uint64_t v127 = v104[16].u32[0];
  if (!v127) {
    goto LABEL_123;
  }
  float32x4_t v128 = (float32x4_t *)v104[14];
  unint64_t v129 = (v127 - 1) & 0x3FFFFFFFFFFFFFFFLL;
  if (v129 > 2)
  {
    unint64_t v131 = v129 + 1;
    uint64_t v132 = (v129 + 1) & 0x7FFFFFFFFFFFFFFCLL;
    __asm { FMOV            V0.4S, #1.0 }
    float32x4_t v254 = _Q0;
    float32x4_t v256 = (float32x4_t)vdupq_n_s32(0x2B8CBCCCu);
    int8x16_t v252 = (int8x16_t)vdupq_n_s32(0x5368D4A5u);
    float32x4_t v134 = v128;
    uint64_t v135 = v132;
    do
    {
      float32x4_t v264 = vnegq_f32(*v134);
      float v260 = expf(v264.f32[1]);
      v136.f32[0] = expf(v264.f32[0]);
      v136.f32[1] = v260;
      float32x4_t v261 = v136;
      float v137 = expf(v264.f32[2]);
      float32x4_t v138 = v261;
      v138.f32[2] = v137;
      float32x4_t v262 = v138;
      float v139 = expf(v264.f32[3]);
      float32x4_t v140 = v262;
      v140.f32[3] = v139;
      float32x4_t v141 = vaddq_f32(v140, v254);
      *(int8x16_t *)v134++ = vbslq_s8((int8x16_t)vcgtq_f32(v256, v141), v252, (int8x16_t)vdivq_f32(v254, v141));
      v135 -= 4;
    }
    while (v135);
    if (v131 == v132) {
      goto LABEL_123;
    }
    float32x4_t v130 = &v128->f32[v132];
  }
  else
  {
    float32x4_t v130 = (float *)v104[14];
  }
  do
  {
    float v142 = expf(-*v130) + 1.0;
    float v143 = 1.0 / v142;
    _NF = v142 < 1.0e-12;
    float v144 = 1.0e12;
    if (!_NF) {
      float v144 = v143;
    }
    *v130++ = v144;
  }
  while (v130 != &v128->f32[v127]);
LABEL_123:
  uint64_t v145 = *(unsigned int *)(*a3 + 280);
  uint64_t v146 = v145 * a4;
  float32x4_t v147 = *(char **)(*a3 + 88);
  float32x4_t v148 = &v147[4 * v146];
  memptr[0] = 0;
  malloc_type_posix_memalign(memptr, 0x20uLL, (4 * v145 + 31) & 0x7FFFFFFE0, 0x49090899uLL);
  float32x4_t v149 = (float *)memptr[0];
  unsigned int v247 = a4;
  if (v147 == memptr[0])
  {
    memptr[0] = 0;
    malloc_type_posix_memalign(memptr, 0x20uLL, (4 * v145 + 31) & 0x7FFFFFFE0, 0x49090899uLL);
    float32x4_t v149 = (float *)memptr[0];
    if (v145)
    {
      unint64_t v152 = (v145 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v152 >= 7)
      {
        float32x4_t v153 = (float *)memptr[0];
        if ((unint64_t)((char *)memptr[0] - (char *)v147 - 4 * v146) >= 0x20)
        {
          uint64_t v160 = (v152 + 1) & 0x7FFFFFFFFFFFFFF8;
          v148 += 4 * v160;
          int32x4_t v161 = (char *)memptr[0] + 16;
          float32x2_t v162 = &v147[4 * v146 + 16];
          uint64_t v163 = v160;
          do
          {
            long long v164 = *(_OWORD *)v162;
            *(v161 - 1) = *((_OWORD *)v162 - 1);
            *int32x4_t v161 = v164;
            v161 += 2;
            v162 += 32;
            v163 -= 8;
          }
          while (v163);
          if (v152 + 1 == v160) {
            goto LABEL_143;
          }
          float32x4_t v153 = &v149[v160];
        }
      }
      else
      {
        float32x4_t v153 = (float *)memptr[0];
      }
      do
      {
        int v165 = *(_DWORD *)v148;
        v148 += 4;
        *(_DWORD *)v153++ = v165;
      }
      while (v153 != &v149[v145]);
    }
LABEL_143:
    free(v147);
    goto LABEL_144;
  }
  if (!v145) {
    goto LABEL_144;
  }
  unint64_t v150 = (v145 - 1) & 0x3FFFFFFFFFFFFFFFLL;
  if (v150 < 7)
  {
    float32x4_t v151 = (float *)memptr[0];
    goto LABEL_135;
  }
  float32x4_t v151 = (float *)memptr[0];
  if ((void *)((char *)memptr[0] - (char *)&v147[4 * v146]) < (void *)0x20)
  {
    do
    {
LABEL_135:
      int v159 = *(_DWORD *)v148;
      v148 += 4;
      *(_DWORD *)v151++ = v159;
    }
    while (v151 != &v149[v145]);
    goto LABEL_144;
  }
  uint64_t v154 = 0;
  uint64_t v155 = (v150 + 1) & 0x7FFFFFFFFFFFFFF8;
  uint64_t v156 = v155;
  do
  {
    float32x4_t v157 = &v149[v154];
    long long v158 = *(_OWORD *)&v148[v154 * 4 + 16];
    *(_OWORD *)float32x4_t v157 = *(_OWORD *)&v148[v154 * 4];
    *((_OWORD *)v157 + 1) = v158;
    v154 += 8;
    v156 -= 8;
  }
  while (v156);
  if (v150 + 1 != v155)
  {
    float32x4_t v151 = &v149[v155];
    v148 += 4 * v155;
    goto LABEL_135;
  }
LABEL_144:
  float32x2_t v166 = *v103;
  uint64_t v167 = *(void *)(a1 + 8);
  uint64_t v168 = *(unsigned int *)(v167 + 56);
  if (v168)
  {
    uint64_t v169 = 0;
    uint64_t v170 = *(void *)(v167 + 40);
    float32x2_t v171 = v166[3];
    uint64_t v172 = 2 * v168;
    do
    {
      uint64_t v173 = (unsigned int *)(v170 + 4 * (v169 & 0xFFFFFFFE));
      uint64_t v174 = v173[1];
      float v175 = expf(-v149[*v173]) + 1.0;
      float v176 = 1.0 / v175;
      _NF = v175 < 1.0e-12;
      float v177 = 1.0e12;
      if (!_NF) {
        float v177 = v176;
      }
      *(float *)(*(void *)&v171 + 4 * v174) = v177;
      v169 += 2;
    }
    while (v172 != v169);
  }
  uint64_t v178 = *(unsigned int *)(v167 + 80);
  if (v178)
  {
    uint64_t v179 = 0;
    uint64_t v180 = *(void *)(v167 + 64);
    int8x16_t v181 = (void *)v166[3];
    uint64_t v182 = 3 * v178;
    do
    {
      float32x4_t v183 = (unsigned int *)(v180 + 4 * v179);
      uint64_t v184 = v183[1];
      uint64_t v185 = v183[2];
      float v186 = expf(-v149[*v183]) + 1.0;
      float v187 = 1.0 / v186;
      _NF = v186 < 1.0e-12;
      float v188 = 1.0e12;
      if (!_NF) {
        float v188 = v187;
      }
      float v189 = (float)(v188 * 2.0) + -1.0;
      float v190 = -v189;
      float v191 = fmaxf(v189, 0.0);
      if (v189 > 0.0) {
        float v190 = 0.0;
      }
      *((float *)v181 + v184) = v191;
      *((float *)v181 + v185) = v190;
      v179 += 3;
    }
    while (v182 != v179);
  }
  else
  {
    int8x16_t v181 = (void *)v166[3];
  }
  *(void *)((char *)v181 + 204) = *v181;
  *int8x16_t v181 = vdup_n_s32(0x7FC00000u);
  float v192 = (float32x2_t *)(*(void *)(*a3 + 232) + 4 * v246);
  float v193 = v192[1].f32[0];
  v166[6] = vadd_f32(vmul_f32(*v192, (float32x2_t)vdup_n_s32(0x42C80000u)), v166[6]);
  v166[7].f32[0] = (float)(v193 * 100.0) + v166[7].f32[0];
  float v194 = (__int32 *)v166[40];
  unsigned int v195 = 3 * (v166[42].i32[0] / 3u);
  uint64_t v196 = &v194[v195 - 3];
  __int32 v197 = *v196;
  if (v194 == &v166[31].i32[1])
  {
    __int32 v199 = v196[1];
    __int32 v198 = v196[2];
    *float v194 = v197;
    v166[32].i32[0] = v199;
  }
  else
  {
    v166[31].i32[1] = v197;
    v166[32].i32[0] = v196[1];
    __int32 v198 = v196[2];
  }
  v166[32].i32[1] = v198;
  __int32 v200 = &v194[v195 - 6];
  uint64_t v201 = *(float32x2_t **)a2;
  __int32 v202 = *v200;
  if (v194 == (__int32 *)(*(void *)a2 + 240))
  {
    __int32 v204 = v200[1];
    __int32 v203 = v200[2];
    *float v194 = v202;
    v201[30].i32[1] = v204;
  }
  else
  {
    v201[30].i32[0] = v202;
    v201[30].i32[1] = v200[1];
    __int32 v203 = v200[2];
  }
  v201[31].i32[0] = v203;
  uint64_t v205 = *(float32x2_t **)a2;
  uint64_t v206 = *(std::__shared_weak_count **)(a2 + 8);
  if (v206)
  {
    atomic_fetch_add_explicit(&v206->__shared_owners_, 1uLL, memory_order_relaxed);
    float v207 = sub_1D0E3BDE8((float *)v205, (float *)(*(void *)a2 + 48), (float *)v166[3], (float *)(*(void *)a2 + 60), (float *)(*(void *)a2 + 68));
    if (!atomic_fetch_add(&v206->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *, float))v206->__on_zero_shared)(v206, v207);
      std::__shared_weak_count::__release_weak(v206);
    }
  }
  else
  {
    sub_1D0E3BDE8((float *)v205, (float *)&v205[6], (float *)v166[3], (float *)&v205[7] + 1, (float *)&v205[8] + 1);
  }
  id v208 = *(float32x2_t **)a2;
  uint64_t v209 = *(std::__shared_weak_count **)(a2 + 8);
  if (v209) {
    atomic_fetch_add_explicit(&v209->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  float32x2_t v210 = v208[3];
  float v212 = *(float *)(*(void *)&v210 + 204);
  float v211 = *(float *)(*(void *)&v210 + 208);
  **(void **)&float32x2_t v210 = 0;
  int v213 = *(_DWORD *)(*(void *)(a1 + 8) + 8);
  uint64_t v214 = (3 * v213);
  memptr[0] = 0;
  malloc_type_posix_memalign(memptr, 0x20uLL, (4 * v214 + 31) & 0x7FFFFFFE0, 0x49090899uLL);
  uint64_t v215 = (float *)memptr[0];
  if (v213) {
    bzero(memptr[0], 4 * (3 * v213));
  }
  __int32 v216 = v208[5].i32[0];
  float32x2_t v217 = v208[3];
  int v265 = *(_DWORD *)(*(void *)(a1 + 8) + 4);
  float32x2_t v266 = v217;
  __int32 v267 = v216;
  int v268 = 0;
  unsigned int v269 = v214;
  int32x4_t v270 = v215;
  int v271 = v214;
  int v272 = 0;
  if (v213)
  {
    uint64_t v218 = (int *)v208[46];
    unint64_t v219 = (v214 - 1) & 0x3FFFFFFFFFFFFFFFLL;
    if (v219 < 7)
    {
      uint64_t v220 = v215;
      do
      {
LABEL_180:
        int v228 = *v218++;
        *(_DWORD *)v220++ = v228;
      }
      while (v220 != &v215[v214]);
      goto LABEL_181;
    }
    uint64_t v220 = v215;
    if ((unint64_t)((char *)v215 - (char *)v218) < 0x20) {
      goto LABEL_180;
    }
    unint64_t v221 = v219 + 1;
    uint64_t v222 = (v219 + 1) & 0x7FFFFFFFFFFFFFF8;
    id v223 = &v218[v222];
    uint64_t v224 = v215 + 4;
    int v225 = (long long *)(v218 + 4);
    uint64_t v226 = v222;
    do
    {
      long long v227 = *v225;
      *(v224 - 1) = *(v225 - 1);
      *uint64_t v224 = v227;
      v224 += 2;
      v225 += 2;
      v226 -= 8;
    }
    while (v226);
    if (v221 != v222)
    {
      uint64_t v220 = &v215[v222];
      uint64_t v218 = v223;
      goto LABEL_180;
    }
  }
LABEL_181:
  memptr[1] = &v208[49];
  memptr[2] = &v265;
  int v274 = 1065353216;
  sub_1D0E08068(&v269, (uint64_t)memptr);
  float v229 = v215[10] - v215[7];
  float v230 = v212 * (float)((float)(v215[4] - v215[1]) / v208[52].f32[0]);
  float v231 = fminf(v230, 1.0);
  _NF = v230 < 0.0;
  float v232 = 0.0;
  if (_NF) {
    float v231 = 0.0;
  }
  uint64_t v233 = (float *)v208[3];
  *uint64_t v233 = v231;
  float v234 = v211 * (float)(v229 / v208[52].f32[1]);
  float v235 = fminf(v234, 1.0);
  if (v234 >= 0.0) {
    float v232 = v235;
  }
  v233[1] = v232;
  free(v215);
  if (v209 && !atomic_fetch_add(&v209->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v209->__on_zero_shared)(v209);
    std::__shared_weak_count::__release_weak(v209);
  }
  uint64_t v236 = *a3;
  uint64_t v237 = *(void *)(*a3 + 256) + 8 * v247;
  float v238 = *(float *)(v237 + 4);
  float v239 = expf(*(float *)v237);
  float v240 = expf(v238);
  float v241 = v239 + v240;
  if ((float)(v239 + v240) < 1.0e-12) {
    float v241 = 1.0e-12;
  }
  unsigned int v242 = *(float32x2_t **)a2;
  *(float *)(*(void *)a2 + 80) = v240 / v241;
  float v243 = expf(-*(float *)(*(void *)(v236 + 160) + 4 * v247)) + 1.0;
  float v244 = 1.0 / v243;
  _NF = v243 < 1.0e-12;
  float v245 = 1.0e12;
  if (!_NF) {
    float v245 = v244;
  }
  v242[9].f32[1] = v245;
  free(v149);
}

void sub_1D0DFE844(void *a1)
{
  if (a1)
  {
    sub_1D0DFE844(*a1);
    sub_1D0DFE844(a1[1]);
    uint64_t v2 = (std::__shared_weak_count *)a1[5];
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete(a1);
  }
}

void *sub_1D0DFE8D8(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  uint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  double result = (void *)*v8;
  if (*v8)
  {
    if (v6.u32[0] < 2uLL)
    {
      uint64_t v10 = *(void *)&v2 - 1;
      while (1)
      {
        uint64_t v12 = result[1];
        if (v5 == v12)
        {
          if (result[2] == a2) {
            return result;
          }
        }
        else if ((v12 & v10) != v7)
        {
          return 0;
        }
        double result = (void *)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v11 = result[1];
      if (v5 == v11)
      {
        if (result[2] == a2) {
          return result;
        }
      }
      else
      {
        if (v11 >= *(void *)&v2) {
          v11 %= *(void *)&v2;
        }
        if (v11 != v7) {
          return 0;
        }
      }
      double result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void sub_1D0DFE9E8(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 24) >> 39) {
    BOOL v4 = (*(void *)(a2 + 24) & 0xFFFFFF80) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    unint64_t v5 = *(void **)(a2 + 40);
    if (v5)
    {
      free(v5);
      *(void *)(a2 + 40) = 0;
    }
    *(_OWORD *)(a2 + 16) = xmmword_1D0E81740;
    *(void *)(a2 + 32) = 0x8000000001;
    *(void *)(a2 + 40) = malloc_type_malloc(0x4000uLL, 0xA153FF5uLL);
  }
  else
  {
    *(_OWORD *)(a2 + 16) = xmmword_1D0E81740;
  }
  uint8x8_t v6 = (std::__shared_weak_count *)operator new(0x38uLL);
  v6->__shared_owners_ = 0;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4C98;
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)0x8000000080;
  v6[1].__shared_owners_ = 0;
  v6[1].__shared_weak_owners_ = 0x4000;
  size_t size = 0;
  malloc_type_posix_memalign((void **)&size, 0x20uLL, 0x10000uLL, 0x49090899uLL);
  unint64_t v7 = (void *)size;
  v6[1].__shared_owners_ = size;
  LODWORD(v6[2].__vftable) = 0x4000;
  bzero(v7, 0x10000uLL);
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v8 = *(std::__shared_weak_count **)(a2 + 56);
  *(void *)(a2 + 48) = v6 + 1;
  *(void *)(a2 + 56) = v6;
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  long long v9 = *(_DWORD **)(a1 + 24);
  uint64_t v10 = *(void *)(a1 + 8);
  unint64_t v11 = 1717986919 * *(int *)(*(void *)(v10 + 144) + 16);
  int v12 = (v11 >> 63) + (SHIDWORD(v11) >> 2) + *(_DWORD *)(*(void *)(v10 + 112) + 16);
  uint64_t v13 = v9[23];
  unsigned int v14 = v9[10];
  int v15 = v9[11];
  int v16 = *(_DWORD *)(v10 + 4);
  size_t v17 = (std::__shared_weak_count *)operator new(0x228uLL);
  v17->__shared_owners_ = 0;
  v17->__shared_weak_owners_ = 0;
  v17->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4CD0;
  v17[1].std::__shared_count = 0u;
  size_t v18 = (4 * (v15 + 1) + 31) & 0x7FFFFFFE0;
  *(_OWORD *)&v17[1].__shared_weak_owners_ = 0u;
  v17[2].__shared_owners_ = v18 >> 2;
  size_t size = 0;
  malloc_type_posix_memalign((void **)&size, 0x20uLL, v18, 0x49090899uLL);
  unint64_t v19 = (void *)size;
  v17[2].__vftable = (std::__shared_weak_count_vtbl *)size;
  LODWORD(v17[2].__shared_weak_owners_) = v15 + 1;
  if (v15 != -1) {
    bzero(v19, 4 * (v15 + 1));
  }
  LODWORD(v17[4].__shared_owners_) = 0;
  *(_OWORD *)&v17[3].__shared_weak_owners_ = 0u;
  v17[3].std::__shared_count = 0u;
  size_t v20 = (4 * v13 + 31) & 0x7FFFFFFE0;
  v17[4].__shared_weak_owners_ = 0;
  v17[5].__vftable = 0;
  LODWORD(v17[5].__shared_owners_) = 0;
  v17[5].__shared_weak_owners_ = 0;
  v17[6].__vftable = 0;
  LODWORD(v17[6].__shared_owners_) = 0;
  v17[6].__shared_weak_owners_ = 0;
  v17[7].__vftable = (std::__shared_weak_count_vtbl *)(v20 >> 2);
  size_t size = 0;
  malloc_type_posix_memalign((void **)&size, 0x20uLL, v20, 0x49090899uLL);
  unint64_t v21 = (void *)size;
  v17[6].__shared_weak_owners_ = size;
  LODWORD(v17[7].__shared_owners_) = v13;
  if (v13) {
    bzero(v21, 4 * v13);
  }
  v17[7].__shared_weak_owners_ = 0;
  v17[8].__vftable = 0;
  LODWORD(v17[8].__shared_owners_) = 0;
  LODWORD(v17[8].__shared_weak_owners_) = v16;
  HIDWORD(v17[8].__shared_weak_owners_) = 4;
  size_t v22 = (4 * (2 * v12) + 31) & 0x7FFFFFFE0;
  v17[9].__vftable = 0;
  v17[9].__shared_owners_ = v22 >> 2;
  size_t size = 0;
  malloc_type_posix_memalign((void **)&size, 0x20uLL, v22, 0x49090899uLL);
  size_t v23 = (void *)size;
  v17[9].__vftable = (std::__shared_weak_count_vtbl *)size;
  LODWORD(v17[9].__shared_weak_owners_) = v12;
  if (2 * v12) {
    bzero(v23, 4 * (2 * v12));
  }
  int v24 = v15 - 1;
  size_t v25 = (4 * (3 * v12) + 31) & 0x7FFFFFFE0;
  v17[10].__vftable = 0;
  v17[10].__shared_owners_ = v25 >> 2;
  size_t size = 0;
  malloc_type_posix_memalign((void **)&size, 0x20uLL, v25, 0x49090899uLL);
  unint64_t v26 = (void *)size;
  v17[10].__vftable = (std::__shared_weak_count_vtbl *)size;
  LODWORD(v17[10].__shared_weak_owners_) = v12;
  if (v12) {
    bzero(v26, 4 * (3 * v12));
  }
  LOBYTE(v17[14].__vftable) = 0;
  unsigned int v27 = 3 * (v14 / 3);
  v17[11].__shared_owners_ = 0;
  v17[11].__shared_weak_owners_ = 0;
  v17[11].__vftable = 0;
  size_t v28 = (4 * v27 + 31) & 0x3FFFFFFE0;
  LOBYTE(v17[12].__vftable) = 0;
  v17[14].__shared_owners_ = 0;
  v17[14].__shared_weak_owners_ = v28 >> 2;
  size_t size = 0;
  malloc_type_posix_memalign((void **)&size, 0x20uLL, v28, 0x49090899uLL);
  uint64_t v29 = (void *)size;
  v17[14].__shared_owners_ = size;
  LODWORD(v17[15].__vftable) = v27;
  if (v14 >= 3) {
    bzero(v29, 12 * (v14 / 3));
  }
  size_t v30 = (4 * v27 * v24 + 31) & 0x7FFFFFFE0;
  v17[15].__shared_owners_ = 0;
  v17[15].__shared_weak_owners_ = v30 >> 2;
  size_t size = 0;
  malloc_type_posix_memalign((void **)&size, 0x20uLL, v30, 0x49090899uLL);
  uint64_t v31 = (void *)size;
  v17[15].__shared_owners_ = size;
  LODWORD(v17[16].__vftable) = v27;
  HIDWORD(v17[16].__vftable) = v24;
  if (v27 * v24) {
    bzero(v31, 4 * v27 * v24);
  }
  int shared_weak_owners_high = HIDWORD(v17[8].__shared_weak_owners_);
  size_t v33 = (4 * (3 * shared_weak_owners_high) + 31) & 0x7FFFFFFE0;
  v17[16].__shared_owners_ = 0;
  v17[16].__shared_weak_owners_ = v33 >> 2;
  size_t size = 0;
  malloc_type_posix_memalign((void **)&size, 0x20uLL, v33, 0x49090899uLL);
  int v34 = (void *)size;
  v17[16].__shared_owners_ = size;
  LODWORD(v17[17].__vftable) = 3 * shared_weak_owners_high;
  if (shared_weak_owners_high) {
    bzero(v34, 4 * (3 * shared_weak_owners_high));
  }
  int v35 = 3 * HIDWORD(v17[8].__shared_weak_owners_);
  size_t v36 = (4 * (v35 * v16) + 31) & 0x7FFFFFFE0;
  v17[17].__shared_owners_ = 0;
  v17[17].__shared_weak_owners_ = v36 >> 2;
  size_t size = 0;
  malloc_type_posix_memalign((void **)&size, 0x20uLL, v36, 0x49090899uLL);
  uint32x4_t v37 = (void *)size;
  v17[17].__shared_owners_ = size;
  LODWORD(v17[18].__vftable) = v35;
  HIDWORD(v17[18].__vftable) = v16;
  if (v35 * v16) {
    bzero(v37, 4 * (v35 * v16));
  }
  v17[18].__shared_owners_ = 0;
  v17[18].__shared_weak_owners_ = 0;
  LODWORD(v17[19].__shared_owners_) = 0;
  v17[19].__vftable = 0;
  *(_OWORD *)&v17[19].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v17[20].__shared_owners_ = 0u;
  *(_OWORD *)((char *)&v17[20].__shared_weak_owners_ + 4) = 0u;
  v17[21].__shared_weak_owners_ = 0;
  v17[22].__shared_owners_ = 0;
  v17[22].__vftable = 0;
  LOBYTE(v17[22].__shared_weak_owners_) = 0;
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v38 = *(std::__shared_weak_count **)(a2 + 72);
  *(void *)(a2 + 64) = v17 + 1;
  *(void *)(a2 + 72) = v17;
  if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
    std::__shared_weak_count::__release_weak(v38);
  }
  if (atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    uint64_t v40 = *(void *)(a2 + 64);
    long long v39 = *(std::__shared_weak_count **)(a2 + 72);
    if (!v39) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }
  ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
  std::__shared_weak_count::__release_weak(v17);
  uint64_t v40 = *(void *)(a2 + 64);
  long long v39 = *(std::__shared_weak_count **)(a2 + 72);
  if (v39) {
LABEL_35:
  }
    atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_36:
  int v41 = *(_DWORD *)(*(void *)(*(void *)(a1 + 8) + 112) + 16);
  unint64_t v42 = (3 * v41);
  *(_DWORD *)(v40 + 440) = v42;
  if (v41)
  {
    if (*(void *)(v40 + 432) < v42)
    {
      free(*(void **)(v40 + 424));
      size_t v43 = (4 * v42 + 31) & 0x7FFFFFFE0;
      *(void *)(v40 + 424) = 0;
      *(void *)(v40 + 432) = v43 >> 2;
      size_t size = 0;
      malloc_type_posix_memalign((void **)&size, 0x20uLL, v43, 0x49090899uLL);
      *(void *)(v40 + 424) = size;
    }
  }
  else
  {
    free(*(void **)(v40 + 424));
    *(void *)(v40 + 424) = 0;
    *(void *)(v40 + 432) = 0;
  }
  int v44 = *(_DWORD *)(v40 + 364);
  *(_DWORD *)(v40 + 464) = v42;
  *(_DWORD *)(v40 + 468) = v44;
  unint64_t v45 = (v44 * v42);
  if (v45)
  {
    if (*(void *)(v40 + 456) < v45)
    {
      free(*(void **)(v40 + 448));
      size_t v46 = (4 * v45 + 31) & 0x7FFFFFFE0;
      *(void *)(v40 + 448) = 0;
      *(void *)(v40 + 456) = v46 >> 2;
      size_t size = 0;
      malloc_type_posix_memalign((void **)&size, 0x20uLL, v46, 0x49090899uLL);
      *(void *)(v40 + 448) = size;
    }
  }
  else
  {
    free(*(void **)(v40 + 448));
    *(void *)(v40 + 448) = 0;
    *(void *)(v40 + 456) = 0;
  }
  uint64_t v47 = (*(void *)(*(void *)(a1 + 8) + 24) - *(void *)(*(void *)(a1 + 8) + 16)) >> 2;
  unint64_t v48 = (3 * v47);
  *(_DWORD *)(v40 + 488) = v48;
  if (v47)
  {
    if (*(void *)(v40 + 480) < v48)
    {
      free(*(void **)(v40 + 472));
      size_t v49 = (4 * v48 + 31) & 0x7FFFFFFE0;
      *(void *)(v40 + 472) = 0;
      *(void *)(v40 + 480) = v49 >> 2;
      size_t size = 0;
      malloc_type_posix_memalign((void **)&size, 0x20uLL, v49, 0x49090899uLL);
      *(void *)(v40 + 472) = size;
    }
  }
  else
  {
    free(*(void **)(v40 + 472));
    *(void *)(v40 + 472) = 0;
    *(void *)(v40 + 480) = 0;
  }
  int v50 = *(_DWORD *)(v40 + 364);
  *(_DWORD *)(v40 + 512) = v48;
  *(_DWORD *)(v40 + 516) = v50;
  unint64_t v51 = (v50 * v48);
  if (!v51)
  {
    free(*(void **)(v40 + 496));
    *(void *)(v40 + 496) = 0;
    *(void *)(v40 + 504) = 0;
    if (!v39) {
      goto LABEL_58;
    }
    goto LABEL_56;
  }
  if (*(void *)(v40 + 504) < v51)
  {
    free(*(void **)(v40 + 496));
    size_t v52 = (4 * v51 + 31) & 0x7FFFFFFE0;
    *(void *)(v40 + 496) = 0;
    *(void *)(v40 + 504) = v52 >> 2;
    size_t size = 0;
    malloc_type_posix_memalign((void **)&size, 0x20uLL, v52, 0x49090899uLL);
    *(void *)(v40 + 496) = size;
  }
  if (v39)
  {
LABEL_56:
    if (!atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
LABEL_58:
  uint64_t v53 = (std::__shared_weak_count *)operator new(0x20uLL);
  v53->__shared_owners_ = 0;
  v53->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4E20;
  v53->__shared_weak_owners_ = 0;
  v53[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F3F50;
  atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
  long long v54 = *(std::__shared_weak_count **)(a2 + 88);
  *(void *)(a2 + 80) = v53 + 1;
  *(void *)(a2 + 88) = v53;
  if (v54 && !atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
    std::__shared_weak_count::__release_weak(v54);
  }
  if (!atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
  }
}

void sub_1D0DFF2D4()
{
}

uint64_t sub_1D0DFF2F0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1D0DFF314(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4E20;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0DFF368(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4E20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0DFF38C(uint64_t a1)
{
  free(*(void **)(a1 + 520));
  free(*(void **)(a1 + 496));
  free(*(void **)(a1 + 472));
  free(*(void **)(a1 + 448));
  free(*(void **)(a1 + 416));
  free(*(void **)(a1 + 392));
  free(*(void **)(a1 + 368));
  free(*(void **)(a1 + 344));
  free(*(void **)(a1 + 240));
  free(*(void **)(a1 + 216));
  free(*(void **)(a1 + 184));
  free(*(void **)(a1 + 160));
  free(*(void **)(a1 + 136));
  free(*(void **)(a1 + 112));
  int8x8_t v2 = *(void **)(a1 + 48);
  free(v2);
}

void sub_1D0DFF430(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4CD0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0DFF484(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4CD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0DFF4A8(uint64_t a1)
{
}

void sub_1D0DFF4B0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4C98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0DFF504(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4C98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_1D0DFF524(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 56);
  if (*(void **)(a1 + 64) == v1) {
    return 0;
  }
  else {
    return (*v1 != 0) << 7;
  }
}

uint64_t sub_1D0DFF550(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1D0DFF580(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0DFF5BC()
{
}

void sub_1D0E023EC(uint64_t a1)
{
  free(*(void **)(a1 + 48));
  int8x8_t v2 = *(void **)(a1 + 24);
  free(v2);
}

void sub_1D0E02428(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4DB0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E0247C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4DB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0E024A0(uint64_t a1)
{
  int8x8_t v2 = *(std::__shared_weak_count **)(a1 + 176);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    unint64_t v3 = *(std::__shared_weak_count **)(a1 + 160);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    unint64_t v3 = *(std::__shared_weak_count **)(a1 + 160);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 144);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  free(*(void **)(a1 + 112));
  free(*(void **)(a1 + 88));
  free(*(void **)(a1 + 64));
  unint64_t v5 = *(void **)(a1 + 40);
  if (v5)
  {
    *(void *)(a1 + 48) = v5;
    operator delete(v5);
  }
}

void sub_1D0E025E4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4DE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E02638(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4DE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_1D0E0265C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    free(*(void **)(v1 + 256));
    free(*(void **)(v1 + 232));
    free(*(void **)(v1 + 208));
    free(*(void **)(v1 + 184));
    free(*(void **)(v1 + 160));
    free(*(void **)(v1 + 136));
    free(*(void **)(v1 + 112));
    free(*(void **)(v1 + 88));
    free(*(void **)(v1 + 64));
    free(*(void **)(v1 + 40));
    uint64_t v2 = *(void *)(v1 + 24);
    *(void *)(v1 + 24) = 0;
    if (v2)
    {
      unint64_t v3 = *(void **)(v2 + 16);
      if (v3)
      {
        do
        {
          BOOL v4 = (void *)*v3;
          operator delete(v3);
          unint64_t v3 = v4;
        }
        while (v4);
      }
      unint64_t v5 = *(void **)v2;
      *(void *)uint64_t v2 = 0;
      if (v5) {
        operator delete(v5);
      }
      MEMORY[0x1D25F16B0](v2, 0x10A0C408EF24B1CLL);
    }
    uint64_t v6 = *(void *)(v1 + 16);
    *(void *)(v1 + 16) = 0;
    if (v6)
    {
      unint64_t v7 = *(void **)(v6 + 16);
      if (v7)
      {
        do
        {
          uint64_t v8 = (void *)*v7;
          operator delete(v7);
          unint64_t v7 = v8;
        }
        while (v8);
      }
      long long v9 = *(void **)v6;
      *(void *)uint64_t v6 = 0;
      if (v9) {
        operator delete(v9);
      }
      MEMORY[0x1D25F16B0](v6, 0x10A0C408EF24B1CLL);
    }
    uint64_t v10 = *(std::__shared_weak_count **)(v1 + 8);
    if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    JUMPOUT(0x1D25F16B0);
  }
  return result;
}

void sub_1D0E027EC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

uint64_t sub_1D0E0282C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

void sub_1D0E0285C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E02898(uint64_t a1, uint64_t *a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 850045863;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)(a1 + 80) = 0;
  __p = operator new(0x28uLL);
  long long v9 = xmmword_1D0E813F0;
  strcpy((char *)__p, "com.apple.applecva.taskthreadpool");
  LOBYTE(v10) = 0;
  char v11 = 0;
  LOBYTE(v12) = 0;
  char v13 = 0;
  __int16 v14 = 0;
  LOBYTE(v15) = 0;
  char v17 = 0;
  sub_1D0DCEE38(&__p, "com.apple.applecva.facekit.3", 0x1CuLL);
  int v10 = 1;
  char v11 = 1;
  int v12 = 31;
  char v13 = 1;
  uint64_t v3 = *a2;
  if (v17)
  {
    BOOL v4 = (std::__shared_weak_count *)a2[1];
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v5 = v16;
    uint64_t v15 = v3;
    int v16 = v4;
    if (v5)
    {
      if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
  else
  {
    uint64_t v6 = (std::__shared_weak_count *)a2[1];
    uint64_t v15 = *a2;
    int v16 = v6;
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    char v17 = 1;
  }
  unint64_t v7 = operator new(0x28uLL);
  v7[1] = 0;
  _DWORD v7[2] = 0;
  void *v7 = &unk_1F26F5050;
  sub_1D0E79AF8(v7 + 3);
}

void sub_1D0E02B08(uint64_t a1, void *a2, long long **a3)
{
  kdebug_trace();
  if (((*(uint64_t (**)(void, void, long long **))(**(void **)(a1 + 232) + 32))(*(void *)(a1 + 232), *a2, a3) & 1) == 0)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    uint64_t v6 = qword_1EB9F1620;
    if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v6, OS_LOG_TYPE_ERROR, "Error getting faceprints.", buf, 2u);
    }
  }
  kdebug_trace();
  std::mutex::lock((std::mutex *)(a1 + 24));
  sub_1D0E02E24(a1, a3[1] - *a3 + ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4));
  unint64_t v7 = *a3;
  uint64_t v8 = a3[1];
  if (*a3 != v8)
  {
    long long v9 = *(void **)(a1 + 8);
    do
    {
      unint64_t v11 = *(void *)(a1 + 16);
      if ((unint64_t)v9 >= v11)
      {
        char v13 = *(void **)a1;
        uint64_t v14 = ((uint64_t)v9 - *(void *)a1) >> 4;
        unint64_t v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 60) {
          abort();
        }
        uint64_t v16 = v11 - (void)v13;
        if (v16 >> 3 > v15) {
          unint64_t v15 = v16 >> 3;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17 >> 60) {
          sub_1D0DE8CE0();
        }
        uint64_t v18 = 16 * v17;
        unint64_t v19 = (char *)operator new(16 * v17);
        size_t v20 = &v19[16 * v14];
        long long v21 = *v7;
        *(_OWORD *)size_t v20 = *v7;
        if (*((void *)&v21 + 1))
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v21 + 1) + 8), 1uLL, memory_order_relaxed);
          char v13 = *(void **)a1;
          long long v9 = *(void **)(a1 + 8);
        }
        size_t v22 = &v19[v18];
        int v10 = v20 + 16;
        if (v9 == v13)
        {
          *(void *)a1 = v20;
          *(void *)(a1 + 8) = v10;
          *(void *)(a1 + 16) = v22;
        }
        else
        {
          do
          {
            long long v23 = *((_OWORD *)v9 - 1);
            v9 -= 2;
            *((_OWORD *)v20 - 1) = v23;
            v20 -= 16;
            *long long v9 = 0;
            v9[1] = 0;
          }
          while (v9 != v13);
          char v13 = *(void **)a1;
          int v24 = *(void **)(a1 + 8);
          *(void *)a1 = v20;
          *(void *)(a1 + 8) = v10;
          *(void *)(a1 + 16) = v22;
          while (v24 != v13)
          {
            size_t v25 = (std::__shared_weak_count *)*(v24 - 1);
            if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
              std::__shared_weak_count::__release_weak(v25);
            }
            v24 -= 2;
          }
        }
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        uint64_t v12 = *((void *)v7 + 1);
        *long long v9 = *(void *)v7;
        v9[1] = v12;
        if (v12) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
        }
        int v10 = v9 + 2;
      }
      *(void *)(a1 + 8) = v10;
      ++v7;
      long long v9 = v10;
    }
    while (v7 != v8);
  }
  std::mutex::unlock((std::mutex *)(a1 + 24));
  std::mutex::lock((std::mutex *)(a1 + 112));
  --*(_DWORD *)(a1 + 104);
  std::mutex::unlock((std::mutex *)(a1 + 112));
  if (*(unsigned char *)(a1 + 176)) {
    std::condition_variable::notify_all((std::condition_variable *)(a1 + 184));
  }
}

void sub_1D0E02E24(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(char **)a1;
  if (a2 > (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4)
  {
    if (a2 >> 60) {
      abort();
    }
    BOOL v4 = *(char **)(a1 + 8);
    uint64_t v5 = 16 * a2;
    uint64_t v6 = (char *)operator new(16 * a2);
    unint64_t v7 = &v6[v5];
    uint64_t v8 = &v6[v4 - v2];
    if (v4 == v2)
    {
      *(void *)a1 = v8;
      *(void *)(a1 + 8) = v8;
      *(void *)(a1 + 16) = v7;
    }
    else
    {
      long long v9 = &v6[v4 - v2];
      do
      {
        long long v10 = *((_OWORD *)v4 - 1);
        v4 -= 16;
        *((_OWORD *)v9 - 1) = v10;
        v9 -= 16;
        *(void *)BOOL v4 = 0;
        *((void *)v4 + 1) = 0;
      }
      while (v4 != v2);
      uint64_t v2 = *(char **)a1;
      unint64_t v11 = *(char **)(a1 + 8);
      *(void *)a1 = v9;
      *(void *)(a1 + 8) = v8;
      for (*(void *)(a1 + 16) = v7; v11 != v2; v11 -= 16)
      {
        uint64_t v12 = (std::__shared_weak_count *)*((void *)v11 - 1);
        if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
    }
    if (v2)
    {
      operator delete(v2);
    }
  }
}

uint64_t sub_1D0E02F44(uint64_t a1)
{
  kdebug_trace();
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 232) + 24))(*(void *)(a1 + 232));
  if (v2)
  {
    atomic_store(1u, (unsigned __int8 *)(a1 + 248));
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    uint64_t v3 = qword_1EB9F1620;
    if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl(&dword_1D0DBD000, v3, OS_LOG_TYPE_ERROR, "Error during the Initialization of the recognition framework.", v5, 2u);
    }
  }
  kdebug_trace();
  return v2;
}

uint64_t sub_1D0E03080(void *a1)
{
  uint64_t v1 = a1[2];
  uint64_t v2 = (uint64_t (*)(void *))a1[1];
  uint64_t v3 = (void *)(a1[3] + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

__n128 sub_1D0E030B0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F26F4748;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1D0E030E0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F26F4748;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_1D0E03134()
{
}

uint64_t sub_1D0E03150(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1D0E03174(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F5168;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E031C8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F5168;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0E031E8(void *a1)
{
  uint64_t v1 = a1 + 5;
  uint64_t v2 = a1[2];
  uint64_t v3 = (void (*)(void *, CVPixelBufferRef *, void *))a1[1];
  BOOL v4 = (void *)(a1[3] + (v2 >> 1));
  if (v2) {
    uint64_t v3 = *(void (**)(void *, CVPixelBufferRef *, void *))(*v4 + v3);
  }
  uint64_t v5 = (__CVBuffer *)a1[4];
  CVPixelBufferRef texture = v5;
  if (v5) {
    CVPixelBufferRetain(v5);
  }
  v3(v4, &texture, v1);
  if (texture) {
    CVPixelBufferRelease(texture);
  }
}

void sub_1D0E03268(void *__p)
{
  uint64_t v2 = __p[5];
  if (v2)
  {
    uint64_t v3 = __p[6];
    BOOL v4 = (void *)__p[5];
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      BOOL v4 = (void *)__p[5];
    }
    __p[6] = v2;
    operator delete(v4);
  }
  uint64_t v6 = (__CVBuffer *)__p[4];
  if (v6) {
    CVPixelBufferRelease(v6);
  }
  operator delete(__p);
}

void sub_1D0E03338(void *a1)
{
  uint64_t v2 = a1[5];
  if (v2)
  {
    uint64_t v3 = a1[6];
    BOOL v4 = (void *)a1[5];
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      BOOL v4 = (void *)a1[5];
    }
    a1[6] = v2;
    operator delete(v4);
  }
  uint64_t v6 = (__CVBuffer *)a1[4];
  if (v6)
  {
    CVPixelBufferRelease(v6);
  }
}

int64_t sub_1D0E03414(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F26F4790;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  BOOL v4 = *(__CVBuffer **)(a1 + 32);
  *(void *)(a2 + 32) = v4;
  if (v4) {
    CVPixelBufferRetain(v4);
  }
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  uint64_t v6 = *(char **)(a1 + 40);
  uint64_t v5 = *(char **)(a1 + 48);
  int64_t result = v5 - v6;
  if (v5 != v6)
  {
    if (result < 0) {
      abort();
    }
    uint64_t v8 = result >> 4;
    int64_t result = (int64_t)operator new(result);
    *(void *)(a2 + 40) = result;
    *(void *)(a2 + 48) = result;
    *(void *)(a2 + 56) = result + 16 * v8;
    do
    {
      uint64_t v9 = *((void *)v6 + 1);
      *(void *)int64_t result = *(void *)v6;
      *(void *)(result + 8) = v9;
      if (v9) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
      }
      result += 16;
      v6 += 16;
    }
    while (v6 != v5);
    *(void *)(a2 + 48) = result;
  }
  return result;
}

char *sub_1D0E034E0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_1F26F4790;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(__CVBuffer **)(a1 + 32);
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  *((void *)v2 + 4) = v3;
  if (v3) {
    CVPixelBufferRetain(v3);
  }
  *((void *)v2 + 5) = 0;
  *((void *)v2 + 6) = 0;
  *((void *)v2 + 7) = 0;
  uint64_t v5 = *(char **)(a1 + 40);
  BOOL v4 = *(char **)(a1 + 48);
  int64_t v6 = v4 - v5;
  if (v4 != v5)
  {
    if (v6 < 0) {
      abort();
    }
    uint64_t v7 = v6 >> 4;
    uint64_t v8 = operator new(v6);
    *((void *)v2 + 5) = v8;
    *((void *)v2 + 6) = v8;
    *((void *)v2 + 7) = &v8[2 * v7];
    do
    {
      uint64_t v9 = *((void *)v5 + 1);
      void *v8 = *(void *)v5;
      v8[1] = v9;
      if (v9) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
      }
      v8 += 2;
      v5 += 16;
    }
    while (v5 != v4);
    *((void *)v2 + 6) = v8;
  }
  return v2;
}

void sub_1D0E035B0(void *a1)
{
  *a1 = &unk_1F26F4790;
  uint64_t v2 = a1[5];
  if (v2)
  {
    uint64_t v3 = a1[6];
    BOOL v4 = (void *)a1[5];
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      BOOL v4 = (void *)a1[5];
    }
    a1[6] = v2;
    operator delete(v4);
  }
  int64_t v6 = (__CVBuffer *)a1[4];
  if (v6) {
    CVPixelBufferRelease(v6);
  }
  JUMPOUT(0x1D25F16B0);
}

void *sub_1D0E036AC(void *a1)
{
  *a1 = &unk_1F26F4790;
  uint64_t v2 = a1[5];
  if (v2)
  {
    uint64_t v3 = a1[6];
    BOOL v4 = (void *)a1[5];
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      BOOL v4 = (void *)a1[5];
    }
    a1[6] = v2;
    operator delete(v4);
  }
  int64_t v6 = (__CVBuffer *)a1[4];
  if (v6) {
    CVPixelBufferRelease(v6);
  }
  return a1;
}

uint64_t sub_1D0E03788(uint64_t a1, uint64_t *a2)
{
  kdebug_trace();
  BOOL v4 = (std::mutex *)(*a2 + 8);
  std::mutex::lock(v4);
  uint64_t v5 = *a2;
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(void **)(*a2 + 1024);
  uint64_t v8 = *(std::__shared_weak_count **)(*a2 + 1032);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *v7;
  uint64_t v9 = (std::mutex *)(v7 + 1);
  std::mutex::lock(v9);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v6 + 32))(&v18, v6, v10);
  uint64_t v11 = v18;
  uint64_t v18 = 0;
  uint64_t v12 = *(void *)(v5 + 72);
  *(void *)(v5 + 72) = v11;
  if (v12)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    uint64_t v13 = v18;
    uint64_t v18 = 0;
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    }
  }
  std::mutex::unlock(v9);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  uint64_t v14 = *a2;
  uint64_t v15 = *a2 + 304;
  uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(v14 + 72) + 16))(*(void *)(v14 + 72));
  sub_1D0E41D80(v15, v16);
  std::mutex::unlock(v4);
  return kdebug_trace();
}

uint64_t sub_1D0E0396C(uint64_t a1, uint64_t **a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  uint64_t v5 = *a2;
  BOOL v4 = a2[1];
  if (v5 != v4)
  {
    while (1)
    {
      uint64_t v7 = (std::mutex *)(*v5 + 8);
      std::mutex::lock(v7);
      uint64_t v8 = *(void *)(*v5 + 72);
      kdebug_trace();
      uint64_t v9 = *v5;
      uint64_t v10 = *v5 + 88;
      uint64_t v11 = (std::mutex *)(*v5 + 240);
      std::mutex::lock(v11);
      if (*(unsigned char *)(v9 + 120)) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = 0;
      }
      int v13 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, float))(**(void **)(a1 + 16) + 48))(*(void *)(a1 + 16), v9 + 216, v12, v9 + 128, v9 + 156, v9 + 164, v8, *(float *)(v9 + 152));
      std::mutex::unlock(v11);
      kdebug_trace();
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
      uint64_t v14 = qword_1EB9F1620;
      if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG)) {
        break;
      }
      if (v13) {
        goto LABEL_14;
      }
LABEL_7:
      uint64_t v6 = *v5;
      v5 += 2;
      atomic_store(0, (unsigned __int8 *)(v6 + 80));
      std::mutex::unlock(v7);
      if (v5 == v4) {
        goto LABEL_32;
      }
    }
    size_t v30 = "unsuccessful";
    if (v13) {
      size_t v30 = "successful";
    }
    *(_DWORD *)memptr = 136315138;
    *(void *)&memptr[4] = v30;
    _os_log_debug_impl(&dword_1D0DBD000, v14, OS_LOG_TYPE_DEBUG, "fit was %s", memptr, 0xCu);
    if (!v13) {
      goto LABEL_7;
    }
LABEL_14:
    kdebug_trace();
    uint64_t v15 = *v5 + 304;
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
    sub_1D0E41D80(v15, v16);
    uint64_t v17 = *(void *)(a1 + 16);
    uint64_t v18 = *(void **)(*v5 + 1024);
    unint64_t v19 = *(std::__shared_weak_count **)(*v5 + 1032);
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v21 = *v18;
    size_t v20 = (std::mutex *)(v18 + 1);
    std::mutex::lock(v20);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v17 + 40))(v17, v8, v21);
    std::mutex::unlock(v20);
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    if ((*(uint64_t (**)(uint64_t))(*(void *)v8 + 32))(v8))
    {
      uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 32))(v8);
      uint64_t v23 = *v5;
      uint64_t v24 = *v5 + 1040;
      size_t v25 = (std::mutex *)(*v5 + 1064);
      std::mutex::lock(v25);
      if (v24 != v22)
      {
        unint64_t v26 = *(unsigned int *)(v22 + 16);
        if (v26)
        {
          unsigned int v27 = *(void **)(v23 + 1040);
          if (*(void *)(v23 + 1048) >= v26)
          {
            size_t v28 = 4 * v26;
          }
          else
          {
            free(v27);
            *(void *)(v23 + 1040) = 0;
            size_t v28 = 4 * v26;
            size_t v29 = (v28 + 31) & 0x7FFFFFFE0;
            *(void *)(v23 + 1048) = v29 >> 2;
            *(void *)memptr = 0;
            malloc_type_posix_memalign((void **)memptr, 0x20uLL, v29, 0x49090899uLL);
            unsigned int v27 = *(void **)memptr;
            *(void *)(v23 + 1040) = *(void *)memptr;
          }
          memcpy(v27, *(const void **)v22, v28);
        }
        else
        {
          free(*(void **)v24);
          *(void *)uint64_t v24 = 0;
          *(void *)(v24 + 8) = 0;
        }
        *(_DWORD *)(v23 + 1056) = *(_DWORD *)(v22 + 16);
      }
      std::mutex::unlock(v25);
    }
    kdebug_trace();
    goto LABEL_7;
  }
LABEL_32:
  atomic_fetch_add((atomic_uint *volatile)a1, 0xFFFFFFFF);
  return kdebug_trace();
}

void *sub_1D0E03DE4(void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    BOOL v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        int64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        int64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      int64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1D0E0404C(void *a1@<X0>, void *a2@<X8>)
{
  BOOL v4 = (uint64_t *)a1[5];
  uint64_t v5 = *v4;
  uint64_t *v4 = 0;
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v5 + 24);
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)(v5 + 24));
  std::__assoc_sub_state::__sub_wait((std::__assoc_sub_state *)v5, &__lk);
  uint64_t v6 = *(void *)(v5 + 16);
  v34[0].__ptr_ = 0;
  std::exception_ptr::~exception_ptr(v34);
  if (v6)
  {
    std::exception_ptr::exception_ptr(v34, (const std::exception_ptr *)(v5 + 16));
    v25.__ptr_ = v34;
    std::rethrow_exception(v25);
    sub_1D0E04750();
    return;
  }
  LOBYTE(v34[0].__ptr_) = 0;
  int v7 = *(unsigned __int8 *)(v5 + 160);
  if (*(unsigned char *)(v5 + 160))
  {
    *(_OWORD *)&v34[0].__ptr_ = *(_OWORD *)(v5 + 144);
    *(void *)(v5 + 144) = 0;
    *(void *)(v5 + 152) = 0;
  }
  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
  if (!atomic_fetch_add((atomic_ullong *volatile)(v5 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
    if (v7) {
      goto LABEL_8;
    }
LABEL_10:
    *a2 = 0;
    a2[1] = 0;
    goto LABEL_11;
  }
  if (!v7) {
    goto LABEL_10;
  }
LABEL_8:
  *(_OWORD *)a2 = *(_OWORD *)&v34[0].__ptr_;
LABEL_11:
  uint64_t v8 = (void *)a1[1];
  uint64_t v9 = a1[3];
  uint64_t v10 = (std::__shared_weak_count *)a1[4];
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)std::string __dst = operator new(0x28uLL);
  *(_OWORD *)&__dst[8] = xmmword_1D0E813F0;
  strcpy(*(char **)__dst, "com.apple.applecva.taskthreadpool");
  LOBYTE(v29) = 0;
  BYTE4(v29) = 0;
  BYTE8(v29) = 0;
  BYTE12(v29) = 0;
  __int16 v30 = 0;
  LOBYTE(v31) = 0;
  unsigned __int8 v33 = 0;
  sub_1D0DCEE38((void **)__dst, "com.apple.applecva.facekit.2", 0x1CuLL);
  LODWORD(v29) = 1;
  BYTE4(v29) = 1;
  BYTE12(v29) = 1;
  DWORD2(v29) = 31;
  unint64_t v26 = v10;
  if (v33)
  {
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v11 = v32;
    uint64_t v31 = v9;
    uint64_t v32 = v10;
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
    uint64_t v31 = v9;
    uint64_t v32 = v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unsigned __int8 v33 = 1;
  }
  uint64_t v12 = v8[1];
  int v13 = *(std::exception_ptr **)(v12 + 16);
  unsigned int v27 = *(std::exception_ptr **)(v12 + 24);
  if (v13 != v27)
  {
    while (1)
    {
      v34[0] = (std::exception_ptr)v13->__ptr_;
      ptr = (atomic_ullong *)v13[1].__ptr_;
      v34[1].__ptr_ = ptr;
      if (ptr) {
        atomic_fetch_add_explicit(ptr + 1, 1uLL, memory_order_relaxed);
      }
      if ((__dst[23] & 0x80000000) != 0)
      {
        sub_1D0DCB370(&__p, *(void **)__dst, *(unint64_t *)&__dst[8]);
      }
      else
      {
        long long __p = *(_OWORD *)__dst;
        uint64_t v36 = *(void *)&__dst[16];
      }
      long long v37 = v29;
      __int16 v38 = v30;
      LOBYTE(v39) = 0;
      char v41 = 0;
      int v15 = v33;
      if (v33)
      {
        uint64_t v39 = v31;
        uint64_t v40 = v32;
        if (v32) {
          atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        char v41 = 1;
      }
      uint64_t v16 = (char *)operator new(0x40uLL);
      *((void *)v16 + 1) = 0;
      *((void *)v16 + 2) = 0;
      *(void *)uint64_t v16 = &unk_1F26F4F00;
      *((void *)v16 + 3) = &unk_1F26F4160;
      __lint k = *(std::unique_lock<std::mutex> *)&v34[0].__ptr_;
      v34[0].__ptr_ = 0;
      v34[1].__ptr_ = 0;
      if (SHIBYTE(v36) < 0)
      {
        sub_1D0DCB370(&v43, (void *)__p, *((unint64_t *)&__p + 1));
      }
      else
      {
        long long v43 = __p;
        uint64_t v44 = v36;
      }
      long long v45 = v37;
      __int16 v46 = v38;
      LOBYTE(v47) = 0;
      char v49 = 0;
      if (v15)
      {
        uint64_t v47 = v39;
        unint64_t v48 = v40;
        if (v40) {
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        char v49 = 1;
      }
      *((void *)v16 + 7) = 0;
      uint64_t v17 = (char *)operator new(0x60uLL);
      *(void *)uint64_t v17 = &unk_1F26F4A18;
      *(std::unique_lock<std::mutex> *)(v17 + 8) = __lk;
      __lk.__m_ = 0;
      *(void *)&__lk.__owns_ = 0;
      uint64_t v18 = v17 + 24;
      if (SHIBYTE(v44) < 0)
      {
        sub_1D0DCB370(v18, (void *)v43, *((unint64_t *)&v43 + 1));
      }
      else
      {
        *(_OWORD *)uint64_t v18 = v43;
        *((void *)v17 + 5) = v44;
      }
      *((_OWORD *)v17 + 3) = v37;
      *((_WORD *)v17 + 32) = v38;
      v17[72] = 0;
      v17[88] = 0;
      if (!v15) {
        goto LABEL_51;
      }
      unint64_t v19 = v48;
      *((void *)v17 + 9) = v47;
      *((void *)v17 + 10) = v19;
      if (!v19) {
        break;
      }
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      v17[88] = 1;
      *((void *)v16 + 7) = v17;
      if (atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        if (SHIBYTE(v44) < 0) {
          goto LABEL_52;
        }
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
        if (SHIBYTE(v44) < 0)
        {
LABEL_52:
          operator delete((void *)v43);
          size_t v20 = *(std::__shared_weak_count **)&__lk.__owns_;
          if (!*(void *)&__lk.__owns_) {
            goto LABEL_55;
          }
          goto LABEL_53;
        }
      }
LABEL_48:
      size_t v20 = *(std::__shared_weak_count **)&__lk.__owns_;
      if (!*(void *)&__lk.__owns_) {
        goto LABEL_55;
      }
LABEL_53:
      if (!atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
LABEL_55:
      __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v16 + 24);
      *(void *)&__lk.__owns_ = v16;
      (*(void (**)(void *, std::unique_lock<std::mutex> *))(*v8 + 16))(v8, &__lk);
      uint64_t v21 = *(std::__shared_weak_count **)&__lk.__owns_;
      if (*(void *)&__lk.__owns_
        && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&__lk.__owns_ + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
      if (v41 && (uint64_t v22 = v40) != 0 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
        if ((SHIBYTE(v36) & 0x80000000) == 0)
        {
LABEL_62:
          uint64_t v23 = (std::__shared_weak_count *)v34[1].__ptr_;
          if (v34[1].__ptr_) {
            goto LABEL_68;
          }
          goto LABEL_24;
        }
      }
      else if ((SHIBYTE(v36) & 0x80000000) == 0)
      {
        goto LABEL_62;
      }
      operator delete((void *)__p);
      uint64_t v23 = (std::__shared_weak_count *)v34[1].__ptr_;
      if (v34[1].__ptr_)
      {
LABEL_68:
        if (!atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }
LABEL_24:
      v13 += 2;
      if (v13 == v27) {
        goto LABEL_70;
      }
    }
    v17[88] = 1;
LABEL_51:
    *((void *)v16 + 7) = v17;
    if (SHIBYTE(v44) < 0) {
      goto LABEL_52;
    }
    goto LABEL_48;
  }
LABEL_70:
  if (v33)
  {
    uint64_t v24 = v32;
    if (v32)
    {
      if (!atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }
  if ((__dst[23] & 0x80000000) != 0) {
    operator delete(*(void **)__dst);
  }
  if (v26)
  {
    if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
}

void sub_1D0E04750(void *a1)
{
  sub_1D0E0478C(a1 + 1);
  operator delete(a1);
}

void sub_1D0E0478C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[3];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[3];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  BOOL v4 = (std::__shared_weak_count *)a1[1];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_1D0E048A8(uint64_t a1)
{
}

void *sub_1D0E048B0(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = &unk_1F26F3948;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = result[4];
  a2[3] = result[3];
  a2[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = result[6];
  a2[5] = result[5];
  a2[6] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_1D0E04918(void *a1)
{
  int64_t result = operator new(0x38uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  *int64_t result = &unk_1F26F3948;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a1[4];
  result[3] = a1[3];
  result[4] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = a1[6];
  result[5] = a1[5];
  result[6] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1D0E049A4(void *a1)
{
  *a1 = &unk_1F26F3948;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[4];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[4];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1D25F16B0);
}

void *sub_1D0E04AE8(void *a1)
{
  *a1 = &unk_1F26F3948;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[4];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[4];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

atomic_ullong *sub_1D0E04C10(uint64_t a1)
{
  int64_t result = *(atomic_ullong **)(a1 + 24);
  if (result)
  {
    if (!atomic_fetch_add(result + 1, 0xFFFFFFFFFFFFFFFFLL)) {
      return (atomic_ullong *)(*(uint64_t (**)(void))(*result + 16))();
    }
  }
  return result;
}

void sub_1D0E04C50(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F3750;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E04CA4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F3750;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_1D0E04CC4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 136))
  {
    if (*(unsigned char *)(a1 + 160))
    {
      uint64_t v2 = *(std::__shared_weak_count **)(a1 + 152);
      if (v2)
      {
        if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
          std::__shared_weak_count::__release_weak(v2);
        }
      }
    }
  }
  uint64_t v3 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 8);
  return v3(a1);
}

void sub_1D0E04D70(uint64_t a1)
{
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  uint64_t v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E04DF0(uint64_t a1)
{
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  uint64_t v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

uint64_t sub_1D0E04E5C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    (*(void (**)(long long *__return_ptr))(*(void *)result + 48))(&v9);
    long long v8 = v9;
    long long v9 = 0uLL;
    uint64_t v3 = *(void *)(a1 + 40);
    if (!v3
      || (std::mutex::lock((std::mutex *)(v3 + 24)), (*(unsigned char *)(v3 + 136) & 1) != 0)
      || (v10.__ptr_ = 0, uint64_t v4 = *(void *)(v3 + 16), std::exception_ptr::~exception_ptr(&v10), v4))
    {
      uint64_t v7 = sub_1D0DF0920();
      return sub_1D0E04FE4(v7);
    }
    else
    {
      uint64_t v5 = a1 + 8;
      *(_OWORD *)(v3 + 144) = v8;
      *(unsigned char *)(v3 + 160) = 1;
      *(_DWORD *)(v3 + 136) |= 5u;
      std::condition_variable::notify_all((std::condition_variable *)(v3 + 88));
      std::mutex::unlock((std::mutex *)(v3 + 24));
      uint64_t v6 = (std::__shared_weak_count *)*((void *)&v9 + 1);
      if (*((void *)&v9 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v9 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
      uint64_t result = *(void *)(a1 + 32);
      *(void *)(a1 + 32) = 0;
      if (result == v5)
      {
        return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32))(a1 + 8);
      }
      else if (result)
      {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
      }
    }
  }
  else
  {
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

void sub_1D0E04FE4(void *a1)
{
  sub_1D0E0501C(a1);
  JUMPOUT(0x1D25F16B0);
}

void *sub_1D0E0501C(void *a1)
{
  *a1 = &unk_1F26F41B0;
  if (a1[4])
  {
    uint64_t v2 = a1[5];
    if (!v2
      || (std::mutex::lock((std::mutex *)(v2 + 24)), (*(unsigned char *)(v2 + 136) & 1) != 0)
      || (v9[0].__ptr_ = 0, uint64_t v3 = *(void *)(v2 + 16), std::exception_ptr::~exception_ptr(v9), v3))
    {
      sub_1D0DF0920();
      goto LABEL_18;
    }
    *(unsigned char *)(v2 + 144) = 0;
    *(unsigned char *)(v2 + 160) = 0;
    *(_DWORD *)(v2 + 136) |= 5u;
    std::condition_variable::notify_all((std::condition_variable *)(v2 + 88));
    std::mutex::unlock((std::mutex *)(v2 + 24));
  }
  uint64_t v4 = a1[5];
  if (!v4) {
    goto LABEL_12;
  }
  if ((*(unsigned char *)(v4 + 136) & 1) == 0)
  {
    v9[0].__ptr_ = 0;
    uint64_t v5 = *(void *)(v4 + 16);
    std::exception_ptr::~exception_ptr(v9);
    uint64_t v4 = a1[5];
    if (!v5 && *(uint64_t *)(v4 + 8) >= 1)
    {
LABEL_18:
      long long v8 = std::future_category();
      MEMORY[0x1D25F1310](v9, 4, v8);
      abort();
    }
  }
  if (!atomic_fetch_add((atomic_ullong *volatile)(v4 + 8), 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  }
LABEL_12:
  uint64_t v6 = (void *)a1[4];
  if (v6 == a1 + 1)
  {
    (*(void (**)(void *))(a1[1] + 32))(a1 + 1);
  }
  else if (v6)
  {
    (*(void (**)(void *))(*v6 + 40))(v6);
  }
  return a1;
}

uint64_t sub_1D0E051BC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1D0E051E0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4F70;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E05234(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4F70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_1D0E05254@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1D0E05270(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void sub_1D0E052EC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_1D0E05368(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = &unk_1F26F3900;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_1D0E053A0(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = &unk_1F26F3900;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1D0E053FC(void *a1)
{
  *a1 = &unk_1F26F3900;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1D25F16B0);
}

void *sub_1D0E054A4(void *a1)
{
  *a1 = &unk_1F26F3900;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1D0E0552C(uint64_t *a1)
{
  uint64_t v2 = *(void *)(*a1 + 56);
  if (v2)
  {
    (*(void (**)(long long *__return_ptr))(*(void *)v2 + 48))(&v10);
    uint64_t v3 = *a1;
    long long v4 = v10;
    long long v10 = 0uLL;
    uint64_t v5 = *(std::__shared_weak_count **)(v3 + 24);
    *(_OWORD *)(v3 + 16) = v4;
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    uint64_t v6 = (std::__shared_weak_count *)*((void *)&v10 + 1);
    if (*((void *)&v10 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v10 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
    uint64_t v7 = *a1 + 32;
    uint64_t v8 = *(void *)(*a1 + 56);
    *(void *)(*a1 + 56) = 0;
    if (v8 == v7)
    {
      (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
    }
    else if (v8)
    {
      (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
    }
  }
  else
  {
    long long v9 = (void *)sub_1D0DD8808();
    operator delete(v9);
  }
}

uint64_t sub_1D0E0569C(uint64_t a1)
{
  std::mutex::~mutex((std::mutex *)(a1 + 32));
  uint64_t result = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v3();
  }
  return result;
}

void sub_1D0E0570C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4FA8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E05760(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4FA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0E05780(void *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = (void (*)(void *, uint64_t *))a1[1];
  long long v4 = (void *)(a1[3] + (v2 >> 1));
  if (v2) {
    uint64_t v3 = *(void (**)(void *, uint64_t *))(*v4 + v3);
  }
  uint64_t v6 = a1[4];
  uint64_t v5 = (std::__shared_weak_count *)a1[5];
  uint64_t v8 = v6;
  long long v9 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v3(v4, &v8);
  uint64_t v7 = v9;
  if (v9)
  {
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_1D0E05834(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[5];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void sub_1D0E058B0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_1D0E0592C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1F26F38B8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  uint64_t v2 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

char *sub_1D0E05974(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x30uLL);
  *(void *)uint64_t result = &unk_1F26F38B8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  uint64_t v4 = *(void *)(a1 + 40);
  *((void *)result + 5) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1D0E059E0(void *a1)
{
  *a1 = &unk_1F26F38B8;
  uint64_t v1 = (std::__shared_weak_count *)a1[5];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1D25F16B0);
}

void *sub_1D0E05A88(void *a1)
{
  *a1 = &unk_1F26F38B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_1D0E05B10(void *a1)
{
  uint64_t v1 = a1[2];
  uint64_t v2 = (uint64_t (*)(void *, void *))a1[1];
  uint64_t v3 = (void *)(a1[3] + (v1 >> 1));
  if (v1) {
    uint64_t v2 = *(uint64_t (**)(void *, void *))(*v3 + v2);
  }
  return v2(v3, a1 + 4);
}

void sub_1D0E05B40(void *__p)
{
  uint64_t v2 = __p[4];
  if (v2)
  {
    uint64_t v3 = __p[5];
    uint64_t v4 = (void *)__p[4];
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)__p[4];
    }
    __p[5] = v2;
    operator delete(v4);
  }
  operator delete(__p);
}

void sub_1D0E05C04(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = *(void **)(a1 + 32);
    if (v3 != v1)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v1);
      uint64_t v4 = *(void **)(a1 + 32);
    }
    *(void *)(a1 + 40) = v1;
    operator delete(v4);
  }
}

int64_t sub_1D0E05CD4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F26F3870;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 24) = v2;
  *(void *)(a2 + 32) = 0;
  uint64_t v3 = *(char **)(a1 + 32);
  uint64_t v4 = *(char **)(a1 + 40);
  int64_t result = v4 - v3;
  if (v4 != v3)
  {
    if (result < 0) {
      abort();
    }
    uint64_t v7 = result >> 4;
    int64_t result = (int64_t)operator new(result);
    *(void *)(a2 + 32) = result;
    *(void *)(a2 + 40) = result;
    *(void *)(a2 + 48) = result + 16 * v7;
    do
    {
      uint64_t v8 = *((void *)v3 + 1);
      *(void *)int64_t result = *(void *)v3;
      *(void *)(result + 8) = v8;
      if (v8) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
      }
      result += 16;
      v3 += 16;
    }
    while (v3 != v4);
    *(void *)(a2 + 40) = result;
  }
  return result;
}

char *sub_1D0E05D88(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = &unk_1F26F3870;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(char **)(a1 + 32);
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  *((void *)v2 + 4) = 0;
  *((void *)v2 + 5) = 0;
  *((void *)v2 + 6) = 0;
  uint64_t v4 = *(char **)(a1 + 40);
  int64_t v5 = v4 - v3;
  if (v4 != v3)
  {
    if (v5 < 0) {
      abort();
    }
    uint64_t v6 = v5 >> 4;
    uint64_t v7 = operator new(v5);
    *((void *)v2 + 4) = v7;
    *((void *)v2 + 5) = v7;
    *((void *)v2 + 6) = &v7[2 * v6];
    do
    {
      uint64_t v8 = *((void *)v3 + 1);
      void *v7 = *(void *)v3;
      v7[1] = v8;
      if (v8) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
      }
      v7 += 2;
      v3 += 16;
    }
    while (v3 != v4);
    *((void *)v2 + 5) = v7;
  }
  return v2;
}

void sub_1D0E05E4C(void *a1)
{
  *a1 = &unk_1F26F3870;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = a1[5];
    uint64_t v4 = (void *)a1[4];
    if (v3 != v2)
    {
      do
      {
        int64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[4];
    }
    a1[5] = v2;
    operator delete(v4);
  }
  JUMPOUT(0x1D25F16B0);
}

void *sub_1D0E05F3C(void *a1)
{
  *a1 = &unk_1F26F3870;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = a1[5];
    uint64_t v4 = (void *)a1[4];
    if (v3 != v2)
    {
      do
      {
        int64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[4];
    }
    a1[5] = v2;
    operator delete(v4);
  }
  return a1;
}

void sub_1D0E0600C(void *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  sub_1D0E06244((uint64_t)__p);
  *(_DWORD *)int buf = 1;
  uint64_t v2 = (std::__shared_weak_count *)operator new(0x2A0uLL);
  v2->__shared_owners_ = 0;
  v2->__shared_weak_owners_ = 0;
  v2->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4FE0;
  uint64_t v3 = sub_1D0E777A8((uint64_t)&v2[1], (long long *)__p, buf);
  if (((uint64_t (*)(uint64_t))v2[1].__on_zero_shared)(v3))
  {
    *a1 = v2 + 1;
    a1[1] = v2;
    if ((v7 & 0x80000000) == 0) {
      return;
    }
    goto LABEL_8;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v4 = (id)qword_1EB9F1620;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    int64_t v5 = __p;
    if (v7 < 0) {
      int64_t v5 = (void **)__p[0];
    }
    *(_DWORD *)int buf = 136315138;
    long long v9 = v5;
    _os_log_error_impl(&dword_1D0DBD000, v4, OS_LOG_TYPE_ERROR, "couldn't open %s", buf, 0xCu);
  }

  *a1 = 0;
  a1[1] = 0;
  if (atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
    goto LABEL_8;
  }
  ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
  std::__shared_weak_count::__release_weak(v2);
  if (v7 < 0) {
LABEL_8:
  }
    operator delete(__p[0]);
}

void sub_1D0E0620C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1D0E06244(uint64_t a1)
{
  cva::Path::Path();
  cva::Path::Path();
  cva::Path::Path((cva::Path *)v6, (const cva::Path *)v4);
  cva::Path::append();
  cva::Path::Path((cva::Path *)v5, (const cva::Path *)v6);
  cva::Path::~Path((cva::Path *)v6);
  uint64_t v2 = cva::Path::string((cva::Path *)v5);
  if (*(char *)(v2 + 23) < 0)
  {
    sub_1D0DCB370((unsigned char *)a1, *(void **)v2, *(void *)(v2 + 8));
  }
  else
  {
    *(_OWORD *)a1 = *(_OWORD *)v2;
    *(void *)(a1 + 16) = *(void *)(v2 + 16);
  }
  cva::Path::~Path((cva::Path *)v5);
  cva::Path::~Path((cva::Path *)&v3);
  cva::Path::~Path((cva::Path *)v4);
}

void sub_1D0E062F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
}

uint64_t sub_1D0E0633C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1D0E06360(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4FE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E063B4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4FE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0E0646C()
{
  v30[9] = *MEMORY[0x1E4F143B8];
  v29[0] = &unk_1F26F93A8;
  v27[0] = &unk_1F26F9360;
  v27[1] = &unk_1F26F9378;
  v28[0] = &unk_1F26F9450;
  v28[1] = &unk_1F26F9460;
  v27[2] = &unk_1F26F9390;
  v28[2] = &unk_1F26F9470;
  uint64_t v10 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v28 forKeys:v27 count:3];
  v30[0] = v10;
  v29[1] = &unk_1F26F9360;
  v25[0] = &unk_1F26F9360;
  v25[1] = &unk_1F26F9378;
  v26[0] = &unk_1F26F9480;
  v26[1] = &unk_1F26F9460;
  v25[2] = &unk_1F26F9390;
  v26[2] = &unk_1F26F9490;
  long long v9 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v26 forKeys:v25 count:3];
  v30[1] = v9;
  v29[2] = &unk_1F26F9378;
  v23[0] = &unk_1F26F9360;
  v23[1] = &unk_1F26F9378;
  v24[0] = &unk_1F26F94A0;
  v24[1] = &unk_1F26F94B0;
  v23[2] = &unk_1F26F9390;
  v24[2] = &unk_1F26F94C0;
  uint64_t v8 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v24 forKeys:v23 count:3];
  v30[2] = v8;
  v29[3] = &unk_1F26F9390;
  v21[0] = &unk_1F26F9360;
  v21[1] = &unk_1F26F9378;
  v22[0] = &unk_1F26F9450;
  v22[1] = &unk_1F26F94C0;
  v21[2] = &unk_1F26F9390;
  uint64_t v22[2] = &unk_1F26F94D0;
  char v7 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v22 forKeys:v21 count:3];
  v30[3] = v7;
  void v29[4] = &unk_1F26F93C0;
  v19[0] = &unk_1F26F9360;
  v19[1] = &unk_1F26F9378;
  v20[0] = &unk_1F26F9460;
  v20[1] = &unk_1F26F94C0;
  v19[2] = &unk_1F26F9390;
  v20[2] = &unk_1F26F94E0;
  uint64_t v6 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v20 forKeys:v19 count:3];
  void v30[4] = v6;
  v29[5] = &unk_1F26F93D8;
  v17[0] = &unk_1F26F9360;
  v17[1] = &unk_1F26F9378;
  v18[0] = &unk_1F26F94F0;
  v18[1] = &unk_1F26F94B0;
  v17[2] = &unk_1F26F9390;
  v18[2] = &unk_1F26F9490;
  unint64_t v0 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v18 forKeys:v17 count:3];
  v30[5] = v0;
  v29[6] = &unk_1F26F93F0;
  v15[0] = &unk_1F26F9360;
  v15[1] = &unk_1F26F9378;
  v16[0] = &unk_1F26F9500;
  v16[1] = &unk_1F26F9460;
  v15[2] = &unk_1F26F9390;
  v16[2] = &unk_1F26F9510;
  uint64_t v1 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v16 forKeys:v15 count:3];
  v30[6] = v1;
  v29[7] = &unk_1F26F9408;
  v13[0] = &unk_1F26F9360;
  v13[1] = &unk_1F26F9378;
  v14[0] = &unk_1F26F9520;
  v14[1] = &unk_1F26F9460;
  v13[2] = &unk_1F26F9390;
  v14[2] = &unk_1F26F9490;
  uint64_t v2 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v14 forKeys:v13 count:3];
  v30[7] = v2;
  v29[8] = &unk_1F26F9420;
  v11[0] = &unk_1F26F9360;
  v11[1] = &unk_1F26F9378;
  v12[0] = &unk_1F26F9520;
  v12[1] = &unk_1F26F9460;
  v11[2] = &unk_1F26F9390;
  void v12[2] = &unk_1F26F9490;
  uint64_t v3 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v12 forKeys:v11 count:3];
  v30[8] = v3;
  uint64_t v4 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v30 forKeys:v29 count:9];
  int64_t v5 = (void *)qword_1EA6437D0;
  qword_1EA6437D0 = v4;
}

void sub_1D0E06EE0(uint64_t a1, uint64_t *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  long long v14 = 0u;
  memset(v13, 0, sizeof(v13));
  uint64_t v3 = *a2;
  unsigned int v4 = *(_DWORD *)(*a2 + 152) - 2;
  int64_t v5 = *(const void **)(*a2 + 136);
  uint64_t v6 = 4 * v4;
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6);
  theCFDataRef Data = Mutable;
  CFDataSetLength(Mutable, v6);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (v4) {
    memcpy(MutableBytePtr, v5, v6);
  }
  uint64_t v9 = *(void *)(v3 + 136);
  HIDWORD(v13[1]) = *(_DWORD *)v9;
  LODWORD(v14) = *(_DWORD *)(v9 + 4);
  *(void *)((char *)&v14 + 4) = *(void *)(v9 + 204);
  *(_DWORD *)CFDataGetMutableBytePtr(Mutable) = DWORD1(v14);
  *((_DWORD *)CFDataGetMutableBytePtr(theData) + 1) = DWORD2(v14);
  uint64_t v10 = *a2;
  uint64_t v11 = *a2 + 208;
  if (v13 != (_OWORD *)v11)
  {
    *(void *)&v13[0] = *(void *)v11;
    DWORD2(v13[0]) = *(_DWORD *)(v11 + 8);
  }
  *(int32x4_t *)((char *)v13 + 12) = vuzp2q_s32(*(int32x4_t *)(v10 + 220), vrev64q_s32(*(int32x4_t *)(v10 + 220)));
  HIDWORD(v14) = *(_DWORD *)(v10 + 236);
  sub_1D0E52E9C((cva::DictionaryHandler *)&v12, (uint64_t)v13);
}

void sub_1D0E0769C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1D0E07840(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v6 = *a1;
  cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)v25);
  float v23 = *(float *)(*(void *)a2 + 128);
  if (!a3)
  {
LABEL_12:
    uint64_t v19 = *(void *)a1[1];
    float32x2_t v20 = *(float32x2_t *)(v19 + 252);
    float v21 = *(float *)(v19 + 260);
    v26[1] = (void *)8;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, 0x20uLL, 0x49090899uLL);
    uint64_t v22 = (float *)memptr;
    v26[0] = memptr;
    int v27 = 3;
    *(float32x2_t *)memptr = vmul_n_f32(v20, v23);
    uint64_t v22[2] = v23 * v21;
    cva::ItemHandler::createVector<float>();
  }
  sub_1D0E07EBC(*(void *)a1[1] + 184, *(void *)(*(void *)a2 + 136), *(_DWORD *)(*(void *)a2 + 152), v6 + 168);
  char v7 = *(const UInt8 **)(v6 + 168);
  int v8 = *(_DWORD *)(v6 + 184);
  if (v23 != 1.0 && v8)
  {
    uint64_t v9 = (3 * v8);
    unint64_t v10 = (v9 - 1) & 0x3FFFFFFFFFFFFFFFLL;
    uint64_t v11 = *(float **)(v6 + 168);
    if (v10 >= 7)
    {
      uint64_t v12 = (v10 + 1) & 0x7FFFFFFFFFFFFFF8;
      int v13 = (float32x4_t *)(v7 + 16);
      uint64_t v14 = v12;
      do
      {
        float32x4_t v15 = vmulq_n_f32(*v13, v23);
        v13[-1] = vmulq_n_f32(v13[-1], v23);
        float32x4_t *v13 = v15;
        v13 += 2;
        v14 -= 8;
      }
      while (v14);
      if (v10 + 1 == v12) {
        goto LABEL_11;
      }
      uint64_t v11 = (float *)&v7[4 * v12];
    }
    uint64_t v16 = (float *)&v7[4 * v9];
    do
    {
      *uint64_t v11 = v23 * *v11;
      ++v11;
    }
    while (v11 != v16);
  }
LABEL_11:
  uint64_t v17 = CFDataCreate(0, v7, 4 * (3 * v8 - 6));
  cva::ItemHandler::createData((uint64_t *)v26, v17, v18);
  cva::DictionaryHandler::setItem((cva::DictionaryHandler *)v25, @"vertices", (const cva::ItemHandler *)v26);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v26);
  CFRelease(v17);
  goto LABEL_12;
}

void sub_1D0E07DB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, void *a17)
{
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)&a17);
  CFRelease(v17);
  cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)&a13);
  _Unwind_Resume(a1);
}

void sub_1D0E07EBC(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  int v24 = a3 - 2;
  uint64_t v25 = a2;
  int v26 = a3;
  int v27 = 0;
  unsigned int v6 = *(_DWORD *)(a1 + 152);
  *(_DWORD *)(a4 + 16) = v6 / 3;
  if (v6 > 2)
  {
    unint64_t v8 = 3 * (v6 / 3);
    char v7 = *(_OWORD **)a4;
    if (*(void *)(a4 + 8) < v8)
    {
      free(v7);
      size_t v9 = (4 * v8 + 31) & 0x7FFFFFFE0;
      *(void *)a4 = 0;
      *(void *)(a4 + 8) = v9 >> 2;
      memptr[0] = 0;
      malloc_type_posix_memalign(memptr, 0x20uLL, v9, 0x49090899uLL);
      char v7 = memptr[0];
      *(void **)a4 = memptr[0];
    }
  }
  else
  {
    free(*(void **)a4);
    char v7 = 0;
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
  }
  int v10 = *(_DWORD *)(a4 + 16);
  uint64_t v11 = (3 * v10);
  int v28 = 3 * v10;
  long long v29 = v7;
  int v30 = 3 * v10;
  int v31 = 0;
  if (v10)
  {
    uint64_t v12 = *(int **)(a1 + 136);
    unint64_t v13 = (v11 - 1) & 0x3FFFFFFFFFFFFFFFLL;
    if (v13 < 7)
    {
      uint64_t v14 = v7;
LABEL_13:
      uint64_t v22 = (_DWORD *)v7 + v11;
      do
      {
        int v23 = *v12++;
        *v14++ = v23;
      }
      while (v14 != v22);
      goto LABEL_15;
    }
    uint64_t v14 = v7;
    if ((unint64_t)((char *)v7 - (char *)v12) < 0x20) {
      goto LABEL_13;
    }
    unint64_t v15 = v13 + 1;
    uint64_t v16 = (v13 + 1) & 0x7FFFFFFFFFFFFFF8;
    uint64_t v17 = &v12[v16];
    CFDataRef v18 = v7 + 1;
    uint64_t v19 = (long long *)(v12 + 4);
    uint64_t v20 = v16;
    do
    {
      long long v21 = *v19;
      *(v18 - 1) = *(v19 - 1);
      *CFDataRef v18 = v21;
      v18 += 2;
      v19 += 2;
      v20 -= 8;
    }
    while (v20);
    if (v15 != v16)
    {
      uint64_t v14 = (_DWORD *)v7 + v16;
      uint64_t v12 = v17;
      goto LABEL_13;
    }
  }
LABEL_15:
  memptr[1] = (void *)(a1 + 160);
  memptr[2] = &v24;
  int v33 = 1065353216;
  sub_1D0E08068((unsigned int *)&v28, (uint64_t)memptr);
}

void sub_1D0E08068(unsigned int *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *((void *)a1 + 1) - 4 * a1[5];
  if (*(void *)v4 == v5 || (uint64_t v6 = *(void *)(a2 + 16), *(void *)(v6 + 8) - 4 * *(unsigned int *)(v6 + 20) == v5))
  {
    size_t v7 = (4 * *(unsigned int *)(v4 + 16) + 31) & 0x7FFFFFFE0;
    v21[1] = (void *)(v7 >> 2);
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    v21[0] = memptr;
    int v22 = *(_DWORD *)(*(void *)(a2 + 8) + 16);
    sub_1D0E08230((uint64_t)v21, a2);
    uint64_t v8 = *a1;
    size_t v9 = v21[0];
    if (v8)
    {
      int v10 = (float32x4_t *)*((void *)a1 + 1);
      unint64_t v11 = (v8 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v11 >= 0xB)
      {
        if (v10 >= (float32x4_t *)((char *)v21[0] + 4 * v8)
          || (uint64_t v12 = (float *)v21[0], v13 = (float *)*((void *)a1 + 1), v21[0] >= &v10->f32[v8]))
        {
          uint64_t v14 = (v11 + 1) & 0x7FFFFFFFFFFFFFF8;
          uint64_t v12 = (float *)((char *)v21[0] + 4 * v14);
          unint64_t v15 = v10 + 1;
          uint64_t v16 = (float32x4_t *)((char *)v21[0] + 16);
          uint64_t v17 = v14;
          do
          {
            float32x4_t v18 = vaddq_f32(*v16, *v15);
            v15[-1] = vaddq_f32(v16[-1], v15[-1]);
            *unint64_t v15 = v18;
            v15 += 2;
            v16 += 2;
            v17 -= 8;
          }
          while (v17);
          if (v11 + 1 == v14) {
            goto LABEL_17;
          }
          unint64_t v13 = &v10->f32[v14];
        }
      }
      else
      {
        uint64_t v12 = (float *)v21[0];
        unint64_t v13 = (float *)*((void *)a1 + 1);
      }
      uint64_t v19 = &v10->f32[v8];
      do
      {
        float v20 = *v12++;
        float *v13 = v20 + *v13;
        ++v13;
      }
      while (v13 != v19);
    }
LABEL_17:
    free(v9);
    return;
  }
  if (*(_DWORD *)(v4 + 20) * *(_DWORD *)(v4 + 16))
  {
    if (*(_DWORD *)v6) {
      cva::VecLib<float>::gemm();
    }
  }
}

void sub_1D0E0821C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
}

void sub_1D0E08230(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void **)a1;
  if (*(void **)v4 == v5
    || (uint64_t v6 = *(void *)(a2 + 16), (void *)(*(void *)(v6 + 8) - 4 * *(unsigned int *)(v6 + 20)) == v5))
  {
    size_t v7 = (4 * *(unsigned int *)(v4 + 16) + 31) & 0x7FFFFFFE0;
    size_t v12 = v7 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    unint64_t v11 = memptr;
    int v13 = *(_DWORD *)(*(void *)(a2 + 8) + 16);
    sub_1D0E08230(&v11, a2);
    uint64_t v8 = *(void **)a1;
    size_t v9 = v12;
    *(void *)a1 = v11;
    *(void *)(a1 + 8) = v9;
    *(_DWORD *)(a1 + 16) = v13;
    free(v8);
  }
  else
  {
    if (*(_DWORD *)(v4 + 20) * *(_DWORD *)(v4 + 16) && *(_DWORD *)v6) {
      cva::VecLib<float>::gemm();
    }
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      bzero(v5, 4 * v10);
    }
  }
}

void sub_1D0E08364(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
}

void sub_1D0E08378()
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  unint64_t v0 = operator new(0x28uLL);
  v0[1] = 0;
  v0[2] = 0;
  *unint64_t v0 = &unk_1F26F4B80;
  cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)(v0 + 3));
  uint64_t v4 = v0 + 3;
  uint64_t v5 = v0;
  cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)v3);
  *(void *)&time.timescale = 8;
  memptr = 0;
  malloc_type_posix_memalign(&memptr, 0x20uLL, 0x20uLL, 0x49090899uLL);
  uint64_t v1 = memptr;
  time.value = (CMTimeValue)memptr;
  LODWORD(time.epoch) = 3;
  *(void *)memptr = 38;
  v1[2] = 0;
  cva::ItemHandler::createVector<int>();
}

void sub_1D0E08C44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,void *a21)
{
}

void sub_1D0E08E18(uint64_t a1, uint64_t ***a2, double a3)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  int64_t v5 = (char *)v3 - (char *)*a2;
  if (v3 == *a2) {
    return;
  }
  if (v5 < 0) {
    abort();
  }
  __p[0] = operator new(v5);
  __p[1] = __p[0];
  int v50 = (char *)__p[0] + 16 * (v5 >> 4);
  do
  {
    uint64_t v7 = **v4;
    uint64_t v8 = *(void *)(v7 + 136);
    size_t v9 = *(std::__shared_weak_count **)(v7 + 144);
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      unsigned __int8 v10 = atomic_load((unsigned __int8 *)(v8 + 80));
      if (atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        if ((v10 & 1) == 0) {
          goto LABEL_5;
        }
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
        if ((v10 & 1) == 0) {
          goto LABEL_5;
        }
      }
    }
    else
    {
      unsigned __int8 v11 = atomic_load((unsigned __int8 *)(v8 + 80));
      if ((v11 & 1) == 0) {
        goto LABEL_5;
      }
    }
    uint64_t v12 = **v4;
    uint64_t v14 = *(void *)(v12 + 136);
    uint64_t v13 = *(void *)(v12 + 144);
    *(void *)__lint k = v14;
    *(void *)&__lk[8] = v13;
    if (v13) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v15 = (char *)__p[1];
    if (__p[1] < v50)
    {
      *(_OWORD *)__p[1] = *(_OWORD *)__lk;
      __p[1] = (char *)__p[1] + 16;
      goto LABEL_5;
    }
    uint64_t v16 = (char *)__p[0];
    uint64_t v17 = ((char *)__p[1] - (char *)__p[0]) >> 4;
    unint64_t v18 = v17 + 1;
    if ((unint64_t)(v17 + 1) >> 60) {
      abort();
    }
    uint64_t v19 = v50 - (char *)__p[0];
    if ((v50 - (char *)__p[0]) >> 3 > v18) {
      unint64_t v18 = v19 >> 3;
    }
    if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v20 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v20 = v18;
    }
    if (v20 >> 60) {
      sub_1D0DE8CE0();
    }
    long long v21 = (char *)operator new(16 * v20);
    int v22 = &v21[16 * v17];
    *(_OWORD *)int v22 = *(_OWORD *)__lk;
    int v23 = v22 + 16;
    *(void *)__lint k = 0;
    *(void *)&__lk[8] = 0;
    if (__p[1] == __p[0])
    {
      __p[0] = v22;
      int v50 = &v21[16 * v20];
      if (!__p[1]) {
        goto LABEL_33;
      }
    }
    else
    {
      int v24 = __p[1];
      do
      {
        long long v25 = *((_OWORD *)v24 - 1);
        v24 -= 2;
        *((_OWORD *)v22 - 1) = v25;
        v22 -= 16;
        *int v24 = 0;
        v24[1] = 0;
      }
      while (v24 != __p[0]);
      __p[0] = v22;
      int v50 = &v21[16 * v20];
      do
      {
        int v26 = (std::__shared_weak_count *)*((void *)v15 - 1);
        if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
        v15 -= 16;
      }
      while (v15 != v16);
      unint64_t v15 = v16;
      if (!v16) {
        goto LABEL_33;
      }
    }
    operator delete(v15);
LABEL_33:
    __p[1] = v23;
    if (*(void *)&__lk[8]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&__lk[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      (*(void (**)(void))(**(void **)&__lk[8] + 16))(*(void *)&__lk[8]);
      std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&__lk[8]);
    }
LABEL_5:
    v4 += 2;
  }
  while (v4 != v3);
  int v27 = (char *)__p[1];
  if (__p[0] != __p[1])
  {
    int v28 = *(atomic_uint *volatile **)(a1 + 32);
    long long v29 = (unsigned int *)*v28;
    double v30 = *((double *)*v28 + 1);
    if (v30 >= a3)
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
      int v31 = qword_1EB9F1620;
      if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
      {
        uint64_t v46 = *((void *)*v28 + 1);
        *(_DWORD *)__lint k = 134218240;
        *(double *)&__lk[4] = a3;
        *(_WORD *)&__lk[12] = 2048;
        *(void *)&__lk[14] = v46;
        _os_log_error_impl(&dword_1D0DBD000, v31, OS_LOG_TYPE_ERROR, "non-increasing timestamp %15g <= %15g", __lk, 0x16u);
      }
      long long v29 = (unsigned int *)*v28;
      *((void *)*v28 + 1) = 0xFFEFFFFFFFFFFFFFLL;
      double v30 = -1.79769313e308;
    }
    if (v30 >= a3 || v30 + 1000.0 <= a3)
    {
      int v33 = atomic_load(v29);
      if (v33 <= 0)
      {
        *((double *)*v28 + 1) = a3;
        if (a3 + 1000.0 <= a3)
        {
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EB9F1610))
          {
            qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
            __cxa_guard_release(&qword_1EB9F1610);
          }
          uint64_t v34 = qword_1EB9F1620;
          if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)__lint k = 134217984;
            *(double *)&__lk[4] = a3;
            _os_log_debug_impl(&dword_1D0DBD000, v34, OS_LOG_TYPE_DEBUG, "insufficient timestamp precision or invalid timestamp %15g", __lk, 0xCu);
          }
        }
        for (uint64_t i = (unint64_t **)__p[0]; i != __p[1]; i += 2)
        {
          uint64_t v36 = *i;
          atomic_store(*(unint64_t *)&a3, v36);
        }
        atomic_fetch_add(*v28, 1u);
        atomic_uint *volatile v37 = *v28;
        long long v48 = *(_OWORD *)__p;
        *(_OWORD *)long long __p = 0uLL;
        __int16 v38 = (std::__shared_weak_count *)operator new(0xB8uLL);
        v38->__shared_owners_ = 0;
        v38->__shared_weak_owners_ = 0;
        v38->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F5168;
        uint64_t v39 = operator new(0x38uLL);
        *uint64_t v39 = &unk_1F26F3870;
        v39[1] = sub_1D0E0396C;
        uint64_t v39[2] = 0;
        v39[3] = v37;
        *((_OWORD *)v39 + 2) = v48;
        v38[1].__shared_owners_ = 850045863;
        p_shared_owners = (std::mutex *)&v38[1].__shared_owners_;
        v38[4].__vftable = (std::__shared_weak_count_vtbl *)1018212795;
        v39[6] = v50;
        *(_OWORD *)&v38[1].__shared_weak_owners_ = 0u;
        *(_OWORD *)&v38[2].__shared_owners_ = 0u;
        v38[3].std::__shared_count = 0u;
        v38[3].__shared_weak_owners_ = 0;
        *(_OWORD *)&v38[4].__shared_owners_ = 0u;
        v38[5].std::__shared_count = 0u;
        *(_OWORD *)((char *)&v38[5].__shared_owners_ + 1) = 0u;
        v38[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4568;
        v38[7].__shared_owners_ = (uint64_t)sub_1D0E05D88((uint64_t)v39);
        (*(void (**)(void *))(*v39 + 40))(v39);
        uint64_t v41 = *((void *)v37 + 8);
        *(void *)__lint k = v38 + 1;
        *(void *)&__lk[8] = v38;
        atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
        (*(void (**)(uint64_t, unsigned char *))(*(void *)v41 + 16))(v41, __lk);
        unint64_t v42 = *(std::__shared_weak_count **)&__lk[8];
        if (*(void *)&__lk[8]
          && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&__lk[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
          std::__shared_weak_count::__release_weak(v42);
        }
        if (*((unsigned char *)v37 + 80))
        {
          *(void *)__lint k = (char *)v38 + 32;
          __lk[8] = 1;
          std::mutex::lock((std::mutex *)&v38[1].__shared_owners_);
          if (LOBYTE(v38[6].__vftable)) {
            goto LABEL_64;
          }
          do
            std::condition_variable::wait((std::condition_variable *)&v38[4], (std::unique_lock<std::mutex> *)__lk);
          while (!LOBYTE(v38[6].__vftable));
          if (__lk[8])
          {
            p_shared_owners = *(std::mutex **)__lk;
LABEL_64:
            std::mutex::unlock(p_shared_owners);
          }
        }
        if (!atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v38);
        }
      }
    }
    int v27 = (char *)__p[0];
  }
  if (v27)
  {
    long long v43 = (char *)__p[1];
    uint64_t v44 = v27;
    if (__p[1] != v27)
    {
      do
      {
        long long v45 = (std::__shared_weak_count *)*((void *)v43 - 1);
        if (v45)
        {
          if (!atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
            std::__shared_weak_count::__release_weak(v45);
          }
        }
        v43 -= 16;
      }
      while (v43 != v27);
      uint64_t v44 = (char *)__p[0];
    }
    operator delete(v44);
  }
}

void sub_1D0E09588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1D0DF76BC((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1D0E095B0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1D0E0961C(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[2];
  uint64_t v4 = (void (*)(void *, uint64_t, uint64_t *))a1[1];
  int64_t v5 = (void *)(a1[3] + (v3 >> 1));
  if (v3) {
    uint64_t v4 = *(void (**)(void *, uint64_t, uint64_t *))(*v5 + v4);
  }
  uint64_t v7 = a1[4];
  uint64_t v6 = (std::__shared_weak_count *)a1[5];
  uint64_t v9 = v7;
  unsigned __int8 v10 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v4(v5, a2, &v9);
  uint64_t v8 = v10;
  if (v10)
  {
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_1D0E096D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    if (!atomic_fetch_add(&a10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1D0E09724(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[5];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void sub_1D0E097A0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_1D0E0981C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1F26F4700;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  uint64_t v2 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

char *sub_1D0E09864(uint64_t a1)
{
  int64_t result = (char *)operator new(0x30uLL);
  *(void *)int64_t result = &unk_1F26F4700;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  uint64_t v4 = *(void *)(a1 + 40);
  *((void *)result + 5) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1D0E098D0(void *a1)
{
  *a1 = &unk_1F26F4700;
  uint64_t v1 = (std::__shared_weak_count *)a1[5];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1D25F16B0);
}

void *sub_1D0E09978(void *a1)
{
  *a1 = &unk_1F26F4700;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_1D0E09A00(uint64_t a1, uint64_t a2, void *a3)
{
  return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), a2, *a3);
}

void sub_1D0E09A2C()
{
}

void sub_1D0E09AE4(_Unwind_Exception *a1)
{
  uint64_t v4 = v2;
  uint64_t v6 = (char *)*v3;
  if (*v3)
  {
    uint64_t v7 = (char *)v1[13];
    uint64_t v8 = *v3;
    if (v7 != v6)
    {
      do
      {
        uint64_t v9 = (void *)*((void *)v7 - 1);
        if (v9)
        {
          free(v9);
          *((void *)v7 - 1) = 0;
        }
        v7 -= 32;
      }
      while (v7 != v6);
      uint64_t v8 = *v3;
    }
    v1[13] = v6;
    operator delete(v8);
  }
  unsigned __int8 v10 = (std::__shared_weak_count *)v1[5];
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  unsigned __int8 v11 = (std::__shared_weak_count *)v1[3];
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  uint64_t v12 = *v4;
  uint64_t *v4 = 0;
  if (v12)
  {
    if (*(char *)(v12 + 47) < 0) {
      operator delete(*(void **)(v12 + 24));
    }
    MEMORY[0x1D25F16B0](v12, 0x1012C409C40065ELL);
  }
  MEMORY[0x1D25F16B0](v1, 0x10E2C40ACF00C74);
  _Unwind_Resume(a1);
}

uint64_t *sub_1D0E09C1C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (!v2) {
    return a1;
  }
  free(*(void **)(v2 + 168));
  uint64_t v3 = *(void *)(v2 + 160);
  *(void *)(v2 + 160) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *(void *)(v2 + 152);
  *(void *)(v2 + 152) = 0;
  if (v4)
  {
    free(*(void **)(v4 + 64));
    free(*(void **)(v4 + 40));
    free(*(void **)(v4 + 16));
    int64_t v5 = *(std::__shared_weak_count **)(v4 + 8);
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    MEMORY[0x1D25F16B0](v4, 0x10E0C40FDDF1BE6);
  }
  uint64_t v6 = *(void *)(v2 + 144);
  *(void *)(v2 + 144) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  if (*(unsigned char *)(v2 + 136)) {
    sub_1D0E421FC((void *)(v2 + 128));
  }
  uint64_t v7 = *(void ***)(v2 + 120);
  *(void *)(v2 + 120) = 0;
  if (v7)
  {
    uint64_t v8 = (char *)v7[3];
    if (v8)
    {
      uint64_t v9 = (char *)v7[4];
      unsigned __int8 v10 = v7[3];
      if (v9 != v8)
      {
        do
        {
          unsigned __int8 v11 = (std::__shared_weak_count *)*((void *)v9 - 1);
          if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
          v9 -= 16;
        }
        while (v9 != v8);
        unsigned __int8 v10 = v7[3];
      }
      v7[4] = v8;
      operator delete(v10);
    }
    uint64_t v12 = (char *)*v7;
    if (*v7)
    {
      uint64_t v13 = (char *)v7[1];
      uint64_t v14 = *v7;
      if (v13 != v12)
      {
        do
        {
          unint64_t v15 = (std::__shared_weak_count *)*((void *)v13 - 2);
          if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
            std::__shared_weak_count::__release_weak(v15);
          }
          v13 -= 24;
        }
        while (v13 != v12);
        uint64_t v14 = *v7;
      }
      v7[1] = v12;
      operator delete(v14);
    }
    MEMORY[0x1D25F16B0](v7, 0x20C40A759441BLL);
  }
  uint64_t v16 = *(void *)(v2 + 96);
  if (v16)
  {
    uint64_t v17 = *(void *)(v2 + 104);
    unint64_t v18 = *(void **)(v2 + 96);
    if (v17 != v16)
    {
      do
      {
        uint64_t v19 = *(void **)(v17 - 8);
        if (v19)
        {
          free(v19);
          *(void *)(v17 - 8) = 0;
        }
        v17 -= 32;
      }
      while (v17 != v16);
      unint64_t v18 = *(void **)(v2 + 96);
    }
    *(void *)(v2 + 104) = v16;
    operator delete(v18);
  }
  unint64_t v20 = *(std::__shared_weak_count **)(v2 + 40);
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
    long long v21 = *(std::__shared_weak_count **)(v2 + 24);
    if (v21)
    {
LABEL_44:
      if (!atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
  }
  else
  {
    long long v21 = *(std::__shared_weak_count **)(v2 + 24);
    if (v21) {
      goto LABEL_44;
    }
  }
  uint64_t v22 = *(void *)(v2 + 8);
  *(void *)(v2 + 8) = 0;
  if (v22)
  {
    if (*(char *)(v22 + 47) < 0) {
      operator delete(*(void **)(v22 + 24));
    }
    MEMORY[0x1D25F16B0](v22, 0x1012C409C40065ELL);
  }
  MEMORY[0x1D25F16B0](v2, 0x10E2C40ACF00C74);
  return a1;
}

void sub_1D0E09FB4()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  unint64_t v0 = (id)qword_1EB9F1620;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl(&dword_1D0DBD000, v0, OS_LOG_TYPE_INFO, "Initializing FaceKitProcessor.", buf, 2u);
  }

  kdebug_trace();
  std::mutex::lock(&stru_1EB9F15B8);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1EB9F1618)) {
      sub_1D0E225B4();
    }
  }
  sub_1D0E2276C();
  sub_1D0E439FC();
}

void sub_1D0E0D5C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,uint64_t a56,void *a57,uint64_t a58,int a59,__int16 a60,char a61,char a62)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  std::mutex::unlock(&stru_1EB9F15B8);
  kdebug_trace();
  _Unwind_Resume(a1);
}

uint64_t sub_1D0E0D780(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t *sub_1D0E0D7EC(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t v4 = *a1;
  *a1 = v3;
  if (v4)
  {
    free(*(void **)(v4 + 64));
    free(*(void **)(v4 + 40));
    free(*(void **)(v4 + 16));
    int64_t v5 = *(std::__shared_weak_count **)(v4 + 8);
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    MEMORY[0x1D25F16B0](v4, 0x10E0C40FDDF1BE6);
  }
  return a1;
}

uint64_t *sub_1D0E0D8A4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    free(*(void **)(v2 + 64));
    free(*(void **)(v2 + 40));
    free(*(void **)(v2 + 16));
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 8);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    MEMORY[0x1D25F16B0](v2, 0x10E0C40FDDF1BE6);
  }
  return a1;
}

uint64_t sub_1D0E0D954(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 880);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 864);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 864);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 848);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    int64_t v5 = *(std::__shared_weak_count **)(a1 + 832);
    if (!v5) {
      goto LABEL_13;
    }
  }
  else
  {
    int64_t v5 = *(std::__shared_weak_count **)(a1 + 832);
    if (!v5) {
      goto LABEL_13;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_13:
  if (*(unsigned char *)(a1 + 816) && *(char *)(a1 + 815) < 0)
  {
    operator delete(*(void **)(a1 + 792));
    if ((*(char *)(a1 + 783) & 0x80000000) == 0)
    {
LABEL_16:
      if ((*(char *)(a1 + 759) & 0x80000000) == 0) {
        goto LABEL_17;
      }
      goto LABEL_32;
    }
  }
  else if ((*(char *)(a1 + 783) & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(*(void **)(a1 + 760));
  if ((*(char *)(a1 + 759) & 0x80000000) == 0)
  {
LABEL_17:
    if ((*(char *)(a1 + 735) & 0x80000000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_33;
  }
LABEL_32:
  operator delete(*(void **)(a1 + 736));
  if ((*(char *)(a1 + 735) & 0x80000000) == 0)
  {
LABEL_18:
    if ((*(char *)(a1 + 711) & 0x80000000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_34;
  }
LABEL_33:
  operator delete(*(void **)(a1 + 712));
  if ((*(char *)(a1 + 711) & 0x80000000) == 0)
  {
LABEL_19:
    if ((*(char *)(a1 + 687) & 0x80000000) == 0) {
      goto LABEL_20;
    }
    goto LABEL_35;
  }
LABEL_34:
  operator delete(*(void **)(a1 + 688));
  if ((*(char *)(a1 + 687) & 0x80000000) == 0)
  {
LABEL_20:
    if ((*(char *)(a1 + 663) & 0x80000000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_36;
  }
LABEL_35:
  operator delete(*(void **)(a1 + 664));
  if ((*(char *)(a1 + 663) & 0x80000000) == 0)
  {
LABEL_21:
    if ((*(char *)(a1 + 639) & 0x80000000) == 0) {
      goto LABEL_22;
    }
    goto LABEL_37;
  }
LABEL_36:
  operator delete(*(void **)(a1 + 640));
  if ((*(char *)(a1 + 639) & 0x80000000) == 0)
  {
LABEL_22:
    if ((*(char *)(a1 + 615) & 0x80000000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_38;
  }
LABEL_37:
  operator delete(*(void **)(a1 + 616));
  if ((*(char *)(a1 + 615) & 0x80000000) == 0)
  {
LABEL_23:
    if ((*(char *)(a1 + 591) & 0x80000000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_39;
  }
LABEL_38:
  operator delete(*(void **)(a1 + 592));
  if ((*(char *)(a1 + 591) & 0x80000000) == 0)
  {
LABEL_24:
    if ((*(char *)(a1 + 567) & 0x80000000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_40;
  }
LABEL_39:
  operator delete(*(void **)(a1 + 568));
  if ((*(char *)(a1 + 567) & 0x80000000) == 0)
  {
LABEL_25:
    if ((*(char *)(a1 + 543) & 0x80000000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_41;
  }
LABEL_40:
  operator delete(*(void **)(a1 + 544));
  if ((*(char *)(a1 + 543) & 0x80000000) == 0)
  {
LABEL_26:
    if ((*(char *)(a1 + 519) & 0x80000000) == 0) {
      goto LABEL_27;
    }
    goto LABEL_42;
  }
LABEL_41:
  operator delete(*(void **)(a1 + 520));
  if ((*(char *)(a1 + 519) & 0x80000000) == 0)
  {
LABEL_27:
    uint64_t v6 = *(void **)(a1 + 64);
    if (!v6) {
      goto LABEL_28;
    }
    goto LABEL_43;
  }
LABEL_42:
  operator delete(*(void **)(a1 + 496));
  uint64_t v6 = *(void **)(a1 + 64);
  if (!v6)
  {
LABEL_28:
    if ((*(char *)(a1 + 23) & 0x80000000) == 0) {
      return a1;
    }
LABEL_47:
    operator delete(*(void **)a1);
    return a1;
  }
LABEL_43:
  uint64_t v8 = *(void *)(a1 + 72);
  uint64_t v9 = v6;
  if ((void *)v8 != v6)
  {
    do
      uint64_t v8 = sub_1D0E0DC44(v8 - 1168);
    while ((void *)v8 != v6);
    uint64_t v9 = *(void **)(a1 + 64);
  }
  *(void *)(a1 + 72) = v6;
  operator delete(v9);
  if (*(char *)(a1 + 23) < 0) {
    goto LABEL_47;
  }
  return a1;
}

uint64_t sub_1D0E0DC44(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 1160);
  if (!v2 || atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (!*(unsigned char *)(a1 + 1144)) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
  std::__shared_weak_count::__release_weak(v2);
  if (*(unsigned char *)(a1 + 1144)) {
LABEL_4:
  }
    free(*(void **)(a1 + 1120));
LABEL_5:
  if (*(unsigned char *)(a1 + 1112)) {
    sub_1D0E638FC((uint64_t *)(a1 + 1104));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 984);
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (!*(unsigned char *)(a1 + 968)) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  if (*(unsigned char *)(a1 + 968)) {
LABEL_10:
  }
    free(*(void **)(a1 + 944));
LABEL_11:
  if (*(unsigned char *)(a1 + 936)) {
    sub_1D0E638FC((uint64_t *)(a1 + 928));
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 808);
  if (!v4 || atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (!*(unsigned char *)(a1 + 792)) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  if (*(unsigned char *)(a1 + 792)) {
LABEL_16:
  }
    free(*(void **)(a1 + 768));
LABEL_17:
  if (*(unsigned char *)(a1 + 760)) {
    sub_1D0E638FC((uint64_t *)(a1 + 752));
  }
  int64_t v5 = *(std::__shared_weak_count **)(a1 + 632);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 616);
    if (!v6) {
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 616);
    if (!v6) {
      goto LABEL_31;
    }
  }
  if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
LABEL_31:
  if (*(unsigned char *)(a1 + 600) && *(char *)(a1 + 599) < 0)
  {
    operator delete(*(void **)(a1 + 576));
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 568);
    if (!v7) {
      goto LABEL_37;
    }
  }
  else
  {
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 568);
    if (!v7) {
      goto LABEL_37;
    }
  }
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
LABEL_37:
  if (!*(unsigned char *)(a1 + 552) || (*(char *)(a1 + 551) & 0x80000000) == 0)
  {
    if (!*(unsigned char *)(a1 + 512)) {
      goto LABEL_41;
    }
    goto LABEL_40;
  }
  operator delete(*(void **)(a1 + 528));
  if (*(unsigned char *)(a1 + 512)) {
LABEL_40:
  }
    free(*(void **)(a1 + 488));
LABEL_41:
  if (*(unsigned char *)(a1 + 288)) {
    free(*(void **)(a1 + 264));
  }
  if (*(unsigned char *)(a1 + 200) && *(char *)(a1 + 199) < 0)
  {
    operator delete(*(void **)(a1 + 176));
    if (!*(unsigned char *)(a1 + 120)) {
      goto LABEL_51;
    }
  }
  else if (!*(unsigned char *)(a1 + 120))
  {
    goto LABEL_51;
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
LABEL_51:
  if (*(unsigned char *)(a1 + 88)) {
    free(*(void **)(a1 + 64));
  }
  if (*(unsigned char *)(a1 + 56)) {
    free(*(void **)(a1 + 32));
  }
  if (*(unsigned char *)(a1 + 24)) {
    free(*(void **)a1);
  }
  return a1;
}

double sub_1D0E0DF7C@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  (*(void (**)(long long *__return_ptr))(a1 + 8))(&v4);
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_1D0E0DFC0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F26F48F8;
  a2[1] = v2;
  return result;
}

void *sub_1D0E0DFE4(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1F26F48F8;
  result[1] = v3;
  return result;
}

void sub_1D0E0E02C()
{
}

void sub_1D0E0E044(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  v4[0] = *(void *)(a1 + 16);
  v4[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1D0E3E028(&v5, (uint64_t)v4, *(unsigned char **)(a1 + 8), *(void *)(a1 + 32), *(void *)(a1 + 40), **(void **)(a1 + 48));
  *a2 = v5;
  long long v5 = 0uLL;
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_1D0E0E10C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void sub_1D0E0E188(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

__n128 sub_1D0E0E204(__n128 *a1, __n128 *a2)
{
  unint64_t v2 = a1->n128_u64[1];
  a2->n128_u64[0] = (unint64_t)&unk_1F26F55D8;
  a2->n128_u64[1] = v2;
  unint64_t v3 = a1[1].n128_u64[1];
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  a2[1].n128_u64[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 result = a1[2];
  a2[3].n128_u64[0] = a1[3].n128_u64[0];
  a2[2] = result;
  return result;
}

__n128 sub_1D0E0E250(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)unint64_t v2 = &unk_1F26F55D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)v2 + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 result = *(__n128 *)(a1 + 32);
  *((__n128 *)v2 + 2) = result;
  *((void *)v2 + 6) = *(void *)(a1 + 48);
  return result;
}

void sub_1D0E0E2C4(void *a1)
{
  *a1 = &unk_1F26F55D8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1D25F16B0);
}

void *sub_1D0E0E36C(void *a1)
{
  *a1 = &unk_1F26F55D8;
  unint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_1D0E0E3F8(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 24);
  if (v1)
  {
    uint64_t v2 = v1[8];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    }
    uint64_t v3 = (std::__shared_weak_count *)v1[9];
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    long long v4 = (void *)v1[7];
    if (v4 == v1 + 4)
    {
      (*(void (**)(void *))(v1[4] + 32))(v1 + 4);
      long long v5 = (std::__shared_weak_count *)v1[3];
      if (!v5) {
        goto LABEL_16;
      }
    }
    else
    {
      if (v4) {
        (*(void (**)(void *))(*v4 + 40))(v4);
      }
      long long v5 = (std::__shared_weak_count *)v1[3];
      if (!v5)
      {
LABEL_16:
        JUMPOUT(0x1D25F16B0);
      }
    }
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    goto LABEL_16;
  }
  return result;
}

void sub_1D0E0E574(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F3AF8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E0E5C8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F3AF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0E0E5E8(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  v4[0] = *(void *)(a1 + 16);
  v4[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1D0E3E028(&v5, (uint64_t)v4, *(unsigned char **)(a1 + 8), *(void *)(a1 + 32), *(void *)(a1 + 40), **(void **)(a1 + 48));
  *a2 = v5;
  long long v5 = 0uLL;
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_1D0E0E6B0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void sub_1D0E0E72C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

__n128 sub_1D0E0E7A8(__n128 *a1, __n128 *a2)
{
  unint64_t v2 = a1->n128_u64[1];
  a2->n128_u64[0] = (unint64_t)&unk_1F26F5620;
  a2->n128_u64[1] = v2;
  unint64_t v3 = a1[1].n128_u64[1];
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  a2[1].n128_u64[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 result = a1[2];
  a2[3].n128_u64[0] = a1[3].n128_u64[0];
  a2[2] = result;
  return result;
}

__n128 sub_1D0E0E7F4(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)unint64_t v2 = &unk_1F26F5620;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)v2 + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 result = *(__n128 *)(a1 + 32);
  *((__n128 *)v2 + 2) = result;
  *((void *)v2 + 6) = *(void *)(a1 + 48);
  return result;
}

void sub_1D0E0E868(void *a1)
{
  *a1 = &unk_1F26F5620;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1D25F16B0);
}

void *sub_1D0E0E910(void *a1)
{
  *a1 = &unk_1F26F5620;
  unint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void *sub_1D0E0E998(void *a1, CVPixelBufferRef pixelBuffer)
{
  if (CVPixelBufferIsPlanar(pixelBuffer))
  {
    unsigned int WidthOfPlane = CVPixelBufferGetWidthOfPlane(pixelBuffer, 0);
    unsigned int HeightOfPlane = CVPixelBufferGetHeightOfPlane(pixelBuffer, 0);
    size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
    __n128 result = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0);
  }
  else
  {
    unsigned int WidthOfPlane = CVPixelBufferGetWidth(pixelBuffer);
    unsigned int HeightOfPlane = CVPixelBufferGetHeight(pixelBuffer);
    size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRow(pixelBuffer);
    __n128 result = CVPixelBufferGetBaseAddress(pixelBuffer);
  }
  *a1 = 0;
  a1[1] = WidthOfPlane | ((unint64_t)HeightOfPlane << 32);
  a1[2] = (BytesPerRowOfPlane << 32) | 1;
  a1[3] = result;
  return result;
}

uint64_t sub_1D0E0EA58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, float a6)
{
  uint64_t v248 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a3 + 52;
  *(void *)&long long v234 = a3 + 52;
  *(void *)int buf = &v234;
  uint64_t v13 = buf;
  *(void *)&v227[0] = buf;
  *((void *)&v227[0] + 1) = a3 + 88;
  v237.i64[0] = 0;
  v237.i32[2] = 0;
  sub_1D0E0FBA0(v237.f32, (uint64_t)v227);
  *(void *)&long long v231 = a2 + 60;
  *(void *)int buf = &v231;
  *(void *)&v227[0] = buf;
  *((void *)&v227[0] + 1) = a2 + 96;
  *(void *)&long long v234 = 0;
  DWORD2(v234) = 0;
  sub_1D0E0FBA0((float *)&v234, (uint64_t)v227);
  uint64_t v14 = 0;
  float32x2_t v15 = vsub_f32(*(float32x2_t *)v237.f32, *(float32x2_t *)&v234);
  if ((float)(vaddv_f32(vmul_f32(v15, v15))
             + (float)((float)(v237.f32[2] - *((float *)&v234 + 2)) * (float)(v237.f32[2] - *((float *)&v234 + 2)))) <= 0.00001)
  {
    float v16 = *(float *)(a3 + 60) - *(float *)(a2 + 68);
    float v17 = *(float *)(a3 + 72) - *(float *)(a2 + 80);
    if ((float)((float)((float)(v16 * v16) + (float)(v17 * v17))
               + (float)((float)(*(float *)(a3 + 84) - *(float *)(a2 + 92))
                       * (float)(*(float *)(a3 + 84) - *(float *)(a2 + 92)))) <= 0.00001)
    {
      float32x2_t v18 = *(float32x2_t *)(a3 + 16);
      int32x2_t v19 = *(int32x2_t *)(a3 + 28);
      *(float32x2_t *)&long long v20 = v18;
      *((int32x2_t *)&v20 + 1) = v19;
      v227[0] = v20;
      int32x2_t v22 = *(int32x2_t *)(a3 + 40);
      *(int32x2_t *)&v227[1] = v22;
      float v21 = -*(float *)v19.i32;
      *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(-*(float *)v19.i32, v18, 1), *(float *)&v19.i32[1], v18.f32[0]);
      DWORD2(v227[1]) = v22.i32[0];
      if (fabsf(*(float *)v22.i32) >= 1.0e-15)
      {
        v24.i32[0] = vdup_lane_s32(v19, 1).u32[0];
        v24.f32[1] = -v18.f32[1];
        v24.i64[1] = __PAIR64__(vdup_lane_s32(*(int32x2_t *)&v18, 0).u32[1], LODWORD(v21));
        float32x4_t v237 = vdivq_f32(v24, (float32x4_t)vdupq_lane_s32(v22, 0));
        *(void *)&long long v231 = &v237;
        *(void *)&long long v234 = &v231;
        *((void *)&v234 + 1) = &v227[1];
        *(void *)&long long v244 = 0;
        sub_1D0E0FC64((float *)&v244, (uint64_t)&v234);
        *(float32x4_t *)int buf = v237;
        *(void *)&uint8_t buf[4] = v244;
        float v23 = (float)(v237.f32[0] * v237.f32[3]) - (float)(v237.f32[2] * v237.f32[1]);
      }
      else
      {
        memset(buf, 0, sizeof(buf));
        float v23 = 1.0;
      }
      v246.f32[0] = v23;
      *(void *)&long long v231 = a2 + 60;
      *((void *)&v231 + 1) = 3;
      *(void *)&long long v244 = v12;
      *((void *)&v244 + 1) = 3;
      unsigned int v242 = (float *)&v244;
      long long v25 = &v231;
      *(void *)&long long v234 = &v231;
      *((void *)&v234 + 1) = &v242;
      v227[0] = 0uLL;
      sub_1D0E0FCE4((float *)v227, (uint64_t **)&v234);
      float32x4_t v237 = (float32x4_t)v227[0];
      uint64_t v238 = 0;
      float v239 = (float)(*(float *)v227 * *((float *)v227 + 3)) - (float)(*((float *)v227 + 2) * *((float *)v227 + 1));
      *(void *)&long long v26 = *(void *)(a2 + 24);
      float v27 = vmlas_n_f32(vmuls_lane_f32(-COERCE_FLOAT(*(void *)(a2 + 36)), *(float32x2_t *)&v26, 1), COERCE_FLOAT(HIDWORD(*(void *)(a2 + 36))), *(float *)&v26);
      *((void *)&v26 + 1) = *(void *)(a2 + 36);
      long long v234 = v26;
      float32x2_t v235 = *(float32x2_t *)(a2 + 48);
      float32x2_t v28 = v235;
      float v236 = v27;
      unsigned int v242 = (float *)&v234;
      float v243 = &v237;
      long long v244 = 0uLL;
      sub_1D0E0FE28((uint64_t)&v244, &v242);
      float v240 = (float *)&v234;
      float v241 = &v238;
      long long v29 = (char *)v227 + 4;
      *(void *)((char *)v227 + 4) = 0;
      sub_1D0DD6E58((float *)v227 + 1, &v240);
      long long v231 = v244;
      float32x2_t v30 = vadd_f32(*(float32x2_t *)((char *)v227 + 4), v28);
      float32x2_t v232 = v30;
      float v233 = (float)(*(float *)&v244 * *((float *)&v244 + 3)) - (float)(*((float *)&v244 + 2) * *((float *)&v244 + 1));
      unsigned int v242 = (float *)&v231;
      float v243 = (float32x4_t *)buf;
      long long v244 = 0uLL;
      sub_1D0E0FE28((uint64_t)&v244, &v242);
      float v240 = (float *)&v231;
      float v241 = (uint64_t *)&buf[4];
      *(void *)((char *)v227 + 4) = 0;
      sub_1D0DD6E58((float *)v227 + 1, &v240);
      uint64_t v31 = 0;
      long long v228 = v244;
      float32x2_t v32 = vadd_f32(*(float32x2_t *)((char *)v227 + 4), v30);
      float32x2_t v229 = v32;
      float v230 = (float)(*(float *)&v244 * *((float *)&v244 + 3)) - (float)(*((float *)&v244 + 2) * *((float *)&v244 + 1));
      *(void *)&buf[3] = 0x3F80000000000000;
      *(void *)&buf[1] = 0;
      buf[0] = 1065353216;
      buf[5] = 0;
      int v247 = 1065353216;
      unint64_t v33 = 0x100000000;
      uint64_t v34 = (int *)&v228;
      do
      {
        int v35 = *v34++;
        buf[v31] = v35;
        unint64_t v36 = HIDWORD(v33);
        BOOL v37 = (int)v33 < 1;
        if ((int)v33 < 1) {
          unint64_t v36 = 0;
        }
        uint64_t v38 = v31 + v36;
        uint64_t v39 = (v33 + 1);
        unint64_t v40 = v33 & 0xFFFFFFFF00000000;
        if (!v37) {
          uint64_t v39 = 0;
        }
        unint64_t v33 = v39 | v40;
        uint64_t v31 = v38 + 1;
      }
      while (v31 != 6);
      float32x2_t v246 = v32;
      v237.i64[0] = (uint64_t)buf;
      v237.i64[1] = a4;
      memset(v227, 0, 36);
      sub_1D0DF1BF0((uint64_t)v227, (float **)&v237);
      uint64_t v41 = *(unsigned int *)(a1 + 48);
      if (v41 > *(_DWORD *)(a5 + 8) || v41 > *(_DWORD *)(a5 + 12))
      {
        unint64_t v42 = *(void **)(a5 + 24);
        if (v42)
        {
          free(v42);
          *(void *)(a5 + 24) = 0;
        }
        *(void *)a5 = 0;
        *(void *)(a5 + 8) = v41 | (v41 << 32);
        *(void *)(a5 + 16) = ((unint64_t)(((4 * v41 + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
        *(void *)int buf = v41 * (unint64_t)((4 * v41 + 15) & 0xFFFFFFF0);
        if (*(void *)buf) {
          long long v43 = malloc_type_malloc(*(size_t *)buf, 0xA153FF5uLL);
        }
        else {
          long long v43 = 0;
        }
        *(void *)(a5 + 24) = v43;
      }
      else
      {
        *(void *)a5 = 0;
        *(void *)(a5 + 8) = v41 | (v41 << 32);
      }
      kdebug_trace();
      uint64_t v44 = *(__CVBuffer **)a2;
      signed int PixelFormatType = (_WORD *)CVPixelBufferGetPixelFormatType(*(CVPixelBufferRef *)a2);
      uint64_t v46 = PixelFormatType;
      if (PixelFormatType == 825306677
        || PixelFormatType == 1647392359
        || PixelFormatType == 825437747)
      {
        int v47 = *(_DWORD *)(a2 + 124);
        if (v47 == 1)
        {
          float v225 = *(float *)(a2 + 112);
          CVPixelBufferLockBaseAddress(v44, 1uLL);
          int Width = CVPixelBufferGetWidth(v44);
          int Height = CVPixelBufferGetHeight(v44);
          unsigned int BytesPerRow = CVPixelBufferGetBytesPerRow(v44);
          BaseAddress = CVPixelBufferGetBaseAddress(v44);
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EB9F1618))
          {
            sub_1D0E225B4();
          }
          *(float *)v95.i32 = a6 / v225;
          float32x4_t v98 = (float32x4_t)vdupq_lane_s32(v95, 0);
          unsigned int v99 = Width - 1;
          if (*(unsigned char *)(qword_1EB9F15F8 + 109))
          {
            int v100 = *(_DWORD *)(a5 + 12);
            if (v100 >= 1)
            {
              int v101 = *(_DWORD *)(a5 + 8);
              if (v101 >= 1)
              {
                int v102 = 0;
                *(float *)v96.i32 = (float)v99;
                float32x4_t v103 = (float32x4_t)vdupq_lane_s32(v96, 0);
                *(float *)v97.i32 = (float)(Height - 1);
                float32x4_t v104 = (float32x4_t)vdupq_lane_s32(v97, 0);
                float32x4_t v105 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)v227 + 12), 0);
                float32x4_t v106 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v227[1], 0);
                float32x4_t v107 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)&v227[1] + 4), 0);
                __asm { FMOV            V23.4S, #4.0 }
                float32x4_t v109 = vmulq_n_f32(_Q23, *(float *)v227);
                float32x4_t v110 = vmulq_n_f32(_Q23, *((float *)v227 + 1));
                int32x4_t v111 = vdupq_n_s32(BytesPerRow >> 1);
                float32x4_t v112 = vmulq_n_f32(_Q23, *((float *)v227 + 2));
                float32x4_t v113 = vmlaq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshrq_n_u64(*(uint64x2_t *)((char *)&v227[1] + 4), 0x20uLL), 0), (float32x4_t)xmmword_1D0E81540, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v227[0], 0));
                uint64_t v114 = *(float32x4_t **)(a5 + 24);
                float32x4_t v115 = vmlaq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)((char *)&v227[1] + 4), 2), (float32x4_t)xmmword_1D0E81540, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)v227 + 4), 0));
                float32x4_t v116 = vmlaq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)((char *)&v227[1] + 4), 3), (float32x4_t)xmmword_1D0E81540, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)v227 + 8), 0));
                do
                {
                  int v117 = 0;
                  float32x4_t v118 = v116;
                  float32x4_t v119 = v115;
                  float32x4_t v120 = v113;
                  do
                  {
                    int32x4_t v121 = vmlaq_s32(vcvtaq_s32_f32(vmaxnmq_f32(vminnmq_f32(vdivq_f32(v120, v118), v103), (float32x4_t)0)), vcvtaq_s32_f32(vmaxnmq_f32(vminnmq_f32(vdivq_f32(v119, v118), v104), (float32x4_t)0)), v111);
                    v121.i16[0] = BaseAddress[v121.i32[0]];
                    v121.i16[1] = BaseAddress[v121.i32[1]];
                    v121.i16[2] = BaseAddress[v121.i32[2]];
                    v121.i16[3] = BaseAddress[v121.i32[3]];
                    float32x4_t v122 = vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v121.i8));
                    *v114++ = vdivq_f32(vmulq_n_f32((float32x4_t)vandq_s8((int8x16_t)v122, (int8x16_t)vcgeq_f32(v98, v122)), v225), v118);
                    float32x4_t v120 = vaddq_f32(v109, v120);
                    float32x4_t v119 = vaddq_f32(v110, v119);
                    float32x4_t v118 = vaddq_f32(v112, v118);
                    v117 += 4;
                  }
                  while (v117 < v101);
                  float32x4_t v113 = vaddq_f32(v105, v113);
                  float32x4_t v115 = vaddq_f32(v106, v115);
                  float32x4_t v116 = vaddq_f32(v107, v116);
                  ++v102;
                }
                while (v102 != v100);
              }
            }
          }
          else
          {
            int v126 = *(_DWORD *)(a5 + 12);
            if (v126 >= 1)
            {
              uint64_t v127 = *(unsigned int *)(a5 + 8);
              if (v127)
              {
                int v128 = 0;
                int32x4_t v129 = vdupq_n_s32(v99);
                int32x4_t v130 = vdupq_n_s32(Height - 1);
                unsigned int v131 = (int)(float)((float)(*((float *)v227 + 1) * 262140.0) + 0.5);
                unsigned int v132 = (int)(float)((float)(*(float *)v227 * 262140.0) + 0.5);
                int32x4_t v133 = vdupq_n_s32(BytesPerRow >> 1);
                int32x4_t v134 = vdupq_n_s32(4 * v132);
                int32x4_t v135 = vdupq_n_s32(4 * v131);
                int32x4_t v136 = vdupq_n_s32((int)(float)((float)(*((float *)v227 + 3) * 262140.0) + 0.5) - v127
                                                                                                * v132);
                int32x4_t v137 = vmlaq_s32(vdupq_n_s32((int)(float)((float)(*((float *)&v227[1] + 2) * 262140.0) + 0.5)), vdupq_n_s32(v132), (int32x4_t)xmmword_1D0E814F0);
                int32x4_t v138 = vdupq_n_s32((int)(float)((float)(*(float *)&v227[1] * 262140.0) + 0.5) - v127
                                                                                              * v131);
                uint64_t v139 = ((unint64_t)*(unsigned int *)(a5 + 20) >> 2) - v127;
                int32x4_t v140 = vmlaq_s32(vdupq_n_s32((int)(float)((float)(*((float *)&v227[1] + 3) * 262140.0) + 0.5)), vdupq_n_s32(v131), (int32x4_t)xmmword_1D0E814F0);
                float32x4_t v141 = *(float32x4_t **)(a5 + 24);
                v142.i64[0] = 0x2000000020000;
                v142.i64[1] = 0x2000000020000;
                do
                {
                  float v143 = (float32x4_t *)((char *)v141 + 4 * v127);
                  do
                  {
                    int32x4_t v144 = vmlaq_s32(vmaxq_s32(vminq_s32(vshrq_n_s32(vaddq_s32(v137, v142), 0x12uLL), v129), (int32x4_t)0), vmaxq_s32(vminq_s32(vshrq_n_s32(vaddq_s32(v140, v142), 0x12uLL), v130), (int32x4_t)0), v133);
                    v144.i16[0] = BaseAddress[v144.i32[0]];
                    v144.i16[1] = BaseAddress[v144.i32[1]];
                    v144.i16[2] = BaseAddress[v144.i32[2]];
                    v144.i16[3] = BaseAddress[v144.i32[3]];
                    float32x4_t v145 = vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v144.i8));
                    *v141++ = vmulq_n_f32((float32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgeq_f32(v98, v145)), v225);
                    int32x4_t v137 = vaddq_s32(v137, v134);
                    int32x4_t v140 = vaddq_s32(v140, v135);
                  }
                  while (v141 < v143);
                  float32x4_t v141 = (float32x4_t *)((char *)v141 + 4 * v139);
                  int32x4_t v137 = vaddq_s32(v137, v136);
                  int32x4_t v140 = vaddq_s32(v140, v138);
                  ++v128;
                }
                while (v128 != v126);
              }
            }
          }
          goto LABEL_91;
        }
        if (v47 == 2)
        {
          CVPixelBufferLockBaseAddress(v44, 1uLL);
          LODWORD(v25) = CVPixelBufferGetWidth(v44);
          LODWORD(v13) = CVPixelBufferGetHeight(v44);
          LODWORD(v29) = CVPixelBufferGetBytesPerRow(v44);
          uint64_t v46 = CVPixelBufferGetBaseAddress(v44);
          *(float *)v48.i32 = *(float *)(a2 + 112) * 0.001;
          *(float *)v49.i32 = *(float *)(a2 + 116) * 0.001;
          int32x2_t v223 = v49;
          int32x2_t v224 = v48;
          float v50 = (float)((float)(1.0 / a6) - *(float *)v49.i32) / *(float *)v48.i32;
          *(float *)v51.i32 = nextafterf((float)*(int *)(a2 + 120), 0.0);
          if (v50 >= *(float *)v51.i32) {
            float v54 = *(float *)v51.i32;
          }
          else {
            float v54 = v50;
          }
          v55.i32[1] = v224.i32[1];
          if (*(float *)v224.i32 <= 0.0) {
            *(float *)v55.i32 = 0.0;
          }
          else {
            *(float *)v55.i32 = v50;
          }
          if (*(float *)v224.i32 <= 0.0) {
            *(float *)v51.i32 = v54;
          }
          int32x2_t v221 = v51;
          int32x2_t v222 = v55;
          if (atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire)) {
            goto LABEL_36;
          }
          goto LABEL_97;
        }
LABEL_96:
        sub_1D0E221E0();
LABEL_97:
        if (__cxa_guard_acquire(&qword_1EB9F1618)) {
          sub_1D0E225B4();
        }
LABEL_36:
        float32x4_t v56 = (float32x4_t)vdupq_lane_s32(v224, 0);
        float32x4_t v57 = (float32x4_t)vdupq_lane_s32(v223, 0);
        float32x4_t v58 = (float32x4_t)vdupq_lane_s32(v221, 0);
        float32x4_t v59 = (float32x4_t)vdupq_lane_s32(v222, 0);
        if (*(unsigned char *)(qword_1EB9F15F8 + 109))
        {
          int v60 = *(_DWORD *)(a5 + 12);
          if (v60 >= 1)
          {
            int v61 = *(_DWORD *)(a5 + 8);
            if (v61 >= 1)
            {
              int v62 = 0;
              *(float *)v52.i32 = (float)(v25 - 1);
              float32x4_t v63 = (float32x4_t)vdupq_lane_s32(v52, 0);
              *(float *)v53.i32 = (float)(v13 - 1);
              float32x4_t v64 = (float32x4_t)vdupq_lane_s32(v53, 0);
              float32x4_t v65 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)v227 + 12), 0);
              float32x4_t v66 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v227[1], 0);
              float32x4_t v67 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)&v227[1] + 4), 0);
              __asm { FMOV            V26.4S, #4.0 }
              float32x4_t v73 = vmulq_n_f32(_Q26, *(float *)v227);
              float32x4_t v74 = vmulq_n_f32(_Q26, *((float *)v227 + 1));
              int32x4_t v75 = vdupq_n_s32(v29 >> 1);
              float32x4_t v76 = vmulq_n_f32(_Q26, *((float *)v227 + 2));
              float32x4_t v77 = vmlaq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshrq_n_u64(*(uint64x2_t *)((char *)&v227[1] + 4), 0x20uLL), 0), (float32x4_t)xmmword_1D0E81540, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v227[0], 0));
              unint64_t v78 = *(float32x4_t **)(a5 + 24);
              float32x4_t v79 = vmlaq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)((char *)&v227[1] + 4), 2), (float32x4_t)xmmword_1D0E81540, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)v227 + 4), 0));
              float32x4_t v80 = vmlaq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)((char *)&v227[1] + 4), 3), (float32x4_t)xmmword_1D0E81540, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)v227 + 8), 0));
              do
              {
                int v81 = 0;
                float32x4_t v82 = v80;
                float32x4_t v83 = v79;
                float32x4_t v84 = v77;
                do
                {
                  int32x4_t v85 = vmlaq_s32(vcvtaq_s32_f32(vmaxnmq_f32(vminnmq_f32(vdivq_f32(v84, v82), v63), (float32x4_t)0)), vcvtaq_s32_f32(vmaxnmq_f32(vminnmq_f32(vdivq_f32(v83, v82), v64), (float32x4_t)0)), v75);
                  v85.i16[0] = v46[v85.i32[0]];
                  v85.i16[1] = v46[v85.i32[1]];
                  v85.i16[2] = v46[v85.i32[2]];
                  v85.i16[3] = v46[v85.i32[3]];
                  float32x4_t v86 = vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v85.i8));
                  int8x16_t v87 = vandq_s8((int8x16_t)vcgeq_f32(v58, v86), (int8x16_t)vcgeq_f32(v86, v59));
                  float32x4_t v88 = vmlaq_f32(v57, v56, v86);
                  float32x4_t v89 = vrecpeq_f32(v88);
                  float32x4_t v90 = vmulq_f32(v89, vrecpsq_f32(v88, v89));
                  *v78++ = vdivq_f32((float32x4_t)vandq_s8((int8x16_t)vmulq_f32(v90, vrecpsq_f32(v88, v90)), v87), v82);
                  float32x4_t v84 = vaddq_f32(v73, v84);
                  float32x4_t v83 = vaddq_f32(v74, v83);
                  float32x4_t v82 = vaddq_f32(v76, v82);
                  v81 += 4;
                }
                while (v81 < v61);
                float32x4_t v77 = vaddq_f32(v65, v77);
                float32x4_t v79 = vaddq_f32(v66, v79);
                float32x4_t v80 = vaddq_f32(v67, v80);
                ++v62;
              }
              while (v62 != v60);
            }
          }
        }
        else
        {
          int v146 = *(_DWORD *)(a5 + 12);
          if (v146 >= 1)
          {
            uint64_t v147 = *(unsigned int *)(a5 + 8);
            if (v147)
            {
              int v148 = 0;
              int32x4_t v149 = vdupq_n_s32((int)v25 - 1);
              int32x4_t v150 = vdupq_n_s32((int)v13 - 1);
              unsigned int v151 = (int)(float)((float)(*((float *)v227 + 1) * 262140.0) + 0.5);
              unsigned int v152 = (int)(float)((float)(*(float *)v227 * 262140.0) + 0.5);
              int32x4_t v153 = vdupq_n_s32(v29 >> 1);
              int32x4_t v154 = vdupq_n_s32(4 * v152);
              int32x4_t v155 = vdupq_n_s32(4 * v151);
              int32x4_t v156 = vdupq_n_s32((int)(float)((float)(*((float *)v227 + 3) * 262140.0) + 0.5) - v147
                                                                                              * v152);
              int32x4_t v157 = vmlaq_s32(vdupq_n_s32((int)(float)((float)(*((float *)&v227[1] + 2) * 262140.0) + 0.5)), vdupq_n_s32(v152), (int32x4_t)xmmword_1D0E814F0);
              int32x4_t v158 = vdupq_n_s32((int)(float)((float)(*(float *)&v227[1] * 262140.0) + 0.5) - v147 * v151);
              uint64_t v159 = ((unint64_t)*(unsigned int *)(a5 + 20) >> 2) - v147;
              int32x4_t v160 = vmlaq_s32(vdupq_n_s32((int)(float)((float)(*((float *)&v227[1] + 3) * 262140.0) + 0.5)), vdupq_n_s32(v151), (int32x4_t)xmmword_1D0E814F0);
              int32x4_t v161 = *(int8x16_t **)(a5 + 24);
              v162.i64[0] = 0x2000000020000;
              v162.i64[1] = 0x2000000020000;
              do
              {
                uint64_t v163 = (int8x16_t *)((char *)v161 + 4 * v147);
                do
                {
                  int32x4_t v164 = vmlaq_s32(vmaxq_s32(vminq_s32(vshrq_n_s32(vaddq_s32(v157, v162), 0x12uLL), v149), (int32x4_t)0), vmaxq_s32(vminq_s32(vshrq_n_s32(vaddq_s32(v160, v162), 0x12uLL), v150), (int32x4_t)0), v153);
                  v164.i16[0] = v46[v164.i32[0]];
                  v164.i16[1] = v46[v164.i32[1]];
                  v164.i16[2] = v46[v164.i32[2]];
                  v164.i16[3] = v46[v164.i32[3]];
                  float32x4_t v165 = vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v164.i8));
                  int8x16_t v166 = vandq_s8((int8x16_t)vcgeq_f32(v58, v165), (int8x16_t)vcgeq_f32(v165, v59));
                  float32x4_t v167 = vmlaq_f32(v57, v56, v165);
                  float32x4_t v168 = vrecpeq_f32(v167);
                  float32x4_t v169 = vmulq_f32(v168, vrecpsq_f32(v167, v168));
                  *v161++ = vandq_s8((int8x16_t)vmulq_f32(v169, vrecpsq_f32(v167, v169)), v166);
                  int32x4_t v157 = vaddq_s32(v157, v154);
                  int32x4_t v160 = vaddq_s32(v160, v155);
                }
                while (v161 < v163);
                int32x4_t v161 = (int8x16_t *)((char *)v161 + 4 * v159);
                int32x4_t v157 = vaddq_s32(v157, v156);
                int32x4_t v160 = vaddq_s32(v160, v158);
                ++v148;
              }
              while (v148 != v146);
            }
          }
        }
LABEL_91:
        uint64_t v14 = 1;
        CVPixelBufferUnlockBaseAddress(v44, 1uLL);
        goto LABEL_92;
      }
      int v123 = *(_DWORD *)(a2 + 124);
      if (v123 == 1)
      {
        float v226 = *(float *)(a2 + 112);
        if (PixelFormatType == 1717855600 || PixelFormatType == 1278226534)
        {
          CVPixelBufferLockBaseAddress(v44, 1uLL);
          int v170 = CVPixelBufferGetWidth(v44);
          int v171 = CVPixelBufferGetHeight(v44);
          unsigned int v172 = CVPixelBufferGetBytesPerRow(v44);
          uint64_t v173 = CVPixelBufferGetBaseAddress(v44);
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EB9F1618))
          {
            sub_1D0E225B4();
          }
          *(float *)v174.i32 = a6 / v226;
          float32x4_t v177 = (float32x4_t)vdupq_lane_s32(v174, 0);
          unsigned int v178 = v170 - 1;
          if (*(unsigned char *)(qword_1EB9F15F8 + 109))
          {
            int v179 = *(_DWORD *)(a5 + 12);
            if (v179 >= 1)
            {
              int v180 = *(_DWORD *)(a5 + 8);
              if (v180 >= 1)
              {
                int v181 = 0;
                *(float *)v175.i32 = (float)v178;
                float32x4_t v182 = (float32x4_t)vdupq_lane_s32(v175, 0);
                *(float *)v176.i32 = (float)(v171 - 1);
                float32x4_t v183 = (float32x4_t)vdupq_lane_s32(v176, 0);
                float32x4_t v184 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)v227 + 12), 0);
                float32x4_t v185 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v227[1], 0);
                float32x4_t v186 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)&v227[1] + 4), 0);
                __asm { FMOV            V23.4S, #4.0 }
                float32x4_t v188 = vmulq_n_f32(_Q23, *(float *)v227);
                float32x4_t v189 = vmulq_n_f32(_Q23, *((float *)v227 + 1));
                int32x4_t v190 = vdupq_n_s32(v172 >> 2);
                float32x4_t v191 = vmulq_n_f32(_Q23, *((float *)v227 + 2));
                float32x4_t v192 = vmlaq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshrq_n_u64(*(uint64x2_t *)((char *)&v227[1] + 4), 0x20uLL), 0), (float32x4_t)xmmword_1D0E81540, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v227[0], 0));
                float v193 = *(float32x4_t **)(a5 + 24);
                float32x4_t v194 = vmlaq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)((char *)&v227[1] + 4), 2), (float32x4_t)xmmword_1D0E81540, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)v227 + 4), 0));
                float32x4_t v195 = vmlaq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)((char *)&v227[1] + 4), 3), (float32x4_t)xmmword_1D0E81540, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)v227 + 8), 0));
                do
                {
                  int v196 = 0;
                  float32x4_t v197 = v195;
                  float32x4_t v198 = v194;
                  float32x4_t v199 = v192;
                  do
                  {
                    float32x4_t v200 = (float32x4_t)vmlaq_s32(vcvtaq_s32_f32(vmaxnmq_f32(vminnmq_f32(vdivq_f32(v199, v197), v182), (float32x4_t)0)), vcvtaq_s32_f32(vmaxnmq_f32(vminnmq_f32(vdivq_f32(v198, v197), v183), (float32x4_t)0)), v190);
                    v200.i32[0] = v173[v200.i32[0]];
                    v200.i32[1] = v173[v200.i32[1]];
                    v200.i32[2] = v173[v200.i32[2]];
                    v200.i32[3] = v173[v200.i32[3]];
                    *v193++ = vdivq_f32(vmulq_n_f32((float32x4_t)vandq_s8((int8x16_t)v200, (int8x16_t)vcgeq_f32(v177, v200)), v226), v197);
                    float32x4_t v199 = vaddq_f32(v188, v199);
                    float32x4_t v198 = vaddq_f32(v189, v198);
                    float32x4_t v197 = vaddq_f32(v191, v197);
                    v196 += 4;
                  }
                  while (v196 < v180);
                  float32x4_t v192 = vaddq_f32(v184, v192);
                  float32x4_t v194 = vaddq_f32(v185, v194);
                  float32x4_t v195 = vaddq_f32(v186, v195);
                  ++v181;
                }
                while (v181 != v179);
              }
            }
          }
          else
          {
            int v201 = *(_DWORD *)(a5 + 12);
            if (v201 >= 1)
            {
              uint64_t v202 = *(unsigned int *)(a5 + 8);
              if (v202)
              {
                int v203 = 0;
                int32x4_t v204 = vdupq_n_s32(v178);
                int32x4_t v205 = vdupq_n_s32(v171 - 1);
                unsigned int v206 = (int)(float)((float)(*((float *)v227 + 1) * 262140.0) + 0.5);
                unsigned int v207 = (int)(float)((float)(*(float *)v227 * 262140.0) + 0.5);
                int32x4_t v208 = vdupq_n_s32(v172 >> 2);
                int32x4_t v209 = vdupq_n_s32(4 * v207);
                int32x4_t v210 = vdupq_n_s32(4 * v206);
                int32x4_t v211 = vdupq_n_s32((int)(float)((float)(*((float *)v227 + 3) * 262140.0) + 0.5) - v202
                                                                                                * v207);
                int32x4_t v212 = vmlaq_s32(vdupq_n_s32((int)(float)((float)(*((float *)&v227[1] + 2) * 262140.0) + 0.5)), vdupq_n_s32(v207), (int32x4_t)xmmword_1D0E814F0);
                int32x4_t v213 = vdupq_n_s32((int)(float)((float)(*(float *)&v227[1] * 262140.0) + 0.5) - v202
                                                                                              * v206);
                uint64_t v214 = ((unint64_t)*(unsigned int *)(a5 + 20) >> 2) - v202;
                int32x4_t v215 = vmlaq_s32(vdupq_n_s32((int)(float)((float)(*((float *)&v227[1] + 3) * 262140.0) + 0.5)), vdupq_n_s32(v206), (int32x4_t)xmmword_1D0E814F0);
                __int32 v216 = *(float32x4_t **)(a5 + 24);
                v217.i64[0] = 0x2000000020000;
                v217.i64[1] = 0x2000000020000;
                do
                {
                  uint64_t v218 = (float32x4_t *)((char *)v216 + 4 * v202);
                  do
                  {
                    float32x4_t v219 = (float32x4_t)vmlaq_s32(vmaxq_s32(vminq_s32(vshrq_n_s32(vaddq_s32(v212, v217), 0x12uLL), v204), (int32x4_t)0), vmaxq_s32(vminq_s32(vshrq_n_s32(vaddq_s32(v215, v217), 0x12uLL), v205), (int32x4_t)0), v208);
                    v219.i32[0] = v173[v219.i32[0]];
                    v219.i32[1] = v173[v219.i32[1]];
                    v219.i32[2] = v173[v219.i32[2]];
                    v219.i32[3] = v173[v219.i32[3]];
                    *v216++ = vmulq_n_f32((float32x4_t)vandq_s8((int8x16_t)v219, (int8x16_t)vcgeq_f32(v177, v219)), v226);
                    int32x4_t v212 = vaddq_s32(v212, v209);
                    int32x4_t v215 = vaddq_s32(v215, v210);
                  }
                  while (v216 < v218);
                  __int32 v216 = (float32x4_t *)((char *)v216 + 4 * v214);
                  int32x4_t v212 = vaddq_s32(v212, v211);
                  int32x4_t v215 = vaddq_s32(v215, v213);
                  ++v203;
                }
                while (v203 != v201);
              }
            }
          }
          goto LABEL_91;
        }
        float v124 = sub_1D0E53388();
        if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR))
        {
          buf[0] = 67109120;
          buf[1] = v46;
          float v125 = "unknown depth buffer format (%u)";
          goto LABEL_95;
        }
      }
      else
      {
        if (v123 != 2) {
          goto LABEL_96;
        }
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1610))
        {
          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
          __cxa_guard_release(&qword_1EB9F1610);
        }
        float v124 = (id)qword_1EB9F1620;
        if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR))
        {
          buf[0] = 67109120;
          buf[1] = v46;
          float v125 = "unknown depth buffer format (%u) for normalized disparity";
LABEL_95:
          _os_log_error_impl(&dword_1D0DBD000, v124, OS_LOG_TYPE_ERROR, v125, (uint8_t *)buf, 8u);
        }
      }

      uint64_t v14 = 0;
LABEL_92:
      kdebug_trace();
      return v14;
    }
    return 0;
  }
  return v14;
}

void sub_1D0E0FB58(_Unwind_Exception *a1)
{
}

float *sub_1D0E0FBA0(float *result, uint64_t a2)
{
  unint64_t v2 = result;
  uint64_t v3 = *(float **)(a2 + 8);
  if (v3 == result)
  {
    int v12 = 0;
    uint64_t v11 = 0;
    __n128 result = (float *)sub_1D0E0FBA0(&v11);
    *(void *)unint64_t v2 = v11;
    *((_DWORD *)v2 + 2) = v12;
  }
  else
  {
    long long v4 = ***(float ****)a2;
    float v5 = v4[6];
    float v6 = v4[7];
    float v7 = v4[3];
    float v8 = v4[4];
    float v9 = v4[5];
    float v10 = v4[8];
    *__n128 result = (float)((float)(0.0 - (float)(*v4 * *v3)) - (float)(v4[1] * v3[1])) - (float)(v4[2] * v3[2]);
    result[1] = (float)((float)(0.0 - (float)(v7 * *v3)) - (float)(v8 * v3[1])) - (float)(v9 * v3[2]);
    result[2] = (float)((float)(0.0 - (float)(v5 * *v3)) - (float)(v6 * v3[1])) - (float)(v10 * v3[2]);
  }
  return result;
}

float *sub_1D0E0FC64(float *result, uint64_t a2)
{
  unint64_t v2 = result;
  uint64_t v3 = *(float **)(a2 + 8);
  if (v3 == result)
  {
    uint64_t v7 = 0;
    __n128 result = (float *)sub_1D0E0FC64(&v7);
    *(void *)unint64_t v2 = v7;
  }
  else
  {
    long long v4 = **(float ***)a2;
    float v5 = v4[1];
    float v6 = v4[3];
    *__n128 result = (float)(0.0 - (float)(*v4 * *v3)) - (float)(v4[2] * v3[1]);
    result[1] = (float)(0.0 - (float)(v5 * *v3)) - (float)(v6 * v3[1]);
  }
  return result;
}

float *sub_1D0E0FCE4(float *result, uint64_t **a2)
{
  unint64_t v2 = result;
  uint64_t v3 = **a2;
  if ((float *)(v3 - 4 * *((unsigned int *)*a2 + 3)) == result)
  {
    long long v24 = 0uLL;
    __n128 result = (float *)sub_1D0E0FCE4(&v24);
    *(_OWORD *)unint64_t v2 = v24;
  }
  else
  {
    uint64_t v4 = *((unsigned int *)*a2 + 2);
    if (v4)
    {
      uint64_t v5 = 0;
      uint64_t v6 = *a2[1];
      uint64_t v7 = *(unsigned int *)(v6 + 8);
      float v8 = *(float **)v6;
      uint64_t v9 = 4 * (3 * v4);
      uint64_t v10 = 4 * v4;
      uint64_t v11 = 4 * v7;
      float v12 = 0.0;
      uint64_t v13 = v8;
      do
      {
        float v12 = v12 + (float)(*(float *)(v3 + v5) * *v13);
        v5 += v10;
        uint64_t v13 = (float *)((char *)v13 + v11);
      }
      while (v9 != v5);
      uint64_t v14 = 0;
      *__n128 result = v12;
      uint64_t v15 = v3 + 4;
      float v16 = 0.0;
      float v17 = v8;
      do
      {
        float v16 = v16 + (float)(*(float *)(v15 + v14) * *v17);
        v14 += v10;
        float v17 = (float *)((char *)v17 + v11);
      }
      while (v9 != v14);
      uint64_t v18 = 0;
      result[1] = v16;
      int32x2_t v19 = v8 + 1;
      float v20 = 0.0;
      float v21 = v19;
      do
      {
        float v20 = v20 + (float)(*(float *)(v3 + v18) * *v21);
        v18 += v10;
        float v21 = (float *)((char *)v21 + v11);
      }
      while (v9 != v18);
      uint64_t v22 = 0;
      result[2] = v20;
      float v23 = 0.0;
      do
      {
        float v23 = v23 + (float)(*(float *)(v15 + v22) * *v19);
        v22 += v10;
        int32x2_t v19 = (float *)((char *)v19 + v11);
      }
      while (v9 != v22);
    }
    else
    {
      *(void *)__n128 result = 0;
      float v23 = 0.0;
      result[2] = 0.0;
    }
    result[3] = v23;
  }
  return result;
}

double sub_1D0E0FE28(uint64_t a1, float **a2)
{
  uint64_t v3 = *a2;
  if (*a2 == (float *)a1 || (uint64_t v4 = a2[1], v4 == (float *)a1))
  {
    long long v6 = 0uLL;
    sub_1D0E0FE28(&v6);
    double result = *(double *)&v6;
    *(_OWORD *)a1 = v6;
  }
  else
  {
    *(float *)a1 = (float)((float)(*v3 * *v4) + 0.0) + (float)(v3[2] * v4[1]);
    *(float *)(a1 + 4) = (float)((float)(v3[1] * *v4) + 0.0) + (float)(v3[3] * v4[1]);
    *(float *)(a1 + 8) = (float)((float)(*v3 * v4[2]) + 0.0) + (float)(v3[2] * v4[3]);
    *(float *)&double result = (float)((float)(v3[1] * v4[2]) + 0.0) + (float)(v3[3] * v4[3]);
    *(_DWORD *)(a1 + 12) = LODWORD(result);
  }
  return result;
}

void sub_1D0E0FEE4(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v2026 = *MEMORY[0x1E4F143B8];
  if (!*a3)
  {
    sub_1D0E1EB5C();
  }
  kdebug_trace();
  std::mutex::lock(&stru_1EB9F15B8);
  v1870 = a3;
  CVPixelBufferRef texture = *(__CVBuffer **)(*a3 + 88);
  uint64_t v1867 = *(void *)(*a3 + 200);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0) {
    goto LABEL_2235;
  }
  while (1)
  {
    if (*(unsigned char *)(qword_1EB9F15F8 + 316)) {
      BOOL v4 = 1;
    }
    else {
      BOOL v4 = *(unsigned char *)(*v1870 + 385) != 0;
    }
    BOOL v1858 = v4;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1618))
    {
      sub_1D0E225B4();
    }
    if (*(unsigned char *)(qword_1EB9F15F8 + 316))
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
      uint64_t v5 = (id)qword_1EB9F1620;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1D0DBD000, v5, OS_LOG_TYPE_DEFAULT, "Force enabling return of debug information.", buf, 2u);
      }
    }
    long long v6 = (void *)*v1870;
    uint64_t v7 = *(void *)(*v1870 + 88);
    if (v7)
    {
      uint64_t v8 = *a2;
      if (*(void *)(*a2 + 144))
      {
        kdebug_trace();
        v1981 = 0;
        v1980 = 0;
        v1982 = 0;
        (*(void (**)(void, uint64_t, void **))(**(void **)(v8 + 144) + 16))(*(void *)(v8 + 144), v7, &v1980);
        uint64_t v9 = (char *)v1980;
        uint64_t v10 = v1981;
        while (v9 != v10)
        {
          if (v9[32]) {
            v9[32] = 0;
          }
          v9 += 48;
        }
        kdebug_trace();
      }
      else
      {
        int Width = CVPixelBufferGetWidth(*(CVPixelBufferRef *)(*v1870 + 88));
        uint64_t v38 = (__CVBuffer *)v6[11];
        if (v38) {
          int Height = CVPixelBufferGetHeight(v38);
        }
        else {
          int Height = 0;
        }
        uint64_t v41 = v6[41];
        uint64_t v40 = v6[42];
        v1982 = 0;
        v1980 = 0;
        v1981 = 0;
        uint64_t v42 = v40 - v41;
        if (v42)
        {
          if (v42 < 0) {
            abort();
          }
          size_t v43 = 12 * (v42 >> 5);
          uint64_t v44 = operator new(v43 * 4);
          long long v45 = (char *)&v44[v43];
          v1980 = v44;
          v1982 = &v44[v43];
          uint64_t v46 = v44 + 10;
          do
          {
            *((unsigned char *)v46 - 16) = 0;
            *((unsigned char *)v46 - 12) = 0;
            *((unsigned char *)v46 - 8) = 0;
            *uint64_t v46 = 0;
            *(v46 - 5) = 0;
            *(v46 - 4) = 0;
            *(void *)((char *)v46 - 27) = 0;
            v46 += 6;
            v43 -= 12;
          }
          while (v43 * 4);
          v1981 = v45;
          int v47 = (uint64_t *)v6[41];
          int32x2_t v48 = (uint64_t *)v6[42];
          if (v47 != v48)
          {
            float v49 = (float)Width;
            float v50 = (float)Height;
            do
            {
              int v51 = *((_DWORD *)v47 + 2);
              float v52 = *((float *)v47 + 5) * v49;
              float v53 = *((float *)v47 + 6) * v50;
              float v54 = (float)(*((float *)v47 + 3) * v49) + -0.5;
              float v55 = (float)(*((float *)v47 + 4) * v50) + -0.5;
              uint64_t v56 = *v47;
              v47 += 4;
              *uint64_t v44 = 1;
              *((float *)v44 + 1) = v54;
              *((float *)v44 + 2) = v55;
              *((float *)v44 + 3) = v52;
              *((float *)v44 + 4) = v53;
              v44[5] = v51;
              *((unsigned char *)v44 + 24) = 1;
              *((unsigned char *)v44 + 28) = 0;
              *((unsigned char *)v44 + 32) = 0;
              *((void *)v44 + 5) = v56;
              v44 += 12;
            }
            while (v47 != v48);
          }
        }
      }
    }
    else
    {
      v1981 = 0;
      v1980 = 0;
      v1982 = 0;
    }
    uint64_t v11 = *(void *)(*v1870 + 80);
    uint64_t v1978 = *(void *)(*v1870 + 72);
    uint64_t v1979 = v11;
    if (v11) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    }
    if (texture)
    {
      uint64_t v12 = *v1870;
      uint64_t v13 = *(void *)(*v1870 + 104);
      long long v14 = *(_OWORD *)(*v1870 + 128);
      *(_OWORD *)v1974 = *(_OWORD *)(*v1870 + 112);
      *(_OWORD *)&v1974[16] = v14;
      int v15 = *(_DWORD *)(v12 + 144);
      *(_OWORD *)&v1975[4] = *(_OWORD *)(v12 + 148);
      *(_OWORD *)&v1975[20] = *(_OWORD *)(v12 + 164);
      int v16 = *(_DWORD *)(v12 + 180);
      *(_DWORD *)v1975 = v15;
      *(_DWORD *)&v1975[36] = v16;
      float v1977 = *(float *)(v12 + 192);
      float32x2_t v1976 = *(float32x2_t *)(v12 + 184);
    }
    else
    {
      *(void *)&v1974[4] = 0;
      *(_OWORD *)&v1974[12] = 0x3F80000000000000uLL;
      *(_DWORD *)v1974 = 1065353216;
      *(_DWORD *)&v1974[28] = 0;
      *(void *)&v1975[16] = 0x3F80000000000000;
      *(void *)&v1975[8] = 0;
      *(void *)&v1975[24] = 0;
      *(void *)&v1975[32] = 0x3F80000000000000;
      __asm { FMOV            V0.2S, #1.0 }
      *(void *)v1975 = _D0;
      float32x2_t v1976 = 0;
      uint64_t v13 = 0x100000001;
      float v1977 = 0.0;
    }
    *(void *)&long long v1973 = &unk_1F26F4478;
    *((void *)&v1973 + 1) = v13;
    if (v1867)
    {
      uint64_t v20 = *v1870;
      uint64_t v21 = *v1870 + 200;
      uint64_t v22 = *(void *)(*v1870 + 216);
      v1967 = &unk_1F26F4478;
      uint64_t v1968 = v22;
      long long v23 = *(_OWORD *)(v20 + 240);
      *(_OWORD *)v1969 = *(_OWORD *)(v20 + 224);
      *(_OWORD *)&v1969[16] = v23;
      int v24 = *(_DWORD *)(v20 + 292);
      *(_DWORD *)v1970 = *(_DWORD *)(v20 + 256);
      *(_DWORD *)&v1970[36] = v24;
      *(_OWORD *)&v1970[4] = *(_OWORD *)(v21 + 60);
      *(_OWORD *)&v1970[20] = *(_OWORD *)(v21 + 76);
      float32x2_t v25 = *(float32x2_t *)(v20 + 296);
      float v1972 = *(float *)(v20 + 304);
      float32x2_t v1971 = v25;
      if (!**(unsigned char **)(*a2 + 8))
      {
        *(void *)v2006 = &v1975[4];
        v2022[0] = (float32x2_t)v2006;
        *(void *)int buf = v2022;
        *(void *)&uint8_t buf[8] = &v1976;
        *(void *)v2013 = 0;
        *(_DWORD *)&v2013[8] = 0;
        sub_1D0E0FBA0((float *)v2013, (uint64_t)buf);
        __p[0] = &v1970[4];
        v2022[0] = (float32x2_t)__p;
        *(void *)int buf = v2022;
        *(void *)&uint8_t buf[8] = &v1971;
        *(void *)v2006 = 0;
        *(_DWORD *)&v2006[8] = 0;
        sub_1D0E0FBA0((float *)v2006, (uint64_t)buf);
        float32x2_t v26 = vsub_f32(*(float32x2_t *)v2013, *(float32x2_t *)v2006);
        if ((float)(vaddv_f32(vmul_f32(v26, v26))
                   + (float)((float)(*(float *)&v2013[8] - *(float *)&v2006[8])
                           * (float)(*(float *)&v2013[8] - *(float *)&v2006[8]))) > 0.00001
          || (float)((float)((float)((float)(*(float *)&v1975[12] - *(float *)&v1970[12])
                                   * (float)(*(float *)&v1975[12] - *(float *)&v1970[12]))
                           + (float)((float)(*(float *)&v1975[24] - *(float *)&v1970[24])
                                   * (float)(*(float *)&v1975[24] - *(float *)&v1970[24])))
                   + (float)((float)(*(float *)&v1975[36] - *(float *)&v1970[36])
                           * (float)(*(float *)&v1975[36] - *(float *)&v1970[36]))) > 0.00001)
        {
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EB9F1610))
          {
            qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
            __cxa_guard_release(&qword_1EB9F1610);
          }
          float v27 = (id)qword_1EB9F1620;
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)int buf = 0;
            _os_log_error_impl(&dword_1D0DBD000, v27, OS_LOG_TYPE_ERROR, "RGB and depth must be registered", buf, 2u);
          }

          uint64_t v1867 = 0;
        }
      }
    }
    else
    {
      uint64_t v1867 = 0;
      v1967 = &unk_1F26F4478;
      uint64_t v1968 = 0x100000001;
      *(void *)&v1969[12] = 0x3F80000000000000;
      *(void *)&v1970[24] = 0;
      *(void *)&v1970[32] = 0x3F80000000000000;
      *(void *)&v1969[4] = 0;
      *(void *)&v1969[20] = 0;
      *(_DWORD *)v1969 = 1065353216;
      *(_DWORD *)&v1969[28] = 0;
      *(void *)&v1970[16] = 0x3F80000000000000;
      *(void *)&v1970[8] = 0;
      __asm { FMOV            V0.2S, #1.0 }
      *(void *)v1970 = _D0;
      float32x2_t v1971 = 0;
      float v1972 = 0.0;
    }
    uint64_t v29 = *v1870 + 24;
    int v30 = *(_DWORD *)(*v1870 + 48);
    v1868 = (float64x2_t *)v29;
    if (v30)
    {
      if (v30 != 1) {
        goto LABEL_2234;
      }
      *(_OWORD *)int buf = *(_OWORD *)v29;
      *(void *)&uint8_t buf[16] = *(void *)(v29 + 16);
      double Seconds = CMTimeGetSeconds((CMTime *)buf);
    }
    else
    {
      double Seconds = *(double *)v29;
    }
    double v1838 = Seconds * 1000.0;
    if (*(unsigned char *)(*a2 + 88))
    {
      unsigned __int8 v32 = sub_1D0E75EF8((uint64_t)v1868, *a2 + 56);
      if (v32 != 129 && (char)v32 <= 0)
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0)
        {
LABEL_2250:
          if (__cxa_guard_acquire(&qword_1EB9F1610))
          {
            qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
            __cxa_guard_release(&qword_1EB9F1610);
          }
        }
        unint64_t v33 = (id)qword_1EB9F1620;
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v34 = *a2 + 56;
          int v35 = *(_DWORD *)(*a2 + 80);
          if (v35)
          {
            if (v35 != 1) {
              goto LABEL_2234;
            }
            *(_OWORD *)int buf = *(_OWORD *)v34;
            *(void *)&uint8_t buf[16] = *(void *)(v34 + 16);
            double v36 = CMTimeGetSeconds((CMTime *)buf);
          }
          else
          {
            double v36 = *(double *)v34;
          }
          *(_DWORD *)int buf = 134218240;
          *(double *)&uint8_t buf[4] = v36 * 1000.0;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(double *)&buf[14] = v1838;
          _os_log_impl(&dword_1D0DBD000, v33, OS_LOG_TYPE_DEFAULT, "Non-increasing timestamp: last %.12g ms, current %.12g ms", buf, 0x16u);
        }
      }
    }
    kdebug_trace();
    kdebug_trace();
    if (!*(unsigned char *)(*a2 + 88)) {
      goto LABEL_87;
    }
    uint64_t v57 = *a2 + 56;
    v2022[3].i32[0] = 0;
    v2022[0] = (float32x2_t)0x3FF0000000000000;
    sub_1D0E75D88((CMTime *)buf, v57, (uint64_t)v2022);
    if ((char)sub_1D0E75EF8((uint64_t)v1868, (uint64_t)buf) < 1) {
      goto LABEL_87;
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    float32x4_t v58 = (id)qword_1EB9F1620;
    if (!os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_74;
    }
    uint64_t v59 = *a2 + 56;
    int v60 = *(_DWORD *)(*a2 + 80);
    if (!v60)
    {
      double v61 = *(double *)v59;
      goto LABEL_73;
    }
    if (v60 == 1)
    {
      *(_OWORD *)int buf = *(_OWORD *)v59;
      *(void *)&uint8_t buf[16] = *(void *)(v59 + 16);
      double v61 = CMTimeGetSeconds((CMTime *)buf);
LABEL_73:
      *(_DWORD *)int buf = 134218240;
      *(double *)&uint8_t buf[4] = v61 * 1000.0;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(double *)&buf[14] = v1838;
      _os_log_impl(&dword_1D0DBD000, v58, OS_LOG_TYPE_DEFAULT, "Timestamp gap detected, discarding all current face tracks: last %.12g ms, current %.12g ms", buf, 0x16u);
LABEL_74:

      uint64_t v62 = *a2;
      float32x4_t v63 = *(uint64_t **)(*a2 + 120);
      uint64_t v64 = *v63;
      uint64_t v65 = v63[1];
      if (v65 != *v63)
      {
        do
        {
          float32x4_t v66 = *(std::__shared_weak_count **)(v65 - 16);
          if (v66 && !atomic_fetch_add(&v66->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
            std::__shared_weak_count::__release_weak(v66);
          }
          v65 -= 24;
        }
        while (v65 != v64);
      }
      v63[1] = v64;
      uint64_t v67 = *(void *)(v62 + 120);
      uint64_t v68 = *(void *)(v67 + 24);
      for (uint64_t i = *(void *)(v67 + 32); i != v68; i -= 16)
      {
        size_t v70 = *(std::__shared_weak_count **)(i - 8);
        if (v70 && !atomic_fetch_add(&v70->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
          std::__shared_weak_count::__release_weak(v70);
        }
      }
      *(void *)(v67 + 32) = v68;
LABEL_87:
      uint64_t v71 = *a2;
      int v72 = *(unsigned __int8 *)(*a2 + 88);
      _Q0 = v1868[1];
      *(float64x2_t *)(v71 + 56) = *v1868;
      *(float64x2_t *)(v71 + 72) = _Q0;
      if (!v72) {
        *(unsigned char *)(v71 + 88) = 1;
      }
      uint64_t v74 = *a2;
      unint64_t v1873 = *(int *)(*(void *)(*a2 + 8) + 12);
      int32x4_t v75 = *(uint64_t **)(*a2 + 120);
      uint64_t v76 = *v75;
      uint64_t v77 = v75[1];
      unint64_t v78 = 0xAAAAAAAAAAAAAAABLL * ((v77 - *v75) >> 3);
      if ((int)v78 >= 2)
      {
        uint64_t v79 = 0;
        uint64_t v80 = (v78 - 1);
        uint64_t v81 = (int)v78;
        uint64_t v1887 = -1431655765 * ((v77 - *v75) >> 3);
        LODWORD(_Q0.f64[0]) = 136315394;
        uint64_t v82 = 24;
        uint64_t v83 = 1;
        uint64_t v1878 = v80;
        uint64_t v1875 = (int)v78;
        while (1)
        {
          v1919 = *(uint64_t **)(**(void **)(v74 + 120) + 24 * v79);
          float32x4_t v84 = (float *)*v1919;
          if (!*(void *)(*v1919 + 128))
          {
            ++v79;
            goto LABEL_92;
          }
          if (++v79 >= v81) {
            goto LABEL_92;
          }
          uint64_t key = v79;
          uint64_t v1889 = v82;
          uint64_t v85 = v1887;
          while (1)
          {
            float32x4_t v86 = *(uint64_t **)(**(void **)(v74 + 120) + v82);
            int8x16_t v87 = (float *)*v86;
            unint64_t v88 = *(void *)(*v86 + 128);
            if (!v88) {
              goto LABEL_98;
            }
            float v89 = v84[11];
            float v90 = v84[12];
            double v91 = v90;
            float v92 = v87[11];
            float v93 = v87[12];
            double v94 = v93;
            double v95 = v89 + v84[13];
            double v96 = v92 + v87[13];
            if (v89 >= v92) {
              double v97 = v89;
            }
            else {
              double v97 = v92;
            }
            if (v96 >= v95) {
              double v98 = v89 + v84[13];
            }
            else {
              double v98 = v92 + v87[13];
            }
            double v99 = v98 - v97;
            if (v90 >= v93) {
              double v100 = v90;
            }
            else {
              double v100 = v93;
            }
            double v101 = v94 + v87[14];
            double v102 = v91 + v84[14];
            if (v101 >= v102) {
              double v103 = v91 + v84[14];
            }
            else {
              double v103 = v94 + v87[14];
            }
            float v104 = v99;
            float v105 = v103 - v100;
            if (v92 >= v89) {
              double v106 = v89;
            }
            else {
              double v106 = v92;
            }
            if (v95 >= v96) {
              double v107 = v95;
            }
            else {
              double v107 = v92 + v87[13];
            }
            double v108 = v107 - v106;
            if (v93 >= v90) {
              double v109 = v90;
            }
            else {
              double v109 = v93;
            }
            if (v102 >= v101) {
              double v110 = v91 + v84[14];
            }
            else {
              double v110 = v94 + v87[14];
            }
            float v111 = v108;
            float v112 = v110 - v109;
            _NF = v105 < 0.0 || v104 < 0.0;
            float v114 = v105 * v104;
            if (_NF) {
              float v114 = 0.0;
            }
            BOOL v115 = v112 < 0.0 || v111 < 0.0;
            float v116 = v112 * v111;
            if (v115) {
              float v116 = 0.0;
            }
            *(float *)_Q0.f64 = v116 <= 0.0 ? 0.0 : v114 / v116;
            if (*(float *)_Q0.f64 <= 0.7) {
              goto LABEL_98;
            }
            unint64_t v117 = *(void *)(*v1919 + 128);
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EB9F1610))
            {
              qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
              __cxa_guard_release(&qword_1EB9F1610);
            }
            float32x4_t v118 = (id)qword_1EB9F1620;
            BOOL v119 = os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT);
            if (v88 > v117) {
              break;
            }
            if (!v119) {
              goto LABEL_97;
            }
            float32x4_t v120 = *(void **)(*v86 + 24);
            int32x4_t v121 = *(std::__shared_weak_count **)(*v86 + 32);
            if (v121) {
              atomic_fetch_add_explicit(&v121->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v120)
            {
              float32x4_t v122 = (const char *)(*v120 + 160);
              if (!v121) {
                goto LABEL_149;
              }
            }
            else
            {
              float32x4_t v122 = "(null)";
              if (!v121) {
                goto LABEL_149;
              }
            }
            if (!atomic_fetch_add(&v121->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v121->__on_zero_shared)(v121);
              std::__shared_weak_count::__release_weak(v121);
            }
LABEL_149:
            int v123 = *(void **)(*v1919 + 24);
            float v124 = *(std::__shared_weak_count **)(*v1919 + 32);
            if (v124) {
              atomic_fetch_add_explicit(&v124->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v123)
            {
              float v125 = (const char *)(*v123 + 160);
              if (v124) {
                goto LABEL_155;
              }
            }
            else
            {
              float v125 = "(null)";
              if (v124)
              {
LABEL_155:
                if (!atomic_fetch_add(&v124->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v124->__on_zero_shared)(v124);
                  std::__shared_weak_count::__release_weak(v124);
                }
              }
            }
            *(_DWORD *)int buf = 136315394;
            *(void *)&uint8_t buf[4] = v122;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v125;
            _os_log_impl(&dword_1D0DBD000, v118, OS_LOG_TYPE_DEFAULT, "duplicate tracks for same face, discarding %s in favor of %s", buf, 0x16u);
LABEL_97:

            sub_1D0E3F500(v86);
LABEL_98:
            --v85;
            v82 += 24;
            if (v83 == v85) {
              goto LABEL_178;
            }
          }
          if (v119)
          {
            int v126 = *(void **)(*v1919 + 24);
            uint64_t v127 = *(std::__shared_weak_count **)(*v1919 + 32);
            if (v127) {
              atomic_fetch_add_explicit(&v127->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v126)
            {
              int v128 = (const char *)(*v126 + 160);
              if (!v127) {
                goto LABEL_168;
              }
            }
            else
            {
              int v128 = "(null)";
              if (!v127) {
                goto LABEL_168;
              }
            }
            if (!atomic_fetch_add(&v127->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v127->__on_zero_shared)(v127);
              std::__shared_weak_count::__release_weak(v127);
            }
LABEL_168:
            int32x4_t v129 = *(void **)(*v86 + 24);
            int32x4_t v130 = *(std::__shared_weak_count **)(*v86 + 32);
            if (v130) {
              atomic_fetch_add_explicit(&v130->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v129)
            {
              unsigned int v131 = (const char *)(*v129 + 160);
              if (!v130) {
                goto LABEL_176;
              }
            }
            else
            {
              unsigned int v131 = "(null)";
              if (!v130) {
                goto LABEL_176;
              }
            }
            if (!atomic_fetch_add(&v130->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v130->__on_zero_shared)(v130);
              std::__shared_weak_count::__release_weak(v130);
            }
LABEL_176:
            *(_DWORD *)int buf = 136315394;
            *(void *)&uint8_t buf[4] = v128;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v131;
            _os_log_impl(&dword_1D0DBD000, v118, OS_LOG_TYPE_DEFAULT, "duplicate tracks for same face, discarding %s in favor of %s", buf, 0x16u);
          }

          sub_1D0E3F500(v1919);
LABEL_178:
          uint64_t v79 = key;
          uint64_t v80 = v1878;
          uint64_t v81 = v1875;
          uint64_t v82 = v1889;
LABEL_92:
          ++v83;
          v82 += 24;
          if (v79 == v80)
          {
            int32x4_t v75 = *(uint64_t **)(v74 + 120);
            uint64_t v76 = *v75;
            uint64_t v77 = v75[1];
            goto LABEL_182;
          }
        }
      }
      while (1)
      {
LABEL_182:
        if (v76 == v77) {
          goto LABEL_201;
        }
        if (!*(void *)(**(void **)v76 + 128)) {
          break;
        }
        v76 += 24;
      }
      if (v76 != v77)
      {
        uint64_t v132 = v76 + 24;
        if (v76 + 24 != v77)
        {
          do
          {
            if (*(void *)(**(void **)v132 + 128))
            {
              _Q0 = *(float64x2_t *)v132;
              *(void *)uint64_t v132 = 0;
              *(void *)(v132 + 8) = 0;
              int32x4_t v133 = *(std::__shared_weak_count **)(v76 + 8);
              *(float64x2_t *)uint64_t v76 = _Q0;
              if (v133 && !atomic_fetch_add(&v133->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v133->__on_zero_shared)(v133);
                std::__shared_weak_count::__release_weak(v133);
              }
              LODWORD(_Q0.f64[0]) = *(_DWORD *)(v132 + 16);
              *(_DWORD *)(v76 + 16) = LODWORD(_Q0.f64[0]);
              v76 += 24;
            }
            v132 += 24;
          }
          while (v132 != v77);
          uint64_t v77 = v75[1];
        }
      }
      if (v76 != v77)
      {
        do
        {
          int32x4_t v134 = *(std::__shared_weak_count **)(v77 - 16);
          if (v134 && !atomic_fetch_add(&v134->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v134->__on_zero_shared)(v134);
            std::__shared_weak_count::__release_weak(v134);
          }
          v77 -= 24;
        }
        while (v77 != v76);
        v75[1] = v76;
      }
LABEL_201:
      int32x4_t v135 = *(float ***)(v74 + 120);
      int32x4_t v137 = *v135;
      int32x4_t v136 = v135[1];
      int32x4_t v138 = v137;
      if (v137 != v136)
      {
        __asm { FMOV            V0.2S, #1.0 }
        uint64_t v139 = v137;
        do
        {
          uint64_t v140 = **(void **)v139;
          float32x2_t v141 = vdiv_f32(*(float32x2_t *)&_Q0.f64[0], (float32x2_t)__PAIR64__(*(unsigned int *)&v1974[16], *(unsigned int *)v1974));
          float32x2_t v142 = vmul_f32(v141, vsub_f32(*(float32x2_t *)(v140 + 44), *(float32x2_t *)&v1974[24]));
          float32x2_t v143 = vmul_f32(v141, *(float32x2_t *)(v140 + 52));
          float v144 = v143.f32[1];
          if (v143.f32[0] >= v143.f32[1]) {
            float v144 = v143.f32[0];
          }
          float32x2_t v145 = vadd_f32(vmul_f32(v143, (float32x2_t)0x3F0000003F000000), v142);
          v145.f32[0] = vaddv_f32(vmul_f32(v145, v145));
          v139[4] = (float)(v144 * v144) / (float)((float)(v145.f32[0] + 1.0) * (float)(v145.f32[0] + 1.0));
          v139 += 6;
        }
        while (v139 != v136);
        int32x4_t v138 = v136;
      }
      unint64_t v146 = ((char *)v138 - (char *)v137) / 24;
      uint64_t v147 = (char *)v1980;
      int v148 = v1981;
      if (v1980 != v1981)
      {
        if (v146 <= 1) {
          uint64_t v149 = 1;
        }
        else {
          uint64_t v149 = ((char *)v138 - (char *)v137) / 24;
        }
        uint64_t keya = v149;
        __asm
        {
          FMOV            V9.2S, #-0.25
          FMOV            V10.2S, #1.5
          FMOV            V13.2S, #1.0
          FMOV            V0.2S, #0.25
        }
        float32x2_t v1904 = _D0;
        do
        {
          _Q0.f64[0] = *(float64_t *)(v147 + 4);
          float32x2_t v154 = *(float32x2_t *)(v147 + 12);
          *(_OWORD *)int buf = *(_OWORD *)(v147 + 20);
          *(_DWORD *)&uint8_t buf[16] = *((_DWORD *)v147 + 9);
          if (v154.f32[0] >= 0.0 && v154.f32[1] >= 0.0 && (float)(v154.f32[0] * v154.f32[1]) >= 0.00000011921)
          {
            float32x2_t v156 = vadd_f32(*(float32x2_t *)&_Q0.f64[0], vmul_f32(v154, _D9));
            *(float32x2_t *)&_Q0.f64[0] = vmul_f32(v154, _D10);
            float64x2_t v1920 = _Q0;
            if (v138 == v137)
            {
LABEL_244:
              float32x2_t v176 = vdiv_f32(_D13, vcvt_f32_s32(vmax_s32(*(int32x2_t *)((char *)&v1973 + 8), (int32x2_t)0x100000001)));
              _Q0.f64[1] = v1920.f64[1];
              *(float32x2_t *)&_Q0.f64[0] = vmul_f32(*(float32x2_t *)&v1920.f64[0], v176);
              float32x2_t v177 = vadd_f32(vmul_f32(vadd_f32(v156, (float32x2_t)0x3F0000003F000000), v176), vmul_f32(*(float32x2_t *)&_Q0.f64[0], v1904));
              if (v177.f32[0] >= 0.0 && v177.f32[1] >= 0.0)
              {
                *(int8x8_t *)&_Q0.f64[0] = vmvn_s8((int8x8_t)vcge_f32(_D13, vadd_f32(v177, vmul_f32(*(float32x2_t *)&_Q0.f64[0], (float32x2_t)0x3F0000003F000000))));
                if ((LOBYTE(_Q0.f64[0]) & 1) == 0 && (BYTE4(_Q0.f64[0]) & 1) == 0)
                {
                  unsigned int v178 = operator new(0x20uLL);
                  v178[1] = 0;
                  v178[2] = 0;
                  void *v178 = &unk_1F26F4C60;
                  operator new();
                }
              }
            }
            else
            {
              int32x4_t v157 = **(void ****)(v74 + 120);
              _Q0 = vcvtq_f64_f32(v156);
              float64x2_t v158 = vaddq_f64(_Q0, vcvtq_f64_f32(*(float32x2_t *)&v1920.f64[0]));
              BOOL v159 = *((float *)v1920.f64 + 1) < 0.0 || *(float *)v1920.f64 < 0.0;
              float v160 = vmuls_lane_f32(*(float *)v1920.f64, *(float32x2_t *)&v1920.f64[0], 1);
              if (v159) {
                float v160 = 0.0;
              }
              uint64_t v161 = keya;
              while (1)
              {
                int32x4_t v162 = (void *)**v157;
                if (v162[16])
                {
                  float32x2_t v163 = *(float32x2_t *)((char *)v162 + 44);
                  float64x2_t v164 = vcvtq_f64_f32(v163);
                  float32x2_t v165 = *(float32x2_t *)((char *)v162 + 52);
                  int32x2_t v166 = vcgt_f32(v163, v156);
                  v167.i64[0] = v166.i32[0];
                  v167.i64[1] = v166.i32[1];
                  float64x2_t v168 = (float64x2_t)vbslq_s8(v167, (int8x16_t)v164, (int8x16_t)_Q0);
                  float64x2_t v169 = vaddq_f64(v164, vcvtq_f64_f32(v165));
                  float32x2_t v170 = vcvt_f32_f64(vsubq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v158, v169), (int8x16_t)v169, (int8x16_t)v158), v168));
                  BOOL v171 = v170.f32[1] < 0.0 || v170.f32[0] < 0.0;
                  float v172 = vmuls_lane_f32(v170.f32[0], v170, 1);
                  if (v171) {
                    float v172 = 0.0;
                  }
                  BOOL v173 = v165.f32[1] < 0.0 || v165.f32[0] < 0.0;
                  float v174 = vmuls_lane_f32(v165.f32[0], v165, 1);
                  if (v173) {
                    float v174 = 0.0;
                  }
                  if (v174 >= v160) {
                    float v174 = v160;
                  }
                  float v175 = v172 / v174;
                  if (v174 <= 0.0) {
                    float v175 = 0.0;
                  }
                  if (v175 >= 0.5) {
                    break;
                  }
                }
                v157 += 3;
                if (!--v161) {
                  goto LABEL_244;
                }
              }
              LODWORD(_Q0.f64[0]) = 1061997773;
              if (v175 >= 0.8) {
                v162[10] = *((void *)v147 + 5);
              }
            }
          }
          v147 += 48;
        }
        while (v147 != v148);
        int v179 = *(float ***)(v74 + 120);
        int32x4_t v137 = *v179;
        int32x4_t v138 = v179[1];
      }
      uint64_t v180 = (uint64_t)&v137[6 * v146];
      if ((uint64_t)v138 - v180 < 1)
      {
LABEL_254:
        float32x4_t v184 = 0;
        unint64_t v182 = 0;
      }
      else
      {
        int v181 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
        unint64_t v182 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v138 - v180) >> 3);
        while (1)
        {
          float32x4_t v183 = (float *)operator new(24 * v182, v181);
          if (v183) {
            break;
          }
          BOOL v746 = v182 > 1;
          v182 >>= 1;
          if (!v746) {
            goto LABEL_254;
          }
        }
        float32x4_t v184 = v183;
      }
      sub_1D0DF9410(v180, v138, (uint64_t)buf, 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v138 - v180) >> 3), v184, v182, *(float *)_Q0.f64);
      if (v184) {
        operator delete(v184);
      }
      float32x4_t v185 = *(void **)(v74 + 120);
      unint64_t v186 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v185[1] - *v185) >> 3);
      if (v186 >= 2)
      {
        do
        {
          uint64_t v187 = 0;
          if (v186 <= 2) {
            uint64_t v188 = 2;
          }
          else {
            uint64_t v188 = v186;
          }
          uint64_t v189 = v188 - 1;
          do
          {
            int32x4_t v190 = (long long *)(**(void **)(v74 + 120) + v187);
            float v191 = *((float *)v190 + 10);
            float v192 = *((float *)v190 + 4);
            if (v191 > (float)(v192 + v192))
            {
              long long v193 = *(long long *)((char *)v190 + 24);
              *((float *)v190 + 4) = v191;
              long long v194 = *v190;
              *int32x4_t v190 = v193;
              *(long long *)((char *)v190 + 24) = v194;
              *((float *)v190 + 10) = v192;
            }
            v187 += 24;
            --v189;
          }
          while (v189);
          --v186;
        }
        while (v186 > 1);
        float32x4_t v185 = *(void **)(v74 + 120);
      }
      uint64_t v195 = v185[3];
      for (uint64_t j = v185[4]; j != v195; j -= 16)
      {
        float32x4_t v197 = *(std::__shared_weak_count **)(j - 8);
        if (v197 && !atomic_fetch_add(&v197->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v197->__on_zero_shared)(v197);
          std::__shared_weak_count::__release_weak(v197);
        }
      }
      v185[4] = v195;
      float32x4_t v198 = *(void **)(v74 + 120);
      float32x4_t v199 = (char *)v198[3];
      int v200 = v1873;
      if (v1873 > (uint64_t)(v198[5] - (void)v199) >> 4)
      {
        if ((v1873 & 0x80000000) != 0) {
          abort();
        }
        int v201 = (char *)v198[4];
        uint64_t v202 = (char *)operator new(16 * v1873);
        int v203 = &v202[16 * v1873];
        int32x4_t v204 = &v202[v201 - v199];
        if (v201 == v199)
        {
          v198[3] = v204;
          v198[4] = v204;
          v198[5] = v203;
        }
        else
        {
          int32x4_t v205 = &v202[v201 - v199];
          do
          {
            long long v206 = *((_OWORD *)v201 - 1);
            v201 -= 16;
            *((_OWORD *)v205 - 1) = v206;
            v205 -= 16;
            *(void *)int v201 = 0;
            *((void *)v201 + 1) = 0;
          }
          while (v201 != v199);
          float32x4_t v199 = (char *)v198[3];
          unsigned int v207 = (char *)v198[4];
          v198[3] = v205;
          v198[4] = v204;
          for (v198[5] = v203; v207 != v199; v207 -= 16)
          {
            int32x4_t v208 = (std::__shared_weak_count *)*((void *)v207 - 1);
            if (v208 && !atomic_fetch_add(&v208->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v208->__on_zero_shared)(v208);
              std::__shared_weak_count::__release_weak(v208);
            }
          }
        }
        int v200 = v1873;
        if (v199) {
          operator delete(v199);
        }
      }
      int v209 = -1431655765 * ((*(void *)(*(void *)(v74 + 120) + 8) - **(void **)(v74 + 120)) >> 3);
      if (v209 >= v200) {
        int v210 = v200;
      }
      else {
        int v210 = -1431655765 * ((*(void *)(*(void *)(v74 + 120) + 8) - **(void **)(v74 + 120)) >> 3);
      }
      if (v210 >= 1)
      {
        uint64_t v211 = 0;
        while (2)
        {
          int32x4_t v212 = *(uint64_t **)(v74 + 120);
          uint64_t v213 = *v212;
          uint64_t v214 = (__n128 *)v212[4];
          if ((unint64_t)v214 >= v212[5])
          {
            __int32 v216 = sub_1D0DF9A20((uint64_t)(v212 + 3), *(__n128 *)(v213 + v211));
          }
          else
          {
            v214->n128_u64[0] = *(void *)(v213 + v211);
            unint64_t v215 = *(void *)(v213 + v211 + 8);
            v214->n128_u64[1] = v215;
            if (v215) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v215 + 8), 1uLL, memory_order_relaxed);
            }
            __int32 v216 = v214 + 1;
          }
          v212[4] = (uint64_t)v216;
          uint64_t v217 = **(void **)(v213 + v211);
          if (*(void *)(v217 + 128)) {
            goto LABEL_296;
          }
          float v219 = *(float *)(v217 + 44);
          float v218 = *(float *)(v217 + 48);
          float v220 = *(float *)(v217 + 52);
          float v221 = *(float *)(v217 + 56);
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EB9F1610))
          {
            qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
            __cxa_guard_release(&qword_1EB9F1610);
          }
          int32x2_t v222 = (id)qword_1EB9F1620;
          if (os_log_type_enabled(v222, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v223 = **(void **)(v213 + v211);
            int32x2_t v224 = *(void **)(v223 + 24);
            float v225 = *(std::__shared_weak_count **)(v223 + 32);
            if (v225) {
              atomic_fetch_add_explicit(&v225->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v224)
            {
              float v226 = (const char *)(*v224 + 160);
              if (!v225) {
                goto LABEL_294;
              }
            }
            else
            {
              float v226 = "(null)";
              if (!v225) {
                goto LABEL_294;
              }
            }
            if (!atomic_fetch_add(&v225->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v225->__on_zero_shared)(v225);
              std::__shared_weak_count::__release_weak(v225);
            }
LABEL_294:
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v226;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(double *)&buf[14] = (float)(v219 + (float)(v220 * 0.5));
            *(_WORD *)&unsigned char buf[22] = 2048;
            *(double *)&unsigned char buf[24] = (float)(v218 + (float)(v221 * 0.5));
            *(_WORD *)&buf[32] = 2048;
            *(double *)&buf[34] = v220;
            *(_WORD *)&buf[42] = 2048;
            *(double *)&buf[44] = v221;
            _os_log_impl(&dword_1D0DBD000, v222, OS_LOG_TYPE_DEFAULT, "new track for user %s at (%.0f,%.0f), bbox size (%.0f,%.0f)", buf, 0x34u);
          }

LABEL_296:
          v211 += 24;
          if (24 * v210 == v211) {
            break;
          }
          continue;
        }
      }
      if ((int)v1873 < v209)
      {
        int v227 = v209 - v1873;
        uint64_t v228 = 24 * v1873;
        while (1)
        {
          uint64_t v229 = **(void **)(v74 + 120);
          float v230 = *(uint64_t **)(v229 + v228);
          if (*(void *)(*v230 + 128)) {
            break;
          }
LABEL_317:
          sub_1D0E3F500(v230);
          v228 += 24;
          if (!--v227) {
            goto LABEL_333;
          }
        }
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1610))
        {
          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
          __cxa_guard_release(&qword_1EB9F1610);
        }
        long long v231 = (id)qword_1EB9F1620;
        if (os_log_type_enabled(v231, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v232 = **(void **)(v229 + v228);
          float v233 = *(void **)(v232 + 24);
          long long v234 = *(std::__shared_weak_count **)(v232 + 32);
          if (v234) {
            atomic_fetch_add_explicit(&v234->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v233)
          {
            float32x2_t v235 = (const char *)(*v233 + 160);
            if (!v234) {
              goto LABEL_329;
            }
          }
          else
          {
            float32x2_t v235 = "(null)";
            if (!v234) {
              goto LABEL_329;
            }
          }
          if (!atomic_fetch_add(&v234->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v234->__on_zero_shared)(v234);
            std::__shared_weak_count::__release_weak(v234);
          }
LABEL_329:
          *(_DWORD *)int buf = 136315394;
          *(void *)&uint8_t buf[4] = v235;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v210;
          _os_log_impl(&dword_1D0DBD000, v231, OS_LOG_TYPE_DEFAULT, "resetting track for user %s: exceeded number of faces to track (%d)", buf, 0x12u);
        }

        float v230 = *(uint64_t **)(v229 + v228);
        goto LABEL_317;
      }
LABEL_333:
      uint64_t v236 = *(void *)(v74 + 120);
      v1890 = (uint64_t ***)(v236 + 24);
      kdebug_trace();
      uint64_t v1857 = *(void *)(v236 + 32) - *(void *)(v236 + 24);
      unint64_t v237 = (unint64_t)v1857 >> 4;
      uint64_t v1888 = v236;
      if (texture && (int)v237 >= 1 && *(unsigned char *)(*a2 + 136))
      {
        kdebug_trace();
        uint64_t v1921 = *a2;
        int v238 = *(_DWORD *)(*(void *)(*a2 + 8) + 48);
        if (v238 == 1)
        {
          int v239 = 3;
        }
        else if (v238 == 2)
        {
          int v239 = 0;
        }
        else
        {
          float v240 = *(uint64_t **)(v236 + 24);
          float v241 = *(uint64_t **)(v236 + 32);
          if (v240 == v241)
          {
            int v242 = 0;
          }
          else
          {
            int v242 = 0;
            float v243 = (float)*(unsigned int *)(v1921 + 48);
            do
            {
              uint64_t v244 = *v240;
              v240 += 2;
              int v245 = llroundf(-1.0 - log2f(v243 / *(float *)(*(void *)v244 + 52)));
              if (v245 < 0) {
                int v245 = -1;
              }
              if (v242 <= v245 + 1) {
                int v242 = v245 + 1;
              }
            }
            while (v240 != v241);
          }
          if (v242 >= 3) {
            int v239 = 3;
          }
          else {
            int v239 = v242;
          }
        }
        CVPixelBufferRetain(texture);
        int v246 = CVPixelBufferGetWidth(texture);
        int v247 = CVPixelBufferGetHeight(texture);
        OSType PixelFormatType = CVPixelBufferGetPixelFormatType(texture);
        uint64_t v248 = *(void *)(v1921 + 128);
        if (*(_DWORD *)v248 == v246
          && *(_DWORD *)(v248 + 4) == v247
          && PixelFormatType == *(_DWORD *)(v248 + 20)
          && *(_DWORD *)(v248 + 12) >= v239)
        {
          goto LABEL_419;
        }
        uint64_t v249 = v239;
        v250 = *(char **)(v248 + 24);
        if (v239 > (unint64_t)((uint64_t)(*(void *)(v248 + 40) - (void)v250) >> 3))
        {
          int8x16_t v251 = *(char **)(v248 + 32);
          int8x16_t v252 = (char *)operator new(8 * v239);
          uint64_t v253 = v251 - v250;
          unint64_t v254 = (unint64_t)&v252[(v251 - v250) & 0xFFFFFFFFFFFFFFF8];
          float32x4_t v255 = &v252[8 * v239];
          if (v251 == v250)
          {
            *(void *)(v248 + 24) = v254;
            *(void *)(v248 + 32) = v254;
            *(void *)(v248 + 40) = v255;
          }
          else
          {
            unint64_t v256 = v251 - v250 - 8;
            if (v256 <= 0x77)
            {
              float v257 = &v252[(v251 - v250) & 0xFFFFFFFFFFFFFFF8];
              goto LABEL_2088;
            }
            BOOL v1729 = &v252[(v253 & 0xFFFFFFFFFFFFFFF8) - (v256 & 0xFFFFFFFFFFFFFFF8) - 8] >= v251
                 || (unint64_t)&v251[-(v256 & 0xFFFFFFFFFFFFFFF8) - 8] >= v254;
            float v257 = &v252[(v251 - v250) & 0xFFFFFFFFFFFFFFF8];
            if (!v1729) {
              goto LABEL_2278;
            }
            uint64_t v1730 = v253 >> 3;
            uint64_t v1731 = (v256 >> 3) + 1;
            v1732 = &v252[8 * v1730 - 16];
            v1733 = v251 - 32;
            uint64_t v1734 = v1731 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v1735 = *((_OWORD *)v1733 + 1);
              *((_OWORD *)v1732 - 1) = *(_OWORD *)v1733;
              *(_OWORD *)v1732 = v1735;
              *(_OWORD *)v1733 = 0uLL;
              *((_OWORD *)v1733 + 1) = 0uLL;
              v1733 -= 32;
              v1732 -= 32;
              v1734 -= 4;
            }
            while (v1734);
            float v257 = (char *)(v254 - 8 * (v1731 & 0x3FFFFFFFFFFFFFFCLL));
            v251 -= 8 * (v1731 & 0x3FFFFFFFFFFFFFFCLL);
            if (v1731 != (v1731 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_2278:
              do
              {
LABEL_2088:
                uint64_t v1736 = *((void *)v251 - 1);
                v251 -= 8;
                *((void *)v257 - 1) = v1736;
                v257 -= 8;
                *(void *)int8x16_t v251 = 0;
              }
              while (v251 != v250);
            }
            v250 = *(char **)(v248 + 24);
            v1737 = *(char **)(v248 + 32);
            *(void *)(v248 + 24) = v257;
            *(void *)(v248 + 32) = v254;
            *(void *)(v248 + 40) = v255;
            while (v1737 != v250)
            {
              v1739 = (__CVBuffer *)*((void *)v1737 - 1);
              v1737 -= 8;
              v1738 = v1739;
              if (v1739) {
                CVPixelBufferRelease(v1738);
              }
            }
          }
          if (v250) {
            operator delete(v250);
          }
        }
        *(void *)(*(void *)(v1921 + 128) + 56) = *(void *)(*(void *)(v1921 + 128) + 48);
        uint64_t v248 = *(void *)(v1921 + 128);
        *(_DWORD *)uint64_t v248 = v246;
        *(_DWORD *)(v248 + 4) = v247;
        *(_DWORD *)(v248 + 16) = v239;
        *(_DWORD *)(v248 + 20) = PixelFormatType;
        *(_DWORD *)(v248 + 12) = v239;
        if (v239 < 1) {
          goto LABEL_419;
        }
        int v1876 = v239;
        uint64_t v258 = 0;
        if (v247 >= 0) {
          int v259 = v247;
        }
        else {
          int v259 = v247 + 1;
        }
        uint64_t v260 = (v259 >> 1);
        if (v246 >= 0) {
          int v261 = v246;
        }
        else {
          int v261 = v246 + 1;
        }
        unint64_t v262 = (v261 >> 1);
        CFStringRef keyb = (const __CFString *)*MEMORY[0x1E4F2F128];
        uint64_t v263 = PixelFormatType;
        while (2)
        {
          if ((int)v262 < 17 || (int)v260 <= 16)
          {
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EB9F1610))
            {
              qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
              __cxa_guard_release(&qword_1EB9F1610);
            }
            float32x4_t v290 = (id)qword_1EB9F1620;
            if (os_log_type_enabled(v290, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)int buf = 67109632;
              *(_DWORD *)&uint8_t buf[4] = v258;
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = v262;
              *(_WORD *)&buf[14] = 1024;
              *(_DWORD *)&uint8_t buf[16] = v260;
              _os_log_impl(&dword_1D0DBD000, v290, OS_LOG_TYPE_INFO, "image size in pyramid is becoming too small, size for level %d is %d/%d, stopping!", buf, 0x14u);
            }

            uint64_t v248 = *(void *)(v1921 + 128);
            *(_DWORD *)(v248 + 16) = v258;
LABEL_418:
            int v239 = v1876;
LABEL_419:
            int v291 = *(_DWORD *)(v248 + 16);
            if (v291 >= v239) {
              int v291 = v239;
            }
            *(_DWORD *)(v248 + 8) = v291;
            if (*(void *)(v248 + 24) != *(void *)(v248 + 32) && !*(void *)(v248 + 72))
            {
              float32x2_t v316 = operator new(0x20uLL);
              v316[1] = 0;
              v316[2] = 0;
              *float32x2_t v316 = &unk_1F26F4D08;
              operator new();
            }
            int v292 = *(void **)(v248 + 48);
            if (v292 == *(void **)(v248 + 56))
            {
              int v293 = *(_DWORD *)(v248 + 8);
              if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v248 + 64) - (void)v292) >> 2) < (unint64_t)v293)
              {
                if (v293 < 0) {
LABEL_2244:
                }
                  abort();
                unint64_t v294 = (char *)operator new(28 * v293);
                *(void *)(v248 + 48) = v294;
                *(void *)(v248 + 56) = v294;
                *(void *)(v248 + 64) = &v294[28 * v293];
                if (v292)
                {
                  operator delete(v292);
                  int v293 = *(_DWORD *)(v248 + 8);
                }
              }
              *(float32x2_t *)((char *)v2022 + 4) = 0;
              v2022[0].i32[0] = 1065353216;
              *(_OWORD *)&v2022[1].i32[1] = xmmword_1D0E81450;
              if (v293 >= 1)
              {
                for (int k = 0; k < *(_DWORD *)(v248 + 8); ++k)
                {
                  *(void *)&v2013[4] = 0;
                  *(_DWORD *)v2013 = 1056964608;
                  *(_DWORD *)&v2013[12] = 1056964608;
                  *(void *)&v2013[16] = 0;
                  *(_DWORD *)&v2013[24] = 1048576000;
                  __p[0] = v2013;
                  __p[1] = v2022;
                  *(void *)&v2006[8] = 0;
                  *(void *)v2006 = 0;
                  sub_1D0E0FE28((uint64_t)v2006, (float **)__p);
                  memptr[0] = v2013;
                  memptr[1] = &v2022[2];
                  *(void *)&uint8_t buf[4] = 0;
                  sub_1D0DD6E58((float *)&buf[4], (float **)memptr);
                  float v297 = (float)(*(float *)v2006 * *(float *)&v2006[12])
                       - (float)(*(float *)&v2006[8] * *(float *)&v2006[4]);
                  v2022[0] = *(float32x2_t *)v2006;
                  v2022[1] = *(float32x2_t *)&v2006[8];
                  v2022[2] = vadd_f32(*(float32x2_t *)&buf[4], 0);
                  v2022[3].f32[0] = v297;
                  if (fabsf(v297) < 1.0e-15)
                  {
                    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                      && __cxa_guard_acquire(&qword_1EB9F1610))
                    {
                      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                      __cxa_guard_release(&qword_1EB9F1610);
                    }
                    v1740 = (id)qword_1EB9F1620;
                    if (os_log_type_enabled(v1740, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)int buf = 0;
                      _os_log_error_impl(&dword_1D0DBD000, v1740, OS_LOG_TYPE_ERROR, "failed to set transformation in image pyramid", buf, 2u);
                    }

                    uint64_t v1818 = *(void *)(v1921 + 128);
                    v1819 = *(std::__shared_weak_count **)(v1818 + 80);
                    *(void *)(v1818 + 72) = 0;
                    *(void *)(v1818 + 80) = 0;
                    if (v1819 && !atomic_fetch_add(&v1819->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v1819->__on_zero_shared)(v1819);
                      std::__shared_weak_count::__release_weak(v1819);
                    }
                    goto LABEL_2228;
                  }
                  float v298 = *(float *)&v2006[12] / v297;
                  float v299 = (float)-*(float *)&v2006[4] / v297;
                  *(float *)int buf = *(float *)&v2006[12] / v297;
                  *(float *)&uint8_t buf[4] = v299;
                  float v300 = (float)-*(float *)&v2006[8] / v297;
                  float v301 = *(float *)v2006 / v297;
                  *(float *)&uint8_t buf[8] = v300;
                  *(float *)&unsigned char buf[12] = *(float *)v2006 / v297;
                  *(void *)v2006 = buf;
                  *(void *)v2013 = v2006;
                  *(void *)&v2013[8] = &v2022[2];
                  __p[0] = 0;
                  sub_1D0E0FC64((float *)__p, (uint64_t)v2013);
                  unint64_t v302 = __p[0];
                  float v303 = (float)(v298 * v301) - (float)(v300 * v299);
                  float32x2_t v305 = *(float **)(v248 + 56);
                  unint64_t v304 = *(void *)(v248 + 64);
                  if ((unint64_t)v305 < v304)
                  {
                    *float32x2_t v305 = v298;
                    v305[1] = v299;
                    v305[2] = v300;
                    v305[3] = v301;
                    *((void *)v305 + 2) = v302;
                    uint64_t v296 = (char *)(v305 + 7);
                    v305[6] = v303;
                  }
                  else
                  {
                    uint64_t v306 = *(float **)(v248 + 48);
                    unint64_t v307 = 0x6DB6DB6DB6DB6DB7 * (v305 - v306) + 1;
                    if (v307 > 0x924924924924924) {
                      goto LABEL_2244;
                    }
                    unint64_t v308 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v304 - (void)v306) >> 2);
                    if (2 * v308 > v307) {
                      unint64_t v307 = 2 * v308;
                    }
                    if (v308 >= 0x492492492492492) {
                      unint64_t v309 = 0x924924924924924;
                    }
                    else {
                      unint64_t v309 = v307;
                    }
                    if (v309 > 0x924924924924924) {
                      sub_1D0DE8CE0();
                    }
                    long long v310 = (char *)operator new(28 * v309);
                    int v311 = (float *)&v310[4 * (v305 - v306)];
                    *int v311 = v298;
                    v311[1] = v299;
                    v311[2] = v300;
                    v311[3] = v301;
                    *((void *)v311 + 2) = v302;
                    v311[6] = v303;
                    if (v305 == v306)
                    {
                      uint64_t v314 = &v310[4 * (v305 - v306)];
                    }
                    else
                    {
                      uint64_t v312 = 0;
                      do
                      {
                        float32x2_t v313 = (char *)&v311[v312];
                        *(_OWORD *)(v313 - 28) = *(_OWORD *)&v305[v312 - 7];
                        *(void *)(v313 - 12) = *(void *)&v305[v312 - 3];
                        *((float *)v313 - 1) = v305[v312 - 1];
                        v312 -= 7;
                      }
                      while (&v305[v312] != v306);
                      uint64_t v314 = (char *)&v311[v312];
                    }
                    float32x2_t v315 = &v310[28 * v309];
                    uint64_t v296 = (char *)(v311 + 7);
                    *(void *)(v248 + 48) = v314;
                    *(void *)(v248 + 56) = v311 + 7;
                    *(void *)(v248 + 64) = v315;
                    if (v306) {
                      operator delete(v306);
                    }
                  }
                  *(void *)(v248 + 56) = v296;
                }
              }
              uint64_t v248 = *(void *)(v1921 + 128);
            }
            if (*(int *)(v248 + 8) < 1) {
              goto LABEL_498;
            }
            uint64_t v317 = 0;
            BOOL v318 = 1;
            int v319 = texture;
            while (2)
            {
              if (!v318) {
                goto LABEL_534;
              }
              int v320 = v319;
              int v319 = *(__CVBuffer **)(*(void *)(v248 + 24) + 8 * v317);
              if (***(void ***)(v248 + 72))
              {
                if (v320)
                {
                  if (v319)
                  {
                    if (CVPixelBufferGetIOSurface(v320))
                    {
                      if (CVPixelBufferGetIOSurface(v319))
                      {
                        *(_OWORD *)v2013 = xmmword_1F26F5658;
                        *(void *)&v2013[16] = qword_1F26F5668;
                        unsigned int v321 = CVPixelBufferGetWidth(v320);
                        unsigned int v322 = CVPixelBufferGetHeight(v320);
                        unsigned int v323 = CVPixelBufferGetWidth(v319);
                        unsigned int v324 = CVPixelBufferGetHeight(v319);
                        *(void *)&buf[32] = 0;
                        *(_OWORD *)int buf = 0u;
                        int32x2_t v325 = (int32x2_t)vmin_u32((uint32x2_t)(*(void *)&vmax_s32((int32x2_t)__PAIR64__(v324, v323), 0) & 0xFFFFFFFEFFFFFFFELL), (uint32x2_t)(*(void *)&vshr_n_u32((uint32x2_t)vmax_s32((int32x2_t)__PAIR64__(v322, v321), 0), 1uLL) & 0xFFFFFFFEFFFFFFFELL));
                        *(uint64x2_t *)&uint8_t buf[16] = vshll_n_u32((uint32x2_t)vadd_s32(v325, v325), 0x10uLL);
                        *(int32x2_t *)&buf[40] = v325;
                        CVPixelBufferGetIOSurface(v320);
                        CVPixelBufferGetIOSurface(v319);
                        int v326 = IOSurfaceAcceleratorTransformSurface();
                        BOOL v318 = v326 == 0;
                        if (v326)
                        {
                          CFStringRef v327 = CFCopyDescription(v320);
                          CFStringRef v328 = CFCopyDescription(v319);
                          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                            && __cxa_guard_acquire(&qword_1EB9F1610))
                          {
                            qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                            __cxa_guard_release(&qword_1EB9F1610);
                          }
                          uint64_t v329 = (id)qword_1EB9F1620;
                          if (os_log_type_enabled(v329, OS_LOG_TYPE_ERROR))
                          {
                            cva::ItemHandler::ItemHandler((cva::ItemHandler *)memptr, v327);
                            cva::ItemHandler::getValue<std::string>();
                          }

                          CFRelease(v327);
                          CFRelease(v328);
                        }
LABEL_482:
                        uint64_t v248 = *(void *)(v1921 + 128);
                        if (++v317 >= *(int *)(v248 + 8))
                        {
                          if (v318)
                          {
LABEL_498:
                            CVPixelBufferRelease(texture);
                            kdebug_trace();
                            LODWORD(v237) = (unint64_t)v1857 >> 4;
                            goto LABEL_499;
                          }
LABEL_534:
                          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                            && __cxa_guard_acquire(&qword_1EB9F1610))
                          {
                            qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                            __cxa_guard_release(&qword_1EB9F1610);
                          }
                          int v364 = (id)qword_1EB9F1620;
                          if (os_log_type_enabled(v364, OS_LOG_TYPE_ERROR))
                          {
                            *(_WORD *)int buf = 0;
                            _os_log_error_impl(&dword_1D0DBD000, v364, OS_LOG_TYPE_ERROR, "failure during hardware scaling", buf, 2u);
                          }
LABEL_537:

LABEL_2228:
                          CVPixelBufferRelease(texture);
                          if (atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire))
                          {
LABEL_2229:
                            v1820 = (id)qword_1EB9F1620;
                            if (os_log_type_enabled(v1820, OS_LOG_TYPE_ERROR))
                            {
                              *(_WORD *)int buf = 0;
                              _os_log_error_impl(&dword_1D0DBD000, v1820, OS_LOG_TYPE_ERROR, "could not generate image pyramid", buf, 2u);
                            }

                            sub_1D0E1EB5C();
                          }
LABEL_2254:
                          if (__cxa_guard_acquire(&qword_1EB9F1610))
                          {
                            qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                            __cxa_guard_release(&qword_1EB9F1610);
                          }
                          goto LABEL_2229;
                        }
                        continue;
                      }
                      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                        && __cxa_guard_acquire(&qword_1EB9F1610))
                      {
                        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                        __cxa_guard_release(&qword_1EB9F1610);
                      }
                      float32x2_t v330 = (id)qword_1EB9F1620;
                      if (os_log_type_enabled(v330, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)int buf = 0;
                        _os_log_error_impl(&dword_1D0DBD000, v330, OS_LOG_TYPE_ERROR, "output pixel buffer must be backed by an IOSurface", buf, 2u);
                      }
                    }
                    else
                    {
                      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                        && __cxa_guard_acquire(&qword_1EB9F1610))
                      {
                        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                        __cxa_guard_release(&qword_1EB9F1610);
                      }
                      float32x2_t v330 = (id)qword_1EB9F1620;
                      if (os_log_type_enabled(v330, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)int buf = 0;
                        _os_log_error_impl(&dword_1D0DBD000, v330, OS_LOG_TYPE_ERROR, "input pixel buffer must be backed by an IOSurface", buf, 2u);
                      }
                    }
                  }
                  else
                  {
                    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                      && __cxa_guard_acquire(&qword_1EB9F1610))
                    {
                      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                      __cxa_guard_release(&qword_1EB9F1610);
                    }
                    float32x2_t v330 = (id)qword_1EB9F1620;
                    if (os_log_type_enabled(v330, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)int buf = 0;
                      _os_log_error_impl(&dword_1D0DBD000, v330, OS_LOG_TYPE_ERROR, "no output defined", buf, 2u);
                    }
                  }
                }
                else
                {
                  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                    && __cxa_guard_acquire(&qword_1EB9F1610))
                  {
                    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                    __cxa_guard_release(&qword_1EB9F1610);
                  }
                  float32x2_t v330 = (id)qword_1EB9F1620;
                  if (os_log_type_enabled(v330, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)int buf = 0;
                    _os_log_error_impl(&dword_1D0DBD000, v330, OS_LOG_TYPE_ERROR, "no input defined", buf, 2u);
                  }
                }
              }
              else
              {
                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                  && __cxa_guard_acquire(&qword_1EB9F1610))
                {
                  qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                  __cxa_guard_release(&qword_1EB9F1610);
                }
                float32x2_t v330 = (id)qword_1EB9F1620;
                if (os_log_type_enabled(v330, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)int buf = 0;
                  _os_log_error_impl(&dword_1D0DBD000, v330, OS_LOG_TYPE_ERROR, "hardware scaler not initialized", buf, 2u);
                }
              }
              break;
            }

            BOOL v318 = 0;
            goto LABEL_482;
          }
          float32x4_t v264 = *(void **)(v1921 + 128);
          int v265 = (char *)v264[3];
          float32x2_t v266 = (char *)v264[4];
          uint64_t v267 = v266 - v265;
          if (v258 >= (int)((unint64_t)(v266 - v265) >> 3))
          {
            unint64_t v268 = v264[5];
            if ((unint64_t)v266 < v268)
            {
              *(void *)float32x2_t v266 = 0;
              unsigned int v269 = v266 + 8;
              goto LABEL_407;
            }
            uint64_t v270 = v267 >> 3;
            unint64_t v271 = (v267 >> 3) + 1;
            if (v271 >> 61) {
              abort();
            }
            uint64_t v272 = v268 - (void)v265;
            if (v272 >> 2 > v271) {
              unint64_t v271 = v272 >> 2;
            }
            if ((unint64_t)v272 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v273 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v273 = v271;
            }
            if (v273)
            {
              if (v273 >> 61) {
                sub_1D0DE8CE0();
              }
              int v274 = (char *)operator new(8 * v273);
            }
            else
            {
              int v274 = 0;
            }
            uint64_t v275 = &v274[8 * v270];
            float v276 = &v274[8 * v273];
            *(void *)uint64_t v275 = 0;
            unsigned int v269 = v275 + 8;
            if (v266 == v265)
            {
              v264[3] = v275;
              v264[4] = v269;
              v264[5] = v276;
              uint64_t v263 = PixelFormatType;
              goto LABEL_405;
            }
            unint64_t v277 = v266 - v265 - 8;
            if (v277 <= 0x77) {
              goto LABEL_2279;
            }
            if (&v274[v267 - (v277 & 0xFFFFFFFFFFFFFFF8) - 8] < v266
              && &v266[-(v277 & 0xFFFFFFFFFFFFFFF8) - 8] < v275)
            {
              goto LABEL_2279;
            }
            uint64_t v279 = (v277 >> 3) + 1;
            __float2 v280 = &v274[8 * v270 - 16];
            __float2 v281 = v266 - 32;
            uint64_t v282 = v279 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v283 = *((_OWORD *)v281 + 1);
              *((_OWORD *)v280 - 1) = *(_OWORD *)v281;
              *(_OWORD *)__float2 v280 = v283;
              *(_OWORD *)__float2 v281 = 0uLL;
              *((_OWORD *)v281 + 1) = 0uLL;
              v281 -= 32;
              v280 -= 32;
              v282 -= 4;
            }
            while (v282);
            v275 -= 8 * (v279 & 0x3FFFFFFFFFFFFFFCLL);
            v266 -= 8 * (v279 & 0x3FFFFFFFFFFFFFFCLL);
            if (v279 != (v279 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_2279:
              do
              {
                uint64_t v284 = *((void *)v266 - 1);
                v266 -= 8;
                *((void *)v275 - 1) = v284;
                v275 -= 8;
                *(void *)float32x2_t v266 = 0;
              }
              while (v266 != v265);
            }
            float32x2_t v266 = (char *)v264[3];
            float32x4_t v285 = (char *)v264[4];
            v264[3] = v275;
            v264[4] = v269;
            v264[5] = v276;
            if (v285 == v266)
            {
              uint64_t v263 = PixelFormatType;
              if (v266) {
                goto LABEL_406;
              }
            }
            else
            {
              uint64_t v263 = PixelFormatType;
              do
              {
                float32x4_t v287 = (__CVBuffer *)*((void *)v285 - 1);
                v285 -= 8;
                float32x4_t v286 = v287;
                if (v287) {
                  CVPixelBufferRelease(v286);
                }
              }
              while (v285 != v266);
LABEL_405:
              if (v266) {
LABEL_406:
              }
                operator delete(v266);
            }
LABEL_407:
            v264[4] = v269;
            int v265 = *(char **)(*(void *)(v1921 + 128) + 24);
          }
          int v288 = sub_1D0DD6124((CVPixelBufferRef *)&v265[8 * v258], (cva *)v262, v260, v263);
          if (v288 == 2)
          {
            IOSurface = CVPixelBufferGetIOSurface(*(CVPixelBufferRef *)(*(void *)(*(void *)(v1921 + 128) + 24)
                                                                      + 8 * v258));
            if (IOSurface) {
              IOSurfaceSetValue(IOSurface, keyb, @"AppleCVA:ImagePyramid");
            }
          }
          else if (!v288)
          {
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EB9F1610))
            {
              qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
              __cxa_guard_release(&qword_1EB9F1610);
            }
            int v364 = (id)qword_1EB9F1620;
            if (os_log_type_enabled(v364, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)int buf = 0;
              _os_log_error_impl(&dword_1D0DBD000, v364, OS_LOG_TYPE_ERROR, "failed to create/update buffer", buf, 2u);
            }
            goto LABEL_537;
          }
          unint64_t v262 = v262 >> 1;
          uint64_t v260 = v260 >> 1;
          if (++v258 == v249)
          {
            uint64_t v248 = *(void *)(v1921 + 128);
            goto LABEL_418;
          }
          continue;
        }
      }
LABEL_499:
      *(_OWORD *)v1964 = 0u;
      *(_OWORD *)v1965 = 0u;
      int v1966 = 1065353216;
      kdebug_trace();
      (*(void (**)(void, uint64_t ***, void **))(**(void **)(*a2 + 160) + 24))(*(void *)(*a2 + 160), v1890, v1964);
      kdebug_trace();
      uint64_t v332 = *(void *)(v1888 + 24);
      uint64_t v331 = *(void *)(v1888 + 32);
      *(void *)&uint8_t buf[8] = 0;
      *(void *)int buf = 0;
      v1963 = 0;
      v1961 = 0;
      v1962 = 0;
      uint64_t v333 = v331 - v332;
      if (v331 != v332)
      {
        if (v333 < 0) {
          abort();
        }
        uint64_t v334 = operator new(v331 - v332);
        uint64_t v335 = 2 * (v333 >> 4);
        uint64_t v336 = &v334[v335];
        v1961 = v334;
        v1963 = &v334[v335];
        do
        {
          *uint64_t v334 = 0;
          v334[1] = 0;
          v334 += 2;
          v335 -= 2;
        }
        while (v335 * 8);
        v1962 = v336;
      }
      if (!texture)
      {
LABEL_739:
        uint64_t v594 = *(void *)(v1888 + 24);
        if (*(void *)(v1888 + 32) != v594)
        {
          uint64_t v595 = 0;
          unint64_t v596 = 0;
          do
          {
            v597 = **(void ***)(v594 + v595);
            if (v597[16])
            {
              v598 = (uint64_t *)(*(void *)(v597[12] + ((v597[15] >> 4) & 0xFFFFFFFFFFFFFF8))
                               + 32 * (v597[15] & 0x7FLL));
              uint64_t v600 = *v598;
              v599 = (std::__shared_weak_count *)v598[1];
              if (v599)
              {
                atomic_fetch_add_explicit(&v599->__shared_owners_, 1uLL, memory_order_relaxed);
                if (!atomic_fetch_add(&v599->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v599->__on_zero_shared)(v599);
                  std::__shared_weak_count::__release_weak(v599);
                }
              }
              if (*(void *)((char *)v1961 + v595))
              {
                __int32 v601 = *(_DWORD *)(v600 + 252);
                if (v601)
                {
                  if ((v601 & 0xFFFFFFFC) == 0xC8) {
                    __int32 v601 = 6;
                  }
                  v2022[0].i32[0] = v601;
                  cva::ItemHandler::createValue<int>();
                }
              }
            }
            ++v596;
            uint64_t v594 = *(void *)(v1888 + 24);
            v595 += 16;
          }
          while (v596 < (*(void *)(v1888 + 32) - v594) >> 4);
        }
        v602 = operator new(0x28uLL);
        v602[1] = 0;
        v602[2] = 0;
        void *v602 = &unk_1F26F4AD8;
        cva::ArrayHandler::ArrayHandler((cva::ArrayHandler *)(v602 + 3));
        *(void *)int buf = v602 + 3;
        *(void *)&uint8_t buf[8] = v602;
        v603 = v1961;
        v604 = v1962;
        while (v603 != v604)
        {
          if (*v603)
          {
            cva::ItemHandler::ItemHandler();
            cva::ArrayHandler::addItem((cva::ArrayHandler *)(v602 + 3), (const cva::ItemHandler *)v2022);
            cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v2022);
          }
          v603 += 2;
        }
        kdebug_trace();
        atomic_fetch_add_explicit(v602 + 1, 1uLL, memory_order_relaxed);
        sub_1D0E08378();
      }
      uint64_t v337 = (void *)*a2;
      uint64_t v338 = *(void *)(*a2 + 96);
      uint64_t v339 = *(void *)(*a2 + 104);
      unint64_t v340 = (v339 - v338) >> 5;
      uint64_t v1851 = v1857 << 28;
      unint64_t v1852 = (int)(v1857 >> 4);
      unint64_t v341 = v1852 - v340;
      if (v1852 <= v340)
      {
        if (v1852 < v340)
        {
          uint64_t v359 = v338 + 32 * v1852;
          while (v339 != v359)
          {
            uint64_t v360 = *(void **)(v339 - 8);
            if (v360)
            {
              free(v360);
              *(void *)(v339 - 8) = 0;
            }
            v339 -= 32;
          }
          v337[13] = v359;
        }
      }
      else
      {
        uint64_t v342 = v337[14];
        if (v341 <= (v342 - v339) >> 5)
        {
          uint64_t v361 = v339 + 32 * v341;
          uint64_t v362 = (void *)(v339 + 8);
          uint64_t v363 = 32 * v1852 - 32 * v340;
          do
          {
            *uint64_t v362 = 0;
            v362[1] = 0;
            v362[2] = 0;
            v362 += 4;
            v363 -= 32;
          }
          while (v363);
          v337[13] = v361;
        }
        else
        {
          if (v1851 < 0) {
            abort();
          }
          uint64_t v343 = v342 - v338;
          uint64_t v344 = v343 >> 4;
          if (v343 >> 4 <= v1852) {
            uint64_t v344 = (int)(v1857 >> 4);
          }
          if ((unint64_t)v343 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v345 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v345 = v344;
          }
          if (v345 >> 59) {
            sub_1D0DE8CE0();
          }
          float v346 = (char *)operator new(32 * v345);
          float v347 = &v346[32 * v340];
          float v348 = &v346[32 * v1852];
          uint64_t v349 = 32 * v1852 - 32 * v340;
          float v350 = v347 + 8;
          do
          {
            *float v350 = 0;
            v350[1] = 0;
            v350[2] = 0;
            v350 += 4;
            v349 -= 32;
          }
          while (v349);
          float v351 = &v346[32 * v345];
          float v352 = (char *)v337[12];
          float v353 = (char *)v337[13];
          if (v353 == v352)
          {
            v337[12] = v347;
            v337[13] = v348;
            v337[14] = v351;
          }
          else
          {
            uint64_t v354 = 0;
            do
            {
              int v355 = &v347[v354];
              int v356 = &v353[v354];
              *((void *)v355 - 4) = *(void *)&v353[v354 - 32];
              *((void *)v355 - 3) = *(void *)&v353[v354 - 24];
              *((void *)v355 - 2) = *(void *)&v353[v354 - 16];
              *((void *)v355 - 1) = *(void *)&v353[v354 - 8];
              *((_OWORD *)v356 - 2) = 0uLL;
              *((_OWORD *)v356 - 1) = 0uLL;
              v354 -= 32;
            }
            while (&v353[v354] != v352);
            float v353 = (char *)v337[12];
            uint64_t v357 = (char *)v337[13];
            v337[12] = &v347[v354];
            v337[13] = v348;
            v337[14] = v351;
            while (v357 != v353)
            {
              uint64_t v358 = (void *)*((void *)v357 - 1);
              if (v358)
              {
                free(v358);
                *((void *)v357 - 1) = 0;
              }
              v357 -= 32;
            }
          }
          if (v353) {
            operator delete(v353);
          }
        }
      }
      v1959 = 0;
      v1958 = 0;
      v1960 = 0;
      if (v1851)
      {
        if (v1851 < 0) {
          abort();
        }
        uint64_t v365 = (char *)operator new(104 * (int)v1852);
        uint64_t v366 = &v365[104 * (int)v1852];
        v1958 = v365;
        v1960 = v366;
        __asm { FMOV            V1.2S, #1.0 }
        id v368 = v365;
        do
        {
          *(void *)id v368 = &unk_1F26F4478;
          *((void *)v368 + 1) = 0x100000001;
          *((_DWORD *)v368 + 4) = 1065353216;
          *(void *)(v368 + 20) = 0;
          *(void *)(v368 + 28) = 0x3F80000000000000;
          *(void *)(v368 + 36) = 0;
          *((_DWORD *)v368 + 11) = 0;
          *((void *)v368 + 7) = 0;
          *((void *)v368 + 8) = 0;
          *((void *)v368 + 9) = 0;
          *((void *)v368 + 10) = 0x3F80000000000000;
          *((void *)v368 + 6) = _D1;
          *((_DWORD *)v368 + 17) = 1065353216;
          v365 += 104;
          *((void *)v368 + 11) = 0;
          *((_DWORD *)v368 + 24) = 0;
          v368 += 104;
        }
        while (v368 != v366);
        v1959 = v366;
        v1874 = operator new(36 * v1852);
        bzero(v1874, 36 * ((36 * v1852 - 36) / 0x24) + 36);
      }
      else
      {
        v1874 = 0;
      }
      if ((int)v237 < 1)
      {
        v588 = v1874;
        if (!v1874) {
          goto LABEL_732;
        }
        goto LABEL_731;
      }
      uint64_t v369 = 0;
      uint64_t v1871 = ((unint64_t)v1857 >> 4);
      uint64_t v1877 = v1871;
      __asm { FMOV            V0.4S, #4.0 }
      float32x4_t v1853 = _Q0;
      while (2)
      {
        float v371 = (*v1890)[2 * v369];
        uint64_t v373 = *(void *)(*v371 + 8);
        float v372 = *(std::__shared_weak_count **)(*v371 + 16);
        if (v372
          && (atomic_fetch_add_explicit(&v372->__shared_owners_, 1uLL, memory_order_relaxed),
              !atomic_fetch_add(&v372->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
        {
          ((void (*)(std::__shared_weak_count *))v372->__on_zero_shared)(v372);
          std::__shared_weak_count::__release_weak(v372);
          if (!v373) {
            goto LABEL_553;
          }
        }
        else if (!v373)
        {
LABEL_553:
          kdebug_trace();
          float v374 = (char *)operator new(0x78uLL);
          *((void *)v374 + 1) = 0;
          *((void *)v374 + 2) = 0;
          *(void *)float v374 = &unk_1F26F4C28;
          *(_OWORD *)(v374 + 40) = 0u;
          *(_OWORD *)(v374 + 56) = 0u;
          *(_OWORD *)(v374 + 72) = 0u;
          *(_OWORD *)(v374 + 88) = 0u;
          *(_OWORD *)(v374 + 104) = 0u;
          *(_OWORD *)(v374 + 24) = 0u;
          uint64_t v375 = *v371;
          v376 = *(std::__shared_weak_count **)(*v371 + 16);
          *(void *)(v375 + 8) = v374 + 24;
          *(void *)(v375 + 16) = v374;
          if (v376 && !atomic_fetch_add(&v376->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v376->__on_zero_shared)(v376);
            std::__shared_weak_count::__release_weak(v376);
          }
          uint64_t v377 = *(void *)(*a2 + 16);
          float v378 = *(std::__shared_weak_count **)(*v371 + 16);
          *(void *)int buf = *(void *)(*v371 + 8);
          *(void *)&uint8_t buf[8] = v378;
          if (v378) {
            atomic_fetch_add_explicit(&v378->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(uint64_t))(*(void *)v377 + 8))(v377);
          if (v378 && !atomic_fetch_add(&v378->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v378->__on_zero_shared)(v378);
            std::__shared_weak_count::__release_weak(v378);
          }
          uint64_t v379 = *(void *)(*a2 + 16);
          if (*(void *)(*a2 + 152))
          {
            float v380 = *(std::__shared_weak_count **)(*v371 + 16);
            *(void *)int buf = *(void *)(*v371 + 8);
            *(void *)&uint8_t buf[8] = v380;
            if (v380) {
              atomic_fetch_add_explicit(&v380->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            (*(void (**)(uint64_t))(*(void *)v379 + 16))(v379);
          }
          else
          {
            float v380 = *(std::__shared_weak_count **)(*v371 + 16);
            *(void *)int buf = *(void *)(*v371 + 8);
            *(void *)&uint8_t buf[8] = v380;
            if (v380) {
              atomic_fetch_add_explicit(&v380->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            (*(void (**)(uint64_t, void))(*(void *)v379 + 16))(v379, 0);
          }
          if (v380 && !atomic_fetch_add(&v380->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v380->__on_zero_shared)(v380);
            std::__shared_weak_count::__release_weak(v380);
          }
          kdebug_trace();
        }
        kdebug_trace();
        uint64_t v381 = *a2;
        uint64_t v383 = *(void *)(*v371 + 136);
        float v382 = *(std::__shared_weak_count **)(*v371 + 144);
        keyc = v371;
        if (v382
          && (atomic_fetch_add_explicit(&v382->__shared_owners_, 1uLL, memory_order_relaxed),
              !atomic_fetch_add(&v382->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
        {
          ((void (*)(std::__shared_weak_count *))v382->__on_zero_shared)(v382);
          std::__shared_weak_count::__release_weak(v382);
          if (v383) {
            goto LABEL_577;
          }
        }
        else if (v383)
        {
          goto LABEL_577;
        }
        v408 = (void *)(*(void *)(v381 + 16) + 24);
        float v409 = (char *)operator new(0x480uLL);
        *((void *)v409 + 1) = 0;
        *((void *)v409 + 2) = 0;
        *(void *)float v409 = &unk_1F26F4D40;
        *((void *)v409 + 3) = 0xFFEFFFFFFFFFFFFFLL;
        *((void *)v409 + 4) = 850045863;
        *((_OWORD *)v409 + 7) = 0u;
        *((_OWORD *)v409 + 8) = 0u;
        *((_OWORD *)v409 + 9) = 0u;
        *((_OWORD *)v409 + 10) = 0u;
        *((_OWORD *)v409 + 11) = 0u;
        *((_OWORD *)v409 + 12) = 0u;
        *((_OWORD *)v409 + 13) = 0u;
        *((_OWORD *)v409 + 14) = 0u;
        *((_OWORD *)v409 + 15) = 0u;
        *((void *)v409 + 31) = 0;
        *((void *)v409 + 32) = 0;
        *(_OWORD *)(v409 + 40) = 0u;
        *(_OWORD *)(v409 + 56) = 0u;
        *(_OWORD *)(v409 + 72) = 0u;
        *(_OWORD *)(v409 + 88) = 0u;
        v409[104] = 0;
        *((_DWORD *)v409 + 47) = 1065353216;
        *((_DWORD *)v409 + 51) = 1065353216;
        *((_DWORD *)v409 + 55) = 1065353216;
        *((void *)v409 + 28) = 0;
        *((_DWORD *)v409 + 58) = 0;
        *((_DWORD *)v409 + 64) = 0;
        *((void *)v409 + 30) = 0;
        *((void *)v409 + 33) = 850045863;
        *((_OWORD *)v409 + 17) = 0u;
        *((_OWORD *)v409 + 18) = 0u;
        *((_OWORD *)v409 + 19) = 0u;
        *((void *)v409 + 40) = 0;
        sub_1D0E6D8D0((uint64_t *)v409 + 41, v408);
        sub_1D0E6D8D0((uint64_t *)v409 + 59, v408);
        sub_1D0E6D8D0((uint64_t *)v409 + 77, v408);
        sub_1D0E6D8D0((uint64_t *)v409 + 95, v408);
        *((_DWORD *)v409 + 226) = 1;
        *((void *)v409 + 114) = 850045863;
        *(_OWORD *)(v409 + 920) = 0u;
        *(_OWORD *)(v409 + 936) = 0u;
        *(_OWORD *)(v409 + 952) = 0u;
        *((void *)v409 + 121) = 0;
        *((void *)v409 + 122) = 850045863;
        *(_OWORD *)(v409 + 1048) = 0u;
        *(_OWORD *)(v409 + 1064) = 0u;
        *((_DWORD *)v409 + 270) = 0;
        *(_OWORD *)(v409 + 984) = 0u;
        *(_OWORD *)(v409 + 1000) = 0u;
        *(_OWORD *)(v409 + 1016) = 0u;
        *(_OWORD *)(v409 + 1025) = 0u;
        *((void *)v409 + 136) = 850045863;
        *(_OWORD *)(v409 + 1096) = 0u;
        *(_OWORD *)(v409 + 1112) = 0u;
        *(_OWORD *)(v409 + 1128) = 0u;
        *((void *)v409 + 143) = 0;
        uint64_t v410 = *v371;
        v411 = *(std::__shared_weak_count **)(*v371 + 144);
        *(void *)(v410 + 136) = v409 + 24;
        *(void *)(v410 + 144) = v409;
        if (v411 && !atomic_fetch_add(&v411->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v411->__on_zero_shared)(v411);
          std::__shared_weak_count::__release_weak(v411);
        }
LABEL_577:
        uint64_t v385 = *(uint64_t **)(*v371 + 24);
        unsigned int v384 = *(std::__shared_weak_count **)(*v371 + 32);
        if (v384)
        {
          atomic_fetch_add_explicit(&v384->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v384->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v384->__on_zero_shared)(v384);
            std::__shared_weak_count::__release_weak(v384);
          }
        }
        int32x4_t v386 = *(_OWORD *)(*v371 + 136);
        unsigned int v387 = *(std::__shared_weak_count **)(*v371 + 144);
        if (v387) {
          atomic_fetch_add_explicit(&v387->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v388 = v386;
        uint64_t v1879 = v369;
        if (!*(unsigned char *)(v386 + 1016))
        {
          uint64_t v398 = *v385;
          if (*(unsigned char *)(*v385 + 16))
          {
            float v399 = *(uint64_t **)(v381 + 32);
            long long v400 = *(_OWORD *)(v398 + 144);
            unsigned int v401 = *(std::__shared_weak_count **)(v398 + 152);
            if (v401) {
              atomic_fetch_add_explicit(&v401->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v387) {
              atomic_fetch_add_explicit(&v387->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            *(unsigned char *)(v386 + 1016) = 1;
            v1922 = v401;
            if ((void)v400)
            {
              *(_OWORD *)v1906 = v400;
              int32x4_t v1859 = (int32x4_t)v386;
              kdebug_trace();
              if (v401) {
                atomic_fetch_add_explicit(&v401->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              v402 = *(std::__shared_weak_count **)(v388 + 1032);
              *(_OWORD *)(v388 + 1024) = *(_OWORD *)v1906;
              if (v402 && !atomic_fetch_add(&v402->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v402->__on_zero_shared)(v402);
                std::__shared_weak_count::__release_weak(v402);
              }
              uint64_t v403 = *v399;
              if (v387) {
                atomic_fetch_add_explicit(&v387->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              v404 = (std::__shared_weak_count *)operator new(0xB8uLL);
              v404->__shared_owners_ = 0;
              v404->__shared_weak_owners_ = 0;
              v404->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F5168;
              int v405 = operator new(0x30uLL);
              int32x4_t *v405 = &unk_1F26F38B8;
              v405[1] = sub_1D0E03788;
              v405[2] = 0;
              v405[3] = v403;
              *((int32x4_t *)v405 + 2) = v1859;
              v404[1].__shared_owners_ = 850045863;
              v404[4].__vftable = (std::__shared_weak_count_vtbl *)1018212795;
              *(_OWORD *)&v404[1].__shared_weak_owners_ = 0u;
              *(_OWORD *)&v404[2].__shared_owners_ = 0u;
              v404[3].std::__shared_count = 0u;
              v404[3].__shared_weak_owners_ = 0;
              *(_OWORD *)&v404[4].__shared_owners_ = 0u;
              v404[5].std::__shared_count = 0u;
              *(_OWORD *)((char *)&v404[5].__shared_owners_ + 1) = 0u;
              v404[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4568;
              v404[7].__shared_owners_ = (uint64_t)sub_1D0E05974((uint64_t)v405);
              (*(void (**)(int32x4_t *))(*v405 + 40))((int32x4_t *)v405);
              uint64_t v406 = *(void *)(v403 + 64);
              *(void *)int buf = v404 + 1;
              *(void *)&uint8_t buf[8] = v404;
              atomic_fetch_add_explicit(&v404->__shared_owners_, 1uLL, memory_order_relaxed);
              (*(void (**)(uint64_t, unsigned char *))(*(void *)v406 + 16))(v406, buf);
              unsigned int v407 = *(std::__shared_weak_count **)&buf[8];
              if (*(void *)&buf[8]
                && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v407->__on_zero_shared)(v407);
                std::__shared_weak_count::__release_weak(v407);
              }
              if (*(unsigned char *)(v403 + 80))
              {
                *(void *)int buf = (char *)v404 + 32;
                uint8_t buf[8] = 1;
                std::mutex::lock((std::mutex *)&v404[1].__shared_owners_);
                if (LOBYTE(v404[6].__vftable)) {
                  goto LABEL_615;
                }
                do
                  std::condition_variable::wait((std::condition_variable *)&v404[4], (std::unique_lock<std::mutex> *)buf);
                while (!LOBYTE(v404[6].__vftable));
                if (buf[8]) {
LABEL_615:
                }
                  std::mutex::unlock(*(std::mutex **)buf);
              }
              if (!atomic_fetch_add(&v404->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
                goto LABEL_680;
              }
            }
            else
            {
              kdebug_trace();
              (*(void (**)(unsigned char *__return_ptr))(**(void **)(*v399 + 16) + 16))(buf);
              uint64_t v530 = *(void *)buf;
              *(void *)int buf = 0;
              uint64_t v531 = *(void *)(v388 + 72);
              *(void *)(v388 + 72) = v530;
              if (v531)
              {
                (*(void (**)(uint64_t))(*(void *)v531 + 8))(v531);
                uint64_t v532 = *(void *)buf;
                *(void *)int buf = 0;
                if (v532) {
                  (*(void (**)(uint64_t))(*(void *)v532 + 8))(v532);
                }
              }
              (*(void (**)(unsigned char *__return_ptr))(**(void **)(*v399 + 16) + 24))(buf);
              v533 = (char *)operator new(0x60uLL);
              *((void *)v533 + 3) = *(void *)buf;
              *((void *)v533 + 1) = 0;
              *((void *)v533 + 2) = 0;
              *(void *)v533 = &unk_1F26F4FA8;
              *((void *)v533 + 4) = 850045863;
              *(_OWORD *)(v533 + 40) = 0u;
              *(_OWORD *)(v533 + 56) = 0u;
              *(_OWORD *)(v533 + 72) = 0u;
              *((void *)v533 + 11) = 0;
              *(void *)&long long v534 = v533 + 24;
              *((void *)&v534 + 1) = v533;
              v404 = *(std::__shared_weak_count **)(v388 + 1032);
              *(_OWORD *)(v388 + 1024) = v534;
              if (v404 && !atomic_fetch_add(&v404->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
LABEL_680:
                ((void (*)(std::__shared_weak_count *))v404->__on_zero_shared)(v404);
                std::__shared_weak_count::__release_weak(v404);
              }
            }
            kdebug_trace();
            if (v387 && !atomic_fetch_add(&v387->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v387->__on_zero_shared)(v387);
              std::__shared_weak_count::__release_weak(v387);
            }
            if (v1922 && !atomic_fetch_add(&v1922->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v1922->__on_zero_shared)(v1922);
              std::__shared_weak_count::__release_weak(v1922);
            }
            uint64_t v536 = *(void *)(*v385 + 144);
            v535 = *(std::__shared_weak_count **)(*v385 + 152);
            if (v535
              && (atomic_fetch_add_explicit(&v535->__shared_owners_, 1uLL, memory_order_relaxed),
                  !atomic_fetch_add(&v535->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
            {
              ((void (*)(std::__shared_weak_count *))v535->__on_zero_shared)(v535);
              std::__shared_weak_count::__release_weak(v535);
              if (!v536)
              {
LABEL_690:
                long long v537 = *(_OWORD *)(v388 + 1024);
                uint64_t v538 = *(void *)(v388 + 1032);
                if (v538) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v538 + 8), 1uLL, memory_order_relaxed);
                }
                v539 = *(std::__shared_weak_count **)(*v385 + 152);
                *(_OWORD *)(*v385 + 144) = v537;
                if (v539 && !atomic_fetch_add(&v539->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v539->__on_zero_shared)(v539);
                  std::__shared_weak_count::__release_weak(v539);
                }
              }
            }
            else if (!v536)
            {
              goto LABEL_690;
            }
          }
        }
        if (v387 && !atomic_fetch_add(&v387->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v387->__on_zero_shared)(v387);
          std::__shared_weak_count::__release_weak(v387);
        }
        kdebug_trace();
        uint64_t v389 = *a2;
        float v390 = v1958;
        uint64_t v392 = *(void *)(*keyc + 8);
        uint64_t v391 = *(atomic_ullong **)(*keyc + 16);
        uint64_t v393 = *keyc;
        __p[0] = (void *)v392;
        __p[1] = v391;
        if (v391) {
          atomic_fetch_add_explicit(v391 + 1, 1uLL, memory_order_relaxed);
        }
        uint64_t v394 = *(unsigned int *)(v389 + 48);
        uint64_t v395 = v394 | (v394 << 32);
        if (v394 > *(_DWORD *)(v392 + 24) || v394 > *(_DWORD *)(v392 + 28))
        {
          uint64_t v396 = *(void **)(v392 + 40);
          if (v396)
          {
            free(v396);
            *(void *)(v392 + 40) = 0;
          }
          *(void *)(v392 + 16) = 0;
          *(void *)(v392 + 24) = v395;
          *(void *)(v392 + 32) = ((unint64_t)(((v394 + 15) & 0xFFFFFFF0) >> 4) << 36) | 1;
          *(void *)int buf = v394 * (unint64_t)((v394 + 15) & 0xFFFFFFF0);
          if (*(void *)buf) {
            unsigned int v397 = malloc_type_malloc(*(size_t *)buf, 0xA153FF5uLL);
          }
          else {
            unsigned int v397 = 0;
          }
          *(void *)(v392 + 40) = v397;
        }
        else
        {
          *(void *)(v392 + 16) = 0;
          *(void *)(v392 + 24) = v395;
        }
        *(void *)&v2013[4] = 0;
        *(_DWORD *)v2013 = 1065353216;
        *(_OWORD *)&v2013[12] = xmmword_1D0E81450;
        if (!*(unsigned char *)(v389 + 136)
          || ((int v412 = llroundf(-1.0 - log2f((float)(int)v394 / *(float *)(v393 + 52))), v412 < 0)
            ? (int v415 = -1)
            : (int v415 = v412),
              (uint64_t v416 = *(void *)(v389 + 128), v417 = *(_DWORD *)(v416 + 8), v417 - 1 >= v415)
            ? (unsigned int v418 = v415)
            : (unsigned int v418 = v417 - 1),
              (v418 & 0x80000000) != 0))
        {
          id v419 = texture;
        }
        else
        {
          if (v417 <= (int)v418)
          {
            id v419 = 0;
            uint64_t v421 = 0;
            v413.i32[0] = 1.0;
            int8x16_t v422 = (int8x16_t)xmmword_1D0E81450;
          }
          else
          {
            id v419 = *(__CVBuffer **)(*(void *)(v416 + 24) + 8 * v418);
            uint64_t v420 = *(void *)(v416 + 48) + 28 * v418;
            v413.i32[0] = *(_DWORD *)v420;
            uint64_t v421 = *(void *)(v420 + 4);
            v414.i64[0] = *(void *)(v420 + 16);
            int8x16_t v422 = vextq_s8(v413, v414, 0xCuLL);
            v422.i32[0] = *(_DWORD *)(v420 + 12);
            v422.i32[3] = *(_DWORD *)(v420 + 24);
          }
          *(void *)&v2013[4] = v421;
          *(_DWORD *)v2013 = v413.i32[0];
          *(_DWORD *)&v2013[12] = v422.i32[0];
          *(void *)&v2013[16] = vextq_s8(v422, v413, 4uLL).u64[0];
          *(_DWORD *)&v2013[24] = v422.i32[3];
        }
        double v423 = 0.0;
        memset(buf, 0, 36);
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1618))
        {
          sub_1D0E225B4();
        }
        uint64_t v424 = v393 + 40;
        uint64_t v425 = (uint64_t)v1874 + 36 * v369;
        uint64_t v426 = (uint64_t)v390 + 104 * v369;
        if (*(unsigned char *)(qword_1EB9F15F8 + 109)) {
          sub_1D0E6520C(v394, v424, (uint64_t)v2013, &v1973, v426, v425, (uint64_t)buf);
        }
        else {
          sub_1D0E64C14(v394, v424, (uint64_t)v2013, (uint64_t)&v1973, v426, v425, (uint64_t)buf, v423);
        }
        signed int v427 = CVPixelBufferGetPixelFormatType(v419);
        kdebug_trace();
        CVPixelBufferLockBaseAddress(v419, 1uLL);
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1618))
        {
          sub_1D0E225B4();
        }
        __asm { FMOV            V0.4S, #1.0 }
        float32x4_t v1923 = _Q0;
        if (*(unsigned char *)(qword_1EB9F15F8 + 109))
        {
          float32x4_t v1907 = (float32x4_t)vdupq_n_s32(0x437F0000u);
          if (v427 > 1278226487)
          {
            if (v427 == 2019963440 || v427 == 2016686640)
            {
              if (CVPixelBufferIsPlanar(v419))
              {
                int WidthOfPlane = CVPixelBufferGetWidthOfPlane(v419, 0);
                int HeightOfPlane = CVPixelBufferGetHeightOfPlane(v419, 0);
                unsigned int BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v419, 0);
                BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(v419, 0);
              }
              else
              {
                int WidthOfPlane = CVPixelBufferGetWidth(v419);
                int HeightOfPlane = CVPixelBufferGetHeight(v419);
                unsigned int BytesPerRowOfPlane = CVPixelBufferGetBytesPerRow(v419);
                BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddress(v419);
              }
              v540 = BaseAddressOfPlane;
              int v541 = *(_DWORD *)(v392 + 24);
              int v542 = *(_DWORD *)(v392 + 28);
              *(float *)v543.i32 = nextafterf((float)(WidthOfPlane - 1), 0.0);
              int32x2_t v1861 = v543;
              *(float *)v544.i32 = nextafterf((float)(HeightOfPlane - 1), 0.0);
              char v529 = 1;
              if (v542 >= 1 && v541 >= 1)
              {
                int v545 = 0;
                int32x4_t v546 = vdupq_n_s32(BytesPerRowOfPlane >> 1);
                float32x4_t v547 = (float32x4_t)vdupq_lane_s32(v1861, 0);
                float32x4_t v548 = (float32x4_t)vdupq_lane_s32(v544, 0);
                float32x4_t v549 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&buf[12], 0);
                float32x4_t v550 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&buf[16], 0);
                float32x4_t v551 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&buf[20], 0);
                float32x4_t v552 = vmulq_n_f32(v1853, *(float *)buf);
                float32x4_t v553 = vmulq_n_f32(v1853, *(float *)&buf[4]);
                float32x4_t v554 = vmulq_n_f32(v1853, *(float *)&buf[8]);
                uint64_t v555 = *(void *)(v392 + 40);
                float32x4_t v556 = vmlaq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshrq_n_u64(*(uint64x2_t *)&buf[20], 0x20uLL), 0), (float32x4_t)xmmword_1D0E81540, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)buf, 0));
                float32x4_t v557 = vmlaq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)&buf[20], 2), (float32x4_t)xmmword_1D0E81540, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&buf[4], 0));
                float32x4_t v558 = vmlaq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)&buf[20], 3), (float32x4_t)xmmword_1D0E81540, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&buf[8], 0));
                do
                {
                  uint64_t v559 = 0;
                  float32x4_t v560 = v558;
                  float32x4_t v561 = v557;
                  float32x4_t v562 = v556;
                  do
                  {
                    float32x4_t v563 = vmaxnmq_f32(vminnmq_f32(vdivq_f32(v562, v560), v547), (float32x4_t)0);
                    float32x4_t v564 = vmaxnmq_f32(vminnmq_f32(vdivq_f32(v561, v560), v548), (float32x4_t)0);
                    int32x4_t v565 = vcvtq_s32_f32(v563);
                    int32x4_t v566 = vcvtq_s32_f32(v564);
                    float32x4_t v567 = vcvtq_f32_s32(v565);
                    int32x4_t v568 = vmlaq_s32(v565, v546, v566);
                    float32x4_t v569 = vsubq_f32(v563, v567);
                    int32x4_t v570 = vaddq_s32(v568, v546);
                    v571 = (__int16 *)&v540[2 * v568.i32[0]];
                    v572 = (__int16 *)&v540[2 * v568.i32[1]];
                    float32x4_t v573 = vsubq_f32(v564, vcvtq_f32_s32(v566));
                    v574 = (__int16 *)&v540[2 * v568.i32[2]];
                    v568.i16[0] = *v571;
                    v568.i16[1] = *v572;
                    v575 = (__int16 *)&v540[2 * v568.i32[3]];
                    v568.i16[2] = *v574;
                    v568.i16[3] = *v575;
                    v566.i16[0] = v571[1];
                    float32x4_t v576 = vsubq_f32(v1923, v569);
                    v566.i16[1] = v572[1];
                    v566.i16[2] = v574[1];
                    v566.i16[3] = v575[1];
                    v577 = (__int16 *)&v540[2 * v570.i32[0]];
                    v578 = (__int16 *)&v540[2 * v570.i32[1]];
                    v570.i16[0] = *v577;
                    v570.i16[1] = *v578;
                    v579 = (__int16 *)&v540[2 * v570.i32[2]];
                    v580 = (__int16 *)&v540[2 * v570.i32[3]];
                    v570.i16[2] = *v579;
                    v570.i16[3] = *v580;
                    v581.i16[0] = v577[1];
                    v581.i16[1] = v578[1];
                    v581.i16[2] = v579[1];
                    v581.i16[3] = v580[1];
                    int16x8_t v582 = (int16x8_t)vcvtq_s32_f32(vminnmq_f32(vmulq_f32(vmlaq_f32(vmulq_f32(vsubq_f32(v1923, v573), vmlaq_f32(vmulq_f32(v576, vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v568.i8))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v566.i8)), v569)), vmlaq_f32(vmulq_f32(v576, vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v570.i8))), vcvtq_f32_u32(vmovl_u16(v581)), v569), v573), (float32x4_t)vdupq_n_s32(0x3B800000u)), v1907));
                    *(int16x4_t *)v582.i8 = vmovn_s32((int32x4_t)v582);
                    *(_DWORD *)(v555 + v559) = vmovn_s16(v582).u32[0];
                    float32x4_t v562 = vaddq_f32(v552, v562);
                    float32x4_t v561 = vaddq_f32(v553, v561);
                    float32x4_t v560 = vaddq_f32(v554, v560);
                    v559 += 4;
                  }
                  while ((int)v559 < v541);
                  v555 += v559;
                  float32x4_t v556 = vaddq_f32(v549, v556);
                  float32x4_t v557 = vaddq_f32(v550, v557);
                  float32x4_t v558 = vaddq_f32(v551, v558);
                  ++v545;
                }
                while (v545 != v542);
                goto LABEL_702;
              }
            }
            else
            {
              if (v427 != 1278226488) {
                goto LABEL_669;
              }
LABEL_660:
              sub_1D0E0E998(v2022, v419);
              int v478 = *(_DWORD *)(v392 + 24);
              int v479 = *(_DWORD *)(v392 + 28);
              *(float *)v480.i32 = nextafterf((float)(v2022[1].i32[0] - 1), 0.0);
              int32x2_t v1860 = v480;
              *(float *)v481.i32 = nextafterf((float)(v2022[1].i32[1] - 1), 0.0);
              if (v479 >= 1 && v478 >= 1)
              {
                int v483 = 0;
                float32x4_t v484 = (float32x4_t)vdupq_lane_s32(v1860, 0);
                float32x4_t v485 = (float32x4_t)vdupq_lane_s32(v481, 0);
                float32x4_t v486 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&buf[12], 0);
                float32x4_t v487 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&buf[16], 0);
                float32x4_t v488 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&buf[20], 0);
                float32x4_t v489 = vmulq_n_f32(v1853, *(float *)buf);
                float32x4_t v490 = vmulq_n_f32(v1853, *(float *)&buf[4]);
                float32x4_t v491 = vmulq_n_f32(v1853, *(float *)&buf[8]);
                int32x4_t v492 = vdupq_lane_s32(*(int32x2_t *)((char *)&v2022[2] + 4), 0);
                float32x2_t v493 = v2022[3];
                uint64_t v494 = *(void *)(v392 + 40);
                float32x4_t v495 = vmlaq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshrq_n_u64(*(uint64x2_t *)&buf[20], 0x20uLL), 0), (float32x4_t)xmmword_1D0E81540, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)buf, 0));
                float32x4_t v496 = vmlaq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)&buf[20], 2), (float32x4_t)xmmword_1D0E81540, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&buf[4], 0));
                float32x4_t v497 = vmlaq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)&buf[20], 3), (float32x4_t)xmmword_1D0E81540, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&buf[8], 0));
                do
                {
                  uint64_t v498 = 0;
                  float32x4_t v499 = v497;
                  float32x4_t v500 = v496;
                  float32x4_t v501 = v495;
                  v502.i64[0] = 0xFF000000FFLL;
                  v502.i64[1] = 0xFF000000FFLL;
                  do
                  {
                    float32x4_t v503 = vmaxnmq_f32(vminnmq_f32(vdivq_f32(v501, v499), v484), (float32x4_t)0);
                    float32x4_t v504 = vmaxnmq_f32(vminnmq_f32(vdivq_f32(v500, v499), v485), (float32x4_t)0);
                    int32x4_t v505 = vcvtq_s32_f32(v503);
                    int32x4_t v506 = vcvtq_s32_f32(v504);
                    float32x4_t v507 = vcvtq_f32_s32(v505);
                    int32x4_t v508 = vmlaq_s32(v505, v492, v506);
                    float32x4_t v509 = vsubq_f32(v503, v507);
                    float32x4_t v510 = vsubq_f32(v504, vcvtq_f32_s32(v506));
                    int32x4_t v511 = vaddq_s32(v508, v492);
                    v512 = (__int8 *)(*(void *)&v493 + v508.i32[0]);
                    float v513 = (__int8 *)(*(void *)&v493 + v508.i32[1]);
                    long long v514 = (__int8 *)(*(void *)&v493 + v508.i32[2]);
                    long long v515 = (__int8 *)(*(void *)&v493 + v508.i32[3]);
                    v508.i8[0] = *v512;
                    v508.i8[2] = *v513;
                    v507.i8[0] = v512[1];
                    v508.i8[4] = *v514;
                    v507.i8[2] = v513[1];
                    v507.i8[4] = v514[1];
                    v508.i8[6] = *v515;
                    v507.i8[6] = v515[1];
                    int8x16_t v516 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v507.f32);
                    LODWORD(v515) = v511.i32[3];
                    float32x4_t v517 = vsubq_f32(v1923, v509);
                    float v518 = (__int8 *)(*(void *)&v493 + v511.i32[0]);
                    uint64_t v519 = (__int8 *)(*(void *)&v493 + v511.i32[1]);
                    simd_float3x3 v520 = (__int8 *)(*(void *)&v493 + v511.i32[2]);
                    uint32x4_t v521 = (uint32x4_t)vandq_s8(v516, v502);
                    simd_float3x3 v522 = (__int8 *)(*(void *)&v493 + (int)v515);
                    v516.i8[0] = *v518;
                    v516.i8[2] = *v519;
                    v516.i8[4] = *v520;
                    v516.i8[6] = *v522;
                    v482.i8[0] = v518[1];
                    v482.i8[2] = v519[1];
                    v482.i8[4] = v520[1];
                    v482.i8[6] = v522[1];
                    uint32x4_t v482 = (uint32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v482.i8), v502);
                    int16x8_t v523 = (int16x8_t)vcvtq_s32_f32(vminnmq_f32(vmlaq_f32(vmulq_f32(vsubq_f32(v1923, v510), vmlaq_f32(vmulq_f32(v517, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v508.i8), v502))), vcvtq_f32_u32(v521), v509)), vmlaq_f32(vmulq_f32(v517, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v516.i8), v502))), vcvtq_f32_u32(v482),
                                              v509),
                                            v510),
                                          v1907));
                    *(int16x4_t *)v523.i8 = vmovn_s32((int32x4_t)v523);
                    *(_DWORD *)(v494 + v498) = vmovn_s16(v523).u32[0];
                    float32x4_t v501 = vaddq_f32(v489, v501);
                    float32x4_t v500 = vaddq_f32(v490, v500);
                    float32x4_t v499 = vaddq_f32(v491, v499);
                    v498 += 4;
                  }
                  while ((int)v498 < v478);
                  v494 += v498;
                  float32x4_t v495 = vaddq_f32(v486, v495);
                  float32x4_t v496 = vaddq_f32(v487, v496);
                  float32x4_t v497 = vaddq_f32(v488, v497);
                  ++v483;
                }
                while (v483 != v479);
              }
LABEL_702:
              char v529 = 1;
            }
LABEL_703:
            CVPixelBufferUnlockBaseAddress(v419, 1uLL);
            kdebug_trace();
            v583 = (std::__shared_weak_count *)__p[1];
            if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v583->__on_zero_shared)(v583);
              std::__shared_weak_count::__release_weak(v583);
            }
            if ((v529 & 1) == 0)
            {
              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&qword_1EB9F1610))
              {
                qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                __cxa_guard_release(&qword_1EB9F1610);
              }
              v587 = (id)qword_1EB9F1620;
              if (os_log_type_enabled(v587, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v1817 = *(void *)(v393 + 80);
                *(_DWORD *)int buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = v1817;
                _os_log_debug_impl(&dword_1D0DBD000, v587, OS_LOG_TYPE_DEBUG, "Computing the crop for face %d failed.", buf, 8u);
              }

              sub_1D0E1EB5C();
            }
            v584 = *(_DWORD **)(*keyc + 8);
            v585 = *(std::__shared_weak_count **)(*keyc + 16);
            if (v585) {
              atomic_fetch_add_explicit(&v585->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            v586 = (char *)v1958 + 104 * v1879;
            _DWORD *v584 = v586[4];
            v584[1] = v586[10];
            v584[2] = v586[11];
            if (v585 && !atomic_fetch_add(&v585->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v585->__on_zero_shared)(v585);
              std::__shared_weak_count::__release_weak(v585);
            }
            uint64_t v369 = v1879 + 1;
            if (v1879 + 1 != v1871) {
              continue;
            }
            if (*(void *)(*a2 + 152)) {
              BOOL v605 = 0;
            }
            else {
              BOOL v605 = *(unsigned char *)(*v1870 + 384) != 0;
            }
            BOOL v1839 = v605;
            kdebug_trace();
            v606 = *(uint64_t ***)(v1888 + 24);
            v607 = *(uint64_t ***)(v1888 + 32);
            if (v606 != v607)
            {
              while (2)
              {
                uint64_t v608 = **v606;
                v610 = *(void **)(v608 + 8);
                v609 = *(std::__shared_weak_count **)(v608 + 16);
                memptr[0] = v610;
                memptr[1] = v609;
                if (v609)
                {
                  atomic_fetch_add_explicit(&v609->__shared_owners_, 1uLL, memory_order_relaxed);
                  uint64_t v608 = **v606;
                }
                uint64_t v611 = *a2;
                if (!*(void *)(*a2 + 152))
                {
                  BOOL v612 = v1839;
                  if (*(int *)(v608 + 4) >= 50) {
                    BOOL v612 = 0;
                  }
                  if (v612)
                  {
                    uint64_t v614 = *(void *)(v608 + 136);
                    uint64_t v613 = *(void *)(v608 + 144);
                    *(void *)&long long v1988 = v614;
                    *((void *)&v1988 + 1) = v613;
                    if (v613)
                    {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v613 + 8), 1uLL, memory_order_relaxed);
                      uint64_t v611 = *a2;
                    }
                    v1956 = v610;
                    v1957 = v609;
                    if (v609)
                    {
                      atomic_fetch_add_explicit(&v609->__shared_owners_, 1uLL, memory_order_relaxed);
                      atomic_fetch_add_explicit(&v609->__shared_owners_, 1uLL, memory_order_relaxed);
                      v615 = v609;
                    }
                    else
                    {
                      v615 = 0;
                    }
                    *(void *)int buf = sub_1D0E09A00;
                    *(void *)&uint8_t buf[8] = 0;
                    *(void *)&uint8_t buf[16] = v611;
                    *(void *)&unsigned char buf[24] = v610;
                    *(void *)&buf[32] = v615;
                    v2022[3] = 0;
                    v616 = operator new(0x30uLL);
                    void *v616 = &unk_1F26F4700;
                    v616[1] = sub_1D0E09A00;
                    v616[2] = 0;
                    v616[3] = v611;
                    v616[4] = v610;
                    v616[5] = v609;
                    v2022[3] = (float32x2_t)v616;
                    std::mutex::lock((std::mutex *)(v614 + 888));
                    if (*(_DWORD *)(v614 + 880))
                    {
                      kdebug_trace();
                      int v617 = *(_DWORD *)(v614 + 880);
                      if (v617)
                      {
                        int v618 = v617 - 1;
                        *(_DWORD *)(v614 + 880) = v617 - 1;
                        if (v617 == 1)
                        {
                          sub_1D0E41E74(v614 + 304, (uint64_t *)(v614 + 592));
                          sub_1D0E41E74(v614 + 448, (uint64_t *)(v614 + 592));
                        }
                        else
                        {
                          v2028.columns[0].f32[0] = (float)(v617 * v617);
                          float v1942 = (float)(v618 * v618);
                          float v1943 = (float)(v618 * v618 * v618);
                          v2028.columns[1].f32[0] = (float)(v617 * v617 * v617);
                          v2028.columns[0].f32[1] = (float)v617 + (float)v617;
                          v2028.columns[1].f32[1] = v2028.columns[0].f32[0] * 3.0;
                          *(simd_float2x2 *)v2006 = __invert_f2(v2028);
                          *(void *)v2013 = &v1942;
                          *(void *)&v2013[8] = v2006;
                          *(_OWORD *)long long __p = xmmword_1D0E81760;
                          *(void *)int buf = v2013;
                          *(void *)&uint8_t buf[8] = __p;
                          *(void *)&long long v1983 = 0;
                          sub_1D0E420F4((float *)&v1983, (uint64_t)buf);
                          v619.i32[0] = DWORD1(v1983);
                          float v620 = *(float *)&v1983;
                          *(float *)v621.i32 = 1.0 - (float)(*(float *)&v1983 + *((float *)&v1983 + 1));
                          uint64_t v622 = *(unsigned int *)(v614 + 480);
                          if ((int)v622 >= 1)
                          {
                            v623 = *(float32x4_t **)(v614 + 464);
                            v624 = *(float32x4_t **)(v614 + 320);
                            v625 = *(float32x4_t **)(v614 + 608);
                            if (v622 < 8)
                            {
                              uint64_t v626 = 0;
                              goto LABEL_788;
                            }
                            uint64_t v626 = v622 & 0x7FFFFFF8;
                            float32x4_t v627 = (float32x4_t)vdupq_lane_s32(v619, 0);
                            float32x4_t v628 = (float32x4_t)vdupq_lane_s32(v621, 0);
                            v629 = v625 + 1;
                            v630 = v624 + 1;
                            v631 = v623 + 1;
                            uint64_t v632 = v622 & 0xFFFFFFF8;
                            do
                            {
                              float32x4_t v633 = vmlaq_f32(vmlaq_f32(vmulq_n_f32(*v630, v620), *v631, v627), *v629, v628);
                              v631[-1] = vmlaq_f32(vmlaq_f32(vmulq_n_f32(v630[-1], v620), v631[-1], v627), v629[-1], v628);
                              float32x4_t *v631 = v633;
                              v629 += 2;
                              v630 += 2;
                              v631 += 2;
                              v632 -= 8;
                            }
                            while (v632);
                            if (v626 != v622)
                            {
LABEL_788:
                              uint64_t v634 = v622 - v626;
                              uint64_t v635 = v626;
                              v636 = &v625->f32[v635];
                              v637 = &v624->f32[v635];
                              v638 = &v623->f32[v635];
                              do
                              {
                                float v639 = *v637++;
                                float v640 = (float)(v639 * v620) + (float)(*(float *)v619.i32 * *v638);
                                float v641 = *v636++;
                                *v638++ = v640 + (float)(*(float *)v621.i32 * v641);
                                --v634;
                              }
                              while (v634);
                            }
                          }
                          uint64_t v642 = *(unsigned int *)(v614 + 504);
                          if ((int)v642 >= 1)
                          {
                            v643 = *(float32x4_t **)(v614 + 488);
                            v644 = *(float32x4_t **)(v614 + 344);
                            v645 = *(float32x4_t **)(v614 + 632);
                            if (v642 < 8)
                            {
                              uint64_t v646 = 0;
                              goto LABEL_796;
                            }
                            uint64_t v646 = v642 & 0x7FFFFFF8;
                            float32x4_t v647 = (float32x4_t)vdupq_lane_s32(v619, 0);
                            float32x4_t v648 = (float32x4_t)vdupq_lane_s32(v621, 0);
                            v649 = v645 + 1;
                            v650 = v644 + 1;
                            v651 = v643 + 1;
                            uint64_t v652 = v642 & 0xFFFFFFF8;
                            do
                            {
                              float32x4_t v653 = vmlaq_f32(vmlaq_f32(vmulq_n_f32(*v650, v620), *v651, v647), *v649, v648);
                              v651[-1] = vmlaq_f32(vmlaq_f32(vmulq_n_f32(v650[-1], v620), v651[-1], v647), v649[-1], v648);
                              float32x4_t *v651 = v653;
                              v649 += 2;
                              v650 += 2;
                              v651 += 2;
                              v652 -= 8;
                            }
                            while (v652);
                            if (v646 != v642)
                            {
LABEL_796:
                              uint64_t v654 = v642 - v646;
                              uint64_t v655 = v646;
                              v656 = &v645->f32[v655];
                              v657 = &v644->f32[v655];
                              v658 = &v643->f32[v655];
                              do
                              {
                                float v659 = *v657++;
                                float v660 = (float)(v659 * v620) + (float)(*(float *)v619.i32 * *v658);
                                float v661 = *v656++;
                                *v658++ = v660 + (float)(*(float *)v621.i32 * v661);
                                --v654;
                              }
                              while (v654);
                            }
                          }
                          uint64_t v662 = (*(_DWORD *)(v614 + 532) * *(_DWORD *)(v614 + 528));
                          if ((int)v662 >= 1)
                          {
                            v663 = *(float32x4_t **)(v614 + 368);
                            v664 = *(float32x4_t **)(v614 + 656);
                            v665 = *(float32x4_t **)(v614 + 512);
                            if (v662 < 8)
                            {
                              uint64_t v666 = 0;
                              goto LABEL_804;
                            }
                            uint64_t v666 = v662 & 0x7FFFFFF8;
                            float32x4_t v667 = (float32x4_t)vdupq_lane_s32(v619, 0);
                            float32x4_t v668 = (float32x4_t)vdupq_lane_s32(v621, 0);
                            v669 = v664 + 1;
                            v670 = v663 + 1;
                            v671 = v665 + 1;
                            uint64_t v672 = v662 & 0xFFFFFFF8;
                            do
                            {
                              float32x4_t v673 = vmlaq_f32(vmlaq_f32(vmulq_n_f32(*v670, v620), *v671, v667), *v669, v668);
                              v671[-1] = vmlaq_f32(vmlaq_f32(vmulq_n_f32(v670[-1], v620), v671[-1], v667), v669[-1], v668);
                              float32x4_t *v671 = v673;
                              v669 += 2;
                              v670 += 2;
                              v671 += 2;
                              v672 -= 8;
                            }
                            while (v672);
                            if (v666 != v662)
                            {
LABEL_804:
                              uint64_t v674 = v662 - v666;
                              uint64_t v675 = v666;
                              v676 = &v664->f32[v675];
                              v677 = &v663->f32[v675];
                              v678 = &v665->f32[v675];
                              do
                              {
                                float v679 = *v677++;
                                float v680 = (float)(v679 * v620) + (float)(*(float *)v619.i32 * *v678);
                                float v681 = *v676++;
                                *v678++ = v680 + (float)(*(float *)v621.i32 * v681);
                                --v674;
                              }
                              while (v674);
                            }
                          }
                          if (*(unsigned char *)(v614 + 584))
                          {
                            float32x4_t v682 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(v614 + 408), v620), *(float32x4_t *)(v614 + 552), *(float *)v619.i32), *(float32x4_t *)(v614 + 696), *(float *)v621.i32);
                            *(float32x4_t *)(v614 + 536) = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(v614 + 392), v620), *(float32x4_t *)(v614 + 536), *(float *)v619.i32), *(float32x4_t *)(v614 + 680), *(float *)v621.i32);
                            *(float32x4_t *)(v614 + 552) = v682;
                            *(float32x4_t *)(v614 + 568) = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(v614 + 424), v620), *(float32x4_t *)(v614 + 568), *(float *)v619.i32), *(float32x4_t *)(v614 + 712), *(float *)v621.i32);
                          }
                          sub_1D0E6E85C((uint64_t *)(v614 + 304), (uint64_t *)(v614 + 448));
                        }
                      }
                      if (!*(void *)&v2022[3])
                      {
                        sub_1D0DD8808();
                        goto LABEL_2250;
                      }
                      (*(void (**)(void, uint64_t))(**(void **)&v2022[3] + 48))(*(void *)&v2022[3], v614 + 304);
                      kdebug_trace();
                    }
                    std::mutex::unlock((std::mutex *)(v614 + 888));
                    if ((float32x2_t *)v2022[3] == v2022)
                    {
                      (*(void (**)(float32x2_t *))(*(void *)v2022 + 32))(v2022);
                      if (!v609) {
                        goto LABEL_819;
                      }
                    }
                    else
                    {
                      if (v2022[3]) {
                        (*(void (**)(void))(**(void **)&v2022[3] + 40))();
                      }
                      if (!v609)
                      {
LABEL_819:
                        v683 = (std::__shared_weak_count *)*((void *)&v1988 + 1);
                        if (*((void *)&v1988 + 1)
                          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v1988 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v683->__on_zero_shared)(v683);
                          std::__shared_weak_count::__release_weak(v683);
                        }
                        v609 = (std::__shared_weak_count *)memptr[1];
                        if (!memptr[1])
                        {
LABEL_762:
                          v606 += 2;
                          if (v606 == v607) {
                            goto LABEL_824;
                          }
                          continue;
                        }
LABEL_775:
                        if (!atomic_fetch_add(&v609->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v609->__on_zero_shared)(v609);
                          std::__shared_weak_count::__release_weak(v609);
                        }
                        goto LABEL_762;
                      }
                    }
                    if (!atomic_fetch_add(&v609->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v609->__on_zero_shared)(v609);
                      std::__shared_weak_count::__release_weak(v609);
                    }
                    goto LABEL_819;
                  }
                  (*(void (**)(void, void, void *))(**(void **)(v611 + 16) + 16))(*(void *)(v611 + 16), 0, v610);
                }
                break;
              }
              if (!v609) {
                goto LABEL_762;
              }
              goto LABEL_775;
            }
LABEL_824:
            kdebug_trace();
            kdebug_trace();
            memset(buf, 0, 24);
            if (v1851)
            {
              if (v1851 < 0) {
                abort();
              }
              v684 = (char *)operator new(v1857 & 0xFFFFFFFFFLL);
              *(void *)int buf = v684;
              *(void *)&uint8_t buf[16] = &v684[16 * v1852];
              bzero(v684, v1857 & 0xFFFFFFFFFLL);
              *(void *)&uint8_t buf[8] = &v684[v1857 & 0xFFFFFFFFFLL];
            }
            uint64_t v685 = 0;
            do
            {
              long long v686 = *(_OWORD *)(*(*v1890)[v685] + 8);
              uint64_t v687 = *(void *)(*(*v1890)[v685] + 16);
              if (v687) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v687 + 8), 1uLL, memory_order_relaxed);
              }
              v688 = *(std::__shared_weak_count **)(*(void *)buf + v685 * 8 + 8);
              *(_OWORD *)(*(void *)buf + v685 * 8) = v686;
              if (v688 && !atomic_fetch_add(&v688->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v688->__on_zero_shared)(v688);
                std::__shared_weak_count::__release_weak(v688);
              }
              v685 += 2;
              --v1877;
            }
            while (v1877);
            uint64_t v689 = *(void *)(*a2 + 16);
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EB9F1618))
            {
              sub_1D0E225B4();
            }
            (*(void (**)(uint64_t, unsigned char *, void, void))(*(void *)v689 + 24))(v689, buf, *(unsigned __int8 *)(qword_1EB9F15F8 + 192), *(unsigned __int8 *)(*(void *)(*a2 + 8) + 3));
            uint64_t v690 = *(void *)buf;
            if (*(void *)buf)
            {
              uint64_t v691 = *(void *)&buf[8];
              v692 = *(void **)buf;
              if (*(void *)&buf[8] != *(void *)buf)
              {
                do
                {
                  v693 = *(std::__shared_weak_count **)(v691 - 8);
                  if (v693 && !atomic_fetch_add(&v693->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v693->__on_zero_shared)(v693);
                    std::__shared_weak_count::__release_weak(v693);
                  }
                  v691 -= 16;
                }
                while (v691 != v690);
                v692 = *(void **)buf;
              }
              *(void *)&uint8_t buf[8] = v690;
              operator delete(v692);
            }
            kdebug_trace();
            v1862.i32[0] = 0;
            uint64_t v694 = 0;
            CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            while (2)
            {
              long long v695 = *(_OWORD *)&(*v1890)[2 * v694];
              long long v1955 = v695;
              if (*((void *)&v695 + 1)) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v695 + 1) + 8), 1uLL, memory_order_relaxed);
              }
              uint64_t v696 = *(void *)(*(void *)v695 + 8);
              v697 = *(std::__shared_weak_count **)(*(void *)v695 + 16);
              if (v697) {
                atomic_fetch_add_explicit(&v697->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              v699 = *(float **)(v696 + 64);
              v698 = *(std::__shared_weak_count **)(v696 + 72);
              if (v698) {
                atomic_fetch_add_explicit(&v698->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              v1953 = v699;
              v1954 = v698;
              if (v697)
              {
                if (!atomic_fetch_add(&v697->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v697->__on_zero_shared)(v697);
                  std::__shared_weak_count::__release_weak(v697);
                }
                v699 = v1953;
              }
              if (!v699)
              {
                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                  && __cxa_guard_acquire(&qword_1EB9F1610))
                {
                  qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                  __cxa_guard_release(&qword_1EB9F1610);
                }
                v711 = (id)qword_1EB9F1620;
                if (os_log_type_enabled(v711, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)int buf = 0;
                  _os_log_error_impl(&dword_1D0DBD000, v711, OS_LOG_TYPE_ERROR, "net output invalid", buf, 2u);
                }

                sub_1D0E1EB5C();
              }
              kdebug_trace();
              v700 = v1953;
              uint64_t v1951 = 0;
              float v1952 = 0.0;
              float v701 = v1953[1];
              float v702 = v1953[2];
              __float2 v703 = __sincosf_stret(*v1953);
              __float2 v704 = __sincosf_stret(v701);
              __float2 v705 = __sincosf_stret(v702);
              float v1942 = v704.__cosval * v705.__cosval;
              float v1943 = (float)(v704.__sinval * (float)(v703.__sinval * v705.__cosval))
                    + (float)(v703.__cosval * v705.__sinval);
              float v1944 = (float)(v704.__sinval * (float)-(float)(v703.__cosval * v705.__cosval))
                    + (float)(v703.__sinval * v705.__sinval);
              float v1945 = -(float)(v704.__cosval * v705.__sinval);
              float v1946 = (float)((float)-(float)(v703.__sinval * v704.__sinval) * v705.__sinval)
                    + (float)(v703.__cosval * v705.__cosval);
              float v1947 = (float)((float)(v703.__cosval * v704.__sinval) * v705.__sinval)
                    + (float)(v705.__cosval * v703.__sinval);
              float sinval = v704.__sinval;
              float v1949 = -(float)(v704.__cosval * v703.__sinval);
              float v1950 = v703.__cosval * v704.__cosval;
              if (&v1951 != (uint64_t *)(v700 + 3))
              {
                uint64_t v706 = *(void *)(v700 + 3);
                float v1952 = v700[5];
                uint64_t v1951 = v706;
              }
              uint64_t v1936 = 0;
              uint64_t v1937 = 0;
              v707 = (float *)((char *)v1958 + 104 * v694 + 52);
              uint64_t v1935 = 0;
              int v1938 = 0;
              float32x2_t v1940 = 0;
              float v1941 = 0.0;
              if (v707 == &v1934)
              {
                float v708 = 1.0;
                float v709 = 1.0;
                float v710 = 1.0;
              }
              else
              {
                float v708 = *v707;
                LODWORD(v1935) = *((_DWORD *)v1958 + 26 * v694 + 16);
                HIDWORD(v1935) = *((_DWORD *)v1958 + 26 * v694 + 19);
                LODWORD(v1936) = *((_DWORD *)v1958 + 26 * v694 + 14);
                float v709 = *((float *)v1958 + 26 * v694 + 17);
                LODWORD(v1937) = *((_DWORD *)v1958 + 26 * v694 + 20);
                HIDWORD(v1937) = *((_DWORD *)v1958 + 26 * v694 + 15);
                int v1938 = *((_DWORD *)v1958 + 26 * v694 + 18);
                float v710 = *((float *)v1958 + 26 * v694 + 21);
              }
              float v1934 = v708;
              *((float *)&v1936 + 1) = v709;
              float v1939 = v710;
              v2022[0] = (float32x2_t)&v1934;
              *(void *)int buf = v2022;
              *(void *)&uint8_t buf[8] = (char *)v1958 + 104 * v694 + 88;
              sub_1D0E1EC78((float *)&v1940, (uint64_t)buf);
              long long v1930 = 0x3F800000uLL;
              long long v1929 = 0x3F800000uLL;
              int v1931 = 1065353216;
              float32x2_t v1932 = 0;
              float v1933 = 0.0;
              *(void *)int buf = &v1934;
              *(void *)&uint8_t buf[8] = &v1942;
              sub_1D0DF1BF0((uint64_t)&v1929, (float **)buf);
              v2022[0] = (float32x2_t)&v1934;
              v2022[1] = (float32x2_t)&v1951;
              *(void *)&uint8_t buf[4] = 0;
              *(_DWORD *)&unsigned char buf[12] = 0;
              sub_1D0DF1DA0((float *)&buf[4], (float **)v2022);
              float32x2_t v1932 = vadd_f32(*(float32x2_t *)&buf[4], v1940);
              float v1933 = *(float *)&buf[12] + v1941;
              uint64_t v712 = v1862.i32[0] & 0xFFFFFF00;
              uint64_t v713 = *a2;
              uint64_t v1869 = v694;
              if (!v1867 || !*(unsigned char *)(*(void *)(v713 + 8) + 8)) {
                goto LABEL_1060;
              }
              kdebug_trace();
              sub_1D0E07EBC((uint64_t)(v1953 + 46), *((void *)v1953 + 3), *((_DWORD *)v1953 + 10), *a2 + 168);
              *(_DWORD *)&buf[28] = 0;
              *(_DWORD *)&unsigned char buf[12] = 0;
              *(void *)&buf[20] = 0;
              *(void *)&uint8_t buf[4] = 0;
              *(_DWORD *)int buf = 1065353216;
              *(_DWORD *)&uint8_t buf[16] = 1065353216;
              *(_DWORD *)&buf[32] = 1065353216;
              *(void *)&buf[36] = 0;
              *(_DWORD *)&buf[44] = 0;
              v2022[0] = (float32x2_t)&v1970[4];
              v2022[1] = (float32x2_t)&v1929;
              sub_1D0DF1BF0((uint64_t)buf, (float **)v2022);
              *(void *)v2013 = &v1970[4];
              *(void *)&v2013[8] = &v1932;
              *(float32x2_t *)((char *)v2022 + 4) = 0;
              v2022[1].i32[1] = 0;
              sub_1D0DF1DA0((float *)v2022 + 1, (float **)v2013);
              *(float32x2_t *)&buf[36] = vadd_f32(*(float32x2_t *)((char *)v2022 + 4), v1971);
              *(float *)&buf[44] = v2022[1].f32[1] + v1972;
              uint64_t v714 = *a2;
              float v715 = *(float *)(*(void *)(*a2 + 8) + 92);
              if ((float)(v2022[1].f32[1] + v1972) > v715) {
                goto LABEL_1059;
              }
              uint64_t v716 = *v1870;
              long long v717 = *(_OWORD *)(*v1870 + 240);
              *(_OWORD *)v2022[0].f32 = *(_OWORD *)(*v1870 + 224);
              *(_OWORD *)v2022[2].f32 = v717;
              int v2023 = *(_DWORD *)(v716 + 256);
              uint64_t keyd = v714;
              uint64_t v718 = *(int *)(v714 + 184);
              if (v718)
              {
                if ((v718 & 0x80000000) != 0) {
                  goto LABEL_2233;
                }
                v719 = (float *)operator new(4 * v718);
                v1908 = &v719[v718];
              }
              else
              {
                v719 = 0;
                v1908 = 0;
              }
              float v720 = v715 + 100.0;
              v721 = *(__CVBuffer **)(v716 + 200);
              OSType v722 = CVPixelBufferGetPixelFormatType(v721);
              if (v722 == 825306677 || (OSType v723 = v722, v722 == 1647392359) || v722 == 825437747)
              {
                int v724 = *(_DWORD *)(v716 + 324);
                pixelBuffer = v721;
                if (v724 != 1)
                {
                  uint64_t v725 = keyd;
                  if (v724 != 2) {
                    goto LABEL_2234;
                  }
                  CVPixelBufferLockBaseAddress(v721, 1uLL);
                  int v726 = CVPixelBufferGetWidth(v721);
                  int v727 = CVPixelBufferGetHeight(v721);
                  int BytesPerRow = CVPixelBufferGetBytesPerRow(v721);
                  BaseAddress = (char *)CVPixelBufferGetBaseAddress(v721);
                  *(float *)v729.i32 = *(float *)(v716 + 312) * 0.001;
                  int32x2_t v1880 = v729;
                  *(float *)v730.i32 = *(float *)(v716 + 316) * 0.001;
                  int32x2_t v1863 = v730;
                  float v731 = (float)((float)(1.0 / v720) - *(float *)v730.i32) / *(float *)v729.i32;
                  *(float *)v732.i32 = nextafterf((float)*(int *)(v716 + 320), 0.0);
                  if (v731 >= *(float *)v732.i32) {
                    float v734 = *(float *)v732.i32;
                  }
                  else {
                    float v734 = v731;
                  }
                  if (*(float *)v1880.i32 <= 0.0) {
                    *(float *)v733.i32 = 0.0;
                  }
                  else {
                    *(float *)v733.i32 = v731;
                  }
                  if (*(float *)v1880.i32 <= 0.0) {
                    *(float *)v732.i32 = v734;
                  }
                  if (v718)
                  {
                    uint64_t v735 = v718;
                    uint64_t v736 = 0;
                    float32x4_t v1881 = (float32x4_t)vdupq_lane_s32(v1880, 0);
                    float32x4_t v1864 = (float32x4_t)vdupq_lane_s32(v1863, 0);
                    float32x4_t v1854 = (float32x4_t)vdupq_lane_s32(v732, 0);
                    float32x4_t v1848 = (float32x4_t)vdupq_lane_s32(v733, 0);
                    float v737 = (float)(v726 - 1);
                    int v738 = v727 - 1;
                    v739 = v719;
                    float v740 = (float)v738;
                    int v741 = BytesPerRow;
                    while (1)
                    {
                      uint64_t v742 = (3 * v736);
                      __p[0] = (void *)(*(void *)(v725 + 168) + 4 * v742);
                      __p[1] = (void *)((v742 << 32) | 3);
                      *(void *)v2006 = buf;
                      *(void *)&v2006[8] = __p;
                      *(void *)&v2013[4] = 0;
                      *(_DWORD *)&v2013[12] = 0;
                      sub_1D0E4745C((float *)&v2013[4], (uint64_t)v2006);
                      memptr[0] = (void *)vadd_f32(*(float32x2_t *)&v2013[4], *(float32x2_t *)&buf[36]);
                      float v743 = *(float *)&v2013[12] + *(float *)&buf[44];
                      *(float *)&memptr[1] = *(float *)&v2013[12] + *(float *)&buf[44];
                      *(void *)v2013 = v2022;
                      *(void *)&v2013[8] = memptr;
                      *(void *)v2006 = 0;
                      *(_DWORD *)&v2006[8] = 0;
                      sub_1D0DF1DA0((float *)v2006, (float **)v2013);
                      *(float *)v745.i32 = *(float *)v2006 / *(float *)&v2006[8];
                      if ((float)(*(float *)v2006 / *(float *)&v2006[8]) >= 0.0)
                      {
                        *(float *)v744.i32 = *(float *)&v2006[4] / *(float *)&v2006[8];
                        BOOL v746 = (float)(*(float *)&v2006[4] / *(float *)&v2006[8]) >= 0.0 && *(float *)v745.i32 < v737;
                        if (v746 && *(float *)v744.i32 < v740)
                        {
                          int v748 = 2 * (int)*(float *)v745.i32;
                          int v749 = (int)*(float *)v744.i32 * v741;
                          unsigned int v750 = v749 + v748;
                          v751 = (__int16 *)&BaseAddress[v749 + v748 + 2];
                          int v752 = v741 + v749;
                          v753.i16[0] = *(_WORD *)&BaseAddress[v750];
                          v753.i16[1] = *v751;
                          v753.i16[2] = *(_WORD *)&BaseAddress[v752 + v748];
                          v753.i16[3] = *(_WORD *)&BaseAddress[v752 + v748 + 2];
                          float32x4_t v754 = vcvtq_f32_u32(vmovl_u16(v753));
                          int8x16_t v755 = vandq_s8((int8x16_t)vcgeq_f32(v1854, v754), (int8x16_t)vcgeq_f32(v754, v1848));
                          float32x4_t v756 = vmlaq_f32(v1864, v1881, v754);
                          float32x4_t v757 = vrecpeq_f32(v756);
                          float32x4_t v758 = vmulq_f32(v757, vrecpsq_f32(v756, v757));
                          float32x4_t v759 = (float32x4_t)vandq_s8((int8x16_t)vmulq_f32(v758, vrecpsq_f32(v756, v758)), v755);
                          *(float *)v745.i32 = *(float *)v745.i32 - (float)(int)*(float *)v745.i32;
                          *(float *)v744.i32 = *(float *)v744.i32 - (float)(int)*(float *)v744.i32;
                          v756.f32[0] = 1.0 - *(float *)v745.i32;
                          v756.i32[1] = v745.i32[0];
                          v756.f32[2] = 1.0 - *(float *)v745.i32;
                          v756.i32[3] = v745.i32[0];
                          *(float *)v745.i32 = 1.0 - *(float *)v744.i32;
                          *(int32x2_t *)v760.f32 = vdup_lane_s32(v745, 0);
                          *(int32x2_t *)&v760.u32[2] = vdup_lane_s32(v744, 0);
                          float32x4_t v761 = (float32x4_t)vandq_s8((int8x16_t)vmulq_f32(v756, v760), (int8x16_t)vcgtzq_f32(v759));
                          float32x2_t v762 = vadd_f32(*(float32x2_t *)v761.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v761, (int8x16_t)v761, 8uLL));
                          if (vaddv_f32(v762) != 0.0)
                          {
                            int8x16_t v763 = (int8x16_t)vmulq_f32(v759, v761);
                            *(float32x2_t *)v763.i8 = vadd_f32(*(float32x2_t *)v763.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v763, v763, 8uLL));
                            float v764 = vdiv_f32(vadd_f32(*(float32x2_t *)v763.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v763.i8, 1)), vadd_f32(v762, (float32x2_t)vdup_lane_s32((int32x2_t)v762, 1))).f32[0]/ v743;
                            if (v739 >= v1908)
                            {
                              uint64_t v766 = v739 - v719;
                              unint64_t v767 = v766 + 1;
                              if ((unint64_t)(v766 + 1) >> 62) {
                                goto LABEL_2233;
                              }
                              if (((char *)v1908 - (char *)v719) >> 1 > v767) {
                                unint64_t v767 = ((char *)v1908 - (char *)v719) >> 1;
                              }
                              if ((unint64_t)((char *)v1908 - (char *)v719) >= 0x7FFFFFFFFFFFFFFCLL) {
                                unint64_t v768 = 0x3FFFFFFFFFFFFFFFLL;
                              }
                              else {
                                unint64_t v768 = v767;
                              }
                              if (v768)
                              {
                                if (v768 >> 62) {
                                  goto LABEL_2232;
                                }
                                v769 = operator new(4 * v768);
                              }
                              else
                              {
                                v769 = 0;
                              }
                              v770 = (float *)&v769[4 * v766];
                              float *v770 = v764;
                              v765 = v770 + 1;
                              if (v739 == v719)
                              {
                                uint64_t v725 = keyd;
                              }
                              else
                              {
                                unint64_t v771 = (char *)(v739 - 1) - (char *)v719;
                                if (v771 < 0xBC
                                  || &v769[(char *)v739 - (char *)v719 - 4 - (v771 & 0xFFFFFFFFFFFFFFFCLL)] > &v769[(char *)v739 - (char *)v719 - 4]
                                  || (float *)((char *)v739 - (v771 & 0xFFFFFFFFFFFFFFFCLL) - 4) > v739 - 1
                                  || (unint64_t)((char *)v719 - v769) < 0x20)
                                {
                                  v772 = v739;
                                  uint64_t v725 = keyd;
                                }
                                else
                                {
                                  uint64_t v774 = (v771 >> 2) + 1;
                                  v772 = &v739[-(v774 & 0x7FFFFFFFFFFFFFF8)];
                                  v775 = &v769[4 * v766 - 16];
                                  v776 = v739 - 4;
                                  uint64_t v777 = v774 & 0x7FFFFFFFFFFFFFF8;
                                  uint64_t v725 = keyd;
                                  do
                                  {
                                    long long v778 = *(_OWORD *)v776;
                                    *(v775 - 1) = *((_OWORD *)v776 - 1);
                                    _OWORD *v775 = v778;
                                    v775 -= 2;
                                    v776 -= 8;
                                    v777 -= 8;
                                  }
                                  while (v777);
                                  v770 -= v774 & 0x7FFFFFFFFFFFFFF8;
                                  if (v774 == (v774 & 0x7FFFFFFFFFFFFFF8)) {
                                    goto LABEL_919;
                                  }
                                }
                                do
                                {
                                  int v773 = *((_DWORD *)v772-- - 1);
                                  *((_DWORD *)v770-- - 1) = v773;
                                }
                                while (v772 != v719);
                              }
LABEL_919:
                              v1908 = (float *)&v769[4 * v768];
                              if (v719) {
                                operator delete(v719);
                              }
                              v719 = v770;
                              int v741 = BytesPerRow;
                              goto LABEL_901;
                            }
                            *v739++ = v764;
                          }
                        }
                      }
                      v765 = v739;
LABEL_901:
                      ++v736;
                      v739 = v765;
                      if (v736 == v735) {
                        goto LABEL_1023;
                      }
                    }
                  }
LABEL_1022:
                  v765 = v719;
LABEL_1023:
                  CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
LABEL_1024:
                  int v872 = *(_DWORD *)(keyd + 184);
                  unint64_t v873 = (unint64_t)((char *)v765 - (char *)v719) >> 2;
                  if ((int)v873 < 10 || (float v874 = (float)(int)v873, (float)((float)v872 * 0.75) > (float)(int)v873))
                  {
                    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                      && __cxa_guard_acquire(&qword_1EB9F1610))
                    {
                      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                      __cxa_guard_release(&qword_1EB9F1610);
                    }
                    v883 = qword_1EB9F1620;
                    if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
                    {
                      v2022[0].i32[0] = 67109376;
                      v2022[0].i32[1] = v873;
                      v2022[1].i16[0] = 1024;
                      *(__int32 *)((char *)v2022[1].i32 + 2) = v872;
                      _os_log_impl(&dword_1D0DBD000, v883, OS_LOG_TYPE_INFO, "skipping pose refinement: low number of valid depth pixels (%d/%d)", (uint8_t *)v2022, 0xEu);
                    }
                    uint64_t v884 = 0;
                    uint64_t v885 = 0;
                  }
                  else
                  {
                    int v875 = (int)(float)(v874 * 0.25);
                    v876 = &v719[v875];
                    if (v876 != v765) {
                      sub_1D0E4753C(v719, &v719[v875], v765);
                    }
                    int v877 = (int)(float)(v874 * 0.75);
                    v878 = &v719[v877];
                    if (v878 != v765) {
                      sub_1D0E4753C(v876 + 1, v878, v765);
                    }
                    int v879 = v877 - v875 + 1;
                    if (v877 - v875 < 0)
                    {
                      double v886 = 0.0;
                      double v887 = 0.0 / (double)v879;
                    }
                    else
                    {
                      uint64_t v880 = (v877 - v875 + 1);
                      if (v880 <= 7)
                      {
                        uint64_t v881 = 0;
                        double v882 = 0.0;
                        goto LABEL_1041;
                      }
                      uint64_t v881 = v880 & 0xFFFFFFF8;
                      v888 = (float32x4_t *)&v719[v875 + 4];
                      double v882 = 0.0;
                      uint64_t v889 = v881;
                      do
                      {
                        float32x4_t v890 = v888[-1];
                        float64x2_t v891 = vcvt_hight_f64_f32(v890);
                        float64x2_t v892 = vcvtq_f64_f32(*(float32x2_t *)v890.f32);
                        float64x2_t v893 = vcvt_hight_f64_f32(*v888);
                        float64x2_t v894 = vcvtq_f64_f32(*(float32x2_t *)v888->f32);
                        double v882 = v882
                             + v892.f64[0]
                             + v892.f64[1]
                             + v891.f64[0]
                             + v891.f64[1]
                             + v894.f64[0]
                             + v894.f64[1]
                             + v893.f64[0]
                             + v893.f64[1];
                        v888 += 2;
                        v889 -= 8;
                      }
                      while (v889);
                      if (v881 != v880)
                      {
LABEL_1041:
                        uint64_t v895 = v880 - v881;
                        v896 = &v719[v881 + v875];
                        do
                        {
                          float v897 = *v896++;
                          double v882 = v882 + v897;
                          --v895;
                        }
                        while (v895);
                      }
                      double v887 = v882 / (double)v879;
                      if (v880 <= 7)
                      {
                        uint64_t v898 = 0;
                        double v886 = 0.0;
                        goto LABEL_1048;
                      }
                      uint64_t v898 = v880 & 0xFFFFFFF8;
                      float64x2_t v899 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v887, 0);
                      v900 = (float32x2_t *)&v719[v875 + 4];
                      double v886 = 0.0;
                      uint64_t v901 = v898;
                      do
                      {
                        float32x4_t v902 = *(float32x4_t *)v900[-2].f32;
                        float64x2_t v903 = vcvt_hight_f64_f32(v902);
                        float64x2_t v904 = vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)v902.f32), v899);
                        float64x2_t v905 = vsubq_f64(v903, v899);
                        float64x2_t v906 = vsubq_f64(vcvtq_f64_f32(*v900), v899);
                        float64x2_t v907 = vsubq_f64(vcvt_hight_f64_f32(*(float32x4_t *)v900->f32), v899);
                        float64x2_t v908 = vmulq_f64(v905, v905);
                        float64x2_t v909 = vmulq_f64(v904, v904);
                        float64x2_t v910 = vmulq_f64(v907, v907);
                        float64x2_t v911 = vmulq_f64(v906, v906);
                        double v886 = v886
                             + v909.f64[0]
                             + v909.f64[1]
                             + v908.f64[0]
                             + v908.f64[1]
                             + v911.f64[0]
                             + v911.f64[1]
                             + v910.f64[0]
                             + v910.f64[1];
                        v900 += 4;
                        v901 -= 8;
                      }
                      while (v901);
                      if (v898 != v880)
                      {
LABEL_1048:
                        uint64_t v912 = v880 - v898;
                        v913 = &v719[v898 + v875];
                        do
                        {
                          float v914 = *v913++;
                          double v886 = v886 + (v914 - v887) * (v914 - v887);
                          --v912;
                        }
                        while (v912);
                      }
                    }
                    double v915 = sqrt(v886 / (double)(v877 - v875));
                    if (v915 <= 0.05)
                    {
                      *(float *)&unsigned int v917 = v887;
                      uint64_t v885 = v917;
                      uint64_t v884 = 0x100000000;
                    }
                    else
                    {
                      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                        && __cxa_guard_acquire(&qword_1EB9F1610))
                      {
                        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                        __cxa_guard_release(&qword_1EB9F1610);
                      }
                      v916 = qword_1EB9F1620;
                      if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
                      {
                        v2022[0].i32[0] = 134217984;
                        *(float32x2_t *)((char *)v2022 + 4) = *(float32x2_t *)&v915;
                        _os_log_impl(&dword_1D0DBD000, v916, OS_LOG_TYPE_INFO, "skipping pose refinement: the scaling ratios have a high variance (stddev=%g)", (uint8_t *)v2022, 0xCu);
                      }
                      uint64_t v884 = 0;
                      uint64_t v885 = 0;
                    }
                  }
                  if (v719) {
                    operator delete(v719);
                  }
                  uint64_t v712 = v885 | v884;
LABEL_1059:
                  kdebug_trace();
                  uint64_t v713 = *a2;
LABEL_1060:
                  v918 = *(unsigned char **)(v713 + 8);
                  if (v918[3]) {
                    float v919 = v1953[20];
                  }
                  else {
                    float v919 = 0.0;
                  }
                  v1862.i64[0] = v712;
                  if (v918[4])
                  {
                    v920 = v1953;
                    float v921 = *((float *)&v1951 + 1);
                    float v922 = v1952;
                    float v923 = sinval;
                    float v924 = v1949;
                    float v925 = *(float *)&v1951;
                    float v926 = v1950;
                    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
                      && __cxa_guard_acquire(&qword_1EB9F1618))
                    {
                      sub_1D0E225B4();
                    }
                    float v927 = 1.0 / sqrtf((float)((float)(v925 * v925) + (float)(v921 * v921)) + (float)(v922 * v922));
                    if (cosf((float)(*(float *)(qword_1EB9F15F8 + 220) * 3.1416) / 180.0) >= (float)-(float)((float)(v926 * (float)(v922 * v927)) + (float)((float)(v923 * (float)(v925 * v927)) + (float)(v924 * (float)(v921 * v927))))) {
                      float v919 = 0.0;
                    }
                    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
                      && __cxa_guard_acquire(&qword_1EB9F1618))
                    {
                      sub_1D0E225B4();
                    }
                    float v928 = *(float *)(qword_1EB9F15F8 + 224);
                    v929 = (float *)*((void *)v920 + 3);
                    float v930 = 0.5;
                    if (v929[40] > v928 || v929[41] > v928 || v929[42] > v928 || v929[43] > v928) {
                      float v919 = 0.0;
                    }
                    uint64_t v713 = *a2;
                    v918 = *(unsigned char **)(*a2 + 8);
                  }
                  else
                  {
                    float v930 = 0.5;
                  }
                  v931 = (float32x2_t **)v1955;
                  int v932 = v918[8];
                  uint64_t v933 = *(void *)(v713 + 16);
                  uint64_t v934 = *(void *)(*(void *)v1955 + 152);
                  if (!v934) {
                    sub_1D0E42438();
                  }
                  *(_DWORD *)&buf[28] = 0;
                  *(_DWORD *)&unsigned char buf[12] = 0;
                  *(void *)&buf[20] = 0;
                  *(void *)&uint8_t buf[4] = 0;
                  *(_DWORD *)int buf = 1065353216;
                  *(_DWORD *)&uint8_t buf[16] = 1065353216;
                  *(_DWORD *)&buf[32] = 1065353216;
                  *(void *)&buf[36] = 0;
                  *(_DWORD *)&buf[44] = 0;
                  v1884 = (float32x2_t **)v1955;
                  if (*(int *)(v934 + 128) <= 1)
                  {
                    *(_OWORD *)int buf = v1929;
                    *(_OWORD *)&uint8_t buf[16] = v1930;
                    *(_DWORD *)&buf[32] = v1931;
                    goto LABEL_1180;
                  }
                  unint64_t v935 = *(void *)(v934 + 168);
                  int keye = v932;
                  if (v935) {
                    goto LABEL_1131;
                  }
                  v937 = *(uint64_t **)(v934 + 144);
                  v936 = *(uint64_t **)(v934 + 152);
                  unint64_t v938 = v936 - v937;
                  uint64_t v939 = 113 * v938 - 1;
                  if (v936 == v937) {
                    uint64_t v939 = 0;
                  }
                  if ((unint64_t)(v939 - *(void *)(v934 + 176)) >= 0x71)
                  {
                    *(void *)(v934 + 168) = 113;
                    v2022[0] = (float32x2_t)*(v936 - 1);
                    *(void *)(v934 + 152) = v936 - 1;
                    sub_1D0E3EA48((void **)(v934 + 136), v2022);
                    goto LABEL_1130;
                  }
                  v940 = *(char **)(v934 + 160);
                  v941 = *(char **)(v934 + 136);
                  if (v938 < (v940 - v941) >> 3)
                  {
                    if (v937 == (uint64_t *)v941)
                    {
                      v2022[0] = (float32x2_t)operator new(0xFE4uLL);
                      sub_1D0E3EBF0((char **)(v934 + 136), v2022);
                      uint64_t v946 = *(void *)(v934 + 152);
                      v2022[0] = *(float32x2_t *)(v946 - 8);
                      *(void *)(v934 + 152) = v946 - 8;
                    }
                    else
                    {
                      v2022[0] = (float32x2_t)operator new(0xFE4uLL);
                    }
                    sub_1D0E3EA48((void **)(v934 + 136), v2022);
                    if (*(void *)(v934 + 152) - *(void *)(v934 + 144) == 8) {
                      *(void *)(v934 + 168) = 56;
                    }
                    else {
                      *(void *)(v934 + 168) += 113;
                    }
                    goto LABEL_1130;
                  }
                  if (v940 == v941) {
                    unint64_t v942 = 1;
                  }
                  else {
                    unint64_t v942 = (v940 - v941) >> 2;
                  }
                  if (v942 >> 61) {
                    goto LABEL_2232;
                  }
                  v943 = (char *)operator new(8 * v942);
                  v944 = operator new(0xFE4uLL);
                  if (v942)
                  {
                    v945 = &v943[8 * v942];
                  }
                  else
                  {
                    v947 = (char *)operator new(8uLL);
                    v945 = v947 + 8;
                    operator delete(v943);
                    v937 = *(uint64_t **)(v934 + 144);
                    v936 = *(uint64_t **)(v934 + 152);
                    v943 = v947;
                  }
                  *(void *)v943 = v944;
                  v948 = v943 + 8;
                  v949 = v943;
                  if (v937 == v936)
                  {
LABEL_1099:
                    v950 = *(void **)(v934 + 136);
                    *(void *)(v934 + 136) = v943;
                    *(void *)(v934 + 144) = v949;
                    *(void *)(v934 + 152) = v948;
                    *(void *)(v934 + 160) = v945;
                    if (v948 - v949 == 8) {
                      uint64_t v951 = 56;
                    }
                    else {
                      uint64_t v951 = *(void *)(v934 + 168) + 113;
                    }
                    *(void *)(v934 + 168) = v951;
                    if (v950) {
                      operator delete(v950);
                    }
LABEL_1130:
                    unint64_t v935 = *(void *)(v934 + 168);
LABEL_1131:
                    uint64_t v974 = *(void *)(v934 + 144);
                    v975 = (void *)(v974 + 8 * (v935 / 0x71));
                    uint64_t v976 = *v975 + 36 * (v935 % 0x71);
                    if (*(void *)(v934 + 152) == v974) {
                      uint64_t v976 = 0;
                    }
                    if (v976 == *v975) {
                      uint64_t v976 = *(v975 - 1) + 4068;
                    }
                    long long v977 = v1929;
                    long long v978 = v1930;
                    *(_DWORD *)(v976 - 4) = v1931;
                    *(_OWORD *)(v976 - 20) = v978;
                    *(_OWORD *)(v976 - 36) = v977;
                    uint64_t v979 = *(void *)(v934 + 176) + 1;
                    --*(void *)(v934 + 168);
                    *(void *)(v934 + 176) = v979;
                    unint64_t v980 = (int)v979;
                    uint64_t v982 = *(void *)(v934 + 184);
                    v981 = *(char **)(v934 + 192);
                    unint64_t v983 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v981[-v982] >> 2);
                    unint64_t v984 = (int)v979 - v983;
                    if ((int)v979 <= v983)
                    {
                      if ((int)v979 < v983)
                      {
                        v981 = (char *)(v982 + 12 * (int)v979);
                        *(void *)(v934 + 192) = v981;
                      }
                      goto LABEL_1152;
                    }
                    uint64_t v985 = *(void *)(v934 + 200);
                    if (0xAAAAAAAAAAAAAAABLL * ((v985 - (uint64_t)v981) >> 2) >= v984)
                    {
                      bzero(*(void **)(v934 + 192), 12 * ((12 * v984 - 12) / 0xC) + 12);
                      v994 = &v981[12 * ((12 * v984 - 12) / 0xC) + 12];
                      *(void *)(v934 + 192) = v994;
                      goto LABEL_1151;
                    }
                    if (v979 << 32 < 0) {
                      goto LABEL_2233;
                    }
                    unint64_t v986 = 0xAAAAAAAAAAAAAAABLL * ((v985 - v982) >> 2);
                    if (2 * v986 > (int)v979) {
                      unint64_t v980 = 2 * v986;
                    }
                    if (v986 >= 0xAAAAAAAAAAAAAAALL) {
                      unint64_t v980 = 0x1555555555555555;
                    }
                    if (v980 > 0x1555555555555555) {
                      goto LABEL_2232;
                    }
                    uint64_t v987 = 12 * v980;
                    v988 = (char *)operator new(12 * v980);
                    v989 = &v988[4 * ((uint64_t)&v981[-v982] >> 2)];
                    size_t v990 = 12 * ((12 * v984 - 12) / 0xC) + 12;
                    bzero(v989, v990);
                    v991 = v989;
                    if (v981 != (char *)v982)
                    {
                      do
                      {
                        uint64_t v992 = *(void *)(v981 - 12);
                        v981 -= 12;
                        int v993 = *((_DWORD *)v981 + 2);
                        *(void *)(v991 - 12) = v992;
                        v991 -= 12;
                        *((_DWORD *)v991 + 2) = v993;
                      }
                      while (v981 != (char *)v982);
                      v981 = *(char **)(v934 + 184);
                    }
                    v994 = &v989[v990];
                    *(void *)(v934 + 184) = v991;
                    *(void *)(v934 + 192) = &v989[v990];
                    *(void *)(v934 + 200) = &v988[v987];
                    if (v981)
                    {
                      operator delete(v981);
                      v994 = *(char **)(v934 + 192);
                    }
LABEL_1151:
                    uint64_t v982 = *(void *)(v934 + 184);
                    v981 = v994;
LABEL_1152:
                    if ((int)(-1431655765 * ((unint64_t)&v981[-v982] >> 2)) >= 1)
                    {
                      uint64_t v995 = 0;
                      uint64_t v996 = 0;
                      do
                      {
                        unint64_t v997 = v996 + *(void *)(v934 + 168);
                        uint64_t v998 = *(void *)(*(void *)(v934 + 144) + 8 * (v997 / 0x71));
                        __p[0] = &v1929;
                        *(void *)v2013 = v998 + 36 * (v997 % 0x71);
                        *(void *)&v2013[8] = __p;
                        memset(v2022, 0, sizeof(v2022));
                        int v2023 = 0;
                        sub_1D0E21CFC((uint64_t)v2022, (uint64_t)v2013);
                        *(_DWORD *)&v2006[8] = 0;
                        *(void *)v2006 = 0;
                        sub_1D0E21ECC(v2022, (float *)v2006);
                        uint64_t v999 = *(void *)(v934 + 184) + v995;
                        *(void *)uint64_t v999 = *(void *)v2006;
                        *(_DWORD *)(v999 + 8) = *(_DWORD *)&v2006[8];
                        ++v996;
                        uint64_t v982 = *(void *)(v934 + 184);
                        v995 += 12;
                      }
                      while (v996 < (int)(-1431655765 * ((unint64_t)(*(void *)(v934 + 192) - v982) >> 2)));
                    }
                    float v1000 = 0.0;
                    float v1001 = 0.0;
                    if ((int)v979 >= 1)
                    {
                      uint64_t v1002 = v979;
                      v1003 = (float *)(v982 + 8);
                      do
                      {
                        float v1004 = (float)(*(v1003 - 2) * *(v1003 - 2)) + (float)(*(v1003 - 1) * *(v1003 - 1));
                        float v1005 = *v1003;
                        v1003 += 3;
                        float v1006 = sqrtf(v1004 + (float)(v1005 * v1005));
                        if (v1001 < v1006) {
                          float v1001 = v1006;
                        }
                        --v1002;
                      }
                      while (v1002);
                    }
                    float v1007 = expf(-fminf(v1001 * *(float *)(v934 + 132), 10.0));
                    int v932 = keye;
                    if ((int)v979 >= 1)
                    {
                      float v1008 = 1.0;
                      float v1000 = 0.0;
                      int v1009 = v979;
                      do
                      {
                        float v1000 = v1008 + v1000;
                        float v1008 = v1007 * v1008;
                        --v1009;
                      }
                      while (v1009);
                    }
                    float v1010 = 1.0 / v1000;
                    float v1011 = (float)(1.0 / v1000) * *(float *)v982;
                    _D16 = vmul_n_f32(*(float32x2_t *)(v982 + 4), 1.0 / v1000);
                    if ((int)v979 <= 1)
                    {
                      v931 = v1884;
                    }
                    else
                    {
                      uint64_t v1013 = v979 - 1;
                      v1014 = (void *)(v982 + 16);
                      v931 = v1884;
                      do
                      {
                        float v1010 = v1007 * v1010;
                        float v1011 = v1011 + (float)(v1010 * *((float *)v1014 - 1));
                        float32x2_t v1015 = *(float32x2_t *)v1014;
                        v1014 = (void *)((char *)v1014 + 12);
                        _D16 = vadd_f32(_D16, vmul_n_f32(v1015, v1010));
                        --v1013;
                      }
                      while (v1013);
                    }
                    uint64_t v1016 = *(void *)(v934 + 176);
                    int v1017 = *(_DWORD *)(v934 + 128);
                    float32x2_t v1912 = _D16;
                    if (v1017 <= (int)v1016)
                    {
                      uint64_t v1023 = *(void *)(v934 + 152);
                      do
                      {
                        uint64_t v1024 = *(void *)(v934 + 168);
                        if (v1023 == *(void *)(v934 + 144)) {
                          uint64_t v1025 = 0;
                        }
                        else {
                          uint64_t v1025 = 113 * ((v1023 - *(void *)(v934 + 144)) >> 3) - 1;
                        }
                        uint64_t v1026 = v1016 - 1;
                        *(void *)(v934 + 176) = v1016 - 1;
                        if ((unint64_t)(v1025 - (v1016 + v1024) + 1) >= 0xE2)
                        {
                          operator delete(*(void **)(v1023 - 8));
                          _D16 = v1912;
                          uint64_t v1023 = *(void *)(v934 + 152) - 8;
                          *(void *)(v934 + 152) = v1023;
                          uint64_t v1026 = *(void *)(v934 + 176);
                          int v1017 = *(_DWORD *)(v934 + 128);
                        }
                        uint64_t v1016 = v1026;
                      }
                      while (v1017 <= (int)v1026);
                    }
                    float32x2_t v1018 = vmul_f32(_D16, _D16);
                    float v1019 = v1018.f32[1] + (float)(v1018.f32[0] + (float)(v1011 * v1011));
                    if (v1019 >= 0.0061)
                    {
                      float v1027 = sqrtf(v1019);
                      __float2 v1028 = __sincosf_stret(v1027);
                      float cosval = v1028.__cosval;
                      _D16 = v1912;
                      float v1021 = v1028.__sinval / v1027;
                      float v1020 = (float)(1.0 / v1019) * (float)(1.0 - v1028.__cosval);
                    }
                    else
                    {
                      float v1020 = v930 - (float)(v1019 * (float)((float)(v1019 / -720.0) + 0.041667));
                      float v1021 = 1.0
                            - (float)(v1019
                                    * (float)(0.16667 - (float)(v1019 * (float)((float)(v1019 / -5040.0) + 0.0083333))));
                      float cosval = 1.0 - (float)(v1019 * v1020);
                    }
                    float v1029 = v1011 * v1020;
                    _S4 = vmuls_lane_f32(v1020, _D16, 1);
                    float32_t v1031 = cosval + (float)((float)(v1011 * v1020) * v1011);
                    float v1032 = cosval;
                    __asm { FMLA            S1, S4, V16.S[1] }
                    int v2023 = _S1;
                    float v1034 = (float)(v1011 * v1020) * _D16.f32[0];
                    float v1035 = vmuls_lane_f32(v1021, _D16, 1);
                    v2022[0].f32[0] = v1031;
                    v2022[0].f32[1] = v1034 + v1035;
                    float v1036 = v1020 * _D16.f32[0];
                    float v1037 = vmlas_n_f32(v1032, v1036, _D16.f32[0]);
                    float v1038 = vmuls_lane_f32(v1029, _D16, 1);
                    float v1039 = vmuls_lane_f32(v1036, _D16, 1);
                    float v1040 = v1011 * v1021;
                    float v1041 = v1021 * _D16.f32[0];
                    v2022[3].f32[0] = v1041 + v1038;
                    v2022[3].f32[1] = v1039 - v1040;
                    v2022[1].f32[0] = v1038 - v1041;
                    v2022[1].f32[1] = v1034 - v1035;
                    v2022[2].f32[0] = v1037;
                    v2022[2].f32[1] = v1040 + v1039;
                    *(void *)v2013 = v2022;
                    *(void *)&v2013[8] = &v1929;
                    memset(buf, 0, 36);
                    sub_1D0DF1BF0((uint64_t)buf, (float **)v2013);
LABEL_1180:
                    sub_1D0E3FAB8(v2022, v934 + 208, &v1932);
                    *(float32x2_t *)&buf[36] = v2022[0];
                    *(_DWORD *)&buf[44] = v2022[1].i32[0];
                    *(_OWORD *)v2022[0].f32 = v1929;
                    *(_OWORD *)v2022[2].f32 = v1930;
                    int v2023 = v1931;
                    float32x2_t v2024 = v1932;
                    float v2025 = v1933;
                    *(_OWORD *)v2013 = *(_OWORD *)buf;
                    *(_OWORD *)&v2013[16] = *(_OWORD *)&buf[16];
                    int v2014 = *(_DWORD *)&buf[32];
                    float32x2_t v2015 = *(float32x2_t *)&buf[36];
                    float v2016 = *(float *)&buf[44];
                    if (v932)
                    {
                      v1042 = *v931;
                      if (HIDWORD(v1862.i64[0]))
                      {
                        v1042[20].i32[0] = v1862.i32[0];
                        v1042[20].i8[4] = v1862.i8[4];
                      }
                      else if (!*(void *)&v1042[16])
                      {
                        v1042[20].i32[0] = 1065353216;
                        v1042[20].i8[4] = 1;
                      }
                      uint64_t v1043 = *(void *)&(*v931)[19] + 528;
                      LODWORD(__p[0]) = (*v931)[20].i32[0];
                      float keyf = *(float *)__p;
                      sub_1D0E400DC((float *)v2006, v1043, (float *)__p);
                      float v1913 = *(float *)v2006;
                      *(_DWORD *)v2006 = *(_DWORD *)&v1975[4];
                      *(_DWORD *)&v2006[4] = *(_DWORD *)&v1975[16];
                      *(_DWORD *)&v2006[8] = *(_DWORD *)&v1975[28];
                      *(_DWORD *)&v2006[12] = *(_DWORD *)&v1975[8];
                      *(_DWORD *)&v2006[16] = *(_DWORD *)&v1975[20];
                      int v2007 = *(_DWORD *)&v1975[32];
                      float v2012 = 0.0;
                      float32x2_t v2011 = 0;
                      int v2008 = *(_DWORD *)&v1975[12];
                      int v2009 = *(_DWORD *)&v1975[24];
                      int v2010 = *(_DWORD *)&v1975[36];
                      memptr[0] = v2006;
                      __p[0] = memptr;
                      __p[1] = &v1976;
                      sub_1D0E1EC78((float *)&v2011, (uint64_t)__p);
                      long long v1999 = 0x3F800000uLL;
                      HIDWORD(__p[1]) = 0;
                      *(void **)((char *)__p + 4) = 0;
                      LODWORD(__p[0]) = 1065353216;
                      int v2000 = 1065353216;
                      float32x2_t v2001 = 0;
                      float v2002 = 0.0;
                      memptr[0] = &v1975[4];
                      memptr[1] = &v1929;
                      sub_1D0DF1BF0((uint64_t)__p, (float **)memptr);
                      *(void *)&long long v1988 = &v1975[4];
                      *((void *)&v1988 + 1) = &v1932;
                      *(void **)((char *)memptr + 4) = 0;
                      HIDWORD(memptr[1]) = 0;
                      sub_1D0DF1DA0((float *)memptr + 1, (float **)&v1988);
                      float32x2_t v1044 = v1976;
                      float32x2_t v2001 = vadd_f32(*(float32x2_t *)((char *)memptr + 4), v1976);
                      float v1045 = v1977;
                      float v2002 = *((float *)&memptr[1] + 1) + v1977;
                      long long v1994 = 0x3F800000uLL;
                      HIDWORD(memptr[1]) = 0;
                      *(void **)((char *)memptr + 4) = 0;
                      LODWORD(memptr[0]) = 1065353216;
                      int v1995 = 1065353216;
                      float32x2_t v1996 = 0;
                      float v1997 = 0.0;
                      *(void *)&long long v1988 = &v1975[4];
                      *((void *)&v1988 + 1) = buf;
                      sub_1D0DF1BF0((uint64_t)memptr, (float **)&v1988);
                      *(void *)&long long v1983 = &v1975[4];
                      *((void *)&v1983 + 1) = &buf[36];
                      *(void *)((char *)&v1988 + 4) = 0;
                      HIDWORD(v1988) = 0;
                      sub_1D0DF1DA0((float *)&v1988 + 1, (float **)&v1983);
                      float32x2_t v1996 = vadd_f32(*(float32x2_t *)((char *)&v1988 + 4), v1044);
                      float v1997 = *((float *)&v1988 + 3) + v1045;
                      long long v1983 = *(_OWORD *)__p;
                      long long v1984 = v1999;
                      int v1985 = v2000;
                      float32x2_t v1986 = vmul_n_f32(v2001, keyf);
                      float v1987 = v2002 * keyf;
                      long long v1988 = 0x3F800000uLL;
                      long long v1989 = 0x3F800000uLL;
                      int v1990 = 1065353216;
                      float v1992 = 0.0;
                      float32x2_t v1991 = 0;
                      *(void *)&v2005[0] = v2006;
                      *((void *)&v2005[0] + 1) = &v1983;
                      sub_1D0DF1BF0((uint64_t)&v1988, (float **)v2005);
                      v2003 = (float *)v2006;
                      v2004 = &v1986;
                      *(void *)((char *)v2005 + 4) = 0;
                      HIDWORD(v2005[0]) = 0;
                      sub_1D0DF1DA0((float *)v2005 + 1, &v2003);
                      float32x2_t v1046 = v2011;
                      float32x2_t v1991 = vadd_f32(*(float32x2_t *)((char *)v2005 + 4), v2011);
                      float v1047 = v2012;
                      *(_OWORD *)v2022[0].f32 = v1988;
                      *(_OWORD *)v2022[2].f32 = v1989;
                      int v2023 = v1990;
                      float32x2_t v2024 = v1991;
                      float v2025 = *((float *)v2005 + 3) + v2012;
                      long long v1983 = *(_OWORD *)memptr;
                      long long v1984 = v1994;
                      int v1985 = v1995;
                      float32x2_t v1986 = vmul_n_f32(v1996, v1913);
                      float v1987 = v1997 * v1913;
                      long long v1988 = 0x3F800000uLL;
                      long long v1989 = 0x3F800000uLL;
                      int v1990 = 1065353216;
                      float v1992 = 0.0;
                      float32x2_t v1991 = 0;
                      *(void *)&v2005[0] = v2006;
                      *((void *)&v2005[0] + 1) = &v1983;
                      sub_1D0DF1BF0((uint64_t)&v1988, (float **)v2005);
                      v2003 = (float *)v2006;
                      v2004 = &v1986;
                      *(void *)((char *)v2005 + 4) = 0;
                      HIDWORD(v2005[0]) = 0;
                      sub_1D0DF1DA0((float *)v2005 + 1, &v2003);
                      float32x2_t v1991 = vadd_f32(*(float32x2_t *)((char *)v2005 + 4), v1046);
                      float v1992 = *((float *)v2005 + 3) + v1047;
                      *(_OWORD *)v2013 = v1988;
                      *(_OWORD *)&v2013[16] = v1989;
                      int v2014 = v1990;
                      float32x2_t v2015 = v1991;
                      v931 = v1884;
                      float v2016 = *((float *)v2005 + 3) + v1047;
                    }
                    else
                    {
                      float v1913 = 1.0;
                      float keyf = 1.0;
                    }
                    float32x2_t v1048 = (*v931)[19];
                    uint64_t v1049 = *(void *)&v1048 + 400;
                    uint64_t v1050 = 384;
                    if (v919 <= v930) {
                      uint64_t v1049 = *(void *)&v1048 + 384;
                    }
                    else {
                      uint64_t v1050 = 400;
                    }
                    v1051 = *(void ***)(*(void *)&v1048 + v1050);
                    v1052 = *(std::__shared_weak_count **)(v1049 + 8);
                    v1849 = v1052;
                    if (v1052)
                    {
                      atomic_fetch_add_explicit(&v1052->__shared_owners_, 1uLL, memory_order_relaxed);
                      float32x2_t v1048 = (*v931)[19];
                    }
                    v1053 = (void **)(*(void *)&v1048 + 264);
                    v1054 = v1953;
                    v1055 = (const void **)(v1953 + 6);
                    unint64_t v1056 = *(unsigned int *)(*(void *)&v1048 + 280);
                    unint64_t v1057 = *((unsigned int *)v1953 + 10);
                    if (v1056 == v1057)
                    {
                      if (!v1051)
                      {
                        v1051 = (void **)(*(void *)&v1048 + 360);
                        if (*(_DWORD *)(*(void *)&v1048 + 376) != v1056)
                        {
                          *(_DWORD *)(*(void *)&v1048 + 376) = v1056;
                          if (v1056)
                          {
                            v1058 = *(void **)(*(void *)&v1048 + 360);
                            if (*(void *)(*(void *)&v1048 + 368) < v1056)
                            {
                              free(v1058);
                              size_t v1059 = (4 * v1056 + 31) & 0x7FFFFFFE0;
                              *(void *)(*(void *)&v1048 + 360) = 0;
                              *(void *)(*(void *)&v1048 + 368) = v1059 >> 2;
                              *(void *)v2006 = 0;
                              malloc_type_posix_memalign((void **)v2006, 0x20uLL, v1059, 0x49090899uLL);
                              v1058 = *(void **)v2006;
                              *(void *)(*(void *)&v1048 + 360) = *(void *)v2006;
                            }
                          }
                          else
                          {
                            free(*v1051);
                            v1058 = 0;
                            *v1051 = 0;
                            *(void *)(*(void *)&v1048 + 368) = 0;
                          }
                          uint64_t v1118 = *(unsigned int *)(*(void *)&v1048 + 376);
                          if (v1118) {
                            memset_pattern16(v1058, &unk_1D0E818E0, 4 * v1118);
                          }
                        }
                      }
                      uint64_t v1065 = *(unsigned int *)(*(void *)&v1048 + 280);
                      if (v1065)
                      {
                        v1119 = *(float **)(*(void *)&v1048 + 264);
                        v1120 = *(float **)(*(void *)&v1048 + 288);
                        v1121 = (float *)*v1055;
                        v1122 = (float *)*v1051;
                        do
                        {
                          float v1127 = *v1119;
                          float v1128 = *v1119 + (float)(*(float *)(*(void *)&v1048 + 336) * *v1120);
                          float v1129 = vabds_f32(*v1121, v1128);
                          float v1130 = *(float *)(*(void *)&v1048 + 316);
                          float v1123 = 0.0;
                          if (v1129 >= v1130)
                          {
                            if (v1129 < *(float *)(*(void *)&v1048 + 320))
                            {
                              float v1123 = (float)(v1129 - v1130) * *(float *)(*(void *)&v1048 + 344);
                            }
                            else
                            {
                              float v1131 = *(float *)(*(void *)&v1048 + 324);
                              float v1123 = 1.0;
                              if (v1129 >= v1131)
                              {
                                float v1123 = 0.0;
                                if (v1129 < *(float *)(*(void *)&v1048 + 328)) {
                                  float v1123 = 1.0 - (float)((float)(v1129 - v1131) * *(float *)(*(void *)&v1048 + 348));
                                }
                              }
                            }
                          }
                          float v1124 = *v1122++;
                          float v1125 = fminf(*(float *)(*(void *)&v1048 + 340)+ (float)(v1123 / (float)((float)(*(float *)(*(void *)&v1048 + 312) * v1124) + 1.0)), 1.0);
                          float v1126 = (float)(v1128 * (float)(1.0 - v1125)) + (float)(v1125 * *v1121);
                          *v1119++ = v1126;
                          float *v1120 = (float)((float)(1.0 - *(float *)(*(void *)&v1048 + 352)) * *v1120)
                                 + (float)(*(float *)(*(void *)&v1048 + 352) * (float)(v1126 - v1127));
                          ++v1120;
                          ++v1121;
                          --v1065;
                        }
                        while (v1065);
                        goto LABEL_1214;
                      }
                    }
                    else
                    {
                      if (v1053 != (void **)v1055)
                      {
                        if (*((_DWORD *)v1953 + 10))
                        {
                          v1060 = *(void **)(*(void *)&v1048 + 264);
                          if (*(void *)(*(void *)&v1048 + 272) >= v1057)
                          {
                            size_t v1061 = 4 * v1057;
                          }
                          else
                          {
                            free(v1060);
                            size_t v1061 = 4 * v1057;
                            size_t v1062 = (4 * v1057 + 31) & 0x7FFFFFFE0;
                            *(void *)(*(void *)&v1048 + 264) = 0;
                            *(void *)(*(void *)&v1048 + 272) = v1062 >> 2;
                            *(void *)v2006 = 0;
                            malloc_type_posix_memalign((void **)v2006, 0x20uLL, v1062, 0x49090899uLL);
                            v1060 = *(void **)v2006;
                            *(void *)(*(void *)&v1048 + 264) = *(void *)v2006;
                          }
                          memcpy(v1060, *v1055, v1061);
                        }
                        else
                        {
                          free(*v1053);
                          *v1053 = 0;
                          *(void *)(*(void *)&v1048 + 272) = 0;
                        }
                        *(float *)(*(void *)&v1048 + 280) = v1054[10];
                        unint64_t v1057 = *((unsigned int *)v1054 + 10);
                      }
                      v1063 = (void **)(*(void *)&v1048 + 288);
                      if (v1057 != *(_DWORD *)(*(void *)&v1048 + 304))
                      {
                        *(_DWORD *)(*(void *)&v1048 + 304) = v1057;
                        if (v1057)
                        {
                          if (*(void *)(*(void *)&v1048 + 296) < v1057)
                          {
                            free(*(void **)(*(void *)&v1048 + 288));
                            size_t v1064 = (4 * v1057 + 31) & 0x7FFFFFFE0;
                            *(void *)(*(void *)&v1048 + 288) = 0;
                            *(void *)(*(void *)&v1048 + 296) = v1064 >> 2;
                            *(void *)v2006 = 0;
                            malloc_type_posix_memalign((void **)v2006, 0x20uLL, v1064, 0x49090899uLL);
                            *(void *)(*(void *)&v1048 + 288) = *(void *)v2006;
                          }
                        }
                        else
                        {
                          free(*v1063);
                          *v1063 = 0;
                          *(void *)(*(void *)&v1048 + 296) = 0;
                        }
                        unint64_t v1057 = *(unsigned int *)(*(void *)&v1048 + 304);
                      }
                      if (v1057) {
                        bzero(*v1063, 4 * v1057);
                      }
LABEL_1214:
                      uint64_t v1065 = *(unsigned int *)(*(void *)&v1048 + 280);
                    }
                    size_t v1066 = (4 * v1065 + 31) & 0x7FFFFFFE0;
                    *(void *)v2006 = 0;
                    malloc_type_posix_memalign((void **)v2006, 0x20uLL, v1066, 0x49090899uLL);
                    v1067 = *(float **)v2006;
                    if (v1065) {
                      memcpy(*(void **)v2006, *v1053, 4 * v1065);
                    }
                    uint64_t v1068 = *(unsigned int *)(*(void *)&v1048 + 280);
                    uint64_t v1069 = *(void *)(v933 + 8);
                    uint64_t v1070 = *(unsigned int *)(v1069 + 80);
                    if ((int)v1070 >= 1)
                    {
                      uint64_t v1071 = 0;
                      uint64_t v1072 = *(void *)(v1069 + 64);
                      uint64_t v1073 = 3 * v1070;
                      do
                      {
                        uint64_t v1074 = v1072 + 4 * v1071;
                        uint64_t v1075 = *(unsigned int *)(v1074 + 4);
                        uint64_t v1076 = *(unsigned int *)(v1074 + 8);
                        float v1077 = v1067[v1075] - v1067[v1076];
                        float v1078 = fminf(v1077, 1.0);
                        BOOL v1079 = v1077 > 0.0;
                        if (v1077 < 0.0) {
                          float v1078 = 0.0;
                        }
                        v1067[v1075] = v1078;
                        float v1080 = fminf(-v1077, 1.0);
                        if (v1079) {
                          float v1080 = 0.0;
                        }
                        v1067[v1076] = v1080;
                        v1071 += 3;
                      }
                      while (v1073 != v1071);
                    }
                    if (v1068)
                    {
                      unint64_t v1081 = (v1068 - 1) & 0x3FFFFFFFFFFFFFFFLL;
                      v1082 = v1067;
                      if (v1081 <= 6)
                      {
                        do
                        {
LABEL_1230:
                          float v1087 = fminf(*v1082, 1.0);
                          if (*v1082 >= 0.0) {
                            float v1088 = v1087;
                          }
                          else {
                            float v1088 = 0.0;
                          }
                          *v1082++ = v1088;
                        }
                        while (v1082 != &v1067[v1068]);
                      }
                      else
                      {
                        uint64_t v1083 = (v1081 + 1) & 0x7FFFFFFFFFFFFFF8;
                        v1084 = (float32x4_t *)(v1067 + 4);
                        uint64_t v1085 = v1083;
                        do
                        {
                          int8x16_t v1086 = vandq_s8((int8x16_t)vminnmq_f32(*v1084, v1923), (int8x16_t)vcgezq_f32(*v1084));
                          v1084[-1] = (float32x4_t)vandq_s8((int8x16_t)vminnmq_f32(v1084[-1], v1923), (int8x16_t)vcgezq_f32(v1084[-1]));
                          float32x4_t *v1084 = (float32x4_t)v1086;
                          v1084 += 2;
                          v1085 -= 8;
                        }
                        while (v1085);
                        if (v1081 + 1 != v1083)
                        {
                          v1082 = &v1067[v1083];
                          goto LABEL_1230;
                        }
                      }
                    }
                    sub_1D0E3FAB8((float32x2_t *)__p, *(void *)&(*v931)[19] + 416, (float32x2_t *)v1953 + 6);
                    *(void *)&long long v1988 = 0;
                    *(void *)&long long v1983 = 0;
                    v1089 = v1953;
                    v1090 = v1954;
                    if (v1954)
                    {
                      atomic_fetch_add_explicit(&v1954->__shared_owners_, 1uLL, memory_order_relaxed);
                      float v1091 = sub_1D0E3BDE8(v1089, (float *)__p, v1067, (float *)&v1988, (float *)&v1983);
                      if (!atomic_fetch_add(&v1090->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *, float))v1090->__on_zero_shared)(v1090, v1091);
                        std::__shared_weak_count::__release_weak(v1090);
                      }
                    }
                    else
                    {
                      sub_1D0E3BDE8(v1953, (float *)__p, v1067, (float *)&v1988, (float *)&v1983);
                    }
                    uint64_t v1092 = *(void *)&(*v931)[19] + 472;
                    *(float *)memptr = v919;
                    sub_1D0E400DC((float *)v2006, v1092, (float *)memptr);
                    if (*(float *)v2006 <= 1.0) {
                      float v1093 = *(float *)v2006;
                    }
                    else {
                      float v1093 = 1.0;
                    }
                    if (*(float *)v2006 >= 0.0) {
                      float v1094 = v1093;
                    }
                    else {
                      float v1094 = 0.0;
                    }
                    v1095 = v1953;
                    v1096 = (std::__shared_weak_count *)operator new(0x118uLL);
                    v1096->__shared_owners_ = 0;
                    pixelBuffera = &v1096->__shared_owners_;
                    v1096->__shared_weak_owners_ = 0;
                    v1096->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4D78;
                    uint64_t v1097 = *((unsigned int *)v1095 + 10);
                    size_t v1098 = (4 * v1097 + 31) & 0x7FFFFFFE0;
                    *(void *)&v2006[8] = v1098 >> 2;
                    memptr[0] = 0;
                    malloc_type_posix_memalign(memptr, 0x20uLL, v1098, 0x49090899uLL);
                    *(void **)v2006 = memptr[0];
                    if (v1097) {
                      memcpy(memptr[0], *((const void **)v1095 + 3), 4 * v1097);
                    }
                    v1855 = v1096;
                    *(float *)&v2006[16] = v1095[10];
                    v1841 = &v1096[1].__vftable;
                    sub_1D0E3C5D4((uint64_t)&v1096[1], v1868, &v1929, (long long *)v2022, (uint64_t)v2006, (uint64_t)(v1095 + 28), (uint64_t)(v1095 + 22), (uint64_t *)v1095 + 6, keyf, v919, v1095 + 15, v1095 + 17);
                    free(*(void **)v2006);
                    v1099 = v1953 + 28;
                    v1100 = v1953 + 22;
                    v1101 = (std::__shared_weak_count *)operator new(0x118uLL);
                    v1101->__shared_owners_ = 0;
                    v1101->__shared_weak_owners_ = 0;
                    v1101->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4D78;
                    *(void *)v2006 = v1067;
                    *(void *)&v2006[8] = v1066 >> 2;
                    *(_DWORD *)&v2006[16] = v1068;
                    v1102 = v1101 + 1;
                    sub_1D0E3C5D4((uint64_t)&v1101[1], v1868, (long long *)buf, (long long *)v2013, (uint64_t)v2006, (uint64_t)v1099, (uint64_t)v1100, (uint64_t *)__p, v1913, v1094, &v1988, &v1983);
                    free(*(void **)v2006);
                    v1103 = *v931;
                    unint64_t v1104 = (unint64_t)(*v931)[15];
                    v1105 = v1874;
                    if (v1104) {
                      goto LABEL_1362;
                    }
                    v1106 = (char *)v1103[12];
                    v1107 = (char *)v1103[13];
                    uint64_t v1108 = 16 * (v1107 - v1106) - 1;
                    if (v1107 == v1106) {
                      uint64_t v1108 = 0;
                    }
                    if ((unint64_t)(v1108 - *(void *)&v1103[16]) >= 0x80)
                    {
                      v1103[15] = (float32x2_t)128;
                      *(void *)v2006 = *((void *)v1107 - 1);
                      v1103[13] = (float32x2_t)(v1107 - 8);
                      sub_1D0E3EA48((void **)&v1103[11], v2006);
                      v1102 = v1101 + 1;
                      goto LABEL_1361;
                    }
                    v1109 = (char *)v1103[14];
                    v1110 = (char *)v1103[11];
                    if (v1107 - v1106 < (unint64_t)(v1109 - v1110))
                    {
                      v1111 = operator new(0x1000uLL);
                      if (v1106 != v1110)
                      {
                        v1112 = (char *)v1103[12];
                        if (v1112 != (char *)v1103[11])
                        {
                          v1113 = (char *)v1103[12];
                          v1102 = v1101 + 1;
                          goto LABEL_1356;
                        }
                        v1170 = (unsigned char *)v1103[13];
                        unint64_t v1169 = (unint64_t)v1103[14];
                        if ((unint64_t)v1170 < v1169)
                        {
                          uint64_t v1171 = (uint64_t)(v1169 - (void)v1170) >> 3;
                          if (v1171 >= -1) {
                            uint64_t v1172 = v1171 + 1;
                          }
                          else {
                            uint64_t v1172 = v1171 + 2;
                          }
                          uint64_t v1173 = v1172 >> 1;
                          v1113 = &v1112[8 * (v1172 >> 1)];
                          size_t v1174 = v1170 - v1112;
                          if (v1170 != v1112)
                          {
                            v1175 = v1111;
                            memmove(v1113, *(const void **)&v1103[12], v1174);
                            v1111 = v1175;
                            v1112 = (char *)v1103[13];
                          }
                          v1102 = v1101 + 1;
                          v1103[12] = (float32x2_t)v1113;
                          v1103[13] = (float32x2_t)&v1112[8 * v1173];
                          v1105 = v1874;
LABEL_1356:
                          *((void *)v1113 - 1) = v1111;
                          uint64_t v1210 = *(void *)&v1103[12] - 8;
                          v1103[12] = (float32x2_t)v1210;
LABEL_1357:
                          if (*(void *)&v1103[13] - v1210 == 8) {
                            uint64_t v1212 = 64;
                          }
                          else {
                            uint64_t v1212 = *(void *)&v1103[15] + 128;
                          }
                          v1103[15] = (float32x2_t)v1212;
LABEL_1361:
                          unint64_t v1104 = (unint64_t)v1103[15];
LABEL_1362:
                          float32x2_t v1213 = v1103[12];
                          v1214 = (void *)(*(void *)&v1213 + 8 * (v1104 >> 7));
                          uint64_t v1215 = *v1214 + 32 * (v1104 & 0x7F);
                          if (*(void *)&v1103[13] == *(void *)&v1213) {
                            uint64_t v1215 = 0;
                          }
                          if (v1215 == *v1214) {
                            uint64_t v1215 = *(v1214 - 1) + 4096;
                          }
                          *(void *)(v1215 - 32) = v1841;
                          *(void *)(v1215 - 24) = v1855;
                          atomic_fetch_add_explicit(&v1855->__shared_owners_, 1uLL, memory_order_relaxed);
                          *(void *)(v1215 - 16) = v1102;
                          *(void *)(v1215 - 8) = v1101;
                          atomic_fetch_add_explicit(&v1101->__shared_owners_, 1uLL, memory_order_relaxed);
                          *(int64x2_t *)v1103[15].f32 = vaddq_s64(*(int64x2_t *)v1103[15].f32, (int64x2_t)xmmword_1D0E81770);
                          v1216 = *v931;
                          unint64_t v1217 = (unint64_t)(*v931)[16];
                          if (v1217 < 6)
                          {
LABEL_1367:
                            if (!atomic_fetch_add(&v1101->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v1101->__on_zero_shared)(v1101);
                              std::__shared_weak_count::__release_weak(v1101);
                            }
                            if (!atomic_fetch_add(pixelBuffera, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v1855->__on_zero_shared)(v1855);
                              std::__shared_weak_count::__release_weak(v1855);
                            }
                            uint64_t v1218 = v1869;
                            if (v1849 && !atomic_fetch_add(&v1849->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v1849->__on_zero_shared)(v1849);
                              std::__shared_weak_count::__release_weak(v1849);
                            }
                            v1219 = v1953;
                            v1220 = *v931;
                            if (!*(void *)&(*v931)[19]) {
                              sub_1D0E42438();
                            }
                            if (!*(void *)&v1220[16])
                            {
LABEL_1560:
                              memset(&v2013[8], 0, 24);
                              if (v1858)
                              {
                                uint64_t v1402 = *(void *)(*a2 + 16);
                                float32x2_t v1403 = (*v1884)[1];
                                float32x2_t v1404 = (*v1884)[2];
                                v2022[0] = v1403;
                                v2022[1] = v1404;
                                if (v1404) {
                                  atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v1404 + 8), 1uLL, memory_order_relaxed);
                                }
                                uint64_t v1406 = *(void *)(*(void *)&v1403 + 48);
                                v1405 = *(std::__shared_weak_count **)(*(void *)&v1403 + 56);
                                if (v1405) {
                                  atomic_fetch_add_explicit(&v1405->__shared_owners_, 1uLL, memory_order_relaxed);
                                }
                                uint64_t v1927 = v1406;
                                v1928 = v1405;
                                *(void *)&uint8_t buf[8] = 0;
                                *(void *)int buf = 0;
                                (*(void (**)(uint64_t, uint64_t *, unsigned char *, void))(*(void *)v1402 + 32))(v1402, &v1927, v2013, 0);
                                v1407 = v1928;
                                if (v1928 && !atomic_fetch_add(&v1928->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                {
                                  ((void (*)(std::__shared_weak_count *))v1407->__on_zero_shared)(v1407);
                                  std::__shared_weak_count::__release_weak(v1407);
                                }
                                v1408 = *(std::__shared_weak_count **)&buf[8];
                                if (*(void *)&buf[8]
                                  && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
                                {
                                  ((void (*)(std::__shared_weak_count *))v1408->__on_zero_shared)(v1408);
                                  std::__shared_weak_count::__release_weak(v1408);
                                }
                                v1409 = (std::__shared_weak_count *)v2022[1];
                                if (*(void *)&v2022[1]
                                  && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v2022[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
                                {
                                  ((void (*)(std::__shared_weak_count *))v1409->__on_zero_shared)(v1409);
                                  std::__shared_weak_count::__release_weak(v1409);
                                }
                              }
                              v1410 = v1953;
                              unsigned int v1411 = 2 * *((_DWORD *)v1953 + 52);
                              size_t v1412 = 4 * v1411;
                              size_t v1413 = (v1412 + 31) & 0x7FFFFFFE0;
                              *(void *)v2006 = 0;
                              *(void *)&v2006[8] = v1413 >> 2;
                              *(void *)int buf = 0;
                              malloc_type_posix_memalign((void **)buf, 0x20uLL, v1413, 0x49090899uLL);
                              *(void *)v2006 = *(void *)buf;
                              if (v1411) {
                                memcpy(*(void **)buf, *((const void **)v1410 + 24), v1412);
                              }
                              uint64_t v1414 = *((unsigned int *)v1410 + 52);
                              *(_DWORD *)&v2006[16] = v1414;
                              uint64_t v1415 = (uint64_t)v1105 + 36 * v1218;
                              long long v1416 = *(_OWORD *)(v1415 + 16);
                              v1925[0] = *(_OWORD *)v1415;
                              v1925[1] = v1416;
                              keyuint64_t i = v1415;
                              int v1926 = *(_DWORD *)(v1415 + 32);
                              if (v1414)
                              {
                                uint64_t v1417 = 0;
                                uint64_t v1418 = *(void *)v2006;
                                uint64_t v1419 = 2 * v1414;
                                do
                                {
                                  v1420 = (void **)(v1418 + 4 * (v1417 & 0xFFFFFFFE));
                                  __p[0] = *v1420;
                                  LODWORD(__p[1]) = 1065353216;
                                  *(void *)int buf = v1925;
                                  *(void *)&uint8_t buf[8] = __p;
                                  v2022[0] = 0;
                                  v2022[1].i32[0] = 0;
                                  sub_1D0DF1DA0((float *)v2022, (float **)buf);
                                  v1421 = &v2022[1];
                                  float32x2_t v1422 = vld1_dup_f32((const float *)v1421);
                                  *v1420 = (void *)vdiv_f32(v2022[0], v1422);
                                  v1417 += 2;
                                }
                                while (v1419 != v1417);
                              }
                              kdebug_trace();
                              uint64_t v1423 = v1955;
                              float v1424 = v1953[19];
                              v1425 = *(float **)(*a2 + 8);
                              int v1426 = (*(uint64_t (**)(void))(**(void **)(*a2 + 160) + 32))(*(void *)(*a2 + 160));
                              kdebug_trace();
                              if (v1426) {
                                uint64_t v1427 = 0;
                              }
                              else {
                                uint64_t v1427 = 100;
                              }
                              uint64_t v1428 = *(void *)(*(void *)v1423 + 128);
                              if (!v1428)
                              {
                                uint64_t v1431 = 7;
                                uint64_t v1432 = 0;
                                uint64_t v1433 = 0;
                                uint64_t v1434 = 1;
                                uint64_t v1435 = 0;
                                goto LABEL_1683;
                              }
                              if (v1428 != 1)
                              {
                                v1436 = (uint64_t *)(*(void *)(*(void *)(*(void *)v1423 + 96)
                                                              + (((unint64_t)(*(void *)(*(void *)v1423 + 120)
                                                                                   + 1) >> 4) & 0xFFFFFFFFFFFFFF8))
                                                  + 32 * ((*(void *)(*(void *)v1423 + 120) + 1) & 0x7F));
                                uint64_t v1437 = *v1436;
                                v1438 = (std::__shared_weak_count *)v1436[1];
                                if (v1438)
                                {
                                  atomic_fetch_add_explicit(&v1438->__shared_owners_, 1uLL, memory_order_relaxed);
                                  int v1439 = *(_DWORD *)(v1437 + 248);
                                  if (atomic_fetch_add(&v1438->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                  {
                                    float v1430 = v1425[14];
                                    float v1429 = v1425[15];
                                    if (v1439) {
                                      goto LABEL_1589;
                                    }
                                  }
                                  else
                                  {
                                    ((void (*)(std::__shared_weak_count *))v1438->__on_zero_shared)(v1438);
                                    std::__shared_weak_count::__release_weak(v1438);
                                    float v1430 = v1425[14];
                                    float v1429 = v1425[15];
                                    if (v1439) {
                                      goto LABEL_1589;
                                    }
                                  }
                                }
                                else
                                {
                                  float v1430 = v1425[14];
                                  float v1429 = v1425[15];
                                  if (*(_DWORD *)(v1437 + 248)) {
                                    goto LABEL_1589;
                                  }
                                }
                                char v1441 = 1;
                                if (v1429 >= v1424) {
                                  goto LABEL_1603;
                                }
LABEL_1592:
                                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EB9F1610))
                                {
                                  qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                                  __cxa_guard_release(&qword_1EB9F1610);
                                }
                                v1442 = qword_1EB9F1620;
                                if (!os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
                                {
                                  uint64_t v1433 = 0;
                                  uint64_t v1432 = 0;
                                  uint64_t v1434 = 1;
                                  uint64_t v1431 = 1;
                                  goto LABEL_1671;
                                }
                                v1655 = *(void **)(*(void *)v1423 + 24);
                                v1656 = *(std::__shared_weak_count **)(*(void *)v1423 + 32);
                                if (v1656) {
                                  atomic_fetch_add_explicit(&v1656->__shared_owners_, 1uLL, memory_order_relaxed);
                                }
                                v1657 = "(null)";
                                if (v1655) {
                                  v1657 = (const char *)(*v1655 + 160);
                                }
                                if (v1656 && !atomic_fetch_add(&v1656->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                {
                                  ((void (*)(std::__shared_weak_count *))v1656->__on_zero_shared)(v1656);
                                  std::__shared_weak_count::__release_weak(v1656);
                                }
                                *(_DWORD *)int buf = 134218498;
                                *(double *)&uint8_t buf[4] = v1424;
                                *(_WORD *)&unsigned char buf[12] = 2048;
                                *(double *)&buf[14] = v1429;
                                *(_WORD *)&unsigned char buf[22] = 2080;
                                *(void *)&unsigned char buf[24] = v1657;
                                _os_log_debug_impl(&dword_1D0DBD000, v1442, OS_LOG_TYPE_DEBUG, "Resetting face due to ML failure coefficient (%g > %g, user %s)", buf, 0x20u);
                                uint64_t v1428 = 0;
                                uint64_t v1432 = 0;
                                uint64_t v1433 = 0;
                                uint64_t v1435 = 0;
                                uint64_t v1431 = 1;
                                uint64_t v1434 = 1;
                                if (v1430 < v1424) {
                                  goto LABEL_1682;
                                }
                                goto LABEL_1683;
                              }
                              float v1430 = v1425[14];
                              float v1429 = v1425[15];
LABEL_1589:
                              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                                && __cxa_guard_acquire(&qword_1EB9F1610))
                              {
                                qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                                __cxa_guard_release(&qword_1EB9F1610);
                              }
                              float v1430 = v1430 + -0.1;
                              float v1429 = v1429 + -0.1;
                              v1440 = qword_1EB9F1620;
                              if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
                              {
                                v1562 = *(void **)(*(void *)v1423 + 24);
                                v1563 = *(std::__shared_weak_count **)(*(void *)v1423 + 32);
                                if (v1563) {
                                  atomic_fetch_add_explicit(&v1563->__shared_owners_, 1uLL, memory_order_relaxed);
                                }
                                v1564 = "(null)";
                                if (v1562) {
                                  v1564 = (const char *)(*v1562 + 160);
                                }
                                if (v1563 && !atomic_fetch_add(&v1563->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                {
                                  ((void (*)(std::__shared_weak_count *))v1563->__on_zero_shared)(v1563);
                                  std::__shared_weak_count::__release_weak(v1563);
                                }
                                *(_DWORD *)int buf = 134218242;
                                *(double *)&uint8_t buf[4] = v1429;
                                *(_WORD *)&unsigned char buf[12] = 2080;
                                *(void *)&buf[14] = v1564;
                                _os_log_debug_impl(&dword_1D0DBD000, v1440, OS_LOG_TYPE_DEBUG, "Set network failure threshold to %f; due to previous error detected (user %s).",
                                  buf,
                                  0x16u);
                              }
                              char v1441 = 0;
                              if (v1429 < v1424) {
                                goto LABEL_1592;
                              }
LABEL_1603:
                              if (v1426)
                              {
                                if (v1425[34] >= v1424)
                                {
                                  LODWORD(v1427) = 0;
                                  char v1448 = 1;
                                  int v1449 = *(_DWORD *)&v2006[16];
                                  if (!*(_DWORD *)&v2006[16]) {
                                    goto LABEL_2075;
                                  }
                                }
                                else
                                {
                                  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EB9F1610))
                                  {
                                    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                                    __cxa_guard_release(&qword_1EB9F1610);
                                  }
                                  v1447 = qword_1EB9F1620;
                                  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
                                  {
                                    float v1670 = v1425[34];
                                    v1671 = *(void **)(*(void *)v1423 + 24);
                                    v1672 = *(std::__shared_weak_count **)(*(void *)v1423 + 32);
                                    if (v1672) {
                                      atomic_fetch_add_explicit(&v1672->__shared_owners_, 1uLL, memory_order_relaxed);
                                    }
                                    v1673 = "(null)";
                                    if (v1671) {
                                      v1673 = (const char *)(*v1671 + 160);
                                    }
                                    if (v1672 && !atomic_fetch_add(&v1672->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                    {
                                      ((void (*)(std::__shared_weak_count *))v1672->__on_zero_shared)(v1672);
                                      std::__shared_weak_count::__release_weak(v1672);
                                    }
                                    *(_DWORD *)int buf = 134218498;
                                    *(double *)&uint8_t buf[4] = v1424;
                                    *(_WORD *)&unsigned char buf[12] = 2048;
                                    *(double *)&buf[14] = v1670;
                                    *(_WORD *)&unsigned char buf[22] = 2080;
                                    *(void *)&unsigned char buf[24] = v1673;
                                    _os_log_debug_impl(&dword_1D0DBD000, v1447, OS_LOG_TYPE_DEBUG, "Skipping recognition due to ML failure coefficient (%g > %g, user %s).", buf, 0x20u);
                                  }
                                  char v1448 = 0;
                                  LODWORD(v1427) = 1;
                                  int v1449 = *(_DWORD *)&v2006[16];
                                  if (!*(_DWORD *)&v2006[16])
                                  {
                                    while (1)
LABEL_2075:
                                      ;
                                  }
                                }
                              }
                              else
                              {
                                char v1448 = 0;
                                LODWORD(v1427) = 100;
                                int v1449 = *(_DWORD *)&v2006[16];
                                if (!*(_DWORD *)&v2006[16]) {
                                  goto LABEL_2075;
                                }
                              }
                              uint64_t v1450 = (2 * v1449);
                              float v1451 = **(float **)v2006;
                              if (v1450 == 2)
                              {
                                float v1452 = *(float *)(*(void *)v2006 + 4);
                                float v1453 = **(float **)v2006;
                                float v1454 = v1452;
                              }
                              else
                              {
                                v1455 = (float *)(*(void *)v2006 + 8);
                                uint64_t v1456 = 4 * v1450 - 8;
                                uint64_t v1457 = v1456;
                                v1458 = (float *)(*(void *)v2006 + 8);
                                float v1459 = **(float **)v2006;
                                do
                                {
                                  float v1460 = *v1458;
                                  v1458 += 2;
                                  float v1461 = v1460;
                                  if (v1460 < v1459) {
                                    float v1459 = v1461;
                                  }
                                  v1457 -= 8;
                                }
                                while (v1457);
                                float v1454 = *(float *)(*(void *)v2006 + 4);
                                v1462 = (float *)(*(void *)v2006 + 12);
                                uint64_t v1463 = v1456;
                                v1464 = (float *)(*(void *)v2006 + 12);
                                float v1452 = v1454;
                                do
                                {
                                  float v1465 = *v1464;
                                  v1464 += 2;
                                  float v1466 = v1465;
                                  if (v1465 < v1452) {
                                    float v1452 = v1466;
                                  }
                                  v1463 -= 8;
                                }
                                while (v1463);
                                uint64_t v1467 = v1456;
                                float v1453 = **(float **)v2006;
                                do
                                {
                                  float v1468 = *v1455;
                                  v1455 += 2;
                                  float v1469 = v1468;
                                  if (v1453 < v1468) {
                                    float v1453 = v1469;
                                  }
                                  v1467 -= 8;
                                }
                                while (v1467);
                                do
                                {
                                  float v1470 = *v1462;
                                  v1462 += 2;
                                  float v1471 = v1470;
                                  if (v1454 < v1470) {
                                    float v1454 = v1471;
                                  }
                                  v1456 -= 8;
                                }
                                while (v1456);
                                float v1451 = v1459;
                              }
                              float v1472 = v1453 - v1451;
                              float v1473 = v1454 - v1452;
                              if ((float)(v1453 - v1451) >= v1473) {
                                float v1474 = v1453 - v1451;
                              }
                              else {
                                float v1474 = v1473;
                              }
                              v1475.f32[0] = v1451 - (float)((float)(v1474 - v1472) * v930);
                              v1475.f32[1] = v1452 - (float)((float)(v1474 - v1473) * v930);
                              float32x2_t v1476 = vadd_f32(v1475, (float32x2_t)0x3F0000003F000000);
                              __asm { FMOV            V0.2S, #1.0 }
                              float32x2_t v1478 = vdiv_f32(_D0, vcvt_f32_s32(vmax_s32(*(int32x2_t *)((char *)&v1973 + 8), (int32x2_t)0x100000001)));
                              float v1479 = (float)(v1425[16] * -2.0) + 1.0;
                              if (v1479 <= 1.0) {
                                float v1480 = (float)(v1425[16] * -2.0) + 1.0;
                              }
                              else {
                                float v1480 = 1.0;
                              }
                              if (v1479 < 0.0) {
                                float v1480 = 0.0;
                              }
                              float32x2_t v1481 = vmul_n_f32(v1478, v1474);
                              float32x2_t v1482 = vmul_f32(v1476, v1478);
                              float32x2_t v1483 = vsub_f32(v1482, vmul_n_f32(v1481, (float)(v1480 + -1.0) * v930));
                              char v1885 = v1441;
                              if (v1483.f32[0] < 0.0)
                              {
                                BOOL v1486 = 0;
                              }
                              else
                              {
                                float32x2_t v1484 = vadd_f32(v1483, vmul_n_f32(v1481, v1480));
                                BOOL v1486 = v1483.f32[1] >= 0.0 && v1484.f32[0] <= 1.0 && v1484.f32[1] <= 1.0;
                              }
                              float v1487 = (float)(v1425[17] * -2.0) + 1.0;
                              if (v1487 <= 1.0) {
                                float v1488 = (float)(v1425[17] * -2.0) + 1.0;
                              }
                              else {
                                float v1488 = 1.0;
                              }
                              if (v1487 >= 0.0) {
                                float v1489 = v1488;
                              }
                              else {
                                float v1489 = 0.0;
                              }
                              float32x2_t v1490 = vsub_f32(v1482, vmul_n_f32(v1481, (float)(v1489 + -1.0) * v930));
                              float32x2_t v1491 = vmul_n_f32(v1481, v1489);
                              BOOL v1492 = v1490.f32[0] < 0.0;
                              if (v1490.f32[1] < 0.0) {
                                BOOL v1492 = 1;
                              }
                              int8x8_t v1493 = vmvn_s8((int8x8_t)vcge_f32(_D0, vadd_f32(v1490, v1491)));
                              char v1494 = v1492 | v1493.i8[0] | v1493.i8[4];
                              if (v1494)
                              {
                                BOOL v1495 = v1486;
                                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EB9F1610))
                                {
                                  qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                                  __cxa_guard_release(&qword_1EB9F1610);
                                }
                                v1496 = qword_1EB9F1620;
                                if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
                                {
                                  v1667 = *(void **)(*(void *)v1423 + 24);
                                  v1668 = *(std::__shared_weak_count **)(*(void *)v1423 + 32);
                                  if (v1668) {
                                    atomic_fetch_add_explicit(&v1668->__shared_owners_, 1uLL, memory_order_relaxed);
                                  }
                                  v1669 = "(null)";
                                  if (v1667) {
                                    v1669 = (const char *)(*v1667 + 160);
                                  }
                                  if (v1668 && !atomic_fetch_add(&v1668->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                  {
                                    ((void (*)(std::__shared_weak_count *))v1668->__on_zero_shared)(v1668);
                                    std::__shared_weak_count::__release_weak(v1668);
                                  }
                                  *(_DWORD *)int buf = 136315138;
                                  *(void *)&uint8_t buf[4] = v1669;
                                  _os_log_debug_impl(&dword_1D0DBD000, v1496, OS_LOG_TYPE_DEBUG, "Resetting face due to bounding box outside of the image (user %s)", buf, 0xCu);
                                }
                                uint64_t v1431 = 2;
                                uint64_t v1497 = 2;
                                uint64_t v1498 = 2;
                                BOOL v1486 = v1495;
                              }
                              else
                              {
                                uint64_t v1498 = 0;
                                uint64_t v1431 = 7;
                                uint64_t v1497 = 4;
                              }
                              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA643838, memory_order_acquire) & 1) == 0)
                              {
                                uint64_t v1718 = v1498;
                                int v1719 = __cxa_guard_acquire(&qword_1EA643838);
                                uint64_t v1498 = v1718;
                                if (v1719)
                                {
                                  dword_1EA643830 = 1059760811;
                                  __cxa_guard_release(&qword_1EA643838);
                                  uint64_t v1498 = v1718;
                                }
                              }
                              v1499 = *(void **)v1423;
                              float32x2_t v1500 = *(float32x2_t *)(*(void *)v1423 + 52);
                              float32x2_t v1501 = vsub_f32(*(float32x2_t *)(*(void *)v1423 + 44), vmul_n_f32(v1500, (float)(*(float *)&dword_1EA643830 + -1.0) * v930));
                              float32x2_t v1502 = vmul_n_f32(v1500, *(float *)&dword_1EA643830);
                              __asm { FMOV            V5.2D, #-0.5 }
                              float64x2_t v1504 = vaddq_f64(vcvtq_f64_f32(vcvt_f32_s32(*(int32x2_t *)((char *)&v1973 + 8))), _Q5);
                              float64x2_t v1505 = vaddq_f64(vcvtq_f64_f32(v1501), vcvtq_f64_f32(v1502));
                              *(float32x2_t *)&v1504.f64[0] = vcvt_f32_f64(vsubq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v1505, v1504), (int8x16_t)v1504, (int8x16_t)v1505), vcvtq_f64_f32((float32x2_t)vbsl_s8((int8x8_t)vcge_f32((float32x2_t)0xBF000000BF000000, v1501), (int8x8_t)0xBF000000BF000000, (int8x8_t)v1501))));
                              int32x2_t v1506 = vcltz_f32(*(float32x2_t *)&v1504.f64[0]);
                              LODWORD(v1507) = vmul_lane_f32(*(float32x2_t *)&v1504.f64[0], *(float32x2_t *)&v1504.f64[0], 1).u32[0];
                              if ((v1506.i8[0] | v1506.i8[4])) {
                                float v1507 = 0.0;
                              }
                              BOOL v1508 = v1502.f32[1] < 0.0 || v1502.f32[0] < 0.0;
                              float v1509 = vmuls_lane_f32(v1502.f32[0], v1502, 1);
                              if (v1508) {
                                float v1509 = 0.0;
                              }
                              if ((v1448 & ((float)(v1507 / v1509) < 1.0)) != 0) {
                                uint64_t v1427 = 2;
                              }
                              else {
                                uint64_t v1427 = v1427;
                              }
                              if (v1494)
                              {
                                uint64_t v1433 = 0;
                                uint64_t v1432 = 0;
                                uint64_t v1434 = 1;
                                uint64_t v1431 = v1498;
                                uint64_t v1218 = v1869;
                                if (v1486) {
                                  goto LABEL_1671;
                                }
LABEL_1681:
                                uint64_t v1428 = 0x100000000;
                                if (v1430 >= v1424) {
                                  uint64_t v1435 = 0;
                                }
                                else {
LABEL_1682:
                                }
                                  uint64_t v1435 = 0x1000000;
LABEL_1683:
                                uint64_t v1513 = v1435 | v1433 | v1428 | v1432;
                                uint64_t v1514 = v1513 | v1434;
                                if ((unsigned __int16)v1514 != 0 && v1427 == 0) {
                                  uint64_t v1515 = v1431 << 32;
                                }
                                else {
                                  uint64_t v1515 = v1427 << 32;
                                }
                                v1516 = (uint64_t *)(*(void *)(*(void *)(*(void *)v1423 + 96)
                                                              + ((*(void *)(*(void *)v1423 + 120) >> 4) & 0xFFFFFFFFFFFFFF8))
                                                  + 32 * (*(void *)(*(void *)v1423 + 120) & 0x7FLL));
                                uint64_t v1517 = *v1516;
                                v1518 = (std::__shared_weak_count *)v1516[1];
                                if (v1518) {
                                  atomic_fetch_add_explicit(&v1518->__shared_owners_, 1uLL, memory_order_relaxed);
                                }
                                uint64_t v1519 = v1515 | v1431;
                                unint64_t v1520 = v1514 & 0xFFFFFFFFFF00FF00 | ((unint64_t)(((unsigned __int16)v1514 != 0) | BYTE2(v1513)) << 16) | v1514;
                                *(void *)(v1517 + 240) = v1520;
                                *(void *)(v1517 + 248) = v1515 | v1431;
                                if (v1518 && !atomic_fetch_add(&v1518->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                {
                                  ((void (*)(std::__shared_weak_count *))v1518->__on_zero_shared)(v1518);
                                  std::__shared_weak_count::__release_weak(v1518);
                                }
                                uint64_t v1521 = *(void *)(*(void *)(*(void *)v1423 + 96)
                                                  + ((*(void *)(*(void *)v1423 + 120) >> 4) & 0xFFFFFFFFFFFFFF8))
                                      + 32 * (*(void *)(*(void *)v1423 + 120) & 0x7FLL);
                                uint64_t v1522 = *(void *)(v1521 + 16);
                                v1523 = *(std::__shared_weak_count **)(v1521 + 24);
                                if (v1523)
                                {
                                  atomic_fetch_add_explicit(&v1523->__shared_owners_, 1uLL, memory_order_relaxed);
                                  *(void *)(v1522 + 240) = v1520;
                                  *(void *)(v1522 + 248) = v1519;
                                  if (!atomic_fetch_add(&v1523->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                  {
                                    ((void (*)(std::__shared_weak_count *))v1523->__on_zero_shared)(v1523);
                                    std::__shared_weak_count::__release_weak(v1523);
                                  }
                                }
                                else
                                {
                                  *(void *)(v1522 + 240) = v1520;
                                  *(void *)(v1522 + 248) = v1519;
                                }
                                kdebug_trace();
                                v1524 = (unsigned __int8 **)(*(void *)(*(void *)(*(void *)v1423 + 96)
                                                                       + ((*(void *)(*(void *)v1423 + 120) >> 4) & 0xFFFFFFFFFFFFFF8))
                                                           + 32 * (*(void *)(*(void *)v1423 + 120) & 0x7FLL));
                                v1525 = *v1524;
                                v1526 = (std::__shared_weak_count *)v1524[1];
                                if (v1526)
                                {
                                  atomic_fetch_add_explicit(&v1526->__shared_owners_, 1uLL, memory_order_relaxed);
                                  int v1527 = v1525[240];
                                  int v1528 = v1525[241];
                                  unsigned __int8 v1529 = v1525[242];
                                  if (!atomic_fetch_add(&v1526->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                  {
                                    ((void (*)(std::__shared_weak_count *))v1526->__on_zero_shared)(v1526);
                                    std::__shared_weak_count::__release_weak(v1526);
                                  }
                                }
                                else
                                {
                                  int v1527 = v1525[240];
                                  int v1528 = v1525[241];
                                  unsigned __int8 v1529 = v1525[242];
                                }
                                uint64_t v1530 = v1955;
                                uint64_t v1531 = *(void *)(*(void *)v1955 + 24);
                                v1532 = *(std::__shared_weak_count **)(*(void *)v1955 + 32);
                                if (v1532) {
                                  atomic_fetch_add_explicit(&v1532->__shared_owners_, 1uLL, memory_order_relaxed);
                                }
                                if (*(unsigned char *)(*(void *)v1531 + 16) && *(void *)(*(void *)v1530 + 128))
                                {
                                  int v1533 = (v1528 & 1) == 0 || v1858;
                                  if (!v1532 || atomic_fetch_add(&v1532->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                  {
                                    if (v1533) {
                                      goto LABEL_1709;
                                    }
LABEL_1940:
                                    if (v1527) {
                                      goto LABEL_1941;
                                    }
                                    goto LABEL_1942;
                                  }
                                  ((void (*)(std::__shared_weak_count *))v1532->__on_zero_shared)(v1532);
                                  std::__shared_weak_count::__release_weak(v1532);
                                  if (!v1533) {
                                    goto LABEL_1940;
                                  }
LABEL_1709:
                                  if (((v1527 | v1528) & 1) == 0)
                                  {
                                    v1534 = (uint64_t *)v1955;
                                    *(_DWORD *)(*(void *)v1955 + 4) = 0;
                                    BOOL v1535 = v1839;
                                    if (v1529) {
                                      BOOL v1535 = 0;
                                    }
                                    if (v1535)
                                    {
                                      kdebug_trace();
                                      uint64_t v1536 = *v1534;
                                      uint64_t v1537 = *(void *)(*v1534 + 8);
                                      v1538 = *(std::__shared_weak_count **)(v1536 + 16);
                                      if (v1538)
                                      {
                                        atomic_fetch_add_explicit(&v1538->__shared_owners_, 1uLL, memory_order_relaxed);
                                        if (!atomic_fetch_add(&v1538->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                        {
                                          ((void (*)(std::__shared_weak_count *))v1538->__on_zero_shared)(v1538);
                                          std::__shared_weak_count::__release_weak(v1538);
                                        }
                                      }
                                      uint64_t v1539 = *a2;
                                      uint64_t v1540 = *(void *)(v1537 + 48);
                                      v1541 = *(atomic_ullong **)(v1537 + 56);
                                      memptr[0] = (void *)v1540;
                                      memptr[1] = v1541;
                                      if (v1541) {
                                        atomic_fetch_add_explicit(v1541 + 1, 1uLL, memory_order_relaxed);
                                      }
                                      LODWORD(__p[0]) = *(_DWORD *)(v1540 + 24);
                                      __p[1] = *(void **)(v1540 + 8);
                                      *(void *)&long long v1999 = LODWORD(__p[0]);
                                      float v1543 = *(float *)v1537;
                                      v1542 = (void *)(v1537 + 4);
                                      float v1544 = v1543;
                                      v1545 = v1953;
                                      *(void *)&buf[36] = 0;
                                      *(_DWORD *)&buf[44] = 0;
                                      float v1546 = v1953[1];
                                      float v1547 = v1953[2];
                                      __float2 v1548 = __sincosf_stret(*v1953);
                                      __float2 v1549 = __sincosf_stret(v1546);
                                      __float2 v1552 = __sincosf_stret(v1547);
                                      *(float *)int buf = v1549.__cosval * v1552.__cosval;
                                      *(float *)&uint8_t buf[4] = (float)(v1549.__sinval
                                                                * (float)(v1548.__sinval * v1552.__cosval))
                                                        + (float)(v1548.__cosval * v1552.__sinval);
                                      *(float *)&uint8_t buf[8] = (float)(v1549.__sinval
                                                                * (float)-(float)(v1548.__cosval * v1552.__cosval))
                                                        + (float)(v1548.__sinval * v1552.__sinval);
                                      *(float *)&unsigned char buf[12] = -(float)(v1549.__cosval * v1552.__sinval);
                                      *(float *)&uint8_t buf[16] = (float)((float)-(float)(v1548.__sinval * v1549.__sinval)
                                                                 * v1552.__sinval)
                                                         + (float)(v1548.__cosval * v1552.__cosval);
                                      *(float *)&buf[20] = (float)((float)(v1548.__cosval * v1549.__sinval)
                                                                 * v1552.__sinval)
                                                         + (float)(v1552.__cosval * v1548.__sinval);
                                      *(float *)&unsigned char buf[24] = v1549.__sinval;
                                      *(float *)&buf[28] = -(float)(v1549.__cosval * v1548.__sinval);
                                      *(float *)&buf[32] = v1548.__cosval * v1549.__cosval;
                                      if (&buf[36] != (unsigned char *)(v1545 + 3))
                                      {
                                        uint64_t v1553 = *(void *)(v1545 + 3);
                                        *(float *)&buf[44] = v1545[5];
                                        *(void *)&buf[36] = v1553;
                                      }
                                      unsigned int v1554 = *((_DWORD *)v1545 + 10);
                                      float32x2_t v1555 = *(float32x2_t *)(v1545 + 6);
                                      if (v1867) {
                                        uint64_t v1556 = *(void *)(*a2 + 96) + 32 * v1869;
                                      }
                                      else {
                                        uint64_t v1556 = 0;
                                      }
                                      uint64_t v1658 = *(void *)(*(void *)v1955 + 136);
                                      uint64_t v1659 = *(void *)(*(void *)v1955 + 144);
                                      *(void *)&long long v1988 = v1658;
                                      *((void *)&v1988 + 1) = v1659;
                                      if (v1659) {
                                        atomic_fetch_add_explicit((atomic_ullong *volatile)(v1659 + 8), 1uLL, memory_order_relaxed);
                                      }
                                      if (*(unsigned char *)(v1658 + 1016))
                                      {
                                        double v1660 = COERCE_DOUBLE(atomic_load((unint64_t *)v1658));
                                        v1550.n128_f64[0] = v1660;
                                        v1551.n128_f64[0] = v1838;
                                        if (v1838 <= v1660
                                          || (v1550.n128_f64[0] = v1660 + 500.0,
                                              v1551.n128_f64[0] = v1838,
                                              v1660 + 500.0 <= v1838))
                                        {
                                          uint64_t v1661 = v1658 + 80;
                                          unsigned __int8 v1662 = atomic_load((unsigned __int8 *)(v1658 + 80));
                                          if ((v1662 & 1) == 0)
                                          {
                                            uint64_t v1663 = **(void **)(v1539 + 32);
                                            float32x2_t v1664 = *(float32x2_t *)(v1663 + 16);
                                            v1665 = *(std::__shared_weak_count **)(v1663 + 24);
                                            v2022[0] = v1664;
                                            v2022[1] = (float32x2_t)v1665;
                                            if (v1665) {
                                              atomic_fetch_add_explicit(&v1665->__shared_owners_, 1uLL, memory_order_relaxed);
                                            }
                                            char v1666 = (*(uint64_t (**)(float32x2_t, unsigned char *, __n128, __n128))(**(void **)&v1664 + 56))(v1664, buf, v1550, v1551);
                                            if (v1665
                                              && !atomic_fetch_add(&v1665->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                            {
                                              ((void (*)(std::__shared_weak_count *))v1665->__on_zero_shared)(v1665);
                                              std::__shared_weak_count::__release_weak(v1665);
                                            }
                                            if (v1666)
                                            {
                                              uint64_t v1556 = 0;
                                              goto LABEL_1920;
                                            }
                                            if (v1556
                                              && sub_1D0E0EA58(*a2, *v1870 + 200, (uint64_t)&v1973, keyi, v1556, *(float *)(*(void *)(*a2 + 8) + 92) + 100.0))
                                            {
LABEL_1920:
                                              v2022[0].i32[0] = v1554 - 2;
                                              v2022[1] = v1555;
                                              v2022[2] = (float32x2_t)v1554;
                                              sub_1D0E4D7A0(v1661, v1556, (unsigned int *)__p, v1542, (long long *)buf, (unsigned int *)v2022, v1544);
                                            }
                                          }
                                        }
                                      }
                                      v1674 = (std::__shared_weak_count *)*((void *)&v1988 + 1);
                                      if (*((void *)&v1988 + 1)
                                        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v1988 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                                      {
                                        ((void (*)(std::__shared_weak_count *))v1674->__on_zero_shared)(v1674);
                                        std::__shared_weak_count::__release_weak(v1674);
                                      }
                                      v1675 = (std::__shared_weak_count *)memptr[1];
                                      if (memptr[1]
                                        && !atomic_fetch_add((atomic_ullong *volatile)memptr[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
                                      {
                                        ((void (*)(std::__shared_weak_count *))v1675->__on_zero_shared)(v1675);
                                        std::__shared_weak_count::__release_weak(v1675);
                                      }
                                      kdebug_trace();
                                    }
                                  }
                                  kdebug_trace();
                                  v1676 = operator new(0x28uLL);
                                  v1676[1] = 0;
                                  v1676[2] = 0;
                                  void *v1676 = &unk_1F26F4B80;
                                  v1677 = (cva::DictionaryHandler *)(v1676 + 3);
                                  cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)(v1676 + 3));
                                  v2022[0] = (float32x2_t)(v1676 + 3);
                                  v2022[1] = (float32x2_t)v1676;
                                  uint64_t v1678 = v1955;
                                  v1679 = *(void **)(*(void *)v1955 + 24);
                                  v1680 = *(atomic_ullong **)(*(void *)v1955 + 32);
                                  __p[0] = v1679;
                                  __p[1] = v1680;
                                  if (v1680) {
                                    atomic_fetch_add_explicit(v1680 + 1, 1uLL, memory_order_relaxed);
                                  }
                                  v1681 = *(const unsigned __int8 **)v1679;
                                  if (*(unsigned char *)(*(void *)v1679 + 16))
                                  {
                                    memset(buf, 0, 37);
                                    uuid_unparse_upper(v1681, buf);
                                    CFStringRef v1682 = CFStringCreateWithCString(alloc, buf, 0x8000100u);
                                    uint64_t Dictionary = (__CFDictionary *)cva::DictionaryHandler::getDictionary(v1677);
                                    CFDictionaryAddValue(Dictionary, @"face_id", v1682);
                                    CFRelease(v1682);
                                    if (*(void *)(*(void *)v1678 + 128))
                                    {
                                      v1684 = (uint64_t *)(*(void *)(*(void *)(*(void *)v1678 + 96)
                                                                    + ((*(void *)(*(void *)v1678 + 120) >> 4) & 0xFFFFFFFFFFFFFF8))
                                                        + 32 * (*(void *)(*(void *)v1678 + 120) & 0x7FLL));
                                      uint64_t v1686 = *v1684;
                                      v1685 = (std::__shared_weak_count *)v1684[1];
                                      if (v1685)
                                      {
                                        atomic_fetch_add_explicit(&v1685->__shared_owners_, 1uLL, memory_order_relaxed);
                                        if (!atomic_fetch_add(&v1685->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                        {
                                          ((void (*)(std::__shared_weak_count *))v1685->__on_zero_shared)(v1685);
                                          std::__shared_weak_count::__release_weak(v1685);
                                        }
                                      }
                                    }
                                    else
                                    {
                                      uint64_t v1686 = 0;
                                    }
                                    int v1687 = *(_DWORD *)(v1686 + 248);
                                    if ((v1687 & 0xFFFFFFFC) == 0xC8) {
                                      int v1687 = 6;
                                    }
                                    LODWORD(memptr[0]) = v1687;
                                    cva::ItemHandler::createValue<int>();
                                  }
                                  _os_crash();
                                  __break(1u);
                                  goto LABEL_2254;
                                }
                                if (!v1532 || atomic_fetch_add(&v1532->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
                                  goto LABEL_1940;
                                }
                                ((void (*)(std::__shared_weak_count *))v1532->__on_zero_shared)(v1532);
                                std::__shared_weak_count::__release_weak(v1532);
                                if (v1527)
                                {
LABEL_1941:
                                  v1688 = (uint64_t *)v1955;
                                  ++*(_DWORD *)(*(void *)v1955 + 4);
                                  sub_1D0E3F500(v1688);
                                }
LABEL_1942:
                                free(*(void **)v2006);
                                if (*(void *)&v2013[24]) {
                                  free(*(void **)&v2013[24]);
                                }
                                v1689 = v1954;
                                if (v1954 && !atomic_fetch_add(&v1954->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                {
                                  ((void (*)(std::__shared_weak_count *))v1689->__on_zero_shared)(v1689);
                                  std::__shared_weak_count::__release_weak(v1689);
                                }
                                v1690 = (std::__shared_weak_count *)*((void *)&v1955 + 1);
                                if (*((void *)&v1955 + 1)
                                  && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v1955 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                                {
                                  ((void (*)(std::__shared_weak_count *))v1690->__on_zero_shared)(v1690);
                                  std::__shared_weak_count::__release_weak(v1690);
                                }
                                uint64_t v694 = v1218 + 1;
                                if (v694 != v1871) {
                                  continue;
                                }
                                kdebug_trace();
                                if (!(*(unsigned int (**)(void))(**(void **)(*a2 + 160) + 32))(*(void *)(*a2 + 160))) {
                                  goto LABEL_2215;
                                }
                                uint64_t v1724 = *(void *)(v1888 + 24);
                                uint64_t v1723 = *(void *)(v1888 + 32);
                                int64_t v1725 = v1723 - v1724;
                                if (v1723 == v1724)
                                {
                                  v1727 = 0;
                                  v1728 = 0;
                                }
                                else
                                {
                                  if (v1725 < 0) {
LABEL_2233:
                                  }
                                    abort();
                                  uint64_t v1726 = v1725 >> 4;
                                  v1727 = (char *)operator new(v1725);
                                  v1728 = &v1727[16 * v1726];
                                }
                                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA643848, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EA643848))
                                {
                                  dword_1EA643840 = 1059760811;
                                  __cxa_guard_release(&qword_1EA643848);
                                }
                                uint64_t v1741 = *(void *)(v1888 + 24);
                                uint64_t v1742 = *(void *)(v1888 + 32);
                                if (v1741 == v1742) {
                                  goto LABEL_2213;
                                }
                                LODWORD(v1722) = dword_1EA643840;
                                v1743 = v1727;
                                while (2)
                                {
                                  float32x2_t v1745 = *(float32x2_t *)(**(void **)v1741 + 52);
                                  *(float32x2_t *)&long long v1746 = vsub_f32(*(float32x2_t *)(**(void **)v1741 + 44), vmul_n_f32(v1745, (float)(*(float *)&v1722 + -1.0) * 0.5));
                                  *(float32x2_t *)&long long v1721 = vmul_n_f32(v1745, *(float *)&v1722);
                                  if (v1743 < v1728)
                                  {
                                    *(void *)v1743 = v1746;
                                    *((void *)v1743 + 1) = v1721;
                                    v1744 = v1743 + 16;
                                  }
                                  else
                                  {
                                    int64_t v1747 = v1743 - v1727;
                                    uint64_t v1748 = (v1743 - v1727) >> 4;
                                    unint64_t v1749 = v1748 + 1;
                                    if ((unint64_t)(v1748 + 1) >> 60) {
                                      goto LABEL_2233;
                                    }
                                    if ((v1728 - v1727) >> 3 > v1749) {
                                      unint64_t v1749 = (v1728 - v1727) >> 3;
                                    }
                                    if ((unint64_t)(v1728 - v1727) >= 0x7FFFFFFFFFFFFFF0) {
                                      unint64_t v1750 = 0xFFFFFFFFFFFFFFFLL;
                                    }
                                    else {
                                      unint64_t v1750 = v1749;
                                    }
                                    if (v1750)
                                    {
                                      *(_OWORD *)keyuint64_t j = v1721;
                                      uint64_t v1918 = v1746;
                                      long long v1924 = v1722;
                                      if (v1750 >> 60) {
                                        goto LABEL_2232;
                                      }
                                      v1751 = (char *)operator new(16 * v1750);
                                      *(void *)&long long v1746 = v1918;
                                      long long v1722 = v1924;
                                      long long v1721 = *(_OWORD *)keyj;
                                    }
                                    else
                                    {
                                      v1751 = 0;
                                    }
                                    *((void *)&v1746 + 1) = v1721;
                                    v1752 = &v1751[16 * v1748];
                                    *(_OWORD *)v1752 = v1746;
                                    v1744 = v1752 + 16;
                                    int64_t v1753 = v1743 - v1727;
                                    if (v1743 != v1727)
                                    {
                                      unint64_t v1754 = v1753 - 16;
                                      if ((unint64_t)(v1753 - 16) < 0x3F0)
                                      {
                                        v1755 = v1743;
                                        goto LABEL_2121;
                                      }
                                      unint64_t v1757 = v1754 & 0xFFFFFFFFFFFFFFF0;
                                      if (&v1751[v1747 - 16 - (v1754 & 0xFFFFFFFFFFFFFFF0)] > &v1751[v1747 - 16])
                                      {
                                        v1755 = v1743;
                                        goto LABEL_2121;
                                      }
                                      v1758 = &v1751[v1747 - 8];
                                      if (&v1758[-v1757] > v1758)
                                      {
                                        v1755 = v1743;
                                        goto LABEL_2121;
                                      }
                                      if (&v1743[-v1757 - 16] > v1743 - 16)
                                      {
                                        v1755 = v1743;
                                        goto LABEL_2121;
                                      }
                                      v1759 = v1743 - 8;
                                      if (&v1743[-v1757 - 8] > v1743 - 8)
                                      {
                                        v1755 = v1743;
                                        goto LABEL_2121;
                                      }
                                      unint64_t v1760 = v1754 >> 4;
                                      unint64_t v1761 = v1747 - v1757;
                                      v1762 = &v1751[v1761 - 16];
                                      v1763 = &v1751[v1761 - 8];
                                      unint64_t v1764 = (unint64_t)&v1743[-16 * v1760 - 16];
                                      v1765 = &v1759[-16 * v1760];
                                      BOOL v1767 = v1762 < v1759 && v1764 < (unint64_t)v1758;
                                      BOOL v1769 = v1762 < v1743 && v1765 < v1758;
                                      BOOL v1771 = v1763 < v1759 && v1764 < (unint64_t)v1752;
                                      BOOL v1773 = v1763 < v1743 && v1765 < v1752;
                                      if (v1763 < v1758 && v1762 < v1752)
                                      {
                                        v1755 = v1743;
                                        goto LABEL_2121;
                                      }
                                      if (v1767)
                                      {
                                        v1755 = v1743;
                                        goto LABEL_2121;
                                      }
                                      if (v1769)
                                      {
                                        v1755 = v1743;
                                        goto LABEL_2121;
                                      }
                                      if (v1771)
                                      {
                                        v1755 = v1743;
                                        goto LABEL_2121;
                                      }
                                      if (v1773)
                                      {
                                        v1755 = v1743;
                                        goto LABEL_2121;
                                      }
                                      unint64_t v1775 = v1760 + 1;
                                      v1755 = &v1743[-16 * (v1775 & 0x1FFFFFFFFFFFFFFCLL)];
                                      v1776 = (const double *)(v1743 - 32);
                                      v1777 = (double *)(v1752 - 32);
                                      uint64_t v1778 = v1775 & 0x1FFFFFFFFFFFFFFCLL;
                                      do
                                      {
                                        *(float64x2x2_t *)(&v1721 - 1) = vld2q_f64(v1776);
                                        v1779 = v1776 - 4;
                                        float64x2x2_t v2029 = vld2q_f64(v1779);
                                        vst2q_f64(v1777, *(float64x2x2_t *)(&v1721 - 1));
                                        v1780 = v1777 - 4;
                                        vst2q_f64(v1780, v2029);
                                        v1777 -= 8;
                                        v1776 -= 8;
                                        v1778 -= 4;
                                      }
                                      while (v1778);
                                      v1752 -= 16 * (v1775 & 0x1FFFFFFFFFFFFFFCLL);
                                      if (v1775 != (v1775 & 0x1FFFFFFFFFFFFFFCLL))
                                      {
                                        do
                                        {
LABEL_2121:
                                          uint64_t v1756 = *((void *)v1755 - 2);
                                          v1755 -= 16;
                                          *((void *)v1752 - 2) = v1756;
                                          v1752 -= 16;
                                          *((void *)v1752 + 1) = *((void *)v1755 + 1);
                                        }
                                        while (v1755 != v1727);
                                      }
                                    }
                                    v1728 = &v1751[16 * v1750];
                                    if (v1727)
                                    {
                                      operator delete(v1727);
                                      LODWORD(v1722) = dword_1EA643840;
                                    }
                                    v1727 = v1752;
                                  }
                                  v1741 += 16;
                                  v1743 = v1744;
                                  if (v1741 == v1742)
                                  {
                                    uint64_t v1781 = *(void *)(v1888 + 24);
                                    uint64_t v1782 = *(void *)(v1888 + 32);
                                    if (v1782 != v1781)
                                    {
                                      unint64_t v1783 = 0;
                                      uint64_t v1784 = 16;
                                      while (1)
                                      {
                                        uint64_t v1785 = 16 * v1783;
                                        unint64_t v1786 = v1783 + 1;
                                        unint64_t v1787 = (v1782 - v1781) >> 4;
                                        if (*(void *)(**(void **)(v1781 + 16 * v1783) + 128) && v1786 < v1787) {
                                          break;
                                        }
LABEL_2176:
                                        v1784 += 16;
                                        unint64_t v1783 = v1786;
                                        if (v1786 >= v1787) {
                                          goto LABEL_2213;
                                        }
                                      }
                                      v1789 = (float32x2_t *)&v1727[16 * v1783];
                                      uint64_t v1790 = v1784;
                                      unint64_t v1791 = v1783 + 1;
                                      while (2)
                                      {
                                        if (*(void *)(**(void **)(v1781 + v1790) + 128))
                                        {
                                          float32x2_t v1792 = v1789[1];
                                          float64x2_t v1793 = vcvtq_f64_f32(*v1789);
                                          float32x2_t v1794 = *(float32x2_t *)&v1727[v1790];
                                          float64x2_t v1795 = vcvtq_f64_f32(v1794);
                                          int32x2_t v1796 = vcgt_f32(v1794, *v1789);
                                          v1797.i64[0] = v1796.i32[0];
                                          v1797.i64[1] = v1796.i32[1];
                                          float64x2_t v1798 = (float64x2_t)vbslq_s8(v1797, (int8x16_t)v1795, (int8x16_t)v1793);
                                          float64x2_t v1799 = vaddq_f64(v1795, vcvtq_f64_f32(*(float32x2_t *)&v1727[v1790 + 8]));
                                          float64x2_t v1800 = vaddq_f64(v1793, vcvtq_f64_f32(v1792));
                                          *(float32x2_t *)&v1798.f64[0] = vcvt_f32_f64(vsubq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v1800, v1799), (int8x16_t)v1799, (int8x16_t)v1800), v1798));
                                          *(int32x2_t *)&v1800.f64[0] = vcltz_f32(*(float32x2_t *)&v1798.f64[0]);
                                          LODWORD(v1801) = vmul_lane_f32(*(float32x2_t *)&v1798.f64[0], *(float32x2_t *)&v1798.f64[0], 1).u32[0];
                                          if ((LOBYTE(v1800.f64[0]) | BYTE4(v1800.f64[0]))) {
                                            float v1801 = 0.0;
                                          }
                                          BOOL v1802 = v1792.f32[1] < 0.0 || v1792.f32[0] < 0.0;
                                          float v1803 = vmuls_lane_f32(v1792.f32[0], v1792, 1);
                                          if (v1802) {
                                            float v1803 = 0.0;
                                          }
                                          v1804 = **(void ***)(v1781 + v1785);
                                          if (v1804[16])
                                          {
                                            v1805 = (uint64_t *)(*(void *)(v1804[12]
                                                                          + ((v1804[15] >> 4) & 0xFFFFFFFFFFFFFF8))
                                                              + 32 * (v1804[15] & 0x7FLL));
                                            uint64_t v1806 = *v1805;
                                            v1807 = (std::__shared_weak_count *)v1805[1];
                                            if (v1807) {
                                              atomic_fetch_add_explicit(&v1807->__shared_owners_, 1uLL, memory_order_relaxed);
                                            }
                                          }
                                          else
                                          {
                                            uint64_t v1806 = 0;
                                            v1807 = 0;
                                          }
                                          float v1808 = v1801 / v1803;
                                          if ((float)(v1801 / v1803) < 0.1 || *(_DWORD *)(v1806 + 252))
                                          {
                                            if (v1807)
                                            {
LABEL_2199:
                                              if (!atomic_fetch_add(&v1807->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                              {
                                                ((void (*)(std::__shared_weak_count *))v1807->__on_zero_shared)(v1807);
                                                std::__shared_weak_count::__release_weak(v1807);
                                              }
                                            }
                                          }
                                          else
                                          {
                                            *(_DWORD *)(v1806 + 252) = 101;
                                            if (v1807) {
                                              goto LABEL_2199;
                                            }
                                          }
                                          v1809 = **(void ***)((char *)*v1890 + v1790);
                                          if (v1809[16])
                                          {
                                            v1810 = (uint64_t *)(*(void *)(v1809[12]
                                                                          + ((v1809[15] >> 4) & 0xFFFFFFFFFFFFFF8))
                                                              + 32 * (v1809[15] & 0x7FLL));
                                            uint64_t v1811 = *v1810;
                                            v1812 = (std::__shared_weak_count *)v1810[1];
                                            if (v1812) {
                                              atomic_fetch_add_explicit(&v1812->__shared_owners_, 1uLL, memory_order_relaxed);
                                            }
                                          }
                                          else
                                          {
                                            uint64_t v1811 = 0;
                                            v1812 = 0;
                                          }
                                          if (v1808 < 0.1 || *(_DWORD *)(v1811 + 252))
                                          {
                                            if (v1812)
                                            {
LABEL_2209:
                                              if (!atomic_fetch_add(&v1812->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                              {
                                                ((void (*)(std::__shared_weak_count *))v1812->__on_zero_shared)(v1812);
                                                std::__shared_weak_count::__release_weak(v1812);
                                              }
                                            }
                                          }
                                          else
                                          {
                                            *(_DWORD *)(v1811 + 252) = 101;
                                            if (v1812) {
                                              goto LABEL_2209;
                                            }
                                          }
                                          uint64_t v1781 = *(void *)(v1888 + 24);
                                          uint64_t v1782 = *(void *)(v1888 + 32);
                                        }
                                        ++v1791;
                                        unint64_t v1787 = (v1782 - v1781) >> 4;
                                        v1790 += 16;
                                        if (v1791 >= v1787) {
                                          goto LABEL_2176;
                                        }
                                        continue;
                                      }
                                    }
LABEL_2213:
                                    if (v1727) {
                                      operator delete(v1727);
                                    }
LABEL_2215:
                                    (*(void (**)(void, uint64_t ***, __CVBuffer *, float64x2_t *))(**(void **)(*a2 + 160) + 16))(*(void *)(*a2 + 160), v1890, texture, v1868);
                                    kdebug_trace();
                                    if (v1839)
                                    {
                                      uint64_t v1813 = **(void **)(*a2 + 32);
                                      double v1814 = *(double *)(v1813 + 8);
                                      if (v1814 >= v1838 || v1814 + 1000.0 <= v1838)
                                      {
                                        int v1816 = atomic_load((unsigned int *)v1813);
                                        if (v1816 <= 0)
                                        {
                                          kdebug_trace();
                                          sub_1D0E08E18(*a2, v1890, v1838);
                                          kdebug_trace();
                                        }
                                      }
                                    }
                                    v588 = v1874;
                                    if (!v1874)
                                    {
LABEL_732:
                                      v589 = (char *)v1958;
                                      if (v1958)
                                      {
                                        if (v1959 != v1958)
                                        {
                                          v590 = v1959 - 104;
                                          v591 = v1959 - 104;
                                          v592 = (void (***)(char *))(v1959 - 104);
                                          do
                                          {
                                            v593 = *v592;
                                            v592 -= 13;
                                            (*v593)(v591);
                                            v590 -= 104;
                                            _ZF = v591 == v589;
                                            v591 = (char *)v592;
                                          }
                                          while (!_ZF);
                                          v589 = (char *)v1958;
                                        }
                                        operator delete(v589);
                                      }
                                      goto LABEL_739;
                                    }
LABEL_731:
                                    operator delete(v588);
                                    goto LABEL_732;
                                  }
                                  continue;
                                }
                              }
                              unint64_t v1510 = v1499[16];
                              uint64_t v1218 = v1869;
                              if (v1510 <= 2)
                              {
                                BOOL v1511 = v1486;
                                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EB9F1610))
                                {
                                  qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                                  __cxa_guard_release(&qword_1EB9F1610);
                                }
                                v1512 = qword_1EB9F1620;
                                if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
                                {
                                  *(_WORD *)int buf = 0;
                                  _os_log_debug_impl(&dword_1D0DBD000, v1512, OS_LOG_TYPE_DEBUG, "Filling up buffer with 3 frames", buf, 2u);
                                }
                                uint64_t v1434 = 0;
                                uint64_t v1432 = 0;
                                if (v1427) {
                                  uint64_t v1427 = v1427;
                                }
                                else {
                                  uint64_t v1427 = 7;
                                }
                                uint64_t v1433 = 256;
                                if (!v1511) {
                                  goto LABEL_1681;
                                }
                                goto LABEL_1671;
                              }
                              uint64_t v1829 = v1498;
                              v1557 = (long long **)(*(void *)(v1499[12] + ((v1499[15] >> 4) & 0xFFFFFFFFFFFFFF8))
                                                  + 32 * (v1499[15] & 0x7FLL));
                              v1559 = *v1557;
                              v1558 = (std::__shared_weak_count *)v1557[1];
                              if (v1558)
                              {
                                v1837 = v1558;
                                atomic_fetch_add_explicit(&v1558->__shared_owners_, 1uLL, memory_order_relaxed);
                                v1499 = *(void **)v1423;
                                unint64_t v1510 = *(void *)(*(void *)v1423 + 128);
                                uint64_t v1560 = v1497;
                                if (v1510 < 2)
                                {
                                  v1561 = 0;
                                  v1832 = 0;
                                  goto LABEL_1747;
                                }
                              }
                              else
                              {
                                v1837 = 0;
                                uint64_t v1560 = v1497;
                              }
                              v1565 = (long long **)(*(void *)(v1499[12]
                                                              + (((unint64_t)(v1499[15] + 1) >> 4) & 0xFFFFFFFFFFFFFF8))
                                                  + 32 * ((v1499[15] + 1) & 0x7F));
                              v1561 = *v1565;
                              v1566 = (std::__shared_weak_count *)v1565[1];
                              if (v1566)
                              {
                                v1832 = v1566;
                                atomic_fetch_add_explicit(&v1566->__shared_owners_, 1uLL, memory_order_relaxed);
                                v1499 = *(void **)v1423;
                                if (*(void *)(*(void *)v1423 + 128) >= 3uLL)
                                {
LABEL_1744:
                                  v1567 = (long long **)(*(void *)(v1499[12]
                                                                  + (((unint64_t)(v1499[15] + 2) >> 4) & 0xFFFFFFFFFFFFFF8))
                                                      + 32 * ((v1499[15] + 2) & 0x7F));
                                  v1568 = *v1567;
                                  v1569 = (std::__shared_weak_count *)v1567[1];
                                  if (v1569) {
                                    atomic_fetch_add_explicit(&v1569->__shared_owners_, 1uLL, memory_order_relaxed);
                                  }
LABEL_1748:
                                  int v1570 = *((_DWORD *)v1559 + 6);
                                  v1856 = v1561;
                                  pixelBufferb = v1559;
                                  if (v1570)
                                  {
                                    if (v1570 != 1) {
                                      goto LABEL_2234;
                                    }
                                    long long v1571 = *v1559;
                                    *(void *)&uint8_t buf[16] = *((void *)v1559 + 2);
                                    *(_OWORD *)int buf = v1571;
                                    double v1572 = CMTimeGetSeconds((CMTime *)buf);
                                    v1561 = v1856;
                                  }
                                  else
                                  {
                                    double v1572 = *(double *)v1559;
                                  }
                                  double v1573 = v1572 * 1000.0;
                                  int v1574 = *((_DWORD *)v1561 + 6);
                                  if (v1574)
                                  {
                                    if (v1574 != 1) {
                                      goto LABEL_2234;
                                    }
                                    long long v1575 = *v1561;
                                    *(void *)&uint8_t buf[16] = *((void *)v1561 + 2);
                                    *(_OWORD *)int buf = v1575;
                                    Float64 v1576 = CMTimeGetSeconds((CMTime *)buf);
                                    v1561 = v1856;
                                    int v1577 = *((_DWORD *)v1856 + 6);
                                    double v1578 = v1573 + v1576 * -1000.0;
                                    *(float *)&double v1578 = v1578;
                                    double v1850 = v1578;
                                    if (v1577)
                                    {
                                      if (v1577 != 1) {
                                        goto LABEL_2234;
                                      }
                                      long long v1579 = *v1856;
                                      *(void *)&uint8_t buf[16] = *((void *)v1856 + 2);
                                      *(_OWORD *)int buf = v1579;
                                      double v1580 = CMTimeGetSeconds((CMTime *)buf);
LABEL_1759:
                                      int v1582 = *((_DWORD *)v1568 + 6);
                                      BOOL v1828 = v1486;
                                      double v1826 = v1580;
                                      if (v1582)
                                      {
                                        if (v1582 != 1) {
                                          goto LABEL_2234;
                                        }
                                        long long v1583 = *v1568;
                                        *(void *)&uint8_t buf[16] = *((void *)v1568 + 2);
                                        *(_OWORD *)int buf = v1583;
                                        double v1823 = CMTimeGetSeconds((CMTime *)buf);
                                      }
                                      else
                                      {
                                        double v1823 = *(double *)v1568;
                                      }
                                      *(_DWORD *)&buf[28] = 0;
                                      *(_DWORD *)&unsigned char buf[12] = 0;
                                      *(void *)&buf[20] = 0;
                                      *(void *)&uint8_t buf[4] = 0;
                                      *(_DWORD *)int buf = 1065353216;
                                      *(_DWORD *)&uint8_t buf[16] = 1065353216;
                                      *(_DWORD *)&buf[32] = 1065353216;
                                      *(void *)&buf[36] = 0;
                                      *(_DWORD *)&buf[44] = 0;
                                      v2022[0] = (float32x2_t)&v1975[4];
                                      v2022[1] = (float32x2_t)(v1559 + 2);
                                      v1824 = v1559 + 2;
                                      sub_1D0DF1BF0((uint64_t)buf, (float **)v2022);
                                      __p[0] = &v1975[4];
                                      __p[1] = (char *)v1559 + 68;
                                      *(float32x2_t *)((char *)v2022 + 4) = 0;
                                      v2022[1].i32[1] = 0;
                                      sub_1D0DF1DA0((float *)v2022 + 1, (float **)__p);
                                      *(float32x2_t *)&buf[36] = vadd_f32(*(float32x2_t *)((char *)v2022 + 4), v1976);
                                      *(float *)&buf[44] = v2022[1].f32[1] + v1977;
                                      float v1584 = v1425[39];
                                      v1842 = v1568;
                                      if ((v1885 & 1) == 0)
                                      {
                                        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EB9F1610))
                                        {
                                          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                                          __cxa_guard_release(&qword_1EB9F1610);
                                        }
                                        float v1584 = v1584 + -30.0;
                                        v1585 = qword_1EB9F1620;
                                        if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
                                        {
                                          v1691 = *(void **)(*(void *)v1423 + 24);
                                          v1692 = *(std::__shared_weak_count **)(*(void *)v1423 + 32);
                                          if (v1692) {
                                            atomic_fetch_add_explicit(&v1692->__shared_owners_, 1uLL, memory_order_relaxed);
                                          }
                                          v1693 = "(null)";
                                          if (v1691) {
                                            v1693 = (const char *)(*v1691 + 160);
                                          }
                                          if (v1692
                                            && !atomic_fetch_add(&v1692->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                          {
                                            ((void (*)(std::__shared_weak_count *))v1692->__on_zero_shared)(v1692);
                                            std::__shared_weak_count::__release_weak(v1692);
                                          }
                                          v2022[0].i32[0] = 134218242;
                                          *(double *)((char *)v2022 + 4) = v1584;
                                          v2022[1].i16[2] = 2080;
                                          *(float32x2_t *)((char *)&v2022[1] + 6) = (float32x2_t)v1693;
                                          _os_log_debug_impl(&dword_1D0DBD000, v1585, OS_LOG_TYPE_DEBUG, "Decreasing max distance for tracking to %f mm; due to previous error detected (user %s).",
                                            (uint8_t *)v2022,
                                            0x16u);
                                        }
                                      }
                                      if (*(float *)&buf[44] <= v1584)
                                      {
                                        uint64_t v1434 = 0;
                                        uint64_t v1560 = v1829;
                                      }
                                      else
                                      {
                                        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EB9F1610))
                                        {
                                          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                                          __cxa_guard_release(&qword_1EB9F1610);
                                        }
                                        v1586 = qword_1EB9F1620;
                                        if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
                                        {
                                          v1694 = *(void **)(*(void *)v1423 + 24);
                                          v1695 = *(std::__shared_weak_count **)(*(void *)v1423 + 32);
                                          if (v1695) {
                                            atomic_fetch_add_explicit(&v1695->__shared_owners_, 1uLL, memory_order_relaxed);
                                          }
                                          v1696 = "(null)";
                                          if (v1694) {
                                            v1696 = (const char *)(*v1694 + 160);
                                          }
                                          if (v1695
                                            && !atomic_fetch_add(&v1695->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                          {
                                            ((void (*)(std::__shared_weak_count *))v1695->__on_zero_shared)(v1695);
                                            std::__shared_weak_count::__release_weak(v1695);
                                          }
                                          v2022[0].i32[0] = 136315138;
                                          *(float32x2_t *)((char *)v2022 + 4) = (float32x2_t)v1696;
                                          _os_log_debug_impl(&dword_1D0DBD000, v1586, OS_LOG_TYPE_DEBUG, "Resetting due to face too far from camera (user %s)", (uint8_t *)v2022, 0xCu);
                                        }
                                        uint64_t v1434 = 1;
                                      }
                                      float v1587 = *(float *)&buf[44];
                                      float v1589 = v1425[37];
                                      float v1588 = v1425[38];
                                      v1830 = v1569;
                                      if ((v1885 & 1) == 0)
                                      {
                                        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EB9F1610))
                                        {
                                          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                                          __cxa_guard_release(&qword_1EB9F1610);
                                        }
                                        float v1588 = v1588 + 30.0;
                                        v1590 = qword_1EB9F1620;
                                        if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
                                        {
                                          v1697 = *(void **)(*(void *)v1423 + 24);
                                          v1698 = *(std::__shared_weak_count **)(*(void *)v1423 + 32);
                                          if (v1698) {
                                            atomic_fetch_add_explicit(&v1698->__shared_owners_, 1uLL, memory_order_relaxed);
                                          }
                                          v1699 = "(null)";
                                          if (v1697) {
                                            v1699 = (const char *)(*v1697 + 160);
                                          }
                                          if (v1698
                                            && !atomic_fetch_add(&v1698->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                          {
                                            ((void (*)(std::__shared_weak_count *))v1698->__on_zero_shared)(v1698);
                                            std::__shared_weak_count::__release_weak(v1698);
                                          }
                                          v2022[0].i32[0] = 134218242;
                                          *(double *)((char *)v2022 + 4) = v1588;
                                          v2022[1].i16[2] = 2080;
                                          *(float32x2_t *)((char *)&v2022[1] + 6) = (float32x2_t)v1699;
                                          _os_log_debug_impl(&dword_1D0DBD000, v1590, OS_LOG_TYPE_DEBUG, "Increasing min distance for tracking to %f mm; due to previous error detected (user %s).",
                                            (uint8_t *)v2022,
                                            0x16u);
                                        }
                                      }
                                      float v1591 = *(float *)&buf[44];
                                      if (*(float *)&buf[44] < v1588)
                                      {
                                        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EB9F1610))
                                        {
                                          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                                          __cxa_guard_release(&qword_1EB9F1610);
                                        }
                                        v1592 = qword_1EB9F1620;
                                        if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
                                        {
                                          v1700 = *(void **)(*(void *)v1423 + 24);
                                          v1701 = *(std::__shared_weak_count **)(*(void *)v1423 + 32);
                                          if (v1701) {
                                            atomic_fetch_add_explicit(&v1701->__shared_owners_, 1uLL, memory_order_relaxed);
                                          }
                                          v1702 = "(null)";
                                          if (v1700) {
                                            v1702 = (const char *)(*v1700 + 160);
                                          }
                                          if (v1701
                                            && !atomic_fetch_add(&v1701->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                          {
                                            ((void (*)(std::__shared_weak_count *))v1701->__on_zero_shared)(v1701);
                                            std::__shared_weak_count::__release_weak(v1701);
                                          }
                                          v2022[0].i32[0] = 136315138;
                                          *(float32x2_t *)((char *)v2022 + 4) = (float32x2_t)v1702;
                                          _os_log_debug_impl(&dword_1D0DBD000, v1592, OS_LOG_TYPE_DEBUG, "Resetting due to face too close to camera (user %s)", (uint8_t *)v2022, 0xCu);
                                        }
                                        if (!v1560) {
                                          uint64_t v1560 = 3;
                                        }
                                        float v1591 = *(float *)&buf[44];
                                        uint64_t v1434 = 1;
                                      }
                                      float v1593 = 1.0
                                            / sqrtf((float)((float)(*(float *)&buf[36] * *(float *)&buf[36])+ (float)(*(float *)&buf[40] * *(float *)&buf[40]))+ (float)(v1591 * v1591));
                                      float v1594 = -(float)((float)(*(float *)&buf[32] * (float)(v1591 * v1593))
                                                     + (float)((float)(*(float *)&buf[24]
                                                                     * (float)(*(float *)&buf[36] * v1593))
                                                             + (float)(*(float *)&buf[28]
                                                                     * (float)(*(float *)&buf[40] * v1593))));
                                      float v1825 = v1430;
                                      if (cosf(v1425[35] / 57.296) >= v1594)
                                      {
                                        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EB9F1610))
                                        {
                                          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                                          __cxa_guard_release(&qword_1EB9F1610);
                                        }
                                        v1595 = qword_1EB9F1620;
                                        if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
                                        {
                                          v1703 = *(void **)(*(void *)v1423 + 24);
                                          v1704 = *(std::__shared_weak_count **)(*(void *)v1423 + 32);
                                          if (v1704) {
                                            atomic_fetch_add_explicit(&v1704->__shared_owners_, 1uLL, memory_order_relaxed);
                                          }
                                          v1705 = "(null)";
                                          if (v1703) {
                                            v1705 = (const char *)(*v1703 + 160);
                                          }
                                          if (v1704
                                            && !atomic_fetch_add(&v1704->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                          {
                                            ((void (*)(std::__shared_weak_count *))v1704->__on_zero_shared)(v1704);
                                            std::__shared_weak_count::__release_weak(v1704);
                                          }
                                          v2022[0].i32[0] = 136315138;
                                          *(float32x2_t *)((char *)v2022 + 4) = (float32x2_t)v1705;
                                          _os_log_debug_impl(&dword_1D0DBD000, v1595, OS_LOG_TYPE_DEBUG, "Resetting due to too much rotation (user %s)", (uint8_t *)v2022, 0xCu);
                                        }
                                        if (!v1560) {
                                          uint64_t v1560 = 5;
                                        }
                                        uint64_t v1434 = 1;
                                      }
                                      BOOL v1596 = cosf(v1425[24] / 57.296) >= v1594 || v1587 > v1589;
                                      float v1597 = cosf(v1425[29] / 57.296);
                                      *(void *)&long long v1988 = &v1975[4];
                                      if (v1427) {
                                        BOOL v1598 = 1;
                                      }
                                      else {
                                        BOOL v1598 = v1597 < v1594;
                                      }
                                      __p[0] = &v1988;
                                      if (v1598) {
                                        int v1599 = v1427;
                                      }
                                      else {
                                        int v1599 = 5;
                                      }
                                      v2022[0] = (float32x2_t)__p;
                                      v2022[1] = (float32x2_t)&v1976;
                                      memptr[0] = 0;
                                      LODWORD(memptr[1]) = 0;
                                      sub_1D0E0FBA0((float *)memptr, (uint64_t)v2022);
                                      v1600 = v1856;
                                      float v1601 = *((float *)v1856 + 19);
                                      float32x2_t v1602 = *(float32x2_t *)((char *)v1856 + 68);
                                      float32x2_t v1603 = vsub_f32(v1602, (float32x2_t)memptr[0]);
                                      *(float *)v1604.i32 = sqrtf(vaddv_f32(vmul_f32(v1603, v1603))+ (float)((float)(v1601 - *(float *)&memptr[1])* (float)(v1601 - *(float *)&memptr[1])));
                                      float32x2_t v1605 = vdiv_f32(v1603, (float32x2_t)vdup_lane_s32(v1604, 0));
                                      float v1606 = (float)(v1601 - *(float *)&memptr[1]) / *(float *)v1604.i32;
                                      float v1607 = 1000.0;
                                      if ((float)(*(float *)v1604.i32 + -1000.0) <= 1000.0) {
                                        float v1607 = *(float *)v1604.i32 + -1000.0;
                                      }
                                      if ((float)(*(float *)v1604.i32 + -1000.0) >= 0.0) {
                                        float v1608 = v1607;
                                      }
                                      else {
                                        float v1608 = 0.0;
                                      }
                                      float v1609 = (float)(v1608 * -0.0001) + 0.2;
                                      float v1610 = (float)(*(float *)v1604.i32 + -700.0) / 800.0;
                                      if (v1610 <= 1.0) {
                                        float v1611 = v1610;
                                      }
                                      else {
                                        float v1611 = 1.0;
                                      }
                                      if (v1610 >= 0.0) {
                                        float v1612 = v1611;
                                      }
                                      else {
                                        float v1612 = 0.0;
                                      }
                                      float v1613 = (float)(v1612 * 3.0) + 1.0;
                                      float32x2_t v1614 = vsub_f32(*(float32x2_t *)((char *)pixelBufferb + 68), v1602);
                                      float v1615 = *((float *)pixelBufferb + 19) - v1601;
                                      float v1616 = v1609 + -1.0;
                                      float v1617 = (float)(v1609 + -1.0)
                                            * (float)(vaddv_f32(vmul_f32(v1605, v1614)) + (float)(v1606 * v1615));
                                      float32x2_t v1618 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v1850, 0);
                                      float32x2_t v1822 = v1618;
                                      float32x2_t v1619 = vdiv_f32(vadd_f32(v1614, vmul_n_f32(v1605, v1617)), v1618);
                                      float v1620 = (float)(v1615 + (float)(v1606 * v1617)) / *(float *)&v1850;
                                      float v1621 = sqrtf(vaddv_f32(vmul_f32(v1619, v1619)) + (float)(v1620 * v1620));
                                      if (v1621 <= (float)(v1613 * v1425[18]))
                                      {
                                        uint64_t v1886 = v1560;
                                      }
                                      else
                                      {
                                        float v1821 = (float)(v1615 + (float)(v1606 * v1617)) / *(float *)&v1850;
                                        float pixelBufferc = v1613;
                                        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EB9F1610))
                                        {
                                          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                                          __cxa_guard_release(&qword_1EB9F1610);
                                        }
                                        v1622 = qword_1EB9F1620;
                                        if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
                                        {
                                          v1706 = *(void **)(*(void *)v1423 + 24);
                                          v1707 = *(std::__shared_weak_count **)(*(void *)v1423 + 32);
                                          if (v1707) {
                                            atomic_fetch_add_explicit(&v1707->__shared_owners_, 1uLL, memory_order_relaxed);
                                          }
                                          v1708 = "(null)";
                                          if (v1706) {
                                            v1708 = (const char *)(*v1706 + 160);
                                          }
                                          if (v1707
                                            && !atomic_fetch_add(&v1707->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                          {
                                            ((void (*)(std::__shared_weak_count *))v1707->__on_zero_shared)(v1707);
                                            std::__shared_weak_count::__release_weak(v1707);
                                          }
                                          v2022[0].i32[0] = 136315138;
                                          *(float32x2_t *)((char *)v2022 + 4) = (float32x2_t)v1708;
                                          _os_log_debug_impl(&dword_1D0DBD000, v1622, OS_LOG_TYPE_DEBUG, "Resetting due to too high translational velocity (user %s)", (uint8_t *)v2022, 0xCu);
                                        }
                                        if (!v1560) {
                                          uint64_t v1560 = 200;
                                        }
                                        uint64_t v1886 = v1560;
                                        v1600 = v1856;
                                        float32x2_t v1602 = *(float32x2_t *)((char *)v1856 + 68);
                                        float v1601 = *((float *)v1856 + 19);
                                        uint64_t v1434 = 1;
                                        float v1613 = pixelBufferc;
                                        float v1620 = v1821;
                                      }
                                      v1623.i32[1] = HIDWORD(v1823);
                                      *(float *)v1623.i32 = v1826 * 1000.0 + v1823 * -1000.0;
                                      int v1624 = v1621 > v1425[25] || v1596;
                                      if (v1599) {
                                        BOOL v1625 = 1;
                                      }
                                      else {
                                        BOOL v1625 = v1621 <= v1425[30];
                                      }
                                      if (!v1625) {
                                        int v1599 = 200;
                                      }
                                      float v1626 = v1601 - *((float *)v1842 + 19);
                                      v1618.f32[0] = (float)(*(float *)&v1850 + *(float *)v1623.i32) * v930;
                                      float32x2_t v1627 = vsub_f32(v1602, *(float32x2_t *)((char *)v1842 + 68));
                                      float v1628 = v1616
                                            * (float)(vaddv_f32(vmul_f32(v1605, v1627)) + (float)(v1606 * v1626));
                                      float32x2_t v1629 = vadd_f32(v1627, vmul_n_f32(v1605, v1628));
                                      float v1630 = v1606 * v1628;
                                      float32x2_t v1631 = (float32x2_t)vdup_lane_s32(v1623, 0);
                                      float pixelBufferd = v1826 * 1000.0 + v1823 * -1000.0;
                                      float32x2_t v1632 = (float32x2_t)vdup_lane_s32((int32x2_t)v1618, 0);
                                      float32x2_t v1633 = vdiv_f32(vsub_f32(v1619, vdiv_f32(v1629, v1631)), v1632);
                                      float v1827 = v1618.f32[0];
                                      float v1634 = sqrtf(vaddv_f32(vmul_f32(v1633, v1633))+ (float)((float)((float)(v1620- (float)((float)(v1626 + v1630)/ *(float *)v1623.i32))/ v1618.f32[0])* (float)((float)(v1620- (float)((float)(v1626 + v1630)/ *(float *)v1623.i32))/ v1618.f32[0])));
                                      if (v1634 <= (float)(v1613 * v1425[20]))
                                      {
                                        long long v1637 = 0uLL;
                                      }
                                      else
                                      {
                                        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EB9F1610))
                                        {
                                          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                                          __cxa_guard_release(&qword_1EB9F1610);
                                        }
                                        v1635 = qword_1EB9F1620;
                                        if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
                                        {
                                          v1709 = *(void **)(*(void *)v1423 + 24);
                                          v1710 = *(std::__shared_weak_count **)(*(void *)v1423 + 32);
                                          if (v1710) {
                                            atomic_fetch_add_explicit(&v1710->__shared_owners_, 1uLL, memory_order_relaxed);
                                          }
                                          v1711 = "(null)";
                                          if (v1709) {
                                            v1711 = (const char *)(*v1709 + 160);
                                          }
                                          if (v1710
                                            && !atomic_fetch_add(&v1710->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                          {
                                            ((void (*)(std::__shared_weak_count *))v1710->__on_zero_shared)(v1710);
                                            std::__shared_weak_count::__release_weak(v1710);
                                          }
                                          v2022[0].i32[0] = 136315138;
                                          *(float32x2_t *)((char *)v2022 + 4) = (float32x2_t)v1711;
                                          _os_log_debug_impl(&dword_1D0DBD000, v1635, OS_LOG_TYPE_DEBUG, "Resetting due to too high translational acceleration (user %s)", (uint8_t *)v2022, 0xCu);
                                        }
                                        uint64_t v1636 = v1886;
                                        if (!v1886) {
                                          uint64_t v1636 = 201;
                                        }
                                        uint64_t v1886 = v1636;
                                        uint64_t v1434 = 1;
                                        long long v1637 = 0uLL;
                                        v1600 = v1856;
                                      }
                                      v1638 = v1600 + 2;
                                      if (v1634 > v1425[27]) {
                                        int v1624 = 1;
                                      }
                                      float v1639 = v1425[32];
                                      *(void *)&long long v1988 = v1600 + 2;
                                      if (v1599) {
                                        BOOL v1640 = 1;
                                      }
                                      else {
                                        BOOL v1640 = v1634 <= v1639;
                                      }
                                      if (!v1640) {
                                        int v1599 = 201;
                                      }
                                      __p[0] = v1824;
                                      __p[1] = &v1988;
                                      *(_OWORD *)v2022[0].f32 = v1637;
                                      *(_OWORD *)v2022[2].f32 = v1637;
                                      int v2023 = 0;
                                      sub_1D0E21CFC((uint64_t)v2022, (uint64_t)__p);
                                      LODWORD(memptr[1]) = 0;
                                      memptr[0] = 0;
                                      sub_1D0E21ECC(v2022, (float *)memptr);
                                      float32x2_t v1641 = vdiv_f32((float32x2_t)memptr[0], v1822);
                                      float v1642 = *(float *)&memptr[1] / *(float *)&v1850;
                                      float v1643 = sqrtf(vaddv_f32(vmul_f32(v1641, v1641)) + (float)(v1642 * v1642));
                                      if (v1643 > (float)(v1425[19] / 57.296))
                                      {
                                        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EB9F1610))
                                        {
                                          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                                          __cxa_guard_release(&qword_1EB9F1610);
                                        }
                                        v1644 = qword_1EB9F1620;
                                        if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
                                        {
                                          v1712 = *(void **)(*(void *)v1423 + 24);
                                          v1713 = *(std::__shared_weak_count **)(*(void *)v1423 + 32);
                                          if (v1713) {
                                            atomic_fetch_add_explicit(&v1713->__shared_owners_, 1uLL, memory_order_relaxed);
                                          }
                                          v1714 = "(null)";
                                          if (v1712) {
                                            v1714 = (const char *)(*v1712 + 160);
                                          }
                                          if (v1713
                                            && !atomic_fetch_add(&v1713->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                          {
                                            ((void (*)(std::__shared_weak_count *))v1713->__on_zero_shared)(v1713);
                                            std::__shared_weak_count::__release_weak(v1713);
                                          }
                                          v2022[0].i32[0] = 136315138;
                                          *(float32x2_t *)((char *)v2022 + 4) = (float32x2_t)v1714;
                                          _os_log_debug_impl(&dword_1D0DBD000, v1644, OS_LOG_TYPE_DEBUG, "Resetting due to too high angular velocity (user %s)", (uint8_t *)v2022, 0xCu);
                                        }
                                        uint64_t v1645 = v1886;
                                        if (!v1886) {
                                          uint64_t v1645 = 202;
                                        }
                                        uint64_t v1886 = v1645;
                                        uint64_t v1434 = 1;
                                      }
                                      if (v1643 > (float)(v1425[26] / 57.296)) {
                                        int v1646 = 1;
                                      }
                                      else {
                                        int v1646 = v1624;
                                      }
                                      float v1647 = v1425[31] / 57.296;
                                      *(void *)&long long v1988 = v1842 + 2;
                                      __p[0] = v1638;
                                      __p[1] = &v1988;
                                      if (v1599) {
                                        BOOL v1648 = 1;
                                      }
                                      else {
                                        BOOL v1648 = v1643 <= v1647;
                                      }
                                      if (v1648) {
                                        unsigned int v1649 = v1599;
                                      }
                                      else {
                                        unsigned int v1649 = 202;
                                      }
                                      memset(v2022, 0, sizeof(v2022));
                                      int v2023 = 0;
                                      sub_1D0E21CFC((uint64_t)v2022, (uint64_t)__p);
                                      LODWORD(memptr[1]) = 0;
                                      memptr[0] = 0;
                                      sub_1D0E21ECC(v2022, (float *)memptr);
                                      float32x2_t v1650 = vdiv_f32(vsub_f32(v1641, vdiv_f32((float32x2_t)memptr[0], v1631)), v1632);
                                      float v1651 = sqrtf(vaddv_f32(vmul_f32(v1650, v1650))+ (float)((float)((float)(v1642- (float)(*(float *)&memptr[1] / pixelBufferd))/ v1827)* (float)((float)(v1642- (float)(*(float *)&memptr[1] / pixelBufferd))/ v1827)));
                                      if (v1651 <= (float)(v1425[21] / 57.296))
                                      {
                                        uint64_t v1431 = v1886;
                                        float v1430 = v1825;
                                      }
                                      else
                                      {
                                        float v1430 = v1825;
                                        uint64_t v1431 = v1886;
                                        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EB9F1610))
                                        {
                                          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                                          __cxa_guard_release(&qword_1EB9F1610);
                                        }
                                        v1652 = qword_1EB9F1620;
                                        if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
                                        {
                                          v1715 = *(void **)(*(void *)v1423 + 24);
                                          v1716 = *(std::__shared_weak_count **)(*(void *)v1423 + 32);
                                          if (v1716) {
                                            atomic_fetch_add_explicit(&v1716->__shared_owners_, 1uLL, memory_order_relaxed);
                                          }
                                          v1717 = "(null)";
                                          if (v1715) {
                                            v1717 = (const char *)(*v1715 + 160);
                                          }
                                          if (v1716
                                            && !atomic_fetch_add(&v1716->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                          {
                                            ((void (*)(std::__shared_weak_count *))v1716->__on_zero_shared)(v1716);
                                            std::__shared_weak_count::__release_weak(v1716);
                                          }
                                          v2022[0].i32[0] = 136315138;
                                          *(float32x2_t *)((char *)v2022 + 4) = (float32x2_t)v1717;
                                          _os_log_debug_impl(&dword_1D0DBD000, v1652, OS_LOG_TYPE_DEBUG, "Resetting due to too high angular acceleration (user %s)", (uint8_t *)v2022, 0xCu);
                                        }
                                        if (!v1886) {
                                          uint64_t v1431 = 203;
                                        }
                                        uint64_t v1434 = 1;
                                      }
                                      if (v1651 > (float)(v1425[28] / 57.296)) {
                                        int v1653 = 1;
                                      }
                                      else {
                                        int v1653 = v1646;
                                      }
                                      if (v1649) {
                                        BOOL v1654 = 1;
                                      }
                                      else {
                                        BOOL v1654 = v1651 <= (float)(v1425[33] / 57.296);
                                      }
                                      if (v1654) {
                                        uint64_t v1427 = v1649;
                                      }
                                      else {
                                        uint64_t v1427 = 203;
                                      }
                                      if (v1830 && !atomic_fetch_add(&v1830->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                      {
                                        ((void (*)(std::__shared_weak_count *))v1830->__on_zero_shared)(v1830);
                                        std::__shared_weak_count::__release_weak(v1830);
                                      }
                                      if (v1832 && !atomic_fetch_add(&v1832->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                      {
                                        ((void (*)(std::__shared_weak_count *))v1832->__on_zero_shared)(v1832);
                                        std::__shared_weak_count::__release_weak(v1832);
                                      }
                                      if (v1837 && !atomic_fetch_add(&v1837->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                      {
                                        ((void (*)(std::__shared_weak_count *))v1837->__on_zero_shared)(v1837);
                                        std::__shared_weak_count::__release_weak(v1837);
                                      }
                                      uint64_t v1433 = 0;
                                      uint64_t v1432 = 0x10000;
                                      if (!v1653) {
                                        uint64_t v1432 = 0;
                                      }
                                      if (!v1828) {
                                        goto LABEL_1681;
                                      }
LABEL_1671:
                                      uint64_t v1428 = 0;
                                      uint64_t v1435 = 0;
                                      if (v1430 < v1424) {
                                        goto LABEL_1682;
                                      }
                                      goto LABEL_1683;
                                    }
                                  }
                                  else
                                  {
                                    double v1581 = v1573 + *(double *)v1561 * -1000.0;
                                    *(float *)&double v1581 = v1581;
                                    double v1850 = v1581;
                                  }
                                  double v1580 = *(double *)v1561;
                                  goto LABEL_1759;
                                }
                              }
                              else
                              {
                                v1832 = 0;
                                if (v1510 >= 3) {
                                  goto LABEL_1744;
                                }
                              }
LABEL_1747:
                              v1569 = 0;
                              v1568 = 0;
                              goto LABEL_1748;
                            }
                            uint64_t v1230 = *(void *)(*(void *)&v1220[12]
                                              + ((*(void *)&v1220[15] >> 4) & 0xFFFFFFFFFFFFFF8))
                                  + 32 * (*(void *)&v1220[15] & 0x7FLL);
                            uint64_t v1232 = *(void *)(v1230 + 16);
                            v1231 = *(std::__shared_weak_count **)(v1230 + 24);
                            if (v1231)
                            {
                              atomic_fetch_add_explicit(&v1231->__shared_owners_, 1uLL, memory_order_relaxed);
                              if (!atomic_fetch_add(&v1231->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                              {
                                ((void (*)(std::__shared_weak_count *))v1231->__on_zero_shared)(v1231);
                                std::__shared_weak_count::__release_weak(v1231);
                              }
                            }
                            uint64_t v1233 = *((void *)v1219 + 40);
                            unsigned int v1234 = *((_DWORD *)v1219 + 84);
                            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
                              && __cxa_guard_acquire(&qword_1EB9F1618))
                            {
                              sub_1D0E225B4();
                            }
                            float v1235 = *(float *)(qword_1EB9F15F8 + 204);
                            v2022[3].i32[1] = 0;
                            v2022[1].i32[1] = 0;
                            *(float32x2_t *)((char *)&v2022[2] + 4) = 0;
                            *(float32x2_t *)((char *)v2022 + 4) = 0;
                            v2022[0].i32[0] = 1065353216;
                            v2022[2].i32[0] = 1065353216;
                            int v2023 = 1065353216;
                            float32x2_t v2024 = 0;
                            float v2025 = 0.0;
                            *(void *)v2013 = &v1975[4];
                            *(void *)&v2013[8] = v1232 + 32;
                            sub_1D0DF1BF0((uint64_t)v2022, (float **)v2013);
                            *(void *)v2006 = &v1975[4];
                            *(void *)&v2006[8] = v1232 + 68;
                            *(void *)&v2013[4] = 0;
                            *(_DWORD *)&v2013[12] = 0;
                            sub_1D0DF1DA0((float *)&v2013[4], (float **)v2006);
                            float32x2_t v2024 = vadd_f32(*(float32x2_t *)&v2013[4], v1976);
                            float v2025 = *(float *)&v2013[12] + v1977;
                            *(void *)&long long v1236 = *(void *)v1974;
                            *((void *)&v1236 + 1) = *(void *)&v1974[12];
                            *(_OWORD *)int buf = *(_OWORD *)v2022[0].f32;
                            *(_OWORD *)&uint8_t buf[16] = *(_OWORD *)v2022[2].f32;
                            *(_DWORD *)&buf[32] = v2023;
                            *(float32x2_t *)&buf[36] = v2024;
                            *(float *)&buf[44] = *(float *)&v2013[12] + v1977;
                            *(_OWORD *)&buf[48] = v1236;
                            float32x2_t v2018 = *(float32x2_t *)&v1974[24];
                            long long v2020 = 0u;
                            long long v2021 = 0u;
                            long long v2019 = 0u;
                            *(_DWORD *)v2013 = 2;
                            *(void *)&v2013[8] = buf;
                            *(void *)&v2013[16] = 3;
                            *(void *)v2006 = &buf[48];
                            *(void *)&v2006[8] = v2013;
                            sub_1D0E40774((uint64_t)&v2019, (uint64_t)v2006);
                            *(_DWORD *)v2013 = 2;
                            *(void *)&v2013[8] = &buf[36];
                            *(void *)&v2013[16] = 3;
                            *(void *)v2006 = &buf[48];
                            *(void *)&v2006[8] = v2013;
                            sub_1D0E40888((float *)&v2020 + 2, (uint64_t)v2006);
                            float v1239 = *(float *)&buf[8];
                            *(void *)&long long v2021 = __PAIR64__(*(unsigned int *)&buf[20], *(unsigned int *)&buf[8]);
                            float v1240 = *(float *)&buf[44];
                            *((void *)&v2021 + 1) = __PAIR64__(*(unsigned int *)&buf[44], *(unsigned int *)&buf[32]);
                            if (v1234 >= 3)
                            {
                              unint64_t v1242 = v1234 / 3uLL;
                              float32x2_t v1243 = *(float32x2_t *)((char *)&v2021 + 4);
                              float32x2_t v1244 = *(float32x2_t *)((char *)&v2020 + 8);
                              float32x2_t v1245 = v2018;
                              *(void *)&long long v1237 = 0x7F7FFFFFFF7FFFFFLL;
                              *(void *)&long long v1238 = 0xFF7FFFFF7F7FFFFFLL;
                              v1246 = (void *)(v1233 + 4);
                              v1241 = v1884;
                              do
                              {
                                *(_OWORD *)keyint k = v1238;
                                *(_OWORD *)v1914 = v1237;
                                *(void *)v2013 = &v2019;
                                *(void *)&v2013[8] = v1233;
                                *(float32x2_t *)((char *)v2022 + 4) = 0;
                                sub_1D0E406D0((float *)v2022 + 1, (float **)v2013);
                                *((CFStringRef *)&v1238 + 1) = keyk[1];
                                *((void *)&v1237 + 1) = *(void *)&v1914[2];
                                float v1247 = v1239 * *((float *)v1246 - 1);
                                float32x2_t v1248 = *(float32x2_t *)v1246;
                                v1246 = (void *)((char *)v1246 + 12);
                                float32x2_t v1249 = vmul_f32(v1243, v1248);
                                *(float *)v1250.i32 = v1240 + (float)((float)(v1247 + v1249.f32[0]) + v1249.f32[1]);
                                int8x8_t v1251 = (int8x8_t)vadd_f32(v1245, vdiv_f32(vadd_f32(*(float32x2_t *)((char *)v2022 + 4), v1244), (float32x2_t)vdup_lane_s32(v1250, 0)));
                                *(int8x8_t *)&long long v1237 = vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(v1914[1], v1251.u32[0]), (float32x2_t)__PAIR64__(v1251.u32[1], v1914[0])), v1251, *(int8x8_t *)v1914);
                                *(int8x8_t *)&long long v1238 = vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(v1251.u32[1], keyk[0]), (float32x2_t)__PAIR64__(HIDWORD(keyk[0]), v1251.u32[0])), v1251, (int8x8_t)keyk[0]);
                                v1233 += 12;
                                --v1242;
                              }
                              while (v1242);
                            }
                            else
                            {
                              *(void *)&long long v1237 = 0x7F7FFFFFFF7FFFFFLL;
                              *(void *)&long long v1238 = 0xFF7FFFFF7F7FFFFFLL;
                              v1241 = v1884;
                            }
                            int32x2_t v1252 = (int32x2_t)vsub_f32((float32x2_t)__PAIR64__(DWORD1(v1238), v1237), (float32x2_t)__PAIR64__(DWORD1(v1237), v1238));
                            if (*(float *)v1252.i32 < *(float *)&v1252.i32[1]) {
                              v1252.i32[0] = v1252.i32[1];
                            }
                            float32_t v1253 = (float)(v1235 * 0.85) * *(float *)v1252.i32;
                            *(float *)v1252.i32 = v1253 * v930;
                            v1254 = *v1241;
                            *(float32x2_t *)((char *)v1254 + 44) = vsub_f32(vmul_f32(vadd_f32(*(float32x2_t *)&v1238, *(float32x2_t *)&v1237), (float32x2_t)0x3F0000003F000000), (float32x2_t)vdup_lane_s32(v1252, 0));
                            v1254[6].f32[1] = v1253;
                            v1254[7].f32[0] = v1253;
                            float32x2_t v1255 = vsub_f32(vmul_n_f32(*(float32x2_t *)&buf[12], *(float *)&buf[44]), vmul_n_f32(*(float32x2_t *)&buf[36], *(float *)&buf[20]));
                            float v1256 = 0.0;
                            if (vaddv_f32(vmul_f32(v1255, v1255)) >= 0.000000001) {
                              float v1256 = (float)(atan2f(v1255.f32[0], -v1255.f32[1]) / 3.1416) * 180.0;
                            }
                            v1254[7].f32[1] = v1256;
                            v1254[8].i8[0] = 1;
                            v1257 = *v1241;
                            float32x2_t v1258 = (*v1241)[19];
                            uint64_t v1259 = (*v1241)[5].u32[0];
                            float v1260 = (*v1241)[7].f32[0];
                            float v1261 = (*v1241)[7].f32[1];
                            *(_OWORD *)v2022[0].f32 = *(_OWORD *)((char *)(*v1241)[8].f32 + 1);
                            *(float32x2_t *)((char *)&v2022[1] + 7) = v1257[10];
                            float v1262 = (float)(*(float *)(*(void *)&v1258 + 120) * v930)
                                  * (float)(v1257[6].f32[1] + v1260);
                            float v1263 = 1.5 / v1262;
                            BOOL v746 = v1262 <= 0.000001;
                            float v1264 = 1500000.0;
                            if (!v746) {
                              float v1264 = v1263;
                            }
                            *(float *)(*(void *)&v1258 + 4) = v1264;
                            float32x4_t v1265 = *(float32x4_t *)&v1257[5].i32[1];
                            uint64_t v1218 = v1869;
                            if (**(int **)&v1258 < 2) {
                              goto LABEL_1472;
                            }
                            unint64_t v1266 = *(void *)(*(void *)&v1258 + 40);
                            if (v1266) {
                              goto LABEL_1456;
                            }
                            v1268 = *(char **)(*(void *)&v1258 + 16);
                            v1267 = *(char **)(*(void *)&v1258 + 24);
                            uint64_t v1269 = 32 * (v1267 - v1268) - 1;
                            if (v1267 == v1268) {
                              uint64_t v1269 = 0;
                            }
                            *(float32x4_t *)v1915 = v1265;
                            if ((unint64_t)(v1269 - *(void *)(*(void *)&v1258 + 48)) >= 0x100)
                            {
                              *(void *)(*(void *)&v1258 + 40) = 256;
                              *(void *)v2013 = *((void *)v1267 - 1);
                              *(void *)(*(void *)&v1258 + 24) = v1267 - 8;
                              sub_1D0E3EA48((void **)(*(void *)&v1258 + 8), v2013);
                              float32x4_t v1265 = *(float32x4_t *)v1915;
                              v1105 = v1874;
                              v1241 = v1884;
                              goto LABEL_1455;
                            }
                            v1270 = *(char **)(*(void *)&v1258 + 32);
                            v1271 = *(char **)(*(void *)&v1258 + 8);
                            if (v1267 - v1268 < (unint64_t)(v1270 - v1271))
                            {
                              if (v1268 == v1271)
                              {
                                *(void *)v2013 = operator new(0x1000uLL);
                                sub_1D0E3EBF0((char **)(*(void *)&v1258 + 8), v2013);
                                uint64_t v1276 = *(void *)(*(void *)&v1258 + 24);
                                *(void *)v2013 = *(void *)(v1276 - 8);
                                *(void *)(*(void *)&v1258 + 24) = v1276 - 8;
                              }
                              else
                              {
                                *(void *)v2013 = operator new(0x1000uLL);
                              }
                              sub_1D0E3EA48((void **)(*(void *)&v1258 + 8), v2013);
                              v1105 = v1874;
                              v1241 = v1884;
                              float32x4_t v1265 = *(float32x4_t *)v1915;
                              if (*(void *)(*(void *)&v1258 + 24) - *(void *)(*(void *)&v1258 + 16) == 8) {
                                *(void *)(*(void *)&v1258 + 40) = 128;
                              }
                              else {
                                *(void *)(*(void *)&v1258 + 40) += 256;
                              }
                              goto LABEL_1455;
                            }
                            if (v1270 == v1271) {
                              unint64_t v1272 = 1;
                            }
                            else {
                              unint64_t v1272 = (v1270 - v1271) >> 2;
                            }
                            if (v1272 >> 61) {
                              goto LABEL_2232;
                            }
                            v1273 = (char *)operator new(8 * v1272);
                            v1274 = operator new(0x1000uLL);
                            if (v1272)
                            {
                              v1275 = &v1273[8 * v1272];
                            }
                            else
                            {
                              v1277 = (char *)operator new(8uLL);
                              v1275 = v1277 + 8;
                              operator delete(v1273);
                              v1268 = *(char **)(*(void *)&v1258 + 16);
                              v1267 = *(char **)(*(void *)&v1258 + 24);
                              v1273 = v1277;
                            }
                            *(void *)v1273 = v1274;
                            v1278 = v1273 + 8;
                            v1279 = v1273;
                            float32x4_t v1265 = *(float32x4_t *)v1915;
                            if (v1268 == v1267)
                            {
LABEL_1424:
                              v1280 = *(void **)(*(void *)&v1258 + 8);
                              *(void *)(*(void *)&v1258 + 8) = v1273;
                              *(void *)(*(void *)&v1258 + 16) = v1279;
                              *(void *)(*(void *)&v1258 + 24) = v1278;
                              *(void *)(*(void *)&v1258 + 32) = v1275;
                              v1105 = v1874;
                              if (v1278 - v1279 == 8) {
                                uint64_t v1281 = 128;
                              }
                              else {
                                uint64_t v1281 = *(void *)(*(void *)&v1258 + 40) + 256;
                              }
                              uint64_t v1218 = v1869;
                              v1241 = v1884;
                              *(void *)(*(void *)&v1258 + 40) = v1281;
                              if (v1280)
                              {
                                operator delete(v1280);
                                float32x4_t v1265 = *(float32x4_t *)v1915;
                              }
LABEL_1455:
                              unint64_t v1266 = *(void *)(*(void *)&v1258 + 40);
LABEL_1456:
                              uint64_t v1306 = *(void *)(*(void *)&v1258 + 16);
                              v1307 = (void *)(v1306 + 8 * (v1266 >> 8));
                              uint64_t v1308 = *v1307 + 16 * v1266;
                              if (*(void *)(*(void *)&v1258 + 24) == v1306) {
                                uint64_t v1308 = 0;
                              }
                              if (v1308 == *v1307) {
                                uint64_t v1308 = *(v1307 - 1) + 4096;
                              }
                              *(float32x4_t *)(v1308 - 16) = v1265;
                              unint64_t v1310 = *(void *)(*(void *)&v1258 + 40);
                              uint64_t v1309 = *(void *)(*(void *)&v1258 + 48);
                              uint64_t v1311 = v1309 + 1;
                              *(void *)(*(void *)&v1258 + 40) = v1310 - 1;
                              *(void *)(*(void *)&v1258 + 48) = v1309 + 1;
                              float v1312 = 0.0;
                              float v1313 = 0.0;
                              if ((int)v1309 + 1 >= 1)
                              {
                                float32x2_t v1314 = (float32x2_t)vextq_s8((int8x16_t)v1265, (int8x16_t)v1265, 8uLL).u64[0];
                                uint64_t v1315 = (v1309 + 1);
                                unint64_t v1316 = v1310 - 1;
                                do
                                {
                                  v1317 = (float32x2_t *)(*(void *)(*(void *)(*(void *)&v1258 + 16)
                                                                    + ((v1316 >> 5) & 0x7FFFFFFFFFFFFF8))
                                                        + 16 * v1316);
                                  float32x2_t v1318 = vsub_f32(*v1317, *(float32x2_t *)v1265.f32);
                                  float32x2_t v1319 = vmul_f32(v1318, v1318);
                                  float32x2_t v1320 = vsub_f32(v1317[1], v1314);
                                  float32x2_t v1321 = vmul_f32(v1320, v1320);
                                  float v1322 = sqrtf(vadd_f32(vadd_f32(vadd_f32(v1319, (float32x2_t)vdup_lane_s32((int32x2_t)v1319, 1)), v1321), (float32x2_t)vdup_lane_s32((int32x2_t)v1321, 1)).f32[0]);
                                  if (v1313 < v1322) {
                                    float v1313 = v1322;
                                  }
                                  ++v1316;
                                  --v1315;
                                }
                                while (v1315);
                              }
                              float v1323 = expf(-fminf(v1313 * *(float *)(*(void *)&v1258 + 4), 10.0));
                              if ((int)v1311 >= 1)
                              {
                                float v1324 = 1.0;
                                float v1312 = 0.0;
                                int v1325 = v1311;
                                do
                                {
                                  float v1312 = v1324 + v1312;
                                  float v1324 = v1323 * v1324;
                                  --v1325;
                                }
                                while (v1325);
                              }
                              uint64_t v1326 = *(void *)(*(void *)&v1258 + 16);
                              float v1327 = 1.0 / v1312;
                              float32x4_t v1265 = vmulq_n_f32(*(float32x4_t *)(*(void *)(v1326 + (((v1310 - 1) >> 5) & 0x7FFFFFFFFFFFFF8))+ 16 * (v1310 - 1)), 1.0 / v1312);
                              if ((int)v1311 > 1)
                              {
                                uint64_t v1328 = v1311 - 1;
                                do
                                {
                                  float v1327 = v1323 * v1327;
                                  float32x4_t v1265 = vaddq_f32(vmulq_n_f32(*(float32x4_t *)(*(void *)(v1326 + ((v1310 >> 5) & 0x7FFFFFFFFFFFFF8))+ 16 * v1310), v1327), v1265);
                                  ++v1310;
                                  --v1328;
                                }
                                while (v1328);
                              }
                              int v1329 = **(_DWORD **)&v1258;
                              if (**(_DWORD **)&v1258 <= (int)v1311)
                              {
                                uint64_t v1334 = *(void *)(*(void *)&v1258 + 24);
                                *(float32x4_t *)v1917 = v1265;
                                do
                                {
                                  uint64_t v1335 = *(void *)(*(void *)&v1258 + 16);
                                  uint64_t v1336 = 32 * (v1334 - v1335) - 1;
                                  uint64_t v1337 = *(void *)(*(void *)&v1258 + 40);
                                  if (v1334 == v1335) {
                                    uint64_t v1336 = 0;
                                  }
                                  uint64_t v1338 = v1311 - 1;
                                  *(void *)(*(void *)&v1258 + 48) = v1311 - 1;
                                  if ((unint64_t)(v1336 - (v1311 + v1337) + 1) >= 0x200)
                                  {
                                    operator delete(*(void **)(v1334 - 8));
                                    float32x4_t v1265 = *(float32x4_t *)v1917;
                                    uint64_t v1334 = *(void *)(*(void *)&v1258 + 24) - 8;
                                    *(void *)(*(void *)&v1258 + 24) = v1334;
                                    uint64_t v1338 = *(void *)(*(void *)&v1258 + 48);
                                    int v1329 = **(_DWORD **)&v1258;
                                  }
                                  uint64_t v1311 = v1338;
                                }
                                while (v1329 <= (int)v1338);
                              }
LABEL_1472:
                              if (*(int *)(*(void *)&v1258 + 56) < 2) {
                                goto LABEL_1559;
                              }
                              unint64_t v1330 = *(void *)(*(void *)&v1258 + 96);
                              *(float32x4_t *)v1916 = v1265;
                              if (v1330) {
                                goto LABEL_1531;
                              }
                              v1332 = *(char **)(*(void *)&v1258 + 72);
                              v1331 = *(char **)(*(void *)&v1258 + 80);
                              uint64_t v1333 = ((v1331 - v1332) << 7) - 1;
                              if (v1331 == v1332) {
                                uint64_t v1333 = 0;
                              }
                              if ((unint64_t)(v1333 - *(void *)(*(void *)&v1258 + 104)) >= 0x400)
                              {
                                *(void *)(*(void *)&v1258 + 96) = 1024;
                                *(void *)v2013 = *((void *)v1331 - 1);
                                *(void *)(*(void *)&v1258 + 80) = v1331 - 8;
                                sub_1D0E3EA48((void **)(*(void *)&v1258 + 64), v2013);
                                goto LABEL_1530;
                              }
                              v1339 = *(char **)(*(void *)&v1258 + 88);
                              v1340 = *(char **)(*(void *)&v1258 + 64);
                              if (v1331 - v1332 < (unint64_t)(v1339 - v1340))
                              {
                                if (v1332 == v1340)
                                {
                                  *(void *)v2013 = operator new(0x1000uLL);
                                  sub_1D0E3EBF0((char **)(*(void *)&v1258 + 64), v2013);
                                  uint64_t v1345 = *(void *)(*(void *)&v1258 + 80);
                                  *(void *)v2013 = *(void *)(v1345 - 8);
                                  *(void *)(*(void *)&v1258 + 80) = v1345 - 8;
                                }
                                else
                                {
                                  *(void *)v2013 = operator new(0x1000uLL);
                                }
                                sub_1D0E3EA48((void **)(*(void *)&v1258 + 64), v2013);
                                if (*(void *)(*(void *)&v1258 + 80) - *(void *)(*(void *)&v1258 + 72) == 8) {
                                  *(void *)(*(void *)&v1258 + 96) = 512;
                                }
                                else {
                                  *(void *)(*(void *)&v1258 + 96) += 1024;
                                }
                                goto LABEL_1530;
                              }
                              if (v1339 == v1340) {
                                unint64_t v1341 = 1;
                              }
                              else {
                                unint64_t v1341 = (v1339 - v1340) >> 2;
                              }
                              if (!(v1341 >> 61))
                              {
                                v1342 = (char *)operator new(8 * v1341);
                                v1343 = operator new(0x1000uLL);
                                if (v1341)
                                {
                                  v1344 = &v1342[8 * v1341];
                                }
                                else
                                {
                                  v1346 = (char *)operator new(8uLL);
                                  v1344 = v1346 + 8;
                                  operator delete(v1342);
                                  v1332 = *(char **)(*(void *)&v1258 + 72);
                                  v1331 = *(char **)(*(void *)&v1258 + 80);
                                  v1342 = v1346;
                                }
                                *(void *)v1342 = v1343;
                                v1347 = v1342 + 8;
                                v1348 = v1342;
                                if (v1332 == v1331)
                                {
LABEL_1499:
                                  v1349 = *(void **)(*(void *)&v1258 + 64);
                                  *(void *)(*(void *)&v1258 + 64) = v1342;
                                  *(void *)(*(void *)&v1258 + 72) = v1348;
                                  *(void *)(*(void *)&v1258 + 80) = v1347;
                                  *(void *)(*(void *)&v1258 + 88) = v1344;
                                  if (v1347 - v1348 == 8) {
                                    uint64_t v1350 = 512;
                                  }
                                  else {
                                    uint64_t v1350 = *(void *)(*(void *)&v1258 + 96) + 1024;
                                  }
                                  uint64_t v1218 = v1869;
                                  *(void *)(*(void *)&v1258 + 96) = v1350;
                                  if (v1349) {
                                    operator delete(v1349);
                                  }
LABEL_1530:
                                  unint64_t v1330 = *(void *)(*(void *)&v1258 + 96);
LABEL_1531:
                                  uint64_t v1376 = *(void *)(*(void *)&v1258 + 72);
                                  uint64_t v1375 = *(void *)(*(void *)&v1258 + 80);
                                  v1377 = (void *)(v1376 + 8 * (v1330 >> 10));
                                  uint64_t v1378 = *v1377 + 4 * (v1330 & 0x3FF);
                                  if (v1375 == v1376) {
                                    uint64_t v1378 = 0;
                                  }
                                  if (v1378 == *v1377) {
                                    uint64_t v1378 = *(v1377 - 1) + 4096;
                                  }
                                  *(float *)(v1378 - 4) = v1261;
                                  unint64_t v1379 = v1330 - 1;
                                  uint64_t v1380 = *(void *)(*(void *)&v1258 + 104);
                                  uint64_t v1381 = v1380 + 1;
                                  *(void *)(*(void *)&v1258 + 96) = v1330 - 1;
                                  *(void *)(*(void *)&v1258 + 104) = v1380 + 1;
                                  if ((int)v1380 + 1 < 1)
                                  {
                                    float v1384 = 0.0;
                                  }
                                  else
                                  {
                                    float v1382 = *(float *)(*(void *)&v1258 + 112);
                                    uint64_t v1383 = (v1380 + 1);
                                    float v1384 = 0.0;
                                    unint64_t v1385 = v1330 - 1;
                                    do
                                    {
                                      float v1386 = fmodf(*(float *)(*(void *)(v1376 + ((v1385 >> 7) & 0x1FFFFFFFFFFFFF8))+ 4 * (v1385 & 0x3FF))- v1261, v1382);
                                      if (v1386 > (float)(v1382 * v930))
                                      {
                                        float v1386 = v1386 - v1382;
                                      }
                                      else if (v1386 <= (float)(v1382 * -0.5))
                                      {
                                        float v1386 = v1382 + v1386;
                                      }
                                      float v1387 = fabsf(v1386);
                                      if (v1384 < v1387) {
                                        float v1384 = v1387;
                                      }
                                      ++v1385;
                                      --v1383;
                                    }
                                    while (v1383);
                                  }
                                  float v1388 = expf(-fminf(v1384 * *(float *)(*(void *)&v1258 + 60), 10.0));
                                  unint64_t v1389 = v1379 >> 7;
                                  if ((int)v1381 < 1)
                                  {
                                    float v1261 = *(float *)(*(void *)(v1376 + (v1389 & 0x1FFFFFFFFFFFFF8))
                                                     + 4 * (v1379 & 0x3FF));
                                    v1241 = v1884;
                                  }
                                  else
                                  {
                                    float v1390 = v1388;
                                    float v1391 = 0.0;
                                    float v1392 = 1.0;
                                    int v1393 = v1381;
                                    v1241 = v1884;
                                    do
                                    {
                                      float v1391 = v1391 + v1392;
                                      float v1392 = v1390 * v1392;
                                      --v1393;
                                    }
                                    while (v1393);
                                    float v1394 = *(float *)(*(void *)(v1376 + (v1389 & 0x1FFFFFFFFFFFFF8))
                                                     + 4 * (v1379 & 0x3FF));
                                    if ((int)v1381 < 2)
                                    {
                                      float v1261 = *(float *)(*(void *)(v1376 + (v1389 & 0x1FFFFFFFFFFFFF8))
                                                       + 4 * (v1379 & 0x3FF));
                                    }
                                    else
                                    {
                                      float v1395 = *(float *)(*(void *)&v1258 + 112);
                                      float v1396 = v1395 * v930;
                                      uint64_t v1397 = v1381 - 1;
                                      float v1261 = v1394;
                                      float v1398 = 1.0 / v1391;
                                      do
                                      {
                                        float v1399 = fmodf(*(float *)(*(void *)(v1376 + ((v1330 >> 7) & 0x1FFFFFFFFFFFFF8))+ 4 * (v1330 & 0x3FF))- v1394, v1395);
                                        if (v1399 > v1396)
                                        {
                                          float v1399 = v1399 - v1395;
                                        }
                                        else if (v1399 <= (float)(v1395 * -0.5))
                                        {
                                          float v1399 = v1395 + v1399;
                                        }
                                        float v1398 = v1390 * v1398;
                                        float v1261 = v1261 + (float)(v1398 * v1399);
                                        ++v1330;
                                        --v1397;
                                      }
                                      while (v1397);
                                    }
                                  }
                                  int v1400 = *(_DWORD *)(*(void *)&v1258 + 56);
                                  if (v1400 <= (int)v1381)
                                  {
                                    v1105 = v1874;
                                    float v930 = 0.5;
                                    float32x4_t v1265 = *(float32x4_t *)v1916;
                                    do
                                    {
                                      uint64_t v1443 = *(void *)(*(void *)&v1258 + 72);
                                      uint64_t v1444 = ((v1375 - v1443) << 7) - 1;
                                      uint64_t v1445 = *(void *)(*(void *)&v1258 + 96);
                                      if (v1375 == v1443) {
                                        uint64_t v1444 = 0;
                                      }
                                      uint64_t v1446 = v1381 - 1;
                                      *(void *)(*(void *)&v1258 + 104) = v1381 - 1;
                                      if ((unint64_t)(v1444 - (v1381 + v1445) + 1) >= 0x800)
                                      {
                                        operator delete(*(void **)(v1375 - 8));
                                        float32x4_t v1265 = *(float32x4_t *)v1916;
                                        uint64_t v1375 = *(void *)(*(void *)&v1258 + 80) - 8;
                                        *(void *)(*(void *)&v1258 + 80) = v1375;
                                        uint64_t v1446 = *(void *)(*(void *)&v1258 + 104);
                                        int v1400 = *(_DWORD *)(*(void *)&v1258 + 56);
                                      }
                                      uint64_t v1381 = v1446;
                                    }
                                    while (v1400 <= (int)v1446);
                                  }
                                  else
                                  {
                                    v1105 = v1874;
                                    float v930 = 0.5;
                                    float32x4_t v1265 = *(float32x4_t *)v1916;
                                  }
LABEL_1559:
                                  v1401 = *v1241;
                                  v1401[5].i32[0] = v1259;
                                  *(float32x4_t *)&v1401[5].i32[1] = v1265;
                                  v1401[7].f32[1] = v1261;
                                  v1401[8].i8[0] = 1;
                                  *(_OWORD *)((char *)v1401[8].f32 + 1) = *(_OWORD *)v2022[0].f32;
                                  v1401[10] = *(float32x2_t *)((char *)&v2022[1] + 7);
                                  goto LABEL_1560;
                                }
                                while (2)
                                {
                                  if (v1347 != v1344)
                                  {
                                    v1351 = v1348;
                                    v1352 = v1347;
                                    v1347 = v1344;
                                    goto LABEL_1502;
                                  }
                                  if (v1348 > v1342)
                                  {
                                    uint64_t v1354 = (v1348 - v1342) >> 3;
                                    if (v1354 >= -1) {
                                      uint64_t v1355 = v1354 + 1;
                                    }
                                    else {
                                      uint64_t v1355 = v1354 + 2;
                                    }
                                    uint64_t v1356 = v1355 >> 1;
                                    v1357 = &v1348[-8 * (v1355 >> 1)];
                                    v1358 = v1347;
                                    if (v1347 != v1348)
                                    {
                                      memmove(v1357, v1348, v1347 - v1348);
                                      v1358 = v1348;
                                    }
                                    uint64_t v1359 = -v1356;
                                    v1352 = &v1357[v1347 - v1348];
                                    v1351 = &v1358[8 * v1359];
                                    goto LABEL_1502;
                                  }
                                  unint64_t v1360 = (v1347 - v1342) >> 2;
                                  if (v1347 == v1342) {
                                    unint64_t v1360 = 1;
                                  }
                                  if (v1360 >> 61) {
                                    break;
                                  }
                                  uint64_t v1361 = v1259;
                                  unint64_t v1362 = v1360 >> 2;
                                  uint64_t keyh = 8 * v1360;
                                  v1363 = (char *)operator new(8 * v1360);
                                  v1364 = v1363;
                                  v1351 = &v1363[8 * v1362];
                                  v1352 = v1351;
                                  int64_t v1365 = v1347 - v1348;
                                  if (v1347 != v1348)
                                  {
                                    v1352 = &v1351[v1365 & 0xFFFFFFFFFFFFFFF8];
                                    unint64_t v1366 = v1365 - 8;
                                    if (v1366 >= 0x38)
                                    {
                                      if ((unint64_t)(&v1363[8 * v1362] - v1348) < 0x20)
                                      {
                                        v1367 = &v1363[8 * v1362];
                                        goto LABEL_1523;
                                      }
                                      uint64_t v1368 = (v1366 >> 3) + 1;
                                      uint64_t v1369 = 8 * (v1368 & 0x3FFFFFFFFFFFFFFCLL);
                                      v1367 = &v1351[v1369];
                                      v1370 = (long long *)(v1348 + 16);
                                      v1371 = &v1363[8 * v1362 + 16];
                                      uint64_t v1372 = v1368 & 0x3FFFFFFFFFFFFFFCLL;
                                      do
                                      {
                                        long long v1373 = *v1370;
                                        *((_OWORD *)v1371 - 1) = *(v1370 - 1);
                                        *(_OWORD *)v1371 = v1373;
                                        v1370 += 2;
                                        v1371 += 32;
                                        v1372 -= 4;
                                      }
                                      while (v1372);
                                      if (v1368 != (v1368 & 0x3FFFFFFFFFFFFFFCLL))
                                      {
                                        v1348 += v1369;
                                        goto LABEL_1523;
                                      }
                                    }
                                    else
                                    {
                                      v1367 = &v1363[8 * v1362];
                                      do
                                      {
LABEL_1523:
                                        uint64_t v1374 = *(void *)v1348;
                                        v1348 += 8;
                                        *(void *)v1367 = v1374;
                                        v1367 += 8;
                                      }
                                      while (v1367 != v1352);
                                    }
                                  }
                                  v1347 = &v1363[keyh];
                                  if (v1342) {
                                    operator delete(v1342);
                                  }
                                  v1342 = v1364;
                                  uint64_t v1259 = v1361;
LABEL_1502:
                                  uint64_t v1353 = *(void *)v1332;
                                  v1332 += 8;
                                  *(void *)v1352 = v1353;
                                  v1348 = v1351;
                                  v1344 = v1347;
                                  v1347 = v1352 + 8;
                                  if (v1332 == *(char **)(*(void *)&v1258 + 80)) {
                                    goto LABEL_1499;
                                  }
                                  continue;
                                }
                              }
LABEL_2232:
                              sub_1D0DE8CE0();
                            }
                            while (2)
                            {
                              if (v1278 != v1275)
                              {
                                v1282 = v1279;
                                v1283 = v1278;
                                v1278 = v1275;
                                goto LABEL_1427;
                              }
                              if (v1279 > v1273)
                              {
                                uint64_t v1285 = (v1279 - v1273) >> 3;
                                if (v1285 >= -1) {
                                  uint64_t v1286 = v1285 + 1;
                                }
                                else {
                                  uint64_t v1286 = v1285 + 2;
                                }
                                uint64_t v1287 = v1286 >> 1;
                                v1288 = &v1279[-8 * (v1286 >> 1)];
                                v1289 = v1278;
                                if (v1278 != v1279)
                                {
                                  memmove(v1288, v1279, v1278 - v1279);
                                  float32x4_t v1265 = *(float32x4_t *)v1915;
                                  v1289 = v1279;
                                }
                                uint64_t v1290 = -v1287;
                                v1283 = &v1288[v1278 - v1279];
                                v1282 = &v1289[8 * v1290];
                                goto LABEL_1427;
                              }
                              unint64_t v1291 = (v1278 - v1273) >> 2;
                              if (v1278 == v1273) {
                                unint64_t v1291 = 1;
                              }
                              if (v1291 >> 61) {
                                goto LABEL_2232;
                              }
                              uint64_t v1292 = v1259;
                              unint64_t v1293 = v1291 >> 2;
                              uint64_t keyg = 8 * v1291;
                              v1294 = (char *)operator new(8 * v1291);
                              v1295 = v1294;
                              v1282 = &v1294[8 * v1293];
                              v1283 = v1282;
                              int64_t v1296 = v1278 - v1279;
                              if (v1278 != v1279)
                              {
                                v1283 = &v1282[v1296 & 0xFFFFFFFFFFFFFFF8];
                                unint64_t v1297 = v1296 - 8;
                                if (v1297 >= 0x38)
                                {
                                  if ((unint64_t)(&v1294[8 * v1293] - v1279) < 0x20)
                                  {
                                    v1298 = &v1294[8 * v1293];
                                    goto LABEL_1448;
                                  }
                                  uint64_t v1299 = (v1297 >> 3) + 1;
                                  uint64_t v1300 = 8 * (v1299 & 0x3FFFFFFFFFFFFFFCLL);
                                  v1298 = &v1282[v1300];
                                  v1301 = (long long *)(v1279 + 16);
                                  v1302 = &v1294[8 * v1293 + 16];
                                  uint64_t v1303 = v1299 & 0x3FFFFFFFFFFFFFFCLL;
                                  do
                                  {
                                    long long v1304 = *v1301;
                                    *((_OWORD *)v1302 - 1) = *(v1301 - 1);
                                    *(_OWORD *)v1302 = v1304;
                                    v1301 += 2;
                                    v1302 += 32;
                                    v1303 -= 4;
                                  }
                                  while (v1303);
                                  if (v1299 != (v1299 & 0x3FFFFFFFFFFFFFFCLL))
                                  {
                                    v1279 += v1300;
                                    goto LABEL_1448;
                                  }
                                }
                                else
                                {
                                  v1298 = &v1294[8 * v1293];
                                  do
                                  {
LABEL_1448:
                                    uint64_t v1305 = *(void *)v1279;
                                    v1279 += 8;
                                    *(void *)v1298 = v1305;
                                    v1298 += 8;
                                  }
                                  while (v1298 != v1283);
                                }
                              }
                              v1278 = &v1294[keyg];
                              if (v1273) {
                                operator delete(v1273);
                              }
                              v1273 = v1295;
                              uint64_t v1259 = v1292;
                              float32x4_t v1265 = *(float32x4_t *)v1915;
LABEL_1427:
                              uint64_t v1284 = *(void *)v1268;
                              v1268 += 8;
                              *(void *)v1283 = v1284;
                              v1279 = v1282;
                              v1275 = v1278;
                              v1278 = v1283 + 8;
                              if (v1268 == *(char **)(*(void *)&v1258 + 24)) {
                                goto LABEL_1424;
                              }
                              continue;
                            }
                          }
                          while (2)
                          {
                            uint64_t v1221 = *(void *)(*(void *)&v1216[12]
                                              + (((v1217 + *(void *)&v1216[15] - 1) >> 4) & 0xFFFFFFFFFFFFFF8))
                                  + 32 * ((v1217 + *(void *)&v1216[15] - 1) & 0x7F);
                            v1222 = *(std::__shared_weak_count **)(v1221 + 24);
                            if (v1222 && !atomic_fetch_add(&v1222->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v1222->__on_zero_shared)(v1222);
                              std::__shared_weak_count::__release_weak(v1222);
                              v1223 = *(std::__shared_weak_count **)(v1221 + 8);
                              if (v1223) {
                                goto LABEL_1381;
                              }
                            }
                            else
                            {
                              v1223 = *(std::__shared_weak_count **)(v1221 + 8);
                              if (v1223)
                              {
LABEL_1381:
                                if (!atomic_fetch_add(&v1223->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                {
                                  ((void (*)(std::__shared_weak_count *))v1223->__on_zero_shared)(v1223);
                                  std::__shared_weak_count::__release_weak(v1223);
                                }
                              }
                            }
                            float32x2_t v1225 = v1216[12];
                            float32x2_t v1224 = v1216[13];
                            uint64_t v1226 = *(void *)&v1224 - *(void *)&v1225;
                            _ZF = *(void *)&v1224 == *(void *)&v1225;
                            float32x2_t v1228 = v1216[15];
                            float32x2_t v1227 = v1216[16];
                            v1216[16] = (float32x2_t)(*(void *)&v1227 - 1);
                            uint64_t v1229 = 16 * v1226 - 1;
                            if (_ZF) {
                              uint64_t v1229 = 0;
                            }
                            if ((unint64_t)(v1229 - (*(void *)&v1227 + *(void *)&v1228) + 1) >= 0x100)
                            {
                              operator delete(*(void **)(*(void *)&v1224 - 8));
                              *(void *)&v1216[13] -= 8;
                            }
                            v1216 = *v931;
                            unint64_t v1217 = (unint64_t)(*v931)[16];
                            if (v1217 <= 5) {
                              goto LABEL_1367;
                            }
                            continue;
                          }
                        }
                        v1835 = v1111;
                        uint64_t v1176 = v1169 - (void)v1112;
                        _ZF = v1176 == 0;
                        unint64_t v1177 = v1176 >> 2;
                        if (_ZF) {
                          unint64_t v1177 = 1;
                        }
                        if (v1177 >> 61) {
                          goto LABEL_2232;
                        }
                        unint64_t v1178 = (v1177 + 3) >> 2;
                        uint64_t v1179 = 8 * v1177;
                        v1180 = (char *)operator new(8 * v1177);
                        v1113 = &v1180[8 * v1178];
                        v1181 = &v1180[v1179];
                        v1182 = v1113;
                        uint64_t v1183 = v1170 - v1112;
                        _ZF = v1170 == v1112;
                        v1102 = v1101 + 1;
                        if (!_ZF)
                        {
                          v1182 = &v1113[v1183 & 0xFFFFFFFFFFFFFFF8];
                          unint64_t v1184 = v1183 - 8;
                          v1185 = &v1180[8 * v1178];
                          v1186 = v1112;
                          if (v1184 > 0x37)
                          {
                            v1185 = &v1180[8 * v1178];
                            v1186 = v1112;
                            if ((unint64_t)(v1185 - v1112) >= 0x20)
                            {
                              uint64_t v1187 = (v1184 >> 3) + 1;
                              uint64_t v1188 = 8 * (v1187 & 0x3FFFFFFFFFFFFFFCLL);
                              v1185 = &v1113[v1188];
                              v1189 = (long long *)(v1112 + 16);
                              v1190 = &v1180[8 * v1178 + 16];
                              uint64_t v1191 = v1187 & 0x3FFFFFFFFFFFFFFCLL;
                              do
                              {
                                long long v1192 = *v1189;
                                *((_OWORD *)v1190 - 1) = *(v1189 - 1);
                                *(_OWORD *)v1190 = v1192;
                                v1189 += 2;
                                v1190 += 32;
                                v1191 -= 4;
                              }
                              while (v1191);
                              if (v1187 == (v1187 & 0x3FFFFFFFFFFFFFFCLL))
                              {
                                v1103[11] = (float32x2_t)v1180;
                                v1103[12] = (float32x2_t)v1113;
                                v1103[13] = (float32x2_t)v1182;
                                v1103[14] = (float32x2_t)v1181;
                                v1105 = v1874;
LABEL_1355:
                                operator delete(v1112);
                                v1111 = v1835;
                                v1113 = (char *)v1103[12];
                                goto LABEL_1356;
                              }
                              v1186 = &v1112[v1188];
                            }
                          }
                          do
                          {
                            uint64_t v1211 = *(void *)v1186;
                            v1186 += 8;
                            *(void *)v1185 = v1211;
                            v1185 += 8;
                          }
                          while (v1185 != v1182);
                        }
                        v1103[11] = (float32x2_t)v1180;
                        v1103[12] = (float32x2_t)v1113;
                        v1103[13] = (float32x2_t)v1182;
                        v1103[14] = (float32x2_t)v1181;
                        v1105 = v1874;
                        v1111 = v1835;
                        if (!v1112) {
                          goto LABEL_1356;
                        }
                        goto LABEL_1355;
                      }
                      v1132 = (char *)v1103[13];
                      if (v1132 != (char *)v1103[14])
                      {
LABEL_1351:
                        *(void *)v1132 = v1111;
                        v1209 = (void *)v1103[13];
                        v1103[13] = (float32x2_t)(v1209 + 1);
                        *(void *)v2006 = *v1209;
                        v1103[13] = (float32x2_t)v1209;
                        sub_1D0E3EA48((void **)&v1103[11], v2006);
                        uint64_t v1210 = (uint64_t)v1103[12];
                        v1102 = v1101 + 1;
                        goto LABEL_1357;
                      }
                      v1133 = (char *)v1103[11];
                      v1134 = (char *)v1103[12];
                      if (v1134 > v1133)
                      {
                        uint64_t v1135 = (v1134 - v1133) >> 3;
                        if (v1135 >= -1) {
                          uint64_t v1136 = v1135 + 1;
                        }
                        else {
                          uint64_t v1136 = v1135 + 2;
                        }
                        uint64_t v1137 = v1136 >> 1;
                        v1138 = &v1134[-8 * (v1136 >> 1)];
                        size_t v1139 = v1132 - v1134;
                        if (v1132 != v1134)
                        {
                          v1140 = v1111;
                          memmove(&v1134[-8 * (v1136 >> 1)], *(const void **)&v1103[12], v1139);
                          v1111 = v1140;
                          v1132 = (char *)v1103[12];
                        }
                        v1141 = &v1132[-8 * v1137];
                        v1132 = &v1138[v1139];
                        v1103[12] = (float32x2_t)v1141;
                        v1103[13] = (float32x2_t)&v1138[v1139];
                        v1105 = v1874;
                        goto LABEL_1351;
                      }
                      v1836 = v1111;
                      v1831 = (void *)v1103[11];
                      unint64_t v1194 = (v1132 - v1133) >> 2;
                      if (v1132 == v1133) {
                        unint64_t v1194 = 1;
                      }
                      if (v1194 >> 61) {
                        goto LABEL_2232;
                      }
                      unint64_t v1195 = v1194 >> 2;
                      uint64_t v1196 = 8 * v1194;
                      v1197 = (char *)operator new(8 * v1194);
                      v1198 = &v1197[8 * v1195];
                      int64_t v1199 = v1132 - v1134;
                      _ZF = v1132 == v1134;
                      v1132 = v1198;
                      if (!_ZF)
                      {
                        v1132 = &v1198[v1199 & 0xFFFFFFFFFFFFFFF8];
                        unint64_t v1200 = v1199 - 8;
                        if ((unint64_t)(v1199 - 8) >= 0x38)
                        {
                          v1201 = &v1197[8 * v1195];
                          if ((unint64_t)(v1201 - v1134) < 0x20) {
                            goto LABEL_1348;
                          }
                          uint64_t v1202 = (v1200 >> 3) + 1;
                          uint64_t v1203 = 8 * (v1202 & 0x3FFFFFFFFFFFFFFCLL);
                          v1201 = &v1198[v1203];
                          v1204 = (long long *)(v1134 + 16);
                          v1205 = &v1197[8 * v1195 + 16];
                          uint64_t v1206 = v1202 & 0x3FFFFFFFFFFFFFFCLL;
                          do
                          {
                            long long v1207 = *v1204;
                            *((_OWORD *)v1205 - 1) = *(v1204 - 1);
                            *(_OWORD *)v1205 = v1207;
                            v1204 += 2;
                            v1205 += 32;
                            v1206 -= 4;
                          }
                          while (v1206);
                          if (v1202 != (v1202 & 0x3FFFFFFFFFFFFFFCLL))
                          {
                            v1134 += v1203;
                            goto LABEL_1348;
                          }
                        }
                        else
                        {
                          v1201 = &v1197[8 * v1195];
                          do
                          {
LABEL_1348:
                            uint64_t v1208 = *(void *)v1134;
                            v1134 += 8;
                            *(void *)v1201 = v1208;
                            v1201 += 8;
                          }
                          while (v1201 != v1132);
                        }
                      }
                      v1103[11] = (float32x2_t)v1197;
                      v1103[12] = (float32x2_t)v1198;
                      v1103[13] = (float32x2_t)v1132;
                      v1103[14] = (float32x2_t)&v1197[v1196];
                      v1105 = v1874;
                      v1111 = v1836;
                      if (v1831)
                      {
                        operator delete(v1831);
                        v1111 = v1836;
                        v1132 = (char *)v1103[13];
                      }
                      goto LABEL_1351;
                    }
                    if (v1109 == v1110) {
                      unint64_t v1114 = 1;
                    }
                    else {
                      unint64_t v1114 = (v1109 - v1110) >> 2;
                    }
                    if (v1114 >> 61) {
                      goto LABEL_2232;
                    }
                    v1115 = (char *)operator new(8 * v1114);
                    v1116 = operator new(0x1000uLL);
                    if (v1114)
                    {
                      v1117 = &v1115[8 * v1114];
                    }
                    else
                    {
                      v1142 = (char *)operator new(8uLL);
                      v1117 = v1142 + 8;
                      operator delete(v1115);
                      v1106 = (char *)v1103[12];
                      v1107 = (char *)v1103[13];
                      v1115 = v1142;
                    }
                    *(void *)v1115 = v1116;
                    v1143 = v1115 + 8;
                    v1144 = v1115;
                    if (v1106 == v1107)
                    {
LABEL_1284:
                      v1145 = (void *)v1103[11];
                      v1103[11] = (float32x2_t)v1115;
                      v1103[12] = (float32x2_t)v1144;
                      v1103[13] = (float32x2_t)v1143;
                      v1103[14] = (float32x2_t)v1117;
                      if (v1143 - v1144 == 8) {
                        uint64_t v1146 = 64;
                      }
                      else {
                        uint64_t v1146 = *(void *)&v1103[15] + 128;
                      }
                      v1105 = v1874;
                      v1102 = v1101 + 1;
                      v1103[15] = (float32x2_t)v1146;
                      if (v1145) {
                        operator delete(v1145);
                      }
                      goto LABEL_1361;
                    }
                    while (2)
                    {
                      if (v1143 != v1117)
                      {
                        v1147 = v1144;
                        v1148 = v1143;
                        v1143 = v1117;
                        goto LABEL_1287;
                      }
                      if (v1144 > v1115)
                      {
                        uint64_t v1150 = (v1144 - v1115) >> 3;
                        if (v1150 >= -1) {
                          uint64_t v1151 = v1150 + 1;
                        }
                        else {
                          uint64_t v1151 = v1150 + 2;
                        }
                        uint64_t v1152 = v1151 >> 1;
                        v1153 = &v1144[-8 * (v1151 >> 1)];
                        v1154 = v1143;
                        if (v1143 != v1144)
                        {
                          memmove(v1153, v1144, v1143 - v1144);
                          v1154 = v1144;
                        }
                        v1148 = &v1153[v1143 - v1144];
                        v1147 = &v1154[-8 * v1152];
                        goto LABEL_1287;
                      }
                      unint64_t v1155 = (v1143 - v1115) >> 2;
                      if (v1143 == v1115) {
                        unint64_t v1155 = 1;
                      }
                      if (v1155 >> 61) {
                        goto LABEL_2232;
                      }
                      unint64_t v1156 = v1155 >> 2;
                      uint64_t v1834 = 8 * v1155;
                      v1157 = (char *)operator new(8 * v1155);
                      v1158 = v1157;
                      v1147 = &v1157[8 * v1156];
                      v1148 = v1147;
                      int64_t v1159 = v1143 - v1144;
                      if (v1143 != v1144)
                      {
                        v1148 = &v1147[v1159 & 0xFFFFFFFFFFFFFFF8];
                        unint64_t v1160 = v1159 - 8;
                        if (v1160 >= 0x38)
                        {
                          if ((unint64_t)(&v1157[8 * v1156] - v1144) < 0x20)
                          {
                            v1161 = &v1157[8 * v1156];
                            goto LABEL_1308;
                          }
                          uint64_t v1162 = (v1160 >> 3) + 1;
                          uint64_t v1163 = 8 * (v1162 & 0x3FFFFFFFFFFFFFFCLL);
                          v1161 = &v1147[v1163];
                          v1164 = (long long *)(v1144 + 16);
                          v1165 = &v1157[8 * v1156 + 16];
                          uint64_t v1166 = v1162 & 0x3FFFFFFFFFFFFFFCLL;
                          do
                          {
                            long long v1167 = *v1164;
                            *((_OWORD *)v1165 - 1) = *(v1164 - 1);
                            *(_OWORD *)v1165 = v1167;
                            v1164 += 2;
                            v1165 += 32;
                            v1166 -= 4;
                          }
                          while (v1166);
                          if (v1162 != (v1162 & 0x3FFFFFFFFFFFFFFCLL))
                          {
                            v1144 += v1163;
                            goto LABEL_1308;
                          }
                        }
                        else
                        {
                          v1161 = &v1157[8 * v1156];
                          do
                          {
LABEL_1308:
                            uint64_t v1168 = *(void *)v1144;
                            v1144 += 8;
                            *(void *)v1161 = v1168;
                            v1161 += 8;
                          }
                          while (v1161 != v1148);
                        }
                      }
                      v1143 = &v1157[v1834];
                      if (v1115) {
                        operator delete(v1115);
                      }
                      v1115 = v1158;
LABEL_1287:
                      uint64_t v1149 = *(void *)v1106;
                      v1106 += 8;
                      *(void *)v1148 = v1149;
                      v1144 = v1147;
                      v1117 = v1143;
                      v1143 = v1148 + 8;
                      v931 = v1884;
                      if (v1106 == (char *)v1103[13]) {
                        goto LABEL_1284;
                      }
                      continue;
                    }
                  }
                  while (2)
                  {
                    if (v948 != v945)
                    {
                      v952 = v949;
                      v953 = v948;
                      v948 = v945;
                      goto LABEL_1102;
                    }
                    if (v949 > v943)
                    {
                      uint64_t v955 = (v949 - v943) >> 3;
                      if (v955 >= -1) {
                        uint64_t v956 = v955 + 1;
                      }
                      else {
                        uint64_t v956 = v955 + 2;
                      }
                      uint64_t v957 = v956 >> 1;
                      v958 = &v949[-8 * (v956 >> 1)];
                      v959 = v948;
                      if (v948 != v949)
                      {
                        memmove(v958, v949, v948 - v949);
                        v959 = v949;
                      }
                      v953 = &v958[v948 - v949];
                      v952 = &v959[-8 * v957];
                      goto LABEL_1102;
                    }
                    unint64_t v960 = (v948 - v943) >> 2;
                    if (v948 == v943) {
                      unint64_t v960 = 1;
                    }
                    if (v960 >> 61) {
                      goto LABEL_2232;
                    }
                    unint64_t v961 = v960 >> 2;
                    uint64_t v1911 = 8 * v960;
                    v962 = (char *)operator new(8 * v960);
                    v963 = v962;
                    v952 = &v962[8 * v961];
                    v953 = v952;
                    int64_t v964 = v948 - v949;
                    if (v948 != v949)
                    {
                      v953 = &v952[v964 & 0xFFFFFFFFFFFFFFF8];
                      unint64_t v965 = v964 - 8;
                      if (v965 >= 0x38)
                      {
                        if ((unint64_t)(&v962[8 * v961] - v949) < 0x20)
                        {
                          v966 = &v962[8 * v961];
                          goto LABEL_1123;
                        }
                        uint64_t v967 = (v965 >> 3) + 1;
                        uint64_t v968 = 8 * (v967 & 0x3FFFFFFFFFFFFFFCLL);
                        v966 = &v952[v968];
                        v969 = (long long *)(v949 + 16);
                        v970 = &v962[8 * v961 + 16];
                        uint64_t v971 = v967 & 0x3FFFFFFFFFFFFFFCLL;
                        do
                        {
                          long long v972 = *v969;
                          *((_OWORD *)v970 - 1) = *(v969 - 1);
                          *(_OWORD *)v970 = v972;
                          v969 += 2;
                          v970 += 32;
                          v971 -= 4;
                        }
                        while (v971);
                        if (v967 != (v967 & 0x3FFFFFFFFFFFFFFCLL))
                        {
                          v949 += v968;
                          goto LABEL_1123;
                        }
                      }
                      else
                      {
                        v966 = &v962[8 * v961];
                        do
                        {
LABEL_1123:
                          uint64_t v973 = *(void *)v949;
                          v949 += 8;
                          *(void *)v966 = v973;
                          v966 += 8;
                        }
                        while (v966 != v953);
                      }
                    }
                    v948 = &v962[v1911];
                    if (v943) {
                      operator delete(v943);
                    }
                    v943 = v963;
LABEL_1102:
                    uint64_t v954 = *v937++;
                    *(void *)v953 = v954;
                    v949 = v952;
                    v945 = v948;
                    v948 = v953 + 8;
                    if (v937 == *(uint64_t **)(v934 + 152)) {
                      goto LABEL_1099;
                    }
                    continue;
                  }
                }
                float v1882 = *(float *)(v716 + 312);
                CVPixelBufferLockBaseAddress(v721, 1uLL);
                int v779 = CVPixelBufferGetWidth(v721);
                int v780 = CVPixelBufferGetHeight(v721);
                int v781 = CVPixelBufferGetBytesPerRow(v721);
                v782 = (char *)CVPixelBufferGetBaseAddress(v721);
                uint64_t v784 = keyd;
                if (!v718) {
                  goto LABEL_1022;
                }
                v785 = v782;
                uint64_t v786 = 0;
                *(float *)v783.i32 = v720 / v1882;
                float32x4_t v1865 = (float32x4_t)vdupq_lane_s32(v783, 0);
                float v787 = (float)(v779 - 1);
                float v788 = (float)(v780 - 1);
                v789 = v719;
                while (2)
                {
                  uint64_t v790 = (3 * v786);
                  __p[0] = (void *)(*(void *)(v784 + 168) + 4 * v790);
                  __p[1] = (void *)((v790 << 32) | 3);
                  *(void *)v2006 = buf;
                  *(void *)&v2006[8] = __p;
                  *(void *)&v2013[4] = 0;
                  *(_DWORD *)&v2013[12] = 0;
                  sub_1D0E4745C((float *)&v2013[4], (uint64_t)v2006);
                  memptr[0] = (void *)vadd_f32(*(float32x2_t *)&v2013[4], *(float32x2_t *)&buf[36]);
                  float v791 = *(float *)&v2013[12] + *(float *)&buf[44];
                  *(float *)&memptr[1] = *(float *)&v2013[12] + *(float *)&buf[44];
                  *(void *)v2013 = v2022;
                  *(void *)&v2013[8] = memptr;
                  *(void *)v2006 = 0;
                  *(_DWORD *)&v2006[8] = 0;
                  sub_1D0DF1DA0((float *)v2006, (float **)v2013);
                  *(float *)v793.i32 = *(float *)v2006 / *(float *)&v2006[8];
                  if ((float)(*(float *)v2006 / *(float *)&v2006[8]) < 0.0) {
                    goto LABEL_943;
                  }
                  *(float *)v792.i32 = *(float *)&v2006[4] / *(float *)&v2006[8];
                  BOOL v794 = (float)(*(float *)&v2006[4] / *(float *)&v2006[8]) >= 0.0 && *(float *)v793.i32 < v787;
                  if (!v794 || *(float *)v792.i32 >= v788) {
                    goto LABEL_943;
                  }
                  int v796 = 2 * (int)*(float *)v793.i32;
                  int v797 = (int)*(float *)v792.i32 * v781;
                  unsigned int v798 = v797 + v796;
                  v799 = (__int16 *)&v785[v797 + v796 + 2];
                  int v800 = v781 + v797;
                  v801.i16[0] = *(_WORD *)&v785[v798];
                  v801.i16[1] = *v799;
                  v801.i16[2] = *(_WORD *)&v785[v800 + v796];
                  v801.i16[3] = *(_WORD *)&v785[v800 + v796 + 2];
                  float32x4_t v802 = vcvtq_f32_u32(vmovl_u16(v801));
                  float32x4_t v803 = vmulq_n_f32((float32x4_t)vandq_s8((int8x16_t)v802, (int8x16_t)vcgeq_f32(v1865, v802)), v1882);
                  *(float *)v793.i32 = *(float *)v793.i32 - (float)(int)*(float *)v793.i32;
                  *(float *)v792.i32 = *(float *)v792.i32 - (float)(int)*(float *)v792.i32;
                  v804.f32[0] = 1.0 - *(float *)v793.i32;
                  v804.i32[1] = v793.i32[0];
                  v804.f32[2] = 1.0 - *(float *)v793.i32;
                  v804.i32[3] = v793.i32[0];
                  *(float *)v793.i32 = 1.0 - *(float *)v792.i32;
                  *(int32x2_t *)v805.f32 = vdup_lane_s32(v793, 0);
                  *(int32x2_t *)&v805.u32[2] = vdup_lane_s32(v792, 0);
                  float32x4_t v806 = (float32x4_t)vandq_s8((int8x16_t)vmulq_f32(v804, v805), (int8x16_t)vcgtzq_f32(v803));
                  float32x2_t v807 = vadd_f32(*(float32x2_t *)v806.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v806, (int8x16_t)v806, 8uLL));
                  if (vaddv_f32(v807) == 0.0)
                  {
LABEL_943:
                    v765 = v789;
                  }
                  else
                  {
                    int8x16_t v808 = (int8x16_t)vmulq_f32(v803, v806);
                    *(float32x2_t *)v808.i8 = vadd_f32(*(float32x2_t *)v808.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v808, v808, 8uLL));
                    float v809 = vdiv_f32(vadd_f32(*(float32x2_t *)v808.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v808.i8, 1)), vadd_f32(v807, (float32x2_t)vdup_lane_s32((int32x2_t)v807, 1))).f32[0]/ v791;
                    if (v789 < v1908)
                    {
                      *v789++ = v809;
                      goto LABEL_943;
                    }
                    uint64_t v810 = v789 - v719;
                    unint64_t v811 = v810 + 1;
                    if ((unint64_t)(v810 + 1) >> 62) {
                      goto LABEL_2233;
                    }
                    if (((char *)v1908 - (char *)v719) >> 1 > v811) {
                      unint64_t v811 = ((char *)v1908 - (char *)v719) >> 1;
                    }
                    unint64_t v812 = 0x3FFFFFFFFFFFFFFFLL;
                    if ((unint64_t)((char *)v1908 - (char *)v719) < 0x7FFFFFFFFFFFFFFCLL) {
                      unint64_t v812 = v811;
                    }
                    unint64_t v1909 = v812;
                    if (v812)
                    {
                      if (v812 >> 62) {
                        goto LABEL_2232;
                      }
                      v813 = operator new(4 * v812);
                    }
                    else
                    {
                      v813 = 0;
                    }
                    v814 = (float *)&v813[4 * v810];
                    float *v814 = v809;
                    v765 = v814 + 1;
                    if (v789 == v719)
                    {
                      uint64_t v784 = keyd;
                      unint64_t v817 = v1909;
                    }
                    else
                    {
                      unint64_t v815 = (char *)(v789 - 1) - (char *)v719;
                      if (v815 < 0xBC
                        || &v813[(char *)v789 - (char *)v719 - 4 - (v815 & 0xFFFFFFFFFFFFFFFCLL)] > &v813[(char *)v789 - (char *)v719 - 4]
                        || (float *)((char *)v789 - (v815 & 0xFFFFFFFFFFFFFFFCLL) - 4) > v789 - 1
                        || (unint64_t)((char *)v719 - v813) < 0x20)
                      {
                        v816 = v789;
                        uint64_t v784 = keyd;
                        unint64_t v817 = v1909;
                        goto LABEL_958;
                      }
                      uint64_t v819 = (v815 >> 2) + 1;
                      v816 = &v789[-(v819 & 0x7FFFFFFFFFFFFFF8)];
                      v820 = &v813[4 * v810 - 16];
                      v821 = v789 - 4;
                      uint64_t v822 = v819 & 0x7FFFFFFFFFFFFFF8;
                      uint64_t v784 = keyd;
                      do
                      {
                        long long v823 = *(_OWORD *)v821;
                        *(v820 - 1) = *((_OWORD *)v821 - 1);
                        _OWORD *v820 = v823;
                        v820 -= 2;
                        v821 -= 8;
                        v822 -= 8;
                      }
                      while (v822);
                      v814 -= v819 & 0x7FFFFFFFFFFFFFF8;
                      _ZF = v819 == (v819 & 0x7FFFFFFFFFFFFFF8);
                      unint64_t v817 = v1909;
                      if (!_ZF)
                      {
                        do
                        {
LABEL_958:
                          int v818 = *((_DWORD *)v816-- - 1);
                          *((_DWORD *)v814-- - 1) = v818;
                        }
                        while (v816 != v719);
                      }
                    }
                    v1908 = (float *)&v813[4 * v817];
                    if (v719) {
                      operator delete(v719);
                    }
                    v719 = v814;
                  }
                  ++v786;
                  v789 = v765;
                  if (v786 == v718) {
                    goto LABEL_1023;
                  }
                  continue;
                }
              }
              break;
            }
            int v824 = *(_DWORD *)(v716 + 324);
            if (v824 != 1)
            {
              if (v824 != 2) {
                goto LABEL_2234;
              }
              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&qword_1EB9F1610))
              {
                qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                __cxa_guard_release(&qword_1EB9F1610);
              }
              uint64_t v825 = qword_1EB9F1620;
              if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)v2013 = 67109120;
                *(_DWORD *)&v2013[4] = v723;
                v826 = v825;
                v827 = "unknown depth buffer format (%u) for normalized disparity";
                goto LABEL_2027;
              }
LABEL_1335:
              if (v719) {
                goto LABEL_1336;
              }
              goto LABEL_2028;
            }
            if (v722 != 1717855600 && v722 != 1278226534)
            {
              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&qword_1EB9F1610))
              {
                qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                __cxa_guard_release(&qword_1EB9F1610);
              }
              uint64_t v1193 = qword_1EB9F1620;
              if (!os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR)) {
                goto LABEL_1335;
              }
              *(_DWORD *)v2013 = 67109120;
              *(_DWORD *)&v2013[4] = v723;
              v826 = v1193;
              v827 = "unknown depth buffer format (%u)";
LABEL_2027:
              _os_log_error_impl(&dword_1D0DBD000, v826, OS_LOG_TYPE_ERROR, v827, v2013, 8u);
              if (v719)
              {
LABEL_1336:
                operator delete(v719);
                v765 = 0;
                v719 = 0;
                goto LABEL_1024;
              }
LABEL_2028:
              v765 = 0;
              goto LABEL_1024;
            }
            float v1883 = *(float *)(v716 + 312);
            CVPixelBufferLockBaseAddress(v721, 1uLL);
            int v828 = CVPixelBufferGetWidth(v721);
            int v829 = CVPixelBufferGetHeight(v721);
            int v830 = CVPixelBufferGetBytesPerRow(v721);
            pixelBuffer = v721;
            v831 = (char *)CVPixelBufferGetBaseAddress(v721);
            if (!v718) {
              goto LABEL_1022;
            }
            v833 = v831;
            uint64_t v834 = 0;
            *(float *)v832.i32 = v720 / v1883;
            float32x4_t v1866 = (float32x4_t)vdupq_lane_s32(v832, 0);
            float v835 = (float)(v828 - 1);
            float v836 = (float)(v829 - 1);
            v837 = v719;
            uint64_t v838 = keyd;
            while (2)
            {
              uint64_t v839 = (3 * v834);
              __p[0] = (void *)(*(void *)(v838 + 168) + 4 * v839);
              __p[1] = (void *)((v839 << 32) | 3);
              *(void *)v2006 = buf;
              *(void *)&v2006[8] = __p;
              *(void *)&v2013[4] = 0;
              *(_DWORD *)&v2013[12] = 0;
              sub_1D0E4745C((float *)&v2013[4], (uint64_t)v2006);
              memptr[0] = (void *)vadd_f32(*(float32x2_t *)&v2013[4], *(float32x2_t *)&buf[36]);
              float v840 = *(float *)&v2013[12] + *(float *)&buf[44];
              *(float *)&memptr[1] = *(float *)&v2013[12] + *(float *)&buf[44];
              *(void *)v2013 = v2022;
              *(void *)&v2013[8] = memptr;
              *(void *)v2006 = 0;
              *(_DWORD *)&v2006[8] = 0;
              sub_1D0DF1DA0((float *)v2006, (float **)v2013);
              *(float *)v842.i32 = *(float *)v2006 / *(float *)&v2006[8];
              if ((float)(*(float *)v2006 / *(float *)&v2006[8]) < 0.0) {
                goto LABEL_993;
              }
              *(float *)v841.i32 = *(float *)&v2006[4] / *(float *)&v2006[8];
              BOOL v843 = (float)(*(float *)&v2006[4] / *(float *)&v2006[8]) >= 0.0 && *(float *)v842.i32 < v835;
              if (!v843 || *(float *)v841.i32 >= v836) {
                goto LABEL_993;
              }
              int v845 = 4 * (int)*(float *)v842.i32;
              int v846 = (int)*(float *)v841.i32 * v830;
              unsigned int v847 = v846 + v845;
              v848 = (__int32 *)&v833[v846 + v845 + 4];
              int v849 = v830 + v846;
              v850.i32[0] = *(_DWORD *)&v833[v847];
              v850.i32[1] = *v848;
              v850.i32[2] = *(_DWORD *)&v833[v849 + v845];
              v850.i32[3] = *(_DWORD *)&v833[v849 + v845 + 4];
              float32x4_t v851 = vmulq_n_f32((float32x4_t)vandq_s8(v850, (int8x16_t)vcgeq_f32(v1866, (float32x4_t)v850)), v1883);
              *(float *)v842.i32 = *(float *)v842.i32 - (float)(int)*(float *)v842.i32;
              *(float *)v841.i32 = *(float *)v841.i32 - (float)(int)*(float *)v841.i32;
              v852.f32[0] = 1.0 - *(float *)v842.i32;
              v852.i32[1] = v842.i32[0];
              v852.f32[2] = 1.0 - *(float *)v842.i32;
              v852.i32[3] = v842.i32[0];
              *(float *)v842.i32 = 1.0 - *(float *)v841.i32;
              *(int32x2_t *)v853.f32 = vdup_lane_s32(v842, 0);
              *(int32x2_t *)&v853.u32[2] = vdup_lane_s32(v841, 0);
              float32x4_t v854 = (float32x4_t)vandq_s8((int8x16_t)vmulq_f32(v852, v853), (int8x16_t)vcgtzq_f32(v851));
              float32x2_t v855 = vadd_f32(*(float32x2_t *)v854.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v854, (int8x16_t)v854, 8uLL));
              if (vaddv_f32(v855) == 0.0)
              {
LABEL_993:
                v765 = v837;
              }
              else
              {
                int8x16_t v856 = (int8x16_t)vmulq_f32(v851, v854);
                *(float32x2_t *)v856.i8 = vadd_f32(*(float32x2_t *)v856.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v856, v856, 8uLL));
                float v857 = vdiv_f32(vadd_f32(*(float32x2_t *)v856.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v856.i8, 1)), vadd_f32(v855, (float32x2_t)vdup_lane_s32((int32x2_t)v855, 1))).f32[0]/ v840;
                if (v837 < v1908)
                {
                  *v837++ = v857;
                  goto LABEL_993;
                }
                uint64_t v858 = v837 - v719;
                unint64_t v859 = v858 + 1;
                if ((unint64_t)(v858 + 1) >> 62) {
                  goto LABEL_2233;
                }
                if (((char *)v1908 - (char *)v719) >> 1 > v859) {
                  unint64_t v859 = ((char *)v1908 - (char *)v719) >> 1;
                }
                unint64_t v860 = 0x3FFFFFFFFFFFFFFFLL;
                if ((unint64_t)((char *)v1908 - (char *)v719) < 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v860 = v859;
                }
                unint64_t v1910 = v860;
                if (v860)
                {
                  if (v860 >> 62) {
                    goto LABEL_2232;
                  }
                  v861 = operator new(4 * v860);
                }
                else
                {
                  v861 = 0;
                }
                v862 = (float *)&v861[4 * v858];
                float *v862 = v857;
                v765 = v862 + 1;
                if (v837 == v719)
                {
                  uint64_t v838 = keyd;
                  unint64_t v865 = v1910;
                }
                else
                {
                  unint64_t v863 = (char *)(v837 - 1) - (char *)v719;
                  if (v863 < 0xBC
                    || &v861[(char *)v837 - (char *)v719 - 4 - (v863 & 0xFFFFFFFFFFFFFFFCLL)] > &v861[(char *)v837 - (char *)v719 - 4]
                    || (float *)((char *)v837 - (v863 & 0xFFFFFFFFFFFFFFFCLL) - 4) > v837 - 1
                    || (unint64_t)((char *)v719 - v861) < 0x20)
                  {
                    v864 = v837;
                    uint64_t v838 = keyd;
                    unint64_t v865 = v1910;
                    goto LABEL_1008;
                  }
                  uint64_t v867 = (v863 >> 2) + 1;
                  v864 = &v837[-(v867 & 0x7FFFFFFFFFFFFFF8)];
                  v868 = &v861[4 * v858 - 16];
                  v869 = v837 - 4;
                  uint64_t v870 = v867 & 0x7FFFFFFFFFFFFFF8;
                  uint64_t v838 = keyd;
                  do
                  {
                    long long v871 = *(_OWORD *)v869;
                    *(v868 - 1) = *((_OWORD *)v869 - 1);
                    _OWORD *v868 = v871;
                    v868 -= 2;
                    v869 -= 8;
                    v870 -= 8;
                  }
                  while (v870);
                  v862 -= v867 & 0x7FFFFFFFFFFFFFF8;
                  _ZF = v867 == (v867 & 0x7FFFFFFFFFFFFFF8);
                  unint64_t v865 = v1910;
                  if (!_ZF)
                  {
                    do
                    {
LABEL_1008:
                      int v866 = *((_DWORD *)v864-- - 1);
                      *((_DWORD *)v862-- - 1) = v866;
                    }
                    while (v864 != v719);
                  }
                }
                v1908 = (float *)&v861[4 * v865];
                if (v719) {
                  operator delete(v719);
                }
                v719 = v862;
              }
              ++v834;
              v837 = v765;
              if (v834 == v718) {
                goto LABEL_1023;
              }
              continue;
            }
          }
          if (v427 == 875704422 || v427 == 875704438) {
            goto LABEL_660;
          }
LABEL_669:
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EB9F1610))
          {
            qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
            __cxa_guard_release(&qword_1EB9F1610);
          }
          v528 = (id)qword_1EB9F1620;
          if (os_log_type_enabled(v528, OS_LOG_TYPE_ERROR))
          {
            v2022[2].i8[7] = 4;
            v2022[0].i8[0] = HIBYTE(v427);
            v2022[0].i8[1] = BYTE2(v427);
            v2022[0].i8[2] = BYTE1(v427);
            *(__int16 *)((char *)&v2022[0].i16[1] + 1) = v427;
            *(_DWORD *)v2006 = 67109378;
            *(_DWORD *)&v2006[4] = v427;
            *(_WORD *)&v2006[8] = 2080;
            *(void *)&v2006[10] = v2022;
            _os_log_error_impl(&dword_1D0DBD000, v528, OS_LOG_TYPE_ERROR, "not a valid format for processing, format 0x%x ('%s')", v2006, 0x12u);
            if (v2022[2].i8[7] < 0) {
LABEL_717:
            }
              operator delete(*(void **)v2022);
          }
        }
        else
        {
          if (v427 == 875704422 || v427 == 1278226488 || v427 == 875704438)
          {
            sub_1D0E0E998(v2022, v419);
            int v430 = *(_DWORD *)(v392 + 28);
            if (v430 >= 1)
            {
              int v431 = 0;
              float32x2_t v432 = v2022[3];
              int32x4_t v433 = vdupq_n_s32((v2022[1].i32[0] << 10) - 1025);
              int32x4_t v434 = vdupq_n_s32((v2022[1].i32[1] << 10) - 1025);
              _V3.S[1] = *(_DWORD *)&buf[28];
              _V2.S[1] = *(_DWORD *)&buf[4];
              _V4.S[1] = *(_DWORD *)&buf[16];
              int v438 = *(char **)(v392 + 40);
              _S5 = 1216348160;
              __asm { FMLA            S6, S5, V4.S[1] }
              int v441 = (int)_S6;
              __asm { FMLA            S6, S5, V2.S[1] }
              unsigned int v443 = *(_DWORD *)(v392 + 24);
              unsigned int v444 = v441 - v443 * (int)_S6;
              unsigned int v445 = (int)vmlas_n_f32(0.5, 262140.0, *(float *)buf);
              __asm { FMLA            S2, S5, V3.S[1] }
              int32x4_t v447 = vmlaq_s32(vdupq_n_s32((int)_S2), vdupq_n_s32((int)_S6), (int32x4_t)xmmword_1D0E814F0);
              int32x4_t v448 = vmlaq_s32(vdupq_n_s32((int)vmlas_n_f32(0.5, 262140.0, *(float *)&buf[24])), vdupq_n_s32(v445), (int32x4_t)xmmword_1D0E814F0);
              int32x4_t v449 = vdupq_n_s32(v2022[2].u32[1]);
              uint64_t v450 = *(void *)&v2022[3] + v2022[2].i32[1];
              int32x4_t v451 = vdupq_n_s32(4 * v445);
              int32x4_t v452 = vdupq_n_s32(4 * (int)_S6);
              int32x4_t v453 = vdupq_n_s32((int)vmlas_n_f32(0.5, 262140.0, *(float *)&buf[12]) - v443 * v445);
              int32x4_t v454 = vdupq_n_s32(v444);
              do
              {
                if (v443)
                {
                  v455 = &v438[v443];
                  v456.i64[0] = 0x8000000080;
                  v456.i64[1] = 0x8000000080;
                  v457.i64[0] = 0x300000003;
                  v457.i64[1] = 0x300000003;
                  v458.i64[0] = 0x40000000400;
                  v458.i64[1] = 0x40000000400;
                  v459.i64[0] = 0x8000000080000;
                  v459.i64[1] = 0x8000000080000;
                  do
                  {
                    int32x4_t v460 = vmaxq_s32(vminq_s32(vshrq_n_s32(vaddq_s32(v448, v456), 8uLL), v433), (int32x4_t)0);
                    int32x4_t v461 = vmaxq_s32(vminq_s32(vshrq_n_s32(vaddq_s32(v447, v456), 8uLL), v434), (int32x4_t)0);
                    int32x4_t v462 = (int32x4_t)vandq_s8((int8x16_t)v460, v457);
                    int32x4_t v463 = vshrq_n_s32(v461, 0xAuLL);
                    int32x4_t v464 = (int32x4_t)vandq_s8((int8x16_t)v461, v457);
                    int32x4_t v465 = vsraq_n_s32(vmulq_s32(v463, v449), v460, 0xAuLL);
                    uint64_t v466 = v465.i32[0];
                    unsigned int v467 = *(unsigned __int8 *)(*(void *)&v432 + v465.i32[0]);
                    uint64_t v468 = v465.i32[1];
                    unsigned int v469 = *(unsigned __int8 *)(*(void *)&v432 + v465.i32[1]);
                    v460.i8[0] = *(unsigned char *)(*(void *)&v432 + v465.i32[2]);
                    uint64_t v470 = v465.i32[0] + 1;
                    uint64_t v471 = v465.i32[1] + 1;
                    uint64_t v472 = v465.i32[2] + 1;
                    v465.i8[0] = *(unsigned char *)(*(void *)&v432 + v472);
                    v460.i8[4] = *(unsigned char *)(*(void *)&v432 + v465.i32[3]);
                    uint64_t v473 = v465.i32[3] + 1;
                    v465.i8[4] = *(unsigned char *)(*(void *)&v432 + v473);
                    v474.i64[0] = __PAIR64__(v469, v467);
                    v429.i8[0] = *(unsigned char *)(v450 + v465.i32[2]);
                    v429.i8[4] = *(unsigned char *)(v450 + v465.i32[3]);
                    *(int8x8_t *)v460.i8 = vand_s8(*(int8x8_t *)v460.i8, (int8x8_t)0xFF000000FFLL);
                    v475.i32[0] = *(unsigned __int8 *)(v450 + v466);
                    v475.i32[1] = *(unsigned __int8 *)(v450 + v468);
                    v474.i64[1] = v460.i64[0];
                    v460.i8[0] = *(unsigned char *)(v450 + v472);
                    v460.i8[4] = *(unsigned char *)(v450 + v473);
                    v475.u64[1] = (unint64_t)vand_s8(*(int8x8_t *)v429.i8, (int8x8_t)0xFF000000FFLL);
                    v429.i32[0] = *(unsigned __int8 *)(v450 + v470);
                    v429.i32[1] = *(unsigned __int8 *)(v450 + v471);
                    v429.u64[1] = (unint64_t)vand_s8(*(int8x8_t *)v460.i8, (int8x8_t)0xFF000000FFLL);
                    *(int8x8_t *)v460.i8 = vand_s8(*(int8x8_t *)v465.i8, (int8x8_t)0xFF000000FFLL);
                    v465.i32[0] = *(unsigned __int8 *)(*(void *)&v432 + v470);
                    v465.i32[1] = *(unsigned __int8 *)(*(void *)&v432 + v471);
                    v465.i64[1] = v460.i64[0];
                    int32x4_t v476 = vsubq_s32(v458, v462);
                    int16x8_t v477 = (int16x8_t)vshrq_n_u32((uint32x4_t)vaddq_s32(vmlaq_s32(vmulq_s32(vmlaq_s32(vmulq_s32(v475, v476), v429, v462), v464), vmlaq_s32(vmulq_s32(v474, v476), v465, v462), vsubq_s32(v458, v464)), v459), 0x14uLL);
                    *(int16x4_t *)v477.i8 = vmovn_s32((int32x4_t)v477);
                    *(_DWORD *)int v438 = vmovn_s16(v477).u32[0];
                    v438 += 4;
                    int32x4_t v448 = vaddq_s32(v448, v451);
                    int32x4_t v447 = vaddq_s32(v447, v452);
                  }
                  while (v438 < v455);
                  unsigned int v443 = *(_DWORD *)(v392 + 24);
                  int v430 = *(_DWORD *)(v392 + 28);
                }
                v438 += *(_DWORD *)(v392 + 36) - v443;
                int32x4_t v448 = vaddq_s32(v448, v453);
                int32x4_t v447 = vaddq_s32(v447, v454);
                ++v431;
              }
              while (v431 < v430);
            }
            goto LABEL_702;
          }
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EB9F1610))
          {
            qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
            __cxa_guard_release(&qword_1EB9F1610);
          }
          v528 = (id)qword_1EB9F1620;
          if (os_log_type_enabled(v528, OS_LOG_TYPE_ERROR))
          {
            v2022[2].i8[7] = 4;
            v2022[0].i8[0] = HIBYTE(v427);
            v2022[0].i8[1] = BYTE2(v427);
            v2022[0].i8[2] = BYTE1(v427);
            *(__int16 *)((char *)&v2022[0].i16[1] + 1) = v427;
            *(_DWORD *)v2006 = 67109378;
            *(_DWORD *)&v2006[4] = v427;
            *(_WORD *)&v2006[8] = 2080;
            *(void *)&v2006[10] = v2022;
            _os_log_error_impl(&dword_1D0DBD000, v528, OS_LOG_TYPE_ERROR, "not a valid format for processing, format 0x%x ('%s')", v2006, 0x12u);
            if (v2022[2].i8[7] < 0) {
              goto LABEL_717;
            }
          }
        }
        break;
      }

      char v529 = 0;
      goto LABEL_703;
    }
LABEL_2234:
    sub_1D0E221E0();
LABEL_2235:
    if (__cxa_guard_acquire(&qword_1EB9F1618)) {
      sub_1D0E225B4();
    }
  }
}

void sub_1D0E1E390(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1EB9F1618);
  sub_1D0DF76BC((void **)&STACK[0x650]);
  kdebug_trace();
  if (STACK[0x230]) {
    operator delete((void *)STACK[0x230]);
  }
  sub_1D0E1ED38((void **)&STACK[0x3B0]);
  sub_1D0DF76BC((void **)&STACK[0x3C8]);
  sub_1D0E1EDD4((uint64_t)&STACK[0x3E0]);
  sub_1D0DCA2C0((uint64_t)&STACK[0x4D8]);
  unint64_t v2 = (void *)STACK[0x4E8];
  if (STACK[0x4E8])
  {
    STACK[0x4F0] = (unint64_t)v2;
    operator delete(v2);
  }
  std::mutex::unlock(&stru_1EB9F15B8);
  _Unwind_Resume(a1);
}

void sub_1D0E1EB5C()
{
  unint64_t v0 = operator new(0x28uLL);
  v0[1] = 0;
  v0[2] = 0;
  *unint64_t v0 = &unk_1F26F4B80;
  cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)(v0 + 3));
  cva::ItemHandler::createValue<std::string>();
}

void sub_1D0E1EC2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1D0DCA2C0((uint64_t)&a18);
  _Unwind_Resume(a1);
}

void sub_1D0E1EC60(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

float *sub_1D0E1EC78(float *result, uint64_t a2)
{
  unint64_t v2 = result;
  uint64_t v3 = *(float **)(a2 + 8);
  if (v3 == result)
  {
    int v12 = 0;
    uint64_t v11 = 0;
    double result = (float *)sub_1D0E1EC78(&v11);
    *(void *)unint64_t v2 = v11;
    *((_DWORD *)v2 + 2) = v12;
  }
  else
  {
    BOOL v4 = **(float ***)a2;
    float v5 = v4[1];
    float v6 = v4[2];
    float v7 = v4[4];
    float v8 = v4[5];
    float v9 = v4[7];
    float v10 = v4[8];
    *double result = (float)((float)(0.0 - (float)(*v4 * *v3)) - (float)(v4[3] * v3[1])) - (float)(v4[6] * v3[2]);
    result[1] = (float)((float)(0.0 - (float)(v5 * *v3)) - (float)(v7 * v3[1])) - (float)(v9 * v3[2]);
    result[2] = (float)((float)(0.0 - (float)(v6 * *v3)) - (float)(v8 * v3[1])) - (float)(v10 * v3[2]);
  }
  return result;
}

void **sub_1D0E1ED38(void **a1)
{
  unint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    BOOL v4 = *a1;
    if (v3 != v2)
    {
      float v5 = v3 - 104;
      float v6 = v3 - 104;
      float v7 = v3 - 104;
      do
      {
        float v8 = *(void (***)(char *))v7;
        v7 -= 104;
        (*v8)(v6);
        v5 -= 104;
        BOOL v9 = v6 == v2;
        float v6 = v7;
      }
      while (!v9);
      BOOL v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_1D0E1EDD4(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      float v5 = (void *)*v2;
      float v6 = (void *)v2[6];
      if (v6)
      {
        do
        {
          float v7 = (void *)*v6;
          operator delete(v6);
          float v6 = v7;
        }
        while (v7);
      }
      float v8 = (void *)v2[4];
      v2[4] = 0;
      if (v8) {
        operator delete(v8);
      }
      operator delete(v2);
      unint64_t v2 = v5;
    }
    while (v5);
  }
  uint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

void sub_1D0E1EE5C(uint64_t a1)
{
}

void sub_1D0E1EE64(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4AD8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E1EEB8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4AD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0E1EED8(unsigned int ***a1, int8x8_t *a2, uint64_t a3)
{
  double v102 = 0;
  uint64_t v103 = 0;
  double v101 = &v102;
  float v5 = *a1;
  int v6 = *((_DWORD *)*a1 + 4);
  if (v6)
  {
    uint64_t v7 = 0;
    float v8 = *v5;
    uint64_t v9 = (uint64_t)&(*v5)[3 * v6];
    do
    {
      int8x8_t v3 = (int8x8_t)*v8;
      uint64_t v11 = v102;
      int v12 = &v102;
      uint64_t v13 = &v102;
      if (v102)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v13 = (uint64_t **)v11;
            unsigned int v14 = *((_DWORD *)v11 + 7);
            if (v3.i32[0] >= v14) {
              break;
            }
            uint64_t v11 = *v13;
            int v12 = v13;
            if (!*v13) {
              goto LABEL_13;
            }
          }
          if (v14 >= v3.i32[0]) {
            break;
          }
          uint64_t v11 = v13[1];
          if (!v11)
          {
            int v12 = v13 + 1;
            goto LABEL_13;
          }
        }
      }
      else
      {
LABEL_13:
        int v15 = operator new(0x20uLL);
        v15[7] = v3.i32[0];
        *(void *)int v15 = 0;
        *((void *)v15 + 1) = 0;
        *((void *)v15 + 2) = v13;
        *int v12 = (uint64_t *)v15;
        if (*v101)
        {
          double v101 = (uint64_t **)*v101;
          float v10 = *v12;
        }
        else
        {
          float v10 = (uint64_t *)v15;
        }
        sub_1D0DCEC98(v102, v10);
        uint64_t v7 = ++v103;
      }
      ++v8;
    }
    while (v8 != (unsigned int *)v9);
  }
  else
  {
    uint64_t v7 = 0;
  }
  *(_OWORD *)double v98 = 0u;
  *(_OWORD *)long long __p = 0u;
  float v100 = 1.0;
  float v16 = (float)(unint64_t)(int)v7;
  size_t prime = (unint64_t)v16;
  if ((unint64_t)v16 == 1)
  {
    size_t prime = 2;
LABEL_32:
    sub_1D0E1F76C((uint64_t)v98, prime);
    goto LABEL_33;
  }
  if ((prime & ((unint64_t)v16 - 1)) != 0)
  {
    size_t prime = std::__next_prime((unint64_t)v16);
    int8x8_t v3 = (int8x8_t)v98[1];
    BOOL v18 = (void *)prime >= v98[1];
    if ((void *)prime > v98[1]) {
      goto LABEL_32;
    }
  }
  else
  {
    int8x8_t v3 = 0;
    BOOL v18 = 1;
    if (prime) {
      goto LABEL_32;
    }
  }
  if (!v18)
  {
    unint64_t v19 = vcvtps_u32_f32((float)(unint64_t)__p[1] / v100);
    if (*(void *)&v3 < 3uLL || (uint8x8_t v20 = (uint8x8_t)vcnt_s8(v3), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
    {
      unint64_t v19 = std::__next_prime(v19);
    }
    else
    {
      uint64_t v21 = 1 << -(char)__clz(v19 - 1);
      if (v19 >= 2) {
        unint64_t v19 = v21;
      }
    }
    if (prime <= v19) {
      size_t prime = v19;
    }
    if (prime < *(void *)&v3) {
      goto LABEL_32;
    }
  }
LABEL_33:
  uint64_t v22 = (void *)*a2;
  a2[1] = *a2;
  if ((int)v7 > (unint64_t)((uint64_t)(*(void *)&a2[2] - (void)v22) >> 2))
  {
    if (v7 << 32 < 0) {
      goto LABEL_179;
    }
    long long v23 = (char *)operator new((4 * v7) & 0x3FFFFFFFFLL);
    *a2 = (int8x8_t)v23;
    a2[1] = (int8x8_t)v23;
    a2[2] = (int8x8_t)&v23[4 * (int)v7];
    if (v22) {
      operator delete(v22);
    }
  }
  int v24 = v101;
  if (v101 != &v102)
  {
    float32x2_t v25 = (char *)a2[1];
    while (1)
    {
      int8x8_t v26 = (int8x8_t)*((unsigned int *)v24 + 7);
      float v27 = (unsigned char *)*a2;
      unint64_t v28 = (unint64_t)v98[1];
      if (v98[1])
      {
        uint8x8_t v29 = (uint8x8_t)vcnt_s8((int8x8_t)v98[1]);
        v29.i16[0] = vaddlv_u8(v29);
        if (v29.u32[0] > 1uLL)
        {
          int8x8_t v3 = (int8x8_t)*((unsigned int *)v24 + 7);
          if (v98[1] <= (void *)*(void *)&v26) {
            int8x8_t v3 = (int8x8_t)(*(void *)&v26 % (unint64_t)v98[1]);
          }
        }
        else
        {
          int8x8_t v3 = (int8x8_t)((LODWORD(v98[1]) - 1) & v26.i32[0]);
        }
        int v30 = (_DWORD **)*((void *)v98[0] + *(void *)&v3);
        if (v30)
        {
          uint64_t v31 = *v30;
          if (*v30)
          {
            if (v29.u32[0] < 2uLL)
            {
              while (1)
              {
                unint64_t v33 = *((void *)v31 + 1);
                if (v33 == *(void *)&v26)
                {
                  if (v31[4] == v26.i32[0]) {
                    goto LABEL_60;
                  }
                }
                else if ((v33 & ((unint64_t)v98[1] - 1)) != *(void *)&v3)
                {
                  goto LABEL_61;
                }
                uint64_t v31 = *(_DWORD **)v31;
                if (!v31) {
                  goto LABEL_61;
                }
              }
            }
            do
            {
              unint64_t v32 = *((void *)v31 + 1);
              if (v32 == *(void *)&v26)
              {
                if (v31[4] == v26.i32[0])
                {
LABEL_60:
                  int8x8_t v3 = (int8x8_t)v25;
                  goto LABEL_99;
                }
              }
              else
              {
                if ((void *)v32 >= v98[1]) {
                  v32 %= (unint64_t)v98[1];
                }
                if (v32 != *(void *)&v3) {
                  break;
                }
              }
              uint64_t v31 = *(_DWORD **)v31;
            }
            while (v31);
          }
        }
      }
LABEL_61:
      uint64_t v31 = operator new(0x18uLL);
      *(void *)uint64_t v31 = 0;
      *((int8x8_t *)v31 + 1) = v26;
      v31[4] = v26.i32[0];
      void v31[5] = 0;
      float v34 = (float)((unint64_t)__p[1] + 1);
      if (!v28 || (float)(v100 * (float)v28) < v34)
      {
        BOOL v35 = (v28 & (v28 - 1)) != 0;
        if (v28 < 3) {
          BOOL v35 = 1;
        }
        unint64_t v36 = v35 | (2 * v28);
        unint64_t v37 = vcvtps_u32_f32(v34 / v100);
        if (v36 <= v37) {
          size_t v38 = v37;
        }
        else {
          size_t v38 = v36;
        }
        if (v38 == 1)
        {
          size_t v38 = 2;
        }
        else if ((v38 & (v38 - 1)) != 0)
        {
          size_t v38 = std::__next_prime(v38);
          unint64_t v28 = (unint64_t)v98[1];
        }
        if (v38 > v28) {
          goto LABEL_83;
        }
        if (v38 < v28)
        {
          unint64_t v39 = vcvtps_u32_f32((float)(unint64_t)__p[1] / v100);
          if (v28 < 3 || (uint8x8_t v40 = (uint8x8_t)vcnt_s8((int8x8_t)v28), v40.i16[0] = vaddlv_u8(v40), v40.u32[0] > 1uLL))
          {
            unint64_t v39 = std::__next_prime(v39);
          }
          else
          {
            uint64_t v41 = 1 << -(char)__clz(v39 - 1);
            if (v39 >= 2) {
              unint64_t v39 = v41;
            }
          }
          if (v38 <= v39) {
            size_t v38 = v39;
          }
          if (v38 < v28) {
LABEL_83:
          }
            sub_1D0E1F76C((uint64_t)v98, v38);
        }
        unint64_t v28 = (unint64_t)v98[1];
        if (((unint64_t)v98[1] & ((unint64_t)v98[1] - 1)) != 0)
        {
          if (v98[1] <= (void *)*(void *)&v26) {
            int8x8_t v3 = (int8x8_t)(*(void *)&v26 % (unint64_t)v98[1]);
          }
          else {
            int8x8_t v3 = v26;
          }
        }
        else
        {
          int8x8_t v3 = (int8x8_t)((LODWORD(v98[1]) - 1) & v26.i32[0]);
        }
      }
      uint64_t v42 = v98[0];
      size_t v43 = (void *)*((void *)v98[0] + *(void *)&v3);
      if (v43) {
        break;
      }
      *(void **)uint64_t v31 = __p[0];
      __p[0] = v31;
      v42[*(void *)&v3] = __p;
      if (*(void *)v31)
      {
        unint64_t v44 = *(void *)(*(void *)v31 + 8);
        if ((v28 & (v28 - 1)) != 0)
        {
          if (v44 >= v28) {
            v44 %= v28;
          }
        }
        else
        {
          v44 &= v28 - 1;
        }
        size_t v43 = (char *)v98[0] + 8 * v44;
        goto LABEL_97;
      }
LABEL_98:
      ++__p[1];
      int8x8_t v3 = a2[1];
LABEL_99:
      void v31[5] = (unint64_t)(v25 - v27) >> 2;
      int8x8_t v45 = a2[2];
      if (*(void *)&v3 >= *(void *)&v45)
      {
        uint64_t v46 = (char *)*a2;
        uint64_t v47 = *(void *)&v3 - *(void *)a2;
        uint64_t v48 = v47 >> 2;
        unint64_t v49 = (v47 >> 2) + 1;
        if (v49 >> 62) {
          goto LABEL_179;
        }
        uint64_t v50 = *(void *)&v45 - (void)v46;
        if (v50 >> 1 > v49) {
          unint64_t v49 = v50 >> 1;
        }
        if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v51 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v51 = v49;
        }
        if (v51)
        {
          if (v51 >> 62) {
            sub_1D0DE8CE0();
          }
          float v52 = (char *)operator new(4 * v51);
        }
        else
        {
          float v52 = 0;
        }
        float v53 = &v52[4 * v48];
        *(_DWORD *)float v53 = v26.i32[0];
        float32x2_t v25 = v53 + 4;
        if ((char *)v3 != v46)
        {
          unint64_t v54 = *(void *)&v3 - 4 - (void)v46;
          if (v54 < 0x2C)
          {
            float v55 = (char *)v3;
            goto LABEL_119;
          }
          if ((unint64_t)(*(void *)&v3 - (void)v52 - v47) < 0x20)
          {
            float v55 = (char *)v3;
            goto LABEL_119;
          }
          uint64_t v56 = (v54 >> 2) + 1;
          float v55 = (char *)(*(void *)&v3 - 4 * (v56 & 0x7FFFFFFFFFFFFFF8));
          uint64_t v57 = &v52[4 * v48 - 16];
          float32x4_t v58 = (long long *)(*(void *)&v3 - 16);
          uint64_t v59 = v56 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v60 = *v58;
            *((_OWORD *)v57 - 1) = *(v58 - 1);
            *(_OWORD *)uint64_t v57 = v60;
            v57 -= 32;
            v58 -= 2;
            v59 -= 8;
          }
          while (v59);
          v53 -= 4 * (v56 & 0x7FFFFFFFFFFFFFF8);
          if (v56 != (v56 & 0x7FFFFFFFFFFFFFF8))
          {
            do
            {
LABEL_119:
              int v61 = *((_DWORD *)v55 - 1);
              v55 -= 4;
              *((_DWORD *)v53 - 1) = v61;
              v53 -= 4;
            }
            while (v55 != v46);
          }
        }
        *a2 = (int8x8_t)v53;
        a2[1] = (int8x8_t)v25;
        a2[2] = (int8x8_t)&v52[4 * v51];
        if (v46) {
          operator delete(v46);
        }
        goto LABEL_122;
      }
      **(_DWORD **)&int8x8_t v3 = v26.i32[0];
      *(void *)&v3 += 4;
      float32x2_t v25 = (char *)v3;
LABEL_122:
      a2[1] = (int8x8_t)v25;
      uint64_t v62 = v24[1];
      if (v62)
      {
        do
        {
          float32x4_t v63 = (uint64_t **)v62;
          uint64_t v62 = (uint64_t *)*v62;
        }
        while (v62);
      }
      else
      {
        do
        {
          float32x4_t v63 = (uint64_t **)v24[2];
          BOOL v64 = *v63 == (uint64_t *)v24;
          int v24 = v63;
        }
        while (!v64);
      }
      int v24 = v63;
      if (v63 == &v102) {
        goto LABEL_128;
      }
    }
    *(void *)uint64_t v31 = *v43;
LABEL_97:
    *size_t v43 = v31;
    goto LABEL_98;
  }
LABEL_128:
  int v65 = *((_DWORD *)*a1 + 4);
  if (v65)
  {
    unint64_t v66 = (unint64_t)v98[1];
    if (v98[1])
    {
      uint64_t v67 = **a1;
      uint64_t v68 = &v67[3 * v65];
      unint64_t v69 = (unint64_t)v98[1] - 1;
      size_t v70 = v98[0];
      if (((unint64_t)v98[1] & ((unint64_t)v98[1] - 1)) != 0)
      {
        while (1)
        {
          unint64_t v88 = *v67;
          unint64_t v89 = v88;
          if (v66 <= v88) {
            unint64_t v89 = v88 % v66;
          }
          float v90 = (uint64_t *)v70[v89];
          if (!v90) {
            break;
          }
          do
          {
            while (1)
            {
              float v90 = (uint64_t *)*v90;
              if (!v90) {
                goto LABEL_179;
              }
              unint64_t v91 = v90[1];
              if (v91 == v88) {
                break;
              }
              if (v91 >= v66) {
                v91 %= v66;
              }
              if (v91 != v89) {
                goto LABEL_179;
              }
            }
          }
          while (*((_DWORD *)v90 + 4) != v88);
          *v67++ = *((_DWORD *)v90 + 5);
          if (v67 == v68) {
            goto LABEL_139;
          }
        }
      }
      else
      {
        unint64_t v71 = (unint64_t)v98[1] + 0xFFFFFFFF;
        while (1)
        {
          uint64_t v72 = *v67;
          float32x4_t v73 = (uint64_t *)v70[v71 & v72];
          if (!v73) {
            break;
          }
          do
          {
            while (1)
            {
              float32x4_t v73 = (uint64_t *)*v73;
              if (!v73) {
                goto LABEL_179;
              }
              uint64_t v74 = v73[1];
              if (v74 == v72) {
                break;
              }
              if ((v74 & v69) != (v71 & v72)) {
                goto LABEL_179;
              }
            }
          }
          while (*((_DWORD *)v73 + 4) != v72);
          *v67++ = *((_DWORD *)v73 + 5);
          if (v67 == v68) {
            goto LABEL_139;
          }
        }
      }
    }
LABEL_179:
    abort();
  }
LABEL_139:
  int v75 = *(_DWORD *)(a3 + 16);
  if (v75)
  {
    unint64_t v76 = (unint64_t)v98[1];
    if (v98[1])
    {
      uint64_t v77 = *(_DWORD **)a3;
      uint64_t v78 = *(void *)a3 + 4 * (3 * v75);
      unint64_t v79 = (unint64_t)v98[1] - 1;
      uint64_t v80 = v98[0];
      if (((unint64_t)v98[1] & ((unint64_t)v98[1] - 1)) != 0)
      {
        while (1)
        {
          unint64_t v92 = *v77;
          unint64_t v93 = v92;
          if (v76 <= v92) {
            unint64_t v93 = v92 % v76;
          }
          double v94 = (uint64_t *)v80[v93];
          if (!v94) {
            break;
          }
          do
          {
            while (1)
            {
              double v94 = (uint64_t *)*v94;
              if (!v94) {
                goto LABEL_179;
              }
              unint64_t v95 = v94[1];
              if (v95 == v92) {
                break;
              }
              if (v95 >= v76) {
                v95 %= v76;
              }
              if (v95 != v93) {
                goto LABEL_179;
              }
            }
          }
          while (*((_DWORD *)v94 + 4) != v92);
          *v77++ = *((_DWORD *)v94 + 5);
          if (v77 == (_DWORD *)v78) {
            goto LABEL_150;
          }
        }
      }
      else
      {
        unint64_t v81 = (unint64_t)v98[1] + 0xFFFFFFFF;
        while (1)
        {
          uint64_t v82 = *v77;
          uint64_t v83 = (uint64_t *)v80[v81 & v82];
          if (!v83) {
            break;
          }
          do
          {
            while (1)
            {
              uint64_t v83 = (uint64_t *)*v83;
              if (!v83) {
                goto LABEL_179;
              }
              uint64_t v84 = v83[1];
              if (v84 == v82) {
                break;
              }
              if ((v84 & v79) != (v81 & v82)) {
                goto LABEL_179;
              }
            }
          }
          while (*((_DWORD *)v83 + 4) != v82);
          *v77++ = *((_DWORD *)v83 + 5);
          if (v77 == (_DWORD *)v78) {
            goto LABEL_150;
          }
        }
      }
    }
    goto LABEL_179;
  }
LABEL_150:
  uint64_t v85 = __p[0];
  if (__p[0])
  {
    do
    {
      float32x4_t v86 = (void *)*v85;
      operator delete(v85);
      uint64_t v85 = v86;
    }
    while (v86);
  }
  int8x16_t v87 = v98[0];
  v98[0] = 0;
  if (v87) {
    operator delete(v87);
  }
  sub_1D0E1F910(v102);
}

void sub_1D0E1F76C(uint64_t a1, unint64_t a2)
{
  if (!a2)
  {
    int v15 = *(void **)a1;
    *(void *)a1 = 0;
    if (v15) {
      operator delete(v15);
    }
    *(void *)(a1 + 8) = 0;
    return;
  }
  if (a2 >> 61) {
    sub_1D0DE8CE0();
  }
  BOOL v4 = operator new(8 * a2);
  float v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = 0;
  *(void *)(a1 + 8) = a2;
  do
    *(void *)(*(void *)a1 + 8 * v6++) = 0;
  while (a2 != v6);
  uint64_t v8 = a1 + 16;
  uint64_t v7 = *(void **)(a1 + 16);
  if (v7)
  {
    unint64_t v9 = v7[1];
    unint64_t v10 = a2 - 1;
    if ((a2 & (a2 - 1)) == 0)
    {
      uint64_t v11 = v9 & v10;
      *(void *)(*(void *)a1 + 8 * v11) = v8;
      while (1)
      {
        int v12 = (void *)*v7;
        if (!*v7) {
          break;
        }
        uint64_t v13 = v12[1] & v10;
        if (v13 == v11)
        {
          uint64_t v7 = (void *)*v7;
        }
        else if (*(void *)(*(void *)a1 + 8 * v13))
        {
          void *v7 = *v12;
          uint64_t v14 = 8 * v13;
          *int v12 = **(void **)(*(void *)a1 + v14);
          **(void **)(*(void *)a1 + v14) = v12;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v13) = v7;
          uint64_t v7 = v12;
          uint64_t v11 = v13;
        }
      }
      return;
    }
    if (v9 >= a2) {
      v9 %= a2;
    }
    *(void *)(*(void *)a1 + 8 * v9) = v8;
    float v16 = (void *)*v7;
    if (*v7)
    {
      do
      {
        unint64_t v18 = v16[1];
        if (v18 >= a2) {
          v18 %= a2;
        }
        if (v18 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v18))
          {
            *(void *)(*(void *)a1 + 8 * v18) = v7;
            goto LABEL_26;
          }
          void *v7 = *v16;
          uint64_t v17 = 8 * v18;
          *float v16 = **(void **)(*(void *)a1 + v17);
          **(void **)(*(void *)a1 + v17) = v16;
          float v16 = v7;
        }
        unint64_t v18 = v9;
LABEL_26:
        uint64_t v7 = v16;
        float v16 = (void *)*v16;
        unint64_t v9 = v18;
      }
      while (v16);
    }
  }
}

void sub_1D0E1F910(void *a1)
{
  if (a1)
  {
    sub_1D0E1F910(*a1);
    sub_1D0E1F910(a1[1]);
    operator delete(a1);
  }
}

void sub_1D0E1F95C(void *a1)
{
  char v18 = 16;
  strcpy(__p, "landmarks.binary");
  sub_1D0E0600C(&v19);
  unint64_t v2 = v19;
  if (v19)
  {
    *(void *)long long __p = &unk_1F26F4208;
    *(void *)&__p[8] = v19;
    __p[16] = 0;
    unsigned int v16 = 0;
    if (v19[2] != 2)
    {
      uint64_t v3 = (*(uint64_t (**)(_DWORD *, unsigned int *, uint64_t))(*(void *)v19 + 144))(v19, &v16, 4);
      if (v3 >= 1) {
        *((void *)v2 + 2) += v3;
      }
    }
    uint64_t v4 = v16;
    if (v16 - 1000001 >= 0xFFF0BDC0)
    {
      uint64_t v7 = operator new(0x48uLL);
      v7[1] = 0;
      _DWORD v7[2] = 0;
      v7[3] = 0;
      void *v7 = &unk_1F26F4E90;
      size_t v8 = (12 * v4 + 31) & 0x7FFFFFFE0;
      v7[4] = v8 >> 2;
      memptr[0] = 0;
      malloc_type_posix_memalign(memptr, 0x20uLL, v8, 0x49090899uLL);
      unint64_t v9 = memptr[0];
      v7[3] = memptr[0];
      *((_DWORD *)v7 + 10) = v4;
      bzero(v9, 12 * v4);
      v7[6] = 0;
      v7[7] = v8 >> 2;
      memptr[0] = 0;
      malloc_type_posix_memalign(memptr, 0x20uLL, v8, 0x49090899uLL);
      unint64_t v10 = memptr[0];
      v7[6] = memptr[0];
      *((_DWORD *)v7 + 16) = v4;
      bzero(v10, 12 * v4);
      *a1 = v7 + 3;
      a1[1] = v7;
      uint64_t v11 = *(void *)&__p[8];
      if (*(_DWORD *)(*(void *)&__p[8] + 8) != 2)
      {
        uint64_t v12 = (*(uint64_t (**)(void, void, uint64_t))(**(void **)&__p[8] + 144))(*(void *)&__p[8], v7[3], 12 * (int)v16);
        if (v12 >= 1) {
          *(void *)(v11 + 16) += v12;
        }
      }
      uint64_t v13 = *(void *)&__p[8];
      if (*(_DWORD *)(*(void *)&__p[8] + 8) != 2)
      {
        uint64_t v14 = (*(uint64_t (**)(void, void, uint64_t))(**(void **)&__p[8] + 144))(*(void *)&__p[8], v7[6], 12 * (int)v16);
        if (v14 >= 1) {
          *(void *)(v13 + 16) += v14;
        }
      }
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
      float v5 = qword_1EB9F1620;
      if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
      {
        LOWORD(memptr[0]) = 0;
        _os_log_error_impl(&dword_1D0DBD000, v5, OS_LOG_TYPE_ERROR, "landmarks binary resource seems corrupted", (uint8_t *)memptr, 2u);
      }
      *a1 = 0;
      a1[1] = 0;
    }
    *(void *)long long __p = &unk_1F26F4208;
    if (__p[16] && *(void *)&__p[8]) {
      (*(void (**)(void))(**(void **)&__p[8] + 8))(*(void *)&__p[8]);
    }
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    uint64_t v6 = qword_1EB9F1620;
    if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long __p = 0;
      _os_log_error_impl(&dword_1D0DBD000, v6, OS_LOG_TYPE_ERROR, "failure reading landmarks binary resource", (uint8_t *)__p, 2u);
    }
    *a1 = 0;
    a1[1] = 0;
  }
  int v15 = v20;
  if (v20)
  {
    if (!atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void sub_1D0E1FD98(uint64_t a1)
{
  free(*(void **)(a1 + 48));
  unint64_t v2 = *(void **)(a1 + 24);
  free(v2);
}

void sub_1D0E1FDD4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4E90;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E1FE28(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4E90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0E1FE48(void *a1, int a2, int a3, char *__s, const char *a5)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  size_t v8 = strlen(__s);
  if (v8 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_134;
  }
  std::string::size_type v9 = v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    p_dst = (std::string *)operator new(v11 + 1);
    __dst.__r_.__value_.__l.__size_ = v9;
    __dst.__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_8;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v8;
  p_dst = &__dst;
  if (v8) {
LABEL_8:
  }
    memcpy(p_dst, __s, v9);
  p_dst->__r_.__value_.__s.__data_[v9] = 0;
  uint64_t v13 = std::string::append(&__dst, "/", 1uLL);
  std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v79.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v79.__r_.__value_.__r.__words[2] = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  size_t v15 = strlen(__s);
  unsigned int v16 = std::string::append(&v79, __s, v15);
  std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v80.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v80.__r_.__value_.__r.__words[2] = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  sub_1D0E06244((uint64_t)&v76);
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v80.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_11:
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_12;
      }
LABEL_16:
      operator delete(__dst.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v76.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_13;
      }
      goto LABEL_17;
    }
  }
  else if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_11;
  }
  operator delete(v79.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_16;
  }
LABEL_12:
  if ((SHIBYTE(v76.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_13:
    std::string __dst = v76;
    goto LABEL_18;
  }
LABEL_17:
  sub_1D0DCB370(&__dst, v76.__r_.__value_.__l.__data_, v76.__r_.__value_.__l.__size_);
LABEL_18:
  if (*a5)
  {
    *((unsigned char *)&v80.__r_.__value_.__s + 23) = 5;
    strcpy((char *)&v80, "main_");
    size_t v18 = strlen(a5);
    unint64_t v19 = std::string::append(&v80, a5, v18);
    std::string::size_type v20 = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)float32x4_t v73 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    uint64_t v74 = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v80.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    HIBYTE(v74) = 4;
    strcpy((char *)v73, "main");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v21 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
  {
    unint64_t v66 = &v76;
    if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      unint64_t v66 = (std::string *)v76.__r_.__value_.__r.__words[0];
    }
    uint64_t v67 = v73;
    if (v74 < 0) {
      uint64_t v67 = (void **)v73[0];
    }
    LODWORD(v80.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)v80.__r_.__value_.__r.__words + 4) = (std::string::size_type)v66;
    WORD2(v80.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v80.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v67;
    _os_log_debug_impl(&dword_1D0DBD000, v21, OS_LOG_TYPE_DEBUG, "Creating E5RT regressor from %s, configuration %s", (uint8_t *)&v80, 0x16u);
  }
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v22 = &__dst;
  }
  else {
    uint64_t v22 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  size_t v23 = strlen((const char *)v22);
  if (v23 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_134;
  }
  std::string::size_type v24 = v23;
  if (v23 >= 0x17)
  {
    uint64_t v26 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v23 | 7) != 0x17) {
      uint64_t v26 = v23 | 7;
    }
    uint64_t v27 = v26 + 1;
    float32x2_t v25 = operator new(v26 + 1);
    v79.__r_.__value_.__l.__size_ = v24;
    v79.__r_.__value_.__r.__words[2] = v27 | 0x8000000000000000;
    v79.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
    goto LABEL_34;
  }
  *((unsigned char *)&v79.__r_.__value_.__s + 23) = v23;
  float32x2_t v25 = &v79;
  if (v23) {
LABEL_34:
  }
    memcpy(v25, v22, v24);
  *((unsigned char *)v25 + v24) = 0;
  unint64_t v28 = std::string::append(&v79, ".bundle", 7uLL);
  std::string::size_type v29 = v28->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v80.__r_.__value_.__l.__data_ = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
  v80.__r_.__value_.__r.__words[2] = v29;
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  cva::Path::Path();
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v80.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_37;
    }
  }
  else if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_37;
  }
  operator delete(v79.__r_.__value_.__l.__data_);
LABEL_37:
  if (cva::Path::exists((cva::Path *)v78))
  {
    cva::Path::string((cva::Path *)v78);
    operator new();
  }
  size_t v30 = strlen((const char *)v22);
  if (v30 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_137;
  }
  std::string::size_type v31 = v30;
  if (v30 >= 0x17)
  {
    uint64_t v33 = (v30 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v30 | 7) != 0x17) {
      uint64_t v33 = v30 | 7;
    }
    uint64_t v34 = v33 + 1;
    unint64_t v32 = operator new(v33 + 1);
    v79.__r_.__value_.__l.__size_ = v31;
    v79.__r_.__value_.__r.__words[2] = v34 | 0x8000000000000000;
    v79.__r_.__value_.__r.__words[0] = (std::string::size_type)v32;
    goto LABEL_48;
  }
  *((unsigned char *)&v79.__r_.__value_.__s + 23) = v30;
  unint64_t v32 = &v79;
  if (v30) {
LABEL_48:
  }
    memcpy(v32, v22, v31);
  *((unsigned char *)v32 + v31) = 0;
  BOOL v35 = std::string::append(&v79, ".mil", 4uLL);
  std::string::size_type v36 = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v80.__r_.__value_.__l.__data_ = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v80.__r_.__value_.__r.__words[2] = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  cva::Path::Path();
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v80.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_51;
    }
  }
  else if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_51;
  }
  operator delete(v79.__r_.__value_.__l.__data_);
LABEL_51:
  if (cva::Path::exists((cva::Path *)v77)) {
    goto LABEL_65;
  }
  cva::Path::~Path((cva::Path *)v77);
  size_t v37 = strlen((const char *)v22);
  if (v37 > 0x7FFFFFFFFFFFFFF7) {
LABEL_137:
  }
    abort();
  std::string::size_type v38 = v37;
  if (v37 >= 0x17)
  {
    uint64_t v40 = (v37 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v37 | 7) != 0x17) {
      uint64_t v40 = v37 | 7;
    }
    uint64_t v41 = v40 + 1;
    unint64_t v39 = operator new(v40 + 1);
    v79.__r_.__value_.__l.__size_ = v38;
    v79.__r_.__value_.__r.__words[2] = v41 | 0x8000000000000000;
    v79.__r_.__value_.__r.__words[0] = (std::string::size_type)v39;
    goto LABEL_61;
  }
  *((unsigned char *)&v79.__r_.__value_.__s + 23) = v37;
  unint64_t v39 = &v79;
  if (v37) {
LABEL_61:
  }
    memcpy(v39, v22, v38);
  *((unsigned char *)v39 + v38) = 0;
  uint64_t v42 = std::string::append(&v79, ".espresso.net", 0xDuLL);
  std::string::size_type v43 = v42->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v80.__r_.__value_.__l.__data_ = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
  v80.__r_.__value_.__r.__words[2] = v43;
  v42->__r_.__value_.__l.__size_ = 0;
  v42->__r_.__value_.__r.__words[2] = 0;
  v42->__r_.__value_.__r.__words[0] = 0;
  cva::Path::Path();
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v80.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_64;
    }
  }
  else if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_64;
  }
  operator delete(v79.__r_.__value_.__l.__data_);
LABEL_64:
  if (cva::Path::exists((cva::Path *)v77))
  {
LABEL_65:
    cva::Path::string((cva::Path *)v77);
    operator new();
  }
  cva::Path::~Path((cva::Path *)v77);
  cva::Path::~Path((cva::Path *)v78);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  unint64_t v44 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
  {
    uint64_t v68 = &v76;
    if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v68 = (std::string *)v76.__r_.__value_.__r.__words[0];
    }
    unint64_t v69 = v73;
    if (v74 < 0) {
      unint64_t v69 = (void **)v73[0];
    }
    LODWORD(v80.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)v80.__r_.__value_.__r.__words + 4) = (std::string::size_type)v68;
    WORD2(v80.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v80.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v69;
    _os_log_error_impl(&dword_1D0DBD000, v44, OS_LOG_TYPE_ERROR, "Failed to create E5RT regressor from %s, configuration %s", (uint8_t *)&v80, 0x16u);
  }
  int v45 = SHIBYTE(v76.__r_.__value_.__r.__words[2]);
  if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t size = HIBYTE(v76.__r_.__value_.__r.__words[2]);
  }
  else {
    size_t size = v76.__r_.__value_.__l.__size_;
  }
  unint64_t v47 = size + 11;
  if (size + 11 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_134;
  }
  if (v47 >= 0x17)
  {
    uint64_t v49 = (v47 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v47 | 7) != 0x17) {
      uint64_t v49 = v47 | 7;
    }
    uint64_t v50 = v49 + 1;
    uint64_t v48 = operator new(v49 + 1);
    v80.__r_.__value_.__l.__size_ = size + 11;
    v80.__r_.__value_.__r.__words[2] = v50 | 0x8000000000000000;
    v80.__r_.__value_.__r.__words[0] = (std::string::size_type)v48;
  }
  else
  {
    memset(&v80, 0, sizeof(v80));
    uint64_t v48 = &v80;
    *((unsigned char *)&v80.__r_.__value_.__s + 23) = size + 11;
    if (!size) {
      goto LABEL_85;
    }
  }
  if (v45 >= 0) {
    unint64_t v51 = &v76;
  }
  else {
    unint64_t v51 = (std::string *)v76.__r_.__value_.__r.__words[0];
  }
  memmove(v48, v51, size);
LABEL_85:
  strcpy((char *)v48 + size, "_legacy.mil");
  cva::Path::Path();
  char v52 = cva::Path::exists((cva::Path *)&v79);
  cva::Path::~Path((cva::Path *)&v79);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  float v53 = qword_1EB9F1620;
  if (v52)
  {
    if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
    {
      size_t v70 = &v80;
      if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        size_t v70 = (std::string *)v80.__r_.__value_.__r.__words[0];
      }
      LODWORD(v79.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)v79.__r_.__value_.__r.__words + 4) = (std::string::size_type)v70;
      WORD2(v79.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v79.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)a5;
      _os_log_debug_impl(&dword_1D0DBD000, v53, OS_LOG_TYPE_DEBUG, "Creating fallback espresso regressor from %s, configuration %s", (uint8_t *)&v79, 0x16u);
    }
    if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v54 = &v80;
    }
    else {
      unint64_t v54 = (std::string *)v80.__r_.__value_.__r.__words[0];
    }
    size_t v55 = strlen((const char *)v54);
    if (v55 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_134;
    }
    std::string::size_type v56 = v55;
    if (v55 >= 0x17)
    {
      uint64_t v59 = (v55 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v55 | 7) != 0x17) {
        uint64_t v59 = v55 | 7;
      }
      uint64_t v60 = v59 + 1;
      uint64_t v57 = operator new(v59 + 1);
      v79.__r_.__value_.__l.__size_ = v56;
      v79.__r_.__value_.__r.__words[2] = v60 | 0x8000000000000000;
      v79.__r_.__value_.__r.__words[0] = (std::string::size_type)v57;
    }
    else
    {
      *((unsigned char *)&v79.__r_.__value_.__s + 23) = v55;
      uint64_t v57 = &v79;
      if (!v55)
      {
LABEL_103:
        v57[v56] = 0;
        size_t v61 = strlen(a5);
        if (v61 <= 0x7FFFFFFFFFFFFFF7)
        {
          uint64_t v62 = (void *)v61;
          if (v61 >= 0x17)
          {
            uint64_t v64 = (v61 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v61 | 7) != 0x17) {
              uint64_t v64 = v61 | 7;
            }
            uint64_t v65 = v64 + 1;
            float32x4_t v63 = operator new(v64 + 1);
            __p[1] = v62;
            unint64_t v72 = v65 | 0x8000000000000000;
            __p[0] = v63;
          }
          else
          {
            HIBYTE(v72) = v61;
            float32x4_t v63 = __p;
            if (!v61)
            {
LABEL_111:
              *((unsigned char *)v62 + (void)v63) = 0;
              operator new();
            }
          }
          memcpy(v63, a5, (size_t)v62);
          goto LABEL_111;
        }
LABEL_134:
        abort();
      }
    }
    memmove(v57, v54, v56);
    goto LABEL_103;
  }
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
  {
    float32x4_t v58 = &v80;
    if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      float32x4_t v58 = (std::string *)v80.__r_.__value_.__r.__words[0];
    }
    LODWORD(v79.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v79.__r_.__value_.__r.__words + 4) = (std::string::size_type)v58;
    _os_log_error_impl(&dword_1D0DBD000, v53, OS_LOG_TYPE_ERROR, "Failed to create espresso regressor from %s. Missing resources.", (uint8_t *)&v79, 0xCu);
  }
  *a1 = 0;
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v80.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v74) & 0x80000000) == 0)
    {
LABEL_114:
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_115;
      }
      goto LABEL_119;
    }
  }
  else if ((SHIBYTE(v74) & 0x80000000) == 0)
  {
    goto LABEL_114;
  }
  operator delete(v73[0]);
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_115:
    if ((SHIBYTE(v76.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_120:
    operator delete(v76.__r_.__value_.__l.__data_);
    return;
  }
LABEL_119:
  operator delete(__dst.__r_.__value_.__l.__data_);
  if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_120;
  }
}

void sub_1D0E20F78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,int a24,__int16 a25,char a26,char a27,int a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  sub_1D0E59A40(&a29);
  sub_1D0E59A40(&a30);
  (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
  cva::Path::~Path((cva::Path *)&a23);
  cva::Path::~Path((cva::Path *)&a25);
  _Unwind_Resume(a1);
}

void sub_1D0E210F4(uint64_t a1, uint64_t a2, int a3, unsigned int a4, int a5, unsigned int a6, uint64_t a7, unsigned int a8, double a9, float a10, uint64_t a11)
{
  if (a1 && a2 && a7 && a11)
  {
    uint64_t v12 = 0;
    LODWORD(v13) = 0;
    uint64_t v14 = (a3 - 1);
    double v15 = (a9 + a9) * a9;
    double v16 = (a10 + a10) * a10;
    uint64_t v41 = a6;
    uint64_t v42 = a8;
    uint64_t v17 = a1 + 16;
    uint64_t v18 = 4 * a4;
    do
    {
      double v21 = *(double *)(a7 + 8 * v12);
      if ((int)v13 < (int)v14 && *(double *)(a1 + 8 * (int)v13 + 8) <= v21)
      {
        uint64_t v13 = (int)v13;
        while (v14 - 1 != v13)
        {
          double v22 = *(double *)(v17 + 8 * v13++);
          if (v22 > v21) {
            goto LABEL_16;
          }
        }
        LODWORD(v13) = v14;
      }
LABEL_16:
      if ((int)v14 >= (int)v13 + 1) {
        int v23 = v13 + 1;
      }
      else {
        int v23 = v14;
      }
      double v24 = 0.0;
      double v25 = fmax(v21 - *(double *)(a1 + 8 * (int)v13), 0.0);
      double v26 = fmax(*(double *)(a1 + 8 * v23) - v21, 0.0);
      double v27 = v25 + v26;
      double v28 = 1.0;
      double v29 = 0.0;
      if (v25 + v26 >= 0.000000001)
      {
        double v29 = v25 / v27;
        double v28 = v26 / v27;
      }
      double v30 = v29 * *(float *)(a2 + 4 * (int)(v23 * a4)) + v28 * *(float *)(a2 + 4 * (int)(v13 * a4));
      uint64_t v31 = (v13 - a5) & ~(((int)v13 - a5) >> 31);
      int v32 = v13 + a5;
      if ((int)v14 < (int)v13 + a5) {
        int v32 = v14;
      }
      double v33 = 0.0;
      if ((int)v31 <= v32)
      {
        uint64_t v34 = (v32 + 1) - v31;
        BOOL v35 = (float *)(a2 + v18 * v31);
        uint64_t v36 = (double *)(a1 + 8 * v31);
        do
        {
          double v37 = *v36++;
          double v38 = *v35 - v30;
          double v39 = exp(-((v37 - v21) * (v37 - v21)) / v15);
          long double v40 = v39 * exp(-(v38 * v38) / v16);
          double v24 = v24 + v40 * v38;
          double v33 = v33 + v40;
          BOOL v35 = (float *)((char *)v35 + v18);
          --v34;
        }
        while (v34);
      }
      double v19 = v24 / v33;
      if (v33 <= 1.0e-10) {
        double v19 = 0.0;
      }
      float v20 = v30 + v19;
      *(float *)(a11 + 4 * v12 * v42) = v20;
      ++v12;
    }
    while (v12 != v41);
  }
}

void sub_1D0E21350(uint64_t a1, uint64_t a2, int a3, int a4, unsigned int a5, uint64_t a6, uint64_t a7, double a8, float a9, float a10)
{
  if (a1)
  {
    if (a2)
    {
      if (a6)
      {
        uint64_t v10 = a7;
        if (a7)
        {
          uint64_t v11 = 0;
          LODWORD(v12) = 0;
          uint64_t v13 = (a3 - 1);
          float v14 = a8;
          float v15 = (float)(v14 + v14) * v14;
          uint64_t v123 = a5;
          float v129 = (float)(a10 + a10) * a10;
          uint64_t v120 = a1 + 16;
          uint64_t v121 = a2 + 32;
          float v130 = v15;
          float v128 = (float)(a9 + a9) * a9;
          do
          {
            double v16 = *(double *)(a6 + 8 * v11);
            if ((int)v12 < (int)v13 && *(double *)(a1 + 8 * (int)v12 + 8) <= v16)
            {
              uint64_t v12 = (int)v12;
              while (v13 - 1 != v12)
              {
                double v17 = *(double *)(v120 + 8 * v12++);
                if (v17 > v16) {
                  goto LABEL_13;
                }
              }
              LODWORD(v12) = v13;
            }
LABEL_13:
            if ((int)v13 >= (int)v12 + 1) {
              int v18 = v12 + 1;
            }
            else {
              int v18 = v13;
            }
            float v19 = v16 - *(double *)(a1 + 8 * (int)v12);
            float v20 = 0.0;
            float v21 = fmaxf(v19, 0.0);
            float v22 = *(double *)(a1 + 8 * v18) - v16;
            float v23 = fmaxf(v22, 0.0);
            float v24 = v21 + v23;
            float v25 = 1.0;
            if ((float)(v21 + v23) >= 0.000000001)
            {
              float v20 = v21 / v24;
              float v25 = v23 / v24;
            }
            float v139 = v25;
            float v142 = v20;
            double v26 = (_OWORD *)(a2 + ((uint64_t)(int)v12 << 6));
            long long v27 = v26[1];
            v153[0] = *v26;
            v153[1] = v27;
            long long v28 = v26[3];
            v153[2] = v26[2];
            long long v154 = v28;
            double v29 = (_OWORD *)(a2 + ((uint64_t)v18 << 6));
            long long v30 = v29[1];
            v151[0] = *v29;
            v151[1] = v30;
            long long v31 = v29[3];
            v151[2] = v29[2];
            long long v152 = v31;
            *(void *)&long long v161 = 0x300000003;
            *((void *)&v161 + 1) = v153;
            *(void *)&long long v162 = 4;
            sub_1D0E21B44((uint64_t)&v147, (uint64_t)&v161);
            *(void *)&long long v161 = 0x300000003;
            *((void *)&v161 + 1) = v151;
            *(void *)&long long v162 = 4;
            sub_1D0E21B44((uint64_t)&v145, (uint64_t)&v161);
            int32x4_t v155 = &v147;
            v156[0] = &v145;
            v156[1] = &v155;
            memset(v157, 0, sizeof(v157));
            float v158 = 0.0;
            sub_1D0E21CFC((uint64_t)v157, (uint64_t)v156);
            float v160 = 0.0;
            uint64_t v159 = 0;
            sub_1D0E21ECC((float32x2_t *)v157, (float *)&v159);
            float v32 = v142 * *(float *)&v159;
            float v33 = v142 * *((float *)&v159 + 1);
            float v34 = v142 * v160;
            float v35 = (float)((float)(v32 * v32) + (float)(v33 * v33)) + (float)(v34 * v34);
            if (v35 >= 0.0061)
            {
              float v39 = sqrtf(v35);
              __float2 v40 = __sincosf_stret(v39);
              float cosval = v40.__cosval;
              float v37 = v40.__sinval / v39;
              float v36 = (float)(1.0 / v35) * (float)(1.0 - v40.__cosval);
            }
            else
            {
              float v36 = 0.5 - (float)(v35 * (float)((float)(v35 / -720.0) + 0.041667));
              float v37 = 1.0 - (float)(v35 * (float)(0.16667 - (float)(v35 * (float)((float)(v35 / -5040.0) + 0.0083333))));
              float cosval = 1.0 - (float)(v35 * v36);
            }
            float v41 = v33 * v36;
            float v42 = cosval + (float)((float)(v32 * v36) * v32);
            float v43 = cosval + (float)((float)(v33 * v36) * v33);
            float v163 = cosval + (float)((float)(v34 * v36) * v34);
            float v44 = v33 * (float)(v32 * v36);
            float v45 = v34 * (float)(v32 * v36);
            float v46 = v34 * v41;
            float v47 = v32 * v37;
            float v48 = v34 * v37;
            *(float *)&long long v161 = v42;
            *((float *)&v161 + 1) = v44 + (float)(v34 * v37);
            float v49 = v33 * v37;
            *((float *)&v162 + 2) = v49 + v45;
            *((float *)&v162 + 3) = v46 - v47;
            *((float *)&v161 + 2) = v45 - v49;
            *((float *)&v161 + 3) = v44 - v48;
            *(float *)&long long v162 = v43;
            *((float *)&v162 + 1) = v47 + v46;
            v164[0] = (float *)&v161;
            v164[1] = (float *)&v147;
            memset(v149, 0, sizeof(v149));
            int v150 = 0;
            sub_1D0DF1BF0((uint64_t)v149, v164);
            float32x2_t v51 = vadd_f32(vmul_n_f32(*(float32x2_t *)&v154, v139), vmul_n_f32(*(float32x2_t *)&v152, v142));
            float v52 = (float)(v139 * *((float *)&v154 + 2)) + (float)(v142 * *((float *)&v152 + 2));
            uint64_t v53 = (v12 - a4) & ~(((int)v12 - a4) >> 31);
            int v54 = v12 + a4;
            if ((int)v13 < (int)v12 + a4) {
              int v54 = v13;
            }
            if ((int)v53 <= v54)
            {
              float32x2_t v60 = 0;
              uint64_t v61 = (v54 + 1) - v53;
              uint64_t v62 = (double *)(a1 + 8 * v53);
              float32x4_t v63 = (float32x2_t *)(v121 + (v53 << 6));
              *(void *)&long long v50 = 0;
              float v64 = 0.0;
              float v65 = 0.0;
              float v66 = 0.0;
              float v67 = 0.0;
              float v68 = 0.0;
              double v131 = v16;
              do
              {
                float v134 = v67;
                float v135 = v66;
                float v136 = v65;
                float v137 = v64;
                float v138 = v68;
                long long v140 = v50;
                float32x2_t v143 = v60;
                double v69 = *v62++;
                float v70 = v69 - v16;
                *(float32x2_t *)&long long v71 = *(float32x2_t *)((char *)v63 - 28);
                float32x2_t v72 = v63[-2];
                __int32 v73 = v63[-1].i32[0];
                float v74 = v63[1].f32[0];
                float v75 = v63[3].f32[0];
                LODWORD(v157[0]) = v63[-4].i32[0];
                *((float32x2_t *)&v71 + 1) = v72;
                DWORD1(v157[1]) = v73;
                *((float32x2_t *)&v157[1] + 1) = *v63;
                v164[0] = (float *)v149;
                uint64_t v147 = (float *)v157;
                int v148 = v164;
                float v158 = v74;
                long long v161 = 0u;
                long long v162 = 0u;
                float v163 = 0.0;
                *(_OWORD *)((char *)v157 + 4) = v71;
                float v76 = expf((float)-(float)(v70 * v70) / v15);
                float v133 = v75 - v52;
                float32x2_t v132 = v63[2];
                sub_1D0E21CFC((uint64_t)&v161, (uint64_t)&v147);
                float v146 = 0.0;
                uint64_t v145 = 0;
                sub_1D0E21ECC((float32x2_t *)&v161, (float *)&v145);
                float v78 = *((float *)&v145 + 1);
                float v77 = *(float *)&v145;
                float v79 = v146;
                float v80 = sqrtf((float)((float)(*(float *)&v145 * *(float *)&v145)+ (float)(*((float *)&v145 + 1) * *((float *)&v145 + 1)))+ (float)(v79 * v79));
                float v81 = v76 * expf((float)-(float)(v80 * v80) / v128);
                float v82 = v52;
                float32x2_t v83 = v51;
                float32x2_t v84 = vsub_f32(v132, v51);
                float v85 = sqrtf(vaddv_f32(vmul_f32(v84, v84)) + (float)(v133 * v133));
                float v86 = expf((float)-(float)(v85 * v85) / v129);
                long long v50 = v140;
                float v87 = v76 * v86;
                float v65 = v136 + (float)(v77 * v81);
                float v88 = v78 * v81;
                float v15 = v130;
                float v66 = v135 + v88;
                float v89 = v79 * v81;
                double v16 = v131;
                float v67 = v134 + v89;
                float v64 = v137 + v81;
                float32x2_t v90 = vmul_n_f32(v84, v87);
                float32x2_t v51 = v83;
                float v52 = v82;
                float32x2_t v60 = vadd_f32(v143, v90);
                float v68 = v138 + (float)(v133 * v87);
                *(float *)&long long v50 = *(float *)&v140 + v87;
                v63 += 8;
                --v61;
              }
              while (v61);
              float v59 = 0.0;
              float v58 = 0.0;
              float v57 = 0.0;
              float v56 = 0.0;
              if (v64 > 1.0e-10)
              {
                float v56 = v65 / v64;
                float v57 = v66 / v64;
                float v58 = v67 / v64;
              }
              float32x2_t v55 = 0;
              uint64_t v10 = a7;
              if (*(float *)&v50 > 1.0e-10)
              {
                float32x2_t v55 = vdiv_f32(v60, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v50, 0));
                float v59 = v68 / *(float *)&v50;
              }
            }
            else
            {
              float32x2_t v55 = 0;
              float v56 = 0.0;
              float v57 = 0.0;
              float v58 = 0.0;
              float v59 = 0.0;
            }
            unint64_t v91 = (_OWORD *)(v10 + (v11 << 6));
            long long v92 = *MEMORY[0x1E4F149A0];
            long long v93 = *(_OWORD *)(MEMORY[0x1E4F149A0] + 16);
            long long v94 = *(_OWORD *)(MEMORY[0x1E4F149A0] + 48);
            v91[2] = *(_OWORD *)(MEMORY[0x1E4F149A0] + 32);
            v91[3] = v94;
            _OWORD *v91 = v92;
            v91[1] = v93;
            float v95 = (float)(v58 * v58) + (float)((float)(v57 * v57) + (float)(v56 * v56));
            if (v95 >= 0.0061)
            {
              float32x2_t v144 = v55;
              float v141 = v59;
              float v99 = sqrtf(v95);
              float v100 = v57;
              float v101 = v56;
              __float2 v102 = __sincosf_stret(v99);
              float v98 = v102.__cosval;
              float v56 = v101;
              float v57 = v100;
              float v97 = v102.__sinval / v99;
              float v59 = v141;
              float32x2_t v55 = v144;
              float v96 = (float)(1.0 / v95) * (float)(1.0 - v102.__cosval);
            }
            else
            {
              float v96 = 0.5 - (float)(v95 * (float)((float)(v95 / -720.0) + 0.041667));
              float v97 = 1.0 - (float)(v95 * (float)(0.16667 - (float)(v95 * (float)((float)(v95 / -5040.0) + 0.0083333))));
              float v98 = 1.0 - (float)(v95 * v96);
            }
            float v103 = v57 * v96;
            float v104 = v98 + (float)((float)(v56 * v96) * v56);
            float v105 = v98 + (float)((float)(v57 * v96) * v57);
            float v158 = v98 + (float)((float)(v58 * v96) * v58);
            float v106 = v57 * (float)(v56 * v96);
            float v107 = v58 * (float)(v56 * v96);
            float v108 = v58 * v103;
            float v109 = v56 * v97;
            float v110 = v58 * v97;
            *(float *)int32x4_t v157 = v104;
            *((float *)v157 + 1) = v106 + (float)(v58 * v97);
            float v111 = v57 * v97;
            *((float *)&v157[1] + 2) = v111 + v107;
            *((float *)&v157[1] + 3) = v108 - v109;
            *((float *)v157 + 3) = v106 - v110;
            *((float *)v157 + 2) = v107 - v111;
            *(float *)&v157[1] = v105;
            *((float *)&v157[1] + 1) = v109 + v108;
            uint64_t v147 = (float *)v157;
            int v148 = (float **)v149;
            long long v161 = 0u;
            long long v162 = 0u;
            float v163 = 0.0;
            float v112 = (int *)&v161;
            sub_1D0DF1BF0((uint64_t)&v161, &v147);
            int v113 = 0;
            for (uint64_t i = 0; i != 12; ++i)
            {
              int v115 = *v112++;
              *((_DWORD *)v91 + i) = v115;
              if (v113 > 1) {
                ++i;
              }
              if (v113 <= 1) {
                ++v113;
              }
              else {
                int v113 = 0;
              }
            }
            int v116 = 0;
            *(float32x2_t *)&long long v161 = vadd_f32(v51, v55);
            *((float *)&v161 + 2) = v52 + v59;
            unint64_t v117 = (int *)&v161;
            for (uint64_t j = 12; j != 16; ++j)
            {
              int v119 = *v117++;
              *((_DWORD *)v91 + j) = v119;
              if (v116 > 1) {
                ++j;
              }
              if (v116 <= 1) {
                ++v116;
              }
              else {
                int v116 = 0;
              }
            }
            ++v11;
          }
          while (v11 != v123);
        }
      }
    }
  }
}

uint64_t sub_1D0E21B44(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 32) = 0;
  *(_OWORD *)double result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  int v3 = *(_DWORD *)a2;
  if (*(_DWORD *)(a2 + 4) * *(_DWORD *)a2) {
    uint64_t v4 = *(int **)(a2 + 8);
  }
  else {
    uint64_t v4 = 0;
  }
  int v2 = *(_DWORD *)(a2 + 16);
  unsigned int v5 = v2 - v3;
  int v6 = *v4;
  if (*(void *)(a2 + 8) - 4 * *(unsigned int *)(a2 + 20) == result)
  {
    if (v3 <= 1) {
      int v43 = v2 - v3;
    }
    else {
      int v43 = 0;
    }
    float v44 = &v4[v43];
    int v46 = v44[1];
    float v45 = v44 + 1;
    int v47 = v46;
    if (v3 <= 1) {
      int v48 = 1;
    }
    else {
      int v48 = 2;
    }
    if (v48 >= v3) {
      unsigned int v49 = v5;
    }
    else {
      unsigned int v49 = 0;
    }
    long long v50 = &v45[v49];
    int v52 = v50[1];
    float32x2_t v51 = v50 + 1;
    int v53 = v52;
    if (v48 < v3) {
      int v54 = v48 + 1;
    }
    else {
      int v54 = 1;
    }
    if (v54 >= v3) {
      unsigned int v55 = v5;
    }
    else {
      unsigned int v55 = 0;
    }
    float v56 = &v51[v55];
    int v58 = v56[1];
    float v57 = v56 + 1;
    int v59 = v58;
    if (v54 < v3) {
      int v60 = v54 + 1;
    }
    else {
      int v60 = 1;
    }
    if (v60 >= v3) {
      unsigned int v61 = v5;
    }
    else {
      unsigned int v61 = 0;
    }
    uint64_t v62 = &v57[v61];
    int v64 = v62[1];
    float32x4_t v63 = v62 + 1;
    int v65 = v64;
    if (v60 < v3) {
      int v66 = v60 + 1;
    }
    else {
      int v66 = 1;
    }
    if (v66 >= v3) {
      unsigned int v67 = v5;
    }
    else {
      unsigned int v67 = 0;
    }
    float v68 = (uint64_t)&v63[v67];
    int v70 = *(_DWORD *)(v68 + 4);
    uint64_t v69 = v68 + 4;
    int v71 = v70;
    if (v66 < v3) {
      int v72 = v66 + 1;
    }
    else {
      int v72 = 1;
    }
    if (v72 >= v3) {
      unsigned int v73 = v5;
    }
    else {
      unsigned int v73 = 0;
    }
    uint64_t v74 = v69 + 4 * v73;
    int v76 = *(_DWORD *)(v74 + 4);
    uint64_t v75 = v74 + 4;
    int v77 = v76;
    if (v72 < v3) {
      int v78 = v72 + 1;
    }
    else {
      int v78 = 1;
    }
    if (v78 >= v3) {
      unsigned int v79 = v5;
    }
    else {
      unsigned int v79 = 0;
    }
    uint64_t v80 = v75 + 4 * v79;
    int v82 = *(_DWORD *)(v80 + 4);
    uint64_t v81 = v80 + 4;
    int v83 = v82;
    if (v78 < v3) {
      int v84 = v78 + 1;
    }
    else {
      int v84 = 1;
    }
    if (v84 >= v3) {
      unsigned int v85 = v5;
    }
    else {
      unsigned int v85 = 0;
    }
    int v86 = *(_DWORD *)(v81 + 4 * v85 + 4);
    *(_DWORD *)double result = v6;
    *(_DWORD *)(result + 4) = v47;
    *(_DWORD *)(result + 8) = v53;
    *(_DWORD *)(result + 12) = v59;
    *(_DWORD *)(result + 16) = v65;
    *(_DWORD *)(result + 20) = v71;
    *(_DWORD *)(result + 24) = v77;
    *(_DWORD *)(result + 28) = v83;
    *(_DWORD *)(result + 32) = v86;
  }
  else
  {
    *(_DWORD *)double result = v6;
    if (v3 <= 1) {
      int v7 = v2 - v3;
    }
    else {
      int v7 = 0;
    }
    size_t v8 = &v4[v7];
    int v10 = v8[1];
    std::string::size_type v9 = v8 + 1;
    *(_DWORD *)(result + 4) = v10;
    if (v3 <= 1) {
      int v11 = 1;
    }
    else {
      int v11 = 2;
    }
    if (v11 >= v3) {
      unsigned int v12 = v5;
    }
    else {
      unsigned int v12 = 0;
    }
    uint64_t v13 = &v9[v12];
    int v15 = v13[1];
    float v14 = v13 + 1;
    *(_DWORD *)(result + 8) = v15;
    if (v11 < v3) {
      int v16 = v11 + 1;
    }
    else {
      int v16 = 1;
    }
    if (v16 >= v3) {
      unsigned int v17 = v5;
    }
    else {
      unsigned int v17 = 0;
    }
    int v18 = &v14[v17];
    int v20 = v18[1];
    float v19 = v18 + 1;
    *(_DWORD *)(result + 12) = v20;
    if (v16 < v3) {
      int v21 = v16 + 1;
    }
    else {
      int v21 = 1;
    }
    if (v21 >= v3) {
      unsigned int v22 = v5;
    }
    else {
      unsigned int v22 = 0;
    }
    float v23 = &v19[v22];
    int v25 = v23[1];
    float v24 = v23 + 1;
    *(_DWORD *)(result + 16) = v25;
    if (v21 < v3) {
      int v26 = v21 + 1;
    }
    else {
      int v26 = 1;
    }
    if (v26 >= v3) {
      unsigned int v27 = v5;
    }
    else {
      unsigned int v27 = 0;
    }
    long long v28 = (uint64_t)&v24[v27];
    int v30 = *(_DWORD *)(v28 + 4);
    uint64_t v29 = v28 + 4;
    *(_DWORD *)(result + 20) = v30;
    if (v26 < v3) {
      int v31 = v26 + 1;
    }
    else {
      int v31 = 1;
    }
    if (v31 >= v3) {
      unsigned int v32 = v5;
    }
    else {
      unsigned int v32 = 0;
    }
    uint64_t v33 = v29 + 4 * v32;
    int v35 = *(_DWORD *)(v33 + 4);
    uint64_t v34 = v33 + 4;
    *(_DWORD *)(result + 24) = v35;
    if (v31 < v3) {
      int v36 = v31 + 1;
    }
    else {
      int v36 = 1;
    }
    if (v36 >= v3) {
      unsigned int v37 = v5;
    }
    else {
      unsigned int v37 = 0;
    }
    uint64_t v38 = v34 + 4 * v37;
    int v40 = *(_DWORD *)(v38 + 4);
    uint64_t v39 = v38 + 4;
    *(_DWORD *)(result + 28) = v40;
    if (v36 < v3) {
      int v41 = v36 + 1;
    }
    else {
      int v41 = 1;
    }
    if (v41 >= v3) {
      unsigned int v42 = v5;
    }
    else {
      unsigned int v42 = 0;
    }
    *(_DWORD *)(result + 32) = *(_DWORD *)(v39 + 4 * v42 + 4);
  }
  return result;
}

__n64 sub_1D0E21CFC(uint64_t a1, uint64_t a2)
{
  int v3 = *(float **)a2;
  if (*(void *)a2 == a1)
  {
    int v9 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    sub_1D0E21CFC(&v7);
    result.n64_u64[0] = v7;
    long long v6 = v8;
    *(_OWORD *)a1 = v7;
    *(_OWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 32) = v9;
  }
  else
  {
    uint64_t v4 = **(float ***)(a2 + 8);
    result.n64_u32[1] = 0;
    *(float *)a1 = (float)((float)((float)(*v3 * *v4) + 0.0) + (float)(v3[3] * v4[3])) + (float)(v3[6] * v4[6]);
    *(float *)(a1 + 4) = (float)((float)((float)(v3[1] * *v4) + 0.0) + (float)(v3[4] * v4[3])) + (float)(v3[7] * v4[6]);
    *(float *)(a1 + 8) = (float)((float)((float)(v3[2] * *v4) + 0.0) + (float)(v3[5] * v4[3])) + (float)(v3[8] * v4[6]);
    *(float *)(a1 + 12) = (float)((float)((float)(*v3 * v4[1]) + 0.0) + (float)(v3[3] * v4[4])) + (float)(v3[6] * v4[7]);
    *(float *)(a1 + 16) = (float)((float)((float)(v3[1] * v4[1]) + 0.0) + (float)(v3[4] * v4[4]))
                        + (float)(v3[7] * v4[7]);
    *(float *)(a1 + 20) = (float)((float)((float)(v3[2] * v4[1]) + 0.0) + (float)(v3[5] * v4[4]))
                        + (float)(v3[8] * v4[7]);
    *(float *)(a1 + 24) = (float)((float)((float)(*v3 * v4[2]) + 0.0) + (float)(v3[3] * v4[5])) + (float)(v3[6] * v4[8]);
    *(float *)(a1 + 28) = (float)((float)((float)(v3[1] * v4[2]) + 0.0) + (float)(v3[4] * v4[5]))
                        + (float)(v3[7] * v4[8]);
    result.n64_f32[0] = (float)((float)((float)(v3[2] * v4[2]) + 0.0) + (float)(v3[5] * v4[5])) + (float)(v3[8] * v4[8]);
    *(_DWORD *)(a1 + 32) = result.n64_u32[0];
  }
  return result;
}

void sub_1D0E21ECC(float32x2_t *a1, float *a2)
{
  float v4 = (float)(a1[2].f32[1] - a1[3].f32[1]) * 0.5;
  *a2 = v4;
  float v5 = (float)(a1[3].f32[0] - a1[1].f32[0]) * 0.5;
  a2[1] = v5;
  float v6 = (float)(a1->f32[1] - a1[1].f32[1]) * 0.5;
  a2[2] = v6;
  float v7 = a1->f32[0];
  float v8 = a1[2].f32[0];
  float v9 = a1[4].f32[0];
  float v10 = -1.0;
  float v11 = (float)((float)((float)(a1->f32[0] + v8) + v9) + -1.0) * 0.5;
  float v12 = (float)((float)(v5 * v5) + (float)(v4 * v4)) + (float)(v6 * v6);
  if (v11 >= -1.0 || (float)(v11 + 1.0) <= -0.00001)
  {
    BOOL v14 = v11 > 1.0;
    if ((float)(v11 + -1.0) >= 0.00001) {
      BOOL v14 = 0;
    }
    if (v11 <= 0.99 && !v14)
    {
      if (v11 <= -0.99)
      {
        float v10 = (float)((float)((float)(a1->f32[0] + v8) + v9) + -1.0) * 0.5;
        goto LABEL_17;
      }
      float v16 = acosf(v11) / sqrtf(v12);
      *a2 = v4 * v16;
      a2[1] = v5 * v16;
    }
    else
    {
      float v16 = (float)(v12 * (float)((float)(v12 * (float)((float)((float)(v12 * 5.0) / 112.0) + 0.075)) + 0.16667)) + 1.0;
      *a2 = v4 * v16;
      a2[1] = v5 * v16;
    }
    a2[2] = v6 * v16;
    return;
  }
LABEL_17:
  float v17 = asinf(sqrtf(v12));
  float v18 = (float)((float)(3.1416 - v17) * (float)(3.1416 - v17)) / (float)(1.0 - v10);
  float v19 = (float)(v7 - v10) * v18;
  float v20 = (float)(v8 - v10) * v18;
  float v21 = (float)(v9 - v10) * v18;
  if (v19 <= v20)
  {
    float v26 = v18 * 0.5;
    if (v20 <= v21)
    {
      float v33 = sqrtf(v21);
      if (v6 < 0.0) {
        float v33 = -v33;
      }
      a2[2] = v33;
      v34.i32[0] = a1[1].i32[0];
      v34.i32[1] = a1[2].i32[1];
      *(float32x2_t *)a2 = vmul_n_f32(vmul_n_f32(vadd_f32(a1[3], v34), v26), 1.0 / v33);
    }
    else
    {
      float v27 = sqrtf(v20);
      if (v5 < 0.0) {
        float v27 = -v27;
      }
      a2[1] = v27;
      float v28 = 1.0 / v27;
      float v29 = a1[3].f32[1] + a1[2].f32[1];
      *a2 = v28 * (float)(v26 * (float)(a1[1].f32[1] + a1->f32[1]));
      a2[2] = v28 * (float)(v26 * v29);
    }
  }
  else
  {
    float v22 = v18 * 0.5;
    float v23 = v22 * (float)(a1[3].f32[0] + a1[1].f32[0]);
    if (v19 <= v21)
    {
      float v30 = sqrtf(v21);
      if (v6 < 0.0) {
        float v30 = -v30;
      }
      a2[2] = v30;
      float v31 = 1.0 / v30;
      float v32 = v31 * (float)(v22 * (float)(a1[3].f32[1] + a1[2].f32[1]));
      *a2 = v31 * v23;
      a2[1] = v32;
    }
    else
    {
      float v24 = sqrtf(v19);
      if (v4 < 0.0) {
        float v24 = -v24;
      }
      *a2 = v24;
      float v25 = 1.0 / v24;
      a2[1] = v25 * (float)(v22 * (float)(a1[1].f32[1] + a1->f32[1]));
      a2[2] = v25 * v23;
    }
  }
}

uint64_t sub_1D0E221E0()
{
  std::__libcpp_verbose_abort("bad_variant_access was thrown in -fno-exceptions mode");
  return sub_1D0E221F8(v0, v1);
}

void sub_1D0E221F8(uint64_t a1, CVPixelBufferRef texture, uint64_t a3, uint64_t *a4)
{
  *(void *)(a1 + 16) = *(void *)(a3 + 8);
  if (a1 + 8 != a3)
  {
    long long v7 = *(_OWORD *)(a3 + 16);
    long long v8 = *(_OWORD *)(a3 + 32);
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a3 + 48);
    *(_OWORD *)(a1 + 40) = v8;
    *(_OWORD *)(a1 + 24) = v7;
    long long v9 = *(_OWORD *)(a3 + 52);
    long long v10 = *(_OWORD *)(a3 + 68);
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a3 + 84);
    *(_OWORD *)(a1 + 76) = v10;
    *(_OWORD *)(a1 + 60) = v9;
    uint64_t v11 = *(void *)(a3 + 88);
    *(_DWORD *)(a1 + 104) = *(_DWORD *)(a3 + 96);
    *(void *)(a1 + 96) = v11;
  }
  CVPixelBufferRetain(texture);
  if (*(void *)a1) {
    CVPixelBufferRelease(*(CVPixelBufferRef *)a1);
  }
  *(void *)a1 = texture;
  float v12 = (void *)(a1 + 112);
  if (*(_DWORD *)(a1 + 124) == 2)
  {
    uint64_t v13 = *a4;
    *(_DWORD *)(a1 + 120) = *((_DWORD *)a4 + 2);
    *float v12 = v13;
  }
  else
  {
    *(_DWORD *)(a1 + 124) = -1;
    uint64_t v14 = *a4;
    *(_DWORD *)(a1 + 120) = *((_DWORD *)a4 + 2);
    *float v12 = v14;
    *(_DWORD *)(a1 + 124) = 2;
  }
}

__CFDictionary *sub_1D0E222D4(int a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    float v4 = Mutable;
    float v5 = (const void *)*MEMORY[0x1E4F1CFC8];
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F6ED70], (const void *)*MEMORY[0x1E4F1CFC8]);
    float v6 = (const void *)*MEMORY[0x1E4F1CFD0];
    CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F6EC80], (const void *)*MEMORY[0x1E4F1CFD0]);
    if (a1) {
      long long v7 = v6;
    }
    else {
      long long v7 = v5;
    }
    CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F6ED60], v7);
    CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F6ED78], v5);
    int valuePtr = 0;
    CFNumberRef v8 = CFNumberCreate(v2, kCFNumberIntType, &valuePtr);
    if (v8)
    {
      CFNumberRef v9 = v8;
      CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F6EC60], v8);
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
      uint64_t v11 = (id)qword_1EB9F1620;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v13 = 0;
        _os_log_error_impl(&dword_1D0DBD000, v11, OS_LOG_TYPE_ERROR, "could not set up hardware accelerator (setting number)", v13, 2u);
      }

      CFNumberRef v9 = v4;
      float v4 = 0;
    }
    CFRelease(v9);
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    long long v10 = (id)qword_1EB9F1620;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v10, OS_LOG_TYPE_ERROR, "could not set up hardware accelerator (setting options)", buf, 2u);
    }

    return 0;
  }
  return v4;
}

void sub_1D0E22538()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1EB9F1618)) {
      sub_1D0E225B4();
    }
  }
}

void sub_1D0E2259C(_Unwind_Exception *a1)
{
}

void sub_1D0E225B4()
{
}

void sub_1D0E22748(_Unwind_Exception *a1)
{
  MEMORY[0x1D25F16B0](v1, 0x1012C40F8266235);
  _Unwind_Resume(a1);
}

void sub_1D0E2276C()
{
  v27[32] = *MEMORY[0x1E4F143B8];
  context = (void *)MEMORY[0x1D25F1DA0]();
  int v0 = os_variant_allows_internal_security_policies();
  *(unsigned char *)(qword_1EB9F15F8 + 104) = v0;
  if (v0)
  {
    CFDictionaryRef v1 = (const __CFDictionary *)CFPreferencesCopyAppValue(@"com.apple.applecva.facekit", (CFStringRef)*MEMORY[0x1E4F1D3B8]);
    if (v1)
    {
      CFDictionaryRef v2 = v1;
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v1);
      cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)v20, MutableCopy);
      CFRelease(v2);
      uint64_t Dictionary = (const void *)cva::DictionaryHandler::getDictionary((cva::DictionaryHandler *)v20);
      CFRelease(Dictionary);
      float v19 = (cva::DictionaryHandler *)v20;
      sub_1D0E23F38(&v19, "facekit_enable_multiuser");
      sub_1D0E23F38(&v19, "facekit_enable_recognition");
      sub_1D0E23F38(&v19, "facekit_force_enable_recognition");
      sub_1D0E23F38(&v19, "facekit_enable_tongue");
      sub_1D0E23F38(&v19, "facekit_enable_perspective_warp");
      sub_1D0E24444(&v19, "facekit_filter_historysize");
      sub_1D0E24444(&v19, "gaze_facekit_filter_historysize");
      sub_1D0E24444(&v19, "bbox_facekit_filter_historysize");
      sub_1D0E24944(&v19, "facekit_posefilter_translation_smoothing");
      sub_1D0E24944(&v19, "facekit_posefilter_rotation_smoothing");
      sub_1D0E24944(&v19, "facekit_robust_blendshape_smoothing");
      sub_1D0E24944(&v19, "facekit_robust_blendshape_smoothing_lowest_threshold");
      sub_1D0E24944(&v19, "facekit_robust_blendshape_smoothing_low_threshold");
      sub_1D0E24944(&v19, "facekit_robust_blendshape_smoothing_high_threshold");
      sub_1D0E24944(&v19, "facekit_robust_blendshape_smoothing_highest_threshold");
      sub_1D0E24944(&v19, "facekit_robust_blendshape_smoothing_temporal_smoothing");
      sub_1D0E24944(&v19, "facekit_robust_blendshape_smoothing_prediction_factor");
      sub_1D0E24944(&v19, "facekit_robust_blendshape_smoothing_min_smoothing");
      sub_1D0E24944(&v19, "facekit_robust_blendshape_smoothing_brow_multiplier");
      sub_1D0E24944(&v19, "facekit_robust_blendshape_smoothing_eye_multiplier");
      sub_1D0E24944(&v19, "facekit_robust_blendshape_smoothing_mouth_multiplier");
      sub_1D0E24944(&v19, "facekit_robust_blendshape_smoothing_mouth_tongue_multiplier");
      sub_1D0E24944(&v19, "facekit_gaze_smoothing_threshold");
      sub_1D0E24944(&v19, "facekit_tongue_smoothing_threshold");
      sub_1D0E23F38(&v19, "facekit_symmetrize_blendshapes");
      sub_1D0E24944(&v19, "facekit_blendshape_asymmetry_scale");
      sub_1D0E24944(&v19, "facekit_blendshape_asymmetry_shift");
      sub_1D0E24944(&v19, "face_detection_roll_smoothing_threshold");
      sub_1D0E24944(&v19, "face_detection_bbox_smoothing_threshold");
      sub_1D0E24944(&v19, "facekit_enlargement_factor");
      sub_1D0E24944(&v19, "facekit_failure_threshold");
      sub_1D0E24944(&v19, "facekit_failure_threshold");
      sub_1D0E24944(&v19, "facekit_maxangle_cara");
      sub_1D0E24944(&v19, "facekit_mindistance_for_tracking");
      sub_1D0E24944(&v19, "facekit_maxdistance_for_tracking");
      sub_1D0E24944(&v19, "facekit_mindistance_for_fitting");
      sub_1D0E24944(&v19, "facekit_mindistance_for_fitting_rgbd");
      sub_1D0E24944(&v19, "facekit_maxdistance_for_fitting_rgbd");
      sub_1D0E24944(&v19, "facekit_maxdistance_for_fitting");
      sub_1D0E24944(&v19, "facekit_maxtranslationalvelocity");
      sub_1D0E24944(&v19, "facekit_maxtranslationalacceleration");
      sub_1D0E24944(&v19, "facekit_maxangularvelocity");
      sub_1D0E24944(&v19, "facekit_maxangularacceleration");
      sub_1D0E24944(&v19, "max_angle_recognition");
      sub_1D0E24944(&v19, "max_translational_velocity_recognition");
      sub_1D0E24944(&v19, "max_angular_velocity_recognition");
      sub_1D0E24944(&v19, "max_translational_acceleration_recognition");
      sub_1D0E24944(&v19, "max_angular_acceleration_recognition");
      sub_1D0E24944(&v19, "recognition_failure_threshold");
      sub_1D0E23F38(&v19, "facekit_robusttongueactivation");
      sub_1D0E24944(&v19, "facekit_maxangle_tongue");
      sub_1D0E24944(&v19, "facekit_maxexpression_tongue");
      sub_1D0E24444(&v19, "facekit_luxlevel_threshold");
      sub_1D0E23F38(&v19, "facekit_use_debug_profile");
      if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)v20, "facekit_debug_profile_path"))
      {
        cva::DictionaryHandler::item((uint64_t *)v26, (cva::DictionaryHandler *)v20, "facekit_debug_profile_path");
        cva::ItemHandler::getValue<std::string>();
      }
      cva::DictionaryHandler::removeItem((cva::DictionaryHandler *)v20, "facekit_debug_profile_path");
      sub_1D0E24944(&v19, "face_identity_cluster_detection_range");
      sub_1D0E24944(&v19, "face_identity_cluster_radius");
      sub_1D0E24444(&v19, "recognition_update_period");
      sub_1D0E23F38(&v19, "facekit_force_debug_info");
      sub_1D0E24444(&v19, "facekit_postprocessing_kernel_size");
      if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)v20, "facekit_postprocessing_time_std"))
      {
        cva::DictionaryHandler::item((uint64_t *)v26, (cva::DictionaryHandler *)v20, "facekit_postprocessing_time_std");
        cva::ItemHandler::getValue<double>();
      }
      cva::DictionaryHandler::removeItem((cva::DictionaryHandler *)v20, "facekit_postprocessing_time_std");
      sub_1D0E24944(&v19, "facekit_postprocessing_blendshape_std");
      sub_1D0E24944(&v19, "facekit_postprocessing_blendshape_brow_multiplier");
      sub_1D0E24944(&v19, "facekit_postprocessing_blendshape_eye_multiplier");
      sub_1D0E24944(&v19, "facekit_postprocessing_blendshape_mouth_multiplier");
      sub_1D0E24944(&v19, "facekit_postprocessing_rotation_std");
      sub_1D0E24944(&v19, "facekit_postprocessing_translation_std");
      CFDictionaryRef v5 = (const __CFDictionary *)cva::DictionaryHandler::getDictionary((cva::DictionaryHandler *)v20);
      int Count = CFDictionaryGetCount(v5);
      if (Count)
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1610))
        {
          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
          __cxa_guard_release(&qword_1EB9F1610);
        }
        long long v7 = (id)qword_1EB9F1620;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          CStringPtr = CFStringGetCStringPtr(@"com.apple.applecva.facekit", 0x8000100u);
          *(_DWORD *)float v26 = 67109378;
          *(_DWORD *)&void v26[4] = Count;
          LOWORD(v27[0]) = 2080;
          *(void *)((char *)v27 + 2) = CStringPtr;
          _os_log_impl(&dword_1D0DBD000, v7, OS_LOG_TYPE_DEFAULT, "%d unrecognized setting(s) in %s defaults", v26, 0x12u);
        }

        cva::DictionaryHandler::getKeys((uint64_t *)v26, (cva::DictionaryHandler *)v20);
        long long v10 = *(const char **)v26;
        CFNumberRef v9 = (const char *)v27[0];
        if (*(void *)v26 != v27[0])
        {
          do
          {
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EB9F1610))
            {
              qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
              __cxa_guard_release(&qword_1EB9F1610);
            }
            uint64_t v11 = (id)qword_1EB9F1620;
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              float v12 = v10;
              if (v10[23] < 0) {
                float v12 = *(const char **)v10;
              }
              uint64_t v13 = NSString;
              cva::DictionaryHandler::item((uint64_t *)&__p, (cva::DictionaryHandler *)v20, v12);
              id v14 = [v13 stringWithFormat:@"%@", cva::ItemHandler::getObject((cva::ItemHandler *)&__p), context];
              uint64_t v15 = [v14 UTF8String];
              int __s1 = 136315394;
              __s1_4 = v12;
              __int16 __n_4 = 2080;
              size_t __n_6 = v15;
              _os_log_impl(&dword_1D0DBD000, v11, OS_LOG_TYPE_DEFAULT, "\tunrecognized facekit setting: %s=%s", (uint8_t *)&__s1, 0x16u);

              cva::ItemHandler::~ItemHandler((cva::ItemHandler *)&__p);
            }

            v10 += 24;
          }
          while (v10 != v9);
          long long v10 = *(const char **)v26;
        }
        if (v10)
        {
          float v16 = (void **)v27[0];
          float v17 = (char *)v10;
          if ((const char *)v27[0] != v10)
          {
            do
            {
              if (*((char *)v16 - 1) < 0) {
                operator delete(*(v16 - 3));
              }
              v16 -= 3;
            }
            while (v16 != (void **)v10);
            float v17 = *(char **)v26;
          }
          v27[0] = v10;
          operator delete(v17);
        }
      }
      cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)v20);
    }
  }
}

void sub_1D0E23C60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *__p,uint64_t a47,int a48,__int16 a49,char a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,void *a62,uint64_t a63)
{
  if (a51 < 0) {
    operator delete(__p);
  }
  a53 = *MEMORY[0x1E4FBA418];
  *(uint64_t *)((char *)&a53 + *(void *)(a53 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  a54 = MEMORY[0x1E4FBA470] + 16;
  if (a67 < 0) {
    operator delete(a62);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1D25F1640](&a70);
  if (a22 < 0)
  {
    operator delete(a17);
    if ((a29 & 0x80000000) == 0) {
      goto LABEL_7;
    }
  }
  else if ((a29 & 0x80000000) == 0)
  {
LABEL_7:
    if ((a36 & 0x80000000) == 0)
    {
LABEL_12:
      cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)&a15);
      _Unwind_Resume(a1);
    }
LABEL_11:
    operator delete(a31);
    goto LABEL_12;
  }
  operator delete(a24);
  if ((a36 & 0x80000000) == 0) {
    goto LABEL_12;
  }
  goto LABEL_11;
}

uint64_t sub_1D0E23F38(cva::DictionaryHandler **a1, const char *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  float v4 = *a1;
  if (cva::DictionaryHandler::hasKey(*a1, a2))
  {
    cva::DictionaryHandler::item(&v6, v4, a2);
    cva::ItemHandler::getValue<BOOL>();
  }
  return cva::DictionaryHandler::removeItem(*a1, a2);
}

void sub_1D0E24338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  a12 = *MEMORY[0x1E4FBA418];
  *(uint64_t *)((char *)&a12 + *(void *)(a12 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  a13 = MEMORY[0x1E4FBA470] + 16;
  if (a26 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1D25F1640](&a29);
  _Unwind_Resume(a1);
}

uint64_t sub_1D0E24444(cva::DictionaryHandler **a1, const char *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  float v4 = *a1;
  if (cva::DictionaryHandler::hasKey(*a1, a2))
  {
    cva::DictionaryHandler::item(&v6, v4, a2);
    cva::ItemHandler::getValue<int>();
  }
  return cva::DictionaryHandler::removeItem(*a1, a2);
}

void sub_1D0E24838(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  a12 = *MEMORY[0x1E4FBA418];
  *(uint64_t *)((char *)&a12 + *(void *)(a12 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  a13 = MEMORY[0x1E4FBA470] + 16;
  if (a26 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1D25F1640](&a29);
  _Unwind_Resume(a1);
}

uint64_t sub_1D0E24944(cva::DictionaryHandler **a1, const char *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  float v4 = *a1;
  if (cva::DictionaryHandler::hasKey(*a1, a2))
  {
    cva::DictionaryHandler::item(&v6, v4, a2);
    cva::ItemHandler::getValue<float>();
  }
  return cva::DictionaryHandler::removeItem(*a1, a2);
}

void sub_1D0E24D64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  a12 = *MEMORY[0x1E4FBA418];
  *(uint64_t *)((char *)&a12 + *(void *)(a12 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  a13 = MEMORY[0x1E4FBA470] + 16;
  if (a26 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1D25F1640](&a29);
  _Unwind_Resume(a1);
}

uint64_t sub_1D0E24E70(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA498] + 64;
  *(void *)(a1 + 112) = MEMORY[0x1E4FBA498] + 64;
  uint64_t v3 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v3;
  CFDictionaryRef v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v5, (void *)(a1 + 8));
  uint64_t v6 = MEMORY[0x1E4FBA498] + 24;
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  *(void *)a1 = v6;
  *(void *)(a1 + 112) = v2;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1D0E24FE0(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x1D25F1640](v1);
  _Unwind_Resume(a1);
}

void *sub_1D0E25008(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x1D25F13D0](v24, a1);
  if (v24[0])
  {
    uint64_t v6 = (char *)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *((void *)v6 + 5);
    int v8 = *((_DWORD *)v6 + 2);
    int v9 = *((_DWORD *)v6 + 36);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      long long v10 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&__b);
      *((_DWORD *)v6 + 36) = v9;
    }
    uint64_t v11 = a2 + a3;
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v12 = a2 + a3;
    }
    else {
      uint64_t v12 = a2;
    }
    if (!v7) {
      goto LABEL_30;
    }
    uint64_t v13 = *((void *)v6 + 3);
    BOOL v14 = v13 <= a3;
    uint64_t v15 = v13 - a3;
    size_t v16 = v14 ? 0 : v15;
    if (v12 - a2 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, a2, v12 - a2) != v12 - a2)
    {
      goto LABEL_30;
    }
    if ((uint64_t)v16 >= 1)
    {
      if (v16 >= 0x7FFFFFFFFFFFFFF8) {
        abort();
      }
      if (v16 >= 0x17)
      {
        uint64_t v18 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v16 | 7) != 0x17) {
          uint64_t v18 = v16 | 7;
        }
        uint64_t v19 = v18 + 1;
        p_b = (std::locale::__imp *)operator new(v18 + 1);
        size_t v26 = v16;
        int64_t v27 = v19 | 0x8000000000000000;
        __b.__locale_ = p_b;
      }
      else
      {
        HIBYTE(v27) = v16;
        p_b = (std::locale::__imp *)&__b;
      }
      memset(p_b, v9, v16);
      *((unsigned char *)p_b + v16) = 0;
      if (v27 >= 0) {
        locale = &__b;
      }
      else {
        locale = __b.__locale_;
      }
      uint64_t v21 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v7 + 96))(v7, locale, v16);
      uint64_t v22 = v21;
      if (SHIBYTE(v27) < 0)
      {
        operator delete(__b.__locale_);
        if (v22 != v16)
        {
LABEL_30:
          std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
          goto LABEL_31;
        }
      }
      else if (v21 != v16)
      {
        goto LABEL_30;
      }
    }
    if (v11 - v12 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, v12, v11 - v12) != v11 - v12)
    {
      goto LABEL_30;
    }
    *((void *)v6 + 3) = 0;
  }
LABEL_31:
  MEMORY[0x1D25F13E0](v24);
  return a1;
}

void sub_1D0E252B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  MEMORY[0x1D25F13E0](&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1D0E252F0(void *a1, cva::DictionaryHandler *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  sub_1D0E533F8(&__p, "resources_facekit/");
  std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    CFDictionaryRef v5 = operator new(0x28uLL);
    v5[1] = 0;
    v5[2] = 0;
    *CFDictionaryRef v5 = &unk_1F26F4B80;
    uint64_t v6 = (cva::DictionaryHandler *)(v5 + 3);
    cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)(v5 + 3));
    if (cva::DictionaryHandler::hasKey(a2, @"legacy_blendshape_names"))
    {
      cva::DictionaryHandler::item((uint64_t *)buf, a2, @"legacy_blendshape_names");
      cva::ItemHandler::getValue<BOOL>();
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F16B8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F16B8))
    {
      sub_1D0E2CB50();
      __cxa_guard_release(&qword_1EB9F16B8);
    }
    uint64_t v7 = *(std::__shared_weak_count **)algn_1EB9F16C8;
    if (*(void *)algn_1EB9F16C8)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)algn_1EB9F16C8 + 8), 1uLL, memory_order_relaxed);
      cva::ItemHandler::ItemHandler();
      cva::DictionaryHandler::setItem(v6, @"blendshape_names", (const cva::ItemHandler *)buf);
      cva::ItemHandler::~ItemHandler((cva::ItemHandler *)buf);
      if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    else
    {
      cva::ItemHandler::ItemHandler();
      cva::DictionaryHandler::setItem(v6, @"blendshape_names", (const cva::ItemHandler *)buf);
      cva::ItemHandler::~ItemHandler((cva::ItemHandler *)buf);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F16B0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F16B0))
    {
      sub_1D0E2F470(buf);
    }
    int v8 = (std::__shared_weak_count *)qword_1EB9F16D8;
    if (qword_1EB9F16D8)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_1EB9F16D8 + 8), 1uLL, memory_order_relaxed);
      cva::ItemHandler::ItemHandler();
      cva::DictionaryHandler::setItem(v6, @"landmark_names", (const cva::ItemHandler *)buf);
      cva::ItemHandler::~ItemHandler((cva::ItemHandler *)buf);
      if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    else
    {
      cva::ItemHandler::ItemHandler();
      cva::DictionaryHandler::setItem(v6, @"landmark_names", (const cva::ItemHandler *)buf);
      cva::ItemHandler::~ItemHandler((cva::ItemHandler *)buf);
    }
    if (cva::DictionaryHandler::hasKey(a2, @"add_identity_model_uuid"))
    {
      cva::DictionaryHandler::item((uint64_t *)buf, a2, @"add_identity_model_uuid");
      cva::ItemHandler::getValue<BOOL>();
    }
    if (cva::DictionaryHandler::hasKey(a2, @"add_mesh"))
    {
      cva::DictionaryHandler::item((uint64_t *)buf, a2, @"add_mesh");
      cva::ItemHandler::getValue<BOOL>();
    }
    if (cva::DictionaryHandler::hasKey(a2, @"hole_filled_mesh"))
    {
      cva::DictionaryHandler::item((uint64_t *)buf, a2, @"hole_filled_mesh");
      cva::ItemHandler::getValue<BOOL>();
    }
    cva::DictionaryHandler::hasKey(a2, @"blendshape_activations");
    int v10 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v11 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      size_t v11 = __p.__r_.__value_.__l.__size_;
    }
    unint64_t v12 = v11 + 21;
    if (v11 + 21 > 0x7FFFFFFFFFFFFFF7) {
      abort();
    }
    if (v12 >= 0x17)
    {
      uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v12 | 7) != 0x17) {
        uint64_t v14 = v12 | 7;
      }
      uint64_t v15 = v14 + 1;
      p_vImage_Buffer src = operator new(v14 + 1);
      unint64_t v21 = v15 | 0x8000000000000000;
      __vImage_Buffer src = p_src;
      size_t v20 = v11 + 21;
    }
    else
    {
      unint64_t v21 = 0;
      size_t v20 = 0;
      __vImage_Buffer src = 0;
      p_vImage_Buffer src = &__src;
      HIBYTE(v21) = v11 + 21;
      if (!v11) {
        goto LABEL_41;
      }
    }
    if (v10 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    memmove(p_src, p_p, v11);
LABEL_41:
    strcpy((char *)p_src + v11, "facekit_resources.dat");
    operator new();
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  int v9 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    _os_log_error_impl(&dword_1D0DBD000, v9, OS_LOG_TYPE_ERROR, "cannot find resources", buf, 2u);
  }
  *a1 = 0;
  a1[1] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return kdebug_trace();
}

void sub_1D0E299F8(void *a1, uint64_t a2, int a3, cva::DictionaryHandler *a4)
{
  cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)v377);
  if (*(unsigned char *)(a2 + 24))
  {
    int v8 = *(_DWORD *)(a2 + 16);
    if (!v8) {
      goto LABEL_7;
    }
    int v9 = *(const UInt8 **)a2;
    CFIndex v10 = 12 * v8;
  }
  else
  {
    int v9 = (const UInt8 *)*a1;
    uint64_t v11 = a1[1];
    if (*a1 == v11) {
      goto LABEL_7;
    }
    CFIndex v10 = (v11 - (uint64_t)v9) << 30 >> 30;
  }
  unint64_t v12 = CFDataCreate(0, v9, v10);
  cva::ItemHandler::createData((uint64_t *)v382, v12, v13);
  cva::DictionaryHandler::setItem((cva::DictionaryHandler *)v377, @"mesh_vertices", (const cva::ItemHandler *)v382);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v382);
  CFRelease(v12);
LABEL_7:
  uint64_t v14 = (const UInt8 *)a1[6];
  uint64_t v15 = (const UInt8 *)a1[7];
  if (v14 != v15)
  {
    size_t v16 = CFDataCreate(0, v14, ((v15 - v14) << 30 >> 30) & 0xFFFFFFFFFFFFFFF8);
    cva::ItemHandler::createData((uint64_t *)v382, v16, v17);
    cva::DictionaryHandler::setItem((cva::DictionaryHandler *)v377, @"mesh_texcoords", (const cva::ItemHandler *)v382);
    cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v382);
    CFRelease(v16);
  }
  if (a3)
  {
    a1[7] = a1[6];
    v376 = a1;
    uint64_t v373 = a4;
    if (a1[35])
    {
      unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[13] - a1[12]) >> 2);
      unint64_t v19 = ((uint64_t)(a1[22] - a1[21]) >> 3) + (int)v18;
      if (v19)
      {
        if (v19 >> 60) {
          goto LABEL_463;
        }
        size_t v20 = 2 * v19;
        unint64_t v21 = (std::__shared_weak_count **)operator new(16 * v19);
        bzero(v21, v20 * 8);
        uint64_t v22 = &v21[v20];
      }
      else
      {
        unint64_t v21 = 0;
        uint64_t v22 = 0;
      }
      uint64_t v23 = (void *)a1[33];
      if (v23 != a1 + 34)
      {
        do
        {
          for (uint64_t i = (std::__shared_weak_count **)v23[7]; i != (std::__shared_weak_count **)v23[8]; i += 2)
          {
            float v25 = *i;
            size_t v26 = (int *)(*i)[1].__vftable;
            int64_t v27 = *i;
            if (v26 != (int *)(*i)[1].__shared_owners_)
            {
              do
              {
                uint64_t v28 = *v26;
                float v30 = *i;
                float v29 = i[1];
                if (v29) {
                  atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                float v31 = &v21[2 * v28];
                float v32 = v31[1];
                _DWORD *v31 = v30;
                v31[1] = v29;
                if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
                  std::__shared_weak_count::__release_weak(v32);
                }
                ++v26;
              }
              while (v26 != (int *)v25[1].__shared_owners_);
              int64_t v27 = *i;
            }
            for (uint64_t j = v27->__vftable;
                  j != (std::__shared_weak_count_vtbl *)v27->__shared_owners_;
                  uint64_t j = (std::__shared_weak_count_vtbl *)((char *)j + 4))
            {
              int v34 = (int)j->~__shared_weak_count;
              int v35 = i[1];
              if (v35) {
                atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              int v36 = &v21[4 * v34] + 2 * (int)v18;
              *int v36 = v27;
              unsigned int v37 = v36[1];
              v36[1] = v35;
              if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
                std::__shared_weak_count::__release_weak(v37);
              }
              int v38 = (int)j->~__shared_weak_count;
              int v40 = *i;
              uint64_t v39 = i[1];
              if (v39) {
                atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              int v41 = &v21[4 * v38 + 2] + 2 * (int)v18;
              *int v41 = v40;
              unsigned int v42 = v41[1];
              v41[1] = v39;
              if (v42)
              {
                if (!atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
                  std::__shared_weak_count::__release_weak(v42);
                }
              }
              int64_t v27 = *i;
            }
            v25[1].__shared_owners_ = (uint64_t)v25[1].__vftable;
          }
          int v43 = (void *)v23[1];
          if (v43)
          {
            do
            {
              float v44 = v43;
              int v43 = (void *)*v43;
            }
            while (v43);
          }
          else
          {
            do
            {
              float v44 = (void *)v23[2];
              BOOL v45 = *v44 == (void)v23;
              uint64_t v23 = v44;
            }
            while (!v45);
          }
          uint64_t v23 = v44;
        }
        while (v44 != a1 + 34);
      }
    }
    else
    {
      unint64_t v21 = 0;
      uint64_t v22 = 0;
    }
    int v48 = (char *)a1[12];
    int v47 = (char *)a1[13];
    int v46 = a1 + 12;
    uint64_t v49 = a1[14];
    uint64_t v50 = a1[21];
    uint64_t v51 = a1[22];
    uint64_t v375 = v46;
    unint64_t v52 = 0xAAAAAAAAAAAAAAABLL * ((v47 - v48) >> 2) + ((v51 - v50) >> 3);
    if (0xAAAAAAAAAAAAAAABLL * ((v49 - (uint64_t)v48) >> 2) >= v52)
    {
      int v59 = v376;
    }
    else
    {
      if (v52 > 0x1555555555555555) {
        goto LABEL_463;
      }
      uint64_t v53 = 12 * v52;
      int v54 = (char *)operator new(12 * v52);
      unsigned int v55 = &v54[4 * ((v47 - v48) >> 2)];
      float v56 = v55;
      if (v47 != v48)
      {
        float v56 = &v54[4 * ((v47 - v48) >> 2)];
        do
        {
          uint64_t v57 = *(void *)(v47 - 12);
          v47 -= 12;
          int v58 = *((_DWORD *)v47 + 2);
          *(void *)(v56 - 12) = v57;
          v56 -= 12;
          *((_DWORD *)v56 + 2) = v58;
        }
        while (v47 != v48);
      }
      int v59 = v376;
      v376[12] = v56;
      v376[13] = v55;
      v376[14] = &v54[v53];
      if (v48)
      {
        operator delete(v48);
        uint64_t v50 = v376[21];
        uint64_t v51 = v376[22];
      }
    }
    if (v59[4] != v59[3])
    {
      unsigned int v61 = (char *)v59[15];
      int v60 = (char *)v59[16];
      unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((v60 - v61) >> 2) + ((v51 - v50) >> 3);
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v59[17] - (void)v61) >> 2) >= v62)
      {
        int v59 = v376;
      }
      else
      {
        if (v62 > 0x1555555555555555) {
          goto LABEL_463;
        }
        uint64_t v63 = 12 * v62;
        int v64 = (char *)operator new(12 * v62);
        int v65 = &v64[4 * ((v60 - v61) >> 2)];
        int v66 = v65;
        if (v60 != v61)
        {
          int v66 = &v64[4 * ((v60 - v61) >> 2)];
          do
          {
            uint64_t v67 = *(void *)(v60 - 12);
            v60 -= 12;
            int v68 = *((_DWORD *)v60 + 2);
            *(void *)(v66 - 12) = v67;
            v66 -= 12;
            *((_DWORD *)v66 + 2) = v68;
          }
          while (v60 != v61);
        }
        int v59 = v376;
        v376[15] = v66;
        v376[16] = v65;
        v376[17] = &v64[v63];
        if (v61)
        {
          operator delete(v61);
          uint64_t v50 = v376[21];
          uint64_t v51 = v376[22];
        }
      }
    }
    float v374 = v22;
    if (v59[7] != v59[6])
    {
      int v70 = (char *)v59[18];
      uint64_t v69 = (char *)v59[19];
      unint64_t v71 = 0xAAAAAAAAAAAAAAABLL * ((v69 - v70) >> 2) + ((v51 - v50) >> 3);
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v59[20] - (void)v70) >> 2) >= v71)
      {
        int v59 = v376;
      }
      else
      {
        if (v71 > 0x1555555555555555) {
          goto LABEL_463;
        }
        uint64_t v72 = 12 * v71;
        unsigned int v73 = (char *)operator new(12 * v71);
        uint64_t v74 = &v73[4 * ((v69 - v70) >> 2)];
        uint64_t v75 = v74;
        if (v69 != v70)
        {
          uint64_t v75 = &v73[4 * ((v69 - v70) >> 2)];
          do
          {
            uint64_t v76 = *(void *)(v69 - 12);
            v69 -= 12;
            int v77 = *((_DWORD *)v69 + 2);
            *(void *)(v75 - 12) = v76;
            v75 -= 12;
            *((_DWORD *)v75 + 2) = v77;
          }
          while (v69 != v70);
        }
        int v59 = v376;
        v376[18] = v75;
        v376[19] = v74;
        v376[20] = &v73[v72];
        if (v70)
        {
          operator delete(v70);
          uint64_t v50 = v376[21];
          uint64_t v51 = v376[22];
        }
      }
    }
    if ((int)((unint64_t)(v51 - v50) >> 4) >= 1)
    {
      uint64_t v78 = 0;
      while (1)
      {
        uint64_t v80 = (int *)(v50 + 16 * v78);
        int v81 = *v80;
        int v82 = v80[1];
        int v83 = (float *)(*v59 + 12 * *v80);
        float v84 = v83[1];
        float v85 = v83[2];
        int v87 = v80[2];
        int v86 = v80[3];
        float v88 = (float *)(*v59 + 12 * v87);
        float v89 = *v88 - *v83;
        float v90 = v88[1] - v84;
        float v91 = v88[2] - v85;
        float v92 = (float)((float)((float)(*(float *)(*v59 + 12 * v82) - *v83) * v89)
                    + (float)((float)(*(float *)(*v59 + 12 * v82 + 4) - v84) * v90))
            + (float)((float)(*(float *)(*v59 + 12 * v82 + 8) - v85) * v91);
        float v93 = (float)((float)(v89 * (float)(*(float *)(*v59 + 12 * v86) - *v83))
                    + (float)(v90 * (float)(*(float *)(*v59 + 12 * v86 + 4) - v84)))
            + (float)(v91 * (float)(*(float *)(*v59 + 12 * v86 + 8) - v85));
        if (v92 >= 0.0 && v93 <= 0.0)
        {
          float v95 = (_DWORD *)v59[13];
          unint64_t v94 = v59[14];
LABEL_86:
          if ((unint64_t)v95 >= v94)
          {
            uint64_t v97 = *v375;
            unint64_t v98 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v95 - *v375) >> 2);
            unint64_t v99 = v98 + 1;
            if (v98 + 1 > 0x1555555555555555) {
              goto LABEL_463;
            }
            unint64_t v100 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v94 - v97) >> 2);
            if (2 * v100 > v99) {
              unint64_t v99 = 2 * v100;
            }
            if (v100 >= 0xAAAAAAAAAAAAAAALL) {
              unint64_t v101 = 0x1555555555555555;
            }
            else {
              unint64_t v101 = v99;
            }
            if (v101)
            {
              if (v101 > 0x1555555555555555) {
                goto LABEL_464;
              }
              __float2 v102 = (char *)operator new(12 * v101);
            }
            else
            {
              __float2 v102 = 0;
            }
            float v104 = &v102[12 * v98];
            *(_DWORD *)float v104 = v81;
            *((_DWORD *)v104 + 1) = v82;
            *((_DWORD *)v104 + 2) = v87;
            float v105 = v104;
            if (v95 == (_DWORD *)v97)
            {
              int v59 = v376;
            }
            else
            {
              int v59 = v376;
              do
              {
                uint64_t v106 = *(void *)(v95 - 3);
                v95 -= 3;
                int v107 = v95[2];
                *(void *)(v105 - 12) = v106;
                v105 -= 12;
                *((_DWORD *)v105 + 2) = v107;
              }
              while (v95 != (_DWORD *)v97);
              float v95 = (_DWORD *)*v375;
            }
            float v96 = v104 + 12;
            v59[12] = v105;
            v59[13] = v104 + 12;
            v59[14] = &v102[12 * v101];
            if (v95) {
              operator delete(v95);
            }
          }
          else
          {
            _DWORD *v95 = v81;
            v95[1] = v82;
            float v96 = v95 + 3;
            v95[2] = v87;
          }
          v59[13] = v96;
          float v108 = (int *)(v59[21] + 16 * v78);
          int v109 = *v108;
          int v111 = v108[2];
          int v110 = v108[3];
          unint64_t v112 = v59[14];
          if ((unint64_t)v96 < v112)
          {
            _DWORD *v96 = v109;
            v96[1] = v111;
            int v113 = v96 + 3;
            v96[2] = v110;
            goto LABEL_126;
          }
          float v114 = (_DWORD *)*v375;
          unint64_t v115 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v96 - *v375) >> 2);
          unint64_t v116 = v115 + 1;
          if (v115 + 1 > 0x1555555555555555) {
            goto LABEL_463;
          }
          unint64_t v117 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v112 - (void)v114) >> 2);
          if (2 * v117 > v116) {
            unint64_t v116 = 2 * v117;
          }
          if (v117 >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v118 = 0x1555555555555555;
          }
          else {
            unint64_t v118 = v116;
          }
          if (v118)
          {
            if (v118 > 0x1555555555555555) {
              goto LABEL_464;
            }
            int v119 = (char *)operator new(12 * v118);
          }
          else
          {
            int v119 = 0;
          }
          uint64_t v120 = &v119[12 * v115];
          uint64_t v121 = &v119[12 * v118];
          *(_DWORD *)uint64_t v120 = v109;
          *((_DWORD *)v120 + 1) = v111;
          *((_DWORD *)v120 + 2) = v110;
          int v113 = v120 + 12;
          if (v96 == v114)
          {
            int v59 = v376;
            v376[12] = v120;
            v376[13] = v113;
            v376[14] = v121;
          }
          else
          {
            int v59 = v376;
            do
            {
              uint64_t v122 = *(void *)(v96 - 3);
              v96 -= 3;
              int v123 = v96[2];
              *(void *)(v120 - 12) = v122;
              v120 -= 12;
              *((_DWORD *)v120 + 2) = v123;
            }
            while (v96 != v114);
            float v96 = (_DWORD *)v376[12];
            v376[12] = v120;
            v376[13] = v113;
            v376[14] = v121;
            if (!v96)
            {
LABEL_126:
              v59[13] = v113;
              if (v59[4] == v59[3]) {
                goto LABEL_175;
              }
              float v124 = (int *)(v59[24] + 16 * v78);
              int v126 = *v124;
              int v125 = v124[1];
              int v127 = v124[2];
              float v129 = (_DWORD *)v59[16];
              unint64_t v128 = v59[17];
              if ((unint64_t)v129 >= v128)
              {
                double v131 = (_DWORD *)v59[15];
                unint64_t v132 = 0xAAAAAAAAAAAAAAABLL * (v129 - v131) + 1;
                if (v132 > 0x1555555555555555) {
                  goto LABEL_463;
                }
                unint64_t v133 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v128 - (void)v131) >> 2);
                if (2 * v133 > v132) {
                  unint64_t v132 = 2 * v133;
                }
                if (v133 >= 0xAAAAAAAAAAAAAAALL) {
                  unint64_t v134 = 0x1555555555555555;
                }
                else {
                  unint64_t v134 = v132;
                }
                if (v134)
                {
                  if (v134 > 0x1555555555555555) {
                    goto LABEL_464;
                  }
                  float v135 = (char *)operator new(12 * v134);
                }
                else
                {
                  float v135 = 0;
                }
                float v142 = &v135[4 * (v129 - v131)];
                *(_DWORD *)float v142 = v126;
                *((_DWORD *)v142 + 1) = v125;
                *((_DWORD *)v142 + 2) = v127;
                float32x2_t v143 = v142;
                if (v129 == v131)
                {
                  int v59 = v376;
                }
                else
                {
                  int v59 = v376;
                  do
                  {
                    uint64_t v144 = *(void *)(v129 - 3);
                    v129 -= 3;
                    int v145 = v129[2];
                    *(void *)(v143 - 12) = v144;
                    v143 -= 12;
                    *((_DWORD *)v143 + 2) = v145;
                  }
                  while (v129 != v131);
                  float v129 = (_DWORD *)v376[15];
                }
                float v130 = v142 + 12;
                v59[15] = v143;
                v59[16] = v142 + 12;
                v59[17] = &v135[12 * v134];
                if (v129) {
                  operator delete(v129);
                }
              }
              else
              {
                *float v129 = v126;
                v129[1] = v125;
                float v130 = v129 + 3;
                v129[2] = v127;
              }
              v59[16] = v130;
              float v146 = (int *)(v59[24] + 16 * v78);
              int v147 = *v146;
              int v149 = v146[2];
              int v148 = v146[3];
              unint64_t v150 = v59[17];
              if ((unint64_t)v130 < v150)
              {
                _DWORD *v130 = v147;
                v130[1] = v149;
                unsigned int v151 = v130 + 3;
                v130[2] = v148;
                goto LABEL_174;
              }
              long long v152 = (_DWORD *)v59[15];
              unint64_t v153 = 0xAAAAAAAAAAAAAAABLL * (v130 - v152) + 1;
              if (v153 > 0x1555555555555555) {
                goto LABEL_463;
              }
              unint64_t v154 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v150 - (void)v152) >> 2);
              if (2 * v154 > v153) {
                unint64_t v153 = 2 * v154;
              }
              if (v154 >= 0xAAAAAAAAAAAAAAALL) {
                unint64_t v155 = 0x1555555555555555;
              }
              else {
                unint64_t v155 = v153;
              }
              if (v155)
              {
                if (v155 > 0x1555555555555555) {
                  goto LABEL_464;
                }
                float32x2_t v156 = (char *)operator new(12 * v155);
              }
              else
              {
                float32x2_t v156 = 0;
              }
              int32x4_t v157 = &v156[4 * (v130 - v152)];
              float v158 = &v156[12 * v155];
              *(_DWORD *)int32x4_t v157 = v147;
              *((_DWORD *)v157 + 1) = v149;
              *((_DWORD *)v157 + 2) = v148;
              unsigned int v151 = v157 + 12;
              if (v130 == v152)
              {
                int v59 = v376;
                v376[15] = v157;
                v376[16] = v151;
                v376[17] = v158;
              }
              else
              {
                int v59 = v376;
                do
                {
                  uint64_t v159 = *(void *)(v130 - 3);
                  v130 -= 3;
                  int v160 = v130[2];
                  *(void *)(v157 - 12) = v159;
                  v157 -= 12;
                  *((_DWORD *)v157 + 2) = v160;
                }
                while (v130 != v152);
                float v130 = (_DWORD *)v376[15];
                v376[15] = v157;
                v376[16] = v151;
                v376[17] = v158;
                if (!v130)
                {
LABEL_174:
                  v59[16] = v151;
LABEL_175:
                  if (v59[7] == v59[6]) {
                    goto LABEL_80;
                  }
                  long long v161 = (int *)(v59[27] + 16 * v78);
                  int v163 = *v161;
                  int v162 = v161[1];
                  int v164 = v161[2];
                  int32x2_t v166 = (_DWORD *)v59[19];
                  unint64_t v165 = v59[20];
                  if ((unint64_t)v166 >= v165)
                  {
                    float64x2_t v168 = (_DWORD *)v59[18];
                    unint64_t v169 = 0xAAAAAAAAAAAAAAABLL * (v166 - v168) + 1;
                    if (v169 > 0x1555555555555555) {
                      goto LABEL_463;
                    }
                    unint64_t v170 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v165 - (void)v168) >> 2);
                    if (2 * v170 > v169) {
                      unint64_t v169 = 2 * v170;
                    }
                    if (v170 >= 0xAAAAAAAAAAAAAAALL) {
                      unint64_t v171 = 0x1555555555555555;
                    }
                    else {
                      unint64_t v171 = v169;
                    }
                    if (v171)
                    {
                      if (v171 > 0x1555555555555555) {
                        goto LABEL_464;
                      }
                      float v172 = (char *)operator new(12 * v171);
                    }
                    else
                    {
                      float v172 = 0;
                    }
                    BOOL v173 = &v172[4 * (v166 - v168)];
                    *(_DWORD *)BOOL v173 = v163;
                    *((_DWORD *)v173 + 1) = v162;
                    *((_DWORD *)v173 + 2) = v164;
                    float v174 = v173;
                    if (v166 == v168)
                    {
                      int v59 = v376;
                    }
                    else
                    {
                      int v59 = v376;
                      do
                      {
                        uint64_t v175 = *(void *)(v166 - 3);
                        v166 -= 3;
                        int v176 = v166[2];
                        *(void *)(v174 - 12) = v175;
                        v174 -= 12;
                        *((_DWORD *)v174 + 2) = v176;
                      }
                      while (v166 != v168);
                      int32x2_t v166 = (_DWORD *)v376[18];
                    }
                    int8x16_t v167 = v173 + 12;
                    v59[18] = v174;
                    v59[19] = v173 + 12;
                    v59[20] = &v172[12 * v171];
                    if (v166) {
                      operator delete(v166);
                    }
                  }
                  else
                  {
                    *int32x2_t v166 = v163;
                    v166[1] = v162;
                    int8x16_t v167 = v166 + 3;
                    v166[2] = v164;
                  }
                  v59[19] = v167;
                  float32x2_t v177 = (int *)(v59[27] + 16 * v78);
                  int v178 = *v177;
                  int v179 = v177[2];
                  int v180 = v177[3];
                  unint64_t v181 = v59[20];
                  if ((unint64_t)v167 >= v181)
                  {
                    unint64_t v182 = (_DWORD *)v59[18];
                    unint64_t v183 = 0xAAAAAAAAAAAAAAABLL * (v167 - v182) + 1;
                    if (v183 > 0x1555555555555555) {
                      goto LABEL_463;
                    }
                    unint64_t v184 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v181 - (void)v182) >> 2);
                    if (2 * v184 > v183) {
                      unint64_t v183 = 2 * v184;
                    }
                    if (v184 >= 0xAAAAAAAAAAAAAAALL) {
                      unint64_t v185 = 0x1555555555555555;
                    }
                    else {
                      unint64_t v185 = v183;
                    }
                    if (v185)
                    {
                      if (v185 > 0x1555555555555555) {
                        goto LABEL_464;
                      }
                      unint64_t v186 = (char *)operator new(12 * v185);
                    }
                    else
                    {
                      unint64_t v186 = 0;
                    }
                    uint64_t v187 = &v186[4 * (v167 - v182)];
                    uint64_t v188 = &v186[12 * v185];
                    *(_DWORD *)uint64_t v187 = v178;
                    *((_DWORD *)v187 + 1) = v179;
                    *((_DWORD *)v187 + 2) = v180;
                    unsigned int v79 = v187 + 12;
                    if (v167 != v182)
                    {
                      int v59 = v376;
                      do
                      {
                        uint64_t v189 = *(void *)(v167 - 3);
                        v167 -= 3;
                        int v190 = v167[2];
                        *(void *)(v187 - 12) = v189;
                        v187 -= 12;
                        *((_DWORD *)v187 + 2) = v190;
                      }
                      while (v167 != v182);
LABEL_311:
                      int8x16_t v167 = (_DWORD *)v59[18];
                      v59[18] = v187;
                      v59[19] = v79;
                      v59[20] = v188;
                      if (!v167) {
                        goto LABEL_79;
                      }
LABEL_314:
                      operator delete(v167);
                      goto LABEL_79;
                    }
LABEL_313:
                    int v59 = v376;
                    v376[18] = v187;
                    v376[19] = v79;
                    v376[20] = v188;
                    goto LABEL_314;
                  }
                  goto LABEL_78;
                }
              }
              operator delete(v130);
              goto LABEL_174;
            }
          }
          operator delete(v96);
          goto LABEL_126;
        }
        float v95 = (_DWORD *)v59[13];
        unint64_t v94 = v59[14];
        if (v92 <= 0.0 && v93 >= 0.0) {
          goto LABEL_86;
        }
        if ((unint64_t)v95 >= v94)
        {
          float v136 = (_DWORD *)*v375;
          unint64_t v137 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v95 - *v375) >> 2);
          unint64_t v138 = v137 + 1;
          if (v137 + 1 > 0x1555555555555555) {
            goto LABEL_463;
          }
          unint64_t v139 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v94 - (void)v136) >> 2);
          if (2 * v139 > v138) {
            unint64_t v138 = 2 * v139;
          }
          if (v139 >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v140 = 0x1555555555555555;
          }
          else {
            unint64_t v140 = v138;
          }
          if (v140)
          {
            if (v140 > 0x1555555555555555) {
              goto LABEL_464;
            }
            float v141 = (char *)operator new(12 * v140);
          }
          else
          {
            float v141 = 0;
          }
          float v191 = &v141[12 * v137];
          *(_DWORD *)float v191 = v81;
          *((_DWORD *)v191 + 1) = v82;
          *((_DWORD *)v191 + 2) = v86;
          float v192 = v191;
          if (v95 == v136)
          {
            int v59 = v376;
          }
          else
          {
            int v59 = v376;
            do
            {
              uint64_t v193 = *(void *)(v95 - 3);
              v95 -= 3;
              int v194 = v95[2];
              *(void *)(v192 - 12) = v193;
              v192 -= 12;
              *((_DWORD *)v192 + 2) = v194;
            }
            while (v95 != v136);
            float v95 = (_DWORD *)*v375;
          }
          float v103 = v191 + 12;
          v59[12] = v192;
          v59[13] = v191 + 12;
          v59[14] = &v141[12 * v140];
          if (v95) {
            operator delete(v95);
          }
        }
        else
        {
          _DWORD *v95 = v81;
          v95[1] = v82;
          float v103 = v95 + 3;
          v95[2] = v86;
        }
        v59[13] = v103;
        uint64_t v195 = (_DWORD *)(v59[21] + 16 * v78);
        int v197 = v195[1];
        int v196 = v195[2];
        int v198 = v195[3];
        unint64_t v199 = v59[14];
        if ((unint64_t)v103 < v199)
        {
          *float v103 = v197;
          v103[1] = v196;
          int v200 = v103 + 3;
          v103[2] = v198;
          goto LABEL_237;
        }
        int v201 = (_DWORD *)*v375;
        unint64_t v202 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v103 - *v375) >> 2);
        unint64_t v203 = v202 + 1;
        if (v202 + 1 > 0x1555555555555555) {
          goto LABEL_463;
        }
        unint64_t v204 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v199 - (void)v201) >> 2);
        if (2 * v204 > v203) {
          unint64_t v203 = 2 * v204;
        }
        unint64_t v205 = v204 >= 0xAAAAAAAAAAAAAAALL ? 0x1555555555555555 : v203;
        if (v205)
        {
          if (v205 > 0x1555555555555555) {
            goto LABEL_464;
          }
          long long v206 = (char *)operator new(12 * v205);
        }
        else
        {
          long long v206 = 0;
        }
        unsigned int v207 = &v206[12 * v202];
        int32x4_t v208 = &v206[12 * v205];
        *(_DWORD *)unsigned int v207 = v197;
        *((_DWORD *)v207 + 1) = v196;
        *((_DWORD *)v207 + 2) = v198;
        int v200 = v207 + 12;
        if (v103 == v201) {
          break;
        }
        int v59 = v376;
        do
        {
          uint64_t v209 = *(void *)(v103 - 3);
          v103 -= 3;
          int v210 = v103[2];
          *(void *)(v207 - 12) = v209;
          v207 -= 12;
          *((_DWORD *)v207 + 2) = v210;
        }
        while (v103 != v201);
        float v103 = (_DWORD *)v376[12];
        v376[12] = v207;
        v376[13] = v200;
        v376[14] = v208;
        if (v103) {
          goto LABEL_236;
        }
LABEL_237:
        v59[13] = v200;
        if (v59[4] == v59[3]) {
          goto LABEL_277;
        }
        uint64_t v211 = (int *)(v59[24] + 16 * v78);
        int v213 = *v211;
        int v212 = v211[1];
        int v214 = v211[3];
        __int32 v216 = (_DWORD *)v59[16];
        unint64_t v215 = v59[17];
        if ((unint64_t)v216 >= v215)
        {
          float v218 = (_DWORD *)v59[15];
          unint64_t v219 = 0xAAAAAAAAAAAAAAABLL * (v216 - v218) + 1;
          if (v219 > 0x1555555555555555) {
            goto LABEL_463;
          }
          unint64_t v220 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v215 - (void)v218) >> 2);
          if (2 * v220 > v219) {
            unint64_t v219 = 2 * v220;
          }
          if (v220 >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v221 = 0x1555555555555555;
          }
          else {
            unint64_t v221 = v219;
          }
          if (v221)
          {
            if (v221 > 0x1555555555555555) {
              goto LABEL_464;
            }
            int32x2_t v222 = (char *)operator new(12 * v221);
          }
          else
          {
            int32x2_t v222 = 0;
          }
          uint64_t v223 = &v222[4 * (v216 - v218)];
          *(_DWORD *)uint64_t v223 = v213;
          *((_DWORD *)v223 + 1) = v212;
          *((_DWORD *)v223 + 2) = v214;
          int32x2_t v224 = v223;
          if (v216 == v218)
          {
            int v59 = v376;
          }
          else
          {
            int v59 = v376;
            do
            {
              uint64_t v225 = *(void *)(v216 - 3);
              v216 -= 3;
              int v226 = v216[2];
              *(void *)(v224 - 12) = v225;
              v224 -= 12;
              *((_DWORD *)v224 + 2) = v226;
            }
            while (v216 != v218);
            __int32 v216 = (_DWORD *)v376[15];
          }
          uint64_t v217 = v223 + 12;
          v59[15] = v224;
          v59[16] = v223 + 12;
          v59[17] = &v222[12 * v221];
          if (v216) {
            operator delete(v216);
          }
        }
        else
        {
          *__int32 v216 = v213;
          v216[1] = v212;
          uint64_t v217 = v216 + 3;
          v216[2] = v214;
        }
        v59[16] = v217;
        int v227 = (_DWORD *)(v59[24] + 16 * v78);
        int v229 = v227[1];
        int v228 = v227[2];
        int v230 = v227[3];
        unint64_t v231 = v59[17];
        if ((unint64_t)v217 >= v231)
        {
          float v233 = (_DWORD *)v59[15];
          unint64_t v234 = 0xAAAAAAAAAAAAAAABLL * (v217 - v233) + 1;
          if (v234 > 0x1555555555555555) {
            goto LABEL_463;
          }
          unint64_t v235 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v231 - (void)v233) >> 2);
          if (2 * v235 > v234) {
            unint64_t v234 = 2 * v235;
          }
          if (v235 >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v236 = 0x1555555555555555;
          }
          else {
            unint64_t v236 = v234;
          }
          if (v236)
          {
            if (v236 > 0x1555555555555555) {
              goto LABEL_464;
            }
            unint64_t v237 = (char *)operator new(12 * v236);
          }
          else
          {
            unint64_t v237 = 0;
          }
          int v238 = &v237[4 * (v217 - v233)];
          int v239 = &v237[12 * v236];
          *(_DWORD *)int v238 = v229;
          *((_DWORD *)v238 + 1) = v228;
          *((_DWORD *)v238 + 2) = v230;
          uint64_t v232 = v238 + 12;
          if (v217 == v233)
          {
            int v59 = v376;
            v376[15] = v238;
            v376[16] = v232;
            v376[17] = v239;
          }
          else
          {
            int v59 = v376;
            do
            {
              uint64_t v240 = *(void *)(v217 - 3);
              v217 -= 3;
              int v241 = v217[2];
              *(void *)(v238 - 12) = v240;
              v238 -= 12;
              *((_DWORD *)v238 + 2) = v241;
            }
            while (v217 != v233);
            uint64_t v217 = (_DWORD *)v376[15];
            v376[15] = v238;
            v376[16] = v232;
            v376[17] = v239;
            if (!v217) {
              goto LABEL_276;
            }
          }
          operator delete(v217);
        }
        else
        {
          *uint64_t v217 = v229;
          v217[1] = v228;
          uint64_t v232 = v217 + 3;
          v217[2] = v230;
        }
LABEL_276:
        v59[16] = v232;
LABEL_277:
        if (v59[7] == v59[6]) {
          goto LABEL_80;
        }
        int v242 = (int *)(v59[27] + 16 * v78);
        int v244 = *v242;
        int v243 = v242[1];
        int v245 = v242[3];
        int v247 = (_DWORD *)v59[19];
        unint64_t v246 = v59[20];
        if ((unint64_t)v247 >= v246)
        {
          uint64_t v248 = (_DWORD *)v59[18];
          unint64_t v249 = 0xAAAAAAAAAAAAAAABLL * (v247 - v248) + 1;
          if (v249 > 0x1555555555555555) {
            goto LABEL_463;
          }
          unint64_t v250 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v246 - (void)v248) >> 2);
          if (2 * v250 > v249) {
            unint64_t v249 = 2 * v250;
          }
          if (v250 >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v251 = 0x1555555555555555;
          }
          else {
            unint64_t v251 = v249;
          }
          if (v251)
          {
            if (v251 > 0x1555555555555555) {
              goto LABEL_464;
            }
            int8x16_t v252 = (char *)operator new(12 * v251);
          }
          else
          {
            int8x16_t v252 = 0;
          }
          uint64_t v253 = &v252[4 * (v247 - v248)];
          *(_DWORD *)uint64_t v253 = v244;
          *((_DWORD *)v253 + 1) = v243;
          *((_DWORD *)v253 + 2) = v245;
          unint64_t v254 = v253;
          if (v247 == v248)
          {
            int v59 = v376;
          }
          else
          {
            int v59 = v376;
            do
            {
              uint64_t v255 = *(void *)(v247 - 3);
              v247 -= 3;
              int v256 = v247[2];
              *(void *)(v254 - 12) = v255;
              v254 -= 12;
              *((_DWORD *)v254 + 2) = v256;
            }
            while (v247 != v248);
            int v247 = (_DWORD *)v376[18];
          }
          int8x16_t v167 = v253 + 12;
          v59[18] = v254;
          v59[19] = v253 + 12;
          v59[20] = &v252[12 * v251];
          if (v247) {
            operator delete(v247);
          }
        }
        else
        {
          *int v247 = v244;
          v247[1] = v243;
          int8x16_t v167 = v247 + 3;
          v247[2] = v245;
        }
        v59[19] = v167;
        float v257 = (_DWORD *)(v59[27] + 16 * v78);
        int v178 = v257[1];
        int v179 = v257[2];
        int v180 = v257[3];
        unint64_t v258 = v59[20];
        if ((unint64_t)v167 >= v258)
        {
          int v259 = (_DWORD *)v59[18];
          unint64_t v260 = 0xAAAAAAAAAAAAAAABLL * (v167 - v259) + 1;
          if (v260 > 0x1555555555555555) {
            goto LABEL_463;
          }
          unint64_t v261 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v258 - (void)v259) >> 2);
          if (2 * v261 > v260) {
            unint64_t v260 = 2 * v261;
          }
          if (v261 >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v262 = 0x1555555555555555;
          }
          else {
            unint64_t v262 = v260;
          }
          if (v262)
          {
            if (v262 > 0x1555555555555555) {
LABEL_464:
            }
              sub_1D0DE8CE0();
            uint64_t v263 = (char *)operator new(12 * v262);
          }
          else
          {
            uint64_t v263 = 0;
          }
          uint64_t v187 = &v263[4 * (v167 - v259)];
          uint64_t v188 = &v263[12 * v262];
          *(_DWORD *)uint64_t v187 = v178;
          *((_DWORD *)v187 + 1) = v179;
          *((_DWORD *)v187 + 2) = v180;
          unsigned int v79 = v187 + 12;
          if (v167 != v259)
          {
            int v59 = v376;
            do
            {
              uint64_t v264 = *(void *)(v167 - 3);
              v167 -= 3;
              int v265 = v167[2];
              *(void *)(v187 - 12) = v264;
              v187 -= 12;
              *((_DWORD *)v187 + 2) = v265;
            }
            while (v167 != v259);
            goto LABEL_311;
          }
          goto LABEL_313;
        }
LABEL_78:
        *int8x16_t v167 = v178;
        v167[1] = v179;
        unsigned int v79 = v167 + 3;
        v167[2] = v180;
LABEL_79:
        v59[19] = v79;
LABEL_80:
        ++v78;
        uint64_t v50 = v59[21];
        if (v78 >= (int)((unint64_t)(v59[22] - v50) >> 4)) {
          goto LABEL_315;
        }
      }
      int v59 = v376;
      v376[12] = v207;
      v376[13] = v200;
      v376[14] = v208;
LABEL_236:
      operator delete(v103);
      goto LABEL_237;
    }
LABEL_315:
    uint64_t v383 = 0;
    unsigned int v384 = 0;
    uint64_t v385 = 0;
    unint64_t v266 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v59[13] - v59[12]) >> 2);
    if (0xAAAAAAAB00000000 * ((uint64_t)(v59[13] - v59[12]) >> 2))
    {
      sub_1D0E663D8((uint64_t)&v383, (int)(-1431655765 * ((uint64_t)(v59[13] - v59[12]) >> 2)));
      uint64_t v267 = v383;
      if ((int)v266 < 1) {
        goto LABEL_325;
      }
    }
    else
    {
      uint64_t v267 = 0;
      if ((int)v266 < 1) {
        goto LABEL_325;
      }
    }
    if (v266 >= 8uLL)
    {
      unint64_t v268 = v266 - (v266 & 7);
      int32x4_t v269 = (int32x4_t)xmmword_1D0E814F0;
      uint64_t v270 = (int32x4_t *)(v267 + 4);
      v271.i64[0] = 0x400000004;
      v271.i64[1] = 0x400000004;
      v272.i64[0] = 0x800000008;
      v272.i64[1] = 0x800000008;
      unint64_t v273 = v268;
      do
      {
        v270[-1] = v269;
        *uint64_t v270 = vaddq_s32(v269, v271);
        int32x4_t v269 = vaddq_s32(v269, v272);
        v270 += 2;
        v273 -= 8;
      }
      while (v273);
      if ((v266 & 7) == 0) {
        goto LABEL_325;
      }
    }
    else
    {
      unint64_t v268 = 0;
    }
    do
    {
      v267[v268] = v268;
      ++v268;
    }
    while (v266 != v268);
LABEL_325:
    int v274 = v384;
    unint64_t v275 = v384 - v267;
    unint64_t v276 = 126 - 2 * __clz(v275);
    v382[0] = v375;
    v382[1] = &v380;
    if (v384 == v267) {
      uint64_t v277 = 0;
    }
    else {
      uint64_t v277 = v276;
    }
    sub_1D0E66588((uint64_t)v267, v384, v382, v277, 1);
    float32x2_t v278 = v59;
    uint64_t v279 = (unsigned char *)v59[12];
    __float2 v280 = (unsigned char *)v278[13];
    int64_t v281 = v280 - v279;
    if (v280 == v279)
    {
      uint64_t v282 = 0;
    }
    else
    {
      if (0xAAAAAAAAAAAAAAABLL * (v281 >> 2) > 0x1555555555555555) {
        goto LABEL_463;
      }
      uint64_t v282 = (char *)operator new(v281);
      memcpy(v282, v279, 12 * ((v281 - 12) / 0xCuLL) + 12);
    }
    long long v283 = v376;
    uint64_t v284 = v374;
    if (v274 != v267)
    {
      uint64_t v285 = 0;
      unint64_t v286 = 0;
      do
      {
        int v288 = &v282[12 * v267[v286]];
        uint64_t v289 = *v375 + v285;
        if ((char *)v289 != v288)
        {
          uint64_t v287 = *(void *)v288;
          *(_DWORD *)(v289 + 8) = *((_DWORD *)v288 + 2);
          *(void *)uint64_t v289 = v287;
        }
        ++v286;
        v285 += 12;
      }
      while (v286 < v274 - v267);
    }
    if (v282) {
      operator delete(v282);
    }
    if (v376[4] != v376[3])
    {
      int v291 = (unsigned char *)v376[15];
      float32x4_t v290 = (unsigned char *)v376[16];
      int64_t v292 = v290 - v291;
      if (v290 == v291)
      {
        int v293 = 0;
      }
      else
      {
        if (0xAAAAAAAAAAAAAAABLL * (v292 >> 2) > 0x1555555555555555) {
          goto LABEL_463;
        }
        int v293 = (char *)operator new(v292);
        memcpy(v293, v291, 12 * ((v292 - 12) / 0xCuLL) + 12);
      }
      long long v283 = v376;
      uint64_t v284 = v374;
      if (v274 != v267)
      {
        uint64_t v294 = 0;
        unint64_t v295 = 0;
        do
        {
          float v297 = &v293[12 * v267[v295]];
          uint64_t v298 = v376[15] + v294;
          if ((char *)v298 != v297)
          {
            uint64_t v296 = *(void *)v297;
            *(_DWORD *)(v298 + 8) = *((_DWORD *)v297 + 2);
            *(void *)uint64_t v298 = v296;
          }
          ++v295;
          v294 += 12;
        }
        while (v295 < v274 - v267);
      }
      if (v293) {
        operator delete(v293);
      }
    }
    if (v283[7] != v283[6])
    {
      float v300 = (unsigned char *)v283[18];
      float v299 = (unsigned char *)v283[19];
      int64_t v301 = v299 - v300;
      if (v299 == v300)
      {
        unint64_t v302 = 0;
      }
      else
      {
        if (0xAAAAAAAAAAAAAAABLL * (v301 >> 2) > 0x1555555555555555) {
          goto LABEL_463;
        }
        unint64_t v302 = (char *)operator new(v301);
        memcpy(v302, v300, 12 * ((v301 - 12) / 0xCuLL) + 12);
      }
      long long v283 = v376;
      uint64_t v284 = v374;
      if (v274 != v267)
      {
        uint64_t v303 = 0;
        unint64_t v304 = 0;
        do
        {
          uint64_t v306 = &v302[12 * v267[v304]];
          uint64_t v307 = v376[18] + v303;
          if ((char *)v307 != v306)
          {
            uint64_t v305 = *(void *)v306;
            *(_DWORD *)(v307 + 8) = *((_DWORD *)v306 + 2);
            *(void *)uint64_t v307 = v305;
          }
          ++v304;
          v303 += 12;
        }
        while (v304 < v274 - v267);
      }
      if (v302) {
        operator delete(v302);
      }
    }
    if (!v283[35]) {
      goto LABEL_428;
    }
    unint64_t v308 = (char *)v284 - (char *)v21;
    uint64_t v309 = ((char *)v284 - (char *)v21) >> 4;
    if (v309 != 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v376[13] - v376[12]) >> 2))
    {
      sub_1D0E5C8F8(&v380);
      sub_1D0E5E098((uint64_t)v382, &v380, 0, 0, "[RELEASE ERROR  ]", "/Library/Caches/com.apple.xbs/Sources/AppleCVA/shared/src/modules/avatar/shrek/libs/alg/geometry/src/three_d/quad_mesh.cpp", 1047, "assert %s failed. triangle_to_part.size() != m_tris_vi.size()%s", (char)"triangle_to_part.size() == m_tris_vi.size()");
      sub_1D0E6054C((uint64_t)v382);
      long long v310 = v381;
      if (v381 && !atomic_fetch_add(&v381->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v310->__on_zero_shared)(v310);
        std::__shared_weak_count::__release_weak(v310);
      }
      unint64_t v275 = v384 - v383;
    }
    if (v309 != v275)
    {
      sub_1D0E5C8F8(&v378);
      sub_1D0E5E098((uint64_t)&v380, &v378, 0, 0, "[RELEASE ERROR  ]", "/Library/Caches/com.apple.xbs/Sources/AppleCVA/shared/src/modules/avatar/shrek/libs/alg/geometry/src/three_d/quad_mesh.cpp", 1048, "assert %s failed. triangle_to_part .size() != order.size()%s", (char)"triangle_to_part.size() == order.size()");
      sub_1D0E6054C((uint64_t)&v380);
      int v311 = v379;
      if (v379)
      {
        if (!atomic_fetch_add(&v379->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v311->__on_zero_shared)(v311);
          std::__shared_weak_count::__release_weak(v311);
        }
      }
    }
    if (v284 == v21)
    {
      int v319 = v383;
      if (v384 == v383) {
        goto LABEL_401;
      }
      BOOL v318 = 0;
      float32x2_t v313 = 0;
      goto LABEL_387;
    }
    if ((v308 & 0x8000000000000000) == 0)
    {
      uint64_t v312 = (char *)operator new((char *)v284 - (char *)v21);
      float32x2_t v313 = v312;
      uint64_t v314 = 0;
      do
      {
        float32x2_t v315 = &v21[v314];
        float32x2_t v316 = &v312[v314 * 8];
        *(void *)float32x2_t v316 = v21[v314];
        uint64_t v317 = v21[v314 + 1];
        *((void *)v316 + 1) = v317;
        if (v317) {
          atomic_fetch_add_explicit(&v317->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        v314 += 2;
      }
      while (v315 + 2 != v284);
      BOOL v318 = &v312[v314 * 8];
      int v319 = v383;
      if (v384 == v383)
      {
        if (v318 == v312)
        {
LABEL_400:
          operator delete(v313);
LABEL_401:
          if ((int)(v308 >> 4) >= 1)
          {
            for (uint64_t k = 0; k < (int)((unint64_t)((char *)v284 - (char *)v21) >> 4); ++k)
            {
              CFStringRef v328 = &v21[2 * k]->__vftable;
              if (v328)
              {
                float32x2_t v330 = (char *)v328[4];
                unint64_t v329 = v328[5];
                if ((unint64_t)v330 < v329)
                {
                  *(_DWORD *)float32x2_t v330 = k;
                  CFStringRef v327 = v330 + 4;
                }
                else
                {
                  uint64_t v331 = (char *)v328[3];
                  uint64_t v332 = (v330 - v331) >> 2;
                  unint64_t v333 = v332 + 1;
                  if ((unint64_t)(v332 + 1) >> 62) {
                    goto LABEL_463;
                  }
                  uint64_t v334 = v284;
                  uint64_t v335 = v329 - (void)v331;
                  if (v335 >> 1 > v333) {
                    unint64_t v333 = v335 >> 1;
                  }
                  if ((unint64_t)v335 >= 0x7FFFFFFFFFFFFFFCLL) {
                    unint64_t v336 = 0x3FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v336 = v333;
                  }
                  if (v336)
                  {
                    if (v336 >> 62) {
                      goto LABEL_464;
                    }
                    uint64_t v337 = operator new(4 * v336);
                  }
                  else
                  {
                    uint64_t v337 = 0;
                  }
                  uint64_t v338 = &v337[4 * v332];
                  *uint64_t v338 = k;
                  CFStringRef v327 = v338 + 1;
                  if (v330 != v331)
                  {
                    unint64_t v339 = v330 - 4 - v331;
                    if (v339 < 0x2C) {
                      goto LABEL_467;
                    }
                    if ((unint64_t)(v331 - v337) < 0x20) {
                      goto LABEL_467;
                    }
                    uint64_t v340 = (v339 >> 2) + 1;
                    unint64_t v341 = &v337[4 * v332 - 16];
                    uint64_t v342 = v330 - 16;
                    uint64_t v343 = v340 & 0x7FFFFFFFFFFFFFF8;
                    do
                    {
                      long long v344 = *(_OWORD *)v342;
                      *(v341 - 1) = *((_OWORD *)v342 - 1);
                      *unint64_t v341 = v344;
                      v341 -= 2;
                      v342 -= 32;
                      v343 -= 8;
                    }
                    while (v343);
                    v338 -= v340 & 0x7FFFFFFFFFFFFFF8;
                    v330 -= 4 * (v340 & 0x7FFFFFFFFFFFFFF8);
                    if (v340 != (v340 & 0x7FFFFFFFFFFFFFF8))
                    {
LABEL_467:
                      do
                      {
                        int v345 = *((_DWORD *)v330 - 1);
                        v330 -= 4;
                        *--uint64_t v338 = v345;
                      }
                      while (v330 != v331);
                    }
                  }
                  v328[3] = v338;
                  v328[4] = v327;
                  v328[5] = &v337[4 * v336];
                  if (v331) {
                    operator delete(v331);
                  }
                  uint64_t v284 = v334;
                }
                v328[4] = v327;
              }
            }
          }
LABEL_428:
          a1 = v376;
          v376[52] = v376[51];
          uint64_t v347 = v376[42];
          uint64_t v346 = v376[43];
          a4 = v373;
          if (v346 != v347)
          {
            uint64_t v348 = v376[43];
            do
            {
              float v350 = *(void **)(v348 - 24);
              v348 -= 24;
              uint64_t v349 = v350;
              if (v350)
              {
                *(void *)(v346 - 16) = v349;
                operator delete(v349);
              }
              uint64_t v346 = v348;
            }
            while (v348 != v347);
          }
          v376[43] = v347;
          if (v383) {
            operator delete(v383);
          }
          if (v21)
          {
            for (; v284 != v21; v284 -= 2)
            {
              float v351 = *(v284 - 1);
              if (v351 && !atomic_fetch_add(&v351->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v351->__on_zero_shared)(v351);
                std::__shared_weak_count::__release_weak(v351);
              }
            }
            operator delete(v21);
          }
          v376[22] = v376[21];
          v376[25] = v376[24];
          v376[28] = v376[27];
          float v352 = (void *)v376[33];
          if (v352 == v376 + 34) {
            goto LABEL_444;
          }
          while (1)
          {
            uint64_t v361 = (char *)v352[7];
            uint64_t v362 = (char *)v352[8];
            if (v361 == v362) {
              goto LABEL_457;
            }
            unint64_t v363 = v362 - v361 - 16;
            if (v363 <= 0xF) {
              goto LABEL_456;
            }
            uint64_t v364 = (v363 >> 4) + 1;
            uint64_t v365 = (uint64_t **)(v361 + 16);
            uint64_t v366 = v364 & 0x1FFFFFFFFFFFFFFELL;
            do
            {
              uint64_t v367 = *(v365 - 2);
              id v368 = *v365;
              v365 += 4;
              uint64_t v369 = *v368;
              v367[1] = *v367;
              v368[1] = v369;
              v366 -= 2;
            }
            while (v366);
            if (v364 != (v364 & 0x1FFFFFFFFFFFFFFELL)) {
              break;
            }
LABEL_457:
            float v371 = (void *)v352[1];
            if (v371)
            {
              do
              {
                float v372 = v371;
                float v371 = (void *)*v371;
              }
              while (v371);
            }
            else
            {
              do
              {
                float v372 = (void *)v352[2];
                BOOL v45 = *v372 == (void)v352;
                float v352 = v372;
              }
              while (!v45);
            }
            float v352 = v372;
            if (v372 == v376 + 34) {
              goto LABEL_444;
            }
          }
          v361 += 16 * (v364 & 0x1FFFFFFFFFFFFFFELL);
          do
          {
LABEL_456:
            float v370 = *(void **)v361;
            v361 += 16;
            v370[1] = *v370;
          }
          while (v361 != v362);
          goto LABEL_457;
        }
        do
        {
LABEL_397:
          int32x2_t v325 = (std::__shared_weak_count *)*((void *)v318 - 1);
          if (v325 && !atomic_fetch_add(&v325->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v325->__on_zero_shared)(v325);
            std::__shared_weak_count::__release_weak(v325);
          }
          v318 -= 16;
        }
        while (v318 != v313);
        goto LABEL_400;
      }
LABEL_387:
      unint64_t v320 = 0;
      unsigned int v321 = v21 + 1;
      do
      {
        long long v322 = *(_OWORD *)&v313[16 * v319[v320]];
        uint64_t v323 = *(void *)&v313[16 * v319[v320] + 8];
        if (v323) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v323 + 8), 1uLL, memory_order_relaxed);
        }
        unsigned int v324 = *v321;
        *(_OWORD *)(v321 - 1) = v322;
        if (v324 && !atomic_fetch_add(&v324->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v324->__on_zero_shared)(v324);
          std::__shared_weak_count::__release_weak(v324);
        }
        ++v320;
        int v319 = v383;
        v321 += 2;
      }
      while (v320 < v384 - v383);
      uint64_t v284 = v374;
      if (v318 == v313) {
        goto LABEL_400;
      }
      goto LABEL_397;
    }
LABEL_463:
    abort();
  }
LABEL_444:
  float v353 = (const UInt8 *)a1[12];
  uint64_t v354 = (const UInt8 *)a1[13];
  if (v353 != v354)
  {
    int v355 = CFDataCreate(0, v353, (v354 - v353) << 30 >> 30);
    cva::ItemHandler::createData((uint64_t *)v382, v355, v356);
    cva::DictionaryHandler::setItem((cva::DictionaryHandler *)v377, @"mesh_tri_indices", (const cva::ItemHandler *)v382);
    cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v382);
    CFRelease(v355);
  }
  uint64_t v357 = (const UInt8 *)a1[21];
  uint64_t v358 = (const UInt8 *)a1[22];
  if (v357 != v358)
  {
    uint64_t v359 = CFDataCreate(0, v357, ((v358 - v357) << 30 >> 30) & 0xFFFFFFFFFFFFFFF0);
    cva::ItemHandler::createData((uint64_t *)v382, v359, v360);
    cva::DictionaryHandler::setItem((cva::DictionaryHandler *)v377, @"mesh_quad_indices", (const cva::ItemHandler *)v382);
    cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v382);
    CFRelease(v359);
  }
  cva::ItemHandler::ItemHandler();
  cva::DictionaryHandler::setItem(a4, @"mesh", (const cva::ItemHandler *)v382);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v382);
  cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)v377);
}

uint64_t sub_1D0E2B740(uint64_t a1)
{
  if ((*(char *)(a1 + 455) & 0x80000000) == 0)
  {
    uint64_t v2 = *(void **)(a1 + 408);
    if (!v2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  operator delete(*(void **)(a1 + 432));
  uint64_t v2 = *(void **)(a1 + 408);
  if (v2)
  {
LABEL_3:
    *(void *)(a1 + 416) = v2;
    operator delete(v2);
  }
LABEL_4:
  uint64_t v3 = *(void **)(a1 + 384);
  if (v3)
  {
    *(void *)(a1 + 392) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 360);
  if (v4)
  {
    *(void *)(a1 + 368) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void *)(a1 + 336);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 344);
    uint64_t v7 = *(void **)(a1 + 336);
    if (v6 != v5)
    {
      uint64_t v8 = *(void *)(a1 + 344);
      do
      {
        CFIndex v10 = *(void **)(v8 - 24);
        v8 -= 24;
        int v9 = v10;
        if (v10)
        {
          *(void *)(v6 - 16) = v9;
          operator delete(v9);
        }
        uint64_t v6 = v8;
      }
      while (v8 != v5);
      uint64_t v7 = *(void **)(a1 + 336);
    }
    *(void *)(a1 + 344) = v5;
    operator delete(v7);
  }
  sub_1D0E2B8C4(*(char **)(a1 + 320));
  sub_1D0E2B93C(*(char **)(a1 + 296));
  sub_1D0E2B93C(*(char **)(a1 + 272));
  sub_1D0E2BA28(*(char **)(a1 + 248));
  uint64_t v11 = *(void **)(a1 + 216);
  if (v11)
  {
    *(void *)(a1 + 224) = v11;
    operator delete(v11);
  }
  unint64_t v12 = *(void **)(a1 + 192);
  if (v12)
  {
    *(void *)(a1 + 200) = v12;
    operator delete(v12);
  }
  CFDataRef v13 = *(void **)(a1 + 168);
  if (v13)
  {
    *(void *)(a1 + 176) = v13;
    operator delete(v13);
  }
  uint64_t v14 = *(void **)(a1 + 144);
  if (v14)
  {
    *(void *)(a1 + 152) = v14;
    operator delete(v14);
  }
  uint64_t v15 = *(void **)(a1 + 120);
  if (v15)
  {
    *(void *)(a1 + 128) = v15;
    operator delete(v15);
  }
  size_t v16 = *(void **)(a1 + 96);
  if (v16)
  {
    *(void *)(a1 + 104) = v16;
    operator delete(v16);
  }
  CFDataRef v17 = *(void **)(a1 + 72);
  if (v17)
  {
    *(void *)(a1 + 80) = v17;
    operator delete(v17);
  }
  unint64_t v18 = *(void **)(a1 + 48);
  if (v18)
  {
    *(void *)(a1 + 56) = v18;
    operator delete(v18);
  }
  unint64_t v19 = *(void **)(a1 + 24);
  if (v19)
  {
    *(void *)(a1 + 32) = v19;
    operator delete(v19);
  }
  size_t v20 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v20;
    operator delete(v20);
  }
  return a1;
}

void sub_1D0E2B8C4(char *a1)
{
  if (!a1) {
    return;
  }
  sub_1D0E2B8C4(*(void *)a1);
  sub_1D0E2B8C4(*((void *)a1 + 1));
  if (a1[79] < 0)
  {
    operator delete(*((void **)a1 + 7));
    if ((a1[55] & 0x80000000) == 0) {
      goto LABEL_4;
    }
LABEL_9:
    operator delete(*((void **)a1 + 4));
    goto LABEL_4;
  }
  if (a1[55] < 0) {
    goto LABEL_9;
  }
LABEL_4:
  operator delete(a1);
}

void sub_1D0E2B93C(char *a1)
{
  if (a1)
  {
    sub_1D0E2B93C(*(void *)a1);
    sub_1D0E2B93C(*((void *)a1 + 1));
    uint64_t v2 = *((void *)a1 + 7);
    if (v2)
    {
      uint64_t v3 = *((void *)a1 + 8);
      uint64_t v4 = (void *)*((void *)a1 + 7);
      if (v3 != v2)
      {
        do
        {
          uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
          if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
          v3 -= 16;
        }
        while (v3 != v2);
        uint64_t v4 = (void *)*((void *)a1 + 7);
      }
      *((void *)a1 + 8) = v2;
      operator delete(v4);
    }
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

void sub_1D0E2BA28(char *a1)
{
  if (!a1) {
    return;
  }
  sub_1D0E2BA28(*(void *)a1);
  sub_1D0E2BA28(*((void *)a1 + 1));
  if (a1[159] < 0)
  {
    operator delete(*((void **)a1 + 17));
    if ((a1[135] & 0x80000000) == 0)
    {
LABEL_4:
      if ((a1[111] & 0x80000000) == 0) {
        goto LABEL_5;
      }
LABEL_12:
      operator delete(*((void **)a1 + 11));
      if ((a1[55] & 0x80000000) == 0) {
        goto LABEL_6;
      }
LABEL_13:
      operator delete(*((void **)a1 + 4));
      goto LABEL_6;
    }
  }
  else if ((a1[135] & 0x80000000) == 0)
  {
    goto LABEL_4;
  }
  operator delete(*((void **)a1 + 14));
  if (a1[111] < 0) {
    goto LABEL_12;
  }
LABEL_5:
  if (a1[55] < 0) {
    goto LABEL_13;
  }
LABEL_6:
  operator delete(a1);
}

BOOL sub_1D0E2BAD0(uint64_t a1, CVPixelBufferRef pixelBuffer)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  int Width = CVPixelBufferGetWidth(pixelBuffer);
  int Height = CVPixelBufferGetHeight(pixelBuffer);
  int v6 = Height;
  BOOL v7 = *(_DWORD *)(a1 + 8) == Width && *(_DWORD *)(a1 + 12) == Height;
  if (!v7)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0)
    {
      if (__cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
    }
    uint64_t v8 = qword_1EB9F1620;
    BOOL result = os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR);
    if (result)
    {
      int v10 = *(_DWORD *)(a1 + 8);
      int v11 = *(_DWORD *)(a1 + 12);
      int v31 = 67109888;
      *(_DWORD *)float v32 = v10;
      *(_WORD *)&v32[4] = 1024;
      *(_DWORD *)&v32[6] = v11;
      LOWORD(v33) = 1024;
      *(_DWORD *)((char *)&v33 + 2) = Width;
      HIWORD(v33) = 1024;
      v34[0] = v6;
      unint64_t v12 = "Camera parameters size (%d, %d) does not match buffer size (%d, %d).";
      CFDataRef v13 = v8;
      uint32_t v14 = 26;
LABEL_32:
      _os_log_error_impl(&dword_1D0DBD000, v13, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&v31, v14);
      return 0;
    }
    return result;
  }
  uint64_t v15 = 0;
  do
  {
    BOOL v16 = (*(_DWORD *)(a1 + 16 + v15) & 0x7FFFFFFFu) < 0x7F800000;
    if ((*(_DWORD *)(a1 + 16 + v15) & 0x7FFFFFFFu) > 0x7F7FFFFF) {
      break;
    }
    BOOL v7 = v15 == 32;
    v15 += 4;
  }
  while (!v7);
  if (!v16)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    uint64_t v27 = qword_1EB9F1620;
    BOOL result = os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(v31) = 0;
    unint64_t v12 = "intrinsic camera parameters contain invalid values";
LABEL_28:
    CFDataRef v13 = v27;
    uint32_t v14 = 2;
    goto LABEL_32;
  }
  float v17 = *(float *)(a1 + 16);
  float v18 = *(float *)(a1 + 32);
  if (v17 <= 0.0 || v18 <= 0.0)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    uint64_t v28 = qword_1EB9F1620;
    BOOL result = os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR);
    if (result)
    {
      int v31 = 134218240;
      *(double *)float v32 = v17;
      *(_WORD *)&v32[8] = 2048;
      double v33 = v18;
      unint64_t v12 = "intrinsic camera parameters have invalid focal length: %g, %g (should be positive)";
      CFDataRef v13 = v28;
      uint32_t v14 = 22;
      goto LABEL_32;
    }
    return result;
  }
  float v19 = *(float *)(a1 + 24);
  float v20 = *(float *)(a1 + 36);
  float v21 = *(float *)(a1 + 48);
  float v22 = fabsf(v20);
  BOOL v23 = fabsf(v19) <= 0.000001 && v22 <= 0.000001;
  float v24 = fabsf(v21 + -1.0);
  if (!v23 || v24 > 0.000001)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    uint64_t v26 = qword_1EB9F1620;
    BOOL result = os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR);
    if (result)
    {
      int v31 = 134218496;
      *(double *)float v32 = v19;
      *(_WORD *)&v32[8] = 2048;
      double v33 = v20;
      LOWORD(v34[0]) = 2048;
      *(double *)((char *)v34 + 2) = v21;
      unint64_t v12 = "intrinsic camera parameters have invalid 3rd row: %g, %g, %g (should be 0, 0, 1)";
      CFDataRef v13 = v26;
      uint32_t v14 = 32;
      goto LABEL_32;
    }
    return result;
  }
  uint64_t v29 = 0;
  do
  {
    BOOL v30 = (*(_DWORD *)(a1 + 52 + v29) & 0x7FFFFFFFu) < 0x7F800000;
    if ((*(_DWORD *)(a1 + 52 + v29) & 0x7FFFFFFFu) > 0x7F7FFFFF) {
      break;
    }
    BOOL v7 = v29 == 32;
    v29 += 4;
  }
  while (!v7);
  if (v30
    && (*(_DWORD *)(a1 + 88) & 0x7FFFFFFFu) <= 0x7F7FFFFF
    && (*(_DWORD *)(a1 + 92) & 0x7FFFFFFFu) <= 0x7F7FFFFF
    && (*(_DWORD *)(a1 + 96) & 0x7FFFFFFFu) < 0x7F800000)
  {
    return 1;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v27 = qword_1EB9F1620;
  BOOL result = os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR);
  if (result)
  {
    LOWORD(v31) = 0;
    unint64_t v12 = "extrinsic camera parameters contain invalid values";
    goto LABEL_28;
  }
  return result;
}

void sub_1D0E2BFA0(cva::ArrayHandler **a1, uint64_t a2, float a3, float a4, float a5)
{
  unsigned int v10 = cva::ArrayHandler::size(*a1);
  if (v10 != *(_DWORD *)(a2 + 16))
  {
    *(_DWORD *)(a2 + 16) = v10;
    if (v10)
    {
      uint64_t v11 = v10;
      if (*(void *)(a2 + 8) < (unint64_t)v10)
      {
        free(*(void **)a2);
        size_t v12 = (4 * v11 + 31) & 0x7FFFFFFE0;
        *(void *)a2 = 0;
        *(void *)(a2 + 8) = v12 >> 2;
        memptr = 0;
        malloc_type_posix_memalign(&memptr, 0x20uLL, v12, 0x49090899uLL);
        *(void *)a2 = memptr;
      }
    }
    else
    {
      free(*(void **)a2);
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
    }
    unsigned int v10 = *(_DWORD *)(a2 + 16);
  }
  if (v10) {
    memset_pattern16(*(void **)a2, &unk_1D0E818E0, 4 * v10);
  }
  v16[0] = 0;
  v16[1] = 0;
  memptr = v16;
  std::string __p = "browDown_L";
  uint64_t v14 = LODWORD(a3);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "browDown_R";
  uint64_t v14 = LODWORD(a3);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "browInnerUp";
  uint64_t v14 = LODWORD(a3);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "browOuterUp_L";
  uint64_t v14 = LODWORD(a3);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "browOuterUp_R";
  uint64_t v14 = LODWORD(a3);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "eyeSquint_L";
  uint64_t v14 = LODWORD(a4);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "eyeSquint_R";
  uint64_t v14 = LODWORD(a4);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "eyeWide_L";
  uint64_t v14 = LODWORD(a4);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "eyeWide_R";
  uint64_t v14 = LODWORD(a4);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthClose";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthUpperUp_L";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthUpperUp_R";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthLowerDown_L";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthLowerDown_R";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthRollUpper";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthRollLower";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthSmile_L";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthSmile_R";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthDimple_L";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthDimple_R";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthStretch_L";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthStretch_R";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthFrown_L";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthFrown_R";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthPress_L";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthPress_R";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthPucker";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthFunnel";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthLeft";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthRight";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthShrugLower";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "mouthShrugUpper";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "jawOpen";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "jawLeft";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "jawRight";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "jawForward";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "BrowsD_L";
  uint64_t v14 = LODWORD(a3);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "BrowsD_R";
  uint64_t v14 = LODWORD(a3);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "BrowsU_C";
  uint64_t v14 = LODWORD(a3);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "BrowsU_L";
  uint64_t v14 = LODWORD(a3);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "BrowsU_R";
  uint64_t v14 = LODWORD(a3);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "EyeSquint_L";
  uint64_t v14 = LODWORD(a4);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "EyeSquint_R";
  uint64_t v14 = LODWORD(a4);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "EyeOpen_L";
  uint64_t v14 = LODWORD(a4);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "EyeOpen_R";
  uint64_t v14 = LODWORD(a4);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "LipsTogether";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "LipsUpperUp_L";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "LipsUpperUp_R";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "LipsLowerDown_L";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "LipsLowerDown_R";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "LipsUpperClose";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "LipsLowerClose";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "MouthSmile_L";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "MouthSmile_R";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "MouthDimple_L";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "MouthDimple_R";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "LipsStretch_L";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "LipsStretch_R";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "MouthFrown_L";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "MouthFrown_R";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "MouthPress_L";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "MouthPress_R";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "LipsPucker";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "LipsFunnel";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "MouthLeft";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "MouthRight";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "ChinLowerRaise";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "ChinUpperRaise";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "JawOpen";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "JawLeft";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "JawRight";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  std::string __p = "JawFwd";
  uint64_t v14 = LODWORD(a5);
  sub_1D0E2C948((uint64_t **)&memptr, (uint64_t)&__p);
  if (cva::ArrayHandler::size(*a1))
  {
    cva::ArrayHandler::item(*a1);
    cva::ItemHandler::getValue<std::string>();
  }
  sub_1D0DD5F80(v16[0]);
}

void sub_1D0E2C948(uint64_t **a1, uint64_t a2)
{
  uint64_t v4 = operator new(0x40uLL);
  uint64_t v5 = *(const char **)a2;
  size_t v6 = strlen(*(const char **)a2);
  if (v6 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    uint64_t v8 = operator new(v9 + 1);
    v4[5] = v7;
    v4[6] = v10 | 0x8000000000000000;
    v4[4] = v8;
    goto LABEL_8;
  }
  *((unsigned char *)v4 + 55) = v6;
  uint64_t v8 = v4 + 4;
  if (v6) {
LABEL_8:
  }
    memmove(v8, v5, v7);
  *((unsigned char *)v8 + v7) = 0;
  *((_DWORD *)v4 + 14) = *(_DWORD *)(a2 + 8);
  uint64_t v11 = (uint64_t *)(a1 + 1);
  size_t v12 = a1[1];
  if (v12)
  {
    int v13 = *((char *)v4 + 55);
    uint64_t v14 = (void *)v4[4];
    if (v13 >= 0) {
      uint64_t v15 = v4 + 4;
    }
    else {
      uint64_t v15 = (const void *)v4[4];
    }
    if (v13 >= 0) {
      size_t v16 = *((unsigned __int8 *)v4 + 55);
    }
    else {
      size_t v16 = v4[5];
    }
    while (1)
    {
      float v17 = v12;
      float v18 = v12 + 4;
      float v19 = (const void *)v12[4];
      int v20 = *((char *)v18 + 23);
      if (v20 >= 0) {
        float v21 = v18;
      }
      else {
        float v21 = v19;
      }
      if (v20 >= 0) {
        size_t v22 = *((unsigned __int8 *)v18 + 23);
      }
      else {
        size_t v22 = v18[1];
      }
      if (v22 >= v16) {
        size_t v23 = v16;
      }
      else {
        size_t v23 = v22;
      }
      int v24 = memcmp(v15, v21, v23);
      if (v24)
      {
        if (v24 < 0) {
          goto LABEL_16;
        }
LABEL_30:
        int v25 = memcmp(v21, v15, v23);
        if (v25)
        {
          if ((v25 & 0x80000000) == 0) {
            goto LABEL_40;
          }
        }
        else if (v22 >= v16)
        {
LABEL_40:
          if (v13 < 0) {
            operator delete(v14);
          }
          operator delete(v4);
          return;
        }
        size_t v12 = (uint64_t *)v17[1];
        if (!v12)
        {
          uint64_t v11 = v17 + 1;
          goto LABEL_37;
        }
      }
      else
      {
        if (v16 >= v22) {
          goto LABEL_30;
        }
LABEL_16:
        size_t v12 = (uint64_t *)*v17;
        uint64_t v11 = v17;
        if (!*v17) {
          goto LABEL_37;
        }
      }
    }
  }
  float v17 = (uint64_t *)(a1 + 1);
LABEL_37:
  void *v4 = 0;
  v4[1] = 0;
  void v4[2] = v17;
  *uint64_t v11 = (uint64_t)v4;
  uint64_t v26 = (uint64_t *)**a1;
  if (v26)
  {
    *a1 = v26;
    uint64_t v4 = (void *)*v11;
  }
  sub_1D0DCEC98(a1[1], v4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
}

void sub_1D0E2CB50()
{
  int v0 = operator new(0x28uLL);
  v0[1] = 0;
  v0[2] = 0;
  *int v0 = &unk_1F26F4AD8;
  cva::ArrayHandler::ArrayHandler((cva::ArrayHandler *)(v0 + 3));
  uint64_t v1 = 0;
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  do
  {
    CFStringRef v4 = CFStringCreateWithCStringNoCopy(v2, *off_1E689B098[v1], 0x8000100u, v3);
    cva::ItemHandler::ItemHandler((cva::ItemHandler *)v5, v4);
    cva::ArrayHandler::addItem((cva::ArrayHandler *)(v0 + 3), (const cva::ItemHandler *)v5);
    cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v5);
    CFRelease(v4);
    v1 += 2;
  }
  while (v1 != 102);
  qword_1EB9F16C0 = (uint64_t)(v0 + 3);
  *(void *)algn_1EB9F16C8 = v0;
}

void sub_1D0E2CC4C()
{
  int v0 = operator new(0x28uLL);
  v0[1] = 0;
  v0[2] = 0;
  *int v0 = &unk_1F26F4AD8;
  cva::ArrayHandler::ArrayHandler((cva::ArrayHandler *)(v0 + 3));
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  uint64_t v3 = 1u;
  do
  {
    CFStringRef v4 = CFStringCreateWithCStringNoCopy(v1, *off_1E689B098[v3], 0x8000100u, v2);
    cva::ItemHandler::ItemHandler((cva::ItemHandler *)v5, v4);
    cva::ArrayHandler::addItem((cva::ArrayHandler *)(v0 + 3), (const cva::ItemHandler *)v5);
    cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v5);
    CFRelease(v4);
    v3 += 2;
  }
  while (v3 != 103);
  qword_1EA6437E0 = (uint64_t)(v0 + 3);
  *(void *)algn_1EA6437E8 = v0;
}

void *sub_1D0E2CD48(void *result)
{
  unint64_t v1 = 0x1EA643000uLL;
  unint64_t v2 = 0x1EA643000uLL;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA643808, memory_order_acquire) & 1) == 0)
  {
    size_t v6 = result;
    int v4 = __cxa_guard_acquire(&qword_1EA643808);
    unint64_t v1 = 0x1EA643000;
    unint64_t v2 = 0x1EA643000;
    int v5 = v4;
    BOOL result = v6;
    if (v5) {
      sub_1D0E2CE04(&v7);
    }
  }
  uint64_t v3 = *(void *)(v2 + 2048);
  *BOOL result = *(void *)(v1 + 2040);
  result[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1D0E2CE04(void *a1)
{
  unint64_t v2 = operator new(0x28uLL);
  v2[1] = 0;
  _DWORD v2[2] = 0;
  void *v2 = &unk_1F26F4AD8;
  cva::ArrayHandler::ArrayHandler((cva::ArrayHandler *)(v2 + 3));
  *a1 = v2 + 3;
  a1[1] = v2;
  atomic_fetch_add_explicit(v2 + 1, 1uLL, memory_order_relaxed);
  cva::ItemHandler::createValue<std::string>();
}

void sub_1D0E2F470(void *a1)
{
  unint64_t v2 = operator new(0x28uLL);
  v2[1] = 0;
  _DWORD v2[2] = 0;
  void *v2 = &unk_1F26F4AD8;
  cva::ArrayHandler::ArrayHandler((cva::ArrayHandler *)(v2 + 3));
  *a1 = v2 + 3;
  a1[1] = v2;
  atomic_fetch_add_explicit(v2 + 1, 1uLL, memory_order_relaxed);
  cva::ItemHandler::createValue<std::string>();
}

void sub_1D0E32658(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a2 + 408;
  sub_1D0E60DA4((uint64_t)&memptr);
  int v5 = *(void **)(v3 + 240);
  size_t v6 = *(void *)(v3 + 248);
  size_t v7 = v580;
  *(void *)(v3 + 240) = memptr;
  *(void *)(v3 + 248) = v7;
  memptr = v5;
  size_t v580 = v6;
  *(_DWORD *)(v3 + 256) = v581;
  uint64_t v8 = *(void **)(v3 + 264);
  uint64_t v9 = *(void *)(v3 + 272);
  uint64_t v10 = v583;
  *(void *)(v3 + 264) = v582;
  *(void *)(v3 + 272) = v10;
  int16x8_t v582 = v8;
  uint64_t v583 = v9;
  *(_DWORD *)(v3 + 280) = v584;
  uint64_t v11 = *(void **)(v3 + 288);
  uint64_t v12 = *(void *)(v3 + 296);
  uint64_t v13 = v586;
  *(void *)(v3 + 288) = v585;
  *(void *)(v3 + 296) = v13;
  v585 = v11;
  uint64_t v586 = v12;
  *(_DWORD *)(v3 + 304) = v587;
  uint64_t v14 = *(void **)(v3 + 312);
  size_t v15 = *(void *)(v3 + 320);
  size_t v16 = v589;
  *(void *)(v3 + 312) = v588;
  *(void *)(v3 + 320) = v16;
  v588 = v14;
  size_t v589 = v15;
  *(_DWORD *)(v3 + 328) = v590;
  uint64_t v17 = *(void *)(v3 + 336);
  uint64_t v18 = *(void *)(v3 + 344);
  uint64_t v19 = *((void *)&v591 + 1);
  *(void *)(v3 + 336) = v591;
  *(void *)(v3 + 344) = v19;
  *(void *)&long long v591 = v17;
  *((void *)&v591 + 1) = v18;
  *(_DWORD *)(v3 + 352) = v592;
  uint64_t v20 = *(void *)(v3 + 360);
  uint64_t v21 = *(void *)(v3 + 368);
  uint64_t v22 = v594;
  *(void *)(v3 + 360) = v593;
  *(void *)(v3 + 368) = v22;
  uint64_t v593 = v20;
  uint64_t v594 = v21;
  *(_DWORD *)(v3 + 376) = v595;
  uint64_t v23 = *(void *)(v3 + 384);
  uint64_t v24 = *(void *)(v3 + 392);
  uint64_t v25 = v597;
  *(void *)(v3 + 384) = v596;
  *(void *)(v3 + 392) = v25;
  int v581 = 0;
  int v584 = 0;
  unsigned int v587 = 0;
  int v590 = 0;
  LODWORD(v592) = 0;
  int v595 = 0;
  uint64_t v596 = v23;
  uint64_t v597 = v24;
  *(_DWORD *)(v3 + 400) = v598;
  int v598 = 0;
  uint64_t v26 = *(void **)(v3 + 408);
  if (v26)
  {
    *(void *)(v3 + 416) = v26;
    operator delete(v26);
    *(void *)uint64_t v4 = 0;
    *(void *)(v4 + 8) = 0;
    *(void *)(v4 + 16) = 0;
  }
  *(_OWORD *)uint64_t v4 = v599;
  uint64_t v27 = *(void *)(v3 + 432);
  uint64_t v28 = *(void *)(v3 + 440);
  *(_OWORD *)(v3 + 424) = v600;
  long long v599 = 0uLL;
  *(void *)&long long v600 = 0;
  *((void *)&v600 + 1) = v27;
  *(void *)(v3 + 440) = v601;
  uint64_t v601 = v28;
  *(_DWORD *)(v3 + 448) = v602;
  int v602 = 0;
  uint64_t v29 = *(void **)(v3 + 456);
  if (v29)
  {
    *(void *)(v3 + 464) = v29;
    operator delete(v29);
  }
  *(_OWORD *)(v4 + 48) = v603;
  *(void *)(v3 + 472) = v604;
  long long v603 = 0uLL;
  uint64_t v604 = 0;
  sub_1D0E60D20((uint64_t)&memptr);
  uint64_t v30 = *a2;
  sub_1D0E61120((uint64_t)&memptr);
  int v31 = *(void **)(v30 + 480);
  size_t v32 = *(void *)(v30 + 488);
  size_t v33 = v580;
  *(void *)(v30 + 480) = memptr;
  *(void *)(v30 + 488) = v33;
  memptr = v31;
  size_t v580 = v32;
  *(_DWORD *)(v30 + 496) = v581;
  int v581 = 0;
  int v34 = *(void **)(v30 + 504);
  uint64_t v35 = *(void *)(v30 + 512);
  uint64_t v36 = v583;
  *(void *)(v30 + 504) = v582;
  *(void *)(v30 + 512) = v36;
  int16x8_t v582 = v34;
  uint64_t v583 = v35;
  *(_DWORD *)(v30 + 520) = v584;
  int v584 = 0;
  unsigned int v37 = *(void **)(v30 + 528);
  uint64_t v38 = v586;
  *(void *)(v30 + 528) = v585;
  uint64_t v39 = *(void *)(v30 + 536);
  *(void *)(v30 + 536) = v38;
  v585 = v37;
  uint64_t v586 = v39;
  *(_DWORD *)(v30 + 544) = v587;
  unsigned int v587 = 0;
  int v40 = *(void **)(v30 + 552);
  size_t v41 = v589;
  *(void *)(v30 + 552) = v588;
  size_t v42 = *(void *)(v30 + 560);
  *(void *)(v30 + 560) = v41;
  v588 = v40;
  size_t v589 = v42;
  *(_DWORD *)(v30 + 568) = v590;
  int v590 = 0;
  int v43 = *(void **)(v30 + 576);
  if (v43)
  {
    *(void *)(v30 + 584) = v43;
    operator delete(v43);
    *(void *)(v30 + 576) = 0;
    *(void *)(v30 + 584) = 0;
    *(void *)(v30 + 592) = 0;
    int v40 = v588;
  }
  *(_OWORD *)(v30 + 576) = v591;
  *(void *)(v30 + 592) = v592;
  uint64_t v592 = 0;
  long long v591 = 0uLL;
  free(v40);
  free(v585);
  free(v582);
  free(memptr);
  uint64_t v44 = *a2;
  sub_1D0E609A4((uint64_t)&memptr);
  BOOL v45 = *(void **)v44;
  size_t v46 = *(void *)(v44 + 8);
  *(void *)uint64_t v44 = memptr;
  *(void *)(v44 + 8) = v580;
  memptr = v45;
  size_t v580 = v46;
  *(_DWORD *)(v44 + 16) = v581;
  int v47 = *(void **)(v44 + 24);
  uint64_t v48 = *(void *)(v44 + 32);
  *(void *)(v44 + 24) = v582;
  *(void *)(v44 + 32) = v583;
  int16x8_t v582 = v47;
  uint64_t v583 = v48;
  *(_DWORD *)(v44 + 40) = v584;
  uint64_t v49 = *(void **)(v44 + 48);
  uint64_t v50 = *(void *)(v44 + 56);
  *(void *)(v44 + 48) = v585;
  *(void *)(v44 + 56) = v586;
  v585 = v49;
  uint64_t v586 = v50;
  *(_DWORD *)(v44 + 64) = v587;
  uint64_t v51 = *(void **)(v44 + 72);
  size_t v52 = *(void *)(v44 + 80);
  *(void *)(v44 + 72) = v588;
  *(void *)(v44 + 80) = v589;
  v588 = v51;
  size_t v589 = v52;
  *(_DWORD *)(v44 + 88) = v590;
  uint64_t v53 = *(void *)(v44 + 96);
  uint64_t v54 = *(void *)(v44 + 104);
  *(_OWORD *)(v44 + 96) = v591;
  *(void *)&long long v591 = v53;
  *((void *)&v591 + 1) = v54;
  *(_DWORD *)(v44 + 112) = v592;
  uint64_t v55 = *(void *)(v44 + 120);
  uint64_t v56 = *(void *)(v44 + 128);
  *(void *)(v44 + 120) = v593;
  *(void *)(v44 + 128) = v594;
  uint64_t v593 = v55;
  uint64_t v594 = v56;
  *(_DWORD *)(v44 + 136) = v595;
  uint64_t v57 = *(void *)(v44 + 144);
  uint64_t v58 = *(void *)(v44 + 152);
  *(void *)(v44 + 144) = v596;
  *(void *)(v44 + 152) = v597;
  int v581 = 0;
  int v584 = 0;
  unsigned int v587 = 0;
  int v590 = 0;
  LODWORD(v592) = 0;
  int v595 = 0;
  uint64_t v596 = v57;
  uint64_t v597 = v58;
  *(_DWORD *)(v44 + 160) = v598;
  int v598 = 0;
  int v59 = *(void **)(v44 + 168);
  if (v59)
  {
    *(void *)(v44 + 176) = v59;
    operator delete(v59);
    *(void *)(v44 + 168) = 0;
    *(void *)(v44 + 176) = 0;
    *(void *)(v44 + 184) = 0;
  }
  *(_OWORD *)(v44 + 168) = v599;
  *(void *)(v44 + 184) = v600;
  uint64_t v60 = *(void *)(v44 + 192);
  uint64_t v61 = *(void *)(v44 + 200);
  *(void *)(v44 + 192) = *((void *)&v600 + 1);
  long long v599 = 0uLL;
  *(void *)&long long v600 = 0;
  *((void *)&v600 + 1) = v60;
  *(void *)(v44 + 200) = v601;
  uint64_t v601 = v61;
  *(_DWORD *)(v44 + 208) = v602;
  int v602 = 0;
  unint64_t v62 = *(void **)(v44 + 216);
  if (v62)
  {
    *(void *)(v44 + 224) = v62;
    operator delete(v62);
  }
  *(_OWORD *)(v44 + 216) = v603;
  *(void *)(v44 + 232) = v604;
  long long v603 = 0uLL;
  uint64_t v604 = 0;
  sub_1D0E60D20((uint64_t)&memptr);
  uint64_t v63 = *a2;
  sub_1D0E612E4((uint64_t)&memptr);
  int v64 = *(void **)(v63 + 600);
  size_t v65 = v580;
  *(void *)(v63 + 600) = memptr;
  size_t v66 = *(void *)(v63 + 608);
  *(void *)(v63 + 608) = v65;
  memptr = v64;
  size_t v580 = v66;
  *(_DWORD *)(v63 + 616) = v581;
  int v581 = 0;
  uint64_t v67 = *(void **)(v63 + 624);
  uint64_t v68 = v583;
  *(void *)(v63 + 624) = v582;
  uint64_t v69 = *(void *)(v63 + 632);
  *(void *)(v63 + 632) = v68;
  int16x8_t v582 = v67;
  uint64_t v583 = v69;
  *(_DWORD *)(v63 + 640) = v584;
  int v584 = 0;
  int v70 = *(void **)(v63 + 648);
  uint64_t v71 = v586;
  *(void *)(v63 + 648) = v585;
  uint64_t v72 = *(void *)(v63 + 656);
  *(void *)(v63 + 656) = v71;
  v585 = v70;
  uint64_t v586 = v72;
  *(_DWORD *)(v63 + 664) = v587;
  unsigned int v587 = 0;
  unsigned int v73 = *(void **)(v63 + 672);
  size_t v74 = v589;
  *(void *)(v63 + 672) = v588;
  size_t v75 = *(void *)(v63 + 680);
  *(void *)(v63 + 680) = v74;
  v588 = v73;
  size_t v589 = v75;
  *(_DWORD *)(v63 + 688) = v590;
  int v590 = 0;
  uint64_t v76 = (void *)(v63 + 696);
  int v77 = *(void **)(v63 + 696);
  if (v77)
  {
    *(void *)(v63 + 704) = v77;
    operator delete(v77);
    *uint64_t v76 = 0;
    *(void *)(v63 + 704) = 0;
    *(void *)(v63 + 712) = 0;
    unsigned int v73 = v588;
  }
  *(_OWORD *)uint64_t v76 = v591;
  *(void *)(v63 + 712) = v592;
  uint64_t v592 = 0;
  long long v591 = 0uLL;
  free(v73);
  free(v585);
  free(v582);
  free(memptr);
  uint64_t v78 = *a2;
  sub_1D0E614A8((uint64_t)&memptr);
  unsigned int v79 = *(void **)(v78 + 720);
  size_t v80 = v580;
  *(void *)(v78 + 720) = memptr;
  size_t v81 = *(void *)(v78 + 728);
  *(void *)(v78 + 728) = v80;
  memptr = v79;
  size_t v580 = v81;
  *(_DWORD *)(v78 + 736) = v581;
  int v581 = 0;
  int v82 = *(void **)(v78 + 744);
  uint64_t v83 = v583;
  *(void *)(v78 + 744) = v582;
  uint64_t v84 = *(void *)(v78 + 752);
  *(void *)(v78 + 752) = v83;
  int16x8_t v582 = v82;
  uint64_t v583 = v84;
  *(_DWORD *)(v78 + 760) = v584;
  int v584 = 0;
  float v85 = *(void **)(v78 + 768);
  uint64_t v86 = v586;
  *(void *)(v78 + 768) = v585;
  uint64_t v87 = *(void *)(v78 + 776);
  *(void *)(v78 + 776) = v86;
  v585 = v85;
  uint64_t v586 = v87;
  *(_DWORD *)(v78 + 784) = v587;
  unsigned int v587 = 0;
  float v88 = *(void **)(v78 + 792);
  size_t v89 = v589;
  *(void *)(v78 + 792) = v588;
  size_t v90 = *(void *)(v78 + 800);
  *(void *)(v78 + 800) = v89;
  v588 = v88;
  size_t v589 = v90;
  *(_DWORD *)(v78 + 808) = v590;
  int v590 = 0;
  float v91 = *(void **)(v78 + 816);
  if (v91)
  {
    *(void *)(v78 + 824) = v91;
    operator delete(v91);
    *(void *)(v78 + 816) = 0;
    *(void *)(v78 + 824) = 0;
    *(void *)(v78 + 832) = 0;
    float v88 = v588;
  }
  *(_OWORD *)(v78 + 816) = v591;
  *(void *)(v78 + 832) = v592;
  uint64_t v592 = 0;
  long long v591 = 0uLL;
  free(v88);
  free(v585);
  free(v582);
  free(memptr);
  uint64_t v92 = *a2;
  float v93 = *(int **)(a1 + 8);
  unint64_t v94 = *(int **)(*a2 + 120);
  int v95 = *v93;
  if (&v93[-*(unsigned int *)(a1 + 20)] == v94)
  {
    int v96 = v93[1];
    int *v94 = v95;
  }
  else
  {
    int *v94 = v95;
    int v96 = v93[1];
  }
  v94[1] = v96;
  uint64_t v97 = *(unsigned int *)(a1 + 20);
  uint64_t v98 = *(void *)(a1 + 8) - 4 * v97;
  unint64_t v99 = (int *)(v98 + 4 * (*(_DWORD *)(a1 + 16) + v97));
  uint64_t v100 = *(void *)(v92 + 120);
  int v101 = *v99;
  if (v98 == v100)
  {
    int v102 = v99[1];
    *(_DWORD *)(v100 + 8) = v101;
  }
  else
  {
    *(_DWORD *)(v100 + 8) = v101;
    int v102 = v99[1];
  }
  *(_DWORD *)(v100 + 12) = v102;
  uint64_t v103 = *(unsigned int *)(a1 + 20);
  uint64_t v104 = *(void *)(a1 + 8) - 4 * v103;
  float v105 = (int *)(v104 + 4 * (v103 + 2 * *(_DWORD *)(a1 + 16)));
  uint64_t v106 = *(void *)(v92 + 120);
  int v107 = *v105;
  if (v104 == v106)
  {
    int v108 = v105[1];
    *(_DWORD *)(v106 + 16) = v107;
  }
  else
  {
    *(_DWORD *)(v106 + 16) = v107;
    int v108 = v105[1];
  }
  *(_DWORD *)(v106 + 20) = v108;
  uint64_t v109 = *(unsigned int *)(a1 + 20);
  uint64_t v110 = *(void *)(a1 + 8) - 4 * v109;
  int v111 = (int *)(v110 + 4 * (3 * *(_DWORD *)(a1 + 16) + v109));
  uint64_t v112 = *(void *)(v92 + 120);
  int v113 = *v111;
  if (v110 == v112)
  {
    int v114 = v111[1];
    *(_DWORD *)(v112 + 24) = v113;
  }
  else
  {
    *(_DWORD *)(v112 + 24) = v113;
    int v114 = v111[1];
  }
  *(_DWORD *)(v112 + 28) = v114;
  uint64_t v115 = *(unsigned int *)(a1 + 20);
  uint64_t v116 = *(void *)(a1 + 8) - 4 * v115;
  unint64_t v117 = (int *)(v116 + 4 * (v115 + 4 * *(_DWORD *)(a1 + 16)));
  uint64_t v118 = *(void *)(v92 + 120);
  int v119 = *v117;
  if (v116 == v118)
  {
    int v120 = v117[1];
    *(_DWORD *)(v118 + 32) = v119;
  }
  else
  {
    *(_DWORD *)(v118 + 32) = v119;
    int v120 = v117[1];
  }
  *(_DWORD *)(v118 + 36) = v120;
  uint64_t v121 = *(unsigned int *)(a1 + 20);
  uint64_t v122 = *(void *)(a1 + 8) - 4 * v121;
  int v123 = (int *)(v122 + 4 * (5 * *(_DWORD *)(a1 + 16) + v121));
  uint64_t v124 = *(void *)(v92 + 120);
  int v125 = *v123;
  if (v122 == v124)
  {
    int v126 = v123[1];
    *(_DWORD *)(v124 + 40) = v125;
  }
  else
  {
    *(_DWORD *)(v124 + 40) = v125;
    int v126 = v123[1];
  }
  *(_DWORD *)(v124 + 44) = v126;
  uint64_t v127 = *(unsigned int *)(a1 + 20);
  uint64_t v128 = *(void *)(a1 + 8) - 4 * v127;
  float v129 = (int *)(v128 + 4 * (v127 + 6 * *(_DWORD *)(a1 + 16)));
  uint64_t v130 = *(void *)(v92 + 120);
  int v131 = *v129;
  if (v128 == v130)
  {
    int v132 = v129[1];
    *(_DWORD *)(v130 + 48) = v131;
  }
  else
  {
    *(_DWORD *)(v130 + 48) = v131;
    int v132 = v129[1];
  }
  *(_DWORD *)(v130 + 52) = v132;
  uint64_t v133 = *(unsigned int *)(a1 + 20);
  unint64_t v134 = (_DWORD *)(*(void *)(a1 + 8) - 4 * v133);
  float v135 = &v134[(v133 - *(_DWORD *)(a1 + 16) + 8 * *(_DWORD *)(a1 + 16))];
  float v136 = *(_DWORD **)(v92 + 96);
  int v137 = *v135;
  if (v134 == v136)
  {
    int v138 = v135[1];
    _DWORD *v134 = v137;
  }
  else
  {
    *float v136 = v137;
    int v138 = v135[1];
  }
  v136[1] = v138;
  uint64_t v139 = *(unsigned int *)(a1 + 20);
  uint64_t v140 = *(void *)(a1 + 8) - 4 * v139;
  float v141 = (int *)(v140 + 4 * (v139 + 8 * *(_DWORD *)(a1 + 16)));
  uint64_t v142 = *(void *)(v92 + 96);
  int v143 = *v141;
  if (v140 == v142)
  {
    int v144 = v141[1];
    *(_DWORD *)(v142 + 8) = v143;
  }
  else
  {
    *(_DWORD *)(v142 + 8) = v143;
    int v144 = v141[1];
  }
  *(_DWORD *)(v142 + 12) = v144;
  uint64_t v145 = *(unsigned int *)(a1 + 20);
  uint64_t v146 = *(void *)(a1 + 8) - 4 * v145;
  int v147 = (int *)(v146 + 4 * (9 * *(_DWORD *)(a1 + 16) + v145));
  uint64_t v148 = *(void *)(v92 + 96);
  int v149 = *v147;
  if (v146 == v148)
  {
    int v150 = v147[1];
    *(_DWORD *)(v148 + 16) = v149;
  }
  else
  {
    *(_DWORD *)(v148 + 16) = v149;
    int v150 = v147[1];
  }
  *(_DWORD *)(v148 + 20) = v150;
  uint64_t v151 = *(unsigned int *)(a1 + 20);
  uint64_t v152 = *(void *)(a1 + 8) - 4 * v151;
  unint64_t v153 = (int *)(v152 + 4 * (v151 + 10 * *(_DWORD *)(a1 + 16)));
  uint64_t v154 = *(void *)(v92 + 96);
  int v155 = *v153;
  if (v152 == v154)
  {
    int v156 = v153[1];
    *(_DWORD *)(v154 + 24) = v155;
  }
  else
  {
    *(_DWORD *)(v154 + 24) = v155;
    int v156 = v153[1];
  }
  *(_DWORD *)(v154 + 28) = v156;
  uint64_t v157 = *(unsigned int *)(a1 + 20);
  uint64_t v158 = *(void *)(a1 + 8) - 4 * v157;
  uint64_t v159 = (int *)(v158 + 4 * (v157 + 11 * *(_DWORD *)(a1 + 16)));
  uint64_t v160 = *(void *)(v92 + 96);
  int v161 = *v159;
  if (v158 == v160)
  {
    int v162 = v159[1];
    *(_DWORD *)(v160 + 32) = v161;
  }
  else
  {
    *(_DWORD *)(v160 + 32) = v161;
    int v162 = v159[1];
  }
  *(_DWORD *)(v160 + 36) = v162;
  uint64_t v163 = *(unsigned int *)(a1 + 20);
  uint64_t v164 = *(void *)(a1 + 8) - 4 * v163;
  unint64_t v165 = (int *)(v164 + 4 * (v163 + 12 * *(_DWORD *)(a1 + 16)));
  uint64_t v166 = *(void *)(v92 + 96);
  int v167 = *v165;
  if (v164 == v166)
  {
    int v168 = v165[1];
    *(_DWORD *)(v166 + 40) = v167;
  }
  else
  {
    *(_DWORD *)(v166 + 40) = v167;
    int v168 = v165[1];
  }
  *(_DWORD *)(v166 + 44) = v168;
  uint64_t v169 = *(unsigned int *)(a1 + 20);
  uint64_t v170 = *(void *)(a1 + 8) - 4 * v169;
  unint64_t v171 = (int *)(v170 + 4 * (v169 + 13 * *(_DWORD *)(a1 + 16)));
  uint64_t v172 = *(void *)(v92 + 96);
  int v173 = *v171;
  if (v170 == v172)
  {
    int v174 = v171[1];
    *(_DWORD *)(v172 + 48) = v173;
  }
  else
  {
    *(_DWORD *)(v172 + 48) = v173;
    int v174 = v171[1];
  }
  *(_DWORD *)(v172 + 52) = v174;
  uint64_t v175 = *a2;
  uint64_t v176 = *(unsigned int *)(a1 + 20);
  uint64_t v177 = *(void *)(a1 + 8) - 4 * v176;
  int v178 = (int *)(v177 + 4 * (v176 + 14 * *(_DWORD *)(a1 + 16)));
  uint64_t v179 = *(void *)(*a2 + 360);
  int v180 = *v178;
  if (v177 == v179)
  {
    int v181 = v178[1];
    *(_DWORD *)(v179 + 40) = v180;
  }
  else
  {
    *(_DWORD *)(v179 + 40) = v180;
    int v181 = v178[1];
  }
  *(_DWORD *)(v179 + 44) = v181;
  uint64_t v182 = *(unsigned int *)(a1 + 20);
  unint64_t v183 = (_DWORD *)(*(void *)(a1 + 8) - 4 * v182);
  unint64_t v184 = &v183[(v182 + 14 * *(_DWORD *)(a1 + 16))];
  unint64_t v185 = *(_DWORD **)(v175 + 360);
  int v186 = *v184;
  if (v183 == v185)
  {
    int v187 = v184[1];
    *unint64_t v183 = v186;
  }
  else
  {
    *unint64_t v185 = v186;
    int v187 = v184[1];
  }
  v185[1] = v187;
  uint64_t v188 = *(unsigned int *)(a1 + 20);
  uint64_t v189 = *(void *)(a1 + 8) - 4 * v188;
  int v190 = (int *)(v189 + 4 * (v188 - *(_DWORD *)(a1 + 16) + 16 * *(_DWORD *)(a1 + 16)));
  uint64_t v191 = *(void *)(v175 + 360);
  int v192 = *v190;
  if (v189 == v191)
  {
    int v193 = v190[1];
    *(_DWORD *)(v191 + 32) = v192;
  }
  else
  {
    *(_DWORD *)(v191 + 32) = v192;
    int v193 = v190[1];
  }
  *(_DWORD *)(v191 + 36) = v193;
  uint64_t v194 = *(unsigned int *)(a1 + 20);
  uint64_t v195 = *(void *)(a1 + 8) - 4 * v194;
  int v196 = (int *)(v195 + 4 * (v194 - *(_DWORD *)(a1 + 16) + 16 * *(_DWORD *)(a1 + 16)));
  uint64_t v197 = *(void *)(v175 + 360);
  int v198 = *v196;
  if (v195 == v197)
  {
    int v199 = v196[1];
    *(_DWORD *)(v197 + 8) = v198;
  }
  else
  {
    *(_DWORD *)(v197 + 8) = v198;
    int v199 = v196[1];
  }
  *(_DWORD *)(v197 + 12) = v199;
  uint64_t v200 = *(unsigned int *)(a1 + 20);
  uint64_t v201 = *(void *)(a1 + 8) - 4 * v200;
  unint64_t v202 = (int *)(v201 + 4 * (v200 + 16 * *(_DWORD *)(a1 + 16)));
  uint64_t v203 = *(void *)(v175 + 360);
  int v204 = *v202;
  if (v201 == v203)
  {
    int v205 = v202[1];
    *(_DWORD *)(v203 + 24) = v204;
  }
  else
  {
    *(_DWORD *)(v203 + 24) = v204;
    int v205 = v202[1];
  }
  *(_DWORD *)(v203 + 28) = v205;
  uint64_t v206 = *(unsigned int *)(a1 + 20);
  uint64_t v207 = *(void *)(a1 + 8) - 4 * v206;
  int32x4_t v208 = (int *)(v207 + 4 * (v206 + 16 * *(_DWORD *)(a1 + 16)));
  uint64_t v209 = *(void *)(v175 + 360);
  int v210 = *v208;
  if (v207 == v209)
  {
    int v211 = v208[1];
    *(_DWORD *)(v209 + 16) = v210;
  }
  else
  {
    *(_DWORD *)(v209 + 16) = v210;
    int v211 = v208[1];
  }
  *(_DWORD *)(v209 + 20) = v211;
  uint64_t v212 = *(unsigned int *)(a1 + 20);
  uint64_t v213 = *(void *)(a1 + 8) - 4 * v212;
  int v214 = (int *)(v213 + 4 * (17 * *(_DWORD *)(a1 + 16) + v212));
  uint64_t v215 = *(void *)(v175 + 336);
  int v216 = *v214;
  if (v213 == v215)
  {
    int v217 = v214[1];
    *(_DWORD *)(v215 + 40) = v216;
  }
  else
  {
    *(_DWORD *)(v215 + 40) = v216;
    int v217 = v214[1];
  }
  *(_DWORD *)(v215 + 44) = v217;
  uint64_t v218 = *(unsigned int *)(a1 + 20);
  unint64_t v219 = (_DWORD *)(*(void *)(a1 + 8) - 4 * v218);
  unint64_t v220 = &v219[(17 * *(_DWORD *)(a1 + 16) + v218)];
  unint64_t v221 = *(_DWORD **)(v175 + 336);
  int v222 = *v220;
  if (v219 == v221)
  {
    int v223 = v220[1];
    *unint64_t v219 = v222;
  }
  else
  {
    *unint64_t v221 = v222;
    int v223 = v220[1];
  }
  v221[1] = v223;
  uint64_t v224 = *(unsigned int *)(a1 + 20);
  uint64_t v225 = *(void *)(a1 + 8) - 4 * v224;
  int v226 = (int *)(v225 + 4 * (v224 + 18 * *(_DWORD *)(a1 + 16)));
  uint64_t v227 = *(void *)(v175 + 336);
  int v228 = *v226;
  if (v225 == v227)
  {
    int v229 = v226[1];
    *(_DWORD *)(v227 + 32) = v228;
  }
  else
  {
    *(_DWORD *)(v227 + 32) = v228;
    int v229 = v226[1];
  }
  *(_DWORD *)(v227 + 36) = v229;
  uint64_t v230 = *(unsigned int *)(a1 + 20);
  uint64_t v231 = *(void *)(a1 + 8) - 4 * v230;
  uint64_t v232 = (int *)(v231 + 4 * (v230 + 18 * *(_DWORD *)(a1 + 16)));
  uint64_t v233 = *(void *)(v175 + 336);
  int v234 = *v232;
  if (v231 == v233)
  {
    int v235 = v232[1];
    *(_DWORD *)(v233 + 8) = v234;
  }
  else
  {
    *(_DWORD *)(v233 + 8) = v234;
    int v235 = v232[1];
  }
  *(_DWORD *)(v233 + 12) = v235;
  uint64_t v236 = *(unsigned int *)(a1 + 20);
  uint64_t v237 = *(void *)(a1 + 8) - 4 * v236;
  int v238 = (int *)(v237 + 4 * (v236 + 19 * *(_DWORD *)(a1 + 16)));
  uint64_t v239 = *(void *)(v175 + 336);
  int v240 = *v238;
  if (v237 == v239)
  {
    int v241 = v238[1];
    *(_DWORD *)(v239 + 24) = v240;
  }
  else
  {
    *(_DWORD *)(v239 + 24) = v240;
    int v241 = v238[1];
  }
  *(_DWORD *)(v239 + 28) = v241;
  uint64_t v242 = *(unsigned int *)(a1 + 20);
  uint64_t v243 = *(void *)(a1 + 8) - 4 * v242;
  int v244 = (int *)(v243 + 4 * (v242 + 19 * *(_DWORD *)(a1 + 16)));
  uint64_t v245 = *(void *)(v175 + 336);
  int v246 = *v244;
  if (v243 == v245)
  {
    int v247 = v244[1];
    *(_DWORD *)(v245 + 16) = v246;
  }
  else
  {
    *(_DWORD *)(v245 + 16) = v246;
    int v247 = v244[1];
  }
  *(_DWORD *)(v245 + 20) = v247;
  uint64_t v248 = *a2;
  uint64_t v249 = *(unsigned int *)(a1 + 20);
  unint64_t v250 = (_DWORD *)(*(void *)(a1 + 8) - 4 * v249);
  unint64_t v251 = &v250[(v249 + 20 * *(_DWORD *)(a1 + 16))];
  int8x16_t v252 = *(_DWORD **)(*a2 + 528);
  int v253 = *v251;
  if (v250 == v252)
  {
    int v254 = v251[1];
    _DWORD *v250 = v253;
  }
  else
  {
    *int8x16_t v252 = v253;
    int v254 = v251[1];
  }
  v252[1] = v254;
  uint64_t v255 = *(unsigned int *)(a1 + 20);
  uint64_t v256 = *(void *)(a1 + 8) - 4 * v255;
  float v257 = (int *)(v256 + 4 * (v255 + 21 * *(_DWORD *)(a1 + 16)));
  uint64_t v258 = *(void *)(v248 + 528);
  int v259 = *v257;
  if (v256 == v258)
  {
    int v260 = v257[1];
    *(_DWORD *)(v258 + 8) = v259;
  }
  else
  {
    *(_DWORD *)(v258 + 8) = v259;
    int v260 = v257[1];
  }
  *(_DWORD *)(v258 + 12) = v260;
  uint64_t v261 = *(unsigned int *)(a1 + 20);
  uint64_t v262 = *(void *)(a1 + 8) - 4 * v261;
  uint64_t v263 = (int *)(v262 + 4 * (v261 + 22 * *(_DWORD *)(a1 + 16)));
  uint64_t v264 = *(void *)(v248 + 528);
  int v265 = *v263;
  if (v262 == v264)
  {
    int v266 = v263[1];
    *(_DWORD *)(v264 + 16) = v265;
  }
  else
  {
    *(_DWORD *)(v264 + 16) = v265;
    int v266 = v263[1];
  }
  *(_DWORD *)(v264 + 20) = v266;
  uint64_t v267 = *(unsigned int *)(a1 + 20);
  uint64_t v268 = *(void *)(a1 + 8) - 4 * v267;
  int32x4_t v269 = (int *)(v268 + 4 * (v267 + 23 * *(_DWORD *)(a1 + 16)));
  uint64_t v270 = *(void *)(v248 + 528);
  int v271 = *v269;
  if (v268 == v270)
  {
    int v272 = v269[1];
    *(_DWORD *)(v270 + 24) = v271;
  }
  else
  {
    *(_DWORD *)(v270 + 24) = v271;
    int v272 = v269[1];
  }
  *(_DWORD *)(v270 + 28) = v272;
  uint64_t v273 = *(unsigned int *)(a1 + 20);
  uint64_t v274 = *(void *)(a1 + 8) - 4 * v273;
  unint64_t v275 = (int *)(v274 + 4 * (v273 + 24 * *(_DWORD *)(a1 + 16)));
  uint64_t v276 = *(void *)(v248 + 528);
  int v277 = *v275;
  if (v274 == v276)
  {
    int v278 = v275[1];
    *(_DWORD *)(v276 + 32) = v277;
  }
  else
  {
    *(_DWORD *)(v276 + 32) = v277;
    int v278 = v275[1];
  }
  *(_DWORD *)(v276 + 36) = v278;
  uint64_t v279 = *(unsigned int *)(a1 + 20);
  uint64_t v280 = *(void *)(a1 + 8) - 4 * v279;
  int64_t v281 = (int *)(v280 + 4 * (v279 + 25 * *(_DWORD *)(a1 + 16)));
  uint64_t v282 = *(void *)(v248 + 528);
  int v283 = *v281;
  if (v280 == v282)
  {
    int v284 = v281[1];
    *(_DWORD *)(v282 + 40) = v283;
  }
  else
  {
    *(_DWORD *)(v282 + 40) = v283;
    int v284 = v281[1];
  }
  *(_DWORD *)(v282 + 44) = v284;
  uint64_t v285 = *(unsigned int *)(a1 + 20);
  uint64_t v286 = *(void *)(a1 + 8) - 4 * v285;
  uint64_t v287 = (int *)(v286 + 4 * (v285 + 26 * *(_DWORD *)(a1 + 16)));
  uint64_t v288 = *(void *)(v248 + 528);
  int v289 = *v287;
  if (v286 == v288)
  {
    int v290 = v287[1];
    *(_DWORD *)(v288 + 48) = v289;
  }
  else
  {
    *(_DWORD *)(v288 + 48) = v289;
    int v290 = v287[1];
  }
  *(_DWORD *)(v288 + 52) = v290;
  uint64_t v291 = *(unsigned int *)(a1 + 20);
  uint64_t v292 = *(void *)(a1 + 8) - 4 * v291;
  int v293 = (int *)(v292 + 4 * (v291 + 27 * *(_DWORD *)(a1 + 16)));
  uint64_t v294 = *(void *)(v248 + 528);
  int v295 = *v293;
  if (v292 == v294)
  {
    int v296 = v293[1];
    *(_DWORD *)(v294 + 56) = v295;
  }
  else
  {
    *(_DWORD *)(v294 + 56) = v295;
    int v296 = v293[1];
  }
  *(_DWORD *)(v294 + 60) = v296;
  uint64_t v297 = *(unsigned int *)(a1 + 20);
  uint64_t v298 = *(void *)(a1 + 8) - 4 * v297;
  float v299 = (int *)(v298 + 4 * (v297 + 28 * *(_DWORD *)(a1 + 16)));
  uint64_t v300 = *(void *)(v248 + 528);
  int v301 = *v299;
  if (v298 == v300)
  {
    int v302 = v299[1];
    *(_DWORD *)(v300 + 64) = v301;
  }
  else
  {
    *(_DWORD *)(v300 + 64) = v301;
    int v302 = v299[1];
  }
  *(_DWORD *)(v300 + 68) = v302;
  uint64_t v303 = *(unsigned int *)(a1 + 20);
  uint64_t v304 = *(void *)(a1 + 8) - 4 * v303;
  uint64_t v305 = (int *)(v304 + 4 * (v303 + 29 * *(_DWORD *)(a1 + 16)));
  uint64_t v306 = *(void *)(v248 + 528);
  int v307 = *v305;
  if (v304 == v306)
  {
    int v308 = v305[1];
    *(_DWORD *)(v306 + 72) = v307;
  }
  else
  {
    *(_DWORD *)(v306 + 72) = v307;
    int v308 = v305[1];
  }
  *(_DWORD *)(v306 + 76) = v308;
  uint64_t v309 = *(unsigned int *)(a1 + 20);
  uint64_t v310 = *(void *)(a1 + 8) - 4 * v309;
  int v311 = (int *)(v310 + 4 * (v309 + 30 * *(_DWORD *)(a1 + 16)));
  uint64_t v312 = *(void *)(v248 + 528);
  int v313 = *v311;
  if (v310 == v312)
  {
    int v314 = v311[1];
    *(_DWORD *)(v312 + 80) = v313;
  }
  else
  {
    *(_DWORD *)(v312 + 80) = v313;
    int v314 = v311[1];
  }
  *(_DWORD *)(v312 + 84) = v314;
  uint64_t v315 = *(unsigned int *)(a1 + 20);
  uint64_t v316 = *(void *)(a1 + 8) - 4 * v315;
  uint64_t v317 = (int *)(v316 + 4 * (v315 - *(_DWORD *)(a1 + 16) + 32 * *(_DWORD *)(a1 + 16)));
  uint64_t v318 = *(void *)(v248 + 528);
  int v319 = *v317;
  if (v316 == v318)
  {
    int v320 = v317[1];
    *(_DWORD *)(v318 + 88) = v319;
  }
  else
  {
    *(_DWORD *)(v318 + 88) = v319;
    int v320 = v317[1];
  }
  *(_DWORD *)(v318 + 92) = v320;
  uint64_t v321 = *(unsigned int *)(a1 + 20);
  uint64_t v322 = *(void *)(a1 + 8) - 4 * v321;
  uint64_t v323 = (int *)(v322 + 4 * (v321 + 32 * *(_DWORD *)(a1 + 16)));
  uint64_t v324 = *(void *)(v248 + 528);
  int v325 = *v323;
  if (v322 == v324)
  {
    int v326 = v323[1];
    *(_DWORD *)(v324 + 96) = v325;
  }
  else
  {
    *(_DWORD *)(v324 + 96) = v325;
    int v326 = v323[1];
  }
  *(_DWORD *)(v324 + 100) = v326;
  uint64_t v327 = *(unsigned int *)(a1 + 20);
  uint64_t v328 = *(void *)(a1 + 8) - 4 * v327;
  unint64_t v329 = (int *)(v328 + 4 * (33 * *(_DWORD *)(a1 + 16) + v327));
  uint64_t v330 = *(void *)(v248 + 528);
  int v331 = *v329;
  if (v328 == v330)
  {
    int v332 = v329[1];
    *(_DWORD *)(v330 + 104) = v331;
  }
  else
  {
    *(_DWORD *)(v330 + 104) = v331;
    int v332 = v329[1];
  }
  *(_DWORD *)(v330 + 108) = v332;
  uint64_t v333 = *(unsigned int *)(a1 + 20);
  uint64_t v334 = *(void *)(a1 + 8) - 4 * v333;
  uint64_t v335 = (int *)(v334 + 4 * (v333 + 34 * *(_DWORD *)(a1 + 16)));
  uint64_t v336 = *(void *)(v248 + 528);
  int v337 = *v335;
  if (v334 == v336)
  {
    int v338 = v335[1];
    *(_DWORD *)(v336 + 112) = v337;
  }
  else
  {
    *(_DWORD *)(v336 + 112) = v337;
    int v338 = v335[1];
  }
  *(_DWORD *)(v336 + 116) = v338;
  uint64_t v339 = *(unsigned int *)(a1 + 20);
  uint64_t v340 = *(void *)(a1 + 8) - 4 * v339;
  unint64_t v341 = (int *)(v340 + 4 * (v339 + 35 * *(_DWORD *)(a1 + 16)));
  uint64_t v342 = *(void *)(v248 + 528);
  int v343 = *v341;
  if (v340 == v342)
  {
    int v344 = v341[1];
    *(_DWORD *)(v342 + 120) = v343;
  }
  else
  {
    *(_DWORD *)(v342 + 120) = v343;
    int v344 = v341[1];
  }
  *(_DWORD *)(v342 + 124) = v344;
  uint64_t v345 = *(unsigned int *)(a1 + 20);
  uint64_t v346 = *(void *)(a1 + 8) - 4 * v345;
  uint64_t v347 = (int *)(v346 + 4 * (v345 + 36 * *(_DWORD *)(a1 + 16)));
  uint64_t v348 = *(void *)(v248 + 528);
  int v349 = *v347;
  if (v346 == v348)
  {
    int v350 = v347[1];
    *(_DWORD *)(v348 + 128) = v349;
  }
  else
  {
    *(_DWORD *)(v348 + 128) = v349;
    int v350 = v347[1];
  }
  *(_DWORD *)(v348 + 132) = v350;
  uint64_t v351 = *(unsigned int *)(a1 + 20);
  uint64_t v352 = *(void *)(a1 + 8) - 4 * v351;
  float v353 = (int *)(v352 + 4 * (v351 + 37 * *(_DWORD *)(a1 + 16)));
  uint64_t v354 = *(void *)(v248 + 528);
  int v355 = *v353;
  if (v352 == v354)
  {
    int v356 = v353[1];
    *(_DWORD *)(v354 + 136) = v355;
  }
  else
  {
    *(_DWORD *)(v354 + 136) = v355;
    int v356 = v353[1];
  }
  *(_DWORD *)(v354 + 140) = v356;
  uint64_t v357 = *(unsigned int *)(a1 + 20);
  uint64_t v358 = *(void *)(a1 + 8) - 4 * v357;
  uint64_t v359 = (int *)(v358 + 4 * (v357 + 38 * *(_DWORD *)(a1 + 16)));
  uint64_t v360 = *(void *)(v248 + 528);
  int v361 = *v359;
  if (v358 == v360)
  {
    int v362 = v359[1];
    *(_DWORD *)(v360 + 144) = v361;
  }
  else
  {
    *(_DWORD *)(v360 + 144) = v361;
    int v362 = v359[1];
  }
  *(_DWORD *)(v360 + 148) = v362;
  uint64_t v363 = *(unsigned int *)(a1 + 20);
  uint64_t v364 = *(void *)(a1 + 8) - 4 * v363;
  uint64_t v365 = (int *)(v364 + 4 * (v363 + 39 * *(_DWORD *)(a1 + 16)));
  uint64_t v366 = *(void *)(v248 + 528);
  int v367 = *v365;
  if (v364 == v366)
  {
    int v368 = v365[1];
    *(_DWORD *)(v366 + 152) = v367;
  }
  else
  {
    *(_DWORD *)(v366 + 152) = v367;
    int v368 = v365[1];
  }
  *(_DWORD *)(v366 + 156) = v368;
  uint64_t v369 = *a2;
  uint64_t v370 = *(unsigned int *)(a1 + 20);
  float v371 = (_DWORD *)(*(void *)(a1 + 8) - 4 * v370);
  float v372 = &v371[(v370 + 40 * *(_DWORD *)(a1 + 16))];
  uint64_t v373 = *(_DWORD **)(*a2 + 648);
  int v374 = *v372;
  if (v371 == v373)
  {
    int v375 = v372[1];
    _DWORD *v371 = v374;
  }
  else
  {
    *uint64_t v373 = v374;
    int v375 = v372[1];
  }
  v373[1] = v375;
  uint64_t v376 = *(unsigned int *)(a1 + 20);
  uint64_t v377 = *(void *)(a1 + 8) - 4 * v376;
  uint64_t v378 = (int *)(v377 + 4 * (v376 + 41 * *(_DWORD *)(a1 + 16)));
  uint64_t v379 = *(void *)(v369 + 648);
  int v380 = *v378;
  if (v377 == v379)
  {
    int v381 = v378[1];
    *(_DWORD *)(v379 + 8) = v380;
  }
  else
  {
    *(_DWORD *)(v379 + 8) = v380;
    int v381 = v378[1];
  }
  *(_DWORD *)(v379 + 12) = v381;
  uint64_t v382 = *(unsigned int *)(a1 + 20);
  uint64_t v383 = *(void *)(a1 + 8) - 4 * v382;
  unsigned int v384 = (int *)(v383 + 4 * (v382 + 42 * *(_DWORD *)(a1 + 16)));
  uint64_t v385 = *(void *)(v369 + 648);
  int v386 = *v384;
  if (v383 == v385)
  {
    int v387 = v384[1];
    *(_DWORD *)(v385 + 16) = v386;
  }
  else
  {
    *(_DWORD *)(v385 + 16) = v386;
    int v387 = v384[1];
  }
  *(_DWORD *)(v385 + 20) = v387;
  uint64_t v388 = *(unsigned int *)(a1 + 20);
  uint64_t v389 = *(void *)(a1 + 8) - 4 * v388;
  float v390 = (int *)(v389 + 4 * (v388 + 43 * *(_DWORD *)(a1 + 16)));
  uint64_t v391 = *(void *)(v369 + 648);
  int v392 = *v390;
  if (v389 == v391)
  {
    int v393 = v390[1];
    *(_DWORD *)(v391 + 24) = v392;
  }
  else
  {
    *(_DWORD *)(v391 + 24) = v392;
    int v393 = v390[1];
  }
  *(_DWORD *)(v391 + 28) = v393;
  uint64_t v394 = *(unsigned int *)(a1 + 20);
  uint64_t v395 = *(void *)(a1 + 8) - 4 * v394;
  uint64_t v396 = (int *)(v395 + 4 * (v394 + 44 * *(_DWORD *)(a1 + 16)));
  uint64_t v397 = *(void *)(v369 + 648);
  int v398 = *v396;
  if (v395 == v397)
  {
    int v399 = v396[1];
    *(_DWORD *)(v397 + 32) = v398;
  }
  else
  {
    *(_DWORD *)(v397 + 32) = v398;
    int v399 = v396[1];
  }
  *(_DWORD *)(v397 + 36) = v399;
  uint64_t v400 = *(unsigned int *)(a1 + 20);
  uint64_t v401 = *(void *)(a1 + 8) - 4 * v400;
  v402 = (int *)(v401 + 4 * (v400 + 45 * *(_DWORD *)(a1 + 16)));
  uint64_t v403 = *(void *)(v369 + 648);
  int v404 = *v402;
  if (v401 == v403)
  {
    int v405 = v402[1];
    *(_DWORD *)(v403 + 40) = v404;
  }
  else
  {
    *(_DWORD *)(v403 + 40) = v404;
    int v405 = v402[1];
  }
  *(_DWORD *)(v403 + 44) = v405;
  uint64_t v406 = *(unsigned int *)(a1 + 20);
  uint64_t v407 = *(void *)(a1 + 8) - 4 * v406;
  v408 = (int *)(v407 + 4 * (v406 + 46 * *(_DWORD *)(a1 + 16)));
  uint64_t v409 = *(void *)(v369 + 648);
  int v410 = *v408;
  if (v407 == v409)
  {
    int v411 = v408[1];
    *(_DWORD *)(v409 + 48) = v410;
  }
  else
  {
    *(_DWORD *)(v409 + 48) = v410;
    int v411 = v408[1];
  }
  *(_DWORD *)(v409 + 52) = v411;
  uint64_t v412 = *(unsigned int *)(a1 + 20);
  uint64_t v413 = *(void *)(a1 + 8) - 4 * v412;
  int8x16_t v414 = (int *)(v413 + 4 * (v412 + 47 * *(_DWORD *)(a1 + 16)));
  uint64_t v415 = *(void *)(v369 + 648);
  int v416 = *v414;
  if (v413 == v415)
  {
    int v417 = v414[1];
    *(_DWORD *)(v415 + 56) = v416;
  }
  else
  {
    *(_DWORD *)(v415 + 56) = v416;
    int v417 = v414[1];
  }
  *(_DWORD *)(v415 + 60) = v417;
  uint64_t v418 = *(unsigned int *)(a1 + 20);
  uint64_t v419 = *(void *)(a1 + 8) - 4 * v418;
  uint64_t v420 = (int *)(v419 + 4 * (v418 + 48 * *(_DWORD *)(a1 + 16)));
  uint64_t v421 = *(void *)(v369 + 648);
  int v422 = *v420;
  if (v419 == v421)
  {
    int v423 = v420[1];
    *(_DWORD *)(v421 + 64) = v422;
  }
  else
  {
    *(_DWORD *)(v421 + 64) = v422;
    int v423 = v420[1];
  }
  *(_DWORD *)(v421 + 68) = v423;
  uint64_t v424 = *(unsigned int *)(a1 + 20);
  uint64_t v425 = *(void *)(a1 + 8) - 4 * v424;
  uint64_t v426 = (int *)(v425 + 4 * (v424 + 49 * *(_DWORD *)(a1 + 16)));
  uint64_t v427 = *(void *)(v369 + 648);
  int v428 = *v426;
  if (v425 == v427)
  {
    int v429 = v426[1];
    *(_DWORD *)(v427 + 72) = v428;
  }
  else
  {
    *(_DWORD *)(v427 + 72) = v428;
    int v429 = v426[1];
  }
  *(_DWORD *)(v427 + 76) = v429;
  uint64_t v430 = *(unsigned int *)(a1 + 20);
  uint64_t v431 = *(void *)(a1 + 8) - 4 * v430;
  float32x2_t v432 = (int *)(v431 + 4 * (v430 + 50 * *(_DWORD *)(a1 + 16)));
  uint64_t v433 = *(void *)(v369 + 648);
  int v434 = *v432;
  if (v431 == v433)
  {
    int v435 = v432[1];
    *(_DWORD *)(v433 + 80) = v434;
  }
  else
  {
    *(_DWORD *)(v433 + 80) = v434;
    int v435 = v432[1];
  }
  *(_DWORD *)(v433 + 84) = v435;
  uint64_t v436 = *(unsigned int *)(a1 + 20);
  uint64_t v437 = *(void *)(a1 + 8) - 4 * v436;
  int v438 = (int *)(v437 + 4 * (v436 + 51 * *(_DWORD *)(a1 + 16)));
  uint64_t v439 = *(void *)(v369 + 648);
  int v440 = *v438;
  if (v437 == v439)
  {
    int v441 = v438[1];
    *(_DWORD *)(v439 + 88) = v440;
  }
  else
  {
    *(_DWORD *)(v439 + 88) = v440;
    int v441 = v438[1];
  }
  *(_DWORD *)(v439 + 92) = v441;
  uint64_t v442 = *(unsigned int *)(a1 + 20);
  uint64_t v443 = *(void *)(a1 + 8) - 4 * v442;
  unsigned int v444 = (int *)(v443 + 4 * (v442 + 52 * *(_DWORD *)(a1 + 16)));
  uint64_t v445 = *(void *)(v369 + 648);
  int v446 = *v444;
  if (v443 == v445)
  {
    int v447 = v444[1];
    *(_DWORD *)(v445 + 96) = v446;
  }
  else
  {
    *(_DWORD *)(v445 + 96) = v446;
    int v447 = v444[1];
  }
  *(_DWORD *)(v445 + 100) = v447;
  int32x4_t v448 = operator new(0x34uLL);
  v448[12] = 53;
  *(_OWORD *)int32x4_t v448 = xmmword_1D0E8191C;
  *((_OWORD *)v448 + 1) = unk_1D0E8192C;
  *((_OWORD *)v448 + 2) = xmmword_1D0E8193C;
  memptr = 0;
  malloc_type_posix_memalign(&memptr, 0x20uLL, 0x80uLL, 0x49090899uLL);
  int32x4_t v449 = (char *)memptr;
  uint64_t v450 = *(void *)(a1 + 8);
  int v451 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)memptr = *(_DWORD *)(v450 + 4 * (60 * v451));
  *((_DWORD *)v449 + 1) = *(_DWORD *)(v450 + 4 * ((60 * v451) | 1u));
  *((_DWORD *)v449 + 2) = *(_DWORD *)(v450 + 4 * (61 * v451));
  int32x4_t v452 = (float *)(v449 + 8);
  *((_DWORD *)v449 + 3) = *(_DWORD *)(v450 + 4 * (61 * v451 + 1));
  *((_DWORD *)v449 + 4) = *(_DWORD *)(v450 + 4 * (62 * v451));
  *((_DWORD *)v449 + 5) = *(_DWORD *)(v450 + 4 * ((62 * v451) | 1u));
  *((_DWORD *)v449 + 6) = *(_DWORD *)(v450 + 4 * (63 * v451));
  *((_DWORD *)v449 + 7) = *(_DWORD *)(v450 + 4 * (63 * v451 + 1));
  *((_DWORD *)v449 + 8) = *(_DWORD *)(v450 + 4 * (v451 << 6));
  *((_DWORD *)v449 + 9) = *(_DWORD *)(v450 + 4 * ((v451 << 6) | 1u));
  *((_DWORD *)v449 + 10) = *(_DWORD *)(v450 + 4 * (65 * v451));
  *((_DWORD *)v449 + 11) = *(_DWORD *)(v450 + 4 * (65 * v451 + 1));
  *((_DWORD *)v449 + 12) = *(_DWORD *)(v450 + 4 * (59 * v451));
  *((_DWORD *)v449 + 13) = *(_DWORD *)(v450 + 4 * (59 * v451 + 1));
  *((_DWORD *)v449 + 14) = *(_DWORD *)(v450 + 4 * (58 * v451));
  *((_DWORD *)v449 + 15) = *(_DWORD *)(v450 + 4 * ((58 * v451) | 1u));
  unsigned int v453 = v448[8] * v451;
  *((_DWORD *)v449 + 16) = *(_DWORD *)(v450 + 4 * v453);
  *((_DWORD *)v449 + 17) = *(_DWORD *)(v450 + 4 * (v453 + 1));
  unsigned int v454 = v448[9] * v451;
  *((_DWORD *)v449 + 18) = *(_DWORD *)(v450 + 4 * v454);
  *((_DWORD *)v449 + 19) = *(_DWORD *)(v450 + 4 * (v454 + 1));
  unsigned int v455 = v448[10] * v451;
  *((_DWORD *)v449 + 20) = *(_DWORD *)(v450 + 4 * v455);
  *((_DWORD *)v449 + 21) = *(_DWORD *)(v450 + 4 * (v455 + 1));
  unsigned int v456 = v448[11] * v451;
  *((_DWORD *)v449 + 22) = *(_DWORD *)(v450 + 4 * v456);
  *((_DWORD *)v449 + 23) = *(_DWORD *)(v450 + 4 * (v456 + 1));
  std::string __p = v448;
  unsigned int v457 = v448[12] * v451;
  *((_DWORD *)v449 + 24) = *(_DWORD *)(v450 + 4 * v457);
  *((_DWORD *)v449 + 25) = *(_DWORD *)(v450 + 4 * (v457 + 1));
  uint64_t v577 = 12;
  memptr = 0;
  malloc_type_posix_memalign(&memptr, 0x20uLL, 0x180uLL, 0x49090899uLL);
  int32x4_t v458 = (char *)memptr;
  float32x4_t v576 = memptr;
  unsigned int v578 = 12;
  int32x4_t v459 = operator new(0x34uLL);
  *int32x4_t v459 = 0u;
  v459[1] = 0u;
  v459[2] = 0u;
  *((_DWORD *)v459 + 12) = 0;
  *(_DWORD *)int32x4_t v459 = 0;
  float v460 = 0.0;
  for (uint64_t i = 4; i != 52; i += 4)
  {
    float v460 = v460
         + powf((float)((float)(*v452 - *(v452 - 2)) * (float)(*v452 - *(v452 - 2)))+ (float)((float)(v452[1] - *(v452 - 1)) * (float)(v452[1] - *(v452 - 1))), 0.25);
    *(float *)((char *)v459 + i) = v460;
    v452 += 2;
  }
  uint64_t v465 = 0;
  uint64_t v466 = (int *)(v449 + 12);
  uint64_t v467 = -384;
  int v468 = 2;
  float32x2_t v469 = (float32x2_t)vdup_n_s32(0x3727C5ACu);
  do
  {
    int v480 = v468 - 3;
    if (v467 == -384) {
      int v480 = 0;
    }
    if (v468 >= 12) {
      int v481 = 12;
    }
    else {
      int v481 = v468;
    }
    v464.i32[0] = *((_DWORD *)v459 + v481);
    v462.i64[0] = *(void *)((char *)v459 + v465);
    v463.i32[0] = *((_DWORD *)v459 + v480);
    float32x2_t v482 = *(float32x2_t *)&v449[8 * v481];
    float32x2_t v483 = *(float32x2_t *)(v466 - 1);
    float32x2_t v484 = *(float32x2_t *)(v466 - 3);
    float32x2_t v485 = *(float32x2_t *)&v449[8 * v480];
    float32x4_t v486 = &v458[v467 + 384];
    if (v486 == v449)
    {
      int v487 = HIDWORD(*(void *)(v466 - 3));
      *(_DWORD *)int32x4_t v449 = v484.i32[0];
    }
    else
    {
      *(_DWORD *)float32x4_t v486 = v484.i32[0];
      int v487 = *(v466 - 2);
    }
    *(_DWORD *)&v458[v467 + 388] = v487;
    float32x4_t v488 = (char *)v576;
    float32x4_t v489 = (char *)v576 + v467;
    int v490 = *(v466 - 1);
    if ((char *)v576 + v467 + 384 == v449)
    {
      int v470 = *v466;
      *((_DWORD *)v489 + 98) = v490;
    }
    else
    {
      *((_DWORD *)v489 + 98) = v490;
      int v470 = *v466;
    }
    float v471 = fmaxf(v464.f32[0] - *(float *)&v462.i32[1], 0.00001);
    v472.i32[0] = vdup_lane_s32(*(int32x2_t *)v462.i8, 1).u32[0];
    v472.i32[1] = v464.i32[0];
    float32x2_t v473 = (float32x2_t)vzip1_s32(*(int32x2_t *)v463.f32, *(int32x2_t *)v462.i8);
    *(float32x2_t *)v464.f32 = vmaxnm_f32(vsub_f32(v472, v473), v469);
    float32x4_t v464 = (float32x4_t)vzip1q_s32((int32x4_t)v464, (int32x4_t)v464);
    *(float32x2_t *)v462.i8 = vmaxnm_f32(vsub_f32(*(float32x2_t *)v462.i8, v473), v469);
    float32x4_t v463 = (float32x4_t)vzip1q_s32(v462, v462);
    float32x2_t v474 = vsub_f32(v482, v483);
    float32x2_t v475 = vsub_f32(v482, v484);
    *(float32x2_t *)v476.f32 = vsub_f32(v483, v484);
    *(float32x2_t *)v477.f32 = vsub_f32(v483, v485);
    *(float32x2_t *)v478.f32 = vsub_f32(v484, v485);
    *(_DWORD *)&v488[v467 + 396] = v470;
    int32x4_t v458 = (char *)v576;
    v478.i64[1] = v476.i64[0];
    *(float32x2_t *)&v477.u32[2] = v475;
    *(float32x2_t *)&v476.u32[2] = v474;
    int32x4_t v479 = vdupq_lane_s32(*(int32x2_t *)v462.i8, 1);
    *(float *)&v479.i32[1] = v471;
    *(float32x4_t *)((char *)v576 + v467 + 400) = vmulq_lane_f32(vaddq_f32(vsubq_f32(vdivq_f32(v478, v463), vdivq_f32(v477, v464)), vdivq_f32(v476, (float32x4_t)vzip1q_s32(v479, v479))), *(float32x2_t *)v462.i8, 1);
    v466 += 2;
    v465 += 4;
    ++v468;
    v467 += 32;
  }
  while (v467);
  operator delete(v459);
  size_t v580 = 0;
  v607 = 0;
  malloc_type_posix_memalign(&v607, 0x20uLL, 0, 0x49090899uLL);
  float32x4_t v491 = v607;
  memptr = v607;
  int v581 = 0;
  uint64_t v583 = 0;
  v607 = 0;
  malloc_type_posix_memalign(&v607, 0x20uLL, 0, 0x49090899uLL);
  int16x8_t v582 = v607;
  int v584 = 0;
  uint64_t v586 = 0;
  v607 = 0;
  malloc_type_posix_memalign(&v607, 0x20uLL, 0, 0x49090899uLL);
  int32x4_t v492 = v607;
  v585 = v607;
  unsigned int v587 = 0;
  v588 = 0;
  size_t v589 = 0;
  int v590 = 0;
  uint64_t v493 = v578;
  *(_OWORD *)uint64_t v611 = xmmword_1D0E81470;
  v607 = v576;
  uint64_t v608 = v611;
  *(void *)&long long v610 = 0;
  sub_1D0E62278((float *)&v610, (float **)&v607);
  uint64_t v494 = v610;
  float32x4_t v495 = operator new(0x20uLL);
  v495[2] = 0;
  v495[3] = v494;
  *float32x4_t v495 = &v607;
  v495[1] = &v607;
  v607 = v495;
  uint64_t v608 = (void **)v495;
  uint64_t v496 = 1;
  uint64_t v609 = 1;
  if ((int)v493 <= 0)
  {
    int v581 = 1;
    uint64_t v504 = 2;
    int v503 = 1;
    goto LABEL_213;
  }
  float32x4_t v573 = v492;
  uint64_t v497 = 0;
  int v498 = 0;
  uint64_t v499 = 32 * v493;
  do
  {
    float32x4_t v500 = v607;
    uint64_t v605 = 0;
    v606 = (float *)v607;
    long long v610 = xmmword_1D0E81860;
    v611[0] = (char *)v576 + v497;
    v611[1] = &v610;
    sub_1D0E62278((float *)&v605, (float **)v611);
    uint64_t v501 = v605;
    int8x16_t v502 = operator new(0x20uLL);
    v502[4] = v498;
    v502[5] = 1065353216;
    *((void *)v502 + 3) = v501;
    *(void *)int8x16_t v502 = v500;
    *((void *)v502 + 1) = &v607;
    v500[1] = v502;
    v607 = v502;
    ++v609;
    v611[0] = v502;
    sub_1D0E35128((uint64_t)&v607, &v576, &v606, (float **)v611);
    ++v498;
    v497 += 32;
  }
  while (v499 != v497);
  int v503 = v609;
  uint64_t v496 = v609;
  int v581 = v609;
  uint64_t v504 = (2 * v609);
  if (v504)
  {
    int32x4_t v492 = v573;
LABEL_213:
    free(v491);
    size_t v505 = (4 * v504 + 31) & 0x7FFFFFFE0;
    size_t v580 = v505 >> 2;
    v611[0] = 0;
    malloc_type_posix_memalign(v611, 0x20uLL, v505, 0x49090899uLL);
    int32x4_t v506 = (char *)v611[0];
    memptr = v611[0];
    goto LABEL_215;
  }
  free(v491);
  int32x4_t v506 = 0;
  memptr = 0;
  size_t v580 = 0;
  int32x4_t v492 = v573;
LABEL_215:
  float32x4_t v507 = v608;
  if (v608 != &v607)
  {
    int32x4_t v508 = v506 + 4;
    do
    {
      *(v508 - 1) = *((_DWORD *)v507 + 6);
      *int32x4_t v508 = *((_DWORD *)v507 + 7);
      v508 += 2;
      float32x4_t v507 = (void **)v507[1];
    }
    while (v507 != &v607);
  }
  unsigned int v587 = 0;
  free(v492);
  v585 = 0;
  uint64_t v586 = 0;
  int v590 = v503;
  if (v503)
  {
    if (v496)
    {
      size_t v509 = (4 * v496 + 31) & 0x7FFFFFFE0;
      size_t v589 = v509 >> 2;
      v611[0] = 0;
      malloc_type_posix_memalign(v611, 0x20uLL, v509, 0x49090899uLL);
      float32x4_t v510 = (float *)v611[0];
      v588 = v611[0];
    }
    else
    {
      float32x4_t v510 = 0;
    }
  }
  else
  {
    float32x4_t v510 = 0;
    v588 = 0;
    size_t v589 = 0;
  }
  int32x4_t v511 = v608;
  if (v608 != &v607)
  {
    v512 = v608;
    do
    {
      *v510++ = *((float *)v512 + 5) + (float)*((int *)v512 + 4);
      v512 = (void **)v512[1];
    }
    while (v512 != &v607);
  }
  if (v609)
  {
    float v513 = (void **)v607;
    long long v514 = *v511;
    v514[1] = *((void *)v607 + 1);
    *v513[1] = v514;
    uint64_t v609 = 0;
    if (v511 != &v607)
    {
      do
      {
        long long v515 = (void **)v511[1];
        operator delete(v511);
        int32x4_t v511 = v515;
      }
      while (v515 != &v607);
    }
  }
  free(v576);
  int8x16_t v516 = (int *)operator new(8uLL);
  *(void *)int8x16_t v516 = 0x63F000000;
  v607 = 0;
  malloc_type_posix_memalign(&v607, 0x20uLL, 0x20uLL, 0x49090899uLL);
  float32x4_t v517 = (float *)v607;
  v607 = 0;
  malloc_type_posix_memalign(&v607, 0x20uLL, 0x20uLL, 0x49090899uLL);
  float v518 = (float *)v607;
  *float32x4_t v517 = 0.0;
  *float v518 = 0.0;
  sub_1D0E34CBC((uint64_t)&memptr, v519);
  float v520 = 0.0;
  float v521 = 0.0;
  if (!v587) {
    goto LABEL_237;
  }
  float v521 = *(float *)v585;
  if (v587 == 1) {
    goto LABEL_237;
  }
  simd_float3x3 v522 = (float *)((char *)v585 + 4);
  if (((v587 + 0x3FFFFFFFFFFFFFFELL) & 0x3FFFFFFFFFFFFFFFLL) != 0)
  {
    uint64_t v523 = ((v587 + 0x3FFFFFFFFFFFFFFELL) & 0x3FFFFFFFFFFFFFFFLL) + 1;
    v524 = (float *)((char *)v585 + 8);
    uint64_t v525 = v523 & 0x7FFFFFFFFFFFFFFELL;
    do
    {
      float v521 = (float)(v521 + *(v524 - 1)) + *v524;
      v524 += 2;
      v525 -= 2;
    }
    while (v525);
    if (v523 == (v523 & 0x7FFFFFFFFFFFFFFELL)) {
      goto LABEL_237;
    }
    v522 += v523 & 0x7FFFFFFFFFFFFFFELL;
  }
  do
  {
    float v526 = *v522++;
    float v521 = v521 + v526;
  }
  while (v522 != (float *)((char *)v585 + 4 * v587));
LABEL_237:
  v527 = (float *)v588;
  v528 = (float *)v585;
  if (v521 < 1.0e-12) {
    float v521 = 1.0e-12;
  }
  *((_DWORD *)v517 + 1) = *v516;
  float v529 = (float)v516[1];
  if (*v527 < v529)
  {
    uint64_t v530 = 0;
    float v520 = 0.0;
    unsigned int v531 = 1;
    do
    {
      float v520 = v520 + v528[v530];
      uint64_t v530 = v531;
      float v532 = v527[v531++];
    }
    while (v532 < v529);
  }
  v518[1] = v520 / v521;
  v517[2] = 1.0;
  v518[2] = 1.0;
  operator delete(v516);
  uint64_t v534 = 0;
  uint64_t v535 = *a2;
  do
  {
    v533.f32[0] = (float)(int)v534 * 0.0625;
    if (*v517 >= v533.f32[0])
    {
      float v547 = *v518;
    }
    else if (v517[2] <= v533.f32[0])
    {
      float v547 = v518[2];
    }
    else
    {
      unint64_t v537 = 3;
      uint64_t v538 = v517;
      do
      {
        unint64_t v539 = v537 >> 1;
        v540 = &v538[v537 >> 1];
        float v542 = *v540;
        int v541 = v540 + 1;
        v537 += ~(v537 >> 1);
        if (v542 > v533.f32[0]) {
          unint64_t v537 = v539;
        }
        else {
          uint64_t v538 = v541;
        }
      }
      while (v537);
      float v544 = *(v538 - 1);
      float v545 = v533.f32[0] - v544;
      float v546 = *v538 - v544;
      if (v546 < 1.0e-12) {
        float v546 = 1.0e-12;
      }
      v533.f32[0] = v545 / v546;
      float v543 = v518[((unint64_t)((char *)v538 - (char *)v517) >> 2) - 1];
      float v547 = v543
           + (float)((float)(*(float *)((char *)v518 + (((char *)v538 - (char *)v517) & 0x3FFFFFFFCLL)) - v543)
                   * v533.f32[0]);
    }
    int v548 = v581;
    if (v581 <= 0)
    {
      *(void *)&long long v610 = 0;
      v533.i64[0] = 0;
      goto LABEL_244;
    }
    sub_1D0E34CBC((uint64_t)&memptr, v533);
    if (!v587)
    {
      v533.i64[0] = 0;
      goto LABEL_268;
    }
    v533.i32[0] = *(_DWORD *)v585;
    if (v587 == 1) {
      goto LABEL_268;
    }
    float32x4_t v549 = (float *)((char *)v585 + 4);
    if (((v587 + 0x3FFFFFFFFFFFFFFELL) & 0x3FFFFFFFFFFFFFFFLL) == 0) {
      goto LABEL_265;
    }
    uint64_t v550 = ((v587 + 0x3FFFFFFFFFFFFFFELL) & 0x3FFFFFFFFFFFFFFFLL) + 1;
    float32x4_t v551 = (float *)((char *)v585 + 8);
    uint64_t v552 = v550 & 0x7FFFFFFFFFFFFFFELL;
    do
    {
      v533.f32[0] = (float)(v533.f32[0] + *(v551 - 1)) + *v551;
      v551 += 2;
      v552 -= 2;
    }
    while (v552);
    if (v550 != (v550 & 0x7FFFFFFFFFFFFFFELL))
    {
      v549 += v550 & 0x7FFFFFFFFFFFFFFELL;
      do
      {
LABEL_265:
        float v553 = *v549++;
        v533.f32[0] = v533.f32[0] + v553;
      }
      while (v549 != (float *)((char *)v585 + 4 * v587));
    }
LABEL_268:
    uint64_t v554 = (v548 - 1);
    if (v548 < 2)
    {
LABEL_276:
      float32x4_t v560 = (uint64_t *)((char *)memptr + 4 * (2 * v554));
      *(void *)&long long v610 = 0;
      if (memptr == &v610) {
        v533.i64[0] = *v560;
      }
      else {
        v533.i32[0] = *(_DWORD *)v560;
      }
      *(void *)&long long v610 = *v560;
    }
    else
    {
      uint64_t v555 = 0;
      float v556 = v533.f32[0] * v547;
      float v557 = 0.0;
      while (1)
      {
        float v558 = v557 + *((float *)v585 + v555);
        if (v557 <= v556 && v556 <= v558) {
          break;
        }
        ++v555;
        float v557 = v558;
        if (v554 == v555) {
          goto LABEL_276;
        }
      }
      float v561 = v558 - v557;
      float v562 = 0.0;
      if (v561 > 0.0) {
        float v562 = (float)-(float)(v557 - (float)(v547 * v533.f32[0])) / v561;
      }
      float32x4_t v576 = (char *)memptr + 4 * (2 * v555);
      uint64_t v577 = (v555 << 33) | 2;
      *(float *)uint64_t v611 = 1.0 - v562;
      *((float *)v611 + 1) = v562;
      v607 = &v576;
      uint64_t v608 = v611;
      *(void *)&long long v610 = 0;
      sub_1D0E35054((float *)&v610, (float **)&v607);
      v533.i32[0] = v610;
    }
LABEL_244:
    uint64_t v536 = (_DWORD *)(*(void *)(v535 + 768) + 8 * v534);
    *uint64_t v536 = v533.i32[0];
    v536[1] = DWORD1(v610);
    ++v534;
  }
  while (v534 != 17);
  for (int j = 0; j != 7; ++j)
  {
    switch(j)
    {
      case 0:
        float32x4_t v564 = (uint64_t *)(*a2 + 120);
        int32x4_t v565 = (uint64_t *)(*a2 + 72);
        break;
      case 1:
        float32x4_t v564 = (uint64_t *)(*a2 + 96);
        int32x4_t v565 = (uint64_t *)(*a2 + 48);
        break;
      case 2:
        float32x4_t v564 = (uint64_t *)(*a2 + 360);
        int32x4_t v565 = (uint64_t *)(*a2 + 312);
        break;
      case 3:
        float32x4_t v564 = (uint64_t *)(*a2 + 336);
        int32x4_t v565 = (uint64_t *)(*a2 + 288);
        break;
      case 4:
        float32x4_t v564 = (uint64_t *)(*a2 + 528);
        int32x4_t v565 = (uint64_t *)(*a2 + 504);
        break;
      case 5:
        float32x4_t v564 = (uint64_t *)(*a2 + 648);
        int32x4_t v565 = (uint64_t *)(*a2 + 624);
        break;
      case 6:
        uint64_t v566 = *a2;
        float32x4_t v564 = (uint64_t *)(*a2 + 768);
LABEL_296:
        int32x4_t v565 = (uint64_t *)(v566 + 744);
        break;
      default:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6438F8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EA6438F8))
        {
          qword_1EA6438E0 = 0;
          *(void *)algn_1EA6438E8 = 0;
          v607 = 0;
          malloc_type_posix_memalign(&v607, 0x20uLL, 0, 0x49090899uLL);
          qword_1EA6438E0 = (uint64_t)v607;
          dword_1EA6438F0 = 0;
          __cxa_guard_release(&qword_1EA6438F8);
        }
        switch(j)
        {
          case 0:
            float32x4_t v564 = &qword_1EA6438E0;
            int32x4_t v565 = (uint64_t *)(*a2 + 72);
            goto LABEL_297;
          case 1:
            float32x4_t v564 = &qword_1EA6438E0;
            int32x4_t v565 = (uint64_t *)(*a2 + 48);
            goto LABEL_297;
          case 2:
            float32x4_t v564 = &qword_1EA6438E0;
            int32x4_t v565 = (uint64_t *)(*a2 + 312);
            goto LABEL_297;
          case 3:
            float32x4_t v564 = &qword_1EA6438E0;
            int32x4_t v565 = (uint64_t *)(*a2 + 288);
            goto LABEL_297;
          case 4:
            float32x4_t v564 = &qword_1EA6438E0;
            int32x4_t v565 = (uint64_t *)(*a2 + 504);
            goto LABEL_297;
          case 5:
            float32x4_t v564 = &qword_1EA6438E0;
            int32x4_t v565 = (uint64_t *)(*a2 + 624);
            goto LABEL_297;
          case 6:
            uint64_t v566 = *a2;
            float32x4_t v564 = &qword_1EA6438E0;
            goto LABEL_296;
          default:
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6438D8, memory_order_acquire) & 1) != 0
              || !__cxa_guard_acquire(&qword_1EA6438D8))
            {
              int32x4_t v565 = &qword_1EA6438C0;
            }
            else
            {
              int32x4_t v565 = &qword_1EA6438C0;
              qword_1EA6438C0 = 0;
              *(void *)algn_1EA6438C8 = 0;
              v607 = 0;
              malloc_type_posix_memalign(&v607, 0x20uLL, 0, 0x49090899uLL);
              qword_1EA6438C0 = (uint64_t)v607;
              dword_1EA6438D0 = 0;
              __cxa_guard_release(&qword_1EA6438D8);
            }
            float32x4_t v564 = &qword_1EA6438E0;
            goto LABEL_298;
        }
    }
LABEL_297:
    if (v565 != v564)
    {
LABEL_298:
      unint64_t v567 = (2 * *((_DWORD *)v564 + 4));
      if (v567)
      {
        int32x4_t v568 = (void *)*v565;
        if (v565[1] >= v567)
        {
          size_t v569 = 4 * v567;
        }
        else
        {
          free(v568);
          size_t v569 = 4 * v567;
          size_t v570 = (v569 + 31) & 0x7FFFFFFE0;
          *int32x4_t v565 = 0;
          v565[1] = v570 >> 2;
          v607 = 0;
          malloc_type_posix_memalign(&v607, 0x20uLL, v570, 0x49090899uLL);
          int32x4_t v568 = v607;
          *int32x4_t v565 = (uint64_t)v607;
        }
        memcpy(v568, (const void *)*v564, v569);
      }
      else
      {
        free((void *)*v565);
        *int32x4_t v565 = 0;
        v565[1] = 0;
      }
      *((_DWORD *)v565 + 4) = *((_DWORD *)v564 + 4);
    }
    switch(j)
    {
      case 0:
        v571 = (uint64_t *)(*a2 + 192);
        break;
      case 1:
        v571 = (uint64_t *)(*a2 + 144);
        break;
      case 2:
        v571 = (uint64_t *)(*a2 + 432);
        break;
      case 3:
        v571 = (uint64_t *)(*a2 + 384);
        break;
      case 4:
        v571 = (uint64_t *)(*a2 + 552);
        break;
      case 5:
        v571 = (uint64_t *)(*a2 + 672);
        break;
      case 6:
        v571 = (uint64_t *)(*a2 + 792);
        break;
      default:
        v571 = &qword_1EA643900;
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA643930, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EA643930))
        {
          qword_1EA643900 = 0;
          *(void *)algn_1EA643908 = 0;
          v607 = 0;
          malloc_type_posix_memalign(&v607, 0x20uLL, 0, 0x49090899uLL);
          qword_1EA643900 = (uint64_t)v607;
          dword_1EA643910 = 0;
          qword_1EA643920 = 0;
          unk_1EA643928 = 0;
          qword_1EA643918 = 0;
          __cxa_guard_release(&qword_1EA643930);
        }
        break;
    }
    LOBYTE(v607) = 4;
    sub_1D0E34A90((uint64_t)(v571 + 3), v571[4] - v571[3], (const char *)&v607);
    uint64_t v572 = *((unsigned int *)v571 + 4);
    if (v572) {
      memset_pattern16((void *)*v571, &unk_1D0E818C0, 4 * v572);
    }
  }
  free(v518);
  free(v517);
  free(v588);
  free(v585);
  free(v582);
  free(memptr);
  free(v449);
  operator delete(__p);
}

char *sub_1D0E34A90(uint64_t a1, size_t a2, const char *a3)
{
  unint64_t v6 = *(void *)(a1 + 16);
  size_t v7 = *(char **)a1;
  BOOL result = v7;
  if (v6 - (unint64_t)v7 < a2)
  {
    if (v7)
    {
      *(void *)(a1 + 8) = v7;
      operator delete(v7);
      unint64_t v6 = 0;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
    }
    if ((a2 & 0x8000000000000000) != 0) {
      goto LABEL_52;
    }
    uint64_t v9 = 2 * v6;
    if (2 * v6 <= a2) {
      uint64_t v9 = a2;
    }
    size_t v10 = v6 >= 0x3FFFFFFFFFFFFFFFLL ? 0x7FFFFFFFFFFFFFFFLL : v9;
    if ((v10 & 0x8000000000000000) != 0) {
LABEL_52:
    }
      abort();
    uint64_t v11 = (char *)operator new(v10);
    *(void *)a1 = v11;
    *(void *)(a1 + 16) = &v11[v10];
    BOOL result = (char *)memset(v11, *(unsigned __int8 *)a3, a2);
    uint64_t v12 = &v11[a2];
    goto LABEL_40;
  }
  uint64_t v13 = *(char **)(a1 + 8);
  size_t v14 = v13 - v7;
  if (v13 - v7 >= a2) {
    unint64_t v15 = a2;
  }
  else {
    unint64_t v15 = v13 - v7;
  }
  if (v15)
  {
    if (v15 < 8) {
      goto LABEL_32;
    }
    if (v7 < a3 + 1 && &v7[v15] > a3) {
      goto LABEL_32;
    }
    if (v15 >= 0x20)
    {
      unint64_t v17 = v15 & 0xFFFFFFFFFFFFFFE0;
      int8x16_t v18 = vld1q_dup_s8(a3);
      uint64_t v19 = (int8x16_t *)(v7 + 16);
      unint64_t v20 = v15 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        v19[-1] = v18;
        *uint64_t v19 = v18;
        v19 += 2;
        v20 -= 32;
      }
      while (v20);
      if (v15 == v17) {
        goto LABEL_33;
      }
      if ((v15 & 0x18) == 0)
      {
        v15 &= 0x1Fu;
        BOOL result = &v7[v17];
        do
        {
LABEL_32:
          *result++ = *a3;
          --v15;
        }
        while (v15);
        goto LABEL_33;
      }
    }
    else
    {
      unint64_t v17 = 0;
    }
    BOOL result = &v7[v15 & 0xFFFFFFFFFFFFFFF8];
    int8x8_t v21 = vld1_dup_s8(a3);
    unint64_t v22 = v17 - (v15 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v23 = (int8x8_t *)&v7[v17];
    do
    {
      *v23++ = v21;
      v22 += 8;
    }
    while (v22);
    if (v15 != (v15 & 0xFFFFFFFFFFFFFFF8))
    {
      v15 &= 7u;
      goto LABEL_32;
    }
  }
LABEL_33:
  BOOL v24 = a2 >= v14;
  unint64_t v25 = a2 - v14;
  if (v25 == 0 || !v24)
  {
    uint64_t v12 = &v7[a2];
LABEL_40:
    *(void *)(a1 + 8) = v12;
    return result;
  }
  uint64_t v26 = &v13[v25];
  if (v25 < 8 || v13 < a3 + 1 && v26 > a3) {
    goto LABEL_50;
  }
  if (v25 >= 0x20)
  {
    unint64_t v27 = v25 & 0xFFFFFFFFFFFFFFE0;
    int8x16_t v28 = vld1q_dup_s8(a3);
    uint64_t v29 = (int8x16_t *)(v13 + 16);
    unint64_t v30 = v25 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      v29[-1] = v28;
      *uint64_t v29 = v28;
      v29 += 2;
      v30 -= 32;
    }
    while (v30);
    if (v25 == v27) {
      goto LABEL_51;
    }
    if ((v25 & 0x18) == 0)
    {
      v13 += v27;
      goto LABEL_50;
    }
  }
  else
  {
    unint64_t v27 = 0;
  }
  unint64_t v31 = v25 & 0xFFFFFFFFFFFFFFF8;
  int8x8_t v32 = vld1_dup_s8(a3);
  unint64_t v33 = v27 - (v25 & 0xFFFFFFFFFFFFFFF8);
  int v34 = (int8x8_t *)&v13[v27];
  do
  {
    *v34++ = v32;
    v33 += 8;
  }
  while (v33);
  if (v25 == v31) {
    goto LABEL_51;
  }
  v13 += v31;
  do
LABEL_50:
    *v13++ = *a3;
  while (v13 != v26);
LABEL_51:
  *(void *)(a1 + 8) = v26;
  return result;
}

void sub_1D0E34CBC(uint64_t a1, float32x4_t a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  uint64_t v3 = (v2 - 1);
  if (*(_DWORD *)(a1 + 64) == v3) {
    return;
  }
  unint64_t v5 = v3 & ~((int)v3 >> 31);
  *(_DWORD *)(a1 + 64) = v5;
  if (v2 < 2)
  {
    unint64_t v6 = (void *)(a1 + 48);
    free(*(void **)(a1 + 48));
    void *v6 = 0;
    *(void *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 40) = v5;
    free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    return;
  }
  if (*(void *)(a1 + 56) < v5)
  {
    free(*(void **)(a1 + 48));
    size_t v7 = (4 * v5 + 31) & 0x3FFFFFFE0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = v7 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    *(void *)(a1 + 48) = memptr;
  }
  *(_DWORD *)(a1 + 40) = v5;
  unint64_t v8 = (2 * v5);
  uint64_t v9 = *(float32x2_t **)(a1 + 24);
  if (*(void *)(a1 + 32) < v8)
  {
    free(v9);
    size_t v10 = (4 * v8 + 31) & 0x7FFFFFFE0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = v10 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v10, 0x49090899uLL);
    uint64_t v9 = (float32x2_t *)memptr;
    *(void *)(a1 + 24) = memptr;
  }
  uint64_t v11 = *(float32x2_t **)a1;
  uint64_t v12 = *(float32x2_t **)(a1 + 48);
  if (*(float32x2_t **)a1 != v9)
  {
    size_t v14 = (float *)&v11[1];
    do
    {
      float32_t v15 = *v14 - *(v14 - 2);
      v9->f32[0] = v15;
      float32_t v16 = v14[1] - *(v14 - 1);
      v9->f32[1] = v16;
      a2.f32[0] = sqrtf((float)(v15 * v15) + (float)(v16 * v16));
      v12->i32[0] = a2.i32[0];
      if (a2.f32[0] < 0.000001)
      {
        v12->i32[0] = 0;
        a2.i64[0] = 0;
      }
      else
      {
        *(float32x2_t *)a2.f32 = vdiv_f32(*v9, (float32x2_t)vdup_lane_s32(*(int32x2_t *)a2.f32, 0));
      }
      *v9++ = *(float32x2_t *)a2.f32;
      uint64_t v12 = (float32x2_t *)((char *)v12 + 4);
      v14 += 2;
      --v3;
    }
    while (v3);
    return;
  }
  if (v2 >= 9)
  {
    uint64_t v17 = v3;
    uint64_t v18 = 8 * v3 - 8;
    unint64_t v19 = (unint64_t)v9 + v18 + 4;
    unint64_t v20 = (char *)v9 + v18;
    uint64_t v13 = 0;
    if (v19 < (unint64_t)v9 + 4 || v20 < (char *)v9) {
      goto LABEL_53;
    }
    unint64_t v22 = &v9[v17];
    uint64_t v23 = (float32x2_t *)((char *)v12 + 4 * v3);
    unint64_t v24 = (unint64_t)&v11[v17 + 1];
    BOOL v25 = (unint64_t)v9 >= v24 || v11 >= v22;
    BOOL v26 = !v25;
    BOOL v27 = (unint64_t)v12 >= v24 || v11 >= v23;
    BOOL v28 = !v27;
    BOOL v29 = v12 >= v22 || v9 >= v23;
    if (!v29 || v26 || v28) {
      goto LABEL_53;
    }
    uint64_t v13 = v3 & 0xFFFFFFFC;
    unint64_t v30 = v11 + 1;
    a2 = (float32x4_t)vdupq_n_s32(0x358637BDu);
    unint64_t v31 = (float32x4_t *)v9;
    int8x8_t v32 = *(float32x4_t **)(a1 + 48);
    uint64_t v33 = v13;
    while (1)
    {
      float32x4_t v34 = vsubq_f32(*(float32x4_t *)v30->f32, *(float32x4_t *)v30[-1].f32);
      float32x4_t v35 = vsubq_f32(*(float32x4_t *)v30[2].f32, *(float32x4_t *)v30[1].f32);
      float32x4_t *v31 = v34;
      v31[1] = v35;
      int32x4_t v36 = (int32x4_t)vmulq_f32(v35, v35);
      int32x4_t v37 = (int32x4_t)vmulq_f32(v34, v34);
      float32x4_t v38 = vsqrtq_f32(vaddq_f32((float32x4_t)vuzp1q_s32(v37, v36), (float32x4_t)vuzp2q_s32(v37, v36)));
      *int8x8_t v32 = v38;
      int8x16_t v39 = (int8x16_t)vcgeq_f32(v38, a2);
      int16x4_t v40 = vmovn_s32((int32x4_t)vmvnq_s8(v39));
      float32x4_t v41 = *v31;
      v42.i32[0] = vdupq_lane_s32(*(int32x2_t *)v31->f32, 1).u32[0];
      v42.i32[1] = HIDWORD(*(unsigned long long *)v31);
      v41.i32[1] = v31->i64[1];
      v41.i32[2] = v31[1].i32[0];
      v41.i32[3] = v31[1].i32[2];
      v42.i32[2] = v31[1].i32[1];
      v42.i32[3] = v31[1].i32[3];
      if (v40.i8[0])
      {
        v32->i32[0] = 0;
        if ((v40.i8[2] & 1) == 0)
        {
LABEL_45:
          if ((v40.i8[4] & 1) == 0) {
            goto LABEL_46;
          }
          goto LABEL_50;
        }
      }
      else if ((v40.i8[2] & 1) == 0)
      {
        goto LABEL_45;
      }
      v32->i32[1] = 0;
      if ((v40.i8[4] & 1) == 0)
      {
LABEL_46:
        if (v40.i8[6]) {
          goto LABEL_51;
        }
        goto LABEL_42;
      }
LABEL_50:
      v32->i32[2] = 0;
      if (v40.i8[6]) {
LABEL_51:
      }
        v32->i32[3] = 0;
LABEL_42:
      v51.val[0] = (float32x4_t)vandq_s8((int8x16_t)vdivq_f32(v41, v38), v39);
      v51.val[1] = (float32x4_t)vandq_s8((int8x16_t)vdivq_f32(v42, v38), v39);
      vst2q_f32(v31->f32, v51);
      v31 += 2;
      ++v32;
      v30 += 4;
      v33 -= 4;
      if (!v33)
      {
        if (v13 != v3) {
          goto LABEL_53;
        }
        return;
      }
    }
  }
  uint64_t v13 = 0;
LABEL_53:
  int v43 = (_DWORD *)v12 + v13;
  uint64_t v44 = v13;
  BOOL v45 = &v9[v13];
  uint64_t v46 = v3 - v13;
  int v47 = (float *)&v11[v44 + 1];
  do
  {
    float32_t v48 = *v47 - *(v47 - 2);
    float32_t v49 = v47[1] - *(v47 - 1);
    v45->f32[0] = v48;
    v45->f32[1] = v49;
    a2.f32[0] = sqrtf((float)(v48 * v48) + (float)(v49 * v49));
    *int v43 = a2.i32[0];
    if (a2.f32[0] < 0.000001)
    {
      *int v43 = 0;
      a2.i64[0] = 0;
    }
    else
    {
      *(float32x2_t *)a2.f32 = vdiv_f32(*v45, (float32x2_t)vdup_lane_s32(*(int32x2_t *)a2.f32, 0));
    }
    *v45++ = *(float32x2_t *)a2.f32;
    ++v43;
    v47 += 2;
    --v46;
  }
  while (v46);
}

float *sub_1D0E35054(float *result, float **a2)
{
  int v2 = result;
  uint64_t v3 = *(void *)*a2;
  if ((float *)(v3 - 4 * *((unsigned int *)*a2 + 3)) == result || (uint64_t v4 = a2[1], v4 == result))
  {
    uint64_t v17 = 0;
    BOOL result = (float *)sub_1D0E35054(&v17);
    *(void *)int v2 = v17;
  }
  else
  {
    uint64_t v5 = *((unsigned int *)*a2 + 2);
    uint64_t v6 = (2 * v5);
    if (v6)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 4 * v6;
      uint64_t v9 = 4 * v5;
      float v10 = 0.0;
      uint64_t v11 = a2[1];
      do
      {
        float v12 = *v11++;
        float v10 = v10 + (float)(*(float *)(v3 + v7) * v12);
        v7 += v9;
      }
      while (v8 != v7);
      uint64_t v13 = 0;
      *BOOL result = v10;
      uint64_t v14 = v3 + 4;
      float v15 = 0.0;
      do
      {
        float v16 = *v4++;
        float v15 = v15 + (float)(*(float *)(v14 + v13) * v16);
        v13 += v9;
      }
      while (v8 != v13);
    }
    else
    {
      *BOOL result = 0.0;
      float v15 = 0.0;
    }
    result[1] = v15;
  }
  return result;
}

float *sub_1D0E35128(uint64_t a1, void *a2, float **a3, float **a4)
{
  uint64_t v8 = *a3;
  uint64_t v9 = *a4;
  float v38 = (*a3)[5] + (float)*((int *)*a3 + 4);
  float v39 = (float)*((int *)*a4 + 4);
  float v40 = (*a4)[5];
  float v10 = (float)(v40 + (float)(v38 + v39)) * 0.5;
  uint64_t v11 = (int)v10;
  float v12 = (float)(int)v10;
  float v13 = v10 - v12;
  float v14 = (float)(v13 * v13) * v13;
  float v15 = (float *)(*a2 + 32 * v11);
  float v16 = (float)(v13 * v13) * 3.0;
  v42[0] = 1.0 - (float)(v16 - (float)(v14 * 2.0));
  v42[1] = v16 + (float)(v14 * -2.0);
  v42[2] = (float)(v14 + (float)((float)(v13 * v13) * -2.0)) + v13;
  v42[3] = v14 - (float)(v13 * v13);
  v43[0] = v15;
  v43[1] = v42;
  uint64_t v41 = 0;
  sub_1D0E62278((float *)&v41, v43);
  int v17 = v41;
  int v18 = HIDWORD(v41);
  float v19 = *(float *)&v41 - v8[6];
  float v20 = *((float *)&v41 + 1) - v8[7];
  float v21 = v9[6] - *(float *)&v41;
  float v22 = v9[7] - *((float *)&v41 + 1);
  float v23 = sqrtf((float)(v19 * v19) + (float)(v20 * v20));
  float v24 = sqrtf((float)(v21 * v21) + (float)(v22 * v22));
  BOOL result = (float *)operator new(0x20uLL);
  *((_DWORD *)result + 4) = v11;
  result[5] = v13;
  *((_DWORD *)result + 6) = v17;
  *((_DWORD *)result + 7) = v18;
  uint64_t v27 = *(void *)v9;
  *(void *)(v27 + 8) = result;
  *(void *)BOOL result = v27;
  *(void *)uint64_t v9 = result;
  *((void *)result + 1) = v9;
  ++*(void *)(a1 + 16);
  v43[0] = result;
  if (v23 >= 0.0001 || v24 >= 0.0001)
  {
    v26.n128_f32[0] = (float)(v40 + v39) - (float)(v13 + v12);
    if (v23 < 0.0001)
    {
      if (v26.n128_f32[0] <= 0.0001) {
        return result;
      }
      BOOL v29 = v43;
      uint64_t v30 = a1;
      unint64_t v31 = a2;
      int8x8_t v32 = a4;
      return (float *)sub_1D0E35128(v30, v31, v29, v32, v26);
    }
    float v33 = (float)(v13 + v12) - v38;
    if (v24 < 0.0001)
    {
      v26.n128_u32[0] = 953267991;
      if (v33 <= 0.0001) {
        return result;
      }
      goto LABEL_26;
    }
    float v34 = (float)((float)(v19 / v23) * (float)(v21 / v24)) + (float)((float)(v20 / v23) * (float)(v22 / v24));
    BOOL v35 = v34 < 0.85 || v23 > 25.0;
    int v36 = v33 > 0.3 || v35;
    if (v24 > 25.0 || (v34 >= 0.85 ? (BOOL v37 = v26.n128_f32[0] <= 0.3) : (BOOL v37 = 0), !v37))
    {
      BOOL result = (float *)sub_1D0E35128(a1, a2, v43, a4, v26);
      if ((v36 & 1) == 0) {
        return result;
      }
      goto LABEL_26;
    }
    if (v36)
    {
LABEL_26:
      int8x8_t v32 = v43;
      uint64_t v30 = a1;
      unint64_t v31 = a2;
      BOOL v29 = a3;
      return (float *)sub_1D0E35128(v30, v31, v29, v32, v26);
    }
  }
  return result;
}

uint64_t *sub_1D0E353E0()
{
  BOOL result = (uint64_t *)operator new(0x38uLL);
  int v1 = 0;
  *((_DWORD *)result + 8) = 0;
  *BOOL result = 0;
  result[1] = 0;
  qword_1EA643810 = (uint64_t)result;
  qword_1EA643820 = 1;
  qword_1EA643818 = (uint64_t)result;
  result[2] = (uint64_t)&qword_1EA643818;
  *((unsigned char *)result + 24) = 1;
  result[5] = @"No failure";
  result[6] = @"OK";
  int v2 = (uint64_t **)result;
  while (v1 < 2)
  {
    if (v1 == 1)
    {
      v2[5] = (uint64_t *)@"Failure detection ML";
      v2[6] = (uint64_t *)@"Failure(ML)";
      goto LABEL_14;
    }
    uint64_t v3 = v2[1];
    if (!v3)
    {
      uint64_t v4 = v2 + 1;
      goto LABEL_9;
    }
LABEL_3:
    int v1 = *((_DWORD *)v3 + 8);
    int v2 = (uint64_t **)v3;
  }
  uint64_t v3 = *v2;
  if (*v2) {
    goto LABEL_3;
  }
  uint64_t v4 = v2;
LABEL_9:
  uint64_t v5 = operator new(0x38uLL);
  unsigned char v5[8] = 1;
  *((void *)v5 + 5) = 0;
  *((void *)v5 + 6) = 0;
  *(void *)uint64_t v5 = 0;
  *((void *)v5 + 1) = 0;
  *((void *)v5 + 2) = v2;
  float *v4 = (uint64_t *)v5;
  uint64_t v6 = (uint64_t *)v5;
  if (*(void *)qword_1EA643810)
  {
    qword_1EA643810 = *(void *)qword_1EA643810;
    uint64_t v6 = *v4;
  }
  uint64_t v7 = &qword_1EA643818;
  sub_1D0DCEC98((uint64_t *)qword_1EA643818, v6);
  BOOL result = (uint64_t *)qword_1EA643818;
  ++qword_1EA643820;
  *((void *)v5 + 5) = @"Failure detection ML";
  *((void *)v5 + 6) = @"Failure(ML)";
  if (!result)
  {
    uint64_t v8 = &qword_1EA643818;
LABEL_20:
    uint64_t v11 = v8;
    uint64_t v8 = (uint64_t *)operator new(0x38uLL);
    *((_DWORD *)v8 + 8) = 2;
    v8[5] = 0;
    v8[6] = 0;
    uint64_t *v8 = 0;
    v8[1] = 0;
    v8[2] = (uint64_t)v11;
    uint64_t *v7 = (uint64_t)v8;
    float v12 = v8;
    if (*(void *)qword_1EA643810)
    {
      qword_1EA643810 = *(void *)qword_1EA643810;
      float v12 = (uint64_t *)*v7;
    }
    sub_1D0DCEC98((uint64_t *)qword_1EA643818, v12);
    BOOL result = (uint64_t *)qword_1EA643818;
    ++qword_1EA643820;
    goto LABEL_23;
  }
LABEL_14:
  uint64_t v9 = result;
  while (1)
  {
    while (1)
    {
      uint64_t v8 = v9;
      int v10 = *((_DWORD *)v9 + 8);
      if (v10 < 3) {
        break;
      }
      uint64_t v9 = (uint64_t *)*v8;
      uint64_t v7 = v8;
      if (!*v8) {
        goto LABEL_20;
      }
    }
    if (v10 == 2) {
      break;
    }
    uint64_t v9 = (uint64_t *)v8[1];
    if (!v9)
    {
      uint64_t v7 = v8 + 1;
      goto LABEL_20;
    }
  }
LABEL_23:
  v8[5] = @"Bounding box outside of the image";
  v8[6] = @"BB Out";
  if (result)
  {
    float v13 = result;
    while (1)
    {
      while (1)
      {
        float v15 = v13;
        int v16 = *((_DWORD *)v13 + 8);
        if (v16 < 4) {
          break;
        }
        float v13 = (uint64_t *)*v15;
        float v14 = v15;
        if (!*v15) {
          goto LABEL_31;
        }
      }
      if (v16 == 3) {
        break;
      }
      float v13 = (uint64_t *)v15[1];
      if (!v13)
      {
        float v14 = v15 + 1;
        goto LABEL_31;
      }
    }
  }
  else
  {
    float v14 = &qword_1EA643818;
    float v15 = &qword_1EA643818;
LABEL_31:
    int v17 = v15;
    float v15 = (uint64_t *)operator new(0x38uLL);
    *((_DWORD *)v15 + 8) = 3;
    v15[5] = 0;
    v15[6] = 0;
    *float v15 = 0;
    v15[1] = 0;
    v15[2] = (uint64_t)v17;
    *float v14 = (uint64_t)v15;
    int v18 = v15;
    if (*(void *)qword_1EA643810)
    {
      qword_1EA643810 = *(void *)qword_1EA643810;
      int v18 = (uint64_t *)*v14;
    }
    sub_1D0DCEC98((uint64_t *)qword_1EA643818, v18);
    BOOL result = (uint64_t *)qword_1EA643818;
    ++qword_1EA643820;
  }
  v15[5] = @"Face too close to camera";
  v15[6] = @"Too Close";
  if (result)
  {
    float v19 = result;
    while (1)
    {
      while (1)
      {
        float v21 = v19;
        int v22 = *((_DWORD *)v19 + 8);
        if (v22 < 5) {
          break;
        }
        float v19 = (uint64_t *)*v21;
        float v20 = v21;
        if (!*v21) {
          goto LABEL_42;
        }
      }
      if (v22 == 4) {
        break;
      }
      float v19 = (uint64_t *)v21[1];
      if (!v19)
      {
        float v20 = v21 + 1;
        goto LABEL_42;
      }
    }
  }
  else
  {
    float v20 = &qword_1EA643818;
    float v21 = &qword_1EA643818;
LABEL_42:
    float v23 = v21;
    float v21 = (uint64_t *)operator new(0x38uLL);
    *((_DWORD *)v21 + 8) = 4;
    v21[5] = 0;
    v21[6] = 0;
    *float v21 = 0;
    v21[1] = 0;
    v21[2] = (uint64_t)v23;
    *float v20 = (uint64_t)v21;
    float v24 = v21;
    if (*(void *)qword_1EA643810)
    {
      qword_1EA643810 = *(void *)qword_1EA643810;
      float v24 = (uint64_t *)*v20;
    }
    sub_1D0DCEC98((uint64_t *)qword_1EA643818, v24);
    BOOL result = (uint64_t *)qword_1EA643818;
    ++qword_1EA643820;
  }
  v21[5] = @"Face too far from camera";
  v21[6] = @"Too Far";
  if (result)
  {
    BOOL v25 = result;
    while (1)
    {
      while (1)
      {
        uint64_t v27 = v25;
        int v28 = *((_DWORD *)v25 + 8);
        if (v28 < 6) {
          break;
        }
        BOOL v25 = (uint64_t *)*v27;
        __n128 v26 = v27;
        if (!*v27) {
          goto LABEL_53;
        }
      }
      if (v28 == 5) {
        break;
      }
      BOOL v25 = (uint64_t *)v27[1];
      if (!v25)
      {
        __n128 v26 = v27 + 1;
        goto LABEL_53;
      }
    }
  }
  else
  {
    __n128 v26 = &qword_1EA643818;
    uint64_t v27 = &qword_1EA643818;
LABEL_53:
    BOOL v29 = v27;
    uint64_t v27 = (uint64_t *)operator new(0x38uLL);
    *((_DWORD *)v27 + 8) = 5;
    v27[5] = 0;
    v27[6] = 0;
    *uint64_t v27 = 0;
    v27[1] = 0;
    v27[2] = (uint64_t)v29;
    *__n128 v26 = (uint64_t)v27;
    uint64_t v30 = v27;
    if (*(void *)qword_1EA643810)
    {
      qword_1EA643810 = *(void *)qword_1EA643810;
      uint64_t v30 = (uint64_t *)*v26;
    }
    sub_1D0DCEC98((uint64_t *)qword_1EA643818, v30);
    BOOL result = (uint64_t *)qword_1EA643818;
    ++qword_1EA643820;
  }
  v27[5] = @"Too much rotation";
  v27[6] = @"Too Rotated";
  if (result)
  {
    unint64_t v31 = result;
    while (1)
    {
      while (1)
      {
        float v33 = v31;
        int v34 = *((_DWORD *)v31 + 8);
        if (v34 < 7) {
          break;
        }
        unint64_t v31 = (uint64_t *)*v33;
        int8x8_t v32 = v33;
        if (!*v33) {
          goto LABEL_64;
        }
      }
      if (v34 == 6) {
        break;
      }
      unint64_t v31 = (uint64_t *)v33[1];
      if (!v31)
      {
        int8x8_t v32 = v33 + 1;
        goto LABEL_64;
      }
    }
  }
  else
  {
    int8x8_t v32 = &qword_1EA643818;
    float v33 = &qword_1EA643818;
LABEL_64:
    BOOL v35 = v33;
    float v33 = (uint64_t *)operator new(0x38uLL);
    *((_DWORD *)v33 + 8) = 6;
    v33[5] = 0;
    v33[6] = 0;
    *float v33 = 0;
    v33[1] = 0;
    uint64_t v33[2] = (uint64_t)v35;
    *int8x8_t v32 = (uint64_t)v33;
    int v36 = v33;
    if (*(void *)qword_1EA643810)
    {
      qword_1EA643810 = *(void *)qword_1EA643810;
      int v36 = (uint64_t *)*v32;
    }
    sub_1D0DCEC98((uint64_t *)qword_1EA643818, v36);
    BOOL result = (uint64_t *)qword_1EA643818;
    ++qword_1EA643820;
  }
  v33[5] = @"Face moving too fast";
  v33[6] = @"Moving Too Fast";
  if (result)
  {
    BOOL v37 = result;
    while (1)
    {
      while (1)
      {
        float v39 = v37;
        int v40 = *((_DWORD *)v37 + 8);
        if (v40 < 8) {
          break;
        }
        BOOL v37 = (uint64_t *)*v39;
        float v38 = v39;
        if (!*v39) {
          goto LABEL_75;
        }
      }
      if (v40 == 7) {
        break;
      }
      BOOL v37 = (uint64_t *)v39[1];
      if (!v37)
      {
        float v38 = v39 + 1;
        goto LABEL_75;
      }
    }
  }
  else
  {
    float v38 = &qword_1EA643818;
    float v39 = &qword_1EA643818;
LABEL_75:
    uint64_t v41 = v39;
    float v39 = (uint64_t *)operator new(0x38uLL);
    *((_DWORD *)v39 + 8) = 7;
    v39[5] = 0;
    v39[6] = 0;
    *float v39 = 0;
    v39[1] = 0;
    uint64_t v39[2] = (uint64_t)v41;
    *float v38 = (uint64_t)v39;
    float32x4_t v42 = v39;
    if (*(void *)qword_1EA643810)
    {
      qword_1EA643810 = *(void *)qword_1EA643810;
      float32x4_t v42 = (uint64_t *)*v38;
    }
    sub_1D0DCEC98((uint64_t *)qword_1EA643818, v42);
    BOOL result = (uint64_t *)qword_1EA643818;
    ++qword_1EA643820;
  }
  v39[5] = @"Filling up buffer with 3 frames";
  v39[6] = @"Buffering";
  if (result)
  {
    int v43 = result;
    while (1)
    {
      while (1)
      {
        BOOL v45 = v43;
        int v46 = *((_DWORD *)v43 + 8);
        if (v46 < 101) {
          break;
        }
        int v43 = (uint64_t *)*v45;
        uint64_t v44 = v45;
        if (!*v45) {
          goto LABEL_86;
        }
      }
      if (v46 == 100) {
        break;
      }
      int v43 = (uint64_t *)v45[1];
      if (!v43)
      {
        uint64_t v44 = v45 + 1;
        goto LABEL_86;
      }
    }
  }
  else
  {
    uint64_t v44 = &qword_1EA643818;
    BOOL v45 = &qword_1EA643818;
LABEL_86:
    int v47 = v45;
    BOOL v45 = (uint64_t *)operator new(0x38uLL);
    *((_DWORD *)v45 + 8) = 100;
    v45[5] = 0;
    v45[6] = 0;
    *BOOL v45 = 0;
    v45[1] = 0;
    v45[2] = (uint64_t)v47;
    *uint64_t v44 = (uint64_t)v45;
    float32_t v48 = v45;
    if (*(void *)qword_1EA643810)
    {
      qword_1EA643810 = *(void *)qword_1EA643810;
      float32_t v48 = (uint64_t *)*v44;
    }
    sub_1D0DCEC98((uint64_t *)qword_1EA643818, v48);
    BOOL result = (uint64_t *)qword_1EA643818;
    ++qword_1EA643820;
  }
  v45[5] = @"Recognition Disabled";
  v45[6] = @"Disabled";
  if (result)
  {
    float32_t v49 = result;
    while (1)
    {
      while (1)
      {
        float32x4x2_t v51 = v49;
        int v52 = *((_DWORD *)v49 + 8);
        if (v52 < 102) {
          break;
        }
        float32_t v49 = (uint64_t *)*v51;
        uint64_t v50 = v51;
        if (!*v51) {
          goto LABEL_97;
        }
      }
      if (v52 == 101) {
        break;
      }
      float32_t v49 = (uint64_t *)v51[1];
      if (!v49)
      {
        uint64_t v50 = v51 + 1;
        goto LABEL_97;
      }
    }
  }
  else
  {
    uint64_t v50 = &qword_1EA643818;
    float32x4x2_t v51 = &qword_1EA643818;
LABEL_97:
    uint64_t v53 = v51;
    float32x4x2_t v51 = (uint64_t *)operator new(0x38uLL);
    *((_DWORD *)v51 + 8) = 101;
    v51[5] = 0;
    v51[6] = 0;
    *float32x4x2_t v51 = 0;
    v51[1] = 0;
    v51[2] = (uint64_t)v53;
    *uint64_t v50 = (uint64_t)v51;
    uint64_t v54 = v51;
    if (*(void *)qword_1EA643810)
    {
      qword_1EA643810 = *(void *)qword_1EA643810;
      uint64_t v54 = (uint64_t *)*v50;
    }
    sub_1D0DCEC98((uint64_t *)qword_1EA643818, v54);
    BOOL result = (uint64_t *)qword_1EA643818;
    ++qword_1EA643820;
  }
  v51[5] = @"Overlapping faces";
  v51[6] = @"Overlap";
  if (result)
  {
    uint64_t v55 = result;
    while (1)
    {
      while (1)
      {
        uint64_t v57 = v55;
        int v58 = *((_DWORD *)v55 + 8);
        if (v58 < 201) {
          break;
        }
        uint64_t v55 = (uint64_t *)*v57;
        uint64_t v56 = v57;
        if (!*v57) {
          goto LABEL_108;
        }
      }
      if (v58 == 200) {
        break;
      }
      uint64_t v55 = (uint64_t *)v57[1];
      if (!v55)
      {
        uint64_t v56 = v57 + 1;
        goto LABEL_108;
      }
    }
  }
  else
  {
    uint64_t v56 = &qword_1EA643818;
    uint64_t v57 = &qword_1EA643818;
LABEL_108:
    int v59 = v57;
    uint64_t v57 = (uint64_t *)operator new(0x38uLL);
    *((_DWORD *)v57 + 8) = 200;
    v57[5] = 0;
    v57[6] = 0;
    *uint64_t v57 = 0;
    v57[1] = 0;
    v57[2] = (uint64_t)v59;
    *uint64_t v56 = (uint64_t)v57;
    uint64_t v60 = v57;
    if (*(void *)qword_1EA643810)
    {
      qword_1EA643810 = *(void *)qword_1EA643810;
      uint64_t v60 = (uint64_t *)*v56;
    }
    sub_1D0DCEC98((uint64_t *)qword_1EA643818, v60);
    BOOL result = (uint64_t *)qword_1EA643818;
    ++qword_1EA643820;
  }
  v57[5] = @"Too high translational velocity";
  v57[6] = @"High velocity(t)";
  if (result)
  {
    uint64_t v61 = result;
    while (1)
    {
      while (1)
      {
        uint64_t v63 = v61;
        int v64 = *((_DWORD *)v61 + 8);
        if (v64 < 202) {
          break;
        }
        uint64_t v61 = (uint64_t *)*v63;
        unint64_t v62 = v63;
        if (!*v63) {
          goto LABEL_119;
        }
      }
      if (v64 == 201) {
        break;
      }
      uint64_t v61 = (uint64_t *)v63[1];
      if (!v61)
      {
        unint64_t v62 = v63 + 1;
        goto LABEL_119;
      }
    }
  }
  else
  {
    unint64_t v62 = &qword_1EA643818;
    uint64_t v63 = &qword_1EA643818;
LABEL_119:
    size_t v65 = v63;
    uint64_t v63 = (uint64_t *)operator new(0x38uLL);
    *((_DWORD *)v63 + 8) = 201;
    v63[5] = 0;
    v63[6] = 0;
    *uint64_t v63 = 0;
    v63[1] = 0;
    v63[2] = (uint64_t)v65;
    *unint64_t v62 = (uint64_t)v63;
    size_t v66 = v63;
    if (*(void *)qword_1EA643810)
    {
      qword_1EA643810 = *(void *)qword_1EA643810;
      size_t v66 = (uint64_t *)*v62;
    }
    sub_1D0DCEC98((uint64_t *)qword_1EA643818, v66);
    BOOL result = (uint64_t *)qword_1EA643818;
    ++qword_1EA643820;
  }
  v63[5] = @"Too high translational acceleration";
  v63[6] = @"High acceleration(t)";
  if (result)
  {
    uint64_t v67 = result;
    while (1)
    {
      while (1)
      {
        uint64_t v69 = v67;
        int v70 = *((_DWORD *)v67 + 8);
        if (v70 < 203) {
          break;
        }
        uint64_t v67 = (uint64_t *)*v69;
        uint64_t v68 = v69;
        if (!*v69) {
          goto LABEL_130;
        }
      }
      if (v70 == 202) {
        break;
      }
      uint64_t v67 = (uint64_t *)v69[1];
      if (!v67)
      {
        uint64_t v68 = v69 + 1;
        goto LABEL_130;
      }
    }
  }
  else
  {
    uint64_t v68 = &qword_1EA643818;
    uint64_t v69 = &qword_1EA643818;
LABEL_130:
    uint64_t v71 = v69;
    uint64_t v69 = (uint64_t *)operator new(0x38uLL);
    *((_DWORD *)v69 + 8) = 202;
    v69[5] = 0;
    v69[6] = 0;
    *uint64_t v69 = 0;
    v69[1] = 0;
    v69[2] = (uint64_t)v71;
    uint64_t *v68 = (uint64_t)v69;
    uint64_t v72 = v69;
    if (*(void *)qword_1EA643810)
    {
      qword_1EA643810 = *(void *)qword_1EA643810;
      uint64_t v72 = (uint64_t *)*v68;
    }
    sub_1D0DCEC98((uint64_t *)qword_1EA643818, v72);
    BOOL result = (uint64_t *)qword_1EA643818;
    ++qword_1EA643820;
  }
  v69[5] = @"Too high angular velocity";
  v69[6] = @"High velocity(a)";
  if (result)
  {
    while (1)
    {
      while (1)
      {
        size_t v74 = result;
        int v75 = *((_DWORD *)result + 8);
        if (v75 < 204) {
          break;
        }
        BOOL result = (uint64_t *)*result;
        unsigned int v73 = v74;
        if (!*v74) {
          goto LABEL_140;
        }
      }
      if (v75 == 203) {
        break;
      }
      BOOL result = (uint64_t *)result[1];
      if (!result)
      {
        unsigned int v73 = v74 + 1;
        goto LABEL_140;
      }
    }
  }
  else
  {
    unsigned int v73 = &qword_1EA643818;
    size_t v74 = &qword_1EA643818;
LABEL_140:
    uint64_t v76 = v74;
    size_t v74 = (uint64_t *)operator new(0x38uLL);
    *((_DWORD *)v74 + 8) = 203;
    v74[5] = 0;
    v74[6] = 0;
    *size_t v74 = 0;
    v74[1] = 0;
    v74[2] = (uint64_t)v76;
    *unsigned int v73 = (uint64_t)v74;
    int v77 = v74;
    if (*(void *)qword_1EA643810)
    {
      qword_1EA643810 = *(void *)qword_1EA643810;
      int v77 = (uint64_t *)*v73;
    }
    BOOL result = sub_1D0DCEC98((uint64_t *)qword_1EA643818, v77);
    ++qword_1EA643820;
  }
  v74[5] = @"Too high angular acceleration";
  v74[6] = @"High acceleration(a)";
  return result;
}

uint64_t CVAFaceTrackingGetErrorDescription_0(int a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA643828, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA643828))
  {
    sub_1D0E353E0();
    __cxa_guard_release(&qword_1EA643828);
  }
  uint64_t v2 = qword_1EA643818;
  if (qword_1EA643818)
  {
    uint64_t v3 = &qword_1EA643818;
    do
    {
      int v4 = *(_DWORD *)(v2 + 32);
      BOOL v5 = v4 < a1;
      if (v4 >= a1) {
        uint64_t v6 = (uint64_t *)v2;
      }
      else {
        uint64_t v6 = (uint64_t *)(v2 + 8);
      }
      if (!v5) {
        uint64_t v3 = (uint64_t *)v2;
      }
      uint64_t v2 = *v6;
    }
    while (*v6);
    if (v3 != &qword_1EA643818 && *((_DWORD *)v3 + 8) <= a1) {
      return v3[5];
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v7 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
  {
    v9[0] = 67109120;
    v9[1] = a1;
    _os_log_error_impl(&dword_1D0DBD000, v7, OS_LOG_TYPE_ERROR, "unknown failure type %d", (uint8_t *)v9, 8u);
  }
  return 0;
}

void sub_1D0E35F28(void ***a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (void *)MEMORY[0x1D25F1DA0]();
  int v7 = *(_DWORD *)(a2 + 60);
  int v8 = *(_DWORD *)(a2 + 40);
  unint64_t v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  uint64_t v9 = **a1;
  int v21 = v7;
  int8x16_t v22 = vextq_s8(*(int8x16_t *)(a2 + 24), *(int8x16_t *)(a2 + 24), 8uLL);
  int8x16_t v23 = vextq_s8(*(int8x16_t *)(a2 + 8), (int8x16_t)vrev64q_s32(*(int32x4_t *)(a2 + 8)), 8uLL);
  int8x16_t v10 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(a2 + 44));
  int8x16_t v24 = vextq_s8(v10, v10, 8uLL);
  int v25 = v8;
  if (v9)
  {
    [v9 processIncomingExpressions:&v21];
    LOBYTE(add) = v26;
    if ((unint64_t)v26 >= 4)
    {
      sub_1D0E5C8F8(&v31);
      sub_1D0E5E098((uint64_t)v33, &v31, 0, 0, "[RELEASE ERROR  ]", "/Library/Caches/com.apple.xbs/Sources/AppleCVA/shared/src/modules/avatar/facekit/accessibilityfilter.mm", 47, "assert %s failed. activation value not implemented%s", (char)"false");
      sub_1D0E6054C((uint64_t)v33);
      float v12 = v32;
      if (v32)
      {
        unint64_t add = atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL);
        if (!add)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
    }
  }
  else
  {
    LOBYTE(add) = 0;
  }
  *(unsigned char *)a3 = add;
  LOBYTE(add) = BYTE8(v26);
  if (*((void *)&v26 + 1) >= 4uLL)
  {
    sub_1D0E5C8F8(&v31);
    sub_1D0E5E098((uint64_t)v33, &v31, 0, 0, "[RELEASE ERROR  ]", "/Library/Caches/com.apple.xbs/Sources/AppleCVA/shared/src/modules/avatar/facekit/accessibilityfilter.mm", 47, "assert %s failed. activation value not implemented%s", (char)"false");
    sub_1D0E6054C((uint64_t)v33);
    float v13 = v32;
    if (v32)
    {
      unint64_t add = atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL);
      if (!add)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }
  *(unsigned char *)(a3 + 1) = add;
  LOBYTE(add) = v27;
  if ((unint64_t)v27 >= 4)
  {
    sub_1D0E5C8F8(&v31);
    sub_1D0E5E098((uint64_t)v33, &v31, 0, 0, "[RELEASE ERROR  ]", "/Library/Caches/com.apple.xbs/Sources/AppleCVA/shared/src/modules/avatar/facekit/accessibilityfilter.mm", 47, "assert %s failed. activation value not implemented%s", (char)"false");
    sub_1D0E6054C((uint64_t)v33);
    float v14 = v32;
    if (v32)
    {
      unint64_t add = atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL);
      if (!add)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }
  *(unsigned char *)(a3 + 2) = add;
  LOBYTE(add) = BYTE8(v27);
  if (*((void *)&v27 + 1) >= 4uLL)
  {
    sub_1D0E5C8F8(&v31);
    sub_1D0E5E098((uint64_t)v33, &v31, 0, 0, "[RELEASE ERROR  ]", "/Library/Caches/com.apple.xbs/Sources/AppleCVA/shared/src/modules/avatar/facekit/accessibilityfilter.mm", 47, "assert %s failed. activation value not implemented%s", (char)"false");
    sub_1D0E6054C((uint64_t)v33);
    float v15 = v32;
    if (v32)
    {
      unint64_t add = atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL);
      if (!add)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
  *(unsigned char *)(a3 + 3) = add;
  LOBYTE(add) = v28;
  if ((unint64_t)v28 >= 4)
  {
    sub_1D0E5C8F8(&v31);
    sub_1D0E5E098((uint64_t)v33, &v31, 0, 0, "[RELEASE ERROR  ]", "/Library/Caches/com.apple.xbs/Sources/AppleCVA/shared/src/modules/avatar/facekit/accessibilityfilter.mm", 47, "assert %s failed. activation value not implemented%s", (char)"false");
    sub_1D0E6054C((uint64_t)v33);
    int v16 = v32;
    if (v32)
    {
      unint64_t add = atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL);
      if (!add)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
  *(unsigned char *)(a3 + 4) = add;
  LOBYTE(add) = BYTE8(v28);
  if (*((void *)&v28 + 1) >= 4uLL)
  {
    sub_1D0E5C8F8(&v31);
    sub_1D0E5E098((uint64_t)v33, &v31, 0, 0, "[RELEASE ERROR  ]", "/Library/Caches/com.apple.xbs/Sources/AppleCVA/shared/src/modules/avatar/facekit/accessibilityfilter.mm", 47, "assert %s failed. activation value not implemented%s", (char)"false");
    sub_1D0E6054C((uint64_t)v33);
    int v17 = v32;
    if (v32)
    {
      unint64_t add = atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL);
      if (!add)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
  }
  *(unsigned char *)(a3 + 5) = add;
  LOBYTE(add) = v29;
  if ((unint64_t)v29 >= 4)
  {
    sub_1D0E5C8F8(&v31);
    sub_1D0E5E098((uint64_t)v33, &v31, 0, 0, "[RELEASE ERROR  ]", "/Library/Caches/com.apple.xbs/Sources/AppleCVA/shared/src/modules/avatar/facekit/accessibilityfilter.mm", 47, "assert %s failed. activation value not implemented%s", (char)"false");
    sub_1D0E6054C((uint64_t)v33);
    int v18 = v32;
    if (v32)
    {
      unint64_t add = atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL);
      if (!add)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
  }
  *(unsigned char *)(a3 + 8) = add;
  LOBYTE(add) = BYTE8(v29);
  if (*((void *)&v29 + 1) >= 4uLL)
  {
    sub_1D0E5C8F8(&v31);
    sub_1D0E5E098((uint64_t)v33, &v31, 0, 0, "[RELEASE ERROR  ]", "/Library/Caches/com.apple.xbs/Sources/AppleCVA/shared/src/modules/avatar/facekit/accessibilityfilter.mm", 47, "assert %s failed. activation value not implemented%s", (char)"false");
    sub_1D0E6054C((uint64_t)v33);
    float v19 = v32;
    if (v32)
    {
      unint64_t add = atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL);
      if (!add)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }
  *(unsigned char *)(a3 + 6) = add;
  LOBYTE(add) = v30;
  if (v30 >= 4)
  {
    sub_1D0E5C8F8(&v31);
    sub_1D0E5E098((uint64_t)v33, &v31, 0, 0, "[RELEASE ERROR  ]", "/Library/Caches/com.apple.xbs/Sources/AppleCVA/shared/src/modules/avatar/facekit/accessibilityfilter.mm", 47, "assert %s failed. activation value not implemented%s", (char)"false");
    sub_1D0E6054C((uint64_t)v33);
    float v20 = v32;
    if (v32)
    {
      unint64_t add = atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL);
      if (!add)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
  }
  *(unsigned char *)(a3 + 7) = add;
  *(void *)(a3 + 12) = *(void *)(a2 + 64);
  *(unsigned char *)(a3 + 20) = 1;
}

const void *sub_1D0E36600(uint64_t a1)
{
  cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)v5);
  if (*(unsigned char *)(a1 + 20))
  {
    cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)v4);
    cva::ItemHandler::createValue<int>();
  }
  uint64_t Dictionary = (const void *)cva::DictionaryHandler::getDictionary((cva::DictionaryHandler *)v5);
  CFRetain(Dictionary);
  cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)v5);
  return Dictionary;
}

void sub_1D0E368E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, void *a17)
{
}

uint64_t sub_1D0E3698C(uint64_t a1)
{
  *(void *)a1 = &unk_1F26F37F8;
  if (*(void *)(a1 + 152))
  {
    uint64_t v2 = (uint64_t *)(a1 + 136);
    uint64_t v3 = *(void *)(a1 + 136);
    int v4 = *(uint64_t **)(a1 + 144);
    uint64_t v5 = *v4;
    *(void *)(v5 + 8) = *(void *)(v3 + 8);
    **(void **)(v3 + 8) = v5;
    *(void *)(a1 + 152) = 0;
    if (v4 != (uint64_t *)(a1 + 136))
    {
      do
      {
        uint64_t v6 = (uint64_t *)v4[1];
        int v7 = (std::__shared_weak_count *)v4[3];
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        operator delete(v4);
        int v4 = v6;
      }
      while (v6 != v2);
    }
  }
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 80));
  std::mutex::~mutex((std::mutex *)(a1 + 16));
  return a1;
}

uint64_t **sub_1D0E36A84(uint64_t **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = sub_1D0E09C1C(v2);
    MEMORY[0x1D25F16B0](v3, 0x20C4093837F09);
  }
  return a1;
}

uint64_t sub_1D0E36ACC(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v3 = *(unsigned int *)(a1 + 152);
  std::mutex::unlock(v2);
  return v3;
}

void sub_1D0E36B08(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  if (*(void *)(a1 + 152))
  {
    uint64_t v3 = (uint64_t *)(a1 + 136);
    uint64_t v4 = *(void *)(a1 + 136);
    uint64_t v5 = *(uint64_t **)(a1 + 144);
    uint64_t v6 = *v5;
    *(void *)(v6 + 8) = *(void *)(v4 + 8);
    **(void **)(v4 + 8) = v6;
    *(void *)(a1 + 152) = 0;
    if (v5 != (uint64_t *)(a1 + 136))
    {
      do
      {
        int v7 = (uint64_t *)v5[1];
        int v8 = (std::__shared_weak_count *)v5[3];
        if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
        operator delete(v5);
        uint64_t v5 = v7;
      }
      while (v7 != v3);
    }
  }
  std::mutex::unlock(v2);
}

BOOL sub_1D0E36BF0(uint64_t a1, void *a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  int v5 = *(unsigned __int8 *)(a1 + 128);
  if (*(unsigned char *)(a1 + 128))
  {
    std::mutex::unlock(v4);
  }
  else
  {
    uint64_t v6 = operator new(0x20uLL);
    uint64_t v7 = a2[1];
    uint64_t v6[2] = *a2;
    v6[3] = v7;
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = *(void *)(a1 + 136);
    void *v6 = v8;
    v6[1] = a1 + 136;
    *(void *)(v8 + 8) = v6;
    *(void *)(a1 + 136) = v6;
    uint64_t v9 = *(void *)(a1 + 152) + 1;
    *(void *)(a1 + 152) = v9;
    int v10 = *(_DWORD *)(a1 + 8);
    if (v10 < (int)v9 && (v10 & 0x80000000) == 0)
    {
      do
      {
        uint64_t v11 = *(uint64_t **)(a1 + 144);
        uint64_t v12 = *v11;
        *(void *)(v12 + 8) = v11[1];
        *(void *)v11[1] = v12;
        *(void *)(a1 + 152) = v9 - 1;
        float v13 = (std::__shared_weak_count *)v11[3];
        if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
        operator delete(v11);
        uint64_t v9 = *(void *)(a1 + 152);
        int v14 = *(_DWORD *)(a1 + 8);
      }
      while (v14 < (int)v9 && (v14 & 0x80000000) == 0);
    }
    std::mutex::unlock(v4);
    std::condition_variable::notify_one((std::condition_variable *)(a1 + 80));
  }
  return v5 == 0;
}

void sub_1D0E36D2C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1D0E36D40(uint64_t a1, void *a2, int a3, uint64_t a4)
{
  v20.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 16);
  v20.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 16));
  BOOL v8 = 0;
  uint64_t v9 = *(void *)(a1 + 152);
  if (a3 < 1 || v9) {
    goto LABEL_18;
  }
  BOOL v8 = a4 != 0;
  if (a4)
  {
    if (!*(unsigned char *)(a4 + 8)) {
      goto LABEL_37;
    }
    std::mutex::unlock(*(std::mutex **)a4);
    *(unsigned char *)(a4 + 8) = 0;
  }
  std::chrono::steady_clock::now();
  v10.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  if (!v10.__d_.__rep_)
  {
    uint64_t v11 = 0;
    goto LABEL_14;
  }
  if (v10.__d_.__rep_ < 1)
  {
    if ((unint64_t)v10.__d_.__rep_ < 0xFFDF3B645A1CAC09)
    {
      uint64_t v11 = 0x8000000000000000;
      goto LABEL_14;
    }
LABEL_13:
    uint64_t v11 = 1000 * v10.__d_.__rep_;
    goto LABEL_14;
  }
  if ((unint64_t)v10.__d_.__rep_ <= 0x20C49BA5E353F7) {
    goto LABEL_13;
  }
  uint64_t v11 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_14:
  if (v11 <= ((1000000 * a3) ^ 0x7FFFFFFFFFFFFFFFLL)) {
    v12.__d_.__rep_ = v11 + 1000000 * a3;
  }
  else {
    v12.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
  }
  std::condition_variable::__do_timed_wait((std::condition_variable *)(a1 + 80), &v20, v12);
  std::chrono::steady_clock::now();
  uint64_t v9 = *(void *)(a1 + 152);
LABEL_18:
  if (v9)
  {
    uint64_t v13 = *(void *)(a1 + 144);
    uint64_t v15 = *(void *)(v13 + 16);
    uint64_t v14 = *(void *)(v13 + 24);
    if (v14) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
    }
    int v16 = (std::__shared_weak_count *)a2[1];
    *a2 = v15;
    a2[1] = v14;
    if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
    int v17 = *(uint64_t **)(a1 + 144);
    uint64_t v18 = *v17;
    *(void *)(v18 + 8) = v17[1];
    *(void *)v17[1] = v18;
    --*(void *)(a1 + 152);
    float v19 = (std::__shared_weak_count *)v17[3];
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    operator delete(v17);
  }
  if (v20.__owns_) {
    std::mutex::unlock(v20.__m_);
  }
  if (v8)
  {
    if (*(void *)a4)
    {
      if (!*(unsigned char *)(a4 + 8))
      {
        std::mutex::lock(*(std::mutex **)a4);
        *(unsigned char *)(a4 + 8) = 1;
        return;
      }
    }
    else
    {
      std::__throw_system_error(1, "unique_lock::lock: references null mutex");
    }
    std::__throw_system_error(11, "unique_lock::lock: already locked");
LABEL_37:
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    __break(1u);
  }
}

void sub_1D0E36FBC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1D0E36FD0(uint64_t a1@<X0>, void *a2@<X8>)
{
  v9.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 16);
  v9.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 16));
  for (uint64_t i = *(void *)(a1 + 152); !i; uint64_t i = *(void *)(a1 + 152))
    std::condition_variable::wait((std::condition_variable *)(a1 + 80), &v9);
  int v5 = *(uint64_t **)(a1 + 144);
  uint64_t v6 = v5[3];
  *a2 = v5[2];
  a2[1] = v6;
  if (v6)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    int v5 = *(uint64_t **)(a1 + 144);
    uint64_t i = *(void *)(a1 + 152);
    uint64_t v7 = (std::__shared_weak_count *)v5[3];
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *v5;
  *(void *)(v8 + 8) = v5[1];
  *(void *)v5[1] = v8;
  *(void *)(a1 + 152) = i - 1;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  operator delete(v5);
  if (v9.__owns_) {
    std::mutex::unlock(v9.__m_);
  }
}

void sub_1D0E370D8(uint64_t a1)
{
  *(void *)a1 = &unk_1F26F37F8;
  if (*(void *)(a1 + 152))
  {
    uint64_t v2 = (uint64_t *)(a1 + 136);
    uint64_t v3 = *(void *)(a1 + 136);
    uint64_t v4 = *(uint64_t **)(a1 + 144);
    uint64_t v5 = *v4;
    *(void *)(v5 + 8) = *(void *)(v3 + 8);
    **(void **)(v3 + 8) = v5;
    *(void *)(a1 + 152) = 0;
    if (v4 != (uint64_t *)(a1 + 136))
    {
      do
      {
        uint64_t v6 = (uint64_t *)v4[1];
        uint64_t v7 = (std::__shared_weak_count *)v4[3];
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        operator delete(v4);
        uint64_t v4 = v6;
      }
      while (v6 != v2);
    }
  }
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 80));
  std::mutex::~mutex((std::mutex *)(a1 + 16));
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E371F4(uint64_t a1)
{
  int v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1D0E37270(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F50C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E372C4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F50C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0E372E4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = (void *)MEMORY[0x1D25F1DA0]();
  float v19 = 0;
  uint64_t v20 = 0;
  sub_1D0E36D40(v1 + 40, &v19, 0, 0);
  uint64_t v4 = (uint64_t)v19;
  if (v19) {
    char v5 = v3;
  }
  else {
    char v5 = 0;
  }
  if ((v5 & 1) == 0) {
    goto LABEL_27;
  }
  std::mutex::lock((std::mutex *)(v1 + 56));
  uint64_t v6 = *(void *)(v1 + 192);
  std::mutex::unlock((std::mutex *)(v1 + 56));
  kdebug_trace();
  int v7 = *(_DWORD *)(v4 + 48);
  if (v7)
  {
    if (v7 != 1)
    {
      uint64_t v15 = (_Unwind_Exception *)sub_1D0E221E0();
      std::mutex::unlock(&stru_1EB9F15B8);
      if (v6 && !atomic_fetch_add((atomic_ullong *volatile)((int)v6 + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        (*(void (**)(void))(*(void *)(int)v6 + 16))((int)v6);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)(int)v6);
      }
      kdebug_trace();
      int v16 = (std::__shared_weak_count *)v20;
      if (v20 && !atomic_fetch_add((atomic_ullong *volatile)(v20 + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
      _Unwind_Resume(v15);
    }
    CMTime time = *(CMTime *)(v4 + 24);
    CMTimeGetSeconds(&time);
  }
  if (v6 && (!*(void *)(v4 + 200) || (int)v6 > 9))
  {
    kdebug_trace();
    if (v20) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
    }
    std::mutex::lock(&stru_1EB9F15B8);
    time.value = 0;
    *(void *)&time.timescale = 0;
    sub_1D0E08378();
  }
  kdebug_trace();
  uint64_t v8 = *(uint64_t **)v1;
  std::unique_lock<std::mutex> v9 = (std::__shared_weak_count *)v20;
  v18[0] = v4;
  v18[1] = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1D0E0FEE4((uint64_t)&time, v8, v18);
  long long v17 = *(_OWORD *)&time.value;
  time.value = 0;
  *(void *)&time.timescale = 0;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  kdebug_trace();
  uint64_t v10 = MEMORY[0x1D25F1F10](*v19);
  uint64_t v11 = (void (**)(void, void))v10;
  std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v12 = (std::__shared_weak_count *)v20;
  float v19 = 0;
  uint64_t v20 = 0;
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
    if (!v11) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  if (v10)
  {
LABEL_23:
    kdebug_trace();
    uint64_t Dictionary = cva::DictionaryHandler::getDictionary((cva::DictionaryHandler *)v17);
    v11[2](v11, Dictionary);
    kdebug_trace();
  }
LABEL_24:

  if (*((void *)&v17 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**((void **)&v17 + 1) + 16))(*((void *)&v17 + 1));
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v17 + 1));
  }
LABEL_27:
  uint64_t v14 = (std::__shared_weak_count *)v20;
  if (v20 && !atomic_fetch_add((atomic_ullong *volatile)(v20 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
}

uint64_t sub_1D0E3785C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F26F3660;
  a2[1] = v2;
  return result;
}

void *sub_1D0E37880(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1F26F3660;
  result[1] = v3;
  return result;
}

void sub_1D0E378C8()
{
}

uint64_t sub_1D0E378E0(unsigned char ****a1, const __CFDictionary *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (****a1)
  {
    cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)v4, a2);
    operator new();
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v2 = (id)qword_1EB9F1620;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    _os_log_error_impl(&dword_1D0DBD000, v2, OS_LOG_TYPE_ERROR, "facekit is not properly initialized", buf, 2u);
  }

  return 0;
}

void sub_1D0E397DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, char a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,char a21,uint64_t a22,char a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)(v40 - 224));
  CVPixelBufferRelease(v39);
  sub_1D0DCA2C0((uint64_t)&a19);
  cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)&a21);
  _Unwind_Resume(a1);
}

uint64_t sub_1D0E399B4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 360);
  if (!v2 || atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    uint64_t v3 = *(void **)(a1 + 328);
    if (!v3) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
  std::__shared_weak_count::__release_weak(v2);
  uint64_t v3 = *(void **)(a1 + 328);
  if (v3)
  {
LABEL_4:
    *(void *)(a1 + 336) = v3;
    operator delete(v3);
  }
LABEL_5:
  uint64_t v4 = *(__CVBuffer **)(a1 + 200);
  if (v4) {
    CVPixelBufferRelease(v4);
  }
  char v5 = *(__CVBuffer **)(a1 + 88);
  if (v5) {
    CVPixelBufferRelease(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 80);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    int v7 = *(std::__shared_weak_count **)(a1 + 64);
    if (!v7) {
      goto LABEL_17;
    }
  }
  else
  {
    int v7 = *(std::__shared_weak_count **)(a1 + 64);
    if (!v7) {
      goto LABEL_17;
    }
  }
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
LABEL_17:
  cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)(a1 + 8));

  return a1;
}

void sub_1D0E39B00(uint64_t a1, cva::DictionaryHandler **a2, CVPixelBufferRef pixelBuffer)
{
  if (*a2)
  {
    *(void *)int buf = &unk_1F26F4478;
    *(_DWORD *)uint64_t v20 = 1065353216;
    *(void *)&v20[4] = 0;
    *(void *)&v20[12] = 0x3F80000000000000;
    *(void *)&v20[20] = 0;
    *(_DWORD *)&v20[28] = 0;
    *(void *)&v21[8] = 0;
    *(void *)&v21[16] = 0x3F80000000000000;
    *(void *)&v21[24] = 0;
    *(void *)&v21[32] = 0x3F80000000000000;
    __asm { FMOV            V0.2S, #1.0 }
    *(void *)int v21 = _D0;
    uint64_t v22 = 0;
    int v23 = 0;
    LODWORD(v19) = CVPixelBufferGetWidth(pixelBuffer);
    HIDWORD(v19) = CVPixelBufferGetHeight(pixelBuffer);
    if (sub_1D0E3A468(*a2))
    {
      if (sub_1D0E2BAD0((uint64_t)buf, pixelBuffer))
      {
        long long v11 = *(_OWORD *)&v20[16];
        *(_OWORD *)(a1 + 16) = *(_OWORD *)v20;
        *(_OWORD *)(a1 + 32) = v11;
        long long v12 = *(_OWORD *)&v21[20];
        *(_OWORD *)(a1 + 52) = *(_OWORD *)&v21[4];
        uint64_t v13 = v19;
        *(void *)a1 = &unk_1F26F4478;
        *(void *)(a1 + 8) = v13;
        *(_DWORD *)(a1 + 48) = *(_DWORD *)v21;
        *(_OWORD *)(a1 + 68) = v12;
        *(_DWORD *)(a1 + 84) = *(_DWORD *)&v21[36];
        *(_DWORD *)(a1 + 96) = v23;
        char v14 = 1;
        *(void *)(a1 + 88) = v22;
LABEL_14:
        *(unsigned char *)(a1 + 104) = v14;
        return;
      }
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
      int v16 = (id)qword_1EB9F1620;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long v17 = 0;
        _os_log_error_impl(&dword_1D0DBD000, v16, OS_LOG_TYPE_ERROR, "Failed to extract camera parameters from dictionary.", v17, 2u);
      }
    }
    char v14 = 0;
    *(unsigned char *)a1 = 0;
    goto LABEL_14;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v15 = (id)qword_1EB9F1620;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    _os_log_error_impl(&dword_1D0DBD000, v15, OS_LOG_TYPE_ERROR, "Camera parameters dictionary missing or incomplete.", buf, 2u);
  }

  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 104) = 0;
}

uint64_t sub_1D0E39D94(cva::DictionaryHandler *a1)
{
  uint64_t hasKey = cva::DictionaryHandler::hasKey(a1, @"disparity_invalid_value");
  if (hasKey)
  {
    cva::DictionaryHandler::item(&v4, a1, @"disparity_invalid_value");
    cva::ItemHandler::getValue<int>();
  }
  return hasKey;
}

void sub_1D0E39E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1D0E39E1C(uint64_t a1)
{
  uint64_t v2 = *(__CVBuffer **)(a1 + 88);
  if (v2)
  {
    if (!sub_1D0E2BAD0(a1 + 96, v2))
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
      char v5 = (id)qword_1EB9F1620;
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        goto LABEL_24;
      }
      __int16 v11 = 0;
      uint64_t v6 = "rgb camera parameters check failed";
      int v7 = (uint8_t *)&v11;
      goto LABEL_23;
    }
    uint64_t v3 = *(__CVBuffer **)(a1 + 200);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = *(__CVBuffer **)(a1 + 200);
    if (!v3)
    {
      if (atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire)) {
        goto LABEL_21;
      }
      goto LABEL_30;
    }
  }
  if (!sub_1D0E2BAD0(a1 + 208, v3))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    char v5 = (id)qword_1EB9F1620;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    __int16 v10 = 0;
    uint64_t v6 = "depth camera parameters check failed";
    int v7 = (uint8_t *)&v10;
    goto LABEL_23;
  }
LABEL_7:
  int v4 = *(_DWORD *)(a1 + 48);
  if (!v4) {
    return 1;
  }
  if (v4 == 1)
  {
    if ((*(unsigned char *)(a1 + 36) & 1) == 0)
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0)
      {
        if (__cxa_guard_acquire(&qword_1EB9F1610))
        {
          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
          __cxa_guard_release(&qword_1EB9F1610);
        }
      }
      char v5 = (id)qword_1EB9F1620;
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        goto LABEL_24;
      }
      __int16 v9 = 0;
      uint64_t v6 = "invalid timestamp";
      int v7 = (uint8_t *)&v9;
      goto LABEL_23;
    }
    return 1;
  }
  sub_1D0E221E0();
LABEL_30:
  if (__cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
LABEL_21:
  char v5 = (id)qword_1EB9F1620;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    uint64_t v6 = "color or depth data missing";
    int v7 = buf;
LABEL_23:
    _os_log_error_impl(&dword_1D0DBD000, v5, OS_LOG_TYPE_ERROR, v6, v7, 2u);
  }
LABEL_24:

  return 0;
}

uint64_t sub_1D0E3A0CC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    sub_1D0E399B4(result);
    JUMPOUT(0x1D25F16B0);
  }
  return result;
}

void sub_1D0E3A114(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

uint64_t sub_1D0E3A154(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    sub_1D0E399B4(result);
    JUMPOUT(0x1D25F16B0);
  }
  return result;
}

void sub_1D0E3A19C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E3A1D8(cva::DictionaryHandler *a1, _DWORD *a2)
{
  cva::DictionaryHandler::DictionaryHandler(a1);
  memptr[3] = (void *)16;
  memptr[0] = 0;
  malloc_type_posix_memalign(memptr, 0x20uLL, 0x40uLL, 0x49090899uLL);
  uint64_t v3 = memptr[0];
  memptr[2] = memptr[0];
  memptr[4] = (void *)0x300000003;
  *(_DWORD *)memptr[0] = *a2;
  v3[1] = a2[1];
  v3[2] = a2[2];
  v3[3] = a2[3];
  v3[4] = a2[4];
  v3[5] = a2[5];
  v3[6] = a2[6];
  v3[7] = a2[7];
  v3[8] = a2[8];
  cva::ItemHandler::createMatrix<float>();
}

void sub_1D0E3A304(cva::DictionaryHandler *a1, _DWORD *a2)
{
  cva::DictionaryHandler::DictionaryHandler(a1);
  memptr[3] = (void *)16;
  memptr[0] = 0;
  malloc_type_posix_memalign(memptr, 0x20uLL, 0x40uLL, 0x49090899uLL);
  uint64_t v3 = memptr[0];
  memptr[2] = memptr[0];
  memptr[4] = (void *)0x300000003;
  *(_DWORD *)memptr[0] = *a2;
  v3[1] = a2[1];
  v3[2] = a2[2];
  v3[3] = a2[3];
  v3[4] = a2[4];
  v3[5] = a2[5];
  v3[6] = a2[6];
  v3[7] = a2[7];
  v3[8] = a2[8];
  cva::ItemHandler::createMatrix<float>();
}

uint64_t sub_1D0E3A468(cva::DictionaryHandler *a1)
{
  if (cva::DictionaryHandler::hasKey(a1, @"intrinsics")
    && cva::DictionaryHandler::hasKey(a1, @"extrinsics"))
  {
    cva::DictionaryHandler::item(v5, a1, @"extrinsics");
    cva::ItemHandler::getDictionary((uint64_t *)&v6, (cva::ItemHandler *)v5);
    uint64_t v3 = (cva::DictionaryHandler *)v6;
    uint64_t v2 = v7;
    uint64_t v6 = 0;
    int v7 = 0;
    cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v5);
    if (v3 && sub_1D0E3A600(v3))
    {
      cva::DictionaryHandler::item(v5, a1, @"intrinsics");
      cva::ItemHandler::getMatrix<float>();
    }
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return 0;
}

uint64_t sub_1D0E3A600(cva::DictionaryHandler *a1)
{
  uint64_t result = cva::DictionaryHandler::hasKey(a1, @"rotation");
  if (result)
  {
    uint64_t result = cva::DictionaryHandler::hasKey(a1, @"translation");
    if (result)
    {
      cva::DictionaryHandler::item(&v3, a1, @"rotation");
      cva::ItemHandler::getMatrix<float>();
    }
  }
  return result;
}

void sub_1D0E3A770(uint64_t a1, unsigned int **a2, uint64_t a3)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1618))
  {
    sub_1D0E225B4();
  }
  float v5 = *(float *)(qword_1EB9F15F8 + 112);
  if (v5 <= 0.0) {
    float v6 = -3.0;
  }
  else {
    float v6 = -v5;
  }
  if (v5 <= 0.0) {
    float v7 = 3.0;
  }
  else {
    float v7 = *(float *)(qword_1EB9F15F8 + 112);
  }
  uint64_t v8 = **a2;
  uint64_t v9 = (*a2)[1];
  if (v8 > *(_DWORD *)(a3 + 8) || v9 > *(_DWORD *)(a3 + 12))
  {
    __int16 v11 = *(void **)(a3 + 24);
    if (v11)
    {
      free(v11);
      *(void *)(a3 + 24) = 0;
    }
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = v8 | (v9 << 32);
    *(void *)(a3 + 16) = ((unint64_t)(((v8 + 15) & 0xFFFFFFF0) >> 4) << 36) | 1;
    unint64_t size = v9 * (unint64_t)((v8 + 15) & 0xFFFFFFF0);
    if (size) {
      long long v12 = malloc_type_malloc(size, 0xA153FF5uLL);
    }
    else {
      long long v12 = 0;
    }
    *(void *)(a3 + 24) = v12;
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = v8 | (v9 << 32);
  }
  uint64_t v13 = (v9 * v8);
  if ((int)v13 >= 1)
  {
    for (uint64_t i = 0; i != v13; ++i)
    {
      float v15 = (float)(0.5 - (float)(v6 * (float)(255.0 / (float)(v7 - v6))))
          + (float)((float)(255.0 / (float)(v7 - v6)) * *(float *)(*((void *)*a2 + 1) + 4 * i));
      float v16 = fminf(v15, 255.0);
      if (v15 >= 0.0) {
        float v17 = v16;
      }
      else {
        float v17 = 0.0;
      }
      *(unsigned char *)(*(void *)(a3 + 24) + i) = (int)v17;
    }
  }
}

void sub_1D0E3A8EC(_Unwind_Exception *a1)
{
}

void sub_1D0E3A904(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v175 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a3 + 64);
  float v5 = *(std::__shared_weak_count **)(a3 + 72);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!a2)
  {
    uint64_t v12 = *(unsigned int *)(v6 + 152);
    if (!v12)
    {
LABEL_19:
      if (*(unsigned char *)(v6 + 520)) {
        goto LABEL_188;
      }
LABEL_20:
      if (v12) {
        bzero(*(void **)(v6 + 136), 4 * v12);
      }
      unint64_t v24 = *(unsigned int *)(*(void *)(a1 + 24) + 92);
      int v25 = (void **)(v6 + 160);
      if (v24 != *(_DWORD *)(v6 + 176))
      {
        *(_DWORD *)(v6 + 176) = v24;
        if (v24)
        {
          if (*(void *)(v6 + 168) < v24)
          {
            free(*(void **)(v6 + 160));
            size_t v26 = (4 * v24 + 31) & 0x7FFFFFFE0;
            *(void *)(v6 + 160) = 0;
            *(void *)(v6 + 168) = v26 >> 2;
            memptr = 0;
            malloc_type_posix_memalign(&memptr, 0x20uLL, v26, 0x49090899uLL);
            *(void *)(v6 + 160) = memptr;
          }
        }
        else
        {
          free(*v25);
          *int v25 = 0;
          *(void *)(v6 + 168) = 0;
        }
        unint64_t v24 = *(unsigned int *)(v6 + 176);
      }
      if (v24) {
        bzero(*v25, 4 * v24);
      }
      uint64_t v58 = *(void *)(a1 + 24);
      unint64_t v59 = *(unsigned int *)(v58 + 40);
      uint64_t v60 = *(char **)(v58 + 24);
      uint64_t v61 = *(char **)(v6 + 320);
      if (v59 == *(_DWORD *)(v6 + 336))
      {
LABEL_87:
        if (v60 != v61)
        {
          if (!v59) {
            goto LABEL_121;
          }
          unint64_t v72 = (v59 - 1) & 0x3FFFFFFFFFFFFFFFLL;
          if (v72 < 7)
          {
            unsigned int v73 = v61;
          }
          else
          {
            unsigned int v73 = v61;
            if ((unint64_t)(v61 - v60) >= 0x20)
            {
              uint64_t v74 = (v72 + 1) & 0x7FFFFFFFFFFFFFF8;
              int v75 = v61 + 16;
              uint64_t v76 = (long long *)(v60 + 16);
              uint64_t v77 = v74;
              do
              {
                long long v78 = *v76;
                *(v75 - 1) = *(v76 - 1);
                *int v75 = v78;
                v75 += 2;
                v76 += 2;
                v77 -= 8;
              }
              while (v77);
              if (v72 + 1 == v74)
              {
LABEL_121:
                uint64_t v102 = *(void *)(a1 + 24);
                uint64_t v103 = *(unsigned int *)(v102 + 40);
                int v104 = *(_DWORD *)(v102 + 44) - 1;
                float v105 = *(unsigned char **)(v102 + 24);
                uint64_t v106 = (int *)&v105[4 * v103];
                int v107 = (void **)(v6 + 344);
                if (__PAIR64__(v104, v103) == *(void *)(v6 + 360))
                {
                  int v108 = *v107;
                  goto LABEL_132;
                }
                int v108 = *v107;
                unint64_t v109 = (v104 * v103);
                if (v105 != *v107)
                {
                  *(_DWORD *)(v6 + 360) = v103;
                  *(_DWORD *)(v6 + 364) = v104;
                  if (v109)
                  {
                    if (*(void *)(v6 + 352) < v109)
                    {
                      free(v108);
                      size_t v110 = (4 * v109 + 31) & 0x7FFFFFFE0;
                      *(void *)(v6 + 344) = 0;
                      *(void *)(v6 + 352) = v110 >> 2;
                      memptr = 0;
                      malloc_type_posix_memalign(&memptr, 0x20uLL, v110, 0x49090899uLL);
                      int v108 = memptr;
                      *(void *)(v6 + 344) = memptr;
                    }
                  }
                  else
                  {
                    free(v108);
                    int v108 = 0;
                    *int v107 = 0;
                    *(void *)(v6 + 352) = 0;
                  }
LABEL_132:
                  int v115 = *(_DWORD *)(v6 + 360);
                  int v116 = *(_DWORD *)(v6 + 364);
                  uint64_t v117 = (v116 * v115);
                  if (v105 != (unsigned char *)v108)
                  {
                    if (v117)
                    {
                      if (v104 * v103) {
                        uint64_t v118 = (int *)&v105[4 * v103];
                      }
                      else {
                        uint64_t v118 = 0;
                      }
                      unint64_t v119 = (v117 - 1) & 0x3FFFFFFFFFFFFFFFLL;
                      if (v119 < 7)
                      {
                        int v120 = v108;
                      }
                      else
                      {
                        int v120 = v108;
                        if ((unint64_t)((char *)v108 - (char *)v118) >= 0x20)
                        {
                          unint64_t v121 = v119 + 1;
                          uint64_t v122 = 4 * (v121 & 0x7FFFFFFFFFFFFFF8);
                          int v120 = (_DWORD *)((char *)v108 + v122);
                          int v123 = (long long *)(v118 + 4);
                          uint64_t v124 = v108 + 1;
                          uint64_t v125 = v121 & 0x7FFFFFFFFFFFFFF8;
                          do
                          {
                            long long v126 = *v123;
                            *(v124 - 1) = *(v123 - 1);
                            *uint64_t v124 = v126;
                            v123 += 2;
                            v124 += 2;
                            v125 -= 8;
                          }
                          while (v125);
                          if (v121 == (v121 & 0x7FFFFFFFFFFFFFF8)) {
                            goto LABEL_178;
                          }
                          uint64_t v118 = (int *)((char *)v118 + v122);
                        }
                      }
                      do
                      {
                        int v140 = *v118++;
                        *v120++ = v140;
                      }
                      while (v120 != (_DWORD *)((char *)v108 + 4 * v117));
                    }
LABEL_178:
                    if (*(unsigned char *)(*(void *)(a1 + 24) + 240))
                    {
                      *(_OWORD *)(v6 + 264) = 0u;
                      *(_OWORD *)(v6 + 280) = 0u;
                      *(_OWORD *)(v6 + 296) = 0u;
                      *(unsigned char *)(v6 + 312) = 1;
                      uint64_t v157 = *(void *)(a1 + 24);
                      uint64_t v158 = *(unsigned int *)(v157 + 184);
                      if (v158) {
                        memmove((void *)(v6 + 264), *(const void **)(v157 + 168), 4 * v158);
                      }
                    }
                    v163[0] = v6;
                    v163[1] = v5;
                    if (!v5)
                    {
                      uint64_t v53 = v163;
                      goto LABEL_186;
                    }
                    p_shared_owners = &v5->__shared_owners_;
                    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
                    uint64_t v55 = v163;
LABEL_183:
                    float v159 = sub_1D0E3B644(a1, v55);
                    if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *, float))v5->__on_zero_shared)(v5, v159);
                      std::__shared_weak_count::__release_weak(v5);
                    }
                    goto LABEL_187;
                  }
                  size_t v127 = (4 * v117 + 31) & 0x7FFFFFFE0;
                  size_t v160 = v127 >> 2;
                  memptr = 0;
                  malloc_type_posix_memalign(&memptr, 0x20uLL, v127, 0x49090899uLL);
                  uint64_t v128 = (char *)memptr;
                  if (!v117) {
                    goto LABEL_168;
                  }
                  if (v104 * v103) {
                    float v129 = (int *)&v105[4 * v103];
                  }
                  else {
                    float v129 = 0;
                  }
                  unint64_t v130 = (v117 - 1) & 0x3FFFFFFFFFFFFFFFLL;
                  if (v130 < 7)
                  {
                    int v131 = (char *)memptr;
                  }
                  else
                  {
                    int v131 = (char *)memptr;
                    if ((unint64_t)((unsigned char *)memptr - (unsigned char *)v129) >= 0x20)
                    {
                      unint64_t v132 = v130 + 1;
                      uint64_t v133 = 4 * (v132 & 0x7FFFFFFFFFFFFFF8);
                      int v131 = (char *)memptr + v133;
                      unint64_t v134 = (long long *)(v129 + 4);
                      float v135 = (char *)memptr + 16;
                      uint64_t v136 = v132 & 0x7FFFFFFFFFFFFFF8;
                      do
                      {
                        long long v137 = *v134;
                        *(v135 - 1) = *(v134 - 1);
                        *float v135 = v137;
                        v134 += 2;
                        v135 += 2;
                        v136 -= 8;
                      }
                      while (v136);
                      if (v132 == (v132 & 0x7FFFFFFFFFFFFFF8)) {
                        goto LABEL_168;
                      }
                      float v129 = (int *)((char *)v129 + v133);
                    }
                  }
                  do
                  {
                    int v148 = *v129++;
                    *(_DWORD *)int v131 = v148;
                    v131 += 4;
                  }
                  while (v131 != &v128[4 * v117]);
LABEL_168:
                  int v149 = *(void **)(v6 + 344);
                  *(void *)(v6 + 344) = v128;
                  *(void *)(v6 + 352) = v160;
                  *(_DWORD *)(v6 + 360) = v115;
                  *(_DWORD *)(v6 + 364) = v116;
LABEL_177:
                  free(v149);
                  goto LABEL_178;
                }
                size_t v111 = (4 * (v104 * v103) + 31) & 0x7FFFFFFE0;
                memptr = 0;
                malloc_type_posix_memalign(&memptr, 0x20uLL, v111, 0x49090899uLL);
                uint64_t v112 = (char *)memptr;
                if (v105 != memptr)
                {
                  if (v109)
                  {
                    unint64_t v113 = (v109 - 1) & 0x3FFFFFFFFFFFFFFFLL;
                    if (v113 >= 7)
                    {
                      int v114 = (char *)memptr;
                      if ((unint64_t)((unsigned char *)memptr - &v105[4 * v103]) >= 0x20)
                      {
                        uint64_t v141 = 0;
                        unint64_t v142 = v113 + 1;
                        uint64_t v143 = 4 * (v142 & 0x7FFFFFFFFFFFFFF8);
                        int v114 = (char *)memptr + v143;
                        uint64_t v144 = v142 & 0x7FFFFFFFFFFFFFF8;
                        do
                        {
                          uint64_t v145 = &v112[v141 * 4];
                          long long v146 = *(_OWORD *)&v106[v141 + 4];
                          *(_OWORD *)uint64_t v145 = *(_OWORD *)&v106[v141];
                          *((_OWORD *)v145 + 1) = v146;
                          v141 += 8;
                          v144 -= 8;
                        }
                        while (v144);
                        if (v142 == (v142 & 0x7FFFFFFFFFFFFFF8)) {
                          goto LABEL_176;
                        }
                        uint64_t v106 = (int *)((char *)v106 + v143);
                      }
                    }
                    else
                    {
                      int v114 = (char *)memptr;
                    }
                    do
                    {
                      int v147 = *v106++;
                      *(_DWORD *)int v114 = v147;
                      v114 += 4;
                    }
                    while (v114 != &v112[4 * v109]);
                  }
LABEL_176:
                  int v149 = *(void **)(v6 + 344);
                  *(void *)(v6 + 344) = v112;
                  *(void *)(v6 + 352) = v111 >> 2;
                  *(_DWORD *)(v6 + 360) = v103;
                  *(_DWORD *)(v6 + 364) = v104;
                  goto LABEL_177;
                }
                memptr = 0;
                malloc_type_posix_memalign(&memptr, 0x20uLL, v111, 0x49090899uLL);
                uint64_t v112 = (char *)memptr;
                if (v109)
                {
                  unint64_t v138 = (v109 - 1) & 0x3FFFFFFFFFFFFFFFLL;
                  if (v138 >= 7)
                  {
                    uint64_t v139 = (char *)memptr;
                    if ((unint64_t)((unsigned char *)memptr - v105 - 4 * v103) >= 0x20)
                    {
                      unint64_t v150 = v138 + 1;
                      uint64_t v151 = 4 * (v150 & 0x7FFFFFFFFFFFFFF8);
                      uint64_t v139 = (char *)memptr + v151;
                      uint64_t v152 = (long long *)&v105[4 * v103 + 16];
                      unint64_t v153 = (char *)memptr + 16;
                      uint64_t v154 = v150 & 0x7FFFFFFFFFFFFFF8;
                      do
                      {
                        long long v155 = *v152;
                        *(v153 - 1) = *(v152 - 1);
                        *unint64_t v153 = v155;
                        v152 += 2;
                        v153 += 2;
                        v154 -= 8;
                      }
                      while (v154);
                      if (v150 == (v150 & 0x7FFFFFFFFFFFFFF8)) {
                        goto LABEL_175;
                      }
                      uint64_t v106 = (int *)((char *)v106 + v151);
                    }
                  }
                  else
                  {
                    uint64_t v139 = (char *)memptr;
                  }
                  do
                  {
                    int v156 = *v106++;
                    *(_DWORD *)uint64_t v139 = v156;
                    v139 += 4;
                  }
                  while (v139 != &v112[4 * v109]);
                }
LABEL_175:
                free(v105);
                goto LABEL_176;
              }
              unsigned int v73 = &v61[4 * v74];
              v60 += 4 * v74;
            }
          }
          do
          {
            int v89 = *(_DWORD *)v60;
            v60 += 4;
            *(_DWORD *)unsigned int v73 = v89;
            v73 += 4;
          }
          while (v73 != &v61[4 * v59]);
          goto LABEL_121;
        }
        size_t v79 = (4 * v59 + 31) & 0x7FFFFFFE0;
        size_t v80 = v79 >> 2;
        memptr = 0;
        malloc_type_posix_memalign(&memptr, 0x20uLL, v79, 0x49090899uLL);
        size_t v81 = (char *)memptr;
        if (!v59) {
          goto LABEL_116;
        }
        unint64_t v82 = (v59 - 1) & 0x3FFFFFFFFFFFFFFFLL;
        if (v82 < 7)
        {
          uint64_t v83 = (char *)memptr;
        }
        else
        {
          uint64_t v83 = (char *)memptr;
          if ((unint64_t)((unsigned char *)memptr - v60) >= 0x20)
          {
            uint64_t v84 = (v82 + 1) & 0x7FFFFFFFFFFFFFF8;
            float v85 = (char *)memptr + 16;
            uint64_t v86 = (long long *)(v60 + 16);
            uint64_t v87 = v84;
            do
            {
              long long v88 = *v86;
              *(v85 - 1) = *(v86 - 1);
              *float v85 = v88;
              v85 += 2;
              v86 += 2;
              v87 -= 8;
            }
            while (v87);
            if (v82 + 1 == v84) {
              goto LABEL_116;
            }
            uint64_t v83 = &v81[4 * v84];
            v60 += 4 * v84;
          }
        }
        do
        {
          int v99 = *(_DWORD *)v60;
          v60 += 4;
          *(_DWORD *)uint64_t v83 = v99;
          v83 += 4;
        }
        while (v83 != &v81[4 * v59]);
LABEL_116:
        uint64_t v100 = *(void **)(v6 + 320);
        *(void *)(v6 + 320) = v81;
        *(void *)(v6 + 328) = v80;
LABEL_120:
        *(_DWORD *)(v6 + 336) = v59;
        free(v100);
        goto LABEL_121;
      }
      if (v60 != v61)
      {
        *(_DWORD *)(v6 + 336) = v59;
        if (v59)
        {
          if (*(void *)(v6 + 328) < v59)
          {
            free(v61);
            size_t v62 = (4 * v59 + 31) & 0x7FFFFFFE0;
            *(void *)(v6 + 320) = 0;
            *(void *)(v6 + 328) = v62 >> 2;
            memptr = 0;
            malloc_type_posix_memalign(&memptr, 0x20uLL, v62, 0x49090899uLL);
            uint64_t v61 = (char *)memptr;
            *(void *)(v6 + 320) = memptr;
          }
        }
        else
        {
          free(v61);
          uint64_t v61 = 0;
          *(void *)(v6 + 320) = 0;
          *(void *)(v6 + 328) = 0;
        }
        LODWORD(v59) = *(_DWORD *)(v6 + 336);
        goto LABEL_87;
      }
      size_t v63 = (4 * v59 + 31) & 0x7FFFFFFE0;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v63, 0x49090899uLL);
      int v64 = (char *)memptr;
      if (v60 != memptr)
      {
        if (v59)
        {
          unint64_t v65 = (v59 - 1) & 0x3FFFFFFFFFFFFFFFLL;
          if (v65 < 7)
          {
            size_t v66 = (char *)memptr;
          }
          else
          {
            size_t v66 = (char *)memptr;
            if ((unint64_t)((unsigned char *)memptr - v60) >= 0x20)
            {
              uint64_t v67 = 0;
              uint64_t v68 = (v65 + 1) & 0x7FFFFFFFFFFFFFF8;
              uint64_t v69 = v68;
              do
              {
                int v70 = &v64[v67];
                long long v71 = *(_OWORD *)&v60[v67 + 16];
                *(_OWORD *)int v70 = *(_OWORD *)&v60[v67];
                *((_OWORD *)v70 + 1) = v71;
                v67 += 32;
                v69 -= 8;
              }
              while (v69);
              if (v65 + 1 == v68) {
                goto LABEL_119;
              }
              size_t v66 = &v64[4 * v68];
              v60 += 4 * v68;
            }
          }
          do
          {
            int v101 = *(_DWORD *)v60;
            v60 += 4;
            *(_DWORD *)size_t v66 = v101;
            v66 += 4;
          }
          while (v66 != &v64[4 * v59]);
        }
LABEL_119:
        uint64_t v100 = *(void **)(v6 + 320);
        *(void *)(v6 + 320) = v64;
        *(void *)(v6 + 328) = v63 >> 2;
        goto LABEL_120;
      }
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v63, 0x49090899uLL);
      int v64 = (char *)memptr;
      if (v59)
      {
        unint64_t v90 = (v59 - 1) & 0x3FFFFFFFFFFFFFFFLL;
        float v91 = v60;
        uint64_t v92 = (char *)memptr;
        if (v90 >= 7)
        {
          float v91 = v60;
          uint64_t v92 = (char *)memptr;
          if ((unint64_t)((unsigned char *)memptr - v60) >= 0x20)
          {
            uint64_t v93 = (v90 + 1) & 0x7FFFFFFFFFFFFFF8;
            float v91 = &v60[4 * v93];
            unint64_t v94 = (char *)memptr + 16;
            int v95 = (long long *)(v60 + 16);
            uint64_t v96 = v93;
            do
            {
              long long v97 = *v95;
              *(v94 - 1) = *(v95 - 1);
              _OWORD *v94 = v97;
              v94 += 2;
              v95 += 2;
              v96 -= 8;
            }
            while (v96);
            if (v90 + 1 == v93) {
              goto LABEL_113;
            }
            uint64_t v92 = &v64[4 * v93];
          }
        }
        do
        {
          int v98 = *(_DWORD *)v91;
          v91 += 4;
          *(_DWORD *)uint64_t v92 = v98;
          v92 += 4;
        }
        while (v92 != &v64[4 * v59]);
      }
LABEL_113:
      free(v60);
      goto LABEL_119;
    }
    uint64_t v13 = *(float **)(v6 + 136);
    float v14 = *v13 * *v13;
    if (v12 != 1)
    {
      float v15 = v13 + 1;
      unint64_t v16 = (v12 + 0x3FFFFFFFFFFFFFFELL) & 0x3FFFFFFFFFFFFFFFLL;
      if (v16 < 7) {
        goto LABEL_16;
      }
      unint64_t v17 = v16 + 1;
      uint64_t v18 = (float32x4_t *)(v13 + 5);
      uint64_t v19 = v17 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        float32x4_t v20 = vmulq_f32(v18[-1], v18[-1]);
        float32x4_t v21 = vmulq_f32(*v18, *v18);
        float v14 = (float)((float)((float)((float)((float)((float)((float)(v14 + v20.f32[0]) + v20.f32[1]) + v20.f32[2])
                                            + v20.f32[3])
                                    + v21.f32[0])
                            + v21.f32[1])
                    + v21.f32[2])
            + v21.f32[3];
        v18 += 2;
        v19 -= 8;
      }
      while (v19);
      if (v17 != (v17 & 0x7FFFFFFFFFFFFFF8))
      {
        v15 += v17 & 0x7FFFFFFFFFFFFFF8;
LABEL_16:
        uint64_t v22 = &v13[v12];
        do
        {
          float v23 = *v15++;
          float v14 = v14 + (float)(v23 * v23);
        }
        while (v15 != v22);
      }
    }
    if (v14 > 0.0) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  float v7 = (void **)(v6 + 136);
  if (v6 + 136 == a2 + 16)
  {
    int v27 = *(_DWORD *)(v6 + 152);
  }
  else
  {
    unint64_t v8 = *(unsigned int *)(a2 + 32);
    if (v8)
    {
      uint64_t v9 = *(void **)(v6 + 136);
      size_t v10 = 4 * v8;
      if (*(void *)(v6 + 144) < v8)
      {
        free(v9);
        size_t v11 = (v10 + 31) & 0x7FFFFFFE0;
        *(void *)(v6 + 136) = 0;
        *(void *)(v6 + 144) = v11 >> 2;
        memptr = 0;
        malloc_type_posix_memalign(&memptr, 0x20uLL, v11, 0x49090899uLL);
        uint64_t v9 = memptr;
        *(void *)(v6 + 136) = memptr;
      }
      memcpy(v9, *(const void **)(a2 + 16), v10);
    }
    else
    {
      free(*v7);
      std::__shared_weak_count *v7 = 0;
      *(void *)(v6 + 144) = 0;
    }
    int v27 = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(v6 + 152) = v27;
  }
  uint64_t v28 = *(void *)(a1 + 24);
  long long v29 = (void **)(v6 + 160);
  unint64_t v30 = *(unsigned int *)(v28 + 88);
  uint64_t v31 = *(void **)(v28 + 72);
  v164[0] = v30;
  v164[1] = v27;
  unint64_t v165 = v31;
  int v166 = v30;
  int v167 = 0;
  if (v30 == *(_DWORD *)(v6 + 176)) {
    goto LABEL_30;
  }
  int8x8_t v32 = *v29;
  if (v31 != *v29 && *v7 != v32)
  {
    *(_DWORD *)(v6 + 176) = v30;
    if (v30)
    {
      if (*(void *)(v6 + 168) < v30)
      {
        free(v32);
        size_t v43 = (4 * v30 + 31) & 0x7FFFFFFE0;
        *(void *)(v6 + 160) = 0;
        *(void *)(v6 + 168) = v43 >> 2;
        memptr = 0;
        malloc_type_posix_memalign(&memptr, 0x20uLL, v43, 0x49090899uLL);
        *(void *)(v6 + 160) = memptr;
      }
    }
    else
    {
      free(v32);
      *long long v29 = 0;
      *(void *)(v6 + 168) = 0;
    }
LABEL_30:
    uint64_t v172 = v164;
    uint64_t v173 = v6 + 136;
    int v174 = 1065353216;
    sub_1D0E3D2F4(v6 + 160, (uint64_t)&memptr);
    goto LABEL_37;
  }
  size_t v34 = (4 * v30 + 31) & 0x7FFFFFFE0;
  size_t v169 = v34 >> 2;
  memptr = 0;
  malloc_type_posix_memalign(&memptr, 0x20uLL, v34, 0x49090899uLL);
  int v168 = memptr;
  int v170 = v164[0];
  uint64_t v172 = v164;
  uint64_t v173 = v6 + 136;
  int v174 = 1065353216;
  sub_1D0E3D2F4((uint64_t)&v168, (uint64_t)&memptr);
  BOOL v35 = *(void **)(v6 + 160);
  size_t v36 = *(void *)(v6 + 168);
  size_t v37 = v169;
  *(void *)(v6 + 160) = v168;
  *(void *)(v6 + 168) = v37;
  int v168 = v35;
  size_t v169 = v36;
  *(_DWORD *)(v6 + 176) = v170;
  free(v35);
LABEL_37:
  float v38 = (void **)(v6 + 320);
  if (v6 + 320 != a2 + 40)
  {
    unint64_t v39 = *(unsigned int *)(a2 + 56);
    if (v39)
    {
      uint64_t v40 = *(void **)(v6 + 320);
      if (*(void *)(v6 + 328) >= v39)
      {
        size_t v41 = 4 * v39;
      }
      else
      {
        free(v40);
        size_t v41 = 4 * v39;
        size_t v42 = (4 * v39 + 31) & 0x7FFFFFFE0;
        *(void *)(v6 + 320) = 0;
        *(void *)(v6 + 328) = v42 >> 2;
        memptr = 0;
        malloc_type_posix_memalign(&memptr, 0x20uLL, v42, 0x49090899uLL);
        uint64_t v40 = memptr;
        *(void *)(v6 + 320) = memptr;
      }
      memcpy(v40, *(const void **)(a2 + 40), v41);
    }
    else
    {
      free(*v38);
      *float v38 = 0;
      *(void *)(v6 + 328) = 0;
    }
    *(_DWORD *)(v6 + 336) = *(_DWORD *)(a2 + 56);
  }
  uint64_t v44 = (void **)(v6 + 344);
  if (v6 + 344 != a2 + 64)
  {
    unint64_t v45 = (*(_DWORD *)(a2 + 84) * *(_DWORD *)(a2 + 80));
    if (v45)
    {
      int v46 = *(void **)(v6 + 344);
      if (*(void *)(v6 + 352) >= v45)
      {
        size_t v47 = 4 * v45;
      }
      else
      {
        free(v46);
        size_t v47 = 4 * v45;
        size_t v48 = (4 * v45 + 31) & 0x7FFFFFFE0;
        *(void *)(v6 + 344) = 0;
        *(void *)(v6 + 352) = v48 >> 2;
        memptr = 0;
        malloc_type_posix_memalign(&memptr, 0x20uLL, v48, 0x49090899uLL);
        int v46 = memptr;
        *(void *)(v6 + 344) = memptr;
      }
      memcpy(v46, *(const void **)(a2 + 64), v47);
    }
    else
    {
      free(*v44);
      *uint64_t v44 = 0;
      *(void *)(v6 + 352) = 0;
    }
    *(void *)(v6 + 360) = *(void *)(a2 + 80);
  }
  float32_t v49 = (long long *)(a2 + 88);
  uint64_t v50 = (long long *)(v6 + 264);
  if (*(unsigned __int8 *)(v6 + 312) != *(unsigned __int8 *)(a2 + 136))
  {
    if (!*(unsigned char *)(v6 + 312))
    {
      long long v56 = *v49;
      long long v57 = *(_OWORD *)(a2 + 120);
      *(_OWORD *)(v6 + 280) = *(_OWORD *)(a2 + 104);
      *(_OWORD *)(v6 + 296) = v57;
      *uint64_t v50 = v56;
      *(unsigned char *)(v6 + 312) = 1;
      uint64_t v161 = v6;
      int v162 = v5;
      if (!v5) {
        goto LABEL_60;
      }
      goto LABEL_64;
    }
    *(unsigned char *)(v6 + 312) = 0;
LABEL_63:
    uint64_t v161 = v6;
    int v162 = v5;
    if (!v5) {
      goto LABEL_60;
    }
    goto LABEL_64;
  }
  if (v50 == v49 || !*(unsigned char *)(v6 + 312)) {
    goto LABEL_63;
  }
  long long v51 = *v49;
  long long v52 = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(v6 + 280) = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(v6 + 296) = v52;
  *uint64_t v50 = v51;
  uint64_t v161 = v6;
  int v162 = v5;
  if (v5)
  {
LABEL_64:
    p_shared_owners = &v5->__shared_owners_;
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v55 = &v161;
    goto LABEL_183;
  }
LABEL_60:
  uint64_t v53 = &v161;
LABEL_186:
  sub_1D0E3B644(a1, v53);
LABEL_187:
  *(unsigned char *)(v6 + 520) = 1;
LABEL_188:
  if (v5)
  {
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

float sub_1D0E3B644(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  float v5 = (std::__shared_weak_count *)a2[1];
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    unsigned int v6 = *(_DWORD *)(v4 + 364);
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    unsigned int v6 = *(_DWORD *)(v4 + 364);
  }
  int v7 = *(_DWORD *)(v4 + 364);
  unint64_t v8 = *(uint64_t **)(*(void *)(a1 + 8) + 112);
  uint64_t v9 = *(void *)(v4 + 320);
  v17[0] = *(_DWORD *)(v4 + 360);
  v17[1] = v7;
  uint64_t v18 = *(void *)(v4 + 344);
  int v19 = v17[0];
  int v20 = 0;
  sub_1D0E3B86C(v8, v8 + 3, v9, (uint64_t)v17, v6, *(void *)(v4 + 424), *(void *)(v4 + 448), *(_DWORD *)(v4 + 464));
  if (!v5) {
    goto LABEL_7;
  }
  p_shared_owners = &v5->__shared_owners_;
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_11;
    }
LABEL_7:
    uint64_t v11 = *a2;
    uint64_t v12 = (std::__shared_weak_count *)a2[1];
    if (v12) {
      goto LABEL_8;
    }
LABEL_12:
    sub_1D0E3BA08(*(int **)(*(void *)(a1 + 8) + 16), *(void *)(*(void *)(a1 + 8) + 24), v11);
    goto LABEL_13;
  }
  if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_7;
  }
LABEL_11:
  ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
  std::__shared_weak_count::__release_weak(v5);
  uint64_t v11 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (!v12) {
    goto LABEL_12;
  }
LABEL_8:
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_1D0E3BA08(*(int **)(*(void *)(a1 + 8) + 16), *(void *)(*(void *)(a1 + 8) + 24), v11);
  if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
LABEL_13:
  uint64_t v13 = *a2;
  float v14 = (std::__shared_weak_count *)a2[1];
  v16[0] = v13;
  v16[1] = v14;
  if (!v14) {
    return sub_1D0E3BB70(a1, v16);
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  float result = sub_1D0E3BB70(a1, v16);
  if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *, float))v14->__on_zero_shared)(v14, result);
    std::__shared_weak_count::__release_weak(v14);
  }
  return result;
}

uint64_t *sub_1D0E3B86C(uint64_t *result, uint64_t *a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v8 = *((unsigned int *)result + 4);
  if (v8)
  {
    uint64_t v9 = 0;
    uint64_t v10 = *a2;
    uint64_t v11 = *result;
    do
    {
      uint64_t v12 = 4 * v9;
      uint64_t v13 = (float32x2_t *)(a3 + 4 * (3 * *(_DWORD *)(v11 + v12)));
      float v14 = *(float *)(v10 + v12);
      uint64_t v15 = 4 * (v9 + 1);
      unint64_t v16 = (float32x2_t *)(a3 + 4 * (3 * *(_DWORD *)(v11 + v15)));
      float v17 = *(float *)(v10 + v15);
      uint64_t v18 = 4 * (v9 + 2);
      int v19 = (float32x2_t *)(a3 + 4 * (3 * *(_DWORD *)(v11 + v18)));
      float v20 = *(float *)(v10 + v18);
      float32_t v21 = (float)((float)(v13[1].f32[0] * v14) + (float)(v16[1].f32[0] * v17)) + (float)(v19[1].f32[0] * v20);
      uint64_t v22 = (float32x2_t *)(a6 + v12);
      *uint64_t v22 = vadd_f32(vadd_f32(vmul_n_f32(*v13, v14), vmul_n_f32(*v16, v17)), vmul_n_f32(*v19, v20));
      v22[1].f32[0] = v21;
      v9 += 3;
    }
    while (3 * v8 != v9);
  }
  if (a5 && v8)
  {
    uint64_t v23 = 0;
    int v25 = *(_DWORD *)(a4 + 16);
    uint64_t v24 = *(unsigned int *)(a4 + 20);
    uint64_t v26 = *(void *)(a4 + 8) - 4 * v24;
    uint64_t v27 = *a2;
    uint64_t v28 = *result;
    uint64_t v29 = a5;
    uint64_t v30 = 3 * v8;
    do
    {
      uint64_t v31 = 0;
      uint64_t v32 = v26 + 4 * (v24 + v25 * v23);
      float result = (uint64_t *)(a7 + 4 * (v23 * a8));
      do
      {
        uint64_t v33 = 4 * v31;
        size_t v34 = (float32x2_t *)(v32 + 4 * (3 * *(_DWORD *)(v28 + v33)));
        float v35 = *(float *)(v27 + v33);
        uint64_t v36 = 4 * (v31 + 1);
        size_t v37 = (float32x2_t *)(v32 + 4 * (3 * *(_DWORD *)(v28 + v36)));
        float v38 = *(float *)(v27 + v36);
        uint64_t v39 = 4 * (v31 + 2);
        uint64_t v40 = (float32x2_t *)(v32 + 4 * (3 * *(_DWORD *)(v28 + v39)));
        float v41 = *(float *)(v27 + v39);
        float32_t v42 = (float)((float)(v34[1].f32[0] * v35) + (float)(v37[1].f32[0] * v38)) + (float)(v40[1].f32[0] * v41);
        size_t v43 = (float32x2_t *)((char *)result + v33);
        *size_t v43 = vadd_f32(vadd_f32(vmul_n_f32(*v34, v35), vmul_n_f32(*v37, v38)), vmul_n_f32(*v40, v41));
        v43[1].f32[0] = v42;
        v31 += 3;
      }
      while (v30 != v31);
      ++v23;
    }
    while (v23 != v29);
  }
  return result;
}

int *sub_1D0E3BA08(int *result, uint64_t a2, uint64_t a3)
{
  if ((int)((unint64_t)(a2 - (void)result) >> 2) >= 1)
  {
    uint64_t v3 = *(void *)(a3 + 320);
    uint64_t v4 = *(unsigned int *)(a3 + 364);
    uint64_t v5 = *(void *)(a3 + 344);
    int v6 = *(_DWORD *)(a3 + 360);
    uint64_t v7 = *(void *)(a3 + 472);
    uint64_t v8 = ((unint64_t)(a2 - (void)result) >> 2);
    if (v3 == v7)
    {
      uint64_t v14 = 0;
      uint64_t v15 = result;
      do
      {
        int v16 = *v15++;
        uint64_t v17 = v3 + 4 * (3 * v16);
        uint64_t v18 = v3 + 4 * v14;
        uint64_t v19 = *(void *)(v17 + 4);
        *(_DWORD *)uint64_t v18 = *(_DWORD *)v17;
        *(void *)(v18 + 4) = v19;
        v14 += 3;
      }
      while (3 * v8 != v14);
    }
    else
    {
      uint64_t v9 = 0;
      uint64_t v10 = result;
      do
      {
        int v11 = *v10++;
        uint64_t v12 = (_DWORD *)(v3 + 4 * (3 * v11));
        uint64_t v13 = (_DWORD *)(v7 + 4 * v9);
        _DWORD *v13 = *v12;
        v13[1] = v12[1];
        _OWORD v13[2] = v12[2];
        v9 += 3;
      }
      while (3 * v8 != v9);
    }
    if (v4)
    {
      for (uint64_t i = 0; i != v4; ++i)
      {
        uint64_t v21 = v5 + 4 * (v6 * i);
        uint64_t v22 = *(void *)(a3 + 496) + 4 * (*(_DWORD *)(a3 + 512) * i);
        if (v21 == v22)
        {
          uint64_t v29 = 0;
          uint64_t v30 = result;
          uint64_t v31 = v8;
          do
          {
            int v32 = *v30++;
            uint64_t v33 = (int *)(v21 + 4 * (3 * v32));
            int v34 = *v33;
            uint64_t v35 = *(void *)(v33 + 1);
            uint64_t v36 = v21 + 4 * v29;
            *(_DWORD *)uint64_t v36 = v34;
            *(void *)(v36 + 4) = v35;
            v29 += 3;
            --v31;
          }
          while (v31);
        }
        else
        {
          uint64_t v23 = 0;
          uint64_t v24 = result;
          uint64_t v25 = v8;
          do
          {
            int v26 = *v24++;
            uint64_t v27 = (_DWORD *)(v21 + 4 * (3 * v26));
            uint64_t v28 = (_DWORD *)(v22 + 4 * v23);
            *uint64_t v28 = *v27;
            v28[1] = v27[1];
            v28[2] = v27[2];
            v23 += 3;
            --v25;
          }
          while (v25);
        }
      }
    }
  }
  return result;
}

float sub_1D0E3BB70(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)*a2;
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  unsigned int v5 = *(_DWORD *)(*a2 + 412);
  uint64_t v6 = *a2;
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v6 = *a2;
  }
  uint64_t v7 = *(uint64_t **)(*(void *)(a1 + 8) + 128);
  uint64_t v8 = v3[40];
  v13[0] = v3[45];
  v13[1] = v3[43];
  int v14 = v13[0];
  int v15 = 0;
  sub_1D0E3B86C(v7, v7 + 3, v8, (uint64_t)v13, v5, *(void *)(v6 + 368), *(void *)(v6 + 392), *(_DWORD *)(v6 + 408));
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v9 = *a2;
  uint64_t v10 = *(void *)(*a2 + 392);
  *(float *)(v9 + 416) = *(float *)(v10 + 4) - *(float *)(v10 + 16);
  uint64_t v11 = v10 + 4 * *(unsigned int *)(v9 + 408);
  float result = *(float *)(v11 + 28) - *(float *)(v11 + 40);
  *(float *)(v9 + 420) = result;
  return result;
}

float sub_1D0E3BC68(unsigned int a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1618))
  {
    sub_1D0E225B4();
  }
  float v6 = *(float *)(qword_1EB9F15F8 + 196);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1618))
  {
    sub_1D0E225B4();
  }
  uint64_t v7 = 4 * a2;
  uint64_t v8 = 4 * a1;
  float v9 = *(float *)(qword_1EB9F15F8 + 200);
  float v10 = *(float *)(v5 + v7);
  float v11 = *(float *)(v5 + v8);
  float v12 = hypotf(v10 - v11, 0.0);
  float v13 = expf(v6 * (float)(1.0 - v9));
  float v14 = expf(-(float)(v9 * v6));
  float v15 = expf(v6 * (float)(v12 - v9));
  float v16 = (float)-(float)((float)(v13 + 1.0) * (float)(v14 - v15)) / (float)((float)(v13 - v14) * (float)(v15 + 1.0));
  float v17 = (float)(v10 + v11) * 0.5;
  *(float *)(v5 + v8) = (float)(v11 * v16) + (float)((float)(1.0 - v16) * v17);
  float result = (float)(*(float *)(v5 + v7) * v16) + (float)((float)(1.0 - v16) * v17);
  *(float *)(v5 + v7) = result;
  return result;
}

void sub_1D0E3BDCC(_Unwind_Exception *a1)
{
}

float sub_1D0E3BDE8(float *a1, float *a2, float *a3, float *a4, float *a5)
{
  float v10 = *a2 - a1[63];
  float v11 = a2[1] - a1[64];
  float v12 = a2[2] - a1[65];
  float v13 = 1.0 / sqrtf((float)((float)(v10 * v10) + (float)(v11 * v11)) + (float)(v12 * v12));
  float v14 = v11 * v13;
  float v15 = atan2f(v10 * v13, v12 * v13);
  float v16 = asinf(v14);
  float v17 = fminf(v16 * -1.637, 1.0);
  if ((float)(v16 * -1.637) >= 0.0) {
    float v18 = v17;
  }
  else {
    float v18 = 0.0;
  }
  a3[4] = v18;
  float v19 = v16 * 2.2918;
  float v20 = fminf(v19, 1.0);
  if (v19 >= 0.0) {
    float v21 = v20;
  }
  else {
    float v21 = 0.0;
  }
  a3[12] = v21;
  float v22 = fminf(v15 * -1.637, 1.0);
  if ((float)(v15 * -1.637) >= 0.0) {
    float v23 = v22;
  }
  else {
    float v23 = 0.0;
  }
  a3[6] = v23;
  float v24 = fminf(v15 * 1.637, 1.0);
  if ((float)(v15 * 1.637) >= 0.0) {
    float v25 = v24;
  }
  else {
    float v25 = 0.0;
  }
  a3[10] = v25;
  float v26 = *a2 - a1[60];
  float v27 = a2[1] - a1[61];
  float v28 = a2[2] - a1[62];
  float v29 = 1.0 / sqrtf((float)((float)(v26 * v26) + (float)(v27 * v27)) + (float)(v28 * v28));
  float v30 = v27 * v29;
  float v31 = atan2f(v26 * v29, v28 * v29);
  float v32 = asinf(v30);
  float v33 = fminf(v32 * -1.637, 1.0);
  if ((float)(v32 * -1.637) >= 0.0) {
    float v34 = v33;
  }
  else {
    float v34 = 0.0;
  }
  a3[5] = v34;
  float v35 = v32 * 2.2918;
  float v36 = fminf(v35, 1.0);
  if (v35 >= 0.0) {
    float v37 = v36;
  }
  else {
    float v37 = 0.0;
  }
  a3[13] = v37;
  float v38 = fminf(v31 * 1.637, 1.0);
  if ((float)(v31 * 1.637) >= 0.0) {
    float v39 = v38;
  }
  else {
    float v39 = 0.0;
  }
  a3[7] = v39;
  float v40 = fminf(v31 * -1.637, 1.0);
  if ((float)(v31 * -1.637) >= 0.0) {
    float v41 = v40;
  }
  else {
    float v41 = 0.0;
  }
  a3[11] = v41;
  float v42 = *a2 - a1[63];
  float v43 = a2[1] - a1[64];
  float v44 = a2[2] - a1[65];
  float v45 = 1.0 / sqrtf((float)((float)(v42 * v42) + (float)(v43 * v43)) + (float)(v44 * v44));
  float v46 = v43 * v45;
  *a4 = atan2f(v42 * v45, v44 * v45);
  a4[1] = -asinf(v46);
  float v47 = *a2 - a1[60];
  float v48 = a2[1] - a1[61];
  float v49 = a2[2] - a1[62];
  float v50 = 1.0 / sqrtf((float)((float)(v47 * v47) + (float)(v48 * v48)) + (float)(v49 * v49));
  float v51 = v48 * v50;
  *a5 = atan2f(v47 * v50, v49 * v50);
  float result = -asinf(v51);
  a5[1] = result;
  return result;
}

void sub_1D0E3C074(unsigned int *a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int **)(a2 + 8);
  uint64_t v5 = *((void *)a1 + 1) - 4 * a1[5];
  if (*((void *)v4 + 1) - 4 * v4[5] == v5
    || (uint64_t v6 = *(void *)(a2 + 16), *(void *)(v6 + 8) - 4 * *(unsigned int *)(v6 + 20) == v5))
  {
    size_t v7 = (4 * *v4 + 31) & 0x7FFFFFFE0;
    v21[1] = (void *)(v7 >> 2);
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    v21[0] = memptr;
    int v22 = **(_DWORD **)(a2 + 8);
    sub_1D0E3C230((uint64_t)v21, a2);
    uint64_t v8 = *a1;
    float v9 = v21[0];
    if (v8)
    {
      float v10 = (float32x4_t *)*((void *)a1 + 1);
      unint64_t v11 = (v8 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v11 >= 0xB)
      {
        if (v10 >= (float32x4_t *)((char *)v21[0] + 4 * v8)
          || (float v12 = (float *)v21[0], v13 = (float *)*((void *)a1 + 1), v21[0] >= &v10->f32[v8]))
        {
          uint64_t v14 = (v11 + 1) & 0x7FFFFFFFFFFFFFF8;
          float v12 = (float *)((char *)v21[0] + 4 * v14);
          float v15 = v10 + 1;
          float v16 = (float32x4_t *)((char *)v21[0] + 16);
          uint64_t v17 = v14;
          do
          {
            float32x4_t v18 = vaddq_f32(*v16, *v15);
            v15[-1] = vaddq_f32(v16[-1], v15[-1]);
            *float v15 = v18;
            v15 += 2;
            v16 += 2;
            v17 -= 8;
          }
          while (v17);
          if (v11 + 1 == v14) {
            goto LABEL_17;
          }
          float v13 = &v10->f32[v14];
        }
      }
      else
      {
        float v12 = (float *)v21[0];
        float v13 = (float *)*((void *)a1 + 1);
      }
      float v19 = &v10->f32[v8];
      do
      {
        float v20 = *v12++;
        float *v13 = v20 + *v13;
        ++v13;
      }
      while (v13 != v19);
    }
LABEL_17:
    free(v9);
    return;
  }
  if (v4[1] * *v4)
  {
    if (*(_DWORD *)v6) {
      cva::VecLib<float>::gemm();
    }
  }
}

void sub_1D0E3C230(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int **)(a2 + 8);
  uint64_t v5 = *(void **)a1;
  if ((void *)(*((void *)v4 + 1) - 4 * v4[5]) == v5
    || (uint64_t v6 = *(void *)(a2 + 16), (void *)(*(void *)(v6 + 8) - 4 * *(unsigned int *)(v6 + 20)) == v5))
  {
    size_t v7 = (4 * *v4 + 31) & 0x7FFFFFFE0;
    size_t v12 = v7 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    unint64_t v11 = memptr;
    int v13 = **(_DWORD **)(a2 + 8);
    sub_1D0E3C230(&v11, a2);
    uint64_t v8 = *(void **)a1;
    size_t v9 = v12;
    *(void *)a1 = v11;
    *(void *)(a1 + 8) = v9;
    *(_DWORD *)(a1 + 16) = v13;
    free(v8);
  }
  else
  {
    if (v4[1] * *v4 && *(_DWORD *)v6) {
      cva::VecLib<float>::gemm();
    }
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      bzero(v5, 4 * v10);
    }
  }
}

uint64_t *sub_1D0E3C36C(uint64_t *a1)
{
  (*(void (**)(void))(**(void **)(*a1 + 392) + 24))(*(void *)(*a1 + 392));
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v2 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEFAULT))
  {
    v10[0] = 0;
    _os_log_impl(&dword_1D0DBD000, v2, OS_LOG_TYPE_DEFAULT, "~FaceKitLiteScheduler", (uint8_t *)v10, 2u);
  }
  uint64_t v3 = *a1;
  if (*a1)
  {
    uint64_t v4 = *(void **)(v3 + 624);
    if (v4)
    {
      *(void *)(v3 + 632) = v4;
      operator delete(v4);
    }
    uint64_t v5 = *(void **)(v3 + 600);
    if (v5)
    {
      *(void *)(v3 + 608) = v5;
      operator delete(v5);
    }
    if (*(unsigned char *)(v3 + 440))
    {
      uint64_t v6 = *(std::__shared_weak_count **)(v3 + 424);
      if (v6)
      {
        if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
    }
    sub_1D0E09C1C((uint64_t *)(v3 + 408));
    size_t v7 = *(std::__shared_weak_count **)(v3 + 400);
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    uint64_t v8 = sub_1D0E399B4(v3);
    MEMORY[0x1D25F16B0](v8, 0x10E2C4060765A9DLL);
  }
  return a1;
}

uint64_t sub_1D0E3C53C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1D0E3C560(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F3B30;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E3C5B4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F3B30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_1D0E3C5D4(uint64_t a1, _OWORD *a2, long long *a3, long long *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, float a9, float a10, void *a11, void *a12)
{
  long long v17 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v17;
  long long v18 = *a3;
  long long v19 = a3[1];
  *(_DWORD *)(a1 + 64) = *((_DWORD *)a3 + 8);
  *(_OWORD *)(a1 + 32) = v18;
  *(_OWORD *)(a1 + 48) = v19;
  uint64_t v20 = *(void *)((char *)a3 + 36);
  *(_DWORD *)(a1 + 76) = *((_DWORD *)a3 + 11);
  *(void *)(a1 + 68) = v20;
  long long v21 = *a4;
  long long v22 = a4[1];
  *(_DWORD *)(a1 + 112) = *((_DWORD *)a4 + 8);
  *(_OWORD *)(a1 + 80) = v21;
  *(_OWORD *)(a1 + 96) = v22;
  uint64_t v23 = *(void *)((char *)a4 + 36);
  *(_DWORD *)(a1 + 124) = *((_DWORD *)a4 + 11);
  *(void *)(a1 + 116) = v23;
  *(float *)(a1 + 128) = a9;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 136) = *(void *)a5;
  *(void *)a5 = 0;
  *(void *)(a1 + 144) = *(void *)(a5 + 8);
  *(void *)(a5 + 8) = 0;
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a5 + 16);
  *(_DWORD *)(a5 + 16) = 0;
  uint64_t v24 = *(unsigned int *)(a6 + 16);
  size_t v25 = (4 * v24 + 31) & 0x7FFFFFFE0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = v25 >> 2;
  memptr = 0;
  malloc_type_posix_memalign(&memptr, 0x20uLL, v25, 0x49090899uLL);
  float v26 = memptr;
  *(void *)(a1 + 160) = memptr;
  if (v24) {
    memcpy(v26, *(const void **)a6, 4 * v24);
  }
  *(_DWORD *)(a1 + 176) = *(_DWORD *)(a6 + 16);
  uint64_t v27 = *(unsigned int *)(a7 + 16);
  size_t v28 = (4 * v27 + 31) & 0x7FFFFFFE0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = v28 >> 2;
  memptr = 0;
  malloc_type_posix_memalign(&memptr, 0x20uLL, v28, 0x49090899uLL);
  float v29 = memptr;
  *(void *)(a1 + 184) = memptr;
  if (v27) {
    memcpy(v29, *(const void **)a7, 4 * v27);
  }
  *(_DWORD *)(a1 + 200) = *(_DWORD *)(a7 + 16);
  uint64_t v30 = *a8;
  *(_DWORD *)(a1 + 216) = *((_DWORD *)a8 + 2);
  *(void *)(a1 + 208) = v30;
  *(void *)(a1 + 220) = *a11;
  *(void *)(a1 + 228) = *a12;
  *(float *)(a1 + 236) = a10;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = 0;
  return a1;
}

BOOL sub_1D0E3C770(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 8)) {
    return 1;
  }
  float v3 = *(float *)(a2 + 44);
  return v3 < *(float *)(a1 + 12) || v3 > *(float *)(a1 + 16);
}

uint64_t sub_1D0E3C7A8(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, float a8)
{
  uint64_t v161 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a7 + 208))
  {
    uint64_t v14 = *(void *)(a7 + 136);
    uint64_t v15 = *(void *)(a7 + 144);
    int v16 = *(_DWORD *)(a7 + 152);
    uint64_t v17 = *(void *)(a7 + 120);
    *(void *)(a7 + 136) = *(void *)(a7 + 112);
    *(void *)(a7 + 144) = v17;
    *(_DWORD *)(a7 + 152) = *(_DWORD *)(a7 + 128);
    *(void *)(a7 + 112) = v14;
    *(void *)(a7 + 120) = v15;
    *(_DWORD *)(a7 + 128) = v16;
  }
  else
  {
    uint64_t v18 = *(unsigned int *)(a7 + 128);
    if (v18) {
      memset_pattern16(*(void **)(a7 + 112), &unk_1D0E818D0, 4 * v18);
    }
  }
  long long v19 = a1 + 6;
  int v20 = (*(uint64_t (**)(void *, uint64_t))(*a1 + 56))(a1, a6);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  long long v21 = qword_1EB9F1620;
  BOOL v22 = os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG);
  int v147 = a2;
  uint64_t v145 = a3;
  int v148 = v20;
  if (v20)
  {
    long long v19 = a1 + 5;
    if (!v22) {
      goto LABEL_10;
    }
    LOWORD(memptr) = 0;
    uint64_t v23 = "Using RGB";
  }
  else
  {
    if (!v22) {
      goto LABEL_10;
    }
    LOWORD(memptr) = 0;
    uint64_t v23 = "Using RGB + DEPTH";
  }
  _os_log_debug_impl(&dword_1D0DBD000, v21, OS_LOG_TYPE_DEBUG, v23, (uint8_t *)&memptr, 2u);
LABEL_10:
  uint64_t v24 = *v19;
  uint64_t v25 = *(void *)(*v19 + 64);
  float v26 = (void *)(a7 + 8);
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v25 + 16) - *(void *)(v25 + 8)) >> 3) == (uint64_t)(*(void *)(a7 + 16) - *(void *)(a7 + 8)) >> 3) {
    goto LABEL_36;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  uint64_t v143 = v24;
  uint64_t v27 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v139 = "rgbd";
    if (v148) {
      uint64_t v139 = "rgb only";
    }
    LODWORD(memptr) = 136315138;
    *(void *)((char *)&memptr + 4) = v139;
    _os_log_debug_impl(&dword_1D0DBD000, v27, OS_LOG_TYPE_DEBUG, "Switching setup for using %s regressor.", (uint8_t *)&memptr, 0xCu);
  }
  unint64_t v28 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v25 + 16) - *(void *)(v25 + 8)) >> 3);
  uint64_t v30 = *(char **)(a7 + 8);
  float v29 = *(char **)(a7 + 16);
  unint64_t v31 = (v29 - v30) >> 3;
  BOOL v32 = v28 >= v31;
  unint64_t v33 = v28 - v31;
  if (v28 > v31)
  {
    uint64_t v34 = *(void *)(a7 + 24);
    if (v33 <= (v34 - (uint64_t)v29) >> 3)
    {
      bzero(*(void **)(a7 + 16), 8 * v33);
      *(void *)(a7 + 16) = &v29[8 * v33];
      float v26 = (void *)(a7 + 8);
      uint64_t v24 = v143;
      goto LABEL_36;
    }
    if (v28 >> 61) {
      abort();
    }
    unint64_t v142 = a1;
    uint64_t v35 = v34 - (void)v30;
    if (v35 >> 2 > v28) {
      unint64_t v28 = v35 >> 2;
    }
    if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v28 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v28 >> 61) {
      sub_1D0DE8CE0();
    }
    uint64_t v36 = 8 * v28;
    float v37 = (char *)operator new(8 * v28);
    float v38 = &v37[8 * v31];
    int v140 = v37;
    uint64_t v141 = &v37[v36];
    bzero(v38, 8 * v33);
    float v39 = &v38[8 * v33];
    if (v29 == v30)
    {
      uint64_t v30 = v29;
      float v26 = (void *)(a7 + 8);
      float v41 = v141;
      goto LABEL_34;
    }
    unint64_t v40 = v29 - v30 - 8;
    float v26 = (void *)(a7 + 8);
    if (v40 >= 0x58)
    {
      float v41 = v141;
      if ((unint64_t)(v30 - v140) >= 0x20)
      {
        uint64_t v42 = (v40 >> 3) + 1;
        float v43 = &v140[8 * v31 - 16];
        float v44 = (long long *)(v29 - 16);
        uint64_t v45 = v42 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v46 = *v44;
          *((_OWORD *)v43 - 1) = *(v44 - 1);
          *(_OWORD *)float v43 = v46;
          v43 -= 32;
          v44 -= 2;
          v45 -= 4;
        }
        while (v45);
        v38 -= 8 * (v42 & 0x3FFFFFFFFFFFFFFCLL);
        v29 -= 8 * (v42 & 0x3FFFFFFFFFFFFFFCLL);
        if (v42 == (v42 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_34;
        }
      }
    }
    else
    {
      float v41 = v141;
    }
    do
    {
      uint64_t v47 = *((void *)v29 - 1);
      v29 -= 8;
      *((void *)v38 - 1) = v47;
      v38 -= 8;
    }
    while (v29 != v30);
    uint64_t v30 = *(char **)(a7 + 8);
LABEL_34:
    *(void *)(a7 + 8) = v38;
    *(void *)(a7 + 16) = v39;
    *(void *)(a7 + 24) = v41;
    a1 = v142;
    uint64_t v24 = v143;
    if (v30) {
      operator delete(v30);
    }
    goto LABEL_36;
  }
  float v26 = (void *)(a7 + 8);
  uint64_t v24 = v143;
  if (!v32) {
    *(void *)(a7 + 16) = &v30[0x6666666666666668 * ((uint64_t)(*(void *)(v25 + 16) - *(void *)(v25 + 8)) >> 3)];
  }
LABEL_36:
  float v48 = sub_1D0DFE8D8(*(void **)(v24 + 72), (unint64_t)"network_inputs_image_2_0_bridge");
  if (v48) {
    uint64_t v49 = *((int *)v48 + 6);
  }
  else {
    uint64_t v49 = -1;
  }
  uint64_t v50 = *(void *)(v25 + 8) + 40 * (int)v49;
  int v51 = *(_DWORD *)(v50 + 32);
  uint64_t v52 = *(unsigned int *)(v50 + 36);
  memcpy(*(void **)(a7 + 56), *(const void **)a4, 4 * *(unsigned int *)(a4 + 16));
  uint64_t v54 = *(void *)(a7 + 56);
  if ((int)v52 >= 1 && v51 >= 1)
  {
    v53.i32[0] = *(_DWORD *)a5;
    float v56 = *(float *)(a5 + 4);
    long long v57 = (float *)(v54 + 4 * *(unsigned int *)(a4 + 16));
    uint64_t v58 = v52 & 0xFFFFFFF8;
    uint64_t v59 = 4 * v58;
    float v60 = 1.0 / a8;
    if (v52 > 7)
    {
      float32x4_t v61 = (float32x4_t)vdupq_lane_s32(v53, 0);
      if (v58 == v52)
      {
        int v69 = 0;
        v70.i64[0] = 0x400000004;
        v70.i64[1] = 0x400000004;
        v71.i64[0] = 0x800000008;
        v71.i64[1] = 0x800000008;
        do
        {
          uint64_t v72 = 0;
          int32x4_t v73 = (int32x4_t)xmmword_1D0E814F0;
          do
          {
            uint64_t v74 = (float32x4_t *)&v57[v72];
            *uint64_t v74 = vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(v73), v61), v60);
            v74[1] = vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(vaddq_s32(v73, v70)), v61), v60);
            int32x4_t v73 = vaddq_s32(v73, v71);
            v72 += 8;
          }
          while (v52 != v72);
          long long v57 = (float *)((char *)v57 + v59);
          ++v69;
        }
        while (v69 != v51);
      }
      else
      {
        int v75 = 0;
        v76.i64[0] = 0x400000004;
        v76.i64[1] = 0x400000004;
        v77.i64[0] = 0x800000008;
        v77.i64[1] = 0x800000008;
        do
        {
          long long v78 = (float32x4_t *)(v57 + 4);
          uint64_t v79 = v52 & 0xFFFFFFF8;
          int32x4_t v80 = (int32x4_t)xmmword_1D0E814F0;
          do
          {
            v78[-1] = vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(v80), v61), v60);
            *long long v78 = vmulq_n_f32(vsubq_f32(vcvtq_f32_s32(vaddq_s32(v80, v76)), v61), v60);
            int32x4_t v80 = vaddq_s32(v80, v77);
            v78 += 2;
            v79 -= 8;
          }
          while (v79);
          long long v57 = (float *)((char *)v57 + v59);
          int v81 = v52 & 0xFFFFFFF8;
          do
            *v57++ = v60 * (float)((float)v81++ - *(float *)v53.i32);
          while (v52 != v81);
          ++v75;
        }
        while (v75 != v51);
      }
    }
    else
    {
      v61.i32[1] = 0;
      v61.f32[0] = v60 * (float)(0.0 - *(float *)v53.i32);
      float v62 = v60 * (float)(1.0 - *(float *)v53.i32);
      float v63 = v60 * (float)(2.0 - *(float *)v53.i32);
      float v64 = v60 * (float)(3.0 - *(float *)v53.i32);
      float v65 = v60 * (float)(4.0 - *(float *)v53.i32);
      float v66 = v60 * (float)(5.0 - *(float *)v53.i32);
      float v67 = v60 * (float)(6.0 - *(float *)v53.i32);
      int v68 = v51;
      do
      {
        *long long v57 = v61.f32[0];
        if (v52 == 1)
        {
          ++v57;
        }
        else
        {
          v57[1] = v62;
          if (v52 == 2)
          {
            v57 += 2;
          }
          else
          {
            v57[2] = v63;
            if (v52 == 3)
            {
              v57 += 3;
            }
            else
            {
              v57[3] = v64;
              if (v52 == 4)
              {
                v57 += 4;
              }
              else
              {
                v57[4] = v65;
                if (v52 == 5)
                {
                  v57 += 5;
                }
                else
                {
                  v57[5] = v66;
                  if (v52 == 6)
                  {
                    v57 += 6;
                  }
                  else
                  {
                    v57[6] = v67;
                    v57 += 7;
                  }
                }
              }
            }
          }
        }
        --v68;
      }
      while (v68);
    }
    if (v52 > 7)
    {
      if (v58 == v52)
      {
        int v84 = 0;
        do
        {
          uint64_t v85 = 0;
          v61.f32[0] = v60 * (float)((float)v84 - v56);
          float32x4_t v61 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v61.f32, 0);
          do
          {
            uint64_t v86 = (float32x4_t *)&v57[v85];
            *uint64_t v86 = v61;
            v86[1] = v61;
            v85 += 8;
          }
          while (v52 != v85);
          long long v57 = (float *)((char *)v57 + v59);
          ++v84;
        }
        while (v84 != v51);
      }
      else
      {
        int v87 = 0;
        do
        {
          v61.f32[0] = v60 * (float)((float)v87 - v56);
          int32x4_t v88 = vdupq_lane_s32(*(int32x2_t *)v61.f32, 0);
          int v89 = (int32x4_t *)(v57 + 4);
          uint64_t v90 = v52 & 0xFFFFFFF8;
          do
          {
            v89[-1] = v88;
            *int v89 = v88;
            v89 += 2;
            v90 -= 8;
          }
          while (v90);
          long long v57 = (float *)((char *)v57 + v59);
          int v91 = v52 - v58;
          do
          {
            *v57++ = v61.f32[0];
            --v91;
          }
          while (v91);
          ++v87;
        }
        while (v87 != v51);
      }
    }
    else
    {
      int v82 = 0;
      do
      {
        int v83 = v52;
        do
        {
          *v57++ = v60 * (float)((float)v82 - v56);
          --v83;
        }
        while (v83);
        ++v82;
      }
      while (v82 != v51);
    }
  }
  *(void *)(*v26 + 8 * v49) = v54;
  if ((v148 & 1) == 0)
  {
    uint64_t v92 = v26;
    uint64_t v93 = sub_1D0DFE8D8(*(void **)(v24 + 72), (unint64_t)"network_inputs_depth_images_rays_0_bridge");
    if (v93) {
      uint64_t v94 = *((int *)v93 + 6);
    }
    else {
      uint64_t v94 = -1;
    }
    int v95 = *(_DWORD *)(v145 + 12) * *(_DWORD *)(v145 + 8);
    memcpy(*(void **)(a7 + 80), *(const void **)(v145 + 24), 4 * v95);
    memcpy((void *)(*(void *)(a7 + 80) + 4 * v95), (const void *)(*(void *)(a7 + 56) + 4 * v95), 8 * v95);
    *(void *)(*(void *)(a7 + 8) + 8 * v94) = *(void *)(a7 + 80);
    float v26 = v92;
  }
  uint64_t v96 = sub_1D0DFE8D8(*(void **)(v24 + 72), (unint64_t)"network_inputs_reshape_0_bridge");
  if (v96) {
    uint64_t v97 = *((int *)v96 + 6);
  }
  else {
    uint64_t v97 = -1;
  }
  *(void *)(*v26 + 8 * v97) = *v147;
  int v98 = sub_1D0DFE8D8(*(void **)(v24 + 72), (unint64_t)"network_inputs_reshape_1_0_bridge");
  if (v98) {
    uint64_t v99 = *((int *)v98 + 6);
  }
  else {
    uint64_t v99 = -1;
  }
  int v155 = 0;
  long long v153 = 0u;
  long long v154 = 0u;
  if (&v153 == (long long *)a6)
  {
    uint64_t v108 = 0;
    unint64_t v109 = 0;
    int v110 = *(_DWORD *)(a6 + 4);
    int v112 = *(_DWORD *)(a6 + 8);
    int v111 = *(_DWORD *)(a6 + 12);
    LODWORD(memptr) = *(_DWORD *)a6;
    DWORD1(memptr) = v111;
    int v113 = *(_DWORD *)(a6 + 28);
    DWORD2(memptr) = *(_DWORD *)(a6 + 24);
    HIDWORD(memptr) = v110;
    int v114 = *(_DWORD *)(a6 + 20);
    LODWORD(v157) = *(_DWORD *)(a6 + 16);
    HIDWORD(v157) = v113;
    int v158 = v112;
    int v159 = v114;
    p_long long memptr = (int *)&memptr;
    int v160 = *(_DWORD *)(a6 + 32);
    do
    {
      int v116 = *p_memptr++;
      *(_DWORD *)(a6 + 4 * v108) = v116;
      unint64_t v117 = HIDWORD(v109);
      BOOL v118 = (int)v109 < 2;
      if ((int)v109 < 2) {
        unint64_t v117 = 0;
      }
      uint64_t v119 = v108 + v117;
      uint64_t v120 = (v109 + 1);
      unint64_t v121 = v109 & 0xFFFFFFFF00000000;
      if (!v118) {
        uint64_t v120 = 0;
      }
      unint64_t v109 = v120 | v121;
      uint64_t v108 = v119 + 1;
    }
    while (v108 != 9);
  }
  else
  {
    uint64_t v100 = 0;
    unint64_t v101 = 0;
    unint64_t v102 = 0;
    do
    {
      *((_DWORD *)&v153 + v100) = *(_DWORD *)(a6 + 4 * (3 * v102 + HIDWORD(v102)));
      if ((int)v102 >= 2) {
        unint64_t v102 = (v102 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v102 = (v102 + 1) | v102 & 0xFFFFFFFF00000000;
      }
      unint64_t v103 = HIDWORD(v101);
      BOOL v104 = (int)v101 < 2;
      if ((int)v101 < 2) {
        unint64_t v103 = 0;
      }
      uint64_t v105 = v100 + v103;
      uint64_t v106 = (v101 + 1);
      unint64_t v107 = v101 & 0xFFFFFFFF00000000;
      if (!v104) {
        uint64_t v106 = 0;
      }
      unint64_t v101 = v106 | v107;
      uint64_t v100 = v105 + 1;
    }
    while (v100 != 9);
  }
  *(void *)(*v26 + 8 * v99) = &v153;
  uint64_t v122 = sub_1D0DFE8D8(*(void **)(v24 + 72), (unint64_t)"network_inputs_latents_input_0_bridge");
  if (v122) {
    uint64_t v123 = *((int *)v122 + 6);
  }
  else {
    uint64_t v123 = -1;
  }
  *(void *)(*(void *)(a7 + 8) + 8 * v123) = *(void *)(a7 + 112);
  uint64_t v124 = sub_1D0DFE8D8(*(void **)(v24 + 80), (unint64_t)"latents_output");
  if (v124) {
    uint64_t v125 = *((int *)v124 + 6);
  }
  else {
    uint64_t v125 = -1;
  }
  *(void *)(*(void *)(a7 + 32) + 8 * v125) = *(void *)(a7 + 136);
  long long v126 = sub_1D0DFE8D8(*(void **)(v24 + 80), (unint64_t)"neutral_pca_subset_coeffs_output");
  if (v126) {
    uint64_t v127 = *((int *)v126 + 6);
  }
  else {
    uint64_t v127 = -1;
  }
  *(void *)(*(void *)(a7 + 32) + 8 * v127) = *(void *)(a7 + 160);
  std::mutex::lock((std::mutex *)v24);
  (*(void (**)(void, void *, uint64_t, void))(**(void **)(v24 + 64) + 16))(*(void *)(v24 + 64), v26, a7 + 32, 0);
  std::mutex::unlock((std::mutex *)v24);
  uint64_t v128 = a1[3];
  int v129 = *(_DWORD *)(a7 + 176);
  unint64_t v130 = *(unsigned int *)(v128 + 136);
  int v131 = *(void **)(v128 + 120);
  v149[0] = v130;
  v149[1] = v129;
  unint64_t v150 = v131;
  int v151 = v130;
  int v152 = 0;
  unint64_t v132 = (void **)(a7 + 184);
  if (v130 != *(_DWORD *)(a7 + 200))
  {
    uint64_t v133 = *v132;
    if (v131 == *v132 || *(void **)(a7 + 160) == v133)
    {
      size_t v135 = (4 * v130 + 31) & 0x7FFFFFFE0;
      *((void *)&v153 + 1) = v135 >> 2;
      *(void *)&long long memptr = 0;
      malloc_type_posix_memalign((void **)&memptr, 0x20uLL, v135, 0x49090899uLL);
      *(void *)&long long v153 = memptr;
      LODWORD(v154) = v149[0];
      *((void *)&memptr + 1) = v149;
      uint64_t v157 = a7 + 160;
      int v158 = 1065353216;
      sub_1D0E3D2F4((uint64_t)&v153, (uint64_t)&memptr);
      uint64_t v136 = *(void **)(a7 + 184);
      uint64_t v137 = *((void *)&v153 + 1);
      *(void *)(a7 + 184) = v153;
      *(void *)(a7 + 192) = v137;
      *(_DWORD *)(a7 + 200) = v154;
      free(v136);
      goto LABEL_134;
    }
    *(_DWORD *)(a7 + 200) = v130;
    if (v130)
    {
      if (*(void *)(a7 + 192) < v130)
      {
        free(v133);
        size_t v134 = (4 * v130 + 31) & 0x7FFFFFFE0;
        *(void *)(a7 + 184) = 0;
        *(void *)(a7 + 192) = v134 >> 2;
        *(void *)&long long memptr = 0;
        malloc_type_posix_memalign((void **)&memptr, 0x20uLL, v134, 0x49090899uLL);
        *(void *)(a7 + 184) = memptr;
      }
    }
    else
    {
      free(v133);
      *unint64_t v132 = 0;
      *(void *)(a7 + 192) = 0;
    }
  }
  *((void *)&memptr + 1) = v149;
  uint64_t v157 = a7 + 160;
  int v158 = 1065353216;
  sub_1D0E3D2F4(a7 + 184, (uint64_t)&memptr);
LABEL_134:
  ++*(_DWORD *)(a7 + 208);
  return 1;
}

void sub_1D0E3D2F4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int **)(a2 + 8);
  uint64_t v5 = *(void **)a1;
  if ((void *)(*((void *)v4 + 1) - 4 * v4[5]) == v5 || (uint64_t v6 = *(void *)(a2 + 16), *(void **)v6 == v5))
  {
    size_t v7 = (4 * *v4 + 31) & 0x7FFFFFFE0;
    size_t v12 = v7 >> 2;
    long long memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    unint64_t v11 = memptr;
    int v13 = **(_DWORD **)(a2 + 8);
    sub_1D0E3D2F4(&v11, a2);
    uint64_t v8 = *(void **)a1;
    size_t v9 = v12;
    *(void *)a1 = v11;
    *(void *)(a1 + 8) = v9;
    *(_DWORD *)(a1 + 16) = v13;
    free(v8);
  }
  else
  {
    if (v4[1] * *v4 && *(_DWORD *)(v6 + 16)) {
      cva::VecLib<float>::gemm();
    }
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      bzero(v5, 4 * v10);
    }
  }
}

void sub_1D0E3D424(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (const void **)(a2 + 136);
  uint64_t v6 = a3 + 8;
  if (a3 + 8 != a2 + 136)
  {
    unint64_t v7 = *(unsigned int *)(a2 + 152);
    if (v7)
    {
      uint64_t v8 = *(void **)(a3 + 8);
      if (*(void *)(a3 + 16) >= v7)
      {
        size_t v9 = 4 * v7;
      }
      else
      {
        free(v8);
        size_t v9 = 4 * v7;
        size_t v10 = (4 * v7 + 31) & 0x7FFFFFFE0;
        *(void *)(a3 + 8) = 0;
        *(void *)(a3 + 16) = v10 >> 2;
        long long memptr = 0;
        malloc_type_posix_memalign(&memptr, 0x20uLL, v10, 0x49090899uLL);
        uint64_t v8 = memptr;
        *(void *)(a3 + 8) = memptr;
      }
      memcpy(v8, *v5, v9);
    }
    else
    {
      free(*(void **)v6);
      *(void *)uint64_t v6 = 0;
      *(void *)(v6 + 8) = 0;
    }
    *(_DWORD *)(a3 + 24) = *(_DWORD *)(a2 + 152);
  }
  unint64_t v11 = (void **)(a3 + 32);
  if (a3 + 32 != a2 + 184)
  {
    unint64_t v12 = *(unsigned int *)(a2 + 200);
    if (v12)
    {
      int v13 = *(void **)(a3 + 32);
      if (*(void *)(a3 + 40) >= v12)
      {
        size_t v14 = 4 * v12;
      }
      else
      {
        free(v13);
        size_t v14 = 4 * v12;
        size_t v15 = (4 * v12 + 31) & 0x7FFFFFFE0;
        *(void *)(a3 + 32) = 0;
        *(void *)(a3 + 40) = v15 >> 2;
        long long memptr = 0;
        malloc_type_posix_memalign(&memptr, 0x20uLL, v15, 0x49090899uLL);
        int v13 = memptr;
        *(void *)(a3 + 32) = memptr;
      }
      memcpy(v13, *(const void **)(a2 + 184), v14);
    }
    else
    {
      free(*v11);
      *unint64_t v11 = 0;
      *(void *)(a3 + 40) = 0;
    }
    *(_DWORD *)(a3 + 48) = *(_DWORD *)(a2 + 200);
  }
  *(_DWORD *)(a3 + 56) = *(_DWORD *)(a2 + 208);
}

void sub_1D0E3D578(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v5 = *a3;
  uint64_t v6 = *a3 + 136;
  if (v6 != a2 + 8)
  {
    unint64_t v7 = *(unsigned int *)(a2 + 24);
    if (v7)
    {
      uint64_t v8 = *(void **)(v5 + 136);
      if (*(void *)(v5 + 144) >= v7)
      {
        size_t v9 = 4 * v7;
      }
      else
      {
        free(v8);
        size_t v9 = 4 * v7;
        size_t v10 = (4 * v7 + 31) & 0x7FFFFFFE0;
        *(void *)(v5 + 136) = 0;
        *(void *)(v5 + 144) = v10 >> 2;
        long long memptr = 0;
        malloc_type_posix_memalign(&memptr, 0x20uLL, v10, 0x49090899uLL);
        uint64_t v8 = memptr;
        *(void *)(v5 + 136) = memptr;
      }
      memcpy(v8, *(const void **)(a2 + 8), v9);
    }
    else
    {
      free(*(void **)v6);
      *(void *)uint64_t v6 = 0;
      *(void *)(v6 + 8) = 0;
    }
    *(_DWORD *)(v5 + 152) = *(_DWORD *)(a2 + 24);
  }
  unint64_t v11 = (void **)(v5 + 184);
  if (v5 + 184 != a2 + 32)
  {
    unint64_t v12 = *(unsigned int *)(a2 + 48);
    if (v12)
    {
      int v13 = *(void **)(v5 + 184);
      if (*(void *)(v5 + 192) >= v12)
      {
        size_t v14 = 4 * v12;
      }
      else
      {
        free(v13);
        size_t v14 = 4 * v12;
        size_t v15 = (4 * v12 + 31) & 0x7FFFFFFE0;
        *(void *)(v5 + 184) = 0;
        *(void *)(v5 + 192) = v15 >> 2;
        long long memptr = 0;
        malloc_type_posix_memalign(&memptr, 0x20uLL, v15, 0x49090899uLL);
        int v13 = memptr;
        *(void *)(v5 + 184) = memptr;
      }
      memcpy(v13, *(const void **)(a2 + 32), v14);
    }
    else
    {
      free(*v11);
      *unint64_t v11 = 0;
      *(void *)(v5 + 192) = 0;
    }
    *(_DWORD *)(v5 + 200) = *(_DWORD *)(a2 + 48);
  }
  *(_DWORD *)(v5 + 208) = *(_DWORD *)(a2 + 56);
}

void sub_1D0E3D6F4()
{
}

void sub_1D0E3D848(uint64_t a1)
{
  *(void *)a1 = &unk_1F26F3EF8;
  free(*(void **)(a1 + 32));
  free(*(void **)(a1 + 8));
  JUMPOUT(0x1D25F16B0);
}

uint64_t sub_1D0E3D8B8(uint64_t a1)
{
  *(void *)a1 = &unk_1F26F3EF8;
  free(*(void **)(a1 + 32));
  free(*(void **)(a1 + 8));
  return a1;
}

void sub_1D0E3D908()
{
}

uint64_t sub_1D0E3DD34(uint64_t a1)
{
  return a1 + 136;
}

uint64_t sub_1D0E3DD3C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 208);
}

uint64_t sub_1D0E3DD44(uint64_t a1)
{
  return a1 + 184;
}

void sub_1D0E3DD4C(uint64_t a1)
{
  sub_1D0E3DD84(a1);
  JUMPOUT(0x1D25F16B0);
}

uint64_t sub_1D0E3DD84(uint64_t a1)
{
  *(void *)a1 = &unk_1F26F3F18;
  free(*(void **)(a1 + 184));
  free(*(void **)(a1 + 160));
  free(*(void **)(a1 + 136));
  free(*(void **)(a1 + 112));
  if (*(unsigned char *)(a1 + 104)) {
    free(*(void **)(a1 + 80));
  }
  free(*(void **)(a1 + 56));
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }
  float v3 = *(void **)(a1 + 8);
  if (v3)
  {
    *(void *)(a1 + 16) = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1D0E3DE1C(void *a1)
{
  sub_1D0E3DE54(a1);
  JUMPOUT(0x1D25F16B0);
}

void *sub_1D0E3DE54(void *a1)
{
  *a1 = &unk_1F26F3FA8;
  uint64_t v2 = (std::mutex *)a1[6];
  a1[6] = 0;
  if (v2)
  {
    sub_1D0E3DF24(v2);
    MEMORY[0x1D25F16B0]();
  }
  float v3 = (std::mutex *)a1[5];
  a1[5] = 0;
  if (v3)
  {
    sub_1D0E3DF24(v3);
    MEMORY[0x1D25F16B0]();
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[4];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_1D0E3DF24(std::mutex *this)
{
  uint64_t v2 = *(void *)&this[1].__m_.__opaque[8];
  *(void *)&this[1].__m_.__opaque[8] = 0;
  if (v2)
  {
    float v3 = *(void **)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v4 = (void *)*v3;
        operator delete(v3);
        float v3 = v4;
      }
      while (v4);
    }
    uint64_t v5 = *(void **)v2;
    *(void *)uint64_t v2 = 0;
    if (v5) {
      operator delete(v5);
    }
    MEMORY[0x1D25F16B0](v2, 0x10A0C408EF24B1CLL);
  }
  uint64_t v6 = *(void *)this[1].__m_.__opaque;
  *(void *)this[1].__m_.__opaque = 0;
  if (v6)
  {
    unint64_t v7 = *(void **)(v6 + 16);
    if (v7)
    {
      do
      {
        uint64_t v8 = (void *)*v7;
        operator delete(v7);
        unint64_t v7 = v8;
      }
      while (v8);
    }
    size_t v9 = *(void **)v6;
    *(void *)uint64_t v6 = 0;
    if (v9) {
      operator delete(v9);
    }
    MEMORY[0x1D25F16B0](v6, 0x10A0C408EF24B1CLL);
  }
  uint64_t sig = this[1].__m_.__sig;
  if (sig) {
    (*(void (**)(uint64_t))(*(void *)sig + 8))(sig);
  }
  std::mutex::~mutex(this);
}

uint64_t sub_1D0E3E028(void *a1, uint64_t a2, unsigned char *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v29 = a6;
  kdebug_trace();
  if (a3[2])
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    size_t v10 = qword_1EB9F1620;
    if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1D0DBD000, v10, OS_LOG_TYPE_INFO, "Loading MultiFrame IdentityNet on CPU.", buf, 2u);
    }
    int v28 = 0;
  }
  else
  {
    int v11 = MGGetBoolAnswer();
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    unint64_t v12 = qword_1EB9F1620;
    BOOL v13 = os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO);
    if (v11)
    {
      if (v13)
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1D0DBD000, v12, OS_LOG_TYPE_INFO, "Loading MultiFrame IdentityNet on ANE.", buf, 2u);
      }
      int v14 = 2;
    }
    else
    {
      if (v13)
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1D0DBD000, v12, OS_LOG_TYPE_INFO, "Loading MultiFrame IdentityNet on GPU.", buf, 2u);
      }
      int v14 = 1;
    }
    int v28 = v14;
  }
  LOBYTE(v26) = 0;
  char v27 = 0;
  if (*(unsigned char *)(a5 + 8))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    size_t v15 = qword_1EB9F1620;
    if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v15, OS_LOG_TYPE_ERROR, "Failed to initialize the surfaces for IdentityFittingMultiFrame.", buf, 2u);
    }
    goto LABEL_19;
  }
  *(void *)int buf = a3;
  uint64_t v22 = a4;
  uint64_t v23 = &v26;
  uint64_t v24 = &v29;
  uint64_t v25 = &v28;
  sub_1D0E3E48C(&v20, (uint64_t)buf, 1, (uint64_t)&off_1E689AAC0);
  uint64_t v18 = v20;
  if (!v20)
  {
LABEL_19:
    *a1 = 0;
    a1[1] = 0;
    goto LABEL_20;
  }
  if (*a3 || (sub_1D0E3E48C(&v19, (uint64_t)buf, 0, (uint64_t)&off_1E689AAE0), v19)) {
    operator new();
  }
  *a1 = 0;
  a1[1] = 0;
  sub_1D0E3DF24(v18);
  MEMORY[0x1D25F16B0]();
LABEL_20:
  if (v27)
  {
    uint64_t v16 = v26;
    uint64_t v26 = 0;
    if (v16) {
      MEMORY[0x1D25F16B0](v16, 0xC400A2AC0F1);
    }
  }
  return kdebug_trace();
}

uint64_t sub_1D0E3E48C(void *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  if (a3) {
    uint64_t v8 = "RGB";
  }
  else {
    uint64_t v8 = "RGBD";
  }
  if (*(_DWORD *)(*(void *)a2 + 52))
  {
    if (a3) {
      size_t v9 = "id_fitting_multiframe_rgb_only";
    }
    else {
      size_t v9 = "id_fitting_multiframe_rgbd";
    }
    sub_1D0E1FE48(&v27, *(void *)(a2 + 8), **(_DWORD **)(a2 + 32), v9, (const char *)&unk_1D0E87663);
    if (v27)
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
      size_t v10 = qword_1EB9F1620;
      if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int buf = 136315138;
        uint64_t v29 = v8;
        _os_log_impl(&dword_1D0DBD000, v10, OS_LOG_TYPE_INFO, "%s regressor created.", buf, 0xCu);
      }
      int v11 = v27;
      sub_1D0E5BC54(&v26, v27 + 1, a4);
      if (v26)
      {
        sub_1D0E5BC54(&v25, v11 + 4, (uint64_t)&off_1E689AAD0);
        if (v25) {
          operator new();
        }
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1610))
        {
          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
          __cxa_guard_release(&qword_1EB9F1610);
        }
        size_t v15 = qword_1EB9F1620;
        if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 136315138;
          uint64_t v29 = v8;
          _os_log_error_impl(&dword_1D0DBD000, v15, OS_LOG_TYPE_ERROR, "Failed to map output node names to the %s regressor's output nodes.", buf, 0xCu);
        }
        *a1 = 0;
        uint64_t v16 = (void **)v25;
        if (v25)
        {
          uint64_t v17 = *(void **)(v25 + 16);
          if (v17)
          {
            do
            {
              uint64_t v18 = (void *)*v17;
              operator delete(v17);
              uint64_t v17 = v18;
            }
            while (v18);
          }
          uint64_t v19 = *v16;
          *uint64_t v16 = 0;
          if (v19) {
            operator delete(v19);
          }
          MEMORY[0x1D25F16B0](v16, 0x10A0C408EF24B1CLL);
        }
      }
      else
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1610))
        {
          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
          __cxa_guard_release(&qword_1EB9F1610);
        }
        int v14 = qword_1EB9F1620;
        if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 136315138;
          uint64_t v29 = v8;
          _os_log_error_impl(&dword_1D0DBD000, v14, OS_LOG_TYPE_ERROR, "Failed to map input node names to the %s regressor's input nodes.", buf, 0xCu);
        }
        *a1 = 0;
      }
      int v20 = (void **)v26;
      if (v26)
      {
        long long v21 = *(void **)(v26 + 16);
        if (v21)
        {
          do
          {
            uint64_t v22 = (void *)*v21;
            operator delete(v21);
            long long v21 = v22;
          }
          while (v22);
        }
        uint64_t v23 = *v20;
        *int v20 = 0;
        if (v23) {
          operator delete(v23);
        }
        MEMORY[0x1D25F16B0](v20, 0x10A0C408EF24B1CLL);
      }
      goto LABEL_42;
    }
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    unint64_t v12 = qword_1EB9F1620;
    if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl(&dword_1D0DBD000, v12, OS_LOG_TYPE_ERROR, "Invalid depth source", buf, 2u);
    }
    char v27 = 0;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1610))
  {
    qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
    __cxa_guard_release(&qword_1EB9F1610);
  }
  BOOL v13 = qword_1EB9F1620;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)int buf = 136315138;
    uint64_t v29 = v8;
    _os_log_error_impl(&dword_1D0DBD000, v13, OS_LOG_TYPE_ERROR, "Failed to initialize %s regressor for IdentityFittingMultiFrame.", buf, 0xCu);
  }
  *a1 = 0;
LABEL_42:
  if (v27) {
    (*(void (**)(void *))(*v27 + 8))(v27);
  }
  return kdebug_trace();
}

uint64_t sub_1D0E3E9DC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1D0E3EA0C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E3EA48(void **a1, void *a2)
{
  uint64_t v4 = (char *)a1[1];
  if (v4 != *a1)
  {
    uint64_t v5 = (char *)a1[1];
    goto LABEL_25;
  }
  unint64_t v7 = a1[2];
  uint64_t v6 = a1[3];
  if (v7 >= v6)
  {
    uint64_t v13 = v6 - v4;
    BOOL v12 = v13 == 0;
    unint64_t v14 = v13 >> 2;
    if (v12) {
      unint64_t v14 = 1;
    }
    if (v14 >> 61) {
      sub_1D0DE8CE0();
    }
    unint64_t v15 = (v14 + 3) >> 2;
    uint64_t v16 = 8 * v14;
    uint64_t v17 = (char *)operator new(8 * v14);
    uint64_t v5 = &v17[8 * v15];
    uint64_t v18 = &v17[v16];
    uint64_t v19 = v5;
    uint64_t v20 = v7 - v4;
    if (v7 != v4)
    {
      uint64_t v19 = &v5[v20 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v21 = v20 - 8;
      uint64_t v22 = &v17[8 * v15];
      uint64_t v23 = v4;
      if (v21 > 0x37)
      {
        uint64_t v24 = &v17[8 * v15];
        uint64_t v22 = v24;
        uint64_t v23 = v4;
        if ((unint64_t)(v24 - v4) >= 0x20)
        {
          uint64_t v25 = (v21 >> 3) + 1;
          uint64_t v26 = 8 * (v25 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v22 = &v5[v26];
          char v27 = (long long *)(v4 + 16);
          int v28 = v24 + 16;
          uint64_t v29 = v25 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v30 = *v27;
            *(v28 - 1) = *(v27 - 1);
            *int v28 = v30;
            v27 += 2;
            v28 += 2;
            v29 -= 4;
          }
          while (v29);
          if (v25 == (v25 & 0x3FFFFFFFFFFFFFFCLL))
          {
            *a1 = v17;
            a1[1] = v5;
            a1[2] = v19;
            a1[3] = v18;
            goto LABEL_24;
          }
          uint64_t v23 = &v4[v26];
        }
      }
      do
      {
        uint64_t v31 = *(void *)v23;
        v23 += 8;
        *(void *)uint64_t v22 = v31;
        v22 += 8;
      }
      while (v22 != v19);
    }
    *a1 = v17;
    a1[1] = v5;
    a1[2] = v19;
    a1[3] = v18;
    if (!v4) {
      goto LABEL_25;
    }
LABEL_24:
    operator delete(v4);
    uint64_t v5 = (char *)a1[1];
    goto LABEL_25;
  }
  uint64_t v8 = (v6 - v7) >> 3;
  if (v8 >= -1) {
    uint64_t v9 = v8 + 1;
  }
  else {
    uint64_t v9 = v8 + 2;
  }
  uint64_t v10 = v9 >> 1;
  int v11 = &v7[8 * (v9 >> 1)];
  uint64_t v5 = &v11[-(v7 - v4)];
  if (v7 != v4)
  {
    memmove(&v11[-(v7 - v4)], v4, v7 - v4);
    uint64_t v4 = (char *)a1[2];
  }
  a1[1] = v5;
  a1[2] = &v4[8 * v10];
LABEL_25:
  *((void *)v5 - 1) = *a2;
  a1[1] = (char *)a1[1] - 8;
}

void sub_1D0E3EBF0(char **a1, void *a2)
{
  uint64_t v4 = a1[2];
  if (v4 != a1[3]) {
    goto LABEL_23;
  }
  uint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  if (v5 > *a1)
  {
    uint64_t v7 = (v5 - *a1) >> 3;
    if (v7 >= -1) {
      uint64_t v8 = v7 + 1;
    }
    else {
      uint64_t v8 = v7 + 2;
    }
    uint64_t v9 = v8 >> 1;
    uint64_t v10 = -v9;
    int v11 = &v5[-8 * v9];
    int64_t v12 = v4 - v5;
    if (v4 != v5)
    {
      memmove(&v5[-8 * v9], a1[1], v4 - v5);
      uint64_t v4 = a1[1];
    }
    uint64_t v13 = &v4[8 * v10];
    uint64_t v4 = &v11[v12];
    a1[1] = v13;
    a1[2] = &v11[v12];
    goto LABEL_23;
  }
  unint64_t v14 = (v4 - v6) >> 2;
  if (v4 == v6) {
    unint64_t v14 = 1;
  }
  if (v14 >> 61) {
    sub_1D0DE8CE0();
  }
  unint64_t v15 = v14 >> 2;
  uint64_t v16 = 8 * v14;
  uint64_t v17 = (char *)operator new(8 * v14);
  uint64_t v18 = &v17[8 * v15];
  int64_t v20 = v4 - v5;
  BOOL v19 = v4 == v5;
  uint64_t v4 = v18;
  if (!v19)
  {
    uint64_t v4 = &v18[v20 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v21 = v20 - 8;
    if ((unint64_t)(v20 - 8) < 0x38)
    {
      uint64_t v22 = &v17[8 * v15];
      goto LABEL_20;
    }
    uint64_t v23 = &v17[8 * v15];
    uint64_t v22 = v23;
    if ((unint64_t)(v23 - v5) < 0x20)
    {
      do
      {
LABEL_20:
        uint64_t v30 = *(void *)v5;
        v5 += 8;
        *(void *)uint64_t v22 = v30;
        v22 += 8;
      }
      while (v22 != v4);
      goto LABEL_21;
    }
    uint64_t v24 = (v21 >> 3) + 1;
    uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v22 = &v18[v25];
    uint64_t v26 = (long long *)(v5 + 16);
    char v27 = v23 + 16;
    uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v29 = *v26;
      *(v27 - 1) = *(v26 - 1);
      *char v27 = v29;
      v26 += 2;
      v27 += 2;
      v28 -= 4;
    }
    while (v28);
    if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
    {
      v5 += v25;
      goto LABEL_20;
    }
  }
LABEL_21:
  *a1 = v17;
  a1[1] = v18;
  a1[2] = v4;
  a1[3] = &v17[v16];
  if (v6)
  {
    operator delete(v6);
    uint64_t v4 = a1[2];
  }
LABEL_23:
  *(void *)uint64_t v4 = *a2;
  a1[2] += 8;
}

void sub_1D0E3ED7C(char *a1@<X8>)
{
  a1[23] = 8;
  strcpy(a1, "Disabled");
}

uint64_t sub_1D0E3EDA0()
{
  return 0;
}

void sub_1D0E3EDA8(uint64_t a1, uint64_t ***a2)
{
  uint64_t v2 = *a2;
  float v3 = a2[1];
  if (*a2 != v3)
  {
    do
    {
      uint64_t v4 = **v2;
      uint64_t v5 = *(void *)(v4 + 24);
      uint64_t v6 = *(std::__shared_weak_count **)(v4 + 32);
      if (v6)
      {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        int v7 = *(unsigned __int8 *)(*(void *)v5 + 16);
        if (atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          if (!v7) {
            goto LABEL_12;
          }
        }
        else
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
          if (!v7)
          {
LABEL_12:
            uint64_t v8 = **v2;
            uint64_t v9 = *(const unsigned __int8 ***)(v8 + 24);
            uint64_t v10 = *(std::__shared_weak_count **)(v8 + 32);
            if (v10)
            {
              atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_1D0DF8034(v9);
              if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
                std::__shared_weak_count::__release_weak(v10);
              }
            }
            else
            {
              sub_1D0DF8034(v9);
            }
          }
        }
      }
      else if (!*(unsigned char *)(*(void *)v5 + 16))
      {
        goto LABEL_12;
      }
      v2 += 2;
    }
    while (v2 != v3);
  }
}

void sub_1D0E3EECC()
{
}

uint64_t sub_1D0E3EEE4(uint64_t a1)
{
  sub_1D0E3F370(a1 + 536);
  sub_1D0E3F370(a1 + 480);
  sub_1D0E3F438(a1 + 424);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 408);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    float v3 = *(std::__shared_weak_count **)(a1 + 392);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    float v3 = *(std::__shared_weak_count **)(a1 + 392);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  free(*(void **)(a1 + 360));
  free(*(void **)(a1 + 288));
  free(*(void **)(a1 + 264));
  sub_1D0E3F438(a1 + 216);
  uint64_t v4 = *(void **)(a1 + 184);
  if (v4)
  {
    *(void *)(a1 + 192) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void ***)(a1 + 144);
  uint64_t v6 = *(void ***)(a1 + 152);
  *(void *)(a1 + 176) = 0;
  unint64_t v7 = (char *)v6 - (char *)v5;
  if ((unint64_t)((char *)v6 - (char *)v5) >= 0x11)
  {
    do
    {
      operator delete(*v5);
      uint64_t v6 = *(void ***)(a1 + 152);
      uint64_t v5 = (void **)(*(void *)(a1 + 144) + 8);
      *(void *)(a1 + 144) = v5;
      unint64_t v7 = (char *)v6 - (char *)v5;
    }
    while ((unint64_t)((char *)v6 - (char *)v5) > 0x10);
  }
  unint64_t v8 = v7 >> 3;
  if (v8 == 1)
  {
    uint64_t v9 = 56;
    goto LABEL_15;
  }
  if (v8 == 2)
  {
    uint64_t v9 = 113;
LABEL_15:
    *(void *)(a1 + 168) = v9;
  }
  if (v5 != v6)
  {
    do
    {
      uint64_t v10 = *v5++;
      operator delete(v10);
    }
    while (v5 != v6);
    uint64_t v12 = *(void *)(a1 + 144);
    uint64_t v11 = *(void *)(a1 + 152);
    if (v11 != v12) {
      *(void *)(a1 + 152) = v11 + ((v12 - v11 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  uint64_t v13 = *(void **)(a1 + 136);
  if (v13) {
    operator delete(v13);
  }
  unint64_t v14 = *(void ***)(a1 + 72);
  unint64_t v15 = *(void ***)(a1 + 80);
  *(void *)(a1 + 104) = 0;
  unint64_t v16 = (char *)v15 - (char *)v14;
  if ((unint64_t)((char *)v15 - (char *)v14) >= 0x11)
  {
    do
    {
      operator delete(*v14);
      unint64_t v15 = *(void ***)(a1 + 80);
      unint64_t v14 = (void **)(*(void *)(a1 + 72) + 8);
      *(void *)(a1 + 72) = v14;
      unint64_t v16 = (char *)v15 - (char *)v14;
    }
    while ((unint64_t)((char *)v15 - (char *)v14) > 0x10);
  }
  unint64_t v17 = v16 >> 3;
  if (v17 == 1)
  {
    uint64_t v18 = 512;
    goto LABEL_28;
  }
  if (v17 == 2)
  {
    uint64_t v18 = 1024;
LABEL_28:
    *(void *)(a1 + 96) = v18;
  }
  if (v14 != v15)
  {
    do
    {
      BOOL v19 = *v14++;
      operator delete(v19);
    }
    while (v14 != v15);
    uint64_t v21 = *(void *)(a1 + 72);
    uint64_t v20 = *(void *)(a1 + 80);
    if (v20 != v21) {
      *(void *)(a1 + 80) = v20 + ((v21 - v20 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  uint64_t v22 = *(void **)(a1 + 64);
  if (v22) {
    operator delete(v22);
  }
  uint64_t v23 = *(void ***)(a1 + 16);
  uint64_t v24 = *(void ***)(a1 + 24);
  *(void *)(a1 + 48) = 0;
  unint64_t v25 = (char *)v24 - (char *)v23;
  if ((unint64_t)((char *)v24 - (char *)v23) >= 0x11)
  {
    do
    {
      operator delete(*v23);
      uint64_t v24 = *(void ***)(a1 + 24);
      uint64_t v23 = (void **)(*(void *)(a1 + 16) + 8);
      *(void *)(a1 + 16) = v23;
      unint64_t v25 = (char *)v24 - (char *)v23;
    }
    while ((unint64_t)((char *)v24 - (char *)v23) > 0x10);
  }
  unint64_t v26 = v25 >> 3;
  if (v26 == 1)
  {
    uint64_t v27 = 128;
    goto LABEL_41;
  }
  if (v26 == 2)
  {
    uint64_t v27 = 256;
LABEL_41:
    *(void *)(a1 + 40) = v27;
  }
  if (v23 != v24)
  {
    do
    {
      uint64_t v28 = *v23++;
      operator delete(v28);
    }
    while (v23 != v24);
    uint64_t v30 = *(void *)(a1 + 16);
    uint64_t v29 = *(void *)(a1 + 24);
    if (v29 != v30) {
      *(void *)(a1 + 24) = v29 + ((v30 - v29 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  uint64_t v31 = *(void **)(a1 + 8);
  if (v31) {
    operator delete(v31);
  }
  return a1;
}

void sub_1D0E3F1C8(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  float v3 = (void **)a1[2];
  if (v3 != v2)
  {
    uint64_t v4 = a1 + 5;
    unint64_t v5 = a1[4];
    uint64_t v6 = &v2[v5 >> 7];
    uint64_t v7 = (uint64_t)*v6 + 32 * (v5 & 0x7F);
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * ((a1[5] + v5) & 0x7F);
    if (v7 == v8) {
      goto LABEL_15;
    }
    while (1)
    {
      uint64_t v9 = *(std::__shared_weak_count **)(v7 + 24);
      if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
        uint64_t v10 = *(std::__shared_weak_count **)(v7 + 8);
        if (v10)
        {
LABEL_8:
          if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
          }
        }
      }
      else
      {
        uint64_t v10 = *(std::__shared_weak_count **)(v7 + 8);
        if (v10) {
          goto LABEL_8;
        }
      }
      v7 += 32;
      if (v7 - (void)*v6 == 4096)
      {
        uint64_t v11 = (uint64_t)v6[1];
        ++v6;
        uint64_t v7 = v11;
      }
      if (v7 == v8)
      {
        uint64_t v2 = (void **)a1[1];
        float v3 = (void **)a1[2];
        goto LABEL_15;
      }
    }
  }
  uint64_t v4 = a1 + 5;
  float v3 = (void **)a1[1];
LABEL_15:
  void *v4 = 0;
  unint64_t v12 = (char *)v3 - (char *)v2;
  if (v12 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v13 = a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v12 = v13 - (void)v2;
    }
    while (v12 > 0x10);
  }
  if (v12 >> 3 == 1)
  {
    uint64_t v14 = 64;
  }
  else
  {
    if (v12 >> 3 != 2) {
      return;
    }
    uint64_t v14 = 128;
  }
  a1[4] = v14;
}

uint64_t sub_1D0E3F370(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  float v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      float v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 512;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 1024;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1D0E3F438(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  float v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      float v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 170;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 341;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1D0E3F500(uint64_t *a1)
{
  ++dword_1EA643850;
  uint64_t v2 = *a1;
  *(_DWORD *)uint64_t v2 = dword_1EA643850;
  float v3 = *(std::__shared_weak_count **)(v2 + 16);
  *(void *)(v2 + 8) = 0;
  *(void *)(v2 + 16) = 0;
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = *a1;
  unint64_t v5 = *(std::__shared_weak_count **)(*a1 + 32);
  *(void *)(v4 + 24) = 0;
  *(void *)(v4 + 32) = 0;
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = *a1;
  *(void *)(v6 + 40) = 0;
  *(void *)(v6 + 48) = 0;
  *(unsigned char *)(v6 + 64) = 0;
  *(void *)(v6 + 56) = 0;
  *(unsigned char *)(v6 + 68) = 0;
  *(unsigned char *)(v6 + 72) = 0;
  *(void *)(v6 + 80) = 0;
  sub_1D0E3F1C8((void *)(*a1 + 88));
  uint64_t result = *(void *)(*a1 + 152);
  *(void *)(*a1 + 152) = 0;
  if (result)
  {
    uint64_t v8 = sub_1D0E3EEE4(result);
    uint64_t result = MEMORY[0x1D25F16B0](v8, 0x10E0C4016A603E8);
  }
  if (*(unsigned char *)(*a1 + 164)) {
    *(unsigned char *)(*a1 + 164) = 0;
  }
  return result;
}

void sub_1D0E3F638(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[14];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    float v3 = (std::__shared_weak_count *)a1[12];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    float v3 = (std::__shared_weak_count *)a1[12];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = (std::__shared_weak_count *)a1[10];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    unint64_t v5 = (void *)a1[8];
    if (!v5) {
      return;
    }
  }
  else
  {
    unint64_t v5 = (void *)a1[8];
    if (!v5) {
      return;
    }
  }
  free(v5);
  a1[8] = 0;
}

void sub_1D0E3F758(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4C28;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E3F7AC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4C28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0E3F7D0(uint64_t a1)
{
  std::mutex::~mutex((std::mutex *)(a1 + 1088));
  free(*(void **)(a1 + 1064));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 1056);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 976));
  std::mutex::~mutex((std::mutex *)(a1 + 912));
  free(*(void **)(a1 + 824));
  free(*(void **)(a1 + 800));
  free(*(void **)(a1 + 776));
  float v3 = *(std::__shared_weak_count **)(a1 + 768);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  free(*(void **)(a1 + 680));
  free(*(void **)(a1 + 656));
  free(*(void **)(a1 + 632));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 624);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  free(*(void **)(a1 + 536));
  free(*(void **)(a1 + 512));
  free(*(void **)(a1 + 488));
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 480);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  free(*(void **)(a1 + 392));
  free(*(void **)(a1 + 368));
  free(*(void **)(a1 + 344));
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 336);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 264));
  free(*(void **)(a1 + 240));
  free(*(void **)(a1 + 152));
  uint64_t v7 = *(void **)(a1 + 136);
  if (v7)
  {
    free(v7);
    *(void *)(a1 + 136) = 0;
  }
  uint64_t v8 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 32));
}

void sub_1D0E3FA44(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4D40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E3FA98(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4D40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0E3FAB8(float32x2_t *a1, uint64_t a2, float32x2_t *a3)
{
  uint64_t v4 = a1;
  if (*(int *)a2 <= 1)
  {
    *a1 = *a3;
    a1[1].i32[0] = a3[1].i32[0];
    return;
  }
  unint64_t v6 = *(void *)(a2 + 40);
  if (!v6)
  {
    uint64_t v7 = *(uint64_t **)(a2 + 16);
    uint64_t v8 = *(uint64_t **)(a2 + 24);
    unint64_t v9 = v8 - v7;
    uint64_t v10 = 341 * v9 - 1;
    if (v8 == v7) {
      uint64_t v10 = 0;
    }
    if ((unint64_t)(v10 - *(void *)(a2 + 48)) >= 0x155)
    {
      *(void *)(a2 + 40) = 341;
      int v81 = (void *)*(v8 - 1);
      *(void *)(a2 + 24) = v8 - 1;
      sub_1D0E3EA48((void **)(a2 + 8), &v81);
LABEL_55:
      unint64_t v6 = *(void *)(a2 + 40);
      goto LABEL_56;
    }
    uint64_t v11 = *(char **)(a2 + 32);
    unint64_t v12 = *(char **)(a2 + 8);
    if (v9 < (v11 - v12) >> 3)
    {
      if (v7 == (uint64_t *)v12)
      {
        int v81 = operator new(0xFFCuLL);
        sub_1D0E3EBF0((char **)(a2 + 8), &v81);
        uint64_t v17 = *(void *)(a2 + 24);
        int v81 = *(void **)(v17 - 8);
        *(void *)(a2 + 24) = v17 - 8;
      }
      else
      {
        int v81 = operator new(0xFFCuLL);
      }
      sub_1D0E3EA48((void **)(a2 + 8), &v81);
      if (*(void *)(a2 + 24) - *(void *)(a2 + 16) == 8) {
        *(void *)(a2 + 40) = 170;
      }
      else {
        *(void *)(a2 + 40) += 341;
      }
      goto LABEL_55;
    }
    if (v11 == v12) {
      unint64_t v13 = 1;
    }
    else {
      unint64_t v13 = (v11 - v12) >> 2;
    }
    if (v13 >> 61) {
LABEL_81:
    }
      sub_1D0DE8CE0();
    uint64_t v14 = (char *)operator new(8 * v13);
    unint64_t v15 = operator new(0xFFCuLL);
    if (v13)
    {
      unint64_t v16 = &v14[8 * v13];
    }
    else
    {
      uint64_t v18 = (char *)operator new(8uLL);
      unint64_t v16 = v18 + 8;
      operator delete(v14);
      uint64_t v7 = *(uint64_t **)(a2 + 16);
      uint64_t v8 = *(uint64_t **)(a2 + 24);
      uint64_t v14 = v18;
    }
    uint64_t v79 = v4;
    *(void *)uint64_t v14 = v15;
    BOOL v19 = v14 + 8;
    uint64_t v20 = v14;
    if (v7 == v8)
    {
      uint64_t v21 = v14;
      uint64_t v22 = v14 + 8;
LABEL_24:
      uint64_t v23 = *(void **)(a2 + 8);
      *(void *)(a2 + 8) = v20;
      *(void *)(a2 + 16) = v21;
      *(void *)(a2 + 24) = v22;
      *(void *)(a2 + 32) = v16;
      if (v22 - v21 == 8) {
        uint64_t v24 = 170;
      }
      else {
        uint64_t v24 = *(void *)(a2 + 40) + 341;
      }
      uint64_t v4 = v79;
      *(void *)(a2 + 40) = v24;
      if (v23) {
        operator delete(v23);
      }
      goto LABEL_55;
    }
    while (1)
    {
      if (v19 == v16)
      {
        if (v14 <= v20)
        {
          unint64_t v33 = (v19 - v20) >> 2;
          if (v19 == v20) {
            unint64_t v33 = 1;
          }
          if (v33 >> 61) {
            goto LABEL_81;
          }
          uint64_t v34 = v20;
          unint64_t v35 = v33 >> 2;
          uint64_t v80 = 8 * v33;
          uint64_t v36 = (char *)operator new(8 * v33);
          float v37 = v36;
          uint64_t v21 = &v36[8 * v35];
          unint64_t v25 = v21;
          int64_t v38 = v19 - v14;
          if (v19 != v14)
          {
            unint64_t v25 = &v21[v38 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v39 = v38 - 8;
            if (v39 >= 0x38)
            {
              if ((unint64_t)(&v36[8 * v35] - v14) < 0x20)
              {
                unint64_t v40 = &v36[8 * v35];
                goto LABEL_48;
              }
              uint64_t v41 = (v39 >> 3) + 1;
              uint64_t v42 = 8 * (v41 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v40 = &v21[v42];
              float v43 = (long long *)(v14 + 16);
              float v44 = &v36[8 * v35 + 16];
              uint64_t v45 = v41 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v46 = *v43;
                *((_OWORD *)v44 - 1) = *(v43 - 1);
                *(_OWORD *)float v44 = v46;
                v43 += 2;
                v44 += 32;
                v45 -= 4;
              }
              while (v45);
              if (v41 != (v41 & 0x3FFFFFFFFFFFFFFCLL))
              {
                v14 += v42;
                goto LABEL_48;
              }
            }
            else
            {
              unint64_t v40 = &v36[8 * v35];
              do
              {
LABEL_48:
                uint64_t v47 = *(void *)v14;
                v14 += 8;
                *(void *)unint64_t v40 = v47;
                v40 += 8;
              }
              while (v40 != v25);
            }
          }
          BOOL v19 = &v36[v80];
          if (v34) {
            operator delete(v34);
          }
          uint64_t v20 = v37;
          goto LABEL_27;
        }
        uint64_t v27 = (v14 - v20) >> 3;
        if (v27 >= -1) {
          uint64_t v28 = v27 + 1;
        }
        else {
          uint64_t v28 = v27 + 2;
        }
        uint64_t v29 = v28 >> 1;
        uint64_t v30 = &v14[-8 * (v28 >> 1)];
        uint64_t v31 = v19;
        if (v19 != v14)
        {
          BOOL v32 = v20;
          memmove(v30, v14, v19 - v14);
          uint64_t v20 = v32;
          uint64_t v31 = v14;
        }
        unint64_t v25 = &v30[v19 - v14];
        uint64_t v21 = &v31[-8 * v29];
      }
      else
      {
        uint64_t v21 = v14;
        unint64_t v25 = v19;
        BOOL v19 = v16;
      }
LABEL_27:
      unint64_t v16 = v19;
      uint64_t v26 = *v7++;
      *(void *)unint64_t v25 = v26;
      uint64_t v22 = v25 + 8;
      BOOL v19 = v22;
      uint64_t v14 = v21;
      if (v7 == *(uint64_t **)(a2 + 24)) {
        goto LABEL_24;
      }
    }
  }
LABEL_56:
  uint64_t v48 = *(void *)(a2 + 16);
  uint64_t v49 = (void *)(v48 + 8 * (v6 / 0x155));
  uint64_t v50 = *v49 + 12 * (v6 % 0x155);
  if (*(void *)(a2 + 24) == v48) {
    uint64_t v50 = 0;
  }
  if (v50 == *v49) {
    uint64_t v50 = *(v49 - 1) + 4092;
  }
  float32x2_t v51 = *a3;
  *(_DWORD *)(v50 - 4) = a3[1].i32[0];
  *(float32x2_t *)(v50 - 12) = v51;
  unint64_t v53 = *(void *)(a2 + 40);
  uint64_t v52 = *(void *)(a2 + 48);
  uint64_t v54 = v52 + 1;
  *(void *)(a2 + 40) = v53 - 1;
  *(void *)(a2 + 48) = v52 + 1;
  float v55 = 0.0;
  float v56 = 0.0;
  if ((int)v52 + 1 >= 1)
  {
    uint64_t v57 = (v52 + 1);
    uint64_t v58 = 12 * v53;
    unint64_t v59 = v53 - 1;
    do
    {
      unint64_t v60 = *(void *)(*(void *)(a2 + 16) + 8 * (v59 / 0x155)) + v58 - 4092 * (v59 / 0x155);
      float32x2_t v61 = vsub_f32(*(float32x2_t *)(v60 - 12), *a3);
      float v62 = sqrtf(vaddv_f32(vmul_f32(v61, v61))+ (float)((float)(*(float *)(v60 - 4) - a3[1].f32[0]) * (float)(*(float *)(v60 - 4) - a3[1].f32[0])));
      if (v56 < v62) {
        float v56 = v62;
      }
      v58 += 12;
      ++v59;
      --v57;
    }
    while (v57);
  }
  float v63 = expf(-fminf(v56 * *(float *)(a2 + 4), 10.0));
  if ((int)v54 >= 1)
  {
    float v64 = 1.0;
    float v55 = 0.0;
    int v65 = v54;
    do
    {
      float v55 = v64 + v55;
      float v64 = v63 * v64;
      --v65;
    }
    while (v65);
  }
  uint64_t v66 = *(void *)(a2 + 16);
  float v67 = 1.0 / v55;
  int v68 = (float32x2_t *)(*(void *)(v66 + 8 * ((v53 - 1) / 0x155)) + 12 * ((v53 - 1) % 0x155));
  float32x2_t v69 = vmul_n_f32(*v68, 1.0 / v55);
  float32x2_t *v4 = v69;
  float v70 = (float)(1.0 / v55) * v68[1].f32[0];
  v4[1].f32[0] = v70;
  if ((int)v54 > 1)
  {
    uint64_t v71 = 12 * v53;
    uint64_t v72 = v54 - 1;
    do
    {
      float v67 = v63 * v67;
      int32x4_t v73 = (float32x2_t *)(*(void *)(v66 + 8 * (v53 / 0x155)) + v71 - 4092 * (v53 / 0x155));
      float32x2_t v69 = vadd_f32(vmul_n_f32(*v73, v67), v69);
      float v70 = (float)(v67 * v73[1].f32[0]) + v70;
      v71 += 12;
      ++v53;
      --v72;
    }
    while (v72);
    float32x2_t *v4 = v69;
    v4[1].f32[0] = v70;
  }
  int v74 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 <= (int)v54)
  {
    uint64_t v75 = *(void *)(a2 + 24);
    do
    {
      uint64_t v76 = *(void *)(a2 + 40);
      if (v75 == *(void *)(a2 + 16)) {
        uint64_t v77 = 0;
      }
      else {
        uint64_t v77 = 341 * ((v75 - *(void *)(a2 + 16)) >> 3) - 1;
      }
      uint64_t v78 = v54 - 1;
      *(void *)(a2 + 48) = v54 - 1;
      if ((unint64_t)(v77 - (v54 + v76) + 1) >= 0x2AA)
      {
        operator delete(*(void **)(v75 - 8));
        uint64_t v75 = *(void *)(a2 + 24) - 8;
        *(void *)(a2 + 24) = v75;
        uint64_t v78 = *(void *)(a2 + 48);
        int v74 = *(_DWORD *)a2;
      }
      uint64_t v54 = v78;
    }
    while (v74 <= (int)v78);
  }
}

void sub_1D0E400DC(float *__sz, uint64_t a2, float *a3)
{
  uint64_t v4 = __sz;
  if (*(int *)a2 <= 1)
  {
    *__sz = *a3;
    return;
  }
  unint64_t v6 = *(void *)(a2 + 40);
  if (!v6)
  {
    uint64_t v7 = *(char **)(a2 + 16);
    uint64_t v8 = *(char **)(a2 + 24);
    uint64_t v9 = ((v8 - v7) << 7) - 1;
    if (v8 == v7) {
      uint64_t v9 = 0;
    }
    if ((unint64_t)(v9 - *(void *)(a2 + 48)) >= 0x400)
    {
      *(void *)(a2 + 40) = 1024;
      uint64_t v72 = (void *)*((void *)v8 - 1);
      *(void *)(a2 + 24) = v8 - 8;
      sub_1D0E3EA48((void **)(a2 + 8), &v72);
LABEL_55:
      unint64_t v6 = *(void *)(a2 + 40);
      goto LABEL_56;
    }
    uint64_t v10 = *(char **)(a2 + 32);
    uint64_t v11 = *(char **)(a2 + 8);
    if (v8 - v7 < (unint64_t)(v10 - v11))
    {
      if (v7 == v11)
      {
        uint64_t v72 = operator new(0x1000uLL);
        sub_1D0E3EBF0((char **)(a2 + 8), &v72);
        uint64_t v16 = *(void *)(a2 + 24);
        uint64_t v72 = *(void **)(v16 - 8);
        *(void *)(a2 + 24) = v16 - 8;
      }
      else
      {
        uint64_t v72 = operator new(0x1000uLL);
      }
      sub_1D0E3EA48((void **)(a2 + 8), &v72);
      if (*(void *)(a2 + 24) - *(void *)(a2 + 16) == 8) {
        *(void *)(a2 + 40) = 512;
      }
      else {
        *(void *)(a2 + 40) += 1024;
      }
      goto LABEL_55;
    }
    if (v10 == v11) {
      unint64_t v12 = 1;
    }
    else {
      unint64_t v12 = (v10 - v11) >> 2;
    }
    if (v12 >> 61) {
LABEL_80:
    }
      sub_1D0DE8CE0();
    unint64_t v13 = (char *)operator new(8 * v12);
    uint64_t v14 = operator new(0x1000uLL);
    if (v12)
    {
      unint64_t v15 = &v13[8 * v12];
    }
    else
    {
      uint64_t v17 = (char *)operator new(8uLL);
      unint64_t v15 = v17 + 8;
      operator delete(v13);
      uint64_t v7 = *(char **)(a2 + 16);
      uint64_t v8 = *(char **)(a2 + 24);
      unint64_t v13 = v17;
    }
    *(void *)unint64_t v13 = v14;
    uint64_t v18 = v13 + 8;
    BOOL v19 = v13;
    if (v7 == v8)
    {
      uint64_t v20 = v13;
      uint64_t v21 = v13 + 8;
LABEL_24:
      uint64_t v22 = *(void **)(a2 + 8);
      *(void *)(a2 + 8) = v19;
      *(void *)(a2 + 16) = v20;
      *(void *)(a2 + 24) = v21;
      *(void *)(a2 + 32) = v15;
      if (v21 - v20 == 8) {
        uint64_t v23 = 512;
      }
      else {
        uint64_t v23 = *(void *)(a2 + 40) + 1024;
      }
      uint64_t v4 = __sz;
      *(void *)(a2 + 40) = v23;
      if (v22) {
        operator delete(v22);
      }
      goto LABEL_55;
    }
    while (1)
    {
      if (v18 == v15)
      {
        if (v13 <= v19)
        {
          unint64_t v31 = (v18 - v19) >> 2;
          if (v18 == v19) {
            unint64_t v31 = 1;
          }
          if (v31 >> 61) {
            goto LABEL_80;
          }
          unint64_t v32 = v31 >> 2;
          uint64_t v71 = 8 * v31;
          unint64_t v33 = (char *)operator new(8 * v31);
          uint64_t v34 = v33;
          uint64_t v20 = &v33[8 * v32];
          uint64_t v24 = v20;
          int64_t v35 = v18 - v13;
          if (v18 != v13)
          {
            uint64_t v24 = &v20[v35 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v36 = v35 - 8;
            if (v36 >= 0x38)
            {
              if ((unint64_t)(&v33[8 * v32] - v13) < 0x20)
              {
                float v37 = &v33[8 * v32];
                goto LABEL_48;
              }
              uint64_t v38 = (v36 >> 3) + 1;
              uint64_t v39 = 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
              float v37 = &v20[v39];
              unint64_t v40 = (long long *)(v13 + 16);
              uint64_t v41 = &v33[8 * v32 + 16];
              uint64_t v42 = v38 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v43 = *v40;
                *((_OWORD *)v41 - 1) = *(v40 - 1);
                *(_OWORD *)uint64_t v41 = v43;
                v40 += 2;
                v41 += 32;
                v42 -= 4;
              }
              while (v42);
              if (v38 != (v38 & 0x3FFFFFFFFFFFFFFCLL))
              {
                v13 += v39;
                goto LABEL_48;
              }
            }
            else
            {
              float v37 = &v33[8 * v32];
              do
              {
LABEL_48:
                uint64_t v44 = *(void *)v13;
                v13 += 8;
                *(void *)float v37 = v44;
                v37 += 8;
              }
              while (v37 != v24);
            }
          }
          uint64_t v18 = &v33[v71];
          if (v19) {
            operator delete(v19);
          }
          BOOL v19 = v34;
          goto LABEL_27;
        }
        uint64_t v26 = (v13 - v19) >> 3;
        if (v26 >= -1) {
          uint64_t v27 = v26 + 1;
        }
        else {
          uint64_t v27 = v26 + 2;
        }
        uint64_t v28 = v27 >> 1;
        uint64_t v29 = &v13[-8 * (v27 >> 1)];
        uint64_t v30 = v18;
        if (v18 != v13)
        {
          memmove(v29, v13, v18 - v13);
          uint64_t v30 = v13;
        }
        uint64_t v24 = &v29[v18 - v13];
        uint64_t v20 = &v30[-8 * v28];
      }
      else
      {
        uint64_t v20 = v13;
        uint64_t v24 = v18;
        uint64_t v18 = v15;
      }
LABEL_27:
      unint64_t v15 = v18;
      uint64_t v25 = *(void *)v7;
      v7 += 8;
      *(void *)uint64_t v24 = v25;
      uint64_t v21 = v24 + 8;
      uint64_t v18 = v21;
      unint64_t v13 = v20;
      if (v7 == *(char **)(a2 + 24)) {
        goto LABEL_24;
      }
    }
  }
LABEL_56:
  uint64_t v45 = *(void *)(a2 + 16);
  long long v46 = (void *)(v45 + 8 * (v6 >> 10));
  uint64_t v47 = *v46 + 4 * (v6 & 0x3FF);
  if (*(void *)(a2 + 24) == v45) {
    uint64_t v47 = 0;
  }
  if (v47 == *v46) {
    uint64_t v47 = *(v46 - 1) + 4096;
  }
  *(float *)(v47 - 4) = *a3;
  unint64_t v49 = *(void *)(a2 + 40);
  uint64_t v48 = *(void *)(a2 + 48);
  uint64_t v50 = v48 + 1;
  *(void *)(a2 + 40) = v49 - 1;
  *(void *)(a2 + 48) = v48 + 1;
  float v51 = 0.0;
  float v52 = 0.0;
  if ((int)v48 + 1 >= 1)
  {
    uint64_t v53 = (v48 + 1);
    unint64_t v54 = v49 - 1;
    do
    {
      float v55 = *(float *)(*(void *)(*(void *)(a2 + 16) + ((v54 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v54 & 0x3FF)) - *a3;
      float v56 = sqrtf(v55 * v55);
      if (v52 < v56) {
        float v52 = v56;
      }
      ++v54;
      --v53;
    }
    while (v53);
  }
  float v57 = expf(-fminf(v52 * *(float *)(a2 + 4), 10.0));
  if ((int)v50 >= 1)
  {
    float v58 = 1.0;
    float v51 = 0.0;
    int v59 = v50;
    do
    {
      float v51 = v58 + v51;
      float v58 = v57 * v58;
      --v59;
    }
    while (v59);
  }
  float v60 = 1.0 / v51;
  uint64_t v61 = *(void *)(a2 + 16);
  float v62 = (float)(1.0 / v51)
      * *(float *)(*(void *)(v61 + (((v49 - 1) >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * ((v49 - 1) & 0x3FF));
  float *v4 = v62;
  if ((int)v50 > 1)
  {
    uint64_t v63 = v50 - 1;
    do
    {
      float v60 = v57 * v60;
      float v62 = (float)(v60 * *(float *)(*(void *)(v61 + ((v49 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v49 & 0x3FF))) + v62;
      ++v49;
      --v63;
    }
    while (v63);
    float *v4 = v62;
  }
  int v64 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 <= (int)v50)
  {
    uint64_t v65 = *(void *)(a2 + 24);
    do
    {
      uint64_t v66 = *(void *)(a2 + 16);
      uint64_t v67 = ((v65 - v66) << 7) - 1;
      uint64_t v68 = *(void *)(a2 + 40);
      if (v65 == v66) {
        uint64_t v67 = 0;
      }
      uint64_t v69 = v50 - 1;
      *(void *)(a2 + 48) = v50 - 1;
      if ((unint64_t)(v67 - (v50 + v68) + 1) >= 0x800)
      {
        operator delete(*(void **)(v65 - 8));
        uint64_t v65 = *(void *)(a2 + 24) - 8;
        *(void *)(a2 + 24) = v65;
        uint64_t v69 = *(void *)(a2 + 48);
        int v64 = *(_DWORD *)a2;
      }
      uint64_t v50 = v69;
    }
    while (v64 <= (int)v69);
  }
}

void sub_1D0E40618(uint64_t a1)
{
  free(*(void **)(a1 + 208));
  free(*(void **)(a1 + 184));
  uint64_t v2 = *(void **)(a1 + 160);
  free(v2);
}

void sub_1D0E4065C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4D78;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E406B0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4D78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

float *sub_1D0E406D0(float *result, float **a2)
{
  uint64_t v2 = result;
  float v3 = *a2;
  if (*a2 == result || (uint64_t v4 = a2[1], v4 == result))
  {
    uint64_t v5 = 0;
    uint64_t result = (float *)sub_1D0E406D0(&v5);
    *(void *)uint64_t v2 = v5;
  }
  else
  {
    *uint64_t result = (float)((float)((float)(*v3 * *v4) + 0.0) + (float)(v3[2] * v4[1])) + (float)(v3[4] * v4[2]);
    result[1] = (float)((float)((float)(v3[1] * *v4) + 0.0) + (float)(v3[3] * v4[1])) + (float)(v3[5] * v4[2]);
  }
  return result;
}

double sub_1D0E40774(uint64_t a1, uint64_t a2)
{
  float v3 = *(float **)a2;
  if (*(void *)a2 == a1
    || (v4 = *(void *)(a2 + 8), uint64_t v5 = *(float **)(v4 + 8), &v5[-*(unsigned int *)(v4 + 20)] == (float *)a1))
  {
    long long v10 = 0uLL;
    uint64_t v11 = 0;
    sub_1D0E40774(&v10);
    double result = *(double *)&v10;
    *(_OWORD *)a1 = v10;
    *(void *)(a1 + 16) = v11;
  }
  else
  {
    uint64_t v6 = *(unsigned int *)(v4 + 16);
    *(float *)a1 = (float)((float)(*v3 * *v5) + 0.0) + (float)(v3[2] * v5[1]);
    *(float *)(a1 + 4) = (float)((float)(v3[1] * *v5) + 0.0) + (float)(v3[3] * v5[1]);
    uint64_t v7 = &v5[v6];
    *(float *)(a1 + 8) = (float)((float)(*v3 * *v7) + 0.0) + (float)(v3[2] * v7[1]);
    *(float *)(a1 + 12) = (float)((float)(v3[1] * *v7) + 0.0) + (float)(v3[3] * v7[1]);
    uint64_t v8 = &v5[(2 * v6)];
    *(float *)(a1 + 16) = (float)((float)(*v3 * *v8) + 0.0) + (float)(v3[2] * v8[1]);
    *(float *)&double result = (float)((float)(v3[1] * *v8) + 0.0) + (float)(v3[3] * v8[1]);
    *(_DWORD *)(a1 + 20) = LODWORD(result);
  }
  return result;
}

float *sub_1D0E40888(float *result, uint64_t a2)
{
  uint64_t v2 = result;
  float v3 = *(float **)a2;
  if (*(float **)a2 == result
    || (v4 = *(void *)(a2 + 8), uint64_t v5 = *(float **)(v4 + 8), &v5[-*(unsigned int *)(v4 + 20)] == result))
  {
    uint64_t v6 = 0;
    double result = (float *)sub_1D0E40888(&v6);
    *(void *)uint64_t v2 = v6;
  }
  else
  {
    *double result = (float)((float)(*v3 * *v5) + 0.0) + (float)(v3[2] * v5[1]);
    result[1] = (float)((float)(v3[1] * *v5) + 0.0) + (float)(v3[3] * v5[1]);
  }
  return result;
}

uint64_t sub_1D0E40920(uint64_t a1, __CVBuffer *a2, void *a3)
{
  v120[1] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (void *)MEMORY[0x1D25F1DA0]();
  if (*a3 == a3[1])
  {
    unsigned int v99 = 1;
    goto LABEL_104;
  }
  context = v5;
  unsigned int Width = CVPixelBufferGetWidth(a2);
  unsigned int Height = CVPixelBufferGetHeight(a2);
  unint64_t v102 = objc_opt_new();
  uint64_t v8 = *a3;
  uint64_t v9 = a3[1];
  if (*a3 != v9)
  {
    __asm { FMOV            V1.2S, #1.0 }
    *(float32x2_t *)v15.f32 = vdiv_f32(_D1, vcvt_f32_s32(vmax_s32((int32x2_t)__PAIR64__(Height, Width), (int32x2_t)0x100000001)));
    v15.i64[1] = v15.i64[0];
    float32x4_t v103 = v15;
    do
    {
      long long v16 = *(_OWORD *)(*(void *)v8 + 52);
      if (*(unsigned char *)(*(void *)v8 + 72))
      {
        long long v105 = *(_OWORD *)(*(void *)v8 + 52);
        v15.f32[0] = *(float *)(*(void *)v8 + 68) / -57.296;
        uint64_t v17 = [NSNumber numberWithFloat:*(double *)v15.i64];
        long long v16 = v105;
      }
      else
      {
        uint64_t v17 = 0;
      }
      *(float32x2_t *)v18.f32 = vadd_f32(*(float32x2_t *)&v16, (float32x2_t)0x3F0000003F000000);
      v18.i64[1] = *((void *)&v16 + 1);
      float32x4_t v19 = vmulq_f32(v18, v103);
      uint64_t v20 = objc_msgSend(MEMORY[0x1E4F457F8], "faceObservationWithRequestRevision:boundingBox:roll:yaw:pitch:", 0, v17, 0, 0, v19.f32[0], (float)(1.0 - (float)(v19.f32[1] + v19.f32[3])), v19.f32[2], v19.f32[3]);
      if (v20) {
        [v102 addObject:v20];
      }

      v8 += 16;
    }
    while (v8 != v9);
  }
  uint64_t v106 = sub_1D0E41410(v102);
  id v21 = objc_alloc(MEMORY[0x1E4F45890]);
  int v98 = (void *)[v21 initWithCVPixelBuffer:a2 options:MEMORY[0x1E4F1CC08]];
  kdebug_trace();
  v120[0] = v106;
  uint64_t v22 = [MEMORY[0x1E4F1C978] arrayWithObjects:v120 count:1];
  BOOL v104 = a3;
  id v119 = 0;
  char v23 = [v98 performRequests:v22 error:&v119];
  id v100 = v119;

  kdebug_trace();
  if (v23)
  {
    uint64_t v24 = [v106 results];
    int v25 = [v24 count];

    if (v25 == ((a3[1] - *a3) >> 4))
    {
      unsigned int v99 = 1;
      if (v25 < 1) {
        goto LABEL_103;
      }
      uint64_t v26 = 0;
      while (1)
      {
        uint64_t v27 = [v106 results];
        uint64_t v28 = [v27 objectAtIndexedSubscript:v26];

        uint64_t v29 = [v28 faceprint];
        BOOL v30 = v29 == 0;

        if (!v30) {
          break;
        }
LABEL_40:

        if (++v26 == v25)
        {
          unsigned int v99 = 1;
          goto LABEL_103;
        }
      }
      id v31 = [v28 faceprint];
      unint64_t v32 = [v31 descriptorData];
      unint64_t v33 = v32;
      if (!v32)
      {
        unint64_t v40 = 0;
        size_t v43 = 0;
        LODWORD(v39) = 0;
        goto LABEL_37;
      }
      unint64_t v101 = v28;
      int v34 = [v32 length];
      int64_t v35 = (int *)[v33 bytes];
      unint64_t v36 = v34;
      uint64_t v37 = ((unint64_t)v34 >> 2);
      size_t v38 = (4 * v37 + 31) & 0x7FFFFFFE0;
      memptr[0] = 0;
      malloc_type_posix_memalign(memptr, 0x20uLL, v38, 0x49090899uLL);
      unint64_t v39 = v36 >> 2;
      unint64_t v40 = (char *)memptr[0];
      if (v35 != memptr[0])
      {
        if (v39)
        {
          uint64_t v41 = v37;
          unint64_t v42 = (v37 - 1) & 0x3FFFFFFFFFFFFFFFLL;
          size_t v43 = v38 >> 2;
          if (v42 < 7)
          {
            uint64_t v44 = (char *)memptr[0];
            uint64_t v28 = v101;
          }
          else
          {
            uint64_t v44 = (char *)memptr[0];
            uint64_t v28 = v101;
            if ((void *)((char *)memptr[0] - (char *)v35) >= (void *)0x20)
            {
              uint64_t v45 = 0;
              uint64_t v46 = (v42 + 1) & 0x7FFFFFFFFFFFFFF8;
              uint64_t v47 = v46;
              do
              {
                uint64_t v48 = &v40[v45 * 4];
                long long v49 = *(_OWORD *)&v35[v45 + 4];
                *(_OWORD *)uint64_t v48 = *(_OWORD *)&v35[v45];
                *((_OWORD *)v48 + 1) = v49;
                v45 += 8;
                v47 -= 8;
              }
              while (v47);
              if (v42 + 1 == v46) {
                goto LABEL_37;
              }
              uint64_t v44 = &v40[4 * v46];
              v35 += v46;
            }
          }
          do
          {
            int v60 = *v35++;
            *(_DWORD *)uint64_t v44 = v60;
            v44 += 4;
          }
          while (v44 != &v40[4 * v41]);
        }
        else
        {
          size_t v43 = v38 >> 2;
          uint64_t v28 = v101;
        }
LABEL_37:

        uint64_t v61 = *(void *)(*v104 + 16 * v26);
        float v62 = *(void **)(v61 + 96);
        *(void *)(v61 + 96) = v40;
        *(void *)(v61 + 104) = v43;
        *(_DWORD *)(v61 + 112) = v39;
        free(v62);

        uint64_t v63 = *(void *)(*v104 + 16 * v26);
        *(_DWORD *)(v63 + 120) = 1;
        if (*(char *)(v63 + 151) < 0)
        {
          **(unsigned char **)(v63 + 128) = 0;
          *(void *)(v63 + 136) = 0;
        }
        else
        {
          *(unsigned char *)(v63 + 128) = 0;
          *(unsigned char *)(v63 + 151) = 0;
        }
        goto LABEL_40;
      }
      memptr[0] = 0;
      malloc_type_posix_memalign(memptr, 0x20uLL, v38, 0x49090899uLL);
      unint64_t v40 = (char *)memptr[0];
      size_t v43 = v38 >> 2;
      uint64_t v50 = v37;
      uint64_t v28 = v101;
      if (v39)
      {
        unint64_t v51 = (v50 - 1) & 0x3FFFFFFFFFFFFFFFLL;
        float v52 = v35;
        uint64_t v53 = (char *)memptr[0];
        if (v51 >= 7)
        {
          float v52 = v35;
          uint64_t v53 = (char *)memptr[0];
          if ((void *)((char *)memptr[0] - (char *)v35) >= (void *)0x20)
          {
            uint64_t v54 = (v51 + 1) & 0x7FFFFFFFFFFFFFF8;
            float v52 = &v35[v54];
            float v55 = (char *)memptr[0] + 16;
            float v56 = (long long *)(v35 + 4);
            uint64_t v57 = v54;
            do
            {
              long long v58 = *v56;
              *(v55 - 1) = *(v56 - 1);
              *float v55 = v58;
              v55 += 2;
              v56 += 2;
              v57 -= 8;
            }
            while (v57);
            if (v51 + 1 == v54) {
              goto LABEL_33;
            }
            uint64_t v53 = &v40[4 * v54];
          }
        }
        do
        {
          int v59 = *v52++;
          *(_DWORD *)uint64_t v53 = v59;
          v53 += 4;
        }
        while (v53 != &v40[4 * v50]);
      }
LABEL_33:
      free(v35);
      goto LABEL_37;
    }
    sub_1D0E24E70((uint64_t)memptr);
    sub_1D0E25008(memptr, (uint64_t)"Not enough faceprintRequest results ", 36);
    uint64_t v69 = (void *)std::ostream::operator<<();
    sub_1D0E25008(v69, (uint64_t)" != ", 4);
    std::ostream::operator<<();
    if ((v117 & 0x10) != 0)
    {
      unint64_t v83 = v116;
      if (v116 < v113)
      {
        unint64_t v116 = v113;
        unint64_t v83 = v113;
      }
      int v84 = (const void **)&v112;
    }
    else
    {
      if ((v117 & 8) == 0)
      {
        size_t v70 = 0;
        HIBYTE(v108) = 0;
        p_dst = &__dst;
        goto LABEL_83;
      }
      int v84 = (const void **)v111;
      unint64_t v83 = v111[2];
    }
    uint64_t v85 = *v84;
    size_t v70 = v83 - (void)*v84;
    if (v70 > 0x7FFFFFFFFFFFFFF7) {
      abort();
    }
    if (v70 >= 0x17)
    {
      uint64_t v86 = (v70 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v70 | 7) != 0x17) {
        uint64_t v86 = v70 | 7;
      }
      uint64_t v87 = v86 + 1;
      p_dst = (long long *)operator new(v86 + 1);
      *((void *)&__dst + 1) = v70;
      int64_t v108 = v87 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v108) = v83 - *(unsigned char *)v84;
      p_dst = &__dst;
      if (!v70) {
        goto LABEL_83;
      }
    }
    memmove(p_dst, v85, v70);
LABEL_83:
    *((unsigned char *)p_dst + v70) = 0;
    int32x4_t v88 = (uint64_t *)*a3;
    int v89 = (uint64_t *)a3[1];
    if ((uint64_t *)*a3 == v89)
    {
      LOBYTE(v90) = HIBYTE(v108);
    }
    else
    {
      int v90 = SHIBYTE(v108);
      long long v91 = __dst;
      if (v108 >= 0) {
        uint64_t v92 = &__dst;
      }
      else {
        uint64_t v92 = (long long *)__dst;
      }
      if (v108 >= 0) {
        size_t v93 = HIBYTE(v108);
      }
      else {
        size_t v93 = *((void *)&__dst + 1);
      }
      do
      {
        uint64_t v94 = *v88;
        *(_DWORD *)(v94 + 120) = 0;
        int v95 = (void **)(v94 + 128);
        if (*(char *)(v94 + 151) < 0)
        {
          sub_1D0DF92F0(v95, v92, v93);
        }
        else if (v90 < 0)
        {
          sub_1D0DF922C(v95, (void *)v91, *((size_t *)&v91 + 1));
        }
        else
        {
          *(_OWORD *)int v95 = __dst;
          *(void *)(v94 + 144) = v108;
        }
        v88 += 2;
      }
      while (v88 != v89);
    }
    if ((v90 & 0x80) != 0) {
      operator delete((void *)__dst);
    }
    memptr[0] = *(void **)MEMORY[0x1E4FBA418];
    *(void **)((char *)memptr + *((void *)memptr[0] - 3)) = *(void **)(MEMORY[0x1E4FBA418] + 24);
    memptr[1] = (void *)(MEMORY[0x1E4FBA470] + 16);
    if (v115 < 0) {
      operator delete(__p);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    MEMORY[0x1D25F1640](&v118);
    goto LABEL_102;
  }
  id v64 = [v100 description];
  uint64_t v65 = (const char *)[v64 UTF8String];
  size_t v66 = strlen(v65);
  if (v66 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  uint64_t v67 = (void *)v66;
  if (v66 >= 0x17)
  {
    uint64_t v72 = (v66 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v66 | 7) != 0x17) {
      uint64_t v72 = v66 | 7;
    }
    uint64_t v73 = v72 + 1;
    uint64_t v68 = operator new(v72 + 1);
    memptr[1] = v67;
    int64_t v110 = v73 | 0x8000000000000000;
    memptr[0] = v68;
  }
  else
  {
    HIBYTE(v110) = v66;
    uint64_t v68 = memptr;
    if (!v66) {
      goto LABEL_54;
    }
  }
  memmove(v68, v65, (size_t)v67);
LABEL_54:
  *((unsigned char *)v67 + (void)v68) = 0;
  int v74 = (uint64_t *)*a3;
  uint64_t v75 = (uint64_t *)a3[1];
  if ((uint64_t *)*a3 == v75)
  {
    LOBYTE(v76) = HIBYTE(v110);
  }
  else
  {
    int v76 = SHIBYTE(v110);
    uint64_t v77 = memptr[0];
    uint64_t v78 = memptr[1];
    if (v110 >= 0) {
      uint64_t v79 = memptr;
    }
    else {
      uint64_t v79 = (void **)memptr[0];
    }
    if (v110 >= 0) {
      size_t v80 = HIBYTE(v110);
    }
    else {
      size_t v80 = (size_t)memptr[1];
    }
    do
    {
      uint64_t v81 = *v74;
      *(_DWORD *)(v81 + 120) = 0;
      int v82 = (void **)(v81 + 128);
      if (*(char *)(v81 + 151) < 0)
      {
        sub_1D0DF92F0(v82, v79, v80);
      }
      else if (v76 < 0)
      {
        sub_1D0DF922C(v82, v77, (size_t)v78);
      }
      else
      {
        *(_OWORD *)int v82 = *(_OWORD *)memptr;
        *(void *)(v81 + 144) = v110;
      }
      v74 += 2;
    }
    while (v74 != v75);
  }
  if ((v76 & 0x80) != 0) {
    operator delete(memptr[0]);
  }

LABEL_102:
  unsigned int v99 = 0;
LABEL_103:

  uint64_t v5 = context;
LABEL_104:
  return v99;
}

void sub_1D0E412B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

id sub_1D0E41410(void *a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = objc_opt_new();
  id v10 = 0;
  char v3 = [v2 setRevision:3737841665 error:&v10];
  id v4 = v10;
  if ((v3 & 1) == 0)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    uint64_t v5 = (id)qword_1EB9F1620;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      id v8 = [v4 description];
      uint64_t v9 = [v8 UTF8String];
      *(_DWORD *)int buf = 136315138;
      uint64_t v12 = v9;
      _os_log_error_impl(&dword_1D0DBD000, v5, OS_LOG_TYPE_ERROR, "Unable to set private faceprint revision (%s).", buf, 0xCu);
    }
  }

  [v2 setInputFaceObservations:v1];
  [v2 setDetectionLevel:2];
  uint64_t v6 = [MEMORY[0x1E4F458E8] defaultANEDevice];
  [v2 setProcessingDevice:v6];

  return v2;
}

void sub_1D0E415C4(_Unwind_Exception *a1)
{
  uint64_t v6 = v5;

  _Unwind_Resume(a1);
}

uint64_t sub_1D0E41618(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA418];
  uint64_t v3 = *MEMORY[0x1E4FBA418];
  *(void *)a1 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1D25F1640](a1 + 112);
  return a1;
}

uint64_t sub_1D0E4171C()
{
  v14[1] = *MEMORY[0x1E4F143B8];
  int v0 = (void *)MEMORY[0x1D25F1DA0]();
  CVPixelBufferRef pixelBufferOut = 0;
  if (CVPixelBufferCreate(0, 0x80uLL, 0x80uLL, 0x4C303038u, 0, &pixelBufferOut))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1610))
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
    }
    id v1 = (id)qword_1EB9F1620;
    if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1D0DBD000, v1, OS_LOG_TYPE_INFO, "Recognition initialization failure: unable to create pixel buffer", buf, 2u);
    }
    uint64_t v2 = 0;
  }
  else
  {
    id v3 = objc_alloc(MEMORY[0x1E4F45890]);
    id v1 = [v3 initWithCVPixelBuffer:pixelBufferOut options:MEMORY[0x1E4F1CC08]];
    id v4 = objc_msgSend(MEMORY[0x1E4F457F8], "faceObservationWithRequestRevision:boundingBox:roll:yaw:pitch:", 0, 0, 0, 0, 0.0, 0.0, 1.0, 1.0);
    v14[0] = v4;
    uint64_t v5 = [MEMORY[0x1E4F1C978] arrayWithObjects:v14 count:1];
    uint64_t v6 = sub_1D0E41410(v5);

    uint64_t v13 = v6;
    uint64_t v7 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v13 count:1];
    id v10 = 0;
    uint64_t v2 = [v1 performRequests:v7 error:&v10];
    id v8 = v10;

    CVPixelBufferRelease(pixelBufferOut);
  }

  return v2;
}

void sub_1D0E41938(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1D0E41984@<X0>(unsigned char *a1@<X8>)
{
  sub_1D0E24E70((uint64_t)v10);
  sub_1D0E25008(v10, (uint64_t)"Vision:", 7);
  std::ostream::operator<<();
  if ((v17 & 0x10) != 0)
  {
    unint64_t v3 = v16;
    if (v16 < v13)
    {
      unint64_t v16 = v13;
      unint64_t v3 = v13;
    }
    id v4 = (const void **)&v12;
  }
  else
  {
    if ((v17 & 8) == 0)
    {
      size_t v2 = 0;
      a1[23] = 0;
      goto LABEL_16;
    }
    id v4 = (const void **)v11;
    unint64_t v3 = v11[2];
  }
  uint64_t v5 = *v4;
  size_t v2 = v3 - (void)*v4;
  if (v2 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v2 >= 0x17)
  {
    uint64_t v6 = (v2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v2 | 7) != 0x17) {
      uint64_t v6 = v2 | 7;
    }
    uint64_t v7 = v6 + 1;
    id v8 = operator new(v6 + 1);
    *((void *)a1 + 1) = v2;
    *((void *)a1 + 2) = v7 | 0x8000000000000000;
    *(void *)a1 = v8;
    a1 = v8;
    goto LABEL_15;
  }
  a1[23] = v2;
  if (v2) {
LABEL_15:
  }
    memmove(a1, v5, v2);
LABEL_16:
  a1[v2] = 0;
  v10[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v10 + *(void *)(v10[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v10[1] = MEMORY[0x1E4FBA470] + 16;
  if (v15 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1D25F1640](&v18);
}

void sub_1D0E41B84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1D0E41618((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1D0E41B98()
{
}

void sub_1D0E41BB0(void *a1@<X8>)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1630, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1630))
  {
    sub_1D0E41C40();
  }
  uint64_t v2 = qword_1EB9F16A8;
  *a1 = qword_1EB9F16A0;
  a1[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_1D0E41C28(_Unwind_Exception *a1)
{
}

void sub_1D0E41C40()
{
}

void sub_1D0E41CDC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1D0E41D14(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1D0E41D44(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E41D80(uint64_t a1, uint64_t a2)
{
  id v4 = (std::mutex *)(a1 + 648);
  std::mutex::lock((std::mutex *)(a1 + 648));
  sub_1D0E6DCF8((uint64_t *)(a1 + 432), a2);
  std::mutex::lock((std::mutex *)(a1 + 584));
  sub_1D0E6E85C((uint64_t *)(a1 + 288), (uint64_t *)(a1 + 432));
  uint64_t v5 = *(float **)(a1 + 328);
  uint64_t v6 = *(float **)(a1 + 40);
  uint64_t v7 = *(unsigned int *)(a1 + 344);
  float v8 = vabds_f32(*v5, *v6);
  if (v7 != 1)
  {
    uint64_t v9 = v5 + 1;
    uint64_t v10 = 4 * v7 - 4;
    uint64_t v11 = v6 + 1;
    do
    {
      float v12 = *v9++;
      float v13 = v12;
      float v14 = *v11++;
      float v15 = vabds_f32(v13, v14);
      if (v8 < v15) {
        float v8 = v15;
      }
      v10 -= 4;
    }
    while (v10);
  }
  int v16 = llroundf((float)(v8 / 5.0) * 10.0);
  if (v16 >= 10) {
    int v16 = 10;
  }
  if (v16 <= 1) {
    int v16 = 1;
  }
  *(_DWORD *)(a1 + 576) = v16;
  std::mutex::unlock((std::mutex *)(a1 + 584));
  std::mutex::unlock(v4);
}

uint64_t sub_1D0E41E74(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 8);
  *(void *)a1 = v5;
  *(void *)(a1 + 8) = v4;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if ((uint64_t *)a1 == a2) {
      goto LABEL_27;
    }
  }
  else if ((uint64_t *)a1 == a2)
  {
    goto LABEL_27;
  }
  unint64_t v7 = *((unsigned int *)a2 + 8);
  if (v7)
  {
    float v8 = *(void **)(a1 + 16);
    if (*(void *)(a1 + 24) >= v7)
    {
      size_t v9 = 4 * v7;
    }
    else
    {
      free(v8);
      size_t v9 = 4 * v7;
      size_t v10 = (v9 + 31) & 0x7FFFFFFE0;
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 24) = v10 >> 2;
      long long memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v10, 0x49090899uLL);
      float v8 = memptr;
      *(void *)(a1 + 16) = memptr;
    }
    memcpy(v8, (const void *)a2[2], v9);
  }
  else
  {
    free(*(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
  }
  *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
  unint64_t v11 = *((unsigned int *)a2 + 14);
  if (v11)
  {
    float v12 = *(void **)(a1 + 40);
    if (*(void *)(a1 + 48) >= v11)
    {
      size_t v13 = 4 * v11;
    }
    else
    {
      free(v12);
      size_t v13 = 4 * v11;
      size_t v14 = (v13 + 31) & 0x7FFFFFFE0;
      *(void *)(a1 + 40) = 0;
      *(void *)(a1 + 48) = v14 >> 2;
      long long memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v14, 0x49090899uLL);
      float v12 = memptr;
      *(void *)(a1 + 40) = memptr;
    }
    memcpy(v12, (const void *)a2[5], v13);
  }
  else
  {
    free(*(void **)(a1 + 40));
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
  }
  *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 14);
  unint64_t v15 = (*((_DWORD *)a2 + 21) * *((_DWORD *)a2 + 20));
  if (v15)
  {
    int v16 = *(void **)(a1 + 64);
    if (*(void *)(a1 + 72) >= v15)
    {
      size_t v17 = 4 * v15;
    }
    else
    {
      free(v16);
      size_t v17 = 4 * v15;
      size_t v18 = (v17 + 31) & 0x7FFFFFFE0;
      *(void *)(a1 + 64) = 0;
      *(void *)(a1 + 72) = v18 >> 2;
      long long memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v18, 0x49090899uLL);
      int v16 = memptr;
      *(void *)(a1 + 64) = memptr;
    }
    memcpy(v16, (const void *)a2[8], v17);
  }
  else
  {
    free(*(void **)(a1 + 64));
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
  }
  *(void *)(a1 + 80) = a2[10];
LABEL_27:
  float32x4_t v19 = (_OWORD *)(a1 + 88);
  uint64_t v20 = (long long *)(a2 + 11);
  if (*(unsigned __int8 *)(a1 + 136) == *((unsigned __int8 *)a2 + 136))
  {
    if ((uint64_t *)a1 != a2 && *(unsigned char *)(a1 + 136))
    {
      long long v21 = *v20;
      long long v22 = *(_OWORD *)(a2 + 15);
      *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 13);
      *(_OWORD *)(a1 + 120) = v22;
      *float32x4_t v19 = v21;
    }
  }
  else if (*(unsigned char *)(a1 + 136))
  {
    *(unsigned char *)(a1 + 136) = 0;
  }
  else
  {
    long long v23 = *v20;
    long long v24 = *(_OWORD *)(a2 + 15);
    *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 13);
    *(_OWORD *)(a1 + 120) = v24;
    *float32x4_t v19 = v23;
    *(unsigned char *)(a1 + 136) = 1;
  }
  return a1;
}

float *sub_1D0E420F4(float *a1, uint64_t a2)
{
  unint64_t v3 = *(float **)(a2 + 8);
  if (v3 == a1)
  {
    uint64_t v7 = 0;
    uint64_t result = (float *)sub_1D0E420F4(&v7);
    *(void *)a1 = v7;
  }
  else
  {
    uint64_t v4 = *(float ***)a2;
    uint64_t v7 = 0;
    uint64_t result = sub_1D0E42178((float *)&v7, v4);
    uint64_t v6 = v7;
    *a1 = (float)((float)(*(float *)&v7 * *v3) + 0.0) + (float)(*((float *)&v7 + 1) * v3[1]);
    a1[1] = (float)((float)(*(float *)&v6 * v3[2]) + 0.0) + (float)(*((float *)&v6 + 1) * v3[3]);
  }
  return result;
}

float *sub_1D0E42178(float *result, float **a2)
{
  uint64_t v2 = result;
  unint64_t v3 = *a2;
  if (*a2 == result || (uint64_t v4 = a2[1], v4 == result))
  {
    uint64_t v5 = 0;
    uint64_t result = (float *)sub_1D0E42178(&v5);
    *(void *)uint64_t v2 = v5;
  }
  else
  {
    *uint64_t result = (float)((float)(*v3 * *v4) + 0.0) + (float)(v3[1] * v4[1]);
    result[1] = (float)((float)(*v3 * v4[2]) + 0.0) + (float)(v3[1] * v4[3]);
  }
  return result;
}

void *sub_1D0E421FC(void *a1)
{
  uint64_t v2 = (void *)*a1;
  *a1 = 0;
  if (!v2) {
    return a1;
  }
  if (v2[9])
  {
    unint64_t v3 = (std::__shared_weak_count *)v2[10];
    v2[9] = 0;
    v2[10] = 0;
    if (v3)
    {
      if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)v2[10];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = (void *)v2[6];
    if (!v5) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  uint64_t v5 = (void *)v2[6];
  if (v5)
  {
LABEL_9:
    v2[7] = v5;
    operator delete(v5);
  }
LABEL_10:
  uint64_t v6 = v2[3];
  if (v6)
  {
    uint64_t v7 = v2[4];
    float v8 = (void *)v2[3];
    if (v7 != v6)
    {
      do
      {
        size_t v10 = *(__CVBuffer **)(v7 - 8);
        v7 -= 8;
        size_t v9 = v10;
        if (v10) {
          CVPixelBufferRelease(v9);
        }
      }
      while (v7 != v6);
      float v8 = (void *)v2[3];
    }
    v2[4] = v6;
    operator delete(v8);
  }
  MEMORY[0x1D25F16B0](v2, 0x1020C40612EDB84);
  return a1;
}

uint64_t sub_1D0E42348(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  *(void *)(result + 24) = 0;
  if (v1)
  {
    if (*(void *)v1) {
      CFRelease(*(CFTypeRef *)v1);
    }
    uint64_t v2 = *(const void **)(v1 + 8);
    if (v2) {
      CFRelease(v2);
    }
    unint64_t v3 = *(const void **)(v1 + 16);
    if (v3) {
      CFRelease(v3);
    }
    JUMPOUT(0x1D25F16B0);
  }
  return result;
}

void sub_1D0E423C4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4D08;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E42418(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4D08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0E42438()
{
  if (!off_1EB9F15B0)
  {
    std::mutex::unlock(&stru_1EB9F1570);
    sub_1D0E439FC();
  }
  operator new();
}

void sub_1D0E439FC()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F16B8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F16B8))
  {
    sub_1D0E2CB50();
    __cxa_guard_release(&qword_1EB9F16B8);
  }
  if (*(void *)algn_1EB9F16C8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)algn_1EB9F16C8 + 8), 1uLL, memory_order_relaxed);
  }
  operator new();
}

void sub_1D0E459CC(_Unwind_Exception *a1)
{
}

void sub_1D0E45A84(uint64_t a1, void *a2, uint64_t *a3, unint64_t a4)
{
  unint64_t v4 = a4;
  float v8 = *(char **)(a1 + 8);
  size_t v9 = *(char **)(a1 + 16);
  uint64_t v10 = (v9 - v8) >> 3;
  if (v9 == v8) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = 341 * v10 - 1;
  }
  unint64_t v12 = *(void *)(a1 + 32);
  uint64_t v13 = *(void *)(a1 + 40);
  unint64_t v14 = v13 + v12;
  unint64_t v15 = v11 - (v13 + v12);
  BOOL v16 = a4 >= v15;
  unint64_t v17 = a4 - v15;
  if (v17 == 0 || !v16) {
    goto LABEL_139;
  }
  unint64_t v18 = v17 + (v9 == v8);
  if (v18 % 0x155) {
    unint64_t v19 = v18 / 0x155 + 1;
  }
  else {
    unint64_t v19 = v18 / 0x155;
  }
  if (v19 >= v12 / 0x155) {
    unint64_t v20 = v12 / 0x155;
  }
  else {
    unint64_t v20 = v19;
  }
  if (v19 <= v12 / 0x155)
  {
    *(void *)(a1 + 32) = v12 - 341 * v20;
    if (!v20) {
      goto LABEL_138;
    }
    while (1)
    {
      uint64_t v27 = *(void **)(a1 + 8);
      uint64_t v28 = (char *)(v27 + 1);
      uint64_t v29 = *v27;
      *(void *)(a1 + 8) = v27 + 1;
      if (v9 == *(char **)(a1 + 24))
      {
        BOOL v30 = *(char **)a1;
        if ((unint64_t)v28 <= *(void *)a1)
        {
          unint64_t v36 = (v9 - v30) >> 2;
          if (v9 == v30) {
            unint64_t v36 = 1;
          }
          if (v36 >> 61) {
            goto LABEL_182;
          }
          unint64_t v37 = v36 >> 2;
          uint64_t v164 = 8 * v36;
          size_t v38 = (char *)operator new(8 * v36);
          unint64_t v39 = &v38[8 * v37];
          int64_t v41 = v9 - v28;
          BOOL v40 = v9 == v28;
          size_t v9 = v39;
          if (!v40)
          {
            size_t v9 = &v39[v41 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v42 = v41 - 8;
            if ((unint64_t)(v41 - 8) >= 0x38)
            {
              size_t v43 = &v38[8 * v37];
              if ((unint64_t)(v43 - v28) < 0x20) {
                goto LABEL_42;
              }
              uint64_t v44 = (v42 >> 3) + 1;
              uint64_t v45 = 8 * (v44 & 0x3FFFFFFFFFFFFFFCLL);
              size_t v43 = &v39[v45];
              uint64_t v46 = (long long *)(v27 + 3);
              uint64_t v47 = &v38[8 * v37 + 16];
              uint64_t v48 = v44 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v49 = *v46;
                *((_OWORD *)v47 - 1) = *(v46 - 1);
                *(_OWORD *)uint64_t v47 = v49;
                v46 += 2;
                v47 += 32;
                v48 -= 4;
              }
              while (v48);
              if (v44 != (v44 & 0x3FFFFFFFFFFFFFFCLL))
              {
                v28 += v45;
                goto LABEL_42;
              }
            }
            else
            {
              size_t v43 = &v38[8 * v37];
              do
              {
LABEL_42:
                uint64_t v50 = *(void *)v28;
                v28 += 8;
                *(void *)size_t v43 = v50;
                v43 += 8;
              }
              while (v43 != v9);
            }
          }
          *(void *)a1 = v38;
          *(void *)(a1 + 8) = v39;
          *(void *)(a1 + 16) = v9;
          *(void *)(a1 + 24) = &v38[v164];
          if (v30)
          {
            operator delete(v30);
            size_t v9 = *(char **)(a1 + 16);
          }
          goto LABEL_23;
        }
        uint64_t v31 = (uint64_t)&v28[-*(void *)a1] >> 3;
        if (v31 >= -1) {
          uint64_t v32 = v31 + 1;
        }
        else {
          uint64_t v32 = v31 + 2;
        }
        uint64_t v33 = v32 >> 1;
        int v34 = &v28[-8 * (v32 >> 1)];
        int64_t v35 = v9 - v28;
        if (v9 != v28)
        {
          memmove(&v28[-8 * (v32 >> 1)], v28, v9 - v28);
          size_t v9 = *(char **)(a1 + 8);
        }
        uint64_t v26 = &v9[-8 * v33];
        size_t v9 = &v34[v35];
        *(void *)(a1 + 8) = v26;
        *(void *)(a1 + 16) = &v34[v35];
      }
LABEL_23:
      *(void *)size_t v9 = v29;
      size_t v9 = (char *)(*(void *)(a1 + 16) + 8);
      *(void *)(a1 + 16) = v9;
      if (!--v20) {
        goto LABEL_138;
      }
    }
  }
  unint64_t v21 = v19 - v20;
  uint64_t v22 = *(void *)(a1 + 24) - *(void *)a1;
  if (v19 - v20 <= (v22 >> 3) - v10)
  {
    if (!v21) {
      goto LABEL_136;
    }
    do
    {
      if (*(void *)(a1 + 24) == *(void *)(a1 + 16))
      {
        for (uint64_t i = 0; i != v21; ++i)
        {
          int v168 = operator new(0xFFCuLL);
          sub_1D0E3EA48((void **)a1, &v168);
          size_t v9 = *(char **)(a1 + 16);
          if (&v9[-*(void *)(a1 + 8)] == (char *)8) {
            uint64_t v121 = 340;
          }
          else {
            uint64_t v121 = 341;
          }
          uint64_t v122 = v121 + *(void *)(a1 + 32);
          *(void *)(a1 + 32) = v122;
        }
        v20 += v21;
        goto LABEL_137;
      }
      int v168 = operator new(0xFFCuLL);
      sub_1D0E3EBF0((char **)a1, &v168);
      --v21;
    }
    while (v21);
    size_t v9 = *(char **)(a1 + 16);
LABEL_136:
    uint64_t v122 = *(void *)(a1 + 32);
LABEL_137:
    *(void *)(a1 + 32) = v122 - 341 * v20;
    if (!v20) {
      goto LABEL_138;
    }
    while (1)
    {
      int v129 = *(void **)(a1 + 8);
      unint64_t v130 = (char *)(v129 + 1);
      uint64_t v131 = *v129;
      *(void *)(a1 + 8) = v129 + 1;
      if (v9 == *(char **)(a1 + 24))
      {
        unint64_t v132 = *(char **)a1;
        if ((unint64_t)v130 <= *(void *)a1)
        {
          unint64_t v138 = (v9 - v132) >> 2;
          if (v9 == v132) {
            unint64_t v138 = 1;
          }
          if (v138 >> 61) {
            goto LABEL_182;
          }
          unint64_t v139 = v138 >> 2;
          uint64_t v167 = 8 * v138;
          int v140 = (char *)operator new(8 * v138);
          uint64_t v141 = &v140[8 * v139];
          int64_t v142 = v9 - v130;
          BOOL v40 = v9 == v130;
          size_t v9 = v141;
          if (!v40)
          {
            size_t v9 = &v141[v142 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v143 = v142 - 8;
            if ((unint64_t)(v142 - 8) >= 0x38)
            {
              uint64_t v144 = &v140[8 * v139];
              if ((unint64_t)(v144 - v130) < 0x20) {
                goto LABEL_164;
              }
              uint64_t v145 = (v143 >> 3) + 1;
              uint64_t v146 = 8 * (v145 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v144 = &v141[v146];
              int v147 = (long long *)(v129 + 3);
              int v148 = &v140[8 * v139 + 16];
              uint64_t v149 = v145 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v150 = *v147;
                *((_OWORD *)v148 - 1) = *(v147 - 1);
                *(_OWORD *)int v148 = v150;
                v147 += 2;
                v148 += 32;
                v149 -= 4;
              }
              while (v149);
              if (v145 != (v145 & 0x3FFFFFFFFFFFFFFCLL))
              {
                v130 += v146;
                goto LABEL_164;
              }
            }
            else
            {
              uint64_t v144 = &v140[8 * v139];
              do
              {
LABEL_164:
                uint64_t v151 = *(void *)v130;
                v130 += 8;
                *(void *)uint64_t v144 = v151;
                v144 += 8;
              }
              while (v144 != v9);
            }
          }
          *(void *)a1 = v140;
          *(void *)(a1 + 8) = v141;
          *(void *)(a1 + 16) = v9;
          *(void *)(a1 + 24) = &v140[v167];
          if (v132)
          {
            operator delete(v132);
            size_t v9 = *(char **)(a1 + 16);
          }
          goto LABEL_145;
        }
        uint64_t v133 = (uint64_t)&v130[-*(void *)a1] >> 3;
        if (v133 >= -1) {
          uint64_t v134 = v133 + 1;
        }
        else {
          uint64_t v134 = v133 + 2;
        }
        uint64_t v135 = v134 >> 1;
        uint64_t v136 = &v130[-8 * (v134 >> 1)];
        int64_t v137 = v9 - v130;
        if (v9 != v130)
        {
          memmove(&v130[-8 * (v134 >> 1)], v130, v9 - v130);
          size_t v9 = *(char **)(a1 + 8);
        }
        uint64_t v128 = &v9[-8 * v135];
        size_t v9 = &v136[v137];
        *(void *)(a1 + 8) = v128;
        *(void *)(a1 + 16) = &v136[v137];
      }
LABEL_145:
      *(void *)size_t v9 = v131;
      size_t v9 = (char *)(*(void *)(a1 + 16) + 8);
      *(void *)(a1 + 16) = v9;
      if (!--v20) {
        goto LABEL_138;
      }
    }
  }
  unint64_t v23 = v22 >> 2;
  if (v23 <= v21 + v10) {
    unint64_t v24 = v21 + v10;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24)
  {
    if (v24 >> 61) {
LABEL_182:
    }
      sub_1D0DE8CE0();
    int v25 = (char *)operator new(8 * v24);
  }
  else
  {
    int v25 = 0;
  }
  uint64_t v158 = -341 * v20;
  unint64_t v51 = &v25[8 * (v10 - v20)];
  float v52 = &v25[8 * v24];
  size_t v9 = v51;
  do
  {
    uint64_t v54 = operator new(0xFFCuLL);
    if (v9 != v52) {
      goto LABEL_52;
    }
    unint64_t v165 = v25;
    if (v51 <= v25)
    {
      unint64_t v62 = (v52 - v25) >> 2;
      if (v52 == v25) {
        unint64_t v62 = 1;
      }
      if (v62 >> 61) {
        goto LABEL_182;
      }
      unint64_t v63 = v62 >> 2;
      uint64_t v161 = 8 * v62;
      id v64 = (char *)operator new(8 * v62);
      uint64_t v65 = &v64[8 * v63];
      size_t v9 = v65;
      int64_t v66 = v52 - v51;
      if (v52 == v51) {
        goto LABEL_73;
      }
      size_t v9 = &v65[v66 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v67 = v66 - 8;
      if (v67 >= 0x38)
      {
        if ((unint64_t)(&v64[8 * v63] - v51) >= 0x20)
        {
          uint64_t v69 = (v67 >> 3) + 1;
          uint64_t v70 = 8 * (v69 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v68 = &v65[v70];
          uint64_t v71 = (long long *)(v51 + 16);
          uint64_t v72 = &v64[8 * v63 + 16];
          uint64_t v73 = v69 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v74 = *v71;
            *((_OWORD *)v72 - 1) = *(v71 - 1);
            *(_OWORD *)uint64_t v72 = v74;
            v71 += 2;
            v72 += 32;
            v73 -= 4;
          }
          while (v73);
          if (v69 == (v69 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_73;
          }
          v51 += v70;
        }
        else
        {
          uint64_t v68 = &v64[8 * v63];
        }
      }
      else
      {
        uint64_t v68 = &v64[8 * v63];
      }
      do
      {
        uint64_t v75 = *(void *)v51;
        v51 += 8;
        *(void *)uint64_t v68 = v75;
        v68 += 8;
      }
      while (v68 != v9);
LABEL_73:
      float v52 = &v64[v161];
      if (v165)
      {
        int v25 = v64;
        unint64_t v51 = v65;
        operator delete(v165);
      }
      else
      {
        unint64_t v51 = v65;
        int v25 = v64;
      }
      goto LABEL_52;
    }
    uint64_t v55 = (v51 - v25) >> 3;
    if (v55 >= -1) {
      uint64_t v56 = v55 + 1;
    }
    else {
      uint64_t v56 = v55 + 2;
    }
    uint64_t v57 = v56 >> 1;
    long long v58 = v52;
    int v59 = &v51[-8 * (v56 >> 1)];
    int v60 = v58;
    int v160 = v58;
    int64_t v61 = v58 - v51;
    if (v58 != v51)
    {
      memmove(v59, v51, v58 - v51);
      int v60 = v51;
    }
    uint64_t v53 = -v57;
    size_t v9 = &v59[v61];
    unint64_t v51 = &v60[8 * v53];
    float v52 = v160;
    int v25 = v165;
LABEL_52:
    *(void *)size_t v9 = v54;
    v9 += 8;
    --v21;
  }
  while (v21);
  int v76 = *(void **)(a1 + 8);
  if (v20)
  {
    while (1)
    {
      if (v9 == v52)
      {
        int v166 = v25;
        if (v51 <= v25)
        {
          unint64_t v86 = (v52 - v25) >> 2;
          if (v52 == v25) {
            unint64_t v86 = 1;
          }
          if (v86 >> 61) {
            goto LABEL_182;
          }
          unint64_t v87 = v86 >> 2;
          uint64_t v163 = 8 * v86;
          int32x4_t v88 = (char *)operator new(8 * v86);
          uint64_t v77 = &v88[8 * v87];
          size_t v9 = v77;
          int64_t v89 = v52 - v51;
          if (v52 != v51)
          {
            size_t v9 = &v77[v89 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v90 = v89 - 8;
            if (v90 >= 0x38)
            {
              if ((unint64_t)(&v88[8 * v87] - v51) < 0x20)
              {
                long long v91 = &v88[8 * v87];
                goto LABEL_103;
              }
              uint64_t v92 = (v90 >> 3) + 1;
              uint64_t v93 = 8 * (v92 & 0x3FFFFFFFFFFFFFFCLL);
              long long v91 = &v77[v93];
              uint64_t v94 = (long long *)(v51 + 16);
              int v95 = &v88[8 * v87 + 16];
              uint64_t v96 = v92 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v97 = *v94;
                *((_OWORD *)v95 - 1) = *(v94 - 1);
                *(_OWORD *)int v95 = v97;
                v94 += 2;
                v95 += 32;
                v96 -= 4;
              }
              while (v96);
              if (v92 != (v92 & 0x3FFFFFFFFFFFFFFCLL))
              {
                v51 += v93;
                goto LABEL_103;
              }
            }
            else
            {
              long long v91 = &v88[8 * v87];
              do
              {
LABEL_103:
                uint64_t v98 = *(void *)v51;
                v51 += 8;
                *(void *)long long v91 = v98;
                v91 += 8;
              }
              while (v91 != v9);
            }
          }
          float v52 = &v88[v163];
          int v25 = v88;
          if (v166) {
            operator delete(v166);
          }
          goto LABEL_82;
        }
        uint64_t v80 = (v51 - v25) >> 3;
        if (v80 >= -1) {
          uint64_t v81 = v80 + 1;
        }
        else {
          uint64_t v81 = v80 + 2;
        }
        uint64_t v82 = v81 >> 1;
        unint64_t v83 = &v51[-8 * (v81 >> 1)];
        int v84 = v52;
        int v162 = v52;
        size_t v85 = v52 - v51;
        if (v85)
        {
          memmove(v83, v51, v85);
          int v84 = v51;
        }
        size_t v9 = &v83[v85];
        uint64_t v77 = &v84[-8 * v82];
        float v52 = v162;
        int v25 = v166;
      }
      else
      {
        uint64_t v77 = v51;
      }
LABEL_82:
      *(void *)size_t v9 = *v76;
      v9 += 8;
      int v76 = (void *)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v76;
      unint64_t v51 = v77;
      if (!--v20) {
        goto LABEL_78;
      }
    }
  }
  uint64_t v77 = v51;
LABEL_78:
  uint64_t v78 = *(void **)(a1 + 16);
  if (v78 != v76)
  {
    while (v77 != v25)
    {
LABEL_108:
      uint64_t v99 = *--v78;
      *((void *)v77 - 1) = v99;
      v77 -= 8;
      if (v78 == *(void **)(a1 + 8)) {
        goto LABEL_79;
      }
    }
    if (v9 < v52)
    {
      uint64_t v100 = (v52 - v9) >> 3;
      if (v100 >= -1) {
        uint64_t v101 = v100 + 1;
      }
      else {
        uint64_t v101 = v100 + 2;
      }
      uint64_t v102 = v101 >> 1;
      uint64_t v77 = &v25[8 * (v101 >> 1)];
      float32x4_t v103 = v25;
      if (v9 != v25)
      {
        memmove(v77, v25, v9 - v25);
        float32x4_t v103 = v9;
      }
      size_t v9 = &v103[8 * v102];
      goto LABEL_108;
    }
    unint64_t v104 = (v52 - v25) >> 2;
    if (v52 == v25) {
      unint64_t v104 = 1;
    }
    if (v104 >> 61) {
      goto LABEL_182;
    }
    unint64_t v105 = (v104 + 3) >> 2;
    uint64_t v106 = 8 * v104;
    unint64_t v107 = (char *)operator new(8 * v104);
    int64_t v108 = v107;
    uint64_t v77 = &v107[8 * v105];
    float v52 = &v107[v106];
    int64_t v109 = v9 - v25;
    BOOL v40 = v9 == v25;
    size_t v9 = v77;
    if (!v40)
    {
      size_t v9 = &v77[v109 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v110 = v109 - 8;
      int v111 = &v107[8 * v105];
      uint64_t v112 = v25;
      if (v110 >= 0x38)
      {
        int v111 = &v107[8 * v105];
        uint64_t v112 = v25;
        if ((unint64_t)(v111 - v25) >= 0x20)
        {
          uint64_t v113 = (v110 >> 3) + 1;
          uint64_t v114 = 8 * (v113 & 0x3FFFFFFFFFFFFFFCLL);
          int v111 = &v77[v114];
          char v115 = (long long *)(v25 + 16);
          unint64_t v116 = &v107[8 * v105 + 16];
          uint64_t v117 = v113 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v118 = *v115;
            *((_OWORD *)v116 - 1) = *(v115 - 1);
            *(_OWORD *)unint64_t v116 = v118;
            v115 += 2;
            v116 += 32;
            v117 -= 4;
          }
          while (v117);
          if (v113 == (v113 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_128;
          }
          uint64_t v112 = &v25[v114];
        }
      }
      do
      {
        uint64_t v119 = *(void *)v112;
        v112 += 8;
        *(void *)int v111 = v119;
        v111 += 8;
      }
      while (v111 != v9);
    }
    if (!v25)
    {
LABEL_129:
      int v25 = v108;
      goto LABEL_108;
    }
LABEL_128:
    operator delete(v25);
    goto LABEL_129;
  }
LABEL_79:
  uint64_t v79 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v77;
  *(void *)(a1 + 16) = v9;
  *(void *)(a1 + 24) = v52;
  *(void *)(a1 + 32) += v158;
  if (v79)
  {
    operator delete(v79);
    size_t v9 = *(char **)(a1 + 16);
  }
LABEL_138:
  uint64_t v13 = *(void *)(a1 + 40);
  float v8 = *(char **)(a1 + 8);
  unint64_t v14 = *(void *)(a1 + 32) + v13;
  unint64_t v4 = a4;
LABEL_139:
  uint64_t v123 = &v8[8 * (v14 / 0x155)];
  if (v9 == v8)
  {
    unint64_t v124 = 0;
    if (!v4) {
      return;
    }
LABEL_141:
    uint64_t v125 = (uint64_t)(v124 - *(void *)v123) / 12 + v4;
    if (v125 < 1)
    {
      unint64_t v152 = 340 - v125;
      long long v126 = &v123[-8 * (v152 / 0x155)];
      unint64_t v127 = *(void *)v126 + 12 * (340 - v152 % 0x155);
      if (v124 == v127) {
        return;
      }
    }
    else
    {
      long long v126 = &v123[8 * (v125 / 0x155uLL)];
      unint64_t v127 = *(void *)v126 + 12 * (v125 % 0x155uLL);
      if (v124 == v127) {
        return;
      }
    }
    do
    {
      uint64_t v153 = v127;
      if (v123 != v126) {
        uint64_t v153 = *(void *)v123 + 4092;
      }
      if (v124 == v153)
      {
        uint64_t v153 = v124;
      }
      else
      {
        unint64_t v154 = v124;
        do
        {
          uint64_t v155 = *a3;
          *(_DWORD *)(v154 + 8) = *((_DWORD *)a3 + 2);
          *(void *)unint64_t v154 = v155;
          a3 = (uint64_t *)((char *)a3 + 12);
          if ((uint64_t *)((char *)a3 - *a2) == (uint64_t *)4092)
          {
            int v156 = (uint64_t *)a2[1];
            ++a2;
            a3 = v156;
          }
          v154 += 12;
        }
        while (v154 != v153);
        uint64_t v13 = *(void *)(a1 + 40);
      }
      v13 -= 0x5555555555555555 * ((uint64_t)(v153 - v124) >> 2);
      *(void *)(a1 + 40) = v13;
      if (v123 == v126) {
        break;
      }
      unint64_t v157 = *((void *)v123 + 1);
      v123 += 8;
      unint64_t v124 = v157;
    }
    while (v157 != v127);
  }
  else
  {
    unint64_t v124 = *(void *)v123 + 12 * (v14 % 0x155);
    if (v4) {
      goto LABEL_141;
    }
  }
}

void sub_1D0E4659C(uint64_t a1, void *a2, int *a3, unint64_t a4)
{
  unint64_t v4 = a4;
  float v8 = *(char **)(a1 + 8);
  size_t v9 = *(char **)(a1 + 16);
  uint64_t v10 = v9 - v8;
  if (v9 == v8) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = ((v9 - v8) << 7) - 1;
  }
  unint64_t v13 = *(void *)(a1 + 32);
  uint64_t v12 = *(void *)(a1 + 40);
  unint64_t v14 = v12 + v13;
  unint64_t v15 = v11 - (v12 + v13);
  BOOL v16 = a4 >= v15;
  unint64_t v17 = a4 - v15;
  if (v17 == 0 || !v16) {
    goto LABEL_142;
  }
  if (v9 == v8) {
    unint64_t v18 = v17 + 1;
  }
  else {
    unint64_t v18 = v17;
  }
  if ((v18 & 0x3FF) != 0) {
    unint64_t v19 = (v18 >> 10) + 1;
  }
  else {
    unint64_t v19 = v18 >> 10;
  }
  if (v19 >= v13 >> 10) {
    unint64_t v20 = v13 >> 10;
  }
  else {
    unint64_t v20 = v19;
  }
  if (v19 <= v13 >> 10)
  {
    *(void *)(a1 + 32) = v13 - (v20 << 10);
    if (!v20) {
      goto LABEL_141;
    }
    while (1)
    {
      uint64_t v27 = *(void **)(a1 + 8);
      uint64_t v28 = (char *)(v27 + 1);
      uint64_t v29 = *v27;
      *(void *)(a1 + 8) = v27 + 1;
      if (v9 == *(char **)(a1 + 24))
      {
        BOOL v30 = *(char **)a1;
        if ((unint64_t)v28 <= *(void *)a1)
        {
          unint64_t v36 = (v9 - v30) >> 2;
          if (v9 == v30) {
            unint64_t v36 = 1;
          }
          if (v36 >> 61) {
            goto LABEL_186;
          }
          unint64_t v37 = v36 >> 2;
          uint64_t v164 = 8 * v36;
          size_t v38 = (char *)operator new(8 * v36);
          unint64_t v39 = &v38[8 * v37];
          int64_t v41 = v9 - v28;
          BOOL v40 = v9 == v28;
          size_t v9 = v39;
          if (!v40)
          {
            size_t v9 = &v39[v41 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v42 = v41 - 8;
            if ((unint64_t)(v41 - 8) >= 0x38)
            {
              size_t v43 = &v38[8 * v37];
              if ((unint64_t)(v43 - v28) < 0x20) {
                goto LABEL_45;
              }
              uint64_t v44 = (v42 >> 3) + 1;
              uint64_t v45 = 8 * (v44 & 0x3FFFFFFFFFFFFFFCLL);
              size_t v43 = &v39[v45];
              uint64_t v46 = (long long *)(v27 + 3);
              uint64_t v47 = &v38[8 * v37 + 16];
              uint64_t v48 = v44 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v49 = *v46;
                *((_OWORD *)v47 - 1) = *(v46 - 1);
                *(_OWORD *)uint64_t v47 = v49;
                v46 += 2;
                v47 += 32;
                v48 -= 4;
              }
              while (v48);
              if (v44 != (v44 & 0x3FFFFFFFFFFFFFFCLL))
              {
                v28 += v45;
                goto LABEL_45;
              }
            }
            else
            {
              size_t v43 = &v38[8 * v37];
              do
              {
LABEL_45:
                uint64_t v50 = *(void *)v28;
                v28 += 8;
                *(void *)size_t v43 = v50;
                v43 += 8;
              }
              while (v43 != v9);
            }
          }
          *(void *)a1 = v38;
          *(void *)(a1 + 8) = v39;
          *(void *)(a1 + 16) = v9;
          *(void *)(a1 + 24) = &v38[v164];
          if (v30)
          {
            operator delete(v30);
            size_t v9 = *(char **)(a1 + 16);
          }
          goto LABEL_26;
        }
        uint64_t v31 = (uint64_t)&v28[-*(void *)a1] >> 3;
        if (v31 >= -1) {
          uint64_t v32 = v31 + 1;
        }
        else {
          uint64_t v32 = v31 + 2;
        }
        uint64_t v33 = v32 >> 1;
        int v34 = &v28[-8 * (v32 >> 1)];
        int64_t v35 = v9 - v28;
        if (v9 != v28)
        {
          memmove(&v28[-8 * (v32 >> 1)], v28, v9 - v28);
          size_t v9 = *(char **)(a1 + 8);
        }
        uint64_t v26 = &v9[-8 * v33];
        size_t v9 = &v34[v35];
        *(void *)(a1 + 8) = v26;
        *(void *)(a1 + 16) = &v34[v35];
      }
LABEL_26:
      *(void *)size_t v9 = v29;
      size_t v9 = (char *)(*(void *)(a1 + 16) + 8);
      *(void *)(a1 + 16) = v9;
      if (!--v20) {
        goto LABEL_141;
      }
    }
  }
  unint64_t v21 = v19 - v20;
  uint64_t v22 = *(void *)(a1 + 24) - *(void *)a1;
  uint64_t v23 = v10 >> 3;
  if (v21 <= (v22 >> 3) - (v10 >> 3))
  {
    if (!v21) {
      goto LABEL_139;
    }
    do
    {
      if (*(void *)(a1 + 24) == *(void *)(a1 + 16))
      {
        for (uint64_t i = 0; i != v21; ++i)
        {
          int v168 = operator new(0x1000uLL);
          sub_1D0E3EA48((void **)a1, &v168);
          size_t v9 = *(char **)(a1 + 16);
          if (&v9[-*(void *)(a1 + 8)] == (char *)8) {
            uint64_t v121 = 1023;
          }
          else {
            uint64_t v121 = 1024;
          }
          uint64_t v122 = v121 + *(void *)(a1 + 32);
          *(void *)(a1 + 32) = v122;
        }
        v20 += v21;
        goto LABEL_140;
      }
      int v168 = operator new(0x1000uLL);
      sub_1D0E3EBF0((char **)a1, &v168);
      --v21;
    }
    while (v21);
    size_t v9 = *(char **)(a1 + 16);
LABEL_139:
    uint64_t v122 = *(void *)(a1 + 32);
LABEL_140:
    *(void *)(a1 + 32) = v122 - (v20 << 10);
    if (!v20) {
      goto LABEL_141;
    }
    while (1)
    {
      uint64_t v128 = *(void **)(a1 + 8);
      int v129 = (char *)(v128 + 1);
      uint64_t v130 = *v128;
      *(void *)(a1 + 8) = v128 + 1;
      if (v9 == *(char **)(a1 + 24))
      {
        uint64_t v131 = *(char **)a1;
        if ((unint64_t)v129 <= *(void *)a1)
        {
          unint64_t v137 = (v9 - v131) >> 2;
          if (v9 == v131) {
            unint64_t v137 = 1;
          }
          if (v137 >> 61) {
            goto LABEL_186;
          }
          unint64_t v138 = v137 >> 2;
          uint64_t v167 = 8 * v137;
          unint64_t v139 = (char *)operator new(8 * v137);
          int v140 = &v139[8 * v138];
          int64_t v141 = v9 - v129;
          BOOL v40 = v9 == v129;
          size_t v9 = v140;
          if (!v40)
          {
            size_t v9 = &v140[v141 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v142 = v141 - 8;
            if ((unint64_t)(v141 - 8) >= 0x38)
            {
              unint64_t v143 = &v139[8 * v138];
              if ((unint64_t)(v143 - v129) < 0x20) {
                goto LABEL_166;
              }
              uint64_t v144 = (v142 >> 3) + 1;
              uint64_t v145 = 8 * (v144 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v143 = &v140[v145];
              uint64_t v146 = (long long *)(v128 + 3);
              int v147 = &v139[8 * v138 + 16];
              uint64_t v148 = v144 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v149 = *v146;
                *((_OWORD *)v147 - 1) = *(v146 - 1);
                *(_OWORD *)int v147 = v149;
                v146 += 2;
                v147 += 32;
                v148 -= 4;
              }
              while (v148);
              if (v144 != (v144 & 0x3FFFFFFFFFFFFFFCLL))
              {
                v129 += v145;
                goto LABEL_166;
              }
            }
            else
            {
              unint64_t v143 = &v139[8 * v138];
              do
              {
LABEL_166:
                uint64_t v150 = *(void *)v129;
                v129 += 8;
                *(void *)unint64_t v143 = v150;
                v143 += 8;
              }
              while (v143 != v9);
            }
          }
          *(void *)a1 = v139;
          *(void *)(a1 + 8) = v140;
          *(void *)(a1 + 16) = v9;
          *(void *)(a1 + 24) = &v139[v167];
          if (v131)
          {
            operator delete(v131);
            size_t v9 = *(char **)(a1 + 16);
          }
          goto LABEL_147;
        }
        uint64_t v132 = (uint64_t)&v129[-*(void *)a1] >> 3;
        if (v132 >= -1) {
          uint64_t v133 = v132 + 1;
        }
        else {
          uint64_t v133 = v132 + 2;
        }
        uint64_t v134 = v133 >> 1;
        uint64_t v135 = &v129[-8 * (v133 >> 1)];
        int64_t v136 = v9 - v129;
        if (v9 != v129)
        {
          memmove(&v129[-8 * (v133 >> 1)], v129, v9 - v129);
          size_t v9 = *(char **)(a1 + 8);
        }
        unint64_t v127 = &v9[-8 * v134];
        size_t v9 = &v135[v136];
        *(void *)(a1 + 8) = v127;
        *(void *)(a1 + 16) = &v135[v136];
      }
LABEL_147:
      *(void *)size_t v9 = v130;
      size_t v9 = (char *)(*(void *)(a1 + 16) + 8);
      *(void *)(a1 + 16) = v9;
      if (!--v20) {
        goto LABEL_141;
      }
    }
  }
  if (v22 >> 2 <= v21 + v23) {
    unint64_t v24 = v21 + v23;
  }
  else {
    unint64_t v24 = v22 >> 2;
  }
  if (v24)
  {
    if (v24 >> 61) {
LABEL_186:
    }
      sub_1D0DE8CE0();
    int v25 = (char *)operator new(8 * v24);
  }
  else
  {
    int v25 = 0;
  }
  uint64_t v158 = v20 << 10;
  unint64_t v51 = &v25[8 * (v23 - v20)];
  float v52 = &v25[8 * v24];
  size_t v9 = v51;
  do
  {
    uint64_t v54 = operator new(0x1000uLL);
    if (v9 != v52) {
      goto LABEL_55;
    }
    unint64_t v165 = v25;
    if (v51 <= v25)
    {
      unint64_t v62 = (v52 - v25) >> 2;
      if (v52 == v25) {
        unint64_t v62 = 1;
      }
      if (v62 >> 61) {
        goto LABEL_186;
      }
      unint64_t v63 = v62 >> 2;
      uint64_t v161 = 8 * v62;
      id v64 = (char *)operator new(8 * v62);
      uint64_t v65 = &v64[8 * v63];
      size_t v9 = v65;
      int64_t v66 = v52 - v51;
      if (v52 == v51) {
        goto LABEL_76;
      }
      size_t v9 = &v65[v66 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v67 = v66 - 8;
      if (v67 >= 0x38)
      {
        if ((unint64_t)(&v64[8 * v63] - v51) >= 0x20)
        {
          uint64_t v69 = (v67 >> 3) + 1;
          uint64_t v70 = 8 * (v69 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v68 = &v65[v70];
          uint64_t v71 = (long long *)(v51 + 16);
          uint64_t v72 = &v64[8 * v63 + 16];
          uint64_t v73 = v69 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v74 = *v71;
            *((_OWORD *)v72 - 1) = *(v71 - 1);
            *(_OWORD *)uint64_t v72 = v74;
            v71 += 2;
            v72 += 32;
            v73 -= 4;
          }
          while (v73);
          if (v69 == (v69 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_76;
          }
          v51 += v70;
        }
        else
        {
          uint64_t v68 = &v64[8 * v63];
        }
      }
      else
      {
        uint64_t v68 = &v64[8 * v63];
      }
      do
      {
        uint64_t v75 = *(void *)v51;
        v51 += 8;
        *(void *)uint64_t v68 = v75;
        v68 += 8;
      }
      while (v68 != v9);
LABEL_76:
      float v52 = &v64[v161];
      if (v165)
      {
        int v25 = v64;
        unint64_t v51 = v65;
        operator delete(v165);
      }
      else
      {
        unint64_t v51 = v65;
        int v25 = v64;
      }
      goto LABEL_55;
    }
    uint64_t v55 = (v51 - v25) >> 3;
    if (v55 >= -1) {
      uint64_t v56 = v55 + 1;
    }
    else {
      uint64_t v56 = v55 + 2;
    }
    uint64_t v57 = v56 >> 1;
    long long v58 = v52;
    int v59 = &v51[-8 * (v56 >> 1)];
    int v60 = v58;
    int v160 = v58;
    int64_t v61 = v58 - v51;
    if (v58 != v51)
    {
      memmove(v59, v51, v58 - v51);
      int v60 = v51;
    }
    uint64_t v53 = -v57;
    size_t v9 = &v59[v61];
    unint64_t v51 = &v60[8 * v53];
    float v52 = v160;
    int v25 = v165;
LABEL_55:
    *(void *)size_t v9 = v54;
    v9 += 8;
    --v21;
  }
  while (v21);
  int v76 = *(void **)(a1 + 8);
  if (v20)
  {
    while (1)
    {
      if (v9 == v52)
      {
        int v166 = v25;
        if (v51 <= v25)
        {
          unint64_t v86 = (v52 - v25) >> 2;
          if (v52 == v25) {
            unint64_t v86 = 1;
          }
          if (v86 >> 61) {
            goto LABEL_186;
          }
          unint64_t v87 = v86 >> 2;
          uint64_t v163 = 8 * v86;
          int32x4_t v88 = (char *)operator new(8 * v86);
          uint64_t v77 = &v88[8 * v87];
          size_t v9 = v77;
          int64_t v89 = v52 - v51;
          if (v52 != v51)
          {
            size_t v9 = &v77[v89 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v90 = v89 - 8;
            if (v90 >= 0x38)
            {
              if ((unint64_t)(&v88[8 * v87] - v51) < 0x20)
              {
                long long v91 = &v88[8 * v87];
                goto LABEL_106;
              }
              uint64_t v92 = (v90 >> 3) + 1;
              uint64_t v93 = 8 * (v92 & 0x3FFFFFFFFFFFFFFCLL);
              long long v91 = &v77[v93];
              uint64_t v94 = (long long *)(v51 + 16);
              int v95 = &v88[8 * v87 + 16];
              uint64_t v96 = v92 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v97 = *v94;
                *((_OWORD *)v95 - 1) = *(v94 - 1);
                *(_OWORD *)int v95 = v97;
                v94 += 2;
                v95 += 32;
                v96 -= 4;
              }
              while (v96);
              if (v92 != (v92 & 0x3FFFFFFFFFFFFFFCLL))
              {
                v51 += v93;
                goto LABEL_106;
              }
            }
            else
            {
              long long v91 = &v88[8 * v87];
              do
              {
LABEL_106:
                uint64_t v98 = *(void *)v51;
                v51 += 8;
                *(void *)long long v91 = v98;
                v91 += 8;
              }
              while (v91 != v9);
            }
          }
          float v52 = &v88[v163];
          int v25 = v88;
          if (v166) {
            operator delete(v166);
          }
          goto LABEL_85;
        }
        uint64_t v80 = (v51 - v25) >> 3;
        if (v80 >= -1) {
          uint64_t v81 = v80 + 1;
        }
        else {
          uint64_t v81 = v80 + 2;
        }
        uint64_t v82 = v81 >> 1;
        unint64_t v83 = &v51[-8 * (v81 >> 1)];
        int v84 = v52;
        int v162 = v52;
        size_t v85 = v52 - v51;
        if (v85)
        {
          memmove(v83, v51, v85);
          int v84 = v51;
        }
        size_t v9 = &v83[v85];
        uint64_t v77 = &v84[-8 * v82];
        float v52 = v162;
        int v25 = v166;
      }
      else
      {
        uint64_t v77 = v51;
      }
LABEL_85:
      *(void *)size_t v9 = *v76;
      v9 += 8;
      int v76 = (void *)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v76;
      unint64_t v51 = v77;
      if (!--v20) {
        goto LABEL_81;
      }
    }
  }
  uint64_t v77 = v51;
LABEL_81:
  uint64_t v78 = *(void **)(a1 + 16);
  if (v78 != v76)
  {
    while (v77 != v25)
    {
LABEL_111:
      uint64_t v99 = *--v78;
      *((void *)v77 - 1) = v99;
      v77 -= 8;
      if (v78 == *(void **)(a1 + 8)) {
        goto LABEL_82;
      }
    }
    if (v9 < v52)
    {
      uint64_t v100 = (v52 - v9) >> 3;
      if (v100 >= -1) {
        uint64_t v101 = v100 + 1;
      }
      else {
        uint64_t v101 = v100 + 2;
      }
      uint64_t v102 = v101 >> 1;
      uint64_t v77 = &v25[8 * (v101 >> 1)];
      float32x4_t v103 = v25;
      if (v9 != v25)
      {
        memmove(v77, v25, v9 - v25);
        float32x4_t v103 = v9;
      }
      size_t v9 = &v103[8 * v102];
      goto LABEL_111;
    }
    unint64_t v104 = (v52 - v25) >> 2;
    if (v52 == v25) {
      unint64_t v104 = 1;
    }
    if (v104 >> 61) {
      goto LABEL_186;
    }
    unint64_t v105 = (v104 + 3) >> 2;
    uint64_t v106 = 8 * v104;
    unint64_t v107 = (char *)operator new(8 * v104);
    int64_t v108 = v107;
    uint64_t v77 = &v107[8 * v105];
    float v52 = &v107[v106];
    int64_t v109 = v9 - v25;
    BOOL v40 = v9 == v25;
    size_t v9 = v77;
    if (!v40)
    {
      size_t v9 = &v77[v109 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v110 = v109 - 8;
      int v111 = &v107[8 * v105];
      uint64_t v112 = v25;
      if (v110 >= 0x38)
      {
        int v111 = &v107[8 * v105];
        uint64_t v112 = v25;
        if ((unint64_t)(v111 - v25) >= 0x20)
        {
          uint64_t v113 = (v110 >> 3) + 1;
          uint64_t v114 = 8 * (v113 & 0x3FFFFFFFFFFFFFFCLL);
          int v111 = &v77[v114];
          char v115 = (long long *)(v25 + 16);
          unint64_t v116 = &v107[8 * v105 + 16];
          uint64_t v117 = v113 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v118 = *v115;
            *((_OWORD *)v116 - 1) = *(v115 - 1);
            *(_OWORD *)unint64_t v116 = v118;
            v115 += 2;
            v116 += 32;
            v117 -= 4;
          }
          while (v117);
          if (v113 == (v113 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_131;
          }
          uint64_t v112 = &v25[v114];
        }
      }
      do
      {
        uint64_t v119 = *(void *)v112;
        v112 += 8;
        *(void *)int v111 = v119;
        v111 += 8;
      }
      while (v111 != v9);
    }
    if (!v25)
    {
LABEL_132:
      int v25 = v108;
      goto LABEL_111;
    }
LABEL_131:
    operator delete(v25);
    goto LABEL_132;
  }
LABEL_82:
  uint64_t v79 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v77;
  *(void *)(a1 + 16) = v9;
  *(void *)(a1 + 24) = v52;
  *(void *)(a1 + 32) -= v158;
  if (v79)
  {
    operator delete(v79);
    size_t v9 = *(char **)(a1 + 16);
  }
LABEL_141:
  uint64_t v12 = *(void *)(a1 + 40);
  float v8 = *(char **)(a1 + 8);
  unint64_t v14 = *(void *)(a1 + 32) + v12;
  unint64_t v4 = a4;
LABEL_142:
  uint64_t v123 = &v8[8 * (v14 >> 10)];
  if (v9 == v8)
  {
    uint64_t v124 = 0;
    if (!v4) {
      goto LABEL_170;
    }
LABEL_144:
    uint64_t v125 = v4 + ((v124 - *(void *)v123) >> 2);
    if (v125 < 1)
    {
      unint64_t v152 = 1023 - v125;
      LOWORD(v125) = ~(1023 - v125);
      long long v126 = &v123[-8 * (v152 >> 10)];
    }
    else
    {
      long long v126 = &v123[8 * ((unint64_t)v125 >> 10)];
    }
    uint64_t v151 = *(void *)v126 + 4 * (v125 & 0x3FF);
  }
  else
  {
    uint64_t v124 = *(void *)v123 + 4 * (v14 & 0x3FF);
    if (v4) {
      goto LABEL_144;
    }
LABEL_170:
    uint64_t v151 = v124;
    long long v126 = v123;
  }
  while (v124 != v151)
  {
    uint64_t v153 = v151;
    if (v123 != v126) {
      uint64_t v153 = *(void *)v123 + 4096;
    }
    if (v124 == v153)
    {
      uint64_t v153 = v124;
    }
    else
    {
      unint64_t v154 = (_DWORD *)v124;
      do
      {
        int v155 = *a3++;
        *v154++ = v155;
        if ((int *)((char *)a3 - *a2) == (int *)4096)
        {
          int v156 = (int *)a2[1];
          ++a2;
          a3 = v156;
        }
      }
      while (v154 != (_DWORD *)v153);
      uint64_t v12 = *(void *)(a1 + 40);
    }
    v12 += (v153 - v124) >> 2;
    *(void *)(a1 + 40) = v12;
    if (v123 == v126) {
      break;
    }
    uint64_t v157 = *((void *)v123 + 1);
    v123 += 8;
    uint64_t v124 = v157;
  }
}

void sub_1D0E46FB4(uint64_t a1, unsigned int a2)
{
  if (*(void *)(a1 + 8) >= (unint64_t)a2)
  {
    *(_DWORD *)(a1 + 16) = a2;
    return;
  }
  size_t v4 = (4 * a2 + 31) & 0x7FFFFFFE0;
  size_t v5 = v4 >> 2;
  long long memptr = 0;
  malloc_type_posix_memalign(&memptr, 0x20uLL, v4, 0x49090899uLL);
  uint64_t v6 = (char *)memptr;
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (v7 >= a2) {
    uint64_t v8 = a2;
  }
  else {
    uint64_t v8 = v7;
  }
  size_t v9 = *(int **)a1;
  if (*(void **)a1 == memptr)
  {
    long long memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, (4 * v8 + 31) & 0x7FFFFFFE0, 0x49090899uLL);
    unint64_t v19 = (char *)memptr;
    if (!v8) {
      goto LABEL_31;
    }
    unint64_t v20 = (v8 - 1) & 0x3FFFFFFFFFFFFFFFLL;
    unint64_t v21 = v20 + 1;
    uint64_t v22 = v6;
    uint64_t v23 = (char *)memptr;
    if (v20 >= 7)
    {
      uint64_t v22 = v6;
      uint64_t v23 = (char *)memptr;
      if ((unint64_t)((unsigned char *)memptr - v6) >= 0x20)
      {
        uint64_t v24 = 4 * (v21 & 0x7FFFFFFFFFFFFFF8);
        uint64_t v22 = &v6[v24];
        int v25 = (char *)memptr + 16;
        uint64_t v26 = (long long *)(v6 + 16);
        uint64_t v27 = v21 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v28 = *v26;
          *(v25 - 1) = *(v26 - 1);
          *int v25 = v28;
          v25 += 2;
          v26 += 2;
          v27 -= 8;
        }
        while (v27);
        if (v21 == (v21 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_24;
        }
        uint64_t v23 = &v19[v24];
      }
    }
    do
    {
      int v29 = *(_DWORD *)v22;
      v22 += 4;
      *(_DWORD *)uint64_t v23 = v29;
      v23 += 4;
    }
    while (v23 != &v19[4 * v8]);
LABEL_24:
    BOOL v30 = v19;
    uint64_t v31 = v6;
    if (v20 >= 7)
    {
      BOOL v30 = v19;
      uint64_t v31 = v6;
      if ((unint64_t)(v6 - v19) >= 0x20)
      {
        uint64_t v32 = 4 * (v21 & 0x7FFFFFFFFFFFFFF8);
        BOOL v30 = &v19[v32];
        uint64_t v33 = v6 + 16;
        int v34 = (long long *)(v19 + 16);
        uint64_t v35 = v21 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v36 = *v34;
          *(v33 - 1) = *(v34 - 1);
          *uint64_t v33 = v36;
          v33 += 2;
          v34 += 2;
          v35 -= 8;
        }
        while (v35);
        if (v21 == (v21 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_31;
        }
        uint64_t v31 = &v6[v32];
      }
    }
    do
    {
      int v37 = *(_DWORD *)v30;
      v30 += 4;
      *(_DWORD *)uint64_t v31 = v37;
      v31 += 4;
    }
    while (v31 != &v6[4 * v8]);
LABEL_31:
    free(v19);
    size_t v9 = *(int **)a1;
    goto LABEL_32;
  }
  if (v8)
  {
    unint64_t v10 = (v8 - 1) & 0x3FFFFFFFFFFFFFFFLL;
    uint64_t v11 = *(int **)a1;
    uint64_t v12 = (char *)memptr;
    if (v10 >= 7)
    {
      uint64_t v11 = *(int **)a1;
      uint64_t v12 = (char *)memptr;
      if ((unint64_t)((unsigned char *)memptr - (unsigned char *)v9) >= 0x20)
      {
        uint64_t v13 = 0;
        uint64_t v14 = (v10 + 1) & 0x7FFFFFFFFFFFFFF8;
        uint64_t v11 = &v9[v14];
        uint64_t v15 = v14;
        do
        {
          BOOL v16 = &v6[v13 * 4];
          long long v17 = *(_OWORD *)&v9[v13 + 4];
          *(_OWORD *)BOOL v16 = *(_OWORD *)&v9[v13];
          *((_OWORD *)v16 + 1) = v17;
          v13 += 8;
          v15 -= 8;
        }
        while (v15);
        if (v10 + 1 == v14) {
          goto LABEL_32;
        }
        uint64_t v12 = &v6[4 * v14];
      }
    }
    do
    {
      int v18 = *v11++;
      *(_DWORD *)uint64_t v12 = v18;
      v12 += 4;
    }
    while (v12 != &v6[4 * v8]);
  }
LABEL_32:
  *(void *)a1 = v6;
  *(void *)(a1 + 8) = v5;
  *(_DWORD *)(a1 + 16) = a2;
  free(v9);
}

void sub_1D0E47208(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    unint64_t v3 = *(void *)(a1 + 32);
    size_t v4 = *(void ***)(a1 + 8);
    if (v3 >= 0x155)
    {
      operator delete(*v4);
      size_t v4 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v4;
      uint64_t v2 = *(void *)(a1 + 40);
      unint64_t v3 = *(void *)(a1 + 32) - 341;
      *(void *)(a1 + 32) = v3;
    }
    uint64_t v5 = *(void *)(a1 + 16);
    uint64_t v6 = 341 * ((v5 - (uint64_t)v4) >> 3) - 1;
    if ((void **)v5 == v4) {
      uint64_t v6 = 0;
    }
    if (v6 - (v2 + v3) >= 0x155)
    {
      operator delete(*(void **)(v5 - 8));
      size_t v4 = *(void ***)(a1 + 8);
      uint64_t v5 = *(void *)(a1 + 16) - 8;
      *(void *)(a1 + 16) = v5;
    }
  }
  else
  {
    size_t v4 = *(void ***)(a1 + 16);
    if (v4 != *(void ***)(a1 + 8))
    {
      do
      {
        operator delete(*(v4 - 1));
        unsigned int v7 = *(void ***)(a1 + 8);
        size_t v4 = (void **)(*(void *)(a1 + 16) - 8);
        *(void *)(a1 + 16) = v4;
      }
      while (v4 != v7);
    }
    *(void *)(a1 + 32) = 0;
    uint64_t v5 = (uint64_t)v4;
  }
  uint64_t v8 = *(void **)a1;
  uint64_t v9 = v5 - (void)v4;
  unint64_t v10 = (v5 - (uint64_t)v4) >> 3;
  if (v10 < (uint64_t)(*(void *)(a1 + 24) - *(void *)a1) >> 3)
  {
    if ((void **)v5 == v4)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 8 * v10;
      goto LABEL_24;
    }
    if (v9 < 0) {
      sub_1D0DE8CE0();
    }
    uint64_t v11 = operator new(v5 - (void)v4);
    uint64_t v12 = (uint64_t)&v11[v10];
    if ((unint64_t)(v9 - 8) < 0x18)
    {
      BOOL v16 = v11;
    }
    else if ((unint64_t)((char *)v11 - (char *)v4) < 0x20)
    {
      BOOL v16 = v11;
    }
    else
    {
      uint64_t v13 = 0;
      unint64_t v14 = ((unint64_t)(v9 - 8) >> 3) + 1;
      uint64_t v15 = v14 & 0x3FFFFFFFFFFFFFFCLL;
      BOOL v16 = &v11[v15];
      uint64_t v17 = v14 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        int v18 = &v11[v13];
        long long v19 = *(_OWORD *)&v4[v13 + 2];
        *int v18 = *(_OWORD *)&v4[v13];
        v18[1] = v19;
        v13 += 4;
        v17 -= 4;
      }
      while (v17);
      if (v14 == (v14 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_24:
        *(void *)a1 = v11;
        *(void *)(a1 + 8) = v11;
        *(void *)(a1 + 16) = v12;
        *(void *)(a1 + 24) = v12;
        if (v8)
        {
          operator delete(v8);
        }
        return;
      }
      size_t v4 = (void **)((char *)v4 + v15 * 8);
    }
    do
    {
      unint64_t v20 = *v4++;
      *v16++ = v20;
    }
    while (v16 != (void *)v12);
    goto LABEL_24;
  }
}

void sub_1D0E473E0(uint64_t a1)
{
}

void sub_1D0E473E8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4BB8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E4743C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4BB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

float *sub_1D0E4745C(float *result, uint64_t a2)
{
  uint64_t v2 = result;
  unint64_t v3 = *(float **)a2;
  if (*(float **)a2 == result
    || (uint64_t v4 = *(void *)(a2 + 8),
        uint64_t v5 = *(float **)v4,
        (float *)(*(void *)v4 - 4 * *(unsigned int *)(v4 + 12)) == result))
  {
    int v7 = 0;
    uint64_t v6 = 0;
    uint64_t result = (float *)sub_1D0E4745C(&v6);
    *(void *)uint64_t v2 = v6;
    *((_DWORD *)v2 + 2) = v7;
  }
  else
  {
    *uint64_t result = (float)((float)((float)(*v3 * *v5) + 0.0) + (float)(v3[3] * v5[1])) + (float)(v3[6] * v5[2]);
    result[1] = (float)((float)((float)(v3[1] * *v5) + 0.0) + (float)(v3[4] * v5[1])) + (float)(v3[7] * v5[2]);
    result[2] = (float)((float)((float)(v3[2] * *v5) + 0.0) + (float)(v3[5] * v5[1])) + (float)(v3[8] * v5[2]);
  }
  return result;
}

float *sub_1D0E4753C(float *result, float *a2, float *a3)
{
  if (a3 != a2)
  {
    while (1)
    {
      unint64_t v3 = a3 - result;
      if (v3 < 2) {
        return result;
      }
      if (v3 == 3)
      {
        float v40 = *result;
        float v41 = result[1];
        float v42 = *(a3 - 1);
        if (v41 >= *result)
        {
          if (v42 < v41)
          {
            result[1] = v42;
            *(a3 - 1) = v41;
            float v52 = *result;
            float v51 = result[1];
            if (v51 < *result)
            {
              *uint64_t result = v51;
              result[1] = v52;
            }
          }
        }
        else if (v42 >= v41)
        {
          *uint64_t result = v41;
          result[1] = v40;
          float v53 = *(a3 - 1);
          if (v53 < v40)
          {
            result[1] = v53;
            *(a3 - 1) = v40;
          }
        }
        else
        {
          *uint64_t result = v42;
          *(a3 - 1) = v40;
        }
        return result;
      }
      if (v3 == 2)
      {
        float v38 = *(a3 - 1);
        float v39 = *result;
        if (v38 < *result)
        {
          *uint64_t result = v38;
          *(a3 - 1) = v39;
        }
        return result;
      }
      if ((char *)a3 - (char *)result <= 31)
      {
        while (result != a3 - 1)
        {
          size_t v43 = result++;
          if (v43 != a3 && result != a3)
          {
            float v44 = *v43;
            float v45 = *v43;
            uint64_t v46 = result;
            uint64_t v47 = v43;
            uint64_t v48 = result;
            do
            {
              float v49 = *v48++;
              float v50 = v49;
              if (v49 < v45)
              {
                float v45 = v50;
                uint64_t v47 = v46;
              }
              uint64_t v46 = v48;
            }
            while (v48 != a3);
            if (v47 != v43)
            {
              *size_t v43 = *v47;
              *uint64_t v47 = v44;
            }
          }
        }
        return result;
      }
      uint64_t v4 = &result[v3 >> 1];
      uint64_t v5 = a3 - 1;
      float v6 = *(a3 - 1);
      float v7 = *v4;
      float v8 = *result;
      if (*v4 < *result) {
        break;
      }
      if (v6 < v7)
      {
        float *v4 = v6;
        *uint64_t v5 = v7;
        float v9 = *result;
        if (*v4 < *result)
        {
          *uint64_t result = *v4;
          float *v4 = v9;
LABEL_14:
          int v10 = 2;
          goto LABEL_17;
        }
        goto LABEL_15;
      }
      int v10 = 0;
LABEL_17:
      float v11 = *result;
      if (*result < *v4)
      {
LABEL_22:
        BOOL v16 = result + 1;
        if (result + 1 >= v5)
        {
          long long v19 = result + 1;
        }
        else
        {
          uint64_t v17 = result + 1;
          while (1)
          {
            float v18 = *v4;
            do
            {
              long long v19 = v17;
              float v20 = *v17++;
              float v21 = v20;
            }
            while (v20 < v18);
            do
            {
              float v22 = *--v5;
              float v23 = v22;
            }
            while (v22 >= v18);
            if (v19 >= v5) {
              break;
            }
            *long long v19 = v23;
            *uint64_t v5 = v21;
            ++v10;
            if (v4 == v19) {
              uint64_t v4 = v5;
            }
          }
        }
        if (v19 != v4)
        {
          float v24 = *v19;
          if (*v4 < *v19)
          {
            *long long v19 = *v4;
            float *v4 = v24;
            ++v10;
          }
        }
        if (v19 == a2) {
          return result;
        }
        if (!v10)
        {
          if (v19 <= a2)
          {
            BOOL v30 = v19 + 1;
            while (v30 != a3)
            {
              float v32 = *(v30 - 1);
              float v31 = *v30++;
              if (v31 < v32) {
                goto LABEL_37;
              }
            }
          }
          else
          {
            while (v16 != v19)
            {
              float v27 = *(v16 - 1);
              float v26 = *v16++;
              if (v26 < v27) {
                goto LABEL_37;
              }
            }
          }
          return result;
        }
LABEL_37:
        if (v19 <= a2)
        {
          int v25 = v19 + 1;
        }
        else
        {
          a3 = v19;
          int v25 = result;
        }
      }
      else
      {
        uint64_t v12 = a3 - 2;
        while (v12 != result)
        {
          uint64_t v13 = v12;
          float v14 = *v12--;
          float v15 = v14;
          if (v14 < *v4)
          {
            *uint64_t result = v15;
            float *v13 = v11;
            ++v10;
            uint64_t v5 = v13;
            goto LABEL_22;
          }
        }
        long long v28 = result + 1;
        if (v11 >= *v5)
        {
          if (v28 == v5) {
            return result;
          }
          while (1)
          {
            float v29 = *v28;
            if (v11 < *v28) {
              break;
            }
            if (++v28 == v5) {
              return result;
            }
          }
          *v28++ = *v5;
          *uint64_t v5 = v29;
        }
        if (v28 == v5) {
          return result;
        }
        while (1)
        {
          float v33 = *result;
          do
          {
            int v25 = v28;
            float v34 = *v28++;
            float v35 = v34;
          }
          while (v33 >= v34);
          do
          {
            float v36 = *--v5;
            float v37 = v36;
          }
          while (v33 < v36);
          if (v25 >= v5) {
            break;
          }
          *int v25 = v37;
          *uint64_t v5 = v35;
        }
        if (v25 > a2) {
          return result;
        }
      }
      uint64_t result = v25;
      if (a3 == a2) {
        return result;
      }
    }
    if (v6 >= v7)
    {
      *uint64_t result = v7;
      float *v4 = v8;
      if (*v5 < v8)
      {
        float *v4 = *v5;
        *uint64_t v5 = v8;
        goto LABEL_14;
      }
    }
    else
    {
      *uint64_t result = v6;
      *uint64_t v5 = v8;
    }
LABEL_15:
    int v10 = 1;
    goto LABEL_17;
  }
  return result;
}

uint64_t sub_1D0E4789C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 56) + 16))();
}

uint64_t sub_1D0E478C8()
{
  return 1;
}

void sub_1D0E478D0(uint64_t a1, uint64_t ***a2, void *a3)
{
  uint64_t v561 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void ****)(*(void *)(a1 + 8) + 8);
  float v6 = *v5;
  if (*((unsigned char *)*v5 + 176))
  {
    float v7 = (std::mutex *)(v6 + 14);
    *(void *)__luint64_t k = v6 + 14;
    __lk[8] = 1;
    std::mutex::lock((std::mutex *)(v6 + 14));
    if (*((int *)*v5 + 26) < 1)
    {
LABEL_7:
      std::mutex::unlock(v7);
      float v6 = *v5;
      goto LABEL_8;
    }
    float v8 = (std::condition_variable *)(*v5 + 23);
    do
    {
      std::condition_variable::wait(v8, (std::unique_lock<std::mutex> *)__lk);
      float v6 = *v5;
    }
    while (*((_DWORD *)*v5 + 26));
    if (__lk[8])
    {
      float v7 = *(std::mutex **)__lk;
      goto LABEL_7;
    }
  }
LABEL_8:
  float v9 = (std::mutex *)(v6 + 3);
  std::mutex::lock((std::mutex *)(v6 + 3));
  int v10 = *v5;
  float v11 = (char *)**v5;
  float v556 = v11;
  *int v10 = 0;
  long long v557 = *(_OWORD *)(v10 + 1);
  float v546 = (char *)v557;
  v10[1] = 0;
  v10[2] = 0;
  std::mutex::unlock(v9);
  if (v11 != v546)
  {
    unint64_t v12 = v546 - v11 - 16;
    uint64_t v13 = v11;
    if (v12 < 0x10) {
      goto LABEL_846;
    }
    uint64_t v14 = (v12 >> 4) + 1;
    uint64_t v13 = &v11[16 * (v14 & 0x1FFFFFFFFFFFFFFELL)];
    float v15 = (uint64_t *)(v11 + 16);
    uint64_t v16 = v14 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      uint64_t v17 = *(v15 - 2);
      uint64_t v18 = *v15;
      v15 += 4;
      uint64_t v19 = **(void **)(v18 + 32);
      *(unsigned char *)(**(void **)(v17 + 32) + 168) = 0;
      *(unsigned char *)(v19 + 168) = 0;
      v16 -= 2;
    }
    while (v16);
    if (v14 != (v14 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_846:
      do
      {
        uint64_t v20 = *(void *)v13;
        v13 += 16;
        *(unsigned char *)(**(void **)(v20 + 32) + 168) = 0;
      }
      while (v13 != v546);
    }
  }
  float v21 = (char *)v556;
  uint64_t v534 = (char *)v557;
  if (v556 != (void *)v557)
  {
    float v532 = a3 + 2;
    float32x4_t v533 = (float *)a3;
    while (1)
    {
      uint64_t v22 = **(void **)(*(void *)v21 + 32);
      float v23 = *(const unsigned __int8 ***)(v22 + 24);
      float v24 = *(std::__shared_weak_count **)(v22 + 32);
      uint64_t v554 = v23;
      uint64_t v555 = v24;
      if (v24) {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (!v23)
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1610))
        {
          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
          __cxa_guard_release(&qword_1EB9F1610);
        }
        float v35 = (id)qword_1EB9F1620;
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__luint64_t k = 0;
          _os_log_debug_impl(&dword_1D0DBD000, v35, OS_LOG_TYPE_DEBUG, "Warning: no user for this track", __lk, 2u);
        }

        goto LABEL_663;
      }
      float v547 = (uint64_t *)v21;
      uint64_t v25 = *(void *)v21;
      int v26 = *(_DWORD *)(v25 + 120);
      if (v26 != 2) {
        break;
      }
      float v21 = (char *)v547;
      if ((*v23)[16]) {
        goto LABEL_663;
      }
      sub_1D0DF8034(v23);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
      float v36 = (id)qword_1EB9F1620;
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__luint64_t k = 0;
        _os_log_debug_impl(&dword_1D0DBD000, v36, OS_LOG_TYPE_DEBUG, "Tracking new user with no faceprint", __lk, 2u);
      }

LABEL_662:
      float v21 = (char *)v547;
LABEL_663:
      uint64_t v445 = v555;
      if (v555 && !atomic_fetch_add(&v555->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v445->__on_zero_shared)(v445);
        std::__shared_weak_count::__release_weak(v445);
      }
      v21 += 16;
      if (v21 == v534) {
        goto LABEL_692;
      }
    }
    if (!v26)
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
      float v27 = (id)qword_1EB9F1620;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        int v111 = (void *)(*v547 + 128);
        if (*(char *)(*v547 + 151) < 0) {
          int v111 = (void *)*v111;
        }
        *(_DWORD *)__luint64_t k = 136315138;
        *(void *)&__lk[4] = v111;
        _os_log_debug_impl(&dword_1D0DBD000, v27, OS_LOG_TYPE_DEBUG, "Error getting faceprint: %s.", __lk, 0xCu);
      }

      long long v28 = v554;
      if (*((void *)*v554 + 3) == *((void *)*v554 + 4)) {
        double v29 = 0.1;
      }
      else {
        double v29 = 0.5;
      }
      uint64_t v30 = *v547;
      double v31 = v29 * (double)*(int *)(*(void *)(a1 + 8) + 24) * 0.001;
      *(_DWORD *)&unsigned char buf[24] = 0;
      *(double *)int buf = v31;
      sub_1D0E75D88((CMTime *)__lk, v30, (uint64_t)buf);
      float v32 = *v28;
      int v33 = (*v28)[80];
      long long v34 = *(_OWORD *)&__lk[16];
      *((_OWORD *)v32 + 3) = *(_OWORD *)__lk;
      *((_OWORD *)v32 + 4) = v34;
      if (!v33) {
        *((unsigned char *)v32 + 80) = 1;
      }
      goto LABEL_662;
    }
    uint64_t v552 = 0;
    float v553 = 0;
    float v37 = *(uint64_t *****)(a1 + 8);
    uint64_t v550 = 0;
    float32x4_t v551 = 0;
    std::string __p = 0;
    *(void *)__luint64_t k = 0;
    *(void *)&__lk[8] = 0;
    float v38 = *v37;
    float v39 = *v38;
    float v40 = v38[1];
    if (*v38 != v40)
    {
      float v41 = INFINITY;
      while (1)
      {
        uint64_t v42 = **v39;
        unint64_t v3 = *(void *)(v42 + 24);
        size_t v43 = *(void **)(v42 + 32);
        if ((void *)v3 == v43) {
          goto LABEL_41;
        }
        float v44 = INFINITY;
        while (1)
        {
          uint64_t v46 = *(float ***)v3;
          uint64_t v47 = *(unsigned int *)(*(void *)v3 + 16);
          if (v47 == *(_DWORD *)(v25 + 112)) {
            break;
          }
          float v45 = INFINITY;
LABEL_45:
          if (v45 < v44) {
            float v44 = v45;
          }
          v3 += 8;
          if ((void *)v3 == v43)
          {
            if (v44 < v41)
            {
              int64_t v66 = *v39;
              uint64_t v65 = v39[1];
              if (v65) {
                atomic_fetch_add_explicit(v65 + 1, 1uLL, memory_order_relaxed);
              }
              unint64_t v67 = *(std::__shared_weak_count **)&__lk[8];
              *(void *)__luint64_t k = v66;
              *(void *)&__lk[8] = v65;
              if (v67 && !atomic_fetch_add(&v67->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
                std::__shared_weak_count::__release_weak(v67);
              }
              float v41 = v44;
            }
            goto LABEL_41;
          }
        }
        if (!v47)
        {
          float v50 = 0.0;
          goto LABEL_60;
        }
        uint64_t v48 = *v46;
        float v49 = *(float **)(v25 + 96);
        float v50 = **v46 * *v49;
        if (v47 != 1)
        {
          float v51 = v48 + 1;
          unint64_t v52 = (v47 + 0x3FFFFFFFFFFFFFFELL) & 0x3FFFFFFFFFFFFFFFLL;
          if (v52 < 7) {
            goto LABEL_56;
          }
          unint64_t v53 = v52 + 1;
          uint64_t v54 = 4 * (v53 & 0x7FFFFFFFFFFFFFF8);
          float v51 = (float *)((char *)v51 + v54);
          uint64_t v55 = (float32x4_t *)(v49 + 5);
          uint64_t v56 = (float32x4_t *)(v48 + 5);
          uint64_t v57 = v53 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            float32x4_t v58 = vmulq_f32(v56[-1], v55[-1]);
            float32x4_t v59 = vmulq_f32(*v56, *v55);
            float v50 = (float)((float)((float)((float)((float)((float)((float)(v50 + v58.f32[0]) + v58.f32[1]) + v58.f32[2])
                                                + v58.f32[3])
                                        + v59.f32[0])
                                + v59.f32[1])
                        + v59.f32[2])
                + v59.f32[3];
            v55 += 2;
            v56 += 2;
            v57 -= 8;
          }
          while (v57);
          if (v53 != (v53 & 0x7FFFFFFFFFFFFFF8)) {
            break;
          }
        }
LABEL_60:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1618))
        {
          sub_1D0E225B4();
        }
        float v45 = (float)(1.0 - v50) * 0.5;
        if (v45 > *(float *)(qword_1EB9F15F8 + 304)) {
          goto LABEL_45;
        }
        uint64_t v68 = v550;
        if (v550 < (void *)v551)
        {
          *uint64_t v550 = *v39;
          uint64_t v69 = v39[1];
          v68[1] = v69;
          if (v69) {
            atomic_fetch_add_explicit(v69 + 1, 1uLL, memory_order_relaxed);
          }
          unint64_t v3 = (unint64_t)(v68 + 2);
          goto LABEL_95;
        }
        uint64_t v70 = __p;
        uint64_t v71 = ((char *)v550 - (unsigned char *)__p) >> 4;
        unint64_t v72 = v71 + 1;
        if ((unint64_t)(v71 + 1) >> 60) {
          abort();
        }
        uint64_t v73 = v551 - (unsigned char *)__p;
        if ((v551 - (unsigned char *)__p) >> 3 > v72) {
          unint64_t v72 = v73 >> 3;
        }
        if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v74 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v74 = v72;
        }
        if (v74 >> 60) {
          goto LABEL_838;
        }
        uint64_t v75 = (char *)operator new(16 * v74);
        int v76 = &v75[16 * v71];
        long long v77 = *(_OWORD *)v39;
        *(_OWORD *)int v76 = *(_OWORD *)v39;
        if (*((void *)&v77 + 1))
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v77 + 1) + 8), 1uLL, memory_order_relaxed);
          uint64_t v68 = v550;
        }
        unint64_t v3 = (unint64_t)(v76 + 16);
        if (v68 == v70)
        {
          std::string __p = v76;
          float32x4_t v551 = &v75[16 * v74];
        }
        else
        {
          do
          {
            long long v78 = *((_OWORD *)v68 - 1);
            v68 -= 2;
            *((_OWORD *)v76 - 1) = v78;
            v76 -= 16;
            void *v68 = 0;
            v68[1] = 0;
          }
          while (v68 != v70);
          uint64_t v79 = v550;
          std::string __p = v76;
          uint64_t v550 = (void *)v3;
          float32x4_t v551 = &v75[16 * v74];
          while (v79 != v70)
          {
            uint64_t v80 = (std::__shared_weak_count *)*(v79 - 1);
            if (v80 && !atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
              std::__shared_weak_count::__release_weak(v80);
            }
            v79 -= 2;
          }
        }
        if (v70) {
          operator delete(v70);
        }
LABEL_95:
        uint64_t v550 = (void *)v3;
LABEL_41:
        v39 += 2;
        if (v39 == v40)
        {
          uint64_t v81 = *(void **)__lk;
          uint64_t v82 = *(std::__shared_weak_count **)&__lk[8];
          if (*(void *)&__lk[8]) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&__lk[8] + 8), 1uLL, memory_order_relaxed);
          }
          goto LABEL_99;
        }
      }
      float v49 = (float *)((char *)v49 + v54);
LABEL_56:
      int v60 = &v48[v47];
      int64_t v61 = v49 + 1;
      do
      {
        float v62 = *v51++;
        float v63 = v62;
        float v64 = *v61++;
        float v50 = v50 + (float)(v63 * v64);
      }
      while (v51 != v60);
      goto LABEL_60;
    }
    uint64_t v81 = 0;
    uint64_t v82 = 0;
    float v41 = INFINITY;
LABEL_99:
    unint64_t v83 = v553;
    uint64_t v552 = v81;
    float v553 = v82;
    if (v83 && !atomic_fetch_add(&v83->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
      std::__shared_weak_count::__release_weak(v83);
    }
    unint64_t v84 = 126 - 2 * __clz(((char *)v550 - (unsigned char *)__p) >> 4);
    if (v550 == __p) {
      uint64_t v85 = 0;
    }
    else {
      uint64_t v85 = v84;
    }
    sub_1D0DF688C((unint64_t)__p, (unint64_t)v550, v85, 1);
    unint64_t v86 = *(std::__shared_weak_count **)&__lk[8];
    if (*(void *)&__lk[8]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&__lk[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
      std::__shared_weak_count::__release_weak(v86);
    }
    unint64_t v87 = *a2;
    int32x4_t v88 = a2[1];
    while (v87 != v88)
    {
      if (*v87 != *(uint64_t **)(*v547 + 32))
      {
        uint64_t v89 = **v87;
        unint64_t v3 = *(void *)(v89 + 24);
        unint64_t v90 = *(std::__shared_weak_count **)(v89 + 32);
        if (v90) {
          atomic_fetch_add_explicit(&v90->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        *(void *)__luint64_t k = v3;
        *(void *)&__lk[8] = v90;
        if (v3)
        {
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EB9F1610))
          {
            qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
            __cxa_guard_release(&qword_1EB9F1610);
          }
          long long v91 = (id)qword_1EB9F1620;
          if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v97 = *(void *)v3 + 160;
            *(_DWORD *)int buf = 136315138;
            *(void *)&uint8_t buf[4] = v97;
            _os_log_debug_impl(&dword_1D0DBD000, v91, OS_LOG_TYPE_DEBUG, "Excluding user %s from matches, they are currently being tracked", buf, 0xCu);
          }

          uint64_t v92 = v550;
          uint64_t v93 = v550;
          if (__p != v550)
          {
            uint64_t v93 = __p;
            while (*v93 != v3)
            {
              v93 += 2;
              if (v93 == v550)
              {
                uint64_t v93 = v550;
                break;
              }
            }
          }
          if (v93 != v550)
          {
            unint64_t v3 = (unint64_t)(v93 + 2);
            if (v93 + 2 != v550)
            {
              do
              {
                uint64_t v94 = *(float ***)v3;
                if (*(void *)v3 != *(void *)__lk)
                {
                  uint64_t v95 = *(void *)(v3 + 8);
                  *(void *)unint64_t v3 = 0;
                  *(void *)(v3 + 8) = 0;
                  uint64_t v96 = (std::__shared_weak_count *)v93[1];
                  *uint64_t v93 = v94;
                  v93[1] = v95;
                  if (v96 && !atomic_fetch_add(&v96->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v96->__on_zero_shared)(v96);
                    std::__shared_weak_count::__release_weak(v96);
                  }
                  v93 += 2;
                }
                v3 += 16;
              }
              while ((void *)v3 != v92);
              uint64_t v92 = v550;
            }
          }
          sub_1D0DF7EFC((uint64_t)&__p, (uint64_t)v93, (uint64_t)v92);
          unint64_t v90 = *(std::__shared_weak_count **)&__lk[8];
        }
        if (v90 && !atomic_fetch_add(&v90->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
          std::__shared_weak_count::__release_weak(v90);
        }
      }
      v87 += 2;
    }
    if ((*v554)[16])
    {
      if (*((void *)*v554 + 3) != *((void *)*v554 + 4)) {
        goto LABEL_169;
      }
      sub_1D0DF65BC(*(void ****)(a1 + 8), (uint64_t *)&v554);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
      uint64_t v98 = (id)qword_1EB9F1620;
      if (os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v413 = *v554 + 160;
        uint64_t v414 = (uint64_t)(*(void *)(**(void **)(a1 + 8) + 8) - ***(void ***)(a1 + 8)) >> 4;
        *(_DWORD *)__luint64_t k = 136315394;
        *(void *)&__lk[4] = v413;
        *(_WORD *)&__lk[12] = 2048;
        *(void *)&__lk[14] = v414;
        _os_log_debug_impl(&dword_1D0DBD000, v98, OS_LOG_TYPE_DEBUG, "Added tracked user %s with no faceprint to DB. New DB size %zu", __lk, 0x16u);
      }
    }
    else
    {
      uint64_t v99 = (const unsigned __int8 ***)__p;
      if (__p != v550)
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1610))
        {
          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
          __cxa_guard_release(&qword_1EB9F1610);
        }
        uint64_t v100 = (id)qword_1EB9F1620;
        if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v101 = (uint64_t)(**v99 + 160);
          uint64_t v102 = *v554 + 160;
          *(_DWORD *)__luint64_t k = 136315394;
          *(void *)&__lk[4] = v101;
          *(_WORD *)&__lk[12] = 2080;
          *(void *)&__lk[14] = v102;
          _os_log_impl(&dword_1D0DBD000, v100, OS_LOG_TYPE_DEFAULT, "Found match: recognized user %s, replacing user %s", __lk, 0x16u);
        }

        uint64_t v103 = **(void **)(*v547 + 32);
        unint64_t v105 = *v99;
        unint64_t v104 = v99[1];
        if (v104) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)v104 + 1, 1uLL, memory_order_relaxed);
        }
        uint64_t v106 = *(std::__shared_weak_count **)(v103 + 32);
        *(void *)(v103 + 24) = v105;
        *(void *)(v103 + 32) = v104;
        if (v106 && !atomic_fetch_add(&v106->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
          std::__shared_weak_count::__release_weak(v106);
        }
        int64_t v108 = *v99;
        unint64_t v107 = (std::__shared_weak_count *)v99[1];
        if (v107) {
          atomic_fetch_add_explicit(&v107->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int64_t v109 = v555;
        uint64_t v554 = v108;
        uint64_t v555 = v107;
        if (v109 && !atomic_fetch_add(&v109->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v109->__on_zero_shared)(v109);
          std::__shared_weak_count::__release_weak(v109);
        }
LABEL_169:
        uint64_t v114 = (unint64_t ***)__p;
        int v541 = (unint64_t ***)v550;
        char v115 = v554;
        if ((unint64_t)((char *)v550 - (unsigned char *)__p) < 0x11)
        {
LABEL_512:
          uint64_t v304 = *v547;
          double v305 = (double)*(int *)(*(void *)(a1 + 8) + 24) * 0.001;
          *(_DWORD *)&unsigned char buf[24] = 0;
          *(double *)int buf = v305;
          sub_1D0E75D88((CMTime *)__lk, v304, (uint64_t)buf);
          uint64_t v306 = *v115;
          int v307 = (*v115)[80];
          long long v308 = *(_OWORD *)&__lk[16];
          *((_OWORD *)v306 + 3) = *(_OWORD *)__lk;
          *((_OWORD *)v306 + 4) = v308;
          if (!v307) {
            *((unsigned char *)v306 + 80) = 1;
          }
          uint64_t v309 = *v547;
          int v310 = *(_DWORD *)(*v547 + 24);
          if (v310)
          {
            if (v310 != 1)
            {
              sub_1D0E221E0();
LABEL_842:
              _os_crash();
              __break(1u);
            }
            if ((*(unsigned char *)(v309 + 12) & 1) == 0)
            {
              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&qword_1EB9F1610))
              {
                qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                __cxa_guard_release(&qword_1EB9F1610);
              }
              int v311 = (id)qword_1EB9F1620;
              if (os_log_type_enabled(v311, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)__luint64_t k = 0;
                _os_log_error_impl(&dword_1D0DBD000, v311, OS_LOG_TYPE_ERROR, "Invalid timestamp for point", __lk, 2u);
              }
LABEL_520:

LABEL_650:
              int v440 = __p;
              if (__p)
              {
                int v441 = v550;
                uint64_t v442 = __p;
                if (v550 != __p)
                {
                  do
                  {
                    uint64_t v443 = (std::__shared_weak_count *)*(v441 - 1);
                    if (v443 && !atomic_fetch_add(&v443->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v443->__on_zero_shared)(v443);
                      std::__shared_weak_count::__release_weak(v443);
                    }
                    v441 -= 2;
                  }
                  while (v441 != v440);
                  uint64_t v442 = __p;
                }
                uint64_t v550 = v440;
                operator delete(v442);
              }
              unsigned int v444 = v553;
              if (v553 && !atomic_fetch_add(&v553->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v444->__on_zero_shared)(v444);
                std::__shared_weak_count::__release_weak(v444);
              }
              goto LABEL_662;
            }
          }
          uint64_t v312 = (const void **)(v309 + 96);
          uint64_t v313 = *((void *)*v115 + 3);
          uint64_t v314 = *((void *)*v115 + 4);
          if (v313 == v314)
          {
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EB9F1610))
            {
              qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
              __cxa_guard_release(&qword_1EB9F1610);
            }
            uint64_t v323 = (id)qword_1EB9F1620;
            if (os_log_type_enabled(v323, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v412 = (uint64_t)(*v115 + 160);
              *(_DWORD *)__luint64_t k = 136315138;
              *(void *)&__lk[4] = v412;
              _os_log_debug_impl(&dword_1D0DBD000, v323, OS_LOG_TYPE_DEBUG, "%s: No cluster representation. Adding first cluster.", __lk, 0xCu);
            }

            sub_1D0E530D8();
          }
          uint64_t v315 = *(unsigned int *)(v309 + 112);
          if (v315 != *(_DWORD *)(*(void *)v313 + 16))
          {
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EB9F1610))
            {
              qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
              __cxa_guard_release(&qword_1EB9F1610);
            }
            int v311 = (id)qword_1EB9F1620;
            if (os_log_type_enabled(v311, OS_LOG_TYPE_ERROR))
            {
              int v415 = *(_DWORD *)(**((void **)*v115 + 3) + 16);
              int v416 = *(_DWORD *)(v309 + 112);
              *(_DWORD *)__luint64_t k = 67109376;
              *(_DWORD *)&__lk[4] = v416;
              *(_WORD *)&__lk[8] = 1024;
              *(_DWORD *)&__lk[10] = v415;
              _os_log_error_impl(&dword_1D0DBD000, v311, OS_LOG_TYPE_ERROR, "Point size does not match cluster dimensionality %u != %u", __lk, 0xEu);
            }
            goto LABEL_520;
          }
          unint64_t v316 = (v314 - v313) >> 3;
          if (v316 <= 1) {
            unint64_t v316 = 1;
          }
          if (v315)
          {
            uint64_t v317 = (float *)*v312;
            if (v315 == 1)
            {
              uint64_t v318 = 0;
              uint64_t v319 = 0;
              float v320 = INFINITY;
              do
              {
                uint64_t v322 = *(void *)(v313 + 8 * v318);
                if (*(_DWORD *)(v322 + 16) == 1) {
                  float v321 = (float)(1.0 - (float)(**(float **)v322 * *v317)) * 0.5;
                }
                else {
                  float v321 = INFINITY;
                }
                if (v320 > v321)
                {
                  uint64_t v319 = v318;
                  float v320 = v321;
                }
                ++v318;
              }
              while (v316 != v318);
            }
            else
            {
              unint64_t v347 = (v315 + 0x3FFFFFFFFFFFFFFELL) & 0x3FFFFFFFFFFFFFFFLL;
              uint64_t v348 = 4 * v315;
              if (v347 >= 7)
              {
                uint64_t v362 = 0;
                uint64_t v319 = 0;
                unint64_t v363 = v347 + 1;
                uint64_t v364 = 4 * (v363 & 0x7FFFFFFFFFFFFFF8);
                uint64_t v365 = v348 - v364 - 4;
                float v320 = INFINITY;
                do
                {
                  uint64_t v367 = *(void *)(v313 + 8 * v362);
                  if (*(_DWORD *)(v367 + 16) == v315)
                  {
                    int v368 = *(float **)v367;
                    uint64_t v369 = *(void *)v367 + 4;
                    float v371 = *v368;
                    uint64_t v370 = (float32x4_t *)(v368 + 5);
                    float v372 = v371 * *v317;
                    uint64_t v373 = (float32x4_t *)(v317 + 5);
                    uint64_t v374 = v363 & 0x7FFFFFFFFFFFFFF8;
                    do
                    {
                      float32x4_t v375 = vmulq_f32(v370[-1], v373[-1]);
                      float32x4_t v376 = vmulq_f32(*v370, *v373);
                      float v372 = (float)((float)((float)((float)((float)((float)((float)(v372 + v375.f32[0]) + v375.f32[1])
                                                                   + v375.f32[2])
                                                           + v375.f32[3])
                                                   + v376.f32[0])
                                           + v376.f32[1])
                                   + v376.f32[2])
                           + v376.f32[3];
                      v373 += 2;
                      v370 += 2;
                      v374 -= 8;
                    }
                    while (v374);
                    if (v363 != (v363 & 0x7FFFFFFFFFFFFFF8))
                    {
                      uint64_t v377 = (float *)(v369 + v364);
                      uint64_t v378 = &v317[(unint64_t)v364 / 4 + 1];
                      uint64_t v379 = v365;
                      do
                      {
                        float v380 = *v377++;
                        float v381 = v380;
                        float v382 = *v378++;
                        float v372 = v372 + (float)(v381 * v382);
                        v379 -= 4;
                      }
                      while (v379);
                    }
                    float v366 = (float)(1.0 - v372) * 0.5;
                  }
                  else
                  {
                    float v366 = INFINITY;
                  }
                  if (v320 > v366)
                  {
                    uint64_t v319 = v362;
                    float v320 = v366;
                  }
                  ++v362;
                }
                while (v362 != v316);
              }
              else
              {
                uint64_t v349 = 0;
                uint64_t v319 = 0;
                uint64_t v350 = v348 - 4;
                float v320 = INFINITY;
                do
                {
                  uint64_t v352 = *(void *)(v313 + 8 * v349);
                  if (*(_DWORD *)(v352 + 16) == v315)
                  {
                    float v353 = *(float **)v352;
                    float v355 = *v353;
                    uint64_t v354 = v353 + 1;
                    float v356 = v355 * *v317;
                    uint64_t v357 = v317 + 1;
                    uint64_t v358 = v350;
                    do
                    {
                      float v359 = *v354++;
                      float v360 = v359;
                      float v361 = *v357++;
                      float v356 = v356 + (float)(v360 * v361);
                      v358 -= 4;
                    }
                    while (v358);
                    float v351 = (float)(1.0 - v356) * 0.5;
                  }
                  else
                  {
                    float v351 = INFINITY;
                  }
                  if (v320 > v351)
                  {
                    uint64_t v319 = v349;
                    float v320 = v351;
                  }
                  ++v349;
                }
                while (v349 != v316);
              }
            }
          }
          else
          {
            uint64_t v324 = 0;
            uint64_t v319 = 0;
            float v320 = INFINITY;
            do
            {
              float v325 = INFINITY;
              if (!*(_DWORD *)(*(void *)(v313 + 8 * v324) + 16)) {
                float v325 = 0.5;
              }
              if (v320 > v325)
              {
                uint64_t v319 = v324;
                float v320 = v325;
              }
              ++v324;
            }
            while (v316 != v324);
          }
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1618, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EB9F1618))
          {
            sub_1D0E225B4();
          }
          if (v320 > *(float *)(qword_1EB9F15F8 + 308)) {
            sub_1D0E530D8();
          }
          uint64_t v326 = *((void *)*v115 + 3);
          uint64_t v327 = *(void *)(v326 + 8 * v319);
          uint64_t v328 = *(unsigned int *)(v327 + 16);
          if (v328 != *(_DWORD *)(v309 + 112))
          {
LABEL_639:
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EB9F1610))
            {
              qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
              __cxa_guard_release(&qword_1EB9F1610);
            }
            float32x2_t v432 = (id)qword_1EB9F1620;
            if (os_log_type_enabled(v432, OS_LOG_TYPE_DEBUG))
            {
              int v446 = *(_DWORD *)(*(void *)(*((void *)*v115 + 3) + 8 * v319) + 48);
              uint64_t v447 = (uint64_t)(*v115 + 160);
              *(_DWORD *)__luint64_t k = 136315650;
              *(void *)&__lk[4] = v447;
              *(_WORD *)&__lk[12] = 2048;
              *(void *)&__lk[14] = v319;
              *(_WORD *)&unsigned char __lk[22] = 1024;
              *(_DWORD *)&__lk[24] = v446;
              _os_log_debug_impl(&dword_1D0DBD000, v432, OS_LOG_TYPE_DEBUG, "%s: Cluster index %lu match -> adding point. Total points in cluster: %u", __lk, 0x1Cu);
            }

            uint64_t v433 = *v115;
            uint64_t v434 = (uint64_t)(*v115 + 120);
            if ((const void **)v434 != v312)
            {
              unint64_t v435 = *(unsigned int *)(v309 + 112);
              if (v435)
              {
                uint64_t v436 = (void *)*((void *)v433 + 15);
                size_t v437 = 4 * v435;
                if (*((void *)v433 + 16) < v435)
                {
                  free(v436);
                  size_t v438 = (v437 + 31) & 0x7FFFFFFE0;
                  *((void *)v433 + 15) = 0;
                  *((void *)v433 + 16) = v438 >> 2;
                  *(void *)__luint64_t k = 0;
                  malloc_type_posix_memalign((void **)__lk, 0x20uLL, v438, 0x49090899uLL);
                  uint64_t v436 = *(void **)__lk;
                  *(void *)uint64_t v434 = *(void *)__lk;
                }
                memcpy(v436, *v312, v437);
              }
              else
              {
                free(*(void **)v434);
                *(void *)uint64_t v434 = 0;
                *(void *)(v434 + 8) = 0;
              }
              *((_DWORD *)v433 + 34) = *(_DWORD *)(v309 + 112);
              uint64_t v433 = *v115;
            }
            long long v439 = *(_OWORD *)v309;
            *(_OWORD *)(v433 + 104) = *(_OWORD *)(v309 + 16);
            *(_OWORD *)(v433 + 88) = v439;
            goto LABEL_650;
          }
          float v329 = 0.0;
          float v330 = 0.0;
          if (v328)
          {
            int v331 = (char *)*v312;
            float v330 = *(float *)*v312 * *(float *)*v312;
            if (v328 != 1)
            {
              int v332 = (float *)(v331 + 4);
              unint64_t v333 = (v328 + 0x3FFFFFFFFFFFFFFELL) & 0x3FFFFFFFFFFFFFFFLL;
              if (v333 < 7) {
                goto LABEL_559;
              }
              unint64_t v334 = v333 + 1;
              uint64_t v335 = (float32x4_t *)(v331 + 20);
              uint64_t v336 = v334 & 0x7FFFFFFFFFFFFFF8;
              do
              {
                float32x4_t v337 = vmulq_f32(v335[-1], v335[-1]);
                float32x4_t v338 = vmulq_f32(*v335, *v335);
                float v330 = (float)((float)((float)((float)((float)((float)((float)(v330 + v337.f32[0]) + v337.f32[1])
                                                             + v337.f32[2])
                                                     + v337.f32[3])
                                             + v338.f32[0])
                                     + v338.f32[1])
                             + v338.f32[2])
                     + v338.f32[3];
                v335 += 2;
                v336 -= 8;
              }
              while (v336);
              if (v334 != (v334 & 0x7FFFFFFFFFFFFFF8))
              {
                v332 += v334 & 0x7FFFFFFFFFFFFFF8;
LABEL_559:
                uint64_t v339 = (float *)&v331[4 * v328];
                do
                {
                  float v340 = *v332++;
                  float v330 = v330 + (float)(v340 * v340);
                }
                while (v332 != v339);
              }
            }
          }
          unint64_t v341 = *(float **)(v327 + 24);
          unint64_t v3 = *(unsigned int *)(v327 + 40);
          if (!v3) {
            goto LABEL_609;
          }
          float v342 = 1.0 / sqrtf(v330);
          int v343 = &v341[v3];
          int v344 = (float *)*v312;
          unint64_t v345 = (v3 - 1) & 0x3FFFFFFFFFFFFFFFLL;
          if (v345 >= 7)
          {
            if (v341 >= &v344[v3] || (uint64_t v346 = *(float **)(v327 + 24), v344 >= &v341[v3]))
            {
              unint64_t v384 = v345 + 1;
              uint64_t v385 = v384 & 0x7FFFFFFFFFFFFFF8;
              uint64_t v346 = &v341[v385];
              int v386 = (float32x4_t *)(v344 + 4);
              int v387 = (float32x4_t *)(v341 + 4);
              uint64_t v388 = v384 & 0x7FFFFFFFFFFFFFF8;
              do
              {
                float32x4_t v389 = vaddq_f32(vmulq_n_f32(*v386, v342), *v387);
                v387[-1] = vaddq_f32(vmulq_n_f32(v386[-1], v342), v387[-1]);
                *int v387 = v389;
                v386 += 2;
                v387 += 2;
                v388 -= 8;
              }
              while (v388);
              if (v384 == (v384 & 0x7FFFFFFFFFFFFFF8))
              {
LABEL_602:
                float v329 = *v341 * *v341;
                if (v3 == 1) {
                  goto LABEL_609;
                }
                uint64_t v391 = v341 + 1;
                unint64_t v392 = (v3 + 0x3FFFFFFFFFFFFFFELL) & 0x3FFFFFFFFFFFFFFFLL;
                if (v392 >= 7)
                {
                  unint64_t v393 = v392 + 1;
                  uint64_t v394 = (float32x4_t *)(v341 + 5);
                  uint64_t v395 = v393 & 0x7FFFFFFFFFFFFFF8;
                  do
                  {
                    float32x4_t v396 = vmulq_f32(v394[-1], v394[-1]);
                    float32x4_t v397 = vmulq_f32(*v394, *v394);
                    float v329 = (float)((float)((float)((float)((float)((float)((float)(v329 + v396.f32[0]) + v396.f32[1])
                                                                 + v396.f32[2])
                                                         + v396.f32[3])
                                                 + v397.f32[0])
                                         + v397.f32[1])
                                 + v397.f32[2])
                         + v397.f32[3];
                    v394 += 2;
                    v395 -= 8;
                  }
                  while (v395);
                  if (v393 == (v393 & 0x7FFFFFFFFFFFFFF8))
                  {
LABEL_609:
                    float v399 = 1.0 / sqrtf(v329);
                    uint64_t v400 = *(float **)v327;
                    if (v3 == v328) {
                      goto LABEL_610;
                    }
                    if (v341 != v400)
                    {
                      *(_DWORD *)(v327 + 16) = v3;
                      if (v3)
                      {
                        if (*(void *)(v327 + 8) >= v3)
                        {
                          v402 = &v400[v3];
                          goto LABEL_612;
                        }
                        float v542 = v399;
                        free(v400);
                        size_t v411 = (4 * v3 + 31) & 0x7FFFFFFE0;
                        *(void *)uint64_t v327 = 0;
                        *(void *)(v327 + 8) = v411 >> 2;
                        *(void *)__luint64_t k = 0;
                        malloc_type_posix_memalign((void **)__lk, 0x20uLL, v411, 0x49090899uLL);
                        float v399 = v542;
                        uint64_t v400 = *(float **)__lk;
                        *(void *)uint64_t v327 = *(void *)__lk;
                      }
                      else
                      {
                        float v544 = v399;
                        free(v400);
                        float v399 = v544;
                        uint64_t v400 = 0;
                        *(void *)uint64_t v327 = 0;
                        *(void *)(v327 + 8) = 0;
                      }
LABEL_610:
                      uint64_t v401 = *(unsigned int *)(v327 + 16);
                      if (!v401) {
                        goto LABEL_638;
                      }
                      v402 = &v400[v401];
                      unint64_t v341 = *(float **)(v327 + 24);
LABEL_612:
                      unint64_t v403 = (char *)v402 - (char *)v400 - 4;
                      if (v403 < 0x1C)
                      {
                        uint64_t v406 = v400;
                      }
                      else if ((unint64_t)((char *)v400 - (char *)v341) < 0x20)
                      {
                        uint64_t v406 = v400;
                      }
                      else
                      {
                        uint64_t v404 = (v403 >> 2) + 1;
                        uint64_t v405 = v404 & 0x7FFFFFFFFFFFFFF8;
                        uint64_t v406 = &v400[v405];
                        uint64_t v407 = (float32x4_t *)(v341 + 4);
                        v408 = (float32x4_t *)(v400 + 4);
                        uint64_t v409 = v404 & 0x7FFFFFFFFFFFFFF8;
                        do
                        {
                          float32x4_t v410 = vmulq_n_f32(*v407, v399);
                          v408[-1] = vmulq_n_f32(v407[-1], v399);
                          float32x4_t *v408 = v410;
                          v407 += 2;
                          v408 += 2;
                          v409 -= 8;
                        }
                        while (v409);
                        if (v404 == (v404 & 0x7FFFFFFFFFFFFFF8)) {
                          goto LABEL_638;
                        }
                        unint64_t v341 = (float *)((char *)v341 + v405 * 4);
                      }
                      do
                      {
                        float v429 = *v341++;
                        *v406++ = v399 * v429;
                      }
                      while (v406 != v402);
LABEL_638:
                      ++*(_DWORD *)(*(void *)(v326 + 8 * v319) + 48);
                      goto LABEL_639;
                    }
                    *(void *)__luint64_t k = 0;
                    float v543 = v399;
                    malloc_type_posix_memalign((void **)__lk, 0x20uLL, (4 * v3 + 31) & 0x7FFFFFFE0, 0x49090899uLL);
                    uint64_t v418 = *(void *)__lk;
                    uint64_t v419 = *(unsigned int *)(v327 + 40);
                    if (v419)
                    {
                      uint64_t v420 = *(float **)(v327 + 24);
                      unint64_t v421 = (v419 - 1) & 0x3FFFFFFFFFFFFFFFLL;
                      if (v421 < 7)
                      {
                        int v422 = *(float **)__lk;
                      }
                      else
                      {
                        int v422 = *(float **)__lk;
                        if (*(void *)__lk - (void)v420 >= 0x20uLL)
                        {
                          unint64_t v423 = v421 + 1;
                          uint64_t v424 = 4 * (v423 & 0x7FFFFFFFFFFFFFF8);
                          int v422 = (float *)(*(void *)__lk + v424);
                          uint64_t v425 = (float32x4_t *)(v420 + 4);
                          uint64_t v426 = (float32x4_t *)(*(void *)__lk + 16);
                          uint64_t v427 = v423 & 0x7FFFFFFFFFFFFFF8;
                          do
                          {
                            float32x4_t v428 = vmulq_n_f32(*v425, v543);
                            v426[-1] = vmulq_n_f32(v425[-1], v543);
                            *uint64_t v426 = v428;
                            v425 += 2;
                            v426 += 2;
                            v427 -= 8;
                          }
                          while (v427);
                          if (v423 == (v423 & 0x7FFFFFFFFFFFFFF8)) {
                            goto LABEL_637;
                          }
                          uint64_t v420 = (float *)((char *)v420 + v424);
                        }
                      }
                      do
                      {
                        float v430 = *v420++;
                        *v422++ = v543 * v430;
                      }
                      while (v422 != (float *)(v418 + 4 * v419));
                    }
LABEL_637:
                    uint64_t v431 = *(float **)v327;
                    *(void *)uint64_t v327 = v418;
                    *(void *)(v327 + 8) = ((4 * v3 + 31) & 0x7FFFFFFE0) >> 2;
                    *(_DWORD *)(v327 + 16) = v419;
                    free(v431);
                    goto LABEL_638;
                  }
                  v391 += v393 & 0x7FFFFFFFFFFFFFF8;
                }
                do
                {
                  float v398 = *v391++;
                  float v329 = v329 + (float)(v398 * v398);
                }
                while (v391 != v343);
                goto LABEL_609;
              }
              int v344 = (float *)((char *)v344 + v385 * 4);
            }
          }
          else
          {
            uint64_t v346 = *(float **)(v327 + 24);
          }
          do
          {
            float v390 = *v344++;
            *uint64_t v346 = (float)(v342 * v390) + *v346;
            ++v346;
          }
          while (v346 != v343);
          goto LABEL_602;
        }
        memset(__lk, 0, sizeof(__lk));
        v559[0] = 1.0;
        unint64_t v116 = (unint64_t *)*v554;
        if (!(*v554)[16]) {
          goto LABEL_842;
        }
        uint64_t v535 = (unint64_t *)*v554;
        if (__p == v550) {
          goto LABEL_407;
        }
        while (1)
        {
          uint64_t v117 = *v114;
          long long v118 = **v114;
          if (!*((unsigned char *)v118 + 16)) {
            goto LABEL_836;
          }
          BOOL v119 = *v118 == *v116 && v118[1] == v116[1];
          if (v119) {
            goto LABEL_176;
          }
          unint64_t v120 = bswap64(*v116);
          unint64_t v121 = bswap64(*v118);
          if (v120 == v121 && (v120 = bswap64(v116[1]), unint64_t v121 = bswap64(v118[1]), v120 == v121)) {
            int v122 = 0;
          }
          else {
            int v122 = v120 < v121 ? -1 : 1;
          }
          uint64_t v123 = *(void *)(a1 + 8);
          BOOL v124 = v122 < 0;
          uint64_t v125 = v122 < 0 ? v116 : **v114;
          long long v126 = v124 ? **v114 : v116;
          *(_OWORD *)int buf = *(_OWORD *)v125;
          *(_OWORD *)&uint8_t buf[16] = *(_OWORD *)v126;
          int v129 = *(void **)(v123 + 40);
          unint64_t v127 = (void *)(v123 + 40);
          uint64_t v128 = v129;
          if (!v129) {
            break;
          }
          uint64_t v130 = v127;
          do
          {
            unint64_t v136 = bswap64(*(void *)((char *)v128 + 25));
            unint64_t v137 = bswap64(*(unint64_t *)buf);
            if (v136 == v137
              && (unint64_t v136 = bswap64(*(void *)((char *)v128 + 33)),
                  unint64_t v137 = bswap64(*(unint64_t *)&buf[8]),
                  v136 == v137))
            {
              int v138 = 0;
            }
            else if (v136 < v137)
            {
              int v138 = -1;
            }
            else
            {
              int v138 = 1;
            }
            if (v138 < 0) {
              char v133 = -1;
            }
            else {
              char v133 = 1;
            }
            if (!v138)
            {
              unint64_t v139 = bswap64(*(void *)((char *)v128 + 41));
              unint64_t v140 = bswap64(*(unint64_t *)&buf[16]);
              if (v139 == v140
                && (unint64_t v139 = bswap64(*(void *)((char *)v128 + 49)),
                    unint64_t v140 = bswap64(*(unint64_t *)&buf[24]),
                    v139 == v140))
              {
                int v131 = 0;
              }
              else
              {
                int v131 = v139 < v140 ? -1 : 1;
              }
              BOOL v132 = v131 == 0;
              char v133 = v131 < 0 ? -1 : 1;
              if (v132) {
                char v133 = 0;
              }
            }
            BOOL v134 = v133 < 0;
            if (v133 >= 0) {
              uint64_t v135 = v128;
            }
            else {
              uint64_t v135 = v128 + 1;
            }
            if (!v134) {
              uint64_t v130 = v128;
            }
            uint64_t v128 = (void *)*v135;
          }
          while (*v135);
          if (v130 == v127) {
            break;
          }
          unint64_t v141 = bswap64(*(unint64_t *)buf);
          unint64_t v142 = bswap64(*(void *)((char *)v130 + 25));
          if (v141 == v142
            && (unint64_t v141 = bswap64(*(unint64_t *)&buf[8]),
                unint64_t v142 = bswap64(*(void *)((char *)v130 + 33)),
                v141 == v142))
          {
            unint64_t v144 = bswap64(*(unint64_t *)&buf[16]);
            unint64_t v145 = bswap64(*(void *)((char *)v130 + 41));
            if (v144 == v145)
            {
              unint64_t v144 = bswap64(*(unint64_t *)&buf[24]);
              unint64_t v145 = bswap64(*(void *)((char *)v130 + 49));
              if (v144 == v145) {
                goto LABEL_176;
              }
            }
            int v143 = v144 < v145 ? -1 : 1;
          }
          else
          {
            int v143 = v141 < v142 ? -1 : 1;
          }
          if (v143 < 0) {
            break;
          }
LABEL_176:
          v114 += 2;
          if (v114 == v541)
          {
            if (*(void *)&__lk[24])
            {
              int v247 = *(uint64_t ***)(a1 + 8);
              uint64_t v248 = *v247;
              uint64_t v249 = **v247;
              uint64_t v250 = (*v247)[1];
              if (v249 == v250)
              {
                uint64_t v250 = **v247;
              }
              else
              {
                uint64_t v252 = *(void *)__lk;
                unint64_t v251 = *(void *)&__lk[8];
                while (1)
                {
                  uint64_t v253 = **(void **)v249;
                  if (*(unsigned char *)(v253 + 16))
                  {
                    if (sub_1D0DF7E18(v252, v251, (void *)v253)) {
                      break;
                    }
                  }
                  v249 += 16;
                  if (v249 == v250)
                  {
                    uint64_t v249 = v250;
                    goto LABEL_413;
                  }
                }
                if (v249 != v250)
                {
                  uint64_t v254 = v249 + 16;
                  if (v249 + 16 != v250)
                  {
                    do
                    {
                      uint64_t v255 = **(void **)v254;
                      if (!*(unsigned char *)(v255 + 16)
                        || !sub_1D0DF7E18(*(uint64_t *)__lk, *(unint64_t *)&__lk[8], (void *)v255))
                      {
                        long long v256 = *(_OWORD *)v254;
                        *(void *)uint64_t v254 = 0;
                        *(void *)(v254 + 8) = 0;
                        float v257 = *(std::__shared_weak_count **)(v249 + 8);
                        *(_OWORD *)uint64_t v249 = v256;
                        if (v257 && !atomic_fetch_add(&v257->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v257->__on_zero_shared)(v257);
                          std::__shared_weak_count::__release_weak(v257);
                        }
                        v249 += 16;
                      }
                      v254 += 16;
                    }
                    while (v254 != v250);
                    uint64_t v248 = *v247;
                    uint64_t v250 = (*v247)[1];
                  }
                }
              }
LABEL_413:
              sub_1D0DF7EFC((uint64_t)v248, v249, v250);
              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&qword_1EB9F1610))
              {
                qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                __cxa_guard_release(&qword_1EB9F1610);
              }
              uint64_t v258 = (id)qword_1EB9F1620;
              if (os_log_type_enabled(v258, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v417 = ((*v247)[1] - **v247) >> 4;
                *(_DWORD *)int buf = 134217984;
                *(void *)&uint8_t buf[4] = v417;
                _os_log_debug_impl(&dword_1D0DBD000, v258, OS_LOG_TYPE_DEBUG, "Remaining number of user identities in db: %lu", buf, 0xCu);
              }
              goto LABEL_416;
            }
LABEL_407:
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EB9F1610))
            {
              qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
              __cxa_guard_release(&qword_1EB9F1610);
            }
            uint64_t v258 = (id)qword_1EB9F1620;
            if (os_log_type_enabled(v258, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)int buf = 0;
              _os_log_impl(&dword_1D0DBD000, v258, OS_LOG_TYPE_INFO, "No user identities to remove", buf, 2u);
            }
LABEL_416:

            uint64_t v259 = *(void *)&__lk[24];
            if (!*(void *)&__lk[24])
            {
LABEL_507:
              int v301 = *(void **)&__lk[16];
              if (*(void *)&__lk[16])
              {
                do
                {
                  int v302 = (void *)*v301;
                  operator delete(v301);
                  int v301 = v302;
                }
                while (v302);
              }
              uint64_t v303 = *(void **)__lk;
              *(void *)__luint64_t k = 0;
              if (v303) {
                operator delete(v303);
              }
              char v115 = v554;
              goto LABEL_512;
            }
            unint64_t v260 = v535[1] ^ *v535;
            unint64_t v261 = *((void *)v533 + 1);
            if (v261)
            {
              uint8x8_t v262 = (uint8x8_t)vcnt_s8((int8x8_t)v261);
              v262.i16[0] = vaddlv_u8(v262);
              if (v262.u32[0] > 1uLL)
              {
                unint64_t v3 = v535[1] ^ *v535;
                if (v260 >= v261) {
                  unint64_t v3 = v260 % v261;
                }
              }
              else
              {
                unint64_t v3 = (v261 - 1) & v260;
              }
              uint64_t v263 = *(void **)(*(void *)v533 + 8 * v3);
              if (v263)
              {
                uint64_t v264 = (void *)*v263;
                if (v264)
                {
                  if (v262.u32[0] < 2uLL)
                  {
                    while (1)
                    {
                      uint64_t v268 = v264[1];
                      if (v268 == v260)
                      {
                        if (v264[2] == *v535 && v264[3] == v535[1]) {
                          goto LABEL_507;
                        }
                      }
                      else if ((v268 & (v261 - 1)) != v3)
                      {
                        goto LABEL_443;
                      }
                      uint64_t v264 = (void *)*v264;
                      if (!v264) {
                        goto LABEL_443;
                      }
                    }
                  }
                  do
                  {
                    unint64_t v266 = v264[1];
                    if (v266 == v260)
                    {
                      if (v264[2] == *v535 && v264[3] == v535[1]) {
                        goto LABEL_507;
                      }
                    }
                    else
                    {
                      if (v266 >= v261) {
                        v266 %= v261;
                      }
                      if (v266 != v3) {
                        break;
                      }
                    }
                    uint64_t v264 = (void *)*v264;
                  }
                  while (v264);
                }
              }
            }
LABEL_443:
            int32x4_t v269 = operator new(0x48uLL);
            uint64_t v270 = v269;
            *(void *)int buf = v269;
            *(void *)&uint8_t buf[8] = v532;
            *int32x4_t v269 = 0;
            v269[1] = v260;
            *((_OWORD *)v269 + 1) = *(_OWORD *)v535;
            uint64_t v271 = *(void *)__lk;
            unint64_t v272 = *(void *)&__lk[8];
            v269[4] = *(void *)__lk;
            v269[5] = v272;
            *(void *)__luint64_t k = 0;
            *(void *)&__lk[8] = 0;
            uint64_t v273 = *(void *)&__lk[16];
            v269[6] = *(void *)&__lk[16];
            v269[7] = v259;
            *((float *)v269 + 16) = v559[0];
            unint64_t v274 = *(void *)(v273 + 8);
            if ((v272 & (v272 - 1)) != 0)
            {
              unint64_t v275 = v533;
              if (v274 >= v272) {
                v274 %= v272;
              }
            }
            else
            {
              v274 &= v272 - 1;
              unint64_t v275 = v533;
            }
            *(void *)(v271 + 8 * v274) = v269 + 6;
            *(_OWORD *)&__lk[16] = 0uLL;
            uint8_t buf[16] = 1;
            float v276 = (float)(unint64_t)(*((void *)v275 + 3) + 1);
            float v277 = v275[8];
            if (v261 && (float)(v277 * (float)v261) >= v276)
            {
LABEL_497:
              uint64_t v298 = *(void **)v275;
              float v299 = *(void **)(*(void *)v275 + 8 * v3);
              if (v299)
              {
                *uint64_t v270 = *v299;
              }
              else
              {
                *uint64_t v270 = *v532;
                *float v532 = v270;
                v298[v3] = v532;
                if (!*v270)
                {
LABEL_506:
                  ++*((void *)v275 + 3);
                  goto LABEL_507;
                }
                unint64_t v300 = *(void *)(*v270 + 8);
                if ((v261 & (v261 - 1)) != 0)
                {
                  if (v300 >= v261) {
                    v300 %= v261;
                  }
                }
                else
                {
                  v300 &= v261 - 1;
                }
                float v299 = (void *)(*(void *)v275 + 8 * v300);
              }
              *float v299 = v270;
              goto LABEL_506;
            }
            BOOL v278 = (v261 & (v261 - 1)) != 0;
            if (v261 < 3) {
              BOOL v278 = 1;
            }
            unint64_t v279 = v278 | (2 * v261);
            unint64_t v280 = vcvtps_u32_f32(v276 / v277);
            if (v279 <= v280) {
              size_t prime = v280;
            }
            else {
              size_t prime = v279;
            }
            if (prime == 1)
            {
              size_t prime = 2;
            }
            else if ((prime & (prime - 1)) != 0)
            {
              size_t prime = std::__next_prime(prime);
              unint64_t v261 = *((void *)v275 + 1);
            }
            if (prime <= v261)
            {
              if (prime >= v261) {
                goto LABEL_484;
              }
              unint64_t v292 = vcvtps_u32_f32((float)*((unint64_t *)v275 + 3) / v275[8]);
              if (v261 < 3
                || (uint8x8_t v293 = (uint8x8_t)vcnt_s8((int8x8_t)v261), v293.i16[0] = vaddlv_u8(v293), v293.u32[0] > 1uLL))
              {
                unint64_t v292 = std::__next_prime(v292);
              }
              else
              {
                uint64_t v294 = 1 << -(char)__clz(v292 - 1);
                if (v292 >= 2) {
                  unint64_t v292 = v294;
                }
              }
              if (prime <= v292) {
                size_t prime = v292;
              }
              if (prime >= v261)
              {
                unint64_t v261 = *((void *)v275 + 1);
LABEL_484:
                if ((v261 & (v261 - 1)) != 0)
                {
                  if (v260 >= v261) {
                    unint64_t v3 = v260 % v261;
                  }
                  else {
                    unint64_t v3 = v260;
                  }
                }
                else
                {
                  unint64_t v3 = (v261 - 1) & v260;
                }
                goto LABEL_497;
              }
              if (!prime)
              {
                uint64_t v383 = *(void **)v275;
                *(void *)unint64_t v275 = 0;
                if (v383) {
                  operator delete(v383);
                }
                unint64_t v261 = 0;
                *((void *)v275 + 1) = 0;
                goto LABEL_484;
              }
            }
            if (prime >> 61) {
              sub_1D0DE8CE0();
            }
            uint64_t v282 = operator new(8 * prime);
            int v283 = *(void **)v275;
            *(void *)unint64_t v275 = v282;
            if (v283) {
              operator delete(v283);
            }
            uint64_t v284 = 0;
            *((void *)v275 + 1) = prime;
            do
              *(void *)(*(void *)v275 + 8 * v284++) = 0;
            while (prime != v284);
            uint64_t v285 = (void *)*v532;
            if (!*v532)
            {
LABEL_483:
              unint64_t v261 = prime;
              goto LABEL_484;
            }
            size_t v286 = v285[1];
            size_t v287 = prime - 1;
            if ((prime & (prime - 1)) == 0)
            {
              size_t v288 = v286 & v287;
              *(void *)(*(void *)v275 + 8 * v288) = v532;
              for (uint64_t i = (void *)*v285; *v285; uint64_t i = (void *)*v285)
              {
                size_t v290 = i[1] & v287;
                if (v290 == v288)
                {
                  uint64_t v285 = i;
                }
                else if (*(void *)(*(void *)v275 + 8 * v290))
                {
                  *uint64_t v285 = *i;
                  uint64_t v291 = 8 * v290;
                  *uint64_t i = **(void **)(*(void *)v275 + v291);
                  **(void **)(*(void *)v275 + v291) = i;
                }
                else
                {
                  *(void *)(*(void *)v275 + 8 * v290) = v285;
                  uint64_t v285 = i;
                  size_t v288 = v290;
                }
              }
              goto LABEL_483;
            }
            if (v286 >= prime) {
              v286 %= prime;
            }
            *(void *)(*(void *)v275 + 8 * v286) = v532;
            int v295 = (void *)*v285;
            if (!*v285) {
              goto LABEL_483;
            }
            while (1)
            {
              size_t v297 = v295[1];
              if (v297 >= prime) {
                v297 %= prime;
              }
              if (v297 != v286)
              {
                if (!*(void *)(*(void *)v275 + 8 * v297))
                {
                  *(void *)(*(void *)v275 + 8 * v297) = v285;
                  goto LABEL_488;
                }
                *uint64_t v285 = *v295;
                uint64_t v296 = 8 * v297;
                *int v295 = **(void **)(*(void *)v275 + v296);
                **(void **)(*(void *)v275 + v296) = v295;
                int v295 = v285;
              }
              size_t v297 = v286;
LABEL_488:
              uint64_t v285 = v295;
              int v295 = (void *)*v295;
              size_t v286 = v297;
              if (!v295) {
                goto LABEL_483;
              }
            }
          }
        }
        uint64_t v536 = v114;
        unint64_t v537 = v554;
        unint64_t v3 = (unint64_t)*v554;
        int v147 = (char *)*((void *)*v554 + 3);
        uint64_t v146 = (char *)*((void *)*v554 + 4);
        uint64_t v148 = (char *)(v146 - v147);
        uint64_t v149 = (v146 - v147) >> 3;
        uint64_t v150 = (uint64_t *)v118[3];
        uint64_t v151 = (uint64_t *)v118[4];
        unint64_t v152 = v149 + v151 - v150;
        if (v152 <= (uint64_t)(*((void *)*v554 + 5) - (void)v147) >> 3)
        {
          uint64_t v158 = v118;
          if (v150 == v151)
          {
LABEL_280:
            uint64_t v188 = (uint64_t **)(v158 + 4);
LABEL_281:
            *uint64_t v188 = v151;
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EB9F1610))
            {
              qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
              __cxa_guard_release(&qword_1EB9F1610);
            }
            int v192 = (id)qword_1EB9F1620;
            unint64_t v116 = v535;
            uint64_t v114 = v536;
            if (os_log_type_enabled(v192, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v193 = (uint64_t)(*v117 + 20);
              uint64_t v194 = (uint64_t)(*v537 + 160);
              uint64_t v195 = (uint64_t)(*((void *)*v537 + 4) - *((void *)*v537 + 3)) >> 3;
              *(_DWORD *)int buf = 136315650;
              *(void *)&uint8_t buf[4] = v193;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = v194;
              *(_WORD *)&unsigned char buf[22] = 2048;
              *(void *)&unsigned char buf[24] = v195;
              _os_log_impl(&dword_1D0DBD000, v192, OS_LOG_TYPE_DEFAULT, "Transferred cluster information from user %s to %s. New cluster count: %lu.", buf, 0x20u);
            }

            unint64_t v196 = *(void *)&__lk[8];
            unint64_t v197 = v118[1] ^ *v118;
            if (*(void *)&__lk[8])
            {
              uint8x8_t v198 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&__lk[8]);
              v198.i16[0] = vaddlv_u8(v198);
              if (v198.u32[0] > 1uLL)
              {
                unint64_t v3 = v118[1] ^ *v118;
                if (v197 >= *(void *)&__lk[8]) {
                  unint64_t v3 = v197 % *(void *)&__lk[8];
                }
              }
              else
              {
                unint64_t v3 = (*(void *)&__lk[8] - 1) & v197;
              }
              int v199 = *(void **)(*(void *)__lk + 8 * v3);
              if (v199)
              {
                uint64_t v200 = (void *)*v199;
                if (v200)
                {
                  if (v198.u32[0] < 2uLL)
                  {
                    while (1)
                    {
                      uint64_t v204 = v200[1];
                      if (v204 == v197)
                      {
                        if (v200[2] == *v118 && v200[3] == v118[1]) {
                          goto LABEL_176;
                        }
                      }
                      else if ((v204 & (*(void *)&__lk[8] - 1)) != v3)
                      {
                        goto LABEL_310;
                      }
                      uint64_t v200 = (void *)*v200;
                      if (!v200) {
                        goto LABEL_310;
                      }
                    }
                  }
                  do
                  {
                    unint64_t v202 = v200[1];
                    if (v202 == v197)
                    {
                      if (v200[2] == *v118 && v200[3] == v118[1]) {
                        goto LABEL_176;
                      }
                    }
                    else
                    {
                      if (v202 >= *(void *)&__lk[8]) {
                        v202 %= *(void *)&__lk[8];
                      }
                      if (v202 != v3) {
                        break;
                      }
                    }
                    uint64_t v200 = (void *)*v200;
                  }
                  while (v200);
                }
              }
            }
LABEL_310:
            int v205 = operator new(0x20uLL);
            void *v205 = 0;
            v205[1] = v197;
            *((_OWORD *)v205 + 1) = *(_OWORD *)v118;
            float v206 = (float)(unint64_t)(*(void *)&__lk[24] + 1);
            if (v196 && (float)(v559[0] * (float)v196) >= v206)
            {
LABEL_373:
              uint64_t v243 = *(void *)__lk;
              int v244 = *(void **)(*(void *)__lk + 8 * v3);
              if (v244)
              {
                void *v205 = *v244;
              }
              else
              {
                void *v205 = *(void *)&__lk[16];
                *(void *)&__lk[16] = v205;
                *(void *)(v243 + 8 * v3) = &__lk[16];
                if (!*v205) {
                  goto LABEL_175;
                }
                unint64_t v245 = *(void *)(*v205 + 8);
                if ((v196 & (v196 - 1)) != 0)
                {
                  if (v245 >= v196) {
                    v245 %= v196;
                  }
                }
                else
                {
                  v245 &= v196 - 1;
                }
                int v244 = (void *)(*(void *)__lk + 8 * v245);
              }
              *int v244 = v205;
LABEL_175:
              ++*(void *)&__lk[24];
              goto LABEL_176;
            }
            BOOL v207 = (v196 & (v196 - 1)) != 0;
            if (v196 < 3) {
              BOOL v207 = 1;
            }
            unint64_t v208 = v207 | (2 * v196);
            unint64_t v209 = vcvtps_u32_f32(v206 / v559[0]);
            if (v208 <= v209) {
              size_t v210 = v209;
            }
            else {
              size_t v210 = v208;
            }
            if (v210 == 1)
            {
              size_t v210 = 2;
            }
            else if ((v210 & (v210 - 1)) != 0)
            {
              size_t v210 = std::__next_prime(v210);
              unint64_t v196 = *(void *)&__lk[8];
            }
            if (v210 <= v196)
            {
              if (v210 >= v196) {
                goto LABEL_360;
              }
              unint64_t v221 = vcvtps_u32_f32((float)*(unint64_t *)&__lk[24] / v559[0]);
              if (v196 < 3
                || (uint8x8_t v222 = (uint8x8_t)vcnt_s8((int8x8_t)v196), v222.i16[0] = vaddlv_u8(v222), v222.u32[0] > 1uLL))
              {
                unint64_t v221 = std::__next_prime(v221);
              }
              else
              {
                uint64_t v223 = 1 << -(char)__clz(v221 - 1);
                if (v221 >= 2) {
                  unint64_t v221 = v223;
                }
              }
              if (v210 <= v221) {
                size_t v210 = v221;
              }
              if (v210 >= v196)
              {
                unint64_t v196 = *(void *)&__lk[8];
LABEL_360:
                if ((v196 & (v196 - 1)) != 0)
                {
                  if (v197 >= v196) {
                    unint64_t v3 = v197 % v196;
                  }
                  else {
                    unint64_t v3 = v197;
                  }
                }
                else
                {
                  unint64_t v3 = (v196 - 1) & v197;
                }
                goto LABEL_373;
              }
              if (!v210)
              {
                int v246 = *(void **)__lk;
                *(void *)__luint64_t k = 0;
                if (v246) {
                  operator delete(v246);
                }
                unint64_t v196 = 0;
                *(void *)&__lk[8] = 0;
                goto LABEL_360;
              }
            }
            if (v210 >> 61) {
              sub_1D0DE8CE0();
            }
            int v211 = operator new(8 * v210);
            uint64_t v212 = *(void **)__lk;
            *(void *)__luint64_t k = v211;
            if (v212) {
              operator delete(v212);
            }
            uint64_t v213 = 0;
            *(void *)&__lk[8] = v210;
            do
              *(void *)(*(void *)__lk + 8 * v213++) = 0;
            while (v210 != v213);
            int v214 = *(void ***)&__lk[16];
            if (!*(void *)&__lk[16])
            {
LABEL_359:
              unint64_t v196 = v210;
              goto LABEL_360;
            }
            size_t v215 = *(void *)(*(void *)&__lk[16] + 8);
            size_t v216 = v210 - 1;
            if ((v210 & (v210 - 1)) == 0)
            {
              size_t v217 = v215 & v216;
              *(void *)(*(void *)__lk + 8 * v217) = &__lk[16];
              for (int j = *v214; *v214; int j = *v214)
              {
                size_t v219 = j[1] & v216;
                if (v219 == v217)
                {
                  int v214 = (void **)j;
                }
                else if (*(void *)(*(void *)__lk + 8 * v219))
                {
                  *int v214 = (void *)*j;
                  uint64_t v220 = 8 * v219;
                  *int j = **(void **)(*(void *)__lk + v220);
                  **(void **)(*(void *)__lk + v220) = j;
                }
                else
                {
                  *(void *)(*(void *)__lk + 8 * v219) = v214;
                  int v214 = (void **)j;
                  size_t v217 = v219;
                }
              }
              goto LABEL_359;
            }
            if (v215 >= v210) {
              v215 %= v210;
            }
            *(void *)(*(void *)__lk + 8 * v215) = &__lk[16];
            int v240 = *v214;
            if (!*v214) {
              goto LABEL_359;
            }
            while (1)
            {
              size_t v242 = v240[1];
              if (v242 >= v210) {
                v242 %= v210;
              }
              if (v242 != v215)
              {
                if (!*(void *)(*(void *)__lk + 8 * v242))
                {
                  *(void *)(*(void *)__lk + 8 * v242) = v214;
                  goto LABEL_364;
                }
                *int v214 = (void *)*v240;
                uint64_t v241 = 8 * v242;
                void *v240 = **(void **)(*(void *)__lk + v241);
                **(void **)(*(void *)__lk + v241) = v240;
                int v240 = v214;
              }
              size_t v242 = v215;
LABEL_364:
              int v214 = (void **)v240;
              int v240 = (void *)*v240;
              size_t v215 = v242;
              if (!v240) {
                goto LABEL_359;
              }
            }
          }
LABEL_241:
          int v159 = *(void **)(v3 + 32);
          do
          {
            unint64_t v161 = *(void *)(v3 + 40);
            if ((unint64_t)v159 < v161)
            {
              uint64_t v160 = *v150;
              uint64_t *v150 = 0;
              *v159++ = v160;
              *(void *)(v3 + 32) = v159;
            }
            else
            {
              uint64_t v162 = *(void *)(v3 + 24);
              uint64_t v163 = (char *)v159 - v162;
              uint64_t v164 = ((uint64_t)v159 - v162) >> 3;
              if ((unint64_t)(v164 + 1) >> 61) {
                goto LABEL_833;
              }
              uint64_t v165 = v161 - v162;
              uint64_t v166 = v165 >> 2;
              if (v165 >> 2 <= (unint64_t)(v164 + 1)) {
                uint64_t v166 = v164 + 1;
              }
              if ((unint64_t)v165 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v167 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v167 = v166;
              }
              if (v167)
              {
                if (v167 >> 61) {
                  sub_1D0DE8CE0();
                }
                int v168 = (char *)operator new(8 * v167);
              }
              else
              {
                int v168 = 0;
              }
              size_t v169 = &v168[8 * v164];
              int v170 = &v168[8 * v167];
              uint64_t v171 = *v150;
              uint64_t *v150 = 0;
              *(void *)size_t v169 = v171;
              int v159 = v169 + 8;
              uint64_t v172 = *(char **)(v3 + 24);
              uint64_t v173 = *(char **)(v3 + 32);
              int v174 = (char *)(v173 - v172);
              if (v173 == v172)
              {
                *(void *)(v3 + 24) = v169;
                *(void *)(v3 + 32) = v159;
                *(void *)(v3 + 40) = v170;
              }
              else
              {
                uint64_t v175 = v174 - 8;
                if ((unint64_t)(v174 - 8) < 0x78
                  || &v173[-8 * ((unint64_t)v175 >> 3) - 8] < v169
                  && &v163[(void)v168 - ((unint64_t)v175 & 0xFFFFFFFFFFFFFFF8) - 8] < v173)
                {
                  goto LABEL_847;
                }
                uint64_t v176 = ((unint64_t)v175 >> 3) + 1;
                uint64_t v177 = 8 * (v176 & 0x3FFFFFFFFFFFFFFCLL);
                int v178 = &v173[-v177];
                v169 -= v177;
                uint64_t v179 = &v163[(void)v168 - 16];
                int v180 = v173 - 16;
                uint64_t v181 = v176 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v183 = *((_OWORD *)v180 - 1);
                  long long v182 = *(_OWORD *)v180;
                  *((_OWORD *)v180 - 1) = 0uLL;
                  *(_OWORD *)int v180 = 0uLL;
                  *((_OWORD *)v179 - 1) = v183;
                  *(_OWORD *)uint64_t v179 = v182;
                  v179 -= 32;
                  v180 -= 32;
                  v181 -= 4;
                }
                while (v181);
                uint64_t v173 = v178;
                if (v176 != (v176 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_847:
                  do
                  {
                    uint64_t v184 = *((void *)v173 - 1);
                    v173 -= 8;
                    *(void *)uint64_t v173 = 0;
                    *((void *)v169 - 1) = v184;
                    v169 -= 8;
                  }
                  while (v173 != v172);
                }
                uint64_t v173 = *(char **)(v3 + 24);
                unint64_t v185 = *(char **)(v3 + 32);
                *(void *)(v3 + 24) = v169;
                *(void *)(v3 + 32) = v159;
                *(void *)(v3 + 40) = v170;
                while (v185 != v173)
                {
                  int v187 = (void **)*((void *)v185 - 1);
                  v185 -= 8;
                  int v186 = v187;
                  *(void *)unint64_t v185 = 0;
                  if (v187)
                  {
                    free(v186[3]);
                    free(*v186);
                    MEMORY[0x1D25F16B0](v186, 0x1080C407C7A2332);
                  }
                }
              }
              if (v173) {
                operator delete(v173);
              }
            }
            *(void *)(v3 + 32) = v159;
            ++v150;
          }
          while (v150 != v151);
          uint64_t v188 = (uint64_t **)(*v117 + 4);
          uint64_t v151 = *v188;
          uint64_t v189 = (uint64_t *)(*v117)[3];
          if (*v188 != v189)
          {
            do
            {
              uint64_t v191 = (void **)*--v151;
              int v190 = v191;
              *uint64_t v151 = 0;
              if (v191)
              {
                free(v190[3]);
                free(*v190);
                MEMORY[0x1D25F16B0](v190, 0x1080C407C7A2332);
              }
            }
            while (v151 != v189);
            uint64_t v151 = v189;
          }
          goto LABEL_281;
        }
        if (v152 >> 61) {
LABEL_833:
        }
          abort();
        uint64_t v153 = (char *)operator new(8 * v152);
        unint64_t v154 = &v153[8 * v149];
        int v155 = &v153[8 * v152];
        if (v146 == v147)
        {
          *(void *)(v3 + 24) = v154;
          *(void *)(v3 + 32) = v154;
          *(void *)(v3 + 40) = v155;
          goto LABEL_277;
        }
        unint64_t v156 = v146 - v147 - 8;
        if (v156 >= 0x78)
        {
          unint64_t v224 = v156 >> 3;
          unint64_t v225 = (unint64_t)&v146[-8 * (v156 >> 3) - 8];
          unint64_t v226 = (unint64_t)&v148[(void)v153 - (v156 & 0xFFFFFFFFFFFFFFF8) - 8];
          BOOL v227 = v225 >= (unint64_t)v154 || v226 >= (unint64_t)v146;
          uint64_t v157 = &v153[8 * v149];
          if (v227)
          {
            unint64_t v228 = v224 + 1;
            uint64_t v229 = 8 * (v228 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v230 = &v146[-v229];
            uint64_t v157 = &v154[-v229];
            uint64_t v231 = &v148[(void)v153 - 16];
            uint64_t v232 = v146 - 16;
            uint64_t v233 = v228 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v235 = *((_OWORD *)v232 - 1);
              long long v234 = *(_OWORD *)v232;
              *((_OWORD *)v232 - 1) = 0uLL;
              *(_OWORD *)uint64_t v232 = 0uLL;
              *((_OWORD *)v231 - 1) = v235;
              *(_OWORD *)uint64_t v231 = v234;
              v231 -= 32;
              v232 -= 32;
              v233 -= 4;
            }
            while (v233);
            uint64_t v146 = v230;
            if (v228 == (v228 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_352:
              uint64_t v146 = *(char **)(v3 + 24);
              uint64_t v237 = *(char **)(v3 + 32);
              *(void *)(v3 + 24) = v157;
              *(void *)(v3 + 32) = v154;
              *(void *)(v3 + 40) = v155;
              while (v237 != v146)
              {
                uint64_t v239 = (void **)*((void *)v237 - 1);
                v237 -= 8;
                int v238 = v239;
                *(void *)uint64_t v237 = 0;
                if (v239)
                {
                  free(v238[3]);
                  free(*v238);
                  MEMORY[0x1D25F16B0](v238, 0x1080C407C7A2332);
                }
              }
LABEL_277:
              if (v146) {
                operator delete(v146);
              }
              uint64_t v158 = *v117;
              uint64_t v150 = (uint64_t *)(*v117)[3];
              uint64_t v151 = (uint64_t *)(*v117)[4];
              unint64_t v3 = (unint64_t)*v537;
              if (v150 == v151) {
                goto LABEL_280;
              }
              goto LABEL_241;
            }
          }
        }
        else
        {
          uint64_t v157 = &v153[8 * v149];
        }
        do
        {
          uint64_t v236 = *((void *)v146 - 1);
          v146 -= 8;
          *(void *)uint64_t v146 = 0;
          *((void *)v157 - 1) = v236;
          v157 -= 8;
        }
        while (v146 != v147);
        goto LABEL_352;
      }
      sub_1D0DF8034(v554);
      sub_1D0DF65BC(*(void ****)(a1 + 8), (uint64_t *)&v554);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1610))
      {
        qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
        __cxa_guard_release(&qword_1EB9F1610);
      }
      uint64_t v98 = (id)qword_1EB9F1620;
      if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
      {
        if (v552) {
          unint64_t v110 = (const char *)(*v552 + 160);
        }
        else {
          unint64_t v110 = "n/a";
        }
        uint64_t v112 = *v554 + 160;
        uint64_t v113 = (uint64_t)(*(void *)(**(void **)(a1 + 8) + 8) - ***(void ***)(a1 + 8)) >> 4;
        *(_DWORD *)__luint64_t k = 136315906;
        *(void *)&__lk[4] = v112;
        *(_WORD *)&__lk[12] = 2048;
        *(void *)&__lk[14] = v113;
        *(_WORD *)&unsigned char __lk[22] = 2080;
        *(void *)&__lk[24] = v110;
        LOWORD(v559[0]) = 2048;
        *(double *)((char *)v559 + 2) = v41;
        _os_log_impl(&dword_1D0DBD000, v98, OS_LOG_TYPE_DEFAULT, "Unknown user, assigned new UUID %s. New DB size %zu. Closest mismatch %s, d=%f", __lk, 0x2Au);
      }
    }

    goto LABEL_169;
  }
LABEL_692:
  int32x4_t v448 = *a2;
  if (a2[1] != *a2)
  {
    unint64_t v449 = 0;
    unsigned int v450 = 0;
    uint64_t v451 = *(void *)(a1 + 8);
    int32x4_t v452 = (uint64_t **)(v451 + 40);
    do
    {
      while (1)
      {
        uint64_t v453 = 2 * v449;
        uint64_t v454 = *v448[2 * v449];
        uint64_t v455 = *(void *)(v454 + 24);
        unsigned int v456 = *(std::__shared_weak_count **)(v454 + 32);
        if (v456) {
          atomic_fetch_add_explicit(&v456->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v455) {
          break;
        }
        BOOL v461 = 1;
        if (v456) {
          goto LABEL_705;
        }
LABEL_706:
        if (!v461) {
          goto LABEL_707;
        }
LABEL_694:
        int32x4_t v448 = *a2;
        unint64_t v449 = ++v450;
        if (((char *)a2[1] - (char *)*a2) >> 4 <= (unint64_t)v450) {
          goto LABEL_823;
        }
      }
      uint64_t v457 = *(*a2)[2 * v449];
      uint64_t v458 = *(void *)(v457 + 24);
      int32x4_t v459 = *(std::__shared_weak_count **)(v457 + 32);
      if (v459)
      {
        atomic_fetch_add_explicit(&v459->__shared_owners_, 1uLL, memory_order_relaxed);
        int v460 = *(unsigned __int8 *)(*(void *)v458 + 16);
        if (!atomic_fetch_add(&v459->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v459->__on_zero_shared)(v459);
          std::__shared_weak_count::__release_weak(v459);
        }
      }
      else
      {
        int v460 = *(unsigned __int8 *)(*(void *)v458 + 16);
      }
      BOOL v461 = v460 == 0;
      if (!v456) {
        goto LABEL_706;
      }
LABEL_705:
      if (atomic_fetch_add(&v456->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_706;
      }
      ((void (*)(std::__shared_weak_count *))v456->__on_zero_shared)(v456);
      std::__shared_weak_count::__release_weak(v456);
      if (v461) {
        goto LABEL_694;
      }
LABEL_707:
      uint64_t v462 = *(*a2)[v453];
      float32x4_t v463 = *(unint64_t ***)(v462 + 24);
      float32x4_t v464 = *(std::__shared_weak_count **)(v462 + 32);
      *(void *)__luint64_t k = v463;
      *(void *)&__lk[8] = v464;
      if (v464)
      {
        atomic_fetch_add_explicit(&v464->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v465 = *v463;
        if (!*((unsigned char *)*v463 + 16)) {
          goto LABEL_837;
        }
        if (!atomic_fetch_add(&v464->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v464->__on_zero_shared)(v464);
          std::__shared_weak_count::__release_weak(v464);
        }
      }
      else
      {
        uint64_t v465 = *v463;
        if (!*((unsigned char *)*v463 + 16)) {
          goto LABEL_837;
        }
      }
      unint64_t v466 = v450 + 1;
      int32x4_t v448 = *a2;
      unint64_t v467 = ((char *)a2[1] - (char *)*a2) >> 4;
      unint64_t v468 = v466;
      unsigned int v545 = v466;
      uint64_t v538 = v453 * 8;
      unint64_t v540 = v466;
      if (v467 > v466)
      {
        do
        {
          uint64_t v469 = 2 * v468;
          uint64_t v470 = *v448[2 * v468];
          uint64_t v471 = *(void *)(v470 + 24);
          float32x2_t v472 = *(std::__shared_weak_count **)(v470 + 32);
          if (v472) {
            atomic_fetch_add_explicit(&v472->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v471)
          {
            uint64_t v473 = *(*a2)[2 * v468];
            uint64_t v474 = *(void *)(v473 + 24);
            float32x2_t v475 = *(std::__shared_weak_count **)(v473 + 32);
            if (v475)
            {
              atomic_fetch_add_explicit(&v475->__shared_owners_, 1uLL, memory_order_relaxed);
              int v476 = *(unsigned __int8 *)(*(void *)v474 + 16);
              if (!atomic_fetch_add(&v475->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v475->__on_zero_shared)(v475);
                std::__shared_weak_count::__release_weak(v475);
              }
            }
            else
            {
              int v476 = *(unsigned __int8 *)(*(void *)v474 + 16);
            }
            BOOL v477 = v476 == 0;
            if (!v472)
            {
LABEL_730:
              if (!v477) {
                goto LABEL_731;
              }
              goto LABEL_718;
            }
          }
          else
          {
            BOOL v477 = 1;
            if (!v472) {
              goto LABEL_730;
            }
          }
          if (atomic_fetch_add(&v472->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_730;
          }
          ((void (*)(std::__shared_weak_count *))v472->__on_zero_shared)(v472);
          std::__shared_weak_count::__release_weak(v472);
          if (!v477)
          {
LABEL_731:
            uint64_t v478 = *(*a2)[v469];
            int32x4_t v479 = *(unint64_t ***)(v478 + 24);
            int v480 = *(std::__shared_weak_count **)(v478 + 32);
            *(void *)__luint64_t k = v479;
            *(void *)&__lk[8] = v480;
            if (v480)
            {
              atomic_fetch_add_explicit(&v480->__shared_owners_, 1uLL, memory_order_relaxed);
              int v481 = *v479;
              if (!*((unsigned char *)*v479 + 16)) {
                goto LABEL_835;
              }
              if (!atomic_fetch_add(&v480->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v480->__on_zero_shared)(v480);
                std::__shared_weak_count::__release_weak(v480);
              }
            }
            else
            {
              int v481 = *v479;
              if (!*((unsigned char *)*v479 + 16))
              {
LABEL_835:
                _os_crash();
                __break(1u);
LABEL_836:
                _os_crash();
                __break(1u);
LABEL_837:
                _os_crash();
                __break(1u);
LABEL_838:
                sub_1D0DE8CE0();
              }
            }
            unint64_t v482 = bswap64(*v465);
            unint64_t v483 = bswap64(*v481);
            if (v482 == v483 && (unint64_t v482 = bswap64(v465[1]), v483 = bswap64(v481[1]), v482 == v483))
            {
              int v484 = 0;
            }
            else if (v482 < v483)
            {
              int v484 = -1;
            }
            else
            {
              int v484 = 1;
            }
            BOOL v485 = v484 < 0;
            if (v484 < 0) {
              float32x4_t v486 = v465;
            }
            else {
              float32x4_t v486 = v481;
            }
            if (v485) {
              int v487 = v481;
            }
            else {
              int v487 = v465;
            }
            *(_OWORD *)__luint64_t k = *(_OWORD *)v486;
            *(_OWORD *)&__lk[16] = *(_OWORD *)v487;
            float32x4_t v488 = (uint64_t *)operator new(0x40uLL);
            long long v489 = *(_OWORD *)&__lk[16];
            *(_OWORD *)((char *)v488 + 25) = *(_OWORD *)__lk;
            *(_OWORD *)((char *)v488 + 41) = v489;
            int v490 = *v452;
            float32x4_t v491 = (uint64_t **)(v451 + 40);
            int32x4_t v492 = (uint64_t *)(v451 + 40);
            if (*v452)
            {
              uint64_t v493 = (unint64_t *)((char *)v488 + 25);
              while (1)
              {
                int32x4_t v492 = v490;
                unint64_t v494 = bswap64(*v493);
                unint64_t v495 = bswap64(*(uint64_t *)((char *)v490 + 25));
                if (v494 == v495
                  && (unint64_t v494 = bswap64(*(uint64_t *)((char *)v488 + 33)),
                      unint64_t v495 = bswap64(*(uint64_t *)((char *)v492 + 33)),
                      v494 == v495))
                {
                  unint64_t v497 = bswap64(*(uint64_t *)((char *)v488 + 41));
                  unint64_t v498 = bswap64(*(uint64_t *)((char *)v492 + 41));
                  if (v497 == v498)
                  {
                    unint64_t v497 = bswap64(*(uint64_t *)((char *)v488 + 49));
                    unint64_t v498 = bswap64(*(uint64_t *)((char *)v492 + 49));
                    if (v497 == v498) {
                      goto LABEL_764;
                    }
                  }
                  if (v497 < v498) {
                    int v496 = -1;
                  }
                  else {
                    int v496 = 1;
                  }
                }
                else if (v494 < v495)
                {
                  int v496 = -1;
                }
                else
                {
                  int v496 = 1;
                }
                if (v496 < 0)
                {
                  int v490 = (uint64_t *)*v492;
                  float32x4_t v491 = (uint64_t **)v492;
                  if (!*v492) {
                    break;
                  }
                }
                else
                {
LABEL_764:
                  unint64_t v499 = bswap64(*(uint64_t *)((char *)v492 + 25));
                  unint64_t v500 = bswap64(*v493);
                  if (v499 == v500
                    && (unint64_t v499 = bswap64(*(uint64_t *)((char *)v492 + 33)),
                        unint64_t v500 = bswap64(*(uint64_t *)((char *)v488 + 33)),
                        v499 == v500))
                  {
                    unint64_t v502 = bswap64(*(uint64_t *)((char *)v492 + 41));
                    unint64_t v503 = bswap64(*(uint64_t *)((char *)v488 + 41));
                    if (v502 == v503)
                    {
                      unint64_t v502 = bswap64(*(uint64_t *)((char *)v492 + 49));
                      unint64_t v503 = bswap64(*(uint64_t *)((char *)v488 + 49));
                      if (v502 == v503)
                      {
LABEL_717:
                        operator delete(v488);
                        goto LABEL_718;
                      }
                    }
                    if (v502 < v503) {
                      int v501 = -1;
                    }
                    else {
                      int v501 = 1;
                    }
                  }
                  else if (v499 < v500)
                  {
                    int v501 = -1;
                  }
                  else
                  {
                    int v501 = 1;
                  }
                  if ((v501 & 0x80000000) == 0) {
                    goto LABEL_717;
                  }
                  int v490 = (uint64_t *)v492[1];
                  if (!v490)
                  {
                    float32x4_t v491 = (uint64_t **)(v492 + 1);
                    break;
                  }
                }
              }
            }
            *float32x4_t v488 = 0;
            v488[1] = 0;
            v488[2] = (uint64_t)v492;
            *float32x4_t v491 = v488;
            uint64_t v504 = **(void **)(v451 + 32);
            if (v504)
            {
              *(void *)(v451 + 32) = v504;
              float32x4_t v488 = *v491;
            }
            size_t v505 = *v452;
            BOOL v119 = v488 == *v452;
            *((unsigned char *)v488 + 24) = v119;
            if (!v119)
            {
              do
              {
                uint64_t v506 = v488[2];
                if (*(unsigned char *)(v506 + 24)) {
                  break;
                }
                float32x4_t v507 = *(uint64_t **)(v506 + 16);
                uint64_t v508 = *v507;
                if (*v507 == v506)
                {
                  uint64_t v511 = v507[1];
                  if (!v511 || (v512 = *(unsigned __int8 *)(v511 + 24), size_t v509 = (unsigned char *)(v511 + 24), v512))
                  {
                    if (*(uint64_t **)v506 == v488)
                    {
                      float v513 = (uint64_t *)v488[2];
                    }
                    else
                    {
                      float v513 = *(uint64_t **)(v506 + 8);
                      uint64_t v514 = *v513;
                      *(void *)(v506 + 8) = *v513;
                      if (v514)
                      {
                        *(void *)(v514 + 16) = v506;
                        float32x4_t v507 = *(uint64_t **)(v506 + 16);
                      }
                      v513[2] = (uint64_t)v507;
                      *(void *)(*(void *)(v506 + 16) + 8 * (**(void **)(v506 + 16) != v506)) = v513;
                      *float v513 = v506;
                      *(void *)(v506 + 16) = v513;
                      float32x4_t v507 = (uint64_t *)v513[2];
                      uint64_t v506 = *v507;
                    }
                    *((unsigned char *)v513 + 24) = 1;
                    *((unsigned char *)v507 + 24) = 0;
                    uint64_t v517 = *(void *)(v506 + 8);
                    *float32x4_t v507 = v517;
                    if (v517) {
                      *(void *)(v517 + 16) = v507;
                    }
                    *(void *)(v506 + 16) = v507[2];
                    *(void *)(v507[2] + 8 * (*(void *)v507[2] != (void)v507)) = v506;
                    *(void *)(v506 + 8) = v507;
                    goto LABEL_806;
                  }
                }
                else if (!v508 || (int v510 = *(unsigned __int8 *)(v508 + 24), v509 = (unsigned char *)(v508 + 24), v510))
                {
                  if (*(uint64_t **)v506 == v488)
                  {
                    uint64_t v515 = v488[1];
                    *(void *)uint64_t v506 = v515;
                    if (v515)
                    {
                      *(void *)(v515 + 16) = v506;
                      float32x4_t v507 = *(uint64_t **)(v506 + 16);
                    }
                    v488[2] = (uint64_t)v507;
                    *(void *)(*(void *)(v506 + 16) + 8 * (**(void **)(v506 + 16) != v506)) = v488;
                    v488[1] = v506;
                    *(void *)(v506 + 16) = v488;
                    float32x4_t v507 = (uint64_t *)v488[2];
                  }
                  else
                  {
                    float32x4_t v488 = (uint64_t *)v488[2];
                  }
                  *((unsigned char *)v488 + 24) = 1;
                  *((unsigned char *)v507 + 24) = 0;
                  uint64_t v506 = v507[1];
                  int8x16_t v516 = *(uint64_t **)v506;
                  v507[1] = *(void *)v506;
                  if (v516) {
                    v516[2] = (uint64_t)v507;
                  }
                  *(void *)(v506 + 16) = v507[2];
                  *(void *)(v507[2] + 8 * (*(void *)v507[2] != (void)v507)) = v506;
                  *(void *)uint64_t v506 = v507;
LABEL_806:
                  v507[2] = v506;
                  break;
                }
                *(unsigned char *)(v506 + 24) = 1;
                float32x4_t v488 = v507;
                *((unsigned char *)v507 + 24) = v507 == v505;
                *size_t v509 = 1;
              }
              while (v507 != v505);
            }
            ++*(void *)(v451 + 48);
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EB9F1610))
            {
              qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
              __cxa_guard_release(&qword_1EB9F1610);
            }
            float v518 = (id)qword_1EB9F1620;
            if (!os_log_type_enabled(v518, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_809;
            }
            float32x4_t v519 = *a2;
            uint64_t v520 = **(uint64_t **)((char *)*a2 + v538);
            float v521 = *(void **)(v520 + 24);
            simd_float3x3 v522 = *(std::__shared_weak_count **)(v520 + 32);
            if (v522)
            {
              atomic_fetch_add_explicit(&v522->__shared_owners_, 1uLL, memory_order_relaxed);
              float32x4_t v519 = *a2;
            }
            uint64_t v523 = *v521 + 160;
            uint64_t v524 = *v519[v469];
            uint64_t v525 = *(void **)(v524 + 24);
            float v526 = *(std::__shared_weak_count **)(v524 + 32);
            if (v526)
            {
              atomic_fetch_add_explicit(&v526->__shared_owners_, 1uLL, memory_order_relaxed);
              uint64_t v528 = *v525 + 160;
              *(_DWORD *)__luint64_t k = 136315394;
              *(void *)&__lk[4] = v523;
              *(_WORD *)&__lk[12] = 2080;
              *(void *)&__lk[14] = v528;
              _os_log_debug_impl(&dword_1D0DBD000, v518, OS_LOG_TYPE_DEBUG, "Recorded distinct users %s and %s", __lk, 0x16u);
              if (atomic_fetch_add(&v526->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                if (!v522)
                {
LABEL_809:

                  goto LABEL_718;
                }
              }
              else
              {
                ((void (*)(std::__shared_weak_count *))v526->__on_zero_shared)(v526);
                std::__shared_weak_count::__release_weak(v526);
                if (!v522) {
                  goto LABEL_809;
                }
              }
            }
            else
            {
              uint64_t v527 = *v525 + 160;
              *(_DWORD *)__luint64_t k = 136315394;
              *(void *)&__lk[4] = v523;
              *(_WORD *)&__lk[12] = 2080;
              *(void *)&__lk[14] = v527;
              _os_log_debug_impl(&dword_1D0DBD000, v518, OS_LOG_TYPE_DEBUG, "Recorded distinct users %s and %s", __lk, 0x16u);
              if (!v522) {
                goto LABEL_809;
              }
            }
            if (!atomic_fetch_add(&v522->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v522->__on_zero_shared)(v522);
              std::__shared_weak_count::__release_weak(v522);
            }
            goto LABEL_809;
          }
LABEL_718:
          int32x4_t v448 = *a2;
          unint64_t v467 = ((char *)a2[1] - (char *)*a2) >> 4;
          LODWORD(v466) = v466 + 1;
          unint64_t v468 = v466;
        }
        while (v467 > v466);
      }
      unsigned int v450 = v545;
      unint64_t v449 = v540;
    }
    while (v467 > v540);
  }
LABEL_823:
  float v529 = (char *)v556;
  if (v556)
  {
    uint64_t v530 = (char *)v557;
    if ((void *)v557 != v556)
    {
      do
      {
        unsigned int v531 = (std::__shared_weak_count *)*((void *)v530 - 1);
        if (v531)
        {
          if (!atomic_fetch_add(&v531->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v531->__on_zero_shared)(v531);
            std::__shared_weak_count::__release_weak(v531);
          }
        }
        v530 -= 16;
      }
      while (v530 != v529);
      float v529 = (char *)v556;
    }
    operator delete(v529);
  }
}

void sub_1D0E4B238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,char a40,uint64_t a41,void *a42)
{
}

uint64_t sub_1D0E4B32C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_1D0E4B378(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      unint64_t v3 = (void *)v2[6];
      if (v3)
      {
        do
        {
          uint64_t v4 = (void *)*v3;
          operator delete(v3);
          unint64_t v3 = v4;
        }
        while (v4);
      }
      uint64_t v5 = (void *)v2[4];
      v2[4] = 0;
      if (v5) {
        operator delete(v5);
      }
    }
    operator delete(v2);
  }
  return a1;
}

void sub_1D0E4B3E8(uint64_t a1, __n128 **a2, __CVBuffer *a3, uint64_t a4)
{
  v243[19] = *MEMORY[0x1E4F143B8];
  if (!a3) {
    return;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA643860, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA643860))
  {
    dword_1EA643858 = 1059760811;
    __cxa_guard_release(&qword_1EA643860);
  }
  CVPixelBufferRef texture = a3;
  unint64_t v197 = 0;
  uint8x8_t v198 = 0;
  unint64_t v199 = 0;
  float v6 = *a2;
  float v7 = a2[1];
  if (*a2 != v7)
  {
    int v186 = *(void **)(MEMORY[0x1E4FBA408] + 64);
    int v187 = (void *)*MEMORY[0x1E4FBA408];
    uint64_t v185 = *(void *)(MEMORY[0x1E4FBA408] + 72);
    uint64_t v188 = a2[1];
    while (1)
    {
      uint64_t v8 = *(void *)v6->n128_u64[0];
      if (*(void *)(v8 + 128) && !*(unsigned char *)(v8 + 168))
      {
        float v9 = (uint64_t *)(*(void *)(*(void *)(v8 + 96) + ((*(void *)(v8 + 120) >> 4) & 0xFFFFFFFFFFFFFF8))
                       + 32 * (*(void *)(v8 + 120) & 0x7FLL));
        uint64_t v10 = *v9;
        float v11 = (std::__shared_weak_count *)v9[1];
        if (v11)
        {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
          int v12 = *(_DWORD *)(v10 + 252);
          if (atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            if (!v12) {
              goto LABEL_14;
            }
          }
          else
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
            if (!v12)
            {
LABEL_14:
              uint64_t v13 = *(void *)v6->n128_u64[0];
              uint64_t v14 = *(void **)(v13 + 24);
              float v15 = *(std::__shared_weak_count **)(v13 + 32);
              unint64_t v208 = v14;
              unint64_t v209 = v15;
              if (v15) {
                atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              uint64_t v16 = *v14;
              if (!*(unsigned char *)(v16 + 80) || (sub_1D0E75EF8(a4, v16 + 48) & 0x80) == 0)
              {
                uint64_t v17 = *(float **)v6->n128_u64[0];
                float v18 = v17[11];
                float v19 = v17[12];
                float v20 = v17[13];
                float v21 = v17[14];
                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
                  && __cxa_guard_acquire(&qword_1EB9F1610))
                {
                  qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
                  __cxa_guard_release(&qword_1EB9F1610);
                }
                uint64_t v22 = (id)qword_1EB9F1620;
                if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
                {
                  log = v22;
                  uint64_t v23 = *v208;
                  float v24 = *(void **)v6->n128_u64[0];
                  uint64_t v25 = (std::__shared_weak_count *)v24[16];
                  if (v25)
                  {
                    int v26 = (uint64_t *)(*(void *)(v24[12] + ((v24[15] >> 4) & 0xFFFFFFFFFFFFFF8))
                                    + 32 * (v24[15] & 0x7FLL));
                    uint64_t v27 = *v26;
                    uint64_t v25 = (std::__shared_weak_count *)v26[1];
                    if (v25) {
                      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                  }
                  else
                  {
                    uint64_t v27 = 0;
                  }
                  uint64_t v200 = v27;
                  uint64_t v201 = v25;
                  long long v28 = *(_OWORD *)(v27 + 48);
                  v202[0] = *(_OWORD *)(v27 + 32);
                  v202[1] = v28;
                  int v203 = *(_DWORD *)(v27 + 64);
                  uint64_t v204 = *(void *)(v27 + 68);
                  int v205 = *(_DWORD *)(v27 + 76);
                  sub_1D0E4CF2C((uint64_t)&v210);
                  int v190 = v6;
                  uint64_t v29 = *(void *)((char *)v212 + *((void *)v210 - 3));
                  sub_1D0E4CF2C((uint64_t)v233);
                  uint64_t v30 = 0;
                  uint64_t v189 = v23 + 160;
                  double v31 = (float)(v18 + (float)(v20 * 0.5));
                  *(void *)((char *)&v235[2] + *(void *)(v235[0] - 24)) = (int)v29;
                  float v32 = v202;
                  while (1)
                  {
                    uint64_t v195 = v30;
                    for (uint64_t i = 0; i != 48; i += 12)
                    {
                      long long v34 = (void *)std::ostream::operator<<();
                      MEMORY[0x1D25F13D0](v215, v34);
                      if (v215[0])
                      {
                        float v35 = (char *)v34 + *(void *)(*v34 - 24);
                        uint64_t v36 = *((void *)v35 + 5);
                        int v37 = *((_DWORD *)v35 + 2);
                        int v38 = *((_DWORD *)v35 + 36);
                        if (v38 == -1)
                        {
                          std::ios_base::getloc((const std::ios_base *)((char *)v34 + *(void *)(*v34 - 24)));
                          float v39 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
                          int v38 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v39->__vftable[2].~facet_0)(v39, 32);
                          std::locale::~locale(&__b);
                          *((_DWORD *)v35 + 36) = v38;
                        }
                        if ((v37 & 0xB0) == 0x20) {
                          float v40 = "";
                        }
                        else {
                          float v40 = " ";
                        }
                        if (!v36) {
                          goto LABEL_26;
                        }
                        uint64_t v41 = *((void *)v35 + 3);
                        BOOL v42 = v41 <= 1;
                        uint64_t v43 = v41 - 1;
                        size_t v44 = v42 ? 0 : v43;
                        if (v40 - " " >= 1
                          && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v36 + 96))(v36, " ", v40 - " ") != v40 - " ")
                        {
                          goto LABEL_26;
                        }
                        if ((uint64_t)v44 >= 1)
                        {
                          if (v44 > 0x7FFFFFFFFFFFFFF7) {
                            abort();
                          }
                          if (v44 >= 0x17)
                          {
                            uint64_t v46 = (v44 & 0xFFFFFFFFFFFFFFF8) + 8;
                            if ((v44 | 7) != 0x17) {
                              uint64_t v46 = v44 | 7;
                            }
                            uint64_t v47 = v46 + 1;
                            p_b = (std::locale::__imp *)operator new(v46 + 1);
                            int64_t v218 = v47 | 0x8000000000000000;
                            __b.__locale_ = p_b;
                            size_t v217 = v44;
                          }
                          else
                          {
                            HIBYTE(v218) = v44;
                            p_b = (std::locale::__imp *)&__b;
                          }
                          memset(p_b, v38, v44);
                          *((unsigned char *)p_b + v44) = 0;
                          if (v218 >= 0) {
                            locale = &__b;
                          }
                          else {
                            locale = __b.__locale_;
                          }
                          uint64_t v49 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v36 + 96))(v36, locale, v44);
                          uint64_t v50 = v49;
                          if (SHIBYTE(v218) < 0)
                          {
                            operator delete(__b.__locale_);
                            if (v50 != v44) {
                              goto LABEL_26;
                            }
                          }
                          else if (v49 != v44)
                          {
                            goto LABEL_26;
                          }
                        }
                        uint64_t v51 = " " - v40 + 1;
                        if (v51 >= 1
                          && (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v36 + 96))(v36, v40, " " - v40 + 1) != v51)
                        {
LABEL_26:
                          std::ios_base::clear((std::ios_base *)((char *)v34 + *(void *)(*v34 - 24)), *(_DWORD *)((char *)v34 + *(void *)(*v34 - 24) + 32) | 5);
                          goto LABEL_27;
                        }
                        *((void *)v35 + 3) = 0;
                      }
LABEL_27:
                      MEMORY[0x1D25F13E0](v215);
                    }
                    sub_1D0E25008(v235, (uint64_t)"\n", 1);
                    uint64_t v30 = v195 + 1;
                    float v32 = (_OWORD *)((char *)v32 + 4);
                    if (v195 == 2)
                    {
                      if ((v242 & 0x10) != 0)
                      {
                        unint64_t v54 = v241;
                        uint64_t v55 = (const void **)&v237;
                        float v6 = v190;
                        float v7 = v188;
                        if (v241 < v238)
                        {
                          unint64_t v241 = v238;
                          unint64_t v54 = v238;
                          uint64_t v55 = (const void **)&v237;
                        }
                      }
                      else
                      {
                        float v6 = v190;
                        float v7 = v188;
                        if ((v242 & 8) == 0)
                        {
                          size_t v52 = 0;
                          HIBYTE(v207) = 0;
                          unint64_t v53 = __dst;
                          goto LABEL_72;
                        }
                        unint64_t v54 = v236[2];
                        uint64_t v55 = (const void **)v236;
                      }
                      uint64_t v56 = *v55;
                      size_t v52 = v54 - (void)*v55;
                      if (v52 > 0x7FFFFFFFFFFFFFF7) {
                        abort();
                      }
                      if (v52 >= 0x17)
                      {
                        uint64_t v57 = (v52 & 0xFFFFFFFFFFFFFFF8) + 8;
                        if ((v52 | 7) != 0x17) {
                          uint64_t v57 = v52 | 7;
                        }
                        uint64_t v58 = v57 + 1;
                        unint64_t v53 = (void **)operator new(v57 + 1);
                        __dst[1] = (void *)v52;
                        int64_t v207 = v58 | 0x8000000000000000;
                        __dst[0] = v53;
                      }
                      else
                      {
                        HIBYTE(v207) = v54 - *(unsigned char *)v55;
                        unint64_t v53 = __dst;
                        if (!v52)
                        {
LABEL_72:
                          *((unsigned char *)v53 + v52) = 0;
                          *(void *)uint64_t v233 = v187;
                          *(void *)&v233[*(v187 - 3)] = v186;
                          v235[0] = v185;
                          v235[1] = MEMORY[0x1E4FBA470] + 16;
                          if (v240 < 0) {
                            operator delete(__p);
                          }
                          std::streambuf::~streambuf();
                          std::iostream::~basic_iostream();
                          MEMORY[0x1D25F1640](v243);
                          size_t v210 = v187;
                          *(void **)((char *)&v210 + *(v187 - 3)) = v186;
                          v212[0] = v185;
                          v212[1] = MEMORY[0x1E4FBA470] + 16;
                          if (v213 < 0) {
                            operator delete((void *)v212[9]);
                          }
                          std::streambuf::~streambuf();
                          std::iostream::~basic_iostream();
                          MEMORY[0x1D25F1640](&v214);
                          BOOL v59 = *(void *)(*v208 + 24) != *(void *)(*v208 + 32);
                          int v60 = (void **)__dst[0];
                          if (v207 >= 0) {
                            int v60 = __dst;
                          }
                          *(_DWORD *)int buf = 136316674;
                          uint64_t v220 = v189;
                          __int16 v221 = 2048;
                          double v222 = v31;
                          __int16 v223 = 2048;
                          double v224 = (float)(v19 + (float)(v21 * 0.5));
                          __int16 v225 = 2048;
                          double v226 = v20;
                          __int16 v227 = 2048;
                          double v228 = v21;
                          __int16 v229 = 2080;
                          uint64_t v230 = v60;
                          __int16 v231 = 1024;
                          BOOL v232 = v59;
                          _os_log_impl(&dword_1D0DBD000, log, OS_LOG_TYPE_DEFAULT, "request faceprint for user %s at (%.0f,%.0f), bbox size (%.0f,%.0f), pose=%s, isRepresented=%d", buf, 0x44u);
                          if (SHIBYTE(v207) < 0) {
                            operator delete(__dst[0]);
                          }
                          int64_t v61 = v201;
                          if (v201 && !atomic_fetch_add(&v201->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
                            std::__shared_weak_count::__release_weak(v61);
                          }
                          uint64_t v22 = log;
                          break;
                        }
                      }
                      memmove(v53, v56, v52);
                      goto LABEL_72;
                    }
                  }
                }

                float v62 = v198;
                if ((unint64_t)v198 >= v199)
                {
                  float v64 = sub_1D0DF9A20((uint64_t)&v197, *v6);
                }
                else
                {
                  v198->n128_u64[0] = v6->n128_u64[0];
                  unint64_t v63 = v6->n128_u64[1];
                  v62->n128_u64[1] = v63;
                  if (v63) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v63 + 8), 1uLL, memory_order_relaxed);
                  }
                  float v64 = v62 + 1;
                }
                uint8x8_t v198 = v64;
                float v15 = v209;
              }
              if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
                std::__shared_weak_count::__release_weak(v15);
              }
            }
          }
        }
        else if (!*(_DWORD *)(v10 + 252))
        {
          goto LABEL_14;
        }
      }
      if (++v6 == v7)
      {
        int64_t v66 = v197;
        uint64_t v65 = v198;
        goto LABEL_97;
      }
    }
  }
  int64_t v66 = 0;
  uint64_t v65 = 0;
LABEL_97:
  size_t v210 = 0;
  int v211 = 0;
  v212[0] = 0;
  sub_1D0E02E24((uint64_t)&v210, ((char *)v65 - v66) >> 4);
  if (v197 != v198) {
    operator new();
  }
  unint64_t v67 = v211;
  if (v210 != v211)
  {
    uint64_t v68 = *(void ****)(*(void *)(a1 + 8) + 8);
    unsigned __int8 v69 = atomic_load((unsigned __int8 *)*v68 + 248);
    if (v69)
    {
      unint64_t v86 = (std::mutex *)(*v68 + 14);
      std::mutex::lock(v86);
      uint64_t v101 = *v68;
      if (*((int *)*v68 + 26) >= 3)
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1610))
        {
          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
          __cxa_guard_release(&qword_1EB9F1610);
        }
        uint64_t v102 = qword_1EB9F1620;
        if (os_log_type_enabled((os_log_t)qword_1EB9F1620, OS_LOG_TYPE_DEBUG))
        {
          int v103 = *((_DWORD *)*v68 + 26);
          *(_DWORD *)uint64_t v233 = 67109120;
          *(_DWORD *)&v233[4] = v103;
          _os_log_debug_impl(&dword_1D0DBD000, v102, OS_LOG_TYPE_DEBUG, "Dropping faceprint task groups (too many %i)", v233, 8u);
        }
        goto LABEL_216;
      }
      unint64_t v104 = (uint64_t *)v211;
      if (v210 != v211)
      {
        unint64_t v105 = v211 - (unsigned char *)v210 - 16;
        uint64_t v106 = (uint64_t *)v210;
        if (v105 < 0x10) {
          goto LABEL_246;
        }
        uint64_t v107 = (v105 >> 4) + 1;
        uint64_t v106 = (uint64_t *)((char *)v210 + 16 * (v107 & 0x1FFFFFFFFFFFFFFELL));
        int64_t v108 = (uint64_t *)((char *)v210 + 16);
        uint64_t v109 = v107 & 0x1FFFFFFFFFFFFFFELL;
        do
        {
          uint64_t v110 = *(v108 - 2);
          uint64_t v111 = *v108;
          v108 += 4;
          uint64_t v112 = **(void **)(v111 + 32);
          *(unsigned char *)(**(void **)(v110 + 32) + 168) = 1;
          *(unsigned char *)(v112 + 168) = 1;
          v109 -= 2;
        }
        while (v109);
        if (v107 != (v107 & 0x1FFFFFFFFFFFFFFELL))
        {
LABEL_246:
          do
          {
            uint64_t v113 = *v106;
            v106 += 2;
            *(unsigned char *)(**(void **)(v113 + 32) + 168) = 1;
          }
          while (v106 != v104);
        }
      }
      CVPixelBufferRetain(texture);
      uint64_t v114 = (char *)v210;
      char v115 = v211;
      size_t v116 = v211 - (unsigned char *)v210;
      if (v211 == v210)
      {
        uint64_t v128 = 0;
        long long v118 = 0;
      }
      else
      {
        if ((v116 & 0x8000000000000000) != 0) {
          goto LABEL_240;
        }
        uint64_t v117 = (char *)operator new(v116);
        long long v118 = v117;
        uint64_t v119 = 0;
        do
        {
          unint64_t v120 = &v114[v119];
          unint64_t v121 = &v117[v119];
          *(void *)unint64_t v121 = *(void *)&v114[v119];
          uint64_t v122 = *(void *)&v114[v119 + 8];
          *((void *)v121 + 1) = v122;
          if (v122) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v122 + 8), 1uLL, memory_order_relaxed);
          }
          v119 += 16;
        }
        while (v120 + 16 != v115);
        uint64_t v128 = &v117[v119];
      }
      int v129 = (*v68)[11];
      uint64_t v130 = (std::__shared_weak_count *)operator new(0x40uLL);
      v130->__shared_owners_ = 0;
      v130->__shared_weak_owners_ = 0;
      v130->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4F00;
      v130[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4160;
      CVPixelBufferRetain(texture);
      int64_t v131 = v128 - v118;
      unint64_t v196 = v86;
      if (v128 == v118)
      {
        unint64_t v140 = 0;
        unint64_t v139 = 0;
        BOOL v134 = 0;
      }
      else
      {
        if (v131 < 0) {
          goto LABEL_240;
        }
        uint64_t v132 = v131 >> 4;
        char v133 = (char *)operator new(v131);
        BOOL v134 = v133;
        uint64_t v135 = 0;
        do
        {
          unint64_t v136 = &v118[v135];
          unint64_t v137 = &v133[v135];
          uint64_t v138 = *(void *)&v118[v135 + 8];
          *(void *)unint64_t v137 = *(void *)&v118[v135];
          *((void *)v137 + 1) = v138;
          if (v138) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v138 + 8), 1uLL, memory_order_relaxed);
          }
          v135 += 16;
        }
        while (v136 + 16 != v128);
        unint64_t v139 = &v133[v135];
        unint64_t v140 = &v133[16 * v132];
      }
      unint64_t v141 = operator new(0x40uLL);
      *unint64_t v141 = &unk_1F26F4790;
      v141[1] = sub_1D0E02B08;
      v141[2] = 0;
      v141[3] = v101;
      v141[4] = texture;
      v141[5] = v134;
      v141[6] = v139;
      v141[7] = v140;
      v130[2].__shared_owners_ = (uint64_t)v141;
      *(void *)uint64_t v233 = v130 + 1;
      long long v234 = v130;
      char v142 = (*(uint64_t (**)(void *, uint8_t *))(*(void *)v129 + 16))(v129, v233);
      int v143 = v234;
      if (v234 && !atomic_fetch_add(&v234->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v143->__on_zero_shared)(v143);
        std::__shared_weak_count::__release_weak(v143);
      }
      unint64_t v86 = v196;
      if (v142)
      {
        ++*((_DWORD *)*v68 + 26);
        unint64_t v144 = texture;
      }
      else
      {
        unint64_t v145 = (uint64_t *)v211;
        unint64_t v144 = texture;
        if (v210 != v211)
        {
          unint64_t v146 = v211 - (unsigned char *)v210 - 16;
          int v147 = (uint64_t *)v210;
          if (v146 < 0x10) {
            goto LABEL_247;
          }
          uint64_t v148 = (v146 >> 4) + 1;
          int v147 = (uint64_t *)((char *)v210 + 16 * (v148 & 0x1FFFFFFFFFFFFFFELL));
          uint64_t v149 = (uint64_t *)((char *)v210 + 16);
          uint64_t v150 = v148 & 0x1FFFFFFFFFFFFFFELL;
          do
          {
            uint64_t v151 = *(v149 - 2);
            uint64_t v152 = *v149;
            v149 += 4;
            uint64_t v153 = **(void **)(v152 + 32);
            *(unsigned char *)(**(void **)(v151 + 32) + 168) = 0;
            *(unsigned char *)(v153 + 168) = 0;
            v150 -= 2;
          }
          while (v150);
          if (v148 != (v148 & 0x1FFFFFFFFFFFFFFELL))
          {
LABEL_247:
            do
            {
              uint64_t v154 = *v147;
              v147 += 2;
              *(unsigned char *)(**(void **)(v154 + 32) + 168) = 0;
            }
            while (v147 != v145);
          }
        }
      }
      if (v118)
      {
        if (v128 != v118)
        {
          do
          {
            int v155 = (std::__shared_weak_count *)*((void *)v128 - 1);
            if (v155 && !atomic_fetch_add(&v155->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v155->__on_zero_shared)(v155);
              std::__shared_weak_count::__release_weak(v155);
            }
            v128 -= 16;
          }
          while (v128 != v118);
          uint64_t v128 = v118;
          unint64_t v144 = texture;
        }
        operator delete(v128);
      }
      CVPixelBufferRelease(v144);
      goto LABEL_216;
    }
    uint64_t v70 = (uint64_t *)v210;
    uint64_t v71 = (uint64_t *)v211;
    if (v210 != v211)
    {
      unint64_t v72 = v211 - (unsigned char *)v210 - 16;
      uint64_t v73 = (v72 >> 4) + 1;
      unint64_t v74 = (uint64_t *)v210;
      if (v72 < 0x10) {
        goto LABEL_248;
      }
      unint64_t v74 = (uint64_t *)((char *)v210 + 16 * (v73 & 0x1FFFFFFFFFFFFFFELL));
      uint64_t v75 = (uint64_t *)((char *)v210 + 16);
      uint64_t v76 = v73 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        uint64_t v77 = *(v75 - 2);
        uint64_t v78 = *v75;
        v75 += 4;
        uint64_t v79 = **(void **)(v78 + 32);
        *(unsigned char *)(**(void **)(v77 + 32) + 168) = 1;
        *(unsigned char *)(v79 + 168) = 1;
        v76 -= 2;
      }
      while (v76);
      if (v73 != (v73 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_248:
        do
        {
          uint64_t v80 = *v74;
          v74 += 2;
          *(unsigned char *)(**(void **)(v80 + 32) + 168) = 1;
        }
        while (v74 != v71);
      }
      if (v72 <= 0xF) {
        goto LABEL_112;
      }
      uint64_t v81 = v70 + 2;
      uint64_t v82 = v73 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        uint64_t v83 = *(v81 - 2);
        uint64_t v84 = *v81;
        v81 += 4;
        *(_DWORD *)(v83 + 120) = 2;
        *(_DWORD *)(v84 + 120) = 2;
        v82 -= 2;
      }
      while (v82);
      if (v73 != (v73 & 0x1FFFFFFFFFFFFFFELL))
      {
        v70 += 2 * (v73 & 0x1FFFFFFFFFFFFFFELL);
        do
        {
LABEL_112:
          uint64_t v85 = *v70;
          v70 += 2;
          *(_DWORD *)(v85 + 120) = 2;
        }
        while (v70 != v71);
      }
    }
    unint64_t v86 = (std::mutex *)(*v68 + 3);
    std::mutex::lock(v86);
    int32x4_t v88 = (char *)v210;
    unint64_t v87 = v211;
    if (v211 - (unsigned char *)v210 >= 1)
    {
      uint64_t v89 = *v68;
      uint64_t v90 = (v211 - (unsigned char *)v210) >> 4;
      long long v91 = *v89;
      unint64_t v92 = (unint64_t)v89[1];
      uint64_t v93 = v92 - (void)*v89;
      uint64_t v94 = v93 >> 4;
      unint64_t v95 = (unint64_t)*v89 + (v93 & 0xFFFFFFFFFFFFFFF0);
      uint64_t v96 = v89[2];
      if (v90 > (uint64_t)&v96[-v92] >> 4)
      {
        unint64_t v97 = v94 + v90;
        if (!((unint64_t)(v94 + v90) >> 60))
        {
          uint64_t v98 = v96 - (unsigned char *)v91;
          if (v98 >> 3 > v97) {
            unint64_t v97 = v98 >> 3;
          }
          if ((unint64_t)v98 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v99 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v99 = v97;
          }
          if (v99)
          {
            if (v99 >> 60) {
              sub_1D0DE8CE0();
            }
            uint64_t v100 = (char *)operator new(16 * v99);
          }
          else
          {
            uint64_t v100 = 0;
          }
          unint64_t v156 = &v100[16 * v94];
          uint64_t v157 = &v156[16 * v90];
          uint64_t v158 = v156;
          do
          {
            *(void *)uint64_t v158 = *(void *)v88;
            uint64_t v159 = *((void *)v88 + 1);
            *((void *)v158 + 1) = v159;
            if (v159) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v159 + 8), 1uLL, memory_order_relaxed);
            }
            v158 += 16;
            v88 += 16;
          }
          while (v158 != v157);
          uint64_t v160 = *v89;
          if (*v89 != (void *)v95)
          {
            unint64_t v161 = (void *)v95;
            do
            {
              long long v162 = *((_OWORD *)v161 - 1);
              v161 -= 2;
              *((_OWORD *)v156 - 1) = v162;
              v156 -= 16;
              *unint64_t v161 = 0;
              v161[1] = 0;
            }
            while (v161 != v160);
          }
          uint64_t v163 = v89[1];
          if (v163 != (void *)v95)
          {
            do
            {
              *(_OWORD *)uint64_t v157 = *(_OWORD *)v95;
              v157 += 16;
              *(void *)unint64_t v95 = 0;
              *(void *)(v95 + 8) = 0;
              v95 += 16;
            }
            while ((void *)v95 != v163);
            unint64_t v95 = (unint64_t)v89[1];
          }
          uint64_t v164 = *v89;
          *uint64_t v89 = v156;
          v89[1] = v157;
          for (v89[2] = &v100[16 * v99]; (void *)v95 != v164; v95 -= 16)
          {
            uint64_t v165 = *(std::__shared_weak_count **)(v95 - 8);
            if (v165 && !atomic_fetch_add(&v165->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v165->__on_zero_shared)(v165);
              std::__shared_weak_count::__release_weak(v165);
            }
          }
          if (v164) {
            operator delete(v164);
          }
          goto LABEL_216;
        }
LABEL_240:
        abort();
      }
      uint64_t v123 = (uint64_t)(v92 - v95) >> 4;
      if (v123 >= v90)
      {
        BOOL v124 = (char *)v210 + 16 * v90;
        long long v126 = (char *)v89[1];
      }
      else
      {
        BOOL v124 = (char *)v210 + 16 * v123;
        if (v124 == v211)
        {
          long long v126 = (char *)v89[1];
        }
        else
        {
          uint64_t v125 = (char *)v210 + 16 * v123;
          long long v126 = (char *)v89[1];
          do
          {
            *(void *)long long v126 = *v125;
            uint64_t v127 = v125[1];
            *((void *)v126 + 1) = v127;
            if (v127) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v127 + 8), 1uLL, memory_order_relaxed);
            }
            v126 += 16;
            v125 += 2;
          }
          while (v125 != v87);
        }
        v89[1] = v126;
        if ((uint64_t)(v92 - v95) < 1) {
          goto LABEL_216;
        }
      }
      uint64_t v166 = (char *)(v95 + 16 * v90);
      unint64_t v167 = &v126[-16 * v90];
      int v168 = v126;
      if ((unint64_t)v167 < v92)
      {
        int v168 = v126;
        do
        {
          *(_OWORD *)int v168 = *(_OWORD *)v167;
          v168 += 16;
          *(void *)unint64_t v167 = 0;
          *((void *)v167 + 1) = 0;
          v167 += 16;
        }
        while ((unint64_t)v167 < v92);
      }
      v89[1] = v168;
      if (v126 != v166)
      {
        size_t v169 = (std::__shared_weak_count **)(v126 - 8);
        uint64_t v170 = 16 * ((v126 - v166) >> 4);
        uint64_t v171 = (uint64_t)&v91[2 * v94 - 2];
        do
        {
          uint64_t v172 = (void *)(v171 + v170);
          long long v173 = *(_OWORD *)(v171 + v170);
          *uint64_t v172 = 0;
          v172[1] = 0;
          int v174 = *v169;
          *(_OWORD *)(v169 - 1) = v173;
          if (v174 && !atomic_fetch_add(&v174->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v174->__on_zero_shared)(v174);
            std::__shared_weak_count::__release_weak(v174);
          }
          v169 -= 2;
          v170 -= 16;
        }
        while (v170);
      }
      for (; v88 != v124; v95 += 16)
      {
        uint64_t v176 = *(void *)v88;
        uint64_t v175 = *((void *)v88 + 1);
        if (v175) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v175 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v177 = *(std::__shared_weak_count **)(v95 + 8);
        *(void *)unint64_t v95 = v176;
        *(void *)(v95 + 8) = v175;
        if (v177 && !atomic_fetch_add(&v177->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v177->__on_zero_shared)(v177);
          std::__shared_weak_count::__release_weak(v177);
        }
        v88 += 16;
      }
    }
LABEL_216:
    std::mutex::unlock(v86);
    unint64_t v67 = (char *)v210;
  }
  if (v67)
  {
    int v178 = v211;
    uint64_t v179 = v67;
    if (v211 != v67)
    {
      do
      {
        int v180 = (std::__shared_weak_count *)*((void *)v178 - 1);
        if (v180 && !atomic_fetch_add(&v180->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v180->__on_zero_shared)(v180);
          std::__shared_weak_count::__release_weak(v180);
        }
        v178 -= 16;
      }
      while (v178 != v67);
      uint64_t v179 = v210;
    }
    int v211 = v67;
    operator delete(v179);
  }
  uint64_t v181 = (__n128 *)v197;
  if (v197)
  {
    long long v182 = v198;
    long long v183 = v197;
    if (v198 != v197)
    {
      do
      {
        uint64_t v184 = (std::__shared_weak_count *)v182[-1].n128_u64[1];
        if (v184)
        {
          if (!atomic_fetch_add(&v184->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v184->__on_zero_shared)(v184);
            std::__shared_weak_count::__release_weak(v184);
          }
        }
        --v182;
      }
      while (v182 != v181);
      long long v183 = v197;
    }
    uint8x8_t v198 = v181;
    operator delete(v183);
  }
}

void sub_1D0E4CB9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,char a53)
{
  sub_1D0DCA2C0((uint64_t)&a51);
  sub_1D0DF76BC(&a36);
  _Unwind_Resume(a1);
}

void sub_1D0E4CC98(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1D0E4CD08(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    if (*(char *)(v1 + 151) < 0) {
      operator delete(*(void **)(v1 + 128));
    }
    free(*(void **)(v1 + 96));
    unint64_t v3 = *(std::__shared_weak_count **)(v1 + 40);
    if (v3)
    {
      if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    MEMORY[0x1D25F16B0](v1, 0x10B2C4023166585);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D0E4CD90(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 16;
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1D0E4CE3C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    if (*(char *)(v1 + 151) < 0) {
      operator delete(*(void **)(v1 + 128));
    }
    free(*(void **)(v1 + 96));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 40);
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    JUMPOUT(0x1D25F16B0);
  }
  return result;
}

void sub_1D0E4CEF0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

uint64_t sub_1D0E4CF2C(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA488] + 104;
  *(void *)(a1 + 128) = MEMORY[0x1E4FBA488] + 104;
  uint64_t v3 = a1 + 16;
  uint64_t v4 = MEMORY[0x1E4FBA488] + 64;
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA488] + 64;
  uint64_t v5 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  uint64_t v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  uint64_t v9 = MEMORY[0x1E4FBA488] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v10 = v5[5];
  uint64_t v11 = v5[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v3 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v5[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v5[6];
  *(void *)a1 = v9;
  *(void *)(a1 + 128) = v2;
  *(void *)(a1 + 16) = v4;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_1D0E4D1DC(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x1D25F1640](v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1D0E4D204(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA408];
  uint64_t v3 = *MEMORY[0x1E4FBA408];
  *(void *)a1 = *MEMORY[0x1E4FBA408];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D25F1640](a1 + 128);
  return a1;
}

void sub_1D0E4D33C(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F26F3FF8;
  a1[1] = 0;
  if (v2) {
    sub_1D0E4D3A8(v2);
  }
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E4D3A8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_1D0E1F910(*(void **)(a1 + 40));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = *(void ***)a1;
  *(void *)a1 = 0;
  if (v4)
  {
    uint64_t v5 = (char *)*v4;
    if (*v4)
    {
      uint64_t v6 = (char *)v4[1];
      uint64_t v7 = *v4;
      if (v6 != v5)
      {
        do
        {
          uint64_t v8 = (std::__shared_weak_count *)*((void *)v6 - 1);
          if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
          v6 -= 16;
        }
        while (v6 != v5);
        uint64_t v7 = *v4;
      }
      v4[1] = v5;
      operator delete(v7);
    }
    MEMORY[0x1D25F16B0](v4, 0x1020C4055CCDE27);
  }
  JUMPOUT(0x1D25F16B0);
}

void *sub_1D0E4D538(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F26F3FF8;
  a1[1] = 0;
  if (v2) {
    sub_1D0E4D3A8(v2);
  }
  return a1;
}

uint64_t sub_1D0E4D588(uint64_t result)
{
  uint64_t v1 = *(char ***)(result + 24);
  if (v1)
  {
    uint64_t v2 = (uint64_t)v1[11];
    if (v2) {
      sub_1D0E79664(v2, 0);
    }
    uint64_t v3 = (std::__shared_weak_count *)v1[30];
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    std::condition_variable::~condition_variable((std::condition_variable *)(v1 + 23));
    std::mutex::~mutex((std::mutex *)(v1 + 14));
    uint64_t v4 = (std::__shared_weak_count *)v1[12];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    std::mutex::~mutex((std::mutex *)(v1 + 3));
    uint64_t v5 = *v1;
    if (*v1)
    {
      uint64_t v6 = v1[1];
      uint64_t v7 = *v1;
      if (v6 != v5)
      {
        do
        {
          uint64_t v8 = (std::__shared_weak_count *)*((void *)v6 - 1);
          if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
          v6 -= 16;
        }
        while (v6 != v5);
        uint64_t v7 = *v1;
      }
      v1[1] = v5;
      operator delete(v7);
    }
    JUMPOUT(0x1D25F16B0);
  }
  return result;
}

void sub_1D0E4D72C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4E58;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E4D780(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4E58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0E4D7A0(uint64_t a1, uint64_t a2, unsigned int *a3, void *a4, long long *a5, unsigned int *a6, float a7)
{
  uint64_t v14 = (std::mutex *)(a1 + 160);
  std::mutex::lock((std::mutex *)(a1 + 160));
  *(unsigned char *)(a1 + 40) = a2 != 0;
  if (!a2) {
    goto LABEL_30;
  }
  uint64_t v15 = *(void *)(a2 + 8);
  if (v15 <= *(_DWORD *)(a1 + 16) && HIDWORD(v15) <= *(_DWORD *)(a1 + 20))
  {
    uint64_t v19 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = v15;
    float v18 = *(char **)(a1 + 32);
    uint64_t v20 = *(void *)(a2 + 24);
    if (!v20) {
      goto LABEL_30;
    }
    goto LABEL_15;
  }
  uint64_t v17 = *(void **)(a1 + 32);
  if (v17)
  {
    free(v17);
    *(void *)(a1 + 32) = 0;
  }
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v15;
  *(void *)(a1 + 24) = ((unint64_t)(((4 * v15 + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
  size_t size = ((4 * v15 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v15);
  if (size)
  {
    float v18 = (char *)malloc_type_malloc(size, 0xA153FF5uLL);
    uint64_t v19 = *(void *)(a1 + 8);
  }
  else
  {
    uint64_t v19 = 0;
    float v18 = 0;
  }
  *(void *)(a1 + 32) = v18;
  uint64_t v20 = *(void *)(a2 + 24);
  if (v20)
  {
LABEL_15:
    unint64_t v21 = *(void *)(a2 + 16);
    uint64_t v22 = (*(_DWORD *)(a2 + 12) * HIDWORD(v21));
    if (v22)
    {
      int v23 = 0;
      int v24 = 0;
      unint64_t v25 = *(void *)(a1 + 24);
      int v26 = *(_DWORD *)(a1 + 16);
      int v27 = *(_DWORD *)(a2 + 8);
      long long v28 = (_DWORD *)(v20 + *(void *)a2);
      uint64_t v29 = (_DWORD *)((char *)v28 + v22);
      uint64_t v30 = &v18[v19];
      if (v18) {
        double v31 = v30;
      }
      else {
        double v31 = 0;
      }
      do
      {
        _DWORD *v31 = *v28;
        long long v28 = (_DWORD *)((char *)v28 + v21);
        int v32 = v24 + 1;
        if (v24 + 1 == v27) {
          int v24 = 0;
        }
        else {
          ++v24;
        }
        if (v32 == v27) {
          long long v28 = (_DWORD *)((char *)v28 + HIDWORD(v21) - (v32 * v21));
        }
        double v31 = (_DWORD *)((char *)v31 + v25);
        int v33 = v23 + 1;
        if (v23 + 1 == v26) {
          int v23 = 0;
        }
        else {
          ++v23;
        }
        if (v33 == v26) {
          double v31 = (_DWORD *)((char *)v31 + HIDWORD(v25) - (v33 * v25));
        }
      }
      while (v28 != v29);
    }
  }
LABEL_30:
  long long v34 = *(int **)(a1 + 48);
  unint64_t v35 = *a3;
  if (v35 == *(_DWORD *)(a1 + 64)) {
    goto LABEL_31;
  }
  if ((int *)(*((void *)a3 + 1) - 4 * a3[5]) == v34)
  {
    size_t v61 = (4 * v35 + 31) & 0x7FFFFFFE0;
    size_t size = 0;
    malloc_type_posix_memalign((void **)&size, 0x20uLL, v61, 0x49090899uLL);
    float v62 = (char *)size;
    uint64_t v63 = *a3;
    float v64 = (int *)*((void *)a3 + 1);
    if (&v64[-a3[5]] != (int *)size)
    {
      if (v63)
      {
        unint64_t v65 = (v63 - 1) & 0x3FFFFFFFFFFFFFFFLL;
        if (v65 < 7)
        {
          int64_t v66 = (char *)size;
        }
        else
        {
          int64_t v66 = (char *)size;
          if (size - (unint64_t)v64 >= 0x20)
          {
            uint64_t v67 = 0;
            uint64_t v68 = (v65 + 1) & 0x7FFFFFFFFFFFFFF8;
            uint64_t v69 = v68;
            do
            {
              uint64_t v70 = &v62[v67 * 4];
              long long v71 = *(_OWORD *)&v64[v67 + 4];
              *(_OWORD *)uint64_t v70 = *(_OWORD *)&v64[v67];
              *((_OWORD *)v70 + 1) = v71;
              v67 += 8;
              v69 -= 8;
            }
            while (v69);
            if (v65 + 1 == v68) {
              goto LABEL_74;
            }
            int64_t v66 = &v62[4 * v68];
            v64 += v68;
          }
        }
        do
        {
          int v86 = *v64++;
          *(_DWORD *)int64_t v66 = v86;
          v66 += 4;
        }
        while (v66 != &v62[4 * v63]);
      }
LABEL_74:
      size_t v73 = (size_t)v62;
LABEL_78:
      uint64_t v85 = *(void **)(a1 + 48);
      *(void *)(a1 + 48) = v73;
      *(void *)(a1 + 56) = v61 >> 2;
      *(_DWORD *)(a1 + 64) = v63;
      goto LABEL_79;
    }
    size_t size = 0;
    size_t v61 = (4 * v63 + 31) & 0x7FFFFFFE0;
    malloc_type_posix_memalign((void **)&size, 0x20uLL, v61, 0x49090899uLL);
    size_t v73 = size;
    if (v63)
    {
      unint64_t v74 = (int *)*((void *)a3 + 1);
      unint64_t v75 = (v63 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v75 < 7)
      {
        uint64_t v76 = (_DWORD *)size;
      }
      else
      {
        uint64_t v76 = (_DWORD *)size;
        if (size - (unint64_t)v74 >= 0x20)
        {
          unint64_t v77 = v75 + 1;
          uint64_t v78 = (v75 + 1) & 0x7FFFFFFFFFFFFFF8;
          uint64_t v79 = &v74[v78];
          uint64_t v80 = (_OWORD *)(size + 16);
          uint64_t v81 = (long long *)(v74 + 4);
          uint64_t v82 = v78;
          do
          {
            long long v83 = *v81;
            *(v80 - 1) = *(v81 - 1);
            *uint64_t v80 = v83;
            v80 += 2;
            v81 += 2;
            v82 -= 8;
          }
          while (v82);
          if (v77 == v78) {
            goto LABEL_77;
          }
          uint64_t v76 = (_DWORD *)(v73 + 4 * v78);
          unint64_t v74 = v79;
        }
      }
      do
      {
        int v87 = *v74++;
        *v76++ = v87;
      }
      while (v76 != (_DWORD *)(v73 + 4 * v63));
    }
LABEL_77:
    free(v62);
    goto LABEL_78;
  }
  *(_DWORD *)(a1 + 64) = v35;
  if (v35)
  {
    if (*(void *)(a1 + 56) < v35)
    {
      free(v34);
      size_t v47 = (4 * v35 + 31) & 0x7FFFFFFE0;
      *(void *)(a1 + 48) = 0;
      *(void *)(a1 + 56) = v47 >> 2;
      size_t size = 0;
      malloc_type_posix_memalign((void **)&size, 0x20uLL, v47, 0x49090899uLL);
      long long v34 = (int *)size;
      *(void *)(a1 + 48) = size;
    }
  }
  else
  {
    free(v34);
    long long v34 = 0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
  }
LABEL_31:
  uint64_t v36 = (int *)*((void *)a3 + 1);
  uint64_t v37 = *(unsigned int *)(a1 + 64);
  if (&v36[-a3[5]] == v34)
  {
    size_t v48 = (4 * v37 + 31) & 0x7FFFFFFE0;
    size_t v49 = v48 >> 2;
    size_t size = 0;
    malloc_type_posix_memalign((void **)&size, 0x20uLL, v48, 0x49090899uLL);
    size_t v50 = size;
    if (v37)
    {
      uint64_t v51 = (int *)*((void *)a3 + 1);
      unint64_t v52 = (v37 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v52 < 7)
      {
        unint64_t v53 = (_DWORD *)size;
      }
      else
      {
        unint64_t v53 = (_DWORD *)size;
        if (size - (unint64_t)v51 >= 0x20)
        {
          unint64_t v54 = v52 + 1;
          uint64_t v55 = (v52 + 1) & 0x7FFFFFFFFFFFFFF8;
          uint64_t v56 = &v51[v55];
          uint64_t v57 = (_OWORD *)(size + 16);
          uint64_t v58 = (long long *)(v51 + 4);
          uint64_t v59 = v55;
          do
          {
            long long v60 = *v58;
            *(v57 - 1) = *(v58 - 1);
            *uint64_t v57 = v60;
            v57 += 2;
            v58 += 2;
            v59 -= 8;
          }
          while (v59);
          if (v54 == v55) {
            goto LABEL_71;
          }
          unint64_t v53 = (_DWORD *)(v50 + 4 * v55);
          uint64_t v51 = v56;
        }
      }
      do
      {
        int v84 = *v51++;
        *v53++ = v84;
      }
      while (v53 != (_DWORD *)(v50 + 4 * v37));
    }
LABEL_71:
    uint64_t v85 = *(void **)(a1 + 48);
    *(void *)(a1 + 48) = v50;
    *(void *)(a1 + 56) = v49;
    *(_DWORD *)(a1 + 64) = v37;
LABEL_79:
    free(v85);
    goto LABEL_80;
  }
  if (!v37) {
    goto LABEL_80;
  }
  unint64_t v38 = (v37 - 1) & 0x3FFFFFFFFFFFFFFFLL;
  if (v38 < 7)
  {
    float v39 = v34;
    do
    {
LABEL_60:
      int v72 = *v36++;
      *v39++ = v72;
    }
    while (v39 != &v34[v37]);
    goto LABEL_80;
  }
  float v39 = v34;
  if ((unint64_t)((char *)v34 - (char *)v36) < 0x20) {
    goto LABEL_60;
  }
  unint64_t v40 = v38 + 1;
  uint64_t v41 = (v38 + 1) & 0x7FFFFFFFFFFFFFF8;
  BOOL v42 = &v36[v41];
  uint64_t v43 = v34 + 4;
  size_t v44 = (long long *)(v36 + 4);
  uint64_t v45 = v41;
  do
  {
    long long v46 = *v44;
    *(v43 - 1) = *(v44 - 1);
    *uint64_t v43 = v46;
    v43 += 2;
    v44 += 2;
    v45 -= 8;
  }
  while (v45);
  if (v40 != v41)
  {
    float v39 = &v34[v41];
    uint64_t v36 = v42;
    goto LABEL_60;
  }
LABEL_80:
  *(float *)(a1 + 72) = a7;
  if ((void *)(a1 + 76) != a4) {
    *(void *)(a1 + 76) = *a4;
  }
  if ((long long *)(a1 + 84) != a5)
  {
    long long v88 = *a5;
    long long v89 = a5[1];
    *(_DWORD *)(a1 + 116) = *((_DWORD *)a5 + 8);
    *(_OWORD *)(a1 + 84) = v88;
    *(_OWORD *)(a1 + 100) = v89;
    uint64_t v90 = *(void *)((char *)a5 + 36);
    *(_DWORD *)(a1 + 128) = *((_DWORD *)a5 + 11);
    *(void *)(a1 + 120) = v90;
  }
  long long v91 = *(int **)(a1 + 136);
  unint64_t v92 = *a6;
  if (v92 != *(_DWORD *)(a1 + 152))
  {
    if ((int *)(*((void *)a6 + 1) - 4 * a6[5]) != v91)
    {
      *(_DWORD *)(a1 + 152) = v92;
      if (v92)
      {
        if (*(void *)(a1 + 144) < v92)
        {
          free(v91);
          size_t v104 = (4 * v92 + 31) & 0x7FFFFFFE0;
          *(void *)(a1 + 136) = 0;
          *(void *)(a1 + 144) = v104 >> 2;
          size_t size = 0;
          malloc_type_posix_memalign((void **)&size, 0x20uLL, v104, 0x49090899uLL);
          long long v91 = (int *)size;
          *(void *)(a1 + 136) = size;
        }
      }
      else
      {
        free(v91);
        long long v91 = 0;
        *(void *)(a1 + 136) = 0;
        *(void *)(a1 + 144) = 0;
      }
      goto LABEL_85;
    }
    size_t v118 = (4 * v92 + 31) & 0x7FFFFFFE0;
    size_t size = 0;
    malloc_type_posix_memalign((void **)&size, 0x20uLL, v118, 0x49090899uLL);
    uint64_t v119 = (char *)size;
    uint64_t v120 = *a6;
    unint64_t v121 = (int *)*((void *)a6 + 1);
    if (&v121[-a6[5]] != (int *)size)
    {
      if (v120)
      {
        unint64_t v122 = (v120 - 1) & 0x3FFFFFFFFFFFFFFFLL;
        if (v122 < 7)
        {
          uint64_t v123 = (char *)size;
        }
        else
        {
          uint64_t v123 = (char *)size;
          if (size - (unint64_t)v121 >= 0x20)
          {
            uint64_t v124 = 0;
            uint64_t v125 = (v122 + 1) & 0x7FFFFFFFFFFFFFF8;
            uint64_t v126 = v125;
            do
            {
              uint64_t v127 = &v119[v124 * 4];
              long long v128 = *(_OWORD *)&v121[v124 + 4];
              *(_OWORD *)uint64_t v127 = *(_OWORD *)&v121[v124];
              *((_OWORD *)v127 + 1) = v128;
              v124 += 8;
              v126 -= 8;
            }
            while (v126);
            if (v122 + 1 == v125) {
              goto LABEL_128;
            }
            uint64_t v123 = &v119[4 * v125];
            v121 += v125;
          }
        }
        do
        {
          int v143 = *v121++;
          *(_DWORD *)uint64_t v123 = v143;
          v123 += 4;
        }
        while (v123 != &v119[4 * v120]);
      }
LABEL_128:
      size_t v130 = (size_t)v119;
LABEL_132:
      char v142 = *(void **)(a1 + 136);
      *(void *)(a1 + 136) = v130;
      *(void *)(a1 + 144) = v118 >> 2;
      *(_DWORD *)(a1 + 152) = v120;
      goto LABEL_133;
    }
    size_t v118 = (4 * v120 + 31) & 0x7FFFFFFE0;
    size_t size = 0;
    malloc_type_posix_memalign((void **)&size, 0x20uLL, v118, 0x49090899uLL);
    size_t v130 = size;
    if (v120)
    {
      int64_t v131 = (int *)*((void *)a6 + 1);
      unint64_t v132 = (v120 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v132 < 7)
      {
        char v133 = (_DWORD *)size;
      }
      else
      {
        char v133 = (_DWORD *)size;
        if (size - (unint64_t)v131 >= 0x20)
        {
          unint64_t v134 = v132 + 1;
          uint64_t v135 = (v132 + 1) & 0x7FFFFFFFFFFFFFF8;
          unint64_t v136 = &v131[v135];
          unint64_t v137 = (_OWORD *)(size + 16);
          uint64_t v138 = (long long *)(v131 + 4);
          uint64_t v139 = v135;
          do
          {
            long long v140 = *v138;
            *(v137 - 1) = *(v138 - 1);
            _OWORD *v137 = v140;
            v137 += 2;
            v138 += 2;
            v139 -= 8;
          }
          while (v139);
          if (v134 == v135) {
            goto LABEL_131;
          }
          char v133 = (_DWORD *)(v130 + 4 * v135);
          int64_t v131 = v136;
        }
      }
      do
      {
        int v144 = *v131++;
        *v133++ = v144;
      }
      while (v133 != (_DWORD *)(v130 + 4 * v120));
    }
LABEL_131:
    free(v119);
    goto LABEL_132;
  }
LABEL_85:
  uint64_t v93 = (int *)*((void *)a6 + 1);
  uint64_t v94 = *(unsigned int *)(a1 + 152);
  if (&v93[-a6[5]] == v91)
  {
    size_t v105 = (4 * v94 + 31) & 0x7FFFFFFE0;
    size_t v106 = v105 >> 2;
    size_t size = 0;
    malloc_type_posix_memalign((void **)&size, 0x20uLL, v105, 0x49090899uLL);
    size_t v107 = size;
    if (v94)
    {
      int64_t v108 = (int *)*((void *)a6 + 1);
      unint64_t v109 = (v94 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v109 < 7)
      {
        uint64_t v110 = (_DWORD *)size;
      }
      else
      {
        uint64_t v110 = (_DWORD *)size;
        if (size - (unint64_t)v108 >= 0x20)
        {
          unint64_t v111 = v109 + 1;
          uint64_t v112 = (v109 + 1) & 0x7FFFFFFFFFFFFFF8;
          uint64_t v113 = &v108[v112];
          uint64_t v114 = (_OWORD *)(size + 16);
          char v115 = (long long *)(v108 + 4);
          uint64_t v116 = v112;
          do
          {
            long long v117 = *v115;
            *(v114 - 1) = *(v115 - 1);
            *uint64_t v114 = v117;
            v114 += 2;
            v115 += 2;
            v116 -= 8;
          }
          while (v116);
          if (v111 == v112) {
            goto LABEL_125;
          }
          uint64_t v110 = (_DWORD *)(v107 + 4 * v112);
          int64_t v108 = v113;
        }
      }
      do
      {
        int v141 = *v108++;
        *v110++ = v141;
      }
      while (v110 != (_DWORD *)(v107 + 4 * v94));
    }
LABEL_125:
    char v142 = *(void **)(a1 + 136);
    *(void *)(a1 + 136) = v107;
    *(void *)(a1 + 144) = v106;
    *(_DWORD *)(a1 + 152) = v94;
LABEL_133:
    free(v142);
    goto LABEL_134;
  }
  if (!v94) {
    goto LABEL_134;
  }
  unint64_t v95 = (v94 - 1) & 0x3FFFFFFFFFFFFFFFLL;
  if (v95 < 7)
  {
    uint64_t v96 = v91;
    do
    {
LABEL_114:
      int v129 = *v93++;
      *v96++ = v129;
    }
    while (v96 != &v91[v94]);
    goto LABEL_134;
  }
  uint64_t v96 = v91;
  if ((unint64_t)((char *)v91 - (char *)v93) < 0x20) {
    goto LABEL_114;
  }
  unint64_t v97 = v95 + 1;
  uint64_t v98 = (v95 + 1) & 0x7FFFFFFFFFFFFFF8;
  unint64_t v99 = &v93[v98];
  uint64_t v100 = v91 + 4;
  uint64_t v101 = (long long *)(v93 + 4);
  uint64_t v102 = v98;
  do
  {
    long long v103 = *v101;
    *(v100 - 1) = *(v101 - 1);
    *uint64_t v100 = v103;
    v100 += 2;
    v101 += 2;
    v102 -= 8;
  }
  while (v102);
  if (v97 != v98)
  {
    uint64_t v96 = &v91[v98];
    uint64_t v93 = v99;
    goto LABEL_114;
  }
LABEL_134:
  std::mutex::unlock(v14);
  atomic_store(1u, (unsigned __int8 *)a1);
}

uint64_t sub_1D0E4E0D8(cva::DictionaryHandler *a1, uint64_t a2)
{
  if (!cva::DictionaryHandler::hasKey(a1, @"pose")) {
    return 0;
  }
  int v15 = 0;
  long long v13 = 0u;
  long long v14 = 0u;
  int v12 = 0;
  uint64_t v11 = 0;
  cva::DictionaryHandler::item(v8, a1, @"pose");
  cva::ItemHandler::getDictionary((uint64_t *)&v9, (cva::ItemHandler *)v8);
  uint64_t v4 = sub_1D0E3A600(v9);
  uint64_t v5 = v10;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v8);
  if (v4)
  {
    long long v6 = v14;
    *(_OWORD *)a2 = v13;
    *(_OWORD *)(a2 + 16) = v6;
    *(_DWORD *)(a2 + 32) = v15;
    *(void *)(a2 + 36) = v11;
    *(_DWORD *)(a2 + 44) = v12;
  }
  return v4;
}

uint64_t sub_1D0E4E1E4(uint64_t *a1, cva::DictionaryHandler *this, char a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (this)
  {
    uint64_t v5 = *a1;
    if (!*(unsigned char *)(*a1 + 264))
    {
      *(void *)(v5 + 256) = 0;
      *(_OWORD *)(v5 + 224) = 0u;
      *(_OWORD *)(v5 + 240) = 0u;
      *(_OWORD *)(v5 + 192) = 0u;
      *(_OWORD *)(v5 + 208) = 0u;
      *(_OWORD *)(v5 + 160) = 0u;
      *(_OWORD *)(v5 + 176) = 0u;
      *(_OWORD *)(v5 + 128) = 0u;
      *(_OWORD *)(v5 + 144) = 0u;
      *(_OWORD *)(v5 + 96) = 0u;
      *(_OWORD *)(v5 + 112) = 0u;
      *(_OWORD *)(v5 + 64) = 0u;
      *(_OWORD *)(v5 + 80) = 0u;
      *(_OWORD *)(v5 + 32) = 0u;
      *(_OWORD *)(v5 + 48) = 0u;
      *(_OWORD *)uint64_t v5 = 0u;
      *(_OWORD *)(v5 + 16) = 0u;
      *(unsigned char *)(v5 + 264) = 1;
    }
    *(unsigned char *)(v5 + 256) = a3;
    if (cva::DictionaryHandler::hasKey(this, @"meta"))
    {
      cva::DictionaryHandler::item((uint64_t *)buf, this, @"meta");
      cva::ItemHandler::getDictionary((uint64_t *)v14, (cva::ItemHandler *)buf);
      cva::ItemHandler::~ItemHandler((cva::ItemHandler *)buf);
      if (cva::DictionaryHandler::hasKey(v14[0], @"version"))
      {
        cva::DictionaryHandler::item((uint64_t *)&v17, v14[0], @"version");
        cva::ItemHandler::getVector<unsigned int>();
      }
      long long v6 = (std::__shared_weak_count *)v14[1];
      if (v14[1] && !atomic_fetch_add((atomic_ullong *volatile)v14[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    if (cva::DictionaryHandler::hasKey(this, @"timestamp_seconds"))
    {
      cva::DictionaryHandler::item((uint64_t *)buf, this, @"timestamp_seconds");
      cva::ItemHandler::getValue<double>();
    }
    if (cva::DictionaryHandler::hasKey(this, @"rgb_camera"))
    {
      cva::DictionaryHandler::item((uint64_t *)buf, this, @"rgb_camera");
      cva::ItemHandler::getDictionary((uint64_t *)&v17, (cva::ItemHandler *)buf);
      cva::ItemHandler::~ItemHandler((cva::ItemHandler *)buf);
      int v21 = 0;
      *(_OWORD *)int buf = 0u;
      long long v20 = 0u;
      LODWORD(v16) = 0;
      *(_OWORD *)long long v14 = 0u;
      long long v15 = 0u;
      if (sub_1D0E3A468(v17))
      {
        long long v7 = v20;
        *(_OWORD *)(v5 + 72) = *(_OWORD *)buf;
        *(_OWORD *)(v5 + 88) = v7;
        *(_DWORD *)(v5 + 104) = v21;
        *(_OWORD *)(v5 + 24) = *(_OWORD *)v14;
        *(_OWORD *)(v5 + 40) = v15;
        *(_DWORD *)(v5 + 56) = v16;
        *(void *)(v5 + 60) = 0;
        *(_DWORD *)(v5 + 68) = 0;
      }
      uint64_t v8 = v18;
      if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    uint64_t v9 = (unsigned char *)(v5 + 108);
    if (cva::DictionaryHandler::hasKey(this, @"data_failure"))
    {
      cva::DictionaryHandler::item((uint64_t *)buf, this, @"data_failure");
      cva::ItemHandler::getDictionary((uint64_t *)v14, (cva::ItemHandler *)buf);
      cva::ItemHandler::~ItemHandler((cva::ItemHandler *)buf);
      char hasKey = cva::DictionaryHandler::hasKey(v14[0], @"image_too_dark");
      *uint64_t v9 = hasKey;
      if (hasKey)
      {
        cva::DictionaryHandler::item((uint64_t *)buf, v14[0], @"image_too_dark");
        cva::ItemHandler::getValue<BOOL>();
      }
      *(unsigned char *)(v5 + 109) = 0;
      char v11 = cva::DictionaryHandler::hasKey(v14[0], @"sensor_covered");
      *(unsigned char *)(v5 + 110) = v11;
      if (v11)
      {
        cva::DictionaryHandler::item((uint64_t *)buf, v14[0], @"sensor_covered");
        cva::ItemHandler::getValue<BOOL>();
      }
      *(unsigned char *)(v5 + 111) = 0;
      if (cva::DictionaryHandler::hasKey(v14[0], @"timestamp_gap"))
      {
        cva::DictionaryHandler::item((uint64_t *)buf, v14[0], @"timestamp_gap");
        cva::ItemHandler::getValue<BOOL>();
      }
      *(unsigned char *)(v5 + 112) = 0;
      int v12 = (std::__shared_weak_count *)v14[1];
      if (v14[1] && !atomic_fetch_add((atomic_ullong *volatile)v14[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    else
    {
      *(unsigned char *)(v5 + 112) = 0;
      *(_DWORD *)uint64_t v9 = 0;
    }
  }
  uint64_t result = 0;
  if (*(unsigned char *)(*a1 + 264)) {
    *(unsigned char *)(*a1 + 264) = 0;
  }
  return result;
}

id sub_1D0E4F11C(void *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t v3 = [v1 allKeys];
  uint64_t v4 = [v3 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v14;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v14 != v5) {
          objc_enumerationMutation(v3);
        }
        long long v7 = *(void **)(*((void *)&v13 + 1) + 8 * v6);
        if ([v7 isEqualToString:@"animation"])
        {
          id v8 = [v1 objectForKeyedSubscript:@"animation"];
          [v2 setObject:v8 forKeyedSubscript:@"animation"];
LABEL_12:

          goto LABEL_13;
        }
        if ([v7 isEqualToString:@"pose"])
        {
          id v8 = [v1 objectForKeyedSubscript:@"pose"];
          [v2 setObject:v8 forKeyedSubscript:@"pose"];
          goto LABEL_12;
        }
        if ([v7 isEqualToString:@"geometry"])
        {
          id v8 = [v1 objectForKeyedSubscript:@"geometry"];
          [v2 setObject:v8 forKeyedSubscript:@"geometry"];
          goto LABEL_12;
        }
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1610))
        {
          qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
          __cxa_guard_release(&qword_1EB9F1610);
        }
        uint64_t v9 = (id)qword_1EB9F1620;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)int v12 = 0;
          _os_log_error_impl(&dword_1D0DBD000, v9, OS_LOG_TYPE_ERROR, "data dictionary contains invalid data", v12, 2u);
        }

        id v8 = [v1 objectForKeyedSubscript:v7];
        [v2 setObject:v8 forKeyedSubscript:v7];
LABEL_13:

        ++v6;
      }
      while (v4 != v6);
      uint64_t v10 = [v3 countByEnumeratingWithState:&v13 objects:v17 count:16];
      uint64_t v4 = v10;
    }
    while (v10);
  }

  return v2;
}

void sub_1D0E4F3E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D0E4F458(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void **)(a1 + 24);
    if (v3 != v1)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0) {
          operator delete(*(void **)(v3 - 24));
        }
        v3 -= 24;
      }
      while (v3 != v1);
      uint64_t v4 = *(void **)(a1 + 24);
    }
    *(void *)(a1 + 32) = v1;
    operator delete(v4);
  }
}

void sub_1D0E4F4E4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F51D8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E4F538(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F51D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0E4F558(char **a1, unint64_t a2)
{
  uint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  if (0x7E3F1F8FC7E3F1F9 * ((v4 - v5) >> 4) >= a2)
  {
    if (a2)
    {
      size_t v12 = 1168 * ((1168 * a2 - 1168) / 0x490) + 1168;
      bzero(a1[1], v12);
      v5 += v12;
    }
    a1[1] = v5;
  }
  else
  {
    uint64_t v6 = *a1;
    uint64_t v7 = 0x7E3F1F8FC7E3F1F9 * ((v5 - *a1) >> 4);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x381C0E070381C0) {
      abort();
    }
    unint64_t v9 = 0x7E3F1F8FC7E3F1F9 * ((v4 - v6) >> 4);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x1C0E070381C0E0) {
      unint64_t v10 = 0x381C0E070381C0;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x381C0E070381C0) {
        sub_1D0DE8CE0();
      }
      char v11 = (char *)operator new(1168 * v10);
    }
    else
    {
      char v11 = 0;
    }
    long long v13 = &v11[1168 * v7];
    long long v14 = &v11[1168 * v10];
    size_t v15 = 1168 * ((1168 * a2 - 1168) / 0x490) + 1168;
    bzero(v13, v15);
    long long v16 = &v13[v15];
    if (v5 == v6)
    {
      *a1 = v13;
      a1[1] = v16;
      a1[2] = v14;
      if (!v5) {
        return;
      }
      goto LABEL_73;
    }
    do
    {
      uint64_t v17 = v13 - 1168;
      uint64_t v18 = v5 - 1168;
      *(v13 - 1168) = 0;
      *(v13 - 1144) = 0;
      if (*(v5 - 1144))
      {
        *(void *)uint64_t v17 = 0;
        *((void *)v13 - 145) = 0;
        uint64_t v19 = *((void *)v5 - 145);
        *(void *)uint64_t v17 = *(void *)v18;
        *((void *)v13 - 145) = v19;
        *(void *)uint64_t v18 = 0;
        *((void *)v5 - 145) = 0;
        *((_DWORD *)v13 - 288) = *((_DWORD *)v5 - 288);
        *((_DWORD *)v5 - 288) = 0;
        *(v13 - 1144) = 1;
      }
      *(v13 - 1136) = 0;
      long long v20 = v13 - 1136;
      *(v13 - 1112) = 0;
      if (*(v5 - 1112))
      {
        *(void *)long long v20 = 0;
        *((void *)v13 - 141) = 0;
        uint64_t v21 = *((void *)v5 - 141);
        *(void *)long long v20 = *((void *)v5 - 142);
        *((void *)v13 - 141) = v21;
        *((void *)v5 - 142) = 0;
        *((void *)v5 - 141) = 0;
        *((_DWORD *)v13 - 280) = *((_DWORD *)v5 - 280);
        *((_DWORD *)v5 - 280) = 0;
        *(v13 - 1112) = 1;
      }
      *(v13 - 1104) = 0;
      uint64_t v22 = v13 - 1104;
      *(v13 - 1080) = 0;
      if (*(v5 - 1080))
      {
        *(void *)uint64_t v22 = 0;
        *((void *)v13 - 137) = 0;
        uint64_t v23 = *((void *)v5 - 137);
        *(void *)uint64_t v22 = *((void *)v5 - 138);
        *((void *)v13 - 137) = v23;
        *((void *)v5 - 138) = 0;
        *((void *)v5 - 137) = 0;
        *((_DWORD *)v13 - 272) = *((_DWORD *)v5 - 272);
        *((_DWORD *)v5 - 272) = 0;
        *(v13 - 1080) = 1;
      }
      *(v13 - 1072) = 0;
      *(v13 - 1048) = 0;
      if (*(v5 - 1048))
      {
        long long v24 = *((_OWORD *)v5 - 67);
        *((void *)v13 - 132) = *((void *)v5 - 132);
        *((_OWORD *)v13 - 67) = v24;
        *((void *)v5 - 133) = 0;
        *((void *)v5 - 132) = 0;
        *((void *)v5 - 134) = 0;
        *(v13 - 1048) = 1;
      }
      long long v25 = *((_OWORD *)v5 - 65);
      long long v26 = *((_OWORD *)v5 - 64);
      long long v27 = *(_OWORD *)(v5 - 1015);
      *(v13 - 992) = 0;
      *(_OWORD *)(v13 - 1015) = v27;
      *((_OWORD *)v13 - 65) = v25;
      *((_OWORD *)v13 - 64) = v26;
      *(v13 - 968) = 0;
      if (*(v5 - 968))
      {
        long long v28 = *((_OWORD *)v5 - 62);
        *((void *)v13 - 122) = *((void *)v5 - 122);
        *((_OWORD *)v13 - 62) = v28;
        *((void *)v5 - 123) = 0;
        *((void *)v5 - 122) = 0;
        *((void *)v5 - 124) = 0;
        *(v13 - 968) = 1;
      }
      *(v13 - 960) = 0;
      *(v13 - 912) = 0;
      if (*(v5 - 912))
      {
        long long v29 = *((_OWORD *)v5 - 60);
        long long v30 = *((_OWORD *)v5 - 59);
        *((_DWORD *)v13 - 232) = *((_DWORD *)v5 - 232);
        *((_OWORD *)v13 - 60) = v29;
        *((_OWORD *)v13 - 59) = v30;
        uint64_t v31 = *(void *)(v5 - 924);
        *((_DWORD *)v13 - 229) = *((_DWORD *)v5 - 229);
        *(void *)(v13 - 924) = v31;
        *(v13 - 912) = 1;
      }
      *(v13 - 904) = 0;
      *(v13 - 880) = 0;
      if (*(v5 - 880))
      {
        *((void *)v13 - 113) = 0;
        *((void *)v13 - 112) = 0;
        uint64_t v32 = *((void *)v5 - 112);
        *((void *)v13 - 113) = *((void *)v5 - 113);
        *((void *)v13 - 112) = v32;
        *((void *)v5 - 113) = 0;
        *((void *)v5 - 112) = 0;
        *((_DWORD *)v13 - 222) = *((_DWORD *)v5 - 222);
        *((_DWORD *)v5 - 222) = 0;
        *(v13 - 880) = 1;
      }
      *(v13 - 872) = 0;
      *(v13 - 860) = 0;
      if (*(v5 - 860))
      {
        uint64_t v33 = *((void *)v5 - 109);
        *((_DWORD *)v13 - 216) = *((_DWORD *)v5 - 216);
        *((void *)v13 - 109) = v33;
        *(v13 - 860) = 1;
      }
      long long v34 = v13 - 856;
      long long v35 = *(_OWORD *)(v5 - 840);
      *(_OWORD *)long long v34 = *(_OWORD *)(v5 - 856);
      *((_OWORD *)v34 + 1) = v35;
      long long v36 = *(_OWORD *)(v5 - 824);
      long long v37 = *(_OWORD *)(v5 - 808);
      long long v38 = *(_OWORD *)(v5 - 792);
      *(void *)(v34 + 77) = *(void *)(v5 - 779);
      *((_OWORD *)v34 + 3) = v37;
      *((_OWORD *)v34 + 4) = v38;
      *((_OWORD *)v34 + 2) = v36;
      *(v13 - 768) = 0;
      *(v13 - 756) = 0;
      if (*(v5 - 756))
      {
        uint64_t v39 = *((void *)v5 - 96);
        *((_DWORD *)v13 - 190) = *((_DWORD *)v5 - 190);
        *((void *)v13 - 96) = v39;
        *(v13 - 756) = 1;
      }
      *(v13 - 752) = 0;
      *(v13 - 740) = 0;
      if (*(v5 - 740))
      {
        uint64_t v40 = *((void *)v5 - 94);
        *((_DWORD *)v13 - 186) = *((_DWORD *)v5 - 186);
        *((void *)v13 - 94) = v40;
        *(v13 - 740) = 1;
      }
      *(v13 - 736) = 0;
      *(v13 - 688) = 0;
      if (*(v5 - 688))
      {
        long long v41 = *((_OWORD *)v5 - 46);
        long long v42 = *((_OWORD *)v5 - 44);
        *((_OWORD *)v13 - 45) = *((_OWORD *)v5 - 45);
        *((_OWORD *)v13 - 44) = v42;
        *((_OWORD *)v13 - 46) = v41;
        *(v13 - 688) = 1;
      }
      *(v13 - 680) = 0;
      *(v13 - 656) = 0;
      if (*(v5 - 656))
      {
        *((void *)v13 - 85) = 0;
        *((void *)v13 - 84) = 0;
        uint64_t v43 = *((void *)v5 - 84);
        *((void *)v13 - 85) = *((void *)v5 - 85);
        *((void *)v13 - 84) = v43;
        *((void *)v5 - 85) = 0;
        *((void *)v5 - 84) = 0;
        *((_DWORD *)v13 - 166) = *((_DWORD *)v5 - 166);
        *((_DWORD *)v5 - 166) = 0;
        *(v13 - 656) = 1;
      }
      *((void *)v13 - 81) = *((void *)v5 - 81);
      *(v13 - 640) = 0;
      *(v13 - 616) = 0;
      if (*(v5 - 616))
      {
        long long v44 = *((_OWORD *)v5 - 40);
        *((void *)v13 - 78) = *((void *)v5 - 78);
        *((_OWORD *)v13 - 40) = v44;
        *((void *)v5 - 78) = 0;
        *((void *)v5 - 79) = 0;
        *((void *)v5 - 80) = 0;
        *(v13 - 616) = 1;
      }
      *((_OWORD *)v13 - 38) = *((_OWORD *)v5 - 38);
      *((_OWORD *)v5 - 38) = 0u;
      *(v13 - 592) = 0;
      *(v13 - 568) = 0;
      if (*(v5 - 568))
      {
        long long v45 = *((_OWORD *)v5 - 37);
        *((void *)v13 - 72) = *((void *)v5 - 72);
        *((_OWORD *)v13 - 37) = v45;
        *((void *)v5 - 72) = 0;
        *((void *)v5 - 73) = 0;
        *((void *)v5 - 74) = 0;
        *(v13 - 568) = 1;
      }
      *((_OWORD *)v13 - 35) = *((_OWORD *)v5 - 35);
      *((_OWORD *)v5 - 35) = 0u;
      *((_OWORD *)v13 - 34) = *((_OWORD *)v5 - 34);
      *((_OWORD *)v5 - 34) = 0u;
      *(v13 - 528) = 0;
      *(v13 - 480) = 0;
      if (*(v5 - 480))
      {
        *((_DWORD *)v13 - 132) = *((_DWORD *)v5 - 132);
        long long v46 = v13 - 528;
        *(void *)(v46 + 4) = *(void *)(v5 - 524);
        *(void *)(v46 + 12) = *(void *)(v5 - 516);
        long long v47 = *(_OWORD *)(v5 - 508);
        *((_OWORD *)v13 - 31) = *((_OWORD *)v5 - 31);
        *(_OWORD *)(v46 + 20) = v47;
        *(v13 - 480) = 1;
      }
      *(v13 - 472) = 0;
      *(v13 - 424) = 0;
      if (*(v5 - 424))
      {
        *((_DWORD *)v13 - 118) = *((_DWORD *)v5 - 118);
        size_t v48 = v13 - 528;
        *(void *)(v48 + 60) = *(void *)(v5 - 468);
        *(void *)(v48 + 68) = *(void *)(v5 - 460);
        long long v49 = *(_OWORD *)(v5 - 452);
        *(_OWORD *)(v48 + 88) = *(_OWORD *)(v5 - 440);
        *(_OWORD *)(v48 + 76) = v49;
        *(v13 - 424) = 1;
      }
      *(v13 - 416) = 0;
      *(v13 - 408) = 0;
      if (*(v5 - 408)) {
        sub_1D0E624FC();
      }
      *(v13 - 400) = 0;
      *(v13 - 376) = 0;
      if (*(v5 - 376))
      {
        *((void *)v13 - 50) = 0;
        *((void *)v13 - 49) = 0;
        *((void *)v13 - 50) = *((void *)v5 - 50);
        *((void *)v5 - 50) = 0;
        *((void *)v13 - 49) = *((void *)v5 - 49);
        *((void *)v5 - 49) = 0;
        *((_DWORD *)v13 - 96) = *((_DWORD *)v5 - 96);
        *((_DWORD *)v5 - 96) = 0;
        *(v13 - 376) = 1;
      }
      *((_OWORD *)v13 - 23) = *((_OWORD *)v5 - 23);
      *((void *)v5 - 45) = 0;
      *((void *)v5 - 46) = 0;
      *(v13 - 352) = 0;
      *(v13 - 304) = 0;
      if (*(v5 - 304))
      {
        *((_DWORD *)v13 - 88) = *((_DWORD *)v5 - 88);
        size_t v50 = v13 - 528;
        *(void *)(v50 + 180) = *(void *)(v5 - 348);
        *(void *)(v50 + 188) = *(void *)(v5 - 340);
        long long v51 = *(_OWORD *)(v5 - 332);
        *((_OWORD *)v13 - 20) = *((_OWORD *)v5 - 20);
        *(_OWORD *)(v50 + 196) = v51;
        *(v13 - 304) = 1;
      }
      *(v13 - 296) = 0;
      *(v13 - 248) = 0;
      if (*(v5 - 248))
      {
        *((_DWORD *)v13 - 74) = *((_DWORD *)v5 - 74);
        unint64_t v52 = v13 - 528;
        *(void *)(v52 + 236) = *(void *)(v5 - 292);
        *(void *)(v52 + 244) = *(void *)(v5 - 284);
        long long v53 = *(_OWORD *)(v5 - 276);
        *(_OWORD *)(v13 - 264) = *(_OWORD *)(v5 - 264);
        *(_OWORD *)(v52 + 252) = v53;
        *(v13 - 248) = 1;
      }
      *(v13 - 240) = 0;
      *(v13 - 232) = 0;
      if (*(v5 - 232)) {
        sub_1D0E624FC();
      }
      *(v13 - 224) = 0;
      *(v13 - 200) = 0;
      if (*(v5 - 200))
      {
        *((void *)v13 - 28) = 0;
        *((void *)v13 - 27) = 0;
        uint64_t v54 = *((void *)v5 - 27);
        *((void *)v13 - 28) = *((void *)v5 - 28);
        *((void *)v13 - 27) = v54;
        *((void *)v5 - 28) = 0;
        *((void *)v5 - 27) = 0;
        *((_DWORD *)v13 - 52) = *((_DWORD *)v5 - 52);
        *((_DWORD *)v5 - 52) = 0;
        *(v13 - 200) = 1;
      }
      *((_OWORD *)v13 - 12) = *((_OWORD *)v5 - 12);
      *((void *)v5 - 24) = 0;
      *((void *)v5 - 23) = 0;
      *(v13 - 176) = 0;
      *(v13 - 128) = 0;
      if (*(v5 - 128))
      {
        *((_DWORD *)v13 - 44) = *((_DWORD *)v5 - 44);
        *(void *)(v13 - 172) = *(void *)(v5 - 172);
        *(void *)(v13 - 164) = *(void *)(v5 - 164);
        long long v55 = *(_OWORD *)(v5 - 156);
        *((_OWORD *)v13 - 9) = *((_OWORD *)v5 - 9);
        *(_OWORD *)(v13 - 156) = v55;
        *(v13 - 128) = 1;
      }
      *(v13 - 120) = 0;
      *(v13 - 72) = 0;
      if (*(v5 - 72))
      {
        *((_DWORD *)v13 - 30) = *((_DWORD *)v5 - 30);
        *(void *)(v13 - 116) = *(void *)(v5 - 116);
        *(void *)(v13 - 108) = *(void *)(v5 - 108);
        long long v56 = *(_OWORD *)(v5 - 100);
        *(_OWORD *)(v13 - 88) = *(_OWORD *)(v5 - 88);
        *(_OWORD *)(v13 - 100) = v56;
        *(v13 - 72) = 1;
      }
      *(v13 - 64) = 0;
      *(v13 - 56) = 0;
      if (*(v5 - 56)) {
        sub_1D0E624FC();
      }
      *(v13 - 48) = 0;
      *(v13 - 24) = 0;
      if (*(v5 - 24))
      {
        *((void *)v13 - 6) = 0;
        *((void *)v13 - 5) = 0;
        uint64_t v57 = *((void *)v5 - 5);
        *((void *)v13 - 6) = *((void *)v5 - 6);
        *((void *)v13 - 5) = v57;
        *((void *)v5 - 6) = 0;
        *((void *)v5 - 5) = 0;
        *((_DWORD *)v13 - 8) = *((_DWORD *)v5 - 8);
        *((_DWORD *)v5 - 8) = 0;
        *(v13 - 24) = 1;
      }
      *((_OWORD *)v13 - 1) = *((_OWORD *)v5 - 1);
      *((void *)v5 - 2) = 0;
      *((void *)v5 - 1) = 0;
      v5 -= 1168;
      v13 -= 1168;
    }
    while (v18 != v6);
    uint64_t v5 = *a1;
    uint64_t v58 = (uint64_t)a1[1];
    *a1 = v17;
    a1[1] = v16;
    for (a1[2] = v14; (char *)v58 != v5; uint64_t v58 = sub_1D0E0DC44(v58 - 1168))
      ;
    if (v5)
    {
LABEL_73:
      operator delete(v5);
    }
  }
}

uint64_t sub_1D0E4FDF0(__CFDictionary *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v163 = *MEMORY[0x1E4F143B8];
  cva::DictionaryHandler::DictionaryHandler((cva::DictionaryHandler *)v98, a1);
  if (cva::DictionaryHandler::hasKey((cva::DictionaryHandler *)v98, @"tracked_faces"))
  {
    cva::DictionaryHandler::item(&v162.value, (cva::DictionaryHandler *)v98, @"tracked_faces");
    cva::ItemHandler::getArray(&time.value, (cva::ItemHandler *)&v162);
    value = (cva::ArrayHandler *)time.value;
    uint64_t v5 = *(std::__shared_weak_count **)&time.timescale;
    time.value = 0;
    *(void *)&time.timescale = 0;
    cva::ItemHandler::~ItemHandler((cva::ItemHandler *)&v162);
    if (value && cva::ArrayHandler::size(value))
    {
      unint64_t v7 = (int)cva::ArrayHandler::size(value);
      uint64_t v9 = *(void *)(a4 + 64);
      uint64_t v8 = *(void *)(a4 + 72);
      unint64_t v10 = 0x7E3F1F8FC7E3F1F9 * ((v8 - v9) >> 4);
      uint64_t v94 = value;
      unint64_t v95 = v5;
      if (v7 <= v10)
      {
        if (v7 >= v10)
        {
          uint64_t i = *(void *)(a4 + 72);
        }
        else
        {
          for (i = v9 + 1168 * (int)v7; v8 != i; uint64_t v8 = sub_1D0E0DC44(v8 - 1168))
            ;
          *(void *)(a4 + 72) = i;
        }
      }
      else
      {
        sub_1D0E4F558((char **)(a4 + 64), v7 - v10);
        uint64_t i = *(void *)(a4 + 72);
      }
      *(_DWORD *)(a4 + 56) = 0;
      *(_OWORD *)(a4 + 40) = 0u;
      *(_OWORD *)(a4 + 24) = 0u;
      for (uint64_t j = *(void *)(a4 + 64); j != i; j += 1168)
      {
        bzero(&time, 0x490uLL);
        int v23 = *(unsigned __int8 *)(j + 24);
        if (*(unsigned char *)(j + 24))
        {
          free(*(void **)j);
          *(unsigned char *)(j + 24) = 0;
          int v23 = v103;
        }
        if (*(unsigned __int8 *)(j + 56) == v23)
        {
          if (*(unsigned char *)(j + 56))
          {
            uint64_t v24 = *(void *)(j + 32);
            *(void *)(j + 32) = v100;
            uint64_t v100 = v24;
            uint64_t v25 = *(void *)(j + 40);
            *(void *)(j + 40) = v101;
            uint64_t v101 = v25;
            *(_DWORD *)(j + 48) = v102;
            int v102 = 0;
          }
        }
        else if (*(unsigned char *)(j + 56))
        {
          free(*(void **)(j + 32));
          *(unsigned char *)(j + 56) = 0;
        }
        else
        {
          *(void *)(j + 32) = 0;
          *(void *)(j + 40) = 0;
          *(void *)(j + 32) = v100;
          uint64_t v100 = 0;
          *(void *)(j + 40) = v101;
          uint64_t v101 = 0;
          *(_DWORD *)(j + 48) = v102;
          int v102 = 0;
          *(unsigned char *)(j + 56) = 1;
        }
        if (*(unsigned __int8 *)(j + 88) == v107)
        {
          if (*(unsigned char *)(j + 88))
          {
            uint64_t v26 = *(void *)(j + 64);
            *(void *)(j + 64) = v104;
            uint64_t v104 = v26;
            uint64_t v27 = *(void *)(j + 72);
            *(void *)(j + 72) = v105;
            uint64_t v105 = v27;
            *(_DWORD *)(j + 80) = v106;
            int v106 = 0;
          }
        }
        else if (*(unsigned char *)(j + 88))
        {
          free(*(void **)(j + 64));
          *(unsigned char *)(j + 88) = 0;
        }
        else
        {
          *(void *)(j + 64) = 0;
          *(void *)(j + 72) = 0;
          *(void *)(j + 64) = v104;
          uint64_t v104 = 0;
          *(void *)(j + 72) = v105;
          uint64_t v105 = 0;
          *(_DWORD *)(j + 80) = v106;
          int v106 = 0;
          *(unsigned char *)(j + 88) = 1;
        }
        long long v28 = (void **)(j + 96);
        if (*(unsigned __int8 *)(j + 120) == v110)
        {
          if (*(unsigned char *)(j + 120))
          {
            if (*(char *)(j + 119) < 0) {
              operator delete(*v28);
            }
            long long v29 = v108;
            *(void *)(j + 112) = v109;
            *(_OWORD *)long long v28 = v29;
            HIBYTE(v109) = 0;
            LOBYTE(v108) = 0;
          }
        }
        else if (*(unsigned char *)(j + 120))
        {
          if (*(char *)(j + 119) < 0) {
            operator delete(*v28);
          }
          *(unsigned char *)(j + 120) = 0;
        }
        else
        {
          long long v30 = v108;
          *(void *)(j + 112) = v109;
          *(_OWORD *)long long v28 = v30;
          uint64_t v109 = 0;
          long long v108 = 0uLL;
          *(unsigned char *)(j + 120) = 1;
        }
        long long v31 = v111;
        long long v32 = v112[0];
        *(_OWORD *)(j + 153) = *(_OWORD *)((char *)v112 + 9);
        *(_OWORD *)(j + 128) = v31;
        *(_OWORD *)(j + 144) = v32;
        uint64_t v33 = (void **)(j + 176);
        if (*(unsigned __int8 *)(j + 200) == v115)
        {
          if (*(unsigned char *)(j + 200))
          {
            if (*(char *)(j + 199) < 0) {
              operator delete(*v33);
            }
            long long v34 = v113;
            *(void *)(j + 192) = v114;
            *(_OWORD *)uint64_t v33 = v34;
            HIBYTE(v114) = 0;
            LOBYTE(v113) = 0;
          }
        }
        else if (*(unsigned char *)(j + 200))
        {
          if (*(char *)(j + 199) < 0) {
            operator delete(*v33);
          }
          *(unsigned char *)(j + 200) = 0;
        }
        else
        {
          long long v35 = v113;
          *(void *)(j + 192) = v114;
          *(_OWORD *)uint64_t v33 = v35;
          uint64_t v114 = 0;
          long long v113 = 0uLL;
          *(unsigned char *)(j + 200) = 1;
        }
        long long v36 = (_OWORD *)(j + 208);
        if (*(unsigned __int8 *)(j + 256) == v121)
        {
          if (*(unsigned char *)(j + 256))
          {
            long long v37 = v116;
            long long v38 = v117;
            *(_DWORD *)(j + 240) = v118;
            *long long v36 = v37;
            *(_OWORD *)(j + 224) = v38;
            uint64_t v39 = v119;
            *(_DWORD *)(j + 252) = v120;
            *(void *)(j + 244) = v39;
          }
        }
        else if (*(unsigned char *)(j + 256))
        {
          *(unsigned char *)(j + 256) = 0;
        }
        else
        {
          long long v40 = v116;
          long long v41 = v117;
          *(_DWORD *)(j + 240) = v118;
          *long long v36 = v40;
          *(_OWORD *)(j + 224) = v41;
          uint64_t v42 = v119;
          *(_DWORD *)(j + 252) = v120;
          *(void *)(j + 244) = v42;
          *(unsigned char *)(j + 256) = 1;
        }
        if (*(unsigned __int8 *)(j + 288) == v125)
        {
          if (*(unsigned char *)(j + 288))
          {
            uint64_t v43 = *(void *)(j + 264);
            *(void *)(j + 264) = v122;
            uint64_t v122 = v43;
            uint64_t v44 = *(void *)(j + 272);
            *(void *)(j + 272) = v123;
            uint64_t v123 = v44;
            *(_DWORD *)(j + 280) = v124;
            int v124 = 0;
          }
        }
        else if (*(unsigned char *)(j + 288))
        {
          free(*(void **)(j + 264));
          *(unsigned char *)(j + 288) = 0;
        }
        else
        {
          *(void *)(j + 264) = 0;
          *(void *)(j + 272) = 0;
          *(void *)(j + 264) = v122;
          uint64_t v122 = 0;
          *(void *)(j + 272) = v123;
          uint64_t v123 = 0;
          *(_DWORD *)(j + 280) = v124;
          int v124 = 0;
          *(unsigned char *)(j + 288) = 1;
        }
        long long v45 = (void *)(j + 296);
        if (*(unsigned __int8 *)(j + 308) == v128)
        {
          if (*(unsigned char *)(j + 308))
          {
            uint64_t v46 = v126;
            *(_DWORD *)(j + 304) = v127;
            *long long v45 = v46;
          }
        }
        else if (*(unsigned char *)(j + 308))
        {
          *(unsigned char *)(j + 308) = 0;
        }
        else
        {
          uint64_t v47 = v126;
          *(_DWORD *)(j + 304) = v127;
          *long long v45 = v47;
          *(unsigned char *)(j + 308) = 1;
        }
        long long v48 = v130;
        *(_OWORD *)(j + 312) = v129;
        *(_OWORD *)(j + 328) = v48;
        long long v49 = v131;
        long long v50 = v132;
        long long v51 = *(_OWORD *)v133;
        *(void *)(j + 389) = *(void *)&v133[13];
        *(_OWORD *)(j + 360) = v50;
        *(_OWORD *)(j + 376) = v51;
        *(_OWORD *)(j + 344) = v49;
        unint64_t v52 = (void *)(j + 400);
        if (*(unsigned __int8 *)(j + 412) == v136)
        {
          if (*(unsigned char *)(j + 412))
          {
            uint64_t v53 = v134;
            *(_DWORD *)(j + 408) = v135;
            *unint64_t v52 = v53;
          }
        }
        else if (*(unsigned char *)(j + 412))
        {
          *(unsigned char *)(j + 412) = 0;
        }
        else
        {
          uint64_t v54 = v134;
          *(_DWORD *)(j + 408) = v135;
          *unint64_t v52 = v54;
          *(unsigned char *)(j + 412) = 1;
        }
        long long v55 = (void *)(j + 416);
        if (*(unsigned __int8 *)(j + 428) == v139)
        {
          if (*(unsigned char *)(j + 428))
          {
            uint64_t v56 = v137;
            *(_DWORD *)(j + 424) = v138;
            *long long v55 = v56;
          }
        }
        else if (*(unsigned char *)(j + 428))
        {
          *(unsigned char *)(j + 428) = 0;
        }
        else
        {
          uint64_t v57 = v137;
          *(_DWORD *)(j + 424) = v138;
          *long long v55 = v57;
          *(unsigned char *)(j + 428) = 1;
        }
        uint64_t v58 = (_OWORD *)(j + 432);
        if (*(unsigned __int8 *)(j + 480) == v143)
        {
          if (*(unsigned char *)(j + 480))
          {
            long long v59 = v140;
            long long v60 = v142;
            *(_OWORD *)(j + 448) = v141;
            *(_OWORD *)(j + 464) = v60;
            _OWORD *v58 = v59;
          }
        }
        else if (*(unsigned char *)(j + 480))
        {
          *(unsigned char *)(j + 480) = 0;
        }
        else
        {
          long long v61 = v140;
          long long v62 = v142;
          *(_OWORD *)(j + 448) = v141;
          *(_OWORD *)(j + 464) = v62;
          _OWORD *v58 = v61;
          *(unsigned char *)(j + 480) = 1;
        }
        if (*(unsigned __int8 *)(j + 512) == v147)
        {
          if (*(unsigned char *)(j + 512))
          {
            uint64_t v63 = *(void *)(j + 488);
            *(void *)(j + 488) = v144;
            uint64_t v144 = v63;
            uint64_t v64 = *(void *)(j + 496);
            *(void *)(j + 496) = v145;
            uint64_t v145 = v64;
            *(_DWORD *)(j + 504) = v146;
            int v146 = 0;
          }
        }
        else if (*(unsigned char *)(j + 512))
        {
          free(*(void **)(j + 488));
          *(unsigned char *)(j + 512) = 0;
        }
        else
        {
          *(void *)(j + 488) = 0;
          *(void *)(j + 496) = 0;
          *(void *)(j + 488) = v144;
          uint64_t v144 = 0;
          *(void *)(j + 496) = v145;
          uint64_t v145 = 0;
          *(_DWORD *)(j + 504) = v146;
          int v146 = 0;
          *(unsigned char *)(j + 512) = 1;
        }
        char v65 = v149;
        *(_DWORD *)(j + 520) = v148;
        *(unsigned char *)(j + 524) = v65;
        int64_t v66 = (void **)(j + 528);
        if (*(unsigned __int8 *)(j + 552) == v152)
        {
          if (*(unsigned char *)(j + 552))
          {
            if (*(char *)(j + 551) < 0) {
              operator delete(*v66);
            }
            long long v67 = v150;
            *(void *)(j + 544) = v151;
            *(_OWORD *)int64_t v66 = v67;
            HIBYTE(v151) = 0;
            LOBYTE(v150) = 0;
          }
        }
        else if (*(unsigned char *)(j + 552))
        {
          if (*(char *)(j + 551) < 0) {
            operator delete(*v66);
          }
          *(unsigned char *)(j + 552) = 0;
        }
        else
        {
          long long v68 = v150;
          *(void *)(j + 544) = v151;
          *(_OWORD *)int64_t v66 = v68;
          uint64_t v151 = 0;
          long long v150 = 0uLL;
          *(unsigned char *)(j + 552) = 1;
        }
        long long v69 = v153;
        long long v153 = 0uLL;
        uint64_t v70 = *(std::__shared_weak_count **)(j + 568);
        *(_OWORD *)(j + 560) = v69;
        if (v70 && !atomic_fetch_add(&v70->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
          std::__shared_weak_count::__release_weak(v70);
        }
        long long v71 = (void **)(j + 576);
        if (*(unsigned __int8 *)(j + 600) == v156)
        {
          if (*(unsigned char *)(j + 600))
          {
            if (*(char *)(j + 599) < 0) {
              operator delete(*v71);
            }
            long long v72 = v154;
            *(void *)(j + 592) = v155;
            *(_OWORD *)long long v71 = v72;
            HIBYTE(v155) = 0;
            LOBYTE(v154) = 0;
          }
        }
        else if (*(unsigned char *)(j + 600))
        {
          if (*(char *)(j + 599) < 0) {
            operator delete(*v71);
          }
          *(unsigned char *)(j + 600) = 0;
        }
        else
        {
          long long v73 = v154;
          *(void *)(j + 592) = v155;
          *(_OWORD *)long long v71 = v73;
          uint64_t v155 = 0;
          long long v154 = 0uLL;
          *(unsigned char *)(j + 600) = 1;
        }
        long long v74 = v157;
        long long v157 = 0uLL;
        unint64_t v75 = *(std::__shared_weak_count **)(j + 616);
        *(_OWORD *)(j + 608) = v74;
        if (v75 && !atomic_fetch_add(&v75->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
          std::__shared_weak_count::__release_weak(v75);
        }
        long long v76 = v158;
        long long v158 = 0uLL;
        unint64_t v77 = *(std::__shared_weak_count **)(j + 632);
        *(_OWORD *)(j + 624) = v76;
        if (v77 && !atomic_fetch_add(&v77->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
          std::__shared_weak_count::__release_weak(v77);
        }
        sub_1D0E6EA7C(j + 640, (uint64_t)&v159);
        sub_1D0E6EA7C(j + 816, (uint64_t)&v160);
        sub_1D0E6EA7C(j + 992, (uint64_t)&v161);
        sub_1D0E0DC44((uint64_t)&time);
      }
      uint64_t v78 = *(std::__shared_weak_count **)(a4 + 848);
      *(void *)(a4 + 840) = 0;
      *(void *)(a4 + 848) = 0;
      if (v78 && !atomic_fetch_add(&v78->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
        std::__shared_weak_count::__release_weak(v78);
      }
      uint64_t v79 = *(std::__shared_weak_count **)(a4 + 864);
      *(void *)(a4 + 856) = 0;
      *(void *)(a4 + 864) = 0;
      if (v79 && !atomic_fetch_add(&v79->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
        std::__shared_weak_count::__release_weak(v79);
      }
      uint64_t v80 = *(std::__shared_weak_count **)(a4 + 880);
      *(void *)(a4 + 872) = 0;
      *(void *)(a4 + 880) = 0;
      if (v80 && !atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
        std::__shared_weak_count::__release_weak(v80);
      }
      uint64_t v13 = 1;
      if ((int)(-941362695 * ((*(void *)(a4 + 72) - *(void *)(a4 + 64)) >> 4)) >= 1)
      {
        cva::ArrayHandler::item(v94);
        cva::ItemHandler::getDictionary(&time.value, (cva::ItemHandler *)&v162);
        uint64_t v81 = (cva::DictionaryHandler *)time.value;
        uint64_t v96 = *(std::__shared_weak_count **)&time.timescale;
        time.value = 0;
        *(void *)&time.timescale = 0;
        cva::ItemHandler::~ItemHandler((cva::ItemHandler *)&v162);
        uint64_t v82 = *(void *)(a4 + 64);
        if (cva::DictionaryHandler::hasKey(v81, @"timestamp"))
        {
          cva::DictionaryHandler::item(&v162.value, v81, @"timestamp");
          cva::ItemHandler::getDictionary(&time.value, (cva::ItemHandler *)&v162);
          uint64_t v83 = v82;
          CMTimeValue v85 = time.value;
          int v84 = *(std::__shared_weak_count **)&time.timescale;
          time.value = 0;
          *(void *)&time.timescale = 0;
          cva::ItemHandler::~ItemHandler((cva::ItemHandler *)&v162);
          int v86 = (cva::DictionaryHandler *)v85;
          uint64_t v82 = v83;
          CFDictionaryRef Dictionary = (const __CFDictionary *)cva::DictionaryHandler::getDictionary(v86);
          memset(&v162, 0, sizeof(v162));
          CMTimeMakeFromDictionary(&v162, Dictionary);
          CMTime time = v162;
          Float64 v88 = CMTimeGetSeconds(&time) * 1000.0;
          *(Float64 *)(a4 + 24) = v88;
          *(Float64 *)(a4 + 32) = v88;
          if (v84)
          {
            if (!atomic_fetch_add(&v84->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
              std::__shared_weak_count::__release_weak(v84);
            }
          }
        }
        if (!cva::DictionaryHandler::hasKey(v81, @"identity_coefficients")) {
          goto LABEL_150;
        }
        if (*(unsigned char *)(v82 + 24))
        {
          long long v89 = *(void **)v82;
          *(_DWORD *)(v82 + 16) = 0;
        }
        else
        {
          long long v89 = 0;
          *(_DWORD *)(v82 + 16) = 0;
          *(unsigned char *)(v82 + 24) = 1;
        }
        *(void *)uint64_t v82 = 0;
        *(void *)(v82 + 8) = 0;
        free(v89);
        if (cva::DictionaryHandler::hasKey(v81, @"identity_coefficients"))
        {
          cva::DictionaryHandler::item(&time.value, v81, @"identity_coefficients");
          CFDataRef Data = (const __CFData *)cva::ItemHandler::getData((cva::ItemHandler *)&time);
          unsigned int v91 = sub_1D0E52454(Data, v82);
          cva::ItemHandler::~ItemHandler((cva::ItemHandler *)&time);
          if (v91)
          {
LABEL_150:
            cva::DictionaryHandler::item((uint64_t *)&v97, v81, @"face_id");
            cva::ItemHandler::getValue<std::string>();
          }
        }
        if (v96 && !atomic_fetch_add(&v96->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v96->__on_zero_shared)(v96);
          std::__shared_weak_count::__release_weak(v96);
        }
        uint64_t v13 = 0;
LABEL_156:
        uint64_t v5 = v95;
        goto LABEL_157;
      }
      goto LABEL_157;
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v12 = *(void *)(a4 + 64);
  uint64_t v13 = 1;
  if ((int)(-941362695 * ((unint64_t)(*(void *)(a4 + 72) - v12) >> 4)) >= 1)
  {
    unint64_t v95 = v5;
    uint64_t v14 = 0;
    uint64_t v15 = 200;
    do
    {
      uint64_t v17 = v12 + v15;
      *(_DWORD *)(v17 - 52) = 0;
      *(unsigned char *)(v17 - 48) = 1;
      uint64_t v18 = *(void *)(a4 + 64);
      uint64_t v19 = (void **)(v18 + v15);
      if (*(unsigned char *)(v18 + v15 - 32)) {
        *((unsigned char *)v19 - 32) = 0;
      }
      if (*(unsigned char *)v19)
      {
        uint64_t v20 = v18 + v15;
        if (*(char *)(v18 + v15 - 1) < 0) {
          operator delete(*(v19 - 3));
        }
        *(v19 - 3) = (void *)0x6B63617274206F4ELL;
        *(_DWORD *)(v20 - 16) = 6778473;
        *(unsigned char *)(v20 - 1) = 11;
      }
      else
      {
        *(v19 - 3) = (void *)0x6B63617274206F4ELL;
        uint64_t v21 = v18 + v15;
        *(_DWORD *)(v21 - 16) = 6778473;
        *(_WORD *)(v21 - 1) = 267;
      }
      uint64_t v16 = *(void *)(a4 + 64) + v15;
      *(_DWORD *)(v16 - 44) = 0;
      *(unsigned char *)(v16 - 40) = 1;
      ++v14;
      uint64_t v12 = *(void *)(a4 + 64);
      v15 += 1168;
    }
    while (v14 < (int)(-941362695 * ((unint64_t)(*(void *)(a4 + 72) - v12) >> 4)));
    uint64_t v13 = 1;
    goto LABEL_156;
  }
LABEL_157:
  uint64_t v92 = v13;
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  cva::DictionaryHandler::~DictionaryHandler((cva::DictionaryHandler *)v98);
  return v92;
}

CFDataRef sub_1D0E52454(const __CFData *result, uint64_t a2)
{
  if (result)
  {
    CFDataRef v3 = result;
    unsigned int Length = CFDataGetLength(result);
    if ((Length & 3) != 0)
    {
      return 0;
    }
    else
    {
      unsigned int v5 = Length;
      size_t v6 = Length;
      unint64_t v7 = (unint64_t)Length >> 2;
      *(_DWORD *)(a2 + 16) = v7;
      if (v7)
      {
        if (*(void *)(a2 + 8) < v7)
        {
          free(*(void **)a2);
          size_t v8 = ((v5 & 0xFFFFFFFC) + 31) & 0x1FFFFFFE0;
          *(void *)a2 = 0;
          *(void *)(a2 + 8) = v8 >> 2;
          long long memptr = 0;
          malloc_type_posix_memalign(&memptr, 0x20uLL, v8, 0x49090899uLL);
          *(void *)a2 = memptr;
        }
      }
      else
      {
        free(*(void **)a2);
        *(void *)a2 = 0;
        *(void *)(a2 + 8) = 0;
      }
      if (v6)
      {
        uint64_t v9 = *(void **)a2;
        BytePtr = CFDataGetBytePtr(v3);
        memcpy(v9, BytePtr, v6);
      }
      return (const __CFData *)1;
    }
  }
  return result;
}

uint64_t sub_1D0E52534(uint64_t a1, int *a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    int v4 = *a2;
    int v5 = *(_DWORD *)(a1 + 16);
    size_t v6 = *(_DWORD **)a1;
    if (*a2 != v5)
    {
      if ((_DWORD *)(*((void *)a2 + 1) - 4 * a2[5]) == v6)
      {
        size_t v57 = (4 * (2 * v4) + 31) & 0x7FFFFFFE0;
        long long memptr = 0;
        malloc_type_posix_memalign(&memptr, 0x20uLL, v57, 0x49090899uLL);
        uint64_t v58 = (char *)memptr;
        int v59 = *a2;
        uint64_t v60 = (2 * *a2);
        if ((void *)(*((void *)a2 + 1) - 4 * a2[5]) == memptr)
        {
          uint64_t v70 = 4 * v60;
          size_t v57 = (4 * v60 + 31) & 0x7FFFFFFE0;
          long long memptr = 0;
          malloc_type_posix_memalign(&memptr, 0x20uLL, v57, 0x49090899uLL);
          long long v69 = memptr;
          if (v60)
          {
            unint64_t v71 = (unint64_t)(a2[4] - 2) << 32;
            long long v72 = (_DWORD *)*((void *)a2 + 1);
            if ((*a2 & 0x7FFFFFFF) == 0) {
              long long v72 = 0;
            }
            long long v73 = memptr;
            do
            {
              *v73++ = *v72;
              unint64_t v74 = HIDWORD(v71);
              BOOL v75 = (int)v71 < 1;
              if ((int)v71 < 1) {
                unint64_t v74 = 0;
              }
              long long v76 = &v72[v74];
              uint64_t v77 = (v71 + 1);
              unint64_t v78 = v71 & 0xFFFFFFFF00000000;
              if (!v75) {
                uint64_t v77 = 0;
              }
              unint64_t v71 = v77 | v78;
              long long v72 = v76 + 1;
              v70 -= 4;
            }
            while (v70);
          }
          free(v58);
        }
        else
        {
          if (v60)
          {
            uint64_t v61 = 0;
            unint64_t v62 = (unint64_t)(a2[4] - 2) << 32;
            if ((v59 & 0x7FFFFFFF) != 0) {
              uint64_t v63 = (_DWORD *)*((void *)a2 + 1);
            }
            else {
              uint64_t v63 = 0;
            }
            do
            {
              *(_DWORD *)&v58[v61] = *v63;
              unint64_t v64 = HIDWORD(v62);
              BOOL v65 = (int)v62 < 1;
              if ((int)v62 < 1) {
                unint64_t v64 = 0;
              }
              int64_t v66 = &v63[v64];
              uint64_t v67 = (v62 + 1);
              unint64_t v68 = v62 & 0xFFFFFFFF00000000;
              if (!v65) {
                uint64_t v67 = 0;
              }
              unint64_t v62 = v67 | v68;
              uint64_t v63 = v66 + 1;
              v61 += 4;
            }
            while (4 * v60 != v61);
          }
          long long v69 = v58;
        }
        uint64_t v43 = *(_DWORD **)a1;
        *(void *)a1 = v69;
        *(void *)(a1 + 8) = v57 >> 2;
        *(_DWORD *)(a1 + 16) = v59;
        goto LABEL_75;
      }
      *(_DWORD *)(a1 + 16) = v4;
      unint64_t v29 = (2 * v4);
      if (v29)
      {
        if (*(void *)(a1 + 8) < v29)
        {
          free(v6);
          size_t v30 = (4 * v29 + 31) & 0x7FFFFFFE0;
          *(void *)a1 = 0;
          *(void *)(a1 + 8) = v30 >> 2;
          long long memptr = 0;
          malloc_type_posix_memalign(&memptr, 0x20uLL, v30, 0x49090899uLL);
          size_t v6 = memptr;
          *(void *)a1 = memptr;
        }
      }
      else
      {
        free(v6);
        size_t v6 = 0;
        *(void *)a1 = 0;
        *(void *)(a1 + 8) = 0;
      }
    }
    int v7 = *(_DWORD *)(a1 + 16);
    uint64_t v8 = (2 * v7);
    if ((_DWORD *)(*((void *)a2 + 1) - 4 * a2[5]) != v6)
    {
      if (v8)
      {
        unint64_t v9 = (unint64_t)(a2[4] - 2) << 32;
        if ((*a2 & 0x7FFFFFFF) != 0) {
          unint64_t v10 = (_DWORD *)*((void *)a2 + 1);
        }
        else {
          unint64_t v10 = 0;
        }
        uint64_t v11 = 4 * v8;
        do
        {
          *v6++ = *v10;
          unint64_t v12 = HIDWORD(v9);
          BOOL v13 = (int)v9 < 1;
          if ((int)v9 < 1) {
            unint64_t v12 = 0;
          }
          uint64_t v14 = &v10[v12];
          uint64_t v15 = (v9 + 1);
          unint64_t v16 = v9 & 0xFFFFFFFF00000000;
          if (!v13) {
            uint64_t v15 = 0;
          }
          unint64_t v9 = v15 | v16;
          unint64_t v10 = v14 + 1;
          v11 -= 4;
        }
        while (v11);
      }
      return a1;
    }
    uint64_t v31 = 4 * v8;
    size_t v32 = (4 * v8 + 31) & 0x7FFFFFFE0;
    size_t v33 = v32 >> 2;
    long long memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v32, 0x49090899uLL);
    long long v34 = memptr;
    if (v8)
    {
      unint64_t v35 = (unint64_t)(a2[4] - 2) << 32;
      long long v36 = (_DWORD *)*((void *)a2 + 1);
      if ((*a2 & 0x7FFFFFFF) == 0) {
        long long v36 = 0;
      }
      long long v37 = memptr;
      do
      {
        *v37++ = *v36;
        unint64_t v38 = HIDWORD(v35);
        BOOL v39 = (int)v35 < 1;
        if ((int)v35 < 1) {
          unint64_t v38 = 0;
        }
        long long v40 = &v36[v38];
        uint64_t v41 = (v35 + 1);
        unint64_t v42 = v35 & 0xFFFFFFFF00000000;
        if (!v39) {
          uint64_t v41 = 0;
        }
        unint64_t v35 = v41 | v42;
        long long v36 = v40 + 1;
        v31 -= 4;
      }
      while (v31);
    }
    uint64_t v43 = *(_DWORD **)a1;
    *(void *)a1 = v34;
    *(void *)(a1 + 8) = v33;
    *(_DWORD *)(a1 + 16) = v7;
LABEL_75:
    free(v43);
    return a1;
  }
  size_t v17 = (4 * (2 * *a2) + 31) & 0x7FFFFFFE0;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = v17 >> 2;
  long long memptr = 0;
  malloc_type_posix_memalign(&memptr, 0x20uLL, v17, 0x49090899uLL);
  uint64_t v18 = memptr;
  *(void *)a1 = memptr;
  int v19 = *a2;
  *(_DWORD *)(a1 + 16) = *a2;
  uint64_t v20 = (2 * v19);
  if ((_DWORD *)(*((void *)a2 + 1) - 4 * a2[5]) == v18)
  {
    uint64_t v44 = 4 * v20;
    size_t v45 = (4 * v20 + 31) & 0x7FFFFFFE0;
    size_t v46 = v45 >> 2;
    long long memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v45, 0x49090899uLL);
    uint64_t v47 = memptr;
    if (v20)
    {
      unint64_t v48 = (unint64_t)(a2[4] - 2) << 32;
      long long v49 = (_DWORD *)*((void *)a2 + 1);
      if ((*a2 & 0x7FFFFFFF) == 0) {
        long long v49 = 0;
      }
      long long v50 = memptr;
      do
      {
        *v50++ = *v49;
        unint64_t v51 = HIDWORD(v48);
        BOOL v52 = (int)v48 < 1;
        if ((int)v48 < 1) {
          unint64_t v51 = 0;
        }
        uint64_t v53 = &v49[v51];
        uint64_t v54 = (v48 + 1);
        unint64_t v55 = v48 & 0xFFFFFFFF00000000;
        if (!v52) {
          uint64_t v54 = 0;
        }
        unint64_t v48 = v54 | v55;
        long long v49 = v53 + 1;
        v44 -= 4;
      }
      while (v44);
    }
    uint64_t v56 = *(_DWORD **)a1;
    *(void *)a1 = v47;
    *(void *)(a1 + 8) = v46;
    *(_DWORD *)(a1 + 16) = v19;
    free(v56);
  }
  else if (v20)
  {
    unint64_t v21 = (unint64_t)(a2[4] - 2) << 32;
    if ((*a2 & 0x7FFFFFFF) != 0) {
      uint64_t v22 = (_DWORD *)*((void *)a2 + 1);
    }
    else {
      uint64_t v22 = 0;
    }
    uint64_t v23 = 4 * v20;
    do
    {
      *v18++ = *v22;
      unint64_t v24 = HIDWORD(v21);
      BOOL v25 = (int)v21 < 1;
      if ((int)v21 < 1) {
        unint64_t v24 = 0;
      }
      uint64_t v26 = &v22[v24];
      uint64_t v27 = (v21 + 1);
      unint64_t v28 = v21 & 0xFFFFFFFF00000000;
      if (!v25) {
        uint64_t v27 = 0;
      }
      unint64_t v21 = v27 | v28;
      uint64_t v22 = v26 + 1;
      v23 -= 4;
    }
    while (v23);
  }
  *(unsigned char *)(a1 + 24) = 1;
  return a1;
}

CFDataRef sub_1D0E529B8(cva::DictionaryHandler *a1, uint64_t a2)
{
  if (!cva::DictionaryHandler::hasKey(a1, @"faceprint_snapshot_coefficients")) {
    return 0;
  }
  cva::DictionaryHandler::item(v7, a1, @"faceprint_snapshot_coefficients");
  CFDataRef Data = (const __CFData *)cva::ItemHandler::getData((cva::ItemHandler *)v7);
  CFDataRef v5 = sub_1D0E52454(Data, a2);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v7);
  return v5;
}

uint64_t sub_1D0E52A30(uint64_t a1, long long *a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    long long v4 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v4;
    *((unsigned char *)a2 + 23) = 0;
    *(unsigned char *)a2 = 0;
  }
  else
  {
    long long v5 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v5;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

uint64_t sub_1D0E52AAC(cva::DictionaryHandler **a1, const __CFString *a2)
{
  uint64_t hasKey = cva::DictionaryHandler::hasKey(*a1, a2);
  if (hasKey)
  {
    cva::DictionaryHandler::item(&v8, *a1, a2);
    cva::ItemHandler::getValue<float>();
  }
  sub_1D0E5C8F8(&v8);
  char CStringPtr = CFStringGetCStringPtr(a2, 0x8000100u);
  sub_1D0E5E098((uint64_t)v10, &v8, 0, 0, "[RELEASE ERROR  ]", "/Library/Caches/com.apple.xbs/Sources/AppleCVA/shared/src/modules/avatar/facekit/facekitdictionaryconverter.cpp", 461, "Missing key %s in the animation dictionary.", CStringPtr);
  sub_1D0E6054C((uint64_t)v10);
  size_t v6 = v9;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  return hasKey;
}

void sub_1D0E52BC4(char **a1, unint64_t a2)
{
  long long v5 = a1[1];
  long long v4 = a1[2];
  if (a2 <= (v4 - v5) >> 4)
  {
    if (a2)
    {
      uint64_t v12 = 16 * a2;
      bzero(a1[1], 16 * a2);
      v5 += v12;
    }
    a1[1] = v5;
  }
  else
  {
    size_t v6 = *a1;
    uint64_t v7 = (v5 - *a1) >> 4;
    unint64_t v8 = v7 + a2;
    if ((v7 + a2) >> 60) {
      abort();
    }
    uint64_t v9 = v4 - v6;
    if (v9 >> 3 > v8) {
      unint64_t v8 = v9 >> 3;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 60) {
        sub_1D0DE8CE0();
      }
      uint64_t v11 = (char *)operator new(16 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    BOOL v13 = &v11[16 * v7];
    size_t v14 = 16 * a2;
    uint64_t v15 = &v11[16 * v10];
    bzero(v13, v14);
    unint64_t v16 = &v13[v14];
    if (v5 != v6)
    {
      do
      {
        *((_OWORD *)v13 - 1) = *((_OWORD *)v5 - 1);
        v13 -= 16;
        v5 -= 16;
      }
      while (v5 != v6);
      long long v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v16;
    a1[2] = v15;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void sub_1D0E52CFC(uint64_t a1, unint64_t a2)
{
  long long v5 = *(_DWORD **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - (uint64_t)v5) >> 2) >= a2)
  {
    if (a2)
    {
      size_t v12 = 12 * ((12 * a2 - 12) / 0xC) + 12;
      bzero(*(void **)(a1 + 8), v12);
      long long v5 = (_DWORD *)((char *)v5 + v12);
    }
    *(void *)(a1 + 8) = v5;
  }
  else
  {
    size_t v6 = *(_DWORD **)a1;
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v5 - *(void *)a1) >> 2);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x1555555555555555) {
      abort();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v4 - (uint64_t)v6) >> 2);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v10 = 0x1555555555555555;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x1555555555555555) {
        sub_1D0DE8CE0();
      }
      uint64_t v11 = (char *)operator new(12 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    BOOL v13 = &v11[12 * v7];
    size_t v14 = &v11[12 * v10];
    size_t v15 = 12 * ((12 * a2 - 12) / 0xC) + 12;
    bzero(v13, v15);
    unint64_t v16 = &v13[v15];
    if (v5 != v6)
    {
      do
      {
        uint64_t v17 = *(void *)(v5 - 3);
        v5 -= 3;
        int v18 = v5[2];
        *(void *)(v13 - 12) = v17;
        v13 -= 12;
        *((_DWORD *)v13 + 2) = v18;
      }
      while (v5 != v6);
      long long v5 = *(_DWORD **)a1;
    }
    *(void *)a1 = v13;
    *(void *)(a1 + 8) = v16;
    *(void *)(a1 + 16) = v14;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void sub_1D0E52E9C(cva::DictionaryHandler *a1, uint64_t a2)
{
  cva::DictionaryHandler::DictionaryHandler(a1);
  cva::ItemHandler::createData((uint64_t *)v7, *(cva::ItemHandler **)(a2 + 48), v4);
  cva::DictionaryHandler::setItem(a1, @"blendshapes", (const cva::ItemHandler *)v7);
  cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v7);
  v7[1] = (void *)8;
  long long memptr = 0;
  malloc_type_posix_memalign(&memptr, 0x20uLL, 0x20uLL, 0x49090899uLL);
  long long v5 = memptr;
  v7[0] = memptr;
  int v8 = 3;
  *(_DWORD *)long long memptr = *(_DWORD *)a2;
  v5[1] = *(_DWORD *)(a2 + 4);
  uint64_t v5[2] = *(_DWORD *)(a2 + 8);
  cva::ItemHandler::createVector<float>();
}

void sub_1D0E530D8()
{
}

void ***sub_1D0E53330(void ***a1)
{
  id v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    free(v2[3]);
    free(*v2);
    MEMORY[0x1D25F16B0](v2, 0x1080C407C7A2332);
  }
  return a1;
}

uint64_t sub_1D0E53388()
{
  unint64_t v0 = 0x1EB9F1000uLL;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1610, memory_order_acquire) & 1) == 0)
  {
    int v2 = __cxa_guard_acquire(&qword_1EB9F1610);
    unint64_t v0 = 0x1EB9F1000;
    if (v2)
    {
      qword_1EB9F1620 = (uint64_t)os_log_create("com.apple.AppleCVA", "FaceKit");
      __cxa_guard_release(&qword_1EB9F1610);
      unint64_t v0 = 0x1EB9F1000;
    }
  }
  return *(void *)(v0 + 1568);
}

void sub_1D0E533F8(std::string *a1, const char *a2)
{
  CFDataRef v4 = (void *)MEMORY[0x1E4F28B50];
  long long v5 = [NSString stringWithUTF8String:"com.apple.AppleCVA"];
  size_t v6 = [v4 bundleWithIdentifier:v5];

  if (v6)
  {
    unint64_t v7 = [v6 resourcePath];
    int v8 = v7;
    if (!v7)
    {
      *((unsigned char *)&a1->__r_.__value_.__s + 23) = 0;
      a1->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_49;
    }
    unint64_t v9 = (const char *)[v7 cStringUsingEncoding:4];
    size_t v10 = strlen(v9);
    if (v10 > 0x7FFFFFFFFFFFFFF7) {
      abort();
    }
    size_t v11 = v10;
    if (v10 >= 0x17)
    {
      uint64_t v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v10 | 7) != 0x17) {
        uint64_t v13 = v10 | 7;
      }
      uint64_t v14 = v13 + 1;
      size_t v12 = operator new(v13 + 1);
      a1->__r_.__value_.__l.__size_ = v11;
      a1->__r_.__value_.__r.__words[2] = v14 | 0x8000000000000000;
      a1->__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
    }
    else
    {
      *((unsigned char *)&a1->__r_.__value_.__s + 23) = v10;
      size_t v12 = a1;
      if (!v10)
      {
LABEL_13:
        v12[v11] = 0;
        LODWORD(v15) = SHIBYTE(a1->__r_.__value_.__r.__words[2]);
        if ((v15 & 0x80000000) != 0)
        {
          std::string::size_type size = a1->__r_.__value_.__l.__size_;
          if (!size) {
            goto LABEL_49;
          }
          uint64_t v17 = (std::string *)a1->__r_.__value_.__r.__words[0];
        }
        else
        {
          if (!*((unsigned char *)&a1->__r_.__value_.__s + 23)) {
            goto LABEL_21;
          }
          std::string::size_type size = HIBYTE(a1->__r_.__value_.__r.__words[2]);
          uint64_t v17 = a1;
        }
        if (v17->__r_.__value_.__s.__data_[size - 1] != 47)
        {
          std::string::append(a1, "/", 1uLL);
          LOBYTE(v15) = *((unsigned char *)&a1->__r_.__value_.__s + 23);
        }
        if ((v15 & 0x80) != 0)
        {
          std::string::size_type v15 = a1->__r_.__value_.__l.__size_;
          if (!a2) {
            goto LABEL_49;
          }
          goto LABEL_24;
        }
LABEL_21:
        std::string::size_type v15 = v15;
        if (!a2) {
          goto LABEL_49;
        }
LABEL_24:
        if (v15)
        {
          size_t v18 = strlen(a2);
          if (v18 > 0x7FFFFFFFFFFFFFF7) {
            abort();
          }
          std::string::size_type v19 = v18;
          if (v18 >= 0x17)
          {
            uint64_t v21 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v18 | 7) != 0x17) {
              uint64_t v21 = v18 | 7;
            }
            uint64_t v22 = v21 + 1;
            p_dst = (std::string *)operator new(v21 + 1);
            __dst.__r_.__value_.__l.__size_ = v19;
            __dst.__r_.__value_.__r.__words[2] = v22 | 0x8000000000000000;
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
          }
          else
          {
            *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v18;
            p_dst = &__dst;
            if (!v18) {
              goto LABEL_33;
            }
          }
          memcpy(p_dst, a2, v19);
LABEL_33:
          p_dst->__r_.__value_.__s.__data_[v19] = 0;
          std::string::size_type v23 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          char v24 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          std::string::size_type v26 = __dst.__r_.__value_.__l.__size_;
          std::string::size_type v25 = __dst.__r_.__value_.__r.__words[0];
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v27 = &__dst;
          }
          else {
            uint64_t v27 = (std::string *)__dst.__r_.__value_.__r.__words[0];
          }
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v28 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v28 = __dst.__r_.__value_.__l.__size_;
          }
          if (v27->__r_.__value_.__s.__data_[v28 - 1] != 47)
          {
            std::string::append(&__dst, "/", 1uLL);
            std::string::size_type v23 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
            std::string::size_type v26 = __dst.__r_.__value_.__l.__size_;
            std::string::size_type v25 = __dst.__r_.__value_.__r.__words[0];
            char v24 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          }
          if (v24 >= 0) {
            unint64_t v29 = &__dst;
          }
          else {
            unint64_t v29 = (std::string *)v25;
          }
          if (v24 >= 0) {
            std::string::size_type v30 = v23;
          }
          else {
            std::string::size_type v30 = v26;
          }
          std::string::append(a1, (const std::string::value_type *)v29, v30);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
        }
LABEL_49:

        goto LABEL_50;
      }
    }
    memmove(v12, v9, v11);
    goto LABEL_13;
  }
  *((unsigned char *)&a1->__r_.__value_.__s + 23) = 0;
  a1->__r_.__value_.__s.__data_[0] = 0;
LABEL_50:
}

void sub_1D0E536A0(_Unwind_Exception *a1)
{
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }

  _Unwind_Resume(a1);
}

BOOL sub_1D0E536E0(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *a2;
  uint64_t v7 = a2[1];
  if ((int)((unint64_t)(v7 - *a2) >> 3) >= 1)
  {
    if (a4)
    {
      if (a4 == 1)
      {
        uint64_t v10 = 0;
        do
        {
          uint64_t v11 = *(void *)(*(void *)(a1 + 56) + 48);
          uint64_t v12 = *(void *)(v11 + 24);
          uint64_t v13 = v12 + 40 * v10;
          uint64_t v14 = *(unsigned int *)(v13 + 36);
          if ((int)v14 >= 1)
          {
            uint64_t v15 = *(unsigned int *)(v12 + 40 * v10 + 32);
            if ((int)v15 >= 1)
            {
              unint64_t v16 = (unsigned int *)(v13 + 24);
              uint64_t v17 = *(unsigned int *)(v12 + 40 * v10 + 28);
              uint64_t v18 = *v16;
              if ((int)v17 >= 1 && (int)v18 >= 1)
              {
                uint64_t v20 = *(const void **)(v8 + 8 * v10);
                uint64_t v21 = *(char **)(*(void *)(v11 + 72) + 168 * v10);
                if (v17 == 1)
                {
                  memcpy(v21, v20, 4 * v14 * (unint64_t)v15 * v18);
                  uint64_t v8 = *a2;
                  uint64_t v7 = a2[1];
                }
                else
                {
                  int v22 = 0;
                  int v23 = 0;
                  do
                  {
                    uint64_t v24 = 0;
                    int v25 = v22;
                    do
                    {
                      uint64_t v26 = 0;
                      uint64_t v27 = &v21[4 * v25];
                      int v28 = v22;
                      do
                      {
                        int v29 = v28;
                        std::string::size_type v30 = v27;
                        uint64_t v31 = v14;
                        do
                        {
                          *(_DWORD *)std::string::size_type v30 = *((_DWORD *)v20 + v24 + v29);
                          v30 += 4;
                          v29 += v17;
                          --v31;
                        }
                        while (v31);
                        ++v26;
                        v27 += 4 * v14;
                        v28 += v14 * v17;
                      }
                      while (v26 != v15);
                      ++v24;
                      v25 += v15 * v14;
                    }
                    while (v24 != v17);
                    ++v23;
                    v22 += v15 * v14 * v17;
                  }
                  while (v23 != v18);
                }
              }
            }
          }
          ++v10;
        }
        while (v10 < (int)((unint64_t)(v7 - v8) >> 3));
      }
      else
      {
        uint64_t v43 = 0;
        uint64_t v44 = 0;
        uint64_t v45 = 0;
        do
        {
          uint64_t v46 = *(void *)(*(void *)(a1 + 56) + 48);
          uint64_t v47 = *(void *)(v46 + 24);
          uint64_t v48 = v47 + v44;
          int v49 = *(_DWORD *)(v47 + v44 + 36);
          if (v49 >= 1)
          {
            int v50 = *(_DWORD *)(v48 + 32);
            if (v50 >= 1)
            {
              uint64_t v51 = *(unsigned int *)(v48 + 24);
              if (*(_DWORD *)(v47 + v44 + 28) == 1 && (int)v51 >= 1)
              {
                memcpy(*(void **)(*(void *)(v46 + 72) + v43), *(const void **)(v8 + 8 * v45), 4 * v49 * (unint64_t)v50 * v51);
                uint64_t v8 = *a2;
                uint64_t v7 = a2[1];
              }
            }
          }
          ++v45;
          v44 += 40;
          v43 += 168;
        }
        while (v45 < (int)((unint64_t)(v7 - v8) >> 3));
      }
    }
    else
    {
      uint64_t v32 = 0;
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      do
      {
        uint64_t v35 = *(void *)(*(void *)(a1 + 56) + 48);
        uint64_t v36 = *(void *)(v35 + 24);
        uint64_t v37 = v36 + v33;
        int v38 = *(_DWORD *)(v36 + v33 + 36);
        if (v38 >= 1)
        {
          int v39 = *(_DWORD *)(v37 + 32);
          if (v39 >= 1)
          {
            uint64_t v40 = *(unsigned int *)(v36 + v33 + 28);
            uint64_t v41 = *(unsigned int *)(v37 + 24);
            if ((int)v40 >= 1 && (int)v41 >= 1)
            {
              memcpy(*(void **)(*(void *)(v35 + 72) + v32), *(const void **)(v8 + 8 * v34), 4 * v38 * (unint64_t)v39 * v40 * v41);
              uint64_t v8 = *a2;
              uint64_t v7 = a2[1];
            }
          }
        }
        ++v34;
        v33 += 40;
        v32 += 168;
      }
      while (v34 < (int)((unint64_t)(v7 - v8) >> 3));
    }
  }
  kdebug_trace();
  int v53 = espresso_plan_execute_sync();
  if (v53)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1600))
    {
      qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
      __cxa_guard_release(&qword_1EB9F1600);
    }
    uint64_t v54 = qword_1EB9F1608;
    if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR))
    {
      v80[0] = 67109378;
      v80[1] = v53;
      __int16 v81 = 2080;
      uint64_t status_string = espresso_get_status_string();
      _os_log_error_impl(&dword_1D0DBD000, v54, OS_LOG_TYPE_ERROR, "could not execute espresso network [%d, %s]", (uint8_t *)v80, 0x12u);
    }
    kdebug_trace();
  }
  else
  {
    kdebug_trace();
    uint64_t v57 = *a3;
    uint64_t v56 = a3[1];
    if ((int)((unint64_t)(v56 - *a3) >> 3) >= 1)
    {
      uint64_t v58 = 0;
      do
      {
        uint64_t v59 = *(void *)(*(void *)(a1 + 56) + 48);
        uint64_t v60 = *(void *)(v59 + 48);
        uint64_t v61 = v60 + 40 * v58;
        uint64_t v62 = *(unsigned int *)(v61 + 36);
        if ((int)v62 >= 1)
        {
          uint64_t v63 = *(unsigned int *)(v60 + 40 * v58 + 32);
          if ((int)v63 >= 1)
          {
            uint64_t v64 = *(unsigned int *)(v60 + 40 * v58 + 28);
            uint64_t v65 = *(unsigned int *)(v61 + 24);
            if ((int)v64 >= 1 && (int)v65 >= 1)
            {
              uint64_t v67 = *(char **)(*(void *)(v59 + 96) + 168 * v58);
              unint64_t v68 = *(void **)(v57 + 8 * v58);
              if (!a4 || v64 == 1)
              {
                memcpy(v68, v67, 4 * v62 * (unint64_t)v63 * v64 * v65);
                uint64_t v57 = *a3;
                uint64_t v56 = a3[1];
              }
              else if (a4 == 1)
              {
                int v69 = 0;
                int v70 = 0;
                do
                {
                  uint64_t v71 = 0;
                  int v72 = v69;
                  do
                  {
                    uint64_t v73 = 0;
                    unint64_t v74 = &v67[4 * v72];
                    int v75 = v69;
                    do
                    {
                      long long v76 = v74;
                      int v77 = v75;
                      uint64_t v78 = v62;
                      do
                      {
                        int v79 = *(_DWORD *)v76;
                        v76 += 4;
                        *((_DWORD *)v68 + v71 + v77) = v79;
                        v77 += v64;
                        --v78;
                      }
                      while (v78);
                      ++v73;
                      v75 += v62 * v64;
                      v74 += 4 * v62;
                    }
                    while (v73 != v63);
                    ++v71;
                    v72 += v63 * v62;
                  }
                  while (v71 != v64);
                  ++v70;
                  v69 += v63 * v62 * v64;
                }
                while (v70 != v65);
              }
            }
          }
        }
        ++v58;
      }
      while (v58 < (int)((unint64_t)(v56 - v57) >> 3));
    }
  }
  return v53 == 0;
}

void sub_1D0E53C34(void *a1)
{
  *a1 = &unk_1F26F40E8;
  sub_1D0E53CC4((void *)a1[7]);
  uint64_t v2 = a1[7];
  a1[7] = 0;
  if (v2)
  {
    uint64_t v3 = sub_1D0E53EE8(v2);
    MEMORY[0x1D25F16B0](v3, 0x10B2C4010D42EDDLL);
  }
  sub_1D0E57CEC(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E53CC4(void *a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  a1[6] = 0;
  a1[7] = 0;
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  if (a1[11])
  {
    uint64_t v3 = (char *)a1[10];
    if (v3)
    {
      do
      {
        CFDataRef v4 = *(char **)v3;
        long long v5 = (std::__shared_weak_count *)*((void *)v3 + 6);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        if (v3[39] < 0) {
          operator delete(*((void **)v3 + 2));
        }
        operator delete(v3);
        uint64_t v3 = v4;
      }
      while (v4);
    }
    a1[10] = 0;
    uint64_t v6 = a1[9];
    if (v6)
    {
      for (uint64_t i = 0; i != v6; ++i)
        *(void *)(a1[8] + 8 * i) = 0;
    }
    a1[11] = 0;
  }
  if (*a1)
  {
    int v8 = espresso_context_destroy();
    if (v8)
    {
      int v9 = v8;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1600))
      {
        qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
        __cxa_guard_release(&qword_1EB9F1600);
      }
      uint64_t v10 = qword_1EB9F1608;
      if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR))
      {
        v11[0] = 67109378;
        v11[1] = v9;
        __int16 v12 = 2080;
        uint64_t status_string = espresso_get_status_string();
        _os_log_error_impl(&dword_1D0DBD000, v10, OS_LOG_TYPE_ERROR, "could not delete espresso context [%d, %s]", (uint8_t *)v11, 0x12u);
      }
    }
    *a1 = 0;
  }
}

uint64_t sub_1D0E53EE8(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 80);
  if (v2)
  {
    do
    {
      uint64_t v3 = *(char **)v2;
      CFDataRef v4 = (std::__shared_weak_count *)*((void *)v2 + 6);
      if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
      if (v2[39] < 0) {
        operator delete(*((void **)v2 + 2));
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  long long v5 = *(void **)(a1 + 64);
  *(void *)(a1 + 64) = 0;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 56);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if ((*(char *)(a1 + 47) & 0x80000000) == 0) {
      return a1;
    }
    goto LABEL_14;
  }
  if (*(char *)(a1 + 47) < 0) {
LABEL_14:
  }
    operator delete(*(void **)(a1 + 24));
  return a1;
}

void *sub_1D0E54010(void *a1)
{
  *a1 = &unk_1F26F40E8;
  sub_1D0E53CC4((void *)a1[7]);
  uint64_t v2 = a1[7];
  a1[7] = 0;
  if (v2)
  {
    uint64_t v3 = sub_1D0E53EE8(v2);
    MEMORY[0x1D25F16B0](v3, 0x10B2C4010D42EDDLL);
  }
  return sub_1D0E57CEC(a1);
}

uint64_t sub_1D0E5408C()
{
  unint64_t v0 = 0x1EB9F1000uLL;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0)
  {
    int v2 = __cxa_guard_acquire(&qword_1EB9F1600);
    unint64_t v0 = 0x1EB9F1000;
    if (v2)
    {
      qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
      __cxa_guard_release(&qword_1EB9F1600);
      unint64_t v0 = 0x1EB9F1000;
    }
  }
  return *(void *)(v0 + 1544);
}

BOOL sub_1D0E540FC(uint64_t a1, void *a2, int a3, uint64_t a4)
{
  uint64_t v257 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 56);
  if (*(void *)v4)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0)
    {
      if (__cxa_guard_acquire(&qword_1EB9F1600))
      {
        qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
        __cxa_guard_release(&qword_1EB9F1600);
      }
    }
    long long v5 = qword_1EB9F1608;
    BOOL result = os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)int buf = 0;
    uint64_t v7 = "espresso has already initialized";
    goto LABEL_5;
  }
  *(void *)(v4 + 8) = 0xFFFFFFFF00000000;
  *(_DWORD *)(v4 + 16) = 65568;
  uint64_t v11 = (void **)(v4 + 24);
  if ((void *)(v4 + 24) != a2)
  {
    if (*(char *)(v4 + 47) < 0)
    {
      size_t v13 = a2[1];
      if (*((char *)a2 + 23) >= 0)
      {
        size_t v14 = *((unsigned __int8 *)a2 + 23);
      }
      else
      {
        a2 = (void *)*a2;
        size_t v14 = v13;
      }
      sub_1D0DF92F0(v11, a2, v14);
    }
    else if ((*((unsigned char *)a2 + 23) & 0x80) != 0)
    {
      sub_1D0DF922C(v11, (void *)*a2, a2[1]);
    }
    else
    {
      long long v12 = *(_OWORD *)a2;
      *(void *)(v4 + 40) = a2[2];
      *(_OWORD *)uint64_t v11 = v12;
    }
  }
  CFStringRef v15 = (const __CFString *)CFPreferencesCopyAppValue(@"com.apple.applecva.force_espresso_engine", (CFStringRef)*MEMORY[0x1E4F1D3B8]);
  if (!v15) {
    goto LABEL_31;
  }
  CFStringRef v16 = v15;
  CFStringGetCString(v15, buf, 128, 0x8000100u);
  CFRelease(v16);
  size_t v17 = strlen(buf);
  if (v17 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_404;
  }
  size_t v18 = v17;
  if (v17 >= 0x17)
  {
    uint64_t v20 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v17 | 7) != 0x17) {
      uint64_t v20 = v17 | 7;
    }
    uint64_t v21 = v20 + 1;
    p_dst = (long long *)operator new(v20 + 1);
    *((void *)&__dst + 1) = v18;
    unint64_t v250 = v21 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_23;
  }
  HIBYTE(v250) = v17;
  p_dst = &__dst;
  if (v17) {
LABEL_23:
  }
    memcpy(p_dst, buf, v18);
  *((unsigned char *)p_dst + v18) = 0;
  HIBYTE(v256) = 3;
  strcpy((char *)v255, "CPU");
  int v22 = cva::utils::string::iequals();
  if (SHIBYTE(v256) < 0)
  {
    operator delete(*(void **)v255);
    if ((SHIBYTE(v250) & 0x80000000) == 0)
    {
LABEL_26:
      if (v22) {
        goto LABEL_27;
      }
      goto LABEL_35;
    }
  }
  else if ((SHIBYTE(v250) & 0x80000000) == 0)
  {
    goto LABEL_26;
  }
  operator delete((void *)__dst);
  if (v22)
  {
LABEL_27:
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1600))
    {
      qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
      __cxa_guard_release(&qword_1EB9F1600);
    }
    int v23 = qword_1EB9F1608;
    if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_INFO))
    {
      LOWORD(__dst) = 0;
      _os_log_impl(&dword_1D0DBD000, v23, OS_LOG_TYPE_INFO, "forcing CPU engine for espresso", (uint8_t *)&__dst, 2u);
    }
    a3 = 0;
    goto LABEL_31;
  }
LABEL_35:
  size_t v24 = strlen(buf);
  if (v24 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_404;
  }
  size_t v25 = v24;
  if (v24 >= 0x17)
  {
    uint64_t v44 = (v24 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v24 | 7) != 0x17) {
      uint64_t v44 = v24 | 7;
    }
    uint64_t v45 = v44 + 1;
    uint64_t v26 = (long long *)operator new(v44 + 1);
    *((void *)&__dst + 1) = v25;
    unint64_t v250 = v45 | 0x8000000000000000;
    *(void *)&long long __dst = v26;
    goto LABEL_78;
  }
  HIBYTE(v250) = v24;
  uint64_t v26 = &__dst;
  if (v24) {
LABEL_78:
  }
    memcpy(v26, buf, v25);
  *((unsigned char *)v26 + v25) = 0;
  HIBYTE(v256) = 13;
  strcpy((char *)v255, "CPU_QUANTIZED");
  int v46 = cva::utils::string::iequals();
  if (SHIBYTE(v256) < 0)
  {
    operator delete(*(void **)v255);
    if ((SHIBYTE(v250) & 0x80000000) == 0)
    {
LABEL_81:
      if (v46) {
        goto LABEL_82;
      }
      goto LABEL_88;
    }
  }
  else if ((SHIBYTE(v250) & 0x80000000) == 0)
  {
    goto LABEL_81;
  }
  operator delete((void *)__dst);
  if (v46)
  {
LABEL_82:
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1600))
    {
      qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
      __cxa_guard_release(&qword_1EB9F1600);
    }
    uint64_t v47 = qword_1EB9F1608;
    if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_INFO))
    {
      LOWORD(__dst) = 0;
      _os_log_impl(&dword_1D0DBD000, v47, OS_LOG_TYPE_INFO, "forcing CPU_QUANTIZED engine for espresso", (uint8_t *)&__dst, 2u);
    }
    a3 = 4;
    goto LABEL_31;
  }
LABEL_88:
  size_t v48 = strlen(buf);
  if (v48 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_404;
  }
  size_t v49 = v48;
  if (v48 >= 0x17)
  {
    uint64_t v51 = (v48 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v48 | 7) != 0x17) {
      uint64_t v51 = v48 | 7;
    }
    uint64_t v52 = v51 + 1;
    int v50 = (long long *)operator new(v51 + 1);
    *((void *)&__dst + 1) = v49;
    unint64_t v250 = v52 | 0x8000000000000000;
    *(void *)&long long __dst = v50;
    goto LABEL_96;
  }
  HIBYTE(v250) = v48;
  int v50 = &__dst;
  if (v48) {
LABEL_96:
  }
    memcpy(v50, buf, v49);
  *((unsigned char *)v50 + v49) = 0;
  HIBYTE(v256) = 3;
  strcpy((char *)v255, "GPU");
  int v53 = cva::utils::string::iequals();
  if ((SHIBYTE(v256) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v250) & 0x80000000) == 0) {
      goto LABEL_99;
    }
LABEL_111:
    operator delete((void *)__dst);
    if (v53) {
      goto LABEL_100;
    }
LABEL_112:
    size_t v64 = strlen(buf);
    if (v64 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_404;
    }
    size_t v65 = v64;
    if (v64 >= 0x17)
    {
      uint64_t v67 = (v64 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v64 | 7) != 0x17) {
        uint64_t v67 = v64 | 7;
      }
      uint64_t v68 = v67 + 1;
      int64_t v66 = (long long *)operator new(v67 + 1);
      *((void *)&__dst + 1) = v65;
      unint64_t v250 = v68 | 0x8000000000000000;
      *(void *)&long long __dst = v66;
    }
    else
    {
      HIBYTE(v250) = v64;
      int64_t v66 = &__dst;
      if (!v64)
      {
LABEL_120:
        *((unsigned char *)v66 + v65) = 0;
        HIBYTE(v256) = 3;
        strcpy((char *)v255, "ANE");
        int v69 = cva::utils::string::iequals();
        if (SHIBYTE(v256) < 0)
        {
          operator delete(*(void **)v255);
          if ((SHIBYTE(v250) & 0x80000000) == 0)
          {
LABEL_122:
            if (v69)
            {
LABEL_123:
              uint64_t v54 = sub_1D0E5408C();
              if (!os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
              {
                a3 = 2;
                goto LABEL_31;
              }
              LOWORD(__dst) = 0;
              unint64_t v55 = "forcing ANE engine for espresso";
              a3 = 2;
LABEL_125:
              _os_log_impl(&dword_1D0DBD000, v54, OS_LOG_TYPE_INFO, v55, (uint8_t *)&__dst, 2u);
              goto LABEL_31;
            }
LABEL_174:
            sub_1D0DE8604(&__dst, buf);
            sub_1D0DE8604(v255, "ANE_REALTIME");
            int v86 = cva::utils::string::iequals();
            if (SHIBYTE(v256) < 0) {
              operator delete(*(void **)v255);
            }
            if (SHIBYTE(v250) < 0) {
              operator delete((void *)__dst);
            }
            int v87 = sub_1D0E5408C();
            Float64 v88 = v87;
            if (!v86)
            {
              if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
              {
                LODWORD(__dst) = 136315138;
                *(void *)((char *)&__dst + 4) = buf;
                _os_log_error_impl(&dword_1D0DBD000, v88, OS_LOG_TYPE_ERROR, "%s is not a valid espresso engine", (uint8_t *)&__dst, 0xCu);
              }
              return 0;
            }
            if (os_log_type_enabled(v87, OS_LOG_TYPE_INFO))
            {
              LOWORD(__dst) = 0;
              _os_log_impl(&dword_1D0DBD000, v88, OS_LOG_TYPE_INFO, "forcing ANE realtime engine for espresso", (uint8_t *)&__dst, 2u);
            }
            a3 = 3;
            goto LABEL_31;
          }
        }
        else if ((SHIBYTE(v250) & 0x80000000) == 0)
        {
          goto LABEL_122;
        }
        operator delete((void *)__dst);
        if (v69) {
          goto LABEL_123;
        }
        goto LABEL_174;
      }
    }
    memcpy(v66, buf, v65);
    goto LABEL_120;
  }
  operator delete(*(void **)v255);
  if (SHIBYTE(v250) < 0) {
    goto LABEL_111;
  }
LABEL_99:
  if (!v53) {
    goto LABEL_112;
  }
LABEL_100:
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1600))
  {
    qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
    __cxa_guard_release(&qword_1EB9F1600);
  }
  uint64_t v54 = qword_1EB9F1608;
  a3 = 1;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_INFO))
  {
    LOWORD(__dst) = 0;
    unint64_t v55 = "forcing GPU engine for espresso";
    goto LABEL_125;
  }
LABEL_31:
  switch(a3)
  {
    case 1:
      *(void *)(*(void *)(a1 + 56) + 8) = 0xFFFFFFFD00000005;
      break;
    case 2:
      uint64_t v27 = *(void *)(a1 + 56);
      int v28 = 10007;
      goto LABEL_41;
    case 3:
      uint64_t v27 = *(void *)(a1 + 56);
      int v28 = 10006;
LABEL_41:
      *(_DWORD *)(v27 + 8) = v28;
      *(_DWORD *)(v27 + 16) = 65552;
      break;
    case 4:
      uint64_t v29 = *(void *)(a1 + 56);
      *(_DWORD *)(v29 + 8) = 10010;
      *(_DWORD *)(v29 + 16) = 0x80000;
      break;
    default:
      break;
  }
  **(void **)(a1 + 56) = espresso_create_context();
  uint64_t v30 = *(void *)(a1 + 56);
  if (*(void *)v30) {
    goto LABEL_44;
  }
  if (*(_DWORD *)(v30 + 8) == 5 && *(_DWORD *)(v30 + 12) != -1)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1600))
    {
      qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
      __cxa_guard_release(&qword_1EB9F1600);
    }
    uint64_t v41 = qword_1EB9F1608;
    if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1D0DBD000, v41, OS_LOG_TYPE_DEFAULT, "requested MPS espresso engine but no suitable device available: falling back to CPU", buf, 2u);
    }
    *(void *)(*(void *)(a1 + 56) + 8) = 0xFFFFFFFF00000000;
    **(void **)(a1 + 56) = espresso_create_context();
    if (**(void **)(a1 + 56))
    {
LABEL_44:
      uint64_t v31 = operator new(0x90uLL);
      v31[1] = 0;
      v31[2] = 0;
      v31[3] = 0;
      void *v31 = &unk_1F26F4EC8;
      *((_OWORD *)v31 + 3) = 0u;
      *((_OWORD *)v31 + 4) = 0u;
      *((_OWORD *)v31 + 5) = 0u;
      *((_OWORD *)v31 + 6) = 0u;
      *((_OWORD *)v31 + 7) = 0u;
      *((_OWORD *)v31 + 8) = 0u;
      sub_1D0E56350(v31 + 3);
      uint64_t v32 = *(void *)(a1 + 56);
      uint64_t v33 = *(std::__shared_weak_count **)(v32 + 56);
      *(void *)(v32 + 48) = v31 + 3;
      *(void *)(v32 + 56) = v31;
      if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
      uint64_t v34 = *(void *)(a1 + 56);
      uint64_t v35 = *(uint64_t **)(v34 + 48);
      uint64_t v36 = (const char *)(v34 + 24);
      if (*(char *)(v34 + 47) < 0) {
        uint64_t v36 = *(const char **)v36;
      }
      uint64_t plan = espresso_create_plan();
      *uint64_t v35 = plan;
      if (!plan)
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1600))
        {
          qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
          __cxa_guard_release(&qword_1EB9F1600);
        }
        unint64_t v42 = qword_1EB9F1608;
        if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)int buf = 0;
          _os_log_error_impl(&dword_1D0DBD000, v42, OS_LOG_TYPE_ERROR, "could not create espresso plan", buf, 2u);
        }
        goto LABEL_66;
      }
      int v38 = espresso_plan_add_network();
      if (v38)
      {
        int v39 = v38;
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1600))
        {
          qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
          __cxa_guard_release(&qword_1EB9F1600);
        }
        uint64_t v40 = qword_1EB9F1608;
        if (!os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR)) {
          goto LABEL_53;
        }
        uint64_t status_string = espresso_get_status_string();
        *(_DWORD *)int buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v39;
        *(_WORD *)&uint8_t buf[8] = 2080;
        *(void *)&buf[10] = status_string;
        uint64_t v60 = "could not add network [%d, %s]";
        uint64_t v61 = v40;
LABEL_190:
        _os_log_error_impl(&dword_1D0DBD000, v61, OS_LOG_TYPE_ERROR, v60, buf, 0x12u);
LABEL_53:
        sub_1D0E56350(v35);
        goto LABEL_66;
      }
      if (*(char *)(a4 + 23) < 0)
      {
        if (!*(void *)(a4 + 8)) {
          goto LABEL_108;
        }
      }
      else if (!*(unsigned char *)(a4 + 23))
      {
        goto LABEL_108;
      }
      int v56 = espresso_network_select_configuration();
      if (v56)
      {
        int v57 = v56;
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9F1600))
        {
          qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
          __cxa_guard_release(&qword_1EB9F1600);
        }
        uint64_t v58 = qword_1EB9F1608;
        if (!os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR)) {
          goto LABEL_53;
        }
        uint64_t v59 = espresso_get_status_string();
        *(_DWORD *)int buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v57;
        *(_WORD *)&uint8_t buf[8] = 2080;
        *(void *)&buf[10] = v59;
        uint64_t v60 = "could not select espresso configuration [%d, %s]";
        uint64_t v61 = v58;
        goto LABEL_190;
      }
LABEL_108:
      long long v234 = 0;
      long long v235 = 0;
      uint64_t v236 = 0;
      std::string __p = 0;
      BOOL v232 = 0;
      uint64_t v233 = 0;
      cva::Path::Path((cva::Path *)&v225, v36);
      cva::Path::filename((uint64_t *)&__dst, (cva::Path *)&v225);
      uint64_t v62 = cva::Path::string((cva::Path *)&__dst);
      if (*(char *)(v62 + 23) < 0)
      {
        sub_1D0DCB370(buf, *(void **)v62, *(void *)(v62 + 8));
      }
      else
      {
        long long v63 = *(_OWORD *)v62;
        *(void *)&uint8_t buf[16] = *(void *)(v62 + 16);
        *(_OWORD *)int buf = v63;
      }
      cva::Path::~Path((cva::Path *)&__dst);
      size_t v70 = buf[23];
      if (buf[23] >= 0) {
        uint64_t v71 = buf;
      }
      else {
        uint64_t v71 = *(unsigned char **)buf;
      }
      if (buf[23] < 0) {
        size_t v70 = *(void *)&buf[8];
      }
      if (v70)
      {
        size_t v72 = v70;
        uint64_t v73 = v71;
        do
        {
          if (*v73 == 46) {
            goto LABEL_137;
          }
          ++v73;
          --v72;
        }
        while (v72);
        uint64_t v73 = &v71[v70];
LABEL_137:
        if (v73 == &v71[v70]) {
          unint64_t v74 = -1;
        }
        else {
          unint64_t v74 = v73 - v71;
        }
      }
      else
      {
        unint64_t v74 = -1;
      }
      if (v70 >= v74) {
        size_t v75 = v74;
      }
      else {
        size_t v75 = v70;
      }
      if (v75 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_404;
      }
      if (v75 >= 0x17)
      {
        uint64_t v77 = (v75 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v75 | 7) != 0x17) {
          uint64_t v77 = v75 | 7;
        }
        uint64_t v78 = v77 + 1;
        long long v76 = (long long *)operator new(v77 + 1);
        *((void *)&__dst + 1) = v75;
        unint64_t v250 = v78 | 0x8000000000000000;
        *(void *)&long long __dst = v76;
      }
      else
      {
        HIBYTE(v250) = v75;
        long long v76 = &__dst;
        if (!v75)
        {
LABEL_152:
          *((unsigned char *)v76 + v75) = 0;
          cva::Path::directory((uint64_t *)v238, (cva::Path *)&v225);
          cva::Path::Path();
          cva::Path::Path((cva::Path *)v255, (const cva::Path *)v238);
          cva::Path::append();
          cva::Path::Path((cva::Path *)&v228, (const cva::Path *)v255);
          cva::Path::~Path((cva::Path *)v255);
          HIBYTE(v256) = 5;
          strcpy((char *)v255, ".json");
          cva::Path::Path((cva::Path *)v252, (const cva::Path *)&v228);
          cva::Path::concatenate();
          cva::Path::Path((cva::Path *)&v223, (const cva::Path *)v252);
          cva::Path::~Path((cva::Path *)v252);
          if (SHIBYTE(v256) < 0) {
            operator delete(*(void **)v255);
          }
          cva::Path::~Path((cva::Path *)&v228);
          cva::Path::~Path((cva::Path *)v237);
          cva::Path::~Path((cva::Path *)v238);
          int v79 = (void **)v234;
          for (uint64_t i = v235; i != v79; i -= 3)
          {
            if (*((char *)i - 1) < 0) {
              operator delete(*(i - 3));
            }
          }
          long long v235 = v79;
          __int16 v81 = (void **)__p;
          for (uint64_t j = v232; j != v81; j -= 3)
          {
            if (*((char *)j - 1) < 0) {
              operator delete(*(j - 3));
            }
          }
          BOOL v232 = v81;
          if (!cva::Path::exists((cva::Path *)&v223)
            || (cva::Path::isDirectory((cva::Path *)&v223) & 1) != 0)
          {
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EB9F1600))
            {
              qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
              __cxa_guard_release(&qword_1EB9F1600);
            }
            uint64_t v83 = qword_1EB9F1608;
            if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_INFO))
            {
              uint64_t v84 = cva::Path::string((cva::Path *)&v223);
              if (*(char *)(v84 + 23) >= 0) {
                uint64_t v85 = v84;
              }
              else {
                uint64_t v85 = *(void *)v84;
              }
              *(_DWORD *)uint64_t v255 = 136315138;
              *(void *)&v255[4] = v85;
              _os_log_impl(&dword_1D0DBD000, v83, OS_LOG_TYPE_INFO, "could not find a corresponding json file [%s] to load custom input/output layers", v255, 0xCu);
            }
            goto LABEL_220;
          }
          cva::Path::string((cva::Path *)&v223);
          cva::DictionaryHandler::readJsonFile();
          if (!v228)
          {
LABEL_214:
            char v100 = 1;
            uint64_t v101 = (std::__shared_weak_count *)v229;
            if (!v229) {
              goto LABEL_219;
            }
            goto LABEL_217;
          }
          if (!cva::DictionaryHandler::hasKey(v228, "Inputs")) {
            goto LABEL_201;
          }
          cva::DictionaryHandler::item((uint64_t *)v252, v228, "Inputs");
          cva::ItemHandler::getArray((uint64_t *)v255, (cva::ItemHandler *)v252);
          uint64_t v90 = *(cva::ArrayHandler **)v255;
          long long v89 = *(std::__shared_weak_count **)&v255[8];
          memset(v255, 0, sizeof(v255));
          cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v252);
          if (v90)
          {
            int v93 = cva::ArrayHandler::size(v90);
            BOOL v94 = v93 <= 0;
            if (v93 > 0)
            {
              cva::ArrayHandler::item(v90);
              cva::ItemHandler::getValue<std::string>();
            }
            if (!v89)
            {
LABEL_200:
              if (!v94) {
                goto LABEL_216;
              }
LABEL_201:
              if (!cva::DictionaryHandler::hasKey(v228, "Outputs")) {
                goto LABEL_214;
              }
              cva::DictionaryHandler::item((uint64_t *)v252, v228, "Outputs");
              cva::ItemHandler::getArray((uint64_t *)v255, (cva::ItemHandler *)v252);
              uint64_t v96 = *(cva::ArrayHandler **)v255;
              unint64_t v95 = *(std::__shared_weak_count **)&v255[8];
              memset(v255, 0, sizeof(v255));
              cva::ItemHandler::~ItemHandler((cva::ItemHandler *)v252);
              if (v96)
              {
                int v98 = cva::ArrayHandler::size(v96);
                BOOL v99 = v98 <= 0;
                if (v98 > 0)
                {
                  cva::ArrayHandler::item(v96);
                  cva::ItemHandler::getValue<std::string>();
                }
                if (!v95)
                {
LABEL_213:
                  if (v99) {
                    goto LABEL_214;
                  }
LABEL_216:
                  char v100 = 0;
                  uint64_t v101 = (std::__shared_weak_count *)v229;
                  if (!v229) {
                    goto LABEL_219;
                  }
LABEL_217:
                  if (!atomic_fetch_add(&v101->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
                    std::__shared_weak_count::__release_weak(v101);
                  }
LABEL_219:
                  if ((v100 & 1) == 0)
                  {
                    char v102 = 0;
                    goto LABEL_221;
                  }
LABEL_220:
                  char v102 = 1;
LABEL_221:
                  cva::Path::~Path((cva::Path *)&v223);
                  if (SHIBYTE(v250) < 0) {
                    operator delete((void *)__dst);
                  }
                  if ((buf[23] & 0x80000000) != 0) {
                    operator delete(*(void **)buf);
                  }
                  cva::Path::~Path((cva::Path *)&v225);
                  if ((v102 & 1) == 0)
                  {
                    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
                      && __cxa_guard_acquire(&qword_1EB9F1600))
                    {
                      qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
                      __cxa_guard_release(&qword_1EB9F1600);
                    }
                    int v106 = qword_1EB9F1608;
                    if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)int buf = 0;
                      _os_log_error_impl(&dword_1D0DBD000, v106, OS_LOG_TYPE_ERROR, "could not register the input and output layers", buf, 2u);
                    }
                    goto LABEL_234;
                  }
                  int v103 = espresso_plan_build();
                  if (v103)
                  {
                    int v104 = v103;
                    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
                      && __cxa_guard_acquire(&qword_1EB9F1600))
                    {
                      qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
                      __cxa_guard_release(&qword_1EB9F1600);
                    }
                    uint64_t v105 = qword_1EB9F1608;
                    if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v220 = espresso_get_status_string();
                      *(_DWORD *)int buf = 67109378;
                      *(_DWORD *)&uint8_t buf[4] = v104;
                      *(_WORD *)&uint8_t buf[8] = 2080;
                      *(void *)&buf[10] = v220;
                      _os_log_error_impl(&dword_1D0DBD000, v105, OS_LOG_TYPE_ERROR, "could not build espresso plan [%d, %s]", buf, 0x12u);
                    }
                    sub_1D0E56350(v35);
LABEL_234:
                    LOBYTE(v107) = 0;
                    goto LABEL_235;
                  }
                  memset(v255, 0, sizeof(v255));
                  uint64_t v256 = 0;
                  *(void *)uint64_t v252 = 0;
                  uint64_t v253 = 0;
                  uint64_t v254 = 0;
                  int input_names = c_network_get_input_names();
                  if (input_names)
                  {
                    int v114 = input_names;
                    unsigned __int8 v115 = sub_1D0E5408C();
                    if (!os_log_type_enabled(v115, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_261;
                    }
                    uint64_t v116 = espresso_get_status_string();
                    *(_DWORD *)int buf = 67109378;
                    *(_DWORD *)&uint8_t buf[4] = v114;
                    *(_WORD *)&uint8_t buf[8] = 2080;
                    *(void *)&buf[10] = v116;
                    long long v117 = "could not get network input names [%d, %s]";
                    goto LABEL_397;
                  }
                  int output_names = c_network_get_output_names();
                  if (output_names)
                  {
                    int v119 = output_names;
                    unsigned __int8 v115 = sub_1D0E5408C();
                    if (!os_log_type_enabled(v115, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_261;
                    }
                    uint64_t v221 = espresso_get_status_string();
                    *(_DWORD *)int buf = 67109378;
                    *(_DWORD *)&uint8_t buf[4] = v119;
                    *(_WORD *)&uint8_t buf[8] = 2080;
                    *(void *)&buf[10] = v221;
                    long long v117 = "could not get network output names [%d, %s]";
LABEL_397:
                    _os_log_error_impl(&dword_1D0DBD000, v115, OS_LOG_TYPE_ERROR, v117, buf, 0x12u);
LABEL_261:
                    sub_1D0E56350(v35);
                    LOBYTE(v107) = 0;
                    int v120 = *(void ***)v252;
                    if (!*(void *)v252) {
                      goto LABEL_269;
                    }
                    goto LABEL_262;
                  }
                  double v228 = 0;
                  __int16 v229 = 0;
                  uint64_t v230 = 0;
                  sub_1D0E56790((void **)&v228, (uint64_t)v255);
                  __int16 v225 = 0;
                  double v226 = 0;
                  uint64_t v227 = 0;
                  sub_1D0E56790((void **)&v225, (uint64_t)v252);
                  v224[0] = 0;
                  v224[1] = 0;
                  uint64_t v126 = v228;
                  double v222 = v229;
                  __int16 v223 = v224;
                  if (v228 == v229) {
                    goto LABEL_353;
                  }
LABEL_281:
                  int v127 = v224[0];
                  if (!v224[0]) {
                    goto LABEL_320;
                  }
                  int v128 = *((char *)v126 + 23);
                  if (v128 >= 0) {
                    long long v129 = v126;
                  }
                  else {
                    long long v129 = *(cva::DictionaryHandler **)v126;
                  }
                  if (v128 >= 0) {
                    size_t v130 = *((unsigned __int8 *)v126 + 23);
                  }
                  else {
                    size_t v130 = *((void *)v126 + 1);
                  }
                  long long v131 = v224;
                  while (1)
                  {
                    int v132 = v127[55];
                    if (v132 >= 0) {
                      char v133 = v127 + 32;
                    }
                    else {
                      char v133 = (const void *)*((void *)v127 + 4);
                    }
                    if (v132 >= 0) {
                      size_t v134 = v127[55];
                    }
                    else {
                      size_t v134 = *((void *)v127 + 5);
                    }
                    if (v130 >= v134) {
                      size_t v135 = v134;
                    }
                    else {
                      size_t v135 = v130;
                    }
                    int v136 = memcmp(v133, v129, v135);
                    if (v136)
                    {
                      if (v136 < 0) {
                        goto LABEL_291;
                      }
LABEL_289:
                      long long v131 = (char **)v127;
                      int v127 = *(char **)v127;
                      if (!v127) {
                        goto LABEL_306;
                      }
                    }
                    else
                    {
                      if (v134 >= v130) {
                        goto LABEL_289;
                      }
LABEL_291:
                      int v127 = (char *)*((void *)v127 + 1);
                      if (!v127)
                      {
LABEL_306:
                        if (v131 == v224) {
                          goto LABEL_320;
                        }
                        unsigned __int8 v139 = v131[4];
                        int v138 = v131 + 4;
                        uint64_t v137 = v139;
                        int v140 = *((char *)v138 + 23);
                        if (v140 >= 0) {
                          long long v141 = v138;
                        }
                        else {
                          long long v141 = (char **)v137;
                        }
                        if (v140 >= 0) {
                          size_t v142 = *((unsigned __int8 *)v138 + 23);
                        }
                        else {
                          size_t v142 = (size_t)v138[1];
                        }
                        if (v142 >= v130) {
                          size_t v143 = v130;
                        }
                        else {
                          size_t v143 = v142;
                        }
                        int v144 = memcmp(v129, v141, v143);
                        if (!v144)
                        {
                          if (v130 < v142) {
                            goto LABEL_320;
                          }
                          goto LABEL_280;
                        }
                        if ((v144 & 0x80000000) == 0) {
                          goto LABEL_280;
                        }
LABEL_320:
                        HIBYTE(v250) = 5;
                        strcpy((char *)&__dst, "dummy");
                        *(void *)&long long v251 = -1;
                        *((void *)&v251 + 1) = -1;
                        int v145 = sub_1D0E56828(v35[1], v35[2], (long long *)v126, (uint64_t)&__dst, (uint64_t)buf, 1);
                        if (!v145)
                        {
                          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
                            && __cxa_guard_acquire(&qword_1EB9F1600))
                          {
                            qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
                            __cxa_guard_release(&qword_1EB9F1600);
                          }
                          int v148 = qword_1EB9F1608;
                          if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR))
                          {
                            *(_WORD *)unint64_t v238 = 0;
                            _os_log_error_impl(&dword_1D0DBD000, v148, OS_LOG_TYPE_ERROR, "could not setup espresso input", v238, 2u);
                          }
                          sub_1D0E56350(v35);
                          goto LABEL_349;
                        }
                        unint64_t v146 = v35[4];
                        if (v146 >= v35[5])
                        {
                          char v149 = sub_1D0E56F0C((uint64_t)(v35 + 3), (uint64_t)&__dst);
                        }
                        else
                        {
                          if (SHIBYTE(v250) < 0)
                          {
                            sub_1D0DCB370((unsigned char *)v35[4], (void *)__dst, *((unint64_t *)&__dst + 1));
                          }
                          else
                          {
                            long long v147 = __dst;
                            *(void *)(v146 + 16) = v250;
                            *(_OWORD *)unint64_t v146 = v147;
                          }
                          *(_OWORD *)(v146 + 24) = v251;
                          char v149 = (char *)(v146 + 40);
                        }
                        v35[4] = (uint64_t)v149;
                        uint64_t v151 = (char *)v35[10];
                        unint64_t v150 = v35[11];
                        if ((unint64_t)v151 < v150)
                        {
                          long long v152 = *(_OWORD *)buf;
                          long long v153 = v240;
                          *((_OWORD *)v151 + 1) = *(_OWORD *)&buf[16];
                          *((_OWORD *)v151 + 2) = v153;
                          *(_OWORD *)uint64_t v151 = v152;
                          long long v154 = v241;
                          long long v155 = v242;
                          long long v156 = v244;
                          *((_OWORD *)v151 + 5) = v243;
                          *((_OWORD *)v151 + 6) = v156;
                          *((_OWORD *)v151 + 3) = v154;
                          *((_OWORD *)v151 + 4) = v155;
                          long long v157 = v245;
                          long long v158 = v246;
                          long long v159 = v247;
                          *((void *)v151 + 20) = v248;
                          *((_OWORD *)v151 + 8) = v158;
                          *((_OWORD *)v151 + 9) = v159;
                          *((_OWORD *)v151 + 7) = v157;
                          uint64_t v160 = v151 + 168;
                          goto LABEL_348;
                        }
                        uint64_t v161 = (unsigned char *)v35[9];
                        unint64_t v162 = 0xCF3CF3CF3CF3CF3DLL * ((v151 - v161) >> 3) + 1;
                        if (v162 <= 0x186186186186186)
                        {
                          unint64_t v163 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v150 - (void)v161) >> 3);
                          if (2 * v163 > v162) {
                            unint64_t v162 = 2 * v163;
                          }
                          if (v163 >= 0xC30C30C30C30C3) {
                            unint64_t v164 = 0x186186186186186;
                          }
                          else {
                            unint64_t v164 = v162;
                          }
                          if (v164)
                          {
                            if (v164 > 0x186186186186186) {
LABEL_429:
                            }
                              sub_1D0DE8CE0();
                            uint64_t v165 = (char *)operator new(168 * v164);
                          }
                          else
                          {
                            uint64_t v165 = 0;
                          }
                          long long v166 = v247;
                          unint64_t v167 = &v165[8 * ((v151 - v161) >> 3)];
                          *((_OWORD *)v167 + 8) = v246;
                          *((_OWORD *)v167 + 9) = v166;
                          *((void *)v167 + 20) = v248;
                          long long v168 = v243;
                          *((_OWORD *)v167 + 4) = v242;
                          *((_OWORD *)v167 + 5) = v168;
                          long long v169 = v245;
                          *((_OWORD *)v167 + 6) = v244;
                          *((_OWORD *)v167 + 7) = v169;
                          long long v170 = *(_OWORD *)&buf[16];
                          *(_OWORD *)unint64_t v167 = *(_OWORD *)buf;
                          *((_OWORD *)v167 + 1) = v170;
                          long long v171 = v241;
                          *((_OWORD *)v167 + 2) = v240;
                          *((_OWORD *)v167 + 3) = v171;
                          uint64_t v172 = v167;
                          if (v151 != v161)
                          {
                            do
                            {
                              long long v173 = *(_OWORD *)(v151 - 168);
                              long long v174 = *(_OWORD *)(v151 - 152);
                              *(_OWORD *)(v172 - 136) = *(_OWORD *)(v151 - 136);
                              *(_OWORD *)(v172 - 152) = v174;
                              *(_OWORD *)(v172 - 168) = v173;
                              long long v175 = *(_OWORD *)(v151 - 120);
                              long long v176 = *(_OWORD *)(v151 - 104);
                              long long v177 = *(_OWORD *)(v151 - 88);
                              *(_OWORD *)(v172 - 72) = *(_OWORD *)(v151 - 72);
                              *(_OWORD *)(v172 - 88) = v177;
                              *(_OWORD *)(v172 - 104) = v176;
                              *(_OWORD *)(v172 - 120) = v175;
                              long long v178 = *(_OWORD *)(v151 - 56);
                              long long v179 = *(_OWORD *)(v151 - 40);
                              long long v180 = *(_OWORD *)(v151 - 24);
                              *((void *)v172 - 1) = *((void *)v151 - 1);
                              *(_OWORD *)(v172 - 24) = v180;
                              *(_OWORD *)(v172 - 40) = v179;
                              *(_OWORD *)(v172 - 56) = v178;
                              v172 -= 168;
                              v151 -= 168;
                            }
                            while (v151 != v161);
                            uint64_t v151 = (char *)v35[9];
                          }
                          uint64_t v160 = v167 + 168;
                          v35[9] = (uint64_t)v172;
                          v35[10] = (uint64_t)(v167 + 168);
                          v35[11] = (uint64_t)&v165[168 * v164];
                          if (v151) {
                            operator delete(v151);
                          }
LABEL_348:
                          v35[10] = (uint64_t)v160;
                          sub_1D0E570A4((uint64_t **)&v223, (const void **)v126, (uint64_t)v126);
LABEL_349:
                          if (SHIBYTE(v250) < 0) {
                            operator delete((void *)__dst);
                          }
                          if (v145)
                          {
LABEL_280:
                            uint64_t v126 = (cva::DictionaryHandler *)((char *)v126 + 24);
                            if (v126 != v222) {
                              goto LABEL_281;
                            }
LABEL_353:
                            uint64_t v181 = v225;
                            long long v182 = v226;
                            if (v225 == v226)
                            {
                              LOBYTE(v107) = 1;
                            }
                            else
                            {
                              do
                              {
                                HIBYTE(v250) = 5;
                                strcpy((char *)&__dst, "dummy");
                                *(void *)&long long v251 = -1;
                                *((void *)&v251 + 1) = -1;
                                int v107 = sub_1D0E56828(v35[1], v35[2], v181, (uint64_t)&__dst, (uint64_t)buf, 0);
                                if (v107)
                                {
                                  unint64_t v184 = v35[7];
                                  if (v184 >= v35[8])
                                  {
                                    int v187 = sub_1D0E56F0C((uint64_t)(v35 + 6), (uint64_t)&__dst);
                                  }
                                  else
                                  {
                                    if (SHIBYTE(v250) < 0)
                                    {
                                      sub_1D0DCB370((unsigned char *)v35[7], (void *)__dst, *((unint64_t *)&__dst + 1));
                                    }
                                    else
                                    {
                                      long long v185 = __dst;
                                      *(void *)(v184 + 16) = v250;
                                      *(_OWORD *)unint64_t v184 = v185;
                                    }
                                    *(_OWORD *)(v184 + 24) = v251;
                                    int v187 = (char *)(v184 + 40);
                                  }
                                  v35[7] = (uint64_t)v187;
                                  uint64_t v189 = (char *)v35[13];
                                  unint64_t v188 = v35[14];
                                  if ((unint64_t)v189 >= v188)
                                  {
                                    unint64_t v199 = (char *)v35[12];
                                    unint64_t v200 = 0xCF3CF3CF3CF3CF3DLL * ((v189 - v199) >> 3) + 1;
                                    if (v200 > 0x186186186186186) {
                                      goto LABEL_404;
                                    }
                                    unint64_t v201 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v188 - (void)v199) >> 3);
                                    if (2 * v201 > v200) {
                                      unint64_t v200 = 2 * v201;
                                    }
                                    if (v201 >= 0xC30C30C30C30C3) {
                                      unint64_t v202 = 0x186186186186186;
                                    }
                                    else {
                                      unint64_t v202 = v200;
                                    }
                                    if (v202)
                                    {
                                      if (v202 > 0x186186186186186) {
                                        goto LABEL_429;
                                      }
                                      int v203 = (char *)operator new(168 * v202);
                                    }
                                    else
                                    {
                                      int v203 = 0;
                                    }
                                    long long v204 = v247;
                                    int v205 = &v203[8 * ((v189 - v199) >> 3)];
                                    *((_OWORD *)v205 + 8) = v246;
                                    *((_OWORD *)v205 + 9) = v204;
                                    *((void *)v205 + 20) = v248;
                                    long long v206 = v243;
                                    *((_OWORD *)v205 + 4) = v242;
                                    *((_OWORD *)v205 + 5) = v206;
                                    long long v207 = v245;
                                    *((_OWORD *)v205 + 6) = v244;
                                    *((_OWORD *)v205 + 7) = v207;
                                    long long v208 = *(_OWORD *)&buf[16];
                                    *(_OWORD *)int v205 = *(_OWORD *)buf;
                                    *((_OWORD *)v205 + 1) = v208;
                                    long long v209 = v241;
                                    *((_OWORD *)v205 + 2) = v240;
                                    *((_OWORD *)v205 + 3) = v209;
                                    size_t v210 = v205;
                                    if (v189 != v199)
                                    {
                                      do
                                      {
                                        long long v211 = *(_OWORD *)(v189 - 168);
                                        long long v212 = *(_OWORD *)(v189 - 152);
                                        *(_OWORD *)(v210 - 136) = *(_OWORD *)(v189 - 136);
                                        *(_OWORD *)(v210 - 152) = v212;
                                        *(_OWORD *)(v210 - 168) = v211;
                                        long long v213 = *(_OWORD *)(v189 - 120);
                                        long long v214 = *(_OWORD *)(v189 - 104);
                                        long long v215 = *(_OWORD *)(v189 - 88);
                                        *(_OWORD *)(v210 - 72) = *(_OWORD *)(v189 - 72);
                                        *(_OWORD *)(v210 - 88) = v215;
                                        *(_OWORD *)(v210 - 104) = v214;
                                        *(_OWORD *)(v210 - 120) = v213;
                                        long long v216 = *(_OWORD *)(v189 - 56);
                                        long long v217 = *(_OWORD *)(v189 - 40);
                                        long long v218 = *(_OWORD *)(v189 - 24);
                                        *((void *)v210 - 1) = *((void *)v189 - 1);
                                        *(_OWORD *)(v210 - 24) = v218;
                                        *(_OWORD *)(v210 - 40) = v217;
                                        *(_OWORD *)(v210 - 56) = v216;
                                        v210 -= 168;
                                        v189 -= 168;
                                      }
                                      while (v189 != v199);
                                      uint64_t v189 = (char *)v35[12];
                                    }
                                    size_t v219 = &v203[168 * v202];
                                    uint8x8_t v198 = v205 + 168;
                                    v35[12] = (uint64_t)v210;
                                    v35[13] = (uint64_t)(v205 + 168);
                                    v35[14] = (uint64_t)v219;
                                    if (v189) {
                                      operator delete(v189);
                                    }
                                  }
                                  else
                                  {
                                    long long v190 = *(_OWORD *)buf;
                                    long long v191 = v240;
                                    *((_OWORD *)v189 + 1) = *(_OWORD *)&buf[16];
                                    *((_OWORD *)v189 + 2) = v191;
                                    *(_OWORD *)uint64_t v189 = v190;
                                    long long v192 = v241;
                                    long long v193 = v242;
                                    long long v194 = v244;
                                    *((_OWORD *)v189 + 5) = v243;
                                    *((_OWORD *)v189 + 6) = v194;
                                    *((_OWORD *)v189 + 3) = v192;
                                    *((_OWORD *)v189 + 4) = v193;
                                    long long v195 = v245;
                                    long long v196 = v246;
                                    long long v197 = v247;
                                    *((void *)v189 + 20) = v248;
                                    *((_OWORD *)v189 + 8) = v196;
                                    *((_OWORD *)v189 + 9) = v197;
                                    *((_OWORD *)v189 + 7) = v195;
                                    uint8x8_t v198 = v189 + 168;
                                  }
                                  v35[13] = (uint64_t)v198;
                                }
                                else
                                {
                                  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&qword_1EB9F1600))
                                  {
                                    qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
                                    __cxa_guard_release(&qword_1EB9F1600);
                                  }
                                  int v186 = qword_1EB9F1608;
                                  if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR))
                                  {
                                    *(_WORD *)unint64_t v238 = 0;
                                    _os_log_error_impl(&dword_1D0DBD000, v186, OS_LOG_TYPE_ERROR, "could not setup espresso output", v238, 2u);
                                  }
                                  sub_1D0E56350(v35);
                                }
                                if (SHIBYTE(v250) < 0) {
                                  operator delete((void *)__dst);
                                }
                                uint64_t v181 = (long long *)((char *)v181 + 24);
                                if (v181 == v182) {
                                  char v183 = 0;
                                }
                                else {
                                  char v183 = v107;
                                }
                              }
                              while ((v183 & 1) != 0);
                            }
                          }
                          else
                          {
                            LOBYTE(v107) = 0;
                          }
                          sub_1D0DD5F80(v224[0]);
                          sub_1D0DD5FDC((void **)&v225);
                          sub_1D0DD5FDC((void **)&v228);
                          int v120 = *(void ***)v252;
                          if (!*(void *)v252)
                          {
LABEL_269:
                            uint64_t v123 = *(void *)v255;
                            if (*(void *)v255)
                            {
                              uint64_t v124 = *(void *)&v255[8];
                              unsigned __int8 v125 = *(void **)v255;
                              if (*(void *)&v255[8] != *(void *)v255)
                              {
                                do
                                {
                                  if (*(char *)(v124 - 1) < 0) {
                                    operator delete(*(void **)(v124 - 24));
                                  }
                                  v124 -= 24;
                                }
                                while (v124 != v123);
                                unsigned __int8 v125 = *(void **)v255;
                              }
                              *(void *)&v255[8] = v123;
                              operator delete(v125);
                            }
LABEL_235:
                            long long v108 = (void **)__p;
                            if (__p)
                            {
                              for (uint64_t k = v232; k != v108; k -= 3)
                              {
                                if (*((char *)k - 1) < 0) {
                                  operator delete(*(k - 3));
                                }
                              }
                              operator delete(v108);
                            }
                            unsigned __int8 v110 = (void **)v234;
                            if (v234)
                            {
                              for (uint64_t m = v235; m != v110; m -= 3)
                              {
                                if (*((char *)m - 1) < 0) {
                                  operator delete(*(m - 3));
                                }
                              }
                              operator delete(v110);
                            }
                            if (v107)
                            {
                              uint64_t v112 = *(long long ***)(*(void *)(a1 + 56) + 48);
                              if ((long long **)(a1 + 8) != v112 + 3)
                              {
                                sub_1D0E56470((char **)(a1 + 8), v112[3], v112[4], 0xCCCCCCCCCCCCCCCDLL * (((char *)v112[4] - (char *)v112[3]) >> 3));
                                uint64_t v112 = *(long long ***)(*(void *)(a1 + 56) + 48);
                              }
                              if ((long long **)(a1 + 32) != v112 + 6) {
                                sub_1D0E56470((char **)(a1 + 32), v112[6], v112[7], 0xCCCCCCCCCCCCCCCDLL * (((char *)v112[7] - (char *)v112[6]) >> 3));
                              }
                              return 1;
                            }
LABEL_66:
                            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
                              && __cxa_guard_acquire(&qword_1EB9F1600))
                            {
                              qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
                              __cxa_guard_release(&qword_1EB9F1600);
                            }
                            uint64_t v43 = qword_1EB9F1608;
                            if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR))
                            {
                              *(_WORD *)int buf = 0;
                              _os_log_error_impl(&dword_1D0DBD000, v43, OS_LOG_TYPE_ERROR, "failed to create espresso plan", buf, 2u);
                            }
                            sub_1D0E53CC4(*(void **)(a1 + 56));
                            return 0;
                          }
LABEL_262:
                          unsigned __int8 v121 = v253;
                          uint64_t v122 = v120;
                          if (v253 != v120)
                          {
                            do
                            {
                              if (*((char *)v121 - 1) < 0) {
                                operator delete(*(v121 - 3));
                              }
                              v121 -= 3;
                            }
                            while (v121 != v120);
                            uint64_t v122 = *(void ***)v252;
                          }
                          uint64_t v253 = v120;
                          operator delete(v122);
                          goto LABEL_269;
                        }
LABEL_404:
                        abort();
                      }
                    }
                  }
                }
              }
              else
              {
                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
                  && __cxa_guard_acquire(&qword_1EB9F1600))
                {
                  qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
                  __cxa_guard_release(&qword_1EB9F1600);
                }
                long long v97 = qword_1EB9F1608;
                if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)uint64_t v255 = 0;
                  _os_log_error_impl(&dword_1D0DBD000, v97, OS_LOG_TYPE_ERROR, "invalid model json file, 'Outputs' must be an array", v255, 2u);
                  BOOL v99 = 0;
                  if (!v95) {
                    goto LABEL_213;
                  }
                }
                else
                {
                  BOOL v99 = 0;
                  if (!v95) {
                    goto LABEL_213;
                  }
                }
              }
              if (!atomic_fetch_add(&v95->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
                std::__shared_weak_count::__release_weak(v95);
              }
              goto LABEL_213;
            }
          }
          else
          {
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EB9F1600))
            {
              qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
              __cxa_guard_release(&qword_1EB9F1600);
            }
            uint64_t v92 = qword_1EB9F1608;
            if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint64_t v255 = 0;
              _os_log_error_impl(&dword_1D0DBD000, v92, OS_LOG_TYPE_ERROR, "invalid model json file, 'Inputs' must be an array", v255, 2u);
              BOOL v94 = 0;
              if (!v89) {
                goto LABEL_200;
              }
            }
            else
            {
              BOOL v94 = 0;
              if (!v89) {
                goto LABEL_200;
              }
            }
          }
          if (!atomic_fetch_add(&v89->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
            std::__shared_weak_count::__release_weak(v89);
          }
          goto LABEL_200;
        }
      }
      memmove(v76, v71, v75);
      goto LABEL_152;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1600))
  {
    qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
    __cxa_guard_release(&qword_1EB9F1600);
  }
  long long v5 = qword_1EB9F1608;
  BOOL result = os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)int buf = 0;
    uint64_t v7 = "could not create espresso context";
LABEL_5:
    _os_log_error_impl(&dword_1D0DBD000, v5, OS_LOG_TYPE_ERROR, v7, buf, 2u);
    return 0;
  }
  return result;
}

void sub_1D0E56350(void *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (*a1)
  {
    int v2 = espresso_plan_destroy();
    if (v2)
    {
      int v3 = v2;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9F1600))
      {
        qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
        __cxa_guard_release(&qword_1EB9F1600);
      }
      uint64_t v4 = qword_1EB9F1608;
      if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR))
      {
        v5[0] = 67109378;
        v5[1] = v3;
        __int16 v6 = 2080;
        uint64_t status_string = espresso_get_status_string();
        _os_log_error_impl(&dword_1D0DBD000, v4, OS_LOG_TYPE_ERROR, "could not delete espresso plan [%d, %s]", (uint8_t *)v5, 0x12u);
      }
    }
    *a1 = 0;
  }
}

void sub_1D0E56470(char **a1, long long *a2, long long *a3, size_t __sz)
{
  __int16 v6 = a2;
  uint64_t v8 = (uint64_t)a1[2];
  int v9 = *a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((v8 - (uint64_t)*a1) >> 3) < __sz)
  {
    if (v9)
    {
      uint64_t v10 = (void **)a1[1];
      uint64_t v11 = *a1;
      if (v10 != (void **)v9)
      {
        do
        {
          if (*((char *)v10 - 17) < 0) {
            operator delete(*(v10 - 5));
          }
          v10 -= 5;
        }
        while (v10 != (void **)v9);
        uint64_t v11 = *a1;
      }
      a1[1] = v9;
      operator delete(v11);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (__sz > 0x666666666666666) {
      goto LABEL_68;
    }
    unint64_t v27 = 0xCCCCCCCCCCCCCCCDLL * (v8 >> 3);
    uint64_t v28 = 2 * v27;
    if (2 * v27 <= __sz) {
      uint64_t v28 = __sz;
    }
    unint64_t v29 = v27 >= 0x333333333333333 ? 0x666666666666666 : v28;
    if (v29 > 0x666666666666666) {
LABEL_68:
    }
      abort();
    uint64_t v30 = 40 * v29;
    int v9 = (char *)operator new(40 * v29);
    *a1 = v9;
    a1[1] = v9;
    a1[2] = &v9[v30];
    while (v6 != a3)
    {
      if (*((char *)v6 + 23) < 0)
      {
        sub_1D0DCB370(v9, *(void **)v6, *((void *)v6 + 1));
      }
      else
      {
        *(_OWORD *)int v9 = *v6;
        *((void *)v9 + 2) = *((void *)v6 + 2);
      }
      *(_OWORD *)(v9 + 24) = *(long long *)((char *)v6 + 24);
      __int16 v6 = (long long *)((char *)v6 + 40);
      v9 += 40;
    }
LABEL_67:
    a1[1] = v9;
    return;
  }
  long long v12 = (void **)a1[1];
  unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v12 - v9) >> 3);
  if (v13 >= __sz)
  {
    if (a2 != a3)
    {
      do
      {
        if (v6 != (long long *)v9)
        {
          char v25 = *((unsigned char *)v6 + 23);
          if (v9[23] < 0)
          {
            if (v25 >= 0) {
              int v23 = v6;
            }
            else {
              int v23 = *(long long **)v6;
            }
            if (v25 >= 0) {
              size_t v24 = *((unsigned __int8 *)v6 + 23);
            }
            else {
              size_t v24 = *((void *)v6 + 1);
            }
            sub_1D0DF92F0((void **)v9, v23, v24);
          }
          else if ((*((unsigned char *)v6 + 23) & 0x80) != 0)
          {
            sub_1D0DF922C(v9, *(void **)v6, *((void *)v6 + 1));
          }
          else
          {
            long long v26 = *v6;
            *((void *)v9 + 2) = *((void *)v6 + 2);
            *(_OWORD *)int v9 = v26;
          }
        }
        *(_OWORD *)(v9 + 24) = *(long long *)((char *)v6 + 24);
        __int16 v6 = (long long *)((char *)v6 + 40);
        v9 += 40;
      }
      while (v6 != a3);
      long long v12 = (void **)a1[1];
    }
    while (v12 != (void **)v9)
    {
      if (*((char *)v12 - 17) < 0) {
        operator delete(*(v12 - 5));
      }
      v12 -= 5;
    }
    goto LABEL_67;
  }
  size_t v14 = (long long *)((char *)a2 + 8 * (((char *)v12 - v9) >> 3));
  if (v12 != (void **)v9)
  {
    uint64_t v15 = 0;
    uint64_t v16 = 40 * v13;
    do
    {
      std::string::size_type v19 = &v9[v15];
      uint64_t v20 = (long long *)((char *)v6 + v15);
      if (v6 != (long long *)v9)
      {
        char v21 = *((unsigned char *)v20 + 23);
        if (v19[23] < 0)
        {
          if (v21 >= 0) {
            size_t v17 = (char *)v6 + v15;
          }
          else {
            size_t v17 = *(char **)((char *)v6 + v15);
          }
          if (v21 >= 0) {
            size_t v18 = *((unsigned __int8 *)v20 + 23);
          }
          else {
            size_t v18 = *(void *)((char *)v6 + v15 + 8);
          }
          std::string::size_type v19 = (char *)sub_1D0DF92F0((void **)v19, v17, v18);
        }
        else if ((*((unsigned char *)v20 + 23) & 0x80) != 0)
        {
          std::string::size_type v19 = (char *)sub_1D0DF922C(v19, *(void **)((char *)v6 + v15), *(void *)((char *)v6 + v15 + 8));
        }
        else
        {
          long long v22 = *v20;
          *((void *)v19 + 2) = *((void *)v20 + 2);
          *(_OWORD *)std::string::size_type v19 = v22;
        }
      }
      *(_OWORD *)(v19 + 24) = *(long long *)((char *)v20 + 24);
      v15 += 40;
    }
    while (v16 != v15);
    int v9 = a1[1];
  }
  uint64_t v31 = v9;
  if (v14 != a3)
  {
    uint64_t v31 = v9;
    do
    {
      if (*((char *)v14 + 23) < 0)
      {
        sub_1D0DCB370(v31, *(void **)v14, *((void *)v14 + 1));
      }
      else
      {
        long long v32 = *v14;
        *((void *)v31 + 2) = *((void *)v14 + 2);
        *(_OWORD *)uint64_t v31 = v32;
      }
      *(_OWORD *)(v31 + 24) = *(long long *)((char *)v14 + 24);
      size_t v14 = (long long *)((char *)v14 + 40);
      v31 += 40;
    }
    while (v14 != a3);
  }
  a1[1] = v31;
}

void **sub_1D0E56790(void **a1, uint64_t a2)
{
  uint64_t v4 = (void **)*a1;
  if (*a1)
  {
    long long v5 = (void **)a1[1];
    __int16 v6 = *a1;
    if (v5 != v4)
    {
      do
      {
        if (*((char *)v5 - 1) < 0) {
          operator delete(*(v5 - 3));
        }
        v5 -= 3;
      }
      while (v5 != v4);
      __int16 v6 = *a1;
    }
    a1[1] = v4;
    operator delete(v6);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  *(_OWORD *)a1 = *(_OWORD *)a2;
  a1[2] = *(void **)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  return a1;
}

uint64_t sub_1D0E56828(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *((unsigned __int8 *)a3 + 23);
  BOOL v11 = (v10 & 0x80u) != 0;
  if ((v10 & 0x80u) != 0) {
    uint64_t v10 = *((void *)a3 + 1);
  }
  if (v11) {
    long long v12 = *(long long **)a3;
  }
  else {
    long long v12 = a3;
  }
  if (v10) {
    unint64_t v13 = v12;
  }
  else {
    unint64_t v13 = 0;
  }
  int v14 = espresso_network_bind_buffer();
  if (v14)
  {
    int v15 = v14;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1600))
    {
      qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
      __cxa_guard_release(&qword_1EB9F1600);
    }
    uint64_t v16 = qword_1EB9F1608;
    if (!os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v53 = 136315650;
    *(void *)uint64_t v54 = v13;
    *(_WORD *)&v54[8] = 1024;
    *(_DWORD *)unint64_t v55 = v15;
    *(_WORD *)&v55[4] = 2080;
    *(void *)&v55[6] = espresso_get_status_string();
    size_t v17 = "could not create blob for %s [%d, %s]";
    goto LABEL_42;
  }
  if ((long long *)a4 != a3)
  {
    char v18 = *((unsigned char *)a3 + 23);
    if (*(char *)(a4 + 23) < 0)
    {
      if (v18 >= 0) {
        uint64_t v20 = a3;
      }
      else {
        uint64_t v20 = *(long long **)a3;
      }
      if (v18 >= 0) {
        size_t v21 = *((unsigned __int8 *)a3 + 23);
      }
      else {
        size_t v21 = *((void *)a3 + 1);
      }
      sub_1D0DF92F0((void **)a4, v20, v21);
    }
    else if ((*((unsigned char *)a3 + 23) & 0x80) != 0)
    {
      sub_1D0DF922C((void *)a4, *(void **)a3, *((void *)a3 + 1));
    }
    else
    {
      long long v19 = *a3;
      *(void *)(a4 + 16) = *((void *)a3 + 2);
      *(_OWORD *)a4 = v19;
    }
  }
  *(_DWORD *)(a4 + 24) = *(void *)(a5 + 104);
  uint64_t v22 = *(void *)(a5 + 88);
  *(_DWORD *)(a4 + 32) = v22;
  uint64_t v23 = *(void *)(a5 + 80);
  *(_DWORD *)(a4 + 36) = v23;
  *(_DWORD *)(a4 + 28) = *(void *)(a5 + 96);
  if (*(void *)(a5 + 112) >= 2uLL)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1600))
    {
      qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
      __cxa_guard_release(&qword_1EB9F1600);
    }
    uint64_t v24 = qword_1EB9F1608;
    if (!os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    LOWORD(v53) = 0;
    size_t v17 = "only blob dimensions with sequence length=1 are currently supported";
    char v25 = v24;
    uint32_t v26 = 2;
    goto LABEL_43;
  }
  if (*(void *)(a5 + 120) != 1 || *(void *)(a5 + 128) != v23 || *(void *)(a5 + 136) != v23 * v22)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9F1600))
    {
      qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
      __cxa_guard_release(&qword_1EB9F1600);
    }
    uint64_t v16 = qword_1EB9F1608;
    if (!os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v53 = 136315650;
    *(void *)uint64_t v54 = v13;
    *(_WORD *)&v54[8] = 1024;
    *(_DWORD *)unint64_t v55 = 0;
    *(_WORD *)&v55[4] = 2080;
    *(void *)&v55[6] = espresso_get_status_string();
    size_t v17 = "unsupported stride sizes for %s [%d, %s]";
LABEL_42:
    char v25 = v16;
    uint32_t v26 = 28;
LABEL_43:
    _os_log_error_impl(&dword_1D0DBD000, v25, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&v53, v26);
    return 0;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1600))
  {
    qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
    __cxa_guard_release(&qword_1EB9F1600);
  }
  unint64_t v27 = qword_1EB9F1608;
  BOOL v28 = os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_INFO);
  if (a6)
  {
    if (!v28) {
      goto LABEL_52;
    }
    if (*(char *)(a4 + 23) >= 0) {
      unint64_t v29 = (void *)a4;
    }
    else {
      unint64_t v29 = *(void **)a4;
    }
    int v53 = 136315138;
    *(void *)uint64_t v54 = v29;
    uint64_t v30 = "Input Layer name: %s";
  }
  else
  {
    if (!v28) {
      goto LABEL_52;
    }
    if (*(char *)(a4 + 23) >= 0) {
      uint64_t v33 = (void *)a4;
    }
    else {
      uint64_t v33 = *(void **)a4;
    }
    int v53 = 136315138;
    *(void *)uint64_t v54 = v33;
    uint64_t v30 = "Output Layer name: %s";
  }
  _os_log_impl(&dword_1D0DBD000, v27, OS_LOG_TYPE_INFO, v30, (uint8_t *)&v53, 0xCu);
LABEL_52:
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1600))
  {
    qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
    __cxa_guard_release(&qword_1EB9F1600);
  }
  uint64_t v34 = qword_1EB9F1608;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_INFO))
  {
    int v35 = *(_DWORD *)(a4 + 32);
    int v36 = *(_DWORD *)(a4 + 36);
    int v37 = *(_DWORD *)(a4 + 24);
    int v38 = *(_DWORD *)(a4 + 28);
    int v53 = 67109888;
    *(_DWORD *)uint64_t v54 = v37;
    *(_WORD *)&v54[4] = 1024;
    *(_DWORD *)&v54[6] = v35;
    *(_WORD *)unint64_t v55 = 1024;
    *(_DWORD *)&v55[2] = v36;
    *(_WORD *)&v55[6] = 1024;
    *(_DWORD *)&v55[8] = v38;
    _os_log_impl(&dword_1D0DBD000, v34, OS_LOG_TYPE_INFO, "Size: %d %d %d %d", (uint8_t *)&v53, 0x1Au);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1600))
  {
    qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
    __cxa_guard_release(&qword_1EB9F1600);
  }
  int v39 = qword_1EB9F1608;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_INFO))
  {
    uint64_t v41 = *(void *)(a5 + 104);
    uint64_t v40 = *(void *)(a5 + 112);
    uint64_t v43 = *(void *)(a5 + 88);
    uint64_t v42 = *(void *)(a5 + 96);
    uint64_t v44 = *(void *)(a5 + 80);
    int v53 = 134219008;
    *(void *)uint64_t v54 = v40;
    *(_WORD *)&v54[8] = 2048;
    *(void *)unint64_t v55 = v41;
    *(_WORD *)&v55[8] = 2048;
    *(void *)&unsigned char v55[10] = v42;
    __int16 v56 = 2048;
    uint64_t v57 = v43;
    __int16 v58 = 2048;
    uint64_t v59 = v44;
    _os_log_impl(&dword_1D0DBD000, v39, OS_LOG_TYPE_INFO, "Size (%zd, %zd, %zd, %zd, %zd)", (uint8_t *)&v53, 0x34u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1600))
  {
    qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
    __cxa_guard_release(&qword_1EB9F1600);
  }
  uint64_t v45 = qword_1EB9F1608;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_INFO))
  {
    uint64_t v47 = *(void *)(a5 + 144);
    uint64_t v46 = *(void *)(a5 + 152);
    uint64_t v49 = *(void *)(a5 + 128);
    uint64_t v48 = *(void *)(a5 + 136);
    uint64_t v50 = *(void *)(a5 + 120);
    int v53 = 134219008;
    *(void *)uint64_t v54 = v46;
    *(_WORD *)&v54[8] = 2048;
    *(void *)unint64_t v55 = v47;
    *(_WORD *)&v55[8] = 2048;
    *(void *)&unsigned char v55[10] = v48;
    __int16 v56 = 2048;
    uint64_t v57 = v49;
    __int16 v58 = 2048;
    uint64_t v59 = v50;
    _os_log_impl(&dword_1D0DBD000, v45, OS_LOG_TYPE_INFO, "Stride (%zd, %zd, %zd, %zd, %zd)", (uint8_t *)&v53, 0x34u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9F1600, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9F1600))
  {
    qword_1EB9F1608 = (uint64_t)os_log_create("com.apple.AppleCVA", "Espresso");
    __cxa_guard_release(&qword_1EB9F1600);
  }
  uint64_t v51 = qword_1EB9F1608;
  uint64_t v31 = 1;
  if (os_log_type_enabled((os_log_t)qword_1EB9F1608, OS_LOG_TYPE_INFO))
  {
    int v52 = *(_DWORD *)(a5 + 160);
    int v53 = 67109120;
    *(_DWORD *)uint64_t v54 = v52;
    _os_log_impl(&dword_1D0DBD000, v51, OS_LOG_TYPE_INFO, "Storage: %d", (uint8_t *)&v53, 8u);
  }
  return v31;
}

char *sub_1D0E56F0C(uint64_t a1, uint64_t a2)
{
  int v2 = *(void ***)a1;
  int v3 = *(void ***)(a1 + 8);
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v3 - *(void *)a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x666666666666666) {
    abort();
  }
  if (0x999999999999999ALL * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 3) > v5) {
    unint64_t v5 = 0x999999999999999ALL * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 3);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 3) >= 0x333333333333333) {
    unint64_t v8 = 0x666666666666666;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 > 0x666666666666666) {
      sub_1D0DE8CE0();
    }
    int v9 = operator new(40 * v8);
  }
  else
  {
    int v9 = 0;
  }
  uint64_t v10 = &v9[40 * v4];
  if (*(char *)(a2 + 23) < 0)
  {
    sub_1D0DCB370(&v9[40 * v4], *(void **)a2, *(void *)(a2 + 8));
    int v2 = *(void ***)a1;
    int v3 = *(void ***)(a1 + 8);
  }
  else
  {
    *(_OWORD *)uint64_t v10 = *(_OWORD *)a2;
    *((void *)v10 + 2) = *(void *)(a2 + 16);
  }
  BOOL v11 = &v9[40 * v8];
  *(_OWORD *)&v9[40 * v4 + 24] = *(_OWORD *)(a2 + 24);
  long long v12 = v10 + 40;
  if (v3 == v2)
  {
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v12;
    *(void *)(a1 + 16) = v11;
  }
  else
  {
    do
    {
      long long v13 = *(_OWORD *)(v3 - 5);
      *((void *)v10 - 3) = *(v3 - 3);
      *(_OWORD *)(v10 - 40) = v13;
      *(v3 - 4) = 0;
      *(v3 - 3) = 0;
      *(v3 - 5) = 0;
      *((_OWORD *)v10 - 1) = *((_OWORD *)v3 - 1);
      v10 -= 40;
      v3 -= 5;
    }
    while (v3 != v2);
    int v2 = *(void ***)a1;
    int v14 = *(void ***)(a1 + 8);
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v12;
    *(void *)(a1 + 16) = v11;
    while (v14 != v2)
    {
      if (*((char *)v14 - 17) < 0) {
        operator delete(*(v14 - 5));
      }
      v14 -= 5;
    }
  }
  if (v2) {
    operator delete(v2);
  }
  return v12;
}

uint64_t *sub_1D0E570A4(uint64_t **a1, const void **a2, uint64_t a3)
{
  __int16 v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (!v5)
  {
    uint64_t v10 = a1 + 1;
    goto LABEL_29;
  }
  int v7 = *((char *)a2 + 23);
  if (v7 >= 0) {
    unint64_t v8 = a2;
  }
  else {
    unint64_t v8 = *a2;
  }
  if (v7 >= 0) {
    int v9 = (const void *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    int v9 = a2[1];
  }
  do
  {
    while (1)
    {
      uint64_t v10 = (uint64_t **)v5;
      uint64_t v13 = v5[4];
      BOOL v11 = v5 + 4;
      long long v12 = (void *)v13;
      int v14 = *((char *)v11 + 23);
      int v15 = v14 >= 0 ? v11 : v12;
      uint64_t v16 = v14 >= 0 ? (const void *)*((unsigned __int8 *)v11 + 23) : (const void *)v11[1];
      size_t v17 = (size_t)(v16 >= v9 ? v9 : v16);
      int v18 = memcmp(v8, v15, v17);
      if (v18) {
        break;
      }
      if (v9 >= v16) {
        goto LABEL_22;
      }
LABEL_8:
      unint64_t v5 = *v10;
      __int16 v6 = v10;
      if (!*v10) {
        goto LABEL_29;
      }
    }
    if (v18 < 0) {
      goto LABEL_8;
    }
LABEL_22:
    BOOL result = (uint64_t *)memcmp(v15, v8, v17);
    if (result)
    {
      if ((result & 0x80000000) == 0) {
        return result;
      }
    }
    else if (v16 >= v9)
    {
      return result;
    }
    unint64_t v5 = v10[1];
  }
  while (v5);
  __int16 v6 = v10 + 1;
LABEL_29:
  uint64_t v20 = (uint64_t *)operator new(0x38uLL);
  size_t v21 = v20 + 4;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_1D0DCB370(v21, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)size_t v21 = *(_OWORD *)a3;
    v20[6] = *(void *)(a3 + 16);
  }
  *uint64_t v20 = 0;
  v20[1] = 0;
  v20[2] = (uint64_t)v10;
  void *v6 = v20;
  uint64_t v22 = (uint64_t *)**a1;
  if (v22)
  {
    *a1 = v22;
    uint64_t v20 = *v6;
  }
  BOOL result = sub_1D0DCEC98(a1[1], v20);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

char *sub_1D0E57204(uint64_t a1, uint64_t a2)
{
  int v2 = *(void ***)a1;
  int v3 = *(void ***)(a1 + 8);
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *(void *)a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 3) > v5) {
    unint64_t v5 = 0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      sub_1D0DE8CE0();
    }
    int v9 = (char *)operator new(24 * v8);
  }
  else
  {
    int v9 = 0;
  }
  uint64_t v10 = &v9[24 * v4];
  if (*(char *)(a2 + 23) < 0)
  {
    sub_1D0DCB370(v10, *(void **)a2, *(void *)(a2 + 8));
    int v2 = *(void ***)a1;
    int v3 = *(void ***)(a1 + 8);
  }
  else
  {
    *(_OWORD *)uint64_t v10 = *(_OWORD *)a2;
    *((void *)v10 + 2) = *(void *)(a2 + 16);
  }
  BOOL v11 = &v9[24 * v8];
  long long v12 = v10 + 24;
  if (v3 == v2)
  {
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v12;
    *(void *)(a1 + 16) = v11;
  }
  else
  {
    do
    {
      long long v13 = *(_OWORD *)(v3 - 3);
      *((void *)v10 - 1) = *(v3 - 1);
      *(_OWORD *)(v10 - 24) = v13;
      v10 -= 24;
      *(v3 - 2) = 0;
      *(v3 - 1) = 0;
      *(v3 - 3) = 0;
      v3 -= 3;
    }
    while (v3 != v2);
    int v2 = *(void ***)a1;
    int v14 = *(void ***)(a1 + 8);
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v12;
    *(void *)(a1 + 16) = v11;
    while (v14 != v2)
    {
      if (*((char *)v14 - 1) < 0) {
        operator delete(*(v14 - 3));
      }
      v14 -= 3;
    }
  }
  if (v2) {
    operator delete(v2);
  }
  return v12;
}

void sub_1D0E57380(void *a1)
{
  sub_1D0E56350(a1 + 3);
  int v2 = (void *)a1[15];
  if (v2)
  {
    a1[16] = v2;
    operator delete(v2);
  }
  int v3 = (void *)a1[12];
  if (v3)
  {
    a1[13] = v3;
    operator delete(v3);
  }
  uint64_t v4 = a1[9];
  if (v4)
  {
    uint64_t v5 = a1[10];
    __int16 v6 = (void *)a1[9];
    if (v5 != v4)
    {
      do
      {
        if (*(char *)(v5 - 17) < 0) {
          operator delete(*(void **)(v5 - 40));
        }
        v5 -= 40;
      }
      while (v5 != v4);
      __int16 v6 = (void *)a1[9];
    }
    a1[10] = v4;
    operator delete(v6);
  }
  uint64_t v7 = a1[6];
  if (v7)
  {
    uint64_t v8 = a1[7];
    int v9 = (void *)a1[6];
    if (v8 != v7)
    {
      do
      {
        if (*(char *)(v8 - 17) < 0) {
          operator delete(*(void **)(v8 - 40));
        }
        v8 -= 40;
      }
      while (v8 != v7);
      int v9 = (void *)a1[6];
    }
    a1[7] = v7;
    operator delete(v9);
  }
}

void sub_1D0E5747C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4EC8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

void sub_1D0E574D0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26F4EC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D0E574F0(int a1, uint64_t a2)
{
  unint64_t v4 = a1;
  unint64_t v5 = *((void *)&xmmword_1EA643878 + 1);
  if (*((void *)&xmmword_1EA643878 + 1))
  {
    uint8x8_t v6 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_1EA643878 + 8));
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      unint64_t v2 = a1;
      if (*((void *)&xmmword_1EA643878 + 1) <= (unint64_t)a1) {
        unint64_t v2 = (unint64_t)a1 % *((void *)&xmmword_1EA643878 + 1);
      }
    }
    else
    {
      unint64_t v2 = (*((void *)&xmmword_1EA643878 + 1) - 1) & a1;
    }
    uint64_t v7 = *(uint64_t ***)(xmmword_1EA643878 + 8 * v2);
    if (v7)
    {
      uint64_t v8 = *v7;
      if (v8)
      {
        if (v6.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v10 = v8[1];
            if (v10 == a1)
            {
              if (*((_DWORD *)v8 + 4) == a1) {
                return;
              }
            }
            else if ((v10 & (*((void *)&xmmword_1EA643878 + 1) - 1)) != v2)
            {
              goto LABEL_22;
            }
            uint64_t v8 = (uint64_t *)*v8;
            if (!v8) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v9 = v8[1];
          if (v9 == a1)
          {
            if (*((_DWORD *)v8 + 4) == a1) {
              return;
            }
          }
          else
          {
            if (v9 >= *((void *)&xmmword_1EA643878 + 1)) {
              v9 %= *((void *)&xmmword_1EA643878 + 1);
            }
            if (v9 != v2) {
              break;
            }
          }
          uint64_t v8 = (uint64_t *)*v8;
        }
        while (v8);
      }
    }
  }
LABEL_22:
  BOOL v11 = (char *)operator new(0x30uLL);
  *(void *)BOOL v11 = 0;
  *((void *)v11 + 1) = v4;
  *((_DWORD *)v11 + 4) = *(_DWORD *)a2;
  long long v12 = v11 + 24;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1D0DCB370(v12, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    *(_OWORD *)long long v12 = *(_OWORD *)(a2 + 8);
    *((void *)v11 + 5) = *(void *)(a2 + 24);
  }
  float v13 = (float)(unint64_t)(qword_1EA643890 + 1);
  if (!v5 || (float)(*(float *)&dword_1EA643898 * (float)v5) < v13)
  {
    BOOL v14 = 1;
    if (v5 >= 3) {
      BOOL v14 = (v5 & (v5 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v5);
    unint64_t v16 = vcvtps_u32_f32(v13 / *(float *)&dword_1EA643898);
    if (v15 <= v16) {
      size_t prime = v16;
    }
    else {
      size_t prime = v15;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v5 = *((void *)&xmmword_1EA643878 + 1);
    if (prime <= *((void *)&xmmword_1EA643878 + 1))
    {
      if (prime >= *((void *)&xmmword_1EA643878 + 1)) {
        goto LABEL_62;
      }
      unint64_t v28 = vcvtps_u32_f32((float)(unint64_t)qword_1EA643890 / *(float *)&dword_1EA643898);
      if (*((void *)&xmmword_1EA643878 + 1) < 3uLL
        || (uint8x8_t v29 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_1EA643878 + 8)),
            v29.i16[0] = vaddlv_u8(v29),
            v29.u32[0] > 1uLL))
      {
        unint64_t v28 = std::__next_prime(v28);
      }
      else
      {
        uint64_t v30 = 1 << -(char)__clz(v28 - 1);
        if (v28 >= 2) {
          unint64_t v28 = v30;
        }
      }
      if (prime <= v28) {
        size_t prime = v28;
      }
      if (prime >= v5)
      {
        unint64_t v5 = *((void *)&xmmword_1EA643878 + 1);
LABEL_62:
        if ((v5 & (v5 - 1)) != 0)
        {
          if (v5 <= v4) {
            unint64_t v2 = v4 % v5;
          }
          else {
            unint64_t v2 = v4;
          }
        }
        else
        {
          unint64_t v2 = (v5 - 1) & v4;
        }
        goto LABEL_75;
      }
      if (!prime)
      {
        int v38 = (void *)xmmword_1EA643878;
        *(void *)&xmmword_1EA643878 = 0;
        if (v38) {
          operator delete(v38);
        }
        unint64_t v5 = 0;
        *((void *)&xmmword_1EA643878 + 1) = 0;
        goto LABEL_62;
      }
    }
    if (prime >> 61) {
      sub_1D0DE8CE0();
    }
    int v18 = operator new(8 * prime);
    long long v19 = (void *)xmmword_1EA643878;
    *(void *)&xmmword_1EA643878 = v18;
    if (v19) {
      operator delete(v19);
    }
    uint64_t v20 = 0;
    *((void *)&xmmword_1EA643878 + 1) = prime;
    do
      *(void *)(xmmword_1EA643878 + 8 * v20++) = 0;
    while (prime != v20);
    size_t v21 = (void **)qword_1EA643888;
    if (!qword_1EA643888)
    {
LABEL_61:
      unint64_t v5 = prime;
      goto LABEL_62;
    }
    size_t v22 = *(void *)(qword_1EA643888 + 8);
    size_t v23 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v24 = v22 & v23;
      *(void *)(xmmword_1EA643878 + 8 * v24) = &qword_1EA643888;
      for (uint64_t i = *v21; *v21; uint64_t i = *v21)
      {
        size_t v26 = i[1] & v23;
        if (v26 == v24)
        {
          size_t v21 = (void **)i;
        }
        else if (*(void *)(xmmword_1EA643878 + 8 * v26))
        {
          *size_t v21 = (void *)*i;
          uint64_t v27 = 8 * v26;
          *uint64_t i = **(void **)(xmmword_1EA643878 + v27);
          **(void **)(xmmword_1EA643878 + v27) = i;
        }
        else
        {
          *(void *)(xmmword_1EA643878 + 8 * v26) = v21;
          size_t v21 = (void **)i;
          size_t v24 = v26;
        }
      }
      goto LABEL_61;
    }
    if (v22 >= prime) {
      v22 %= prime;
    }
    *(void *)(xmmword_1EA643878 + 8 * v22) = &qword_1EA643888;
    uint64_t v31 = *v21;
    if (!*v21) {
      goto LABEL_61;
    }
    while (1)
    {
      size_t v33 = v31[1];
      if (v33 >= prime) {
        v33 %= prime;
      }
      if (v33 != v22)
      {
        if (!*(void *)(xmmword_1EA643878 + 8 * v33))
        {
          *(void *)(xmmword_1EA643878 + 8 * v33) = v21;
          goto LABEL_66;
        }
        *size_t v21 = (void *)*v31;
        uint64_t v32 = 8 * v33;
        void *v31 = **(void **)(xmmword_1EA643878 + v32);
        **(void **)(xmmword_1EA643878 + v32) = v31;
        uint64_t v31 = v21;
      }
      size_t v33 = v22;
LABEL_66:
      size_t v21 = (void **)v31;
      uint64_t v31 = (void *)*v31;
      size_t v22 = v33;
      if (!v31) {
        goto LABEL_61;
      }
    }
  }
LABEL_75:
  uint64_t v34 = xmmword_1EA643878;
  int v35 = *(void **)(xmmword_1EA643878 + 8 * v2);
  if (v35)
  {
    *(void *)BOOL v11 = *v35;
LABEL_83:
    *int v35 = v11;
    goto LABEL_84;
  }
  uint64_t v36 = qword_1EA643888;
  *(void *)BOOL v11 = qword_1EA643888;
  qword_1EA643888 = (uint64_t)v11;
  *(void *)(v34 + 8 * v2) = &qword_1EA643888;
  if (v36)
  {
    unint64_t v37 = *(void *)(v36 + 8);
    if ((v5 & (v5 - 1)) != 0)
    {
      if (v37 >= v5) {
        v37 %= v5;
      }
    }
    else
    {
      v37 &= v5 - 1;
    }
    int v35 = (void *)(xmmword_1EA643878 + 8 * v37);
    goto LABEL_83;
  }
LABEL_84:
  ++qword_1EA643890;
}

uint64_t sub_1D0E5798C(unsigned __int8 **a1)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6438A0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v10 = a1;
    int v11 = __cxa_guard_acquire(&qword_1EA6438A0);
    a1 = v10;
    if (v11)
    {
      int v17 = 0;
      v18[23] = 21;
      strcpy(v18, "DetectorType::Unknown");
      int v19 = 1;
      long long v12 = (char *)operator new(0x28uLL);
      uint64_t v20 = v12;
      long long v21 = xmmword_1D0E81880;
      strcpy(v12, "DetectorType::HardwareFaceDetector");
      int v22 = 2;
      float v13 = (char *)operator new(0x19uLL);
      size_t v23 = v13;
      long long v24 = xmmword_1D0E81520;
      strcpy(v13, "DetectorType::VisionKit");
      int v25 = 3;
      BOOL v14 = (char *)operator new(0x20uLL);
      size_t v26 = v14;
      long long v27 = xmmword_1D0E81890;
      strcpy(v14, "DetectorType::CIDetector");
      int v28 = 4;
      unint64_t v15 = (char *)operator new(0x19uLL);
      uint8x8_t v29 = v15;
      long long v30 = xmmword_1D0E81520;
      strcpy(v15, "DetectorType::Projected");
      int v31 = 5;
      unint64_t v16 = (char *)operator new(0x20uLL);
      uint64_t v32 = v16;
      long long v33 = xmmword_1D0E81510;
      strcpy(v16, "DetectorType::VisionKitANFDdev");
      xmmword_1EA643878 = 0u;
      *(_OWORD *)&qword_1EA643888 = 0u;
      dword_1EA643898 = 1065353216;
      sub_1D0E574F0(0, (uint64_t)&v17);
      sub_1D0E574F0(1, (uint64_t)&v19);
      sub_1D0E574F0(2, (uint64_t)&v22);
      sub_1D0E574F0(3, (uint64_t)&v25);
      sub_1D0E574F0(4, (uint64_t)&v28);
      sub_1D0E574F0(5, (uint64_t)&v31);
      operator delete(v16);
      operator delete(v15);
      operator delete(v14);
      operator delete(v13);
      operator delete(v12);
      __cxa_guard_release(&qword_1EA6438A0);
      a1 = v10;
    }
  }
  uint64_t v1 = qword_1EA643888;
  if (qword_1EA643888)
  {
    char v2 = *((unsigned char *)a1 + 23);
    if (v2 >= 0) {
      int v3 = (unsigned __int8 *)*((unsigned __int8 *)a1 + 23);
    }
    else {
      int v3 = a1[1];
    }
    if (v2 >= 0) {
      unint64_t v4 = (unsigned __int8 *)a1;
    }
    else {
      unint64_t v4 = *a1;
    }
    do
    {
      uint64_t v5 = *(unsigned __int8 *)(v1 + 47);
      if ((v5 & 0x80u) == 0) {
        uint8x8_t v6 = (unsigned __int8 *)*(unsigned __int8 *)(v1 + 47);
      }
      else {
        uint8x8_t v6 = *(unsigned __int8 **)(v1 + 32);
      }
      if (v6 == v3)
      {
        uint64_t v7 = (const void **)(v1 + 24);
        if ((v5 & 0x80) != 0)
        {
          if (!memcmp(*v7, v4, *(void *)(v1 + 32))) {
            return *(unsigned int *)(v1 + 16);
          }
        }
        else
        {
          if (!*(unsigned char *)(v1 + 47)) {
            return *(unsigned int *)(v1 + 16);
          }
          for (uint64_t i = v4; *(unsigned __int8 *)v7 == *i; ++i)
          {
            uint64_t v7 = (const void **)((char *)v7 + 1);
            if (!--v5) {
              return *(unsigned int *)(v1 + 16);
            }
          }
        }
      }
      uint64_t v1 = *(void *)v1;
    }
    while (v1);
  }
  return 0;
}

void *sub_1D0E57CEC(void *a1)
{
  *a1 = &unk_1F26F4110;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = a1[5];
    unint64_t v4 = (void *)a1[4];
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 17) < 0) {
          operator delete(*(void **)(v3 - 40));
        }
        v3 -= 40;
      }
      while (v3 != v2);
      unint64_t v4 = (void *)a1[4];
    }
    a1[5] = v2;
    operator delete(v4);
  }
  uint64_t v5 = a1[1];
  if (v5)
  {
    uint64_t v6 = a1[2];
    uint64_t v7 = (void *)a1[1];
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 17) < 0) {
          operator delete(*(void **)(v6 - 40));
        }
        v6 -= 40;
      }
      while (v6 != v5);
      uint64_t v7 = (void *)a1[1];
    }
    a1[2] = v5;
    operator delete(v7);
  }
  return a1;
}

uint64_t sub_1D0E57DC4(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4)
{
  uint64_t v320 = *MEMORY[0x1E4F143B8];
  if (a4) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *a2;
  uint64_t v301 = v4;
  if (a2[1] != *a2)
  {
    unint64_t v6 = 0;
    do
    {
      uint64_t v7 = *(void *)(v4 + 16);
      uint64_t v8 = *(char **)(v5 + 8 * v6);
      uint64_t v9 = v7 + 88 * v6;
      int v11 = *(_DWORD *)(v9 + 64);
      uint64_t v10 = (uint64_t *)(v9 + 64);
      int v12 = 4 * *((_DWORD *)v10 + 1);
      uint64_t v13 = v11 * (uint64_t)v12;
      uint64_t v14 = v11 * v12 * (uint64_t)*((int *)v10 - 1);
      unint64_t v15 = (IOSurfaceRef *)(v10 - 2);
      unint64_t v310 = v6;
      if (*((_DWORD *)v10 + 5) == 3)
      {
        unint64_t v16 = *v15;
        IOSurfaceLock(*v15, 0, 0);
        unint64_t v17 = v6;
        BaseAddress = (float16x8_t *)IOSurfaceGetBaseAddress(v16);
        int v19 = operator new(0x20uLL);
        *int v19 = &unk_1F26F3990;
        v19[1] = v16;
        uint64_t v314 = v16;
        *((_DWORD *)v19 + 4) = 0;
        void v19[3] = 0;
        uint64_t v319 = v19;
        unint64_t v20 = *(void *)(v7 + 88 * v17 + 56);
        unint64_t v21 = HIDWORD(v20);
        unint64_t v22 = HIDWORD(*v10);
        if ((int)*v10 >= 1 && (int)v22 >= 1 && SHIDWORD(v20) >= 1 && (int)v20 >= 1)
        {
          size_t v26 = (int *)(v7 + 88 * v310);
          uint64_t v28 = v26[19];
          uint64_t v27 = v26[20];
          uint64_t v29 = v26[18];
          uint64_t v30 = v12;
          uint64_t v31 = *(void *)(v7 + 88 * v17 + 56);
          uint64_t v32 = *v10;
          unint64_t v33 = (unint64_t)*v10 >> 36;
          if (v33)
          {
            uint64_t v79 = v22 & 0xFFFFFFF0;
            uint64_t v80 = v22 - v79;
            if (v22 == v79)
            {
              uint64_t v81 = 0;
              uint64_t v82 = BaseAddress + 1;
              uint64_t v83 = (float32x4_t *)(v8 + 32);
              do
              {
                uint64_t v84 = 0;
                uint64_t v85 = v83;
                int v86 = v82;
                do
                {
                  uint64_t v87 = 0;
                  Float64 v88 = v85;
                  long long v89 = v86;
                  do
                  {
                    uint64_t v90 = v88;
                    unsigned int v91 = v89;
                    unint64_t v92 = v22;
                    do
                    {
                      float32x4_t v94 = v90[-2];
                      float32x4_t v93 = v90[-1];
                      float32x4_t v96 = *v90;
                      float32x4_t v95 = v90[1];
                      v90 += 4;
                      v91[-1] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v94), v93);
                      float16x8_t *v91 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v96), v95);
                      v91 += 2;
                      v92 -= 16;
                    }
                    while (v92);
                    ++v87;
                    long long v89 = (float16x8_t *)((char *)v89 + v27);
                    Float64 v88 = (float32x4_t *)((char *)v88 + v12);
                  }
                  while (v87 != v32);
                  ++v84;
                  int v86 = (float16x8_t *)((char *)v86 + v28);
                  uint64_t v85 = (float32x4_t *)((char *)v85 + v13);
                }
                while (v84 != v21);
                ++v81;
                uint64_t v82 = (float16x8_t *)((char *)v82 + v29);
                uint64_t v83 = (float32x4_t *)((char *)v83 + v14);
              }
              while (v81 != v31);
            }
            else
            {
              uint64_t v125 = 0;
              uint64_t v126 = BaseAddress + 1;
              int v127 = (float32x4_t *)(v8 + 32);
              i8 = BaseAddress[2 * v33].i8;
              long long v129 = &v8[64 * v33];
              do
              {
                uint64_t v130 = 0;
                long long v131 = (int *)v129;
                int v132 = i8;
                char v133 = v127;
                size_t v134 = v126;
                do
                {
                  uint64_t v135 = 0;
                  int v136 = v131;
                  uint64_t v137 = v132;
                  int v138 = v133;
                  unsigned __int8 v139 = v134;
                  do
                  {
                    int v140 = v138;
                    long long v141 = v139;
                    uint64_t v142 = v79;
                    do
                    {
                      float32x4_t v144 = v140[-2];
                      float32x4_t v143 = v140[-1];
                      float32x4_t v146 = *v140;
                      float32x4_t v145 = v140[1];
                      v140 += 4;
                      v141[-1] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v144), v143);
                      *long long v141 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v146), v145);
                      v141 += 2;
                      v142 -= 16;
                    }
                    while (v142);
                    long long v147 = v136;
                    int v148 = v137;
                    uint64_t v149 = v80;
                    do
                    {
                      int v150 = *v147++;
                      _S0 = v150;
                      __asm { FCVT            H0, S0 }
                      *v148++ = _S0;
                      --v149;
                    }
                    while (v149);
                    ++v135;
                    unsigned __int8 v139 = (float16x8_t *)((char *)v139 + v27);
                    int v138 = (float32x4_t *)((char *)v138 + v30);
                    uint64_t v137 = (_WORD *)((char *)v137 + v27);
                    int v136 = (int *)((char *)v136 + v30);
                  }
                  while (v135 != v32);
                  ++v130;
                  size_t v134 = (float16x8_t *)((char *)v134 + v28);
                  char v133 = (float32x4_t *)((char *)v133 + v13);
                  int v132 = (_WORD *)((char *)v132 + v28);
                  long long v131 = (int *)((char *)v131 + v13);
                }
                while (v130 != v21);
                ++v125;
                uint64_t v126 = (float16x8_t *)((char *)v126 + v29);
                int v127 = (float32x4_t *)((char *)v127 + v14);
                i8 += v29;
                v129 += v14;
              }
              while (v125 != v31);
            }
          }
          else
          {
            do
            {
              uint64_t v34 = 0;
              int v35 = v8;
              uint64_t v36 = BaseAddress;
              do
              {
                uint64_t v37 = 0;
                int v38 = (int *)v35;
                int v39 = v36;
                do
                {
                  uint64_t v40 = v38;
                  uint64_t v41 = v39;
                  unint64_t v42 = v22;
                  do
                  {
                    int v43 = *v40++;
                    _S0 = v43;
                    __asm { FCVT            H0, S0 }
                    v41->i16[0] = _S0;
                    uint64_t v41 = (float16x8_t *)((char *)v41 + 2);
                    --v42;
                  }
                  while (v42);
                  ++v37;
                  int v39 = (float16x8_t *)((char *)v39 + v27);
                  int v38 = (int *)((char *)v38 + v12);
                }
                while (v37 != v32);
                ++v34;
                uint64_t v36 = (float16x8_t *)((char *)v36 + v28);
                v35 += v13;
              }
              while (v34 != v21);
              ++v33;
              BaseAddress = (float16x8_t *)((char *)BaseAddress + v29);
              v8 += v14;
            }
            while (v33 != v31);
          }
        }
        IOSurfaceUnlock(v314, 0, 0);
        long long v97 = v319;
        uint64_t v4 = v301;
        int v98 = a2;
        unint64_t v99 = v310;
        if (v319 == v318)
        {
          (*(void (**)(void *))(v318[0] + 32))(v318);
          goto LABEL_5;
        }
        if (!v319) {
          goto LABEL_5;
        }
        goto LABEL_4;
      }
      uint64_t v48 = *v15;
      IOSurfaceLock(*v15, 0, 0);
      uint64_t v49 = (char *)IOSurfaceGetBaseAddress(v48);
      uint64_t v50 = operator new(0x20uLL);
      *uint64_t v50 = &unk_1F26F3A68;
      v50[1] = v48;
      buffer = v48;
      *((_DWORD *)v50 + 4) = 0;
      v50[3] = 0;
      uint64_t v319 = v50;
      uint64_t v51 = v7 + 88 * v6;
      unint64_t v52 = *(void *)(v51 + 56);
      unint64_t v53 = *v10;
      unint64_t v54 = HIDWORD(v52);
      unint64_t v55 = HIDWORD(*v10);
      if ((int)*v10 >= 1 && (int)v55 >= 1 && SHIDWORD(v52) >= 1 && (int)v52 >= 1)
      {
        uint64_t v59 = *(int *)(v51 + 72);
        uint64_t v60 = *(int *)(v51 + 76);
        uint64_t v61 = *(int *)(v51 + 80);
        if (v14 != v59 || v13 != v60 || v12 != v61)
        {
          uint64_t v64 = v12;
          uint64_t v65 = (int)v13;
          uint64_t v14 = (int)v14;
          uint64_t v66 = v52;
          uint64_t v67 = *v10;
          unint64_t v68 = v53 >> 35;
          if (!(v53 >> 35))
          {
            do
            {
              uint64_t v69 = 0;
              size_t v70 = v8;
              uint64_t v71 = v49;
              do
              {
                uint64_t v72 = 0;
                uint64_t v73 = (int *)v70;
                unint64_t v74 = v71;
                do
                {
                  size_t v75 = v73;
                  long long v76 = v74;
                  unint64_t v77 = v55;
                  do
                  {
                    int v78 = *v75++;
                    *v76++ = v78;
                    --v77;
                  }
                  while (v77);
                  ++v72;
                  unint64_t v74 = (_DWORD *)((char *)v74 + v61);
                  uint64_t v73 = (int *)((char *)v73 + v12);
                }
                while (v72 != v67);
                ++v69;
                v71 += v60;
                v70 += (int)v13;
              }
              while (v69 != v54);
              ++v68;
              v49 += v59;
              v8 += (int)v14;
            }
            while (v68 != v66);
            goto LABEL_63;
          }
          uint64_t v100 = 0;
          uint64_t v101 = (__IOSurface *)(v49 + 16);
          char v102 = v8 + 16;
          int v103 = v8;
          int v104 = v49;
          uint64_t v306 = v59;
          long long v308 = v49;
          uint64_t v302 = v66;
          uint64_t v304 = (int)v14;
          while (2)
          {
            uint64_t v105 = 0;
            int v106 = &v49[v100 * v59];
            int v107 = v103;
            long long v108 = v104;
            uint64_t v312 = v102;
            IOSurfaceRef v315 = v101;
            uint64_t v109 = &v8[v100 * v14];
LABEL_71:
            uint64_t v110 = 0;
            long long v111 = v107;
            uint64_t v112 = v108;
            long long v113 = (long long *)v102;
            int v114 = v101;
LABEL_73:
            if ((unint64_t)(&v106[v105 * v60 + v110 * v61] - &v109[v105 * v65 + v110 * v64]) < 0x20)
            {
              uint64_t v115 = 0;
              goto LABEL_78;
            }
            uint64_t v116 = v113;
            long long v117 = v114;
            uint64_t v118 = v55 & 0xFFFFFFF8;
            do
            {
              long long v119 = *v116;
              *((_OWORD *)v117 - 1) = *(v116 - 1);
              *(_OWORD *)long long v117 = v119;
              long long v117 = (__IOSurface *)((char *)v117 + 32);
              v116 += 2;
              v118 -= 8;
            }
            while (v118);
            uint64_t v115 = v55 & 0xFFFFFFF8;
            if (v55 != v115)
            {
LABEL_78:
              uint64_t v120 = v55 - v115;
              uint64_t v121 = 4 * v115;
              uint64_t v122 = &v112[4 * v115];
              uint64_t v123 = (int *)&v111[v121];
              do
              {
                int v124 = *v123++;
                *(_DWORD *)uint64_t v122 = v124;
                v122 += 4;
                --v120;
              }
              while (v120);
            }
            ++v110;
            int v114 = (__IOSurface *)((char *)v114 + v61);
            long long v113 = (long long *)((char *)v113 + v64);
            v112 += v61;
            v111 += v64;
            if (v110 == v67)
            {
              ++v105;
              uint64_t v101 = (__IOSurface *)((char *)v101 + v60);
              v102 += v65;
              v108 += v60;
              v107 += v65;
              if (v105 == v54)
              {
                ++v100;
                uint64_t v14 = v304;
                uint64_t v59 = v306;
                uint64_t v101 = (IOSurfaceRef)((char *)v315 + v306);
                char v102 = &v312[v304];
                v104 += v306;
                v103 += v304;
                uint64_t v49 = v308;
                if (v100 == v302) {
                  goto LABEL_63;
                }
                continue;
              }
              goto LABEL_71;
            }
            goto LABEL_73;
          }
        }
        memcpy(v49, v8, (int)v14 * (int)v52);
      }
LABEL_63:
      IOSurfaceUnlock(buffer, 0, 0);
      long long v97 = v319;
      int v98 = a2;
      if (v319 == v318)
      {
        (*(void (**)(void *))(v318[0] + 32))(v318);
        uint64_t v4 = v301;
        unint64_t v99 = v310;
        goto LABEL_5;
      }
      uint64_t v4 = v301;
      unint64_t v99 = v310;
      if (!v319) {
        goto LABEL_5;
      }
LABEL_4:
      (*(void (**)(void *))(*v97 + 40))(v97);
LABEL_5:
      unint64_t v6 = v99 + 1;
      uint64_t v5 = *v98;
    }
    while (v6 < (v98[1] - *v98) >> 3);
  }
  if (e5rt_execution_stream_execute_sync()) {
    return 0;
  }
  long long v153 = a3;
  uint64_t v154 = *a3;
  uint64_t result = 1;
  if (a3[1] != *a3)
  {
    unint64_t v155 = 0;
    while (1)
    {
      long long v156 = *(char **)(v154 + 8 * v155);
      uint64_t v157 = *(void *)(v4 + 40);
      uint64_t v158 = v157 + 88 * v155;
      int v160 = *(_DWORD *)(v158 + 64);
      long long v159 = (uint64_t *)(v158 + 64);
      int v161 = 4 * *((_DWORD *)v159 + 1);
      uint64_t v162 = v160 * (uint64_t)v161;
      uint64_t v163 = (int)v162 * (uint64_t)*((int *)v159 - 1);
      int v164 = *((_DWORD *)v159 + 5);
      if (v164 != 6)
      {
        if (v164 != 3) {
          goto LABEL_102;
        }
        unint64_t v311 = v155;
        uint64_t v165 = v157 + 88 * v155;
        long long v166 = *(__IOSurface **)(v165 + 48);
        IOSurfaceLock(v166, 1u, 0);
        unint64_t v167 = (float16x4_t *)IOSurfaceGetBaseAddress(v166);
        long long v168 = operator new(0x20uLL);
        *long long v168 = &unk_1F26F39D8;
        v168[1] = v166;
        unint64_t v316 = v166;
        *((_DWORD *)v168 + 4) = 1;
        v168[3] = 0;
        uint64_t v319 = v168;
        unint64_t v169 = *(void *)(v165 + 56);
        unint64_t v170 = HIDWORD(v169);
        unint64_t v171 = HIDWORD(*v159);
        if ((int)*v159 >= 1 && (int)v171 >= 1 && SHIDWORD(v169) >= 1 && (int)v169 >= 1)
        {
          long long v175 = (int *)(v157 + 88 * v311);
          uint64_t v177 = v175[19];
          uint64_t v176 = v175[20];
          uint64_t v178 = v175[18];
          uint64_t v179 = v161;
          uint64_t v180 = *(void *)(v165 + 56);
          uint64_t v181 = *v159;
          unint64_t v182 = (unint64_t)*v159 >> 36;
          if (v182)
          {
            uint64_t v227 = v171 & 0xFFFFFFF0;
            uint64_t v228 = v171 - v227;
            if (v171 == v227)
            {
              uint64_t v229 = 0;
              uint64_t v230 = (float32x4_t *)(v156 + 32);
              __int16 v231 = v167 + 2;
              do
              {
                uint64_t v232 = 0;
                uint64_t v233 = v231;
                long long v234 = v230;
                do
                {
                  uint64_t v235 = 0;
                  uint64_t v236 = v233;
                  uint64_t v237 = v234;
                  do
                  {
                    unint64_t v238 = v236;
                    uint64_t v239 = v237;
                    unint64_t v240 = v171;
                    do
                    {
                      float16x8_t v241 = *(float16x8_t *)v238[-2].i8;
                      float32x4_t v242 = vcvtq_f32_f16(*v238);
                      float32x4_t v243 = vcvt_hight_f32_f16(*(float16x8_t *)v238->i8);
                      v239[-2] = vcvtq_f32_f16(*(float16x4_t *)v241.i8);
                      v239[-1] = vcvt_hight_f32_f16(v241);
                      float32x4_t *v239 = v242;
                      v239[1] = v243;
                      v239 += 4;
                      v238 += 4;
                      v240 -= 16;
                    }
                    while (v240);
                    ++v235;
                    uint64_t v237 = (float32x4_t *)((char *)v237 + v161);
                    uint64_t v236 = (float16x4_t *)((char *)v236 + v176);
                  }
                  while (v235 != v181);
                  ++v232;
                  long long v234 = (float32x4_t *)((char *)v234 + v162);
                  uint64_t v233 = (float16x4_t *)((char *)v233 + v177);
                }
                while (v232 != v170);
                ++v229;
                uint64_t v230 = (float32x4_t *)((char *)v230 + v163);
                __int16 v231 = (float16x4_t *)((char *)v231 + v178);
              }
              while (v229 != v180);
            }
            else
            {
              uint64_t v270 = 0;
              uint64_t v271 = (float32x4_t *)(v156 + 32);
              unint64_t v272 = v167 + 2;
              uint64_t v273 = &v156[64 * v182];
              unint64_t v274 = (char *)&v167[4 * v182];
              do
              {
                uint64_t v275 = 0;
                float v276 = (__int16 *)v274;
                float v277 = v273;
                BOOL v278 = v272;
                unint64_t v279 = v271;
                do
                {
                  uint64_t v280 = 0;
                  int64_t v281 = v276;
                  uint64_t v282 = v277;
                  int v283 = v278;
                  uint64_t v284 = v279;
                  do
                  {
                    uint64_t v285 = v283;
                    size_t v286 = v284;
                    uint64_t v287 = v227;
                    do
                    {
                      float16x8_t v288 = *(float16x8_t *)v285[-2].i8;
                      float32x4_t v289 = vcvtq_f32_f16(*v285);
                      float32x4_t v290 = vcvt_hight_f32_f16(*(float16x8_t *)v285->i8);
                      v286[-2] = vcvtq_f32_f16(*(float16x4_t *)v288.i8);
                      v286[-1] = vcvt_hight_f32_f16(v288);
                      *size_t v286 = v289;
                      v286[1] = v290;
                      v286 += 4;
                      v285 += 4;
                      v287 -= 16;
                    }
                    while (v287);
                    uint64_t v291 = v281;
                    unint64_t v292 = v282;
                    uint64_t v293 = v228;
                    do
                    {
                      __int16 v294 = *v291++;
                      _H0 = v294;
                      __asm { FCVT            S0, H0 }
                      *v292++ = _S0;
                      --v293;
                    }
                    while (v293);
                    ++v280;
                    uint64_t v284 = (float32x4_t *)((char *)v284 + v179);
                    int v283 = (float16x4_t *)((char *)v283 + v176);
                    uint64_t v282 = (_DWORD *)((char *)v282 + v179);
                    int64_t v281 = (__int16 *)((char *)v281 + v176);
                  }
                  while (v280 != v181);
                  ++v275;
                  unint64_t v279 = (float32x4_t *)((char *)v279 + v162);
                  BOOL v278 = (float16x4_t *)((char *)v278 + v177);
                  float v277 = (_DWORD *)((char *)v277 + v162);
                  float v276 = (__int16 *)((char *)v276 + v177);
                }
                while (v275 != v170);
                ++v270;
                uint64_t v271 = (float32x4_t *)((char *)v271 + v163);
                unint64_t v272 = (float16x4_t *)((char *)v272 + v178);
                v273 += v163;
                v274 += v178;
              }
              while (v270 != v180);
            }
          }
          else
          {
            do
            {
              uint64_t v183 = 0;
              unint64_t v184 = v167;
              long long v185 = v156;
              do
              {
                uint64_t v186 = 0;
                int v187 = (__int16 *)v184;
                unint64_t v188 = v185;
                do
                {
                  uint64_t v189 = v187;
                  long long v190 = v188;
                  unint64_t v191 = v171;
                  do
                  {
                    __int16 v192 = *v189++;
                    _H0 = v192;
                    __asm { FCVT            S0, H0 }
                    *v190++ = _S0;
                    --v191;
                  }
                  while (v191);
                  ++v186;
                  unint64_t v188 = (_DWORD *)((char *)v188 + v161);
                  int v187 = (__int16 *)((char *)v187 + v176);
                }
                while (v186 != v181);
                ++v183;
                v185 += v162;
                unint64_t v184 = (float16x4_t *)((char *)v184 + v177);
              }
              while (v183 != v170);
              ++v182;
              v156 += v163;
              unint64_t v167 = (float16x4_t *)((char *)v167 + v178);
            }
            while (v182 != v180);
          }
        }
        IOSurfaceUnlock(v316, 1u, 0);
        long long v244 = v319;
        uint64_t v4 = v301;
        if (v319 == v318)
        {
          (*(void (**)(void *))(v318[0] + 32))(v318);
          goto LABEL_101;
        }
        if (!v319) {
          goto LABEL_101;
        }
        goto LABEL_100;
      }
      unint64_t v311 = v155;
      uint64_t v195 = v157 + 88 * v155;
      long long v196 = *(__IOSurface **)(v195 + 48);
      IOSurfaceLock(v196, 1u, 0);
      long long v197 = (char *)IOSurfaceGetBaseAddress(v196);
      uint8x8_t v198 = operator new(0x20uLL);
      *uint8x8_t v198 = &unk_1F26F3A20;
      v198[1] = v196;
      unint64_t v300 = v196;
      *((_DWORD *)v198 + 4) = 1;
      v198[3] = 0;
      uint64_t v319 = v198;
      unint64_t v199 = *(void *)(v195 + 56);
      unint64_t v200 = *v159;
      unint64_t v201 = HIDWORD(v199);
      unint64_t v202 = HIDWORD(*v159);
      if ((int)*v159 >= 1 && (int)v202 >= 1 && SHIDWORD(v199) >= 1 && (int)v199 >= 1)
      {
        uint64_t v207 = *(int *)(v195 + 72);
        uint64_t v206 = *(int *)(v195 + 76);
        uint64_t v208 = *(int *)(v195 + 80);
        if (v207 != v163 || v206 != v162 || v208 != v161)
        {
          uint64_t v211 = v161;
          uint64_t v212 = (int)v162;
          uint64_t v213 = (int)v163;
          uint64_t v214 = *(void *)(v195 + 56);
          uint64_t v215 = v200;
          unint64_t v216 = v200 >> 35;
          if (!(v200 >> 35))
          {
            do
            {
              uint64_t v217 = 0;
              long long v218 = v197;
              size_t v219 = v156;
              do
              {
                uint64_t v220 = 0;
                uint64_t v221 = (int *)v218;
                double v222 = v219;
                do
                {
                  __int16 v223 = v221;
                  double v224 = v222;
                  unint64_t v225 = v202;
                  do
                  {
                    int v226 = *v223++;
                    *v224++ = v226;
                    --v225;
                  }
                  while (v225);
                  ++v220;
                  double v222 = (_DWORD *)((char *)v222 + v161);
                  uint64_t v221 = (int *)((char *)v221 + v208);
                }
                while (v220 != v215);
                ++v217;
                v219 += v212;
                v218 += v206;
              }
              while (v217 != v201);
              ++v216;
              v156 += (int)v163;
              v197 += v207;
            }
            while (v216 != v214);
            goto LABEL_161;
          }
          uint64_t v245 = 0;
          long long v246 = (__IOSurface *)(v156 + 16);
          long long v247 = v197 + 16;
          uint64_t v248 = v197;
          uint64_t v249 = v156;
          uint64_t v307 = *(int *)(v195 + 72);
          uint64_t v309 = v197;
          uint64_t v303 = *(void *)(v195 + 56);
          uint64_t v305 = (int)v163;
          while (2)
          {
            uint64_t v250 = 0;
            long long v251 = &v156[v245 * v213];
            uint64_t v252 = v248;
            uint64_t v253 = v249;
            uint64_t v313 = v247;
            IOSurfaceRef v317 = v246;
            uint64_t v254 = &v197[v245 * v207];
LABEL_169:
            uint64_t v255 = 0;
            uint64_t v256 = v252;
            uint64_t v257 = v253;
            uint64_t v258 = (long long *)v247;
            uint64_t v259 = v246;
LABEL_171:
            if ((unint64_t)(&v251[v250 * v212 + v255 * v211] - &v254[v250 * v206 + v255 * v208]) < 0x20)
            {
              uint64_t v260 = 0;
              goto LABEL_176;
            }
            unint64_t v261 = v258;
            uint8x8_t v262 = v259;
            uint64_t v263 = v202 & 0xFFFFFFF8;
            do
            {
              long long v264 = *v261;
              *((_OWORD *)v262 - 1) = *(v261 - 1);
              *(_OWORD *)uint8x8_t v262 = v264;
              uint8x8_t v262 = (__IOSurface *)((char *)v262 + 32);
              v261 += 2;
              v263 -= 8;
            }
            while (v263);
            uint64_t v260 = v202 & 0xFFFFFFF8;
            if (v202 != v260)
            {
LABEL_176:
              uint64_t v265 = v202 - v260;
              uint64_t v266 = 4 * v260;
              uint64_t v267 = &v257[4 * v260];
              uint64_t v268 = (int *)&v256[v266];
              do
              {
                int v269 = *v268++;
                *(_DWORD *)uint64_t v267 = v269;
                v267 += 4;
                --v265;
              }
              while (v265);
            }
            ++v255;
            uint64_t v259 = (__IOSurface *)((char *)v259 + v211);
            uint64_t v258 = (long long *)((char *)v258 + v208);
            v257 += v211;
            v256 += v208;
            if (v255 == v200)
            {
              ++v250;
              long long v246 = (__IOSurface *)((char *)v246 + v212);
              v247 += v206;
              v253 += v212;
              v252 += v206;
              if (v250 == v201)
              {
                ++v245;
                uint64_t v213 = v305;
                uint64_t v207 = v307;
                long long v246 = (IOSurfaceRef)((char *)v317 + v305);
                long long v247 = &v313[v307];
                v249 += v305;
                v248 += v307;
                long long v197 = v309;
                if (v245 == v303) {
                  goto LABEL_161;
                }
                continue;
              }
              goto LABEL_169;
            }
            goto LABEL_171;
          }
        }
        memcpy(v156, v197, (int)v163 * (int)v199);
      }
LABEL_161:
      IOSurfaceUnlock(v300, 1u, 0);
      long long v244 = v319;
      if (v319 == v318)
      {
        (*(void (**)(void *))(v318[0] + 32))(v318);
        uint64_t v4 = v301;
        goto LABEL_101;
      }
      uint64_t v4 = v301;
      if (!v319) {
        goto LABEL_101;
      }
LABEL_100:
      (*(void (**)(void *))(*v244 + 40))(v244);
LABEL_101:
      long long v153 = a3;
      unint64_t v155 = v311;
LABEL_102:
      ++v155;
      uint64_t v154 = *v153;
      if (v155 >= (v153[1] - *v153) >> 3) {
        return 1;
      }
    }
  }
  return result;
}

void sub_1D0E58B54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a25 == a12)
  {
    (*(void (**)(void))(a22 + 32))();
    _Unwind_Resume(exception_object);
  }
  if (a25) {
    (*(void (**)(void))(*(void *)a25 + 40))();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D0E58BD4(uint64_t a1)
{
  return IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 8), *(_DWORD *)(a1 + 16), *(uint32_t **)(a1 + 24));
}

__n128 sub_1D0E58BF0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F26F3A20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1D0E58C20(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F26F3A20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_1D0E58C74()
{
}

uint64_t sub_1D0E58C8C(uint64_t a1)
{
  return IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 8), *(_DWORD *)(a1 + 16), *(uint32_t **)(a1 + 24));
}

__n128 sub_1D0E58CA8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F26F39D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1D0E58CD8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F26F39D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_1D0E58D2C()
{
}

uint64_t sub_1D0E58D44(uint64_t a1)
{
  return IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 8), *(_DWORD *)(a1 + 16), *(uint32_t **)(a1 + 24));
}

__n128 sub_1D0E58D60(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F26F3A68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1D0E58D90(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F26F3A68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_1D0E58DE4()
{
}

uint64_t sub_1D0E58DFC(uint64_t a1)
{
  return IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 8), *(_DWORD *)(a1 + 16), *(uint32_t **)(a1 + 24));
}

__n128 sub_1D0E58E18(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F26F3990;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1D0E58E48(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F26F3990;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_1D0E58E9C()
{
}

void sub_1D0E58EB4(void *a1)
{
  *a1 = &unk_1F26F40C0;
  uint64_t v2 = (uint64_t *)a1[7];
  a1[7] = 0;
  if (v2)
  {
    uint64_t v3 = sub_1D0E58F3C(v2);
    MEMORY[0x1D25F16B0](v3, 0x20C400FA965B2);
  }
  sub_1D0E57CEC(a1);
  JUMPOUT(0x1D25F16B0);
}

uint64_t *sub_1D0E58F3C(uint64_t *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    uint64_t v3 = a1[6];
    uint64_t v4 = v2;
    if ((void *)v3 != v2)
    {
      do
        uint64_t v3 = sub_1D0E590F0(v3 - 88);
      while ((void *)v3 != v2);
      uint64_t v4 = (void *)a1[5];
    }
    a1[6] = (uint64_t)v2;
    operator delete(v4);
  }
  uint64_t v5 = a1[2];
  if (v5)
  {
    uint64_t v6 = a1[3];
    uint64_t v7 = (void *)a1[2];
    if (v6 != v5)
    {
      do
        uint64_t v6 = sub_1D0E590F0(v6 - 88);
      while (v6 != v5);
      uint64_t v7 = (void *)a1[2];
    }
    a1[3] = v5;
    operator delete(v7);
  }
  uint64_t v8 = a1[1];
  a1[1] = 0;
  if (v8)
  {
    int v9 = e5rt_execution_stream_operation_release();
    if (v9)
    {
      int v14 = v9;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v16 = v14;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  uint64_t v10 = *a1;
  *a1 = 0;
  if (v10)
  {
    int v11 = e5rt_execution_stream_reset();
    int v12 = e5rt_execution_stream_release();
    if (!v11) {
      int v11 = v12;
    }
    if (v11 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 67109120;
      int v16 = v11;
      _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
    }
  }
  return a1;
}

uint64_t sub_1D0E590F0(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v2)
  {
    int v3 = e5rt_buffer_object_release();
    if (v3)
    {
      int v9 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v13 = v9;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  uint64_t v4 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v4)
  {
    int v5 = e5rt_tensor_desc_release();
    if (v5)
    {
      int v10 = v5;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v13 = v10;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  uint64_t v6 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v6)
  {
    int v7 = e5rt_io_port_release();
    if (v7)
    {
      int v11 = v7;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v13 = v11;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_1D0E592A8(void *a1)
{
  *a1 = &unk_1F26F40C0;
  uint64_t v2 = (uint64_t *)a1[7];
  a1[7] = 0;
  if (v2)
  {
    int v3 = sub_1D0E58F3C(v2);
    MEMORY[0x1D25F16B0](v3, 0x20C400FA965B2);
  }
  return sub_1D0E57CEC(a1);
}

BOOL sub_1D0E5931C(uint64_t *a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  int v1 = e5rt_tensor_desc_alloc_buffer_object();
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    int v3 = e5rt_buffer_object_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v8 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return !v1 && e5rt_buffer_object_get_iosurface() == 0;
}

void sub_1D0E59430(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1D0DEB320((uint64_t **)va);
  _Unwind_Resume(a1);
}

BOOL sub_1D0E59444(uint64_t a1, uint64_t *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a2;
  if (!*a2) {
    return 0;
  }
  *a2 = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = v2;
  if (v4)
  {
    *(void *)uint64_t v30 = v4;
    int v5 = e5rt_execution_stream_operation_release();
    if (v5)
    {
      int v15 = v5;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v15;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  uint64_t v6 = 0;
  uint64_t v29 = 0;
  if (MEMORY[0x1E4F61348])
  {
    uint64_t v6 = v28;
    v28[0] = &unk_1F26F4868;
    v28[1] = MEMORY[0x1F4196A80];
    uint64_t v29 = v28;
  }
  uint64_t v27 = 0;
  if (MEMORY[0x1E4F61340])
  {
    v26[0] = &unk_1F26F48B0;
    v26[1] = MEMORY[0x1F4196A78];
    uint64_t v27 = v26;
  }
  int v25 = 0;
  if (MEMORY[0x1E4F61380])
  {
    v24[0] = &unk_1F26F4820;
    v24[1] = MEMORY[0x1F4196A98];
    int v25 = v24;
  }
  char v7 = sub_1D0E59B08(a1, (uint64_t)v6, (uint64_t)v26, (uint64_t)v24, a1 + 16);
  if (v25 == v24)
  {
    (*(void (**)(void *))(v24[0] + 32))(v24);
  }
  else if (v25)
  {
    (*(void (**)(void))(*v25 + 40))();
  }
  if (v27 == v26)
  {
    (*(void (**)(void *))(v26[0] + 32))(v26);
  }
  else if (v27)
  {
    (*(void (**)(void *))(*v27 + 40))(v27);
  }
  if (v29 == v28)
  {
    (*(void (**)(void *))(v28[0] + 32))(v28);
    if ((v7 & 1) == 0) {
      return 0;
    }
  }
  else
  {
    if (v29) {
      (*(void (**)(void *))(*v29 + 40))(v29);
    }
    if ((v7 & 1) == 0) {
      return 0;
    }
  }
  int v8 = 0;
  size_t v23 = 0;
  if (MEMORY[0x1E4F61358])
  {
    int v8 = v22;
    v22[0] = &unk_1F26F4868;
    v22[1] = MEMORY[0x1F4196A88];
    size_t v23 = v22;
  }
  unint64_t v21 = 0;
  if (MEMORY[0x1E4F61368])
  {
    v20[0] = &unk_1F26F48B0;
    v20[1] = MEMORY[0x1F4196A90];
    unint64_t v21 = v20;
  }
  int v19 = 0;
  if (MEMORY[0x1E4F61398])
  {
    v18[0] = &unk_1F26F4820;
    v18[1] = MEMORY[0x1F4196AA0];
    int v19 = v18;
  }
  char v9 = sub_1D0E59B08(a1, (uint64_t)v8, (uint64_t)v20, (uint64_t)v18, a1 + 40);
  if (v19 == v18)
  {
    (*(void (**)(void *))(v18[0] + 32))(v18);
  }
  else if (v19)
  {
    (*(void (**)(void))(*v19 + 40))();
  }
  if (v21 == v20)
  {
    (*(void (**)(void *))(v20[0] + 32))(v20);
  }
  else if (v21)
  {
    (*(void (**)(void))(*v21 + 40))();
  }
  if (v23 == v22)
  {
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if ((v9 & 1) == 0) {
      return 0;
    }
  }
  else
  {
    if (v23) {
      (*(void (**)(void))(*v23 + 40))();
    }
    if ((v9 & 1) == 0) {
      return 0;
    }
  }
  if (!e5rt_execution_stream_operation_prepare_op_for_encode())
  {
    *(void *)int buf = a1;
    uint64_t v17 = 0;
    int v10 = e5rt_execution_stream_create();
    uint64_t v11 = **(void **)buf;
    **(void **)int buf = v17;
    if (v11)
    {
      int v12 = e5rt_execution_stream_reset();
      int v13 = e5rt_execution_stream_release();
      if (!v12) {
        int v12 = v13;
      }
      if (v12)
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t v30 = 67109120;
          *(_DWORD *)&void v30[4] = v12;
          _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", v30, 8u);
        }
      }
    }
    if (!v10) {
      return e5rt_execution_stream_encode_operation() == 0;
    }
  }
  return 0;
}

void sub_1D0E599E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1D0E5A7C8((uint64_t **)va);
  _Unwind_Resume(a1);
}

void sub_1D0E59A00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  sub_1D0E5A63C((uint64_t *)va);
  sub_1D0E5A6C0((uint64_t *)va1);
  sub_1D0E5A744(va2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1D0E59A40(uint64_t *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    int v3 = e5rt_execution_stream_operation_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t sub_1D0E59B08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  unint64_t v41 = 0;
  *(void *)uint64_t v44 = *(void *)(a1 + 8);
  *(void *)int buf = &v41;
  if (!a2) {
    goto LABEL_38;
  }
  if ((*(unsigned int (**)(uint64_t, uint8_t *, uint8_t *))(*(void *)a2 + 48))(a2, v44, buf)) {
    return 0;
  }
  unint64_t v10 = v41;
  if (v41)
  {
    if (v41 >> 61) {
      abort();
    }
    uint64_t v11 = 8 * v41;
    int v12 = (char *)operator new(8 * v41);
    bzero(v12, 8 * v10);
    uint64_t v13 = &v12[v11];
  }
  else
  {
    uint64_t v13 = 0;
    int v12 = 0;
  }
  uint64_t v14 = *(void *)(a1 + 8);
  int v43 = v12;
  *(void *)uint64_t v44 = v14;
  *(void *)int buf = v10;
  uint64_t v15 = *(void *)(a3 + 24);
  std::string __p = v12;
  if (!v15)
  {
LABEL_38:
    uint64_t result = sub_1D0DD8808();
    goto LABEL_42;
  }
  if ((*(unsigned int (**)(uint64_t, uint8_t *, uint8_t *, char **))(*(void *)v15 + 48))(v15, v44, buf, &v43))
  {
    uint64_t v9 = 0;
    goto LABEL_11;
  }
  unint64_t v17 = (v13 - v12) >> 3;
  int v18 = *(unsigned char **)a5;
  if (0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a5 + 16) - *(void *)a5) >> 3) < v17)
  {
    if ((unint64_t)(v13 - v12) >= 0x1745D1745D1745D1) {
      abort();
    }
    int v19 = *(unsigned char **)(a5 + 8);
    unint64_t v20 = (char *)operator new(88 * v17);
    unint64_t v21 = &v20[88 * v17];
    unint64_t v22 = &v20[v19 - v18];
    if (v19 == v18)
    {
      *(void *)a5 = v22;
      *(void *)(a5 + 8) = v22;
      *(void *)(a5 + 16) = v21;
      if (!v18) {
        goto LABEL_23;
      }
    }
    else
    {
      size_t v23 = &v20[v19 - v18];
      do
      {
        long long v24 = *(_OWORD *)(v19 - 88);
        *((void *)v23 - 9) = *((void *)v19 - 9);
        *(_OWORD *)(v23 - 88) = v24;
        *((void *)v19 - 11) = 0;
        *((void *)v19 - 10) = 0;
        uint64_t v25 = *((void *)v19 - 8);
        *((void *)v19 - 9) = 0;
        *((void *)v19 - 8) = 0;
        *((void *)v23 - 8) = v25;
        uint64_t v26 = *((void *)v19 - 7);
        *((void *)v19 - 7) = 0;
        *((void *)v23 - 7) = v26;
        long long v27 = *((_OWORD *)v19 - 3);
        *((void *)v19 - 6) = 0;
        *((_OWORD *)v23 - 3) = v27;
        long long v28 = *((_OWORD *)v19 - 1);
        *((_OWORD *)v23 - 2) = *((_OWORD *)v19 - 2);
        *((_OWORD *)v23 - 1) = v28;
        v23 -= 88;
        v19 -= 88;
      }
      while (v19 != v18);
      int v18 = *(unsigned char **)a5;
      uint64_t v29 = *(void *)(a5 + 8);
      *(void *)a5 = v23;
      *(void *)(a5 + 8) = v22;
      for (*(void *)(a5 + 16) = v21; (unsigned char *)v29 != v18; uint64_t v29 = sub_1D0E590F0(v29 - 88))
        ;
      if (!v18) {
        goto LABEL_23;
      }
    }
    operator delete(v18);
  }
LABEL_23:
  if (v12 == v13)
  {
    uint64_t v9 = 1;
LABEL_11:
    if (__p) {
      operator delete(__p);
    }
    return v9;
  }
  uint64_t v30 = *(char **)v12;
  uint64_t v40 = 0;
  uint64_t v31 = *(void *)(a1 + 8);
  *(void *)uint64_t v44 = &v40;
  uint64_t v45 = 0;
  *(void *)int buf = v31;
  unint64_t v42 = &v45;
  int v43 = v30;
  uint64_t v32 = *(void *)(a4 + 24);
  if (v32)
  {
    (*(void (**)(uint64_t, uint8_t *, char **, uint64_t **))(*(void *)v32 + 48))(v32, buf, &v43, &v42);
    unint64_t v33 = **(char ***)v44;
    **(void **)uint64_t v44 = v45;
    if (v33)
    {
      int v43 = v33;
      int v34 = e5rt_io_port_release();
      if (v34)
      {
        int v37 = v34;
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v37;
          _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
        }
      }
    }
    uint64_t v35 = v40;
    uint64_t v40 = 0;
    if (v35)
    {
      *(void *)int buf = v35;
      int v36 = e5rt_io_port_release();
      if (v36)
      {
        int v38 = v36;
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t v44 = 67109120;
          *(_DWORD *)&v44[4] = v38;
          _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", v44, 8u);
        }
      }
    }
    uint64_t v9 = 0;
    goto LABEL_11;
  }
  uint64_t result = sub_1D0DD8808();
LABEL_42:
  __break(1u);
  return result;
}

void sub_1D0E5A58C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (!__p) {
    _Unwind_Resume(a1);
  }
  operator delete(__p);
  _Unwind_Resume(a1);
}

void *sub_1D0E5A63C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1D0E5A6C0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1D0E5A744(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t **sub_1D0E5A7C8(uint64_t **a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  int v3 = a1[1];
  uint64_t v4 = **a1;
  uint64_t *v2 = (uint64_t)v3;
  if (v4)
  {
    int v5 = e5rt_execution_stream_reset();
    int v6 = e5rt_execution_stream_release();
    if (!v5) {
      int v5 = v6;
    }
    if (v5 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 67109120;
      int v9 = v5;
      _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
    }
  }
  return a1;
}

uint64_t sub_1D0E5A8A0(uint64_t a1, void *a2, void *a3, void *a4)
{
  return (*(uint64_t (**)(void, void, void))(a1 + 8))(*a2, *a3, *a4);
}

uint64_t sub_1D0E5A8BC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F26F4820;
  a2[1] = v2;
  return result;
}

void *sub_1D0E5A8E0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F26F4820;
  result[1] = v3;
  return result;
}

void sub_1D0E5A928()
{
}

uint64_t sub_1D0E5A940(uint64_t a1, void *a2, void *a3, void *a4)
{
  return (*(uint64_t (**)(void, void, void))(a1 + 8))(*a2, *a3, *a4);
}

uint64_t sub_1D0E5A95C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F26F48B0;
  a2[1] = v2;
  return result;
}

void *sub_1D0E5A980(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F26F48B0;
  result[1] = v3;
  return result;
}

void sub_1D0E5A9C8()
{
}

uint64_t sub_1D0E5A9E0(uint64_t a1, void *a2, void *a3)
{
  return (*(uint64_t (**)(void, void))(a1 + 8))(*a2, *a3);
}

uint64_t sub_1D0E5A9F8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F26F4868;
  a2[1] = v2;
  return result;
}

void *sub_1D0E5AA1C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F26F4868;
  result[1] = v3;
  return result;
}

void sub_1D0E5AA64()
{
}

void sub_1D0E5AA7C(void ***a1, void ***a2)
{
  uint64_t v4 = *a2;
  int v5 = a2[1];
  if (v5 != *a2)
  {
    do
    {
      if (*((char *)v5 - 17) < 0) {
        operator delete(*(v5 - 5));
      }
      v5 -= 5;
    }
    while (v5 != v4);
    int v5 = *a2;
  }
  a2[1] = v4;
  unint64_t v6 = 0x2E8BA2E8BA2E8BA3 * (a1[1] - *a1);
  if (0xCCCCCCCCCCCCCCCDLL * (a2[2] - v5) < v6)
  {
    if (v6 > 0x666666666666666) {
      abort();
    }
    size_t v7 = 0x45D1745D1745D178 * (a1[1] - *a1);
    uint64_t v8 = (char *)operator new(v7);
    int v9 = &v8[v7];
    uint64_t v10 = &v8[(char *)v4 - (char *)v5];
    if (v4 == v5)
    {
      *a2 = (void **)v10;
      a2[1] = (void **)v10;
      a2[2] = (void **)v9;
    }
    else
    {
      uint64_t v11 = &v8[(char *)v4 - (char *)v5];
      do
      {
        long long v12 = *(_OWORD *)(v4 - 5);
        *((void *)v11 - 3) = *(v4 - 3);
        *(_OWORD *)(v11 - 40) = v12;
        *(v4 - 4) = 0;
        *(v4 - 3) = 0;
        *(v4 - 5) = 0;
        *((_OWORD *)v11 - 1) = *((_OWORD *)v4 - 1);
        v11 -= 40;
        v4 -= 5;
      }
      while (v4 != v5);
      uint64_t v4 = *a2;
      uint64_t v13 = a2[1];
      *a2 = (void **)v11;
      a2[1] = (void **)v10;
      a2[2] = (void **)v9;
      while (v13 != v4)
      {
        if (*((char *)v13 - 17) < 0) {
          operator delete(*(v13 - 5));
        }
        v13 -= 5;
      }
    }
    if (v4) {
      operator delete(v4);
    }
  }
  uint64_t v14 = *a1;
  uint64_t v15 = (long long *)a1[1];
  if (*a1 != (void **)v15)
  {
    do
    {
      HIBYTE(v33) = 5;
      strcpy((char *)__p, "dummy");
      *(void *)&long long v34 = -1;
      *((void *)&v34 + 1) = -1;
      if (__p != v14)
      {
        if (*((char *)v14 + 23) < 0)
        {
          sub_1D0DF922C(__p, *v14, (size_t)v14[1]);
        }
        else
        {
          long long v17 = *(_OWORD *)v14;
          unint64_t v33 = v14[2];
          *(_OWORD *)std::string __p = v17;
        }
      }
      long long v34 = *(_OWORD *)(v14 + 7);
      int v19 = a2[1];
      unint64_t v18 = (unint64_t)a2[2];
      if ((unint64_t)v19 < v18)
      {
        long long v16 = *(_OWORD *)__p;
        v19[2] = v33;
        *(_OWORD *)int v19 = v16;
        __p[1] = 0;
        unint64_t v33 = 0;
        __p[0] = 0;
        *(_OWORD *)(v19 + 3) = v34;
        a2[1] = v19 + 5;
      }
      else
      {
        unint64_t v20 = *a2;
        unint64_t v21 = 0xCCCCCCCCCCCCCCCDLL * (v19 - *a2);
        unint64_t v22 = v21 + 1;
        if (v21 + 1 > 0x666666666666666) {
          abort();
        }
        unint64_t v23 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v18 - (void)v20) >> 3);
        if (2 * v23 > v22) {
          unint64_t v22 = 2 * v23;
        }
        if (v23 >= 0x333333333333333) {
          unint64_t v24 = 0x666666666666666;
        }
        else {
          unint64_t v24 = v22;
        }
        if (v24)
        {
          if (v24 > 0x666666666666666) {
            sub_1D0DE8CE0();
          }
          uint64_t v25 = (char *)operator new(40 * v24);
        }
        else
        {
          uint64_t v25 = 0;
        }
        uint64_t v26 = &v25[40 * v21];
        long long v27 = &v25[40 * v24];
        *(_OWORD *)uint64_t v26 = *(_OWORD *)__p;
        *((void *)v26 + 2) = v33;
        __p[1] = 0;
        unint64_t v33 = 0;
        __p[0] = 0;
        *(_OWORD *)(v26 + 24) = v34;
        long long v28 = v26 + 40;
        if (v19 == v20)
        {
          *a2 = (void **)v26;
          a2[1] = (void **)v28;
          a2[2] = (void **)v27;
        }
        else
        {
          do
          {
            long long v29 = *(_OWORD *)(v19 - 5);
            *((void *)v26 - 3) = *(v19 - 3);
            *(_OWORD *)(v26 - 40) = v29;
            *(v19 - 4) = 0;
            *(v19 - 3) = 0;
            *(v19 - 5) = 0;
            *((_OWORD *)v26 - 1) = *((_OWORD *)v19 - 1);
            v26 -= 40;
            v19 -= 5;
          }
          while (v19 != v20);
          int v19 = *a2;
          uint64_t v30 = a2[1];
          *a2 = (void **)v26;
          a2[1] = (void **)v28;
          for (a2[2] = (void **)v27; v30 != v19; v30 -= 5)
          {
            if (*((char *)v30 - 17) < 0) {
              operator delete(*(v30 - 5));
            }
          }
        }
        if (v19) {
          operator delete(v19);
        }
        int v31 = SHIBYTE(v33);
        a2[1] = (void **)v28;
        if (v31 < 0) {
          operator delete(__p[0]);
        }
      }
      v14 += 11;
    }
    while (v14 != (void **)v15);
  }
}

void sub_1D0E5AE0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **sub_1D0E5AE2C(uint64_t **a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **a1;
  **a1 = (uint64_t)a1[1];
  if (v2)
  {
    int v3 = e5rt_e5_compiler_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t **sub_1D0E5AEF8(uint64_t **a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **a1;
  **a1 = (uint64_t)a1[1];
  if (v2)
  {
    int v3 = e5rt_e5_compiler_options_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t *sub_1D0E5AFC4(uint64_t *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    int v3 = e5rt_e5_compiler_options_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t *sub_1D0E5B08C(uint64_t *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    int v3 = e5rt_e5_compiler_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t sub_1D0E5B154()
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v32 = 0;
  *(void *)int v36 = &v32;
  uint64_t v37 = 0;
  uint64_t v34 = 0;
  *(void *)int v38 = &v34;
  uint64_t v39 = 0;
  uint64_t precompiled_compute_operation_with_options = e5rt_e5_compiler_create();
  uint64_t v1 = **(void **)v38;
  **(void **)int v38 = v39;
  if (v1)
  {
    uint64_t v35 = v1;
    int v2 = e5rt_e5_compiler_release();
    if (v2)
    {
      int v22 = v2;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v22;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  if (!precompiled_compute_operation_with_options)
  {
    uint64_t v33 = 0;
    *(void *)int v38 = &v33;
    uint64_t v39 = 0;
    uint64_t precompiled_compute_operation_with_options = e5rt_e5_compiler_options_create();
    uint64_t v3 = **(void **)v38;
    **(void **)int v38 = v39;
    if (v3)
    {
      uint64_t v35 = v3;
      int v4 = e5rt_e5_compiler_options_release();
      if (v4)
      {
        int v26 = v4;
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v26;
          _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
        }
      }
    }
    if (!precompiled_compute_operation_with_options)
    {
      uint64_t precompiled_compute_operation_with_options = e5rt_e5_compiler_options_set_compute_device_types_mask();
      if (!precompiled_compute_operation_with_options) {
        uint64_t precompiled_compute_operation_with_options = e5rt_e5_compiler_compile();
      }
    }
    uint64_t v5 = v33;
    uint64_t v33 = 0;
    if (v5)
    {
      *(void *)int buf = v5;
      int v6 = e5rt_e5_compiler_options_release();
      if (v6)
      {
        int v27 = v6;
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int v38 = 67109120;
          *(_DWORD *)&v38[4] = v27;
          _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", v38, 8u);
        }
      }
    }
  }
  uint64_t v7 = v34;
  uint64_t v34 = 0;
  if (v7)
  {
    *(void *)int buf = v7;
    int v8 = e5rt_e5_compiler_release();
    if (v8)
    {
      int v23 = v8;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v38 = 67109120;
        *(_DWORD *)&v38[4] = v23;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", v38, 8u);
      }
    }
  }
  uint64_t v9 = **(void **)v36;
  **(void **)int v36 = v37;
  if (v9)
  {
    *(void *)int buf = v9;
    int v10 = e5rt_program_library_release();
    if (v10)
    {
      int v24 = v10;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v38 = 67109120;
        *(_DWORD *)&v38[4] = v24;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", v38, 8u);
      }
    }
  }
  if (!precompiled_compute_operation_with_options)
  {
    uint64_t v35 = 0;
    *(void *)int v38 = &v35;
    uint64_t v39 = 0;
    uint64_t precompiled_compute_operation_with_options = e5rt_program_library_retain_program_function();
    uint64_t v11 = **(void **)v38;
    **(void **)int v38 = v39;
    if (v11)
    {
      *(void *)int buf = v11;
      int v12 = e5rt_program_function_release();
      if (v12)
      {
        int v28 = v12;
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int v36 = 67109120;
          *(_DWORD *)&v36[4] = v28;
          _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", v36, 8u);
        }
      }
    }
    if (!precompiled_compute_operation_with_options)
    {
      uint64_t v34 = 0;
      *(void *)int v38 = &v34;
      uint64_t v39 = 0;
      uint64_t precompiled_compute_operation_with_options = e5rt_precompiled_compute_op_create_options_create_with_program_function();
      uint64_t v13 = **(void **)v38;
      **(void **)int v38 = v39;
      if (v13)
      {
        *(void *)int buf = v13;
        int options_release = e5rt_precompiled_compute_op_create_options_release();
        if (options_release)
        {
          int v30 = options_release;
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int v36 = 67109120;
            *(_DWORD *)&v36[4] = v30;
            _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", v36, 8u);
          }
        }
      }
      if (!precompiled_compute_operation_with_options) {
        uint64_t precompiled_compute_operation_with_options = e5rt_execution_stream_operation_create_precompiled_compute_operation_with_options();
      }
      uint64_t v15 = v34;
      uint64_t v34 = 0;
      if (v15)
      {
        *(void *)int v36 = v15;
        int v16 = e5rt_precompiled_compute_op_create_options_release();
        if (v16)
        {
          int v31 = v16;
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int v38 = 67109120;
            *(_DWORD *)&v38[4] = v31;
            _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", v38, 8u);
          }
        }
      }
    }
    uint64_t v17 = v35;
    uint64_t v35 = 0;
    if (v17)
    {
      *(void *)int v36 = v17;
      int v18 = e5rt_program_function_release();
      if (v18)
      {
        int v29 = v18;
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int v38 = 67109120;
          *(_DWORD *)&v38[4] = v29;
          _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", v38, 8u);
        }
      }
    }
  }
  uint64_t v19 = v32;
  uint64_t v32 = 0;
  if (v19)
  {
    *(void *)int v36 = v19;
    int v20 = e5rt_program_library_release();
    if (v20)
    {
      int v25 = v20;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v38 = 67109120;
        *(_DWORD *)&v38[4] = v25;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", v38, 8u);
      }
    }
  }
  return precompiled_compute_operation_with_options;
}

void sub_1D0E5B714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

uint64_t **sub_1D0E5B798(uint64_t **a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **a1;
  **a1 = (uint64_t)a1[1];
  if (v2)
  {
    int v3 = e5rt_program_library_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t **sub_1D0E5B864(uint64_t **a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **a1;
  **a1 = (uint64_t)a1[1];
  if (v2)
  {
    int v3 = e5rt_program_function_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t **sub_1D0E5B930(uint64_t **a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **a1;
  **a1 = (uint64_t)a1[1];
  if (v2)
  {
    int options_release = e5rt_precompiled_compute_op_create_options_release();
    if (options_release)
    {
      int v5 = options_release;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t *sub_1D0E5B9FC(uint64_t *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    int options_release = e5rt_precompiled_compute_op_create_options_release();
    if (options_release)
    {
      int v5 = options_release;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t *sub_1D0E5BAC4(uint64_t *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    int v3 = e5rt_program_function_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

uint64_t *sub_1D0E5BB8C(uint64_t *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    int v3 = e5rt_program_library_release();
    if (v3)
    {
      int v5 = v3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        int v7 = v5;
        _os_log_error_impl(&dword_1D0DBD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "e5rt::AssertSuccess failed with error code %d.", buf, 8u);
      }
    }
  }
  return a1;
}

void *sub_1D0E5BC54(void *result, void *a2, uint64_t a3)
{
  uint64_t v3 = a2[1];
  if (*a2 != v3 && 0xCCCCCCCCCCCCCCCDLL * ((v3 - *a2) >> 3) == *(void *)(a3 + 8)) {
    operator new();
  }
  *uint64_t result = 0;
  return result;
}

uint64_t sub_1D0E5C340(uint64_t a1, __CVBuffer *a2, uint64_t a3)
{
  v73[1] = *MEMORY[0x1E4F143B8];
  context = (void *)MEMORY[0x1D25F1DA0]();
  id v5 = objc_alloc(MEMORY[0x1E4F45890]);
  uint64_t v69 = (void *)[v5 initWithCVPixelBuffer:a2 options:MEMORY[0x1E4F1CC08]];
  int v6 = objc_opt_new();
  uint64_t v71 = v6;
  [v6 setRevision:3737841664 error:0];
  v73[0] = v6;
  int v7 = [MEMORY[0x1E4F1C978] arrayWithObjects:v73 count:1];
  id v72 = 0;
  char v8 = [v69 performRequests:v7 error:&v72];
  id v68 = v72;

  if (v8)
  {
    uint64_t v9 = [v6 results];
    if (v9)
    {
      int Width = CVPixelBufferGetWidth(a2);
      int Height = CVPixelBufferGetHeight(a2);
      uint64_t v12 = [v9 count];
      int v13 = v12;
      int v14 = v12;
      uint64_t v15 = *(_DWORD **)a3;
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 16) - *(void *)a3) >> 4) < (int)v12)
      {
        if (v12 << 32 < 0) {
          abort();
        }
        int v16 = *(unsigned char **)(a3 + 8);
        uint64_t v17 = (char *)operator new(48 * (int)v12);
        int v18 = &v17[v16 - (unsigned char *)v15];
        uint64_t v19 = v18;
        if (v16 != (unsigned char *)v15)
        {
          uint64_t v20 = 0;
          do
          {
            unint64_t v21 = &v18[v20];
            *((_DWORD *)v21 - 12) = *(_DWORD *)&v16[v20 - 48];
            *(void *)(v21 - 44) = *(void *)&v16[v20 - 44];
            *(void *)(v21 - 36) = *(void *)&v16[v20 - 36];
            long long v22 = *(_OWORD *)&v16[v20 - 28];
            *((_OWORD *)v21 - 1) = *(_OWORD *)&v16[v20 - 16];
            *(_OWORD *)(v21 - 28) = v22;
            v20 -= 48;
          }
          while (&v16[v20] != (unsigned char *)v15);
          uint64_t v19 = &v18[v20];
        }
        *(void *)a3 = v19;
        *(void *)(a3 + 8) = v18;
        *(void *)(a3 + 16) = &v17[48 * v14];
        if (v15) {
          operator delete(v15);
        }
      }
      uint64_t v23 = 1;
      if (v13 < 1)
      {
        int v6 = v71;
      }
      else
      {
        uint64_t v24 = 0;
        uint64_t v25 = v13;
        float v26 = (float)Width;
        float v27 = (float)Height;
        int v6 = v71;
        while (1)
        {
          int v28 = [v9 objectAtIndexedSubscript:v24];
          int v29 = v28;
          if (!v28) {
            break;
          }
          [v28 boundingBox];
          double v31 = v30;
          double v33 = v32;
          double v35 = v34;
          double v37 = v36;
          int v38 = [v29 roll];
          [v38 floatValue];
          float v40 = v39;

          uint64_t v41 = [v29 yaw];
          [v41 floatValue];
          float v43 = v42;

          float v44 = v31;
          float v45 = v33 + v37;
          float v46 = v35;
          float v47 = v37;
          *(float *)&long long v48 = (float)(v44 * v26) + -0.5;
          *((float *)&v48 + 1) = (float)((float)(1.0 - v45) * v27) + -0.5;
          *((float *)&v48 + 2) = v46 * v26;
          *((float *)&v48 + 3) = v47 * v27;
          float v49 = v40 / -0.017453;
          float v50 = v43 / 0.017453;
          unint64_t v52 = *(_DWORD **)(a3 + 8);
          unint64_t v51 = *(void *)(a3 + 16);
          if ((unint64_t)v52 >= v51)
          {
            unint64_t v54 = *(_DWORD **)a3;
            unint64_t v55 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v52 - *(void *)a3) >> 4);
            unint64_t v56 = v55 + 1;
            if (v55 + 1 > 0x555555555555555) {
              abort();
            }
            long long v70 = v48;
            unint64_t v57 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v51 - (void)v54) >> 4);
            if (2 * v57 > v56) {
              unint64_t v56 = 2 * v57;
            }
            if (v57 >= 0x2AAAAAAAAAAAAAALL) {
              unint64_t v58 = 0x555555555555555;
            }
            else {
              unint64_t v58 = v56;
            }
            if (v58 > 0x555555555555555) {
              sub_1D0DE8CE0();
            }
            uint64_t v59 = (char *)operator new(48 * v58);
            uint64_t v60 = &v59[48 * v55];
            *(_DWORD *)uint64_t v60 = 5;
            *(_OWORD *)(v60 + 4) = v70;
            *((float *)v60 + 5) = v49;
            v60[24] = 1;
            *((float *)v60 + 7) = v50;
            v60[32] = 1;
            *((void *)v60 + 5) = v24;
            if (v52 == v54)
            {
              uint64_t v64 = &v59[48 * v55];
            }
            else
            {
              uint64_t v61 = 0;
              do
              {
                uint64_t v62 = &v60[v61 * 4];
                *((_DWORD *)v62 - 12) = v52[v61 - 12];
                *(void *)(v62 - 44) = *(void *)&v52[v61 - 11];
                *(void *)(v62 - 36) = *(void *)&v52[v61 - 9];
                long long v63 = *(_OWORD *)&v52[v61 - 7];
                *((_OWORD *)v62 - 1) = *(_OWORD *)&v52[v61 - 4];
                *(_OWORD *)(v62 - 28) = v63;
                v61 -= 12;
              }
              while (&v52[v61] != v54);
              uint64_t v64 = &v60[v61 * 4];
              unint64_t v52 = *(_DWORD **)a3;
            }
            uint64_t v65 = &v59[48 * v58];
            unint64_t v53 = v60 + 48;
            *(void *)a3 = v64;
            *(void *)(a3 + 8) = v60 + 48;
            *(void *)(a3 + 16) = v65;
            if (v52) {
              operator delete(v52);
            }
          }
          else
          {
            *unint64_t v52 = 5;
            *(_OWORD *)(v52 + 1) = v48;
            *((float *)v52 + 5) = v49;
            *((unsigned char *)v52 + 24) = 1;
            *((float *)v52 + 7) = v50;
            *((unsigned char *)v52 + 32) = 1;
            unint64_t v53 = v52 + 12;
            *((void *)v52 + 5) = v24;
          }
          *(void *)(a3 + 8) = v53;

          int v6 = v71;
          if (++v24 == v25) {
            goto LABEL_31;
          }
        }
        uint64_t v23 = 0;
      }
    }
    else
    {
LABEL_31:
      uint64_t v23 = 1;
    }
  }
  else
  {
    uint64_t v23 = 0;
  }

  return v23;
}

void sub_1D0E5C82C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1D0E5C8E0()
{
}

void *sub_1D0E5C8F8(void *result)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA6438B8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v3 = result;
    int v2 = __cxa_guard_acquire(&qword_1EA6438B8);
    uint64_t result = v3;
    if (v2) {
      operator new();
    }
  }
  uint64_t v1 = qword_1EA6438B0;
  *uint64_t result = qword_1EA6438A8;
  result[1] = v1;
  if (v1) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v1 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1D0E5CA28(uint64_t result)
{
  uint64_t v1 = *(uint64_t **)(result + 24);
  if (v1)
  {
    uint64_t v2 = *v1;
    if (*v1)
    {
      uint64_t v3 = *(FILE **)(v2 + 72);
      if (v3) {
        fclose(v3);
      }
      *(void *)(v2 + 72) = 0;
      std::mutex::~mutex((std::mutex *)(v2 + 8));
      MEMORY[0x1D25F16B0](v2, 0x1020C4086060DB6);
    }
    JUMPOUT(0x1D25F16B0);
  }
  return result;
}

void sub_1D0E5CAB4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D25F16B0);
}

uint64_t sub_1D0E5CAF0(void *a1, uint64_t a2)
{
  uint64_t v35 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v2 = MEMORY[0x1E4FBA488] + 104;
  v47[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v3 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v42 = MEMORY[0x1E4FBA488] + 64;
  int v4 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v5 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  v41[0] = *(void *)(MEMORY[0x1E4FBA408] + 16);
  uint64_t v38 = v41[0];
  uint64_t v39 = v5;
  *(void *)((char *)v41 + *(void *)(v41[0] - 24)) = v5;
  v41[1] = 0;
  int v6 = (std::ios_base *)((char *)v41 + *(void *)(v41[0] - 24));
  std::ios_base::init(v6, v43);
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  uint64_t v7 = v4[5];
  uint64_t v42 = v4[4];
  uint64_t v8 = v42;
  uint64_t v37 = v7;
  *(uint64_t *)((char *)&v43[-1] + *(void *)(v42 - 24)) = v7;
  v41[0] = v4[1];
  uint64_t v9 = v41[0];
  uint64_t v34 = v4[6];
  *(void *)((char *)v41 + *(void *)(v41[0] - 24)) = v34;
  v47[0] = v2;
  v41[0] = v35;
  uint64_t v42 = v3;
  std::streambuf::basic_streambuf();
  uint64_t v32 = MEMORY[0x1E4FBA470] + 16;
  v43[0] = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)float v44 = 0u;
  long long v45 = 0u;
  int v46 = 24;
  uint64_t v36 = *(int *)((char *)&v41[2] + *(void *)(v41[0] - 24));
  uint64_t v33 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v10 = MEMORY[0x1E4FBA488] + 104;
  v57[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v11 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v49 = MEMORY[0x1E4FBA488] + 64;
  v48[0] = v38;
  *(void *)((char *)v48 + *(void *)(v38 - 24)) = v39;
  v48[1] = 0;
  uint64_t v12 = (std::ios_base *)((char *)v48 + *(void *)(v48[0] - 24));
  std::ios_base::init(v12, v50);
  v12[1].__fmtflags_ = -1;
  v12[1].__vftable = 0;
  uint64_t v49 = v8;
  *(void *)((char *)&v50[-1] + *(void *)(v8 - 24)) = v37;
  v48[0] = v9;
  *(void *)((char *)v48 + *(void *)(v9 - 24)) = v34;
  v57[0] = v10;
  v48[0] = v33;
  uint64_t v49 = v11;
  std::streambuf::basic_streambuf();
  uint64_t v13 = MEMORY[0x1E4FBA470] + 16;
  v50[0] = MEMORY[0x1E4FBA470] + 16;
  long long v55 = 0u;
  long long __p = 0u;
  int v56 = 24;
  *(void *)((char *)&v50[1] + *(void *)(v49 - 24)) = v36;
  int v14 = *(char *)(a2 + 23);
  if (v14 >= 0) {
    uint64_t v15 = a2;
  }
  else {
    uint64_t v15 = *(void *)a2;
  }
  if (v14 >= 0) {
    uint64_t v16 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v16 = *(void *)(a2 + 8);
  }
  sub_1D0E25008(&v49, v15, v16);
  if ((v56 & 0x10) != 0)
  {
    unint64_t v19 = *((void *)&v55 + 1);
    if (*((void *)&v55 + 1) < v53)
    {
      *((void *)&v55 + 1) = v53;
      unint64_t v19 = v53;
    }
    uint64_t v20 = (const void **)&v52;
  }
  else
  {
    if ((v56 & 8) == 0)
    {
      size_t v17 = 0;
      int v18 = a1;
      *((unsigned char *)a1 + 23) = 0;
      goto LABEL_22;
    }
    uint64_t v20 = (const void **)v51;
    unint64_t v19 = v51[2];
  }
  unint64_t v21 = *v20;
  size_t v17 = v19 - (void)*v20;
  if (v17 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v17 >= 0x17)
  {
    uint64_t v22 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v17 | 7) != 0x17) {
      uint64_t v22 = v17 | 7;
    }
    uint64_t v23 = v22 + 1;
    uint64_t v24 = operator new(v22 + 1);
    a1[1] = v17;
    a1[2] = v23 | 0x8000000000000000;
    *a1 = v24;
    int v18 = v24;
    goto LABEL_21;
  }
  int v18 = a1;
  *((unsigned char *)a1 + 23) = v17;
  if (v17) {
LABEL_21:
  }
    memmove(v18, v21, v17);
LABEL_22:
  uint64_t v25 = (void *)MEMORY[0x1E4FBA408];
  *((unsigned char *)v18 + v17) = 0;
  v48[0] = *v25;
  uint64_t v26 = v48[0];
  uint64_t v27 = v25[9];
  uint64_t v28 = v25[8];
  *(void *)((char *)v48 + *(void *)(v48[0] - 24)) = v28;
  uint64_t v29 = v27;
  uint64_t v49 = v27;
  v50[0] = v13;
  if (SBYTE7(v55) < 0) {
    operator delete((void *)__p);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D25F1640](v57);
  v41[0] = v26;
  *(void *)((char *)v41 + *(void *)(v26 - 24)) = v28;
  uint64_t v42 = v29;
  v43[0] = v32;
  if (SBYTE7(v45) < 0) {
    operator delete(v44[0]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1D25F1640](v47);
}

uint64_t sub_1D0E5D230(void *a1)
{
  uint64_t v31 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v1 = MEMORY[0x1E4FBA488] + 104;
  v42[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v2 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v37 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v3 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  v36[0] = *(void *)(MEMORY[0x1E4FBA408] + 16);
  uint64_t v34 = v36[0];
  uint64_t v35 = v4;
  *(void *)((char *)v36 + *(void *)(v36[0] - 24)) = v4;
  v36[1] = 0;
  uint64_t v5 = (std::ios_base *)((char *)v36 + *(void *)(v36[0] - 24));
  std::ios_base::init(v5, v38);
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  uint64_t v6 = v3[5];
  uint64_t v37 = v3[4];
  uint64_t v7 = v37;
  uint64_t v33 = v6;
  *(uint64_t *)((char *)&v38[-1] + *(void *)(v37 - 24)) = v6;
  v36[0] = v3[1];
  uint64_t v8 = v36[0];
  uint64_t v30 = v3[6];
  *(void *)((char *)v36 + *(void *)(v36[0] - 24)) = v30;
  v42[0] = v1;
  v36[0] = v31;
  uint64_t v37 = v2;
  std::streambuf::basic_streambuf();
  uint64_t v28 = MEMORY[0x1E4FBA470] + 16;
  v38[0] = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)uint64_t v39 = 0u;
  long long v40 = 0u;
  int v41 = 24;
  uint64_t v32 = *(int *)((char *)&v36[2] + *(void *)(v36[0] - 24));
  uint64_t v29 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v9 = MEMORY[0x1E4FBA488] + 104;
  v52[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v10 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v44 = MEMORY[0x1E4FBA488] + 64;
  v43[0] = v34;
  *(void *)((char *)v43 + *(void *)(v34 - 24)) = v35;
  v43[1] = 0;
  uint64_t v11 = (std::ios_base *)((char *)v43 + *(void *)(v43[0] - 24));
  std::ios_base::init(v11, v45);
  v11[1].__fmtflags_ = -1;
  v11[1].__vftable = 0;
  uint64_t v44 = v7;
  *(void *)((char *)&v45[-1] + *(void *)(v7 - 24)) = v33;
  v43[0] = v8;
  *(void *)((char *)v43 + *(void *)(v8 - 24)) = v30;
  v52[0] = v9;
  v43[0] = v29;
  uint64_t v44 = v10;
  std::streambuf::basic_streambuf();
  uint64_t v12 = MEMORY[0x1E4FBA470] + 16;
  v45[0] = MEMORY[0x1E4FBA470] + 16;
  long long v50 = 0u;
  long long __p = 0u;
  int v51 = 24;
  *(void *)((char *)&v45[1] + *(void *)(v44 - 24)) = v32;
  sub_1D0E25008(&v44, (uint64_t)": ", 2);
  if ((v51 & 0x10) != 0)
  {
    unint64_t v15 = *((void *)&v50 + 1);
    if (*((void *)&v50 + 1) < v48)
    {
      *((void *)&v50 + 1) = v48;
      unint64_t v15 = v48;
    }
    uint64_t v16 = (const void **)&v47;
  }
  else
  {
    if ((v51 & 8) == 0)
    {
      size_t v13 = 0;
      int v14 = a1;
      *((unsigned char *)a1 + 23) = 0;
      goto LABEL_16;
    }
    uint64_t v16 = (const void **)v46;
    unint64_t v15 = v46[2];
  }
  size_t v17 = *v16;
  size_t v13 = v15 - (void)*v16;
  if (v13 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v13 >= 0x17)
  {
    uint64_t v18 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17) {
      uint64_t v18 = v13 | 7;
    }
    uint64_t v19 = v18 + 1;
    uint64_t v20 = operator new(v18 + 1);
    a1[1] = v13;
    a1[2] = v19 | 0x8000000000000000;
    *a1 = v20;
    int v14 = v20;
    goto LABEL_15;
  }
  int v14 = a1;
  *((unsigned char *)a1 + 23) = v13;
  if (v13) {
LABEL_15:
  }
    memmove(v14, v17, v13);
LABEL_16:
  unint64_t v21 = (void *)MEMORY[0x1E4FBA408];
  *((unsigned char *)v14 + v13) = 0;
  v43[0] = *v21;
  uint64_t v22 = v43[0];
  uint64_t v23 = v21[9];
  uint64_t v24 = v21[8];
  *(void *)((char *)v43 + *(void *)(v43[0] - 24)) = v24;
  uint64_t v25 = v23;
  uint64_t v44 = v23;
  v45[0] = v12;
  if (SBYTE7(v50) < 0) {
    operator delete((void *)__p);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D25F1640](v52);
  v36[0] = v22;
  *(void *)((char *)v36 + *(void *)(v22 - 24)) = v24;
  uint64_t v37 = v25;
  v38[0] = v28;
  if (SBYTE7(v40) < 0) {
    operator delete(v39[0]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1D25F1640](v42);
}

uint64_t sub_1D0E5D960(void *a1, const char *a2)
{
  uint64_t v33 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v2 = MEMORY[0x1E4FBA488] + 104;
  v45[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v3 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v40 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v4 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v5 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  v39[0] = *(void *)(MEMORY[0x1E4FBA408] + 16);
  uint64_t v36 = v39[0];
  uint64_t v37 = v5;
  *(void *)((char *)v39 + *(void *)(v39[0] - 24)) = v5;
  v39[1] = 0;
  uint64_t v6 = (std::ios_base *)((char *)v39 + *(void *)(v39[0] - 24));
  std::ios_base::init(v6, v41);
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  uint64_t v7 = v4[5];
  uint64_t v40 = v4[4];
  uint64_t v8 = v40;
  uint64_t v35 = v7;
  *(uint64_t *)((char *)&v41[-1] + *(void *)(v40 - 24)) = v7;
  v39[0] = v4[1];
  uint64_t v9 = v39[0];
  uint64_t v32 = v4[6];
  *(void *)((char *)v39 + *(void *)(v39[0] - 24)) = v32;
  v45[0] = v2;
  v39[0] = v33;
  uint64_t v40 = v3;
  std::streambuf::basic_streambuf();
  uint64_t v30 = MEMORY[0x1E4FBA470] + 16;
  v41[0] = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)uint64_t v42 = 0u;
  long long v43 = 0u;
  int v44 = 24;
  uint64_t v34 = *(int *)((char *)&v39[2] + *(void *)(v39[0] - 24));
  uint64_t v31 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v10 = MEMORY[0x1E4FBA488] + 104;
  v55[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v11 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v47 = MEMORY[0x1E4FBA488] + 64;
  v46[0] = v36;
  *(void *)((char *)v46 + *(void *)(v36 - 24)) = v37;
  v46[1] = 0;
  uint64_t v12 = (std::ios_base *)((char *)v46 + *(void *)(v46[0] - 24));
  std::ios_base::init(v12, v48);
  v12[1].__fmtflags_ = -1;
  v12[1].__vftable = 0;
  uint64_t v47 = v8;
  *(void *)((char *)&v48[-1] + *(void *)(v8 - 24)) = v35;
  v46[0] = v9;
  *(void *)((char *)v46 + *(void *)(v9 - 24)) = v32;
  v55[0] = v10;
  v46[0] = v31;
  uint64_t v47 = v11;
  std::streambuf::basic_streambuf();
  uint64_t v13 = MEMORY[0x1E4FBA470] + 16;
  v48[0] = MEMORY[0x1E4FBA470] + 16;
  long long v53 = 0u;
  long long __p = 0u;
  int v54 = 24;
  *(void *)((char *)&v48[1] + *(void *)(v47 - 24)) = v34;
  size_t v14 = strlen(a2);
  sub_1D0E25008(&v47, (uint64_t)a2, v14);
  if ((v54 & 0x10) != 0)
  {
    unint64_t v17 = *((void *)&v53 + 1);
    if (*((void *)&v53 + 1) < v51)
    {
      *((void *)&v53 + 1) = v51;
      unint64_t v17 = v51;
    }
    uint64_t v18 = (const void **)&v50;
  }
  else
  {
    if ((v54 & 8) == 0)
    {
      size_t v15 = 0;
      uint64_t v16 = a1;
      *((unsigned char *)a1 + 23) = 0;
      goto LABEL_16;
    }
    uint64_t v18 = (const void **)v49;
    unint64_t v17 = v49[2];
  }
  uint64_t v19 = *v18;
  size_t v15 = v17 - (void)*v18;
  if (v15 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v15 >= 0x17)
  {
    uint64_t v20 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17) {
      uint64_t v20 = v15 | 7;
    }
    uint64_t v21 = v20 + 1;
    uint64_t v22 = operator new(v20 + 1);
    a1[1] = v15;
    a1[2] = v21 | 0x8000000000000000;
    *a1 = v22;
    uint64_t v16 = v22;
    goto LABEL_15;
  }
  uint64_t v16 = a1;
  *((unsigned char *)a1 + 23) = v15;
  if (v15) {
LABEL_15:
  }
    memmove(v16, v19, v15);
LABEL_16:
  uint64_t v23 = (void *)MEMORY[0x1E4FBA408];
  *((unsigned char *)v16 + v15) = 0;
  v46[0] = *v23;
  uint64_t v24 = v46[0];
  uint64_t v25 = v23[9];
  uint64_t v26 = v23[8];
  *(void *)((char *)v46 + *(void *)(v46[0] - 24)) = v26;
  uint64_t v27 = v25;
  uint64_t v47 = v25;
  v48[0] = v13;
  if (SBYTE7(v53) < 0) {
    operator delete((void *)__p);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D25F1640](v55);
  v39[0] = v24;
  *(void *)((char *)v39 + *(void *)(v24 - 24)) = v26;
  uint64_t v40 = v27;
  v41[0] = v30;
  if (SBYTE7(v43) < 0) {
    operator delete(v42[0]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1D25F1640](v45);
}

uint64_t sub_1D0E5E098(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, const char *a5, const char *a6, uint64_t a7, const char *a8, char a9)
{
  v212[48] = *MEMORY[0x1E4F143B8];
  *(void *)a1 = *a2;
  uint64_t v12 = a2[1];
  *(void *)(a1 + 8) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = (void *)(a1 + 16);
  uint64_t v14 = MEMORY[0x1E4FBA498] + 24;
  uint64_t v15 = MEMORY[0x1E4FBA498] + 64;
  *(void *)(a1 + 128) = MEMORY[0x1E4FBA498] + 64;
  uint64_t v16 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v17 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(void *)(a1 + 16) = v17;
  *(void *)(a1 + 16 + *(void *)(v17 - 24)) = v16;
  uint64_t v18 = (std::ios_base *)(a1 + 16 + *(void *)(*(void *)(a1 + 16) - 24));
  std::ios_base::init(v18, (void *)(a1 + 24));
  v18[1].__vftable = 0;
  v18[1].__fmtflags_ = -1;
  *(void *)(a1 + 16) = v14;
  *(void *)(a1 + 128) = v15;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 16;
  *(unsigned char *)(a1 + 280) = 1;
  int v19 = *(unsigned __int8 *)(*(void *)*a2 + 1);
  uint64_t v20 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v178 = a1;
  uint64_t v179 = (void *)(a1 + 16);
  long long v166 = a2;
  if (!v19)
  {
    time_t v33 = *(void *)(MEMORY[0x1E4FBA408] + 24);
    time_t v169 = *(void *)(MEMORY[0x1E4FBA408] + 8);
    std::string::size_type v171 = *(void *)(MEMORY[0x1E4FBA408] + 32);
    std::string::size_type v173 = *(void *)(MEMORY[0x1E4FBA408] + 40);
    std::string::size_type v168 = *(void *)(MEMORY[0x1E4FBA408] + 48);
    goto LABEL_89;
  }
  v21.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  if ((unint64_t)(v21.__d_.__rep_ % 1000000) <= 0xFFFFFFFFFFF0BDBFLL) {
    std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v22 = v21.__d_.__rep_ % 1000000;
  }
  else {
    std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v22 = v21.__d_.__rep_ % 1000000 + 1000000;
  }
  __t.__d_.__rep_ = v21.__d_.__rep_ - v22;
  time_t __dst = std::chrono::system_clock::to_time_t(&__t);
  memset(&v195, 0, sizeof(v195));
  localtime_r(&__dst, &v205);
  size_t v23 = 84;
  do
  {
    std::string::size_type v28 = v23 | 1;
    if (SHIBYTE(v195.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::size_type size = v195.__r_.__value_.__l.__size_;
      if (v195.__r_.__value_.__l.__size_ < v28)
      {
LABEL_8:
        std::string::append(&v195, v28 - size, 0);
        goto LABEL_9;
      }
      uint64_t v30 = (std::string *)v195.__r_.__value_.__r.__words[0];
      v195.__r_.__value_.__l.__size_ = v23 | 1;
    }
    else
    {
      std::string::size_type size = HIBYTE(v195.__r_.__value_.__r.__words[2]);
      if (v28 > HIBYTE(v195.__r_.__value_.__r.__words[2])) {
        goto LABEL_8;
      }
      *((unsigned char *)&v195.__r_.__value_.__s + 23) = v23 & 0x7C | 1;
      uint64_t v30 = &v195;
    }
    v30->__r_.__value_.__s.__data_[v28] = 0;
LABEL_9:
    if ((v195.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v24 = &v195;
    }
    else {
      uint64_t v24 = (std::string *)v195.__r_.__value_.__r.__words[0];
    }
    size_t v25 = strftime((char *)v24, v23, "%Y-%m-%d %H:%M:%S", &v205);
    BOOL v27 = v25 - 1 >= v23;
    v23 *= 2;
  }
  while (v27);
  if (SHIBYTE(v195.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type v31 = v195.__r_.__value_.__l.__size_;
    if (v195.__r_.__value_.__l.__size_ < v25) {
      goto LABEL_25;
    }
    uint64_t v32 = (std::string *)v195.__r_.__value_.__r.__words[0];
    v195.__r_.__value_.__l.__size_ = v25;
LABEL_27:
    v32->__r_.__value_.__s.__data_[v25] = 0;
  }
  else
  {
    std::string::size_type v31 = HIBYTE(v195.__r_.__value_.__r.__words[2]);
    if (v25 <= HIBYTE(v195.__r_.__value_.__r.__words[2]))
    {
      *((unsigned char *)&v195.__r_.__value_.__s + 23) = v25 & 0x7F;
      uint64_t v32 = &v195;
      goto LABEL_27;
    }
LABEL_25:
    std::string::append(&v195, v25 - v31, 0);
  }
  cva::Sprintf::sprintf((uint64_t *)&v205.tm_sec, (cva::Sprintf *)".%06lld", v26, v22);
  if (v205.tm_year >= 0) {
    uint64_t v34 = &v205;
  }
  else {
    uint64_t v34 = *(tm **)&v205.tm_sec;
  }
  if (v205.tm_year >= 0) {
    std::string::size_type tm_year_high = HIBYTE(v205.tm_year);
  }
  else {
    std::string::size_type tm_year_high = *(void *)&v205.tm_hour;
  }
  std::string::append(&v195, (const std::string::value_type *)v34, tm_year_high);
  if (SHIBYTE(v205.tm_year) < 0) {
    operator delete(*(void **)&v205.tm_sec);
  }
  sub_1D0E5CAF0(&v205, (uint64_t)&v195);
  if (v205.tm_year >= 0) {
    uint64_t v36 = &v205;
  }
  else {
    uint64_t v36 = *(tm **)&v205.tm_sec;
  }
  if (v205.tm_year >= 0) {
    uint64_t v37 = HIBYTE(v205.tm_year);
  }
  else {
    uint64_t v37 = *(void *)&v205.tm_hour;
  }
  sub_1D0E25008(v13, (uint64_t)v36, v37);
  if (SHIBYTE(v205.tm_year) < 0)
  {
    operator delete(*(void **)&v205.tm_sec);
    if (SHIBYTE(v195.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_59;
    }
  }
  else
  {
    if ((SHIBYTE(v195.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_44;
    }
LABEL_59:
    operator delete(v195.__r_.__value_.__l.__data_);
  }
LABEL_44:
  sub_1D0E5D230(&v205);
  if (v205.tm_year >= 0) {
    uint64_t v38 = &v205;
  }
  else {
    uint64_t v38 = *(tm **)&v205.tm_sec;
  }
  if (v205.tm_year >= 0) {
    uint64_t v39 = HIBYTE(v205.tm_year);
  }
  else {
    uint64_t v39 = *(void *)&v205.tm_hour;
  }
  sub_1D0E25008(v13, (uint64_t)v38, v39);
  if (SHIBYTE(v205.tm_year) < 0) {
    operator delete(*(void **)&v205.tm_sec);
  }
  uint64_t v156 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v40 = MEMORY[0x1E4FBA488] + 104;
  v204[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v41 = MEMORY[0x1E4FBA488] + 64;
  v195.__r_.__value_.__r.__words[2] = MEMORY[0x1E4FBA488] + 64;
  std::string::size_type v42 = v20[3];
  v195.__r_.__value_.__r.__words[0] = v20[2];
  std::string::size_type v161 = v195.__r_.__value_.__r.__words[0];
  time_t v151 = v42;
  std::string::size_type v163 = v42;
  *(std::string::size_type *)((char *)v195.__r_.__value_.__r.__words
                            + *(void *)(v195.__r_.__value_.__r.__words[0] - 24)) = v42;
  v195.__r_.__value_.__l.__size_ = 0;
  long long v43 = (std::ios_base *)((char *)&v195 + *(void *)(v195.__r_.__value_.__r.__words[0] - 24));
  std::ios_base::init(v43, v196);
  v43[1].__vftable = 0;
  v43[1].__fmtflags_ = -1;
  std::string::size_type v44 = v20[5];
  std::string::size_type v171 = v20[4];
  std::string::size_type v173 = v44;
  v195.__r_.__value_.__r.__words[2] = v171;
  std::string::size_type v159 = v44;
  *(std::string::size_type *)((char *)&v195.__r_.__value_.__r.__words[2] + *(void *)(v171 - 24)) = v44;
  time_t v169 = v20[1];
  v195.__r_.__value_.__r.__words[0] = v169;
  std::string::size_type v168 = v20[6];
  *(std::string::size_type *)((char *)v195.__r_.__value_.__r.__words + *(void *)(v169 - 24)) = v168;
  v204[0] = v40;
  v195.__r_.__value_.__r.__words[0] = v156;
  v195.__r_.__value_.__r.__words[2] = v41;
  std::streambuf::basic_streambuf();
  uint64_t v148 = MEMORY[0x1E4FBA470] + 16;
  v196[0] = MEMORY[0x1E4FBA470] + 16;
  long long v201 = 0u;
  long long v202 = 0u;
  int v203 = 24;
  uint64_t v157 = *(int *)((char *)&v195.__r_.__value_.__r.__words[2] + *(void *)(v195.__r_.__value_.__r.__words[0] - 24));
  uint64_t v153 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v45 = MEMORY[0x1E4FBA488] + 104;
  v212[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v46 = MEMORY[0x1E4FBA488] + 64;
  *(void *)&v205.tm_mon = MEMORY[0x1E4FBA488] + 64;
  *(void *)&v205.tm_sec = v161;
  *(void *)((char *)&v205.tm_sec + *(void *)(v161 - 24)) = v163;
  *(void *)&v205.tm_hour = 0;
  uint64_t v47 = (std::ios_base *)((char *)&v205 + *(void *)(*(void *)&v205.tm_sec - 24));
  std::ios_base::init(v47, &v205.tm_wday);
  v47[1].__fmtflags_ = -1;
  v47[1].__vftable = 0;
  *(void *)&v205.tm_mon = v171;
  *(void *)((char *)&v205.tm_mon + *(void *)(v171 - 24)) = v159;
  *(void *)&v205.tm_sec = v169;
  *(void *)((char *)&v205.tm_sec + *(void *)(v169 - 24)) = v168;
  v212[0] = v45;
  *(void *)&v205.tm_sec = v153;
  *(void *)&v205.tm_mon = v46;
  std::streambuf::basic_streambuf();
  uint64_t v48 = MEMORY[0x1E4FBA470] + 16;
  *(void *)&v205.tm_wday = MEMORY[0x1E4FBA470] + 16;
  long long v210 = 0u;
  long long __p = 0u;
  int v211 = 24;
  *(void *)((char *)&v205.tm_isdst + *(void *)(*(void *)&v205.tm_mon - 24)) = v157;
  size_t v49 = strlen(a5);
  sub_1D0E25008(&v205.tm_mon, (uint64_t)a5, v49);
  if ((v211 & 0x10) != 0)
  {
    unint64_t v53 = *((void *)&v210 + 1);
    if (*((void *)&v210 + 1) < v208)
    {
      *((void *)&v210 + 1) = v208;
      unint64_t v53 = v208;
    }
    p_tm_gmtoff = &v207;
  }
  else
  {
    if ((v211 & 8) == 0)
    {
      size_t v50 = 0;
      HIBYTE(v189) = 0;
      p_dst = &__dst;
      uint64_t v52 = v179;
      uint64_t v20 = (void *)MEMORY[0x1E4FBA408];
      goto LABEL_69;
    }
    p_tm_gmtoff = &v205.tm_gmtoff;
    unint64_t v53 = v206;
  }
  uint64_t v52 = v179;
  uint64_t v20 = (void *)MEMORY[0x1E4FBA408];
  long long v55 = (const void *)*p_tm_gmtoff;
  size_t v50 = v53 - *p_tm_gmtoff;
  if (v50 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_230;
  }
  if (v50 >= 0x17)
  {
    uint64_t v56 = (v50 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v50 | 7) != 0x17) {
      uint64_t v56 = v50 | 7;
    }
    uint64_t v57 = v56 + 1;
    p_dst = operator new(v56 + 1);
    size_t v188 = v50;
    int64_t v189 = v57 | 0x8000000000000000;
    time_t __dst = (time_t)p_dst;
    goto LABEL_68;
  }
  HIBYTE(v189) = v53 - *(unsigned char *)p_tm_gmtoff;
  p_dst = &__dst;
  if (v50) {
LABEL_68:
  }
    memmove(p_dst, v55, v50);
LABEL_69:
  *((unsigned char *)p_dst + v50) = 0;
  *(void *)&v205.tm_sec = *v20;
  std::string::size_type v58 = *(void *)&v205.tm_sec;
  std::string::size_type v59 = v20[9];
  std::string::size_type v60 = v20[8];
  *(void *)((char *)&v205.tm_sec + *(void *)(*(void *)&v205.tm_sec - 24)) = v60;
  std::string::size_type v61 = v59;
  *(void *)&v205.tm_mon = v59;
  *(void *)&v205.tm_wday = v48;
  if (SBYTE7(v210) < 0) {
    operator delete((void *)__p);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D25F1640](v212);
  v195.__r_.__value_.__r.__words[0] = v58;
  *(std::string::size_type *)((char *)v195.__r_.__value_.__r.__words + *(void *)(v58 - 24)) = v60;
  v195.__r_.__value_.__r.__words[2] = v61;
  v196[0] = v148;
  time_t v33 = v151;
  if (SBYTE7(v202) < 0) {
    operator delete((void *)v201);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D25F1640](v204);
  if (v189 >= 0) {
    uint64_t v62 = (uint64_t)&__dst;
  }
  else {
    uint64_t v62 = __dst;
  }
  if (v189 >= 0) {
    uint64_t v63 = HIBYTE(v189);
  }
  else {
    uint64_t v63 = v188;
  }
  sub_1D0E25008(v52, v62, v63);
  if (SHIBYTE(v189) < 0) {
    operator delete((void *)__dst);
  }
  sub_1D0E5D230(&v205);
  if (v205.tm_year >= 0) {
    uint64_t v64 = &v205;
  }
  else {
    uint64_t v64 = *(tm **)&v205.tm_sec;
  }
  if (v205.tm_year >= 0) {
    uint64_t v65 = HIBYTE(v205.tm_year);
  }
  else {
    uint64_t v65 = *(void *)&v205.tm_hour;
  }
  sub_1D0E25008(v52, (uint64_t)v64, v65);
  if (SHIBYTE(v205.tm_year) < 0) {
    operator delete(*(void **)&v205.tm_sec);
  }
LABEL_89:
  uint64_t v183 = &a9;
  vsnprintf((char *)&v205, 0x200uLL, a8, &a9);
  __formatb = (char *)(MEMORY[0x1E4FBA488] + 24);
  uint64_t v66 = MEMORY[0x1E4FBA488] + 104;
  v194[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v67 = MEMORY[0x1E4FBA488] + 64;
  int64_t v189 = MEMORY[0x1E4FBA488] + 64;
  time_t v164 = v20[2];
  time_t __dst = v164;
  *(time_t *)((char *)&__dst + *(void *)(v164 - 24)) = v33;
  size_t v188 = 0;
  id v68 = (std::ios_base *)((char *)&__dst + *(void *)(__dst - 24));
  std::ios_base::init(v68, v190);
  v68[1].__vftable = 0;
  v68[1].__fmtflags_ = -1;
  int64_t v189 = v171;
  *(void *)((char *)&v190[-1] + *(void *)(v171 - 24)) = v173;
  time_t __dst = v169;
  *(time_t *)((char *)&__dst + *(void *)(v169 - 24)) = v168;
  v194[0] = v66;
  time_t __dst = (time_t)__formatb;
  int64_t v189 = v67;
  std::streambuf::basic_streambuf();
  uint64_t v170 = MEMORY[0x1E4FBA470] + 16;
  v190[0] = MEMORY[0x1E4FBA470] + 16;
  long long v191 = 0u;
  long long v192 = 0u;
  int v193 = 24;
  __formatc = (char *)*(int *)((char *)&v190[-1] + *(void *)(__dst - 24));
  uint64_t v69 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v70 = MEMORY[0x1E4FBA488] + 104;
  v204[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v71 = MEMORY[0x1E4FBA488] + 64;
  v195.__r_.__value_.__r.__words[2] = MEMORY[0x1E4FBA488] + 64;
  v195.__r_.__value_.__r.__words[0] = v164;
  std::string::size_type v162 = v20[3];
  *(std::string::size_type *)((char *)v195.__r_.__value_.__r.__words + *(void *)(v164 - 24)) = v162;
  v195.__r_.__value_.__l.__size_ = 0;
  id v72 = (std::ios_base *)((char *)&v195 + *(void *)(v195.__r_.__value_.__r.__words[0] - 24));
  std::ios_base::init(v72, v196);
  v72[1].__vftable = 0;
  v72[1].__fmtflags_ = -1;
  std::string::size_type v73 = v20[5];
  std::string::size_type v155 = v20[4];
  v195.__r_.__value_.__r.__words[2] = v155;
  std::string::size_type v160 = v73;
  std::string::size_type v74 = v73;
  *(std::string::size_type *)((char *)&v195.__r_.__value_.__r.__words[2] + *(void *)(v155 - 24)) = v73;
  time_t v158 = v20[1];
  v195.__r_.__value_.__r.__words[0] = v158;
  std::string::size_type v75 = v20[6];
  *(std::string::size_type *)((char *)v195.__r_.__value_.__r.__words + *(void *)(v158 - 24)) = v75;
  v204[0] = v70;
  v195.__r_.__value_.__r.__words[0] = v69;
  v195.__r_.__value_.__r.__words[2] = v71;
  std::streambuf::basic_streambuf();
  uint64_t v76 = MEMORY[0x1E4FBA470] + 16;
  v196[0] = MEMORY[0x1E4FBA470] + 16;
  long long v202 = 0u;
  long long v201 = 0u;
  int v203 = 24;
  *(void *)((char *)&v196[1] + *(void *)(v195.__r_.__value_.__r.__words[2] - 24)) = __formatc;
  size_t v77 = strlen((const char *)&v205);
  sub_1D0E25008(&v195.__r_.__value_.__r.__words[2], (uint64_t)&v205, v77);
  std::string::size_type v149 = v74;
  if ((v203 & 0x10) != 0)
  {
    unint64_t v80 = *((void *)&v202 + 1);
    if (*((void *)&v202 + 1) < v200)
    {
      *((void *)&v202 + 1) = v200;
      unint64_t v80 = v200;
    }
    uint64_t v81 = (const void **)&v199;
  }
  else
  {
    if ((v203 & 8) == 0)
    {
      size_t v78 = 0;
      HIBYTE(v186) = 0;
      p_t = &__t;
      goto LABEL_104;
    }
    uint64_t v81 = (const void **)v197;
    unint64_t v80 = v198;
  }
  uint64_t v82 = *v81;
  size_t v78 = v80 - (void)*v81;
  if (v78 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_230;
  }
  if (v78 >= 0x17)
  {
    uint64_t v83 = (v78 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v78 | 7) != 0x17) {
      uint64_t v83 = v78 | 7;
    }
    uint64_t v84 = v83 + 1;
    p_t = operator new(v83 + 1);
    size_t v185 = v78;
    int64_t v186 = v84 | 0x8000000000000000;
    __t.__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000>>::rep)p_t;
    goto LABEL_103;
  }
  HIBYTE(v186) = v80 - *(unsigned char *)v81;
  p_t = &__t;
  if (v78) {
LABEL_103:
  }
    memmove(p_t, v82, v78);
LABEL_104:
  *((unsigned char *)p_t + v78) = 0;
  time_t v152 = *MEMORY[0x1E4FBA408];
  v195.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4FBA408];
  time_t v85 = v195.__r_.__value_.__r.__words[0];
  std::string::size_type v86 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  __formata = *(char **)(MEMORY[0x1E4FBA408] + 64);
  *(std::string::size_type *)((char *)v195.__r_.__value_.__r.__words
                            + *(void *)(v195.__r_.__value_.__r.__words[0] - 24)) = (std::string::size_type)__formata;
  std::string::size_type v154 = v86;
  std::string::size_type v87 = v86;
  v195.__r_.__value_.__r.__words[2] = v86;
  v196[0] = v76;
  if (SBYTE7(v202) < 0) {
    operator delete((void *)v201);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D25F1640](v204);
  time_t __dst = v85;
  *(time_t *)((char *)&__dst + *(void *)(v85 - 24)) = (time_t)__formata;
  int64_t v189 = v87;
  v190[0] = v170;
  Float64 v88 = v179;
  if (SBYTE7(v192) < 0) {
    operator delete((void *)v191);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D25F1640](v194);
  if (v186 >= 0) {
    uint64_t rep = (uint64_t)&__t;
  }
  else {
    uint64_t rep = __t.__d_.__rep_;
  }
  if (v186 >= 0) {
    uint64_t v90 = HIBYTE(v186);
  }
  else {
    uint64_t v90 = v185;
  }
  sub_1D0E25008(v179, rep, v90);
  uint64_t v91 = v178;
  if (SHIBYTE(v186) < 0)
  {
    operator delete((void *)__t.__d_.__rep_);
    if (!a6) {
      goto LABEL_219;
    }
  }
  else if (!a6)
  {
    goto LABEL_219;
  }
  if (!*(unsigned char *)(*(void *)*v166 + 1)) {
    goto LABEL_219;
  }
  size_t v92 = strlen(a6);
  if (v92 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_230;
  }
  size_t v93 = v92;
  if (v92 >= 0x17)
  {
    uint64_t v95 = (v92 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v92 | 7) != 0x17) {
      uint64_t v95 = v92 | 7;
    }
    uint64_t v96 = v95 + 1;
    float32x4_t v94 = operator new(v95 + 1);
    size_t v181 = v93;
    int64_t v182 = v96 | 0x8000000000000000;
    uint64_t v180 = v94;
    goto LABEL_126;
  }
  HIBYTE(v182) = v92;
  float32x4_t v94 = &v180;
  if (v92) {
LABEL_126:
  }
    memcpy(v94, a6, v93);
  *((unsigned char *)v94 + v93) = 0;
  long long v97 = (char *)&v180;
  int v98 = v180;
  size_t v99 = v181;
  if (v182 >= 0) {
    size_t v99 = HIBYTE(v182);
  }
  else {
    long long v97 = (char *)v180;
  }
  do
  {
    if (!v99) {
      goto LABEL_141;
    }
    int v100 = v97[--v99];
  }
  while (v100 != 92 && v100 != 47);
  if (v99 == -1) {
    goto LABEL_141;
  }
  if (SHIBYTE(v182) < 0)
  {
    if (v99 == -2)
    {
      size_t v181 = 0;
      goto LABEL_140;
    }
LABEL_138:
    sub_1D0DC8350(&v180, 0, v99 + 1);
    goto LABEL_141;
  }
  if (v99 != -2) {
    goto LABEL_138;
  }
  HIBYTE(v182) = 0;
  int v98 = &v180;
LABEL_140:
  *int v98 = 0;
LABEL_141:
  time_t v101 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v102 = MEMORY[0x1E4FBA488] + 104;
  v194[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v103 = MEMORY[0x1E4FBA488] + 64;
  int64_t v189 = MEMORY[0x1E4FBA488] + 64;
  time_t __dst = v164;
  *(time_t *)((char *)&__dst + *(void *)(v164 - 24)) = v162;
  size_t v188 = 0;
  int v104 = (std::ios_base *)((char *)&__dst + *(void *)(__dst - 24));
  std::ios_base::init(v104, v190);
  v104[1].__vftable = 0;
  v104[1].__fmtflags_ = -1;
  int64_t v189 = v155;
  *(void *)((char *)&v190[-1] + *(void *)(v155 - 24)) = v149;
  time_t __dst = v158;
  *(time_t *)((char *)&__dst + *(void *)(v158 - 24)) = v75;
  v194[0] = v102;
  time_t __dst = v101;
  int64_t v189 = v103;
  std::streambuf::basic_streambuf();
  uint64_t v150 = MEMORY[0x1E4FBA470] + 16;
  v190[0] = MEMORY[0x1E4FBA470] + 16;
  long long v191 = 0u;
  long long v192 = 0u;
  int v193 = 24;
  uint64_t v172 = *(int *)((char *)&v190[-1] + *(void *)(__dst - 24));
  uint64_t v105 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v106 = MEMORY[0x1E4FBA488] + 104;
  v204[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v107 = MEMORY[0x1E4FBA488] + 64;
  v195.__r_.__value_.__r.__words[2] = MEMORY[0x1E4FBA488] + 64;
  v195.__r_.__value_.__r.__words[0] = v164;
  *(std::string::size_type *)((char *)v195.__r_.__value_.__r.__words + *(void *)(v164 - 24)) = v162;
  v195.__r_.__value_.__l.__size_ = 0;
  long long v108 = (std::ios_base *)((char *)&v195 + *(void *)(v195.__r_.__value_.__r.__words[0] - 24));
  std::ios_base::init(v108, v196);
  v108[1].__vftable = 0;
  v108[1].__fmtflags_ = -1;
  v195.__r_.__value_.__r.__words[2] = v155;
  *(std::string::size_type *)((char *)&v195.__r_.__value_.__r.__words[2] + *(void *)(v155 - 24)) = v160;
  v195.__r_.__value_.__r.__words[0] = v158;
  *(std::string::size_type *)((char *)v195.__r_.__value_.__r.__words + *(void *)(v158 - 24)) = v75;
  v204[0] = v106;
  v195.__r_.__value_.__r.__words[0] = v105;
  v195.__r_.__value_.__r.__words[2] = v107;
  std::streambuf::basic_streambuf();
  uint64_t v109 = MEMORY[0x1E4FBA470] + 16;
  v196[0] = MEMORY[0x1E4FBA470] + 16;
  long long v202 = 0u;
  long long v201 = 0u;
  int v203 = 24;
  *(void *)((char *)&v196[1] + *(void *)(v195.__r_.__value_.__r.__words[2] - 24)) = v172;
  sub_1D0E25008(&v195.__r_.__value_.__r.__words[2], (uint64_t)"\t\t[", 3);
  if ((v203 & 0x10) != 0)
  {
    unint64_t v112 = *((void *)&v202 + 1);
    if (*((void *)&v202 + 1) < v200)
    {
      *((void *)&v202 + 1) = v200;
      unint64_t v112 = v200;
    }
    long long v113 = (const void **)&v199;
  }
  else
  {
    if ((v203 & 8) == 0)
    {
      size_t v110 = 0;
      HIBYTE(v186) = 0;
      long long v111 = &__t;
      goto LABEL_156;
    }
    long long v113 = (const void **)v197;
    unint64_t v112 = v198;
  }
  int v114 = *v113;
  size_t v110 = v112 - (void)*v113;
  if (v110 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_230;
  }
  if (v110 >= 0x17)
  {
    uint64_t v115 = (v110 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v110 | 7) != 0x17) {
      uint64_t v115 = v110 | 7;
    }
    uint64_t v116 = v115 + 1;
    long long v111 = operator new(v115 + 1);
    size_t v185 = v110;
    int64_t v186 = v116 | 0x8000000000000000;
    __t.__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000>>::rep)v111;
    goto LABEL_155;
  }
  HIBYTE(v186) = v112 - *(unsigned char *)v113;
  long long v111 = &__t;
  if (v110) {
LABEL_155:
  }
    memmove(v111, v114, v110);
LABEL_156:
  *((unsigned char *)v111 + v110) = 0;
  v195.__r_.__value_.__r.__words[0] = v152;
  *(std::string::size_type *)((char *)v195.__r_.__value_.__r.__words + *(void *)(v152 - 24)) = (std::string::size_type)__formata;
  v195.__r_.__value_.__r.__words[2] = v154;
  v196[0] = v109;
  if (SBYTE7(v202) < 0) {
    operator delete((void *)v201);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D25F1640](v204);
  time_t __dst = v152;
  *(time_t *)((char *)&__dst + *(void *)(v152 - 24)) = (time_t)__formata;
  int64_t v189 = v154;
  v190[0] = v150;
  long long v117 = v179;
  if (SBYTE7(v192) < 0) {
    operator delete((void *)v191);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D25F1640](v194);
  if (v186 >= 0) {
    uint64_t v118 = (uint64_t)&__t;
  }
  else {
    uint64_t v118 = __t.__d_.__rep_;
  }
  if (v186 >= 0) {
    uint64_t v119 = HIBYTE(v186);
  }
  else {
    uint64_t v119 = v185;
  }
  sub_1D0E25008(v117, v118, v119);
  if (SHIBYTE(v186) < 0) {
    operator delete((void *)__t.__d_.__rep_);
  }
  sub_1D0E5CAF0(&v195, (uint64_t)&v180);
  if ((v195.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v120 = &v195;
  }
  else {
    uint64_t v120 = (std::string *)v195.__r_.__value_.__r.__words[0];
  }
  if ((v195.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v121 = HIBYTE(v195.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v121 = v195.__r_.__value_.__l.__size_;
  }
  sub_1D0E25008(v117, (uint64_t)v120, v121);
  if (SHIBYTE(v195.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v195.__r_.__value_.__l.__data_);
  }
  sub_1D0E5D960(&v195, " ");
  if ((v195.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v122 = &v195;
  }
  else {
    uint64_t v122 = (std::string *)v195.__r_.__value_.__r.__words[0];
  }
  if ((v195.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v123 = HIBYTE(v195.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v123 = v195.__r_.__value_.__l.__size_;
  }
  sub_1D0E25008(v117, (uint64_t)v122, v123);
  if (SHIBYTE(v195.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v195.__r_.__value_.__l.__data_);
  }
  time_t v124 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v125 = MEMORY[0x1E4FBA488] + 104;
  v194[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v126 = MEMORY[0x1E4FBA488] + 64;
  int64_t v189 = MEMORY[0x1E4FBA488] + 64;
  time_t __dst = v164;
  *(time_t *)((char *)&__dst + *(void *)(v164 - 24)) = v162;
  size_t v188 = 0;
  int v127 = (std::ios_base *)((char *)&__dst + *(void *)(__dst - 24));
  std::ios_base::init(v127, v190);
  v127[1].__vftable = 0;
  v127[1].__fmtflags_ = -1;
  int64_t v189 = v155;
  *(void *)((char *)&v190[-1] + *(void *)(v155 - 24)) = v160;
  time_t __dst = v158;
  *(time_t *)((char *)&__dst + *(void *)(v158 - 24)) = v75;
  v194[0] = v125;
  time_t __dst = v124;
  int64_t v189 = v126;
  std::streambuf::basic_streambuf();
  unint64_t v167 = (char *)(MEMORY[0x1E4FBA470] + 16);
  v190[0] = MEMORY[0x1E4FBA470] + 16;
  long long v191 = 0u;
  long long v192 = 0u;
  int v193 = 24;
  uint64_t v128 = *(int *)((char *)&v190[-1] + *(void *)(__dst - 24));
  uint64_t v129 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v130 = MEMORY[0x1E4FBA488] + 104;
  v204[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v131 = MEMORY[0x1E4FBA488] + 64;
  v195.__r_.__value_.__r.__words[2] = MEMORY[0x1E4FBA488] + 64;
  v195.__r_.__value_.__r.__words[0] = v164;
  *(std::string::size_type *)((char *)v195.__r_.__value_.__r.__words + *(void *)(v164 - 24)) = v162;
  v195.__r_.__value_.__l.__size_ = 0;
  int v132 = (std::ios_base *)((char *)&v195 + *(void *)(v195.__r_.__value_.__r.__words[0] - 24));
  std::ios_base::init(v132, v196);
  v132[1].__vftable = 0;
  v132[1].__fmtflags_ = -1;
  v195.__r_.__value_.__r.__words[2] = v155;
  *(std::string::size_type *)((char *)&v195.__r_.__value_.__r.__words[2] + *(void *)(v155 - 24)) = v160;
  v195.__r_.__value_.__r.__words[0] = v158;
  *(std::string::size_type *)((char *)v195.__r_.__value_.__r.__words + *(void *)(v158 - 24)) = v75;
  v204[0] = v130;
  v195.__r_.__value_.__r.__words[0] = v129;
  v195.__r_.__value_.__r.__words[2] = v131;
  std::streambuf::basic_streambuf();
  uint64_t v133 = MEMORY[0x1E4FBA470] + 16;
  v196[0] = MEMORY[0x1E4FBA470] + 16;
  long long v202 = 0u;
  long long v201 = 0u;
  int v203 = 24;
  *(void *)((char *)&v196[1] + *(void *)(v195.__r_.__value_.__r.__words[2] - 24)) = v128;
  std::ostream::operator<<();
  if ((v203 & 0x10) != 0)
  {
    unint64_t v136 = *((void *)&v202 + 1);
    if (*((void *)&v202 + 1) < v200)
    {
      *((void *)&v202 + 1) = v200;
      unint64_t v136 = v200;
    }
    uint64_t v137 = (const void **)&v199;
  }
  else
  {
    if ((v203 & 8) == 0)
    {
      size_t v134 = 0;
      HIBYTE(v186) = 0;
      uint64_t v135 = &__t;
      Float64 v88 = v179;
      goto LABEL_199;
    }
    uint64_t v137 = (const void **)v197;
    unint64_t v136 = v198;
  }
  int v138 = *v137;
  size_t v134 = v136 - (void)*v137;
  if (v134 > 0x7FFFFFFFFFFFFFF7) {
LABEL_230:
  }
    abort();
  if (v134 >= 0x17)
  {
    uint64_t v139 = (v134 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v134 | 7) != 0x17) {
      uint64_t v139 = v134 | 7;
    }
    uint64_t v140 = v139 + 1;
    uint64_t v135 = operator new(v139 + 1);
    size_t v185 = v134;
    int64_t v186 = v140 | 0x8000000000000000;
    __t.__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000>>::rep)v135;
    Float64 v88 = v179;
  }
  else
  {
    HIBYTE(v186) = v136 - *(unsigned char *)v137;
    uint64_t v135 = &__t;
    Float64 v88 = v179;
    if (!v134) {
      goto LABEL_199;
    }
  }
  memmove(v135, v138, v134);
LABEL_199:
  *((unsigned char *)v135 + v134) = 0;
  v195.__r_.__value_.__r.__words[0] = v152;
  *(std::string::size_type *)((char *)v195.__r_.__value_.__r.__words + *(void *)(v152 - 24)) = (std::string::size_type)__formata;
  v195.__r_.__value_.__r.__words[2] = v154;
  v196[0] = v133;
  if (SBYTE7(v202) < 0) {
    operator delete((void *)v201);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D25F1640](v204);
  time_t __dst = v152;
  *(time_t *)((char *)&__dst + *(void *)(v152 - 24)) = (time_t)__formata;
  int64_t v189 = v154;
  v190[0] = v167;
  if (SBYTE7(v192) < 0) {
    operator delete((void *)v191);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D25F1640](v194);
  if (v186 >= 0) {
    uint64_t v141 = (uint64_t)&__t;
  }
  else {
    uint64_t v141 = __t.__d_.__rep_;
  }
  if (v186 >= 0) {
    uint64_t v142 = HIBYTE(v186);
  }
  else {
    uint64_t v142 = v185;
  }
  sub_1D0E25008(v88, v141, v142);
  uint64_t v91 = v178;
  if (SHIBYTE(v186) < 0) {
    operator delete((void *)__t.__d_.__rep_);
  }
  sub_1D0E5D960(&v195, "]");
  if ((v195.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    float32x4_t v143 = &v195;
  }
  else {
    float32x4_t v143 = (std::string *)v195.__r_.__value_.__r.__words[0];
  }
  if ((v195.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v144 = HIBYTE(v195.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v144 = v195.__r_.__value_.__l.__size_;
  }
  sub_1D0E25008(v88, (uint64_t)v143, v144);
  if (SHIBYTE(v195.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v195.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v182) & 0x80000000) == 0) {
      goto LABEL_219;
    }
  }
  else if ((SHIBYTE(v182) & 0x80000000) == 0)
  {
    goto LABEL_219;
  }
  operator delete(v180);
LABEL_219:
  sub_1D0E5D960(&v195, "\n");
  if ((v195.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    float32x4_t v145 = &v195;
  }
  else {
    float32x4_t v145 = (std::string *)v195.__r_.__value_.__r.__words[0];
  }
  if ((v195.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v146 = HIBYTE(v195.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v146 = v195.__r_.__value_.__l.__size_;
  }
  sub_1D0E25008(v88, (uint64_t)v145, v146);
  if (SHIBYTE(v195.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v195.__r_.__value_.__l.__data_);
  }
  return v91;
}