uint64_t sub_18E14BA68(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  _WORD v11[16];
  _OWORD *v12;
  void *v13;
  long long v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;

  if (*(unsigned char *)(a1 + 1))
  {
    if (*(_DWORD *)(a1 + 12704))
    {
      v9 = a1 + 4680;
      sub_18E14E3A8((uint64_t)v11);
      v15 = 0x10000002CLL;
      v13 = &unk_1EDD19188;
      v14 = xmmword_18E21A0B0;
      v16 = &v17;
      sub_18E09183C(v9, (uint64_t)v11, (uint64_t)&v13);
      result = 0;
      *a2 = *v12;
      return result;
    }
  }
  else
  {
    LOBYTE(v13) = 2;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v11, (unsigned __int8 *)&v13, "WARNING: MeasurementAccumulator.LatestLockedMeasurementTime() called on unlocked accumulator.", a4, a5, a6, a7, a8, 2);
  }
  return 0xFFFFFFFFLL;
}

void sub_18E14BB40(uint64_t a1, __n128 *a2)
{
  if (*(unsigned char *)a1)
  {
    if (*(unsigned char *)(a1 + 1)) {
      *(unsigned char *)(a1 + 1) = 0;
    }
    if (*(_DWORD *)(a1 + 3184))
    {
      if (!sub_18DEE8C5C(a2->n128_f64, (double *)(a1 + 8)))
      {
        unint64_t v4 = *(unsigned int *)(a1 + 3184);
        uint64_t v50 = 0x100000058;
        v51 = 0;
        int32x4_t v49 = 0uLL;
        v48 = &unk_1EDD19C08;
        if ((v4 & 0x80000000) == 0)
        {
          unsigned int v5 = 0;
          int32x4_t v6 = vdupq_lane_s32((int32x2_t)(v4 | 0x100000000), 0);
          v6.i32[1] = 1;
          int32x4_t v49 = v6;
          v51 = &v52;
          if (v4)
          {
            v7 = *(void **)(a1 + 48);
            if (v7 != (void *)(a1 + 40))
            {
              uint64_t v8 = 0;
              unsigned int v5 = 0;
              unint64_t v9 = 1;
              do
              {
                if (sub_18DEE4C00((double *)(*(void *)(a1 + 96) + v8), a2->n128_f64))
                {
                  *((_DWORD *)v51 + (int)v5) = v9 - 1;
                  v7 = (void *)v7[1];
                  ++v5;
                }
                else
                {
                  v10 = (void *)*v7;
                  v11 = (void *)v7[1];
                  v10[1] = v11;
                  *(void *)v7[1] = v10;
                  --*(void *)(a1 + 56);
                  sub_18E067C60((uint64_t (**)(void, void, void, void, void))v7 + 2);
                  operator delete(v7);
                  v7 = v11;
                }
                if (v9 >= v4) {
                  break;
                }
                ++v9;
                v8 += 16;
              }
              while (v7 != (void *)(a1 + 40));
            }
          }
          int32x4_t v12 = vdupq_lane_s32((int32x2_t)(v5 | 0x100000000), 0);
          v12.i32[1] = 1;
          int32x4_t v49 = v12;
          if (v5 <= 1) {
            int v13 = 1;
          }
          else {
            int v13 = v5;
          }
          if (!v5) {
            int v13 = 0;
          }
          *(_DWORD *)(a1 + 3184) = v13;
          sub_18E14E1F4((uint64_t)v34);
          *(void *)v34 = &unk_1EDD16D58;
          v42[82] = a1 + 64;
          uint64_t v45 = 0x100000058;
          v43 = &unk_1EDD19C08;
          long long v44 = xmmword_18E21A0A0;
          v46 = &v47;
          sub_18DFEEA3C((uint64_t)&v43, (uint64_t)&v48);
          *(void *)&v34[8] = v44;
          *(_DWORD *)&v34[16] = DWORD1(v44) * v44;
          *(_DWORD *)&v34[20] = v44;
          if (DWORD1(v44) * (int)v44 >= 1)
          {
            uint64_t v14 = 0;
            uint64_t v15 = 0;
            uint64_t v16 = 4 * (DWORD1(v44) * v44);
            do
            {
              *(_OWORD *)&v36[v14] = *(_OWORD *)(*(void *)(a1 + 96) + 16 * *(int *)((char *)v46 + v15));
              v15 += 4;
              v14 += 2;
            }
            while (v16 != v15);
          }
          sub_18E092018(a1 + 64, (uint64_t)v34);
          sub_18E1598A4((uint64_t)v34, a1 + 1512, (uint64_t)&v48);
          sub_18DFEEA3C(a1 + 1512, (uint64_t)v34);
          uint64_t v35 = 0x100000058;
          *(_OWORD *)&v34[8] = xmmword_18E21A0A0;
          v36 = v37;
          *(void *)v34 = &unk_1EDD16E18;
          v37[88] = a1 + 1904;
          uint64_t v40 = 0x100000058;
          v38 = &unk_1EDD19C08;
          long long v39 = xmmword_18E21A0A0;
          v41 = (int *)v42;
          sub_18DFEEA3C((uint64_t)&v38, (uint64_t)&v48);
          *(void *)&v34[8] = v39;
          uint64_t v17 = (DWORD1(v39) * v39);
          *(_DWORD *)&v34[16] = v17;
          *(_DWORD *)&v34[20] = v39;
          if ((int)v17 >= 1)
          {
            uint64_t v18 = *(void *)(a1 + 1936);
            v19 = v41;
            v20 = v36;
            do
            {
              uint64_t v21 = *v19++;
              *v20++ = *(void *)(v18 + 8 * v21);
              --v17;
            }
            while (v17);
          }
          sub_18DFE2F24(a1 + 1904, (uint64_t)v34);
          sub_18E159A28((uint64_t)v34);
        }
        __assert_rtn("CNMatrix", "cnmatrix.h", 419, "nr >= 0");
      }
    }
    else
    {
      *(_OWORD *)v34 = *(_OWORD *)(a1 + 8);
      sub_18E147D28(a1);
      sub_18E059804(a1, a2, v22, v23, v24, v25, v26, v27);
      *(unsigned char *)a1 = 0;
      sub_18E059804(a1, (__n128 *)v34, v28, v29, v30, v31, v32, v33);
    }
  }
}

void *sub_18E14C244(void *result)
{
  *result = &unk_1EDD17418;
  return result;
}

void *sub_18E14C264(void *result)
{
  *result = &unk_1EDD17268;
  return result;
}

void *sub_18E14C284(void *result)
{
  *result = &unk_1EDD17238;
  return result;
}

std::string *raven::RavenIonosphereEstimator::SetLogPrefix(uint64_t a1, const std::string *a2)
{
  std::string::operator=((std::string *)(a1 + 3840), a2);

  return std::string::operator=((std::string *)(a1 + 6232), a2);
}

void *sub_18E14C2EC(void *result)
{
  *result = &unk_1EDD17478;
  return result;
}

void *sub_18E14C30C(void *result)
{
  *result = &unk_1EDD17478;
  return result;
}

uint64_t *sub_18E14C32C(uint64_t *a1)
{
  uint64_t v2 = 0;
  a1[1638] = (uint64_t)&unk_1EDD173E8;
  a1[1589] = (uint64_t)&unk_1EDD17208;
  do
  {
    a1[v2 + 1582] = (uint64_t)&unk_1EDD17478;
    v2 -= 6;
  }
  while (v2 != -264);
  uint64_t v3 = 0;
  a1[1319] = (uint64_t)&unk_1EDD16F68;
  do
  {
    a1[v3 + 1313] = (uint64_t)&unk_1EDD17478;
    v3 -= 6;
  }
  while (v3 != -264);
  uint64_t v4 = 0;
  a1[1050] = (uint64_t)&unk_1EDD16F68;
  a1[1023] = (uint64_t)&unk_1EDD174A8;
  do
  {
    a1[v4 + 1017] = (uint64_t)&unk_1EDD17478;
    v4 -= 6;
  }
  while (v4 != -264);
  a1[754] = (uint64_t)&unk_1EDD16F68;
  a1[705] = (uint64_t)&unk_1EDD17478;
  a1[678] = (uint64_t)&unk_1EDD174A8;
  a1[585] = (uint64_t)&unk_1EDD16ED8;
  a1[492] = (uint64_t)&unk_1EDD173E8;
  a1[399] = (uint64_t)&unk_1EDD17208;
  a1[392] = (uint64_t)&unk_1EDD19B48;
  sub_18E14D524(a1 + 397);
  a1[392] = (uint64_t)&unk_1EDD16F68;
  a1[386] = (uint64_t)&unk_1EDD19B48;
  sub_18E14D524(a1 + 391);
  a1[386] = (uint64_t)&unk_1EDD16F68;
  a1[337] = (uint64_t)&unk_1EDD174A8;
  a1[331] = (uint64_t)&unk_1EDD19B48;
  sub_18E14D524(a1 + 336);
  a1[331] = (uint64_t)&unk_1EDD16F68;
  a1[238] = (uint64_t)&unk_1EDD17478;
  a1[189] = (uint64_t)&unk_1EDD174A8;
  a1[8] = (uint64_t)&unk_1EDD16ED8;
  sub_18E067BEC(a1 + 5);
  return a1;
}

void *sub_18E14C6E8(void *result)
{
  *result = &unk_1EDD173E8;
  return result;
}

void *sub_18E14C708(void *result)
{
  *result = &unk_1EDD17208;
  return result;
}

void *sub_18E14C728(void *result)
{
  for (uint64_t i = 263; i != -1; i -= 6)
    result[i] = &unk_1EDD17478;
  *result = &unk_1EDD16F68;
  return result;
}

void *sub_18E14C778(void *result)
{
  *result = &unk_1EDD174A8;
  return result;
}

void *sub_18E14C798(void *result)
{
  *result = &unk_1EDD17478;
  return result;
}

void *sub_18E14C7B8(void *result)
{
  *result = &unk_1EDD16ED8;
  return result;
}

void *sub_18E14C7D8(void *result)
{
  *result = &unk_1EDD173E8;
  return result;
}

void *sub_18E14C7F8(void *result)
{
  *result = &unk_1EDD17208;
  return result;
}

void *sub_18E14C818(void *a1)
{
  *a1 = &unk_1EDD19B48;
  sub_18E14D524(a1 + 5);
  *a1 = &unk_1EDD16F68;
  return a1;
}

void *sub_18E14C87C(void *result)
{
  *result = &unk_1EDD174A8;
  return result;
}

void *sub_18E14C89C(void *result)
{
  *result = &unk_1EDD17478;
  return result;
}

void *sub_18E14C8BC(void *result)
{
  *result = &unk_1EDD16ED8;
  return result;
}

void sub_18E14C8DC(void *a1)
{
  *a1 = &unk_1EDD173E8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14C90C(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14C918(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = 1;
        do
        {
          uint64_t v8 = &v13[v7];
          if (!v13[v7])
          {
            uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8 * v7);
            int v10 = v7;
            do
            {
              int v10 = (int)(v10 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v11 = *(void *)(a1 + 32);
              uint64_t v12 = *(void *)(v11 + 8 * v10);
              *(void *)(v11 + 8 * v10) = v9;
              *uint64_t v8 = 1;
              uint64_t v8 = &v13[v10];
              uint64_t v9 = v12;
            }
            while (!*v8);
          }
          ++v7;
        }
        while (v7 != v6);
      }
    }
  }
}

void sub_18E14CA14(void *a1)
{
  *a1 = &unk_1EDD17208;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14CA44(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14CA50(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = 1;
        do
        {
          uint64_t v8 = &v13[v7];
          if (!v13[v7])
          {
            uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8 * v7);
            int v10 = v7;
            do
            {
              int v10 = (int)(v10 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v11 = *(void *)(a1 + 32);
              uint64_t v12 = *(void *)(v11 + 8 * v10);
              *(void *)(v11 + 8 * v10) = v9;
              *uint64_t v8 = 1;
              uint64_t v8 = &v13[v10];
              uint64_t v9 = v12;
            }
            while (!*v8);
          }
          ++v7;
        }
        while (v7 != v6);
      }
    }
  }
}

void sub_18E14CB54(void *a1)
{
  for (uint64_t i = 263; i != -1; i -= 6)
    a1[i] = &unk_1EDD17478;
  *a1 = &unk_1EDD16F68;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14CBB4(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14CBC0(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        int v6 = v3 + v1 - v5;
        uint64_t v7 = (v4 - 1);
        uint64_t v8 = 1;
        do
        {
          sub_18E14CD0C((uint64_t)v12, *(void *)(a1 + 32) + 48 * v8);
          uint64_t v9 = &v13[v8];
          if (!v13[v8])
          {
            int v10 = v8;
            do
            {
              int v10 = v10 * v6 % (int)v7;
              sub_18E14CD0C((uint64_t)v11, *(void *)(a1 + 32) + 48 * v10);
              sub_18DFE2F24(*(void *)(a1 + 32) + 48 * v10, (uint64_t)v12);
              *uint64_t v9 = 1;
              sub_18DFE2F24((uint64_t)v12, (uint64_t)v11);
              uint64_t v9 = &v13[v10];
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v7);
      }
    }
  }
}

__n128 sub_18E14CD0C(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0x100000001;
  *(void *)(a1 + 24) = 0x100000001;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EDD18048;
  if (a1 == a2)
  {
    uint64_t v17 = "this != &(A)";
    int v18 = 603;
    goto LABEL_16;
  }
  int v3 = *(_DWORD *)(a2 + 8);
  int v4 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = (v4 * v3);
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  int v6 = (unint64_t *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 1u)
  {
    uint64_t v17 = "this->max_num_rows_ >= A.num_rows_";
    int v18 = 616;
    goto LABEL_16;
  }
  if (*(_DWORD *)(a2 + 12) >= 2u)
  {
    uint64_t v17 = "this->max_num_cols_ >= A.num_cols_";
    int v18 = 617;
LABEL_16:
    __assert_rtn("CNMatrix", "cnmatrix.h", v18, v17);
  }
  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    uint64_t v11 = *(long long **)(a2 + 32);
    uint64_t v12 = (v7 - 1) >> 1;
    int v13 = v11;
    uint64_t v14 = (_OWORD *)(a1 + 40);
    do
    {
      long long v15 = *v13++;
      *v14++ = v15;
      --v12;
    }
    while (v12);
    uint64_t v16 = v10;
    __n128 result = *(__n128 *)((char *)v11 + v16 * 8);
    *(__n128 *)&v6[v16] = result;
  }
  else if ((int)v5 >= 1)
  {
    uint64_t v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *v6++ = v9;
      --v5;
    }
    while (v5);
  }
  return result;
}

void sub_18E14CE38(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

void sub_18E14CE58(void *a1)
{
  *a1 = &unk_1EDD174A8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14CE88(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14CE94(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unint64_t v9 = &v13[v8];
          if (!v13[v8])
          {
            int v10 = *(_DWORD *)(v7 + 4 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              int v12 = *(_DWORD *)(v7 + 4 * v11);
              *(_DWORD *)(v7 + 4 * v11) = v10;
              *unint64_t v9 = 1;
              unint64_t v9 = &v13[v11];
              int v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void sub_18E14CF8C(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14CFBC(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14CFC8(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unint64_t v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *unint64_t v9 = 1;
              unint64_t v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void sub_18E14D0C0(void *a1)
{
  *a1 = &unk_1EDD16ED8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14D0F0(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14D0FC(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = 1;
        do
        {
          long long v12 = *(_OWORD *)(*(void *)(a1 + 32) + 16 * v7);
          uint64_t v8 = &v13[v7];
          if (!v13[v7])
          {
            int v9 = v7;
            do
            {
              int v9 = (int)(v9 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v10 = *(void *)(a1 + 32);
              long long v11 = *(_OWORD *)(v10 + 16 * v9);
              *(_OWORD *)(v10 + 16 * v9) = v12;
              *uint64_t v8 = 1;
              long long v12 = v11;
              uint64_t v8 = &v13[v9];
            }
            while (!*v8);
          }
          ++v7;
        }
        while (v7 != v6);
      }
    }
  }
}

void sub_18E14D200(void *a1)
{
  *a1 = &unk_1EDD173E8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14D230(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14D23C(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = 1;
        do
        {
          uint64_t v8 = &v13[v7];
          if (!v13[v7])
          {
            uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8 * v7);
            int v10 = v7;
            do
            {
              int v10 = (int)(v10 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v11 = *(void *)(a1 + 32);
              uint64_t v12 = *(void *)(v11 + 8 * v10);
              *(void *)(v11 + 8 * v10) = v9;
              *uint64_t v8 = 1;
              uint64_t v8 = &v13[v10];
              uint64_t v9 = v12;
            }
            while (!*v8);
          }
          ++v7;
        }
        while (v7 != v6);
      }
    }
  }
}

void sub_18E14D338(void *a1)
{
  *a1 = &unk_1EDD17208;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14D368(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14D374(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = 1;
        do
        {
          uint64_t v8 = &v13[v7];
          if (!v13[v7])
          {
            uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8 * v7);
            int v10 = v7;
            do
            {
              int v10 = (int)(v10 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v11 = *(void *)(a1 + 32);
              uint64_t v12 = *(void *)(v11 + 8 * v10);
              *(void *)(v11 + 8 * v10) = v9;
              *uint64_t v8 = 1;
              uint64_t v8 = &v13[v10];
              uint64_t v9 = v12;
            }
            while (!*v8);
          }
          ++v7;
        }
        while (v7 != v6);
      }
    }
  }
}

void sub_18E14D470(void *a1)
{
  *a1 = &unk_1EDD19B48;
  sub_18E14D524(a1 + 5);
  *a1 = &unk_1EDD16F68;

  JUMPOUT(0x192FA6240);
}

void sub_18E14D4F4()
{
}

uint64_t *sub_18E14D524(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 48 * v2;
      uint64_t v4 = v1 - 48;
      do
      {
        *(void *)(v4 + v3) = &unk_1EDD17478;
        v3 -= 48;
      }
      while (v3);
    }
    JUMPOUT(0x192FA6220);
  }
  return result;
}

void sub_18E14D588()
{
}

uint64_t *sub_18E14D640(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *__n128 result = a2;
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 48 * v3;
      uint64_t v5 = v2 - 48;
      do
      {
        *(void *)(v5 + v4) = &unk_1EDD17478;
        v4 -= 48;
      }
      while (v4);
    }
    JUMPOUT(0x192FA6220);
  }
  return result;
}

void sub_18E14D6A4()
{
}

void sub_18E14D724(_Unwind_Exception *a1)
{
  MEMORY[0x192FA6220](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void sub_18E14D748(uint64_t a1, char *a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= 2)
  {
    unsigned int v4 = *(_DWORD *)(a1 + 12);
    if (v4 >= 2)
    {
      int v6 = *(_DWORD *)(a1 + 20);
      bzero(a2, *(unsigned int *)(a1 + 16));
      int v7 = *(_DWORD *)(a1 + 16);
      if (v7 >= 3)
      {
        int v8 = v4 + v2 - v6;
        uint64_t v9 = (v7 - 1);
        uint64_t v10 = 1;
        do
        {
          sub_18E14CD0C((uint64_t)v14, *(void *)(a1 + 32) + 48 * v10);
          uint64_t v11 = &a2[v10];
          if (!a2[v10])
          {
            int v12 = v10;
            do
            {
              int v12 = v12 * v8 % (int)v9;
              sub_18E14CD0C((uint64_t)v13, *(void *)(a1 + 32) + 48 * v12);
              sub_18DFE2F24(*(void *)(a1 + 32) + 48 * v12, (uint64_t)v14);
              char *v11 = 1;
              sub_18DFE2F24((uint64_t)v14, (uint64_t)v13);
              uint64_t v11 = &a2[v12];
            }
            while (!*v11);
          }
          ++v10;
        }
        while (v10 != v9);
      }
    }
  }
}

void sub_18E14D858(void *a1)
{
  *a1 = &unk_1EDD174A8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14D888(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14D894(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          uint64_t v9 = &v13[v8];
          if (!v13[v8])
          {
            int v10 = *(_DWORD *)(v7 + 4 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              int v12 = *(_DWORD *)(v7 + 4 * v11);
              *(_DWORD *)(v7 + 4 * v11) = v10;
              *uint64_t v9 = 1;
              uint64_t v9 = &v13[v11];
              int v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void sub_18E14D98C(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14D9BC(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14D9C8(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          uint64_t v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *uint64_t v9 = 1;
              uint64_t v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void sub_18E14DAC0(void *a1)
{
  *a1 = &unk_1EDD16ED8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14DAF0(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14DAFC(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = 1;
        do
        {
          long long v12 = *(_OWORD *)(*(void *)(a1 + 32) + 16 * v7);
          uint64_t v8 = &v13[v7];
          if (!v13[v7])
          {
            int v9 = v7;
            do
            {
              int v9 = (int)(v9 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v10 = *(void *)(a1 + 32);
              long long v11 = *(_OWORD *)(v10 + 16 * v9);
              *(_OWORD *)(v10 + 16 * v9) = v12;
              *uint64_t v8 = 1;
              long long v12 = v11;
              uint64_t v8 = &v13[v9];
            }
            while (!*v8);
          }
          ++v7;
        }
        while (v7 != v6);
      }
    }
  }
}

uint64_t sub_18E14DC00(uint64_t a1)
{
  *(void *)a1 = &unk_1EDD0A508;
  if (*(char *)(a1 + 2391) < 0) {
    operator delete(*(void **)(a1 + 2368));
  }
  if (*(char *)(a1 + 2367) < 0) {
    operator delete(*(void **)(a1 + 2344));
  }
  unsigned int v3 = (void **)(a1 + 2320);
  sub_18E0694B8(&v3);
  unsigned int v3 = (void **)(a1 + 2296);
  sub_18E0694B8(&v3);
  unsigned int v3 = (void **)(a1 + 2272);
  sub_18E0694B8(&v3);
  *(void *)(a1 + 2048) = &unk_1EDD17478;
  *(void *)(a1 + 1208) = &unk_1EDD17478;
  *(void *)(a1 + 1088) = &unk_1EDD17478;
  *(void *)(a1 + 968) = &unk_1EDD17478;
  *(void *)(a1 + 128) = &unk_1EDD17478;
  *(void *)(a1 + 8) = &unk_1EDD17478;
  return a1;
}

void sub_18E14DD58(void *a1)
{
  *a1 = &unk_1EDD0A758;
  a1[419] = &unk_1EDD17478;
  a1[404] = &unk_1EDD17478;
  a1[299] = &unk_1EDD17478;
  sub_18E14DC00((uint64_t)a1);

  JUMPOUT(0x192FA6240);
}

double sub_18E14DE0C@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 24) = 0x10000000ALL;
  *(void *)a2 = &unk_1EDD17628;
  *(_OWORD *)(a2 + 8) = xmmword_18E200CF0;
  *(void *)(a2 + 32) = a2 + 40;
  if (*(_DWORD *)(a1 + 2180)) {
    uint64_t v2 = a1 + 2048;
  }
  else {
    uint64_t v2 = a1 + 968;
  }
  *(void *)&double result = sub_18DFE2F24(a2, v2).n128_u64[0];
  return result;
}

double sub_18E14DE64@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 24) = 0xA0000000ALL;
  *(void *)a2 = &unk_1EDD175C8;
  *(_OWORD *)(a2 + 8) = xmmword_18E1FD870;
  *(void *)(a2 + 32) = a2 + 40;
  if (*(_DWORD *)(a1 + 2180)) {
    uint64_t v2 = a1 + 1208;
  }
  else {
    uint64_t v2 = a1 + 128;
  }
  *(void *)&double result = sub_18DFE2F24(a2, v2).n128_u64[0];
  return result;
}

void sub_18E14DEBC(uint64_t a1)
{
  sub_18E14DC00(a1);

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14DEF4(uint64_t a1, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_18DEDE668((unsigned char *)(a1 + 56), *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *(void *)(a1 + 72) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + 56) = v4;
  }
  *(void *)(a1 + 80) = *((void *)a2 + 3);
  memcpy((void *)(a1 + 88), a2 + 2, 0x1A0uLL);
  *(void *)(a1 + 504) = &unk_1EDD0AE58;
  int v5 = (unsigned char *)(a1 + 512);
  if (*((char *)a2 + 479) < 0)
  {
    sub_18DEDE668(v5, *((void **)a2 + 57), *((void *)a2 + 58));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 456);
    *(void *)(a1 + 528) = *((void *)a2 + 59);
    *(_OWORD *)int v5 = v6;
  }
  *(void *)(a1 + 536) = *((void *)a2 + 60);
  long long v7 = *(long long *)((char *)a2 + 488);
  long long v8 = *(long long *)((char *)a2 + 520);
  *(_OWORD *)(a1 + 560) = *(long long *)((char *)a2 + 504);
  *(_OWORD *)(a1 + 576) = v8;
  *(_OWORD *)(a1 + 544) = v7;
  long long v9 = *(long long *)((char *)a2 + 536);
  long long v10 = *(long long *)((char *)a2 + 552);
  long long v11 = *(long long *)((char *)a2 + 584);
  *(_OWORD *)(a1 + 624) = *(long long *)((char *)a2 + 568);
  *(_OWORD *)(a1 + 640) = v11;
  *(_OWORD *)(a1 + 592) = v9;
  *(_OWORD *)(a1 + 608) = v10;
  long long v12 = *(long long *)((char *)a2 + 600);
  long long v13 = *(long long *)((char *)a2 + 616);
  long long v14 = *(long long *)((char *)a2 + 648);
  *(_OWORD *)(a1 + 688) = *(long long *)((char *)a2 + 632);
  *(_OWORD *)(a1 + 704) = v14;
  *(_OWORD *)(a1 + 656) = v12;
  *(_OWORD *)(a1 + 672) = v13;
  long long v15 = *(long long *)((char *)a2 + 664);
  *(void *)(a1 + 736) = *((void *)a2 + 85);
  *(_OWORD *)(a1 + 720) = v15;
  sub_18E06BF24((void *)a1, 32);
  *(void *)a1 = &unk_1EDD15F50;
  return a1;
}

void sub_18E14E040(_Unwind_Exception *exception_object)
{
  *(void *)(v2 + 504) = &unk_1EDD0A9B8;
  if (*(char *)(v2 + 79) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_18E14E088(uint64_t a1)
{
  *(void *)a1 = &unk_1EDD0A4E8;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  *(void *)(a1 + 504) = &unk_1EDD0AE58;
  if (*(char *)(a1 + 535) < 0) {
    operator delete(*(void **)(a1 + 512));
  }
  *(void *)(a1 + 504) = &unk_1EDD0A9B8;
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }

  JUMPOUT(0x192FA6240);
}

__n128 sub_18E14E154(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1EDD146B8;
  long long v2 = *(_OWORD *)(a2 + 8);
  long long v3 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 24) = v3;
  *(_OWORD *)(a1 + 8) = v2;
  long long v4 = *(_OWORD *)(a2 + 56);
  long long v5 = *(_OWORD *)(a2 + 72);
  long long v6 = *(_OWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 88) = v6;
  *(_OWORD *)(a1 + 72) = v5;
  *(_OWORD *)(a1 + 56) = v4;
  *(void *)(a1 + 120) = &unk_1EDD0B000;
  *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
  __n128 result = *(__n128 *)(a2 + 176);
  *(__n128 *)(a1 + 176) = result;
  *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
  return result;
}

uint64_t sub_18E14E1F4(uint64_t a1)
{
  *(void *)(a1 + 24) = 0x100000058;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EDD19B18;
  for (uint64_t i = 40; i != 1448; i += 16)
  {
    long long v3 = (void *)(a1 + i);
    *long long v3 = 0;
    v3[1] = 0;
  }
  if (!*(_DWORD *)(a1 + 24))
  {
    long long v5 = "this->max_num_rows_ > 0";
    int v6 = 394;
    goto LABEL_8;
  }
  if (!*(_DWORD *)(a1 + 28))
  {
    long long v5 = "this->max_num_cols_ > 0";
    int v6 = 395;
LABEL_8:
    __assert_rtn("CNMatrix", "cnmatrix.h", v6, v5);
  }
  *(_OWORD *)(a1 + 8) = xmmword_18E21A0A0;
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  return a1;
}

void sub_18E14E2D8(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD16ED8;
  _Unwind_Resume(a1);
}

void sub_18E14E2F8(uint64_t a1)
{
  *(void *)(a1 + 24) = 0x100000058;
  *(void *)a1 = &unk_1EDD19B48;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_OWORD *)(a1 + 8) = xmmword_18E21A0A0;
  sub_18E14D588();
}

void sub_18E14E370(_Unwind_Exception *a1)
{
  sub_18E14D524(v2);
  *unsigned int v1 = &unk_1EDD16F68;
  _Unwind_Resume(a1);
}

uint64_t sub_18E14E3A8(uint64_t a1)
{
  *(void *)(a1 + 24) = 0x10000002CLL;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EDD19038;
  for (uint64_t i = 40; i != 744; i += 16)
  {
    long long v3 = (void *)(a1 + i);
    *long long v3 = 0;
    v3[1] = 0;
  }
  if (!*(_DWORD *)(a1 + 24))
  {
    long long v5 = "this->max_num_rows_ > 0";
    int v6 = 394;
    goto LABEL_8;
  }
  if (!*(_DWORD *)(a1 + 28))
  {
    long long v5 = "this->max_num_cols_ > 0";
    int v6 = 395;
LABEL_8:
    __assert_rtn("CNMatrix", "cnmatrix.h", v6, v5);
  }
  *(_OWORD *)(a1 + 8) = xmmword_18E21A0B0;
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  return a1;
}

void sub_18E14E48C(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD16ED8;
  _Unwind_Resume(a1);
}

void *sub_18E14E4AC(void *a1)
{
  uint64_t v2 = 0;
  a1[3] = 0x10000002CLL;
  a1[4] = 0;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDD19068;
  *(void *)&long long v3 = 0x100000001;
  *((void *)&v3 + 1) = 0x100000001;
  do
  {
    long long v4 = &a1[v2];
    v4[8] = 0x100000001;
    v4[5] = &unk_1EDD18048;
    *((_OWORD *)v4 + 3) = v3;
    v4[9] = &a1[v2 + 10];
    v2 += 6;
  }
  while (v2 != 264);
  *(_OWORD *)(a1 + 1) = xmmword_18E21A0B0;
  (*(void (**)(void *))(*a1 + 16))(a1);
  return a1;
}

void sub_18E14E584(_Unwind_Exception *a1)
{
  for (uint64_t i = 263; i != -1; i -= 6)
    v1[i] = &unk_1EDD17478;
  *unsigned int v1 = &unk_1EDD16F68;
  _Unwind_Resume(a1);
}

__n128 sub_18E14E5D4(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0x10000000ALL;
  *(void *)(a1 + 24) = 0x10000000ALL;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EDD17628;
  if (a1 == a2)
  {
    uint64_t v17 = "this != &(A)";
    int v18 = 603;
    goto LABEL_16;
  }
  int v3 = *(_DWORD *)(a2 + 8);
  int v4 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = (v4 * v3);
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  int v6 = (unint64_t *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 0xAu)
  {
    uint64_t v17 = "this->max_num_rows_ >= A.num_rows_";
    int v18 = 616;
    goto LABEL_16;
  }
  if (*(_DWORD *)(a2 + 12) >= 2u)
  {
    uint64_t v17 = "this->max_num_cols_ >= A.num_cols_";
    int v18 = 617;
LABEL_16:
    __assert_rtn("CNMatrix", "cnmatrix.h", v18, v17);
  }
  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    long long v11 = *(long long **)(a2 + 32);
    uint64_t v12 = (v7 - 1) >> 1;
    long long v13 = v11;
    long long v14 = (_OWORD *)(a1 + 40);
    do
    {
      long long v15 = *v13++;
      *v14++ = v15;
      --v12;
    }
    while (v12);
    uint64_t v16 = v10;
    __n128 result = *(__n128 *)((char *)v11 + v16 * 8);
    *(__n128 *)&v6[v16] = result;
  }
  else if ((int)v5 >= 1)
  {
    long long v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *v6++ = v9;
      --v5;
    }
    while (v5);
  }
  return result;
}

void sub_18E14E704(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

uint64_t sub_18E14E724(uint64_t a1)
{
  *(void *)(a1 + 24) = 0xA00000001;
  *(void *)a1 = &unk_1EDD17DA8;
  *(void *)(a1 + 32) = a1 + 40;
  *(_OWORD *)(a1 + 8) = xmmword_18E21A120;
  return sub_18DFE2CC8(a1, 0.0);
}

void *sub_18E14E768(void *result)
{
  *__n128 result = &unk_1EDD17478;
  return result;
}

void sub_18E14E788(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14E7B8(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14E7C4(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unint64_t v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *unint64_t v9 = 1;
              unint64_t v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

__n128 sub_18E14E8BC(void *a1, uint64_t a2)
{
  int v4 = (char *)operator new(0x2E8uLL);
  int v5 = v4;
  if (*(char *)(a2 + 79) < 0)
  {
    sub_18DEDE668(v4 + 56, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    *(_OWORD *)(v4 + 56) = *(_OWORD *)(a2 + 56);
    *((void *)v4 + 9) = *(void *)(a2 + 72);
  }
  *((void *)v5 + 10) = *(void *)(a2 + 80);
  memcpy(v5 + 88, (const void *)(a2 + 88), 0x1A0uLL);
  *((void *)v5 + 63) = &unk_1EDD0AE58;
  uint64_t v6 = v5 + 512;
  if (*(char *)(a2 + 535) < 0)
  {
    sub_18DEDE668(v6, *(void **)(a2 + 512), *(void *)(a2 + 520));
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *(_OWORD *)(a2 + 512);
    *((void *)v5 + 66) = *(void *)(a2 + 528);
  }
  *((void *)v5 + 67) = *(void *)(a2 + 536);
  long long v7 = *(_OWORD *)(a2 + 688);
  *((_OWORD *)v5 + 42) = *(_OWORD *)(a2 + 672);
  *((_OWORD *)v5 + 43) = v7;
  long long v8 = *(_OWORD *)(a2 + 624);
  *((_OWORD *)v5 + 38) = *(_OWORD *)(a2 + 608);
  *((_OWORD *)v5 + 39) = v8;
  long long v9 = *(_OWORD *)(a2 + 656);
  *((_OWORD *)v5 + 40) = *(_OWORD *)(a2 + 640);
  *((_OWORD *)v5 + 41) = v9;
  long long v10 = *(_OWORD *)(a2 + 560);
  *((_OWORD *)v5 + 34) = *(_OWORD *)(a2 + 544);
  *((_OWORD *)v5 + 35) = v10;
  long long v11 = *(_OWORD *)(a2 + 592);
  *((_OWORD *)v5 + 36) = *(_OWORD *)(a2 + 576);
  *((_OWORD *)v5 + 37) = v11;
  long long v12 = *(_OWORD *)(a2 + 720);
  *((_OWORD *)v5 + 44) = *(_OWORD *)(a2 + 704);
  *((_OWORD *)v5 + 45) = v12;
  *((void *)v5 + 92) = *(void *)(a2 + 736);
  *(void *)int v5 = &unk_1EDD0A4E8;
  *((_DWORD *)v5 + 2) = *(_DWORD *)(a2 + 8);
  long long v13 = v5 + 16;
  if (*(char *)(a2 + 39) < 0)
  {
    sub_18DEDE668(v13, *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    *(_OWORD *)long long v13 = *(_OWORD *)(a2 + 16);
    *((void *)v5 + 4) = *(void *)(a2 + 32);
  }
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(v5 + 40) = result;
  *(void *)int v5 = &unk_1EDD15F50;
  *a1 = sub_18E14EAB0;
  a1[1] = v5;
  return result;
}

void sub_18E14EA58(_Unwind_Exception *a1)
{
  sub_18E144530(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_18E14EAB0(unsigned int a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v5 = a1;
  __n128 result = &unk_1EDD06038;
  switch(v5)
  {
    case 1:
      sub_18E14E8BC(a3, a2[1]);
      __n128 result = 0;
      break;
    case 2:
      __n128 result = 0;
      uint64_t v9 = a2[1];
      *a3 = sub_18E14EAB0;
      a3[1] = v9;
      goto LABEL_5;
    case 3:
      if (a4) {
        BOOL v10 = sub_18DEE4C68(a4, (uint64_t)&unk_1EDD06038);
      }
      else {
        BOOL v10 = a5 == &std::__any_imp::__unique_typeinfo<raven::h_GnssGeometryFreePsrArgs_RavenIonosphere>::__id;
      }
      if (v10) {
        __n128 result = (void *)a2[1];
      }
      else {
        __n128 result = 0;
      }
      break;
    case 4:
      return result;
    default:
      long long v8 = (void (***)(void))a2[1];
      (**v8)(v8);
      operator delete(v8);
      __n128 result = 0;
LABEL_5:
      *a2 = 0;
      break;
  }
  return result;
}

__n128 sub_18E14EBB4(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0xA0000000ALL;
  *(void *)(a1 + 24) = 0xA0000000ALL;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EDD175C8;
  if (a1 == a2)
  {
    uint64_t v17 = "this != &(A)";
    int v18 = 603;
    goto LABEL_16;
  }
  int v3 = *(_DWORD *)(a2 + 8);
  int v4 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = (v4 * v3);
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  uint64_t v6 = (unint64_t *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 0xAu)
  {
    uint64_t v17 = "this->max_num_rows_ >= A.num_rows_";
    int v18 = 616;
    goto LABEL_16;
  }
  if (*(_DWORD *)(a2 + 12) >= 0xBu)
  {
    uint64_t v17 = "this->max_num_cols_ >= A.num_cols_";
    int v18 = 617;
LABEL_16:
    __assert_rtn("CNMatrix", "cnmatrix.h", v18, v17);
  }
  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    long long v11 = *(long long **)(a2 + 32);
    uint64_t v12 = (v7 - 1) >> 1;
    long long v13 = v11;
    uint64_t v14 = (_OWORD *)(a1 + 40);
    do
    {
      long long v15 = *v13++;
      *v14++ = v15;
      --v12;
    }
    while (v12);
    uint64_t v16 = v10;
    __n128 result = *(__n128 *)((char *)v11 + v16 * 8);
    *(__n128 *)&v6[v16] = result;
  }
  else if ((int)v5 >= 1)
  {
    long long v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *v6++ = v9;
      --v5;
    }
    while (v5);
  }
  return result;
}

void sub_18E14ECE0(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

uint64_t sub_18E14ED00(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 8);
  int v2 = *(_DWORD *)(a2 + 12);
  *(void *)(a1 + 24) = 0xA0000000ALL;
  *(void *)a1 = &unk_1EDD175C8;
  *(_DWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 12) = v3;
  *(_DWORD *)(a1 + 16) = v3 * v2;
  *(_DWORD *)(a1 + 20) = v2;
  *(void *)(a1 + 32) = a1 + 40;
  return sub_18DFE2C64(a2, a1);
}

void sub_18E14ED68(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

void *sub_18E14ED88(void *result)
{
  *__n128 result = &unk_1EDD17478;
  return result;
}

void *sub_18E14EDA8(void *result)
{
  *__n128 result = &unk_1EDD174A8;
  return result;
}

void sub_18E14EDC8(void *a1)
{
  *a1 = &unk_1EDD174A8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14EDF8(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14EE04(uint64_t a1)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  sub_18DFE2870(a1, v1);
}

void sub_18E14EE54(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14EE84(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14EE90(uint64_t a1)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  sub_18DEF3CF4(a1, v1);
}

void sub_18E14EEE4(void *a1)
{
  sub_18E14F0CC(a1);

  JUMPOUT(0x192FA6240);
}

void sub_18E14EF1C()
{
}

void sub_18E14EF48()
{
}

void sub_18E14F050()
{
}

void *sub_18E14F0CC(void *a1)
{
  *a1 = &unk_1EDD184F8;
  uint64_t v2 = a1[5];
  a1[5] = 0;
  if (v2) {
    MEMORY[0x192FA6220](v2, 0x1000C8000313F17);
  }
  *a1 = &unk_1EDD17478;
  return a1;
}

void sub_18E14F148(void *a1)
{
  *a1 = &unk_1EDD17238;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14F178(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14F184(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(&v9, v4);
      if (v4 >= 3)
      {
        int v6 = v9;
        uint64_t v7 = 8;
        int v8 = v3 + v1 - v5;
        do
        {
          if (!v6)
          {
            *(void *)(*(void *)(a1 + 32) + 8 * (v8 % (v4 - 1))) = *(void *)(*(void *)(a1 + 32) + v7);
            int v6 = 1;
          }
          v8 += v3 + v1 - v5;
          v7 += 8;
        }
        while (8 * (v4 - 1) != v7);
      }
    }
  }
}

void sub_18E14F23C(void *a1)
{
  *a1 = &unk_1EDD17418;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14F26C(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14F278(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(&v9, v4);
      if (v4 >= 3)
      {
        int v6 = v9;
        uint64_t v7 = 8;
        int v8 = v3 + v1 - v5;
        do
        {
          if (!v6)
          {
            *(void *)(*(void *)(a1 + 32) + 8 * (v8 % (v4 - 1))) = *(void *)(*(void *)(a1 + 32) + v7);
            int v6 = 1;
          }
          v8 += v3 + v1 - v5;
          v7 += 8;
        }
        while (8 * (v4 - 1) != v7);
      }
    }
  }
}

void sub_18E14F328(void *a1)
{
  *a1 = &unk_1EDD17268;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E14F358(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E14F364(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(&v9, v4);
      if (v4 >= 3)
      {
        int v6 = v9;
        uint64_t v7 = 8;
        int v8 = v3 + v1 - v5;
        do
        {
          if (!v6)
          {
            *(void *)(*(void *)(a1 + 32) + 8 * (v8 % (v4 - 1))) = *(void *)(*(void *)(a1 + 32) + v7);
            int v6 = 1;
          }
          v8 += v3 + v1 - v5;
          v7 += 8;
        }
        while (8 * (v4 - 1) != v7);
      }
    }
  }
}

uint64_t sub_18E14F41C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19, uint64_t a20,uint64_t a21,int a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v251 = v27;
  uint64_t v252 = v26;
  uint64_t v258 = v28;
  unsigned int v30 = v29;
  uint64_t v32 = v31;
  uint64_t v259 = v33;
  unsigned int v35 = v34;
  uint64_t v37 = v36;
  if (a19 >= 1)
  {
    uint64_t v38 = 0;
    do
    {
      sub_18E14CD0C((uint64_t)&v353, *(void *)(a11 + 32) + v38);
      v38 += 48;
    }
    while (48 * a19 != v38);
    uint64_t v39 = 0;
    do
    {
      sub_18E14CD0C((uint64_t)&v353, *(void *)(a13 + 32) + v39);
      sub_18E14CD0C((uint64_t)&v353, *(void *)(a14 + 32) + v39);
      sub_18E14CD0C((uint64_t)&v353, *(void *)(a14 + 32) + v39);
      v39 += 48;
    }
    while (48 * a19 != v39);
  }
  sub_18E1550F8((uint64_t)&__p, a16, 0);
  HIDWORD(v354.__r_.__value_.__r.__words[2]) = 1;
  v355 = v356;
  uint64_t v40 = HIDWORD(__p.__r_.__value_.__r.__words[1]);
  LODWORD(v354.__r_.__value_.__l.__data_) = 1;
  HIDWORD(v354.__r_.__value_.__r.__words[0]) = HIDWORD(__p.__r_.__value_.__r.__words[1]);
  LODWORD(v354.__r_.__value_.__r.__words[1]) = HIDWORD(__p.__r_.__value_.__r.__words[1]);
  *(std::string::size_type *)((char *)&v354.__r_.__value_.__r.__words[1] + 4) = 0x100000001;
  if (HIDWORD(__p.__r_.__value_.__r.__words[1]))
  {
    uint64_t v41 = 0;
    v42 = v351;
    unsigned int v43 = __p.__r_.__value_.__r.__words[1];
    uint64_t v44 = LODWORD(__p.__r_.__value_.__r.__words[1]) - 1;
    int v45 = 1;
    do
    {
      int v46 = v42[v43 * v41];
      unsigned int v47 = v45;
      uint64_t v48 = v44;
      if (v43 >= 2)
      {
        do
        {
          v46 += v42[v47++];
          --v48;
        }
        while (v48);
      }
      v356[v41++] = v46;
      v45 += v43;
    }
    while (v41 != v40);
  }
  sub_18E1550F8((uint64_t)&__p, a16, 1);
  HIDWORD(v354.__r_.__value_.__r.__words[2]) = 1;
  v355 = v356;
  uint64_t v49 = HIDWORD(__p.__r_.__value_.__r.__words[1]);
  LODWORD(v354.__r_.__value_.__l.__data_) = 1;
  HIDWORD(v354.__r_.__value_.__r.__words[0]) = HIDWORD(__p.__r_.__value_.__r.__words[1]);
  LODWORD(v354.__r_.__value_.__r.__words[1]) = HIDWORD(__p.__r_.__value_.__r.__words[1]);
  *(std::string::size_type *)((char *)&v354.__r_.__value_.__r.__words[1] + 4) = 0x100000001;
  if (HIDWORD(__p.__r_.__value_.__r.__words[1]))
  {
    uint64_t v50 = 0;
    v51 = v351;
    unsigned int v52 = __p.__r_.__value_.__r.__words[1];
    uint64_t v53 = LODWORD(__p.__r_.__value_.__r.__words[1]) - 1;
    int v54 = 1;
    do
    {
      int v55 = v51[v52 * v50];
      unsigned int v56 = v54;
      uint64_t v57 = v53;
      if (v52 >= 2)
      {
        do
        {
          v55 += v51[v56++];
          --v57;
        }
        while (v57);
      }
      v356[v50++] = v55;
      v54 += v52;
    }
    while (v50 != v49);
  }
  unint64_t v256 = __PAIR64__(v35, v30);
  v354.__r_.__value_.__r.__words[2] = 0x100000001;
  *(void *)&long long v58 = 0x100000001;
  *((void *)&v58 + 1) = 0x100000001;
  *(_OWORD *)&v354.__r_.__value_.__l.__data_ = v58;
  v353 = &unk_1EDD18078;
  v355 = v356;
  LogLevel = (cnprint::CNPrinter *)sub_18E07519C(a23, 1, (uint64_t)&v353);
  double v254 = *(double *)(a26 + 64);
  int v60 = *(unsigned __int8 *)(a26 + 32);
  int v250 = *(unsigned __int8 *)(a26 + 33);
  if (a19 >= 1)
  {
    uint64_t v61 = 0;
    do
    {
      int v62 = *(_DWORD *)(*(void *)(a9 + 32) + 4 * v61);
      int v63 = *(_DWORD *)(*(void *)(a12 + 32) + 4 * v61);
      if (v62 <= v63)
      {
        ++v61;
      }
      else
      {
        LOWORD(v353) = 2;
        __p.__r_.__value_.__s.__data_[0] = 2;
        cnprint::CNLogFormatter::FormatWarning((cnprint::CNLogFormatter *)(v37 + 2344), "%d measurements > %d noise sources in measurement function %d.", v62, v63, ++v61);
        if (*(char *)(v37 + 2367) >= 0) {
          LOBYTE(v69) = v37 + 40;
        }
        else {
          uint64_t v69 = *(void *)(v37 + 2344);
        }
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v353, (unsigned __int8 *)&__p, "%s", v64, v65, v66, v67, v68, v69);
      }
    }
    while (v61 != a19);
  }
  if (*(_DWORD *)a26)
  {
    LogLevel = (cnprint::CNPrinter *)cnprint::CNPrinter::GetLogLevel(LogLevel);
    if (LogLevel <= 1)
    {
      LOWORD(v353) = 2;
      __p.__r_.__value_.__s.__data_[0] = 1;
      unsigned __int8 v70 = cnprint::CNLogFormatter::FormatWarning((cnprint::CNLogFormatter *)(v37 + 2344), "PredictAndUpdate is only compatible with NewtonRaphson solver.");
      if (*(char *)(v37 + 2367) >= 0) {
        LOBYTE(v76) = v70;
      }
      else {
        uint64_t v76 = *(void *)(v37 + 2344);
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v353, (unsigned __int8 *)&__p, "%s", v71, v72, v73, v74, v75, v76);
    }
  }
  if (*(int *)(a26 + 4) >= 2 && cnprint::CNPrinter::GetLogLevel(LogLevel) <= 1)
  {
    LOWORD(v353) = 2;
    __p.__r_.__value_.__s.__data_[0] = 1;
    unsigned __int8 v77 = cnprint::CNLogFormatter::FormatWarning((cnprint::CNLogFormatter *)(v37 + 2344), "PredictAndUpdate is only compatible with single-iteration least squares solutions.");
    if (*(char *)(v37 + 2367) >= 0) {
      LOBYTE(v83) = v77;
    }
    else {
      uint64_t v83 = *(void *)(v37 + 2344);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v353, (unsigned __int8 *)&__p, "%s", v78, v79, v80, v81, v82, v83);
  }
  int v84 = *(_DWORD *)(a26 + 8);
  v354.__r_.__value_.__r.__words[2] = 0x10000002CLL;
  *(_OWORD *)&v354.__r_.__value_.__l.__data_ = xmmword_18E21A0B0;
  v353 = &unk_1EDD19158;
  v355 = v356;
  v85 = (cnprint::CNPrinter *)sub_18E07519C(a9, 1, (uint64_t)&v353);
  unsigned int v86 = HIDWORD(v256);
  if (v84 < *v355)
  {
    v85 = (cnprint::CNPrinter *)cnprint::CNPrinter::GetLogLevel(v85);
    if (v85 <= 1)
    {
      LOWORD(v353) = 2;
      __p.__r_.__value_.__s.__data_[0] = 1;
      unsigned __int8 v87 = cnprint::CNLogFormatter::FormatWarning((cnprint::CNLogFormatter *)(v37 + 2344), "PredictAndUpdate is only compatible with QR factorizations of unconstrained size.");
      if (*(char *)(v37 + 2367) >= 0) {
        LOBYTE(v93) = v87;
      }
      else {
        uint64_t v93 = *(void *)(v37 + 2344);
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v353, (unsigned __int8 *)&__p, "%s", v88, v89, v90, v91, v92, v93);
    }
  }
  unsigned int v94 = v30;
  if (*(unsigned char *)(a26 + 89))
  {
    v85 = (cnprint::CNPrinter *)cnprint::CNPrinter::GetLogLevel(v85);
    if (v85 <= 1)
    {
      LOWORD(v353) = 2;
      __p.__r_.__value_.__s.__data_[0] = 1;
      unsigned __int8 v95 = cnprint::CNLogFormatter::FormatWarning((cnprint::CNLogFormatter *)(v37 + 2344), "PredictAndUpdate is only compatible with dense prediction.");
      if (*(char *)(v37 + 2367) >= 0) {
        LOBYTE(v101) = v95;
      }
      else {
        uint64_t v101 = *(void *)(v37 + 2344);
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v353, (unsigned __int8 *)&__p, "%s", v96, v97, v98, v99, v100, v101);
    }
  }
  if (!v60 && v250 && cnprint::CNPrinter::GetLogLevel(v85) <= 1)
  {
    LOWORD(v353) = 2;
    __p.__r_.__value_.__s.__data_[0] = 1;
    unsigned __int8 v102 = cnprint::CNLogFormatter::FormatWarning((cnprint::CNLogFormatter *)(v37 + 2344), "Local hypothesis testing implies global hypothesis testing.  Global hypothesis testing will be enabled.");
    if (*(char *)(v37 + 2367) >= 0) {
      LOBYTE(v108) = v102;
    }
    else {
      uint64_t v108 = *(void *)(v37 + 2344);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v353, (unsigned __int8 *)&__p, "%s", v103, v104, v105, v106, v107, v108);
  }
  if (*(_DWORD *)(v259 + 8) && *(_DWORD *)(v259 + 12))
  {
    uint64_t v109 = v37 + 8;
    v110 = (void **)v259;
  }
  else
  {
    if ((v256 & 0x8000000000000000) != 0) {
      __assert_rtn("Zeros", "cnmatrix.h", 3098, "nr >= 0");
    }
    v354.__r_.__value_.__r.__words[2] = 0x10000000ALL;
    v353 = &unk_1EDD17628;
    v355 = v356;
    v354.__r_.__value_.__r.__words[0] = HIDWORD(v256) | 0x100000000;
    LODWORD(v354.__r_.__value_.__r.__words[1]) = HIDWORD(v256);
    HIDWORD(v354.__r_.__value_.__r.__words[1]) = HIDWORD(v256);
    sub_18DFE2CC8((uint64_t)&v353, 0.0);
    uint64_t v109 = v37 + 8;
    v110 = &v353;
  }
  sub_18DFE2F24(v109, (uint64_t)v110);
  v111 = (void **)v252;
  if (*(_DWORD *)(v252 + 8) && *(_DWORD *)(v252 + 12))
  {
    uint64_t v112 = v37 + 128;
  }
  else
  {
    if ((v256 & 0x8000000000000000) != 0) {
      __assert_rtn("Zeros", "cnmatrix.h", 3056, "n >= 0");
    }
    v354.__r_.__value_.__r.__words[2] = 0xA0000000ALL;
    v353 = &unk_1EDD175C8;
    v355 = v356;
    LODWORD(v354.__r_.__value_.__l.__data_) = HIDWORD(v256);
    HIDWORD(v354.__r_.__value_.__r.__words[0]) = HIDWORD(v256);
    LODWORD(v354.__r_.__value_.__r.__words[1]) = HIDWORD(v256) * HIDWORD(v256);
    HIDWORD(v354.__r_.__value_.__r.__words[1]) = HIDWORD(v256);
    sub_18DFE2CC8((uint64_t)&v353, 0.0);
    uint64_t v112 = v37 + 128;
    v111 = &v353;
  }
  sub_18DFE2F24(v112, (uint64_t)v111);
  if (!*(_DWORD *)(v32 + 8) || !*(_DWORD *)(v32 + 12))
  {
    v354.__r_.__value_.__r.__words[2] = 0x10000000ALL;
    *(_OWORD *)&v354.__r_.__value_.__l.__data_ = xmmword_18E200CF0;
    v353 = &unk_1EDD17628;
    v355 = v356;
    sub_18DFE2B44(v37 + 128, v37 + 8, (uint64_t)&v353);
    sub_18DFE2F24(v37 + 968, (uint64_t)&v353);
  }
  if ((v256 & 0x8000000000000000) != 0) {
    __assert_rtn("Zeros", "cnmatrix.h", 3099, "nc >= 0");
  }
  v354.__r_.__value_.__r.__words[2] = 0xA0000000ALL;
  v353 = &unk_1EDD175C8;
  v355 = v356;
  v354.__r_.__value_.__r.__words[0] = v256;
  LODWORD(v354.__r_.__value_.__r.__words[1]) = v30 * HIDWORD(v256);
  HIDWORD(v354.__r_.__value_.__r.__words[1]) = v30;
  sub_18DFE2CC8((uint64_t)&v353, 0.0);
  uint64_t v248 = v37 + 2392;
  sub_18DFE2F24(v37 + 2392, (uint64_t)&v353);
  v354.__r_.__value_.__r.__words[2] = 0x10000000ALL;
  v353 = &unk_1EDD17628;
  v355 = v356;
  v354.__r_.__value_.__r.__words[0] = v30 | 0x100000000;
  LODWORD(v354.__r_.__value_.__r.__words[1]) = v30;
  HIDWORD(v354.__r_.__value_.__r.__words[1]) = v30;
  sub_18DFE2CC8((uint64_t)&v353, 0.0);
  uint64_t v247 = v37 + 3232;
  sub_18DFE2F24(v37 + 3232, (uint64_t)&v353);
  sub_18DFE2F24(v37 + 3352, v251);
  *(_DWORD *)(v37 + 2180) = 0;
  *(unsigned char *)(v37 + 2176) = 0;
  v354.__r_.__value_.__r.__words[2] = 0x10000002CLL;
  *(_OWORD *)&v354.__r_.__value_.__l.__data_ = xmmword_18E21A0B0;
  v353 = &unk_1EDD19158;
  v355 = v356;
  sub_18E07519C(a9, 1, (uint64_t)&v353);
  int v113 = *v355;
  if (*v355 < 0x2D)
  {
    unsigned int v249 = *v355;
    uint64_t v245 = v37 + 3352;
    unsigned int v123 = *(_DWORD *)(a21 + 8);
    unsigned int v122 = *(_DWORD *)(a21 + 12);
    if (v123 <= v122) {
      unsigned int v124 = *(_DWORD *)(a21 + 12);
    }
    else {
      unsigned int v124 = *(_DWORD *)(a21 + 8);
    }
    if (v123 && v122 && v124)
    {
      unsigned int v126 = *(_DWORD *)(a9 + 8);
      unsigned int v125 = *(_DWORD *)(a9 + 12);
      unsigned int v127 = v126 <= v125 ? *(_DWORD *)(a9 + 12) : *(_DWORD *)(a9 + 8);
      if (!v126 || !v125 || v127 <= v124)
      {
        v354.__r_.__value_.__r.__words[2] = 0x10000002CLL;
        *(_OWORD *)&v354.__r_.__value_.__l.__data_ = xmmword_18E21A0B0;
        v353 = &unk_1EDD19158;
        v355 = v356;
        sub_18E07519C(a9, 1, (uint64_t)&v353);
        sub_18E06950C((uint64_t *)(v37 + 2320));
        unsigned int v222 = *(_DWORD *)(a9 + 8);
        if (v222)
        {
          unsigned int v223 = *(_DWORD *)(a9 + 12);
          if (v223)
          {
            if (v223 | v222)
            {
              int v224 = 0;
              uint64_t v225 = *(void *)(a9 + 32);
              do
              {
                uint64_t v226 = v224;
                if (*(int *)(v225 + 4 * v224) >= 1)
                {
                  int v227 = 0;
                  do
                  {
                    uint64_t v228 = *(void *)(*(void *)(a21 + 32) + 8 * v226);
                    LODWORD(v353) = *(_DWORD *)(v228 + 8);
                    if (*(char *)(v228 + 39) < 0)
                    {
                      sub_18DEDE668(&v354, *(void **)(v228 + 16), *(void *)(v228 + 24));
                      uint64_t v225 = *(void *)(a9 + 32);
                    }
                    else
                    {
                      long long v229 = *(_OWORD *)(v228 + 16);
                      v354.__r_.__value_.__r.__words[2] = *(void *)(v228 + 32);
                      *(_OWORD *)&v354.__r_.__value_.__l.__data_ = v229;
                    }
                    if (*(int *)(v225 + 4 * v226) >= 2)
                    {
                      std::to_string(&__p, v227);
                      v230 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                           ? &__p
                           : (std::string *)__p.__r_.__value_.__r.__words[0];
                      std::string::size_type v231 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                           ? HIBYTE(__p.__r_.__value_.__r.__words[2])
                           : __p.__r_.__value_.__l.__size_;
                      std::string::append(&v354, (const std::string::value_type *)v230, v231);
                      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(__p.__r_.__value_.__l.__data_);
                      }
                    }
                    unint64_t v232 = *(void *)(v37 + 2328);
                    if (v232 >= *(void *)(v37 + 2336))
                    {
                      uint64_t v233 = sub_18E08977C((uint64_t *)(v37 + 2320), (uint64_t)&v353);
                    }
                    else
                    {
                      sub_18E089710(v37 + 2320, (uint64_t)&v353);
                      uint64_t v233 = v232 + 32;
                    }
                    *(void *)(v37 + 2328) = v233;
                    if (SHIBYTE(v354.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v354.__r_.__value_.__l.__data_);
                    }
                    ++v227;
                    uint64_t v225 = *(void *)(a9 + 32);
                  }
                  while (v227 < *(_DWORD *)(v225 + 4 * v226));
                  unsigned int v222 = *(_DWORD *)(a9 + 8);
                  unsigned int v223 = *(_DWORD *)(a9 + 12);
                  unsigned int v94 = v30;
                  unsigned int v86 = HIDWORD(v256);
                }
                if (v222 <= v223) {
                  unsigned int v234 = v223;
                }
                else {
                  unsigned int v234 = v222;
                }
                if (!v222) {
                  break;
                }
                if (!v223) {
                  break;
                }
                int v224 = v226 + 1;
              }
              while (v234 > (int)v226 + 1);
            }
          }
        }
      }
    }
    sub_18E06950C((uint64_t *)(v37 + 2296));
    sub_18E06950C((uint64_t *)(v37 + 2272));
    sub_18E14E5D4((uint64_t)v417, v259);
    sub_18E14E5D4((uint64_t)&v416, v32);
    sub_18E14E5D4((uint64_t)v415, v258);
    uint64_t v412 = 0x10000000ALL;
    unsigned int v408 = v86;
    int v409 = 1;
    unsigned int v410 = v86;
    unsigned int v411 = v86;
    v407 = &unk_1EDD17628;
    v413 = &v414;
    uint64_t v404 = 0xA0000000ALL;
    v399 = &unk_1EDD175C8;
    v405 = &v406;
    unsigned int v400 = v86;
    unsigned int v401 = v86;
    int v402 = v86 * v86;
    unsigned int v403 = v86;
    sub_18DFE2CC8((uint64_t)&v399, 0.0);
    uint64_t v396 = 0xA0000000ALL;
    v391 = &unk_1EDD175C8;
    v397 = &v398;
    unsigned int v392 = v86;
    unsigned int v393 = v86;
    int v246 = v86 * v86;
    int v394 = v86 * v86;
    unsigned int v395 = v86;
    sub_18DFE2CC8((uint64_t)&v391, 0.0);
    uint64_t v388 = 0xA0000000ALL;
    v383 = &unk_1EDD175C8;
    v389 = &v390;
    unsigned int v384 = v86;
    unsigned int v385 = v94;
    int v386 = v30 * HIDWORD(v256);
    unsigned int v387 = v86;
    sub_18DFE2CC8((uint64_t)&v383, 0.0);
    uint64_t v380 = 0x10000000ALL;
    long long v379 = xmmword_18E200CF0;
    v378 = &unk_1EDD17658;
    v381 = &v382;
    uint64_t v375 = 0x10000000ALL;
    long long v374 = xmmword_18E200CF0;
    v373 = &unk_1EDD17658;
    v376 = &v377;
    double v128 = 1.0;
    double v129 = 1.0;
    uint64_t v257 = v37;
    if (a15 < 1)
    {
LABEL_128:
      uint64_t v370 = 0x10000002CLL;
      unsigned int v366 = v249;
      int v367 = 1;
      unsigned int v368 = v249;
      unsigned int v369 = v249;
      v365 = &unk_1EDD19128;
      v371 = &v372;
      uint64_t v362 = 0x10000002CLL;
      unsigned int v358 = v249;
      int v359 = 1;
      unsigned int v360 = v249;
      unsigned int v361 = v249;
      v357 = &unk_1EDD19128;
      v363 = &v364;
      v354.__r_.__value_.__r.__words[2] = 0xA0000002CLL;
      v354.__r_.__value_.__r.__words[0] = __PAIR64__(v86, v249);
      LODWORD(v354.__r_.__value_.__r.__words[1]) = v249 * v86;
      HIDWORD(v354.__r_.__value_.__r.__words[1]) = v249;
      v353 = &unk_1EDD19008;
      v355 = v356;
      uint64_t v350 = 0xA0000002CLL;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1EDD19008;
      __p.__r_.__value_.__l.__size_ = __PAIR64__(v94, v249);
      LODWORD(__p.__r_.__value_.__r.__words[2]) = v249 * v94;
      HIDWORD(__p.__r_.__value_.__r.__words[2]) = v249;
      v351 = v352;
      if (a19 < 1)
      {
LABEL_172:
        int v221 = v256 + HIDWORD(v256);
        uint64_t v336 = 0x1400000040;
        uint64_t v335 = 0;
        unint64_t v334 = 0;
        uint64_t v338 = 0;
        v333 = &unk_1EDD196F8;
        v337 = 0;
        if ((int)(v249 + v256 + HIDWORD(v256)) < 0)
        {
          v243 = "nr >= 0";
          int v244 = 419;
        }
        else
        {
          if ((v221 & 0x80000000) == 0)
          {
            LODWORD(v334) = v249 + v256 + HIDWORD(v256);
            HIDWORD(v334) = v256 + HIDWORD(v256);
            LODWORD(v335) = v334 * v221;
            HIDWORD(v335) = v334;
            sub_18E1570C8();
          }
          v243 = "nc >= 0";
          int v244 = 420;
        }
        __assert_rtn("CNMatrix", "cnmatrix.h", v244, v243);
      }
      uint64_t v164 = 0;
      int v165 = 0;
      int v166 = a22;
      while (1)
      {
        int v253 = v165;
        uint64_t v260 = v164;
        uint64_t v330 = 0x10000000ALL;
        v325 = &unk_1EDD17628;
        v331 = &v332;
        int v326 = HIDWORD(v256);
        int v327 = 1;
        int v328 = HIDWORD(v256);
        int v329 = HIDWORD(v256);
        int v167 = v166;
        sub_18DFE2CC8((uint64_t)&v325, 0.0);
        uint64_t v302 = 0xA0000000ALL;
        v300 = &unk_1EDD175C8;
        v303 = v304;
        LODWORD(v301) = HIDWORD(v256);
        *(void *)((char *)&v301 + 4) = __PAIR64__(v246, HIDWORD(v256));
        HIDWORD(v301) = HIDWORD(v256);
        sub_18DFE2CC8((uint64_t)&v300, 0.0);
        uint64_t v263 = 0xA0000000ALL;
        v261 = &unk_1EDD175C8;
        v264 = (double *)v265;
        LODWORD(v262) = HIDWORD(v256);
        *(void *)((char *)&v262 + 4) = __PAIR64__(v246, HIDWORD(v256));
        HIDWORD(v262) = HIDWORD(v256);
        sub_18DFE2CC8((uint64_t)&v261, 0.0);
        *(void *)&long long v168 = 0x100000001;
        *((void *)&v168 + 1) = 0x100000001;
        if (v167 >= 1) {
          break;
        }
LABEL_147:
        uint64_t v312 = 0x100000001;
        long long v311 = v168;
        v310 = &unk_1EDD18048;
        v313 = &v314;
        uint64_t v341 = 0xA00000001;
        long long v340 = xmmword_18E21A120;
        v339 = &unk_1EDD17DA8;
        v342 = v343;
        uint64_t v307 = 0x100000001;
        long long v306 = v168;
        v305 = &unk_1EDD18048;
        v308 = &v309;
        v183 = *(unsigned int (**)(void **, void **, void, void **, void **, void **, __n128))(*(void *)(a20 + 32) + 8 * v260);
        __n128 v184 = sub_18E14CD0C((uint64_t)&v320, *(void *)(a13 + 32) + 48 * v260);
        if (v183(&v325, &v320, *(void *)(*(void *)(a21 + 32) + 8 * v260), &v310, &v339, &v305, v184)) {
          return 3;
        }
        uint64_t v346 = 0xA0000000ALL;
        long long v345 = xmmword_18E1FD870;
        v344 = &unk_1EDD175C8;
        v347 = v348;
        sub_18DFE2B44((uint64_t)&v261, (uint64_t)&v399, (uint64_t)&v344);
        uint64_t v322 = 0xA0000000ALL;
        long long v321 = xmmword_18E1FD870;
        v320 = &unk_1EDD175C8;
        v323 = v324;
        sub_18DFEF1F4((uint64_t)&v300, (uint64_t)&v344, (uint64_t)&v320);
        uint64_t v279 = 0xA00000001;
        long long v278 = xmmword_18E21A120;
        v277 = &unk_1EDD17DA8;
        v280 = &v281;
        sub_18DFE2B44((uint64_t)&v339, (uint64_t)&v320, (uint64_t)&v277);
        uint64_t v322 = 0xA0000000ALL;
        long long v321 = xmmword_18E1FD870;
        v320 = &unk_1EDD175C8;
        v323 = v324;
        sub_18DFE2B44((uint64_t)&v261, (uint64_t)&v383, (uint64_t)&v320);
        uint64_t v346 = 0xA00000001;
        long long v345 = xmmword_18E21A120;
        v344 = &unk_1EDD17DA8;
        v347 = v348;
        sub_18DFE2B44((uint64_t)&v339, (uint64_t)&v320, (uint64_t)&v344);
        int v185 = v253;
        int v186 = v253 + *(_DWORD *)(*(void *)(a9 + 32) + 4 * v260) - 1;
        uint64_t v322 = 0x100000001;
        v320 = &unk_1EDD18078;
        v323 = v324;
        int v187 = v186 - v253;
        *(void *)&long long v188 = 0x100000001;
        *((void *)&v188 + 1) = 0x100000001;
        if (v187)
        {
          if (v187 < 0)
          {
            int v190 = 0;
            LODWORD(v191) = 0;
            long long v321 = 0uLL;
            LOBYTE(v189) = 1;
          }
          else
          {
            uint64_t v191 = (v187 + 1);
            LODWORD(v321) = 1;
            DWORD1(v321) = v191;
            *((void *)&v321 + 1) = v191 | 0x100000000;
            v192 = v324;
            uint64_t v189 = v191;
            do
            {
              *v192++ = v185++;
              --v189;
            }
            while (v189);
            int v190 = 1;
          }
        }
        else
        {
          LOBYTE(v189) = 0;
          long long v321 = v188;
          LODWORD(v324[0]) = v253;
          int v190 = 1;
          LODWORD(v191) = 1;
        }
        uint64_t v297 = 0x100000001;
        v292 = &unk_1EDD18078;
        v298 = v299;
        int v293 = v191;
        int v294 = v190;
        int v295 = v191 * v190;
        int v296 = v191;
        if (v191)
        {
          int v193 = 0;
          int v194 = 0;
          do
          {
            if ((v189 & 1) == 0)
            {
              int v195 = 0;
              do
              {
                v299[v194 + v296 * v195] = *((_DWORD *)v324 + v193 + v195);
                ++v195;
              }
              while (v190 != v195);
            }
            ++v194;
            v193 += v190;
          }
          while (v194 != v191);
        }
        sub_18E14CD0C((uint64_t)&v266, *(void *)(a14 + 32) + 48 * v260);
        uint64_t v269 = 0x100000001;
        *(void *)&long long v196 = 0x100000001;
        *((void *)&v196 + 1) = 0x100000001;
        long long v268 = v196;
        v267 = &unk_1EDD18048;
        v270 = &v271;
        sub_18DFE2B44((uint64_t)&v305, (uint64_t)&v266, (uint64_t)&v267);
        int v197 = DWORD1(v306);
        int v198 = v306;
        uint64_t v336 = 0x100000001;
        v333 = &unk_1EDD18048;
        v337 = &v338;
        unint64_t v334 = __PAIR64__(v306, DWORD1(v306));
        LODWORD(v335) = v306 * DWORD1(v306);
        HIDWORD(v335) = DWORD1(v306);
        *(void *)&long long v199 = 0x100000001;
        *((void *)&v199 + 1) = 0x100000001;
        if (DWORD1(v306))
        {
          int v200 = 0;
          int v201 = 0;
          int v202 = HIDWORD(v306);
          v203 = v308;
          do
          {
            int v204 = v200;
            int v205 = v201;
            for (int i = v198; i; --i)
            {
              *(&v338 + v205) = v203[v204];
              v205 += v197;
              ++v204;
            }
            ++v201;
            v200 += v202;
          }
          while (v201 != v197);
        }
        uint64_t v274 = 0x100000001;
        long long v273 = v199;
        v272 = &unk_1EDD18048;
        v275 = &v276;
        sub_18DFE2B44((uint64_t)&v267, (uint64_t)&v333, (uint64_t)&v272);
        uint64_t v289 = 0x100000001;
        *(void *)&long long v207 = 0x100000001;
        *((void *)&v207 + 1) = 0x100000001;
        long long v288 = v207;
        v287 = &unk_1EDD18048;
        v290 = &v291;
        LOBYTE(v320) = 0;
        sub_18DFEEFE8((uint64_t)&v272, (uint64_t)&v287, (BOOL *)&v320);
        uint64_t v284 = 0x100000001;
        *(void *)&long long v208 = 0x100000001;
        *((void *)&v208 + 1) = 0x100000001;
        long long v283 = v208;
        v282 = &unk_1EDD18048;
        v285 = &v286;
        uint64_t v317 = 0x100000001;
        long long v316 = v208;
        v315 = &unk_1EDD18078;
        v318 = (double *)v319;
        uint64_t v322 = 0x100000004;
        long long v321 = xmmword_18E1F6F80;
        v320 = &unk_1EDD19458;
        v323 = v324;
        sub_18E01BFEC((uint64_t)&v287, (uint64_t)&v315, (uint64_t)&v320, (uint64_t)&v282);
        uint64_t v317 = 0x200000002;
        long long v316 = xmmword_18E1FD1B0;
        v315 = &unk_1EDD18BB8;
        v318 = (double *)v319;
        sub_18E07D314((uint64_t)&v282, 0, (uint64_t)&v315);
        uint64_t v209 = DWORD1(v316);
        if (DWORD1(v316))
        {
          uint64_t v210 = 0;
          unsigned int v211 = v316;
          v212 = v318;
          uint64_t v213 = v316 - 1;
          int v214 = 1;
          do
          {
            double v215 = v212[v211 * v210];
            int v216 = v214;
            uint64_t v217 = v213;
            if (v211 >= 2)
            {
              do
              {
                double v215 = v215 * v212[v216++];
                --v217;
              }
              while (v217);
            }
            *(double *)&v324[v210++] = v215;
            v214 += v211;
          }
          while (v210 != v209);
        }
        double v218 = *(double *)v324;
        sub_18E14CD0C((uint64_t)&v287, *(void *)(a11 + 32) + 48 * v260);
        uint64_t v317 = 0x100000001;
        *(void *)&long long v219 = 0x100000001;
        *((void *)&v219 + 1) = 0x100000001;
        long long v316 = v219;
        v315 = &unk_1EDD18048;
        v318 = (double *)v319;
        sub_18DFE2B44((uint64_t)&v282, (uint64_t)&v287, (uint64_t)&v315);
        sub_18E156D10((uint64_t)&v320, (uint64_t)&v365, (uint64_t)&v292);
        sub_18E1554D8((uint64_t)&v320, SDWORD2(v316), v318);
        uint64_t v317 = 0x100000001;
        *(void *)&long long v220 = 0x100000001;
        *((void *)&v220 + 1) = 0x100000001;
        long long v316 = v220;
        v315 = &unk_1EDD18048;
        v318 = (double *)v319;
        sub_18DFE2B44((uint64_t)&v282, (uint64_t)&v310, (uint64_t)&v315);
        sub_18E156D10((uint64_t)&v320, (uint64_t)&v357, (uint64_t)&v292);
        sub_18E1554D8((uint64_t)&v320, SDWORD2(v316), v318);
        uint64_t v317 = 0xA00000001;
        long long v316 = xmmword_18E21A120;
        v315 = &unk_1EDD17DA8;
        v318 = (double *)v319;
        sub_18DFE2B44((uint64_t)&v282, (uint64_t)&v277, (uint64_t)&v315);
        sub_18E15558C((uint64_t)&v320, (uint64_t)&v353, (uint64_t)&v292);
        sub_18E155730((uint64_t)&v320, (uint64_t)&v315);
        uint64_t v317 = 0xA00000001;
        long long v316 = xmmword_18E21A120;
        v315 = &unk_1EDD17DA8;
        v318 = (double *)v319;
        sub_18DFE2B44((uint64_t)&v282, (uint64_t)&v344, (uint64_t)&v315);
        sub_18E15558C((uint64_t)&v320, (uint64_t)&__p, (uint64_t)&v292);
        sub_18E155730((uint64_t)&v320, (uint64_t)&v315);
        double v128 = v128 * v218;
        int v165 = *(_DWORD *)(*(void *)(a9 + 32) + 4 * v260) + v253;
        uint64_t v164 = v260 + 1;
        int v166 = a22;
        if (v260 + 1 == a19) {
          goto LABEL_172;
        }
      }
      uint64_t v169 = 0;
      int v170 = 0;
      uint64_t v171 = *(void *)(a23 + 32);
      while (1)
      {
        int v172 = v170 + *(_DWORD *)(v171 + 4 * v169) - 1;
        uint64_t v346 = 0xA00000001;
        v344 = &unk_1EDD17DD8;
        v347 = v348;
        int v173 = v172 - v170;
        if (v173)
        {
          if (v173 < 0)
          {
            int v175 = 0;
            LODWORD(v176) = 0;
            long long v345 = 0uLL;
            LOBYTE(v174) = 1;
          }
          else
          {
            uint64_t v176 = (v173 + 1);
            LODWORD(v345) = 1;
            DWORD1(v345) = v176;
            *((void *)&v345 + 1) = v176 | 0x100000000;
            v177 = v348;
            uint64_t v174 = v176;
            int v178 = v170;
            do
            {
              *v177++ = v178++;
              --v174;
            }
            while (v174);
            int v175 = 1;
          }
        }
        else
        {
          LOBYTE(v174) = 0;
          long long v345 = v168;
          v348[0] = v170;
          int v175 = 1;
          LODWORD(v176) = 1;
        }
        uint64_t v322 = 0x10000000ALL;
        v320 = &unk_1EDD17658;
        v323 = v324;
        *(void *)&long long v321 = __PAIR64__(v175, v176);
        DWORD2(v321) = v176 * v175;
        HIDWORD(v321) = v176;
        if (v176)
        {
          int v179 = 0;
          int v180 = 0;
          do
          {
            if ((v174 & 1) == 0)
            {
              int v181 = 0;
              do
              {
                *((_DWORD *)v324 + v180 + HIDWORD(v321) * v181) = v348[v179 + v181];
                ++v181;
              }
              while (v175 != v181);
            }
            ++v180;
            v179 += v175;
          }
          while (v180 != v176);
        }
        sub_18DFEEA3C((uint64_t)&v378, (uint64_t)&v320);
        uint64_t v317 = 0x10000000ALL;
        long long v316 = xmmword_18E200CF0;
        v315 = &unk_1EDD17628;
        v318 = (double *)v319;
        uint64_t v346 = 0xA0000000ALL;
        long long v345 = xmmword_18E1FD870;
        v344 = &unk_1EDD175C8;
        v347 = v348;
        uint64_t v341 = 0xA0000000ALL;
        long long v340 = xmmword_18E1FD870;
        v339 = &unk_1EDD175C8;
        v342 = v343;
        v182 = *(unsigned int (**)(void **, void **, void, void **, void **, void **, double))(*(void *)(a24 + 32) + 8 * v169);
        sub_18E1568D0((uint64_t)&v320, (uint64_t)v417, (uint64_t)&v378);
        sub_18E1568D0((uint64_t)&v277, (uint64_t)&v407, (uint64_t)&v378);
        if (v182(&v320, &v277, *(void *)(*(void *)(a25 + 32) + 8 * v169), &v315, &v344, &v339, *(double *)(*(void *)(a10 + 32) + 8 * v260)))
        {
          return 22;
        }
        sub_18E1568D0((uint64_t)&v320, (uint64_t)&v325, (uint64_t)&v378);
        sub_18E1551BC((uint64_t)&v320, SDWORD2(v316), v318);
        sub_18E1569F8((uint64_t)&v320, (uint64_t)&v300, (uint64_t)&v378, (uint64_t)&v378);
        sub_18E155230((uint64_t)&v320, (uint64_t)&v344);
        sub_18E1569F8((uint64_t)&v320, (uint64_t)&v261, (uint64_t)&v378, (uint64_t)&v378);
        sub_18E155230((uint64_t)&v320, (uint64_t)&v339);
        uint64_t v171 = *(void *)(a23 + 32);
        v170 += *(_DWORD *)(v171 + 4 * v169++);
        *(void *)&long long v168 = 0x100000001;
        *((void *)&v168 + 1) = 0x100000001;
        if (v169 == a22) {
          goto LABEL_147;
        }
      }
    }
    else
    {
      uint64_t v130 = 0;
      int v131 = 0;
      int v132 = 0;
      uint64_t v133 = *(void *)(a16 + 32);
      char v134 = 1;
      do
      {
        uint64_t v135 = *(unsigned int *)(v133 + 4 * v130);
        uint64_t v322 = 0xA00000001;
        v320 = &unk_1EDD17DD8;
        v323 = v324;
        char v255 = v134;
        if (v135 == 1)
        {
          char v136 = 0;
          *(void *)&long long v137 = 0x100000001;
          *((void *)&v137 + 1) = 0x100000001;
          long long v321 = v137;
          LODWORD(v324[0]) = 0;
          int v138 = 1;
          LODWORD(v135) = 1;
        }
        else if ((int)v135 <= 0)
        {
          int v138 = 0;
          LODWORD(v135) = 0;
          long long v321 = 0uLL;
          char v136 = 1;
        }
        else
        {
          uint64_t v139 = 0;
          LODWORD(v321) = 1;
          DWORD1(v321) = v135;
          *((void *)&v321 + 1) = v135 | 0x100000000;
          do
          {
            *((_DWORD *)v324 + v139) = v139;
            ++v139;
          }
          while (v135 != v139);
          char v136 = 0;
          int v138 = 1;
        }
        uint64_t v350 = 0x10000000ALL;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1EDD17658;
        v351 = v352;
        __p.__r_.__value_.__l.__size_ = __PAIR64__(v138, v135);
        LODWORD(__p.__r_.__value_.__r.__words[2]) = v135 * v138;
        HIDWORD(__p.__r_.__value_.__r.__words[2]) = v135;
        if (v135)
        {
          int v140 = 0;
          int v141 = 0;
          do
          {
            if ((v136 & 1) == 0)
            {
              int v142 = 0;
              do
              {
                v352[v141 + HIDWORD(__p.__r_.__value_.__r.__words[2]) * v142] = *((_DWORD *)v324 + v140 + v142);
                ++v142;
              }
              while (v138 != v142);
            }
            ++v141;
            v140 += v138;
          }
          while (v141 != v135);
          unsigned int v143 = __p.__r_.__value_.__r.__words[1];
          int v138 = HIDWORD(__p.__r_.__value_.__r.__words[1]);
        }
        else
        {
          unsigned int v143 = 0;
        }
        v354.__r_.__value_.__r.__words[2] = 0x10000000ALL;
        v353 = &unk_1EDD17658;
        v355 = v356;
        v354.__r_.__value_.__r.__words[0] = __PAIR64__(v138, v143);
        uint64_t v144 = v143 * v138;
        v354.__r_.__value_.__l.__size_ = __PAIR64__(v143, v144);
        if ((int)v144 >= 1)
        {
          v145 = v352;
          v146 = v356;
          do
          {
            int v147 = *v145++;
            *v146++ = v147 + v132;
            --v144;
          }
          while (v144);
        }
        sub_18DFEEA3C((uint64_t)&v378, (uint64_t)&v353);
        uint64_t v148 = *(unsigned int *)(*(void *)(a16 + 32) + 4 * (*(_DWORD *)(a16 + 20) + (int)v130));
        uint64_t v322 = 0xA00000001;
        v320 = &unk_1EDD17DD8;
        v323 = v324;
        if (v148 == 1)
        {
          char v149 = 0;
          *(void *)&long long v150 = 0x100000001;
          *((void *)&v150 + 1) = 0x100000001;
          long long v321 = v150;
          LODWORD(v324[0]) = 0;
          int v151 = 1;
          LODWORD(v148) = 1;
        }
        else if ((int)v148 <= 0)
        {
          int v151 = 0;
          LODWORD(v148) = 0;
          long long v321 = 0uLL;
          char v149 = 1;
        }
        else
        {
          uint64_t v152 = 0;
          LODWORD(v321) = 1;
          DWORD1(v321) = v148;
          *((void *)&v321 + 1) = v148 | 0x100000000;
          do
          {
            *((_DWORD *)v324 + v152) = v152;
            ++v152;
          }
          while (v148 != v152);
          char v149 = 0;
          int v151 = 1;
        }
        uint64_t v350 = 0x10000000ALL;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1EDD17658;
        v351 = v352;
        __p.__r_.__value_.__l.__size_ = __PAIR64__(v151, v148);
        LODWORD(__p.__r_.__value_.__r.__words[2]) = v148 * v151;
        HIDWORD(__p.__r_.__value_.__r.__words[2]) = v148;
        if (v148)
        {
          int v153 = 0;
          int v154 = 0;
          do
          {
            if ((v149 & 1) == 0)
            {
              int v155 = 0;
              do
              {
                v352[v154 + HIDWORD(__p.__r_.__value_.__r.__words[2]) * v155] = *((_DWORD *)v324 + v153 + v155);
                ++v155;
              }
              while (v151 != v155);
            }
            ++v154;
            v153 += v151;
          }
          while (v154 != v148);
          unsigned int v156 = __p.__r_.__value_.__r.__words[1];
          int v151 = HIDWORD(__p.__r_.__value_.__r.__words[1]);
        }
        else
        {
          unsigned int v156 = 0;
        }
        v354.__r_.__value_.__r.__words[2] = 0x10000000ALL;
        v353 = &unk_1EDD17658;
        v355 = v356;
        v354.__r_.__value_.__r.__words[0] = __PAIR64__(v151, v156);
        uint64_t v157 = v156 * v151;
        v354.__r_.__value_.__l.__size_ = __PAIR64__(v156, v157);
        if ((int)v157 >= 1)
        {
          v158 = v352;
          v159 = v356;
          do
          {
            int v160 = *v158++;
            *v159++ = v160 + v131;
            --v157;
          }
          while (v157);
        }
        sub_18DFEEA3C((uint64_t)&v373, (uint64_t)&v353);
        uint64_t v263 = 0x10000000ALL;
        v261 = &unk_1EDD17628;
        long long v262 = xmmword_18E200CF0;
        v264 = (double *)v265;
        uint64_t v350 = 0xA0000000ALL;
        *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = xmmword_18E1FD870;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1EDD175C8;
        v351 = v352;
        uint64_t v322 = 0xA0000000ALL;
        long long v321 = xmmword_18E1FD870;
        v320 = &unk_1EDD175C8;
        v323 = v324;
        v161 = *(unsigned int (**)(void **, void **, void, void **, std::string *, void **))(*(void *)(a17 + 32) + 8 * v130);
        sub_18E1568D0((uint64_t)&v353, (uint64_t)v417, (uint64_t)&v378);
        sub_18E1568D0((uint64_t)&v300, (uint64_t)v415, (uint64_t)&v373);
        if (v161(&v353, &v300, *(void *)(*(void *)(a18 + 32) + 8 * v130), &v261, &__p, &v320)) {
          return 20;
        }
        sub_18E1568D0((uint64_t)&v353, (uint64_t)&v407, (uint64_t)&v378);
        sub_18E1551BC((uint64_t)&v353, SDWORD2(v262), v264);
        sub_18E1569F8((uint64_t)&v353, (uint64_t)&v399, (uint64_t)&v378, (uint64_t)&v378);
        sub_18E155230((uint64_t)&v353, (uint64_t)&__p);
        uint64_t v302 = 0x10000000ALL;
        long long v301 = xmmword_18E200CF0;
        v300 = &unk_1EDD17658;
        v303 = v304;
        v354.__r_.__value_.__r.__words[2] = 0xA0000000ALL;
        *(_OWORD *)&v354.__r_.__value_.__l.__data_ = xmmword_18E1FD870;
        v353 = &unk_1EDD175C8;
        v355 = v356;
        double v162 = sub_18DFE2D1C((uint64_t)&__p, (uint64_t)&v300, (uint64_t)&v353);
        uint64_t v302 = 0xA0000000ALL;
        long long v301 = xmmword_18E1FD870;
        v300 = &unk_1EDD175C8;
        v303 = v304;
        uint64_t v346 = 0x10000000ALL;
        long long v345 = xmmword_18E200CF0;
        v344 = &unk_1EDD17658;
        v347 = v348;
        uint64_t v341 = 0x10000000ALL;
        long long v340 = xmmword_18E200CF0;
        v339 = &unk_1EDD17658;
        v342 = v343;
        v354.__r_.__value_.__r.__words[2] = 0x100000028;
        *(_OWORD *)&v354.__r_.__value_.__l.__data_ = xmmword_18E21A0C0;
        v353 = &unk_1EDD18FD8;
        v355 = v356;
        double v163 = sub_18E01D7FC((uint64_t)&__p, (uint64_t)&v344, (uint64_t)&v339, (uint64_t)&v353, (uint64_t)&v300);
        sub_18E1569F8((uint64_t)&v353, (uint64_t)&v391, (uint64_t)&v378, (uint64_t)&v378);
        sub_18E155230((uint64_t)&v353, (uint64_t)&v300);
        sub_18E1569F8((uint64_t)&v353, (uint64_t)&v383, (uint64_t)&v378, (uint64_t)&v373);
        sub_18E155230((uint64_t)&v353, (uint64_t)&v320);
        double v129 = v129 * v162;
        char v134 = (v163 <= v254) & v255;
        uint64_t v133 = *(void *)(a16 + 32);
        v132 += *(_DWORD *)(v133 + 4 * v130);
        v131 += *(_DWORD *)(v133 + 4 * (*(_DWORD *)(a16 + 20) + (int)v130++));
      }
      while (v130 != a15);
      unsigned int v94 = v256;
      unsigned int v86 = HIDWORD(v256);
      double v128 = 1.0;
      if (((v163 <= v254) & v255) != 0) {
        goto LABEL_128;
      }
      LOWORD(v353) = 2;
      __p.__r_.__value_.__s.__data_[0] = 2;
      unsigned __int8 v235 = cnprint::CNLogFormatter::FormatWarning((cnprint::CNLogFormatter *)(v257 + 2344), "PredictAndUpdate state Jacobian matrix is not invertible.");
      if (*(char *)(v257 + 2367) >= 0) {
        LOBYTE(v241) = v235;
      }
      else {
        uint64_t v241 = *(void *)(v257 + 2344);
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v353, (unsigned __int8 *)&__p, "%s", v236, v237, v238, v239, v240, v241);
      sub_18DFE2F24(v257 + 1088, (uint64_t)&v407);
      sub_18DFE2F24(v257 + 1208, v252);
      v354.__r_.__value_.__r.__words[2] = 0x10000000ALL;
      *(_OWORD *)&v354.__r_.__value_.__l.__data_ = xmmword_18E200CF0;
      v353 = &unk_1EDD17628;
      v355 = v356;
      sub_18DFE2B44(v257 + 1208, (uint64_t)&v407, (uint64_t)&v353);
      sub_18DFE2F24(v257 + 2048, (uint64_t)&v353);
      v354.__r_.__value_.__r.__words[2] = 0xA0000000ALL;
      v353 = &unk_1EDD175C8;
      v355 = v356;
      v354.__r_.__value_.__r.__words[0] = v256;
      LODWORD(v354.__r_.__value_.__r.__words[1]) = v256 * HIDWORD(v256);
      HIDWORD(v354.__r_.__value_.__r.__words[1]) = v256;
      sub_18DFE2CC8((uint64_t)&v353, 0.0);
      sub_18DFE2F24(v248, (uint64_t)&v353);
      uint64_t v350 = 0x10000000ALL;
      *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = xmmword_18E200CF0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1EDD17628;
      v351 = v352;
      sub_18DFE2B44(v251, (uint64_t)v415, (uint64_t)&__p);
      uint64_t v322 = 0x10000000ALL;
      long long v321 = xmmword_18E200CF0;
      v320 = &unk_1EDD17628;
      v323 = v324;
      sub_18DFE2B44(v248, (uint64_t)&v407, (uint64_t)&v320);
      v354.__r_.__value_.__r.__words[2] = 0x10000000ALL;
      *(_OWORD *)&v354.__r_.__value_.__l.__data_ = xmmword_18E200CF0;
      v353 = &unk_1EDD17628;
      v355 = v356;
      sub_18DFEF1F4((uint64_t)&__p, (uint64_t)&v320, (uint64_t)&v353);
      sub_18DFE2F24(v247, (uint64_t)&v353);
      sub_18DFE2F24(v245, v251);
      *(_DWORD *)(v257 + 2180) = 1;
      return 21;
    }
  }
  else
  {
    uint64_t v114 = 2;
    LOWORD(v353) = 2;
    __p.__r_.__value_.__s.__data_[0] = 5;
    unsigned __int8 v115 = cnprint::CNLogFormatter::FormatGeneral((const void **)(v37 + 2344), "SquareRootInformationFilter::PredictAndUpdate called with %u measurements vs. maximum %u", v113, 44);
    if (*(char *)(v37 + 2367) >= 0) {
      LOBYTE(v121) = v115;
    }
    else {
      uint64_t v121 = *(void *)(v37 + 2344);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v353, (unsigned __int8 *)&__p, "%s", v116, v117, v118, v119, v120, v121);
  }
  return v114;
}

void sub_18E154C84(_Unwind_Exception *a1)
{
}

double sub_18E154EE0(void *a1, unsigned int a2)
{
  a1[3] = 0x10000002CLL;
  a1[4] = 0;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDD19158;
  if ((a2 & 0x80000000) != 0) {
    __assert_rtn("CNMatrix", "cnmatrix.h", 419, "nr >= 0");
  }
  int32x4_t v2 = vdupq_lane_s32((int32x2_t)(a2 | 0x100000000), 0);
  v2.i32[1] = 1;
  *(int32x4_t *)(a1 + 1) = v2;
  a1[4] = a1 + 5;
  return *(double *)v2.i64;
}

void sub_18E154F7C(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD174A8;
  _Unwind_Resume(a1);
}

void *sub_18E154F9C(void *a1, unsigned int a2)
{
  uint64_t v3 = 0;
  a1[3] = 0x10000002CLL;
  a1[4] = 0;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDD19068;
  *(void *)&long long v4 = 0x100000001;
  *((void *)&v4 + 1) = 0x100000001;
  do
  {
    int v5 = &a1[v3];
    v5[8] = 0x100000001;
    v5[5] = &unk_1EDD18048;
    *((_OWORD *)v5 + 3) = v4;
    v5[9] = &a1[v3 + 10];
    v3 += 6;
  }
  while (v3 != 264);
  if ((a2 & 0x80000000) != 0) {
    __assert_rtn("CNMatrix", "cnmatrix.h", 419, "nr >= 0");
  }
  int32x4_t v6 = vdupq_lane_s32((int32x2_t)(a2 | 0x100000000), 0);
  v6.i32[1] = 1;
  *(int32x4_t *)(a1 + 1) = v6;
  (*(void (**)(void *))(*a1 + 16))(a1);
  return a1;
}

void sub_18E1550A8(_Unwind_Exception *a1)
{
  for (uint64_t i = 263; i != -1; i -= 6)
    v1[i] = &unk_1EDD17478;
  *unsigned int v1 = &unk_1EDD16F68;
  _Unwind_Resume(a1);
}

uint64_t sub_18E1550F8(uint64_t result, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(a2 + 8);
  *(void *)(result + 24) = 0x100000001;
  *(void *)__n128 result = &unk_1EDD18078;
  *(_DWORD *)(result + 8) = v3;
  *(_DWORD *)(result + 12) = 1;
  *(_DWORD *)(result + 16) = v3;
  *(_DWORD *)(result + 20) = v3;
  long long v4 = (_DWORD *)(result + 40);
  *(void *)(result + 32) = result + 40;
  if (v3)
  {
    int v5 = *(_DWORD *)(a2 + 20) * a3;
    uint64_t v6 = *(void *)(a2 + 32);
    do
    {
      *v4++ = *(_DWORD *)(v6 + 4 * v5++);
      --v3;
    }
    while (v3);
  }
  return result;
}

void *sub_18E15515C(void *result)
{
  *__n128 result = &unk_1EDD174A8;
  return result;
}

void *sub_18E15517C(void *result)
{
  result[16] = &unk_1EDD174A8;
  *__n128 result = &unk_1EDD17478;
  return result;
}

double sub_18E1551BC(uint64_t a1, int a2, double *a3)
{
  if (*(_DWORD *)(a1 + 16) != a2) {
    __assert_rtn("operator=", "cnsubvector.h", 347, "this->num_elements_ == A.num_elements_");
  }
  if (a2 >= 1)
  {
    int v3 = *(int **)(a1 + 160);
    uint64_t v4 = *(void *)(*(void *)(a1 + 120) + 32);
    int v5 = *(double **)(a1 + 32);
    uint64_t v6 = a2;
    do
    {
      double v7 = *a3++;
      double result = v7;
      uint64_t v9 = *v3++;
      *(double *)(v4 + 8 * v9) = result;
      *v5++ = result;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t sub_18E155230(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(result + 8);
  if (v2 != *(_DWORD *)(a2 + 8)) {
    __assert_rtn("operator=", "cnsubmatrix.h", 376, "this->num_rows_ == A.num_rows_");
  }
  uint64_t v3 = *(unsigned int *)(result + 12);
  if (v3 != *(_DWORD *)(a2 + 12)) {
    __assert_rtn("operator=", "cnsubmatrix.h", 377, "this->num_cols_ == A.num_cols_");
  }
  if (v3)
  {
    unsigned int v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(a2 + 32);
    do
    {
      if (v2)
      {
        uint64_t v7 = *(void *)(result + 840);
        int v8 = *(int **)(result + 880);
        int v9 = *(_DWORD *)(v7 + 20) * *(_DWORD *)(*(void *)(result + 960) + 4 * v5);
        uint64_t v10 = *(void *)(v7 + 32);
        uint64_t v11 = *(void *)(result + 32);
        int v12 = *(_DWORD *)(result + 20) * v5;
        unsigned int v13 = v4;
        int v14 = v2;
        do
        {
          uint64_t v15 = *(void *)(v6 + 8 * v13);
          int v16 = *v8++;
          *(void *)(v10 + 8 * (v16 + v9)) = v15;
          *(void *)(v11 + 8 * v12++) = v15;
          ++v13;
          --v14;
        }
        while (v14);
      }
      ++v5;
      v4 += v2;
    }
    while (v5 != v3);
  }
  return result;
}

void *sub_18E15531C(void *result)
{
  result[116] = &unk_1EDD174A8;
  result[106] = &unk_1EDD174A8;
  *double result = &unk_1EDD17478;
  return result;
}

void sub_18E15537C(uint64_t a1, uint64_t a2, double *a3)
{
  *(void *)(a1 + 24) = 0xA0000000ALL;
  *(void *)a1 = &unk_1EDD175C8;
  *(_OWORD *)(a1 + 8) = xmmword_18E1FD870;
  *(void *)(a1 + 32) = a1 + 40;
  uint64_t v15 = 0x10000000ALL;
  long long v14 = xmmword_18E200CF0;
  unsigned int v13 = &unk_1EDD17658;
  int v16 = &v17;
  uint64_t v10 = 0x10000000ALL;
  long long v9 = xmmword_18E200CF0;
  int v8 = &unk_1EDD17658;
  uint64_t v11 = &v12;
  uint64_t v5 = 0x100000028;
  uint64_t v3 = &unk_1EDD18FD8;
  long long v4 = xmmword_18E21A0C0;
  uint64_t v6 = &v7;
  *a3 = sub_18E01D7FC(a2, (uint64_t)&v13, (uint64_t)&v8, (uint64_t)&v3, a1);
}

void sub_18E1554B8(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

double sub_18E1554D8(uint64_t a1, int a2, double *a3)
{
  if (*(_DWORD *)(a1 + 16) != a2) {
    __assert_rtn("operator=", "cnsubvector.h", 347, "this->num_elements_ == A.num_elements_");
  }
  if (a2 >= 1)
  {
    uint64_t v3 = *(int **)(a1 + 88);
    uint64_t v4 = *(void *)(*(void *)(a1 + 48) + 32);
    uint64_t v5 = *(double **)(a1 + 32);
    uint64_t v6 = a2;
    do
    {
      double v7 = *a3++;
      double result = v7;
      uint64_t v9 = *v3++;
      *(double *)(v4 + 8 * v9) = result;
      *v5++ = result;
      --v6;
    }
    while (v6);
  }
  return result;
}

void *sub_18E15554C(void *result)
{
  result[7] = &unk_1EDD174A8;
  *double result = &unk_1EDD17478;
  return result;
}

uint64_t sub_18E15558C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(unsigned int *)(a2 + 12);
  sub_18E156E30(v22, *(_DWORD *)(a2 + 12));
  if ((int)v6 >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = v22[4];
    do
    {
      *(_DWORD *)(v8 + 4 * v7) = v7;
      ++v7;
    }
    while (v6 != v7);
  }
  *(void *)(a1 + 24) = 0xA00000001;
  *(_OWORD *)(a1 + 8) = xmmword_18E21A120;
  *(void *)(a1 + 32) = a1 + 40;
  *(void *)a1 = &unk_1EDD162A8;
  *(void *)(a1 + 152) = 0x100000001;
  *(void *)(a1 + 120) = a2;
  *(void *)(a1 + 128) = &unk_1EDD18078;
  *(void *)&long long v9 = 0x100000001;
  *((void *)&v9 + 1) = 0x100000001;
  *(_OWORD *)(a1 + 136) = v9;
  *(void *)(a1 + 160) = a1 + 168;
  *(void *)(a1 + 200) = 0x10000000ALL;
  *(void *)(a1 + 176) = &unk_1EDD17658;
  *(_OWORD *)(a1 + 184) = xmmword_18E200CF0;
  *(void *)(a1 + 208) = a1 + 216;
  sub_18DFEEA3C(a1 + 128, a3);
  uint64_t result = sub_18DFEEA3C(a1 + 176, (uint64_t)v22);
  uint64_t v11 = *(unsigned int *)(a1 + 144);
  uint64_t v12 = *(unsigned int *)(a1 + 192);
  *(_DWORD *)(a1 + 8) = v11;
  *(_DWORD *)(a1 + 12) = v12;
  *(_DWORD *)(a1 + 16) = v12 * v11;
  *(_DWORD *)(a1 + 20) = v11;
  if (v12)
  {
    unsigned int v13 = 0;
    uint64_t v14 = 0;
    int v15 = *(_DWORD *)(a2 + 20);
    uint64_t v16 = *(void *)(a2 + 32);
    do
    {
      if (v11)
      {
        uint64_t v17 = *(int **)(a1 + 160);
        int v18 = *(_DWORD *)(*(void *)(a1 + 208) + 4 * v14) * v15;
        uint64_t v19 = *(void *)(a1 + 32);
        unsigned int v20 = v13;
        uint64_t result = v11;
        do
        {
          int v21 = *v17++;
          *(void *)(v19 + 8 * v20++) = *(void *)(v16 + 8 * (v21 + v18));
          --result;
        }
        while (result);
      }
      ++v14;
      v13 += v11;
    }
    while (v14 != v12);
  }
  return result;
}

uint64_t sub_18E155730(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(result + 8);
  if (v2 != *(_DWORD *)(a2 + 8)) {
    __assert_rtn("operator=", "cnsubmatrix.h", 376, "this->num_rows_ == A.num_rows_");
  }
  uint64_t v3 = *(unsigned int *)(result + 12);
  if (v3 != *(_DWORD *)(a2 + 12)) {
    __assert_rtn("operator=", "cnsubmatrix.h", 377, "this->num_cols_ == A.num_cols_");
  }
  if (v3)
  {
    unsigned int v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(a2 + 32);
    do
    {
      if (v2)
      {
        uint64_t v7 = *(void *)(result + 120);
        uint64_t v8 = *(int **)(result + 160);
        int v9 = *(_DWORD *)(v7 + 20) * *(_DWORD *)(*(void *)(result + 208) + 4 * v5);
        uint64_t v10 = *(void *)(v7 + 32);
        uint64_t v11 = *(void *)(result + 32);
        int v12 = *(_DWORD *)(result + 20) * v5;
        unsigned int v13 = v4;
        int v14 = v2;
        do
        {
          uint64_t v15 = *(void *)(v6 + 8 * v13);
          int v16 = *v8++;
          *(void *)(v10 + 8 * (v16 + v9)) = v15;
          *(void *)(v11 + 8 * v12++) = v15;
          ++v13;
          --v14;
        }
        while (v14);
      }
      ++v5;
      v4 += v2;
    }
    while (v5 != v3);
  }
  return result;
}

void *sub_18E15581C(void *result)
{
  result[22] = &unk_1EDD174A8;
  result[16] = &unk_1EDD174A8;
  *uint64_t result = &unk_1EDD17478;
  return result;
}

void *sub_18E15587C(void *result)
{
  *uint64_t result = &unk_1EDD17478;
  return result;
}

uint64_t sub_18E15589C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = 0x100000040;
  uint64_t v10 = &unk_1EDD19698;
  long long v11 = xmmword_18E21A140;
  unsigned int v13 = &v14;
  uint64_t v7 = 0x1400000014;
  uint64_t v5 = &unk_1EDD184C8;
  long long v6 = xmmword_18E21A0F0;
  uint64_t v8 = &v9;
  return sub_18E075FB8(a1, a2, (uint64_t)&v10, (uint64_t)&v5, a3, a4);
}

uint64_t sub_18E155954(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 8);
  int v2 = *(_DWORD *)(a2 + 12);
  *(void *)(a1 + 24) = 0x10000002CLL;
  *(void *)a1 = &unk_1EDD19158;
  *(_DWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 12) = v3;
  *(_DWORD *)(a1 + 16) = v3 * v2;
  *(_DWORD *)(a1 + 20) = v2;
  *(void *)(a1 + 32) = a1 + 40;
  return sub_18DFEE808(a2, a1);
}

void sub_18E1559C0(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD174A8;
  _Unwind_Resume(a1);
}

uint64_t sub_18E1559E0(uint64_t result, int a2, int a3)
{
  int v3 = (_OWORD *)(result + 8);
  *(void *)(result + 24) = 0x2C00000001;
  *(void *)uint64_t result = &unk_1EDD18288;
  unsigned int v4 = (_DWORD *)(result + 40);
  *(void *)(result + 32) = result + 40;
  if (a3 == a2)
  {
    *(void *)&long long v5 = 0x100000001;
    *((void *)&v5 + 1) = 0x100000001;
    *int v3 = v5;
    *unsigned int v4 = a2;
  }
  else if (a3 - a2 < 0)
  {
    *(void *)int v3 = 0;
    *(void *)(result + 16) = 0;
  }
  else
  {
    uint64_t v6 = (a3 - a2 + 1);
    *(_DWORD *)(result + 8) = 1;
    *(_DWORD *)(result + 12) = v6;
    *(_DWORD *)(result + 16) = v6;
    *(_DWORD *)(result + 20) = 1;
    do
    {
      *v4++ = a2++;
      --v6;
    }
    while (v6);
  }
  return result;
}

void *sub_18E155A5C(void *result)
{
  *uint64_t result = &unk_1EDD174A8;
  return result;
}

void *sub_18E155A7C(void *result)
{
  result[50] = &unk_1EDD174A8;
  *uint64_t result = &unk_1EDD17478;
  return result;
}

uint64_t sub_18E155ABC(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 8);
  int v2 = *(_DWORD *)(a2 + 12);
  *(void *)(a1 + 24) = 0x2C0000000ALL;
  *(void *)a1 = &unk_1EDD176B8;
  *(_DWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 12) = v3;
  *(_DWORD *)(a1 + 16) = v3 * v2;
  *(_DWORD *)(a1 + 20) = v2;
  *(void *)(a1 + 32) = a1 + 40;
  return sub_18DFE2C64(a2, a1);
}

void sub_18E155B28(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

void sub_18E155B48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 24) = 0x2C0000000ALL;
  *(void *)a1 = &unk_1EDD176B8;
  *(_OWORD *)(a1 + 8) = xmmword_18E21A150;
  *(void *)(a1 + 32) = a1 + 40;
  sub_18DFE2B44(a2, a3, a1);
}

void sub_18E155BB4(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

void *sub_18E155BD4(void *result)
{
  *uint64_t result = &unk_1EDD17478;
  return result;
}

void sub_18E155BF4()
{
  uint64_t v3 = 0x100000036;
  unsigned int v1 = &unk_1EDD19608;
  long long v2 = xmmword_18E21A160;
  unsigned int v4 = &v5;
  sub_18E157AE8((uint64_t)v0);
}

void sub_18E155CD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_18E1586A0(v2);
  sub_18E157F84((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_18E155D34(uint64_t a1)
{
}

void sub_18E155E44(_Unwind_Exception *a1)
{
  sub_18E157F84(v1);
  _Unwind_Resume(a1);
}

void sub_18E155E58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

double sub_18E155F08(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 24) = 0x10000002CLL;
  *(void *)a1 = &unk_1EDD19128;
  *(_OWORD *)(a1 + 8) = xmmword_18E21A0B0;
  *(void *)(a1 + 32) = a1 + 40;
  *(void *)&double result = *(_OWORD *)&sub_18DFE2AA8(a2, a3, a1);
  return result;
}

void sub_18E155F58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 24) = 0x10000002CLL;
  *(void *)a1 = &unk_1EDD19128;
  *(_OWORD *)(a1 + 8) = xmmword_18E21A0B0;
  *(void *)(a1 + 32) = a1 + 40;
  sub_18DFE2B44(a2, a3, a1);
}

void sub_18E155FC4(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

void sub_18E155FE4(uint64_t a1, uint64_t a2)
{
}

void sub_18E156020(_Unwind_Exception *a1)
{
  sub_18E157F84(v1);
  _Unwind_Resume(a1);
}

void sub_18E156034(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  uint64_t v17 = 0;
  int v18 = 0;
  unint64_t v19 = 0;
  int v4 = *(_DWORD *)(a2 + 8);
  int v5 = *(_DWORD *)(a2 + 12);
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6 || (v5 | v4) == 0)
  {
LABEL_9:
    if ((char **)(a1 + 2320) != &v17) {
      sub_18E08BF6C((uint64_t *)(a1 + 2320), v17, v3, (v3 - v17) >> 5);
    }
  }
  else
  {
    uint64_t v3 = 0;
    unsigned int v9 = 1;
    while (1)
    {
      unint64_t v10 = *(int *)(*(void *)(a2 + 32) + 4 * (int)(v9 - 1));
      uint64_t v11 = *(void *)(a1 + 2320);
      if (v10 >= (*(void *)(a1 + 2328) - v11) >> 5) {
        break;
      }
      uint64_t v12 = v11 + 32 * v10;
      if ((unint64_t)v3 >= v19)
      {
        uint64_t v3 = (char *)sub_18E08977C((uint64_t *)&v17, v12);
      }
      else
      {
        sub_18E089710((uint64_t)&v17, v12);
        v3 += 32;
      }
      int v18 = v3;
      unsigned int v14 = *(_DWORD *)(a2 + 8);
      unsigned int v13 = *(_DWORD *)(a2 + 12);
      if (v14 <= v13) {
        unsigned int v15 = *(_DWORD *)(a2 + 12);
      }
      else {
        unsigned int v15 = *(_DWORD *)(a2 + 8);
      }
      if (v14)
      {
        if (v13)
        {
          if (v15 > v9++) {
            continue;
          }
        }
      }
      goto LABEL_9;
    }
  }
  unsigned int v20 = &v17;
  sub_18E0694B8((void ***)&v20);
}

void sub_18E156140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_18E0694B8(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_18E156160(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 24) = 0x100000040;
  *(void *)a1 = &unk_1EDD196C8;
  *(_OWORD *)(a1 + 8) = xmmword_18E21A140;
  *(void *)(a1 + 32) = a1 + 40;
  return sub_18E072E48(a2, a3, a1);
}

uint64_t sub_18E1561B0(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 8);
  int v2 = *(_DWORD *)(a2 + 12);
  *(void *)(a1 + 24) = 0x100000014;
  *(void *)a1 = &unk_1EDD18498;
  *(_DWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 12) = v3;
  *(_DWORD *)(a1 + 16) = v3 * v2;
  *(_DWORD *)(a1 + 20) = v2;
  *(void *)(a1 + 32) = a1 + 40;
  return sub_18DFEE808(a2, a1);
}

void sub_18E15621C(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD174A8;
  _Unwind_Resume(a1);
}

uint64_t sub_18E15623C(uint64_t result, int a2)
{
  int v2 = (void *)(result + 8);
  *(void *)(result + 24) = 0x1400000001;
  *(void *)double result = &unk_1EDD180D8;
  int v3 = (_DWORD *)(result + 40);
  *(void *)(result + 32) = result + 40;
  if (a2)
  {
    if (a2 < 0)
    {
      *int v2 = 0;
      *(void *)(result + 16) = 0;
    }
    else
    {
      uint64_t v4 = 0;
      uint64_t v5 = (a2 + 1);
      *(_DWORD *)(result + 8) = 1;
      *(_DWORD *)(result + 12) = v5;
      *(_DWORD *)(result + 16) = v5;
      *(_DWORD *)(result + 20) = 1;
      do
      {
        v3[v4] = v4;
        ++v4;
      }
      while (v5 != v4);
    }
  }
  else
  {
    *(void *)&long long v6 = 0x100000001;
    *((void *)&v6 + 1) = 0x100000001;
    *(_OWORD *)int v2 = v6;
    *int v3 = 0;
  }
  return result;
}

uint64_t sub_18E1562B8(uint64_t result, uint64_t a2, int a3)
{
  *(void *)(result + 24) = 0x10000002CLL;
  *(void *)double result = &unk_1EDD19158;
  int v3 = (_DWORD *)(result + 40);
  *(void *)(result + 32) = result + 40;
  int v5 = *(_DWORD *)(a2 + 8);
  int v4 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(result + 8) = v5;
  *(_DWORD *)(result + 12) = v4;
  uint64_t v6 = (v4 * v5);
  *(_DWORD *)(result + 16) = v6;
  *(_DWORD *)(result + 20) = v5;
  if ((int)v6 >= 1)
  {
    uint64_t v7 = *(int **)(a2 + 32);
    do
    {
      int v8 = *v7++;
      *v3++ = v8 + a3;
      --v6;
    }
    while (v6);
  }
  return result;
}

void *sub_18E15631C(void *result)
{
  *double result = &unk_1EDD174A8;
  return result;
}

void *sub_18E15633C(void *result)
{
  *double result = &unk_1EDD174A8;
  return result;
}

void sub_18E15635C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a2 + 12);
  sub_18E15839C(v6, *(_DWORD *)(a2 + 12));
  if ((int)v3 >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = v6[4];
    do
    {
      *(_DWORD *)(v5 + 4 * v4) = v4;
      ++v4;
    }
    while (v3 != v4);
  }
  sub_18E157278(a1);
}

void sub_18E156528(_Unwind_Exception *a1)
{
  v1[44] = &unk_1EDD174A8;
  v1[7] = &unk_1EDD174A8;
  sub_18E158458(v1);
  _Unwind_Resume(a1);
}

void *sub_18E156574(void *a1)
{
  *a1 = &unk_1EDD167B8;
  a1[44] = &unk_1EDD174A8;
  a1[7] = &unk_1EDD174A8;
  return sub_18E158458(a1);
}

void *sub_18E1565D4(void *result)
{
  result[70] = &unk_1EDD174A8;
  *double result = &unk_1EDD17478;
  return result;
}

void *sub_18E156614(void *result)
{
  *double result = &unk_1EDD174A8;
  return result;
}

void *sub_18E156638(void *a1)
{
  *a1 = &unk_1EDD19098;
  sub_18E15894C(a1 + 5);
  *a1 = &unk_1EDD17088;
  return a1;
}

void *sub_18E156698(void *result)
{
  *double result = &unk_1EDD17478;
  return result;
}

void *sub_18E1566B8(void *result)
{
  result[421] = &unk_1EDD174A8;
  result[406] = &unk_1EDD174A8;
  *double result = &unk_1EDD17478;
  return result;
}

void *sub_18E156718(void *result)
{
  result[26] = &unk_1EDD174A8;
  *double result = &unk_1EDD17478;
  return result;
}

void *sub_18E156758(void *result)
{
  *double result = &unk_1EDD17478;
  return result;
}

void *sub_18E156778(void *result)
{
  *double result = &unk_1EDD17478;
  return result;
}

void sub_18E15679C(void *a1)
{
  *a1 = &unk_1EDD174A8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1567CC(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E1567D8(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unsigned int v9 = &v13[v8];
          if (!v13[v8])
          {
            int v10 = *(_DWORD *)(v7 + 4 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              int v12 = *(_DWORD *)(v7 + 4 * v11);
              *(_DWORD *)(v7 + 4 * v11) = v10;
              *unsigned int v9 = 1;
              unsigned int v9 = &v13[v11];
              int v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

uint64_t sub_18E1568D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 24) = 0x10000000ALL;
  *(_OWORD *)(a1 + 8) = xmmword_18E200CF0;
  *(void *)(a1 + 32) = a1 + 40;
  *(void *)a1 = &unk_1EDD168A8;
  *(void *)(a1 + 120) = a2;
  *(void *)(a1 + 152) = 0x10000000ALL;
  *(void *)(a1 + 128) = &unk_1EDD17658;
  *(_OWORD *)(a1 + 136) = xmmword_18E200CF0;
  *(void *)(a1 + 160) = a1 + 168;
  sub_18DFEEA3C(a1 + 128, a3);
  int v6 = *(_DWORD *)(a1 + 136);
  int v5 = *(_DWORD *)(a1 + 140);
  *(_DWORD *)(a1 + 8) = v6;
  *(_DWORD *)(a1 + 12) = v5;
  uint64_t v7 = (v5 * v6);
  *(_DWORD *)(a1 + 16) = v7;
  *(_DWORD *)(a1 + 20) = v6;
  if ((int)v7 >= 1)
  {
    uint64_t v8 = *(int **)(a1 + 160);
    uint64_t v9 = *(void *)(a2 + 32);
    int v10 = *(void **)(a1 + 32);
    do
    {
      uint64_t v11 = *v8++;
      *v10++ = *(void *)(v9 + 8 * v11);
      --v7;
    }
    while (v7);
  }
  return a1;
}

void sub_18E1569A8(void *a1)
{
  a1[16] = &unk_1EDD174A8;
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1569F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)(a1 + 24) = 0xA0000000ALL;
  *(_OWORD *)(a1 + 8) = xmmword_18E1FD870;
  *(void *)(a1 + 32) = a1 + 40;
  *(void *)a1 = &unk_1EDD16218;
  *(void *)(a1 + 840) = a2;
  *(void *)(a1 + 872) = 0x10000000ALL;
  *(void *)(a1 + 848) = &unk_1EDD17658;
  *(_OWORD *)(a1 + 856) = xmmword_18E200CF0;
  *(void *)(a1 + 880) = a1 + 888;
  *(void *)(a1 + 952) = 0x10000000ALL;
  *(void *)(a1 + 928) = &unk_1EDD17658;
  *(_OWORD *)(a1 + 936) = xmmword_18E200CF0;
  *(void *)(a1 + 960) = a1 + 968;
  sub_18DFEEA3C(a1 + 848, a3);
  sub_18DFEEA3C(a1 + 928, a4);
  uint64_t v7 = *(unsigned int *)(a1 + 864);
  uint64_t v8 = *(unsigned int *)(a1 + 944);
  *(_DWORD *)(a1 + 8) = v7;
  *(_DWORD *)(a1 + 12) = v8;
  *(_DWORD *)(a1 + 16) = v8 * v7;
  *(_DWORD *)(a1 + 20) = v7;
  if (v8)
  {
    unsigned int v9 = 0;
    uint64_t v10 = 0;
    int v11 = *(_DWORD *)(a2 + 20);
    uint64_t v12 = *(void *)(a2 + 32);
    do
    {
      if (v7)
      {
        unsigned int v13 = *(int **)(a1 + 880);
        int v14 = *(_DWORD *)(*(void *)(a1 + 960) + 4 * v10) * v11;
        uint64_t v15 = *(void *)(a1 + 32);
        unsigned int v16 = v9;
        uint64_t v17 = v7;
        do
        {
          int v18 = *v13++;
          *(void *)(v15 + 8 * v16++) = *(void *)(v12 + 8 * (v18 + v14));
          --v17;
        }
        while (v17);
      }
      ++v10;
      v9 += v7;
    }
    while (v10 != v8);
  }
  return a1;
}

void sub_18E156B64(void *a1)
{
  a1[116] = &unk_1EDD174A8;
  a1[106] = &unk_1EDD174A8;
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

void sub_18E156BD4(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E156C04(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E156C10(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unsigned int v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *unsigned int v9 = 1;
              unsigned int v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

uint64_t sub_18E156D10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 24) = 0x100000001;
  *(void *)&long long v5 = 0x100000001;
  *((void *)&v5 + 1) = 0x100000001;
  *(_OWORD *)(a1 + 8) = v5;
  *(void *)(a1 + 32) = a1 + 40;
  *(void *)a1 = &unk_1EDD16AE8;
  *(void *)(a1 + 48) = a2;
  *(void *)(a1 + 80) = 0x100000001;
  *(void *)(a1 + 56) = &unk_1EDD18078;
  *(_OWORD *)(a1 + 64) = v5;
  *(void *)(a1 + 88) = a1 + 96;
  sub_18DFEEA3C(a1 + 56, a3);
  int v7 = *(_DWORD *)(a1 + 64);
  int v6 = *(_DWORD *)(a1 + 68);
  *(_DWORD *)(a1 + 8) = v7;
  *(_DWORD *)(a1 + 12) = v6;
  uint64_t v8 = (v6 * v7);
  *(_DWORD *)(a1 + 16) = v8;
  *(_DWORD *)(a1 + 20) = v7;
  if ((int)v8 >= 1)
  {
    unsigned int v9 = *(int **)(a1 + 88);
    uint64_t v10 = *(void *)(a2 + 32);
    int v11 = *(void **)(a1 + 32);
    do
    {
      uint64_t v12 = *v9++;
      *v11++ = *(void *)(v10 + 8 * v12);
      --v8;
    }
    while (v8);
  }
  return a1;
}

void sub_18E156DE0(void *a1)
{
  a1[7] = &unk_1EDD174A8;
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

double sub_18E156E30(void *a1, unsigned int a2)
{
  a1[3] = 0x10000000ALL;
  a1[4] = 0;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDD17658;
  if ((a2 & 0x80000000) != 0) {
    __assert_rtn("CNMatrix", "cnmatrix.h", 419, "nr >= 0");
  }
  int32x4_t v2 = vdupq_lane_s32((int32x2_t)(a2 | 0x100000000), 0);
  v2.i32[1] = 1;
  *(int32x4_t *)(a1 + 1) = v2;
  a1[4] = a1 + 5;
  return *(double *)v2.i64;
}

void sub_18E156ECC(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD174A8;
  _Unwind_Resume(a1);
}

void sub_18E156EEC(void *a1)
{
  a1[22] = &unk_1EDD174A8;
  a1[16] = &unk_1EDD174A8;
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

void sub_18E156F5C(void *a1)
{
  sub_18E158458(a1);

  JUMPOUT(0x192FA6240);
}

void sub_18E156F94()
{
}

void sub_18E156FC0()
{
}

void sub_18E1570C8()
{
}

void sub_18E157144(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E157174(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E157180(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unsigned int v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *unsigned int v9 = 1;
              unsigned int v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void sub_18E157278(uint64_t a1)
{
  *(void *)(a1 + 24) = 0x1400000040;
  *(void *)a1 = &unk_1EDD196F8;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 8) = xmmword_18E21A190;
  sub_18E1570C8();
}

void sub_18E1572E0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1[5];
  v1[5] = 0;
  if (v3) {
    MEMORY[0x192FA6220](v3, 0x1000C8000313F17);
  }
  *unsigned int v1 = &unk_1EDD17478;
  _Unwind_Resume(exception_object);
}

void sub_18E157328(void *a1)
{
  *a1 = &unk_1EDD174A8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E157358(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E157364(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unsigned int v9 = &v13[v8];
          if (!v13[v8])
          {
            int v10 = *(_DWORD *)(v7 + 4 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              int v12 = *(_DWORD *)(v7 + 4 * v11);
              *(_DWORD *)(v7 + 4 * v11) = v10;
              *unsigned int v9 = 1;
              unsigned int v9 = &v13[v11];
              int v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

uint64_t sub_18E15745C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 24) = 0x10000002CLL;
  *(_OWORD *)(a1 + 8) = xmmword_18E21A0B0;
  *(void *)(a1 + 32) = a1 + 40;
  *(void *)a1 = &unk_1EDD16C68;
  uint64_t v5 = a1 + 400;
  *(void *)(a1 + 424) = 0x10000002CLL;
  *(void *)(a1 + 392) = a2;
  *(void *)(a1 + 400) = &unk_1EDD19158;
  *(_OWORD *)(a1 + 408) = xmmword_18E21A0B0;
  *(void *)(a1 + 432) = a1 + 440;
  sub_18DFEEA3C(a1 + 400, a3);
  int v6 = *(_DWORD *)(v5 + 8);
  int v7 = *(_DWORD *)(a1 + 412);
  *(_DWORD *)(a1 + 8) = v6;
  *(_DWORD *)(a1 + 12) = v7;
  uint64_t v8 = (v7 * v6);
  *(_DWORD *)(a1 + 16) = v8;
  *(_DWORD *)(a1 + 20) = v6;
  if ((int)v8 >= 1)
  {
    unsigned int v9 = *(int **)(a1 + 432);
    uint64_t v10 = *(void *)(a2 + 32);
    int v11 = *(void **)(a1 + 32);
    do
    {
      uint64_t v12 = *v9++;
      *v11++ = *(void *)(v10 + 8 * v12);
      --v8;
    }
    while (v8);
  }
  return a1;
}

void sub_18E157540(void *a1)
{
  a1[50] = &unk_1EDD174A8;
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

void sub_18E157590(uint64_t a1, int a2, int a3)
{
  *(void *)(a1 + 24) = 0x2C00000036;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EDD19638;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  if ((a2 & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 8) = a2;
    *(_DWORD *)(a1 + 12) = a3;
    *(_DWORD *)(a1 + 16) = a3 * a2;
    *(_DWORD *)(a1 + 20) = a2;
    sub_18E1577DC();
  }
  __assert_rtn("CNMatrix", "cnmatrix.h", 419, "nr >= 0");
}

void sub_18E157628(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1[5];
  v1[5] = 0;
  if (v3) {
    MEMORY[0x192FA6220](v3, 0x1000C8000313F17);
  }
  *unsigned int v1 = &unk_1EDD17478;
  _Unwind_Resume(exception_object);
}

void sub_18E157670(void *a1)
{
  sub_18E1586A0(a1);

  JUMPOUT(0x192FA6240);
}

void sub_18E1576A8()
{
}

void sub_18E1576D4()
{
}

void sub_18E1577DC()
{
}

void sub_18E157858(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E157888(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E157894(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unsigned int v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *unsigned int v9 = 1;
              unsigned int v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void *sub_18E157994(void *result)
{
  *double result = &unk_1EDD17478;
  return result;
}

void sub_18E1579B4(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1579E4(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E1579F0(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unsigned int v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *unsigned int v9 = 1;
              unsigned int v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void sub_18E157AE8(uint64_t a1)
{
  *(void *)(a1 + 24) = 0x2C0000002CLL;
  *(void *)a1 = &unk_1EDD191B8;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 8) = xmmword_18E21A1A0;
  sub_18E157D00();
}

void sub_18E157B4C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1[5];
  v1[5] = 0;
  if (v3) {
    MEMORY[0x192FA6220](v3, 0x1000C8000313F17);
  }
  *unsigned int v1 = &unk_1EDD17478;
  _Unwind_Resume(exception_object);
}

void sub_18E157B94(void *a1)
{
  sub_18E157F84(a1);

  JUMPOUT(0x192FA6240);
}

void sub_18E157BCC()
{
}

void sub_18E157BF8()
{
}

void sub_18E157D00()
{
}

void *sub_18E157D7C(void *result)
{
  *double result = &unk_1EDD17478;
  return result;
}

void sub_18E157D9C(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E157DCC(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E157DD8(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unsigned int v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *unsigned int v9 = 1;
              unsigned int v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void sub_18E157ED8(uint64_t a1, int a2, int a3)
{
  *(void *)(a1 + 24) = 0x2C0000002CLL;
  *(void *)a1 = &unk_1EDD191B8;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = a3;
  *(_DWORD *)(a1 + 16) = a3 * a2;
  *(_DWORD *)(a1 + 20) = a2;
  sub_18E157D00();
}

void sub_18E157F3C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1[5];
  v1[5] = 0;
  if (v3) {
    MEMORY[0x192FA6220](v3, 0x1000C8000313F17);
  }
  *unsigned int v1 = &unk_1EDD17478;
  _Unwind_Resume(exception_object);
}

void *sub_18E157F84(void *a1)
{
  *a1 = &unk_1EDD191B8;
  uint64_t v2 = a1[5];
  a1[5] = 0;
  if (v2) {
    MEMORY[0x192FA6220](v2, 0x1000C8000313F17);
  }
  *a1 = &unk_1EDD17478;
  return a1;
}

void sub_18E158000(void *a1)
{
  *a1 = &unk_1EDD174A8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E158030(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E15803C(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unsigned int v9 = &v13[v8];
          if (!v13[v8])
          {
            int v10 = *(_DWORD *)(v7 + 4 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              int v12 = *(_DWORD *)(v7 + 4 * v11);
              *(_DWORD *)(v7 + 4 * v11) = v10;
              *unsigned int v9 = 1;
              unsigned int v9 = &v13[v11];
              int v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void sub_18E158134(void *a1)
{
  *a1 = &unk_1EDD174A8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E158164(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E158170(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unsigned int v9 = &v13[v8];
          if (!v13[v8])
          {
            int v10 = *(_DWORD *)(v7 + 4 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              int v12 = *(_DWORD *)(v7 + 4 * v11);
              *(_DWORD *)(v7 + 4 * v11) = v10;
              *unsigned int v9 = 1;
              unsigned int v9 = &v13[v11];
              int v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void sub_18E158268(void *a1)
{
  *a1 = &unk_1EDD174A8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E158298(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E1582A4(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unsigned int v9 = &v13[v8];
          if (!v13[v8])
          {
            int v10 = *(_DWORD *)(v7 + 4 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              int v12 = *(_DWORD *)(v7 + 4 * v11);
              *(_DWORD *)(v7 + 4 * v11) = v10;
              *unsigned int v9 = 1;
              unsigned int v9 = &v13[v11];
              int v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

double sub_18E15839C(void *a1, unsigned int a2)
{
  a1[3] = 0x100000014;
  a1[4] = 0;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDD18498;
  if ((a2 & 0x80000000) != 0) {
    __assert_rtn("CNMatrix", "cnmatrix.h", 419, "nr >= 0");
  }
  int32x4_t v2 = vdupq_lane_s32((int32x2_t)(a2 | 0x100000000), 0);
  v2.i32[1] = 1;
  *(int32x4_t *)(a1 + 1) = v2;
  a1[4] = a1 + 5;
  return *(double *)v2.i64;
}

void sub_18E158438(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD174A8;
  _Unwind_Resume(a1);
}

void *sub_18E158458(void *a1)
{
  *a1 = &unk_1EDD196F8;
  uint64_t v2 = a1[5];
  a1[5] = 0;
  if (v2) {
    MEMORY[0x192FA6220](v2, 0x1000C8000313F17);
  }
  *a1 = &unk_1EDD17478;
  return a1;
}

void sub_18E1584D4(void *a1)
{
  *a1 = &unk_1EDD167B8;
  a1[44] = &unk_1EDD174A8;
  a1[7] = &unk_1EDD174A8;
  sub_18E158458(a1);

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E158568(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 24) = 0x100000040;
  *(_OWORD *)(a1 + 8) = xmmword_18E21A140;
  *(void *)(a1 + 32) = a1 + 40;
  *(void *)a1 = &unk_1EDD16CC8;
  *(void *)(a1 + 552) = a2;
  uint64_t v5 = a1 + 560;
  *(void *)(a1 + 584) = 0x100000040;
  *(void *)(a1 + 560) = &unk_1EDD196C8;
  *(_OWORD *)(a1 + 568) = xmmword_18E21A140;
  *(void *)(a1 + 592) = a1 + 600;
  sub_18DFEEA3C(a1 + 560, a3);
  int v6 = *(_DWORD *)(v5 + 8);
  int v7 = *(_DWORD *)(a1 + 572);
  *(_DWORD *)(a1 + 8) = v6;
  *(_DWORD *)(a1 + 12) = v7;
  uint64_t v8 = (v7 * v6);
  *(_DWORD *)(a1 + 16) = v8;
  *(_DWORD *)(a1 + 20) = v6;
  if ((int)v8 >= 1)
  {
    unsigned int v9 = *(int **)(a1 + 592);
    uint64_t v10 = *(void *)(a2 + 32);
    int v11 = *(void **)(a1 + 32);
    do
    {
      uint64_t v12 = *v9++;
      *v11++ = *(void *)(v10 + 8 * v12);
      --v8;
    }
    while (v8);
  }
  return a1;
}

void sub_18E158650(void *a1)
{
  a1[70] = &unk_1EDD174A8;
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

void *sub_18E1586A0(void *a1)
{
  *a1 = &unk_1EDD19638;
  uint64_t v2 = a1[5];
  a1[5] = 0;
  if (v2) {
    MEMORY[0x192FA6220](v2, 0x1000C8000313F17);
  }
  *a1 = &unk_1EDD17478;
  return a1;
}

void sub_18E15871C(void *a1)
{
  *a1 = &unk_1EDD19098;
  sub_18E15894C(a1 + 5);
  *a1 = &unk_1EDD17088;

  JUMPOUT(0x192FA6240);
}

void sub_18E15879C()
{
}

void sub_18E1587C8()
{
}

void sub_18E15891C(_Unwind_Exception *a1)
{
  MEMORY[0x192FA6220](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t *sub_18E15894C(uint64_t *result)
{
  uint64_t v1 = *result;
  *double result = 0;
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 392 * v2;
      uint64_t v4 = v1 - 392;
      do
      {
        *(void *)(v4 + v3) = &unk_1EDD17478;
        v3 -= 392;
      }
      while (v3);
    }
    JUMPOUT(0x192FA6220);
  }
  return result;
}

void sub_18E1589B0()
{
}

__n128 sub_18E158AC4(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0x10000002CLL;
  *(void *)(a1 + 24) = 0x10000002CLL;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EDD19128;
  if (a1 == a2)
  {
    uint64_t v17 = "this != &(A)";
    int v18 = 603;
    goto LABEL_16;
  }
  int v3 = *(_DWORD *)(a2 + 8);
  int v4 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = (v4 * v3);
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  int v6 = (unint64_t *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 0x2Cu)
  {
    uint64_t v17 = "this->max_num_rows_ >= A.num_rows_";
    int v18 = 616;
    goto LABEL_16;
  }
  if (*(_DWORD *)(a2 + 12) >= 2u)
  {
    uint64_t v17 = "this->max_num_cols_ >= A.num_cols_";
    int v18 = 617;
LABEL_16:
    __assert_rtn("CNMatrix", "cnmatrix.h", v18, v17);
  }
  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    int v11 = *(long long **)(a2 + 32);
    uint64_t v12 = (v7 - 1) >> 1;
    unsigned int v13 = v11;
    uint64_t v14 = (_OWORD *)(a1 + 40);
    do
    {
      long long v15 = *v13++;
      *v14++ = v15;
      --v12;
    }
    while (v12);
    uint64_t v16 = v10;
    __n128 result = *(__n128 *)((char *)v11 + v16 * 8);
    *(__n128 *)&v6[v16] = result;
  }
  else if ((int)v5 >= 1)
  {
    uint64_t v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *v6++ = v9;
      --v5;
    }
    while (v5);
  }
  return result;
}

void sub_18E158BF4(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

void sub_18E158C14(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E158C44(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E158C50(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unint64_t v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *unint64_t v9 = 1;
              unint64_t v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void sub_18E158D50(void *a1)
{
  a1[421] = &unk_1EDD174A8;
  a1[406] = &unk_1EDD174A8;
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

void sub_18E158DC0(void *a1)
{
  a1[26] = &unk_1EDD174A8;
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E158E10(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E158E1C(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unint64_t v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *unint64_t v9 = 1;
              unint64_t v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void sub_18E158F14(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

double sub_18E158F44(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a3 + 8);
  int v4 = *(_DWORD *)(a3 + 12);
  uint64_t v5 = (v4 * v3);
  *(void *)&double result = 0x10000000ALL;
  *(void *)(a1 + 24) = 0x10000000ALL;
  *(void *)a1 = &unk_1EDD17628;
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  uint64_t v7 = (double *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (v5)
  {
    uint64_t v8 = *(int **)(a3 + 32);
    do
    {
      uint64_t v9 = *v8++;
      double result = *(double *)(a2 + 8 * v9);
      *v7++ = result;
      --v5;
    }
    while (v5);
  }
  return result;
}

void *sub_18E158FA4(void *result)
{
  *double result = &unk_1EDD17478;
  return result;
}

void *sub_18E158FC4(void *result)
{
  result[5] = &unk_1EDD17478;
  *double result = &unk_1EDD16F08;
  return result;
}

void *sub_18E159004(void *result)
{
  result[5] = &unk_1EDD17478;
  *double result = &unk_1EDD16F38;
  return result;
}

void sub_18E159044(void *a1)
{
  a1[5] = &unk_1EDD17478;
  *a1 = &unk_1EDD16F38;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E159094(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E1590A0(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(&v11, v4);
      if (v4 >= 3)
      {
        int v6 = v3 + v1 - v5;
        int v7 = v4 - 1;
        int v8 = v11;
        uint64_t v9 = 120;
        int v10 = v6;
        do
        {
          sub_18E14E5D4((uint64_t)v13, *(void *)(a1 + 32) + v9);
          if (!v8)
          {
            sub_18E14E5D4((uint64_t)v12, *(void *)(a1 + 32) + 120 * (v10 % v7));
            sub_18DFE2F24(*(void *)(a1 + 32) + 120 * (v10 % v7), (uint64_t)v13);
            sub_18DFE2F24((uint64_t)v13, (uint64_t)v12);
            int v8 = 1;
          }
          v10 += v6;
          v9 += 120;
        }
        while (120 * v7 != v9);
      }
    }
  }
}

double sub_18E15919C(uint64_t a1, unsigned int a2)
{
  *(void *)(a1 + 24) = 0x100000001;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EDD17E68;
  *(void *)(a1 + 64) = 0xA0000000ALL;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = &unk_1EDD175C8;
  *(_OWORD *)(a1 + 48) = xmmword_18E1FD870;
  *(void *)(a1 + 72) = a1 + 80;
  if ((a2 & 0x80000000) != 0) {
    __assert_rtn("CNMatrix", "cnmatrix.h", 419, "nr >= 0");
  }
  int32x4_t v2 = vdupq_lane_s32((int32x2_t)(a2 | 0x100000000), 0);
  v2.i32[1] = 1;
  *(int32x4_t *)(a1 + 8) = v2;
  *(void *)(a1 + 32) = a1 + 40;
  return *(double *)v2.i64;
}

void sub_18E159268(_Unwind_Exception *a1)
{
  v1[5] = &unk_1EDD17478;
  *unsigned int v1 = &unk_1EDD16F08;
  _Unwind_Resume(a1);
}

void sub_18E1592A8(void *a1)
{
  a1[5] = &unk_1EDD17478;
  *a1 = &unk_1EDD16F08;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1592F8(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E159304(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(&v11, v4);
      if (v4 >= 3)
      {
        int v6 = v3 + v1 - v5;
        int v7 = v4 - 1;
        int v8 = v11;
        uint64_t v9 = 840;
        int v10 = v6;
        do
        {
          sub_18E14EBB4((uint64_t)v13, *(void *)(a1 + 32) + v9);
          if (!v8)
          {
            sub_18E14EBB4((uint64_t)v12, *(void *)(a1 + 32) + 840 * (v10 % v7));
            sub_18DFE2F24(*(void *)(a1 + 32) + 840 * (v10 % v7), (uint64_t)v13);
            sub_18DFE2F24((uint64_t)v13, (uint64_t)v12);
            int v8 = 1;
          }
          v10 += v6;
          v9 += 840;
        }
        while (840 * v7 != v9);
      }
    }
  }
}

void sub_18E159400(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E159430(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E15943C(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          uint64_t v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *uint64_t v9 = 1;
              uint64_t v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void *sub_18E15953C(void *result)
{
  *double result = &unk_1EDD174D8;
  return result;
}

void sub_18E15955C(void *a1)
{
  *a1 = &unk_1EDD174D8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E15958C(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E159598(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          uint64_t v9 = &v13[v8];
          if (!v13[v8])
          {
            int v10 = *(_DWORD *)(v7 + 4 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              int v12 = *(_DWORD *)(v7 + 4 * v11);
              *(_DWORD *)(v7 + 4 * v11) = v10;
              *uint64_t v9 = 1;
              uint64_t v9 = &v13[v11];
              int v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void *sub_18E159690(void *result)
{
  result[182] = &unk_1EDD174A8;
  *double result = &unk_1EDD16ED8;
  return result;
}

void *sub_18E1596D0(void *result)
{
  result[50] = &unk_1EDD174A8;
  *double result = &unk_1EDD174A8;
  return result;
}

void *sub_18E159710(void *result)
{
  result[94] = &unk_1EDD174A8;
  *double result = &unk_1EDD17478;
  return result;
}

void *sub_18E159750(void *a1)
{
  a1[7] = &unk_1EDD174A8;
  *a1 = &unk_1EDD19B48;
  sub_18E14D524(a1 + 5);
  *a1 = &unk_1EDD16F68;
  return a1;
}

void *sub_18E1597D4(void *result)
{
  result[94] = &unk_1EDD174A8;
  *double result = &unk_1EDD17208;
  return result;
}

void *sub_18E159814(void *result)
{
  result[94] = &unk_1EDD174A8;
  *double result = &unk_1EDD173E8;
  return result;
}

void sub_18E159854(void *a1)
{
  a1[182] = &unk_1EDD174A8;
  *a1 = &unk_1EDD16ED8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1598A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 24) = 0x100000058;
  *(_OWORD *)(a1 + 8) = xmmword_18E21A0A0;
  *(void *)(a1 + 32) = a1 + 40;
  *(void *)a1 = &unk_1EDD16E48;
  uint64_t v5 = a1 + 400;
  *(void *)(a1 + 424) = 0x100000058;
  *(void *)(a1 + 392) = a2;
  *(void *)(a1 + 400) = &unk_1EDD19C08;
  *(_OWORD *)(a1 + 408) = xmmword_18E21A0A0;
  *(void *)(a1 + 432) = a1 + 440;
  sub_18DFEEA3C(a1 + 400, a3);
  int v6 = *(_DWORD *)(v5 + 8);
  int v7 = *(_DWORD *)(a1 + 412);
  *(_DWORD *)(a1 + 8) = v6;
  *(_DWORD *)(a1 + 12) = v7;
  uint64_t v8 = (v7 * v6);
  *(_DWORD *)(a1 + 16) = v8;
  *(_DWORD *)(a1 + 20) = v6;
  if ((int)v8 >= 1)
  {
    uint64_t v9 = *(int **)(a1 + 432);
    uint64_t v10 = *(void *)(a2 + 32);
    int v11 = *(_DWORD **)(a1 + 32);
    do
    {
      uint64_t v12 = *v9++;
      *v11++ = *(_DWORD *)(v10 + 4 * v12);
      --v8;
    }
    while (v8);
  }
  return a1;
}

void sub_18E159988(void *a1)
{
  a1[50] = &unk_1EDD174A8;
  *a1 = &unk_1EDD174A8;
  JUMPOUT(0x192FA6240);
}

void sub_18E1599D8(void *a1)
{
  a1[94] = &unk_1EDD174A8;
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

void sub_18E159A28(uint64_t a1)
{
}

void sub_18E159B58(_Unwind_Exception *a1)
{
  v1[7] = &unk_1EDD174A8;
  *unsigned int v1 = &unk_1EDD19B48;
  sub_18E14D524(v2);
  *unsigned int v1 = &unk_1EDD16F68;
  _Unwind_Resume(a1);
}

void sub_18E159BC4(void *a1)
{
  a1[7] = &unk_1EDD174A8;
  *a1 = &unk_1EDD19B48;
  sub_18E14D524(a1 + 5);
  *a1 = &unk_1EDD16F68;

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E159C68(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v5 = *(_DWORD *)(a2 + 8);
    int v4 = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a1 + 8) = v5;
    *(_DWORD *)(a1 + 12) = v4;
    int v6 = v4 * v5;
    *(_DWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 20) = v5;
    int v7 = *(_DWORD *)(a2 + 16);
    if (v7 > 3)
    {
      unsigned int v10 = v7 - 1;
      uint64_t v11 = *(void *)(a1 + 32);
      uint64_t v12 = *(void *)(a2 + 32);
      uint64_t v13 = v11 + 48 * (v7 - 1);
      uint64_t v14 = v12;
      uint64_t v15 = (v7 - 1);
      do
      {
        sub_18DFE2F24(v11, v14);
        v11 += 48;
        v14 += 48;
        --v15;
      }
      while (v15);
      sub_18DFE2F24(v13, v12 + 48 * v10);
    }
    else if (v6 >= 1)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      do
      {
        sub_18DFE2F24(*(void *)(a1 + 32) + v8, *(void *)(a2 + 32) + v8);
        ++v9;
        v8 += 48;
      }
      while (v9 < *(int *)(a1 + 16));
    }
  }
  return a1;
}

void sub_18E159D50(void *a1)
{
  a1[94] = &unk_1EDD174A8;
  *a1 = &unk_1EDD17208;
  JUMPOUT(0x192FA6240);
}

void sub_18E159DA0(void *a1)
{
  a1[94] = &unk_1EDD174A8;
  *a1 = &unk_1EDD173E8;
  JUMPOUT(0x192FA6240);
}

void sub_18E159DF0(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E159E20(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E159E2C(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          uint64_t v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *uint64_t v9 = 1;
              uint64_t v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void sub_18E159F2C(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E159F5C(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E159F68(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          uint64_t v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *uint64_t v9 = 1;
              uint64_t v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

uint64_t raven::GnssReceiverBandCorrectionsFilter::TickFilterAndOverwriteCorrections(uint64_t *a1, uint64_t **a2, __n128 *a3, unsigned __int8 *a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  uint64_t v13 = a1[5];
  double v14 = *(double *)(v13 + 568);
  a10.i64[0] = *(void *)(v13 + 792);
  double v15 = fabs(*(double *)a10.i64);
  double v16 = 0.0;
  if (fabs(v14) >= 2.22044605e-16 && v15 >= 2.22044605e-16) {
    double v16 = 1.0 / ((1.0 / *(double *)a10.i64 / v14 - 1.0 / *(double *)a10.i64) * 6.28318531);
  }
  if (fabs(v16) < 2.22044605e-16)
  {
    LOWORD(v91) = 12;
    LOBYTE(v90) = 4;
    LOBYTE(v84) = LOBYTE(v14);
    int v18 = "#rxbc,Invalid receiver band correction LPF parameters,alpha,%.4f,sampling_freq,%.2f";
LABEL_8:
    unint64_t v19 = (cnprint::CNPrinter *)&v91;
    unsigned int v20 = (unsigned __int8 *)&v90;
LABEL_9:
    cnprint::CNPrinter::Print(v19, v20, v18, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, SLOBYTE(v84));
    return 0;
  }
  uint64_t v22 = (uint64_t *)(a2 + 1);
  uint64_t v23 = *a2;
  if (*a2 != (uint64_t *)(a2 + 1))
  {
    unsigned __int8 v87 = a1 + 2;
    while (1)
    {
      if (*((unsigned char *)v23 + 40))
      {
        uint64_t v24 = (double *)(v23 + 6);
        if ((v23[6] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          a10.i32[0] = *((_DWORD *)v23 + 14);
          BOOL v25 = (a10.i32[0] & 0x7FFFFFFFu) <= 0x7F7FFFFF && *(float *)a10.i32 < 20.0;
          if (v25)
          {
            double v26 = fabs(*((double *)v23 + 6));
            BOOL v25 = *(float *)a10.i32 > 0.0;
            a10.i64[0] = 0x3CB0000000000000;
            if (v25 && v26 >= 2.22044605e-16) {
              break;
            }
          }
        }
      }
LABEL_123:
      int v60 = (uint64_t *)v23[1];
      if (v60)
      {
        do
        {
          uint64_t v61 = v60;
          int v60 = (uint64_t *)*v60;
        }
        while (v60);
      }
      else
      {
        do
        {
          uint64_t v61 = (uint64_t *)v23[2];
          BOOL v78 = *v61 == (void)v23;
          uint64_t v23 = v61;
        }
        while (!v78);
      }
      uint64_t v23 = v61;
      if (v61 == v22) {
        goto LABEL_139;
      }
    }
    unint64_t v28 = *((unsigned __int8 *)v23 + 32);
    unint64_t v29 = a1[1];
    if (v29)
    {
      uint8x8_t v30 = (uint8x8_t)vcnt_s8((int8x8_t)v29);
      v30.i16[0] = vaddlv_u8(v30);
      if (v30.u32[0] > 1uLL)
      {
        int8x8_t prime = (int8x8_t)*((unsigned __int8 *)v23 + 32);
        if (v29 <= v28) {
          int8x8_t prime = (int8x8_t)(v28 % v29);
        }
      }
      else
      {
        int8x8_t prime = (int8x8_t)((v29 - 1) & v28);
      }
      uint64_t v31 = *(void ***)(*a1 + 8 * *(void *)&prime);
      if (v31)
      {
        uint64_t v32 = (unsigned __int8 *)*v31;
        if (*v31)
        {
          do
          {
            unint64_t v33 = *((void *)v32 + 1);
            if (v33 == v28)
            {
              if (v32[16] == v28) {
                goto LABEL_95;
              }
            }
            else
            {
              if (v30.u32[0] > 1uLL)
              {
                if (v33 >= v29) {
                  v33 %= v29;
                }
              }
              else
              {
                v33 &= v29 - 1;
              }
              if (v33 != *(void *)&prime) {
                break;
              }
            }
            uint64_t v32 = *(unsigned __int8 **)v32;
          }
          while (v32);
        }
      }
    }
    uint64_t v32 = (unsigned __int8 *)operator new(0xF8uLL);
    *(void *)uint64_t v32 = 0;
    *((void *)v32 + 1) = v28;
    v32[16] = *((unsigned char *)v23 + 32);
    *(_OWORD *)(v32 + 232) = 0u;
    *(_OWORD *)(v32 + 216) = 0u;
    *(_OWORD *)(v32 + 200) = 0u;
    *(_OWORD *)(v32 + 184) = 0u;
    *(_OWORD *)(v32 + 168) = 0u;
    *(_OWORD *)(v32 + 152) = 0u;
    *(_OWORD *)(v32 + 136) = 0u;
    *(_OWORD *)(v32 + 120) = 0u;
    *(_OWORD *)(v32 + 104) = 0u;
    *(_OWORD *)(v32 + 88) = 0u;
    *(_OWORD *)(v32 + 72) = 0u;
    *(_OWORD *)(v32 + 56) = 0u;
    *(_OWORD *)(v32 + 40) = 0u;
    *(_OWORD *)(v32 + 24) = 0u;
    *((void *)v32 + 29) = 0x7FF8000000000000;
    float v34 = (float)(unint64_t)(a1[3] + 1);
    a10.i32[0] = *((_DWORD *)a1 + 8);
    if (v29 && (float)(*(float *)a10.i32 * (float)v29) >= v34)
    {
      unint64_t v28 = (unint64_t)prime;
      goto LABEL_85;
    }
    BOOL v35 = (v29 & (v29 - 1)) != 0;
    if (v29 < 3) {
      BOOL v35 = 1;
    }
    unint64_t v36 = v35 | (2 * v29);
    unint64_t v37 = vcvtps_u32_f32(v34 / *(float *)a10.i32);
    if (v36 <= v37) {
      int8x8_t prime = (int8x8_t)v37;
    }
    else {
      int8x8_t prime = (int8x8_t)v36;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v29 = a1[1];
    }
    if (*(void *)&prime <= v29)
    {
      if (*(void *)&prime >= v29) {
        goto LABEL_81;
      }
      a10.i32[0] = *((_DWORD *)a1 + 8);
      unint64_t v44 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *(float *)a10.i32);
      if (v29 < 3 || (uint8x8_t v45 = (uint8x8_t)vcnt_s8((int8x8_t)v29), v45.i16[0] = vaddlv_u8(v45), v45.u32[0] > 1uLL))
      {
        unint64_t v44 = std::__next_prime(v44);
      }
      else
      {
        uint64_t v46 = 1 << -(char)__clz(v44 - 1);
        if (v44 >= 2) {
          unint64_t v44 = v46;
        }
      }
      if (*(void *)&prime <= v44) {
        int8x8_t prime = (int8x8_t)v44;
      }
      if (*(void *)&prime >= v29)
      {
        unint64_t v29 = a1[1];
        goto LABEL_81;
      }
      if (!*(void *)&prime)
      {
        int v62 = (void *)*a1;
        *a1 = 0;
        if (v62) {
          operator delete(v62);
        }
        unint64_t v29 = 0;
        a1[1] = 0;
        goto LABEL_81;
      }
    }
    if (*(void *)&prime >> 61) {
      sub_18DEDF7D4();
    }
    uint64_t v38 = operator new(8 * *(void *)&prime);
    uint64_t v39 = (void *)*a1;
    *a1 = (uint64_t)v38;
    if (v39) {
      operator delete(v39);
    }
    uint64_t v40 = 0;
    a1[1] = (uint64_t)prime;
    do
      *(void *)(*a1 + 8 * v40++) = 0;
    while (*(void *)&prime != v40);
    uint64_t v41 = (void *)*v87;
    if (*v87)
    {
      unint64_t v42 = v41[1];
      uint8x8_t v43 = (uint8x8_t)vcnt_s8(prime);
      v43.i16[0] = vaddlv_u8(v43);
      if (v43.u32[0] > 1uLL)
      {
        if (v42 >= *(void *)&prime) {
          v42 %= *(void *)&prime;
        }
      }
      else
      {
        v42 &= *(void *)&prime - 1;
      }
      *(void *)(*a1 + 8 * v42) = v87;
      unsigned int v47 = (void *)*v41;
      if (*v41)
      {
        do
        {
          unint64_t v48 = v47[1];
          if (v43.u32[0] > 1uLL)
          {
            if (v48 >= *(void *)&prime) {
              v48 %= *(void *)&prime;
            }
          }
          else
          {
            v48 &= *(void *)&prime - 1;
          }
          if (v48 != v42)
          {
            if (!*(void *)(*a1 + 8 * v48))
            {
              *(void *)(*a1 + 8 * v48) = v41;
              goto LABEL_77;
            }
            void *v41 = *v47;
            *unsigned int v47 = **(void **)(*a1 + 8 * v48);
            **(void **)(*a1 + 8 * v48) = v47;
            unsigned int v47 = v41;
          }
          unint64_t v48 = v42;
LABEL_77:
          uint64_t v41 = v47;
          unsigned int v47 = (void *)*v47;
          unint64_t v42 = v48;
        }
        while (v47);
      }
    }
    unint64_t v29 = (unint64_t)prime;
LABEL_81:
    if ((v29 & (v29 - 1)) != 0)
    {
      if (v29 <= v28) {
        v28 %= v29;
      }
    }
    else
    {
      unint64_t v28 = (v29 - 1) & v28;
    }
LABEL_85:
    uint64_t v49 = *a1;
    uint64_t v50 = *(void **)(*a1 + 8 * v28);
    if (v50)
    {
      *(void *)uint64_t v32 = *v50;
    }
    else
    {
      *(void *)uint64_t v32 = *v87;
      *unsigned __int8 v87 = v32;
      *(void *)(v49 + 8 * v28) = v87;
      if (!*(void *)v32)
      {
LABEL_94:
        ++a1[3];
LABEL_95:
        if (*((_DWORD *)v32 + 54) <= 0xBB7u)
        {
          double v52 = 1.0 / (float)(*((float *)v23 + 14) * *((float *)v23 + 14));
          if (sub_18DFF11E4((uint64_t)(v32 + 24), (double *)v23 + 6, v52))
          {
            sub_18E15AB90(a1, *((unsigned char *)v23 + 32));
            LOWORD(v91) = 12;
            LOBYTE(v90) = 4;
            LOBYTE(v84) = LOBYTE(v52);
            int v18 = "#rxbc,Could not add receiver band correction to weighted average filter,weight,%.4f,corr_value,%.4f";
            goto LABEL_8;
          }
          *(double *)&long long v91 = *((float *)v23 + 14);
          if (sub_18DFF11E4((uint64_t)(v32 + 72), (double *)&v91, 1.0))
          {
            sub_18E15AB90(a1, *((unsigned char *)v23 + 32));
            LOWORD(v91) = 12;
            LOBYTE(v90) = 4;
            double v84 = *((float *)v23 + 14);
            int v18 = "#rxbc,Could not add receiver band correction uncertainty to weighted average filter,uncertainty,%.4f";
            goto LABEL_8;
          }
          goto LABEL_120;
        }
        uint64_t v53 = v32 + 120;
        int8x8_t prime = (int8x8_t)(v32 + 168);
        if (v32[240])
        {
          if (!*v53)
          {
            sub_18E15AB90(a1, *((unsigned char *)v23 + 32));
            LOWORD(v91) = 12;
            LOBYTE(v90) = 4;
            double v84 = *((double *)v23 + 6);
            int v18 = "#rxbc,Could not add sample to receiver band correction LPF,sample_value,%.4f";
            goto LABEL_8;
          }
          if (!v32[144])
          {
            v32[144] = 1;
            double v54 = *v24;
LABEL_115:
            *((double *)v32 + 20) = v54;
            if (!**(unsigned char **)&prime)
            {
              sub_18E15AB90(a1, *((unsigned char *)v23 + 32));
              LOWORD(v91) = 12;
              LOBYTE(v90) = 4;
              double v84 = *((float *)v23 + 14);
              int v18 = "#rxbc,Could not add sample to receiver band correction uncertainty LPF,sample_value,%.4f";
              goto LABEL_8;
            }
            double v58 = *((float *)v23 + 14);
            if (v32[192])
            {
              a10.i64[0] = *((void *)v32 + 25);
              double v58 = (1.0 - *(double *)a10.i64) * *((double *)v32 + 26) + *(double *)a10.i64 * v58;
            }
            else
            {
              v32[192] = 1;
            }
            *((double *)v32 + 26) = v58;
LABEL_120:
            int v59 = *((_DWORD *)v32 + 54);
            if (v59 != -1) {
              *((_DWORD *)v32 + 54) = v59 + 1;
            }
            a9 = *(int8x16_t *)a3;
            *((__n128 *)v32 + 14) = *a3;
            goto LABEL_123;
          }
LABEL_114:
          a10.i64[0] = *((void *)v32 + 19);
          double v54 = (1.0 - *(double *)a10.i64) * *((double *)v32 + 20) + *(double *)a10.i64 * *v24;
          goto LABEL_115;
        }
        uint64_t v55 = *(void *)(a1[5] + 792);
        *(double *)&long long v91 = v16;
        *((void *)&v91 + 1) = v55;
        if (sub_18E15AAFC((uint64_t)v53, &v91) || sub_18E15AAFC((uint64_t)(v32 + 168), &v91))
        {
          sub_18E15AB90(a1, *((unsigned char *)v23 + 32));
          __int16 v90 = 12;
          char v89 = 4;
          LOBYTE(v84) = v91;
          int v18 = "#rxbc,Error in configuring receiver band correction LPF,lpf_cutoff_frequency,%.4f,signal_sample_frequency,%.4f";
        }
        else if (v32[120])
        {
          double v56 = *((double *)v32 + 6);
          if (v32[144]) {
            double v56 = (1.0 - *((double *)v32 + 19)) * *((double *)v32 + 20) + *((double *)v32 + 19) * v56;
          }
          else {
            v32[144] = 1;
          }
          *((double *)v32 + 20) = v56;
          if (v32[168])
          {
            double v57 = *((double *)v32 + 12);
            if (v32[192])
            {
              *((double *)v32 + 26) = (1.0 - *((double *)v32 + 25)) * *((double *)v32 + 26)
                                    + *((double *)v32 + 25) * v57;
            }
            else
            {
              v32[192] = 1;
              *((double *)v32 + 26) = v57;
            }
            v32[240] = 1;
            goto LABEL_114;
          }
          sub_18E15AB90(a1, *((unsigned char *)v23 + 32));
          __int16 v90 = 12;
          char v89 = 4;
          double v84 = *((double *)v32 + 12);
          int v18 = "#rxbc,Could not initialize receiver band correction uncertainty LPF,sample_value,%.4f";
        }
        else
        {
          sub_18E15AB90(a1, *((unsigned char *)v23 + 32));
          __int16 v90 = 12;
          char v89 = 4;
          double v84 = *((double *)v32 + 6);
          int v18 = "#rxbc,Could not initialize receiver band correction LPF,sample_value,%.4f";
        }
        unint64_t v19 = (cnprint::CNPrinter *)&v90;
        unsigned int v20 = (unsigned __int8 *)&v89;
        goto LABEL_9;
      }
      unint64_t v51 = *(void *)(*(void *)v32 + 8);
      if ((v29 & (v29 - 1)) != 0)
      {
        if (v51 >= v29) {
          v51 %= v29;
        }
      }
      else
      {
        v51 &= v29 - 1;
      }
      uint64_t v50 = (void *)(*a1 + 8 * v51);
    }
    *uint64_t v50 = v32;
    goto LABEL_94;
  }
LABEL_139:
  uint64_t v63 = a1[2];
  if (v63)
  {
    a9.i64[0] = 0x3F847AE147AE147BLL;
    double v64 = 0.01 / v16;
    do
    {
      while (1)
      {
        *(double *)a10.i64 = (double)CNTimeSpan::operator-((uint64_t)a3, (void *)(v63 + 224), a9, a10);
        *(double *)a9.i64 = v65 + *(double *)a10.i64;
        if (v65 + *(double *)a10.i64 < 0.0 || *(double *)a9.i64 > 10.0) {
          break;
        }
        unsigned int v67 = *(_DWORD *)(v63 + 216);
        if (v67 <= 9) {
          break;
        }
        if (*(unsigned char *)(v63 + 240)) {
          uint64_t v68 = 208;
        }
        else {
          uint64_t v68 = 96;
        }
        if (*(unsigned char *)(v63 + 240)) {
          uint64_t v69 = 160;
        }
        else {
          uint64_t v69 = 48;
        }
        unsigned int v70 = *(unsigned __int8 *)(v63 + 16);
        uint64_t v71 = *(uint64_t **)(v63 + v69);
        a9.i64[0] = *(void *)(v63 + v68);
        float v72 = *(double *)a9.i64;
        uint64_t v73 = *v22;
        if (*v22)
        {
          uint64_t v74 = v22;
          do
          {
            unsigned int v75 = *(unsigned __int8 *)(v73 + 32);
            BOOL v76 = v75 >= v70;
            if (v75 >= v70) {
              unsigned __int8 v77 = (uint64_t *)v73;
            }
            else {
              unsigned __int8 v77 = (uint64_t *)(v73 + 8);
            }
            if (v76) {
              uint64_t v74 = (uint64_t *)v73;
            }
            uint64_t v73 = *v77;
          }
          while (*v77);
          if (v74 != v22 && v70 >= *((unsigned __int8 *)v74 + 32))
          {
            a9.i32[0] = *((_DWORD *)v74 + 14);
            if (*(float *)a9.i32 > 20.0)
            {
              if (v67 < 0x64) {
                goto LABEL_188;
              }
              BOOL v78 = *(float *)a9.i32 < v72 || v70 == 0;
              if (v78) {
                goto LABEL_188;
              }
LABEL_176:
              if (((unint64_t)v71 & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL
                || (LODWORD(v72) & 0x7FFFFFFFu) > 0x7F7FFFFF)
              {
                goto LABEL_188;
              }
              if (*(unsigned char *)(a1[5] + 550))
              {
                int v79 = *a5;
                if ((v79 - 3) >= 2)
                {
                  float v81 = 1.0;
                  if (v79 == 2)
                  {
                    unsigned int v80 = *a4;
                    if (v80 < 0xA)
                    {
                      uint64_t v82 = (float *)&unk_18E21AFBC;
LABEL_185:
                      float v81 = v82[(char)v80];
                    }
                  }
                }
                else
                {
                  unsigned int v80 = *a4;
                  float v81 = 0.5;
                  if (v80 <= 9)
                  {
                    uint64_t v82 = (float *)&unk_18E21AFE4;
                    goto LABEL_185;
                  }
                }
                float v72 = v81 * v72;
              }
              *(void *)&long long v91 = v63 + 16;
              uint64_t v83 = sub_18E0E8160(a2, (unsigned __int8 *)(v63 + 16), (uint64_t)&std::piecewise_construct, (unsigned char **)&v91);
              *((unsigned char *)v83 + 40) = v70;
              *(_DWORD *)((char *)v83 + 41) = v91;
              *((_DWORD *)v83 + 11) = *(_DWORD *)((char *)&v91 + 3);
              v83[6] = v71;
              *((float *)v83 + 14) = v72;
              goto LABEL_188;
            }
          }
        }
        if (*(unsigned char *)(v63 + 16)) {
          goto LABEL_176;
        }
LABEL_188:
        uint64_t v63 = *(void *)v63;
        if (!v63) {
          return 1;
        }
      }
      if (*(double *)a9.i64 <= v64) {
        goto LABEL_188;
      }
      uint64_t v63 = sub_18E15AC40(a1, (uint64_t *)v63);
    }
    while (v63);
  }
  return 1;
}

void sub_18E15AAE4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_18E15AAFC(uint64_t a1, long long *a2)
{
  uint64_t v2 = 0xFFFFFFFFLL;
  if ((*(void *)a2 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && *(double *)a2 > 0.0)
  {
    uint64_t v2 = 0xFFFFFFFFLL;
    if ((*((void *)a2 + 1) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && *((double *)a2 + 1) > 0.0)
    {
      uint64_t v2 = 0;
      *(unsigned char *)a1 = 0;
      long long v3 = *a2;
      *(unsigned char *)a1 = 1;
      *(_OWORD *)(a1 + 8) = v3;
      *(double *)(a1 + 32) = 1.0
                           / *(double *)(a1 + 16)
                           / (1.0 / (*(double *)(a1 + 8) * 6.28318531) + 1.0 / *(double *)(a1 + 16));
      *(unsigned char *)(a1 + 24) = 0;
      *(void *)(a1 + 40) = 0;
    }
  }
  return v2;
}

void *sub_18E15AB90(void *result, unsigned __int8 a2)
{
  unint64_t v2 = result[1];
  if (v2)
  {
    uint64_t v3 = a2;
    uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL)
    {
      unint64_t v5 = a2;
      if (v2 <= a2) {
        unint64_t v5 = a2 % v2;
      }
    }
    else
    {
      unint64_t v5 = (v2 - 1) & a2;
    }
    uint64_t v6 = *(uint64_t **)(*result + 8 * v5);
    if (v6)
    {
      for (uint64_t i = *v6; i; uint64_t i = *(void *)i)
      {
        unint64_t v8 = *(void *)(i + 8);
        if (v8 == v3)
        {
          if (*(unsigned __int8 *)(i + 16) == v3) {
            return (void *)sub_18E15AC40(result, (uint64_t *)i);
          }
        }
        else
        {
          if (v4.u32[0] > 1uLL)
          {
            if (v8 >= v2) {
              v8 %= v2;
            }
          }
          else
          {
            v8 &= v2 - 1;
          }
          if (v8 != v5) {
            return result;
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_18E15AC40(void *a1, uint64_t *__p)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  uint64_t v4 = *__p;
  unint64_t v3 = __p[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v2);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v3 >= *(void *)&v2) {
      v3 %= *(void *)&v2;
    }
  }
  else
  {
    v3 &= *(void *)&v2 - 1;
  }
  uint64_t v6 = *(uint64_t **)(*a1 + 8 * v3);
  do
  {
    uint64_t v7 = v6;
    uint64_t v6 = (uint64_t *)*v6;
  }
  while (v6 != __p);
  if (v7 != a1 + 2)
  {
    unint64_t v8 = v7[1];
    if (v5.u32[0] > 1uLL)
    {
      if (v8 >= *(void *)&v2) {
        v8 %= *(void *)&v2;
      }
    }
    else
    {
      v8 &= *(void *)&v2 - 1;
    }
    uint64_t v9 = *__p;
    if (v8 == v3)
    {
LABEL_20:
      if (!v9) {
        goto LABEL_27;
      }
      goto LABEL_21;
    }
  }
  if (!v4) {
    goto LABEL_19;
  }
  unint64_t v10 = *(void *)(v4 + 8);
  if (v5.u32[0] > 1uLL)
  {
    if (v10 >= *(void *)&v2) {
      v10 %= *(void *)&v2;
    }
  }
  else
  {
    v10 &= *(void *)&v2 - 1;
  }
  uint64_t v9 = *__p;
  if (v10 != v3)
  {
LABEL_19:
    *(void *)(*a1 + 8 * v3) = 0;
    uint64_t v9 = *__p;
    goto LABEL_20;
  }
LABEL_21:
  unint64_t v11 = *(void *)(v9 + 8);
  if (v5.u32[0] > 1uLL)
  {
    if (v11 >= *(void *)&v2) {
      v11 %= *(void *)&v2;
    }
  }
  else
  {
    v11 &= *(void *)&v2 - 1;
  }
  if (v11 != v3)
  {
    *(void *)(*a1 + 8 * v11) = v7;
    uint64_t v9 = *__p;
  }
LABEL_27:
  uint64_t *v7 = v9;
  *std::string __p = 0;
  --a1[3];
  operator delete(__p);
  return v4;
}

void raven::AccelerometerEvent::~AccelerometerEvent(raven::AccelerometerEvent *this)
{
}

void raven::AccelerometerMeasurement::~AccelerometerMeasurement(raven::AccelerometerMeasurement *this)
{
  *(void *)this = &unk_1EDD0A3F0;
}

{
  *(void *)this = &unk_1EDD0A3F0;
}

{
  *(void *)this = &unk_1EDD0A3F0;
  JUMPOUT(0x192FA6240);
}

void raven::AccessoryVehicleSpeedEvent::~AccessoryVehicleSpeedEvent(raven::AccessoryVehicleSpeedEvent *this)
{
  *(void *)this = &unk_1EDD14A68;
  int8x8_t v2 = (void *)*((void *)this + 29);
  if (v2)
  {
    *((void *)this + 30) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 26);
  if (v3)
  {
    *((void *)this + 27) = v3;
    operator delete(v3);
  }
}

{
  uint64_t vars8;

  raven::AccessoryVehicleSpeedEvent::~AccessoryVehicleSpeedEvent(this);

  JUMPOUT(0x192FA6240);
}

void raven::ActivityInputEvent::~ActivityInputEvent(raven::ActivityInputEvent *this)
{
}

void raven::ActivityStateEvent::~ActivityStateEvent(raven::ActivityStateEvent *this)
{
}

void raven::AltitudeChangeEvent::~AltitudeChangeEvent(raven::AltitudeChangeEvent *this)
{
}

void raven::AltitudeEvent::~AltitudeEvent(raven::AltitudeEvent *this)
{
}

void raven::ARSessionStatusEvent::~ARSessionStatusEvent(raven::ARSessionStatusEvent *this)
{
}

void raven::AttitudeChangeEvent::~AttitudeChangeEvent(raven::AttitudeChangeEvent *this)
{
  *(void *)this = &unk_1EDD141B0;
  *((void *)this + 29) = &unk_1EDD17478;
}

{
  *(void *)this = &unk_1EDD141B0;
  *((void *)this + 29) = &unk_1EDD17478;
}

{
  *(void *)this = &unk_1EDD141B0;
  *((void *)this + 29) = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

void raven::AttitudeEvent::~AttitudeEvent(raven::AttitudeEvent *this)
{
}

void raven::BarometerEvent::~BarometerEvent(raven::BarometerEvent *this)
{
}

void raven::BodyMetricsEvent::~BodyMetricsEvent(raven::BodyMetricsEvent *this)
{
}

void raven::DecomposedAccelerationEvent::~DecomposedAccelerationEvent(raven::DecomposedAccelerationEvent *this)
{
}

void raven::EstimatorErrorRecoveryEvent::~EstimatorErrorRecoveryEvent(raven::EstimatorErrorRecoveryEvent *this)
{
}

void raven::FitnessSessionEvent::~FitnessSessionEvent(raven::FitnessSessionEvent *this)
{
}

void raven::GEOMapBuildingDataEvent::~GEOMapBuildingDataEvent(raven::GEOMapBuildingDataEvent *this)
{
  *(void *)this = &unk_1EDD14628;
  sub_18E012A10((uint64_t)this + 144, *((void **)this + 19));
  int8x8_t v2 = (void **)((char *)this + 104);
  sub_18E0DDF5C(&v2);
}

{
  void **v2;

  *(void *)this = &unk_1EDD14628;
  sub_18E012A10((uint64_t)this + 144, *((void **)this + 19));
  int8x8_t v2 = (void **)((char *)this + 104);
  sub_18E0DDF5C(&v2);
}

{
  void **v2;
  uint64_t vars8;

  *(void *)this = &unk_1EDD14628;
  sub_18E012A10((uint64_t)this + 144, *((void **)this + 19));
  int8x8_t v2 = (void **)((char *)this + 104);
  sub_18E0DDF5C(&v2);

  JUMPOUT(0x192FA6240);
}

void raven::GnssAvailabilityEvent::~GnssAvailabilityEvent(raven::GnssAvailabilityEvent *this)
{
}

void raven::GnssMeasurementDataEvent::~GnssMeasurementDataEvent(raven::GnssMeasurementDataEvent *this)
{
  *(void *)this = &unk_1EDD14688;
  sub_18E15E380((uint64_t)this + 112);
}

{
  *(void *)this = &unk_1EDD14688;
  sub_18E15E380((uint64_t)this + 112);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EDD14688;
  sub_18E15E380((uint64_t)this + 112);

  JUMPOUT(0x192FA6240);
}

void raven::GnssPreprocessedMeasurementsEvent::~GnssPreprocessedMeasurementsEvent(raven::GnssPreprocessedMeasurementsEvent *this)
{
  *(void *)this = &unk_1EDD154D0;
  unsigned int v1 = (void **)((char *)this + 96);
  sub_18DEE4B60(&v1);
}

{
  void **v1;

  *(void *)this = &unk_1EDD154D0;
  unsigned int v1 = (void **)((char *)this + 96);
  sub_18DEE4B60(&v1);
}

{
  void **v2;

  *(void *)this = &unk_1EDD154D0;
  int8x8_t v2 = (void **)((char *)this + 96);
  sub_18DEE4B60(&v2);
  MEMORY[0x192FA6240](this, 0x10A1C40DFD4140ELL);
}

void raven::GNSSUTCParametersEvent::~GNSSUTCParametersEvent(raven::GNSSUTCParametersEvent *this)
{
}

void raven::HorizontalDOTInIMUFrameEvent::~HorizontalDOTInIMUFrameEvent(raven::HorizontalDOTInIMUFrameEvent *this)
{
  *(void *)this = &unk_1EDD14DC8;
  *((void *)this + 27) = &unk_1EDD17478;
  *((void *)this + 1) = &unk_1EDD17478;
}

{
  *(void *)this = &unk_1EDD14DC8;
  *((void *)this + 27) = &unk_1EDD17478;
  *((void *)this + 1) = &unk_1EDD17478;
}

{
  *(void *)this = &unk_1EDD14DC8;
  *((void *)this + 27) = &unk_1EDD17478;
  *((void *)this + 1) = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

void raven::KlobucharParametersEvent::~KlobucharParametersEvent(raven::KlobucharParametersEvent *this)
{
  *(void *)this = &unk_1EDD146B8;
}

{
  *(void *)this = &unk_1EDD146B8;
}

{
  *(void *)this = &unk_1EDD146B8;
  JUMPOUT(0x192FA6240);
}

void raven::MapsRouteHintEvent::~MapsRouteHintEvent(raven::MapsRouteHintEvent *this)
{
  *(void *)this = &unk_1EDD140E8;
  int8x8_t v2 = (void *)*((void *)this + 26);
  if (v2)
  {
    *((void *)this + 27) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(void *)this = &unk_1EDD140E8;
  int8x8_t v2 = (void *)*((void *)this + 26);
  if (v2)
  {
    *((void *)this + 27) = v2;
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EDD140E8;
  int8x8_t v2 = (void *)*((void *)this + 26);
  if (v2)
  {
    *((void *)this + 27) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x192FA6240);
}

void raven::MapVectorEvent::~MapVectorEvent(raven::MapVectorEvent *this)
{
}

void raven::MountStateEvent::~MountStateEvent(raven::MountStateEvent *this)
{
}

void raven::MovingStateEvent::~MovingStateEvent(raven::MovingStateEvent *this)
{
}

void raven::NonHolonomicVelocityConstraintEvent::~NonHolonomicVelocityConstraintEvent(raven::NonHolonomicVelocityConstraintEvent *this)
{
}

void raven::OdometerEvent::~OdometerEvent(raven::OdometerEvent *this)
{
}

void raven::PositionChangeEvent::~PositionChangeEvent(raven::PositionChangeEvent *this)
{
  *(void *)this = &unk_1EDD14210;
  *((void *)this + 33) = &unk_1EDD17478;
  *((void *)this + 25) = &unk_1EDD17478;
}

{
  *(void *)this = &unk_1EDD14210;
  *((void *)this + 33) = &unk_1EDD17478;
  *((void *)this + 25) = &unk_1EDD17478;
}

{
  *(void *)this = &unk_1EDD14210;
  *((void *)this + 33) = &unk_1EDD17478;
  *((void *)this + 25) = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

void raven::PositionContextStateEvent::~PositionContextStateEvent(raven::PositionContextStateEvent *this)
{
}

void raven::PositionEvent::~PositionEvent(raven::PositionEvent *this)
{
}

void raven::PrefilteredBarometerEvent::~PrefilteredBarometerEvent(raven::PrefilteredBarometerEvent *this)
{
}

void raven::PrefilteredPressureResetEvent::~PrefilteredPressureResetEvent(raven::PrefilteredPressureResetEvent *this)
{
}

void raven::RateGyroEvent::~RateGyroEvent(raven::RateGyroEvent *this)
{
}

void raven::RateGyroMeasurement::~RateGyroMeasurement(raven::RateGyroMeasurement *this)
{
  *(void *)this = &unk_1EDD0A3C0;
}

{
  *(void *)this = &unk_1EDD0A3C0;
}

{
  *(void *)this = &unk_1EDD0A3C0;
  JUMPOUT(0x192FA6240);
}

void raven::RavenGnssAssistanceFileEvent::~RavenGnssAssistanceFileEvent(raven::RavenGnssAssistanceFileEvent *this)
{
  *(void *)this = &unk_1EDD14DF8;
  int8x8_t v2 = (void *)*((void *)this + 15);
  if (v2)
  {
    *((void *)this + 16) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(void *)this = &unk_1EDD14DF8;
  int8x8_t v2 = (void *)*((void *)this + 15);
  if (v2)
  {
    *((void *)this + 16) = v2;
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EDD14DF8;
  int8x8_t v2 = (void *)*((void *)this + 15);
  if (v2)
  {
    *((void *)this + 16) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x192FA6240);
}

void raven::RavenSolutionEvent::~RavenSolutionEvent(raven::RavenSolutionEvent *this)
{
}

void raven::RavenSystemEvent::~RavenSystemEvent(raven::RavenSystemEvent *this)
{
}

void raven::RayTracingTileEvent::~RayTracingTileEvent(void **this)
{
  *this = &unk_1EDD14270;
  if (*((char *)this + 127) < 0) {
    operator delete(this[13]);
  }
}

{
  *this = &unk_1EDD14270;
  if (*((char *)this + 127) < 0) {
    operator delete(this[13]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EDD14270;
  if (*((char *)this + 127) < 0) {
    operator delete(this[13]);
  }

  JUMPOUT(0x192FA6240);
}

void raven::ReceiverDifferentialCodeBiasesEvent::~ReceiverDifferentialCodeBiasesEvent(raven::ReceiverDifferentialCodeBiasesEvent *this)
{
}

void raven::SignalEnvironmentEvent::~SignalEnvironmentEvent(raven::SignalEnvironmentEvent *this)
{
}

void raven::SignalPeriodicityAnalysisEvent::~SignalPeriodicityAnalysisEvent(raven::SignalPeriodicityAnalysisEvent *this)
{
}

void raven::StepCountEvent::~StepCountEvent(raven::StepCountEvent *this)
{
}

void raven::ThinShellIonosphereParametersEvent::~ThinShellIonosphereParametersEvent(raven::ThinShellIonosphereParametersEvent *this)
{
}

void raven::TimeMarkEvent::~TimeMarkEvent(raven::TimeMarkEvent *this)
{
}

void raven::TimerEvent::~TimerEvent(raven::TimerEvent *this)
{
}

void raven::TunnelBridgeNotificationEvent::~TunnelBridgeNotificationEvent(raven::TunnelBridgeNotificationEvent *this)
{
}

void raven::TunnelEndPointAssistanceEvent::~TunnelEndPointAssistanceEvent(raven::TunnelEndPointAssistanceEvent *this)
{
}

void raven::TurnStateEvent::~TurnStateEvent(raven::TurnStateEvent *this)
{
}

void raven::UserGaitEvent::~UserGaitEvent(raven::UserGaitEvent *this)
{
}

void raven::UserSpeedEvent::~UserSpeedEvent(raven::UserSpeedEvent *this)
{
}

void raven::VelocityEvent::~VelocityEvent(raven::VelocityEvent *this)
{
}

void raven::VIOEstimateEvent::~VIOEstimateEvent(raven::VIOEstimateEvent *this)
{
  *(void *)this = &unk_1EDD13DC0;
  *((void *)this + 133) = &unk_1EDD17478;
  *((void *)this + 119) = &unk_1EDD17478;
  *((void *)this + 105) = &unk_1EDD17478;
  *((void *)this + 97) = &unk_1EDD17478;
  *((void *)this + 78) = &unk_1EDD17478;
  *((void *)this + 64) = &unk_1EDD17478;
  *((void *)this + 50) = &unk_1EDD17478;
  *((void *)this + 42) = &unk_1EDD17478;
}

{
  uint64_t vars8;

  raven::VIOEstimateEvent::~VIOEstimateEvent(this);

  JUMPOUT(0x192FA6240);
}

void raven::VLLocalizationEvent::~VLLocalizationEvent(raven::VLLocalizationEvent *this)
{
  *(void *)this = &unk_1EDD142A0;
  *((void *)this + 120) = &unk_1EDD17478;
  *((void *)this + 106) = &unk_1EDD17478;
  *((void *)this + 92) = &unk_1EDD17478;
  *((void *)this + 84) = &unk_1EDD17478;
  *((void *)this + 65) = &unk_1EDD17478;
  *((void *)this + 51) = &unk_1EDD17478;
  *((void *)this + 37) = &unk_1EDD17478;
  *((void *)this + 29) = &unk_1EDD17478;
}

{
  uint64_t vars8;

  raven::VLLocalizationEvent::~VLLocalizationEvent(this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenAccelerationDecompositionActiveObject::~RavenAccelerationDecompositionActiveObject(raven::RavenAccelerationDecompositionActiveObject *this)
{
  *(void *)this = &unk_1EDD15F78;
  sub_18DFFF978((void *)this + 2260);
  *((void *)this + 2181) = &unk_1EDD0B230;
  *((void *)this + 2241) = &unk_1EDD17478;
  *((void *)this + 2220) = &unk_1EDD17478;
  *((void *)this + 2211) = &unk_1EDD17478;
  *((void *)this + 2198) = &unk_1EDD17478;
  *((void *)this + 2189) = &unk_1EDD17478;
  int8x8_t v2 = (char *)this + 17296;
  uint64_t v3 = 16800;
  do
  {
    *(void *)((char *)this + v3 + 496) = &unk_1EDD0A3C0;
    v2 -= 48;
    v3 -= 48;
  }
  while (v3);
  *((void *)this + 62) = &unk_1EDD0A6C8;

  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  raven::RavenAccelerationDecompositionActiveObject::~RavenAccelerationDecompositionActiveObject(this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenCoarseOdometerActiveObject::~RavenCoarseOdometerActiveObject(raven::RavenCoarseOdometerActiveObject *this)
{
  cnframework::ActiveObjectBase::~ActiveObjectBase(this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenConvergenceEstimatorActiveObject::~RavenConvergenceEstimatorActiveObject(raven::RavenConvergenceEstimatorActiveObject *this)
{
  *(void *)this = &unk_1EDD15B08;
  int8x8_t v2 = (char *)this + 3000;
  *((void *)this + 375) = &unk_1EDD14798;
  sub_18E0B687C((uint64_t *)this + 1417);
  *((void *)this + 1408) = &unk_1EDD0A6A8;
  sub_18E067E60((uint64_t)this + 8704);
  *((void *)this + 705) = &unk_1EDD0A818;
  *((void *)this + 1006) = &unk_1EDD17478;
  *((void *)this + 993) = &unk_1EDD17478;
  *((void *)this + 924) = &unk_1EDD17478;
  sub_18E0B6C34((uint64_t)this + 5640);
  sub_18E0268B0((uint64_t)v2);

  sub_18E0B6554((void **)this);
}

{
  uint64_t vars8;

  raven::RavenConvergenceEstimatorActiveObject::~RavenConvergenceEstimatorActiveObject(this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenDeltaAltitudeActiveObject::~RavenDeltaAltitudeActiveObject(raven::RavenDeltaAltitudeActiveObject *this)
{
  *(void *)this = &unk_1EDD14F90;
  sub_18E15E6D4((uint64_t)this + 536);

  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EDD14F90;
  sub_18E15E6D4((uint64_t)this + 536);

  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EDD14F90;
  sub_18E15E6D4((uint64_t)this + 536);
  cnframework::ActiveObjectBase::~ActiveObjectBase(this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenGnssPreprocessorActiveObject::~RavenGnssPreprocessorActiveObject(raven::RavenGnssPreprocessorActiveObject *this)
{
  *(void *)this = &unk_1EDD15570;
  sub_18E15E488((uint64_t)this + 488);

  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EDD15570;
  sub_18E15E488((uint64_t)this + 488);

  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EDD15570;
  sub_18E15E488((uint64_t)this + 488);
  cnframework::ActiveObjectBase::~ActiveObjectBase(this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenIMUPreprocessorActiveObject::~RavenIMUPreprocessorActiveObject(raven::RavenIMUPreprocessorActiveObject *this)
{
  *(void *)this = &unk_1EDD153B8;
  sub_18DFFF978((void *)this + 86);
  sub_18DEE2DB8((void *)this + 80);
  sub_18DFFF978((void *)this + 71);
  sub_18DEE2DB8((void *)this + 65);

  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  raven::RavenIMUPreprocessorActiveObject::~RavenIMUPreprocessorActiveObject(this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenIntegrityEstimatorActiveObject::~RavenIntegrityEstimatorActiveObject(raven::RavenIntegrityEstimatorActiveObject *this)
{
  *(void *)this = &unk_1EDD15868;
  sub_18E0B760C((uint64_t)this + 496);

  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EDD15868;
  sub_18E0B760C((uint64_t)this + 496);

  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EDD15868;
  sub_18E0B760C((uint64_t)this + 496);
  cnframework::ActiveObjectBase::~ActiveObjectBase(this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenMountStateEstimatorActiveObject::~RavenMountStateEstimatorActiveObject(raven::RavenMountStateEstimatorActiveObject *this)
{
  *(void *)this = &unk_1EDD15A70;
  sub_18E0B79E0((void *)this + 62);

  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EDD15A70;
  sub_18E0B79E0((void *)this + 62);

  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EDD15A70;
  sub_18E0B79E0((void *)this + 62);
  cnframework::ActiveObjectBase::~ActiveObjectBase(this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenPassThroughEstimatorActiveObject::~RavenPassThroughEstimatorActiveObject(raven::RavenPassThroughEstimatorActiveObject *this)
{
  *(void *)this = &unk_1EDD15C00;
  *((void *)this + 68) = &unk_1EDD14928;
  sub_18E0268B0((uint64_t)this + 544);

  sub_18E0B7FF0((void **)this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EDD15C00;
  *((void *)this + 68) = &unk_1EDD14928;
  sub_18E0268B0((uint64_t)this + 544);

  sub_18E0B7FF0((void **)this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EDD15C00;
  *((void *)this + 68) = &unk_1EDD14928;
  sub_18E0268B0((uint64_t)this + 544);
  sub_18E0B7FF0((void **)this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenPeriodicityTrackerActiveObject::~RavenPeriodicityTrackerActiveObject(raven::RavenPeriodicityTrackerActiveObject *this)
{
  *(void *)this = &unk_1EDD15E10;
  sub_18DEE2E60((void *)this + 80);
  sub_18DEE2DB8((void *)this + 74);

  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  raven::RavenPeriodicityTrackerActiveObject::~RavenPeriodicityTrackerActiveObject(this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenPNTEstimatorActiveObject::~RavenPNTEstimatorActiveObject(void **this)
{
  *this = &unk_1EDD14E58;
  sub_18E06955C((uint64_t)(this + 68));

  sub_18E0B7D28(this);
}

{
  uint64_t vars8;

  *this = &unk_1EDD14E58;
  sub_18E06955C((uint64_t)(this + 68));

  sub_18E0B7D28(this);
}

{
  uint64_t vars8;

  *this = &unk_1EDD14E58;
  sub_18E06955C((uint64_t)(this + 68));
  sub_18E0B7D28(this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenSolutionPostprocessorActiveObject::~RavenSolutionPostprocessorActiveObject(raven::RavenSolutionPostprocessorActiveObject *this)
{
  *(void *)this = &unk_1EDD15CB0;
  if (*((unsigned char *)this + 1856)) {
    *((unsigned char *)this + 1856) = 0;
  }
  sub_18E0216A4((void *)this + 62);

  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  raven::RavenSolutionPostprocessorActiveObject::~RavenSolutionPostprocessorActiveObject(this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenSolutionSelectorActiveObject::~RavenSolutionSelectorActiveObject(raven::RavenSolutionSelectorActiveObject *this)
{
  *(void *)this = &unk_1EDD155E0;
  if (*((unsigned char *)this + 952)) {
    *((unsigned char *)this + 952) = 0;
  }
  sub_18E011990((uint64_t)this + 888);
  if (*((unsigned char *)this + 648)) {
    *((unsigned char *)this + 648) = 0;
  }
  sub_18E011990((uint64_t)this + 576);
  sub_18E011990((uint64_t)this + 536);
  sub_18E011990((uint64_t)this + 496);

  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  raven::RavenSolutionSelectorActiveObject::~RavenSolutionSelectorActiveObject(this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenTimerActiveObject::~RavenTimerActiveObject(raven::RavenTimerActiveObject *this)
{
  *(void *)this = &unk_1EDD14560;
  if (*((unsigned char *)this + 656)) {
    *((unsigned char *)this + 656) = 0;
  }
  if (*((unsigned char *)this + 480)) {
    *((unsigned char *)this + 480) = 0;
  }
  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  raven::RavenTimerActiveObject::~RavenTimerActiveObject(this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenUserSpeedActiveObject::~RavenUserSpeedActiveObject(raven::RavenUserSpeedActiveObject *this)
{
  *(void *)this = &unk_1EDD14B08;
  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  *(void *)this = &unk_1EDD14B08;
  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EDD14B08;
  cnframework::ActiveObjectBase::~ActiveObjectBase(this);

  JUMPOUT(0x192FA6240);
}

void raven::RavenRayTracingActiveObject::~RavenRayTracingActiveObject(raven::RavenRayTracingActiveObject *this)
{
  *(void *)this = &unk_1EDD14CD0;
  sub_18E15E5FC((uint64_t)this + 496);

  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EDD14CD0;
  sub_18E15E5FC((uint64_t)this + 496);

  cnframework::ActiveObjectBase::~ActiveObjectBase(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EDD14CD0;
  sub_18E15E5FC((uint64_t)this + 496);
  cnframework::ActiveObjectBase::~ActiveObjectBase(this);

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E15CF7C(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15CF88@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenSolutionEvent");
}

uint64_t sub_18E15CF98(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15CFA4@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "PositionEvent");
}

uint64_t sub_18E15CFB4(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_18E15CFC0(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  v24[0] = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 16))(a3);
  v24[1] = v8;
  v23[0] = (*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  v23[1] = v9;
  uint64_t v12 = CNTimeSpan::operator-((uint64_t)a2, v24, v10, v11);
  *(double *)v14.i64 = v13;
  *(double *)v15.i64 = (double)v12;
  double v16 = v13 + (double)v12;
  uint64_t v17 = CNTimeSpan::operator-((uint64_t)v23, v24, v14, v15);
  double v19 = v18 + (double)v17;
  double v20 = fabs(v19);
  double v21 = v16 / v19;
  if (v20 < 2.22044605e-16) {
    double v21 = 0.0;
  }
  *(_OWORD *)(a1 + 8) = *a2;
  *(float64x2_t *)(a1 + 24) = vmlaq_n_f64(*(float64x2_t *)(a3 + 24), vsubq_f64(*(float64x2_t *)(a4 + 24), *(float64x2_t *)(a3 + 24)), v21);
  *(double *)(a1 + 40) = *(double *)(a3 + 40) + (*(double *)(a4 + 40) - *(double *)(a3 + 40)) * v21;
  return 0;
}

uint64_t sub_18E15D0DC(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_18E15D0E8(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  v24[0] = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 16))(a3);
  v24[1] = v8;
  v23[0] = (*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  v23[1] = v9;
  uint64_t v12 = CNTimeSpan::operator-((uint64_t)a2, v24, v10, v11);
  *(double *)v14.i64 = v13;
  *(double *)v15.i64 = (double)v12;
  double v16 = v13 + (double)v12;
  uint64_t v17 = CNTimeSpan::operator-((uint64_t)v23, v24, v14, v15);
  double v19 = v18 + (double)v17;
  double v20 = fabs(v19);
  double v21 = v16 / v19;
  if (v20 < 2.22044605e-16) {
    double v21 = 0.0;
  }
  *(_OWORD *)(a1 + 8) = *a2;
  *(float64x2_t *)(a1 + 24) = vmlaq_n_f64(*(float64x2_t *)(a3 + 24), vsubq_f64(*(float64x2_t *)(a4 + 24), *(float64x2_t *)(a3 + 24)), v21);
  *(double *)(a1 + 40) = *(double *)(a3 + 40) + (*(double *)(a4 + 40) - *(double *)(a3 + 40)) * v21;
  return 0;
}

uint64_t sub_18E15D204(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D210@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "DecomposedAccelerationEvent");
}

void *sub_18E15D220@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenAccelerationDecompositionActiveObject");
}

void sub_18E15D230(cnframework::ActiveObjectBase *this)
{
  if (*((unsigned char *)this + 480)) {
    sub_18E0BB424((uint64_t)this);
  }
  cnframework::ActiveObjectBase::ResetCurrentTime(this);

  cnframework::ActiveObjectBase::ResetEventQueue(this);
}

void *sub_18E15D27C@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenPeriodicityTrackerActiveObject");
}

void sub_18E15D28C(cnframework::ActiveObjectBase *a1)
{
  cnframework::ActiveObjectBase::ResetCurrentTime(a1);

  cnframework::ActiveObjectBase::ResetEventQueue(a1);
}

uint64_t sub_18E15D2C4(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D2D0@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "OdometerEvent");
}

void *sub_18E15D2E0@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenConvergenceEstimatorActiveObject");
}

void sub_18E15D2F0(cnframework::ActiveObjectBase *a1)
{
  if ((*(unsigned int (**)(cnframework::ActiveObjectBase *))(*(void *)a1 + 104))(a1))
  {
    __int16 v10 = 12;
    unsigned __int8 v9 = 2;
    unsigned __int8 v2 = cnprint::CNLogFormatter::FormatGeneral((const void **)a1 + 62, "Resetting");
    if (*((char *)a1 + 519) >= 0) {
      LOBYTE(v8) = v2;
    }
    else {
      uint64_t v8 = *((void *)a1 + 62);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v10, &v9, "%s", v3, v4, v5, v6, v7, v8);
    raven::RavenConvergenceEstimator::Reset((cnframework::ActiveObjectBase *)((char *)a1 + 3000));
  }
  *((unsigned char *)a1 + 544) = 0;
  *((void *)a1 + 69) = 0;
  *((void *)a1 + 70) = 0xFFF0000000000000;
  sub_18DFF49CC((uint64_t)&v10);
  memcpy((char *)a1 + 576, v11, 0x971uLL);
  cnframework::ActiveObjectBase::ResetCurrentTime(a1);
  cnframework::ActiveObjectBase::ResetEventQueue(a1);
}

std::string *sub_18E15D3D4(uint64_t a1, const std::string *a2)
{
  std::string::operator=((std::string *)(a1 + 520), a2);
  std::string::operator=((std::string *)(a1 + 5512), a2);

  return std::string::operator=((std::string *)(a1 + 7368), a2);
}

uint64_t sub_18E15D42C(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D438@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "AltitudeChangeEvent");
}

void *sub_18E15D448@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenDeltaAltitudeActiveObject");
}

void sub_18E15D458(int64x2_t *this)
{
  this[31].i64[0] = 0;
  this[31].i64[1] = 0;
  this[32] = vdupq_n_s64(0x7FF8000000000000uLL);
  this[33].i8[0] = 0;
  unsigned __int8 v2 = (void **)this[34].i64[0];
  uint64_t v3 = (void **)this[34].i64[1];
  if (v3 == v2)
  {
    uint64_t v6 = this + 36;
    uint64_t v3 = (void **)this[34].i64[0];
  }
  else
  {
    unint64_t v4 = this[35].u64[1];
    uint64_t v5 = &v2[v4 / 0x1C];
    uint64_t v6 = this + 36;
    unint64_t v7 = (unint64_t)v2[(this[36].i64[0] + v4) / 0x1C] + 144 * ((this[36].i64[0] + v4) % 0x1C);
    if ((char *)*v5 + 144 * (v4 % 0x1C) != (void *)v7)
    {
      uint64_t v8 = (void (***)(void))((char *)*v5 + 144 * (v4 % 0x1C));
      do
      {
        unsigned __int8 v9 = *v8;
        v8 += 18;
        (*v9)();
        if ((char *)v8 - (unsigned char *)*v5 == 4032)
        {
          __int16 v10 = (void (***)(void))v5[1];
          ++v5;
          uint64_t v8 = v10;
        }
      }
      while (v8 != (void (***)(void))v7);
      uint64_t v3 = (void **)this[34].i64[1];
      unsigned __int8 v2 = (void **)this[34].i64[0];
    }
  }
  v6->i64[0] = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if (v11 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unsigned __int8 v2 = (void **)(this[34].i64[0] + 8);
      this[34].i64[0] = (uint64_t)v2;
      unint64_t v11 = this[34].i64[1] - (void)v2;
    }
    while (v11 > 0x10);
  }
  if (v11 >> 3 == 1)
  {
    uint64_t v12 = 14;
  }
  else
  {
    if (v11 >> 3 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 28;
  }
  this[35].i64[1] = v12;
LABEL_16:
  cnframework::ActiveObjectBase::ResetCurrentTime((cnframework::ActiveObjectBase *)this);

  cnframework::ActiveObjectBase::ResetEventQueue((cnframework::ActiveObjectBase *)this);
}

uint64_t sub_18E15D5E0(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D5EC@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "ReceiverDifferentialCodeBiasesEvent");
}

uint64_t sub_18E15D5FC(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D608@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "GnssPreprocessedMeasurementsEvent");
}

uint64_t sub_18E15D618(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D624@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "GNSSUTCParametersEvent");
}

void *sub_18E15D634@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenGnssPreprocessor");
}

void sub_18E15D644(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  raven::GnssMeasurementPreprocessor::Reset((raven::GnssMeasurementPreprocessor *)(a1 + 488), a2, a3, a4, a5, a6, a7, a8);
  cnframework::ActiveObjectBase::ResetCurrentTime((cnframework::ActiveObjectBase *)a1);

  cnframework::ActiveObjectBase::ResetEventQueue((cnframework::ActiveObjectBase *)a1);
}

uint64_t sub_18E15D688(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D694@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "TunnelBridgeNotificationEvent");
}

void *sub_18E15D6A4@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenIntegrityEstimatorActiveObject");
}

void sub_18E15D6B4(cnframework::ActiveObjectBase *a1)
{
  raven::RavenIntegrityEstimator::Reset((uint64_t)a1 + 496);
  cnframework::ActiveObjectBase::ResetCurrentTime(a1);

  cnframework::ActiveObjectBase::ResetEventQueue(a1);
}

uint64_t sub_18E15D6F8(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D704@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "ActivityStateEvent");
}

uint64_t sub_18E15D714(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D720@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "AccessoryVehicleSpeedEvent");
}

uint64_t sub_18E15D730(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D73C@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "AltitudeEvent");
}

uint64_t sub_18E15D74C(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D758@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "AttitudeChangeEvent");
}

uint64_t sub_18E15D768(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D774@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "MountStateEvent");
}

uint64_t sub_18E15D784(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D790@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "MovingStateEvent");
}

uint64_t sub_18E15D7A0(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D7AC@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "MapVectorEvent");
}

uint64_t sub_18E15D7BC(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D7C8@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "PositionChangeEvent");
}

uint64_t sub_18E15D7D8(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D7E4@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "StepCountEvent");
}

uint64_t sub_18E15D7F4(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D800@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "UserSpeedEvent");
}

uint64_t sub_18E15D810(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D81C@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "TunnelEndPointAssistanceEvent");
}

uint64_t sub_18E15D82C(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15D838@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "VelocityEvent");
}

void *sub_18E15D848@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenMountStateEstimatorActiveObject");
}

void sub_18E15D858(cnframework::ActiveObjectBase *this)
{
  if (*((unsigned char *)this + 480))
  {
    unsigned __int8 v2 = (void **)*((void *)this + 63);
    uint64_t v3 = (void **)*((void *)this + 64);
    if (v3 == v2)
    {
      uint64_t v6 = (void *)((char *)this + 536);
      uint64_t v3 = (void **)*((void *)this + 63);
    }
    else
    {
      unint64_t v4 = *((void *)this + 66);
      uint64_t v5 = &v2[v4 / 0x14];
      uint64_t v6 = (void *)((char *)this + 536);
      unint64_t v7 = (unint64_t)v2[(*((void *)this + 67) + v4) / 0x14] + 200 * ((*((void *)this + 67) + v4) % 0x14);
      if ((char *)*v5 + 200 * (v4 % 0x14) != (void *)v7)
      {
        uint64_t v8 = (void (***)(void))((char *)*v5 + 200 * (v4 % 0x14));
        do
        {
          unsigned __int8 v9 = *v8;
          v8 += 25;
          (*v9)();
          if ((char *)v8 - (unsigned char *)*v5 == 4000)
          {
            __int16 v10 = (void (***)(void))v5[1];
            ++v5;
            uint64_t v8 = v10;
          }
        }
        while (v8 != (void (***)(void))v7);
        unsigned __int8 v2 = (void **)*((void *)this + 63);
        uint64_t v3 = (void **)*((void *)this + 64);
      }
    }
    *uint64_t v6 = 0;
    unint64_t v11 = (char *)v3 - (char *)v2;
    if (v11 >= 0x11)
    {
      do
      {
        operator delete(*v2);
        uint64_t v12 = *((void *)this + 64);
        unsigned __int8 v2 = (void **)(*((void *)this + 63) + 8);
        *((void *)this + 63) = v2;
        unint64_t v11 = v12 - (void)v2;
      }
      while (v11 > 0x10);
    }
    if (v11 >> 3 == 1)
    {
      uint64_t v13 = 10;
    }
    else
    {
      if (v11 >> 3 != 2)
      {
LABEL_17:
        *((void *)this + 78) = 0;
        *((_OWORD *)this + 37) = 0u;
        *((_OWORD *)this + 38) = 0u;
        *((_OWORD *)this + 35) = 0u;
        *((_OWORD *)this + 36) = 0u;
        *((_OWORD *)this + 34) = 0u;
        *((void *)this + 79) = 0x7FF8000000000000;
        *((void *)this + 80) = 0;
        *((void *)this + 81) = 0x7FF8000000000000;
        int64x2_t v14 = vdupq_n_s64(0x7FF8000000000000uLL);
        *((int64x2_t *)this + 41) = v14;
        *((int64x2_t *)this + 42) = v14;
        *((int64x2_t *)this + 43) = v14;
        *((int64x2_t *)this + 44) = v14;
        *((void *)this + 90) = 0;
        *((void *)this + 91) = 0x7FF8000000000000;
        *((int64x2_t *)this + 46) = v14;
        *((int64x2_t *)this + 47) = v14;
        *((int64x2_t *)this + 48) = v14;
        *((int64x2_t *)this + 49) = v14;
        *((int64x2_t *)this + 50) = v14;
        *((int64x2_t *)this + 51) = v14;
        *((void *)this + 104) = 0x7FF8000000000000;
        *((void *)this + 105) = 0;
        *((int64x2_t *)this + 53) = v14;
        *((int64x2_t *)this + 54) = v14;
        *((int64x2_t *)this + 55) = v14;
        *((int64x2_t *)this + 56) = v14;
        *((void *)this + 114) = 0x7FF8000000000000;
        *((void *)this + 115) = 0;
        *((int64x2_t *)this + 58) = v14;
        *((int64x2_t *)this + 59) = v14;
        *((int64x2_t *)this + 60) = v14;
        *((int64x2_t *)this + 61) = v14;
        *((void *)this + 124) = 0x7FF8000000000000;
        *((void *)this + 125) = 0;
        *((int64x2_t *)this + 63) = v14;
        *((int64x2_t *)this + 64) = v14;
        *((int64x2_t *)this + 65) = v14;
        *((int64x2_t *)this + 66) = v14;
        *((int64x2_t *)this + 67) = v14;
        *((int64x2_t *)this + 68) = v14;
        *((int64x2_t *)this + 69) = v14;
        *((void *)this + 140) = 0;
        *((void *)this + 141) = 0x7FF8000000000000;
        *((int64x2_t *)this + 71) = v14;
        *((int64x2_t *)this + 72) = v14;
        *((int64x2_t *)this + 73) = v14;
        *((int64x2_t *)this + 74) = v14;
        *((void *)this + 150) = 0;
        *((void *)this + 151) = 0x7FF8000000000000;
        *((int64x2_t *)this + 76) = v14;
        *((int64x2_t *)this + 77) = v14;
        *((int64x2_t *)this + 78) = v14;
        *((int64x2_t *)this + 79) = v14;
        *((void *)this + 160) = 0;
        *((void *)this + 161) = 0x7FF8000000000000;
        *((int64x2_t *)this + 81) = v14;
        *((int64x2_t *)this + 82) = v14;
        *((int64x2_t *)this + 83) = v14;
        *((int64x2_t *)this + 84) = v14;
        *((void *)this + 170) = 0;
        *((void *)this + 171) = 0x7FF8000000000000;
        *((int64x2_t *)this + 86) = v14;
        *((int64x2_t *)this + 87) = v14;
        *((void *)this + 176) = 0;
        *((void *)this + 177) = 0xFFF0000000000000;
        *((void *)&v15 + 1) = 0x7FF8000000000000;
        *(void *)&long long v16 = 0;
        *(void *)&long long v15 = 0;
        *((void *)&v16 + 1) = 0x3FF0000000000000;
        *(_OWORD *)((char *)this + 1432) = 0uLL;
        *(_OWORD *)((char *)this + 1496) = 0uLL;
        *(_OWORD *)((char *)this + 1480) = 0uLL;
        *(_OWORD *)((char *)this + 1464) = 0uLL;
        *(_OWORD *)((char *)this + 1448) = 0uLL;
        *((void *)this + 195) = 0;
        *(_OWORD *)((char *)this + 1544) = 0uLL;
        *(_OWORD *)((char *)this + 1528) = v16;
        *(_OWORD *)((char *)this + 1512) = v15;
        goto LABEL_18;
      }
      uint64_t v13 = 20;
    }
    *((void *)this + 66) = v13;
    goto LABEL_17;
  }
LABEL_18:
  cnframework::ActiveObjectBase::ResetCurrentTime(this);
  cnframework::ActiveObjectBase::ResetEventQueue(this);
}

void *sub_18E15DB48@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenPassThroughEstimatorActiveObject");
}

void sub_18E15DB58(cnframework::ActiveObjectBase *a1)
{
  if ((*(unsigned int (**)(cnframework::ActiveObjectBase *))(*(void *)a1 + 104))(a1))
  {
    __int16 v10 = 12;
    unsigned __int8 v9 = 2;
    unsigned __int8 v2 = cnprint::CNLogFormatter::FormatGeneral((const void **)a1 + 62, "Resetting");
    if (*((char *)a1 + 519) >= 0) {
      LOBYTE(v8) = v2;
    }
    else {
      uint64_t v8 = *((void *)a1 + 62);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v10, &v9, "%s", v3, v4, v5, v6, v7, v8);
    raven::RavenPassThroughEstimator::Reset((cnframework::ActiveObjectBase *)((char *)a1 + 544));
  }
  cnframework::ActiveObjectBase::ResetCurrentTime(a1);

  cnframework::ActiveObjectBase::ResetEventQueue(a1);
}

std::string *sub_18E15DC14(uint64_t a1, const std::string *a2)
{
  std::string::operator=((std::string *)(a1 + 520), a2);

  return std::string::operator=((std::string *)(a1 + 3056), a2);
}

uint64_t sub_18E15DC58(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15DC64@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "SignalPeriodicityAnalysisEvent");
}

void *sub_18E15DC74@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenPeriodicityTrackerActiveObject");
}

void sub_18E15DC84(cnprint::CNPrinter *a1)
{
  if (cnprint::CNPrinter::GetLogLevel(a1) <= 1)
  {
    __int16 v11 = 12;
    unsigned __int8 v10 = 1;
    (*(void (**)(void **__return_ptr, cnprint::CNPrinter *))(*(void *)a1 + 16))(__p, a1);
    if (v9 >= 0) {
      uint64_t v7 = __p;
    }
    else {
      LOBYTE(v7) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v11, &v10, "Resetting %s", v2, v3, v4, v5, v6, (char)v7);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
  cnframework::ActiveObjectBase::ResetCurrentTime(a1);
  cnframework::ActiveObjectBase::ResetEventQueue(a1);
}

void sub_18E15DD40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E15DD60(uint64_t result)
{
  if (*(unsigned char *)(result + 496))
  {
    LODWORD(v1) = vcvtpd_u64_f64(*(double *)(result + 512) / *(double *)(result + 504));
    if (v1 <= 1) {
      unint64_t v1 = 1;
    }
    else {
      unint64_t v1 = v1;
    }
    if (*(void *)(result + 632) >= v1 && *(unsigned char *)(result + 569))
    {
      if (*(unsigned char *)(result + 568)) {
        sub_18E0F8104();
      }
    }
  }
  return result;
}

void *sub_18E15DE24@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenPNTEstimatorActiveObject");
}

void sub_18E15DE34(cnframework::ActiveObjectBase *a1)
{
  if ((*(unsigned int (**)(cnframework::ActiveObjectBase *))(*(void *)a1 + 104))(a1))
  {
    __int16 v10 = 12;
    unsigned __int8 v9 = 2;
    unsigned __int8 v2 = cnprint::CNLogFormatter::FormatGeneral((const void **)a1 + 62, "Resetting");
    if (*((char *)a1 + 519) >= 0) {
      LOBYTE(v8) = v2;
    }
    else {
      uint64_t v8 = *((void *)a1 + 62);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v10, &v9, "%s", v3, v4, v5, v6, v7, v8);
    raven::RavenPNTEstimator::Reset((cnframework::ActiveObjectBase *)((char *)a1 + 544));
  }
  cnframework::ActiveObjectBase::ResetCurrentTime(a1);

  cnframework::ActiveObjectBase::ResetEventQueue(a1);
}

std::string *sub_18E15DEF0(uint64_t a1, const std::string *a2)
{
  std::string::operator=((std::string *)(a1 + 520), a2);
  std::string::operator=((std::string *)(a1 + 3056), a2);

  return std::string::operator=((std::string *)(a1 + 16872), a2);
}

void *sub_18E15DF44@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenSolutionPostprocessorActiveObject");
}

void sub_18E15DF54(cnframework::ActiveObjectBase *a1)
{
  uint64_t v2 = (uint64_t)a1 + 480;
  v4[0] = cnframework::ActiveObjectBase::GetCurrentTime(a1);
  v4[1] = v3;
  raven::RavenSolutionPostprocessor::Reset(v2, (uint64_t)v4);
  cnframework::ActiveObjectBase::ResetCurrentTime(a1);

  cnframework::ActiveObjectBase::ResetEventQueue(a1);
}

void *sub_18E15DFB0@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenSolutionSelectorActiveObject");
}

void sub_18E15DFC0(uint64_t a1)
{
  raven::RavenSolutionSelector::Reset((raven::RavenSolutionSelector *)(a1 + 480));
  cnframework::ActiveObjectBase::ResetCurrentTime((cnframework::ActiveObjectBase *)a1);

  cnframework::ActiveObjectBase::ResetEventQueue((cnframework::ActiveObjectBase *)a1);
}

void *sub_18E15E004@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenTimerActiveObject");
}

void sub_18E15E014(cnframework::ActiveObjectBase *this)
{
  if (*((unsigned char *)this + 480)) {
    *((unsigned char *)this + 480) = 0;
  }
  *((_DWORD *)this + 162) = 0;
  *(_OWORD *)((char *)this + 616) = 0u;
  *(_OWORD *)((char *)this + 632) = 0u;
  *(_OWORD *)((char *)this + 584) = 0u;
  *(_OWORD *)((char *)this + 600) = 0u;
  if (*((unsigned char *)this + 656)) {
    *((unsigned char *)this + 656) = 0;
  }
  cnframework::ActiveObjectBase::ResetCurrentTime(this);

  cnframework::ActiveObjectBase::ResetEventQueue(this);
}

uint64_t sub_18E15E07C(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E088@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "TimeMarkEvent");
}

uint64_t sub_18E15E098(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E0A4@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "AccelerometerEvent");
}

uint64_t sub_18E15E0B4(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E0C0@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "ActivityInputEvent");
}

uint64_t sub_18E15E0D0(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E0DC@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "ARSessionStatusEvent");
}

uint64_t sub_18E15E0EC(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E0F8@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "AttitudeEvent");
}

uint64_t sub_18E15E108(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E114@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "BarometerEvent");
}

uint64_t sub_18E15E124(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E130@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "BodyMetricsEvent");
}

uint64_t sub_18E15E140(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E14C@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "FitnessSessionEvent");
}

uint64_t sub_18E15E15C(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E168@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "GEOMapBuildingDataEvent");
}

uint64_t sub_18E15E178(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E184@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "GnssAvailabilityEvent");
}

uint64_t sub_18E15E194(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E1A0@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "GnssMeasurementDataEvent");
}

uint64_t sub_18E15E1B0(uint64_t a1)
{
  return *(void *)(a1 + 120);
}

void *sub_18E15E1BC@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "HorizontalDOTInIMUFrameEvent");
}

uint64_t sub_18E15E1CC(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E1D8@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "MapsRouteHintEvent");
}

uint64_t sub_18E15E1E8(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E1F4@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "NonHolonomicVelocityConstraintEvent");
}

uint64_t sub_18E15E204(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E210@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "PositionContextStateEvent");
}

void *sub_18E15E220@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "PrefilteredBarometerEvent");
}

uint64_t sub_18E15E230(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E23C@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "PrefilteredPressureResetEvent");
}

uint64_t sub_18E15E24C(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E258@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RateGyroEvent");
}

uint64_t sub_18E15E268(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E274@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenGnssAssistanceFileEvent");
}

uint64_t sub_18E15E284(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E290@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenSystemEvent");
}

uint64_t sub_18E15E2A0(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E2AC@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RayTracingTileEvent");
}

uint64_t sub_18E15E2BC(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E2C8@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "SignalEnvironmentEvent");
}

uint64_t sub_18E15E2D8(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E2E4@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "ThinShellIonosphereParametersEvent");
}

uint64_t sub_18E15E2F4(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E300@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "TimerEvent");
}

uint64_t sub_18E15E310(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E31C@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "TurnStateEvent");
}

uint64_t sub_18E15E32C(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E338@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "UserGaitEvent");
}

uint64_t sub_18E15E348(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E354@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "VIOEstimateEvent");
}

uint64_t sub_18E15E364(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_18E15E370@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "VLLocalizationEvent");
}

uint64_t sub_18E15E380(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 192);
  if (v2) {
    sub_18DEE4E18(v2);
  }
  uint64_t v3 = *(void *)(a1 + 176);
  *(void *)(a1 + 176) = 0;
  if (v3) {
    MEMORY[0x192FA6240](v3, 0x1000C4095D96C66);
  }
  uint64_t v4 = *(void *)(a1 + 168);
  *(void *)(a1 + 168) = 0;
  if (v4) {
    MEMORY[0x192FA6240](v4, 0x1000C4095D96C66);
  }
  uint64_t v5 = *(void *)(a1 + 160);
  *(void *)(a1 + 160) = 0;
  if (v5) {
    MEMORY[0x192FA6240](v5, 0x1000C4095D96C66);
  }
  uint64_t v6 = *(void *)(a1 + 152);
  *(void *)(a1 + 152) = 0;
  if (v6) {
    MEMORY[0x192FA6240](v6, 0x1000C40D315E998);
  }
  uint64_t v7 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = 0;
  if (v7) {
    MEMORY[0x192FA6240](v7, 0x1000C4079AA8B5ELL);
  }
  uint64_t v8 = *(void **)(a1 + 120);
  if (v8)
  {
    *(void *)(a1 + 128) = v8;
    operator delete(v8);
  }
  __int16 v10 = (void **)(a1 + 96);
  sub_18E0B9830(&v10);
  __int16 v10 = (void **)(a1 + 72);
  sub_18E0B9914(&v10);
  return a1;
}

uint64_t sub_18E15E488(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 2600)) {
    sub_18E011990(a1 + 2560);
  }
  uint64_t v2 = *(void *)(a1 + 2544);
  *(void *)(a1 + 2544) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *(void *)(a1 + 2344) = &unk_1EDD0AA58;
  uint64_t v3 = *(void *)(a1 + 1320);
  *(void *)(a1 + 1320) = 0;
  if (v3) {
    sub_18E0B7500(a1 + 1320, v3);
  }
  sub_18E0B7560((uint64_t *)(a1 + 1312), 0);
  sub_18E012A10(a1 + 1288, *(void **)(a1 + 1296));
  sub_18E012A10(a1 + 1032, *(void **)(a1 + 1040));
  sub_18E012A10(a1 + 1008, *(void **)(a1 + 1016));
  sub_18E0B75B0(a1 + 984, *(void **)(a1 + 992));
  if (*(unsigned char *)(a1 + 520)) {
    *(void *)(a1 + 320) = &unk_1EDD146B8;
  }
  *(void *)(a1 + 24) = &unk_1EDD154D0;
  uint64_t v5 = (void **)(a1 + 120);
  sub_18DEE4B60(&v5);
  return a1;
}

void sub_18E15E5C4(raven::RavenPeriodicityTrackerActiveObject *a1)
{
  raven::RavenPeriodicityTrackerActiveObject::~RavenPeriodicityTrackerActiveObject(a1);

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E15E5FC(uint64_t a1)
{
  uint64_t v2 = a1 + 3056;
  sub_18E012A10(a1 + 3216, *(void **)(a1 + 3224));
  uint64_t v6 = (void **)(a1 + 3184);
  sub_18E011788(&v6);
  sub_18E012A10(a1 + 3128, *(void **)(a1 + 3136));
  uint64_t v6 = (void **)(a1 + 3104);
  sub_18E011848(&v6);
  uint64_t v6 = (void **)(a1 + 3080);
  sub_18E0118D0(&v6);
  sub_18E012A10(v2, *(void **)(a1 + 3064));
  uint64_t v6 = (void **)(a1 + 3032);
  sub_18E12C978(&v6);
  sub_18E12CAF0(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 24);
  if (v4) {
    sub_18DEE4E18(v4);
  }
  return a1;
}

uint64_t sub_18E15E6D4(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    uint64_t v4 = (void *)(a1 + 40);
    uint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    uint64_t v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = &v2[v5 / 0x1C];
    unint64_t v7 = (unint64_t)v2[(*(void *)(a1 + 40) + v5) / 0x1C] + 144 * ((*(void *)(a1 + 40) + v5) % 0x1C);
    if ((char *)*v6 + 144 * (v5 % 0x1C) != (void *)v7)
    {
      uint64_t v8 = (void (***)(void))((char *)*v6 + 144 * (v5 % 0x1C));
      do
      {
        unsigned __int8 v9 = *v8;
        v8 += 18;
        (*v9)();
        if ((char *)v8 - (unsigned char *)*v6 == 4032)
        {
          __int16 v10 = (void (***)(void))v6[1];
          ++v6;
          uint64_t v8 = v10;
        }
      }
      while (v8 != (void (***)(void))v7);
      uint64_t v2 = *(void ***)(a1 + 8);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
  }
  *uint64_t v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 14;
    goto LABEL_15;
  }
  if (v12 == 2)
  {
    uint64_t v13 = 28;
LABEL_15:
    *(void *)(a1 + 32) = v13;
  }
  if (v2 != v3)
  {
    do
    {
      int64x2_t v14 = *v2++;
      operator delete(v14);
    }
    while (v2 != v3);
    uint64_t v16 = *(void *)(a1 + 8);
    uint64_t v15 = *(void *)(a1 + 16);
    if (v15 != v16) {
      *(void *)(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t raven::RavenPressurePrefilterActiveObject::Configure(unsigned char *a1, uint64_t *a2, int8x16_t a3, int8x16_t a4)
{
  if (a1[480])
  {
    __int16 v72 = 12;
    unsigned __int8 v71 = 2;
    (*(void (**)(void **__return_ptr, unsigned char *))(*(void *)a1 + 16))(__p, a1);
    if (v70 >= 0) {
      unint64_t v11 = __p;
    }
    else {
      LOBYTE(v11) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v72, &v71, "WARNING: %s configured more than once", v6, v7, v8, v9, v10, (char)v11);
    if (v70 < 0) {
      operator delete(__p[0]);
    }
  }
  a1[480] = 0;
  uint64_t v12 = *a2;
  if (!v12 || !*(unsigned char *)(v12 + 33))
  {
    __int16 v72 = 12;
    unsigned __int8 v71 = 4;
    (*(void (**)(void **__return_ptr, unsigned char *))(*(void *)a1 + 16))(__p, a1);
    if (v70 >= 0) {
      uint64_t v22 = __p;
    }
    else {
      LOBYTE(v22) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v72, &v71, "%s could not be configured - invalid RavenParameters", v17, v18, v19, v20, v21, (char)v22);
    goto LABEL_47;
  }
  if ((*(void *)(v12 + 1320) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || *(double *)(v12 + 1320) <= 0.0)
  {
    __int16 v72 = 12;
    unsigned __int8 v71 = 4;
    (*(void (**)(void **__return_ptr, unsigned char *))(*(void *)a1 + 16))(__p, a1);
    if (v70 >= 0) {
      unint64_t v28 = __p;
    }
    else {
      LOBYTE(v28) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v72, &v71, "%s could not be configured - invalid kernal halfwidth sigma,%.3lf", v23, v24, v25, v26, v27, (char)v28);
    goto LABEL_47;
  }
  a3.i64[0] = *(void *)(v12 + 1328);
  if ((a3.i64[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || *(double *)a3.i64 <= 0.0)
  {
    __int16 v72 = 12;
    unsigned __int8 v71 = 4;
    (*(void (**)(void **__return_ptr, unsigned char *))(*(void *)a1 + 16))(__p, a1);
    if (v70 >= 0) {
      float v34 = __p;
    }
    else {
      LOBYTE(v34) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v72, &v71, "%s could not be configured - invalid maximum pressure age,%.3lf", v29, v30, v31, v32, v33, (char)v34);
    goto LABEL_47;
  }
  *((void *)a1 + 62) = 0;
  *((void *)a1 + 63) = 0;
  *((void *)a1 + 61) = v12;
  uint64_t v13 = (void **)*((void *)a1 + 65);
  uint64_t v14 = *((void *)a1 + 66);
  *((void *)a1 + 69) = 0;
  unint64_t v15 = v14 - (void)v13;
  if (v15 >= 0x11)
  {
    do
    {
      operator delete(*v13);
      uint64_t v13 = (void **)(*((void *)a1 + 65) + 8);
      *((void *)a1 + 65) = v13;
      unint64_t v15 = *((void *)a1 + 66) - (void)v13;
    }
    while (v15 > 0x10);
  }
  if (v15 >> 3 == 1)
  {
    uint64_t v16 = 256;
  }
  else
  {
    if (v15 >> 3 != 2) {
      goto LABEL_32;
    }
    uint64_t v16 = 512;
  }
  *((void *)a1 + 68) = v16;
LABEL_32:
  uint64_t v35 = *((void *)a1 + 61);
  unsigned int v36 = *(_DWORD *)(v35 + 1312);
  if ((v36 & 0x80000000) != 0)
  {
    double v40 = 0.0;
  }
  else
  {
    double v37 = (double)v36 / *(double *)(v35 + 1320) * ((double)v36 / *(double *)(v35 + 1320));
    int v38 = -v36;
    int v39 = (2 * v36) | 1;
    double v40 = 0.0;
    do
    {
      __p[0] = COERCE_VOID_(exp((double)v38 * -0.5 * (double)v38 / v37));
      double v40 = v40 + *(double *)__p;
      *(double *)a3.i64 = sub_18DEDEC14((void *)a1 + 64, (double *)__p);
      ++v38;
      --v39;
    }
    while (v39);
  }
  uint64_t v41 = *((void *)a1 + 69);
  if (v41 != ((2 * v36) | 1))
  {
    __int16 v72 = 12;
    unsigned __int8 v71 = 4;
    (*(void (**)(void **__return_ptr, unsigned char *, int8x16_t))(*(void *)a1 + 16))(__p, a1, a3);
    if (v70 >= 0) {
      uint64_t v53 = __p;
    }
    else {
      LOBYTE(v53) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v72, &v71, "%s could not be configured - incorrect barometer kernel size,%zu", v48, v49, v50, v51, v52, (char)v53);
    goto LABEL_47;
  }
  a4.i64[0] = 0x3CB0000000000000;
  if (fabs(v40) < 2.22044605e-16)
  {
    __int16 v72 = 12;
    unsigned __int8 v71 = 4;
    (*(void (**)(void **__return_ptr, unsigned char *))(*(void *)a1 + 16))(__p, a1);
    if (v70 >= 0) {
      unsigned int v47 = __p;
    }
    else {
      LOBYTE(v47) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v72, &v71, "%s could not be configured - kernel norm is zero", v42, v43, v44, v45, v46, (char)v47);
LABEL_47:
    if (v70 < 0) {
      operator delete(__p[0]);
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v55 = *((void *)a1 + 65);
  if (*((void *)a1 + 66) != v55)
  {
    unint64_t v56 = *((void *)a1 + 68);
    double v57 = (double **)(v55 + 8 * (v56 >> 9));
    double v58 = *v57;
    int v59 = &(*v57)[v56 & 0x1FF];
    uint64_t v60 = *(void *)(v55 + (((v56 + v41) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v56 + v41) & 0x1FF);
    while (v59 != (double *)v60)
    {
      *int v59 = *v59 / v40;
      if ((char *)++v59 - (char *)v58 == 4096)
      {
        uint64_t v61 = v57[1];
        ++v57;
        double v58 = v61;
        int v59 = v61;
      }
    }
  }
  a3.i64[0] = *(void *)(*((void *)a1 + 61) + 1328);
  __p[0] = 0;
  __p[1] = 0;
  CNTimeSpan::SetTimeSpan((uint64_t *)__p, 0, a3, a4);
  *((_OWORD *)a1 + 31) = *(_OWORD *)__p;
  cnframework::ActiveObjectBase::SetEventQueueDelay((cnframework::ActiveObjectBase *)a1, 0.0);
  a1[480] = 1;
  int v62 = (cnprint::CNPrinter *)(*(uint64_t (**)(unsigned char *))(*(void *)a1 + 48))(a1);
  if (cnprint::CNPrinter::GetLogLevel(v62) < 2)
  {
    __int16 v72 = 12;
    unsigned __int8 v71 = 1;
    (*(void (**)(void **__return_ptr, unsigned char *))(*(void *)a1 + 16))(__p, a1);
    if (v70 >= 0) {
      uint64_t v68 = __p;
    }
    else {
      LOBYTE(v68) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v72, &v71, "%s configured successfully", v63, v64, v65, v66, v67, (char)v68);
    if (v70 < 0) {
      operator delete(__p[0]);
    }
  }
  return 0;
}

void sub_18E15EE18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void raven::RavenPressurePrefilterActiveObject::HandleEvent(raven::RavenPressurePrefilterActiveObject *this, const raven::BarometerEvent *a2)
{
  if (!*((unsigned char *)this + 480)) {
    return;
  }
  if (*((unsigned char *)a2 + 128)) {
    BOOL v3 = *((unsigned char *)a2 + 129) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    if (cnprint::CNPrinter::GetLogLevel(this) <= 1)
    {
      LOWORD(__p) = 12;
      LOBYTE(v159[0]) = 1;
      uint64_t v4 = (*(uint64_t (**)(const raven::BarometerEvent *))(*(void *)a2 + 16))(a2);
      double v143 = v5 + (double)v4;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&__p, (unsigned __int8 *)v159, "t,%.3lf,Invalid barometer state,valid,%d,state,%d", v6, v7, v8, v9, v10, SLOBYTE(v143));
    }
  }
  else
  {
    double v11 = *((double *)a2 + 13);
    if (v11 >= 30.0 && v11 <= 110.0)
    {
      if (!*((void *)this + 75)) {
        goto LABEL_42;
      }
      std::string __p = (void *)(*(uint64_t (**)(const raven::BarometerEvent *))(*(void *)a2 + 16))(a2);
      *(void *)&long long v146 = v13;
      unint64_t v14 = *(void *)(*((void *)this + 71) + 8 * (*((void *)this + 74) / 0x1EuLL))
          + 136 * (*((void *)this + 74) % 0x1EuLL);
      v159[0] = (void *)(*(uint64_t (**)(unint64_t))(*(void *)v14 + 16))(v14);
      v159[1] = v15;
      uint64_t v18 = CNTimeSpan::operator-((uint64_t)&__p, v159, v16, v17);
      *(void *)&v158[0] = v18;
      v158[1] = v19;
      if (v18)
      {
        if (v18 < 0) {
          goto LABEL_19;
        }
      }
      else if (v19 < 0.0)
      {
LABEL_19:
        if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v18) <= 1)
        {
          __int16 v157 = 12;
          unsigned __int8 v156 = 1;
          (*(void (**)(void **__return_ptr, raven::RavenPressurePrefilterActiveObject *))(*(void *)this + 16))(&__p, this);
          int v27 = SHIBYTE(v146);
          char v28 = (char)__p;
          (*(void (**)(void **__return_ptr, const raven::BarometerEvent *))(*(void *)a2 + 24))(v159, a2);
          if (v27 >= 0) {
            p_p = &__p;
          }
          else {
            LOBYTE(p_p) = v28;
          }
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v157, &v156, "WARNING: %s emptying event history of type %s", v29, v30, v31, v32, v33, (char)p_p);
          if (v160 < 0) {
            operator delete(v159[0]);
          }
          if (SHIBYTE(v146) < 0) {
            operator delete(__p);
          }
        }
        uint64_t v35 = (void **)*((void *)this + 71);
        unsigned int v36 = (void **)*((void *)this + 72);
        if (v36 == v35)
        {
          unsigned int v36 = (void **)*((void *)this + 71);
        }
        else
        {
          unint64_t v37 = *((void *)this + 74);
          int v38 = &v35[v37 / 0x1E];
          unint64_t v39 = (unint64_t)v35[(*((void *)this + 75) + v37) / 0x1E]
              + 136 * ((*((void *)this + 75) + v37) % 0x1E);
          if ((char *)*v38 + 136 * (v37 % 0x1E) != (void *)v39)
          {
            double v40 = (void (***)(void))((char *)*v38 + 136 * (v37 % 0x1E));
            do
            {
              uint64_t v41 = *v40;
              v40 += 17;
              (*v41)();
              if ((char *)v40 - (unsigned char *)*v38 == 4080)
              {
                uint64_t v42 = (void (***)(void))v38[1];
                ++v38;
                double v40 = v42;
              }
            }
            while (v40 != (void (***)(void))v39);
            unsigned int v36 = (void **)*((void *)this + 72);
            uint64_t v35 = (void **)*((void *)this + 71);
          }
        }
        *((void *)this + 75) = 0;
        unint64_t v43 = (char *)v36 - (char *)v35;
        if (v43 >= 0x11)
        {
          do
          {
            operator delete(*v35);
            uint64_t v35 = (void **)(*((void *)this + 71) + 8);
            *((void *)this + 71) = v35;
            unint64_t v43 = *((void *)this + 72) - (void)v35;
          }
          while (v43 > 0x10);
        }
        if (v43 >> 3 == 1)
        {
          uint64_t v44 = 15;
          goto LABEL_41;
        }
        if (v43 >> 3 == 2)
        {
          uint64_t v44 = 30;
LABEL_41:
          *((void *)this + 74) = v44;
        }
LABEL_42:
        unint64_t v45 = *((void *)this + 74);
        if (!v45)
        {
          uint64_t v46 = (char *)*((void *)this + 72);
          unsigned int v47 = (char *)*((void *)this + 71);
          unint64_t v48 = (v46 - v47) >> 3;
          uint64_t v49 = 30 * v48 - 1;
          if (v46 == v47) {
            uint64_t v49 = 0;
          }
          if ((unint64_t)(v49 - *((void *)this + 75)) < 0x1E)
          {
            uint64_t v50 = (char *)*((void *)this + 73);
            uint64_t v51 = (char *)*((void *)this + 70);
            if (v48 >= (v50 - v51) >> 3)
            {
              if (v50 == v51) {
                unint64_t v55 = 1;
              }
              else {
                unint64_t v55 = (v50 - v51) >> 2;
              }
              unint64_t v56 = (char *)sub_18DEE2FBC(v55);
              uint64_t v58 = v57;
              int v59 = operator new(0xFF0uLL);
              if (v58)
              {
                uint64_t v60 = &v56[8 * v58];
                uint64_t v61 = v56;
              }
              else
              {
                uint64_t v61 = (char *)operator new(8uLL);
                uint64_t v60 = v61 + 8;
                if (v56) {
                  operator delete(v56);
                }
              }
              *(void *)uint64_t v61 = v59;
              uint64_t v74 = v61 + 8;
              unsigned int v75 = (uint64_t *)*((void *)this + 71);
              if (v75 == *((uint64_t **)this + 72))
              {
                BOOL v78 = v61;
                BOOL v76 = v61;
                uint64_t v92 = v61 + 8;
              }
              else
              {
                BOOL v76 = v61;
                do
                {
                  if (v74 == v60)
                  {
                    if (v61 <= v76)
                    {
                      if (v74 == v76) {
                        unint64_t v83 = 1;
                      }
                      else {
                        unint64_t v83 = (v74 - v76) >> 2;
                      }
                      double v84 = (char *)sub_18DEE2FBC(v83);
                      unsigned int v86 = v84;
                      BOOL v78 = &v84[8 * (v83 >> 2)];
                      unsigned __int8 v77 = v78;
                      uint64_t v87 = v74 - v61;
                      if (v74 != v61)
                      {
                        unsigned __int8 v77 = &v78[v87 & 0xFFFFFFFFFFFFFFF8];
                        uint64_t v88 = 8 * (v87 >> 3);
                        char v89 = v78;
                        do
                        {
                          uint64_t v90 = *(void *)v61;
                          v61 += 8;
                          *(void *)char v89 = v90;
                          v89 += 8;
                          v88 -= 8;
                        }
                        while (v88);
                      }
                      uint64_t v74 = &v84[8 * v85];
                      if (v76) {
                        operator delete(v76);
                      }
                      BOOL v76 = v86;
                    }
                    else
                    {
                      uint64_t v79 = (v61 - v76) >> 3;
                      if (v79 >= -1) {
                        uint64_t v80 = v79 + 1;
                      }
                      else {
                        uint64_t v80 = v79 + 2;
                      }
                      float v81 = v74;
                      if (v74 != v61)
                      {
                        memmove(&v61[-8 * (v80 >> 1)], v61, v74 - v61);
                        float v81 = v61;
                      }
                      uint64_t v82 = -(v80 >> 1);
                      unsigned __int8 v77 = &v74[-8 * (v80 >> 1)];
                      BOOL v78 = &v81[8 * v82];
                    }
                  }
                  else
                  {
                    unsigned __int8 v77 = v74;
                    BOOL v78 = v61;
                    uint64_t v74 = v60;
                  }
                  uint64_t v60 = v74;
                  uint64_t v91 = *v75++;
                  *(void *)unsigned __int8 v77 = v91;
                  uint64_t v92 = v77 + 8;
                  uint64_t v74 = v92;
                  uint64_t v61 = v78;
                }
                while (v75 != *((uint64_t **)this + 72));
              }
              uint64_t v93 = (void *)*((void *)this + 70);
              *((void *)this + 70) = v76;
              *((void *)this + 71) = v78;
              *((void *)this + 72) = v92;
              *((void *)this + 73) = v60;
              if (v92 - v78 == 8) {
                uint64_t v94 = 15;
              }
              else {
                uint64_t v94 = *((void *)this + 74) + 30;
              }
              *((void *)this + 74) = v94;
              if (v93) {
                operator delete(v93);
              }
            }
            else
            {
              uint64_t v52 = operator new(0xFF0uLL);
              uint64_t v53 = v52;
              if (v47 == v51)
              {
                if (v46 == v50)
                {
                  if (v46 == v47) {
                    unint64_t v62 = 1;
                  }
                  else {
                    unint64_t v62 = (v46 - v51) >> 2;
                  }
                  uint64_t v63 = (char *)sub_18DEE2FBC(v62);
                  uint64_t v65 = &v63[8 * (v62 >> 2)];
                  uint64_t v66 = (uint64_t *)*((void *)this + 71);
                  uint64_t v46 = v65;
                  uint64_t v67 = *((void *)this + 72) - (void)v66;
                  if (v67)
                  {
                    uint64_t v46 = &v65[v67 & 0xFFFFFFFFFFFFFFF8];
                    uint64_t v68 = 8 * (v67 >> 3);
                    uint64_t v69 = v65;
                    do
                    {
                      uint64_t v70 = *v66++;
                      *(void *)uint64_t v69 = v70;
                      v69 += 8;
                      v68 -= 8;
                    }
                    while (v68);
                  }
                  unsigned __int8 v71 = (void *)*((void *)this + 70);
                  *((void *)this + 70) = v63;
                  *((void *)this + 71) = v65;
                  *((void *)this + 72) = v46;
                  *((void *)this + 73) = &v63[8 * v64];
                  if (v71)
                  {
                    operator delete(v71);
                    uint64_t v46 = (char *)*((void *)this + 72);
                  }
                }
                *(void *)uint64_t v46 = v53;
                __int16 v72 = (void **)*((void *)this + 72);
                *((void *)this + 72) = v72 + 1;
                std::string __p = *v72;
                *((void *)this + 72) = v72;
                sub_18E02174C((uint64_t)this + 560, &__p);
                uint64_t v54 = *((void *)this + 71);
              }
              else
              {
                *((void *)v47 - 1) = v52;
                uint64_t v54 = *((void *)this + 71) - 8;
                *((void *)this + 71) = v54;
              }
              if (*((void *)this + 72) - v54 == 8) {
                uint64_t v73 = 15;
              }
              else {
                uint64_t v73 = *((void *)this + 74) + 30;
              }
              *((void *)this + 74) = v73;
            }
          }
          else
          {
            *((void *)this + 74) = 30;
            std::string __p = (void *)*((void *)v46 - 1);
            *((void *)this + 72) = v46 - 8;
            sub_18E02174C((uint64_t)this + 560, &__p);
          }
          unint64_t v45 = *((void *)this + 74);
        }
        uint64_t v95 = *((void *)this + 71);
        uint64_t v96 = (void *)(v95 + 8 * (v45 / 0x1E));
        uint64_t v97 = *v96 + 136 * (v45 % 0x1E);
        if (*((void *)this + 72) == v95) {
          uint64_t v97 = 0;
        }
        if (v97 == *v96) {
          uint64_t v97 = *(v96 - 1) + 4080;
        }
        *(void *)(v97 - 136) = &unk_1EDD138B0;
        long long v98 = *(_OWORD *)((char *)a2 + 8);
        long long v99 = *(_OWORD *)((char *)a2 + 24);
        long long v100 = *(_OWORD *)((char *)a2 + 56);
        *(_OWORD *)(v97 - 96) = *(_OWORD *)((char *)a2 + 40);
        *(_OWORD *)(v97 - 80) = v100;
        *(_OWORD *)(v97 - 128) = v98;
        *(_OWORD *)(v97 - 112) = v99;
        long long v101 = *(_OWORD *)((char *)a2 + 72);
        long long v102 = *(_OWORD *)((char *)a2 + 88);
        long long v103 = *(_OWORD *)((char *)a2 + 104);
        *(_OWORD *)(v97 - 22) = *(_OWORD *)((char *)a2 + 114);
        *(_OWORD *)(v97 - 48) = v102;
        *(_OWORD *)(v97 - 32) = v103;
        *(_OWORD *)(v97 - 64) = v101;
        uint64_t v104 = *((void *)this + 74);
        unint64_t v105 = v104 - 1;
        *((void *)this + 74) = v104 - 1;
        uint64_t v106 = *((void *)this + 75);
        unint64_t v107 = v106 + 1;
        *((void *)this + 75) = v106 + 1;
        if (v106 + 1 == *((void *)this + 69))
        {
          unint64_t v108 = *(unsigned int *)(*((void *)this + 61) + 1312);
          if (v107 > v108)
          {
            unint64_t v109 = v105 + v108;
            uint64_t v110 = *((void *)this + 71);
            uint64_t v111 = *(void *)(v110 + 8 * (v109 / 0x1E));
            unint64_t v112 = v109 % 0x1E;
            long long v146 = 0uLL;
            LOBYTE(v147) = 0;
            *((void *)&v147 + 1) = 0;
            v148.n128_u64[0] = 0;
            v148.n128_u8[8] = 0;
            long long v149 = 0uLL;
            LOBYTE(v150) = 0;
            *((void *)&v150 + 1) = 0;
            *(void *)int v151 = 0;
            __n128 v113 = (__n128)vdupq_n_s64(0x7FF8000000000000uLL);
            *(__n128 *)&v151[8] = v113;
            char v152 = 0;
            uint64_t v153 = 0x7FF8000000000000;
            __int16 v154 = 0;
            std::string __p = &unk_1EDD14768;
            if (&__p != (void **)(v111 + 136 * v112))
            {
              uint64_t v114 = v111 + 136 * v112;
              long long v115 = *(_OWORD *)(v114 + 24);
              long long v146 = *(_OWORD *)(v114 + 8);
              long long v147 = v115;
              __n128 v113 = *(__n128 *)(v114 + 40);
              long long v116 = *(_OWORD *)(v114 + 56);
              long long v117 = *(_OWORD *)(v114 + 88);
              long long v150 = *(_OWORD *)(v114 + 72);
              *(_OWORD *)int v151 = v117;
              __n128 v148 = v113;
              long long v149 = v116;
              *(void *)&v151[16] = *(void *)(v114 + 104);
              char v152 = *(unsigned char *)(v114 + 112);
              uint64_t v153 = *(void *)(v114 + 120);
              __int16 v154 = *(_WORD *)(v114 + 128);
            }
            unint64_t v155 = 0;
            uint64_t v118 = *((void *)this + 65);
            unint64_t v119 = *((void *)this + 68);
            uint64_t v120 = (void *)(v118 + 8 * (v119 >> 9));
            uint64_t v121 = *((void *)this + 66);
            if (v121 == v118) {
              unsigned int v122 = 0;
            }
            else {
              unsigned int v122 = (double *)(*v120 + 8 * (*((void *)this + 68) & 0x1FFLL));
            }
            unsigned int v123 = (void *)(v110 + 8 * (v105 / 0x1E));
            uint64_t v124 = *((void *)this + 72);
            if (v124 == v110) {
              unint64_t v125 = 0;
            }
            else {
              unint64_t v125 = *v123 + 136 * (v105 % 0x1E);
            }
            unint64_t v126 = v119 + v107;
            unint64_t v127 = v126 >> 9;
            uint64_t v128 = v126 & 0x1FF;
            uint64_t v129 = v104 + v106;
            unint64_t v130 = (v104 + v106) / 0x1EuLL;
            v113.n128_u64[0] = 0;
            while (1)
            {
              unint64_t v131 = v125 - 4080;
              do
              {
                if (v121 == v118) {
                  uint64_t v132 = 0;
                }
                else {
                  uint64_t v132 = *(void *)(v118 + 8 * v127) + 8 * v128;
                }
                if (v122 == (double *)v132
                  || (v124 == v110 ? (uint64_t v133 = 0) : (uint64_t v133 = *(void *)(v110 + 8 * v130) + 136 * (v129 - 30 * v130)),
                      v125 == v133))
                {
                  long long v137 = (void (***)(void, __n128))(*(void *)(v110 + 8 * ((v105 + v106) / 0x1E))
                                                               + 136 * ((v105 + v106) % 0x1E));
                  (**v137)(v137, v113);
                  uint64_t v138 = *((void *)this + 72);
                  uint64_t v139 = 30 * ((v138 - *((void *)this + 71)) >> 3) - 1;
                  uint64_t v140 = *((void *)this + 75);
                  if (v138 == *((void *)this + 71)) {
                    uint64_t v139 = 0;
                  }
                  *((void *)this + 75) = v140 - 1;
                  if ((unint64_t)(v139 - (v140 + *((void *)this + 74)) - 59) <= 0xFFFFFFFFFFFFFFC3)
                  {
                    operator delete(*(void **)(v138 - 8));
                    *((void *)this + 72) -= 8;
                  }
                  int v141 = operator new(0x60uLL);
                  v141[1] = 0;
                  v141[2] = 0;
                  *int v141 = &unk_1EDD1E458;
                  v141[3] = &unk_1EDD0A260;
                  uint64_t v142 = MEMORY[0x1E4FBA3D8];
                  *((unsigned char *)v141 + 32) = 0;
                  v141[5] = 0;
                  v141[6] = v142;
                  v141[7] = 0;
                  v141[8] = 0;
                  sub_18DEDE7B0(v141 + 9, "");
                  *((unsigned char *)v141 + 32) = 1;
                  operator new();
                }
                double v134 = *v122++;
                v113.n128_f64[0] = v113.n128_f64[0] + v134 * *(double *)(v125 + 104);
                unint64_t v155 = v113.n128_u64[0];
                if ((double *)((char *)v122 - *v120) == (double *)4096)
                {
                  uint64_t v135 = (double *)v120[1];
                  ++v120;
                  unsigned int v122 = v135;
                }
                v131 += 136;
                v125 += 136;
              }
              while (*v123 != v131);
              unint64_t v136 = v123[1];
              ++v123;
              unint64_t v125 = v136;
            }
          }
          sub_18DEDE720("deque");
        }
        return;
      }
      uint64_t v18 = sub_18DEE4C00(v158, (double *)this + 62);
      if (!v18) {
        goto LABEL_42;
      }
      goto LABEL_19;
    }
    if (cnprint::CNPrinter::GetLogLevel(this) <= 1)
    {
      LOWORD(__p) = 12;
      LOBYTE(v159[0]) = 1;
      uint64_t v20 = (*(uint64_t (**)(const raven::BarometerEvent *))(*(void *)a2 + 16))(a2);
      double v144 = v21 + (double)v20;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&__p, (unsigned __int8 *)v159, "t,%.3lf,Invalid barometer data,%.6lf", v22, v23, v24, v25, v26, SLOBYTE(v144));
    }
  }
}

void sub_18E15FB20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  operator delete(v18);
  if (v17) {
    operator delete(v17);
  }
  _Unwind_Resume(a1);
}

void sub_18E15FBF0()
{
}

void raven::RavenPressurePrefilterActiveObject::Reset(raven::RavenPressurePrefilterActiveObject *this)
{
  uint64_t v2 = (void **)*((void *)this + 71);
  BOOL v3 = (void **)*((void *)this + 72);
  if (v3 == v2)
  {
    uint64_t v6 = (void *)((char *)this + 600);
    BOOL v3 = (void **)*((void *)this + 71);
  }
  else
  {
    unint64_t v4 = *((void *)this + 74);
    double v5 = &v2[v4 / 0x1E];
    uint64_t v6 = (void *)((char *)this + 600);
    unint64_t v7 = (unint64_t)v2[(*((void *)this + 75) + v4) / 0x1E] + 136 * ((*((void *)this + 75) + v4) % 0x1E);
    if ((char *)*v5 + 136 * (v4 % 0x1E) != (void *)v7)
    {
      uint64_t v8 = (void (***)(void))((char *)*v5 + 136 * (v4 % 0x1E));
      do
      {
        uint64_t v9 = *v8;
        v8 += 17;
        (*v9)();
        if ((char *)v8 - (unsigned char *)*v5 == 4080)
        {
          uint64_t v10 = (void (***)(void))v5[1];
          ++v5;
          uint64_t v8 = v10;
        }
      }
      while (v8 != (void (***)(void))v7);
      BOOL v3 = (void **)*((void *)this + 72);
      uint64_t v2 = (void **)*((void *)this + 71);
    }
  }
  *uint64_t v6 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if (v11 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v2 = (void **)(*((void *)this + 71) + 8);
      *((void *)this + 71) = v2;
      unint64_t v11 = *((void *)this + 72) - (void)v2;
    }
    while (v11 > 0x10);
  }
  if (v11 >> 3 == 1)
  {
    uint64_t v12 = 15;
  }
  else
  {
    if (v11 >> 3 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 30;
  }
  *((void *)this + 74) = v12;
LABEL_16:
  cnframework::ActiveObjectBase::ResetCurrentTime(this);

  cnframework::ActiveObjectBase::ResetEventQueue(this);
}

void sub_18E15FD5C(cnframework::ActiveObjectBase *a1)
{
  *(void *)a1 = &unk_1EDD15678;
  sub_18E0B8298((void *)a1 + 70);
  sub_18DEE2DB8((void *)a1 + 64);
  cnframework::ActiveObjectBase::~ActiveObjectBase(a1);

  JUMPOUT(0x192FA6240);
}

void *sub_18E15FDD0@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenPressurePrefilterActiveObject");
}

void sub_18E15FDE4()
{
}

void *sub_18E15FDF8()
{
}

void sub_18E15FE04()
{
}

uint64_t raven::TunnelEndPointAssistanceChecker::Configure(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 16) = a3;
  *(unsigned char *)(a1 + 8) = 1;
  return 0;
}

uint64_t raven::TunnelEndPointAssistanceChecker::HandleEvent(raven::TunnelEndPointAssistanceChecker *this, const raven::TunnelEndPointAssistanceEvent *a2, raven::TunnelEndPointAssistanceEvent *a3)
{
  if (*((unsigned char *)this + 8))
  {
    long long v4 = *(_OWORD *)((char *)a2 + 8);
    long long v5 = *(_OWORD *)((char *)a2 + 24);
    *(_OWORD *)((char *)a3 + 40) = *(_OWORD *)((char *)a2 + 40);
    *(_OWORD *)((char *)a3 + 24) = v5;
    *(_OWORD *)((char *)a3 + 8) = v4;
    long long v6 = *(_OWORD *)((char *)a2 + 56);
    long long v7 = *(_OWORD *)((char *)a2 + 72);
    long long v8 = *(_OWORD *)((char *)a2 + 88);
    *(_OWORD *)((char *)a3 + 104) = *(_OWORD *)((char *)a2 + 104);
    *(_OWORD *)((char *)a3 + 88) = v8;
    *(_OWORD *)((char *)a3 + 72) = v7;
    *(_OWORD *)((char *)a3 + 56) = v6;
    long long v9 = *(_OWORD *)((char *)a2 + 120);
    long long v10 = *(_OWORD *)((char *)a2 + 136);
    long long v11 = *(_OWORD *)((char *)a2 + 152);
    *(_OWORD *)((char *)a3 + 168) = *(_OWORD *)((char *)a2 + 168);
    *(_OWORD *)((char *)a3 + 152) = v11;
    *(_OWORD *)((char *)a3 + 136) = v10;
    *(_OWORD *)((char *)a3 + 120) = v9;
    long long v12 = *(_OWORD *)((char *)a2 + 184);
    long long v13 = *(_OWORD *)((char *)a2 + 200);
    long long v14 = *(_OWORD *)((char *)a2 + 216);
    *(_OWORD *)((char *)a3 + 225) = *(_OWORD *)((char *)a2 + 225);
    *(_OWORD *)((char *)a3 + 216) = v14;
    *(_OWORD *)((char *)a3 + 200) = v13;
    *(_OWORD *)((char *)a3 + 184) = v12;
    if (*((unsigned char *)a2 + 240) == 1)
    {
      double v15 = *((double *)a2 + 25);
      if ((*(void *)&v15 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v15 > 90.0 || v15 < -90.0)
      {
        if (cnprint::CNPrinter::GetLogLevel(this) <= 1)
        {
          __int16 v76 = 12;
          unsigned __int8 v75 = 1;
          uint64_t v33 = (*(uint64_t (**)(const raven::TunnelEndPointAssistanceEvent *))(*(void *)a2 + 16))(a2);
          double v70 = v34 + (double)v33;
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v76, &v75, "t,%.3lf,TunnelEndPointAssistanceChecker: Assistance rejected due to invalid latitude, %.3lf", v35, v36, v37, v38, v39, SLOBYTE(v70));
        }
      }
      else
      {
        double v16 = *((double *)a2 + 26);
        if ((*(void *)&v16 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v16 > 180.0 || v16 <= -180.0)
        {
          if (cnprint::CNPrinter::GetLogLevel(this) <= 1)
          {
            __int16 v76 = 12;
            unsigned __int8 v75 = 1;
            uint64_t v40 = (*(uint64_t (**)(const raven::TunnelEndPointAssistanceEvent *))(*(void *)a2 + 16))(a2);
            double v71 = v41 + (double)v40;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v76, &v75, "t,%.3lf,TunnelEndPointAssistanceChecker: Assistance rejected due to invalid longitude, %.3lf", v42, v43, v44, v45, v46, SLOBYTE(v71));
          }
        }
        else if ((*((void *)a2 + 27) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || *((double *)a2 + 27) <= 0.0)
        {
          if (cnprint::CNPrinter::GetLogLevel(this) <= 1)
          {
            __int16 v76 = 12;
            unsigned __int8 v75 = 1;
            uint64_t v47 = (*(uint64_t (**)(const raven::TunnelEndPointAssistanceEvent *))(*(void *)a2 + 16))(a2);
            double v72 = v48 + (double)v47;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v76, &v75, "t,%.3lf,TunnelEndPointAssistanceChecker: Assistance rejected due to invalid horizontal uncertainty, %.3lf", v49, v50, v51, v52, v53, SLOBYTE(v72));
          }
        }
        else
        {
          double v17 = *((double *)a2 + 28);
          if ((*(void *)&v17 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v17 < -423.0 || v17 > 8848.0)
          {
            if (cnprint::CNPrinter::GetLogLevel(this) <= 1)
            {
              __int16 v76 = 12;
              unsigned __int8 v75 = 1;
              uint64_t v54 = (*(uint64_t (**)(const raven::TunnelEndPointAssistanceEvent *))(*(void *)a2 + 16))(a2);
              double v73 = v55 + (double)v54;
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v76, &v75, "t,%.3lf,TunnelEndPointAssistanceChecker: Assistance rejected due to invalid altitude, %.3lf", v56, v57, v58, v59, v60, SLOBYTE(v73));
            }
          }
          else
          {
            if ((*((void *)a2 + 29) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && *((double *)a2 + 29) > 0.0) {
              return 0;
            }
            if (cnprint::CNPrinter::GetLogLevel(this) <= 1)
            {
              __int16 v76 = 12;
              unsigned __int8 v75 = 1;
              uint64_t v61 = (*(uint64_t (**)(const raven::TunnelEndPointAssistanceEvent *))(*(void *)a2 + 16))(a2);
              double v74 = v62 + (double)v61;
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v76, &v75, "t,%.3lf,TunnelEndPointAssistanceChecker: Assistance rejected due to invalid vertical uncertainty, %.3lf", v63, v64, v65, v66, v67, SLOBYTE(v74));
            }
          }
        }
      }
    }
    else if (cnprint::CNPrinter::GetLogLevel(this) <= 1)
    {
      __int16 v76 = 12;
      unsigned __int8 v75 = 1;
      uint64_t v26 = (*(uint64_t (**)(const raven::TunnelEndPointAssistanceEvent *))(*(void *)a2 + 16))(a2);
      double v69 = v27 + (double)v26;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v76, &v75, "t,%.3lf,TunnelEndPointAssistanceChecker: Assistance rejected due to invalid reference frame, %u", v28, v29, v30, v31, v32, SLOBYTE(v69));
    }
  }
  else
  {
    __int16 v76 = 12;
    unsigned __int8 v75 = 4;
    uint64_t v19 = (*(uint64_t (**)(const raven::TunnelEndPointAssistanceEvent *, const raven::TunnelEndPointAssistanceEvent *, raven::TunnelEndPointAssistanceEvent *))(*(void *)a2 + 16))(a2, a2, a3);
    double v68 = v20 + (double)v19;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v76, &v75, "t,%.3lf,TunnelEndPointAssistanceChecker, not configured", v21, v22, v23, v24, v25, SLOBYTE(v68));
  }
  return 0xFFFFFFFFLL;
}

void sub_18E160314()
{
}

uint64_t raven::ActivityStateChecker::Configure(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 16) = a3;
  *(unsigned char *)(a1 + 8) = 1;
  return 0;
}

uint64_t raven::ActivityStateChecker::HandleEvent(raven::ActivityStateChecker *this, const raven::ActivityStateEvent *a2, raven::ActivityStateEvent *a3)
{
  if (!*((unsigned char *)this + 8))
  {
    __int16 v163 = 12;
    unsigned __int8 v162 = 4;
    uint64_t v29 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
    double v145 = v30 + (double)v29;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf,ActivityStateChecker, not configured", v31, v32, v33, v34, v35, SLOBYTE(v145));
    return 0xFFFFFFFFLL;
  }
  long long v3 = *(_OWORD *)((char *)a2 + 8);
  long long v4 = *(_OWORD *)((char *)a2 + 24);
  long long v5 = *(_OWORD *)((char *)a2 + 40);
  *(_OWORD *)((char *)a3 + 56) = *(_OWORD *)((char *)a2 + 56);
  *(_OWORD *)((char *)a3 + 40) = v5;
  *(_OWORD *)((char *)a3 + 24) = v4;
  *(_OWORD *)((char *)a3 + 8) = v3;
  long long v6 = *(_OWORD *)((char *)a2 + 72);
  long long v7 = *(_OWORD *)((char *)a2 + 88);
  long long v8 = *(_OWORD *)((char *)a2 + 104);
  *(_OWORD *)((char *)a3 + 120) = *(_OWORD *)((char *)a2 + 120);
  *(_OWORD *)((char *)a3 + 104) = v8;
  *(_OWORD *)((char *)a3 + 88) = v7;
  *(_OWORD *)((char *)a3 + 72) = v6;
  long long v9 = *(_OWORD *)((char *)a2 + 136);
  long long v10 = *(_OWORD *)((char *)a2 + 152);
  long long v11 = *(_OWORD *)((char *)a2 + 168);
  *((void *)a3 + 23) = *((void *)a2 + 23);
  *(_OWORD *)((char *)a3 + 168) = v11;
  *(_OWORD *)((char *)a3 + 152) = v10;
  *(_OWORD *)((char *)a3 + 136) = v9;
  if (*((unsigned __int8 *)a2 + 104) >= 0xAu)
  {
    __int16 v163 = 12;
    unsigned __int8 v162 = 4;
    uint64_t v36 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
    double v146 = v37 + (double)v36;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf, Warning: ActivityStateChecker,Invalid type detected in activity state integrity check.", v38, v39, v40, v41, v42, SLOBYTE(v146));
    return 0xFFFFFFFFLL;
  }
  double v12 = *((double *)a2 + 14);
  if (v12 < 0.0 || (*((void *)a2 + 14) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || v12 > 1.0)
  {
    __int16 v163 = 12;
    unsigned __int8 v162 = 4;
    uint64_t v43 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
    double v147 = v44 + (double)v43;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf, ActivityStateChecker,Invalid probability_unknown_", v45, v46, v47, v48, v49, SLOBYTE(v147));
    return 0xFFFFFFFFLL;
  }
  double v13 = *((double *)a2 + 15);
  if (v13 < 0.0 || (*((void *)a2 + 15) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || v13 > 1.0)
  {
    __int16 v163 = 12;
    unsigned __int8 v162 = 4;
    uint64_t v50 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
    double v148 = v51 + (double)v50;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf, ActivityStateChecker,Invalid probability_moving_", v52, v53, v54, v55, v56, SLOBYTE(v148));
    return 0xFFFFFFFFLL;
  }
  double v14 = *((double *)a2 + 16);
  if (v14 < 0.0 || (*((void *)a2 + 16) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || v14 > 1.0)
  {
    __int16 v163 = 12;
    unsigned __int8 v162 = 4;
    uint64_t v57 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
    double v149 = v58 + (double)v57;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf, ActivityStateChecker,Invalid probability_walking_", v59, v60, v61, v62, v63, SLOBYTE(v149));
    return 0xFFFFFFFFLL;
  }
  double v15 = *((double *)a2 + 17);
  if (v15 < 0.0 || (*((void *)a2 + 17) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || v15 > 1.0)
  {
    __int16 v163 = 12;
    unsigned __int8 v162 = 4;
    uint64_t v64 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
    double v150 = v65 + (double)v64;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf, ActivityStateChecker,Invalid probability_running_", v66, v67, v68, v69, v70, SLOBYTE(v150));
    return 0xFFFFFFFFLL;
  }
  double v16 = *((double *)a2 + 18);
  if (v16 < 0.0 || (*((void *)a2 + 18) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || v16 > 1.0)
  {
    __int16 v163 = 12;
    unsigned __int8 v162 = 4;
    uint64_t v71 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
    double v151 = v72 + (double)v71;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf, ActivityStateChecker,Invalid probability_cycling_", v73, v74, v75, v76, v77, SLOBYTE(v151));
    return 0xFFFFFFFFLL;
  }
  double v17 = *((double *)a2 + 19);
  if (v17 < 0.0 || (*((void *)a2 + 19) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || v17 > 1.0)
  {
    __int16 v163 = 12;
    unsigned __int8 v162 = 4;
    uint64_t v78 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
    double v152 = v79 + (double)v78;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf, ActivityStateChecker,Invalid probability_driving_", v80, v81, v82, v83, v84, SLOBYTE(v152));
    return 0xFFFFFFFFLL;
  }
  double v18 = *((double *)a2 + 20);
  if (v18 < 0.0 || (*((void *)a2 + 20) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || v18 > 1.0)
  {
    __int16 v163 = 12;
    unsigned __int8 v162 = 4;
    uint64_t v85 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
    double v153 = v86 + (double)v85;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf, ActivityStateChecker,Invalid probability_swimming_", v87, v88, v89, v90, v91, SLOBYTE(v153));
    return 0xFFFFFFFFLL;
  }
  double v19 = *((double *)a2 + 21);
  if (v19 < 0.0 || (*((void *)a2 + 21) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || v19 > 1.0)
  {
    __int16 v163 = 12;
    unsigned __int8 v162 = 4;
    uint64_t v92 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
    double v154 = v93 + (double)v92;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf, ActivityStateChecker,Invalid probability_wheelchair_", v94, v95, v96, v97, v98, SLOBYTE(v154));
    return 0xFFFFFFFFLL;
  }
  double v20 = *((double *)a2 + 22);
  if (v20 < 0.0 || (*((void *)a2 + 22) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || v20 > 1.0)
  {
    __int16 v163 = 12;
    unsigned __int8 v162 = 4;
    uint64_t v99 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
    double v155 = v100 + (double)v99;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf, ActivityStateChecker,Invalid probability_highspeed_", v101, v102, v103, v104, v105, SLOBYTE(v155));
    return 0xFFFFFFFFLL;
  }
  double v21 = *((double *)a2 + 23);
  if (v21 < 0.0 || (*((void *)a2 + 23) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || v21 > 1.0)
  {
    __int16 v163 = 12;
    unsigned __int8 v162 = 4;
    uint64_t v106 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
    double v156 = v107 + (double)v106;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf, ActivityStateChecker,Invalid probability_airborne_", v108, v109, v110, v111, v112, SLOBYTE(v156));
    return 0xFFFFFFFFLL;
  }
  if (fabs(v12 + v13 + v14 + v15 + v16 + v17 + v18 + v19 + v20 + v21 + -1.0) > 0.000000015)
  {
    __int16 v163 = 12;
    unsigned __int8 v162 = 4;
    uint64_t v22 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
    double v144 = v23 + (double)v22;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf, ActivityStateChecker,activity state probabilities do not add to 1.0,sum error,%.3e", v24, v25, v26, v27, v28, SLOBYTE(v144));
    return 0xFFFFFFFFLL;
  }
  if (!*((unsigned char *)this + 9)) {
    return 0;
  }
  uint64_t result = (uint64_t)sub_18DFF465C((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E21BF18);
  if (result)
  {
    if (*(unsigned char *)(result + 1368))
    {
      unsigned int v115 = *((unsigned __int8 *)a2 + 104);
      if (v115 > 9)
      {
        __int16 v163 = 12;
        unsigned __int8 v162 = 4;
        uint64_t v130 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
        double v159 = v131 + (double)v130;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf,ActivityStateChecker,Invalid activity type detected,%u", v132, v133, v134, v135, v136, SLOBYTE(v159));
        return 0xFFFFFFFFLL;
      }
      if (((1 << v115) & 0x3F3) == 0)
      {
        if (v115 == 2)
        {
          if (*(double *)(result + 1376) > sqrt(*(double *)(result + 1408)) + 5.11)
          {
            if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)result) <= 1)
            {
              __int16 v163 = 12;
              unsigned __int8 v162 = 1;
              uint64_t v116 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
              double v157 = v117 + (double)v116;
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf, Warning: ActivityStateChecker,Speed too large to raise walking activity state,user_speed_,%.2lf", v118, v119, v120, v121, v122, SLOBYTE(v157));
            }
LABEL_65:
            uint64_t result = 0;
            *((unsigned char *)a3 + 104) = 1;
            return result;
          }
        }
        else if (*(double *)(result + 1376) > sqrt(*(double *)(result + 1408)) + 13.47)
        {
          if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)result) <= 1)
          {
            __int16 v163 = 12;
            unsigned __int8 v162 = 1;
            uint64_t v137 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
            double v160 = v138 + (double)v137;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf, Warning: ActivityStateChecker,Speed too large to raise running activity state,user_speed_,%.2lf", v139, v140, v141, v142, v143, SLOBYTE(v160));
          }
          goto LABEL_65;
        }
      }
    }
    else if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)result) <= 1)
    {
      __int16 v163 = 12;
      unsigned __int8 v162 = 1;
      uint64_t v123 = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
      double v158 = v124 + (double)v123;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v163, &v162, "t,%.3lf, Warning: ActivityStateChecker,User speed invalid. Exiting with check passed return value.", v125, v126, v127, v128, v129, SLOBYTE(v158));
    }
    return 0;
  }
  return result;
}

void sub_18E160C90()
{
}

BOOL raven::RavenDeviceAttitudeActiveObject::AttitudeViaTwoVectors(uint64_t a1)
{
  double v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  long long v5 = v4;
  double v7 = v6;
  uint64_t v9 = v8;
  uint64_t v11 = v10;
  double v12 = v1;
  uint64_t v14 = v13;
  uint64_t v16 = v15;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404BA0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB404BA0))
  {
    qword_1EB404B98 = 0x3FDFFFFFFFFFFFFFLL;
    __cxa_guard_release(&qword_1EB404BA0);
  }
  uint64_t v143 = 0x100000003;
  long long v142 = xmmword_18E1F6F60;
  uint64_t v141 = &unk_1EDD18D98;
  double v144 = v145;
  uint64_t v180 = 0x100000134;
  long long v179 = xmmword_18E1F6FB0;
  int v178 = &unk_1EDD18C48;
  int v181 = v182;
  uint64_t v138 = 0x100000003;
  long long v137 = xmmword_18E1F6F60;
  uint64_t v136 = &unk_1EDD18D98;
  uint64_t v139 = v140;
  sub_18DFE345C(v16, (uint64_t)&v141, (uint64_t)&v178, (uint64_t)&v136, "2");
  if (v18.f64[0] < v12 || fabs(v18.f64[0]) <= 0.000000015)
  {
    if (cnprint::CNPrinter::GetLogLevel(v17) <= 1)
    {
      LOWORD(v178) = 12;
      LOBYTE(v141) = 1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v178, (unsigned __int8 *)&v141, "DevAtt,Uncertainty of first vector is too large,unc,%.3lf,norm,%.3lf", v38, v39, v40, v41, v42, SLOBYTE(v12));
    }
    return 0;
  }
  uint64_t v175 = 0x100000003;
  long long v174 = xmmword_18E1F6F60;
  int v173 = &unk_1EDD18D98;
  uint64_t v176 = (double *)&v177;
  v18.f64[0] = 1.0 / v18.f64[0];
  sub_18DFE3240(v16, (uint64_t)&v173, v18);
  uint64_t v143 = 0x100000003;
  long long v142 = xmmword_18E1F6F60;
  uint64_t v141 = &unk_1EDD18D98;
  double v144 = v145;
  uint64_t v180 = 0x100000134;
  long long v179 = xmmword_18E1F6FB0;
  int v178 = &unk_1EDD18C48;
  int v181 = v182;
  uint64_t v138 = 0x100000003;
  long long v137 = xmmword_18E1F6F60;
  uint64_t v136 = &unk_1EDD18D98;
  uint64_t v139 = v140;
  sub_18DFE345C(v11, (uint64_t)&v141, (uint64_t)&v178, (uint64_t)&v136, "2");
  if (fabs(v20) <= 0.000000015 || v20 < v7)
  {
    if (cnprint::CNPrinter::GetLogLevel(v19) <= 1)
    {
      LOWORD(v178) = 12;
      LOBYTE(v141) = 1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v178, (unsigned __int8 *)&v141, "DevAtt,Uncertainty of second vector is too large,unc,%.3lf,norm,%.3lf", v43, v44, v45, v46, v47, SLOBYTE(v7));
    }
    return 0;
  }
  uint64_t v170 = 0x100000003;
  *(void *)&v21.f64[1] = 0x300000003;
  long long v169 = xmmword_18E1F6F60;
  long long v168 = &unk_1EDD18D98;
  uint64_t v171 = (double *)&v172;
  v21.f64[0] = 1.0 / v20;
  sub_18DFE3240(v11, (uint64_t)&v168, v21);
  uint64_t v165 = 0x100000003;
  v162[0] = &unk_1EDD18D98;
  int v166 = v167;
  v162[1] = v174;
  int v163 = DWORD1(v174) * v174;
  int v164 = v174;
  double v22 = *v176;
  double v23 = v176[1];
  double v24 = v176[2];
  double v25 = *v171;
  double v26 = v171[1];
  double v27 = v171[2];
  double v28 = v23 * v27 - v24 * v26;
  double v29 = v24 * *v171 - *v176 * v27;
  *(double *)int v167 = v28;
  *(double *)&v167[1] = v29;
  *(double *)&v167[2] = v22 * v26 - v23 * v25;
  uint64_t v143 = 0x100000003;
  long long v142 = xmmword_18E1F6F60;
  uint64_t v141 = &unk_1EDD18D98;
  double v144 = v145;
  uint64_t v180 = 0x100000134;
  long long v179 = xmmword_18E1F6FB0;
  int v178 = &unk_1EDD18C48;
  int v181 = v182;
  uint64_t v138 = 0x100000003;
  long long v137 = xmmword_18E1F6F60;
  uint64_t v136 = &unk_1EDD18D98;
  uint64_t v139 = v140;
  sub_18DFE345C((uint64_t)v162, (uint64_t)&v141, (uint64_t)&v178, (uint64_t)&v136, "2");
  if (v31.f64[0] < *(double *)&qword_1EB404B98)
  {
    if (cnprint::CNPrinter::GetLogLevel(v30) <= 1)
    {
      LOWORD(v178) = 12;
      LOBYTE(v141) = 1;
      double v37 = "DevAtt,Vector 1 and 2 are too close < 30deg";
LABEL_20:
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v178, (unsigned __int8 *)&v141, v37, v32, v33, v34, v35, v36, v118);
      return 0;
    }
    return 0;
  }
  uint64_t v180 = 0x100000003;
  long long v179 = xmmword_18E1F6F60;
  int v178 = &unk_1EDD18D98;
  int v181 = v182;
  v31.f64[0] = 1.0 / v31.f64[0];
  sub_18DFE3240((uint64_t)v162, (uint64_t)&v178, v31);
  sub_18DFE2F24((uint64_t)v162, (uint64_t)&v178);
  uint64_t v143 = 0x100000003;
  long long v142 = xmmword_18E1F6F60;
  uint64_t v141 = &unk_1EDD18D98;
  double v144 = v145;
  uint64_t v180 = 0x100000134;
  long long v179 = xmmword_18E1F6FB0;
  int v178 = &unk_1EDD18C48;
  int v181 = v182;
  uint64_t v138 = 0x100000003;
  long long v137 = xmmword_18E1F6F60;
  uint64_t v136 = &unk_1EDD18D98;
  uint64_t v139 = v140;
  sub_18DFE345C(v14, (uint64_t)&v141, (uint64_t)&v178, (uint64_t)&v136, "2");
  if (fabs(v53.f64[0]) <= 0.000000015)
  {
    LOWORD(v178) = 12;
    LOBYTE(v141) = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v178, (unsigned __int8 *)&v141, "DevAtt,Error,Reference vector 1 is zero vector,norm,%.3lf", v48, v49, v50, v51, v52, SLOBYTE(v53.f64[0]));
    return 0;
  }
  uint64_t v159 = 0x100000003;
  long long v158 = xmmword_18E1F6F60;
  double v157 = &unk_1EDD18D98;
  double v160 = (double *)&v161;
  v53.f64[0] = 1.0 / v53.f64[0];
  sub_18DFE3240(v14, (uint64_t)&v157, v53);
  uint64_t v143 = 0x100000003;
  long long v142 = xmmword_18E1F6F60;
  uint64_t v141 = &unk_1EDD18D98;
  double v144 = v145;
  uint64_t v180 = 0x100000134;
  long long v179 = xmmword_18E1F6FB0;
  int v178 = &unk_1EDD18C48;
  int v181 = v182;
  uint64_t v138 = 0x100000003;
  long long v137 = xmmword_18E1F6F60;
  uint64_t v136 = &unk_1EDD18D98;
  uint64_t v139 = v140;
  sub_18DFE345C(v9, (uint64_t)&v141, (uint64_t)&v178, (uint64_t)&v136, "2");
  if (fabs(v54.f64[0]) <= 0.000000015)
  {
    LOWORD(v178) = 12;
    LOBYTE(v141) = 4;
    char v118 = LOBYTE(v54.f64[0]);
    double v37 = "DevAtt,Error,Reference vector 2 is zero vector,norm,%.3lf";
    goto LABEL_20;
  }
  uint64_t v154 = 0x100000003;
  long long v153 = xmmword_18E1F6F60;
  double v152 = &unk_1EDD18D98;
  double v155 = (double *)&v156;
  v54.f64[0] = 1.0 / v54.f64[0];
  sub_18DFE3240(v9, (uint64_t)&v152, v54);
  uint64_t v149 = 0x100000003;
  v146[0] = &unk_1EDD18D98;
  double v150 = v151;
  v146[1] = v158;
  int v147 = DWORD1(v158) * v158;
  int v148 = v158;
  double v55 = *v160;
  double v56 = v160[1];
  double v57 = v160[2];
  double v58 = *v155;
  double v59 = v155[1];
  double v60 = v155[2];
  double v61 = v56 * v60 - v57 * v59;
  double v62 = v57 * *v155 - *v160 * v60;
  *(double *)double v151 = v61;
  *(double *)&v151[1] = v62;
  *(double *)&v151[2] = v55 * v59 - v56 * v58;
  uint64_t v143 = 0x100000003;
  long long v142 = xmmword_18E1F6F60;
  uint64_t v141 = &unk_1EDD18D98;
  double v144 = v145;
  uint64_t v180 = 0x100000134;
  long long v179 = xmmword_18E1F6FB0;
  int v178 = &unk_1EDD18C48;
  int v181 = v182;
  uint64_t v138 = 0x100000003;
  long long v137 = xmmword_18E1F6F60;
  uint64_t v136 = &unk_1EDD18D98;
  uint64_t v139 = v140;
  sub_18DFE345C((uint64_t)v146, (uint64_t)&v141, (uint64_t)&v178, (uint64_t)&v136, "2");
  if (v64.f64[0] < *(double *)&qword_1EB404B98)
  {
    if (cnprint::CNPrinter::GetLogLevel(v63) <= 1)
    {
      LOWORD(v178) = 12;
      LOBYTE(v141) = 1;
      double v37 = "DevAtt,Reference Vector 1 and 2 are too close < 30deg";
      goto LABEL_20;
    }
    return 0;
  }
  v64.f64[0] = 1.0 / v64.f64[0];
  sub_18E053C38((uint64_t)v146, (uint64_t)&v178, v64);
  sub_18DFE2F24((uint64_t)v146, (uint64_t)&v178);
  if (fabs(v12) <= 0.000000015)
  {
    if (cnprint::CNPrinter::GetLogLevel(v67) <= 1)
    {
      LOWORD(v178) = 12;
      LOBYTE(v141) = 1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v178, (unsigned __int8 *)&v141, "DevAtt,angular/direction uncertainty of first vector is zero,%.3lf", v97, v98, v99, v100, v101, SLOBYTE(v12));
    }
    return 0;
  }
  if (fabs(v7) <= 0.000000015)
  {
    if (cnprint::CNPrinter::GetLogLevel(v67) <= 1)
    {
      LOWORD(v178) = 12;
      LOBYTE(v141) = 1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v178, (unsigned __int8 *)&v141, "DevAtt,angular/direction uncertainty of second vector is zero,%.3lf", v102, v103, v104, v105, v106, SLOBYTE(v7));
    }
    return 0;
  }
  double v68 = 1.0 / v12 / v12;
  double v69 = 1.0 / v7 / v7;
  double v70 = v68 + v69;
  if (fabs(v68 + v69) <= 0.000000015)
  {
    if (cnprint::CNPrinter::GetLogLevel(v67) <= 1)
    {
      LOWORD(v178) = 12;
      LOBYTE(v141) = 1;
      double v119 = v68 + v69;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v178, (unsigned __int8 *)&v141, "DevAtt,Sum of two weight is zero,%.3lf", v107, v108, v109, v110, v111, SLOBYTE(v119));
    }
    return 0;
  }
  uint64_t v71 = DWORD2(v174);
  double v72 = 0.0;
  double v73 = 0.0;
  if (SDWORD2(v174) >= 1)
  {
    uint64_t v74 = v176;
    uint64_t v75 = v171;
    do
    {
      double v76 = *v74++;
      double v77 = v76;
      double v78 = *v75++;
      double v73 = v73 + v77 * v78;
      --v71;
    }
    while (v71);
  }
  uint64_t v79 = DWORD2(v158);
  if (SDWORD2(v158) >= 1)
  {
    uint64_t v80 = v160;
    double v72 = 0.0;
    uint64_t v81 = v155;
    do
    {
      double v82 = *v80++;
      double v83 = v82;
      double v84 = *v81++;
      double v72 = v72 + v83 * v84;
      --v79;
    }
    while (v79);
  }
  sub_18E030138((uint64_t)&v173, (uint64_t)&v168, (uint64_t)&v178);
  sub_18E03017C((uint64_t)&v178);
  double v121 = v85;
  sub_18E030138((uint64_t)&v157, (uint64_t)&v152, (uint64_t)&v141);
  sub_18E03017C((uint64_t)&v141);
  double v120 = v86;
  sub_18E01D4D4((uint64_t)&v157, (uint64_t)&v141);
  sub_18E07D294((uint64_t)&v173, (uint64_t)&v141, (uint64_t)&v178);
  sub_18E01D4D4((uint64_t)&v152, (uint64_t)&v136);
  sub_18E07D294((uint64_t)&v168, (uint64_t)&v136, (uint64_t)&v141);
  sub_18E01D4D4((uint64_t)v146, (uint64_t)v135);
  sub_18E07D294((uint64_t)v162, (uint64_t)v135, (uint64_t)&v136);
  sub_18E161A28((uint64_t)v129, *v176, v176[1], v176[2]);
  sub_18DFF6360((uint64_t)v129, (uint64_t)&v136, (uint64_t)v130);
  sub_18E161A28((uint64_t)v128, *v160, v160[1], v160[2]);
  sub_18DFF6360((uint64_t)v130, (uint64_t)v128, (uint64_t)v131);
  sub_18E06D4CC((uint64_t)&v178, (uint64_t)v131, (uint64_t)v132);
  double v87 = sqrt(v69 / v70 * (v69 / v70)+ v68 / v70 * (v68 / v70)+ v69 / v70 * (v68 / v70 + v68 / v70) * (v121 * v120 + v73 * v72));
  v88.f64[0] = v68 / v70 / v87;
  sub_18E042024((uint64_t)v132, (uint64_t)v133, v88);
  sub_18E161A28((uint64_t)v123, *v171, v171[1], v171[2]);
  sub_18DFF6360((uint64_t)v123, (uint64_t)&v136, (uint64_t)v124);
  sub_18E161A28((uint64_t)v122, *v155, v155[1], v155[2]);
  sub_18DFF6360((uint64_t)v124, (uint64_t)v122, (uint64_t)v125);
  sub_18E06D4CC((uint64_t)&v141, (uint64_t)v125, (uint64_t)v126);
  v89.f64[0] = v69 / v70 / v87;
  sub_18E042024((uint64_t)v126, (uint64_t)v127, v89);
  sub_18E01E39C((uint64_t)v133, (uint64_t)v127, (uint64_t)v134);
  sub_18E01E39C((uint64_t)v134, (uint64_t)&v136, (uint64_t)v135);
  sub_18DFE20A0((uint64_t)v134, (uint64_t)v135);
  if (v134 != v5)
  {
    long long v90 = v134[1];
    *long long v5 = v134[0];
    v5[1] = v90;
  }
  sub_18E01D4D4((uint64_t)&v173, (uint64_t)v133);
  sub_18E07D294((uint64_t)&v173, (uint64_t)v133, (uint64_t)v134);
  sub_18E01D4D4((uint64_t)&v168, (uint64_t)v132);
  sub_18E07D294((uint64_t)&v168, (uint64_t)v132, (uint64_t)v133);
  sub_18E01D4D4((uint64_t)v162, (uint64_t)v131);
  sub_18E07D294((uint64_t)v162, (uint64_t)v131, (uint64_t)v132);
  sub_18E03017C((uint64_t)v162);
  double v92 = v93.f64[0];
  v93.f64[0] = fabs(v93.f64[0]);
  BOOL v65 = v93.f64[0] > 0.000000015;
  if (v93.f64[0] > 0.000000015)
  {
    v93.f64[0] = v7 * v7;
    sub_18E042024((uint64_t)v134, (uint64_t)v128, v93);
    v94.f64[0] = v12 * v12;
    sub_18E042024((uint64_t)v133, (uint64_t)v127, v94);
    sub_18E01E39C((uint64_t)v128, (uint64_t)v127, (uint64_t)v129);
    v95.f64[0] = 1.0 / v70;
    sub_18E042024((uint64_t)v132, (uint64_t)v126, v95);
    sub_18E01E39C((uint64_t)v129, (uint64_t)v126, (uint64_t)v130);
    v96.f64[0] = 1.0 / v92 / v92;
    sub_18E042024((uint64_t)v130, (uint64_t)v131, v96);
    sub_18DFE2F24(v3, (uint64_t)v131);
  }
  else
  {
    unsigned int LogLevel = cnprint::CNPrinter::GetLogLevel(v91);
    if (LogLevel <= 1)
    {
      v131[0] = 12;
      v130[0] = 1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v131, v130, "DevAtt,Cross product of two input body vectors is zero,%.3lf", v113, v114, v115, v116, v117, SLOBYTE(v92));
    }
  }
  return v65;
}

double sub_18E161A28(uint64_t a1, double a2, double a3, double a4)
{
  *(void *)(a1 + 24) = 0x300000003;
  *(void *)a1 = &unk_1EDD18EE8;
  *(void *)(a1 + 32) = a1 + 40;
  *(_OWORD *)(a1 + 8) = xmmword_18E1F0010;
  sub_18DFE2CC8(a1, 0.0);
  uint64_t v8 = *(void *)(a1 + 32);
  *(double *)(v8 + 8) = a4;
  *(double *)(v8 + 16) = -a3;
  uint64_t v9 = *(int *)(a1 + 20);
  uint64_t v10 = (double *)(v8 + 8 * v9);
  v10[2] = a2;
  double *v10 = -*(double *)(v8 + 8);
  *(double *)(v8 + 16 * v9) = -*(double *)(v8 + 16);
  double result = -v10[2];
  *(double *)(v8 + 8 * (int)((2 * v9) | 1)) = result;
  return result;
}

void raven::RavenDeviceAttitudeActiveObject::biermanObservationalUpdate3X3(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  v54[3] = *(double *)MEMORY[0x1E4F143B8];
  uint64_t v50 = 0x100000003;
  uint64_t v48 = &unk_1EDD18D98;
  uint64_t v51 = &v52;
  long long v49 = xmmword_18E1F6F60;
  sub_18DFE2CC8((uint64_t)&v48, 0.0);
  uint64_t v10 = 0;
  uint64_t v11 = *(int *)(a2 + 20);
  uint64_t v12 = *(void *)(a2 + 32);
  int v13 = *(_DWORD *)(a1 + 812) + 1;
  uint64_t v14 = *(double **)(a1 + 824);
  uint64_t v15 = *(void *)(a3 + 32);
  uint64_t v16 = *(void *)(a4 + 32);
  double v17 = v51;
  float64x2_t v18 = (double *)(v12 - 8 * v11);
LABEL_2:
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = -1;
  double v22 = v18;
  do
  {
    double v23 = *(double *)(v12 + 8 * (v10 + v20 * v11));
    if (v20)
    {
      double v24 = v22;
      uint64_t v25 = v21;
      do
      {
        double v23 = v23 + *v24 * *(double *)(*(void *)(a1 + 1080) + v19 * *(int *)(a1 + 1068) + 8 * v25);
        uint64_t v26 = v25-- + 1;
        v24 -= v11;
      }
      while (v26 > 1);
    }
    v54[v20] = v23;
    v53[v20] = v23 * v14[v13 * (int)v20];
    ++v20;
    ++v21;
    v19 += 8;
    v22 += v11;
  }
  while (v20 != 3);
  double v27 = *(double *)(v15 + 8 * v10);
  double v28 = v27 + v54[0] * v53[0];
  if (v28 <= 0.0)
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v54) > 1) {
      goto LABEL_19;
    }
  }
  else
  {
    char v29 = 0;
    double v30 = 1.0 / v28;
    *uint64_t v14 = v27 * (1.0 / v28) * *v14;
    uint64_t v31 = 1;
    while (1)
    {
      double v32 = v54[v31];
      double v33 = v28 + v32 * v53[v31];
      if (v33 <= 0.0) {
        break;
      }
      char v34 = v29;
      uint64_t v35 = 0;
      double v36 = -(v32 * v30);
      double v30 = 1.0 / v33;
      v14[v13 * (int)v31] = v28 * (1.0 / v33) * v14[v13 * (int)v31];
      uint64_t v37 = *(void *)(a1 + 1080) + 8 * *(_DWORD *)(a1 + 1068) * (int)v31;
      do
      {
        double v38 = *(double *)(v37 + v35 * 8);
        double v39 = v53[v35];
        *(double *)(v37 + v35 * 8) = v38 + v39 * v36;
        v53[v35++] = v39 + v53[v31] * v38;
      }
      while (v31 != v35);
      char v29 = 1;
      uint64_t v31 = 2;
      double v28 = v33;
      if (v34)
      {
        for (uint64_t i = 0; i != 3; ++i)
          *(double *)&v17[i] = *(double *)&v17[i] + v30 * *(double *)(v16 + 8 * v10) * v53[i];
        ++v10;
        ++v18;
        if (v10 == 3)
        {
          sub_18DFF2980(a5, (uint64_t)&v48);
          return;
        }
        goto LABEL_2;
      }
    }
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v54) > 1) {
      goto LABEL_19;
    }
  }
  __int16 v47 = 12;
  unsigned __int8 v46 = 1;
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v47, &v46, "DevAtt,%uz: alpha <= 0, matrix ! positive definite", v41, v42, v43, v44, v45, v10);
LABEL_19:
  *(void *)(a5 + 24) = 0x100000003;
  *(void *)a5 = &unk_1EDD18D98;
  *(void *)(a5 + 32) = a5 + 40;
  *(_OWORD *)(a5 + 8) = xmmword_18E1F6F60;
  sub_18DFE2CC8(a5, 0.0);
}

double raven::RavenDeviceAttitudeActiveObject::ComputeMeanStdVector(uint64_t a1, double **a2)
{
  v5[0] = 0;
  long long v6 = 0u;
  memset(v7, 0, sizeof(v7));
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 == v3) {
    return 0.0;
  }
  do
    sub_18DFF11E4((uint64_t)v5, v2++, 1.0);
  while (v2 != v3);
  return *(double *)&v7[4];
}

void raven::RavenDeviceAttitudeActiveObject::ComputePCABasedHorizontalDirectionOfTravelInIMUFrame(raven::RavenDeviceAttitudeActiveObject *this, const raven::TimeMarkEvent *a2, int8x16_t a3, int8x16_t a4)
{
  if (*((unsigned char *)this + 7328) && *((unsigned __int8 *)this + 7288) - 1 <= 1)
  {
    *((_OWORD *)this + 474) = xmmword_18E200CA0;
    return;
  }
  if (*((void *)this + 989))
  {
    uint64_t v6 = *((void *)this + 1042);
    if (v6)
    {
      unint64_t v7 = *((void *)this + 1041) + v6;
      uint64_t v8 = *((void *)this + 1038);
      uint64_t v9 = (void *)(v8 + 8 * (v7 / 0x14));
      unint64_t v10 = *v9 + 200 * (v7 % 0x14);
      if (*((void *)this + 1039) == v8) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = v10;
      }
      if (v11 == *v9) {
        uint64_t v11 = *(v9 - 1) + 4000;
      }
      uint64_t v12 = CNTimeSpan::operator-((uint64_t)this + 7456, (void *)this + 917, a3, a4);
      *(double *)v14.i64 = v13;
      *(double *)v15.i64 = (double)v12;
      double v16 = v13 + (double)v12;
      uint64_t v17 = CNTimeSpan::operator-((uint64_t)this + 7456, (void *)this + 934, v14, v15);
      if (v16 >= (v18 + (double)v17) * 0.5)
      {
        uint64_t v19 = v11 - 200;
        uint64_t v125 = (*(uint64_t (**)(const raven::TimeMarkEvent *))(*(void *)a2 + 16))(a2);
        v126[0] = v20;
        uint64_t v156 = (*(uint64_t (**)(uint64_t))(*(void *)(v11 - 200) + 16))(v11 - 200);
        uint64_t v157 = v21;
        double v24 = (cnprint::CNPrinter *)CNTimeSpan::operator-((uint64_t)&v125, &v156, v22, v23);
        if (v25 + (double)(uint64_t)v24 <= *(double *)(*((void *)this + 61) + 832))
        {
          uint64_t v26 = *((void *)this + 985);
          double v27 = (void *)(v26 + 8 * (*((void *)this + 988) >> 4));
          uint64_t v28 = *((void *)this + 986);
          uint64_t v104 = v11;
          uint64_t v105 = (void *)((char *)this + 7456);
          if (v28 == v26) {
            uint64_t v29 = 0;
          }
          else {
            uint64_t v29 = *v27 + 2432 * (*((void *)this + 988) & 0xFLL);
          }
          char v106 = 0;
          double v30 = 1.79769313e308;
          uint64_t v31 = v29;
          while (1)
          {
            uint64_t v32 = v29;
            if (v28 == v26)
            {
              uint64_t v34 = 0;
            }
            else
            {
              unint64_t v33 = *((void *)this + 989) + *((void *)this + 988);
              uint64_t v34 = *(void *)(v26 + ((v33 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 2432 * (v33 & 0xF);
            }
            if (v29 == v34) {
              break;
            }
            v29 += 2432;
            if (v32 + 2432 - *v27 == 38912)
            {
              uint64_t v35 = v27[1];
              ++v27;
              uint64_t v29 = v35;
            }
            uint64_t v125 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 16))(v19);
            v126[0] = v36;
            uint64_t v156 = (*(uint64_t (**)(uint64_t))(*(void *)v32 + 16))(v32);
            uint64_t v157 = v37;
            double v24 = (cnprint::CNPrinter *)CNTimeSpan::operator-((uint64_t)&v125, &v156, v38, v39);
            *(double *)v42.i64 = v41 + (double)(uint64_t)v24;
            if (*(double *)v42.i64 >= 0.0
              && *(unsigned char *)(v32 + 209) == 2
              && *(unsigned char *)(v32 + 1464)
              && *(unsigned char *)(v32 + 1624)
              && *(unsigned char *)(v32 + 1824)
              && *(unsigned char *)(v32 + 1345)
              && *(unsigned char *)(v32 + 1904))
            {
              *(double *)v40.i64 = (double)(uint64_t)v24;
              double v24 = (cnprint::CNPrinter *)CNTimeSpan::operator-((uint64_t)v105, (void *)(v32 + 1168), v42, v40);
              double v44 = v43 + (double)(uint64_t)v24;
              double v45 = fabs(v30);
              if (v45 < fabs(v44) && (v45 < 1.0 || v30 >= v44)) {
                break;
              }
              char v106 = 1;
            }
            else
            {
              uint64_t v32 = v31;
              double v44 = v30;
            }
            uint64_t v26 = *((void *)this + 985);
            uint64_t v28 = *((void *)this + 986);
            uint64_t v31 = v32;
            double v30 = v44;
          }
          if (v106)
          {
            uint64_t v177 = 0x100000003;
            double v174 = 0.0;
            uint64_t v175 = &unk_1EDD18D98;
            long long v176 = xmmword_18E1F6F60;
            int v178 = &v179;
            uint64_t v171 = 0x100000003;
            long long v170 = xmmword_18E1F6F60;
            long long v169 = &unk_1EDD18D98;
            uint64_t v172 = &v173;
            if (raven::RavenDeviceAttitudeActiveObject::PCAForHorizontalDOTInIMUFrame((uint64_t)this))
            {
              sub_18DFFDA0C((uint64_t)v167, *(float64_t *)(v31 + 1272), *(float64_t *)(v31 + 1280), *(double *)(v31 + 1288));
              if (v167[8])
              {
                uint64_t v164 = 0x300000003;
                long long v163 = xmmword_18E1F0010;
                unsigned __int8 v162 = &unk_1EDD18EE8;
                uint64_t v165 = &v166;
                sub_18DFE2F24((uint64_t)&v162, (uint64_t)&v168);
                sub_18E163BE4((uint64_t)&v156);
                sub_18E163BE4((uint64_t)v153);
                if (raven::RavenDeviceAttitudeActiveObject::GetDAEFromQueueForInputTime(this, (void *)(v31 + 1168), (uint64_t)&v156))
                {
                  if (raven::RavenDeviceAttitudeActiveObject::GetDAEFromQueueForInputTime(this, v105, (uint64_t)v153))
                  {
                    long long v151 = v154;
                    *(_OWORD *)double v152 = v155;
                    double v46 = sqrt(v159 * v159 + v158 * v158 + v160 * v160 + v161 * v161);
                    double v47 = 1.0;
                    double v48 = 0.0;
                    double v49 = 0.0;
                    double v50 = 0.0;
                    double v51 = 0.0;
                    double v52 = 1.0;
                    if (fabs(v46) >= 2.22044605e-16)
                    {
                      double v49 = -v158 / v46;
                      double v50 = -v159 / v46;
                      double v51 = -v160 / v46;
                      double v52 = v161 / v46;
                    }
                    uint64_t v125 = *(void *)&v49;
                    *(double *)uint64_t v126 = v50;
                    *(double *)&v126[1] = v51;
                    *(double *)&v126[2] = v52;
                    cnrotation::Cat((double *)&v151, (const cnrotation::CNRotation *)&v125, v150);
                    uint64_t v146 = 0x100000003;
                    long long v145 = xmmword_18E1F6F60;
                    double v144 = &unk_1EDD18D98;
                    int v147 = &v148;
                    long long v148 = *(_OWORD *)(v31 + 1360);
                    uint64_t v149 = *(void *)(v31 + 1376);
                    sub_18E0300B4((uint64_t)&v162, (uint64_t)&v144, (uint64_t)v141);
                    double v53 = *(double *)(v31 + 1632);
                    double v54 = *(double *)(v31 + 1640);
                    double v55 = *(double *)(v31 + 1648);
                    double v56 = *(double *)(v31 + 1656);
                    double v57 = sqrt(v54 * v54 + v53 * v53 + v55 * v55 + v56 * v56);
                    double v58 = 0.0;
                    double v59 = 0.0;
                    if (fabs(v57) >= 2.22044605e-16)
                    {
                      double v48 = v53 / v57;
                      double v58 = v54 / v57;
                      double v59 = v55 / v57;
                      double v47 = v56 / v57;
                    }
                    *(double *)uint64_t v140 = v48;
                    *(double *)&v140[1] = v58;
                    *(double *)&v140[2] = v59;
                    *(double *)&v140[3] = v47;
                    cnrotation::Cat(v150, (const cnrotation::CNRotation *)v140, &v136);
                    double v60 = sqrt(v137 * v137 + v136 * v136 + v138 * v138 + v139 * v139);
                    if (fabs(v60) >= 2.22044605e-16)
                    {
                      double v62 = -v136 / v60;
                      double v63 = -v137 / v60;
                      double v64 = -v138 / v60;
                      double v61 = v139 / v60;
                    }
                    else
                    {
                      double v61 = 1.0;
                      double v62 = 0.0;
                      double v63 = 0.0;
                      double v64 = 0.0;
                    }
                    *(double *)uint64_t v123 = v62;
                    *(double *)&v123[1] = v63;
                    *(double *)&v123[2] = v64;
                    *(double *)&v123[3] = v61;
                    sub_18DFEDF6C((cnrotation::CNRotation *)v123, (uint64_t)&v175, (uint64_t)v109);
                    sub_18DFF6360((uint64_t)&v162, (uint64_t)v109, (uint64_t)&v125);
                    sub_18DFEF290((uint64_t)v134, (uint64_t)&v125);
                    uint64_t v74 = v142;
                    if (v142 >= 1)
                    {
                      uint64_t v75 = v143;
                      double v76 = 0.0;
                      double v77 = v135;
                      do
                      {
                        double v78 = *v75++;
                        double v79 = v78;
                        double v80 = *v77++;
                        double v76 = v76 + v79 * v80;
                        --v74;
                      }
                      while (v74);
                      if (v76 < 0.0)
                      {
                        sub_18E1642D0((uint64_t)&v125, (uint64_t)&v175);
                        sub_18DFE2F24((uint64_t)&v175, (uint64_t)&v125);
                        sub_18E1642D0((uint64_t)&v125, (uint64_t)v134);
                        __n128 v72 = sub_18DFE2F24((uint64_t)v134, (uint64_t)&v125);
                      }
                    }
                    v72.n128_f64[0] = v174;
                    v73.i64[0] = 1.0;
                    double v81 = 1.0 - v174;
                    uint64_t v82 = *(void *)(v31 + 224);
                    if (v82 < 0 || (v72.n128_u64[0] = *(void *)(v31 + 232), v72.n128_f64[0] < 0.0)) {
                      uint64_t v82 = CNTimeSpan::operator-((double *)(v31 + 224), (int8x16_t)v72, v73);
                    }
                    else {
                      double v83 = *(double *)(v31 + 232);
                    }
                    double v84 = v81 * 40.0 + 10.0;
                    if ((double)v82 + v83 <= 30.0) {
                      goto LABEL_64;
                    }
                    long double v85 = atan2(*v143, v143[1]) * 57.2957795;
                    double v86 = (__double2 *)v135;
                    double v87 = atan2(*v135, v135[1]) * 57.2957795;
                    double v88 = v87 - v85 - round((v87 - v85) / 360.0) * 360.0;
                    if (fabs(v88) <= 45.0 && v84 > 0.0)
                    {
                      double v89 = *((double *)this + 949);
                      double v90 = v89 / (v84 * v84 + v89);
                      double v91 = fmod(*((double *)this + 948) + v90 * (v88 - *((double *)this + 948)), 360.0);
                      *((double *)this + 948) = v91;
                      double v92 = v89 * (1.0 - v90);
                      *((double *)this + 949) = v92;
                      if (v92 <= 30.0)
                      {
                        *((void *)this + 949) = 0x403E000000000000;
                        *double v86 = __sincos_stret((v87 - v91) * 0.0174532925);
                        sub_18DFF63E0((uint64_t)&v162, (uint64_t)v109);
                        sub_18E0300B4((uint64_t)v109, (uint64_t)v134, (uint64_t)v123);
                        sub_18DFEDF6C((cnrotation::CNRotation *)&v136, (uint64_t)v123, (uint64_t)&v125);
                        sub_18DFE2F24((uint64_t)&v175, (uint64_t)&v125);
                        int v93 = 1;
LABEL_65:
                        *(_OWORD *)((char *)this + 7336) = *(_OWORD *)v105;
                        sub_18E164358((uint64_t)&v125);
                        double v94 = sqrt(*((double *)&v151 + 1) * *((double *)&v151 + 1)+ *(double *)&v151 * *(double *)&v151+ v152[0] * v152[0]+ v152[1] * v152[1]);
                        if (fabs(v94) >= 2.22044605e-16)
                        {
                          double v96 = -*(double *)&v151 / v94;
                          double v97 = -*((double *)&v151 + 1) / v94;
                          double v98 = -v152[0] / v94;
                          double v95 = v152[1] / v94;
                        }
                        else
                        {
                          double v95 = 1.0;
                          double v96 = 0.0;
                          double v97 = 0.0;
                          double v98 = 0.0;
                        }
                        *(double *)uint64_t v109 = v96;
                        *(double *)&v109[8] = v97;
                        *(double *)&v109[16] = v98;
                        *(double *)&v109[24] = v95;
                        cnrotation::Cat((double *)(v104 - 32), (const cnrotation::CNRotation *)v109, v124);
                        uint64_t v99 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 16))(v19);
                        long long v130 = 0u;
                        long long v129 = 0u;
                        long long v128 = 0u;
                        long long v127 = 0u;
                        v126[14] = v99;
                        v126[15] = v100;
                        uint64_t v131 = 0;
                        uint64_t v132 = 0x7FF8000000000000;
                        sub_18DFEDF6C((cnrotation::CNRotation *)v124, (uint64_t)&v175, (uint64_t)v109);
                        sub_18DFE2F24((uint64_t)v133, (uint64_t)v109);
                        sub_18DFEDF6C((cnrotation::CNRotation *)v124, (uint64_t)&v169, (uint64_t)v123);
                        cnrotation::Cat(v124, (const cnrotation::CNRotation *)&v136, (double *)v109);
                        v133[4] = *(_OWORD *)v109;
                        v133[5] = *(_OWORD *)&v109[16];
                        if (!v93) {
                          double v84 = v84 + 40.0;
                        }
                        sub_18E06041C((uint64_t)v123, (uint64_t)v109);
                        sub_18DFEF290((uint64_t)v122, (uint64_t)v109);
                        sub_18E030138((uint64_t)v122, (uint64_t)v133, (uint64_t)v121);
                        sub_18DFEB238(3, 3, (uint64_t)v118);
                        uint64_t v101 = v120;
                        *double v120 = 0x4028000000000000;
                        int v102 = v119;
                        v101[2 * v119 + 2] = 0x4028000000000000;
                        *(double *)&v101[v102 + 1] = v84 * 0.0174532925 * (v84 * 0.0174532925);
                        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404BA8, memory_order_acquire) & 1) == 0)
                        {
                          if (__cxa_guard_acquire(&qword_1EB404BA8))
                          {
                            *(void *)&v109[24] = 0x300000001;
                            *(void *)uint64_t v109 = &unk_1EDD18258;
                            uint64_t v110 = &v111;
                            *(_OWORD *)&v109[8] = xmmword_18E1F8560;
                            uint64_t v111 = 0x100000000;
                            int v112 = 2;
                            sub_18DFEC63C((uint64_t)v109, (uint64_t)&unk_1EB404BF8);
                            __cxa_atexit((void (*)(void *))sub_18DFE2E9C, &unk_1EB404BF8, &dword_18DEDB000);
                            __cxa_guard_release(&qword_1EB404BA8);
                          }
                        }
                        uint64_t v115 = 0x300000003;
                        long long v114 = xmmword_18E1F0010;
                        uint64_t v113 = &unk_1EDD18EE8;
                        uint64_t v116 = &v117;
                        sub_18E01D4D4((uint64_t)v133, (uint64_t)v108);
                        sub_18E164420((uint64_t)v109, (uint64_t)&v113, 0);
                        sub_18DFEC97C((uint64_t)v109, (uint64_t)v108);
                        sub_18E01D4D4((uint64_t)v121, (uint64_t)v108);
                        sub_18E164420((uint64_t)v109, (uint64_t)&v113, 1);
                        sub_18DFEC97C((uint64_t)v109, (uint64_t)v108);
                        sub_18E01D4D4((uint64_t)v122, (uint64_t)v108);
                        sub_18E164420((uint64_t)v109, (uint64_t)&v113, 2);
                        sub_18DFEC97C((uint64_t)v109, (uint64_t)v108);
                        sub_18DFF6360((uint64_t)&v113, (uint64_t)v118, (uint64_t)v108);
                        sub_18DFF63E0((uint64_t)&v113, (uint64_t)v107);
                        sub_18DFF6360((uint64_t)v108, (uint64_t)v107, (uint64_t)v109);
                        sub_18DFE2F24((uint64_t)v126, (uint64_t)v109);
                        sub_18E164488();
                      }
LABEL_64:
                      int v93 = 0;
                      goto LABEL_65;
                    }
                  }
                }
              }
            }
          }
          else if (!cnprint::CNPrinter::GetLogLevel(v24))
          {
            LOWORD(v125) = 12;
            LOBYTE(v156) = 0;
            uint64_t v65 = (*(uint64_t (**)(const raven::TimeMarkEvent *))(*(void *)a2 + 16))(a2);
            double v103 = v66 + (double)v65;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v125, (unsigned __int8 *)&v156, "t,%.3lf No applicable PNT solution found for PCA HDOT", v67, v68, v69, v70, v71, SLOBYTE(v103));
          }
        }
      }
    }
  }
}

void sub_18E162B34(_Unwind_Exception *a1)
{
}

uint64_t raven::RavenDeviceAttitudeActiveObject::PCAForHorizontalDOTInIMUFrame(uint64_t a1)
{
  double v1 = (void *)MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  long long v5 = v4;
  uint64_t v7 = v6;
  uint64_t v9 = v8;
  uint64_t v11 = v10;
  double v13 = v12;
  int8x16_t v14 = v1;
  v181[2] = 0;
  v181[0] = &unk_1EDD14BF0;
  v181[1] = 0;
  char v182 = 0;
  uint64_t v184 = 0;
  uint64_t v183 = 0;
  char v185 = 0;
  uint64_t v187 = 0;
  uint64_t v186 = 0;
  char v188 = 0;
  uint64_t v190 = 0;
  uint64_t v189 = 0;
  int64x2_t v191 = vdupq_n_s64(0x7FF8000000000000uLL);
  int64x2_t v192 = v191;
  int64x2_t v193 = v191;
  uint64_t v194 = 0x7FF8000000000000;
  *(void *)&long long v197 = 0;
  long long v196 = 0u;
  long long v195 = 0u;
  *((void *)&v197 + 1) = 0x3FF0000000000000;
  int DAEFromQueueForInputTime = raven::RavenDeviceAttitudeActiveObject::GetDAEFromQueueForInputTime(v1, v10, (uint64_t)v181);
  uint64_t result = 0;
  if (!DAEFromQueueForInputTime) {
    return result;
  }
  v180[0] = v196;
  v180[1] = v197;
  uint64_t v177 = 0x100000003;
  long long v176 = xmmword_18E1F6F60;
  uint64_t v175 = &unk_1EDD18D98;
  int v178 = (double *)&v179;
  double v17 = *(double *)(v9 + 464);
  double v18 = *(double *)(v9 + 472);
  double v19 = *(double *)(v9 + 480);
  double v20 = *(double *)(v9 + 488);
  double v21 = sqrt(v18 * v18 + v17 * v17 + v19 * v19 + v20 * v20);
  if (fabs(v21) >= 2.22044605e-16)
  {
    double v23 = v17 / v21;
    double v24 = v18 / v21;
    double v25 = v19 / v21;
    double v22 = v20 / v21;
  }
  else
  {
    double v22 = 1.0;
    double v23 = 0.0;
    double v24 = 0.0;
    double v25 = 0.0;
  }
  *(double *)double v174 = v23;
  *(double *)&v174[1] = v24;
  *(double *)&v174[2] = v25;
  *(double *)&v174[3] = v22;
  v156[2] = 0;
  v156[0] = &unk_1EDD14BF0;
  v156[1] = 0;
  char v157 = 0;
  uint64_t v159 = 0;
  uint64_t v158 = 0;
  char v160 = 0;
  uint64_t v162 = 0;
  uint64_t v161 = 0;
  char v163 = 0;
  uint64_t v165 = 0;
  uint64_t v164 = 0;
  int64x2_t v166 = vdupq_n_s64(0x7FF8000000000000uLL);
  int64x2_t v167 = v166;
  int64x2_t v168 = v166;
  uint64_t v169 = 0x7FF8000000000000;
  double v172 = 0.0;
  long long v171 = 0u;
  long long v170 = 0u;
  double v173 = 1.0;
  int v26 = raven::RavenDeviceAttitudeActiveObject::GetDAEFromQueueForInputTime(v14, (void *)v9, (uint64_t)v156);
  uint64_t result = 0;
  if (!v26) {
    return result;
  }
  double v27 = sqrt(*((double *)&v171 + 1) * *((double *)&v171 + 1)+ *(double *)&v171 * *(double *)&v171+ v172 * v172+ v173 * v173);
  if (fabs(v27) >= 2.22044605e-16)
  {
    double v29 = -*(double *)&v171 / v27;
    double v30 = -*((double *)&v171 + 1) / v27;
    double v31 = -v172 / v27;
    double v28 = v173 / v27;
  }
  else
  {
    double v28 = 1.0;
    double v29 = 0.0;
    double v30 = 0.0;
    double v31 = 0.0;
  }
  double v198 = v29;
  *(double *)&long long v199 = v30;
  *((double *)&v199 + 1) = v31;
  uint64_t v200 = *(void *)&v28;
  cnrotation::Cat((double *)v180, (const cnrotation::CNRotation *)&v198, v155);
  uint64_t v152 = 0x100000003;
  double v150 = &unk_1EDD18D98;
  long long v153 = &v154;
  long long v151 = xmmword_18E1F6F60;
  sub_18DFE2CC8((uint64_t)&v150, 0.0);
  v153[2] = 0xC0239D013A92A305;
  sub_18E074368((uint64_t)v149, *(float64_t *)(v9 + 104), *(float64_t *)(v9 + 112), *(double *)(v9 + 120));
  if (!v149[8]) {
    return 0;
  }
  double v88 = v13;
  uint64_t v146 = 0x100000003;
  long long v145 = xmmword_18E1F6F60;
  double v144 = &unk_1EDD18D98;
  int v147 = &v148;
  sub_18E168AB8((uint64_t)v149, (uint64_t)&v150, (uint64_t)&v144);
  cnrotation::Cat(v155, (const cnrotation::CNRotation *)v174, v143);
  sub_18DFEDF6C((cnrotation::CNRotation *)v143, (uint64_t)&v144, (uint64_t)&v198);
  sub_18DFE2F24((uint64_t)&v175, (uint64_t)&v198);
  uint64_t v205 = 0x100000003;
  long long v204 = xmmword_18E1F6F60;
  double v203 = COERCE_DOUBLE(&unk_1EDD18D98);
  v206 = v207;
  uint64_t v200 = 0x100000134;
  long long v199 = xmmword_18E1F6FB0;
  double v198 = COERCE_DOUBLE(&unk_1EDD18C48);
  int v201 = (double *)v202;
  uint64_t v135 = 0x100000003;
  long long v134 = xmmword_18E1F6F60;
  uint64_t v133 = &unk_1EDD18D98;
  double v136 = v137;
  sub_18DFE345C((uint64_t)&v175, (uint64_t)&v203, (uint64_t)&v198, (uint64_t)&v133, "2");
  if (v32 <= 0.000000015) {
    return 0;
  }
  double v33 = 1.0 / v32;
  uint64_t v34 = v178;
  uint64_t v35 = *(double **)(v3 + 32);
  *uint64_t v35 = v33 * *v178;
  v35[1] = v33 * v34[1];
  v35[2] = v33 * v34[2];
  uint64_t v140 = 0x100000003;
  double v138 = &unk_1EDD18D98;
  uint64_t v141 = (double *)&v142;
  long long v139 = xmmword_18E1F6F60;
  sub_18DFE2CC8((uint64_t)&v138, 0.0);
  uint64_t v135 = 0x300000003;
  uint64_t v133 = &unk_1EDD18EE8;
  double v136 = v137;
  long long v134 = xmmword_18E1F0010;
  sub_18DFE2CC8((uint64_t)&v133, 0.0);
  uint64_t v38 = v14[1038];
  uint64_t v86 = v7;
  if (v14[1039] == v38
    || (unint64_t v39 = v14[1041],
        unint64_t v40 = *(void *)(v38 + 8 * (v39 / 0x14)) + 200 * (v39 % 0x14),
        unint64_t v87 = *(void *)(v38 + 8 * ((v14[1042] + v39) / 0x14)) + 200 * ((v14[1042] + v39) % 0x14),
        v40 == v87))
  {
    unsigned int v41 = 0;
  }
  else
  {
    unsigned int v41 = 0;
    int8x16_t v42 = (void *)(v38 + 8 * (v39 / 0x14));
    do
    {
      double v198 = COERCE_DOUBLE((*(uint64_t (**)(unint64_t))(*(void *)v40 + 16))(v40));
      *(void *)&long long v199 = v43;
      if (!sub_18DEE4CB8(&v198, v88))
      {
        double v198 = COERCE_DOUBLE((*(uint64_t (**)(unint64_t))(*(void *)v40 + 16))(v40));
        *(void *)&long long v199 = v44;
        if (sub_18DEE4C00(&v198, v11)) {
          break;
        }
        uint64_t v102 = 0x100000003;
        long long v101 = xmmword_18E1F6F60;
        uint64_t v100 = &unk_1EDD18D98;
        double v103 = &v104;
        long long v104 = *(_OWORD *)(v40 + 128);
        uint64_t v105 = *(void *)(v40 + 144);
        cnrotation::Inv((float64x2_t *)(v40 + 168), (float64x2_t *)&v198);
        cnrotation::Cat((double *)v180, (const cnrotation::CNRotation *)&v198, &v129);
        uint64_t v96 = 0x100000003;
        double v94 = &unk_1EDD18D98;
        long long v95 = xmmword_18E1F6F60;
        double v97 = &v98;
        float64x2_t v98 = vmlaq_f64(vnegq_f64(*(float64x2_t *)(v9 + 664)), vaddq_f64(*(float64x2_t *)(v40 + 128), *(float64x2_t *)(v40 + 104)), *(float64x2_t *)(v9 + 744));
        double v99 = -(*(double *)(v9 + 680) - *(double *)(v9 + 760) * (*(double *)(v40 + 144) + *(double *)(v40 + 120)));
        double v45 = sqrt(v130 * v130 + v129 * v129 + v131 * v131 + v132 * v132);
        if (fabs(v45) >= 2.22044605e-16)
        {
          double v47 = -v129 / v45;
          double v48 = -v130 / v45;
          double v49 = -v131 / v45;
          double v46 = v132 / v45;
        }
        else
        {
          double v46 = 1.0;
          double v47 = 0.0;
          double v48 = 0.0;
          double v49 = 0.0;
        }
        double v203 = v47;
        *(double *)&long long v204 = v48;
        *((double *)&v204 + 1) = v49;
        uint64_t v205 = *(void *)&v46;
        sub_18DFEDF6C((cnrotation::CNRotation *)&v203, v3, (uint64_t)&v198);
        uint64_t v51 = DWORD2(v95);
        if (SDWORD2(v95) < 1)
        {
          v50.f64[0] = 0.0;
        }
        else
        {
          double v52 = (double *)v97;
          v50.f64[0] = 0.0;
          double v53 = v201;
          do
          {
            double v54 = *v52++;
            double v55 = v54;
            double v56 = *v53++;
            v50.f64[0] = v50.f64[0] + v55 * v56;
            --v51;
          }
          while (v51);
        }
        uint64_t v205 = 0x300000003;
        long long v204 = xmmword_18E1F0010;
        double v203 = COERCE_DOUBLE(&unk_1EDD18EE8);
        v206 = v207;
        sub_18DFE3240((uint64_t)&v198, (uint64_t)&v203, v50);
        uint64_t v91 = 0x100000003;
        double v89 = &unk_1EDD18D98;
        long long v90 = xmmword_18E1F6F60;
        double v92 = v93;
        sub_18DFE2AA8((uint64_t)&v94, (uint64_t)&v203, (uint64_t)&v89);
        sub_18DFEDF6C((cnrotation::CNRotation *)&v129, (uint64_t)&v89, (uint64_t)&v203);
        sub_18DFEF290((uint64_t)&v208, (uint64_t)&v203);
        uint64_t v126 = 0x100000003;
        long long v125 = xmmword_18E1F6F60;
        double v124 = &unk_1EDD18D98;
        long long v127 = &v128;
        float64x2_t v58 = sub_18DFE2AA8(v57, (uint64_t)&v138, (uint64_t)&v124);
        v58.f64[0] = 1.0 / (double)++v41;
        uint64_t v121 = 0x100000003;
        long long v120 = xmmword_18E1F6F60;
        int v119 = &unk_1EDD18D98;
        uint64_t v122 = v123;
        sub_18DFE3240((uint64_t)&v124, (uint64_t)&v119, v58);
        uint64_t v205 = 0x100000003;
        long long v204 = xmmword_18E1F6F60;
        double v203 = COERCE_DOUBLE(&unk_1EDD18D98);
        v206 = v207;
        sub_18DFEF1F4((uint64_t)&v138, (uint64_t)&v119, (uint64_t)&v203);
        sub_18DFE2F24((uint64_t)&v138, (uint64_t)&v203);
        uint64_t v108 = 0x100000003;
        long long v107 = xmmword_18E1F6F60;
        char v106 = &unk_1EDD18D98;
        uint64_t v109 = &v110;
        sub_18DFE2AA8((uint64_t)&v208, (uint64_t)&v138, (uint64_t)&v106);
        int v59 = DWORD1(v107);
        int v60 = v107;
        uint64_t v116 = 0x300000001;
        uint64_t v111 = &unk_1EDD18228;
        uint64_t v117 = v118;
        int v112 = DWORD1(v107);
        int v113 = v107;
        int v114 = v107 * DWORD1(v107);
        int v115 = DWORD1(v107);
        if (DWORD1(v107))
        {
          int v61 = 0;
          int v62 = 0;
          int v63 = HIDWORD(v107);
          double v64 = v109;
          do
          {
            int v65 = v61;
            int v66 = v62;
            for (int i = v60; i; --i)
            {
              v118[v66] = v64[v65];
              v66 += v59;
              ++v65;
            }
            ++v62;
            v61 += v63;
          }
          while (v62 != v59);
        }
        uint64_t v121 = 0x300000003;
        long long v120 = xmmword_18E1F0010;
        int v119 = &unk_1EDD18EE8;
        uint64_t v122 = v123;
        sub_18DFE2B44((uint64_t)&v124, (uint64_t)&v111, (uint64_t)&v119);
        uint64_t v205 = 0x300000003;
        long long v204 = xmmword_18E1F0010;
        double v203 = COERCE_DOUBLE(&unk_1EDD18EE8);
        v206 = v207;
        sub_18DFEF1F4((uint64_t)&v133, (uint64_t)&v119, (uint64_t)&v203);
        __n128 v36 = sub_18DFE2F24((uint64_t)&v133, (uint64_t)&v203);
      }
      v40 += 200;
      if (v40 - *v42 == 4000)
      {
        unint64_t v68 = v42[1];
        ++v42;
        unint64_t v40 = v68;
      }
    }
    while (v40 != v87);
  }
  double v69 = (double)v41;
  uint64_t v70 = CNTimeSpan::operator-((uint64_t)(v14 + 932), v14 + 934, (int8x16_t)v36, v37);
  v72.f64[0] = (v71 + (double)v70) * 0.7 / *(double *)(v14[61] + 648);
  if (v72.f64[0] < 4.0) {
    v72.f64[0] = 4.0;
  }
  if (v72.f64[0] > v69) {
    return 0;
  }
  uint64_t v121 = 0x300000003;
  long long v120 = xmmword_18E1F0010;
  int v119 = &unk_1EDD18EE8;
  uint64_t v122 = v123;
  v72.f64[0] = 1.0 / (v69 + -1.0);
  sub_18DFE3240((uint64_t)&v133, (uint64_t)&v119, v72);
  uint64_t v102 = 0x300000003;
  long long v101 = xmmword_18E1F0010;
  uint64_t v100 = &unk_1EDD18EE8;
  double v103 = &v104;
  uint64_t v96 = 0x300000003;
  double v94 = &unk_1EDD18EE8;
  double v97 = &v98;
  long long v95 = xmmword_18E1F0010;
  sub_18DFE2CC8((uint64_t)&v94, 0.0);
  uint64_t v91 = 0x300000003;
  double v89 = &unk_1EDD18EE8;
  long long v90 = xmmword_18E1F0010;
  double v92 = v93;
  uint64_t v205 = 0x300000003;
  double v203 = COERCE_DOUBLE(&unk_1EDD18EE8);
  *(void *)&long long v204 = v120;
  DWORD2(v204) = DWORD1(v120) * v120;
  HIDWORD(v204) = v120;
  v206 = v207;
  uint64_t v200 = 0x1000001E6;
  long long v199 = xmmword_18E1FD000;
  double v198 = COERCE_DOUBLE(&unk_1EDD19218);
  int v201 = (double *)v202;
  sub_18E171184((uint64_t)&v119, (uint64_t)&v203, (uint64_t)&v198, (uint64_t)&v100, (uint64_t)&v94, (uint64_t)&v89);
  double v73 = v97->f64[0];
  double v74 = v97->f64[SHIDWORD(v95) + 1];
  uint64_t v205 = 0x100000003;
  long long v204 = xmmword_18E1F6F60;
  double v203 = COERCE_DOUBLE(&unk_1EDD18D98);
  v206 = v207;
  uint64_t v200 = 0x100000134;
  long long v199 = xmmword_18E1F6FB0;
  double v198 = COERCE_DOUBLE(&unk_1EDD18C48);
  int v201 = (double *)v202;
  uint64_t v210 = 0x100000003;
  long long v209 = xmmword_18E1F6F60;
  long long v208 = &unk_1EDD18D98;
  unsigned int v211 = &v212;
  sub_18DFE345C((uint64_t)&v138, (uint64_t)&v203, (uint64_t)&v198, (uint64_t)&v208, "2");
  uint64_t v75 = v14[61];
  if (v76 >= *(double *)(v75 + 992))
  {
    if (fabs(v73) < 2.22044605e-16) {
      return 0;
    }
  }
  else
  {
    uint64_t result = 0;
    if (sqrt(v73) < *(double *)(v75 + 1000) || fabs(v73) < 2.22044605e-16) {
      return result;
    }
  }
  double v77 = v73 / (v73 + v74);
  *long long v5 = v77;
  if (v77 < 0.7) {
    return 0;
  }
  sub_18E0519FC(":", (uint64_t)&v89, 0, (uint64_t)&v198);
  uint64_t v78 = DWORD2(v139);
  if (SDWORD2(v139) < 1) {
    goto LABEL_51;
  }
  double v79 = v141;
  double v80 = 0.0;
  double v81 = v201;
  do
  {
    double v82 = *v79++;
    double v83 = v82;
    double v84 = *v81++;
    double v80 = v80 + v83 * v84;
    --v78;
  }
  while (v78);
  if (v80 >= 0.0)
  {
LABEL_51:
    sub_18E0519FC(":", (uint64_t)&v89, 0, (uint64_t)&v198);
    long double v85 = (void **)&v198;
  }
  else
  {
    sub_18E0519FC(":", (uint64_t)&v89, 0, (uint64_t)&v198);
    sub_18E1642D0((uint64_t)&v203, (uint64_t)&v198);
    long double v85 = (void **)&v203;
  }
  sub_18DFE2F24(v86, (uint64_t)v85);
  return 1;
}

double sub_18E163BE4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EDD14BF0;
  *(unsigned char *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  int64x2_t v1 = vdupq_n_s64(0x7FF8000000000000uLL);
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(int64x2_t *)(a1 + 96) = v1;
  *(int64x2_t *)(a1 + 112) = v1;
  *(int64x2_t *)(a1 + 128) = v1;
  *(void *)(a1 + 144) = 0x7FF8000000000000;
  double result = 0.0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0x3FF0000000000000;
  return result;
}

uint64_t raven::RavenDeviceAttitudeActiveObject::GetDAEFromQueueForInputTime(void *a1, void *a2, uint64_t a3)
{
  unint64_t v6 = a1[1041] + a1[1042];
  uint64_t v7 = a1[1038];
  uint64_t v8 = (uint64_t *)(v7 + 8 * (v6 / 0x14));
  uint64_t v9 = *v8;
  unint64_t v10 = *v8 + 200 * (v6 % 0x14);
  if (a1[1039] == v7) {
    unint64_t v10 = 0;
  }
  uint64_t v11 = v10 - v9;
  unint64_t v12 = 0x8F5C28F5C28F5C29 * ((uint64_t)(v10 - v9) >> 3);
  if (v11 < 201)
  {
    unint64_t v16 = 20 - v12;
    int8x16_t v14 = &v8[-(v16 / 0x14)];
    unint64_t v15 = *v14 + 200 * (20 * (v16 / 0x14) - v16) + 3800;
  }
  else
  {
    unint64_t v13 = v12 - 1;
    int8x16_t v14 = &v8[v13 / 0x14];
    unint64_t v15 = *v14 + 200 * (v13 % 0x14);
  }
  uint64_t v98 = (*(uint64_t (**)(unint64_t))(*(void *)v15 + 16))(v15);
  double v99 = v17;
  uint64_t v20 = CNTimeSpan::operator-((uint64_t)&v98, a2, v18, v19);
  unsigned int v22 = llround((v21 + (double)v20) / *(double *)(a1[61] + 648));
  if ((v22 & 0x80000000) != 0 || (signed int)v22 >= *((_DWORD *)a1 + 2084)) {
    return 0;
  }
  uint64_t v93 = a3;
  if (v22)
  {
    unint64_t v23 = 0x8F5C28F5C28F5C29 * ((uint64_t)(v15 - *v14) >> 3) - v22;
    if ((uint64_t)v23 < 1)
    {
      unint64_t v25 = 19 - v23;
      v14 -= v25 / 0x14;
      unint64_t v15 = *v14 + 200 * (20 * (v25 / 0x14) - v25) + 3800;
    }
    else
    {
      v14 += v23 / 0x14;
      unint64_t v15 = *v14 + 200 * (v23 % 0x14);
    }
  }
  char v26 = 0;
  while (1)
  {
    char v27 = v26;
    unint64_t v28 = v15;
    double v29 = v14;
    uint64_t v30 = a1[1038];
    unint64_t v31 = a1[1041];
    double v32 = (uint64_t *)(v30 + 8 * (v31 / 0x14));
    uint64_t v33 = *v32;
    unint64_t v34 = *v32 + 200 * (v31 % 0x14);
    unint64_t v35 = a1[1039] == v30 ? 0 : v34;
    uint64_t v36 = v35 - v33;
    unint64_t v37 = 0x8F5C28F5C28F5C29 * ((uint64_t)(v35 - v33) >> 3);
    if (v36 < -199)
    {
      unint64_t v41 = 18 - v37;
      unint64_t v39 = &v32[-(v41 / 0x14)];
      unint64_t v40 = *v39 + 200 * (20 * (v41 / 0x14) - v41) + 3800;
    }
    else
    {
      unint64_t v38 = v37 + 1;
      unint64_t v39 = &v32[v38 / 0x14];
      unint64_t v40 = *v39 + 200 * (v38 % 0x14);
    }
    if (v39 >= v14 && (v39 != v14 || v40 >= v15)) {
      break;
    }
    if (*v14 == v15)
    {
      --v14;
      unint64_t v15 = *(v29 - 1) + 4000;
    }
    uint64_t v96 = (*(uint64_t (**)(unint64_t))(*(void *)v28 + 16))(v28);
    uint64_t v97 = v42;
    *(double *)v45.i64 = (double)CNTimeSpan::operator-((uint64_t)&v96, a2, v43, v44);
    *(double *)v47.i64 = fabs(v46 + *(double *)v45.i64);
    uint64_t v98 = 0;
    double v99 = 0.0;
    CNTimeSpan::SetTimeSpan(&v98, 0, v47, v45);
    uint64_t v48 = v98;
    double v49 = v99;
    uint64_t v50 = *(void *)(v15 - 200);
    v15 -= 200;
    uint64_t v94 = (*(uint64_t (**)(unint64_t))(v50 + 16))(v15);
    uint64_t v95 = v51;
    *(double *)v54.i64 = (double)CNTimeSpan::operator-((uint64_t)&v94, a2, v52, v53);
    *(double *)v56.i64 = fabs(v55 + *(double *)v54.i64);
    uint64_t v98 = 0;
    double v99 = 0.0;
    CNTimeSpan::SetTimeSpan(&v98, 0, v56, v54);
    if (v48 || (*(void *)&v49 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
    {
      if ((v98 || (*(void *)&v99 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000) && v48 != v98)
      {
        char v26 = 1;
        if (v48 <= v98) {
          break;
        }
      }
      else
      {
        char v26 = 1;
        if (v49 <= v99) {
          break;
        }
      }
    }
    else
    {
      char v26 = 1;
      if (v49 <= v99) {
        break;
      }
    }
  }
  if (v27)
  {
    unint64_t v57 = v28;
  }
  else
  {
    do
    {
      unint64_t v57 = v28;
      unint64_t v58 = a1[1041] + a1[1042];
      uint64_t v59 = a1[1038];
      int v60 = (uint64_t *)(v59 + 8 * (v58 / 0x14));
      uint64_t v61 = *v60;
      unint64_t v62 = *v60 + 200 * (v58 % 0x14);
      if (a1[1039] == v59) {
        unint64_t v62 = 0;
      }
      uint64_t v63 = v62 - v61;
      unint64_t v64 = 0x8F5C28F5C28F5C29 * ((uint64_t)(v62 - v61) >> 3);
      if (v63 < 201)
      {
        unint64_t v68 = 20 - v64;
        int v66 = &v60[-(v68 / 0x14)];
        unint64_t v67 = *v66 + 200 * (20 * (v68 / 0x14) - v68) + 3800;
      }
      else
      {
        unint64_t v65 = v64 - 1;
        int v66 = &v60[v65 / 0x14];
        unint64_t v67 = *v66 + 200 * (v65 % 0x14);
      }
      if (v29 >= v66 && (v29 != v66 || v28 >= v67)) {
        break;
      }
      v28 += 200;
      if (v57 + 200 - *v29 == 4000)
      {
        unint64_t v70 = v29[1];
        ++v29;
        unint64_t v28 = v70;
      }
      uint64_t v96 = (*(uint64_t (**)(unint64_t))(*(void *)v57 + 16))(v57);
      uint64_t v97 = v71;
      *(double *)v74.i64 = (double)CNTimeSpan::operator-((uint64_t)&v96, a2, v72, v73);
      *(double *)v76.i64 = fabs(v75 + *(double *)v74.i64);
      uint64_t v98 = 0;
      double v99 = 0.0;
      CNTimeSpan::SetTimeSpan(&v98, 0, v76, v74);
      uint64_t v77 = v98;
      double v78 = v99;
      uint64_t v94 = (*(uint64_t (**)(unint64_t))(*(void *)v28 + 16))(v28);
      uint64_t v95 = v79;
      *(double *)v82.i64 = (double)CNTimeSpan::operator-((uint64_t)&v94, a2, v80, v81);
      *(double *)v84.i64 = fabs(v83 + *(double *)v82.i64);
      uint64_t v98 = 0;
      double v99 = 0.0;
      CNTimeSpan::SetTimeSpan(&v98, 0, v84, v82);
      if ((v77 || (*(void *)&v78 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
        && (v98 || (*(void *)&v99 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000))
      {
        BOOL v85 = v77 <= v98;
        if (v77 != v98) {
          continue;
        }
      }
      BOOL v85 = v78 <= v99;
    }
    while (!v85);
  }
  long long v86 = *(_OWORD *)(v57 + 8);
  *(_OWORD *)(v93 + 24) = *(_OWORD *)(v57 + 24);
  *(_OWORD *)(v93 + 8) = v86;
  long long v87 = *(_OWORD *)(v57 + 40);
  long long v88 = *(_OWORD *)(v57 + 56);
  long long v89 = *(_OWORD *)(v57 + 72);
  *(_OWORD *)(v93 + 88) = *(_OWORD *)(v57 + 88);
  *(_OWORD *)(v93 + 72) = v89;
  *(_OWORD *)(v93 + 56) = v88;
  *(_OWORD *)(v93 + 40) = v87;
  long long v90 = *(_OWORD *)(v57 + 104);
  long long v91 = *(_OWORD *)(v57 + 120);
  long long v92 = *(_OWORD *)(v57 + 136);
  *(_OWORD *)(v93 + 152) = *(_OWORD *)(v57 + 152);
  *(_OWORD *)(v93 + 136) = v92;
  *(_OWORD *)(v93 + 120) = v91;
  *(_OWORD *)(v93 + 104) = v90;
  if (v57 != v93)
  {
    *(_OWORD *)(v93 + 168) = *(_OWORD *)(v57 + 168);
    *(_OWORD *)(v93 + 184) = *(_OWORD *)(v57 + 184);
  }
  return 1;
}

double sub_18E1642D0(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = 0x100000003;
  *(void *)a1 = &unk_1EDD18D98;
  *(_OWORD *)(a1 + 8) = xmmword_18E1F6F60;
  *(void *)(a1 + 32) = a1 + 40;
  *(void *)&double result = *(_OWORD *)&sub_18DFEF380(a2, a1);
  return result;
}

void sub_18E164338(_Unwind_Exception *a1)
{
  *int64x2_t v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

double sub_18E164358(uint64_t a1)
{
  *(void *)a1 = &unk_1EDD14DC8;
  *(void *)(a1 + 32) = 0x300000003;
  *(void *)(a1 + 8) = &unk_1EDD18EE8;
  *(_OWORD *)(a1 + 16) = xmmword_18E1F0010;
  *(void *)(a1 + 40) = a1 + 48;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(unsigned char *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 240) = 0x100000003;
  *(void *)(a1 + 208) = 0x7FF8000000000000;
  *(void *)(a1 + 216) = &unk_1EDD18D98;
  *(void *)&double result = 0x100000003;
  *(_OWORD *)(a1 + 224) = xmmword_18E1F6F60;
  *(void *)(a1 + 248) = a1 + 256;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0x3FF0000000000000;
  return result;
}

uint64_t sub_18E164420(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v7 = 0x100000001;
  long long v5 = &unk_1EDD18078;
  *(void *)&long long v3 = 0x100000001;
  *((void *)&v3 + 1) = 0x100000001;
  long long v6 = v3;
  uint64_t v8 = &v9;
  int v9 = a3;
  return sub_18DFEED18(a1, a2, (uint64_t)&v5, (uint64_t)&unk_1EB404BF8);
}

void sub_18E164488()
{
  v0 = operator new(0x60uLL);
  v0[1] = 0;
  v0[2] = 0;
  void *v0 = &unk_1EDD1E458;
  v0[3] = &unk_1EDD0A260;
  uint64_t v1 = MEMORY[0x1E4FBA3D8];
  *((unsigned char *)v0 + 32) = 0;
  v0[5] = 0;
  v0[6] = v1;
  v0[7] = 0;
  v0[8] = 0;
  sub_18DEDE7B0(v0 + 9, "");
  *((unsigned char *)v0 + 32) = 1;
  operator new();
}

void sub_18E164690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_18DEE4E18(a11);
  }
  sub_18DEE4E18(v11);
  _Unwind_Resume(a1);
}

uint64_t raven::RavenDeviceAttitudeActiveObject::convertRvVarToQuaternionVar(uint64_t a1, const cnquaternion::CNQuaternion *a2, uint64_t a3, uint64_t a4)
{
  raven::RavenDeviceAttitudeActiveObject::RotationVectorFromQuaternion(a2, (uint64_t)v99);
  uint64_t v96 = 0x100000003;
  long long v95 = xmmword_18E1F6F60;
  uint64_t v94 = &unk_1EDD18D98;
  uint64_t v97 = v98;
  uint64_t v106 = 0x100000134;
  long long v105 = xmmword_18E1F6FB0;
  long long v104 = &unk_1EDD18C48;
  long long v107 = v108;
  uint64_t v60 = 0x100000003;
  long long v59 = xmmword_18E1F6F60;
  unint64_t v58 = &unk_1EDD18D98;
  uint64_t v61 = v62;
  sub_18DFE345C((uint64_t)v99, (uint64_t)&v94, (uint64_t)&v104, (uint64_t)&v58, "2");
  double v8 = v7;
  double v9 = v7 * 0.5;
  if (fabs(v7 * 0.5) == INFINITY)
  {
    double v10 = NAN;
    double v11 = NAN;
  }
  else if (v9 > 0.01 || v9 < -0.01)
  {
    __double2 v12 = __sincos_stret(v7 * 0.5);
    double v10 = v12.__sinval / v9;
    double v11 = (v12.__cosval - v12.__sinval / v9) / v9;
  }
  else
  {
    double v10 = v9 * v9 / -6.0 + 1.0;
    double v11 = v9 / -3.0;
  }
  if (fabs(v8) == INFINITY)
  {
    if (cnprint::CNPrinter::GetLogLevel(v6) <= 1)
    {
      LOWORD(v104) = 12;
      LOBYTE(v94) = 1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v104, (unsigned __int8 *)&v94, "DevAtt,Invalid Quaternion Variance", v13, v14, v15, v16, v17, v52);
    }
    return 0;
  }
  else
  {
    if (v8 >= 0.05) {
      double v19 = v11 * 0.25 / v8;
    }
    else {
      double v19 = -0.0416666667;
    }
    int v20 = v101;
    int v21 = v100;
    uint64_t v91 = 0x300000001;
    long long v86 = &unk_1EDD18228;
    long long v92 = v93;
    int v87 = v101;
    int v88 = v100;
    int v89 = v100 * v101;
    int v90 = v101;
    if (v101)
    {
      int v22 = 0;
      int v23 = 0;
      int v24 = v102;
      uint64_t v25 = v103;
      do
      {
        int v26 = v22;
        int v27 = v23;
        for (int i = v21; i; --i)
        {
          v93[v27] = *(void *)(v25 + 8 * v26);
          v27 += v20;
          ++v26;
        }
        ++v23;
        v22 += v24;
      }
      while (v23 != v20);
    }
    uint64_t v55 = 0x300000003;
    int8x16_t v53 = &unk_1EDD18EE8;
    long long v54 = xmmword_18E1F0010;
    int8x16_t v56 = v57;
    sub_18DFE2B44((uint64_t)v99, (uint64_t)&v86, (uint64_t)&v53);
    uint64_t v60 = 0x300000003;
    *(void *)&v29.f64[1] = 0x300000009;
    long long v59 = xmmword_18E1F0010;
    unint64_t v58 = &unk_1EDD18EE8;
    uint64_t v61 = v62;
    v29.f64[0] = v19;
    sub_18DFE3240((uint64_t)&v53, (uint64_t)&v58, v29);
    uint64_t v78 = 0x300000003;
    int8x16_t v76 = &unk_1EDD18EE8;
    uint64_t v79 = &v80;
    long long v77 = xmmword_18E1F0010;
    sub_18DFE2CC8((uint64_t)&v76, 0.0);
    int v30 = HIDWORD(v77) + 1;
    unint64_t v31 = v79;
    *uint64_t v79 = 0x3FF0000000000000;
    v31[v30] = 0x3FF0000000000000;
    v31[2 * v30] = 0x3FF0000000000000;
    v32.f64[0] = v10 * 0.5;
    uint64_t v83 = 0x300000003;
    long long v82 = xmmword_18E1F0010;
    int8x16_t v81 = &unk_1EDD18EE8;
    int8x16_t v84 = &v85;
    sub_18DFE3240((uint64_t)&v76, (uint64_t)&v81, v32);
    uint64_t v106 = 0x300000003;
    long long v105 = xmmword_18E1F0010;
    long long v104 = &unk_1EDD18EE8;
    long long v107 = v108;
    float64x2_t v33 = sub_18DFEF1F4((uint64_t)&v58, (uint64_t)&v81, (uint64_t)&v104);
    int v34 = v101;
    int v35 = v100;
    uint64_t v68 = 0x300000001;
    uint64_t v63 = &unk_1EDD18228;
    double v69 = v70;
    int v64 = v101;
    int v65 = v100;
    int v66 = v100 * v101;
    int v67 = v101;
    if (v101)
    {
      int v36 = 0;
      int v37 = 0;
      int v38 = v102;
      uint64_t v39 = v103;
      do
      {
        int v40 = v36;
        int v41 = v37;
        for (int j = v35; j; --j)
        {
          v70[v41] = *(void *)(v39 + 8 * v40);
          v41 += v34;
          ++v40;
        }
        ++v37;
        v36 += v38;
      }
      while (v37 != v34);
    }
    v33.f64[0] = v10 * -0.25;
    uint64_t v73 = 0x300000001;
    long long v72 = xmmword_18E1F8560;
    uint64_t v71 = &unk_1EDD18228;
    int8x16_t v74 = &v75;
    sub_18DFE3240((uint64_t)&v63, (uint64_t)&v71, v33);
    uint64_t v96 = 0x300000004;
    long long v95 = xmmword_18E1F6F90;
    uint64_t v94 = &unk_1EDD19578;
    uint64_t v97 = v98;
    sub_18E075DE4((uint64_t)&v104, (uint64_t)&v71, (uint64_t)&v94);
    uint64_t v60 = 0x300000004;
    long long v59 = xmmword_18E1F6F90;
    unint64_t v58 = &unk_1EDD19578;
    uint64_t v61 = v62;
    sub_18DFE2B44((uint64_t)&v94, a3, (uint64_t)&v58);
    int v43 = DWORD1(v95);
    int v44 = v95;
    uint64_t v55 = 0x400000003;
    int8x16_t v53 = &unk_1EDD18F48;
    int8x16_t v56 = v57;
    *(void *)&long long v54 = __PAIR64__(v95, DWORD1(v95));
    DWORD2(v54) = v95 * DWORD1(v95);
    HIDWORD(v54) = DWORD1(v95);
    if (DWORD1(v95))
    {
      int v45 = 0;
      int v46 = 0;
      int v47 = HIDWORD(v95);
      uint64_t v48 = v97;
      do
      {
        int v49 = v45;
        int v50 = v46;
        for (int k = v44; k; --k)
        {
          v57[v50] = *(void *)&v48[8 * v49];
          v50 += v43;
          ++v49;
        }
        ++v46;
        v45 += v47;
      }
      while (v46 != v43);
    }
    uint64_t v106 = 0x400000004;
    long long v105 = xmmword_18E1F6F70;
    long long v104 = &unk_1EDD195A8;
    long long v107 = v108;
    sub_18DFE2B44((uint64_t)&v58, (uint64_t)&v53, (uint64_t)&v104);
    sub_18DFE2F24(a4, (uint64_t)&v104);
    return 1;
  }
}

void raven::RavenDeviceAttitudeActiveObject::RotationVectorFromQuaternion(const cnquaternion::CNQuaternion *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v11 = 0x100000003;
  double v9 = &unk_1EDD18D98;
  __double2 v12 = &v13;
  long long v10 = xmmword_18E1F6F60;
  sub_18DFE2CC8((uint64_t)&v9, 0.0);
  long long v5 = v12;
  *__double2 v12 = *(void *)a1;
  v5[1] = *((void *)a1 + 1);
  v5[2] = *((void *)a1 + 2);
  uint64_t v26 = 0x100000003;
  int v24 = &unk_1EDD18D98;
  long long v25 = xmmword_18E1F6F60;
  int v27 = &v28;
  uint64_t v21 = 0x100000134;
  double v19 = &unk_1EDD18C48;
  long long v20 = xmmword_18E1F6FB0;
  int v22 = &v23;
  uint64_t v16 = 0x100000003;
  uint64_t v14 = &unk_1EDD18D98;
  long long v15 = xmmword_18E1F6F60;
  uint64_t v17 = &v18;
  sub_18DFE345C((uint64_t)&v9, (uint64_t)&v24, (uint64_t)&v19, (uint64_t)&v14, "2");
  double v6 = v7.f64[0];
  v7.f64[0] = 2.0;
  if (v6 > 0.01)
  {
    long double v8 = atan(v6 / *((double *)a1 + 3));
    v7.f64[0] = 1.0 / (sin(v8) / v8 * 0.5);
  }
  *(void *)(a2 + 24) = 0x100000003;
  *(void *)a2 = &unk_1EDD18D98;
  *(_OWORD *)(a2 + 8) = xmmword_18E1F6F60;
  *(void *)(a2 + 32) = a2 + 40;
  sub_18DFE3240((uint64_t)&v9, a2, v7);
}

void sub_18E164FEC(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

uint64_t raven::RavenDeviceAttitudeActiveObject::DeriveGravityVectorInEcefAndBody(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double *a5)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 8400)) {
    return 0;
  }
  uint64_t v10 = a1 + 8080;
  uint64_t v28 = 0x100000003;
  long long v27 = xmmword_18E1F6F60;
  uint64_t v26 = &unk_1EDD18D98;
  float64x2_t v29 = v30;
  uint64_t v23 = 0x100000134;
  uint64_t v21 = &unk_1EDD18C48;
  long long v22 = xmmword_18E1F6FB0;
  int v24 = v25;
  uint64_t v18 = 0x100000003;
  uint64_t v16 = &unk_1EDD18D98;
  long long v17 = xmmword_18E1F6F60;
  double v19 = v20;
  sub_18DFE345C(a1 + 8080, (uint64_t)&v26, (uint64_t)&v21, (uint64_t)&v16, "2");
  if (fabs(v11) <= 0.000000015) {
    return 0;
  }
  uint64_t v12 = *(void *)(a2 + 32);
  *(_OWORD *)&v30[24] = *(_OWORD *)v12;
  uint64_t v31 = *(void *)(v12 + 16);
  uint64_t v26 = 0;
  if (sub_18E069F6C(a1 + 4168)) {
    return 0;
  }
  uint64_t v13 = *(double **)(a3 + 32);
  *uint64_t v13 = -v32;
  v13[1] = -v33;
  v13[2] = -v34;
  uint64_t v28 = 0x100000003;
  long long v27 = xmmword_18E1F6F60;
  uint64_t v26 = &unk_1EDD18D98;
  float64x2_t v29 = v30;
  uint64_t v23 = 0x100000134;
  uint64_t v21 = &unk_1EDD18C48;
  long long v22 = xmmword_18E1F6FB0;
  int v24 = v25;
  uint64_t v18 = 0x100000003;
  uint64_t v16 = &unk_1EDD18D98;
  long long v17 = xmmword_18E1F6F60;
  double v19 = v20;
  sub_18DFE345C(a3, (uint64_t)&v26, (uint64_t)&v21, (uint64_t)&v16, "2");
  if (fabs(v14) <= 0.000000015) {
    return 0;
  }
  sub_18DFE2F24(a4, v10);
  *a5 = sqrt(*(double *)(a1 + 552) * *(double *)(a1 + 552)+ *(double *)(a1 + 544) * *(double *)(a1 + 544)+ *(double *)(a1 + 560) * *(double *)(a1 + 560))/ 9.80665;
  return 1;
}

void raven::RavenDeviceAttitudeActiveObject::DetectStationaryStatus(raven::RavenDeviceAttitudeActiveObject *this)
{
  v178[0] = 0;
  long long v179 = xmmword_18E21BFD0;
  long long v180 = xmmword_18E21BFD0;
  long long v181 = xmmword_18E21BFD0;
  long long v182 = xmmword_18E21BFD0;
  long long v183 = xmmword_18E21BFD0;
  long long v184 = xmmword_18E21BFD0;
  if (!*((void *)this + 1001) || !*((void *)this + 995)) {
    return;
  }
  unint64_t v2 = *(void *)(*((void *)this + 997) + 8 * (*((void *)this + 1000) / 0x1AuLL))
     + 152 * (*((void *)this + 1000) % 0x1AuLL);
  v192[0] = (*(uint64_t (**)(unint64_t))(*(void *)v2 + 16))(v2);
  v192[1] = v3;
  unint64_t v4 = *((void *)this + 1001) + *((void *)this + 1000) - 1;
  unint64_t v5 = *(void *)(*((void *)this + 997) + 8 * (v4 / 0x1A)) + 152 * (v4 % 0x1A);
  uint64_t v6 = (*(uint64_t (**)(unint64_t))(*(void *)v5 + 16))(v5);
  double v8 = v7;
  double v9 = v7;
  unint64_t v10 = *(void *)(*((void *)this + 991) + 8 * (*((void *)this + 994) / 0x1AuLL))
      + 152 * (*((void *)this + 994) % 0x1AuLL);
  v191[0] = (*(uint64_t (**)(unint64_t))(*(void *)v10 + 16))(v10);
  v191[1] = v11;
  unint64_t v12 = *((void *)this + 995) + *((void *)this + 994) - 1;
  unint64_t v13 = *(void *)(*((void *)this + 991) + 8 * (v12 / 0x1A)) + 152 * (v12 % 0x1A);
  uint64_t v14 = (*(uint64_t (**)(unint64_t))(*(void *)v13 + 16))(v13);
  double v16 = v15;
  std::string __p = (void *)1;
  long long v176 = 0;
  uint64_t v19 = CNTimeSpan::operator+((uint64_t)v192, &__p, v17, v18);
  *(double *)v22.i64 = v20;
  if (v6) {
    BOOL v23 = 1;
  }
  else {
    BOOL v23 = (*(void *)&v8 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
  }
  if (!v23 || !v19 && (*(void *)&v20 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || (BOOL v24 = v6 <= v19, v6 == v19)) {
    BOOL v24 = v9 <= v20;
  }
  if (!v24)
  {
    uint64_t v188 = 1;
    uint64_t v189 = 0;
    uint64_t v25 = CNTimeSpan::operator+((uint64_t)v191, &v188, v22, v21);
    if (v14) {
      BOOL v27 = 1;
    }
    else {
      BOOL v27 = (*(void *)&v16 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
    }
    if (!v27
      || !v25 && (*(void *)&v26 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || (BOOL v28 = v14 <= v25, v14 == v25))
    {
      BOOL v28 = v16 <= v26;
    }
    if (!v28)
    {
      std::string __p = 0;
      long long v176 = 0;
      v177[0] = 0;
      sub_18E0E8750(&__p, *((void *)this + 995));
      uint64_t v188 = 0;
      uint64_t v189 = 0;
      uint64_t v190 = 0;
      sub_18E0E8750((void **)&v188, *((void *)this + 995));
      char v185 = 0;
      uint64_t v186 = 0;
      uint64_t v187 = 0;
      sub_18E0E8750((void **)&v185, *((void *)this + 995));
      uint64_t v30 = *((void *)this + 991);
      if (*((void *)this + 992) != v30)
      {
        unint64_t v31 = *((void *)this + 994);
        double v32 = (void *)(*(void *)(v30 + 8 * (v31 / 0x1A)) + 152 * (v31 % 0x1A));
        unint64_t v33 = *(void *)(v30 + 8 * ((*((void *)this + 995) + v31) / 0x1A))
            + 152 * ((*((void *)this + 995) + v31) % 0x1A);
        if (v32 != (void *)v33)
        {
          double v34 = (void *)(v30 + 8 * (v31 / 0x1A));
          do
          {
            uint64_t v35 = v176;
            if ((unint64_t)v176 >= v177[0])
            {
              float64x2_t v29 = (char *)__p;
              uint64_t v37 = (v176 - (unsigned char *)__p) >> 3;
              unint64_t v38 = v37 + 1;
              if ((unint64_t)(v37 + 1) >> 61) {
                goto LABEL_214;
              }
              uint64_t v39 = v177[0] - (void)__p;
              if ((uint64_t)(v177[0] - (void)__p) >> 2 > v38) {
                unint64_t v38 = v39 >> 2;
              }
              if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v40 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v40 = v38;
              }
              if (v40)
              {
                int v41 = (char *)sub_18DEDF808((uint64_t)v177, v40);
                float64x2_t v29 = (char *)__p;
                uint64_t v35 = v176;
              }
              else
              {
                int v41 = 0;
              }
              uint64_t v42 = &v41[8 * v37];
              *(void *)uint64_t v42 = v32[13];
              int v36 = v42 + 8;
              while (v35 != v29)
              {
                uint64_t v43 = *((void *)v35 - 1);
                v35 -= 8;
                *((void *)v42 - 1) = v43;
                v42 -= 8;
              }
              std::string __p = v42;
              long long v176 = v36;
              v177[0] = &v41[8 * v40];
              if (v29) {
                operator delete(v29);
              }
            }
            else
            {
              *(void *)long long v176 = v32[13];
              int v36 = v35 + 8;
            }
            long long v176 = v36;
            int v44 = v189;
            if (v189 >= v190)
            {
              float64x2_t v29 = (char *)v188;
              uint64_t v46 = (uint64_t)&v189[-v188] >> 3;
              unint64_t v47 = v46 + 1;
              if ((unint64_t)(v46 + 1) >> 61) {
                goto LABEL_214;
              }
              uint64_t v48 = (uint64_t)&v190[-v188];
              if ((uint64_t)&v190[-v188] >> 2 > v47) {
                unint64_t v47 = v48 >> 2;
              }
              if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v49 = v47;
              }
              if (v49)
              {
                int v50 = (char *)sub_18DEDF808((uint64_t)&v190, v49);
                float64x2_t v29 = (char *)v188;
                int v44 = v189;
              }
              else
              {
                int v50 = 0;
              }
              uint64_t v51 = &v50[8 * v46];
              *(void *)uint64_t v51 = v32[14];
              int v45 = v51 + 8;
              while (v44 != v29)
              {
                uint64_t v52 = *((void *)v44 - 1);
                v44 -= 8;
                *((void *)v51 - 1) = v52;
                v51 -= 8;
              }
              uint64_t v188 = (uint64_t)v51;
              uint64_t v189 = v45;
              uint64_t v190 = &v50[8 * v49];
              if (v29) {
                operator delete(v29);
              }
            }
            else
            {
              *(void *)uint64_t v189 = v32[14];
              int v45 = v44 + 8;
            }
            uint64_t v189 = v45;
            int8x16_t v53 = v186;
            if (v186 >= v187)
            {
              float64x2_t v29 = v185;
              uint64_t v55 = (v186 - v185) >> 3;
              unint64_t v56 = v55 + 1;
              if ((unint64_t)(v55 + 1) >> 61) {
LABEL_214:
              }
                sub_18DEE1FC8();
              uint64_t v57 = v187 - v185;
              if ((v187 - v185) >> 2 > v56) {
                unint64_t v56 = v57 >> 2;
              }
              if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v58 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v58 = v56;
              }
              if (v58)
              {
                long long v59 = (char *)sub_18DEDF808((uint64_t)&v187, v58);
                float64x2_t v29 = v185;
                int8x16_t v53 = v186;
              }
              else
              {
                long long v59 = 0;
              }
              uint64_t v60 = &v59[8 * v55];
              *(void *)uint64_t v60 = v32[15];
              long long v54 = v60 + 8;
              while (v53 != v29)
              {
                uint64_t v61 = *((void *)v53 - 1);
                v53 -= 8;
                *((void *)v60 - 1) = v61;
                v60 -= 8;
              }
              char v185 = v60;
              uint64_t v186 = v54;
              uint64_t v187 = &v59[8 * v58];
              if (v29) {
                operator delete(v29);
              }
            }
            else
            {
              *(void *)uint64_t v186 = v32[15];
              long long v54 = v53 + 8;
            }
            uint64_t v186 = v54;
            v32 += 19;
            if ((void *)((char *)v32 - *v34) == (void *)3952)
            {
              unint64_t v62 = (void *)v34[1];
              ++v34;
              double v32 = v62;
            }
          }
          while (v32 != (void *)v33);
        }
      }
      double v63 = raven::RavenDeviceAttitudeActiveObject::ComputeMeanStdVector((uint64_t)v29, (double **)&__p);
      uint64_t v65 = v64;
      *(double *)&long long v179 = v63;
      *((void *)&v179 + 1) = v64;
      double v67 = raven::RavenDeviceAttitudeActiveObject::ComputeMeanStdVector(v66, (double **)&v188);
      uint64_t v69 = v68;
      *(double *)&long long v180 = v67;
      *((void *)&v180 + 1) = v68;
      double v71 = raven::RavenDeviceAttitudeActiveObject::ComputeMeanStdVector(v70, (double **)&v185);
      BOOL v74 = (*(void *)&v63 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
         && (v65 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
      if ((*(void *)&v67 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
        || (v69 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
      {
        BOOL v74 = 0;
      }
      *(double *)&long long v181 = v71;
      *((void *)&v181 + 1) = v72;
      if ((*(void *)&v71 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
        || (v72 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
      {
        BOOL v74 = 0;
      }
      BOOL v174 = v74;
      v178[0] = v74;
      long long v176 = (char *)__p;
      sub_18E0E8750(&__p, *((void *)this + 1001));
      uint64_t v189 = (char *)v188;
      sub_18E0E8750((void **)&v188, *((void *)this + 1001));
      uint64_t v186 = v185;
      sub_18E0E8750((void **)&v185, *((void *)this + 1001));
      uint64_t v78 = *((void *)this + 997);
      if (*((void *)this + 998) != v78)
      {
        unint64_t v79 = *((void *)this + 1000);
        uint64_t v80 = (void *)(*(void *)(v78 + 8 * (v79 / 0x1A)) + 152 * (v79 % 0x1A));
        unint64_t v81 = *(void *)(v78 + 8 * ((*((void *)this + 1001) + v79) / 0x1A))
            + 152 * ((*((void *)this + 1001) + v79) % 0x1A);
        if (v80 != (void *)v81)
        {
          long long v82 = (void *)(v78 + 8 * (v79 / 0x1A));
          do
          {
            uint64_t v83 = v176;
            if ((unint64_t)v176 >= v177[0])
            {
              long long v77 = (char *)__p;
              uint64_t v85 = (v176 - (unsigned char *)__p) >> 3;
              unint64_t v86 = v85 + 1;
              if ((unint64_t)(v85 + 1) >> 61) {
                goto LABEL_215;
              }
              uint64_t v87 = v177[0] - (void)__p;
              if ((uint64_t)(v177[0] - (void)__p) >> 2 > v86) {
                unint64_t v86 = v87 >> 2;
              }
              if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v88 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v88 = v86;
              }
              if (v88)
              {
                int v89 = (char *)sub_18DEDF808((uint64_t)v177, v88);
                long long v77 = (char *)__p;
                uint64_t v83 = v176;
              }
              else
              {
                int v89 = 0;
              }
              int v90 = &v89[8 * v85];
              *(void *)int v90 = v80[13];
              int8x16_t v84 = v90 + 8;
              while (v83 != v77)
              {
                uint64_t v91 = *((void *)v83 - 1);
                v83 -= 8;
                *((void *)v90 - 1) = v91;
                v90 -= 8;
              }
              std::string __p = v90;
              long long v176 = v84;
              v177[0] = &v89[8 * v88];
              if (v77) {
                operator delete(v77);
              }
            }
            else
            {
              *(void *)long long v176 = v80[13];
              int8x16_t v84 = v83 + 8;
            }
            long long v176 = v84;
            long long v92 = v189;
            if (v189 >= v190)
            {
              long long v77 = (char *)v188;
              uint64_t v94 = (uint64_t)&v189[-v188] >> 3;
              unint64_t v95 = v94 + 1;
              if ((unint64_t)(v94 + 1) >> 61) {
                goto LABEL_215;
              }
              uint64_t v96 = (uint64_t)&v190[-v188];
              if ((uint64_t)&v190[-v188] >> 2 > v95) {
                unint64_t v95 = v96 >> 2;
              }
              if ((unint64_t)v96 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v97 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v97 = v95;
              }
              if (v97)
              {
                uint64_t v98 = (char *)sub_18DEDF808((uint64_t)&v190, v97);
                long long v77 = (char *)v188;
                long long v92 = v189;
              }
              else
              {
                uint64_t v98 = 0;
              }
              double v99 = &v98[8 * v94];
              *(void *)double v99 = v80[14];
              uint64_t v93 = v99 + 8;
              while (v92 != v77)
              {
                uint64_t v100 = *((void *)v92 - 1);
                v92 -= 8;
                *((void *)v99 - 1) = v100;
                v99 -= 8;
              }
              uint64_t v188 = (uint64_t)v99;
              uint64_t v189 = v93;
              uint64_t v190 = &v98[8 * v97];
              if (v77) {
                operator delete(v77);
              }
            }
            else
            {
              *(void *)uint64_t v189 = v80[14];
              uint64_t v93 = v92 + 8;
            }
            uint64_t v189 = v93;
            int v101 = v186;
            if (v186 >= v187)
            {
              long long v77 = v185;
              uint64_t v103 = (v186 - v185) >> 3;
              unint64_t v104 = v103 + 1;
              if ((unint64_t)(v103 + 1) >> 61) {
LABEL_215:
              }
                sub_18DEE1FC8();
              uint64_t v105 = v187 - v185;
              if ((v187 - v185) >> 2 > v104) {
                unint64_t v104 = v105 >> 2;
              }
              if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v106 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v106 = v104;
              }
              if (v106)
              {
                long long v107 = (char *)sub_18DEDF808((uint64_t)&v187, v106);
                long long v77 = v185;
                int v101 = v186;
              }
              else
              {
                long long v107 = 0;
              }
              uint64_t v108 = &v107[8 * v103];
              *(void *)uint64_t v108 = v80[15];
              int v102 = v108 + 8;
              while (v101 != v77)
              {
                uint64_t v109 = *((void *)v101 - 1);
                v101 -= 8;
                *((void *)v108 - 1) = v109;
                v108 -= 8;
              }
              char v185 = v108;
              uint64_t v186 = v102;
              uint64_t v187 = &v107[8 * v106];
              if (v77) {
                operator delete(v77);
              }
            }
            else
            {
              *(void *)uint64_t v186 = v80[15];
              int v102 = v101 + 8;
            }
            uint64_t v186 = v102;
            v80 += 19;
            if ((void *)((char *)v80 - *v82) == (void *)3952)
            {
              uint64_t v110 = (void *)v82[1];
              ++v82;
              uint64_t v80 = v110;
            }
          }
          while (v80 != (void *)v81);
        }
      }
      double v111 = raven::RavenDeviceAttitudeActiveObject::ComputeMeanStdVector((uint64_t)v77, (double **)&__p);
      uint64_t v113 = v112;
      *(double *)&long long v182 = v111;
      *((void *)&v182 + 1) = v112;
      double v115 = raven::RavenDeviceAttitudeActiveObject::ComputeMeanStdVector(v114, (double **)&v188);
      uint64_t v117 = v116;
      *(double *)&long long v183 = v115;
      *((void *)&v183 + 1) = v116;
      double v119 = raven::RavenDeviceAttitudeActiveObject::ComputeMeanStdVector(v118, (double **)&v185);
      BOOL v122 = (*(void *)&v111 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
          && (v113 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
      BOOL v124 = (*(void *)&v115 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
          && (v117 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
          && v122;
      *(double *)&long long v184 = v119;
      *((void *)&v184 + 1) = v120;
      if ((*(void *)&v119 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
        || (v120 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
      {
        BOOL v124 = 0;
      }
      v178[0] = v124 && v174;
      uint64_t v126 = (void **)*((void *)this + 997);
      long long v127 = (void **)*((void *)this + 998);
      if (v127 == v126)
      {
        long long v127 = (void **)*((void *)this + 997);
      }
      else
      {
        unint64_t v128 = *((void *)this + 1000);
        double v129 = &v126[v128 / 0x1A];
        unint64_t v130 = (unint64_t)v126[(*((void *)this + 1001) + v128) / 0x1A]
             + 152 * ((*((void *)this + 1001) + v128) % 0x1A);
        if ((char *)*v129 + 152 * (v128 % 0x1A) != (void *)v130)
        {
          double v131 = (void (***)(void))((char *)*v129 + 152 * (v128 % 0x1A));
          do
          {
            double v132 = *v131;
            v131 += 19;
            (*v132)();
            if ((char *)v131 - (unsigned char *)*v129 == 3952)
            {
              uint64_t v133 = (void (***)(void))v129[1];
              ++v129;
              double v131 = v133;
            }
          }
          while (v131 != (void (***)(void))v130);
          long long v127 = (void **)*((void *)this + 998);
          uint64_t v126 = (void **)*((void *)this + 997);
        }
      }
      *((void *)this + 1001) = 0;
      unint64_t v134 = (char *)v127 - (char *)v126;
      if (v134 >= 0x11)
      {
        do
        {
          operator delete(*v126);
          uint64_t v126 = (void **)(*((void *)this + 997) + 8);
          *((void *)this + 997) = v126;
          unint64_t v134 = *((void *)this + 998) - (void)v126;
        }
        while (v134 > 0x10);
      }
      if (v134 >> 3 == 1)
      {
        uint64_t v135 = 13;
      }
      else
      {
        if (v134 >> 3 != 2) {
          goto LABEL_179;
        }
        uint64_t v135 = 26;
      }
      *((void *)this + 1000) = v135;
LABEL_179:
      double v136 = (void **)*((void *)this + 991);
      double v137 = (void **)*((void *)this + 992);
      if (v137 == v136)
      {
        double v137 = (void **)*((void *)this + 991);
      }
      else
      {
        unint64_t v138 = *((void *)this + 994);
        long long v139 = &v136[v138 / 0x1A];
        unint64_t v140 = (unint64_t)v136[(*((void *)this + 995) + v138) / 0x1A]
             + 152 * ((*((void *)this + 995) + v138) % 0x1A);
        if ((char *)*v139 + 152 * (v138 % 0x1A) != (void *)v140)
        {
          uint64_t v141 = (void (***)(void))((char *)*v139 + 152 * (v138 % 0x1A));
          do
          {
            uint64_t v142 = *v141;
            v141 += 19;
            (*v142)();
            if ((char *)v141 - (unsigned char *)*v139 == 3952)
            {
              uint64_t v143 = (void (***)(void))v139[1];
              ++v139;
              uint64_t v141 = v143;
            }
          }
          while (v141 != (void (***)(void))v140);
          double v137 = (void **)*((void *)this + 992);
          double v136 = (void **)*((void *)this + 991);
        }
      }
      *((void *)this + 995) = 0;
      unint64_t v144 = (char *)v137 - (char *)v136;
      if (v144 >= 0x11)
      {
        do
        {
          operator delete(*v136);
          double v136 = (void **)(*((void *)this + 991) + 8);
          *((void *)this + 991) = v136;
          unint64_t v144 = *((void *)this + 992) - (void)v136;
        }
        while (v144 > 0x10);
      }
      if (v144 >> 3 == 1)
      {
        uint64_t v145 = 13;
      }
      else
      {
        if (v144 >> 3 != 2)
        {
LABEL_194:
          if (v185)
          {
            uint64_t v186 = v185;
            operator delete(v185);
          }
          if (v188)
          {
            uint64_t v189 = (char *)v188;
            operator delete((void *)v188);
          }
          if (__p)
          {
            long long v176 = (char *)__p;
            operator delete(__p);
          }
          goto LABEL_200;
        }
        uint64_t v145 = 26;
      }
      *((void *)this + 994) = v145;
      goto LABEL_194;
    }
  }
LABEL_200:
  if (v178[0])
  {
    uint64_t v146 = *((void *)this + 983);
    if (v146)
    {
      if (*((double *)&v179 + 1) < *((double *)this + 68)
        && *((double *)&v180 + 1) < *((double *)this + 69)
        && *((double *)&v181 + 1) < *((double *)this + 70)
        && *((double *)&v182 + 1) < *((double *)this + 869)
        && *((double *)&v183 + 1) < *((double *)this + 870)
        && *((double *)&v184 + 1) < *((double *)this + 871))
      {
        int v147 = (void *)*((void *)this + 1014);
        uint64_t v148 = v180;
        *int v147 = v179;
        v147[1] = v148;
        uint64_t v149 = v182;
        v147[2] = v181;
        double v150 = (void *)*((void *)this + 1006);
        uint64_t v151 = v183;
        uint64_t v152 = v184;
        *double v150 = v149;
        v150[1] = v151;
        v150[2] = v152;
        long long v153 = (void *)(*(void *)(*((void *)this + 979)
                                    + (((unint64_t)(v146 + *((void *)this + 982) - 1) >> 1) & 0x7FFFFFFFFFFFFFF8))
                        + 2432 * ((v146 + *((_DWORD *)this + 1964) - 1) & 0xF));
        uint64_t v154 = (void *)*((void *)this + 1022);
        *uint64_t v154 = v153[184];
        v154[1] = v153[185];
        v154[2] = v153[186];
        *((unsigned char *)this + 8400) = 1;
        raven::RavenDeviceAttitudeActiveObject::UpdateSensorStaticNoise((uint64_t)this, (uint64_t)v178);
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404BB0, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB404BB0))
        {
          qword_1EB404C48 = 0x100000003;
          qword_1EB404C30 = (uint64_t)&unk_1EDD18D98;
          unk_1EB404C38 = xmmword_18E1F6F60;
          qword_1EB404C50 = (uint64_t)&unk_1EB404C58;
          __cxa_atexit((void (*)(void *))sub_18DFE0A40, &qword_1EB404C30, &dword_18DEDB000);
          __cxa_guard_release(&qword_1EB404BB0);
        }
        sub_18E01E318((uint64_t)this + 8144, (uint64_t)&qword_1EB404C30, (uint64_t)&__p);
        sub_18E03017C((uint64_t)&__p);
        if (v156 > 30.0)
        {
          if (!cnprint::CNPrinter::GetLogLevel(v155))
          {
            LOWORD(__p) = 12;
            LOBYTE(v188) = 0;
            unint64_t v157 = *((void *)this + 983) + *((void *)this + 982) - 1;
            uint64_t v158 = *(void *)(*((void *)this + 979) + ((v157 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 2432 * (v157 & 0xF);
            uint64_t v159 = (*(uint64_t (**)(uint64_t))(*(void *)v158 + 16))(v158);
            double v161 = v160 + (double)v159;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&__p, (unsigned __int8 *)&v188, "DevAtt,NewBodyStaionaryGravity,t,%lf,posx,%.3lf,posy,%.3lf,posz,%.3lf,ax,%.3lf,ay,%.3lf,az,%.3lf,gx,%.3lf,gy,%.3lf,gz,%.3lf", v162, v163, v164, v165, v166, SLOBYTE(v161));
          }
          sub_18DFE2F24((uint64_t)&qword_1EB404C30, (uint64_t)this + 8144);
          sub_18DFEB188(3, 1, (uint64_t)&__p);
          *(void *)(v177[2] + 16) = 0x3FF0000000000000;
          double v167 = *(double *)(*((void *)this + 61) + 1160);
          double v168 = *((double *)this + 68);
          double v169 = *((double *)this + 69);
          double v170 = *((double *)this + 70);
          unint64_t v171 = *((void *)this + 983) + *((void *)this + 982) - 1;
          uint64_t v172 = *(void *)(*((void *)this + 979) + ((v171 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 2432 * (v171 & 0xF);
          uint64_t v188 = (*(uint64_t (**)(uint64_t))(*(void *)v172 + 16))(v172);
          uint64_t v189 = v173;
          raven::RavenDeviceAttitudeActiveObject::UpdateDeviceVehicleAttitude((uint64_t)this, (uint64_t)this + 8080, (uint64_t)&__p, (uint64_t)&v188, sqrt((v169 * v169 + v168 * v168 + v170 * v170) / 9.80665 / 9.80665+ v167 * 0.0174532925 * (v167 * 0.0174532925)));
        }
      }
    }
  }
}

void sub_18E166238(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22)
{
  BOOL v24 = *(void **)(v22 - 200);
  if (v24)
  {
    *(void *)(v22 - 192) = v24;
    operator delete(v24);
  }
  uint64_t v25 = *(void **)(v22 - 176);
  if (v25)
  {
    *(void *)(v22 - 168) = v25;
    operator delete(v25);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double raven::RavenDeviceAttitudeActiveObject::UpdateSensorStaticNoise(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    float64x2_t v2 = *(float64x2_t *)(a2 + 16);
    float64x2_t v3 = *(float64x2_t *)(a1 + 544);
    v2.f64[1] = *(float64_t *)(a2 + 32);
    __asm { FMOV            V3.2D, #3.0 }
    float64x2_t v9 = vmlaq_f64(vnegq_f64(v3), _Q3, v2);
    float64x2_t v10 = (float64x2_t)vdupq_n_s64(0x3FE3333333333333uLL);
    *(float64x2_t *)(a1 + 544) = vmlaq_f64(v3, v10, v9);
    *(double *)(a1 + 560) = *(double *)(a1 + 560) + -(*(double *)(a1 + 560) - *(double *)(a2 + 48) * 3.0) * 0.6;
    float64x2_t v11 = *(float64x2_t *)(a2 + 64);
    v11.f64[1] = *(float64_t *)(a2 + 80);
    *(float64x2_t *)(a1 + 6952) = vmlaq_f64(*(float64x2_t *)(a1 + 6952), v10, vmlaq_f64(vnegq_f64(*(float64x2_t *)(a1 + 6952)), _Q3, v11));
    double result = *(double *)(a1 + 6968) + -(*(double *)(a1 + 6968) - *(double *)(a2 + 96) * 3.0) * 0.6;
    *(double *)(a1 + 6968) = result;
  }
  return result;
}

BOOL raven::RavenDeviceAttitudeActiveObject::UpdateDeviceVehicleAttitude(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404BD8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB404BD8))
  {
    qword_1EB404BD0 = 0x3FE6A09E667F3BCDLL;
    __cxa_guard_release(&qword_1EB404BD8);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404BE0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB404BE0))
  {
    sub_18E05B1C8(3, 1, (uint64_t)&unk_1EB404C70);
    __cxa_atexit((void (*)(void *))sub_18DFE0A40, &unk_1EB404C70, &dword_18DEDB000);
    __cxa_guard_release(&qword_1EB404BE0);
  }
  uint64_t v121 = 0x100000003;
  long long v120 = xmmword_18E1F6F60;
  double v119 = &unk_1EDD18D98;
  BOOL v122 = v123;
  uint64_t v139 = 0x100000134;
  long long v138 = xmmword_18E1F6FB0;
  double v137 = &unk_1EDD18C48;
  unint64_t v140 = v141;
  uint64_t v116 = 0x100000003;
  long long v115 = xmmword_18E1F6F60;
  double v114 = COERCE_DOUBLE(&unk_1EDD18D98);
  uint64_t v117 = v118;
  sub_18DFE345C(a2, (uint64_t)&v119, (uint64_t)&v137, (uint64_t)&v114, "2");
  if (fabs(v8) <= 0.000000015) {
    return 0;
  }
  sub_18DFF2980((uint64_t)v134, a3);
  uint64_t v121 = 0x100000003;
  long long v120 = xmmword_18E1F6F60;
  double v119 = &unk_1EDD18D98;
  BOOL v122 = v123;
  uint64_t v139 = 0x100000134;
  long long v138 = xmmword_18E1F6FB0;
  double v137 = &unk_1EDD18C48;
  unint64_t v140 = v141;
  uint64_t v116 = 0x100000003;
  long long v115 = xmmword_18E1F6F60;
  double v114 = COERCE_DOUBLE(&unk_1EDD18D98);
  uint64_t v117 = v118;
  sub_18DFE345C((uint64_t)v134, (uint64_t)&v119, (uint64_t)&v137, (uint64_t)&v114, "2");
  if (fabs(v9.f64[0]) <= 0.000000015) {
    return 0;
  }
  uint64_t v139 = 0x100000003;
  long long v138 = xmmword_18E1F6F60;
  double v137 = &unk_1EDD18D98;
  unint64_t v140 = v141;
  v9.f64[0] = 1.0 / v9.f64[0];
  sub_18DFE3240((uint64_t)v134, (uint64_t)&v137, v9);
  float64x2_t v10 = (unsigned char *)(a1 + 6977);
  sub_18DFE2F24((uint64_t)v134, (uint64_t)&v137);
  uint64_t v131 = 0x100000003;
  double v129 = &unk_1EDD18D98;
  double v132 = (double *)&v133;
  long long v130 = xmmword_18E1F6F60;
  double v11 = 0.0;
  sub_18DFE2CC8((uint64_t)&v129, 0.0);
  uint64_t v14 = v132;
  v132[2] = 1.0;
  uint64_t v15 = v135;
  if (v135 >= 1)
  {
    double v16 = v136;
    do
    {
      uint64_t v17 = *v16++;
      v12.i64[0] = v17;
      double v18 = *v14++;
      *(double *)v13.i64 = v18;
      double v11 = v11 + *(double *)v12.i64 * v18;
      --v15;
    }
    while (v15);
  }
  if (!*v10)
  {
    *(double *)v12.i64 = fabs(v11);
    v13.i64[0] = qword_1EB404BD0;
    if (*(double *)v12.i64 < *(double *)&qword_1EB404BD0)
    {
      uint64_t v111 = 0x100000003;
      uint64_t v109 = &unk_1EDD18D98;
      uint64_t v112 = v113;
      long long v110 = xmmword_18E1F6F60;
      sub_18DFE2CC8((uint64_t)&v109, 0.0);
      if (*(unsigned char *)(a1 + 8400))
      {
        sub_18DFE2F24((uint64_t)&v109, a1 + 8080);
        uint64_t v121 = 0x100000003;
        long long v120 = xmmword_18E1F6F60;
        double v119 = &unk_1EDD18D98;
        BOOL v122 = v123;
        uint64_t v139 = 0x100000134;
        long long v138 = xmmword_18E1F6FB0;
        double v137 = &unk_1EDD18C48;
        unint64_t v140 = v141;
        uint64_t v116 = 0x100000003;
        long long v115 = xmmword_18E1F6F60;
        double v114 = COERCE_DOUBLE(&unk_1EDD18D98);
        uint64_t v117 = v118;
        sub_18DFE345C((uint64_t)&v109, (uint64_t)&v119, (uint64_t)&v137, (uint64_t)&v114, "2");
        if (fabs(v19.f64[0]) > 0.000000015)
        {
          uint64_t v139 = 0x100000003;
          long long v138 = xmmword_18E1F6F60;
          double v137 = &unk_1EDD18D98;
          unint64_t v140 = v141;
          v19.f64[0] = 1.0 / v19.f64[0];
          sub_18DFE3240((uint64_t)&v109, (uint64_t)&v137, v19);
          sub_18DFE2F24((uint64_t)&v109, (uint64_t)&v137);
          if (raven::RavenDeviceAttitudeActiveObject::AttitudeViaTwoVectors(v20))
          {
            sub_18DFEB238(3, 3, (uint64_t)&v137);
            sub_18DFE2F24(a1 + 1048, (uint64_t)&v137);
            sub_18DFEB238(3, 3, (uint64_t)&v137);
            sub_18DFE2F24(a1 + 792, (uint64_t)&v137);
            raven::RavenDeviceAttitudeActiveObject::UDFactor3x3(v21, a1 + 904, a1 + 1048, a1 + 792);
            *(_OWORD *)(a1 + 1160) = *(_OWORD *)a4;
            unsigned char *v10 = 1;
            *(_DWORD *)(a1 + 7576) = 0;
            cnrotation::CNRotation::RotationMatrix((cnrotation::CNRotation *)(a1 + 1016), (uint64_t)&v137);
            if (cnprint::CNPrinter::GetLogLevel(v22) <= 1)
            {
              LOWORD(v119) = 12;
              LOBYTE(v114) = 1;
              double v28 = *(double *)(a4 + 8) + (double)*(uint64_t *)a4;
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v119, (unsigned __int8 *)&v114, "DevAtt,Device-Vehicle Attitude Initialization,t,%lf,type,%hu,Rb2v,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,Pb2v,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,aVx,%.3lf,aVy,%.3lf,aVz,%.3lf,aBx,%.3lf,aBy,%.3lf,aBz,%.3lf,aUnc,%.3lf,rVx,%.3lf,rVy,%.3lf,rVz,%.3lf,rBx,%.3lf,rBy,%.3lf,rBz,%.3lf,rUnc,%.3lf", v23, v24, v25, v26, v27, SLOBYTE(v28));
            }
            return 1;
          }
        }
      }
      return 0;
    }
  }
  if (!*v10) {
    return 0;
  }
  uint64_t v30 = CNTimeSpan::operator-(a4, (void *)(a1 + 1160), v12, v13);
  v32.f64[0] = (v31 + (double)v30)
             * (*(double *)(*(void *)(a1 + 488) + 1168)
              * *(double *)(*(void *)(a1 + 488) + 1168)
              * 0.0174532925
              * 0.0174532925);
  uint64_t v126 = 0x100000003;
  long long v125 = xmmword_18E1F6F60;
  BOOL v124 = &unk_1EDD18D98;
  long long v127 = &v128;
  sub_18DFE3240((uint64_t)&unk_1EB404C70, (uint64_t)&v124, v32);
  uint64_t v121 = 0x300000003;
  double v119 = &unk_1EDD18EE8;
  BOOL v122 = v123;
  long long v120 = xmmword_18E1F0010;
  sub_18DFE2CC8((uint64_t)&v119, 0.0);
  int v33 = HIDWORD(v120) + 1;
  double v34 = v122;
  *BOOL v122 = 0x3FF0000000000000;
  v34[v33] = 0x3FF0000000000000;
  v34[2 * v33] = 0x3FF0000000000000;
  BOOL v35 = raven::RavenDeviceAttitudeActiveObject::ThorntonTemporalUpdate(a1, (uint64_t)&v119, (uint64_t)&v124);
  if (!v35)
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v35) <= 1)
    {
      LOWORD(v137) = 12;
      LOBYTE(v114) = 1;
      double v77 = *(double *)(a4 + 8) + (double)*(uint64_t *)a4;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v137, (unsigned __int8 *)&v114, "DevAtt, reset Device-Vehicle filter for invalid propagation,time,%lf,type,%hu", v72, v73, v74, v75, v76, SLOBYTE(v77));
    }
    BOOL v29 = 0;
    goto LABEL_39;
  }
  uint64_t v116 = 0x300000003;
  long long v115 = xmmword_18E1F0010;
  double v114 = COERCE_DOUBLE(&unk_1EDD18EE8);
  uint64_t v117 = v118;
  sub_18DFE2B44(a1 + 1048, a1 + 792, (uint64_t)&v114);
  unsigned int v36 = *(_DWORD *)(a1 + 1060);
  unsigned int v37 = *(_DWORD *)(a1 + 1056);
  uint64_t v111 = 0x300000003;
  uint64_t v109 = &unk_1EDD18EE8;
  *(void *)&long long v110 = __PAIR64__(v37, v36);
  DWORD2(v110) = v37 * v36;
  HIDWORD(v110) = v36;
  uint64_t v112 = v113;
  sub_18DFE2C64(a1 + 1048, (uint64_t)&v109);
  uint64_t v139 = 0x300000003;
  long long v138 = xmmword_18E1F0010;
  double v137 = &unk_1EDD18EE8;
  unint64_t v140 = v141;
  sub_18DFE2B44((uint64_t)&v114, (uint64_t)&v109, (uint64_t)&v137);
  sub_18DFE2F24(a1 + 904, (uint64_t)&v137);
  *(_OWORD *)(a1 + 1160) = *(_OWORD *)a4;
  cnrotation::Inv((float64x2_t *)(a1 + 1016), v108);
  sub_18DFEDF6C((cnrotation::CNRotation *)v108, a3, (uint64_t)&v137);
  sub_18DFEF290((uint64_t)v106, (uint64_t)&v137);
  uint64_t v116 = 0x100000003;
  long long v115 = xmmword_18E1F6F60;
  double v114 = COERCE_DOUBLE(&unk_1EDD18D98);
  uint64_t v117 = v118;
  uint64_t v139 = 0x100000134;
  long long v138 = xmmword_18E1F6FB0;
  double v137 = &unk_1EDD18C48;
  unint64_t v140 = v141;
  uint64_t v111 = 0x100000003;
  long long v110 = xmmword_18E1F6F60;
  uint64_t v109 = &unk_1EDD18D98;
  uint64_t v112 = v113;
  sub_18DFE345C(a2, (uint64_t)&v114, (uint64_t)&v137, (uint64_t)&v109, "2");
  uint64_t v103 = 0x100000003;
  long long v102 = xmmword_18E1F6F60;
  int v101 = &unk_1EDD18D98;
  unint64_t v104 = (double *)&v105;
  v39.f64[0] = 1.0 / v38;
  sub_18DFE3240(a2, (uint64_t)&v101, v39);
  uint64_t v98 = 0x100000003;
  long long v97 = xmmword_18E1F6F60;
  uint64_t v96 = &unk_1EDD18D98;
  double v99 = &v100;
  sub_18DFE2AA8((uint64_t)&v101, (uint64_t)v106, (uint64_t)&v96);
  uint64_t v40 = DWORD2(v102);
  double v41 = 0.0;
  double v42 = 0.0;
  if (SDWORD2(v102) >= 1)
  {
    uint64_t v43 = v104;
    int v44 = v107;
    do
    {
      double v45 = *v43++;
      double v46 = v45;
      double v47 = *v44++;
      double v42 = v42 + v46 * v47;
      --v40;
    }
    while (v40);
  }
  double v49 = fabs(acos(v42));
  uint64_t v50 = *(unsigned int *)(a1 + 912);
  if ((int)v50 >= 1)
  {
    int v51 = 0;
    double v41 = 0.0;
    do
    {
      double v41 = v41 + *(double *)(*(void *)(a1 + 936) + 8 * v51);
      v51 += *(_DWORD *)(a1 + 924) + 1;
      --v50;
    }
    while (v50);
  }
  double v52 = sqrt(v41) * *(double *)(*(void *)(a1 + 488) + 1184);
  if (v52 > 0.523598776) {
    double v52 = 0.523598776;
  }
  BOOL v29 = v49 <= v52;
  if (v49 <= v52)
  {
    *(_DWORD *)(a1 + 7576) = 0;
    sub_18E161A28((uint64_t)&v137, *v107, v107[1], v107[2]);
    v53.f64[0] = a5 * a5;
    sub_18E053C38((uint64_t)&unk_1EB404C70, (uint64_t)v95, v53);
    raven::RavenDeviceAttitudeActiveObject::biermanObservationalUpdate3X3(a1, (uint64_t)&v137, (uint64_t)v95, (uint64_t)&v96, (uint64_t)v94);
    raven::RavenDeviceAttitudeActiveObject::QuaternionFromRotationVector((uint64_t)v94, (float64x2_t *)&v109);
    v93[0] = v108[0];
    v93[1] = v108[1];
    cnquaternion::CNQuaternion::operator*((double *)&v109, (double *)v93, &v114);
    double v54 = sqrt(*(double *)&v115 * *(double *)&v115+ v114 * v114+ *((double *)&v115 + 1) * *((double *)&v115 + 1)+ *(double *)&v116 * *(double *)&v116);
    double v55 = 1.0;
    double v56 = 0.0;
    double v57 = 0.0;
    double v58 = 0.0;
    double v59 = 0.0;
    double v60 = 1.0;
    if (fabs(v54) >= 2.22044605e-16)
    {
      double v57 = v114 / v54;
      double v58 = *(double *)&v115 / v54;
      double v59 = *((double *)&v115 + 1) / v54;
      double v60 = *(double *)&v116 / v54;
    }
    double v61 = sqrt(v58 * v58 + v57 * v57 + v59 * v59 + v60 * v60);
    double v62 = 0.0;
    double v63 = 0.0;
    if (fabs(v61) >= 2.22044605e-16)
    {
      double v56 = -v57 / v61;
      double v62 = -v58 / v61;
      double v63 = -v59 / v61;
      double v55 = v60 / v61;
    }
    *(double *)(a1 + 1016) = v56;
    *(double *)(a1 + 1024) = v62;
    *(double *)(a1 + 1032) = v63;
    *(double *)(a1 + 1040) = v55;
    sub_18DFF6360(a1 + 1048, a1 + 792, (uint64_t)&v109);
    sub_18DFF63E0(a1 + 1048, (uint64_t)v93);
    sub_18DFF6360((uint64_t)&v109, (uint64_t)v93, (uint64_t)&v114);
    sub_18DFE2F24(a1 + 904, (uint64_t)&v114);
    cnrotation::CNRotation::RotationMatrix((cnrotation::CNRotation *)(a1 + 1016), (uint64_t)&v114);
    if (cnprint::CNPrinter::GetLogLevel(v64) <= 1)
    {
      LOWORD(v109) = 12;
      LOBYTE(v93[0]) = 1;
      double v70 = *(double *)(a4 + 8) + (double)*(uint64_t *)a4;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v109, (unsigned __int8 *)v93, "DevAtt,Device-Vehicle Attitude Updated,t,%lf,type,%hu,Rb2v,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,Pb2v,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,aVx,%.3lf,aVy,%.3lf,aVz,%.3lf,aBx,%.3lf,aBy,%.3lf,aBz,%.3lf,aUnc,%.3lf", v65, v66, v67, v68, v69, SLOBYTE(v70));
    }
  }
  else
  {
    ++*(_DWORD *)(a1 + 7576);
    unsigned int LogLevel = (cnprint::CNPrinter *)cnprint::CNPrinter::GetLogLevel(v48);
    if (LogLevel <= 1)
    {
      LOWORD(v137) = 12;
      LOBYTE(v114) = 1;
      double v84 = *(double *)(a4 + 8) + (double)*(uint64_t *)a4;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v137, (unsigned __int8 *)&v114, "DevAtt, Too large Estimated-Observed Attitude Innovation,time,%lf,type,%hu,outRangeCount,%u", v79, v80, v81, v82, v83, SLOBYTE(v84));
    }
    if (*(_DWORD *)(a1 + 7576) >= *(_DWORD *)(*(void *)(a1 + 488) + 1192))
    {
      if (cnprint::CNPrinter::GetLogLevel(LogLevel) <= 1)
      {
        LOWORD(v137) = 12;
        LOBYTE(v114) = 1;
        double v90 = *(double *)(a4 + 8) + (double)*(uint64_t *)a4;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v137, (unsigned __int8 *)&v114, "DevAtt,t,%lf,reset Device-Vehicle filter for consecutive %u out of range measurements", v85, v86, v87, v88, v89, SLOBYTE(v90));
      }
LABEL_39:
      *(_DWORD *)(a1 + 7576) = 0;
      unsigned char *v10 = 0;
    }
  }
  return v29;
}

void sub_18E167238(_Unwind_Exception *a1)
{
}

uint64_t raven::RavenDeviceAttitudeActiveObject::DownSamplingAccelGyroSamples(uint64_t this)
{
  uint64_t v1 = this;
  v116[0] = 0;
  long long v117 = 0u;
  memset(v118, 0, sizeof(v118));
  v113[0] = 0;
  long long v114 = 0u;
  memset(v115, 0, sizeof(v115));
  v110[0] = 0;
  long long v111 = 0u;
  memset(v112, 0, sizeof(v112));
  uint64_t v2 = *(void *)(this + 7768);
  if (v2)
  {
    int64x2_t v97 = vdupq_n_s64(0x7FF8000000000000uLL);
    while (1)
    {
      unint64_t v3 = *(void *)(*(void *)(v1 + 7736) + 8 * ((v2 + *(void *)(v1 + 7760) - 1) / 0x1AuLL))
         + 152 * ((v2 + *(void *)(v1 + 7760) - 1) % 0x1AuLL);
      uint64_t v4 = (*(uint64_t (**)(unint64_t))(*(void *)v3 + 16))(v3);
      double v6 = v5;
      double v7 = v5;
      unint64_t v8 = *(void *)(*(void *)(v1 + 7736) + 8 * (*(void *)(v1 + 7760) / 0x1AuLL))
         + 152 * (*(void *)(v1 + 7760) % 0x1AuLL);
      double v119 = (void *)(*(uint64_t (**)(unint64_t))(*(void *)v8 + 16))(v8);
      *(void *)&long long v120 = v9;
      v10.i64[0] = *(void *)(*(void *)(v1 + 488) + 1144);
      double v99 = 0;
      *(void *)&long long v100 = 0;
      CNTimeSpan::SetTimeSpan((uint64_t *)&v99, 0, v10, v11);
      this = CNTimeSpan::operator+((uint64_t)&v119, &v99, v12, v13);
      if (v4) {
        BOOL v15 = 1;
      }
      else {
        BOOL v15 = (*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
      }
      if (v15 && (this || (*(void *)&v14 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000) && v4 != this)
      {
        if (v4 <= this) {
          break;
        }
      }
      else if (v7 < v14)
      {
        break;
      }
      v116[0] = 0;
      long long v117 = 0u;
      memset(v118, 0, sizeof(v118));
      v113[0] = 0;
      long long v114 = 0u;
      memset(v115, 0, sizeof(v115));
      v110[0] = 0;
      long long v111 = 0u;
      memset(v112, 0, sizeof(v112));
      unint64_t v16 = *(void *)(*(void *)(v1 + 7736) + 8 * (*(void *)(v1 + 7760) / 0x1AuLL))
          + 152 * (*(void *)(v1 + 7760) % 0x1AuLL);
      double v119 = (void *)(*(uint64_t (**)(unint64_t))(*(void *)v16 + 16))(v16);
      *(void *)&long long v120 = v17;
      v18.i64[0] = *(void *)(*(void *)(v1 + 488) + 1144);
      double v99 = 0;
      *(void *)&long long v100 = 0;
      CNTimeSpan::SetTimeSpan((uint64_t *)&v99, 0, v18, v19);
      uint64_t v23 = CNTimeSpan::operator+((uint64_t)&v119, &v99, v20, v21);
      double v99 = &unk_1EDD14058;
      long long v100 = 0uLL;
      double v24 = v22;
      LOBYTE(v101) = 0;
      *((void *)&v101 + 1) = 0;
      *(void *)&long long v102 = 0;
      BYTE8(v102) = 0;
      long long v103 = 0uLL;
      LOBYTE(v104) = 0;
      *((void *)&v104 + 1) = 0;
      *(void *)uint64_t v105 = 0;
      *(int64x2_t *)&v105[8] = v97;
      int64x2_t v106 = v97;
      char v107 = 0;
      uint64_t v108 = 0x7FF8000000000000;
      if (v23) {
        BOOL v25 = 1;
      }
      else {
        BOOL v25 = (*(void *)&v22 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
      }
      char v26 = v25;
      __int16 v109 = 0;
      while (1)
      {
        unint64_t v27 = *(void *)(*(void *)(v1 + 7736) + 8 * (*(void *)(v1 + 7760) / 0x1AuLL))
            + 152 * (*(void *)(v1 + 7760) % 0x1AuLL);
        uint64_t v28 = (*(uint64_t (**)(unint64_t))(*(void *)v27 + 16))(v27);
        BOOL v30 = v28 || (*(void *)&v29 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
        if (v30 && (v26 & 1) != 0 && v28 != v23) {
          break;
        }
        if (v29 >= v24) {
          goto LABEL_32;
        }
LABEL_31:
        uint64_t v31 = *(void *)(v1 + 7736);
        unint64_t v32 = *(void *)(v1 + 7760);
        unint64_t v33 = v32 / 0x1A;
        unint64_t v34 = 152 * (v32 % 0x1A);
        unint64_t v35 = *(void *)(v31 + 8 * v33) + v34;
        long long v36 = *(_OWORD *)(v35 + 24);
        long long v100 = *(_OWORD *)(v35 + 8);
        long long v101 = v36;
        long long v37 = *(_OWORD *)(v35 + 56);
        long long v38 = *(_OWORD *)(v35 + 88);
        long long v39 = *(_OWORD *)(v35 + 40);
        long long v104 = *(_OWORD *)(v35 + 72);
        *(_OWORD *)uint64_t v105 = v38;
        long long v102 = v39;
        long long v103 = v37;
        sub_18DFF11E4((uint64_t)v116, (double *)(*(void *)(v31 + 8 * v33) + v34 + 104), 1.0);
        sub_18DFF11E4((uint64_t)v113, (double *)(*(void *)(*(void *)(v1 + 7736) + 8 * (*(void *)(v1 + 7760) / 0x1AuLL))+ 152 * (*(void *)(v1 + 7760) % 0x1AuLL)+ 112), 1.0);
        sub_18DFF11E4((uint64_t)v110, (double *)(*(void *)(*(void *)(v1 + 7736) + 8 * (*(void *)(v1 + 7760) / 0x1AuLL))+ 152 * (*(void *)(v1 + 7760) % 0x1AuLL)+ 120), 1.0);
        sub_18E0BB590((int64x2_t *)(v1 + 7728));
      }
      if (v28 < v23) {
        goto LABEL_31;
      }
LABEL_32:
      *(void *)&v105[16] = *(void *)&v118[1];
      v106.i64[0] = *(void *)&v115[1];
      v106.i64[1] = *(void *)&v112[1];
      __int16 v109 = 769;
      sub_18E0BAFF8((void *)(v1 + 496), (uint64_t)&v99);
      if (sub_18E16A5E4(v1, (void *)(v1 + 496), 3.0))
      {
        while (1)
        {
          unint64_t v40 = *(void *)(v1 + 528);
          uint64_t v41 = *(void *)(*(void *)(v1 + 504) + 8 * (v40 / 0x1A));
          double v119 = &unk_1EDD14058;
          uint64_t v42 = v41 + 152 * (v40 % 0x1A);
          long long v43 = *(_OWORD *)(v42 + 88);
          long long v44 = *(_OWORD *)(v42 + 104);
          long long v45 = *(_OWORD *)(v42 + 120);
          *(_OWORD *)((char *)v127 + 10) = *(_OWORD *)(v42 + 130);
          long long v126 = v44;
          v127[0] = v45;
          long long v125 = v43;
          long long v46 = *(_OWORD *)(v42 + 24);
          long long v47 = *(_OWORD *)(v42 + 40);
          long long v48 = *(_OWORD *)(v42 + 72);
          long long v123 = *(_OWORD *)(v42 + 56);
          long long v124 = v48;
          long long v121 = v46;
          long long v122 = v47;
          long long v120 = *(_OWORD *)(v42 + 8);
          sub_18E0BB590((int64x2_t *)(v1 + 496));
          if (!sub_18E16A5E4(v1, (void *)(v1 + 496), 3.0)) {
            break;
          }
          if (!sub_18E16A5E4(v1, (void *)(v1 + 496), 3.0)) {
            goto LABEL_37;
          }
        }
        sub_18DFFED54(v1 + 496, (uint64_t)&v119);
      }
LABEL_37:
      uint64_t v2 = *(void *)(v1 + 7768);
    }
  }
  uint64_t v49 = *(void *)(v1 + 7816);
  if (v49)
  {
    int64x2_t v98 = vdupq_n_s64(0x7FF8000000000000uLL);
    while (1)
    {
      unint64_t v50 = *(void *)(*(void *)(v1 + 7784) + 8 * ((v49 + *(void *)(v1 + 7808) - 1) / 0x1AuLL))
          + 152 * ((v49 + *(void *)(v1 + 7808) - 1) % 0x1AuLL);
      uint64_t v51 = (*(uint64_t (**)(unint64_t))(*(void *)v50 + 16))(v50);
      double v53 = v52;
      double v54 = v52;
      unint64_t v55 = *(void *)(*(void *)(v1 + 7784) + 8 * (*(void *)(v1 + 7808) / 0x1AuLL))
          + 152 * (*(void *)(v1 + 7808) % 0x1AuLL);
      double v119 = (void *)(*(uint64_t (**)(unint64_t))(*(void *)v55 + 16))(v55);
      *(void *)&long long v120 = v56;
      v57.i64[0] = *(void *)(*(void *)(v1 + 488) + 1144);
      double v99 = 0;
      *(void *)&long long v100 = 0;
      CNTimeSpan::SetTimeSpan((uint64_t *)&v99, 0, v57, v58);
      this = CNTimeSpan::operator+((uint64_t)&v119, &v99, v59, v60);
      if (v51) {
        BOOL v62 = 1;
      }
      else {
        BOOL v62 = (*(void *)&v53 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
      }
      if (v62 && (this || (*(void *)&v61 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000) && v51 != this)
      {
        if (v51 <= this) {
          return this;
        }
      }
      else if (v54 < v61)
      {
        return this;
      }
      v116[0] = 0;
      long long v117 = 0u;
      memset(v118, 0, sizeof(v118));
      v113[0] = 0;
      long long v114 = 0u;
      memset(v115, 0, sizeof(v115));
      v110[0] = 0;
      long long v111 = 0u;
      memset(v112, 0, sizeof(v112));
      unint64_t v63 = *(void *)(*(void *)(v1 + 7784) + 8 * (*(void *)(v1 + 7808) / 0x1AuLL))
          + 152 * (*(void *)(v1 + 7808) % 0x1AuLL);
      double v119 = (void *)(*(uint64_t (**)(unint64_t))(*(void *)v63 + 16))(v63);
      *(void *)&long long v120 = v64;
      v65.i64[0] = *(void *)(*(void *)(v1 + 488) + 1144);
      double v99 = 0;
      *(void *)&long long v100 = 0;
      CNTimeSpan::SetTimeSpan((uint64_t *)&v99, 0, v65, v66);
      uint64_t v70 = CNTimeSpan::operator+((uint64_t)&v119, &v99, v67, v68);
      double v99 = &unk_1EDD137F0;
      long long v100 = 0uLL;
      double v71 = v69;
      LOBYTE(v101) = 0;
      *((void *)&v101 + 1) = 0;
      *(void *)&long long v102 = 0;
      BYTE8(v102) = 0;
      long long v103 = 0uLL;
      LOBYTE(v104) = 0;
      *((void *)&v104 + 1) = 0;
      *(void *)uint64_t v105 = 0;
      *(int64x2_t *)&v105[8] = v98;
      int64x2_t v106 = v98;
      char v107 = 0;
      uint64_t v108 = 0x7FF8000000000000;
      if (v70) {
        BOOL v72 = 1;
      }
      else {
        BOOL v72 = (*(void *)&v69 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
      }
      char v73 = v72;
      __int16 v109 = 0;
      while (1)
      {
        unint64_t v74 = *(void *)(*(void *)(v1 + 7784) + 8 * (*(void *)(v1 + 7808) / 0x1AuLL))
            + 152 * (*(void *)(v1 + 7808) % 0x1AuLL);
        uint64_t v75 = (*(uint64_t (**)(unint64_t))(*(void *)v74 + 16))(v74);
        BOOL v77 = v75 || (*(void *)&v76 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
        if (v77 && (v73 & 1) != 0 && v75 != v70) {
          break;
        }
        if (v76 >= v71) {
          goto LABEL_69;
        }
LABEL_68:
        uint64_t v78 = *(void *)(v1 + 7784);
        unint64_t v79 = *(void *)(v1 + 7808);
        unint64_t v80 = v79 / 0x1A;
        unint64_t v81 = 152 * (v79 % 0x1A);
        unint64_t v82 = *(void *)(v78 + 8 * v80) + v81;
        long long v83 = *(_OWORD *)(v82 + 24);
        long long v100 = *(_OWORD *)(v82 + 8);
        long long v101 = v83;
        long long v84 = *(_OWORD *)(v82 + 56);
        long long v85 = *(_OWORD *)(v82 + 88);
        long long v86 = *(_OWORD *)(v82 + 40);
        long long v104 = *(_OWORD *)(v82 + 72);
        *(_OWORD *)uint64_t v105 = v85;
        long long v102 = v86;
        long long v103 = v84;
        sub_18DFF11E4((uint64_t)v116, (double *)(*(void *)(v78 + 8 * v80) + v81 + 104), 1.0);
        sub_18DFF11E4((uint64_t)v113, (double *)(*(void *)(*(void *)(v1 + 7784) + 8 * (*(void *)(v1 + 7808) / 0x1AuLL))+ 152 * (*(void *)(v1 + 7808) % 0x1AuLL)+ 112), 1.0);
        sub_18DFF11E4((uint64_t)v110, (double *)(*(void *)(*(void *)(v1 + 7784) + 8 * (*(void *)(v1 + 7808) / 0x1AuLL))+ 152 * (*(void *)(v1 + 7808) % 0x1AuLL)+ 120), 1.0);
        sub_18E167D30(v1 + 7776);
      }
      if (v75 < v70) {
        goto LABEL_68;
      }
LABEL_69:
      *(void *)&v105[16] = *(void *)&v118[1];
      v106.i64[0] = *(void *)&v115[1];
      v106.i64[1] = *(void *)&v112[1];
      if (*(unsigned char *)(v1 + 8400))
      {
        uint64_t v87 = *(double **)(v1 + 8048);
        *(double *)&v105[16] = *(double *)&v118[1] - *v87;
        *(double *)v106.i64 = *(double *)&v115[1] - v87[1];
        *(double *)&v106.i64[1] = *(double *)&v112[1] - v87[2];
      }
      __int16 v109 = 769;
      sub_18E167DEC((void **)(v1 + 6904), (uint64_t)&v99);
      if (sub_18E16A5E4(v1, (void *)(v1 + 6904), 3.0))
      {
        while (1)
        {
          unint64_t v88 = *(void *)(v1 + 6936);
          uint64_t v89 = *(void *)(*(void *)(v1 + 6912) + 8 * (v88 / 0x1A));
          double v119 = &unk_1EDD137F0;
          uint64_t v90 = v89 + 152 * (v88 % 0x1A);
          long long v91 = *(_OWORD *)(v90 + 88);
          long long v92 = *(_OWORD *)(v90 + 104);
          long long v93 = *(_OWORD *)(v90 + 120);
          *(_OWORD *)((char *)v127 + 10) = *(_OWORD *)(v90 + 130);
          long long v126 = v92;
          v127[0] = v93;
          long long v125 = v91;
          long long v94 = *(_OWORD *)(v90 + 24);
          long long v95 = *(_OWORD *)(v90 + 40);
          long long v96 = *(_OWORD *)(v90 + 72);
          long long v123 = *(_OWORD *)(v90 + 56);
          long long v124 = v96;
          long long v121 = v94;
          long long v122 = v95;
          long long v120 = *(_OWORD *)(v90 + 8);
          sub_18E167D30(v1 + 6904);
          if (!sub_18E16A5E4(v1, (void *)(v1 + 6904), 3.0)) {
            break;
          }
          if (!sub_18E16A5E4(v1, (void *)(v1 + 6904), 3.0)) {
            goto LABEL_76;
          }
        }
        sub_18DFFF508(v1 + 6904, (uint64_t)&v119);
      }
LABEL_76:
      uint64_t v49 = *(void *)(v1 + 7816);
    }
  }
  return this;
}

void sub_18E167D30(uint64_t a1)
{
  uint64_t v2 = (void (***)(void))(*(void *)(*(void *)(a1 + 8) + 8 * (*(void *)(a1 + 32) / 0x1AuLL))
                                     + 152 * (*(void *)(a1 + 32) % 0x1AuLL));
  (**v2)(v2);
  int64x2_t v3 = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_18E1EF670);
  *(int64x2_t *)(a1 + 32) = v3;
  if (v3.i64[0] >= 0x34uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 26;
  }
}

__n128 sub_18E167DEC(void **a1, uint64_t a2)
{
  uint64_t v4 = (char *)a1[1];
  double v5 = (char *)a1[2];
  unint64_t v6 = (v5 - v4) >> 3;
  if (v5 == v4) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = 26 * v6 - 1;
  }
  unint64_t v8 = (unint64_t)a1[4];
  if ((void *)v7 != (char *)a1[5] + v8) {
    goto LABEL_58;
  }
  BOOL v9 = v8 >= 0x1A;
  unint64_t v10 = v8 - 26;
  if (v9)
  {
    uint64_t v11 = (uint64_t)(a1 + 3);
    int8x16_t v12 = (char *)a1[3];
    a1[4] = (void *)v10;
    uint64_t v15 = *(void *)v4;
    int8x16_t v13 = v4 + 8;
    uint64_t v14 = v15;
    a1[1] = v13;
    if (v5 != v12)
    {
LABEL_51:
      *(void *)double v5 = v14;
      a1[2] = (char *)a1[2] + 8;
      goto LABEL_57;
    }
    uint64_t v16 = v13 - (unsigned char *)*a1;
    if (v13 > *a1)
    {
      uint64_t v17 = v16 >> 3;
      BOOL v18 = v16 >> 3 < -1;
      uint64_t v19 = (v16 >> 3) + 2;
      if (v18) {
        uint64_t v20 = v19;
      }
      else {
        uint64_t v20 = v17 + 1;
      }
      uint64_t v21 = -(v20 >> 1);
      uint64_t v22 = v20 >> 1;
      uint64_t v23 = &v13[-8 * v22];
      int64_t v24 = v5 - v13;
      if (v5 != v13)
      {
        memmove(&v13[-8 * v22], v13, v5 - v13);
        double v5 = (char *)a1[1];
      }
      BOOL v25 = &v5[8 * v21];
      double v5 = &v23[v24];
      goto LABEL_15;
    }
    if (v5 == *a1) {
      unint64_t v48 = 1;
    }
    else {
      unint64_t v48 = (v5 - (unsigned char *)*a1) >> 2;
    }
    uint64_t v49 = (char *)sub_18DEDF808(v11, v48);
    unint64_t v50 = &v49[8 * (v48 >> 2)];
    double v52 = &v49[8 * v51];
    double v53 = (uint64_t *)a1[1];
    double v5 = v50;
    uint64_t v54 = (unsigned char *)a1[2] - (unsigned char *)v53;
    if (v54)
    {
      double v5 = &v50[v54 & 0xFFFFFFFFFFFFFFF8];
      uint64_t v55 = 8 * (v54 >> 3);
      uint64_t v56 = &v49[8 * (v48 >> 2)];
      do
      {
        uint64_t v57 = *v53++;
        *(void *)uint64_t v56 = v57;
        v56 += 8;
        v55 -= 8;
      }
      while (v55);
    }
LABEL_48:
    int8x16_t v58 = *a1;
    *a1 = v49;
    a1[1] = v50;
    a1[2] = v5;
    a1[3] = v52;
    if (v58)
    {
      operator delete(v58);
      double v5 = (char *)a1[2];
    }
    goto LABEL_51;
  }
  char v26 = (char *)a1[3];
  uint64_t v27 = v26 - (unsigned char *)*a1;
  if (v6 >= v27 >> 3)
  {
    if (v26 == *a1) {
      unint64_t v28 = 1;
    }
    else {
      unint64_t v28 = v27 >> 2;
    }
    long long v91 = a1 + 3;
    std::string __p = sub_18DEDF808((uint64_t)(a1 + 3), v28);
    __src = (char *)__p + 8 * v6;
    *(void *)&long long v90 = __src;
    *((void *)&v90 + 1) = (char *)__p + 8 * v29;
    uint64_t v87 = operator new(0xF70uLL);
    sub_18DEDF5A0(&__p, &v87);
    BOOL v30 = (char *)a1[2];
    uint64_t v31 = (char *)__src;
    if (v30 == a1[1])
    {
      long long v47 = (char *)a1[2];
    }
    else
    {
      do
      {
        if (v31 == __p)
        {
          if ((unint64_t)v90 >= *((void *)&v90 + 1))
          {
            if (*((char **)&v90 + 1) == v31) {
              unint64_t v36 = 1;
            }
            else {
              unint64_t v36 = (uint64_t)(*((void *)&v90 + 1) - (void)v31) >> 2;
            }
            long long v37 = (char *)sub_18DEDF808((uint64_t)v91, v36);
            unint64_t v32 = &v37[(2 * v36 + 6) & 0xFFFFFFFFFFFFFFF8];
            long long v39 = (uint64_t *)__src;
            unint64_t v40 = v32;
            uint64_t v41 = v90 - (void)__src;
            if ((void *)v90 != __src)
            {
              unint64_t v40 = &v32[v41 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v42 = 8 * (v41 >> 3);
              long long v43 = v32;
              do
              {
                uint64_t v44 = *v39++;
                *(void *)long long v43 = v44;
                v43 += 8;
                v42 -= 8;
              }
              while (v42);
            }
            long long v45 = __p;
            std::string __p = v37;
            __src = v32;
            *(void *)&long long v90 = v40;
            *((void *)&v90 + 1) = &v37[8 * v38];
            if (v45)
            {
              operator delete(v45);
              unint64_t v32 = (char *)__src;
            }
          }
          else
          {
            uint64_t v33 = (uint64_t)(*((void *)&v90 + 1) - v90) >> 3;
            if (v33 >= -1) {
              uint64_t v34 = v33 + 1;
            }
            else {
              uint64_t v34 = v33 + 2;
            }
            uint64_t v35 = v34 >> 1;
            unint64_t v32 = &v31[8 * (v34 >> 1)];
            if ((char *)v90 != v31)
            {
              memmove(&v31[8 * (v34 >> 1)], v31, v90 - (void)v31);
              uint64_t v31 = (char *)v90;
            }
            __src = v32;
            *(void *)&long long v90 = &v31[8 * v35];
          }
        }
        else
        {
          unint64_t v32 = v31;
        }
        uint64_t v46 = *((void *)v30 - 1);
        v30 -= 8;
        *((void *)v32 - 1) = v46;
        uint64_t v31 = (char *)__src - 8;
        __src = (char *)__src - 8;
      }
      while (v30 != a1[1]);
      long long v47 = (char *)a1[2];
    }
    BOOL v62 = *a1;
    *a1 = __p;
    a1[1] = v31;
    std::string __p = v62;
    __src = v30;
    unint64_t v63 = a1[3];
    *((_OWORD *)a1 + 1) = v90;
    *(void *)&long long v90 = v47;
    *((void *)&v90 + 1) = v63;
    if (v47 != v30) {
      *(void *)&long long v90 = &v47[(v30 - v47 + 7) & 0xFFFFFFFFFFFFFFF8];
    }
    if (v62) {
      operator delete(v62);
    }
    goto LABEL_57;
  }
  if (v26 == v5)
  {
    std::string __p = operator new(0xF70uLL);
    sub_18DEDF480((uint64_t)a1, &__p);
    int8x16_t v59 = a1[1];
    double v5 = (char *)a1[2];
    uint64_t v61 = *v59;
    int8x16_t v60 = (char *)(v59 + 1);
    uint64_t v14 = v61;
    a1[1] = v60;
    if (v5 != a1[3]) {
      goto LABEL_51;
    }
    uint64_t v72 = v60 - (unsigned char *)*a1;
    if (v60 > *a1)
    {
      uint64_t v73 = v72 >> 3;
      BOOL v18 = v72 >> 3 < -1;
      uint64_t v74 = (v72 >> 3) + 2;
      if (v18) {
        uint64_t v75 = v74;
      }
      else {
        uint64_t v75 = v73 + 1;
      }
      uint64_t v76 = -(v75 >> 1);
      uint64_t v77 = v75 >> 1;
      uint64_t v78 = &v60[-8 * v77];
      int64_t v79 = v5 - v60;
      if (v5 != v60)
      {
        memmove(&v60[-8 * v77], v60, v5 - v60);
        int8x16_t v60 = (char *)a1[1];
      }
      double v5 = &v78[v79];
      BOOL v25 = &v60[8 * v76];
LABEL_15:
      a1[1] = v25;
      a1[2] = v5;
      goto LABEL_51;
    }
    if (v5 == *a1) {
      unint64_t v80 = 1;
    }
    else {
      unint64_t v80 = (v5 - (unsigned char *)*a1) >> 2;
    }
    uint64_t v49 = (char *)sub_18DEDF808((uint64_t)(a1 + 3), v80);
    unint64_t v50 = &v49[8 * (v80 >> 2)];
    double v52 = &v49[8 * v81];
    unint64_t v82 = (uint64_t *)a1[1];
    double v5 = v50;
    uint64_t v83 = (unsigned char *)a1[2] - (unsigned char *)v82;
    if (v83)
    {
      double v5 = &v50[v83 & 0xFFFFFFFFFFFFFFF8];
      uint64_t v84 = 8 * (v83 >> 3);
      long long v85 = &v49[8 * (v80 >> 2)];
      do
      {
        uint64_t v86 = *v82++;
        *(void *)long long v85 = v86;
        v85 += 8;
        v84 -= 8;
      }
      while (v84);
    }
    goto LABEL_48;
  }
  std::string __p = operator new(0xF70uLL);
  sub_18DEDF368(a1, &__p);
LABEL_57:
  uint64_t v4 = (char *)a1[1];
  double v5 = (char *)a1[2];
LABEL_58:
  if (v5 == v4)
  {
    unint64_t v65 = 0;
  }
  else
  {
    unint64_t v64 = (unint64_t)a1[4] + (void)a1[5];
    unint64_t v65 = *(void *)&v4[8 * (v64 / 0x1A)] + 152 * (v64 % 0x1A);
  }
  *(void *)unint64_t v65 = &unk_1EDD137F0;
  *(_OWORD *)(v65 + 8) = *(_OWORD *)(a2 + 8);
  long long v66 = *(_OWORD *)(a2 + 24);
  long long v67 = *(_OWORD *)(a2 + 40);
  long long v68 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(v65 + 72) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(v65 + 56) = v68;
  *(_OWORD *)(v65 + 40) = v67;
  *(_OWORD *)(v65 + 24) = v66;
  __n128 result = *(__n128 *)(a2 + 88);
  long long v70 = *(_OWORD *)(a2 + 104);
  long long v71 = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(v65 + 130) = *(_OWORD *)(a2 + 130);
  *(_OWORD *)(v65 + 120) = v71;
  *(_OWORD *)(v65 + 104) = v70;
  *(__n128 *)(v65 + 88) = result;
  a1[5] = (char *)a1[5] + 1;
  return result;
}

void sub_18E1682C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  operator delete(v12);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL raven::RavenDeviceAttitudeActiveObject::DualDirSmooth(uint64_t a1, char **a2, double a3)
{
  int64x2_t v3 = *a2;
  uint64_t v4 = a2[1];
  if (*a2 == v4) {
    return 0;
  }
  BOOL v5 = a3 < 0.0 || ((*(void *)&a3 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE;
  if (v5 && (unint64_t)(*(void *)&a3 - 1) > 0xFFFFFFFFFFFFELL) {
    return 0;
  }
  BOOL v7 = 0;
  double v8 = 1.0 / *(double *)(*(void *)(a1 + 488) + 1144);
  if (COERCE__INT64(fabs(v8)) <= 0x7FEFFFFFFFFFFFFFLL && v8 > 0.0)
  {
    double v10 = 1.0 / v8 / (1.0 / (a3 * 6.28318531) + 1.0 / v8);
    long long v37 = 0u;
    long long v38 = 0u;
    long long v36 = 0u;
    double v11 = 1.0 - v10;
    char v12 = 1;
    double v13 = 0.0;
    do
    {
      double v14 = *((double *)v4 - 1);
      v4 -= 8;
      double v15 = v14;
      double v16 = v11 * v13 + v10 * v14;
      if (v12) {
        double v13 = v15;
      }
      else {
        double v13 = v16;
      }
      double v35 = v13;
      sub_18DEE1AB4((uint64_t)&v36, &v35);
      char v12 = 0;
    }
    while (v4 != v3);
    uint64_t v17 = *a2;
    uint64_t v18 = (a2[1] - *a2) >> 3;
    BOOL v7 = v18 == *((void *)&v38 + 1);
    if (v18 != *((void *)&v38 + 1)) {
      goto LABEL_39;
    }
    uint64_t v19 = (const void **)(*((void *)&v36 + 1) + 8 * ((unint64_t)v38 >> 9));
    if ((void)v37 == *((void *)&v36 + 1))
    {
      uint64_t v21 = 0;
      uint64_t v23 = 0;
      uint64_t v22 = (const void **)(*((void *)&v36 + 1) + 8 * (((void)v38 + *((void *)&v38 + 1)) >> 9));
    }
    else
    {
      uint64_t v20 = *v19;
      uint64_t v21 = (char *)*v19 + 8 * (v38 & 0x1FF);
      uint64_t v22 = (const void **)(*((void *)&v36 + 1) + 8 * (((void)v38 + *((void *)&v38 + 1)) >> 9));
      uint64_t v23 = (uint64_t)*v22 + 8 * ((v38 + *((void *)&v38 + 1)) & 0x1FF);
      if (v21 != (char *)v23)
      {
        char v24 = 1;
        double v25 = 0.0;
        unint64_t v26 = *((void *)&v36 + 1) + 8 * ((unint64_t)v38 >> 9);
        uint64_t v27 = (double *)((char *)*v19 + 8 * (v38 & 0x1FF));
        do
        {
          double v25 = v11 * v25 + v10 * *v27;
          if (v24) {
            double v25 = *v27;
          }
          *v27++ = v25;
          if ((char *)v27 - v20 == 4096)
          {
            unint64_t v28 = *(double **)(v26 + 8);
            v26 += 8;
            uint64_t v20 = v28;
            uint64_t v27 = v28;
          }
          char v24 = 0;
        }
        while (v27 != (double *)v23);
      }
    }
    if (v19 == v22)
    {
      size_t v34 = v23 - (void)v21;
      if ((char *)v23 == v21)
      {
LABEL_39:
        sub_18DEE2DB8(&v36);
        return v7;
      }
    }
    else
    {
      uint64_t v30 = (uint64_t)*v19 + 4096;
      uint64_t v31 = v30 - (void)v21;
      if ((char *)v30 != v21) {
        memmove(v17, v21, v30 - (void)v21);
      }
      v17 += v31;
      for (int i = v19 + 1; i != v22; ++i)
      {
        uint64_t v33 = *i;
        memmove(v17, v33, 0x1000uLL);
        v17 += 4096;
      }
      uint64_t v21 = (char *)*v22;
      if (*v22 == (const void *)v23) {
        goto LABEL_39;
      }
      size_t v34 = v23 - (void)v21;
    }
    memmove(v17, v21, v34);
    goto LABEL_39;
  }
  return v7;
}

void sub_18E16856C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_18DEE2DB8((uint64_t *)va);
  _Unwind_Resume(a1);
}

BOOL raven::RavenDeviceAttitudeActiveObject::IsDecelerationToStop(raven::RavenDeviceAttitudeActiveObject *this)
{
  unint64_t v1 = *((void *)this + 983);
  if (v1 < 2) {
    return 0;
  }
  unint64_t v3 = v1 + *((void *)this + 982) - 1;
  uint64_t v4 = *(void *)(*((void *)this + 979) + ((v3 >> 1) & 0x7FFFFFFFFFFFFFF8));
  unsigned int v5 = v3 & 0xF;
  unint64_t v6 = (double *)(v4 + 2432 * v5);
  double v7 = sqrt(v6[195] * v6[195] + v6[194] * v6[194] + v6[196] * v6[196]);
  if (v7 > 1.0) {
    return 0;
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)(v4 + 2432 * v5) + 16))(v4 + 2432 * v5);
  double v10 = v9;
  double v11 = v9;
  sub_18DFF49CC((uint64_t)v42);
  unint64_t v12 = *((void *)this + 982) + *((void *)this + 983);
  uint64_t v13 = *((void *)this + 979);
  double v14 = (void *)(v13 + 8 * (v12 >> 4));
  uint64_t v15 = *((void *)this + 980);
  uint64_t v16 = v15 == v13 ? 0 : *v14 + 2432 * (v12 & 0xF);
  BOOL v17 = v8 || (*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
  BOOL v18 = v17;
  while (1)
  {
    uint64_t v19 = v15 == v13
        ? 0
        : *(void *)(v13 + ((*((void *)this + 982) >> 1) & 0x7FFFFFFFFFFFFFF8))
        + 2432 * (*((void *)this + 982) & 0xFLL);
    if (v19 == v16) {
      break;
    }
    uint64_t v20 = v16 - *v14;
    unint64_t v21 = 0x86BCA1AF286BCA1BLL * (v20 >> 7);
    if (v20 < 2433) {
      uint64_t v22 = v14[-((16 - v21) >> 4)] + 2432 * (~(16 - (_BYTE)v21) & 0xF);
    }
    else {
      uint64_t v22 = *(void *)((char *)v14 + (((v21 - 1) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 2432 * ((v21 - 1) & 0xF);
    }
    v41[0] = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
    v41[1] = v23;
    v40[0] = 0;
    v40[1] = 0x3FECCCCCCCCCCCCDLL;
    uint64_t v26 = CNTimeSpan::operator+((uint64_t)v41, v40, v24, v25);
    if (!v18
      || !v26 && (*(void *)&v27 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || (BOOL v28 = v8 <= v26, v8 == v26))
    {
      BOOL v28 = v11 <= v27;
    }
    if (!v28)
    {
      if (*v14 == v16) {
        uint64_t v16 = *(v14 - 1) + 38912;
      }
      memcpy(v43, (const void *)(v16 - 2424), 0x971uLL);
      break;
    }
    if (*v14 == v16)
    {
      uint64_t v29 = *--v14;
      uint64_t v16 = v29 + 38912;
    }
    v16 -= 2432;
    uint64_t v13 = *((void *)this + 979);
    uint64_t v15 = *((void *)this + 980);
  }
  if (!LOBYTE(v43[192]) || sqrt(v43[194] * v43[194] + v43[193] * v43[193] + v43[195] * v43[195]) > 1.0) {
    return 0;
  }
  uint64_t v31 = *((void *)this + 979);
  if (*((void *)this + 980) == v31
    || (unint64_t v32 = *((void *)this + 982),
        uint64_t v33 = (double **)(v31 + 8 * (v32 >> 4)),
        size_t v34 = *v33,
        double v35 = &(*v33)[304 * (v32 & 0xF)],
        uint64_t v36 = *(void *)(v31 + (((*((void *)this + 983) + v32) >> 1) & 0x7FFFFFFFFFFFFFF8))
            + 2432 * ((*((_DWORD *)this + 1966) + v32) & 0xF),
        v35 == (double *)v36))
  {
    double v37 = -INFINITY;
  }
  else
  {
    double v37 = -INFINITY;
    do
    {
      double v38 = sqrt(v35[195] * v35[195] + v35[194] * v35[194] + v35[196] * v35[196]);
      if (v37 < v38) {
        double v37 = v38;
      }
      v35 += 304;
      if ((char *)v35 - (char *)v34 == 38912)
      {
        long long v39 = v33[1];
        ++v33;
        size_t v34 = v39;
        double v35 = v39;
      }
    }
    while (v35 != (double *)v36);
  }
  return vabdd_f64(v37, v7) >= *(double *)(*((void *)this + 61) + 1056);
}

BOOL raven::RavenDeviceAttitudeActiveObject::IsMovementStraight(raven::RavenDeviceAttitudeActiveObject *this)
{
  v23[0] = 0;
  long long v24 = 0u;
  memset(v25, 0, sizeof(v25));
  v20[0] = 0;
  long long v21 = 0u;
  memset(v22, 0, sizeof(v22));
  v17[0] = 0;
  long long v18 = 0u;
  memset(v19, 0, sizeof(v19));
  uint64_t v2 = *((void *)this + 864);
  double v3 = 0.0;
  if (*((void *)this + 865) == v2)
  {
    double v8 = 0.0;
    double v9 = 0.0;
  }
  else
  {
    unint64_t v4 = *((void *)this + 867);
    unsigned int v5 = (void *)(v2 + 8 * (v4 / 0x1A));
    unint64_t v6 = (double *)(*v5 + 152 * (v4 % 0x1A));
    unint64_t v7 = *(void *)(v2 + 8 * ((*((void *)this + 868) + v4) / 0x1A)) + 152 * ((*((void *)this + 868) + v4) % 0x1A);
    double v8 = 0.0;
    double v9 = 0.0;
    if (v6 != (double *)v7)
    {
      do
      {
        sub_18DFF11E4((uint64_t)v23, v6 + 13, 1.0);
        sub_18DFF11E4((uint64_t)v20, v6 + 14, 1.0);
        sub_18DFF11E4((uint64_t)v17, v6 + 15, 1.0);
        v6 += 19;
        if ((double *)((char *)v6 - *v5) == (double *)3952)
        {
          double v10 = (double *)v5[1];
          ++v5;
          unint64_t v6 = v10;
        }
      }
      while (v6 != (double *)v7);
      double v9 = *(double *)&v25[20];
      double v8 = *(double *)&v22[20];
      double v3 = *(double *)&v19[20];
    }
  }
  uint64_t v11 = *((void *)this + 61);
  double v12 = *(double *)(v11 + 1104) * 0.0174532925 * 0.0174532925;
  BOOL v14 = v9 < v12 && v8 < v12 && v3 < v12;
  if (v14
    && (double v15 = *(double *)(v11 + 1096) * 0.0174532925, fabs(*(double *)&v25[4]) < v15)
    && fabs(*(double *)&v22[4]) < v15)
  {
    return fabs(*(double *)&v19[4]) < v15;
  }
  else
  {
    return 0;
  }
}

double sub_18E168AB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 8)) {
    BOOL v3 = *(_DWORD *)(a2 + 8) == 3;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3 && *(_DWORD *)(a2 + 12) == 1)
  {
    unint64_t v6 = *(long long **)(a2 + 32);
    long long v11 = *v6;
    uint64_t v12 = *((void *)v6 + 2);
    if (sub_18DEF20E0(a1, (double *)&v11, v10))
    {
      uint64_t v8 = 0;
      *(_OWORD *)(a3 + 8) = xmmword_18E1F6F60;
      uint64_t v9 = *(void *)(a3 + 32);
      do
      {
        double result = v10[v8];
        *(double *)(v9 + v8 * 8) = result;
        ++v8;
      }
      while (v8 != 3);
    }
  }
  return result;
}

uint64_t sub_18E168B50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4 = *(_DWORD *)(a1 + 8);
  int v5 = *(_DWORD *)(a1 + 12);
  uint64_t v17 = 0x300000003;
  uint64_t v12 = &unk_1EDD18EE8;
  int v13 = v4;
  int v14 = v5;
  int v15 = v5 * v4;
  int v16 = v4;
  long long v18 = &v19;
  uint64_t v9 = 0x1000001E6;
  unint64_t v7 = &unk_1EDD19218;
  long long v8 = xmmword_18E1FD000;
  double v10 = &v11;
  return sub_18E171184(a1, (uint64_t)&v12, (uint64_t)&v7, a2, a3, a4);
}

void raven::RavenDeviceAttitudeActiveObject::QuaternionFromRotationVector(uint64_t a1@<X1>, float64x2_t *a2@<X8>)
{
  uint64_t v23 = 0x100000003;
  long long v21 = &unk_1EDD18D98;
  long long v22 = xmmword_18E1F6F60;
  long long v24 = &v25;
  uint64_t v18 = 0x100000134;
  int v16 = &unk_1EDD18C48;
  long long v17 = xmmword_18E1F6FB0;
  uint64_t v19 = &v20;
  uint64_t v13 = 0x100000003;
  uint64_t v11 = &unk_1EDD18D98;
  long long v12 = xmmword_18E1F6F60;
  int v14 = &v15;
  sub_18DFE345C(a1, (uint64_t)&v21, (uint64_t)&v16, (uint64_t)&v11, "2");
  double v5 = v4 * 0.5;
  if (fabs(v4 * 0.5) == INFINITY)
  {
    double v6 = NAN;
  }
  else if (v5 > 0.01 || v5 < -0.01)
  {
    double v6 = sin(v5) / v5;
  }
  else
  {
    double v6 = v5 * v5 / -6.0 + 1.0;
  }
  double v10 = v6 * 0.5;
  unint64_t v7 = *(float64x2_t **)(a1 + 32);
  double v8 = v6 * 0.5 * v7[1].f64[0];
  long double v9 = cos(v5);
  *a2 = vmulq_n_f64(*v7, v10);
  a2[1].f64[0] = v8;
  a2[1].f64[1] = v9;
}

uint64_t raven::RavenDeviceAttitudeActiveObject::RaiseExternalAttitudeEvent(uint64_t this, const raven::TimeMarkEvent *a2)
{
  if (*(unsigned char *)(*(void *)(this + 488) + 3790) && *(unsigned char *)(this + 1432))
  {
    if (*(unsigned char *)(this + 1424)) {
      sub_18E0CF124();
    }
  }
  return this;
}

uint64_t raven::RavenDeviceAttitudeActiveObject::RaiseNonHolonomicEvent(uint64_t this, const raven::TimeMarkEvent *a2)
{
  if (*(unsigned char *)(this + 6977) && *(unsigned char *)(this + 6979))
  {
    BOOL v3 = (_DWORD *)this;
    uint64_t v4 = this + 1048;
    uint64_t v14 = 0x300000003;
    long long v12 = &unk_1EDD18EE8;
    long long v13 = xmmword_18E1F0010;
    uint64_t v15 = &v16;
    sub_18DFE2B44(this + 1048, this + 792, (uint64_t)&v12);
    int v5 = v3[265];
    int v6 = v3[264];
    uint64_t v38 = 0x300000003;
    uint64_t v33 = &unk_1EDD18EE8;
    int v34 = v5;
    int v35 = v6;
    int v36 = v6 * v5;
    int v37 = v5;
    long long v39 = &v40;
    sub_18DFE2C64(v4, (uint64_t)&v33);
    uint64_t v19 = 0x300000003;
    long long v17 = &unk_1EDD18EE8;
    long long v18 = xmmword_18E1F0010;
    uint64_t v20 = &v21;
    sub_18DFE2B44((uint64_t)&v12, (uint64_t)&v33, (uint64_t)&v17);
    uint64_t v7 = v18;
    if ((int)v18 < 1)
    {
      double v9 = 0.0;
    }
    else
    {
      int v8 = 0;
      double v9 = 0.0;
      do
      {
        double v9 = v9 + *(double *)&v20[v8];
        v8 += HIDWORD(v18) + 1;
        --v7;
      }
      while (v7);
    }
    double v10 = cnrotation::CNRotation::RotationMatrix((cnrotation::CNRotation *)(v3 + 254), (uint64_t)&v33);
    long long v18 = 0uLL;
    LOBYTE(v19) = 0;
    long long v17 = &unk_1EDD15838;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    char v22 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    char v25 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    uint64_t v28 = 0x7FF8000000000000;
    *(void *)&long long v18 = (*(uint64_t (**)(const raven::TimeMarkEvent *, double))(*(void *)a2 + 16))(a2, v10);
    *((void *)&v18 + 1) = v11;
    uint64_t v29 = *v39;
    uint64_t v30 = v39[v37];
    uint64_t v31 = v39[2 * v37];
    double v32 = sqrt(v9);
    sub_18E0D1024();
  }
  return this;
}

void raven::RavenDeviceAttitudeActiveObject::ResetWahbaSolver(raven::RavenDeviceAttitudeActiveObject *this)
{
  *((_OWORD *)this + 469) = 0u;
  uint64_t v2 = (void **)*((void *)this + 1038);
  BOOL v3 = (void **)*((void *)this + 1039);
  if (v3 == v2)
  {
    int v6 = (void *)((char *)this + 8336);
    BOOL v3 = (void **)*((void *)this + 1038);
  }
  else
  {
    unint64_t v4 = *((void *)this + 1041);
    int v5 = &v2[v4 / 0x14];
    int v6 = (void *)((char *)this + 8336);
    unint64_t v7 = (unint64_t)v2[(*((void *)this + 1042) + v4) / 0x14] + 200 * ((*((void *)this + 1042) + v4) % 0x14);
    if ((char *)*v5 + 200 * (v4 % 0x14) != (void *)v7)
    {
      int v8 = (void (***)(void))((char *)*v5 + 200 * (v4 % 0x14));
      do
      {
        double v9 = *v8;
        v8 += 25;
        (*v9)();
        if ((char *)v8 - (unsigned char *)*v5 == 4000)
        {
          double v10 = (void (***)(void))v5[1];
          ++v5;
          int v8 = v10;
        }
      }
      while (v8 != (void (***)(void))v7);
      BOOL v3 = (void **)*((void *)this + 1039);
      uint64_t v2 = (void **)*((void *)this + 1038);
    }
  }
  *int v6 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if (v11 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v2 = (void **)(*((void *)this + 1038) + 8);
      *((void *)this + 1038) = v2;
      unint64_t v11 = *((void *)this + 1039) - (void)v2;
    }
    while (v11 > 0x10);
  }
  if (v11 >> 3 == 1)
  {
    uint64_t v12 = 10;
  }
  else
  {
    if (v11 >> 3 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 20;
  }
  *((void *)this + 1041) = v12;
LABEL_16:
  *((_WORD *)this + 4172) = 1;
  long long v13 = (void **)*((void *)this + 1045);
  uint64_t v14 = *((void *)this + 1046);
  *((void *)this + 1049) = 0;
  unint64_t v15 = v14 - (void)v13;
  if (v15 >= 0x11)
  {
    do
    {
      operator delete(*v13);
      long long v13 = (void **)(*((void *)this + 1045) + 8);
      *((void *)this + 1045) = v13;
      unint64_t v15 = *((void *)this + 1046) - (void)v13;
    }
    while (v15 > 0x10);
  }
  if (v15 >> 3 == 1)
  {
    uint64_t v16 = 64;
  }
  else
  {
    if (v15 >> 3 != 2) {
      return;
    }
    uint64_t v16 = 128;
  }
  *((void *)this + 1048) = v16;
}

BOOL raven::RavenDeviceAttitudeActiveObject::ThorntonTemporalUpdate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  uint64_t v56 = 0x300000003;
  uint64_t v54 = &unk_1EDD18EE8;
  long long v55 = xmmword_18E1F0010;
  uint64_t v57 = v58;
  do
  {
    uint64_t v5 = 0;
    uint64_t v6 = *(int *)(a2 + 20);
    uint64_t v7 = *(void *)(a2 + 32);
    do
    {
      if (v5)
      {
        uint64_t v8 = 0;
        int v9 = v4 + v6 * v5;
        double v10 = *(double *)(v7 + 8 * v9);
        uint64_t v11 = *(void *)(a1 + 1080) + 8 * *(_DWORD *)(a1 + 1068) * (int)v5;
        uint64_t v12 = (double *)(v7 + v3);
        do
        {
          double v10 = v10 + *v12 * *(double *)(v11 + 8 * v8);
          *(double *)(v7 + 8 * v9) = v10;
          ++v8;
          v12 += v6;
        }
        while (v5 != v8);
      }
      v58[3 * v5++ + v4] = 0;
    }
    while (v5 != 3);
    v58[4 * v4++] = 0x3FF0000000000000;
    v3 += 8;
  }
  while (v4 != 3);
  uint64_t v51 = 0x100000003;
  uint64_t v49 = &unk_1EDD18D98;
  long long v50 = xmmword_18E1F6F60;
  double v52 = v53;
  int v13 = *(_DWORD *)(a1 + 812) + 1;
  uint64_t v14 = *(void *)(a1 + 824);
  uint64_t v15 = *(void *)(a3 + 32);
  uint64_t v16 = *(int *)(a2 + 20);
  uint64_t v17 = *(void *)(a2 + 32);
  uint64_t v18 = 2;
  for (uint64_t i = 7; ; --i)
  {
    int v20 = 0;
    int v21 = 0;
    uint64_t v22 = 0;
    *(void *)&v53[8 * v18] = 0;
    double v23 = 0.0;
    uint64_t v24 = i * 8;
    do
    {
      double v25 = v23 + *(double *)(v7 + 8 * (v18 + v20)) * *(double *)(v7 + 8 * (v18 + v20)) * *(double *)(v14 + 8 * v21);
      *(double *)&v53[8 * v18] = v25;
      double v23 = v25 + *(double *)((char *)&v54 + v24) * *(double *)((char *)&v54 + v24) * *(double *)(v15 + v22);
      *(double *)&v53[8 * v18] = v23;
      v24 += 24;
      v22 += 8;
      v21 += v13;
      v20 += v6;
    }
    while (v22 != 24);
    if (v23 <= 0.0) {
      break;
    }
    if (!v18)
    {
      int v44 = 0;
      for (uint64_t j = 0; j != 24; j += 8)
      {
        *(void *)(v14 + 8 * v44) = *(void *)&v53[j];
        v44 += v13;
      }
      return v23 > 0.0;
    }
    uint64_t v26 = 0;
    uint64_t v27 = v18 * *(int *)(a1 + 1068);
    uint64_t v28 = *(void *)(a1 + 1080);
    uint64_t v29 = 5;
    do
    {
      int v30 = 0;
      int v31 = 0;
      uint64_t v32 = 0;
      double v33 = 0.0;
      int v34 = &v54;
      do
      {
        double v33 = v33
            + *(double *)(v17 + 8 * (v26 + v30)) * *(double *)(v14 + 8 * v31) * *(double *)(v17 + 8 * (v18 + v30))
            + *(double *)&v34[v29] * *(double *)(v15 + v32) * *(double *)&v34[i];
        v34 += 3;
        v32 += 8;
        v31 += v13;
        v30 += v16;
      }
      while (v32 != 24);
      uint64_t v35 = v26 + v27;
      *(double *)(v28 + 8 * (v26 + v27)) = v33 / *(double *)&v53[8 * v18];
      int v36 = &v54;
      uint64_t v37 = v17;
      uint64_t v38 = 3;
      do
      {
        *(double *)(v37 + v29 * 8 - 40) = *(double *)(v37 + v29 * 8 - 40)
                                        - *(double *)(v28 + 8 * v35) * *(double *)(v37 + i * 8 - 40);
        *(double *)&v36[v29] = *(double *)&v36[v29] - *(double *)(v28 + 8 * v35) * *(double *)&v36[i];
        v36 += 3;
        v37 += 8 * v16;
        --v38;
      }
      while (v38);
      ++v26;
      ++v29;
    }
    while (v26 != v18);
    --v18;
  }
  if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) <= 1)
  {
    __int16 v48 = 12;
    unsigned __int8 v47 = 1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v48, &v47, "D(%d) <= 0, matrix ! positive definite", v39, v40, v41, v42, v43, v18);
  }
  return v23 > 0.0;
}

uint64_t raven::RavenDeviceAttitudeActiveObject::UDFactor3x3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = *(int *)(a2 + 20);
  uint64_t v6 = *(void *)(a2 + 32);
  uint64_t v7 = 3;
  uint64_t v8 = 2;
  do
  {
    uint64_t v9 = 0;
    unint64_t v10 = v8;
    uint64_t v11 = v8 * v5;
    uint64_t v12 = *(int *)(a3 + 20);
    uint64_t v13 = *(void *)(a3 + 32);
    int v14 = *(_DWORD *)(a4 + 20) + 1;
    uint64_t v15 = *(void *)(a4 + 32);
    uint64_t v16 = v14 * (int)v10;
    int v17 = v12 * v10;
    uint64_t v18 = (double *)(v13 + 8 * (v10 + v7 * v12));
    uint64_t v19 = 8 * v12;
    int64_t v20 = v10;
    do
    {
      double v21 = *(double *)(v6 + 8 * (v11 + v20));
      uint64_t v22 = v18;
      int v23 = v7 * v14;
      uint64_t v24 = v4;
      uint64_t v8 = v10 - 1;
      if (v10 <= 1)
      {
        do
        {
          double v21 = v21 + -(v22[v9] * *(double *)(v15 + 8 * v23)) * *v22;
          v23 += v14;
          uint64_t v22 = (double *)((char *)v22 + v19);
          --v24;
        }
        while (v24);
      }
      if (v10 == v20)
      {
        *(double *)(v15 + 8 * v16) = v21;
        *(void *)(v13 + 8 * ((int)v10 + v17)) = 0x3FF0000000000000;
      }
      else
      {
        *(double *)(v13 + 8 * (v17 + (int)v20)) = v21 / *(double *)(v15 + 8 * v16);
      }
      --v9;
    }
    while (v20-- > 0);
    --v7;
    ++v4;
  }
  while (v10);
  return 1;
}

void raven::RavenDeviceAttitudeActiveObject::UpdateDeviceAttitudeByLinearAcceleration(raven::RavenDeviceAttitudeActiveObject *this, const raven::TimeMarkEvent *a2)
{
  MEMORY[0x1F4188790](this);
  uint64_t v4 = (unsigned char *)(v2 + 6976);
  if (*(unsigned char *)(v2 + 8400))
  {
    uint64_t v5 = v3;
    uint64_t v6 = v2;
    uint64_t v7 = (void *)(v2 + 6904);
    BOOL v8 = sub_18E16A5E4(v2, (void *)(v2 + 6904), 0.0);
    if (v8 && (BOOL v8 = sub_18E16A5E4(v6, (void *)(v6 + 496), 0.0)) && (BOOL v8 = sub_18E16A788(v6, (void *)(v6 + 7824))))
    {
      if (raven::RavenDeviceAttitudeActiveObject::IsMovementStraight((raven::RavenDeviceAttitudeActiveObject *)v6)
        && raven::RavenDeviceAttitudeActiveObject::IsDecelerationToStop((raven::RavenDeviceAttitudeActiveObject *)v6))
      {
        uint64_t v165 = 0x100000003;
        uint64_t v163 = &unk_1EDD18D98;
        __n128 v10 = (__n128)xmmword_18E1F6F60;
        long long v164 = xmmword_18E1F6F60;
        uint64_t v166 = v167;
        unint64_t v11 = *(void *)(v6 + 528);
        unint64_t v12 = v11 + *(void *)(v6 + 536);
        uint64_t v13 = *(void *)(v6 + 504);
        int v14 = (void *)(*(void *)(v13 + 8 * ((v12 - 1) / 0x1A)) + 152 * ((v12 - 1) % 0x1A));
        v167[0] = v14[13];
        v167[1] = v14[14];
        v167[2] = v14[15];
        uint64_t v161 = 0;
        uint64_t v162 = 0;
        uint64_t v158 = 0x100000003;
        double v156 = &unk_1EDD18D98;
        long long v157 = xmmword_18E1F6F60;
        uint64_t v159 = &v160;
        if (*(void *)(v6 + 512) == v13
          || (uint64_t v15 = (void *)(*(void *)(v13 + 8 * (v11 / 0x1A)) + 152 * (v11 % 0x1A)),
              unint64_t v102 = *(void *)(v13 + 8 * (v12 / 0x1A)) + 152 * (v12 % 0x1A),
              v15 == (void *)v102))
        {
          double v17 = -INFINITY;
        }
        else
        {
          uint64_t v16 = (void *)(v13 + 8 * (v11 / 0x1A));
          double v17 = -INFINITY;
          do
          {
            uint64_t v18 = v159;
            uint64_t *v159 = v15[13];
            v18[1] = v15[14];
            v18[2] = v15[15];
            uint64_t v110 = 0x100000003;
            uint64_t v108 = &unk_1EDD18D98;
            __n128 v109 = v10;
            long long v111 = &v112;
            sub_18DFE2AA8((uint64_t)&v156, (uint64_t)&v163, (uint64_t)&v108);
            uint64_t v105 = 0x100000003;
            *(void *)long long v104 = &unk_1EDD18D98;
            *(_OWORD *)&v104[8] = xmmword_18E1F6F60;
            int64x2_t v106 = (uint64_t *)v107;
            *(void *)&v168[24] = 0x100000134;
            *(void *)double v168 = &unk_1EDD18C48;
            *(_OWORD *)&v168[8] = xmmword_18E1F6FB0;
            *(void *)&v168[32] = v169;
            uint64_t v115 = 0x100000003;
            uint64_t v113 = &unk_1EDD18D98;
            long long v114 = xmmword_18E1F6F60;
            uint64_t v116 = v117;
            sub_18DFE345C((uint64_t)&v108, (uint64_t)v104, (uint64_t)v168, (uint64_t)&v113, "2");
            double v20 = v19;
            if (v19 > v17)
            {
              uint64_t v161 = (*(uint64_t (**)(void *))(*v15 + 16))(v15);
              uint64_t v162 = v21;
              double v17 = v20;
            }
            v15 += 19;
            __n128 v10 = (__n128)xmmword_18E1F6F60;
            if ((void *)((char *)v15 - *v16) == (void *)3952)
            {
              uint64_t v22 = (void *)v16[1];
              ++v16;
              uint64_t v15 = v22;
            }
          }
          while (v15 != (void *)v102);
        }
        if (v17 >= *(double *)(*(void *)(v6 + 488) + 1064))
        {
          __n128 v103 = v10;
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404BB8, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EB404BB8))
          {
            qword_1EB404BE8 = 1;
            unk_1EB404BF0 = 0;
            __cxa_guard_release(&qword_1EB404BB8);
          }
          v153[0] = 0;
          long long v154 = 0u;
          memset(v155, 0, sizeof(v155));
          v150[0] = 0;
          long long v151 = 0u;
          memset(v152, 0, sizeof(v152));
          v147[0] = 0;
          long long v148 = 0u;
          memset(v149, 0, sizeof(v149));
          __n128 v31 = 0uLL;
          uint64_t v32 = *(void *)(v6 + 504);
          if (*(void *)(v6 + 512) == v32)
          {
            v10.n128_u64[0] = 0;
            v9.n128_u64[0] = 0;
          }
          else
          {
            unint64_t v33 = *(void *)(v6 + 528);
            int v34 = (double *)(*(void *)(v32 + 8 * (v33 / 0x1A)) + 152 * (v33 % 0x1A));
            unint64_t v35 = *(void *)(v32 + 8 * ((*(void *)(v6 + 536) + v33) / 0x1A))
                + 152 * ((*(void *)(v6 + 536) + v33) % 0x1A);
            v10.n128_u64[0] = 0;
            v9.n128_u64[0] = 0;
            if (v34 != (double *)v35)
            {
              int v36 = (void *)(v32 + 8 * (v33 / 0x1A));
              do
              {
                uint64_t v113 = (void *)(*(uint64_t (**)(double *, __n128, __n128, __n128))(*(void *)v34 + 16))(v34, v31, v10, v9);
                *(void *)&long long v114 = v37;
                *(double *)v40.i64 = (double)CNTimeSpan::operator-((uint64_t)&v113, &v161, v38, v39);
                *(double *)v42.i64 = fabs(v41 + *(double *)v40.i64);
                *(void *)double v168 = 0;
                *(void *)&v168[8] = 0;
                CNTimeSpan::SetTimeSpan((uint64_t *)v168, 0, v42, v40);
                *(_OWORD *)long long v104 = *(_OWORD *)v168;
                if (sub_18DEE4CB8((double *)v104, (double *)&qword_1EB404BE8))
                {
                  sub_18DFF11E4((uint64_t)v153, v34 + 13, 1.0);
                  sub_18DFF11E4((uint64_t)v150, v34 + 14, 1.0);
                  sub_18DFF11E4((uint64_t)v147, v34 + 15, 1.0);
                }
                v34 += 19;
                if ((double *)((char *)v34 - *v36) == (double *)3952)
                {
                  uint64_t v43 = (double *)v36[1];
                  ++v36;
                  int v34 = v43;
                }
              }
              while (v34 != (double *)v35);
              v9.n128_u64[0] = *(void *)&v155[1];
              v10.n128_u64[0] = *(void *)&v152[1];
              v31.n128_u64[0] = *(void *)&v149[1];
            }
          }
          uint64_t v144 = 0x100000003;
          uint64_t v142 = &unk_1EDD18D98;
          __n128 v143 = v103;
          uint64_t v145 = v146;
          v146[0] = v9.n128_u64[0];
          v146[1] = v10.n128_u64[0];
          void v146[2] = v31.n128_u64[0];
          sub_18E01E318((uint64_t)&v142, (uint64_t)&v163, (uint64_t)v168);
          sub_18DFE2F24((uint64_t)&v142, (uint64_t)v168);
          sub_18E03017C((uint64_t)&v142);
          double v45 = v44;
          if (fabs(v44) > 0.000000015)
          {
            uint64_t v139 = 0x100000003;
            double v137 = &unk_1EDD18D98;
            __n128 v138 = v103;
            unint64_t v140 = (double *)&v141;
            uint64_t v46 = *(void *)(v6 + 7832);
            if (*(void *)(v6 + 7840) == v46
              || (unint64_t v47 = *(void *)(v6 + 7856),
                  __int16 v48 = (void *)(v46 + 8 * (v47 >> 4)),
                  uint64_t v49 = (double *)(*v48 + 2432 * (v47 & 0xF)),
                  uint64_t v50 = *(void *)(v46 + (((*(void *)(v6 + 7864) + v47) >> 1) & 0x7FFFFFFFFFFFFFF8))
                      + 2432 * ((*(_DWORD *)(v6 + 7864) + v47) & 0xF),
                  v49 == (double *)v50))
            {
              double v51 = 0.0;
            }
            else
            {
              double v51 = 0.0;
              double v52 = -INFINITY;
              do
              {
                double v53 = v49[194];
                double v54 = v49[195] * v49[195] + v53 * v53 + v49[196] * v49[196];
                if (v52 < v54)
                {
                  long long v55 = v140;
                  *unint64_t v140 = -v53;
                  v55[1] = -v49[195];
                  v55[2] = -v49[196];
                  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404BC8, memory_order_acquire) & 1) == 0)
                  {
                    double v57 = v54;
                    int v58 = __cxa_guard_acquire(&qword_1EB404BC8);
                    double v54 = v57;
                    if (v58)
                    {
                      *(double *)&qword_1EB404BC0 = *(double *)(*(void *)(v6 + 488) + 1176)
                                                  * 0.0174532925
                                                  * (*(double *)(*(void *)(v6 + 488) + 1176)
                                                   * 0.0174532925);
                      __cxa_guard_release(&qword_1EB404BC8);
                      double v54 = v57;
                    }
                  }
                  if (*(double *)&qword_1EB404BC0 >= (v49[197] + v49[200] + v49[202]) / v54) {
                    double v51 = (v49[197] + v49[200] + v49[202]) / v54;
                  }
                  else {
                    double v51 = *(double *)&qword_1EB404BC0;
                  }
                  double v52 = v54;
                }
                v49 += 304;
                if ((double *)((char *)v49 - *v48) == (double *)38912)
                {
                  uint64_t v56 = (double *)v48[1];
                  ++v48;
                  uint64_t v49 = v56;
                }
              }
              while (v49 != (double *)v50);
            }
            sub_18E03017C((uint64_t)&v137);
            double v60 = v59;
            if (fabs(v59) > 0.000000015)
            {
              sub_18DFEB188(3, 1, (uint64_t)v135);
              *(void *)(v136 + 8) = 0xBFF0000000000000;
              sub_18DFEB188(3, 1, (uint64_t)v134);
              sub_18DFEB188(3, 1, (uint64_t)v133);
              double v132 = -1.0;
              sub_18DFEB188(3, 1, (uint64_t)v130);
              unint64_t v61 = *(void *)(v6 + 7864) + *(void *)(v6 + 7856) - 1;
              BOOL v62 = (void *)(*(void *)(*(void *)(v6 + 7832) + ((v61 >> 1) & 0x7FFFFFFFFFFFFFF8))
                             + 2432 * (v61 & 0xF));
              unint64_t v63 = v131;
              *uint64_t v131 = v62[184];
              v63[1] = v62[185];
              v63[2] = v62[186];
              if (raven::RavenDeviceAttitudeActiveObject::DeriveGravityVectorInEcefAndBody(v6, (uint64_t)v130, (uint64_t)v134, (uint64_t)v133, &v132))
              {
                uint64_t v64 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
                double v66 = v65;
                sub_18E03017C((uint64_t)v134);
                v68.f64[0] = 1.0 / v67;
                sub_18E053C38((uint64_t)v134, (uint64_t)v128, v68);
                v69.f64[0] = 1.0 / v60;
                sub_18E053C38((uint64_t)&v137, (uint64_t)v125, v69);
                uint64_t v70 = v126;
                if (v126 < 1)
                {
                  double v72 = 0.0;
                }
                else
                {
                  long long v71 = v127;
                  double v72 = 0.0;
                  uint64_t v73 = v129;
                  do
                  {
                    double v74 = *v71++;
                    double v75 = v74;
                    double v76 = *v73++;
                    double v72 = v72 + v75 * v76;
                    --v70;
                  }
                  while (v70);
                }
                double v77 = acos(v72);
                sub_18E03017C((uint64_t)v133);
                v79.f64[0] = 1.0 / v78;
                sub_18E053C38((uint64_t)v133, (uint64_t)v123, v79);
                v80.f64[0] = 1.0 / v45;
                sub_18E053C38((uint64_t)&v142, (uint64_t)v120, v80);
                uint64_t v81 = v121;
                if (v121 < 1)
                {
                  double v83 = 0.0;
                }
                else
                {
                  unint64_t v82 = v122;
                  double v83 = 0.0;
                  uint64_t v84 = v124;
                  do
                  {
                    double v85 = *v82++;
                    double v86 = v85;
                    double v87 = *v84++;
                    double v83 = v83 + v86 * v87;
                    --v81;
                  }
                  while (v81);
                }
                double v88 = vabdd_f64(v77, acos(v83));
                double v89 = sqrt(v51 + v88 * 0.5 * (v88 * 0.5));
                long long v118 = 0uLL;
                *(void *)&long long v119 = 0;
                *((void *)&v119 + 1) = 0x3FF0000000000000;
                uint64_t v115 = 0x300000003;
                uint64_t v113 = &unk_1EDD18EE8;
                long long v114 = xmmword_18E1F0010;
                uint64_t v116 = v117;
                if (raven::RavenDeviceAttitudeActiveObject::AttitudeViaTwoVectors(v90))
                {
                  cnrotation::CNRotation::RotationMatrix((cnrotation::CNRotation *)&v118, (uint64_t)&v108);
                  if (cnprint::CNPrinter::GetLogLevel(v91) <= 1)
                  {
                    *(_WORD *)double v168 = 12;
                    v104[0] = 1;
                    double v101 = v66 + (double)v64;
                    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v168, v104, "DevAtt,deviceEcefAttitude,t,%lf,type,%hu,Rb2e,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,Pb2e,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,%.6lf,aEcefX,%.3lf,aEcefY,%.3lf,aEcefZ,%.3lf,aBodyX,%.3lf,aBodyY,%.3lf,aBodyZ,%.3lf,aUnc,%.3lf,gEcefX,%.3lf,gEcefY,%.3lf,gEcefZ,%.3lf,gBodyX,%.3lf,gBodyY,%.3lf,gBodyZ,%.3lf,gUnc,%.3lf", v92, v93, v94, v95, v96, SLOBYTE(v101));
                  }
                  *uint64_t v4 = 1;
                  if ((long long *)(v6 + 568) != &v118)
                  {
                    long long v97 = v119;
                    *(_OWORD *)(v6 + 568) = v118;
                    *(_OWORD *)(v6 + 584) = v97;
                  }
                  sub_18DFE2F24(v6 + 600, (uint64_t)&v113);
                  sub_18DFE2F24(v6 + 712, (uint64_t)v130);
                  *(void *)(v6 + 776) = v64;
                  *(double *)(v6 + 784) = v66;
                  uint64_t v105 = 0x400000004;
                  *(void *)long long v104 = &unk_1EDD195A8;
                  *(_OWORD *)&v104[8] = xmmword_18E1F6F70;
                  int64x2_t v106 = (uint64_t *)v107;
                  *(_OWORD *)double v168 = v118;
                  *(_OWORD *)&v168[16] = v119;
                  if (raven::RavenDeviceAttitudeActiveObject::convertRvVarToQuaternionVar(v98, (const cnquaternion::CNQuaternion *)v168, (uint64_t)&v113, (uint64_t)v104))
                  {
                    sub_18E16A8FC((uint64_t)v168);
                    memset(v169, 0, sizeof(v169));
                    *(_OWORD *)&v168[24] = 0u;
                    long long v172 = v118;
                    *(void *)&v168[8] = v64;
                    *(double *)&v168[16] = v66;
                    uint64_t v170 = 0;
                    uint64_t v171 = 0x7FF8000000000000;
                    long long v173 = v119;
                    uint64_t v174 = *v106;
                    uint64_t v175 = v106[*(int *)&v104[20]];
                    uint64_t v176 = v106[2 * *(int *)&v104[20]];
                    uint64_t v177 = v106[3 * *(_DWORD *)&v104[20]];
                    uint64_t v178 = v106[*(_DWORD *)&v104[20] + 1];
                    double v99 = &v106[2 * *(_DWORD *)&v104[20]];
                    uint64_t v179 = v99[1];
                    uint64_t v180 = v106[3 * *(_DWORD *)&v104[20] + 1];
                    uint64_t v181 = v99[2];
                    uint64_t v182 = v106[3 * *(_DWORD *)&v104[20] + 2];
                    uint64_t v183 = v106[3 * *(_DWORD *)&v104[20] + 3];
                    char v184 = 1;
                    sub_18E0CF124();
                  }
                }
                *(void *)double v168 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
                *(void *)&v168[8] = v100;
                raven::RavenDeviceAttitudeActiveObject::UpdateDeviceVehicleAttitude(v6, (uint64_t)&v142, (uint64_t)v135, (uint64_t)v168, v89);
              }
              sub_18E16A968((void *)(v6 + 496));
            }
          }
        }
      }
    }
    else if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v8) <= 1)
    {
      *(_WORD *)double v168 = 12;
      v104[0] = 1;
      uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
      double v25 = v24 + (double)v23;
      sub_18E16A5E4(v6, v7, 0.0);
      sub_18E16A5E4(v6, (void *)(v6 + 496), 0.0);
      sub_18E16A788(v6, (void *)(v6 + 7824));
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v168, v104, "DevAtt,IsManeuverDetectionBufferFull,t,%lf,%d,%d,%d", v26, v27, v28, v29, v30, SLOBYTE(v25));
    }
  }
}

BOOL sub_18E16A5E4(uint64_t a1, void *a2, double a3)
{
  uint64_t v3 = a2[5];
  if (!v3) {
    return 0;
  }
  unint64_t v7 = *(void *)(a2[1] + 8 * ((v3 + a2[4] - 1) / 0x1AuLL)) + 152 * ((v3 + a2[4] - 1) % 0x1AuLL);
  uint64_t v8 = (*(uint64_t (**)(unint64_t))(*(void *)v7 + 16))(v7);
  double v10 = v9;
  double v11 = v9;
  unint64_t v12 = *(void *)(a2[1] + 8 * (a2[4] / 0x1AuLL)) + 152 * (a2[4] % 0x1AuLL);
  v30[0] = (*(uint64_t (**)(unint64_t))(*(void *)v12 + 16))(v12);
  v30[1] = v13;
  v14.i64[0] = *(void *)(*(void *)(a1 + 488) + 1048);
  v28[0] = 0;
  v28[1] = 0;
  CNTimeSpan::SetTimeSpan(v28, 0, v14, v15);
  v29[0] = CNTimeSpan::operator+((uint64_t)v30, v28, v16, v17);
  v29[1] = v18;
  v27[0] = 0;
  v27[1] = 0;
  *(double *)v19.i64 = a3;
  CNTimeSpan::SetTimeSpan(v27, 0, v19, v20);
  uint64_t v23 = CNTimeSpan::operator+((uint64_t)v29, v27, v21, v22);
  if (v8) {
    BOOL v25 = 1;
  }
  else {
    BOOL v25 = (*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
  }
  if (!v25 || !v23 && (*(void *)&v24 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
    return v11 > v24;
  }
  if (v8 == v23) {
    return v11 > v24;
  }
  return v8 > v23;
}

BOOL sub_18E16A788(uint64_t a1, void *a2)
{
  uint64_t v2 = a2[5];
  if (!v2) {
    return 0;
  }
  uint64_t v5 = *(void *)(a2[1] + (((unint64_t)(v2 + a2[4] - 1) >> 1) & 0x7FFFFFFFFFFFFFF8))
     + 2432 * ((v2 + *((_DWORD *)a2 + 8) - 1) & 0xF);
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
  double v8 = v7;
  double v9 = v7;
  uint64_t v10 = *(void *)(a2[1] + ((a2[4] >> 1) & 0x7FFFFFFFFFFFFFF8)) + 2432 * (a2[4] & 0xFLL);
  v26[0] = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
  v26[1] = v11;
  v12.i64[0] = *(void *)(*(void *)(a1 + 488) + 1048);
  v24[0] = 0;
  v24[1] = 0;
  CNTimeSpan::SetTimeSpan(v24, 0, v12, v13);
  v25[0] = CNTimeSpan::operator+((uint64_t)v26, v24, v14, v15);
  v25[1] = v16;
  v23[0] = 0;
  v23[1] = 0;
  uint64_t v19 = CNTimeSpan::operator+((uint64_t)v25, v23, v17, v18);
  if (v6) {
    BOOL v21 = 1;
  }
  else {
    BOOL v21 = (*(void *)&v8 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
  }
  if (!v21 || !v19 && (*(void *)&v20 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
    return v9 > v20;
  }
  if (v6 == v19) {
    return v9 > v20;
  }
  return v6 > v19;
}

double sub_18E16A8FC(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EDD13760;
  *(unsigned char *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0x7FF8000000000000;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  double result = 1.0;
  int64x2_t v2 = vdupq_n_s64(0x7FF8000000000000uLL);
  *(_OWORD *)(a1 + 128) = xmmword_18E200CD0;
  *(int64x2_t *)(a1 + 144) = v2;
  *(int64x2_t *)(a1 + 160) = v2;
  *(int64x2_t *)(a1 + 176) = v2;
  *(int64x2_t *)(a1 + 192) = v2;
  *(void *)(a1 + 208) = 0x7FF8000000000000;
  *(_WORD *)(a1 + 216) = 1;
  return result;
}

void sub_18E16A968(void *a1)
{
  int64x2_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    uint64_t v4 = a1 + 5;
    uint64_t v3 = (void **)a1[1];
  }
  else
  {
    uint64_t v4 = a1 + 5;
    unint64_t v5 = a1[4];
    uint64_t v6 = &v2[v5 / 0x1A];
    unint64_t v7 = (unint64_t)v2[(a1[5] + v5) / 0x1A] + 152 * ((a1[5] + v5) % 0x1A);
    if ((char *)*v6 + 152 * (v5 % 0x1A) != (void *)v7)
    {
      double v8 = (void (***)(void))((char *)*v6 + 152 * (v5 % 0x1A));
      do
      {
        double v9 = *v8;
        v8 += 19;
        (*v9)();
        if ((char *)v8 - (unsigned char *)*v6 == 3952)
        {
          uint64_t v10 = (void (***)(void))v6[1];
          ++v6;
          double v8 = v10;
        }
      }
      while (v8 != (void (***)(void))v7);
      int64x2_t v2 = (void **)a1[1];
      uint64_t v3 = (void **)a1[2];
    }
  }
  *uint64_t v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if (v11 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v12 = a1[2];
      int64x2_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v11 = v12 - (void)v2;
    }
    while (v11 > 0x10);
  }
  if (v11 >> 3 == 1)
  {
    uint64_t v13 = 13;
  }
  else
  {
    if (v11 >> 3 != 2) {
      return;
    }
    uint64_t v13 = 26;
  }
  a1[4] = v13;
}

void raven::RavenDeviceAttitudeActiveObject::UpdateDeviceAttitudeByWahbaSolution(raven::RavenDeviceAttitudeActiveObject *this, const raven::TimeMarkEvent *a2)
{
  v374[10] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 983);
  if (v2)
  {
    unint64_t v4 = v2 + *((void *)this + 982) - 1;
    uint64_t v5 = *(void *)(*((void *)this + 979) + ((v4 >> 1) & 0x7FFFFFFFFFFFFFF8));
    unsigned int v6 = v4 & 0xF;
    if (*(unsigned char *)(v5 + 2432 * v6 + 209) == 2
      && *(unsigned char *)(v5 + 2432 * v6 + 1464)
      && *(unsigned char *)(v5 + 2432 * v6 + 1544))
    {
      double v8 = (unsigned __int8 *)this + 7088;
      *((_WORD *)this + 4172) = 1;
      *(void *)&long long v343 = (*(uint64_t (**)(const raven::TimeMarkEvent *))(*(void *)a2 + 16))(a2);
      *((void *)&v343 + 1) = v9;
      unint64_t v10 = *((void *)this + 983) + *((void *)this + 982) - 1;
      uint64_t v11 = *(void *)(*((void *)this + 979) + ((v10 >> 1) & 0x7FFFFFFFFFFFFFF8));
      unsigned int v12 = v10 & 0xF;
      uint64_t v15 = CNTimeSpan::operator-((uint64_t)&v343, (void *)this + 938, v13, v14);
      double v17 = v16;
      unsigned int v269 = v12;
      uint64_t v272 = v11;
      int8x16_t v18 = (double *)(v11 + 2432 * v12);
      double v19 = v18[194];
      double v20 = v18[195];
      double v21 = v18[196];
      *(double *)&unint64_t v22 = v18[197] + v18[200];
      double v23 = *(double *)&v22 + v18[202];
      uint64_t v24 = *((void *)this + 61);
      LODWORD(v22) = *(_DWORD *)(v24 + 984);
      unint64_t v25 = vcvtpd_u64_f64(*(double *)(v24 + 648) * (double)v22) + 1;
      unint64_t v26 = *((void *)this + 1049);
      if (v26 >= v25)
      {
        unint64_t v27 = *((void *)this + 1048);
        do
        {
          *((void *)this + 1049) = --v26;
          *((void *)this + 1048) = ++v27;
          if (v27 >= 0x100)
          {
            operator delete(**((void ***)this + 1045));
            *((void *)this + 1045) += 8;
            unint64_t v27 = *((void *)this + 1048) - 128;
            *((void *)this + 1048) = v27;
            unint64_t v26 = *((void *)this + 1049);
          }
        }
        while (v26 >= v25);
      }
      *(void *)&v342[0] = (*(uint64_t (**)(const raven::TimeMarkEvent *))(*(void *)a2 + 16))(a2);
      v342[1] = v29;
      if (v23 > 0.0)
      {
        uint64_t v30 = *((void *)this + 1049);
        if (!v30
          || sub_18DEE4C00(v342, (double *)(*(void *)(*((void *)this + 1045)+ (((unint64_t)(v30 + *((void *)this + 1048) - 1) >> 4) & 0xFFFFFFFFFFFFFF8))+ 32 * ((v30 + *((void *)this + 1048) - 1) & 0x7F))))
        {
          double v268 = v17;
          uint64_t v273 = v15;
          uint64_t v31 = (*(uint64_t (**)(const raven::TimeMarkEvent *))(*(void *)a2 + 16))(a2);
          uint64_t v266 = v32;
          uint64_t v267 = v31;
          double v8 = (unsigned __int8 *)this + 7088;
          v265 = (char **)((char *)this + 8360);
          unint64_t v33 = (char *)*((void *)this + 1046);
          int v34 = (char *)*((void *)this + 1045);
          uint64_t v35 = v33 - v34;
          if (v33 == v34) {
            uint64_t v36 = 0;
          }
          else {
            uint64_t v36 = 16 * (v33 - v34) - 1;
          }
          unint64_t v37 = *((void *)this + 1048);
          uint64_t v38 = *((void *)this + 1049);
          unint64_t v39 = v38 + v37;
          if (v36 == v38 + v37)
          {
            if (v37 < 0x80)
            {
              uint64_t v54 = v35 >> 3;
              long long v55 = (char *)*((void *)this + 1047);
              uint64_t v56 = (char *)*((void *)this + 1044);
              if (v35 >> 3 >= (unint64_t)((v55 - v56) >> 3))
              {
                if (v55 == v56) {
                  unint64_t v59 = 1;
                }
                else {
                  unint64_t v59 = (v55 - v56) >> 2;
                }
                double v60 = (char *)sub_18DEE2FBC(v59);
                uint64_t v62 = v61;
                unint64_t v63 = operator new(0x1000uLL);
                uint64_t v64 = &v60[8 * v54];
                uint64_t v65 = v62;
                double v66 = &v60[8 * v62];
                if (v54 == v65)
                {
                  uint64_t v67 = 8 * v54;
                  if (v35 < 1)
                  {
                    uint64_t v105 = v63;
                    uint64_t v106 = v67 >> 2;
                    if (v33 == v34) {
                      unint64_t v107 = 1;
                    }
                    else {
                      unint64_t v107 = v106;
                    }
                    uint64_t v108 = (char *)sub_18DEE2FBC(v107);
                    uint64_t v64 = &v108[8 * (v107 >> 2)];
                    double v66 = &v108[8 * v109];
                    if (v60) {
                      operator delete(v60);
                    }
                    double v60 = v108;
                    unint64_t v63 = v105;
                  }
                  else
                  {
                    uint64_t v68 = v67 >> 3;
                    if (v68 >= -1) {
                      unint64_t v69 = v68 + 1;
                    }
                    else {
                      unint64_t v69 = v68 + 2;
                    }
                    v64 -= 8 * (v69 >> 1);
                  }
                }
                *(void *)uint64_t v64 = v63;
                uint64_t v110 = v64 + 8;
                uint64_t v111 = *((void *)this + 1046);
                for (uint64_t i = (void *)((char *)this + 8360); v111 != *i; v64 -= 8)
                {
                  if (v64 == v60)
                  {
                    if (v110 >= v66)
                    {
                      if (v66 == v60) {
                        unint64_t v117 = 1;
                      }
                      else {
                        unint64_t v117 = (v66 - v60) >> 2;
                      }
                      long long v118 = (char *)sub_18DEE2FBC(v117);
                      long long v120 = v118;
                      uint64_t v64 = &v118[(2 * v117 + 6) & 0xFFFFFFFFFFFFFFF8];
                      uint64_t v121 = v110 - v60;
                      BOOL v70 = v110 == v60;
                      uint64_t v110 = v64;
                      if (!v70)
                      {
                        uint64_t v110 = &v64[v121 & 0xFFFFFFFFFFFFFFF8];
                        uint64_t v122 = 8 * (v121 >> 3);
                        long long v123 = &v118[(2 * v117 + 6) & 0xFFFFFFFFFFFFFFF8];
                        long long v124 = (uint64_t *)v60;
                        do
                        {
                          uint64_t v125 = *v124++;
                          *(void *)long long v123 = v125;
                          v123 += 8;
                          v122 -= 8;
                        }
                        while (v122);
                      }
                      double v66 = &v118[8 * v119];
                      if (v60) {
                        operator delete(v60);
                      }
                      double v60 = v120;
                      uint64_t i = (void *)((char *)this + 8360);
                    }
                    else
                    {
                      uint64_t v113 = (v66 - v110) >> 3;
                      if (v113 >= -1) {
                        uint64_t v114 = v113 + 1;
                      }
                      else {
                        uint64_t v114 = v113 + 2;
                      }
                      uint64_t v115 = v114 >> 1;
                      uint64_t v64 = &v60[8 * (v114 >> 1)];
                      uint64_t v116 = v60;
                      if (v110 != v60)
                      {
                        memmove(v64, v60, v110 - v60);
                        uint64_t v116 = v110;
                      }
                      uint64_t v110 = &v116[8 * v115];
                    }
                  }
                  uint64_t v126 = *(void *)(v111 - 8);
                  v111 -= 8;
                  *((void *)v64 - 1) = v126;
                }
                long long v127 = (void *)*((void *)this + 1044);
                *((void *)this + 1044) = v60;
                *((void *)this + 1045) = v64;
                *((void *)this + 1046) = v110;
                *((void *)this + 1047) = v66;
                double v8 = (unsigned __int8 *)this + 7088;
                uint64_t v15 = v273;
                double v17 = v268;
                if (v127) {
                  operator delete(v127);
                }
              }
              else
              {
                double v57 = operator new(0x1000uLL);
                int v58 = v57;
                if (v55 == v33)
                {
                  if (v34 == v56)
                  {
                    if (v33 == v34) {
                      unint64_t v83 = 1;
                    }
                    else {
                      unint64_t v83 = (v55 - v34) >> 2;
                    }
                    uint64_t v84 = (char *)sub_18DEE2FBC(v83);
                    int v34 = &v84[8 * ((v83 + 3) >> 2)];
                    double v86 = (uint64_t *)*((void *)this + 1045);
                    double v87 = v34;
                    uint64_t v88 = *((void *)this + 1046) - (void)v86;
                    if (v88)
                    {
                      double v87 = &v34[v88 & 0xFFFFFFFFFFFFFFF8];
                      uint64_t v89 = 8 * (v88 >> 3);
                      uint64_t v90 = &v84[8 * ((v83 + 3) >> 2)];
                      do
                      {
                        uint64_t v91 = *v86++;
                        *(void *)uint64_t v90 = v91;
                        v90 += 8;
                        v89 -= 8;
                      }
                      while (v89);
                    }
                    uint64_t v92 = (void *)*((void *)this + 1044);
                    *((void *)this + 1044) = v84;
                    *((void *)this + 1045) = v34;
                    *((void *)this + 1046) = v87;
                    *((void *)this + 1047) = &v84[8 * v85];
                    if (v92)
                    {
                      operator delete(v92);
                      int v34 = *v265;
                    }
                  }
                  *((void *)v34 - 1) = v58;
                  uint64_t v93 = (char *)*((void *)this + 1045);
                  *((void *)this + 1045) = v93 - 8;
                  uint64_t v94 = *((void *)v93 - 1);
                  *((void *)this + 1045) = v93;
                  uint64_t v95 = (char *)*((void *)this + 1046);
                  if (v95 == *((char **)this + 1047))
                  {
                    unint64_t v96 = *((void *)this + 1044);
                    uint64_t v97 = (uint64_t)&v93[-v96];
                    if ((unint64_t)v93 <= v96)
                    {
                      uint64_t v128 = (uint64_t)&v95[-v96];
                      BOOL v70 = v128 == 0;
                      uint64_t v129 = v128 >> 2;
                      if (v70) {
                        unint64_t v130 = 1;
                      }
                      else {
                        unint64_t v130 = v129;
                      }
                      uint64_t v131 = (char *)sub_18DEE2FBC(v130);
                      uint64_t v133 = &v131[8 * (v130 >> 2)];
                      unint64_t v134 = (uint64_t *)*((void *)this + 1045);
                      uint64_t v95 = v133;
                      uint64_t v135 = *((void *)this + 1046) - (void)v134;
                      if (v135)
                      {
                        uint64_t v95 = &v133[v135 & 0xFFFFFFFFFFFFFFF8];
                        uint64_t v136 = 8 * (v135 >> 3);
                        double v137 = &v131[8 * (v130 >> 2)];
                        do
                        {
                          uint64_t v138 = *v134++;
                          *(void *)double v137 = v138;
                          v137 += 8;
                          v136 -= 8;
                        }
                        while (v136);
                      }
                      uint64_t v139 = (void *)*((void *)this + 1044);
                      *((void *)this + 1044) = v131;
                      *((void *)this + 1045) = v133;
                      *((void *)this + 1046) = v95;
                      *((void *)this + 1047) = &v131[8 * v132];
                      if (v139)
                      {
                        operator delete(v139);
                        uint64_t v95 = (char *)*((void *)this + 1046);
                      }
                    }
                    else
                    {
                      uint64_t v98 = v97 >> 3;
                      BOOL v46 = v97 >> 3 < -1;
                      uint64_t v99 = (v97 >> 3) + 2;
                      if (v46) {
                        uint64_t v100 = v99;
                      }
                      else {
                        uint64_t v100 = v98 + 1;
                      }
                      uint64_t v101 = -(v100 >> 1);
                      uint64_t v102 = v100 >> 1;
                      __n128 v103 = &v93[-8 * v102];
                      int64_t v104 = v95 - v93;
                      if (v95 != v93)
                      {
                        memmove(&v93[-8 * v102], v93, v95 - v93);
                        uint64_t v93 = *v265;
                      }
                      uint64_t v95 = &v103[v104];
                      *((void *)this + 1046) = &v103[v104];
                      *((void *)this + 1045) = &v93[8 * v101];
                    }
                  }
                  *(void *)uint64_t v95 = v94;
                }
                else
                {
                  *(void *)unint64_t v33 = v57;
                }
                *((void *)this + 1046) += 8;
                double v8 = (unsigned __int8 *)this + 7088;
                uint64_t v15 = v273;
                double v17 = v268;
              }
            }
            else
            {
              *((void *)this + 1048) = v37 - 128;
              uint64_t v42 = *(void *)v34;
              double v41 = v34 + 8;
              uint64_t v40 = v42;
              *((void *)this + 1045) = v41;
              uint64_t v15 = v273;
              if (v33 == *((char **)this + 1047))
              {
                unint64_t v43 = *((void *)this + 1044);
                uint64_t v44 = (uint64_t)&v41[-v43];
                if ((unint64_t)v41 <= v43)
                {
                  uint64_t v71 = (uint64_t)&v33[-v43];
                  BOOL v70 = v71 == 0;
                  uint64_t v72 = v71 >> 2;
                  if (v70) {
                    unint64_t v73 = 1;
                  }
                  else {
                    unint64_t v73 = v72;
                  }
                  double v74 = (char *)sub_18DEE2FBC(v73);
                  double v76 = &v74[8 * (v73 >> 2)];
                  double v77 = (uint64_t *)*((void *)this + 1045);
                  unint64_t v33 = v76;
                  uint64_t v78 = *((void *)this + 1046) - (void)v77;
                  if (v78)
                  {
                    unint64_t v33 = &v76[v78 & 0xFFFFFFFFFFFFFFF8];
                    uint64_t v79 = 8 * (v78 >> 3);
                    float64x2_t v80 = &v74[8 * (v73 >> 2)];
                    do
                    {
                      uint64_t v81 = *v77++;
                      *(void *)float64x2_t v80 = v81;
                      v80 += 8;
                      v79 -= 8;
                    }
                    while (v79);
                  }
                  unint64_t v82 = (void *)*((void *)this + 1044);
                  *((void *)this + 1044) = v74;
                  *((void *)this + 1045) = v76;
                  *((void *)this + 1046) = v33;
                  *((void *)this + 1047) = &v74[8 * v75];
                  double v8 = (unsigned __int8 *)this + 7088;
                  uint64_t v15 = v273;
                  if (v82)
                  {
                    operator delete(v82);
                    unint64_t v33 = (char *)*((void *)this + 1046);
                  }
                }
                else
                {
                  uint64_t v45 = v44 >> 3;
                  BOOL v46 = v44 >> 3 < -1;
                  uint64_t v47 = (v44 >> 3) + 2;
                  if (v46) {
                    uint64_t v48 = v47;
                  }
                  else {
                    uint64_t v48 = v45 + 1;
                  }
                  uint64_t v49 = -(v48 >> 1);
                  uint64_t v50 = v48 >> 1;
                  double v51 = &v41[-8 * v50];
                  int64_t v52 = v33 - v41;
                  if (v33 != v41)
                  {
                    memmove(&v41[-8 * v50], v41, v33 - v41);
                    unint64_t v33 = *v265;
                  }
                  double v53 = &v33[8 * v49];
                  unint64_t v33 = &v51[v52];
                  *((void *)this + 1046) = &v51[v52];
                  *((void *)this + 1045) = v53;
                  double v8 = (unsigned __int8 *)this + 7088;
                  uint64_t v15 = v273;
                  double v17 = v268;
                }
              }
              *(void *)unint64_t v33 = v40;
              *((void *)this + 1046) += 8;
            }
            int v34 = (char *)*((void *)this + 1045);
            uint64_t v38 = *((void *)this + 1049);
            unint64_t v39 = v38 + *((void *)this + 1048);
          }
          else
          {
            uint64_t v15 = v273;
          }
          uint64_t v140 = *(void *)&v34[(v39 >> 4) & 0xFFFFFFFFFFFFFF8] + 32 * (v39 & 0x7F);
          *(void *)uint64_t v140 = v267;
          *(void *)(v140 + 8) = v266;
          *(double *)(v140 + 16) = sqrt(v20 * v20 + v19 * v19 + v21 * v21);
          *(double *)(v140 + 24) = v23;
          *((void *)this + 1049) = v38 + 1;
        }
      }
      v28.i64[0] = 0x3FEE666666666666;
      if (v17 + (double)v15 >= 0.95)
      {
        uint64_t v141 = *((void *)this + 61);
        if (*((void *)this + 1042) >= (unint64_t)*(unsigned int *)(v141 + 984))
        {
          double v142 = 1.0;
          v264 = v8;
          if (v8[88]
            && ((uint64_t v143 = *((void *)this + 1049), v144 = *v8, v144 > 7) || v144 == 5)
            && v143 >= 3)
          {
            unint64_t v203 = *((void *)this + 1048);
            uint64_t v204 = *((void *)this + 1045);
            uint64_t v205 = *(void *)(v204 + ((v203 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v203 & 0x7F);
            *(_OWORD *)v344 = *(_OWORD *)v205;
            double v206 = *(double *)(v205 + 16);
            uint64_t v207 = *(void *)(v204 + (((v203 + 1) >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * ((v203 + 1) & 0x7F);
            uint64_t v208 = CNTimeSpan::operator-(v207, (void *)v205, *(int8x16_t *)v344, v28);
            double v210 = v209 + (double)v208;
            double v211 = (*(double *)(v207 + 16) - v206) / v210;
            *(double *)v212.i64 = *(double *)(v207 + 24) + *(double *)(v205 + 24);
            double v213 = *(double *)v212.i64 / (v210 * v210);
            uint64_t v214 = v143 - 2;
            unint64_t v215 = v203 + 2;
            do
            {
              uint64_t v216 = *(void *)(v204 + ((v215 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v215 & 0x7F);
              *(_OWORD *)v371 = *(_OWORD *)v216;
              double v217 = *(double *)(v216 + 16);
              double v218 = *(double *)(v216 + 24);
              uint64_t v219 = CNTimeSpan::operator-((uint64_t)v371, v344, *(int8x16_t *)v371, v212);
              double v221 = v220 + (double)v219;
              *(double *)v212.i64 = v217 - (v206 + v221 * v211);
              double v222 = v213 * v221 / (v218 + v213 * v221 * v221);
              double v211 = v211 + v222 * *(double *)v212.i64;
              double v213 = v213 + -(v222 * v221) * v213;
              ++v215;
              --v214;
            }
            while (v214);
            uint64_t v223 = v143 - 1;
            unint64_t v224 = v203 + 1;
            double v225 = 0.0;
            do
            {
              uint64_t v226 = *(void *)(v204 + ((v224 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v224 & 0x7F);
              *(_OWORD *)v371 = *(_OWORD *)v226;
              double v227 = *(double *)(v226 + 16);
              double v228 = *(double *)(v226 + 24);
              long long v229 = (cnstatistics *)CNTimeSpan::operator-((uint64_t)v371, v344, *(int8x16_t *)v371, v212);
              *(double *)v212.i64 = (double)(uint64_t)v229;
              double v231 = v227 - (v206 + (v230 + (double)(uint64_t)v229) * v211);
              double v225 = v225 + v231 * v231 / v228;
              ++v224;
              --v223;
            }
            while (v223);
            cnstatistics::InverseChi2(v229, *(double *)(v141 + 912), (double)(v143 - 2));
            if (v225 <= v238)
            {
              if ((*(void *)&v211 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                || (*(void *)&v213 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                || v213 <= 0.0)
              {
                *(_WORD *)v371 = 12;
                LOBYTE(v366) = 4;
                cnprint::CNPrinter::Print((cnprint::CNPrinter *)v371, (unsigned __int8 *)&v366, "GNSS-derived acceleration,x,%.3lf,P,%.3lf", v233, v234, v235, v236, v237, SLOBYTE(v211));
                double v142 = 1.0;
              }
              else
              {
                double v256 = 0.0;
                if (v211 < 0.0) {
                  double v256 = -1.0;
                }
                if (v211 > 0.0) {
                  double v256 = 1.0;
                }
                double v142 = v256;
                v264[1256] = fabs(v211 / sqrt(v213)) > cnstatistics::InverseNormal(v232, (1.0 - *(double *)(*((void *)this + 61) + 912)) * -0.5+ 1.0, 0.0, 1.0);
                if (!cnprint::CNPrinter::GetLogLevel(v257))
                {
                  *(_WORD *)v371 = 12;
                  LOBYTE(v366) = 0;
                  cnprint::CNPrinter::Print((cnprint::CNPrinter *)v371, (unsigned __int8 *)&v366, "GNSS-derived acceleration result,reliable,%d,x,%.3lf,std,%.3lf,thresh,%.3lf", v258, v259, v260, v261, v262, v264[1256]);
                }
              }
            }
            else
            {
              double v142 = 1.0;
              if (cnprint::CNPrinter::GetLogLevel(v232) <= 1)
              {
                *(_WORD *)v371 = 12;
                LOBYTE(v366) = 1;
                cnprint::CNPrinter::Print((cnprint::CNPrinter *)v371, (unsigned __int8 *)&v366, "Failed SOS test when estimating slope,sos,%.3lf,threshold,%.3lf,dof,%u", v239, v240, v241, v242, v243, SLOBYTE(v225));
              }
            }
            int v263 = 1;
          }
          else
          {
            int v263 = 0;
          }
          uint64_t v338 = 0x100000003;
          long long v337 = xmmword_18E1F6F60;
          uint64_t v336 = &unk_1EDD18D98;
          v339 = &v340;
          uint64_t v145 = v272 + 2432 * v269;
          *(_OWORD *)v371 = *(_OWORD *)(v145 + 1472);
          *(void *)&v371[16] = *(void *)(v145 + 1488);
          v303 = 0;
          int v270 = sub_18E069F6C((uint64_t)this + 4168);
          long long v340 = v366;
          long long v341 = v367;
          uint64_t v333 = 0x100000003;
          long long v332 = xmmword_18E1F6F60;
          v331 = &unk_1EDD18D98;
          unint64_t v334 = v335;
          unint64_t v146 = *((void *)this + 1042) + *((void *)this + 1041) - 1;
          int v147 = (double *)(*(void *)(*((void *)this + 1038) + 8 * (v146 / 0x14)) + 200 * (v146 % 0x14));
          v335[0] = -v147[13];
          v335[1] = -v147[14];
          v335[2] = -v147[15];
          uint64_t v328 = 0x100000003;
          long long v327 = xmmword_18E1F6F60;
          int v326 = &unk_1EDD18D98;
          int v329 = (double *)v330;
          uint64_t v372 = 0x300000003;
          *(void *)v371 = &unk_1EDD18EE8;
          v373 = v374;
          *(_OWORD *)&v371[8] = xmmword_18E1F0010;
          sub_18DFE2CC8((uint64_t)v371, 0.0);
          *(double *)uint64_t v330 = v18[194];
          *(double *)&v330[1] = v18[195];
          *(double *)&v330[2] = v18[196];
          long long v148 = v373;
          void *v373 = *((void *)v18 + 197);
          int v149 = *(_DWORD *)&v371[20];
          v148[*(_DWORD *)&v371[20] + 1] = *((void *)v18 + 200);
          v148[2 * v149 + 2] = *((void *)v18 + 202);
          uint64_t v368 = 0x100000003;
          long long v367 = xmmword_18E1F6F60;
          unsigned int v366 = &unk_1EDD18D98;
          unsigned int v369 = v370;
          *(void *)&long long v345 = 0x100000134;
          *(_OWORD *)&v344[8] = xmmword_18E1F6FB0;
          *(void *)v344 = &unk_1EDD18C48;
          *((void *)&v345 + 1) = &v346;
          uint64_t v305 = 0x100000003;
          long long v304 = xmmword_18E1F6F60;
          v303 = &unk_1EDD18D98;
          long long v306 = v307;
          sub_18DFE345C((uint64_t)&v326, (uint64_t)&v366, (uint64_t)v344, (uint64_t)&v303, "2");
          double v151 = v150;
          BOOL v152 = 0;
          if (!v270 && fabs(v150) > 0.000000015)
          {
            *(void *)&long long v345 = 0x300000001;
            *(_OWORD *)&v344[8] = xmmword_18E1F8560;
            *(void *)v344 = &unk_1EDD18228;
            *((void *)&v345 + 1) = &v346;
            *(double *)&long long v346 = *v329 / v150;
            *((double *)&v346 + 1) = v329[1] / v150;
            *(double *)&long long v347 = v329[2] / v150;
            sub_18E01D450((uint64_t)v344, (uint64_t)v371, (uint64_t)&v366);
            sub_18E16C4D0((uint64_t)&v303, (uint64_t)v344);
            sub_18E01D3D4((uint64_t)&v366, (uint64_t)&v303, (uint64_t)&v284);
            if (v264[88] && (unsigned int v154 = *v264, v154 <= 7) && ((1 << v154) & 0xCE) != 0) {
              long long v155 = (double *)(*((void *)this + 61) + 936);
            }
            else {
              long long v155 = (double *)(*((void *)this + 61) + 928);
            }
            BOOL v152 = v151 >= cnstatistics::InverseNormal(v153, 1.0 - *v155, 0.0, sqrt(*v287));
          }
          uint64_t v323 = 0x100000003;
          long long v322 = xmmword_18E1F6F60;
          long long v321 = &unk_1EDD18D98;
          v324 = &v325;
          if (v152)
          {
            unint64_t v156 = *((void *)this + 1042) + *((void *)this + 1041) - 1;
            uint64_t v157 = *(void *)(*((void *)this + 1038) + 8 * (v156 / 0x14));
            unint64_t v158 = v156 % 0x14;
            uint64_t v159 = (long long *)(v157 + 200 * (v156 % 0x14) + 168);
            long long v319 = 0u;
            long long v320 = 0u;
            if (&v319 != v159)
            {
              long long v319 = *v159;
              long long v320 = v159[1];
            }
            sub_18DFEB188(3, 1, (uint64_t)v317);
            uint64_t v160 = v157 + 200 * v158;
            float64x2_t v161 = *(float64x2_t *)(v160 + 104);
            double v162 = *(double *)(v160 + 120);
            double v163 = sqrt(vmlad_n_f64(COERCE_DOUBLE(*(void *)&vmulq_f64(v161, v161).f64[1]), v161.f64[0], v161.f64[0])+ v162 * v162);
            BOOL v164 = v163 > 0.000000015;
            if (v163 > 0.000000015)
            {
              uint64_t v165 = v318;
              float64x2_t *v318 = vdivq_f64(vnegq_f64(v161), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v163, 0));
              v165[1].f64[0] = -v162 / v163;
            }
            sub_18DFEB188(3, 1, (uint64_t)v314);
            sub_18DFEB238(3, 3, (uint64_t)&v366);
            uint64_t v166 = *((void *)this + 1038);
            if (*((void *)this + 1039) != v166)
            {
              unint64_t v167 = *((void *)this + 1041);
              unint64_t v168 = *(void *)(v166 + 8 * (v167 / 0x14)) + 200 * (v167 % 0x14);
              unint64_t v271 = *(void *)(v166 + 8 * ((*((void *)this + 1042) + v167) / 0x14))
                   + 200 * ((*((void *)this + 1042) + v167) % 0x14);
              if (v168 != v271)
              {
                double v169 = 0.0;
                uint64_t v170 = (void *)(v166 + 8 * (v167 / 0x14));
                do
                {
                  uint64_t v286 = 0x100000003;
                  uint64_t v284 = &unk_1EDD18D98;
                  long long v285 = xmmword_18E1F6F60;
                  v287 = (double *)&v288;
                  long long v288 = *(_OWORD *)(v168 + 128);
                  uint64_t v289 = *(void *)(v168 + 144);
                  cnrotation::Inv((float64x2_t *)(v168 + 168), (float64x2_t *)v344);
                  cnrotation::Cat((double *)&v319, (const cnrotation::CNRotation *)v344, v313);
                  sub_18DFEDF6C((cnrotation::CNRotation *)v313, (uint64_t)&v284, (uint64_t)v344);
                  sub_18DFEF290((uint64_t)&v279, (uint64_t)v344);
                  uint64_t v172 = DWORD2(v280);
                  if (SDWORD2(v280) < 1)
                  {
                    v171.f64[0] = 0.0;
                  }
                  else
                  {
                    long long v173 = v282;
                    v171.f64[0] = 0.0;
                    uint64_t v174 = (double *)v318;
                    do
                    {
                      double v175 = *v173++;
                      double v176 = v175;
                      double v177 = *v174++;
                      v171.f64[0] = v171.f64[0] + v176 * v177;
                      --v172;
                    }
                    while (v172);
                  }
                  *(void *)&long long v345 = 0x100000003;
                  *(_OWORD *)&v344[8] = xmmword_18E1F6F60;
                  *(void *)v344 = &unk_1EDD18D98;
                  *((void *)&v345 + 1) = &v346;
                  sub_18DFE3240((uint64_t)v317, (uint64_t)v344, v171);
                  uint64_t v276 = 0x100000003;
                  uint64_t v274 = &unk_1EDD18D98;
                  long long v275 = xmmword_18E1F6F60;
                  v277 = v278;
                  sub_18DFE2AA8((uint64_t)&v279, (uint64_t)v344, (uint64_t)&v274);
                  uint64_t v310 = 0x100000003;
                  long long v309 = xmmword_18E1F6F60;
                  v308 = &unk_1EDD18D98;
                  long long v311 = &v312;
                  sub_18DFE2AA8((uint64_t)&v274, (uint64_t)v314, (uint64_t)&v308);
                  double v169 = v169 + 1.0;
                  uint64_t v305 = 0x100000003;
                  *(void *)&v178.f64[1] = 0x300000003;
                  long long v304 = xmmword_18E1F6F60;
                  v303 = &unk_1EDD18D98;
                  long long v306 = v307;
                  v178.f64[0] = 1.0 / v169;
                  sub_18DFE3240((uint64_t)&v308, (uint64_t)&v303, v178);
                  *(void *)&long long v345 = 0x100000003;
                  *(_OWORD *)&v344[8] = xmmword_18E1F6F60;
                  *(void *)v344 = &unk_1EDD18D98;
                  *((void *)&v345 + 1) = &v346;
                  sub_18DFEF1F4((uint64_t)v314, (uint64_t)&v303, (uint64_t)v344);
                  sub_18DFE2F24((uint64_t)v314, (uint64_t)v344);
                  uint64_t v292 = 0x100000003;
                  long long v291 = xmmword_18E1F6F60;
                  v290 = &unk_1EDD18D98;
                  int v293 = &v294;
                  sub_18DFE2AA8((uint64_t)&v274, (uint64_t)v314, (uint64_t)&v290);
                  int v179 = DWORD1(v291);
                  int v180 = v291;
                  uint64_t v300 = 0x300000001;
                  int v295 = &unk_1EDD18228;
                  long long v301 = v302;
                  int v296 = DWORD1(v291);
                  int v297 = v291;
                  int v298 = v291 * DWORD1(v291);
                  int v299 = DWORD1(v291);
                  if (DWORD1(v291))
                  {
                    int v181 = 0;
                    int v182 = 0;
                    int v183 = HIDWORD(v291);
                    char v184 = v293;
                    do
                    {
                      int v185 = v181;
                      int v186 = v182;
                      for (int j = v180; j; --j)
                      {
                        v302[v186] = v184[v185];
                        v186 += v179;
                        ++v185;
                      }
                      ++v182;
                      v181 += v183;
                    }
                    while (v182 != v179);
                  }
                  uint64_t v305 = 0x300000003;
                  long long v304 = xmmword_18E1F0010;
                  v303 = &unk_1EDD18EE8;
                  long long v306 = v307;
                  sub_18DFE2B44((uint64_t)&v308, (uint64_t)&v295, (uint64_t)&v303);
                  *(void *)&long long v345 = 0x300000003;
                  *(_OWORD *)&v344[8] = xmmword_18E1F0010;
                  *(void *)v344 = &unk_1EDD18EE8;
                  *((void *)&v345 + 1) = &v346;
                  sub_18DFEF1F4((uint64_t)&v366, (uint64_t)&v303, (uint64_t)v344);
                  __n128 v188 = sub_18DFE2F24((uint64_t)&v366, (uint64_t)v344);
                  v168 += 200;
                  if (v168 - *v170 == 4000)
                  {
                    unint64_t v189 = v170[1];
                    ++v170;
                    unint64_t v168 = v189;
                  }
                }
                while (v168 != v271);
                BOOL v190 = v164;
                if (v169 >= 4.0)
                {
                  v188.n128_f64[0] = 1.0 / (v169 + -1.0);
                  sub_18E042024((uint64_t)&v366, (uint64_t)&v303, (float64x2_t)v188);
                  uint64_t v286 = 0x300000003;
                  long long v285 = xmmword_18E1F0010;
                  uint64_t v284 = &unk_1EDD18EE8;
                  v287 = (double *)&v288;
                  sub_18E06D444(3, (uint64_t)&v279);
                  uint64_t v276 = 0x300000003;
                  uint64_t v274 = &unk_1EDD18EE8;
                  long long v275 = xmmword_18E1F0010;
                  v277 = v278;
                  sub_18E168B50((uint64_t)&v303, (uint64_t)&v284, (uint64_t)&v279, (uint64_t)&v274);
                  double v191 = *v282;
                  double v192 = v282[SHIDWORD(v280) + 1];
                  sub_18E03017C((uint64_t)v314);
                  int64x2_t v193 = (double *)*((void *)this + 61);
                  if (v194 < v193[124] && sqrt(v191) < v193[125]) {
                    BOOL v190 = 0;
                  }
                  if (fabs(v191) < 2.22044605e-16 && fabs(v192) < 2.22044605e-16 || v191 / (v191 + v192) < v193[126]) {
                    BOOL v190 = 0;
                  }
                  sub_18E0519FC(":", (uint64_t)&v274, 0, (uint64_t)v344);
                  uint64_t v195 = v315;
                  if (v315 <= 0) {
                    goto LABEL_161;
                  }
                  long long v196 = v316;
                  double v197 = 0.0;
                  double v198 = (double *)*((void *)&v345 + 1);
                  do
                  {
                    double v199 = *v196++;
                    double v200 = v199;
                    double v201 = *v198++;
                    double v197 = v197 + v200 * v201;
                    --v195;
                  }
                  while (v195);
                  if (v197 >= 0.0)
                  {
LABEL_161:
                    sub_18E0519FC(":", (uint64_t)&v274, 0, (uint64_t)v344);
                    v244.f64[0] = v151;
                    sub_18E16C55C((uint64_t)&v308, (uint64_t)v344, v244);
                  }
                  else
                  {
                    sub_18E0519FC(":", (uint64_t)&v274, 0, (uint64_t)v344);
                    v202.f64[0] = -v151;
                    sub_18E16C55C((uint64_t)&v308, (uint64_t)v344, v202);
                  }
                  __n128 v245 = sub_18DFE2F24((uint64_t)&v321, (uint64_t)&v308);
                  int v246 = v263;
                  if (v142 == 0.0) {
                    int v246 = 0;
                  }
                  if (v246 == 1)
                  {
                    v245.n128_f64[0] = v142;
                    sub_18E053C38((uint64_t)&v321, (uint64_t)v344, (float64x2_t)v245);
                    sub_18DFE2F24((uint64_t)&v321, (uint64_t)v344);
                  }
                  if (v190)
                  {
                    uint64_t v368 = 0x200000003;
                    long long v367 = xmmword_18E1FD990;
                    unsigned int v366 = &unk_1EDD18EB8;
                    unsigned int v369 = v370;
                    uint64_t v305 = 0x200000003;
                    long long v304 = xmmword_18E1FD990;
                    v303 = &unk_1EDD18EB8;
                    long long v306 = v307;
                    sub_18E07C870((uint64_t)v344, (uint64_t)&v366, 0);
                    sub_18DFEC830((uint64_t)v344, (uint64_t)&v336);
                    sub_18E07C870((uint64_t)v344, (uint64_t)&v366, 1);
                    sub_18DFEC830((uint64_t)v344, (uint64_t)&v326);
                    sub_18E07C870((uint64_t)v344, (uint64_t)&v303, 0);
                    sub_18DFEC830((uint64_t)v344, (uint64_t)&v331);
                    sub_18E07C870((uint64_t)v344, (uint64_t)&v303, 1);
                    sub_18DFEC830((uint64_t)v344, (uint64_t)&v321);
                    uint64_t v281 = 0x100000002;
                    uint64_t v279 = &unk_1EDD18B28;
                    long long v280 = xmmword_18E1FD1A0;
                    v282 = (double *)&v283;
                    long long v283 = *(_OWORD *)(*((void *)this + 61) + 1200);
                    if (!sub_18E171404((uint64_t)this + 8208))
                    {
                      v264[1257] = 1;
                      *((_OWORD *)this + 469) = v343;
                      sub_18E0963D8((uint64_t)&v284, (uint64_t)this + 8216);
                      sub_18E16A8FC((uint64_t)v344);
                      double v247 = *v287;
                      double v248 = v287[1];
                      double v249 = v287[2];
                      double v250 = v287[3];
                      double v251 = sqrt(v248 * v248 + v247 * v247 + v249 * v249 + v250 * v250);
                      if (fabs(v251) >= 2.22044605e-16)
                      {
                        double v253 = v247 / v251;
                        double v254 = v248 / v251;
                        double v255 = v249 / v251;
                        double v252 = v250 / v251;
                      }
                      else
                      {
                        double v252 = 1.0;
                        double v253 = 0.0;
                        double v254 = 0.0;
                        double v255 = 0.0;
                      }
                      double v350 = v253;
                      double v351 = v254;
                      double v352 = v255;
                      double v353 = v252;
                      long long v346 = *(_OWORD *)((char *)a2 + 40);
                      long long v347 = *(_OWORD *)((char *)a2 + 56);
                      long long v348 = *(_OWORD *)((char *)a2 + 72);
                      long long v349 = *(_OWORD *)((char *)a2 + 88);
                      *(_OWORD *)&v344[8] = *(_OWORD *)((char *)a2 + 8);
                      long long v345 = *(_OWORD *)((char *)a2 + 24);
                      uint64_t v354 = *(void *)(*((void *)this + 61) + 944);
                      uint64_t v357 = 0;
                      uint64_t v355 = 0;
                      uint64_t v356 = 0;
                      uint64_t v358 = v354;
                      uint64_t v359 = 0;
                      uint64_t v360 = 0;
                      uint64_t v361 = v354;
                      uint64_t v362 = 0;
                      uint64_t v363 = v354;
                      unsigned __int8 v364 = v264[1256];
                      char v365 = 1;
                      sub_18E0CF124();
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

void sub_18E16C400(_Unwind_Exception *exception_object)
{
}

uint64_t sub_18E16C4D0(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 8);
  int v2 = *(_DWORD *)(a2 + 12);
  *(void *)(a1 + 24) = 0x100000003;
  *(void *)a1 = &unk_1EDD18D98;
  *(_DWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 12) = v3;
  *(_DWORD *)(a1 + 16) = v3 * v2;
  *(_DWORD *)(a1 + 20) = v2;
  *(void *)(a1 + 32) = a1 + 40;
  return sub_18DFE2C64(a2, a1);
}

void sub_18E16C53C(_Unwind_Exception *a1)
{
  *unint64_t v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

double sub_18E16C55C(uint64_t a1, uint64_t a2, float64x2_t a3)
{
  *(void *)(a1 + 24) = 0x100000003;
  *(void *)a1 = &unk_1EDD18D98;
  *(_OWORD *)(a1 + 8) = xmmword_18E1F6F60;
  *(void *)(a1 + 32) = a1 + 40;
  *(void *)&double result = *(_OWORD *)&sub_18DFE3240(a2, a1, a3);
  return result;
}

void sub_18E16C5C4(_Unwind_Exception *a1)
{
  *unint64_t v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

void raven::RavenDeviceAttitudeActiveObject::UpdateDeviceVehicleAttitudeWithRotation(raven::RavenDeviceAttitudeActiveObject *this)
{
  MEMORY[0x1F4188790](this);
  uint64_t v2 = v1;
  int v3 = (void *)(v1 + 6904);
  if (sub_18E16A5E4(v1, (void *)(v1 + 6904), 0.0) && sub_18E16A788(v2, (void *)(v2 + 7824)))
  {
    v277 = 0;
    long long v278 = 0;
    uint64_t v279 = 0;
    sub_18E0E8750((void **)&v277, *(void *)(v2 + 6944));
    uint64_t v4 = *(void *)(v2 + 6912);
    if (*(void *)(v2 + 6920) == v4
      || (unint64_t v5 = *(void *)(v2 + 6936),
          unsigned int v6 = (double *)(*(void *)(v4 + 8 * (v5 / 0x1A)) + 152 * (v5 % 0x1A)),
          unint64_t v7 = *(void *)(v4 + 8 * ((*(void *)(v2 + 6944) + v5) / 0x1A))
             + 152 * ((*(void *)(v2 + 6944) + v5) % 0x1A),
          v6 == (double *)v7))
    {
      uint64_t v9 = v278;
    }
    else
    {
      double v8 = (void *)(v4 + 8 * (v5 / 0x1A));
      uint64_t v9 = v278;
      do
      {
        double v10 = sqrt(v6[14] * v6[14] + v6[13] * v6[13] + v6[15] * v6[15]);
        if (v9 >= v279)
        {
          uint64_t v11 = v277;
          uint64_t v12 = v9 - v277;
          unint64_t v13 = v12 + 1;
          if ((unint64_t)(v12 + 1) >> 61) {
            sub_18DEE1FC8();
          }
          uint64_t v14 = (char *)v279 - (char *)v277;
          if (((char *)v279 - (char *)v277) >> 2 > v13) {
            unint64_t v13 = v14 >> 2;
          }
          if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v15 = v13;
          }
          if (v15)
          {
            double v16 = (char *)sub_18DEDF808((uint64_t)&v279, v15);
            uint64_t v11 = v277;
            uint64_t v9 = v278;
          }
          else
          {
            double v16 = 0;
          }
          double v17 = (double *)&v16[8 * v12];
          *double v17 = v10;
          int8x16_t v18 = v17 + 1;
          while (v9 != v11)
          {
            uint64_t v19 = *((void *)v9-- - 1);
            *((void *)v17-- - 1) = v19;
          }
          v277 = v17;
          long long v278 = v18;
          uint64_t v279 = (double *)&v16[8 * v15];
          if (v11) {
            operator delete(v11);
          }
          uint64_t v9 = v18;
        }
        else
        {
          *v9++ = v10;
        }
        long long v278 = v9;
        v6 += 19;
        if ((double *)((char *)v6 - *v8) == (double *)3952)
        {
          double v20 = (double *)v8[1];
          ++v8;
          unsigned int v6 = v20;
        }
      }
      while (v6 != (double *)v7);
    }
    double v21 = *(double *)(*(void *)(v2 + 488) + 1072) * 0.0174532925;
    unint64_t v22 = v277;
    if (v277 == v9)
    {
      uint64_t v24 = v277;
    }
    else
    {
      double v23 = v277 + 1;
      uint64_t v24 = v277;
      if (v277 + 1 != v9)
      {
        double v25 = *v277;
        uint64_t v24 = v277;
        unint64_t v26 = v277 + 1;
        do
        {
          double v27 = *v26++;
          double v28 = v27;
          if (v25 < v27)
          {
            double v25 = v28;
            uint64_t v24 = v23;
          }
          double v23 = v26;
        }
        while (v26 != v9);
      }
    }
    if (*v24 > v21)
    {
      uint64_t v29 = v24 - v277;
      unint64_t v30 = *(void *)(v2 + 6944);
      if (v29 < (uint64_t)(3 * v30 / 5) && v29 > (uint64_t)(2 * v30 / 5))
      {
        unint64_t v211 = 2 * v30 / 5;
        uint64_t v213 = v24 - v277;
        uint64_t v274 = 0;
        long long v275 = 0;
        uint64_t v276 = 0;
        sub_18E0E8750((void **)&v274, v30);
        unint64_t v271 = 0;
        uint64_t v272 = 0;
        uint64_t v273 = 0;
        sub_18E0E8750((void **)&v271, *(void *)(v2 + 6944));
        double v268 = 0;
        unsigned int v269 = 0;
        int v270 = 0;
        sub_18E0E8750((void **)&v268, *(void *)(v2 + 6944));
        uint64_t v32 = *(void *)(v2 + 6912);
        if (*(void *)(v2 + 6920) != v32)
        {
          unint64_t v33 = *(void *)(v2 + 6936);
          int v34 = (void *)(*(void *)(v32 + 8 * (v33 / 0x1A)) + 152 * (v33 % 0x1A));
          unint64_t v35 = *(void *)(v32 + 8 * ((*(void *)(v2 + 6944) + v33) / 0x1A))
              + 152 * ((*(void *)(v2 + 6944) + v33) % 0x1A);
          if (v34 != (void *)v35)
          {
            uint64_t v36 = (void *)(v32 + 8 * (v33 / 0x1A));
            do
            {
              unint64_t v37 = v275;
              if (v275 >= v276)
              {
                unint64_t v39 = v274;
                uint64_t v40 = (v275 - v274) >> 3;
                unint64_t v41 = v40 + 1;
                if ((unint64_t)(v40 + 1) >> 61) {
                  goto LABEL_242;
                }
                uint64_t v42 = v276 - v274;
                if ((v276 - v274) >> 2 > v41) {
                  unint64_t v41 = v42 >> 2;
                }
                if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v43 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v43 = v41;
                }
                if (v43)
                {
                  uint64_t v44 = (char *)sub_18DEDF808((uint64_t)&v276, v43);
                  unint64_t v39 = v274;
                  unint64_t v37 = v275;
                }
                else
                {
                  uint64_t v44 = 0;
                }
                uint64_t v45 = &v44[8 * v40];
                *(void *)uint64_t v45 = v34[13];
                uint64_t v38 = v45 + 8;
                while (v37 != v39)
                {
                  uint64_t v46 = *((void *)v37 - 1);
                  v37 -= 8;
                  *((void *)v45 - 1) = v46;
                  v45 -= 8;
                }
                uint64_t v274 = v45;
                long long v275 = v38;
                uint64_t v276 = &v44[8 * v43];
                if (v39) {
                  operator delete(v39);
                }
              }
              else
              {
                *(void *)long long v275 = v34[13];
                uint64_t v38 = v37 + 8;
              }
              long long v275 = v38;
              uint64_t v47 = v272;
              if (v272 >= v273)
              {
                uint64_t v49 = v271;
                uint64_t v50 = (v272 - v271) >> 3;
                unint64_t v51 = v50 + 1;
                if ((unint64_t)(v50 + 1) >> 61) {
                  goto LABEL_242;
                }
                uint64_t v52 = v273 - v271;
                if ((v273 - v271) >> 2 > v51) {
                  unint64_t v51 = v52 >> 2;
                }
                if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v53 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v53 = v51;
                }
                if (v53)
                {
                  uint64_t v54 = (char *)sub_18DEDF808((uint64_t)&v273, v53);
                  uint64_t v49 = v271;
                  uint64_t v47 = v272;
                }
                else
                {
                  uint64_t v54 = 0;
                }
                long long v55 = &v54[8 * v50];
                *(void *)long long v55 = v34[14];
                uint64_t v48 = v55 + 8;
                while (v47 != v49)
                {
                  uint64_t v56 = *((void *)v47 - 1);
                  v47 -= 8;
                  *((void *)v55 - 1) = v56;
                  v55 -= 8;
                }
                unint64_t v271 = v55;
                uint64_t v272 = v48;
                uint64_t v273 = &v54[8 * v53];
                if (v49) {
                  operator delete(v49);
                }
              }
              else
              {
                *(void *)uint64_t v272 = v34[14];
                uint64_t v48 = v47 + 8;
              }
              uint64_t v272 = v48;
              double v57 = v269;
              if (v269 >= v270)
              {
                unint64_t v59 = v268;
                uint64_t v60 = (v269 - v268) >> 3;
                unint64_t v61 = v60 + 1;
                if ((unint64_t)(v60 + 1) >> 61) {
LABEL_242:
                }
                  sub_18DEE1FC8();
                uint64_t v62 = v270 - v268;
                if ((v270 - v268) >> 2 > v61) {
                  unint64_t v61 = v62 >> 2;
                }
                if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v63 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v63 = v61;
                }
                if (v63)
                {
                  uint64_t v64 = (char *)sub_18DEDF808((uint64_t)&v270, v63);
                  unint64_t v59 = v268;
                  double v57 = v269;
                }
                else
                {
                  uint64_t v64 = 0;
                }
                uint64_t v65 = &v64[8 * v60];
                *(void *)uint64_t v65 = v34[15];
                int v58 = v65 + 8;
                while (v57 != v59)
                {
                  uint64_t v66 = *((void *)v57 - 1);
                  v57 -= 8;
                  *((void *)v65 - 1) = v66;
                  v65 -= 8;
                }
                double v268 = v65;
                unsigned int v269 = v58;
                int v270 = &v64[8 * v63];
                if (v59) {
                  operator delete(v59);
                }
              }
              else
              {
                *(void *)unsigned int v269 = v34[15];
                int v58 = v57 + 8;
              }
              unsigned int v269 = v58;
              v34 += 19;
              if ((void *)((char *)v34 - *v36) == (void *)3952)
              {
                uint64_t v67 = (void *)v36[1];
                ++v36;
                int v34 = v67;
              }
            }
            while (v34 != (void *)v35);
          }
        }
        if (raven::RavenDeviceAttitudeActiveObject::DualDirSmooth(v2, &v274, *(double *)(*(void *)(v2 + 488) + 1112))&& raven::RavenDeviceAttitudeActiveObject::DualDirSmooth(v2, &v271, *(double *)(*(void *)(v2 + 488) + 1112))&& raven::RavenDeviceAttitudeActiveObject::DualDirSmooth(v2, &v268, *(double *)(*(void *)(v2 + 488) + 1112)))
        {
          uint64_t v68 = (double *)v274;
          unint64_t v69 = (double *)v275;
          if (v274 != v275)
          {
            BOOL v70 = (double *)v274;
            do
            {
              *BOOL v70 = *v70 * *v70;
              ++v70;
            }
            while (v70 != v69);
          }
          uint64_t v71 = (double *)v271;
          uint64_t v72 = (double *)v272;
          while (v71 != v72)
          {
            *uint64_t v71 = *v71 * *v71;
            ++v71;
          }
          unint64_t v73 = (double *)v268;
          double v74 = (double *)v269;
          while (v73 != v74)
          {
            *unint64_t v73 = *v73 * *v73;
            ++v73;
          }
          if (v68 != v69) {
            memmove(v277, v68, (char *)v69 - (char *)v68);
          }
          uint64_t v75 = v277;
          double v76 = v278;
          if (v277 != v278)
          {
            uint64_t v77 = 0;
            uint64_t v78 = v271;
            do
            {
              v75[v77] = v75[v77] + *(double *)&v78[v77 * 8];
              ++v77;
            }
            while (&v75[v77] != v76);
            uint64_t v79 = 0;
            float64x2_t v80 = v268;
            do
            {
              v75[v79] = v75[v79] + *(double *)&v80[v79 * 8];
              ++v79;
            }
            while (&v75[v79] != v76);
            uint64_t v81 = v75 + 1;
            if (v75 + 1 != v76)
            {
              double v82 = *v75;
              unint64_t v83 = v75 + 1;
              do
              {
                double v84 = *v83++;
                double v85 = v84;
                if (v82 < v84)
                {
                  double v82 = v85;
                  uint64_t v75 = v81;
                }
                uint64_t v81 = v83;
              }
              while (v83 != v76);
            }
          }
          uint64_t v86 = *(void *)(v2 + 6912);
          unint64_t v87 = *(void *)(v2 + 6936);
          uint64_t v88 = (void *)(v86 + 8 * (v87 / 0x1A));
          unint64_t v89 = *(void *)(v2 + 6920) == v86 ? 0 : *v88 + 152 * (v87 % 0x1A);
          double v90 = *v75;
          double v222 = *(double *)&v88;
          *(void *)uint64_t v223 = v89;
          sub_18E172E60(&v222, v213);
          v267[0] = (*(uint64_t (**)(void))(**(void **)v223 + 16))(*(void *)v223);
          v267[1] = v91;
          if (sqrt(v90) > v21)
          {
            uint64_t v92 = v213 - v211;
            uint64_t v93 = v211 + v213;
            double v94 = *(double *)(v2 + 6960) * *(double *)(v2 + 6960) + *(double *)(v2 + 6952) * *(double *)(v2 + 6952);
            double v95 = *(double *)(v2 + 6968);
            v264[0] = 0;
            long long v265 = 0u;
            memset(v266, 0, sizeof(v266));
            v261[0] = 0;
            long long v262 = 0u;
            memset(v263, 0, sizeof(v263));
            v258[0] = 0;
            long long v259 = 0u;
            memset(v260, 0, sizeof(v260));
            uint64_t v96 = *(void *)(v2 + 6912);
            unint64_t v97 = *(void *)(v2 + 6936);
            uint64_t v98 = *(void *)(v2 + 6920);
            unint64_t v99 = v98 == v96 ? 0 : *(void *)(v96 + 8 * (v97 / 0x1A)) + 152 * (v97 % 0x1A);
            double v100 = v21 * 0.25;
            double v101 = v94 + v95 * v95;
            *(void *)&double v222 = v96 + 8 * (v97 / 0x1A);
            *(void *)uint64_t v223 = v99;
            uint64_t v214 = v213 - v211;
            sub_18E172E60(&v222, v92);
            double v102 = v222;
            __n128 v103 = *(double **)v223;
            while (1)
            {
              unint64_t v104 = v98 == v96 ? 0 : *(void *)(v96 + 8 * (v97 / 0x1A)) + 152 * (v97 % 0x1A);
              *(void *)&double v222 = v96 + 8 * (v97 / 0x1A);
              *(void *)uint64_t v223 = v104;
              sub_18E172E60(&v222, v93);
              if (*(void *)&v102 >= *(void *)&v222
                && (*(void *)&v102 != *(void *)&v222 || (unint64_t)v103 >= *(void *)v223))
              {
                break;
              }
              double v106 = v103[13];
              double v107 = sqrt(v103[14] * v103[14] + v106 * v106 + v103[15] * v103[15]);
              if (v107 > v100)
              {
                double v222 = v106 / v107;
                sub_18DFF11E4((uint64_t)v264, &v222, v107 * v107 / v101);
                double v222 = v103[14] / v107;
                sub_18DFF11E4((uint64_t)v261, &v222, v107 * v107 / v101);
                double v222 = v103[15] / v107;
                sub_18DFF11E4((uint64_t)v258, &v222, v107 * v107 / v101);
              }
              v103 += 19;
              if ((double *)((char *)v103 - **(void **)&v102) == (double *)3952)
              {
                uint64_t v108 = *(double **)(*(void *)&v102 + 8);
                *(void *)&v102 += 8;
                __n128 v103 = v108;
              }
              uint64_t v96 = *(void *)(v2 + 6912);
              unint64_t v97 = *(void *)(v2 + 6936);
              uint64_t v98 = *(void *)(v2 + 6920);
            }
            uint64_t v255 = 0x100000003;
            long long v254 = xmmword_18E1F6F60;
            double v253 = &unk_1EDD18D98;
            double v256 = (float64x2_t *)v257;
            v257[0] = *(void *)&v266[1];
            v257[1] = *(void *)&v263[1];
            v257[2] = *(void *)&v260[1];
            sub_18E03017C((uint64_t)&v253);
            if (fabs(*(double *)&v109) > 0.000000015)
            {
              uint64_t v110 = v256;
              *double v256 = vdivq_f64(*v256, (float64x2_t)vdupq_lane_s64(v109, 0));
              v110[1].f64[0] = v110[1].f64[0] / *(double *)&v109;
              double v250 = 0;
              uint64_t v251 = 0;
              v246[0] = 0;
              std::string __p = 0;
              uint64_t v247 = 0;
              char v248 = 1;
              sub_18E0C5398((char **)&__p);
              char v252 = 1;
              uint64_t v243 = 0x100000003;
              long long v242 = xmmword_18E1F6F60;
              uint64_t v241 = &unk_1EDD18D98;
              float64x2_t v244 = &v245;
              uint64_t v111 = *(void *)(v2 + 6912);
              unint64_t v112 = *(void *)(v2 + 6936);
              uint64_t v113 = *(void *)(v2 + 6920);
              if (v113 == v111) {
                unint64_t v114 = 0;
              }
              else {
                unint64_t v114 = *(void *)(v111 + 8 * (v112 / 0x1A)) + 152 * (v112 % 0x1A);
              }
              *(void *)&double v222 = v111 + 8 * (v112 / 0x1A);
              *(void *)uint64_t v223 = v114;
              sub_18E172E60(&v222, v214);
              double v115 = v222;
              uint64_t v116 = *(float64_t **)v223;
              while (1)
              {
                unint64_t v117 = v113 == v111 ? 0 : *(void *)(v111 + 8 * (v112 / 0x1A)) + 152 * (v112 % 0x1A);
                *(void *)&double v222 = v111 + 8 * (v112 / 0x1A);
                *(void *)uint64_t v223 = v117;
                sub_18E172E60(&v222, v93);
                if (*(void *)&v115 >= *(void *)&v222
                  && (*(void *)&v115 != *(void *)&v222 || (unint64_t)v116 >= *(void *)v223))
                {
                  break;
                }
                v118.f64[0] = v116[13];
                double v120 = sqrt(v116[14] * v116[14] + v118.f64[0] * v118.f64[0] + v116[15] * v116[15]);
                if (v120 > v100)
                {
                  uint64_t v121 = v244;
                  *float64x2_t v244 = *(void *)&v118.f64[0];
                  v121[1] = *((void *)v116 + 14);
                  v121[2] = *((void *)v116 + 15);
                  v118.f64[0] = 1.0 / v120;
                  *(void *)&v223[16] = 0x100000003;
                  *(_OWORD *)uint64_t v223 = xmmword_18E1F6F60;
                  double v222 = COERCE_DOUBLE(&unk_1EDD18D98);
                  *(void *)&v223[24] = &v223[32];
                  sub_18DFE3240((uint64_t)&v241, (uint64_t)&v222, v118);
                  uint64_t v122 = *(unsigned int *)&v223[8];
                  if (*(int *)&v223[8] < 1)
                  {
                    double v124 = 0.0;
                  }
                  else
                  {
                    long long v123 = *(double **)&v223[24];
                    double v124 = 0.0;
                    uint64_t v125 = (double *)v256;
                    do
                    {
                      double v126 = *v123++;
                      double v127 = v126;
                      double v128 = *v125++;
                      double v124 = v124 + v127 * v128;
                      --v122;
                    }
                    while (v122);
                  }
                  double v220 = v124;
                  sub_18E0C4D80((uint64_t)v246, (uint64_t *)&v220, 1.0);
                }
                v116 += 19;
                if ((float64_t *)((char *)v116 - **(void **)&v115) == (float64_t *)3952)
                {
                  uint64_t v129 = *(float64_t **)(*(void *)&v115 + 8);
                  *(void *)&v115 += 8;
                  uint64_t v116 = v129;
                }
                uint64_t v111 = *(void *)(v2 + 6912);
                unint64_t v112 = *(void *)(v2 + 6936);
                uint64_t v113 = *(void *)(v2 + 6920);
              }
              sub_18E0C5470((uint64_t)v246, 50.0);
              double v210 = acos(v130);
              uint64_t v131 = (cnprint::CNPrinter *)sub_18DFEB188(3, 1, (uint64_t)v239);
              *(void *)(v240 + 16) = 0x3FF0000000000000;
              if (cnprint::CNPrinter::GetLogLevel(v131) <= 1)
              {
                LOWORD(v222) = 12;
                LOBYTE(v220) = 1;
                uint64_t v134 = *(void *)(*(void *)(v2 + 7832) + ((*(void *)(v2 + 7856) >> 1) & 0x7FFFFFFFFFFFFFF8))
                     + 2432 * (*(void *)(v2 + 7856) & 0xFLL);
                uint64_t v135 = (*(uint64_t (**)(uint64_t))(*(void *)v134 + 16))(v134);
                double v137 = v136;
                unint64_t v138 = *(void *)(v2 + 7864) + *(void *)(v2 + 7856) - 1;
                uint64_t v139 = *(void *)(*(void *)(v2 + 7832) + ((v138 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 2432 * (v138 & 0xF);
                (*(void (**)(uint64_t))(*(void *)v139 + 16))(v139);
                double v209 = v137 + (double)v135;
                cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v222, (unsigned __int8 *)&v220, "DevAtt,Rotation,first solution time,%lf,last solution time,%lf,maxRateTime,%lf,rotVectNorm,%lf", v140, v141, v142, v143, v144, SLOBYTE(v209));
              }
              uint64_t v145 = *(void *)(*(void *)(v2 + 488) + 1120);
              *(void *)uint64_t v223 = 0;
              double v222 = 0.0;
              v132.i64[0] = v145;
              CNTimeSpan::SetTimeSpan((uint64_t *)&v222, 0, v132, v133);
              uint64_t v148 = CNTimeSpan::operator-((uint64_t)v267, &v222, v146, v147);
              double v150 = v149;
              *(void *)uint64_t v223 = 0;
              double v222 = 0.0;
              v151.i64[0] = v145;
              CNTimeSpan::SetTimeSpan((uint64_t *)&v222, 0, v151, v152);
              uint64_t v215 = CNTimeSpan::operator+((uint64_t)v267, &v222, v153, v154);
              double v156 = v155;
              uint64_t v236 = 0x300000003;
              long long v235 = xmmword_18E1F0010;
              uint64_t v234 = &unk_1EDD18EE8;
              uint64_t v237 = &v238;
              uint64_t v231 = 0x100000003;
              long long v230 = xmmword_18E1F6F60;
              long long v229 = &unk_1EDD18D98;
              unint64_t v232 = (double *)&v233;
              uint64_t v226 = 0x100000003;
              long long v225 = xmmword_18E1F6F60;
              unint64_t v224 = &unk_1EDD18D98;
              double v227 = (double *)&v228;
              sub_18DFF49CC((uint64_t)&v222);
              sub_18DFF49CC((uint64_t)&v220);
              uint64_t v158 = *(void *)(v2 + 7832);
              double v159 = 0.0;
              if (*(void *)(v2 + 7840) != v158)
              {
                unint64_t v160 = *(void *)(v2 + 7856);
                float64x2_t v161 = (void *)(v158 + 8 * (v160 >> 4));
                uint64_t v162 = *v161 + 2432 * (v160 & 0xF);
                uint64_t v163 = *(void *)(v158 + (((*(void *)(v2 + 7864) + v160) >> 1) & 0x7FFFFFFFFFFFFFF8))
                     + 2432 * ((*(_DWORD *)(v2 + 7864) + v160) & 0xF);
                if (v162 != v163)
                {
                  double v164 = v150;
                  if (v148) {
                    BOOL v165 = 1;
                  }
                  else {
                    BOOL v165 = (*(void *)&v150 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
                  }
                  char v166 = v165;
                  if (v215) {
                    BOOL v167 = 1;
                  }
                  else {
                    BOOL v167 = (*(void *)&v156 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
                  }
                  char v168 = v167;
                  char v212 = v168;
                  do
                  {
                    uint64_t v169 = (*(uint64_t (**)(uint64_t))(*(void *)v162 + 16))(v162);
                    if ((v166 & 1) == 0
                      || (!v169
                        ? (BOOL v171 = (*(void *)&v170 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
                        : (BOOL v171 = 1),
                          !v171 || (BOOL v172 = v148 <= v169, v148 == v169)))
                    {
                      BOOL v172 = v164 <= v170;
                    }
                    if (v172)
                    {
                      uint64_t v173 = *(void *)(v162 + 1552);
                      if (v223[1536])
                      {
                        uint64_t v174 = v227;
                        *(void *)double v227 = v173;
                        v174[1] = *(double *)(v162 + 1560);
                        v174[2] = *(double *)(v162 + 1568);
                        sub_18E03017C((uint64_t)&v224);
                        *(double *)v157.i64 = fabs(v175.f64[0]);
                        if (*(double *)v157.i64 > 0.000000015)
                        {
                          v175.f64[0] = 1.0 / v175.f64[0];
                          sub_18E053C38((uint64_t)&v224, (uint64_t)&v218, v175);
                          sub_18DFE2F24((uint64_t)&v224, (uint64_t)&v218);
                          sub_18E0300B4((uint64_t)&v234, (uint64_t)&v224, (uint64_t)&v218);
                          sub_18DFE2F24((uint64_t)&v224, (uint64_t)&v218);
                          sub_18E030138((uint64_t)&v229, (uint64_t)&v224, (uint64_t)&v218);
                          sub_18E030138((uint64_t)&v229, (uint64_t)&v224, (uint64_t)v216);
                          sub_18E03017C((uint64_t)v216);
                          uint64_t v177 = DWORD2(v230);
                          if (SDWORD2(v230) < 1)
                          {
                            double v179 = 0.0;
                          }
                          else
                          {
                            float64x2_t v178 = v232;
                            double v179 = 0.0;
                            int v180 = v227;
                            do
                            {
                              double v181 = *v178++;
                              double v182 = v181;
                              double v183 = *v180++;
                              double v179 = v179 + v182 * v183;
                              --v177;
                            }
                            while (v177);
                          }
                          uint64_t v187 = v219[2];
                          double v188 = atan2(v176, v179);
                          if (*(double *)(v187 + 16) <= 0.0) {
                            double v189 = -1.0;
                          }
                          else {
                            double v189 = 1.0;
                          }
                          memcpy(v221, (const void *)(v162 + 8), 0x971uLL);
                          __n128 v190 = sub_18DFE2F24((uint64_t)&v229, (uint64_t)&v224);
                          uint64_t v191 = (*(uint64_t (**)(uint64_t, __n128))(*(void *)v162 + 16))(v162, v190);
                          double v159 = v159 + v188 * v189;
                          if (v191) {
                            BOOL v193 = 1;
                          }
                          else {
                            BOOL v193 = (*(void *)&v192 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
                          }
                          if (!v193 || (v212 & 1) == 0 || (BOOL v194 = v191 <= v215, v191 == v215)) {
                            BOOL v194 = v192 <= v156;
                          }
                          if (!v194) {
                            break;
                          }
                        }
                      }
                      else
                      {
                        char v184 = v232;
                        *(void *)unint64_t v232 = v173;
                        v184[1] = *(double *)(v162 + 1560);
                        v184[2] = *(double *)(v162 + 1568);
                        sub_18E03017C((uint64_t)&v229);
                        *(double *)v157.i64 = fabs(v185.f64[0]);
                        if (*(double *)v157.i64 > 0.000000015)
                        {
                          v185.f64[0] = 1.0 / v185.f64[0];
                          sub_18E053C38((uint64_t)&v229, (uint64_t)&v218, v185);
                          sub_18DFE2F24((uint64_t)&v229, (uint64_t)&v218);
                          int v186 = (cnprint::CNPrinter *)sub_18DFFDA0C((uint64_t)&v218, *(float64_t *)(v162 + 1472), *(float64_t *)(v162 + 1480), *(double *)(v162 + 1488));
                          if (!BYTE8(v218))
                          {
                            if (cnprint::CNPrinter::GetLogLevel(v186) <= 1)
                            {
                              LOWORD(v216[0]) = 12;
                              unsigned __int8 v217 = 1;
                              cnprint::CNPrinter::Print((cnprint::CNPrinter *)v216, &v217, "DevAtt,Rotation,cannot derive ecef to enu Jacobian", v203, v204, v205, v206, v207, v208);
                            }
                            goto LABEL_227;
                          }
                          sub_18DFE2F24((uint64_t)&v234, (uint64_t)v219);
                          sub_18E0300B4((uint64_t)&v234, (uint64_t)&v229, (uint64_t)v216);
                          sub_18DFE2F24((uint64_t)&v229, (uint64_t)v216);
                          memcpy(v223, (const void *)(v162 + 8), sizeof(v223));
                        }
                      }
                    }
                    v162 += 2432;
                    if (v162 - *v161 == 38912)
                    {
                      uint64_t v195 = v161[1];
                      ++v161;
                      uint64_t v162 = v195;
                    }
                  }
                  while (v162 != v163);
                }
              }
              uint64_t v196 = v221[0];
              double v197 = *(double *)&v221[1];
              v198.i64[1] = *(void *)&v223[8];
              long long v218 = *(_OWORD *)v223;
              v198.i64[0] = *(void *)(*(void *)(v2 + 488) + 1128);
              v216[0] = 0;
              v216[1] = 0;
              CNTimeSpan::SetTimeSpan(v216, 0, v198, v157);
              uint64_t v201 = CNTimeSpan::operator+((uint64_t)&v218, v216, v199, v200);
              if ((v196 || (*(void *)&v197 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
                && (v201 || (*(void *)&v202 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
                && v196 != v201)
              {
                if (v196 < v201) {
                  goto LABEL_227;
                }
              }
              else if (v197 < v202)
              {
                goto LABEL_227;
              }
              if (v159 < 0.0) {
                *(void *)(v240 + 16) = 0xBFF0000000000000;
              }
              raven::RavenDeviceAttitudeActiveObject::UpdateDeviceVehicleAttitude(v2, (uint64_t)&v253, (uint64_t)v239, (uint64_t)v267, v210);
              sub_18E16A968(v3);
LABEL_227:
              if (__p)
              {
                double v250 = __p;
                operator delete(__p);
              }
            }
          }
        }
        if (v268)
        {
          unsigned int v269 = v268;
          operator delete(v268);
        }
        if (v271)
        {
          uint64_t v272 = v271;
          operator delete(v271);
        }
        if (v274)
        {
          long long v275 = v274;
          operator delete(v274);
        }
        unint64_t v22 = v277;
      }
    }
    if (v22)
    {
      long long v278 = v22;
      operator delete(v22);
    }
  }
}

void sub_18E16D96C(_Unwind_Exception *a1)
{
  int v3 = (void *)STACK[0x15D0];
  if (STACK[0x15D0])
  {
    STACK[0x15D8] = (unint64_t)v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(v1 - 256);
  if (v4)
  {
    *(void *)(v1 - 248) = v4;
    operator delete(v4);
  }
  unint64_t v5 = *(void **)(v1 - 232);
  if (v5)
  {
    *(void *)(v1 - 224) = v5;
    operator delete(v5);
  }
  unsigned int v6 = *(void **)(v1 - 208);
  if (v6)
  {
    *(void *)(v1 - 200) = v6;
    operator delete(v6);
  }
  unint64_t v7 = *(void **)(v1 - 184);
  if (v7)
  {
    *(void *)(v1 - 176) = v7;
    operator delete(v7);
  }
  _Unwind_Resume(a1);
}

uint64_t raven::RavenDeviceAttitudeActiveObject::Configure(uint64x2_t *a1, uint64_t *a2, double a3, int8x16_t a4)
{
  if (a1[30].i8[0])
  {
    __int16 v51 = 12;
    unsigned __int8 v50 = 3;
    (*(void (**)(void **__return_ptr, uint64x2_t *))(a1->i64[0] + 16))(__p, a1);
    if (v49 >= 0) {
      uint64_t v11 = __p;
    }
    else {
      LOBYTE(v11) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v51, &v50, "Warning: %s configured more than once.", v6, v7, v8, v9, v10, (char)v11);
    if (v49 < 0) {
      operator delete(__p[0]);
    }
  }
  a1[30].i8[0] = 0;
  uint64_t v12 = *a2;
  if (!v12 || !*(unsigned char *)(v12 + 33))
  {
    __int16 v51 = 12;
    unsigned __int8 v50 = 4;
    (*(void (**)(void **__return_ptr, uint64x2_t *))(a1->i64[0] + 16))(__p, a1);
    if (v49 >= 0) {
      unint64_t v26 = __p;
    }
    else {
      LOBYTE(v26) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v51, &v50, "Error: %s could not be configured.", v21, v22, v23, v24, v25, (char)v26);
    goto LABEL_21;
  }
  a1[30].i64[1] = v12;
  double v13 = *(double *)(v12 + 648);
  BOOL v14 = v13 > 0.000000015 && (*(void *)(v12 + 648) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL;
  if (!v14
    || ((a4.i64[0] = *(void *)(v12 + 656), *(double *)a4.i64 > 0.000000015)
      ? (BOOL v28 = (*(void *)(v12 + 656) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      : (BOOL v28 = 0),
        !v28
     || (*(double *)(v12 + 792) > 0.000000015
       ? (BOOL v29 = (*(void *)(v12 + 792) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
       : (BOOL v29 = 0),
         !v29)))
  {
    __int16 v51 = 12;
    unsigned __int8 v50 = 4;
    (*(void (**)(void **__return_ptr, uint64x2_t *))(a1->i64[0] + 16))(__p, a1);
    if (v49 >= 0) {
      double v20 = __p;
    }
    else {
      LOBYTE(v20) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v51, &v50, "Error: %s could not be configured because of invalid sensor sample period or input solution rate, accel sample period, %.3lf, gyro sample period, %.3lf, solution output rate, %.3lf", v15, v16, v17, v18, v19, (char)v20);
LABEL_21:
    if (v49 < 0) {
      operator delete(__p[0]);
    }
    return 0xFFFFFFFFLL;
  }
  a1[470] = vcvtq_u64_f64(vmulq_n_f64((float64x2_t)xmmword_18E21BFE0, 1.0 / v13));
  int8x16_t v30 = (int8x16_t)vcvtq_u64_f64(vmulq_n_f64((float64x2_t)xmmword_18E21BFE0, 1.0 / *(double *)a4.i64));
  a1[471] = (uint64x2_t)v30;
  a4.i64[0] = 3.0;
  *(double *)v30.i64 = *(double *)(v12 + 1048) * 3.0;
  __p[0] = 0;
  __p[1] = 0;
  CNTimeSpan::SetTimeSpan((uint64_t *)__p, 0, v30, a4);
  a1[472] = *(uint64x2_t *)__p;
  a1[473].i64[0] = 3
                 * (unint64_t)(*(double *)(v12 + 792) * (*(double *)&a1[472].i64[1] + (double)a1[472].i64[0]));
  if (*(unsigned char *)(v12 + 3656))
  {
    uint64_t v36 = (char *)(v12 + 3664);
    if (*(char *)(v12 + 3687) < 0) {
      uint64_t v36 = *(char **)v36;
    }
    if (sub_18E02AB00((uint64_t)a1[90].i64, v36))
    {
      LOWORD(__p[0]) = 12;
      LOBYTE(v51) = 4;
      unint64_t v37 = "Error: RavenDeviceAttitudeActiveObject::Configure() failed to load gravity parameters.";
LABEL_46:
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v51, v37, v31, v32, v33, v34, v35, v47);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    if (*(_DWORD *)(v12 + 3652))
    {
      LOWORD(__p[0]) = 12;
      LOBYTE(v51) = 4;
      unint64_t v37 = "Error: RavenDeviceAttitudeActiveObject::Configure() failed to load gravity parameters becasue of invalid model type.";
      goto LABEL_46;
    }
    if (sub_18E02ABDC((uint64_t)a1[90].i64, (uint64_t)&unk_18E21C010, (uint64_t)&unk_18E21C10C, (uint64_t)&unk_18E21C208, (uint64_t)&unk_18E21C400, (uint64_t)&unk_18E21C5F8, (uint64_t)&unk_18E21C7F0))
    {
      LOWORD(__p[0]) = 12;
      LOBYTE(v51) = 4;
      unint64_t v37 = "Error: RavenDeviceAttitudeActiveObject::Configure() failed to load EGM96 gravity parameters.";
      goto LABEL_46;
    }
  }
  a1[250].i32[0] = 1;
  uint64_t v38 = a1[30].i64[1];
  if (*(_DWORD *)(v38 + 3652))
  {
    LOWORD(__p[0]) = 12;
    LOBYTE(v51) = 4;
    unint64_t v37 = "Error: RavenDeviceAttitudeActiveObject::Configure() failed to set EGM96 model constants.";
    goto LABEL_46;
  }
  a1[91] = (uint64x2_t)xmmword_18E1FD640;
  a1[92].i64[0] = 0x40E86A0000000000;
  __int32 v39 = *(_DWORD *)(v38 + 3688);
  if ((v39 - 11) <= 0xFFFFFFF6) {
    __assert_rtn("SetTruncationDegree", "sphericalharmonicsgravitymodel.h", 471, "trunc >= 2 && trunc <= max_degree");
  }
  a1[260].i32[0] = v39;
  if (!a1[90].i8[8])
  {
    LOWORD(__p[0]) = 12;
    LOBYTE(v51) = 4;
    unint64_t v37 = "Error: RavenDeviceAttitudeActiveObject::Configure() gravity parameters are invalid.";
    goto LABEL_46;
  }
  sub_18E06E600((uint64_t)a1[261].i64, (uint64_t)a1[90].i64);
  a1[521].i16[4] = 1;
  cnframework::ActiveObjectBase::SetEventQueueDelay((cnframework::ActiveObjectBase *)a1, 0.0);
  a1[30].i8[0] = 1;
  uint64_t v40 = (cnprint::CNPrinter *)(*(uint64_t (**)(uint64x2_t *))(a1->i64[0] + 48))(a1);
  if (cnprint::CNPrinter::GetLogLevel(v40) <= 1)
  {
    __int16 v51 = 12;
    unsigned __int8 v50 = 1;
    (*(void (**)(void **__return_ptr, uint64x2_t *))(a1->i64[0] + 16))(__p, a1);
    if (v49 >= 0) {
      uint64_t v46 = __p;
    }
    else {
      LOBYTE(v46) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v51, &v50, "%s configured successfully.", v41, v42, v43, v44, v45, (char)v46);
    if (v49 < 0) {
      operator delete(__p[0]);
    }
  }
  return 0;
}

void sub_18E16DF48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t raven::RavenDeviceAttitudeActiveObject::IsConfigured(raven::RavenDeviceAttitudeActiveObject *this)
{
  return *((unsigned __int8 *)this + 480);
}

void raven::RavenDeviceAttitudeActiveObject::RemoveStaleSolutions(void *a1, uint64_t a2, int8x16_t a3, int8x16_t a4)
{
  *(double *)a3.i64 = *(double *)(a1[61] + 1048) + *(double *)(a1[61] + 1048);
  v18[0] = 0;
  v18[1] = 0;
  CNTimeSpan::SetTimeSpan(v18, 0, a3, a4);
  uint64_t v8 = CNTimeSpan::operator-(a2, v18, v6, v7);
  if (a1[983])
  {
    uint64_t v10 = v8;
    double v11 = v9;
    if (v8) {
      BOOL v12 = 1;
    }
    else {
      BOOL v12 = (*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
    }
    char v13 = v12;
    do
    {
      uint64_t v14 = *(void *)(a1[979] + ((a1[982] >> 1) & 0x7FFFFFFFFFFFFFF8)) + 2432 * (a1[982] & 0xFLL);
      uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 16))(v14);
      if (v15) {
        BOOL v17 = 1;
      }
      else {
        BOOL v17 = (*(void *)&v16 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
      }
      if (v17 && (v13 & 1) != 0 && v15 != v10)
      {
        if (v15 > v10) {
          return;
        }
      }
      else if (v16 >= v11)
      {
        return;
      }
      sub_18E16E094((uint64_t)(a1 + 978));
    }
    while (a1[983]);
  }
}

void sub_18E16E094(uint64_t a1)
{
  uint64_t v2 = (void (***)(void))(*(void *)(*(void *)(a1 + 8)
                                                 + ((*(void *)(a1 + 32) >> 1) & 0x7FFFFFFFFFFFFFF8))
                                     + 2432 * (*(void *)(a1 + 32) & 0xFLL));
  (**v2)(v2);
  int64x2_t v3 = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_18E1EF670);
  *(int64x2_t *)(a1 + 32) = v3;
  if (v3.i64[0] >= 0x20uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 16;
  }
}

void raven::RavenDeviceAttitudeActiveObject::HandleEvent(int64x2_t *this, const raven::AccelerometerEvent *a2)
{
  if (this[30].i8[0])
  {
    std::string __p = (void *)2;
    uint64_t v41 = 0;
    uint64_t v4 = sub_18E16E434(this + 495, (uint64_t)a2, (double *)&__p, this[470].u64[0]);
    if ((v4 & 1) == 0 && !cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v4))
    {
      LOWORD(__p) = 12;
      LOBYTE(v44) = 0;
      uint64_t v5 = (*(uint64_t (**)(const raven::AccelerometerEvent *))(*(void *)a2 + 16))(a2);
      double v38 = v6 + (double)v5;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&__p, (unsigned __int8 *)&v44, "DevAtt,Accelerometer stationary detection queue overflowed at %.3lf", v7, v8, v9, v10, v11, SLOBYTE(v38));
    }
    std::string __p = (void *)3;
    uint64_t v41 = 0x3FE0000000000000;
    uint64_t v12 = sub_18E16E434(this + 483, (uint64_t)a2, (double *)&__p, this[470].u64[1]);
    if ((v12 & 1) == 0)
    {
      if (!cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v12))
      {
        LOWORD(__p) = 12;
        LOBYTE(v44) = 0;
        uint64_t v13 = (*(uint64_t (**)(const raven::AccelerometerEvent *))(*(void *)a2 + 16))(a2);
        double v39 = v14 + (double)v13;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&__p, (unsigned __int8 *)&v44, "DevAtt,Accelerometer down sampling queue overflowed at %.3lf", v15, v16, v17, v18, v19, SLOBYTE(v39));
      }
      double v20 = (void **)this[31].i64[1];
      uint64_t v21 = (void **)this[32].i64[0];
      if (v21 == v20)
      {
        uint64_t v24 = &this[33].i64[1];
        uint64_t v21 = (void **)this[31].i64[1];
      }
      else
      {
        unint64_t v22 = this[33].u64[0];
        uint64_t v23 = &v20[v22 / 0x1A];
        uint64_t v24 = &this[33].i64[1];
        unint64_t v25 = (unint64_t)v20[(this[33].i64[1] + v22) / 0x1A] + 152 * ((this[33].i64[1] + v22) % 0x1A);
        if ((char *)*v23 + 152 * (v22 % 0x1A) != (void *)v25)
        {
          unint64_t v26 = (void (***)(void))((char *)*v23 + 152 * (v22 % 0x1A));
          do
          {
            double v27 = *v26;
            v26 += 19;
            (*v27)();
            if ((char *)v26 - (unsigned char *)*v23 == 3952)
            {
              BOOL v28 = (void (***)(void))v23[1];
              ++v23;
              unint64_t v26 = v28;
            }
          }
          while (v26 != (void (***)(void))v25);
          double v20 = (void **)this[31].i64[1];
          uint64_t v21 = (void **)this[32].i64[0];
        }
      }
      *uint64_t v24 = 0;
      unint64_t v35 = (char *)v21 - (char *)v20;
      if (v35 >= 0x11)
      {
        do
        {
          operator delete(*v20);
          uint64_t v36 = this[32].i64[0];
          double v20 = (void **)(this[31].i64[1] + 8);
          this[31].i64[1] = (uint64_t)v20;
          unint64_t v35 = v36 - (void)v20;
        }
        while (v35 > 0x10);
      }
      if (v35 >> 3 == 1)
      {
        uint64_t v37 = 13;
      }
      else
      {
        if (v35 >> 3 != 2) {
          return;
        }
        uint64_t v37 = 26;
      }
      this[33].i64[0] = v37;
    }
  }
  else
  {
    __int16 v44 = 12;
    unsigned __int8 v43 = 3;
    (*(void (**)(void **__return_ptr, int64x2_t *, const raven::AccelerometerEvent *))(this->i64[0] + 16))(&__p, this, a2);
    if (v42 >= 0) {
      p_p = &__p;
    }
    else {
      LOBYTE(p_p) = (_BYTE)__p;
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v44, &v43, "Warning: %s is not configured yet.", v29, v30, v31, v32, v33, (char)p_p);
    if (v42 < 0) {
      operator delete(__p);
    }
  }
}

void sub_18E16E418(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E16E434(int64x2_t *a1, uint64_t a2, double *a3, unint64_t a4)
{
  __n128 v8 = sub_18E0BAFF8(a1, a2);
  if (a1[2].i64[1])
  {
    for (char i = 1; ; char i = 0)
    {
      v19[0] = (*(uint64_t (**)(uint64_t, __n128))(*(void *)a2 + 16))(a2, v8);
      v19[1] = v10;
      unint64_t v11 = *(void *)(a1->i64[1] + 8 * (a1[2].i64[0] / 0x1AuLL)) + 152 * (a1[2].i64[0] % 0x1AuLL);
      v18[0] = (*(uint64_t (**)(unint64_t))(*(void *)v11 + 16))(v11);
      v18[1] = v12;
      *(void *)&v20[0] = CNTimeSpan::operator-((uint64_t)v19, v18, v13, v14);
      v20[1] = v15;
      if (!sub_18DEE4C00(v20, a3) && a1[2].i64[1] <= a4) {
        break;
      }
      sub_18E0BB590(a1);
      char v16 = 0;
      if (!a1[2].i64[1]) {
        return v16 & 1;
      }
    }
    char v16 = i;
  }
  else
  {
    char v16 = 1;
  }
  return v16 & 1;
}

__n128 raven::RavenDeviceAttitudeActiveObject::HandleEvent(raven::RavenDeviceAttitudeActiveObject *this, const raven::ActivityStateEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    if (*((unsigned char *)this + 7176))
    {
      long long v2 = *(_OWORD *)((char *)a2 + 8);
      long long v3 = *(_OWORD *)((char *)a2 + 24);
      long long v4 = *(_OWORD *)((char *)a2 + 40);
      *((_OWORD *)this + 440) = *(_OWORD *)((char *)a2 + 56);
      *((_OWORD *)this + 439) = v4;
      *((_OWORD *)this + 438) = v3;
      *((_OWORD *)this + 437) = v2;
      long long v5 = *(_OWORD *)((char *)a2 + 72);
      long long v6 = *(_OWORD *)((char *)a2 + 88);
      long long v7 = *(_OWORD *)((char *)a2 + 104);
      *((_OWORD *)this + 444) = *(_OWORD *)((char *)a2 + 120);
      *((_OWORD *)this + 443) = v7;
      *((_OWORD *)this + 442) = v6;
      *((_OWORD *)this + 441) = v5;
      __n128 result = *(__n128 *)((char *)a2 + 136);
      long long v9 = *(_OWORD *)((char *)a2 + 152);
      long long v10 = *(_OWORD *)((char *)a2 + 168);
      *((void *)this + 896) = *((void *)a2 + 23);
      *((_OWORD *)this + 447) = v10;
      *((_OWORD *)this + 446) = v9;
      *((__n128 *)this + 445) = result;
    }
    else
    {
      *((void *)this + 873) = &unk_1EDD140B8;
      long long v17 = *(_OWORD *)((char *)a2 + 8);
      long long v18 = *(_OWORD *)((char *)a2 + 24);
      long long v19 = *(_OWORD *)((char *)a2 + 40);
      *((_OWORD *)this + 440) = *(_OWORD *)((char *)a2 + 56);
      *((_OWORD *)this + 439) = v19;
      *((_OWORD *)this + 438) = v18;
      *((_OWORD *)this + 437) = v17;
      long long v20 = *(_OWORD *)((char *)a2 + 72);
      long long v21 = *(_OWORD *)((char *)a2 + 88);
      long long v22 = *(_OWORD *)((char *)a2 + 104);
      *((_OWORD *)this + 444) = *(_OWORD *)((char *)a2 + 120);
      *((_OWORD *)this + 443) = v22;
      *((_OWORD *)this + 442) = v21;
      *((_OWORD *)this + 441) = v20;
      __n128 result = *(__n128 *)((char *)a2 + 136);
      long long v23 = *(_OWORD *)((char *)a2 + 152);
      long long v24 = *(_OWORD *)((char *)a2 + 168);
      *((void *)this + 896) = *((void *)a2 + 23);
      *((_OWORD *)this + 447) = v24;
      *((_OWORD *)this + 446) = v23;
      *((__n128 *)this + 445) = result;
      *((unsigned char *)this + 7176) = 1;
    }
  }
  else
  {
    __int16 v28 = 12;
    unsigned __int8 v27 = 3;
    (*(void (**)(void **__return_ptr))(*(void *)this + 16))(__p);
    if (v26 >= 0) {
      char v16 = __p;
    }
    else {
      LOBYTE(v16) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v28, &v27, "Warning: %s is not configured yet.", v11, v12, v13, v14, v15, (char)v16);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
  }
  return result;
}

void sub_18E16E714(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void raven::RavenDeviceAttitudeActiveObject::HandleEvent(raven::RavenDeviceAttitudeActiveObject *this, const raven::AttitudeEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    if (*((unsigned char *)a2 + 217) == 2)
    {
      uint64_t v4 = *((void *)this + 983);
      if (v4)
      {
        unint64_t v5 = v4 + *((void *)this + 982) - 1;
        uint64_t v6 = *(void *)(*((void *)this + 979) + ((v5 >> 1) & 0x7FFFFFFFFFFFFFF8));
        unsigned int v7 = v5 & 0xF;
        if (*(unsigned char *)(v6 + 2432 * v7 + 209) == 2
          && *(unsigned char *)(v6 + 2432 * v7 + 1464)
          && *(unsigned char *)(v6 + 2432 * v7 + 1544)
          && *((unsigned char *)a2 + 216))
        {
          uint64_t v73 = 0x300000003;
          uint64_t v71 = &unk_1EDD18EE8;
          long long v72 = xmmword_18E1F0010;
          double v74 = &v75;
          sub_18DFFDA0C((uint64_t)&v68, *(float64_t *)(v6 + 2432 * v7 + 1472), *(float64_t *)(v6 + 2432 * v7 + 1480), *(double *)(v6 + 2432 * v7 + 1488));
          if (v69)
          {
            sub_18DFE2F24((uint64_t)&v71, (uint64_t)&v70);
            long long v66 = 0u;
            long long v67 = 0u;
            if (&v66 != (long long *)((char *)a2 + 104))
            {
              long long v13 = *(_OWORD *)((char *)a2 + 120);
              long long v66 = *(_OWORD *)((char *)a2 + 104);
              long long v67 = v13;
            }
            *((unsigned char *)this + 6978) = 1;
            sub_18DFE20A0((uint64_t)v65, (uint64_t)&v71);
            cnrotation::Cat((double *)&v66, (const cnrotation::CNRotation *)v65, (double *)&__p);
            uint64_t v14 = __p;
            if ((void **)((char *)this + 1176) == &__p)
            {
              double v15 = *((double *)this + 148);
              double v16 = *((double *)this + 149);
              double v17 = *((double *)this + 150);
            }
            else
            {
              *((double *)this + 147) = *(double *)&__p;
              double v16 = *((double *)&v48 + 1);
              double v15 = *(double *)&v48;
              *((void *)this + 148) = v48;
              *((double *)this + 149) = v16;
              double v17 = *(double *)&v49;
              *((void *)this + 150) = v49;
            }
            sub_18E16A8FC((uint64_t)&__p);
            long long v50 = *(_OWORD *)((char *)a2 + 40);
            long long v51 = *(_OWORD *)((char *)a2 + 56);
            long long v52 = *(_OWORD *)((char *)a2 + 72);
            long long v53 = *(_OWORD *)((char *)a2 + 88);
            long long v48 = *(_OWORD *)((char *)a2 + 8);
            long long v49 = *(_OWORD *)((char *)a2 + 24);
            double v41 = sqrt(v15 * v15 + *(double *)&v14 * *(double *)&v14 + v16 * v16 + v17 * v17);
            if (fabs(v41) >= 2.22044605e-16)
            {
              double v43 = *(double *)&v14 / v41;
              double v44 = v15 / v41;
              double v45 = v16 / v41;
              double v42 = v17 / v41;
            }
            else
            {
              double v42 = 1.0;
              double v43 = 0.0;
              double v44 = 0.0;
              double v45 = 0.0;
            }
            double v54 = v43;
            double v55 = v44;
            double v56 = v45;
            double v57 = v42;
            long long v58 = *(_OWORD *)((char *)a2 + 136);
            long long v59 = *(_OWORD *)((char *)a2 + 152);
            long long v60 = *(_OWORD *)((char *)a2 + 168);
            long long v61 = *(_OWORD *)((char *)a2 + 184);
            long long v62 = *(_OWORD *)((char *)a2 + 200);
            char v63 = *((unsigned char *)a2 + 216);
            char v64 = 1;
            sub_18E16EBC0((uint64_t)this + 1208, (uint64_t)&__p);
          }
          else
          {
            LOWORD(__p) = 12;
            LOBYTE(v66) = 4;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&__p, (unsigned __int8 *)&v66, "DevAtt, Rotation, cannot derive ecef to enu Jacobian", v8, v9, v10, v11, v12, v46);
          }
        }
      }
    }
    else
    {
      long long v24 = (raven::RavenDeviceAttitudeActiveObject *)((char *)this + 1208);
      if (*((unsigned char *)this + 1432))
      {
        long long v25 = *(_OWORD *)((char *)a2 + 8);
        *((_OWORD *)this + 77) = *(_OWORD *)((char *)a2 + 24);
        *((_OWORD *)this + 76) = v25;
        long long v26 = *(_OWORD *)((char *)a2 + 40);
        long long v27 = *(_OWORD *)((char *)a2 + 56);
        long long v28 = *(_OWORD *)((char *)a2 + 72);
        *((_OWORD *)this + 81) = *(_OWORD *)((char *)a2 + 88);
        *((_OWORD *)this + 80) = v28;
        *((_OWORD *)this + 79) = v27;
        *((_OWORD *)this + 78) = v26;
        if (v24 != a2)
        {
          *((_OWORD *)this + 82) = *(_OWORD *)((char *)a2 + 104);
          *((_OWORD *)this + 83) = *(_OWORD *)((char *)a2 + 120);
        }
        long long v29 = *(_OWORD *)((char *)a2 + 136);
        *((_OWORD *)this + 85) = *(_OWORD *)((char *)a2 + 152);
        *((_OWORD *)this + 84) = v29;
        long long v30 = *(_OWORD *)((char *)a2 + 168);
        long long v31 = *(_OWORD *)((char *)a2 + 184);
        long long v32 = *(_OWORD *)((char *)a2 + 200);
        *((_WORD *)this + 712) = *((_WORD *)a2 + 108);
        *((_OWORD *)this + 88) = v32;
        *((_OWORD *)this + 87) = v31;
        *((_OWORD *)this + 86) = v30;
      }
      else
      {
        *((void *)this + 151) = &unk_1EDD13760;
        long long v33 = *(_OWORD *)((char *)a2 + 8);
        *((_OWORD *)this + 77) = *(_OWORD *)((char *)a2 + 24);
        *((_OWORD *)this + 76) = v33;
        long long v34 = *(_OWORD *)((char *)a2 + 40);
        long long v35 = *(_OWORD *)((char *)a2 + 56);
        long long v36 = *(_OWORD *)((char *)a2 + 72);
        *((_OWORD *)this + 81) = *(_OWORD *)((char *)a2 + 88);
        *((_OWORD *)this + 80) = v36;
        *((_OWORD *)this + 79) = v35;
        *((_OWORD *)this + 78) = v34;
        *((_OWORD *)this + 82) = 0u;
        *((_OWORD *)this + 83) = 0u;
        if (v24 != a2)
        {
          *((_OWORD *)this + 82) = *(_OWORD *)((char *)a2 + 104);
          *((_OWORD *)this + 83) = *(_OWORD *)((char *)a2 + 120);
        }
        long long v37 = *(_OWORD *)((char *)a2 + 136);
        *((_OWORD *)this + 85) = *(_OWORD *)((char *)a2 + 152);
        *((_OWORD *)this + 84) = v37;
        long long v38 = *(_OWORD *)((char *)a2 + 168);
        long long v39 = *(_OWORD *)((char *)a2 + 184);
        long long v40 = *(_OWORD *)((char *)a2 + 200);
        *((_WORD *)this + 712) = *((_WORD *)a2 + 108);
        *((_OWORD *)this + 88) = v40;
        *((_OWORD *)this + 87) = v39;
        *((_OWORD *)this + 86) = v38;
        *((unsigned char *)this + 1432) = 1;
      }
    }
  }
  else
  {
    __int16 v68 = 12;
    LOBYTE(v71) = 3;
    (*(void (**)(void **__return_ptr, raven::RavenDeviceAttitudeActiveObject *, const raven::AttitudeEvent *))(*(void *)this + 16))(&__p, this, a2);
    if (v48 >= 0) {
      p_p = &__p;
    }
    else {
      LOBYTE(p_p) = (_BYTE)__p;
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v68, (unsigned __int8 *)&v71, "Warning: %s is not configured yet.", v18, v19, v20, v21, v22, (char)p_p);
    if (SHIBYTE(v48) < 0) {
      operator delete(__p);
    }
  }
}

void sub_18E16EB94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

__n128 sub_18E16EBC0(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 224))
  {
    long long v2 = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v2;
    long long v3 = *(_OWORD *)(a2 + 40);
    long long v4 = *(_OWORD *)(a2 + 56);
    long long v5 = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = v5;
    *(_OWORD *)(a1 + 56) = v4;
    *(_OWORD *)(a1 + 40) = v3;
    if (a1 != a2)
    {
      *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
      *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
    }
    long long v6 = *(_OWORD *)(a2 + 136);
    *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
    *(_OWORD *)(a1 + 136) = v6;
    __n128 result = *(__n128 *)(a2 + 168);
    long long v8 = *(_OWORD *)(a2 + 184);
    long long v9 = *(_OWORD *)(a2 + 200);
    *(_WORD *)(a1 + 216) = *(_WORD *)(a2 + 216);
    *(_OWORD *)(a1 + 200) = v9;
    *(_OWORD *)(a1 + 184) = v8;
    *(__n128 *)(a1 + 168) = result;
  }
  else
  {
    *(void *)a1 = &unk_1EDD13760;
    long long v10 = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v10;
    long long v11 = *(_OWORD *)(a2 + 40);
    long long v12 = *(_OWORD *)(a2 + 56);
    long long v13 = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = v13;
    *(_OWORD *)(a1 + 56) = v12;
    *(_OWORD *)(a1 + 40) = v11;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_OWORD *)(a1 + 120) = 0u;
    if (a1 != a2)
    {
      *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
      *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
    }
    long long v14 = *(_OWORD *)(a2 + 136);
    *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
    *(_OWORD *)(a1 + 136) = v14;
    __n128 result = *(__n128 *)(a2 + 168);
    long long v15 = *(_OWORD *)(a2 + 184);
    long long v16 = *(_OWORD *)(a2 + 200);
    *(_WORD *)(a1 + 216) = *(_WORD *)(a2 + 216);
    *(_OWORD *)(a1 + 200) = v16;
    *(_OWORD *)(a1 + 184) = v15;
    *(__n128 *)(a1 + 168) = result;
    *(unsigned char *)(a1 + 224) = 1;
  }
  return result;
}

void raven::RavenDeviceAttitudeActiveObject::HandleEvent(raven::RavenDeviceAttitudeActiveObject *this, const raven::DecomposedAccelerationEvent *a2, int8x16_t a3, int8x16_t a4)
{
  if (*((unsigned char *)this + 480))
  {
    long long v6 = (int64x2_t *)((char *)this + 8296);
    if (*((void *)this + 1042))
    {
      uint64_t v7 = CNTimeSpan::operator-(*(void *)(*((void *)this + 1038) + 8 * (*((void *)this + 1041) / 0x14uLL))+ 200 * (*((void *)this + 1041) % 0x14uLL)+ 152, (void *)a2 + 19, a3, a4);
      if (fabs(v8 + (double)v7) >= 2.22044605e-16) {
        raven::RavenDeviceAttitudeActiveObject::ResetWahbaSolver(this);
      }
    }
    sub_18E0D5CB0(v6, (uint64_t)a2);
    if (*((void *)this + 1042) > (unint64_t)*(unsigned int *)(*((void *)this + 61) + 984))
    {
      sub_18E0D5DE8(v6);
    }
  }
}

__n128 raven::RavenDeviceAttitudeActiveObject::HandleEvent(raven::RavenDeviceAttitudeActiveObject *this, const raven::MovingStateEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    if (*((unsigned char *)this + 7328))
    {
      __n128 result = *(__n128 *)((char *)a2 + 88);
      long long v3 = *(_OWORD *)((char *)a2 + 104);
      long long v4 = *(_OWORD *)((char *)a2 + 120);
      *((void *)this + 915) = *((void *)a2 + 17);
      *(_OWORD *)((char *)this + 7192) = *(_OWORD *)((char *)a2 + 8);
      long long v5 = *(_OWORD *)((char *)a2 + 24);
      long long v6 = *(_OWORD *)((char *)a2 + 40);
      long long v7 = *(_OWORD *)((char *)a2 + 56);
      *(_OWORD *)((char *)this + 7256) = *(_OWORD *)((char *)a2 + 72);
      *(_OWORD *)((char *)this + 7240) = v7;
      *(_OWORD *)((char *)this + 7224) = v6;
      *(_OWORD *)((char *)this + 7208) = v5;
      *(_OWORD *)((char *)this + 7304) = v4;
      *(_OWORD *)((char *)this + 7288) = v3;
      *(__n128 *)((char *)this + 7272) = result;
    }
    else
    {
      *((void *)this + 898) = &unk_1EDD13CF0;
      *(_OWORD *)((char *)this + 7192) = *(_OWORD *)((char *)a2 + 8);
      long long v14 = *(_OWORD *)((char *)a2 + 24);
      long long v15 = *(_OWORD *)((char *)a2 + 40);
      long long v16 = *(_OWORD *)((char *)a2 + 56);
      *(_OWORD *)((char *)this + 7256) = *(_OWORD *)((char *)a2 + 72);
      *(_OWORD *)((char *)this + 7240) = v16;
      *(_OWORD *)((char *)this + 7224) = v15;
      *(_OWORD *)((char *)this + 7208) = v14;
      __n128 result = *(__n128 *)((char *)a2 + 88);
      long long v17 = *(_OWORD *)((char *)a2 + 104);
      long long v18 = *(_OWORD *)((char *)a2 + 120);
      *((void *)this + 915) = *((void *)a2 + 17);
      *(_OWORD *)((char *)this + 7304) = v18;
      *(_OWORD *)((char *)this + 7288) = v17;
      *(__n128 *)((char *)this + 7272) = result;
      *((unsigned char *)this + 7328) = 1;
    }
  }
  else
  {
    __int16 v22 = 12;
    unsigned __int8 v21 = 3;
    (*(void (**)(void **__return_ptr))(*(void *)this + 16))(__p);
    if (v20 >= 0) {
      long long v13 = __p;
    }
    else {
      LOBYTE(v13) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v22, &v21, "Warning: %s is not configured yet.", v8, v9, v10, v11, v12, (char)v13);
    if (v20 < 0) {
      operator delete(__p[0]);
    }
  }
  return result;
}

void sub_18E16EF54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double raven::RavenDeviceAttitudeActiveObject::HandleEvent(raven::RavenDeviceAttitudeActiveObject *this, const raven::MountStateEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    long long v4 = (char *)this + 6979;
    if (!*((unsigned char *)this + 7176) || (*((unsigned char *)this + 7088) & 0xFE) != 2)
    {
      unsigned int v5 = *((unsigned __int8 *)a2 + 104);
      if (v5 > 3 || v5 == 1)
      {
        if (!*v4)
        {
          __int16 v22 = (cnprint::CNPrinter *)(*(uint64_t (**)(raven::RavenDeviceAttitudeActiveObject *))(*(void *)this + 48))(this);
          *long long v4 = 1;
          if (!cnprint::CNPrinter::GetLogLevel(v22))
          {
            LOWORD(__p[0]) = 12;
            LOBYTE(v35) = 0;
            uint64_t v23 = (*(uint64_t (**)(const raven::MountStateEvent *))(*(void *)a2 + 16))(a2);
            double v31 = v24 + (double)v23;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v35, "DevAtt,t,%.3lf, Engaged for becoming mounted.", v25, v26, v27, v28, v29, SLOBYTE(v31));
          }
        }
      }
      else if (*v4)
      {
        *long long v4 = 0;
        if (!cnprint::CNPrinter::GetLogLevel(this))
        {
          LOWORD(__p[0]) = 12;
          LOBYTE(v35) = 0;
          uint64_t v7 = (*(uint64_t (**)(const raven::MountStateEvent *))(*(void *)a2 + 16))(a2);
          double v30 = v8 + (double)v7;
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v35, "DevAtt,t,%.3lf, Reset because of not being mounted.", v9, v10, v11, v12, v13, SLOBYTE(v30));
        }
        long long v14 = *(void (**)(raven::RavenDeviceAttitudeActiveObject *))(*(void *)this + 48);
        v14(this);
      }
    }
  }
  else
  {
    __int16 v35 = 12;
    unsigned __int8 v34 = 3;
    (*(void (**)(void **__return_ptr, raven::RavenDeviceAttitudeActiveObject *, const raven::MountStateEvent *))(*(void *)this + 16))(__p, this, a2);
    if (v33 >= 0) {
      unsigned __int8 v21 = __p;
    }
    else {
      LOBYTE(v21) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v35, &v34, "Warning: %s is not configured yet.", v16, v17, v18, v19, v20, (char)v21);
    if (v33 < 0) {
      operator delete(__p[0]);
    }
  }
  return result;
}

void sub_18E16F1A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void raven::RavenDeviceAttitudeActiveObject::HandleEvent(raven::RavenDeviceAttitudeActiveObject *this, const raven::RateGyroEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    std::string __p = (void *)2;
    uint64_t v40 = 0;
    uint64_t v4 = sub_18E16F4CC((uint64_t)this + 7968, (uint64_t)a2, (double *)&__p, *((void *)this + 942));
    if ((v4 & 1) == 0 && !cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v4))
    {
      LOWORD(__p) = 12;
      LOBYTE(v43) = 0;
      uint64_t v5 = (*(uint64_t (**)(const raven::RateGyroEvent *))(*(void *)a2 + 16))(a2);
      double v37 = v6 + (double)v5;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&__p, (unsigned __int8 *)&v43, "DevAtt,Gyro stationary detection queue overflowed at %.3lf", v7, v8, v9, v10, v11, SLOBYTE(v37));
    }
    std::string __p = (void *)3;
    uint64_t v40 = 0x3FE0000000000000;
    uint64_t v12 = sub_18E16F4CC((uint64_t)this + 7776, (uint64_t)a2, (double *)&__p, *((void *)this + 943));
    if ((v12 & 1) == 0)
    {
      if (!cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v12))
      {
        LOWORD(__p) = 12;
        LOBYTE(v43) = 0;
        uint64_t v13 = (*(uint64_t (**)(const raven::RateGyroEvent *))(*(void *)a2 + 16))(a2);
        double v38 = v14 + (double)v13;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&__p, (unsigned __int8 *)&v43, "DevAtt,Gyro down sampling queue overflowed at %.3lf", v15, v16, v17, v18, v19, SLOBYTE(v38));
      }
      uint64_t v20 = (void **)*((void *)this + 864);
      unsigned __int8 v21 = (void **)*((void *)this + 865);
      if (v21 == v20)
      {
        double v24 = (void *)((char *)this + 6944);
        unsigned __int8 v21 = (void **)*((void *)this + 864);
      }
      else
      {
        unint64_t v22 = *((void *)this + 867);
        uint64_t v23 = &v20[v22 / 0x1A];
        double v24 = (void *)((char *)this + 6944);
        unint64_t v25 = (unint64_t)v20[(*((void *)this + 868) + v22) / 0x1A]
            + 152 * ((*((void *)this + 868) + v22) % 0x1A);
        if ((char *)*v23 + 152 * (v22 % 0x1A) != (void *)v25)
        {
          uint64_t v26 = (void (***)(void))((char *)*v23 + 152 * (v22 % 0x1A));
          do
          {
            uint64_t v27 = *v26;
            v26 += 19;
            (*v27)();
            if ((char *)v26 - (unsigned char *)*v23 == 3952)
            {
              uint64_t v28 = (void (***)(void))v23[1];
              ++v23;
              uint64_t v26 = v28;
            }
          }
          while (v26 != (void (***)(void))v25);
          unsigned __int8 v21 = (void **)*((void *)this + 865);
          uint64_t v20 = (void **)*((void *)this + 864);
        }
      }
      *double v24 = 0;
      unint64_t v35 = (char *)v21 - (char *)v20;
      if (v35 >= 0x11)
      {
        do
        {
          operator delete(*v20);
          uint64_t v20 = (void **)(*((void *)this + 864) + 8);
          *((void *)this + 864) = v20;
          unint64_t v35 = *((void *)this + 865) - (void)v20;
        }
        while (v35 > 0x10);
      }
      if (v35 >> 3 == 1)
      {
        uint64_t v36 = 13;
      }
      else
      {
        if (v35 >> 3 != 2) {
          return;
        }
        uint64_t v36 = 26;
      }
      *((void *)this + 867) = v36;
    }
  }
  else
  {
    __int16 v43 = 12;
    unsigned __int8 v42 = 3;
    (*(void (**)(void **__return_ptr, raven::RavenDeviceAttitudeActiveObject *, const raven::RateGyroEvent *))(*(void *)this + 16))(&__p, this, a2);
    if (v41 >= 0) {
      p_p = &__p;
    }
    else {
      LOBYTE(p_p) = (_BYTE)__p;
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v43, &v42, "Warning: %s is not configured yet.", v29, v30, v31, v32, v33, (char)p_p);
    if (v41 < 0) {
      operator delete(__p);
    }
  }
}

void sub_18E16F4B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E16F4CC(uint64_t a1, uint64_t a2, double *a3, unint64_t a4)
{
  __n128 v8 = sub_18E167DEC((void **)a1, a2);
  if (*(void *)(a1 + 40))
  {
    for (char i = 1; ; char i = 0)
    {
      v19[0] = (*(uint64_t (**)(uint64_t, __n128))(*(void *)a2 + 16))(a2, v8);
      v19[1] = v10;
      unint64_t v11 = *(void *)(*(void *)(a1 + 8) + 8 * (*(void *)(a1 + 32) / 0x1AuLL))
          + 152 * (*(void *)(a1 + 32) % 0x1AuLL);
      v18[0] = (*(uint64_t (**)(unint64_t))(*(void *)v11 + 16))(v11);
      v18[1] = v12;
      *(void *)&v20[0] = CNTimeSpan::operator-((uint64_t)v19, v18, v13, v14);
      v20[1] = v15;
      if (!sub_18DEE4C00(v20, a3) && *(void *)(a1 + 40) <= a4) {
        break;
      }
      sub_18E167D30(a1);
      char v16 = 0;
      if (!*(void *)(a1 + 40)) {
        return v16 & 1;
      }
    }
    char v16 = i;
  }
  else
  {
    char v16 = 1;
  }
  return v16 & 1;
}

void raven::RavenDeviceAttitudeActiveObject::HandleEvent(raven::RavenDeviceAttitudeActiveObject *this, const raven::RavenSolutionEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    if (*((unsigned char *)a2 + 209) == 2 && *((unsigned char *)a2 + 1464) != 0 && *((unsigned char *)a2 + 1544) != 0)
    {
      if (*((unsigned char *)a2 + 208) == 3)
      {
        if (*(double *)(*((void *)this + 61) + 3336) < (double)*((uint64_t *)a2 + 28) && *((unsigned char *)a2 + 1624) != 0)
        {
          uint64_t v6 = sub_18E16F814((void *)this + 984, (uint64_t)a2, (double *)this + 944, *((void *)this + 946));
          if ((v6 & 1) == 0 && !cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v6))
          {
            LOWORD(__p[0]) = 12;
            LOBYTE(v33) = 0;
            uint64_t v7 = (*(uint64_t (**)(const raven::RavenSolutionEvent *))(*(void *)a2 + 16))(a2);
            double v28 = v8 + (double)v7;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v33, "DevAtt, Raven pnt solution queue overflowed at %.3lf", v9, v10, v11, v12, v13, SLOBYTE(v28));
          }
        }
      }
      else
      {
        uint64_t v20 = sub_18E16F814((void *)this + 978, (uint64_t)a2, (double *)this + 944, *((void *)this + 946));
        if ((v20 & 1) == 0 && !cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v20))
        {
          LOWORD(__p[0]) = 12;
          LOBYTE(v33) = 0;
          uint64_t v21 = (*(uint64_t (**)(const raven::RavenSolutionEvent *))(*(void *)a2 + 16))(a2);
          double v29 = v22 + (double)v21;
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v33, "DevAtt, Raven solution queue overflowed at %.3lf", v23, v24, v25, v26, v27, SLOBYTE(v29));
        }
      }
    }
  }
  else
  {
    __int16 v33 = 12;
    unsigned __int8 v32 = 3;
    (*(void (**)(void **__return_ptr))(*(void *)this + 16))(__p);
    if (v31 >= 0) {
      uint64_t v19 = __p;
    }
    else {
      LOBYTE(v19) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v33, &v32, "Warning: %s is not configured yet.", v14, v15, v16, v17, v18, (char)v19);
    if (v31 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_18E16F7F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E16F814(void *a1, uint64_t a2, double *a3, unint64_t a4)
{
  unint64_t v4 = a4;
  double v8 = (char *)a1[1];
  uint64_t v9 = (char *)a1[2];
  uint64_t v10 = v9 - v8;
  if (v9 == v8) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = 2 * (v9 - v8) - 1;
  }
  unint64_t v12 = a1[4];
  if (v11 != a1[5] + v12) {
    goto LABEL_83;
  }
  BOOL v13 = v12 >= 0x10;
  unint64_t v14 = v12 - 16;
  if (v13)
  {
    a1[4] = v14;
    uint64_t v17 = *(void *)v8;
    uint64_t v15 = v8 + 8;
    uint64_t v16 = v17;
    a1[1] = v15;
    if (v9 == (char *)a1[3])
    {
      uint64_t v18 = (uint64_t)&v15[-*a1];
      if ((unint64_t)v15 <= *a1)
      {
        if (v9 == (char *)*a1) {
          unint64_t v46 = 1;
        }
        else {
          unint64_t v46 = (uint64_t)&v9[-*a1] >> 2;
        }
        char v47 = (char *)sub_18DEE2FBC(v46);
        long long v49 = &v47[8 * (v46 >> 2)];
        long long v50 = (uint64_t *)a1[1];
        uint64_t v9 = v49;
        uint64_t v51 = a1[2] - (void)v50;
        if (v51)
        {
          uint64_t v9 = &v49[v51 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v52 = 8 * (v51 >> 3);
          long long v53 = &v47[8 * (v46 >> 2)];
          do
          {
            uint64_t v54 = *v50++;
            *(void *)long long v53 = v54;
            v53 += 8;
            v52 -= 8;
          }
          while (v52);
        }
        double v55 = (char *)*a1;
        *a1 = v47;
        a1[1] = v49;
        a1[2] = v9;
        a1[3] = &v47[8 * v48];
        if (v55)
        {
          operator delete(v55);
          uint64_t v9 = (char *)a1[2];
        }
      }
      else
      {
        uint64_t v19 = v18 >> 3;
        BOOL v20 = v18 >> 3 < -1;
        uint64_t v21 = (v18 >> 3) + 2;
        if (v20) {
          uint64_t v22 = v21;
        }
        else {
          uint64_t v22 = v19 + 1;
        }
        uint64_t v23 = -(v22 >> 1);
        uint64_t v24 = v22 >> 1;
        uint64_t v25 = &v15[-8 * v24];
        int64_t v26 = v9 - v15;
        if (v9 != v15)
        {
          memmove(&v15[-8 * v24], v15, v9 - v15);
          uint64_t v9 = (char *)a1[1];
        }
        uint64_t v27 = &v9[8 * v23];
        uint64_t v9 = &v25[v26];
        a1[1] = v27;
        a1[2] = &v25[v26];
      }
    }
    *(void *)uint64_t v9 = v16;
    goto LABEL_36;
  }
  uint64_t v28 = v10 >> 3;
  double v29 = (char *)a1[3];
  uint64_t v30 = (char *)*a1;
  uint64_t v31 = (uint64_t)&v29[-*a1];
  if (v10 >> 3 >= (unint64_t)(v31 >> 3))
  {
    uint64_t v34 = v31 >> 2;
    if (v29 == v30) {
      unint64_t v35 = 1;
    }
    else {
      unint64_t v35 = v34;
    }
    uint64_t v36 = (char *)sub_18DEE2FBC(v35);
    uint64_t v38 = v37;
    long long v39 = operator new(0x9800uLL);
    uint64_t v40 = &v36[8 * v28];
    uint64_t v41 = v38;
    unsigned __int8 v42 = &v36[8 * v38];
    if (v28 == v41)
    {
      uint64_t v43 = 8 * v28;
      if (v10 < 1)
      {
        uint64_t v78 = v39;
        uint64_t v79 = v43 >> 2;
        if (v9 == v8) {
          unint64_t v80 = 1;
        }
        else {
          unint64_t v80 = v79;
        }
        uint64_t v81 = (char *)sub_18DEE2FBC(v80);
        uint64_t v40 = &v81[8 * (v80 >> 2)];
        unsigned __int8 v42 = &v81[8 * v82];
        if (v36) {
          operator delete(v36);
        }
        uint64_t v36 = v81;
        long long v39 = v78;
      }
      else
      {
        uint64_t v44 = v43 >> 3;
        if (v44 >= -1) {
          unint64_t v45 = v44 + 1;
        }
        else {
          unint64_t v45 = v44 + 2;
        }
        v40 -= 8 * (v45 >> 1);
      }
    }
    *(void *)uint64_t v40 = v39;
    uint64_t v9 = v40 + 8;
    for (uint64_t i = a1[2]; i != a1[1]; i -= 8)
    {
      if (v40 == v36)
      {
        if (v9 >= v42)
        {
          if (v42 == v36) {
            unint64_t v88 = 1;
          }
          else {
            unint64_t v88 = (v42 - v36) >> 2;
          }
          unint64_t v89 = (char *)sub_18DEE2FBC(v88);
          uint64_t v91 = v89;
          uint64_t v40 = &v89[(2 * v88 + 6) & 0xFFFFFFFFFFFFFFF8];
          uint64_t v93 = v9 - v36;
          BOOL v92 = v9 == v36;
          uint64_t v9 = v40;
          if (!v92)
          {
            uint64_t v9 = &v40[v93 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v94 = 8 * (v93 >> 3);
            double v95 = v40;
            uint64_t v96 = v36;
            do
            {
              uint64_t v97 = *(void *)v96;
              v96 += 8;
              *(void *)double v95 = v97;
              v95 += 8;
              v94 -= 8;
            }
            while (v94);
          }
          unsigned __int8 v42 = &v89[8 * v90];
          if (v36) {
            operator delete(v36);
          }
          uint64_t v36 = v91;
        }
        else
        {
          uint64_t v84 = (v42 - v9) >> 3;
          if (v84 >= -1) {
            uint64_t v85 = v84 + 1;
          }
          else {
            uint64_t v85 = v84 + 2;
          }
          uint64_t v86 = v85 >> 1;
          uint64_t v40 = &v36[8 * (v85 >> 1)];
          unint64_t v87 = v36;
          if (v9 != v36)
          {
            memmove(v40, v36, v9 - v36);
            unint64_t v87 = v9;
          }
          uint64_t v9 = &v87[8 * v86];
        }
      }
      uint64_t v98 = *(void *)(i - 8);
      *((void *)v40 - 1) = v98;
      v40 -= 8;
    }
    unint64_t v99 = (char *)*a1;
    *a1 = v36;
    a1[1] = v40;
    a1[2] = v9;
    a1[3] = v42;
    unint64_t v4 = a4;
    if (v99)
    {
      operator delete(v99);
      uint64_t v9 = (char *)a1[2];
    }
    goto LABEL_82;
  }
  unsigned __int8 v32 = operator new(0x9800uLL);
  __int16 v33 = v32;
  if (v29 == v9)
  {
    if (v8 == v30)
    {
      if (v9 == v8) {
        unint64_t v56 = 1;
      }
      else {
        unint64_t v56 = (v29 - v8) >> 2;
      }
      uint64_t v57 = 2 * v56;
      long long v58 = (char *)sub_18DEE2FBC(v56);
      double v8 = &v58[(v57 + 6) & 0xFFFFFFFFFFFFFFF8];
      long long v60 = (uint64_t *)a1[1];
      long long v61 = v8;
      uint64_t v62 = a1[2] - (void)v60;
      if (v62)
      {
        long long v61 = &v8[v62 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v63 = 8 * (v62 >> 3);
        char v64 = &v58[(v57 + 6) & 0xFFFFFFFFFFFFFFF8];
        do
        {
          uint64_t v65 = *v60++;
          *(void *)char v64 = v65;
          v64 += 8;
          v63 -= 8;
        }
        while (v63);
      }
      long long v66 = (char *)*a1;
      *a1 = v58;
      a1[1] = v8;
      a1[2] = v61;
      a1[3] = &v58[8 * v59];
      if (v66)
      {
        operator delete(v66);
        double v8 = (char *)a1[1];
      }
    }
    *((void *)v8 - 1) = v33;
    long long v67 = (char *)a1[1];
    __int16 v68 = (char *)a1[2];
    a1[1] = v67 - 8;
    uint64_t v69 = *((void *)v67 - 1);
    a1[1] = v67;
    unint64_t v4 = a4;
    if (v68 == (char *)a1[3])
    {
      uint64_t v70 = (uint64_t)&v67[-*a1];
      if ((unint64_t)v67 <= *a1)
      {
        if (v68 == (char *)*a1) {
          unint64_t v112 = 1;
        }
        else {
          unint64_t v112 = (uint64_t)&v68[-*a1] >> 2;
        }
        uint64_t v113 = (char *)sub_18DEE2FBC(v112);
        double v115 = &v113[8 * (v112 >> 2)];
        uint64_t v116 = (uint64_t *)a1[1];
        __int16 v68 = v115;
        uint64_t v117 = a1[2] - (void)v116;
        if (v117)
        {
          __int16 v68 = &v115[v117 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v118 = 8 * (v117 >> 3);
          uint64_t v119 = &v113[8 * (v112 >> 2)];
          do
          {
            uint64_t v120 = *v116++;
            *(void *)uint64_t v119 = v120;
            v119 += 8;
            v118 -= 8;
          }
          while (v118);
        }
        uint64_t v121 = (char *)*a1;
        *a1 = v113;
        a1[1] = v115;
        a1[2] = v68;
        a1[3] = &v113[8 * v114];
        if (v121)
        {
          operator delete(v121);
          __int16 v68 = (char *)a1[2];
        }
      }
      else
      {
        uint64_t v71 = v70 >> 3;
        BOOL v20 = v70 >> 3 < -1;
        uint64_t v72 = (v70 >> 3) + 2;
        if (v20) {
          uint64_t v73 = v72;
        }
        else {
          uint64_t v73 = v71 + 1;
        }
        uint64_t v74 = -(v73 >> 1);
        uint64_t v75 = v73 >> 1;
        double v76 = &v67[-8 * v75];
        int64_t v77 = v68 - v67;
        if (v68 != v67)
        {
          memmove(&v67[-8 * v75], v67, v68 - v67);
          long long v67 = (char *)a1[1];
        }
        __int16 v68 = &v76[v77];
        a1[1] = &v67[8 * v74];
        a1[2] = &v76[v77];
      }
    }
    *(void *)__int16 v68 = v69;
LABEL_36:
    uint64_t v9 = (char *)(a1[2] + 8);
    a1[2] = v9;
    goto LABEL_82;
  }
  *(void *)uint64_t v9 = v32;
  uint64_t v9 = (char *)(a1[2] + 8);
  a1[2] = v9;
  unint64_t v4 = a4;
LABEL_82:
  double v8 = (char *)a1[1];
LABEL_83:
  if (v9 == v8)
  {
    double v101 = 0;
  }
  else
  {
    unint64_t v100 = a1[5] + a1[4];
    double v101 = (void *)(*(void *)&v8[(v100 >> 1) & 0x7FFFFFFFFFFFFFF8] + 2432 * (v100 & 0xF));
  }
  *double v101 = &unk_1EDD14150;
  memcpy(v101 + 1, (const void *)(a2 + 8), 0x971uLL);
  uint64_t v102 = a1[5];
  a1[5] = v102 + 1;
  if (v102 == -1)
  {
    char v103 = 1;
  }
  else
  {
    for (char j = 1; ; char j = 0)
    {
      v124[0] = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
      v124[1] = v105;
      uint64_t v106 = *(void *)(a1[1] + ((a1[4] >> 1) & 0x7FFFFFFFFFFFFFF8)) + 2432 * (a1[4] & 0xFLL);
      v123[0] = (*(uint64_t (**)(uint64_t))(*(void *)v106 + 16))(v106);
      v123[1] = v107;
      *(void *)&v125[0] = CNTimeSpan::operator-((uint64_t)v124, v123, v108, v109);
      v125[1] = v110;
      if (!sub_18DEE4C00(v125, a3) && a1[5] <= v4) {
        break;
      }
      sub_18E16E094((uint64_t)a1);
      char v103 = 0;
      if (!a1[5]) {
        return v103 & 1;
      }
    }
    char v103 = j;
  }
  return v103 & 1;
}

void sub_18E16FE1C(_Unwind_Exception *a1)
{
  operator delete(v2);
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

void raven::RavenDeviceAttitudeActiveObject::HandleEvent(raven::RavenDeviceAttitudeActiveObject *this, const raven::TimeMarkEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    unint64_t v4 = (void *)(*(uint64_t (**)(const raven::TimeMarkEvent *))(*(void *)a2 + 16))(a2);
    double v6 = *(double *)&v5;
    __p[0] = v4;
    __p[1] = v5;
    uint64_t v7 = (void *)*((void *)this + 61);
    v8.i64[0] = v7[144];
    uint64_t v74 = 0;
    uint64_t v75 = 0;
    CNTimeSpan::SetTimeSpan(&v74, 0, v8, v9);
    uint64_t v12 = CNTimeSpan::operator+((uint64_t)this + 7696, &v74, v10, v11);
    if (v4) {
      BOOL v16 = 1;
    }
    else {
      BOOL v16 = (*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
    }
    if (!v16
      || !v12 && (*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || (BOOL v17 = (uint64_t)v4 <= v12, v4 == (void *)v12))
    {
      BOOL v17 = v6 <= v13;
    }
    if (!v17)
    {
      *((void *)this + 962) = v4;
      *((void *)this + 963) = 0;
      raven::RavenDeviceAttitudeActiveObject::DetectStationaryStatus(this);
      uint64_t v7 = (void *)*((void *)this + 61);
    }
    v14.i64[0] = v7[143];
    uint64_t v74 = 0;
    uint64_t v75 = 0;
    CNTimeSpan::SetTimeSpan(&v74, 0, v14, v15);
    uint64_t v20 = CNTimeSpan::operator+((uint64_t)this + 7600, &v74, v18, v19);
    if (v4) {
      BOOL v24 = 1;
    }
    else {
      BOOL v24 = (*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
    }
    if (!v24
      || !v20 && (*(void *)&v21 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || (BOOL v25 = (uint64_t)v4 <= v20, v4 == (void *)v20))
    {
      BOOL v25 = v6 <= v21;
    }
    if (!v25)
    {
      *((_OWORD *)this + 475) = *(_OWORD *)__p;
      raven::RavenDeviceAttitudeActiveObject::DownSamplingAccelGyroSamples((uint64_t)this);
      uint64_t v7 = (void *)*((void *)this + 61);
    }
    v22.i64[0] = v7[136];
    uint64_t v74 = 0;
    uint64_t v75 = 0;
    CNTimeSpan::SetTimeSpan(&v74, 0, v22, v23);
    uint64_t v28 = CNTimeSpan::operator+((uint64_t)this + 7616, &v74, v26, v27);
    if (!v4 && (*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || !v28 && (*(void *)&v29 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || (BOOL v32 = (uint64_t)v4 <= v28, v4 == (void *)v28))
    {
      BOOL v32 = v6 <= v29;
    }
    if (!v32)
    {
      *((void *)this + 952) = v4;
      *((void *)this + 953) = 0;
      raven::RavenDeviceAttitudeActiveObject::RaiseExternalAttitudeEvent((uint64_t)this, a2);
      uint64_t v7 = (void *)*((void *)this + 61);
    }
    v30.i64[0] = v7[136];
    uint64_t v74 = 0;
    uint64_t v75 = 0;
    CNTimeSpan::SetTimeSpan(&v74, 0, v30, v31);
    uint64_t v35 = CNTimeSpan::operator+((uint64_t)this + 7648, &v74, v33, v34);
    *(double *)v38.i64 = v36;
    if (!v4 && (*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || !v35 && (*(void *)&v36 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || (BOOL v39 = (uint64_t)v4 <= v35, v4 == (void *)v35))
    {
      BOOL v39 = v6 <= v36;
    }
    if (!v39)
    {
      *((void *)this + 956) = v4;
      *((void *)this + 957) = 0;
      raven::RavenDeviceAttitudeActiveObject::RaiseNonHolonomicEvent((uint64_t)this, a2);
    }
    uint64_t v74 = 2;
    uint64_t v75 = 0;
    uint64_t v40 = CNTimeSpan::operator+((uint64_t)this + 7680, &v74, v38, v37);
    *(double *)v43.i64 = v41;
    if (!v4 && (*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || !v40 && (*(void *)&v41 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || (BOOL v44 = (uint64_t)v4 <= v40, v4 == (void *)v40))
    {
      BOOL v44 = v6 <= v41;
    }
    if (!v44)
    {
      *((void *)this + 960) = v4;
      *((void *)this + 961) = 0;
      raven::RavenDeviceAttitudeActiveObject::RemoveStaleSolutions(this, (uint64_t)__p, v43, v42);
    }
    uint64_t v45 = *((void *)this + 61);
    v43.i64[0] = *(void *)(v45 + 1040);
    uint64_t v74 = 0;
    uint64_t v75 = 0;
    CNTimeSpan::SetTimeSpan(&v74, 0, v43, v42);
    uint64_t v48 = CNTimeSpan::operator+((uint64_t)this + 7632, &v74, v46, v47);
    if (!v4 && (*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || !v48 && (*(void *)&v49 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || (BOOL v52 = (uint64_t)v4 <= v48, v4 == (void *)v48))
    {
      BOOL v52 = v6 <= v49;
    }
    if (!v52)
    {
      *((void *)this + 954) = v4;
      *((void *)this + 955) = 0;
      raven::RavenDeviceAttitudeActiveObject::UpdateDeviceAttitudeByLinearAcceleration(this, a2);
      uint64_t v45 = *((void *)this + 61);
    }
    v50.i64[0] = *(void *)(v45 + 1088);
    uint64_t v74 = 0;
    uint64_t v75 = 0;
    CNTimeSpan::SetTimeSpan(&v74, 0, v50, v51);
    uint64_t v55 = CNTimeSpan::operator+((uint64_t)this + 7712, &v74, v53, v54);
    if (!v4 && (*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || !v55 && (*(void *)&v56 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || (BOOL v59 = (uint64_t)v4 <= v55, v4 == (void *)v55))
    {
      BOOL v59 = v6 <= v56;
    }
    if (!v59)
    {
      *((void *)this + 964) = v4;
      *((void *)this + 965) = 0;
      raven::RavenDeviceAttitudeActiveObject::UpdateDeviceAttitudeByWahbaSolution(this, a2);
      uint64_t v45 = *((void *)this + 61);
    }
    v57.i64[0] = *(void *)(v45 + 1136);
    uint64_t v74 = 0;
    uint64_t v75 = 0;
    CNTimeSpan::SetTimeSpan(&v74, 0, v57, v58);
    uint64_t v62 = CNTimeSpan::operator+((uint64_t)this + 7664, &v74, v60, v61);
    *(double *)v65.i64 = v63;
    if (!v4 && (*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || !v62 && (*(void *)&v63 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || (BOOL v66 = (uint64_t)v4 <= v62, v4 == (void *)v62))
    {
      BOOL v66 = v6 <= v63;
    }
    if (!v66)
    {
      *((_OWORD *)this + 479) = *(_OWORD *)__p;
      raven::RavenDeviceAttitudeActiveObject::UpdateDeviceVehicleAttitudeWithRotation(this);
      uint64_t v45 = *((void *)this + 61);
    }
    if (*(unsigned char *)(v45 + 3801))
    {
      if (*((unsigned char *)this + 7176))
      {
        unsigned int v67 = *((unsigned __int8 *)this + 7088);
        if (v67 <= 6 && ((1 << v67) & 0x4C) != 0)
        {
          if (*((unsigned char *)this + 7496)) {
            raven::RavenDeviceAttitudeActiveObject::ComputePCABasedHorizontalDirectionOfTravelInIMUFrame(this, a2, v65, v64);
          }
        }
      }
    }
  }
  else
  {
    LOWORD(v74) = 12;
    unsigned __int8 v78 = 3;
    (*(void (**)(void **__return_ptr, raven::RavenDeviceAttitudeActiveObject *, const raven::TimeMarkEvent *))(*(void *)this + 16))(__p, this, a2);
    if (v77 >= 0) {
      uint64_t v73 = __p;
    }
    else {
      LOBYTE(v73) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v74, &v78, "Warning: %s is not configured yet.", v68, v69, v70, v71, v72, (char)v73);
    if (v77 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_18E170350(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 raven::RavenDeviceAttitudeActiveObject::HandleEvent(raven::RavenDeviceAttitudeActiveObject *this, const raven::UserGaitEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    if (*((unsigned char *)this + 7496))
    {
      *((_OWORD *)this + 460) = *(_OWORD *)((char *)a2 + 8);
      long long v2 = *(_OWORD *)((char *)a2 + 24);
      long long v3 = *(_OWORD *)((char *)a2 + 40);
      long long v4 = *(_OWORD *)((char *)a2 + 56);
      *((_OWORD *)this + 464) = *(_OWORD *)((char *)a2 + 72);
      *((_OWORD *)this + 463) = v4;
      *((_OWORD *)this + 462) = v3;
      *((_OWORD *)this + 461) = v2;
      __n128 result = *(__n128 *)((char *)a2 + 88);
      long long v6 = *(_OWORD *)((char *)a2 + 104);
      long long v7 = *(_OWORD *)((char *)a2 + 120);
      *((void *)this + 936) = *((void *)a2 + 17);
      *((_OWORD *)this + 467) = v7;
      *((_OWORD *)this + 466) = v6;
      *((__n128 *)this + 465) = result;
    }
    else
    {
      *((void *)this + 919) = &unk_1EDD13850;
      *((_OWORD *)this + 460) = *(_OWORD *)((char *)a2 + 8);
      long long v14 = *(_OWORD *)((char *)a2 + 24);
      long long v15 = *(_OWORD *)((char *)a2 + 40);
      long long v16 = *(_OWORD *)((char *)a2 + 56);
      *((_OWORD *)this + 464) = *(_OWORD *)((char *)a2 + 72);
      *((_OWORD *)this + 463) = v16;
      *((_OWORD *)this + 462) = v15;
      *((_OWORD *)this + 461) = v14;
      __n128 result = *(__n128 *)((char *)a2 + 88);
      long long v17 = *(_OWORD *)((char *)a2 + 104);
      long long v18 = *(_OWORD *)((char *)a2 + 120);
      *((void *)this + 936) = *((void *)a2 + 17);
      *((_OWORD *)this + 467) = v18;
      *((_OWORD *)this + 466) = v17;
      *((__n128 *)this + 465) = result;
      *((unsigned char *)this + 7496) = 1;
    }
  }
  else
  {
    __int16 v22 = 12;
    unsigned __int8 v21 = 3;
    (*(void (**)(void **__return_ptr))(*(void *)this + 16))(__p);
    if (v20 >= 0) {
      double v13 = __p;
    }
    else {
      LOBYTE(v13) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v22, &v21, "Warning: %s is not configured yet.", v8, v9, v10, v11, v12, (char)v13);
    if (v20 < 0) {
      operator delete(__p[0]);
    }
  }
  return result;
}

void sub_18E1704E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void raven::RavenDeviceAttitudeActiveObject::Reset(raven::RavenDeviceAttitudeActiveObject *this)
{
  long long v2 = (void **)*((void *)this + 63);
  long long v3 = (void **)*((void *)this + 64);
  if (v3 == v2)
  {
    long long v6 = (void *)((char *)this + 536);
    long long v3 = (void **)*((void *)this + 63);
  }
  else
  {
    unint64_t v4 = *((void *)this + 66);
    uint64_t v5 = &v2[v4 / 0x1A];
    long long v6 = (void *)((char *)this + 536);
    unint64_t v7 = (unint64_t)v2[(*((void *)this + 67) + v4) / 0x1A] + 152 * ((*((void *)this + 67) + v4) % 0x1A);
    if ((char *)*v5 + 152 * (v4 % 0x1A) != (void *)v7)
    {
      uint64_t v8 = (void (***)(void))((char *)*v5 + 152 * (v4 % 0x1A));
      do
      {
        uint64_t v9 = *v8;
        v8 += 19;
        (*v9)();
        if ((char *)v8 - (unsigned char *)*v5 == 3952)
        {
          uint64_t v10 = (void (***)(void))v5[1];
          ++v5;
          uint64_t v8 = v10;
        }
      }
      while (v8 != (void (***)(void))v7);
      long long v2 = (void **)*((void *)this + 63);
      long long v3 = (void **)*((void *)this + 64);
    }
  }
  *long long v6 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if (v11 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v12 = *((void *)this + 64);
      long long v2 = (void **)(*((void *)this + 63) + 8);
      *((void *)this + 63) = v2;
      unint64_t v11 = v12 - (void)v2;
    }
    while (v11 > 0x10);
  }
  if (v11 >> 3 == 1)
  {
    uint64_t v13 = 13;
  }
  else
  {
    if (v11 >> 3 != 2) {
      goto LABEL_16;
    }
    uint64_t v13 = 26;
  }
  *((void *)this + 66) = v13;
LABEL_16:
  *((int64x2_t *)this + 34) = vdupq_n_s64(0x3FB999999999999AuLL);
  *((void *)this + 70) = 0x3FB999999999999ALL;
  *(_OWORD *)((char *)this + 776) = 0u;
  *(_OWORD *)((char *)this + 1160) = 0u;
  long long v14 = (void **)*((void *)this + 864);
  long long v15 = (void **)*((void *)this + 865);
  if (v15 == v14)
  {
    long long v18 = (void *)((char *)this + 6944);
    long long v15 = (void **)*((void *)this + 864);
  }
  else
  {
    unint64_t v16 = *((void *)this + 867);
    long long v17 = &v14[v16 / 0x1A];
    long long v18 = (void *)((char *)this + 6944);
    unint64_t v19 = (unint64_t)v14[(*((void *)this + 868) + v16) / 0x1A] + 152 * ((*((void *)this + 868) + v16) % 0x1A);
    if ((char *)*v17 + 152 * (v16 % 0x1A) != (void *)v19)
    {
      char v20 = (void (***)(void))((char *)*v17 + 152 * (v16 % 0x1A));
      do
      {
        unsigned __int8 v21 = *v20;
        v20 += 19;
        (*v21)();
        if ((char *)v20 - (unsigned char *)*v17 == 3952)
        {
          __int16 v22 = (void (***)(void))v17[1];
          ++v17;
          char v20 = v22;
        }
      }
      while (v20 != (void (***)(void))v19);
      long long v15 = (void **)*((void *)this + 865);
      long long v14 = (void **)*((void *)this + 864);
    }
  }
  *long long v18 = 0;
  unint64_t v23 = (char *)v15 - (char *)v14;
  if (v23 >= 0x11)
  {
    do
    {
      operator delete(*v14);
      long long v14 = (void **)(*((void *)this + 864) + 8);
      *((void *)this + 864) = v14;
      unint64_t v23 = *((void *)this + 865) - (void)v14;
    }
    while (v23 > 0x10);
  }
  if (v23 >> 3 == 1)
  {
    uint64_t v24 = 13;
  }
  else
  {
    if (v23 >> 3 != 2) {
      goto LABEL_31;
    }
    uint64_t v24 = 26;
  }
  *((void *)this + 867) = v24;
LABEL_31:
  *((void *)this + 869) = 0x3FF0000000000000;
  __asm { FMOV            V0.2D, #1.0 }
  *((_OWORD *)this + 435) = _Q0;
  if (*((unsigned char *)this + 1432)) {
    *((unsigned char *)this + 1432) = 0;
  }
  *((_WORD *)this + 3488) = 0;
  *((unsigned char *)this + 6979) = 0;
  *(_OWORD *)((char *)this + 7336) = 0u;
  if (*((unsigned char *)this + 7496)) {
    *((unsigned char *)this + 7496) = 0;
  }
  *((_DWORD *)this + 1894) = 0;
  *((_OWORD *)this + 474) = xmmword_18E200CA0;
  *((_OWORD *)this + 475) = 0uLL;
  *((_OWORD *)this + 476) = 0uLL;
  *((_OWORD *)this + 477) = 0uLL;
  *((_OWORD *)this + 478) = 0uLL;
  *((_OWORD *)this + 479) = 0uLL;
  *((_OWORD *)this + 480) = 0uLL;
  *((_OWORD *)this + 481) = 0uLL;
  *((_OWORD *)this + 482) = 0uLL;
  int8x16_t v30 = (void **)*((void *)this + 967);
  int8x16_t v31 = (void **)*((void *)this + 968);
  if (v31 == v30)
  {
    int8x16_t v34 = (void *)((char *)this + 7768);
    int8x16_t v31 = (void **)*((void *)this + 967);
  }
  else
  {
    unint64_t v32 = *((void *)this + 970);
    int8x16_t v33 = &v30[v32 / 0x1A];
    int8x16_t v34 = (void *)((char *)this + 7768);
    unint64_t v35 = (unint64_t)v30[(*((void *)this + 971) + v32) / 0x1A] + 152 * ((*((void *)this + 971) + v32) % 0x1A);
    if ((char *)*v33 + 152 * (v32 % 0x1A) != (void *)v35)
    {
      double v36 = (void (***)(void))((char *)*v33 + 152 * (v32 % 0x1A));
      do
      {
        int8x16_t v37 = *v36;
        v36 += 19;
        (*v37)();
        if ((char *)v36 - (unsigned char *)*v33 == 3952)
        {
          int8x16_t v38 = (void (***)(void))v33[1];
          ++v33;
          double v36 = v38;
        }
      }
      while (v36 != (void (***)(void))v35);
      int8x16_t v31 = (void **)*((void *)this + 968);
      int8x16_t v30 = (void **)*((void *)this + 967);
    }
  }
  *int8x16_t v34 = 0;
  unint64_t v39 = (char *)v31 - (char *)v30;
  if (v39 >= 0x11)
  {
    do
    {
      operator delete(*v30);
      int8x16_t v30 = (void **)(*((void *)this + 967) + 8);
      *((void *)this + 967) = v30;
      unint64_t v39 = *((void *)this + 968) - (void)v30;
    }
    while (v39 > 0x10);
  }
  if (v39 >> 3 == 1)
  {
    uint64_t v40 = 13;
  }
  else
  {
    if (v39 >> 3 != 2) {
      goto LABEL_50;
    }
    uint64_t v40 = 26;
  }
  *((void *)this + 970) = v40;
LABEL_50:
  double v41 = (void **)*((void *)this + 973);
  int8x16_t v42 = (void **)*((void *)this + 974);
  if (v42 == v41)
  {
    uint64_t v45 = (void *)((char *)this + 7816);
    int8x16_t v42 = (void **)*((void *)this + 973);
  }
  else
  {
    unint64_t v43 = *((void *)this + 976);
    BOOL v44 = &v41[v43 / 0x1A];
    uint64_t v45 = (void *)((char *)this + 7816);
    unint64_t v46 = (unint64_t)v41[(*((void *)this + 977) + v43) / 0x1A] + 152 * ((*((void *)this + 977) + v43) % 0x1A);
    if ((char *)*v44 + 152 * (v43 % 0x1A) != (void *)v46)
    {
      int8x16_t v47 = (void (***)(void))((char *)*v44 + 152 * (v43 % 0x1A));
      do
      {
        uint64_t v48 = *v47;
        v47 += 19;
        (*v48)();
        if ((char *)v47 - (unsigned char *)*v44 == 3952)
        {
          double v49 = (void (***)(void))v44[1];
          ++v44;
          int8x16_t v47 = v49;
        }
      }
      while (v47 != (void (***)(void))v46);
      int8x16_t v42 = (void **)*((void *)this + 974);
      double v41 = (void **)*((void *)this + 973);
    }
  }
  *uint64_t v45 = 0;
  unint64_t v50 = (char *)v42 - (char *)v41;
  if (v50 >= 0x11)
  {
    do
    {
      operator delete(*v41);
      double v41 = (void **)(*((void *)this + 973) + 8);
      *((void *)this + 973) = v41;
      unint64_t v50 = *((void *)this + 974) - (void)v41;
    }
    while (v50 > 0x10);
  }
  if (v50 >> 3 == 1)
  {
    uint64_t v51 = 13;
  }
  else
  {
    if (v50 >> 3 != 2) {
      goto LABEL_65;
    }
    uint64_t v51 = 26;
  }
  *((void *)this + 976) = v51;
LABEL_65:
  BOOL v52 = (void **)*((void *)this + 979);
  int8x16_t v53 = (void **)*((void *)this + 980);
  if (v53 == v52)
  {
    int8x16_t v57 = (void *)((char *)this + 7864);
    int8x16_t v53 = (void **)*((void *)this + 979);
  }
  else
  {
    unint64_t v54 = *((void *)this + 982);
    uint64_t v55 = &v52[v54 >> 4];
    double v56 = (char *)*v55 + 2432 * (v54 & 0xF);
    int8x16_t v57 = (void *)((char *)this + 7864);
    uint64_t v58 = *(uint64_t *)((char *)v52 + (((*((void *)this + 983) + v54) >> 1) & 0x7FFFFFFFFFFFFFF8))
        + 2432 * ((*((_DWORD *)this + 1966) + (int)v54) & 0xF);
    if (v56 != (char *)v58)
    {
      do
      {
        (**(void (***)(char *))v56)(v56);
        v56 += 2432;
        if (v56 - (unsigned char *)*v55 == 38912)
        {
          BOOL v59 = (char *)v55[1];
          ++v55;
          double v56 = v59;
        }
      }
      while (v56 != (char *)v58);
      int8x16_t v53 = (void **)*((void *)this + 980);
      BOOL v52 = (void **)*((void *)this + 979);
    }
  }
  *int8x16_t v57 = 0;
  unint64_t v60 = (char *)v53 - (char *)v52;
  if (v60 >= 0x11)
  {
    do
    {
      operator delete(*v52);
      BOOL v52 = (void **)(*((void *)this + 979) + 8);
      *((void *)this + 979) = v52;
      unint64_t v60 = *((void *)this + 980) - (void)v52;
    }
    while (v60 > 0x10);
  }
  if (v60 >> 3 == 1)
  {
    uint64_t v61 = 8;
  }
  else
  {
    if (v60 >> 3 != 2) {
      goto LABEL_79;
    }
    uint64_t v61 = 16;
  }
  *((void *)this + 982) = v61;
LABEL_79:
  uint64_t v62 = (void **)*((void *)this + 985);
  double v63 = (void **)*((void *)this + 986);
  if (v63 == v62)
  {
    unsigned int v67 = (void *)((char *)this + 7912);
    double v63 = (void **)*((void *)this + 985);
  }
  else
  {
    unint64_t v64 = *((void *)this + 988);
    int8x16_t v65 = &v62[v64 >> 4];
    BOOL v66 = (char *)*v65 + 2432 * (v64 & 0xF);
    unsigned int v67 = (void *)((char *)this + 7912);
    uint64_t v68 = *(uint64_t *)((char *)v62 + (((*((void *)this + 989) + v64) >> 1) & 0x7FFFFFFFFFFFFFF8))
        + 2432 * ((*((_DWORD *)this + 1978) + (int)v64) & 0xF);
    if (v66 != (char *)v68)
    {
      do
      {
        (**(void (***)(char *))v66)(v66);
        v66 += 2432;
        if (v66 - (unsigned char *)*v65 == 38912)
        {
          uint64_t v69 = (char *)v65[1];
          ++v65;
          BOOL v66 = v69;
        }
      }
      while (v66 != (char *)v68);
      double v63 = (void **)*((void *)this + 986);
      uint64_t v62 = (void **)*((void *)this + 985);
    }
  }
  *unsigned int v67 = 0;
  unint64_t v70 = (char *)v63 - (char *)v62;
  if (v70 >= 0x11)
  {
    do
    {
      operator delete(*v62);
      uint64_t v62 = (void **)(*((void *)this + 985) + 8);
      *((void *)this + 985) = v62;
      unint64_t v70 = *((void *)this + 986) - (void)v62;
    }
    while (v70 > 0x10);
  }
  if (v70 >> 3 == 1)
  {
    uint64_t v71 = 8;
  }
  else
  {
    if (v70 >> 3 != 2) {
      goto LABEL_93;
    }
    uint64_t v71 = 16;
  }
  *((void *)this + 988) = v71;
LABEL_93:
  raven::RavenDeviceAttitudeActiveObject::ResetWahbaSolver(this);
  cnframework::ActiveObjectBase::ResetCurrentTime(this);
  cnframework::ActiveObjectBase::ResetEventQueue(this);
  uint64_t v72 = (void **)*((void *)this + 997);
  uint64_t v73 = (void **)*((void *)this + 998);
  if (v73 == v72)
  {
    double v76 = (void *)((char *)this + 8008);
    uint64_t v73 = (void **)*((void *)this + 997);
  }
  else
  {
    unint64_t v74 = *((void *)this + 1000);
    uint64_t v75 = &v72[v74 / 0x1A];
    double v76 = (void *)((char *)this + 8008);
    unint64_t v77 = (unint64_t)v72[(*((void *)this + 1001) + v74) / 0x1A]
        + 152 * ((*((void *)this + 1001) + v74) % 0x1A);
    if ((char *)*v75 + 152 * (v74 % 0x1A) != (void *)v77)
    {
      unsigned __int8 v78 = (void (***)(void))((char *)*v75 + 152 * (v74 % 0x1A));
      do
      {
        uint64_t v79 = *v78;
        v78 += 19;
        (*v79)();
        if ((char *)v78 - (unsigned char *)*v75 == 3952)
        {
          unint64_t v80 = (void (***)(void))v75[1];
          ++v75;
          unsigned __int8 v78 = v80;
        }
      }
      while (v78 != (void (***)(void))v77);
      uint64_t v73 = (void **)*((void *)this + 998);
      uint64_t v72 = (void **)*((void *)this + 997);
    }
  }
  *double v76 = 0;
  unint64_t v81 = (char *)v73 - (char *)v72;
  if (v81 >= 0x11)
  {
    do
    {
      operator delete(*v72);
      uint64_t v72 = (void **)(*((void *)this + 997) + 8);
      *((void *)this + 997) = v72;
      unint64_t v81 = *((void *)this + 998) - (void)v72;
    }
    while (v81 > 0x10);
  }
  if (v81 >> 3 == 1)
  {
    uint64_t v82 = 13;
  }
  else
  {
    if (v81 >> 3 != 2) {
      goto LABEL_108;
    }
    uint64_t v82 = 26;
  }
  *((void *)this + 1000) = v82;
LABEL_108:
  unint64_t v83 = (void **)*((void *)this + 991);
  uint64_t v84 = (void **)*((void *)this + 992);
  if (v84 == v83)
  {
    unint64_t v87 = (void *)((char *)this + 7960);
    uint64_t v84 = (void **)*((void *)this + 991);
  }
  else
  {
    unint64_t v85 = *((void *)this + 994);
    uint64_t v86 = &v83[v85 / 0x1A];
    unint64_t v87 = (void *)((char *)this + 7960);
    unint64_t v88 = (unint64_t)v83[(*((void *)this + 995) + v85) / 0x1A] + 152 * ((*((void *)this + 995) + v85) % 0x1A);
    if ((char *)*v86 + 152 * (v85 % 0x1A) != (void *)v88)
    {
      unint64_t v89 = (void (***)(void))((char *)*v86 + 152 * (v85 % 0x1A));
      do
      {
        uint64_t v90 = *v89;
        v89 += 19;
        (*v90)();
        if ((char *)v89 - (unsigned char *)*v86 == 3952)
        {
          uint64_t v91 = (void (***)(void))v86[1];
          ++v86;
          unint64_t v89 = v91;
        }
      }
      while (v89 != (void (***)(void))v88);
      uint64_t v84 = (void **)*((void *)this + 992);
      unint64_t v83 = (void **)*((void *)this + 991);
    }
  }
  *unint64_t v87 = 0;
  unint64_t v92 = (char *)v84 - (char *)v83;
  if (v92 >= 0x11)
  {
    do
    {
      operator delete(*v83);
      unint64_t v83 = (void **)(*((void *)this + 991) + 8);
      *((void *)this + 991) = v83;
      unint64_t v92 = *((void *)this + 992) - (void)v83;
    }
    while (v92 > 0x10);
  }
  if (v92 >> 3 == 1)
  {
    uint64_t v93 = 13;
    goto LABEL_122;
  }
  if (v92 >> 3 == 2)
  {
    uint64_t v93 = 26;
LABEL_122:
    *((void *)this + 994) = v93;
  }
  *((unsigned char *)this + 8400) = 0;
}

void sub_18E170EF8(cnframework::ActiveObjectBase *a1)
{
  sub_18E0B85B4(a1);

  JUMPOUT(0x192FA6240);
}

void *sub_18E170F30@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenDeviceAttitudeActiveObject");
}

uint64_t sub_18E170F40(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1EDD13298;
  *(void *)(a1 + 8) = &unk_1EDD14DC8;
  sub_18DFE2FA8(a1 + 16, a2 + 8);
  long long v4 = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 144) = v4;
  long long v5 = *(_OWORD *)(a2 + 152);
  long long v6 = *(_OWORD *)(a2 + 168);
  long long v7 = *(_OWORD *)(a2 + 200);
  *(_OWORD *)(a1 + 192) = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 208) = v7;
  *(_OWORD *)(a1 + 160) = v5;
  *(_OWORD *)(a1 + 176) = v6;
  sub_18DFF2980(a1 + 224, a2 + 216);
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  if (a1 + 288 != a2 + 280)
  {
    *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 280);
    *(_OWORD *)(a1 + 304) = *(_OWORD *)(a2 + 296);
  }
  return a1;
}

void sub_18E171014(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

void *sub_18E171034(void *result)
{
  result[1] = &unk_1EDD14DC8;
  result[28] = &unk_1EDD17478;
  result[2] = &unk_1EDD17478;
  return result;
}

void sub_18E171098(void *a1)
{
  a1[1] = &unk_1EDD14DC8;
  a1[28] = &unk_1EDD17478;
  a1[2] = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

void *sub_18E17110C()
{
}

void sub_18E171118()
{
}

void sub_18E171160(_Unwind_Exception *a1)
{
  MEMORY[0x192FA6240](v1, 0x1081C40374DCE79);
  _Unwind_Resume(a1);
}

uint64_t sub_18E171184(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned int v12 = *(_DWORD *)(a1 + 8);
  unsigned int v11 = *(_DWORD *)(a1 + 12);
  if (v11 >= v12) {
    int v13 = *(_DWORD *)(a1 + 8);
  }
  else {
    int v13 = *(_DWORD *)(a1 + 12);
  }
  unsigned int v14 = *(_DWORD *)(a3 + 28) * *(_DWORD *)(a3 + 24);
  sub_18DFE2F24(a2, a1);
  __CLPK_integer v15 = *(_DWORD *)(a2 + 8);
  __CLPK_integer v16 = *(_DWORD *)(a2 + 12);
  long long v17 = *(__CLPK_doublereal **)(a2 + 32);
  long long v18 = *(__CLPK_doublereal **)(a5 + 32);
  unint64_t v19 = *(__CLPK_doublereal **)(a4 + 32);
  char v20 = *(__CLPK_doublereal **)(a6 + 32);
  unsigned __int8 v21 = *(__CLPK_doublereal **)(a3 + 32);
  char __jobu = 65;
  char __jobvt = 65;
  __CLPK_integer __n = v16;
  __CLPK_integer __m = v15;
  __CLPK_integer __ldu = v15;
  __CLPK_integer __lda = v15;
  __lworint k = v14;
  __CLPK_integer __ldvt = v16;
  __CLPK_integer v52 = 0;
  __int16 v22 = (cnprint::CNPrinter *)dgesvd_(&__jobu, &__jobvt, &__m, &__n, v17, &__lda, v18, v19, &__ldu, v20, &__ldvt, v21, &__lwork, &v52);
  if (v52)
  {
    LOWORD(__m) = 4;
    if (v52 < 0)
    {
      LOBYTE(__n) = 5;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&__m, (unsigned __int8 *)&__n, "Error using Svd: input argument %d invalid in gesvd.", v23, v24, v25, v26, v27, -(char)v52);
    }
    else
    {
      LOBYTE(__n) = 4;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&__m, (unsigned __int8 *)&__n, "Error using Svd: gesvd failed to converge on %d superdiagonals.", v23, v24, v25, v26, v27, v52);
    }
  }
  unsigned int v28 = **(double **)(a3 + 32);
  if (v14 < v28 && cnprint::CNPrinter::GetLogLevel(v22) <= 1)
  {
    LOWORD(__m) = 4;
    LOBYTE(__n) = 1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&__m, (unsigned __int8 *)&__n, "Warning: Svd optimal workspace size %u is greater than provided workspace size %u; performance may suffer.",
      v29,
      v30,
      v31,
      v32,
      v33,
      v28);
  }
  int v34 = *(_DWORD *)(a3 + 24);
  int v35 = *(_DWORD *)(a3 + 28);
  *(_DWORD *)(a3 + 8) = v34;
  *(_DWORD *)(a3 + 12) = v35;
  *(_DWORD *)(a3 + 16) = v35 * v34;
  *(_DWORD *)(a3 + 20) = v34;
  *(_DWORD *)(a4 + 8) = v12;
  *(_DWORD *)(a4 + 12) = v12;
  *(_DWORD *)(a4 + 16) = v12 * v12;
  *(_DWORD *)(a4 + 20) = v12;
  *(_DWORD *)(a5 + 8) = v12;
  *(_DWORD *)(a5 + 12) = v11;
  *(_DWORD *)(a5 + 16) = v11 * v12;
  *(_DWORD *)(a5 + 20) = v12;
  if (v13)
  {
    int v36 = 0;
    int8x16_t v37 = *(uint64_t **)(a5 + 32);
    int8x16_t v38 = v37;
    do
    {
      uint64_t v39 = *v38++;
      v37[v36] = v39;
      v36 += v12 + 1;
      --v13;
    }
    while (v13);
  }
  if (v11)
  {
    int v40 = 0;
    unsigned int v41 = 0;
    uint64_t v42 = *(void *)(a5 + 32);
    unsigned int v43 = v12 - 1;
    int v44 = 1;
    do
    {
      if (v12 >= v41) {
        unsigned int v45 = v41;
      }
      else {
        unsigned int v45 = v12;
      }
      for (int i = v40; v45; --v45)
        *(void *)(v42 + 8 * i++) = 0;
      ++v41;
      int v47 = v44;
      unsigned int v48 = v43;
      if (v41 < v12)
      {
        do
        {
          *(void *)(v42 + 8 * v47++) = 0;
          --v48;
        }
        while (v48);
      }
      v40 += v12;
      --v43;
      v44 += v12 + 1;
    }
    while (v41 != v11);
  }
  *(_DWORD *)(a6 + 8) = v11;
  *(_DWORD *)(a6 + 12) = v11;
  *(_DWORD *)(a6 + 16) = v11 * v11;
  *(_DWORD *)(a6 + 20) = v11;
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a6 + 24))(a6);
  int v51 = *(_DWORD *)(a6 + 8);
  int v50 = *(_DWORD *)(a6 + 12);
  *(_DWORD *)(a6 + 8) = v50;
  *(_DWORD *)(a6 + 12) = v51;
  *(_DWORD *)(a6 + 16) = v51 * v50;
  *(_DWORD *)(a6 + 20) = v50;
  return result;
}

uint64_t sub_18E171404(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v134 = v2;
  uint64_t v135 = v1;
  uint64_t v136 = v3;
  int v5 = v4;
  uint64_t v7 = v6;
  uint64_t v196 = 0x400000004;
  BOOL v194 = &unk_1EDD195A8;
  double v197 = &v198;
  long long v195 = xmmword_18E1F6F70;
  sub_18DFE2CC8((uint64_t)&v194, 0.0);
  v203[0] = 0x100000000;
  uint64_t v190 = 0x100000003;
  double v188 = &unk_1EDD18DC8;
  uint64_t v191 = &v192;
  long long v189 = xmmword_18E1F6F60;
  int v193 = 2;
  uint64_t v192 = 0x100000000;
  if (v5 < 1) {
    return 25;
  }
  unsigned int v8 = v5;
  uint64_t v132 = v7;
  uint64_t v9 = 0;
  unsigned int v10 = 0;
  uint64_t v133 = v8;
  do
  {
    sub_18E172A70((uint64_t)&v183, v136, v9);
    uint64_t v227 = 0x100000003;
    long long v226 = xmmword_18E1F6F60;
    long long v225 = &unk_1EDD18D98;
    __a = (__CLPK_doublereal *)v229;
    uint64_t v201 = 0x100000134;
    long long v200 = xmmword_18E1F6FB0;
    int8x16_t v199 = &unk_1EDD18C48;
    __worunsigned int k = (__CLPK_doublereal *)v203;
    uint64_t v222 = 0x100000003;
    long long v221 = xmmword_18E1F6F60;
    double v220 = &unk_1EDD18D98;
    __wint i = (__CLPK_doublereal *)v224;
    sub_18DFE345C((uint64_t)&v183, (uint64_t)&v225, (uint64_t)&v199, (uint64_t)&v220, "2");
    double v12 = fabs(v11.f64[0]);
    if (v12 >= 2.22044605e-16)
    {
      uint64_t v201 = 0x100000003;
      long long v200 = xmmword_18E1F6F60;
      int8x16_t v199 = &unk_1EDD18D98;
      __worunsigned int k = (__CLPK_doublereal *)v203;
      v11.f64[0] = 1.0 / v11.f64[0];
      sub_18DFE3240((uint64_t)&v183, (uint64_t)&v199, v11);
      sub_18DFE2F24((uint64_t)&v183, (uint64_t)&v199);
    }
    sub_18E172A70((uint64_t)&__n, v135, v9);
    uint64_t v227 = 0x100000003;
    long long v226 = xmmword_18E1F6F60;
    long long v225 = &unk_1EDD18D98;
    __a = (__CLPK_doublereal *)v229;
    uint64_t v201 = 0x100000134;
    long long v200 = xmmword_18E1F6FB0;
    int8x16_t v199 = &unk_1EDD18C48;
    __worunsigned int k = (__CLPK_doublereal *)v203;
    uint64_t v222 = 0x100000003;
    long long v221 = xmmword_18E1F6F60;
    double v220 = &unk_1EDD18D98;
    __wint i = (__CLPK_doublereal *)v224;
    sub_18DFE345C((uint64_t)&__n, (uint64_t)&v225, (uint64_t)&v199, (uint64_t)&v220, "2");
    if (fabs(v13.f64[0]) < 2.22044605e-16)
    {
      int v14 = 0;
    }
    else
    {
      uint64_t v201 = 0x100000003;
      long long v200 = xmmword_18E1F6F60;
      int8x16_t v199 = &unk_1EDD18D98;
      __worunsigned int k = (__CLPK_doublereal *)v203;
      v13.f64[0] = 1.0 / v13.f64[0];
      sub_18DFE3240((uint64_t)&__n, (uint64_t)&v199, v13);
      sub_18DFE2F24((uint64_t)&__n, (uint64_t)&v199);
      int v14 = v12 >= 2.22044605e-16;
    }
    uint64_t v15 = v180;
    double v16 = 0.0;
    if (v180 >= 1)
    {
      long long v17 = v182;
      long long v18 = v187;
      do
      {
        double v19 = *v17++;
        double v20 = v19;
        double v21 = *v18++;
        double v16 = v16 + v20 * v21;
        --v15;
      }
      while (v15);
    }
    uint64_t v201 = 0x100000003;
    int8x16_t v199 = &unk_1EDD18D98;
    __worunsigned int k = (__CLPK_doublereal *)v203;
    *(void *)&long long v200 = v179;
    DWORD2(v200) = HIDWORD(v179) * v179;
    HIDWORD(v200) = v179;
    double v22 = *v182;
    double v23 = v182[1];
    double v24 = v182[2];
    double v25 = *v187;
    double v26 = v187[1];
    double v27 = v187[2];
    double v28 = v23 * v27 - v24 * v26;
    double v29 = v24 * *v187 - *v182 * v27;
    *(double *)uint64_t v203 = v28;
    *(double *)&v203[1] = v29;
    *(double *)&v203[2] = v22 * v26 - v23 * v25;
    sub_18E1642D0((uint64_t)&__lda, (uint64_t)&v199);
    uint64_t v227 = 0x400000004;
    long long v226 = xmmword_18E1F6F70;
    long long v225 = &unk_1EDD195A8;
    __a = (__CLPK_doublereal *)v229;
    uint64_t v139 = 0x300000003;
    double v137 = &unk_1EDD18EE8;
    uint64_t v140 = (__CLPK_doublereal *)v141;
    long long v138 = xmmword_18E1F0010;
    sub_18DFE2CC8((uint64_t)&v137, 0.0);
    int v30 = HIDWORD(v138) + 1;
    uint64_t v31 = v140;
    *uint64_t v140 = 1.0;
    v31[v30] = 1.0;
    v31[2 * v30] = 1.0;
    uint64_t v144 = 0x300000003;
    *(void *)&v32.f64[1] = 0x300000009;
    long long v143 = xmmword_18E1F0010;
    uint64_t v142 = &unk_1EDD18EE8;
    __wr = (__CLPK_doublereal *)v146;
    v32.f64[0] = v16;
    sub_18DFE3240((uint64_t)&v137, (uint64_t)&v142, v32);
    int v33 = HIDWORD(v179);
    int v34 = v179;
    uint64_t v165 = 0x300000001;
    *(void *)__ldvl = &unk_1EDD18228;
    char v166 = v167;
    int v161 = HIDWORD(v179);
    int v162 = v179;
    int v163 = v179 * HIDWORD(v179);
    int v164 = HIDWORD(v179);
    if (HIDWORD(v179))
    {
      int v35 = 0;
      int v36 = 0;
      int v37 = v181;
      int8x16_t v38 = v182;
      do
      {
        int v39 = v35;
        int v40 = v36;
        for (int i = v34; i; --i)
        {
          v167[v40] = *(void *)&v38[v39];
          v40 += v33;
          ++v39;
        }
        ++v36;
        v35 += v37;
      }
      while (v36 != v33);
    }
    uint64_t v170 = 0x300000003;
    long long v169 = xmmword_18E1F0010;
    char v168 = &unk_1EDD18EE8;
    __rconde = (__CLPK_doublereal *)v172;
    sub_18DFE2B44((uint64_t)&v183, (uint64_t)__ldvl, (uint64_t)&v168);
    uint64_t v217 = 0x300000003;
    long long v216 = xmmword_18E1F0010;
    uint64_t v215 = &unk_1EDD18EE8;
    long long v218 = v219;
    sub_18DFE2AA8((uint64_t)&v142, (uint64_t)&v168, (uint64_t)&v215);
    int v42 = v185;
    int v43 = v184;
    uint64_t v152 = 0x300000001;
    *(void *)__ldvr = &unk_1EDD18228;
    int8x16_t v153 = v154;
    int v148 = v185;
    int v149 = v184;
    int v150 = v184 * v185;
    int v151 = v185;
    if (v185)
    {
      int v44 = 0;
      int v45 = 0;
      int v46 = v186;
      int v47 = v187;
      do
      {
        int v48 = v44;
        int v49 = v45;
        for (int j = v43; j; --j)
        {
          v154[v49] = *(void *)&v47[v48];
          v49 += v42;
          ++v48;
        }
        ++v45;
        v44 += v46;
      }
      while (v45 != v42);
    }
    uint64_t v157 = 0x300000003;
    long long v156 = xmmword_18E1F0010;
    double v155 = &unk_1EDD18EE8;
    __scale = (__CLPK_doublereal *)v159;
    sub_18DFE2B44((uint64_t)&__n, (uint64_t)__ldvr, (uint64_t)&v155);
    uint64_t v222 = 0x300000003;
    long long v221 = xmmword_18E1F0010;
    double v220 = &unk_1EDD18EE8;
    __wint i = (__CLPK_doublereal *)v224;
    sub_18DFE2AA8((uint64_t)&v215, (uint64_t)&v155, (uint64_t)&v220);
    sub_18DFEE864((uint64_t)&v199, (uint64_t)&v225, (uint64_t)&v188, (uint64_t)&v188);
    sub_18DFEC6E4((uint64_t)&v199, (uint64_t)&v220);
    uint64_t v222 = 0x100000001;
    *(void *)&long long v51 = 0x100000001;
    *((void *)&v51 + 1) = 0x100000001;
    long long v221 = v51;
    double v220 = &unk_1EDD18078;
    __wint i = (__CLPK_doublereal *)v224;
    LODWORD(v224[0]) = 3;
    sub_18DFEEB44((uint64_t)&v199, (uint64_t)&v225, (uint64_t)&v188, (uint64_t)&v220);
    sub_18DFEC830((uint64_t)&v199, (uint64_t)&__lda);
    unsigned int v52 = v175;
    unsigned int v53 = v174;
    uint64_t v222 = 0x300000001;
    double v220 = &unk_1EDD18228;
    __wint i = (__CLPK_doublereal *)v224;
    *(void *)&long long v221 = __PAIR64__(v174, v175);
    DWORD2(v221) = v174 * v175;
    HIDWORD(v221) = v175;
    if (v175)
    {
      int v54 = 0;
      int v55 = 0;
      int v56 = v176;
      uint64_t v57 = v177;
      do
      {
        int v58 = v54;
        int v59 = v55;
        for (unsigned int k = v53; k; --k)
        {
          v224[v59] = *(void *)(v57 + 8 * v58);
          v59 += v52;
          ++v58;
        }
        ++v55;
        v54 += v56;
      }
      while (v55 != v52);
    }
    int v61 = DWORD1(v189);
    int v62 = v189;
    uint64_t v217 = 0x300000001;
    uint64_t v215 = &unk_1EDD18258;
    long long v218 = v219;
    *(void *)&long long v216 = __PAIR64__(v189, DWORD1(v189));
    DWORD2(v216) = v189 * DWORD1(v189);
    HIDWORD(v216) = DWORD1(v189);
    if (DWORD1(v189))
    {
      int v63 = 0;
      int v64 = 0;
      int8x16_t v65 = v191;
      int v66 = HIDWORD(v189);
      do
      {
        if (v62)
        {
          for (int m = 0; m != v62; ++m)
            v219[v64 + HIDWORD(v216) * m] = *((_DWORD *)v65 + v63 + m);
        }
        ++v64;
        v63 += v66;
      }
      while (v64 != v61);
    }
    uint64_t v144 = 0x100000001;
    *(void *)&long long v68 = 0x100000001;
    *((void *)&v68 + 1) = 0x100000001;
    long long v143 = v68;
    uint64_t v142 = &unk_1EDD18078;
    __wr = (__CLPK_doublereal *)v146;
    v146[0] = 3;
    uint64_t v201 = 0x300000001;
    long long v200 = xmmword_18E1F8560;
    __worunsigned int k = (__CLPK_doublereal *)v203;
    int8x16_t v199 = &unk_1EDD162D8;
    uint64_t v204 = &v225;
    uint64_t v207 = 0x100000001;
    uint64_t v205 = &unk_1EDD18078;
    long long v206 = v68;
    char v208 = &v209;
    uint64_t v212 = 0x300000001;
    double v210 = &unk_1EDD18258;
    long long v211 = xmmword_18E1F8560;
    uint64_t v213 = &v214;
    sub_18DFEEA3C((uint64_t)&v205, (uint64_t)&v142);
    sub_18DFEEA3C((uint64_t)&v210, (uint64_t)&v215);
    uint64_t v70 = DWORD2(v206);
    uint64_t v71 = DWORD2(v211);
    *(void *)&long long v200 = __PAIR64__(DWORD2(v211), DWORD2(v206));
    DWORD2(v200) = DWORD2(v211) * DWORD2(v206);
    HIDWORD(v200) = DWORD2(v206);
    if (DWORD2(v211))
    {
      int v72 = 0;
      uint64_t v73 = 0;
      int v74 = HIDWORD(v226);
      uint64_t v75 = __a;
      double v76 = v213;
      unint64_t v77 = v208;
      unsigned __int8 v78 = __work;
      do
      {
        if (v70)
        {
          int v79 = *((_DWORD *)v76 + v73) * v74;
          unint64_t v80 = (int *)v77;
          int v81 = v72;
          uint64_t v82 = v70;
          do
          {
            int v83 = *v80++;
            v78[v81++] = v75[v83 + v79];
            --v82;
          }
          while (v82);
        }
        ++v73;
        v72 += v70;
      }
      while (v73 != v71);
    }
    if (v70 != v221)
    {
      int v129 = 376;
      long double v130 = "this->num_rows_ == A.num_rows_";
      goto LABEL_84;
    }
    if (v71 != DWORD1(v221))
    {
      int v129 = 377;
      long double v130 = "this->num_cols_ == A.num_cols_";
LABEL_84:
      __assert_rtn("operator=", "cnsubmatrix.h", v129, v130);
    }
    if (v71)
    {
      int v84 = 0;
      uint64_t v85 = 0;
      uint64_t v86 = __wi;
      unint64_t v87 = v208;
      unint64_t v88 = v213;
      unint64_t v89 = v204;
      uint64_t v90 = __work;
      do
      {
        if (v70)
        {
          int v91 = *((_DWORD *)v89 + 5) * *((_DWORD *)v88 + v85);
          unint64_t v92 = (__CLPK_doublereal *)v89[4];
          int v93 = v84;
          uint64_t v94 = (int *)v87;
          int v95 = v70;
          do
          {
            __CLPK_doublereal v96 = v86[v93];
            int v97 = *v94++;
            v92[v97 + v91] = v96;
            v90[v93++] = v96;
            --v95;
          }
          while (v95);
        }
        ++v85;
        v84 += v70;
      }
      while (v85 != v71);
    }
    __a[3 * SHIDWORD(v226) + 3] = -v16;
    v69.f64[0] = *(float64_t *)(*(void *)(v134 + 32) + 8 * v9);
    v69.f64[0] = 2.0 / (v69.f64[0] * v69.f64[0]);
    uint64_t v222 = 0x400000004;
    long long v221 = xmmword_18E1F6F70;
    double v220 = &unk_1EDD195A8;
    __wint i = (__CLPK_doublereal *)v224;
    sub_18DFE3240((uint64_t)&v225, (uint64_t)&v220, v69);
    uint64_t v201 = 0x400000004;
    long long v200 = xmmword_18E1F6F70;
    int8x16_t v199 = &unk_1EDD195A8;
    __worunsigned int k = (__CLPK_doublereal *)v203;
    sub_18DFEF1F4((uint64_t)&v194, (uint64_t)&v220, (uint64_t)&v199);
    v10 += v14;
    sub_18DFE2F24((uint64_t)&v194, (uint64_t)&v199);
    ++v9;
  }
  while (v9 != v133);
  if (v10 < 2) {
    return 25;
  }
  uint64_t v144 = 0x400000004;
  long long v143 = xmmword_18E1F6F70;
  uint64_t v142 = &unk_1EDD195A8;
  __wr = (__CLPK_doublereal *)v146;
  uint64_t v139 = 0x400000004;
  double v137 = &unk_1EDD195A8;
  long long v138 = xmmword_18E1F6F70;
  uint64_t v140 = (__CLPK_doublereal *)v141;
  uint64_t v227 = 0x400000004;
  long long v226 = xmmword_18E1F6F70;
  long long v225 = &unk_1EDD195A8;
  __a = (__CLPK_doublereal *)v229;
  uint64_t v222 = 0x400000004;
  long long v221 = xmmword_18E1F6F70;
  double v220 = &unk_1EDD195A8;
  __wint i = (__CLPK_doublereal *)v224;
  uint64_t v217 = 0x400000004;
  long long v216 = xmmword_18E1F6F70;
  uint64_t v215 = &unk_1EDD195A8;
  long long v218 = v219;
  uint64_t v157 = 0x100000004;
  long long v156 = xmmword_18E1F6F80;
  double v155 = &unk_1EDD19458;
  __scale = (__CLPK_doublereal *)v159;
  uint64_t v170 = 0x200000004;
  long long v169 = xmmword_18E200B60;
  char v168 = &unk_1EDD194E8;
  __rconde = (__CLPK_doublereal *)v172;
  uint64_t v201 = 0x100000170;
  long long v200 = xmmword_18E21BFF0;
  int8x16_t v199 = &unk_1EDD18CD8;
  __worunsigned int k = (__CLPK_doublereal *)v203;
  uint64_t v99 = (int)v195;
  sub_18DFE2F24((uint64_t)&v225, (uint64_t)&v194);
  LODWORD(v143) = v99;
  DWORD1(v143) = v99;
  DWORD2(v143) = v99 * v99;
  HIDWORD(v143) = v99;
  sub_18DFE2CC8((uint64_t)&v142, 0.0);
  LODWORD(v221) = v99;
  DWORD1(v221) = v99;
  DWORD2(v221) = v99 * v99;
  HIDWORD(v221) = v99;
  sub_18DFE2CC8((uint64_t)&v220, 0.0);
  LODWORD(v138) = v99;
  DWORD1(v138) = v99;
  DWORD2(v138) = v99 * v99;
  HIDWORD(v138) = v99;
  sub_18DFE2CC8((uint64_t)&v137, 0.0);
  LODWORD(v216) = v99;
  DWORD1(v216) = v99;
  DWORD2(v216) = v99 * v99;
  HIDWORD(v216) = v99;
  sub_18DFE2CC8((uint64_t)&v215, 0.0);
  uint64_t v183 = 0;
  qmemcpy(__sense, "NVNB", 4);
  __CLPK_integer __n = v99;
  __CLPK_integer __lda = v226;
  __ldvl[0] = 1;
  __ldvr[0] = v138;
  *(void *)__ihint i = 0;
  __CLPK_integer v230 = 0;
  __CLPK_integer v231 = 368;
  unint64_t v100 = (cnprint::CNPrinter *)dgeevx_(&__sense[3], &__sense[2], &__sense[1], __sense, &__n, __a, &__lda, __wr, __wi, 0, __ldvl, v140, __ldvr, &__ihi[1], __ihi, __scale, (__CLPK_doublereal *)&v183, __rconde, &__rconde[v99],
                                 __work,
                                 &v231,
                                 0,
                                 &v230);
  if (v230)
  {
    LOWORD(__n) = 4;
    if (v230 < 0)
    {
      LOBYTE(__lda) = 5;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&__n, (unsigned __int8 *)&__lda, "Error using Eig: input argument %d invalid in geevx.", v101, v102, v103, v104, v105, -(char)v230);
    }
    else
    {
      LOBYTE(__lda) = 4;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&__n, (unsigned __int8 *)&__lda, "Error using Eig: geevx failed to converge for some eigenvalues.", v101, v102, v103, v104, v105, v131);
    }
  }
  unsigned int v106 = *__work;
  if (v106 >= 0x171 && cnprint::CNPrinter::GetLogLevel(v100) <= 1)
  {
    LOWORD(__n) = 4;
    LOBYTE(__lda) = 1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&__n, (unsigned __int8 *)&__lda, "Warning: Eig optimal workspace size %u is greater than provided workspace size %u; performance may suffer.",
      v101,
      v102,
      v103,
      v104,
      v105,
      v106);
  }
  *(void *)&long long v200 = v201;
  DWORD2(v200) = HIDWORD(v201) * v201;
  HIDWORD(v200) = v201;
  *(void *)&long long v169 = v99 | 0x200000000;
  DWORD2(v169) = 2 * v99;
  HIDWORD(v169) = v99;
  int32x4_t v107 = vdupq_lane_s32((int32x2_t)(v99 | 0x100000000), 0);
  v107.i32[1] = 1;
  long long v156 = (__int128)v107;
  if (v99)
  {
    unsigned int v108 = 0;
    int8x16_t v109 = __wi;
    double v110 = v140;
    uint64_t v111 = v218;
    do
    {
      if (v109[v108] != 0.0)
      {
        int v112 = v108 * v99;
        int v113 = v99 + v108;
        uint64_t v114 = v99;
        do
        {
          *(__CLPK_doublereal *)&v111[2 * v112] = v110[v113];
          *(__CLPK_doublereal *)&v111[2 * v113] = -v110[v113];
          __CLPK_doublereal v115 = v110[v112++];
          v110[v113++] = v115;
          --v114;
        }
        while (v114);
        ++v108;
      }
      ++v108;
    }
    while (v108 < v99);
    if (v99 >= 2)
    {
      uint64_t v116 = __wr;
      int v117 = v99 - 1;
      uint64_t v118 = v109 + 1;
      uint64_t v119 = __wr + 1;
      int v120 = v99 + 1;
      do
      {
        v116[v120] = *v119;
        v109[v120] = *v118;
        *v119++ = 0.0;
        *v118++ = 0.0;
        v120 += v99 + 1;
        --v117;
      }
      while (v117);
    }
  }
  if (DWORD2(v221))
  {
    int v121 = 0;
    while (__wi[v121] == 0.0)
    {
      if (DWORD2(v221) == ++v121) {
        goto LABEL_71;
      }
    }
    LOWORD(v183) = 4;
    LOBYTE(__n) = 2;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v183, (unsigned __int8 *)&__n, "Warning: Imaginary parts of complex eigenvalues are being ignored.", v101, v102, v103, v104, v105, v131);
  }
LABEL_71:
  if (DWORD2(v216))
  {
    int v122 = 0;
    while (*(double *)&v218[2 * v122] == 0.0)
    {
      if (DWORD2(v216) == ++v122) {
        goto LABEL_76;
      }
    }
    LOWORD(v183) = 4;
    LOBYTE(__n) = 2;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v183, (unsigned __int8 *)&__n, "Warning: Imaginary parts of complex eigenvectors are being ignored.", v101, v102, v103, v104, v105, v131);
  }
LABEL_76:
  uint64_t v170 = 0x100000001;
  *(void *)&long long v123 = 0x100000001;
  *((void *)&v123 + 1) = 0x100000001;
  long long v169 = v123;
  char v168 = &unk_1EDD180A8;
  __rconde = (__CLPK_doublereal *)v172;
  uint64_t v157 = 0x100000001;
  long long v156 = v123;
  double v155 = &unk_1EDD18048;
  __scale = (__CLPK_doublereal *)v159;
  uint64_t v201 = 0x800000008;
  long long v200 = xmmword_18E1FD750;
  int8x16_t v199 = &unk_1EDD19DE8;
  __worunsigned int k = (__CLPK_doublereal *)v203;
  sub_18E07D314((uint64_t)&v142, 0, (uint64_t)&v199);
  sub_18E064598((uint64_t)&v199, (uint64_t)&v155, (uint64_t)&v168);
  int v124 = *(_DWORD *)__rconde;
  int v125 = v138;
  uint64_t v227 = 0x100000004;
  long long v225 = &unk_1EDD19488;
  *(void *)&long long v226 = v138 | 0x100000000;
  DWORD2(v226) = v138;
  HIDWORD(v226) = v138;
  __a = (__CLPK_doublereal *)v229;
  if (v138)
  {
    int v126 = 0;
    do
    {
      v229[v126] = v126;
      ++v126;
    }
    while (v125 != v126);
  }
  uint64_t v222 = 0x100000001;
  *(void *)&long long v127 = 0x100000001;
  *((void *)&v127 + 1) = 0x100000001;
  long long v221 = v127;
  double v220 = &unk_1EDD18078;
  __wint i = (__CLPK_doublereal *)v224;
  LODWORD(v224[0]) = v124;
  sub_18E06E064((uint64_t)&v199, (uint64_t)&v137, (uint64_t)&v225, (uint64_t)&v220);
  sub_18E0963D8((uint64_t)&v215, (uint64_t)&v199);
  uint64_t v227 = 0x100000004;
  long long v226 = xmmword_18E1F6F80;
  long long v225 = &unk_1EDD19458;
  __a = (__CLPK_doublereal *)v229;
  uint64_t v201 = 0x10000018BLL;
  long long v200 = xmmword_18E21C000;
  int8x16_t v199 = &unk_1EDD18D08;
  __worunsigned int k = (__CLPK_doublereal *)v203;
  uint64_t v222 = 0x100000004;
  long long v221 = xmmword_18E1F6F80;
  double v220 = &unk_1EDD19458;
  __wint i = (__CLPK_doublereal *)v224;
  sub_18DFE345C((uint64_t)&v215, (uint64_t)&v225, (uint64_t)&v199, (uint64_t)&v220, "2");
  if (fabs(v128.f64[0]) < 2.22044605e-16) {
    return 26;
  }
  uint64_t v201 = 0x100000004;
  long long v200 = xmmword_18E1F6F80;
  int8x16_t v199 = &unk_1EDD19458;
  __worunsigned int k = (__CLPK_doublereal *)v203;
  v128.f64[0] = 1.0 / v128.f64[0];
  sub_18DFE3240((uint64_t)&v215, (uint64_t)&v199, v128);
  sub_18DFE2F24((uint64_t)&v215, (uint64_t)&v199);
  sub_18DFE2F24(v132 + 8, (uint64_t)&v215);
  return 0;
}

double sub_18E172A70(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(a2 + 8);
  *(void *)&double result = 0x100000003;
  *(void *)(a1 + 24) = 0x100000003;
  *(void *)a1 = &unk_1EDD18D98;
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 1;
  *(_DWORD *)(a1 + 16) = v3;
  *(_DWORD *)(a1 + 20) = v3;
  int v5 = (double *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (v3)
  {
    int v6 = *(_DWORD *)(a2 + 20) * a3;
    uint64_t v7 = *(void *)(a2 + 32);
    do
    {
      double result = *(double *)(v7 + 8 * v6);
      *v5++ = result;
      ++v6;
      --v3;
    }
    while (v3);
  }
  return result;
}

void *sub_18E172AD8(void *result)
{
  result[15] = &unk_1EDD174A8;
  result[9] = &unk_1EDD174A8;
  *double result = &unk_1EDD17478;
  return result;
}

void sub_18E172B38(void *a1)
{
  a1[15] = &unk_1EDD174A8;
  a1[9] = &unk_1EDD174A8;
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

void *sub_18E172BA8(void *result)
{
  *double result = &unk_1EDD17478;
  return result;
}

void sub_18E172BC8(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E172BF8(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E172C04(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          uint64_t v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *uint64_t v9 = 1;
              uint64_t v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void *sub_18E172D04(void *result)
{
  *double result = &unk_1EDD17478;
  return result;
}

void sub_18E172D24(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E172D54(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E172D60(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          uint64_t v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *uint64_t v9 = 1;
              uint64_t v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void *sub_18E172E60(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)*result;
    unint64_t v3 = a2 - 0x79435E50D79435E5 * ((uint64_t)(result[1] - *(void *)*result) >> 3);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 25 - v3;
      uint64_t v6 = &v2[-(v5 / 0x1A)];
      *double result = v6;
      unint64_t v4 = *v6 + 152 * (26 * (v5 / 0x1A) - v5) + 3800;
    }
    else
    {
      *double result = &v2[v3 / 0x1A];
      unint64_t v4 = v2[v3 / 0x1A] + 152 * (v3 % 0x1A);
    }
    result[1] = v4;
  }
  return result;
}

uint64_t raven::RavenActivityStateEstimatorActiveObject::Configure(cnframework::ActiveObjectBase *this, uint64_t *a2)
{
  if (*((unsigned char *)this + 480))
  {
    __int16 v27 = 12;
    unsigned __int8 v26 = 3;
    (*(void (**)(void **__return_ptr, cnframework::ActiveObjectBase *))(*(void *)this + 16))(__p, this);
    if (v25 >= 0) {
      uint64_t v9 = __p;
    }
    else {
      LOBYTE(v9) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v27, &v26, "Warning: %s configured more than once", v4, v5, v6, v7, v8, (char)v9);
    if (v25 < 0) {
      operator delete(__p[0]);
    }
  }
  *((unsigned char *)this + 480) = 0;
  uint64_t v10 = *a2;
  if (*a2 && *(unsigned char *)(v10 + 33))
  {
    *((void *)this + 61) = v10;
    cnframework::ActiveObjectBase::SetEventQueueDelay(this, 0.0);
    *((unsigned char *)this + 480) = 1;
    (*(void (**)(cnframework::ActiveObjectBase *))(*(void *)this + 48))(this);
    __int16 v27 = 12;
    unsigned __int8 v26 = 3;
    (*(void (**)(void **__return_ptr, cnframework::ActiveObjectBase *))(*(void *)this + 16))(__p, this);
    if (v25 >= 0) {
      double v16 = __p;
    }
    else {
      LOBYTE(v16) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v27, &v26, "%s configured successfully", v11, v12, v13, v14, v15, (char)v16);
    if (v25 < 0) {
      operator delete(__p[0]);
    }
    return 0;
  }
  else
  {
    __int16 v27 = 12;
    unsigned __int8 v26 = 4;
    (*(void (**)(void **__return_ptr, cnframework::ActiveObjectBase *))(*(void *)this + 16))(__p, this);
    if (v25 >= 0) {
      double v23 = __p;
    }
    else {
      LOBYTE(v23) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v27, &v26, "%s could not be configured", v18, v19, v20, v21, v22, (char)v23);
    if (v25 < 0) {
      operator delete(__p[0]);
    }
    return 0xFFFFFFFFLL;
  }
}

void sub_18E173118(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t raven::RavenActivityStateEstimatorActiveObject::IsConfigured(raven::RavenActivityStateEstimatorActiveObject *this)
{
  return *((unsigned __int8 *)this + 480);
}

void *raven::RavenActivityStateEstimatorActiveObject::GetActiveObjectName@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenActivityStateEstimatorActiveObject");
}

__n128 raven::RavenActivityStateEstimatorActiveObject::HandleEvent(raven::RavenActivityStateEstimatorActiveObject *this, const raven::ActivityInputEvent *a2)
{
  if (*((unsigned char *)this + 608))
  {
    long long v2 = *(_OWORD *)((char *)a2 + 8);
    long long v3 = *(_OWORD *)((char *)a2 + 24);
    *(_OWORD *)((char *)this + 536) = *(_OWORD *)((char *)a2 + 40);
    *(_OWORD *)((char *)this + 520) = v3;
    *(_OWORD *)((char *)this + 504) = v2;
    __n128 result = *(__n128 *)((char *)a2 + 56);
    long long v5 = *(_OWORD *)((char *)a2 + 72);
    long long v6 = *(_OWORD *)((char *)a2 + 88);
    *((_WORD *)this + 300) = *((_WORD *)a2 + 52);
    *(_OWORD *)((char *)this + 584) = v6;
    *(_OWORD *)((char *)this + 568) = v5;
    *(__n128 *)((char *)this + 552) = result;
  }
  else
  {
    *((void *)this + 62) = &unk_1EDD14088;
    long long v7 = *(_OWORD *)((char *)a2 + 8);
    long long v8 = *(_OWORD *)((char *)a2 + 24);
    *(_OWORD *)((char *)this + 536) = *(_OWORD *)((char *)a2 + 40);
    *(_OWORD *)((char *)this + 520) = v8;
    *(_OWORD *)((char *)this + 504) = v7;
    __n128 result = *(__n128 *)((char *)a2 + 56);
    long long v9 = *(_OWORD *)((char *)a2 + 72);
    long long v10 = *(_OWORD *)((char *)a2 + 88);
    *((_WORD *)this + 300) = *((_WORD *)a2 + 52);
    *(_OWORD *)((char *)this + 584) = v10;
    *(_OWORD *)((char *)this + 568) = v9;
    *(__n128 *)((char *)this + 552) = result;
    *((unsigned char *)this + 608) = 1;
  }
  return result;
}

__n128 raven::RavenActivityStateEstimatorActiveObject::HandleEvent(raven::RavenActivityStateEstimatorActiveObject *this, const raven::FitnessSessionEvent *a2)
{
  if (*((unsigned char *)this + 824))
  {
    *((_OWORD *)this + 39) = *(_OWORD *)((char *)a2 + 8);
    long long v2 = *(_OWORD *)((char *)a2 + 24);
    long long v3 = *(_OWORD *)((char *)a2 + 40);
    long long v4 = *(_OWORD *)((char *)a2 + 72);
    *((_OWORD *)this + 42) = *(_OWORD *)((char *)a2 + 56);
    *((_OWORD *)this + 43) = v4;
    *((_OWORD *)this + 40) = v2;
    *((_OWORD *)this + 41) = v3;
    long long v5 = *(_OWORD *)((char *)a2 + 88);
    long long v6 = *(_OWORD *)((char *)a2 + 104);
    long long v7 = *(_OWORD *)((char *)a2 + 136);
    *((_OWORD *)this + 46) = *(_OWORD *)((char *)a2 + 120);
    *((_OWORD *)this + 47) = v7;
    *((_OWORD *)this + 44) = v5;
    *((_OWORD *)this + 45) = v6;
    __n128 result = *(__n128 *)((char *)a2 + 152);
    long long v9 = *(_OWORD *)((char *)a2 + 168);
    long long v10 = *(_OWORD *)((char *)a2 + 184);
    *((void *)this + 102) = *((void *)a2 + 25);
    *((_OWORD *)this + 49) = v9;
    *((_OWORD *)this + 50) = v10;
    *((__n128 *)this + 48) = result;
  }
  else
  {
    *((void *)this + 77) = &unk_1EDD141E0;
    *((_OWORD *)this + 39) = *(_OWORD *)((char *)a2 + 8);
    long long v11 = *(_OWORD *)((char *)a2 + 24);
    long long v12 = *(_OWORD *)((char *)a2 + 40);
    long long v13 = *(_OWORD *)((char *)a2 + 72);
    *((_OWORD *)this + 42) = *(_OWORD *)((char *)a2 + 56);
    *((_OWORD *)this + 43) = v13;
    *((_OWORD *)this + 40) = v11;
    *((_OWORD *)this + 41) = v12;
    long long v14 = *(_OWORD *)((char *)a2 + 88);
    long long v15 = *(_OWORD *)((char *)a2 + 104);
    long long v16 = *(_OWORD *)((char *)a2 + 136);
    *((_OWORD *)this + 46) = *(_OWORD *)((char *)a2 + 120);
    *((_OWORD *)this + 47) = v16;
    *((_OWORD *)this + 44) = v14;
    *((_OWORD *)this + 45) = v15;
    __n128 result = *(__n128 *)((char *)a2 + 152);
    long long v17 = *(_OWORD *)((char *)a2 + 168);
    long long v18 = *(_OWORD *)((char *)a2 + 184);
    *((void *)this + 102) = *((void *)a2 + 25);
    *((_OWORD *)this + 49) = v17;
    *((_OWORD *)this + 50) = v18;
    *((__n128 *)this + 48) = result;
    *((unsigned char *)this + 824) = 1;
  }
  return result;
}

uint64_t raven::RavenActivityStateEstimatorActiveObject::HandleEvent(raven::RavenActivityStateEstimatorActiveObject *this, const raven::MapsRouteHintEvent *a2)
{
  return sub_18E1732E8((uint64_t)this + 832, (uint64_t)a2);
}

uint64_t sub_18E1732E8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 232))
  {
    *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
    long long v3 = *(_OWORD *)(a2 + 24);
    long long v4 = *(_OWORD *)(a2 + 40);
    long long v5 = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v5;
    *(_OWORD *)(a1 + 40) = v4;
    *(_OWORD *)(a1 + 24) = v3;
    long long v6 = *(_OWORD *)(a2 + 88);
    long long v7 = *(_OWORD *)(a2 + 104);
    long long v8 = *(_OWORD *)(a2 + 120);
    *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
    *(_OWORD *)(a1 + 120) = v8;
    *(_OWORD *)(a1 + 104) = v7;
    *(_OWORD *)(a1 + 88) = v6;
    long long v9 = *(_OWORD *)(a2 + 152);
    long long v10 = *(_OWORD *)(a2 + 168);
    long long v11 = *(_OWORD *)(a2 + 184);
    *(_WORD *)(a1 + 200) = *(_WORD *)(a2 + 200);
    *(_OWORD *)(a1 + 184) = v11;
    *(_OWORD *)(a1 + 168) = v10;
    *(_OWORD *)(a1 + 152) = v9;
    if (a1 != a2) {
      sub_18E17411C((char *)(a1 + 208), *(char **)(a2 + 208), *(void *)(a2 + 216), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 216) - *(void *)(a2 + 208)) >> 3));
    }
  }
  else
  {
    *(void *)a1 = &unk_1EDD140E8;
    long long v12 = *(_OWORD *)(a2 + 152);
    long long v13 = *(_OWORD *)(a2 + 168);
    long long v14 = *(_OWORD *)(a2 + 184);
    __int16 v15 = *(_WORD *)(a2 + 200);
    long long v16 = *(_OWORD *)(a2 + 88);
    long long v17 = *(_OWORD *)(a2 + 104);
    long long v18 = *(_OWORD *)(a2 + 120);
    long long v19 = *(_OWORD *)(a2 + 136);
    long long v20 = *(_OWORD *)(a2 + 24);
    long long v21 = *(_OWORD *)(a2 + 40);
    long long v22 = *(_OWORD *)(a2 + 56);
    long long v23 = *(_OWORD *)(a2 + 72);
    long long v24 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 208) = 0;
    *(_OWORD *)(a1 + 8) = v24;
    *(_OWORD *)(a1 + 72) = v23;
    *(_OWORD *)(a1 + 56) = v22;
    *(_OWORD *)(a1 + 40) = v21;
    *(_OWORD *)(a1 + 24) = v20;
    *(_OWORD *)(a1 + 136) = v19;
    *(_OWORD *)(a1 + 120) = v18;
    *(_OWORD *)(a1 + 104) = v17;
    *(_OWORD *)(a1 + 88) = v16;
    *(_WORD *)(a1 + 200) = v15;
    *(_OWORD *)(a1 + 184) = v14;
    *(_OWORD *)(a1 + 168) = v13;
    *(_OWORD *)(a1 + 152) = v12;
    *(void *)(a1 + 216) = 0;
    *(void *)(a1 + 224) = 0;
    sub_18E0BCF38((void *)(a1 + 208), *(const void **)(a2 + 208), *(void *)(a2 + 216), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 216) - *(void *)(a2 + 208)) >> 3));
    *(unsigned char *)(a1 + 232) = 1;
  }
  return a1;
}

uint64_t raven::RavenActivityStateEstimatorActiveObject::HandleEvent(uint64_t this, const raven::RavenSystemEvent *a2)
{
  if (!*((_DWORD *)a2 + 26)) {
    return (*(uint64_t (**)(void))(*(void *)this + 48))();
  }
  return this;
}

__n128 raven::RavenActivityStateEstimatorActiveObject::HandleEvent(raven::RavenActivityStateEstimatorActiveObject *this, const raven::StepCountEvent *a2)
{
  int v2 = *((unsigned __int8 *)this + 1232);
  if (*((unsigned char *)this + 1232) && *((_DWORD *)a2 + 38) == *((_DWORD *)this + 306) + 1)
  {
    if (*((unsigned __int8 *)this + 1400) == v2)
    {
      *((void *)this + 174) = *((void *)this + 153);
      *((_OWORD *)this + 84) = *(_OWORD *)((char *)this + 1176);
      *((_OWORD *)this + 85) = *(_OWORD *)((char *)this + 1192);
      *((_OWORD *)this + 86) = *(_OWORD *)((char *)this + 1208);
      *((_OWORD *)this + 80) = *(_OWORD *)((char *)this + 1112);
      *((_OWORD *)this + 81) = *(_OWORD *)((char *)this + 1128);
      *((_OWORD *)this + 82) = *(_OWORD *)((char *)this + 1144);
      *((_OWORD *)this + 83) = *(_OWORD *)((char *)this + 1160);
      *((_OWORD *)this + 78) = *(_OWORD *)((char *)this + 1080);
      *((_OWORD *)this + 79) = *(_OWORD *)((char *)this + 1096);
    }
    else if (*((unsigned char *)this + 1400))
    {
      *((unsigned char *)this + 1400) = 0;
    }
    else
    {
      *((void *)this + 155) = &unk_1EDD139E0;
      *((void *)this + 174) = *((void *)this + 153);
      *((_OWORD *)this + 84) = *(_OWORD *)((char *)this + 1176);
      *((_OWORD *)this + 85) = *(_OWORD *)((char *)this + 1192);
      *((_OWORD *)this + 86) = *(_OWORD *)((char *)this + 1208);
      *((_OWORD *)this + 80) = *(_OWORD *)((char *)this + 1112);
      *((_OWORD *)this + 81) = *(_OWORD *)((char *)this + 1128);
      *((_OWORD *)this + 82) = *(_OWORD *)((char *)this + 1144);
      *((_OWORD *)this + 83) = *(_OWORD *)((char *)this + 1160);
      *((_OWORD *)this + 78) = *(_OWORD *)((char *)this + 1080);
      *((_OWORD *)this + 79) = *(_OWORD *)((char *)this + 1096);
      *((unsigned char *)this + 1400) = 1;
    }
LABEL_8:
    long long v3 = *(_OWORD *)((char *)a2 + 8);
    *(_OWORD *)((char *)this + 1096) = *(_OWORD *)((char *)a2 + 24);
    *(_OWORD *)((char *)this + 1080) = v3;
    long long v4 = *(_OWORD *)((char *)a2 + 40);
    long long v5 = *(_OWORD *)((char *)a2 + 56);
    long long v6 = *(_OWORD *)((char *)a2 + 72);
    *(_OWORD *)((char *)this + 1160) = *(_OWORD *)((char *)a2 + 88);
    *(_OWORD *)((char *)this + 1144) = v6;
    *(_OWORD *)((char *)this + 1128) = v5;
    *(_OWORD *)((char *)this + 1112) = v4;
    __n128 result = *(__n128 *)((char *)a2 + 104);
    long long v8 = *(_OWORD *)((char *)a2 + 120);
    long long v9 = *(_OWORD *)((char *)a2 + 136);
    *((void *)this + 153) = *((void *)a2 + 19);
    *(_OWORD *)((char *)this + 1208) = v9;
    *(_OWORD *)((char *)this + 1192) = v8;
    *(__n128 *)((char *)this + 1176) = result;
    return result;
  }
  if (*((unsigned char *)this + 1400)) {
    *((unsigned char *)this + 1400) = 0;
  }
  if (v2) {
    goto LABEL_8;
  }
  *((void *)this + 134) = &unk_1EDD139E0;
  long long v10 = *(_OWORD *)((char *)a2 + 8);
  *(_OWORD *)((char *)this + 1096) = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 1080) = v10;
  long long v11 = *(_OWORD *)((char *)a2 + 40);
  long long v12 = *(_OWORD *)((char *)a2 + 56);
  long long v13 = *(_OWORD *)((char *)a2 + 72);
  *(_OWORD *)((char *)this + 1160) = *(_OWORD *)((char *)a2 + 88);
  *(_OWORD *)((char *)this + 1144) = v13;
  *(_OWORD *)((char *)this + 1128) = v12;
  *(_OWORD *)((char *)this + 1112) = v11;
  __n128 result = *(__n128 *)((char *)a2 + 104);
  long long v14 = *(_OWORD *)((char *)a2 + 120);
  long long v15 = *(_OWORD *)((char *)a2 + 136);
  *((void *)this + 153) = *((void *)a2 + 19);
  *(_OWORD *)((char *)this + 1208) = v15;
  *(_OWORD *)((char *)this + 1192) = v14;
  *(__n128 *)((char *)this + 1176) = result;
  *((unsigned char *)this + 1232) = 1;
  return result;
}

void raven::RavenActivityStateEstimatorActiveObject::HandleEvent(raven::RavenActivityStateEstimatorActiveObject *this, const raven::TimeMarkEvent *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*((unsigned char *)this + 480)) {
    return;
  }
  long long v10 = (char *)this + 1408;
  if (!*((unsigned char *)this + 1408))
  {
    int8x16_t v38 = (void *)*((void *)this + 61);
    v98.i64[0] = 0x7FF8000000000000;
    v97[0] = v38;
    v97[1] = (void *)(*(uint64_t (**)(const raven::TimeMarkEvent *))(*(void *)a2 + 16))(a2);
    v98.i64[0] = v39;
    if (!raven::RavenActivityStateEstimator::Initialize((uint64_t)v10, (uint64_t *)v97, v40, v41, v42, v43, v44, v45))
    {
      *(_WORD *)int v95 = 12;
      LOBYTE(v96) = 4;
      (*(void (**)(double *__return_ptr, raven::RavenActivityStateEstimatorActiveObject *))(*(void *)this + 16))(&v136, this);
      if (v138 >= 0) {
        unint64_t v92 = &v136;
      }
      else {
        LOBYTE(v92) = LOBYTE(v136);
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v95, (unsigned __int8 *)&v96, "%s: Could not initialize activity state estimator", v87, v88, v89, v90, v91, (char)v92);
      goto LABEL_35;
    }
LABEL_16:
    if (*((unsigned char *)this + 608))
    {
      v97[0] = (void *)(*(uint64_t (**)(const raven::TimeMarkEvent *))(*(void *)a2 + 16))(a2);
      v97[1] = v46;
      BOOL v52 = raven::RavenActivityStateEstimator::Update((uint64_t)v10, (uint64_t)v97, (unsigned char *)this + 600, v47, v48, v49, v50, v51);
      if (!v52 && cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v52) <= 1)
      {
        LOWORD(v136) = 12;
        v95[0] = 1;
        uint64_t v53 = (*(uint64_t (**)(const raven::TimeMarkEvent *))(*(void *)a2 + 16))(a2);
        double v55 = v54 + (double)v53;
        (*(void (**)(void **__return_ptr, raven::RavenActivityStateEstimatorActiveObject *))(*(void *)this + 16))(v97, this);
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v136, v95, "t,%.3lf,%s: Could not update estimator with latest ActivityInputEvent", v56, v57, v58, v59, v60, SLOBYTE(v55));
        if (v98.i8[7] < 0) {
          operator delete(v97[0]);
        }
      }
    }
    if (*((unsigned char *)this + 1400))
    {
      if (*((unsigned char *)this + 1232))
      {
        v97[0] = (void *)(*(uint64_t (**)(const raven::TimeMarkEvent *))(*(void *)a2 + 16))(a2);
        v97[1] = v61;
        double v136 = COERCE_DOUBLE((*(uint64_t (**)(char *))(*((void *)this + 134) + 16))((char *)this + 1072));
        uint64_t v137 = v62;
        uint64_t v65 = CNTimeSpan::operator-((uint64_t)v97, &v136, v63, v64);
        int v66 = *((_DWORD *)this + 307) - *((_DWORD *)this + 349);
        double v136 = v67 + (double)v65;
        LODWORD(v137) = v66;
        v97[0] = (void *)(*(uint64_t (**)(const raven::TimeMarkEvent *))(*(void *)a2 + 16))(a2);
        v97[1] = v68;
        uint64_t v69 = raven::RavenActivityStateEstimator::Update((uint64_t)v10, (uint64_t)v97, (uint64_t)&v136);
        if ((v69 & 1) == 0 && cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v69) <= 1)
        {
          *(_WORD *)int v95 = 12;
          LOBYTE(v96) = 1;
          uint64_t v70 = (*(uint64_t (**)(const raven::TimeMarkEvent *))(*(void *)a2 + 16))(a2);
          double v72 = v71 + (double)v70;
          (*(void (**)(void **__return_ptr, raven::RavenActivityStateEstimatorActiveObject *))(*(void *)this + 16))(v97, this);
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)v95, (unsigned __int8 *)&v96, "t,%.3lf,%s: Could not update estimator with step count data", v73, v74, v75, v76, v77, SLOBYTE(v72));
          if (v98.i8[7] < 0) {
            operator delete(v97[0]);
          }
        }
      }
    }
    v97[1] = 0;
    v98.i64[0] = 0;
    v97[0] = &unk_1EDD140B8;
    v98.i8[8] = 0;
    long long v99 = 0uLL;
    LOBYTE(v100) = 0;
    *((void *)&v100 + 1) = 0;
    *(void *)&long long v101 = 0;
    BYTE8(v101) = 0;
    long long v102 = 0uLL;
    uint64_t v103 = 0x7FF8000000000000;
    v104.i8[0] = 0;
    long long v105 = 0u;
    int8x16_t v106 = 0u;
    long long v107 = 0u;
    long long v108 = 0u;
    v104.i64[1] = 0x3FF0000000000000;
    *(void *)&long long v109 = 0;
    uint64_t v78 = raven::RavenActivityStateEstimator::PopulateActivityStateEvent((uint64_t)v10, (const raven::TimeMarkEvent *)((char *)a2 + 8), (uint64_t)v97);
    if (v78) {
      sub_18E0CD5AC();
    }
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v78) > 1) {
      return;
    }
    *(_WORD *)int v95 = 12;
    LOBYTE(v96) = 1;
    uint64_t v79 = (*(uint64_t (**)(const raven::TimeMarkEvent *))(*(void *)a2 + 16))(a2);
    double v81 = v80;
    (*(void (**)(double *__return_ptr, raven::RavenActivityStateEstimatorActiveObject *))(*(void *)this + 16))(&v136, this);
    double v94 = v81 + (double)v79;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v95, (unsigned __int8 *)&v96, "t,%.3lf,%s: Could not populate ActivityStateEvent", v82, v83, v84, v85, v86, SLOBYTE(v94));
LABEL_35:
    if (v138 < 0) {
      operator delete(*(void **)&v136);
    }
    return;
  }
  LOBYTE(v103) = 0;
  char v117 = 0;
  LOBYTE(v118) = 0;
  char v135 = 0;
  long long v11 = *(_OWORD *)((char *)a2 + 56);
  long long v99 = *(_OWORD *)((char *)a2 + 40);
  long long v100 = v11;
  long long v12 = *(_OWORD *)((char *)a2 + 88);
  long long v101 = *(_OWORD *)((char *)a2 + 72);
  long long v102 = v12;
  int8x16_t v13 = *(int8x16_t *)((char *)a2 + 8);
  int8x16_t v14 = *(int8x16_t *)((char *)a2 + 24);
  *(int8x16_t *)int v97 = v13;
  int8x16_t v98 = v14;
  if (*((unsigned char *)this + 824))
  {
    long long v15 = *((_OWORD *)this + 50);
    long long v114 = *((_OWORD *)this + 49);
    long long v115 = v15;
    long long v16 = *((_OWORD *)this + 47);
    long long v113 = *((_OWORD *)this + 48);
    long long v17 = *((_OWORD *)this + 43);
    long long v109 = *((_OWORD *)this + 44);
    long long v18 = *((_OWORD *)this + 46);
    long long v110 = *((_OWORD *)this + 45);
    long long v111 = v18;
    long long v112 = v16;
    int8x16_t v14 = *((int8x16_t *)this + 39);
    long long v105 = *((_OWORD *)this + 40);
    int8x16_t v13 = *((int8x16_t *)this + 41);
    long long v19 = *((_OWORD *)this + 42);
    int8x16_t v106 = v13;
    long long v107 = v19;
    long long v108 = v17;
    uint64_t v20 = *((void *)this + 102);
    uint64_t v103 = (uint64_t)&unk_1EDD141E0;
    uint64_t v116 = v20;
    int8x16_t v104 = v14;
    char v117 = 1;
  }
  if (*((unsigned char *)this + 1064))
  {
    uint64_t v118 = &unk_1EDD140E8;
    __int16 v131 = *((_WORD *)this + 516);
    long long v21 = *(_OWORD *)((char *)this + 984);
    long long v22 = *(_OWORD *)((char *)this + 1016);
    long long v129 = *(_OWORD *)((char *)this + 1000);
    long long v130 = v22;
    long long v23 = *(_OWORD *)((char *)this + 920);
    long long v24 = *(_OWORD *)((char *)this + 952);
    long long v125 = *(_OWORD *)((char *)this + 936);
    long long v126 = v24;
    long long v127 = *(_OWORD *)((char *)this + 968);
    long long v128 = v21;
    long long v25 = *(_OWORD *)((char *)this + 856);
    long long v26 = *(_OWORD *)((char *)this + 888);
    long long v121 = *(_OWORD *)((char *)this + 872);
    long long v122 = v26;
    long long v123 = *(_OWORD *)((char *)this + 904);
    long long v124 = v23;
    long long v119 = *(_OWORD *)((char *)this + 840);
    long long v120 = v25;
    __int16 v27 = (const void *)*((void *)this + 130);
    uint64_t v28 = *((void *)this + 131);
    uint64_t v133 = 0;
    std::string __p = 0;
    uint64_t v134 = 0;
    sub_18E0BCF38(&__p, v27, v28, 0xCCCCCCCCCCCCCCCDLL * ((v28 - (uint64_t)v27) >> 3));
    char v135 = 1;
  }
  BOOL v29 = raven::RavenActivityStateEstimator::Predict((uint64_t)v10, (uint64_t)v97, v13, v14, a3, a4, a5, a6, a7, a8);
  if (!v29)
  {
    *(_WORD *)int v95 = 12;
    LOBYTE(v96) = 4;
    uint64_t v30 = (*(uint64_t (**)(const raven::TimeMarkEvent *))(*(void *)a2 + 16))(a2);
    double v32 = v31;
    (*(void (**)(double *__return_ptr, raven::RavenActivityStateEstimatorActiveObject *))(*(void *)this + 16))(&v136, this);
    double v93 = v32 + (double)v30;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v95, (unsigned __int8 *)&v96, "t,%.3lf,%s: Could not predict estimator", v33, v34, v35, v36, v37, SLOBYTE(v93));
    if (v138 < 0) {
      operator delete(*(void **)&v136);
    }
  }
  if (v135)
  {
    uint64_t v118 = &unk_1EDD140E8;
    if (__p)
    {
      uint64_t v133 = __p;
      operator delete(__p);
    }
  }
  if (v29) {
    goto LABEL_16;
  }
}

void sub_18E173F14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E173FB0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 544))
  {
    *(void *)(a1 + 312) = &unk_1EDD140E8;
    int v2 = *(void **)(a1 + 520);
    if (v2)
    {
      *(void *)(a1 + 528) = v2;
      operator delete(v2);
    }
  }
  return a1;
}

void *sub_18E17400C(void *a1, char a2)
{
  return sub_18DEDE7B0(a1, off_1E55B9C48[a2]);
}

void raven::RavenActivityStateEstimatorActiveObject::Reset(raven::RavenActivityStateEstimatorActiveObject *this)
{
  if (*((unsigned char *)this + 480))
  {
    if (*((unsigned char *)this + 608)) {
      *((unsigned char *)this + 608) = 0;
    }
    if (*((unsigned char *)this + 824)) {
      *((unsigned char *)this + 824) = 0;
    }
    if (*((unsigned char *)this + 1064))
    {
      *((void *)this + 104) = &unk_1EDD140E8;
      int v2 = (void *)*((void *)this + 130);
      if (v2)
      {
        *((void *)this + 131) = v2;
        operator delete(v2);
      }
      *((unsigned char *)this + 1064) = 0;
    }
    if (*((unsigned char *)this + 1232)) {
      *((unsigned char *)this + 1232) = 0;
    }
    if (*((unsigned char *)this + 1400)) {
      *((unsigned char *)this + 1400) = 0;
    }
    *((unsigned char *)this + 1408) = 0;
    *((void *)this + 211) = 0;
    *((void *)this + 212) = 0x7FF8000000000000;
  }
  cnframework::ActiveObjectBase::ResetCurrentTime(this);

  cnframework::ActiveObjectBase::ResetEventQueue(this);
}

void sub_18E1740E4(cnframework::ActiveObjectBase *a1)
{
  sub_18E0B8EB0(a1);

  JUMPOUT(0x192FA6240);
}

char *sub_18E17411C(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  long long v7 = result;
  uint64_t v8 = *((void *)result + 2);
  long long v9 = *(char **)result;
  if (0xCCCCCCCCCCCCCCCDLL * ((v8 - *(void *)result) >> 3) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 > 0x666666666666666) {
      sub_18DEE1FC8();
    }
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x333333333333333) {
      unint64_t v12 = 0x666666666666666;
    }
    else {
      unint64_t v12 = v11;
    }
    __n128 result = sub_18E01AEC0(v7, v12);
    int8x16_t v14 = (char *)v7[1];
    int8x16_t v13 = (void **)(v7 + 1);
    long long v9 = v14;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      long long v18 = v9;
      long long v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  int8x16_t v13 = (void **)(result + 8);
  long long v15 = (unsigned char *)*((void *)result + 1);
  if (0xCCCCCCCCCCCCCCCDLL * ((v15 - v9) >> 3) >= a4) {
    goto LABEL_16;
  }
  long long v16 = &__src[8 * ((v15 - v9) >> 3)];
  if (v15 != v9)
  {
    __n128 result = (char *)memmove(*(void **)result, __src, v15 - v9);
    long long v9 = (char *)*v13;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    long long v18 = v9;
    long long v19 = v16;
LABEL_18:
    __n128 result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *int8x16_t v13 = &v9[v17];
  return result;
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::CheckForAndHandleGrossClockOffsetError(uint64_t a1, uint64_t a2)
{
  raven::RavenSequentialGNSSMeasurementSelector::ComputeAndStoreAprioriPseudorangeInnovationStatistics(a1, a2);
  if (!*(unsigned char *)(a1 + 32)) {
    return 0;
  }
  double v3 = *(double *)(a1 + 24);
  double v4 = *(double *)(a1 + 8);
  if (vabdd_f64(v3, v4) <= 0.000000015) {
    return 0;
  }
  double v5 = v3 - v4;
  double v6 = *(double *)(a1 + 16);
  double v7 = *(double *)(*(void *)(a1 + 392) + 48 * *(int *)(a1 + 380) + 48);
  double v8 = sqrt((v3 - v6 + v5 * 0.2413) * (v3 - v6 + v5 * 0.2413) + v7 * 89875.5179);
  if (v6 >= 0.0)
  {
    if (v6 + v8 * -5.0 <= 0.0) {
      return 1;
    }
  }
  else if (v6 + v8 * 5.0 >= 0.0)
  {
    return 1;
  }
  double v11 = v6 * 0.00333564095;
  *(double *)(a1 + 72) = v6 * 0.00333564095;
  uint64_t v9 = 1;
  *(unsigned char *)(a1 + 80) = 1;
  *(double *)(*(void *)(a1 + 944) + 48) = v6 * 0.00333564095 + *(double *)(*(void *)(a1 + 944) + 48);
  raven::RavenSequentialGNSSMeasurementSelector::LogClockOffsetCorrection((void *)a1, v6 * 0.00333564095);
  __int16 v20 = 12;
  unsigned __int8 v19 = 3;
  char v12 = cnprint::CNLogFormatter::FormatGeneral(a1 + 208, a1 + 96, "#MSR gross clock error detected,%.3lf us,sigma,%.3lf us", v11, sqrt(v7));
  if (*(char *)(a1 + 231) >= 0) {
    LOBYTE(v18) = v12;
  }
  else {
    uint64_t v18 = *(void *)(a1 + 208);
  }
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v20, &v19, "%s", v13, v14, v15, v16, v17, v18);
  return v9;
}

void raven::RavenSequentialGNSSMeasurementSelector::ComputeAndStoreAprioriPseudorangeInnovationStatistics(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 1))
  {
    if (*(unsigned char *)(a1 + 32)) {
      *(unsigned char *)(a1 + 32) = 0;
    }
    std::string __p = 0;
    __int16 v27 = 0;
    uint64_t v28 = 0;
    v23[0] = 0;
    uint64_t v24 = 0;
    char v25 = 1;
    sub_18E0C5398((char **)&__p);
    char v29 = 1;
    uint64_t v4 = *(void *)(a2 + 8);
    if (v4 == a2)
    {
LABEL_9:
      if (v23[0])
      {
        double v6 = __p;
        if ((unint64_t)(v27 - (unsigned char *)__p) < 0x30) {
          goto LABEL_22;
        }
        sub_18E0C5470((uint64_t)v23, 25.0);
        double v8 = v7;
        sub_18E0C5470((uint64_t)v23, 50.0);
        double v10 = v9;
        sub_18E0C5470((uint64_t)v23, 75.0);
        double v12 = v11;
        if ((*(void *)&v8 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v11 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
        {
          v23[0] = 0;
          uint64_t v24 = 0;
          char v25 = 1;
          __int16 v27 = __p;
          sub_18E0C5398((char **)&__p);
          char v29 = 1;
          LOWORD(v22) = 12;
          unsigned __int8 v21 = 4;
          char v14 = cnprint::CNLogFormatter::FormatGeneral(a1 + 208, a1 + 96, "#MSR pseudorange innovation quartiles invalid,%.1lf,%.1lf,%.1lf", v8, v10, v12);
          if (*(char *)(a1 + 231) >= 0) {
            LOBYTE(v20) = v14;
          }
          else {
            uint64_t v20 = *(void *)(a1 + 208);
          }
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v22, &v21, "%s", v15, v16, v17, v18, v19, v20);
        }
        else
        {
          int v13 = *(unsigned __int8 *)(a1 + 32);
          *(double *)(a1 + 8) = v8;
          *(double *)(a1 + 16) = v10;
          *(double *)(a1 + 24) = v11;
          if (!v13) {
            *(unsigned char *)(a1 + 32) = 1;
          }
        }
      }
    }
    else
    {
      while (1)
      {
        uint64_t v5 = *(void *)(v4 + 24);
        if (*(_DWORD *)(v5 + 96) == 1)
        {
          if (*(unsigned char *)(v4 + 160))
          {
            double v22 = *(double *)(v5 + 120) - *(double *)(v4 + 48);
            if (sub_18E0C4D80((uint64_t)v23, (uint64_t *)&v22, 1.0 / (*(float *)(v5 + 168) * *(float *)(v5 + 168))))break; {
          }
            }
        }
        uint64_t v4 = *(void *)(v4 + 8);
        if (v4 == a2) {
          goto LABEL_9;
        }
      }
      v23[0] = 0;
      uint64_t v24 = 0;
      char v25 = 1;
      __int16 v27 = __p;
      sub_18E0C5398((char **)&__p);
      char v29 = 1;
    }
    double v6 = __p;
LABEL_22:
    if (v6)
    {
      __int16 v27 = v6;
      operator delete(v6);
    }
  }
}

void sub_18E1745F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *raven::RavenSequentialGNSSMeasurementSelector::LogClockOffsetCorrection(void *this, double a2)
{
  if (*((unsigned char *)this + 1) && *((unsigned char *)this + 1506))
  {
    sub_18DEDD538(this + 189, (uint64_t)"NOTE: Clock offset corrected by ", 32);
    int v2 = (void *)std::ostream::operator<<();
    return sub_18DEDD538(v2, (uint64_t)" meters\n\n", 9);
  }
  return this;
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::CheckGnssInnovationThresholds(uint64_t a1, double *a2, double a3)
{
  if (*a2 >= 0.0)
  {
    __int16 v17 = 12;
    unsigned __int8 v16 = 4;
    unsigned __int8 v8 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR negative rejection threshold invalid,%.3f");
  }
  else
  {
    double v4 = a2[1];
    if (v4 >= 0.0)
    {
      __int16 v17 = 12;
      unsigned __int8 v16 = 4;
      unsigned __int8 v8 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR negative re-weight threshold invalid,%.3f");
    }
    else
    {
      double v5 = a2[2];
      if (v5 <= 0.0)
      {
        __int16 v17 = 12;
        unsigned __int8 v16 = 4;
        unsigned __int8 v8 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR positive re-weight threshold invalid,%.3f");
      }
      else
      {
        double v6 = a2[3];
        if (v6 <= 0.0)
        {
          __int16 v17 = 12;
          unsigned __int8 v16 = 4;
          unsigned __int8 v8 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR positive rejection threshold invalid,%.3f");
        }
        else
        {
          double v7 = fabs(v4);
          if (fabs(*a2) >= v7)
          {
            if (v7 >= a3)
            {
              if (v6 >= v5)
              {
                if (v5 >= a3) {
                  return 1;
                }
                __int16 v17 = 12;
                unsigned __int8 v16 = 4;
                unsigned __int8 v8 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR positive re-weight threshold should be outside target sigma count,reweight,%.3f,target,%.3lf");
              }
              else
              {
                __int16 v17 = 12;
                unsigned __int8 v16 = 4;
                unsigned __int8 v8 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR positive rejection threshold should be outside negative re-weight threshold,reject,%.3lf,reweight,%.3lf");
              }
            }
            else
            {
              __int16 v17 = 12;
              unsigned __int8 v16 = 4;
              unsigned __int8 v8 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR negative re-weight threshold should be outside target sigma count,reweight_abs,%.3f,target,%.3lf");
            }
          }
          else
          {
            __int16 v17 = 12;
            unsigned __int8 v16 = 4;
            unsigned __int8 v8 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR negative rejection threshold should be outside negative re-weight threshold,reject,%.3lf,reweight,%.3lf");
          }
        }
      }
    }
  }
  if (*(char *)(a1 + 231) >= 0) {
    LOBYTE(v14) = v8;
  }
  else {
    uint64_t v14 = *(void *)(a1 + 208);
  }
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v17, &v16, "%s", v9, v10, v11, v12, v13, v14);
  return 0;
}

void raven::RavenSequentialGNSSMeasurementSelector::ComputeHorizontalPositionMisclosureAndHDOP(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 16))
  {
    sub_18DFFDA0C((uint64_t)v62, **(float64_t **)(a1 + 288), *(float64_t *)(*(void *)(a1 + 288) + 8), *(double *)(*(void *)(a1 + 288) + 16));
    uint64_t v59 = 0;
    std::string __p = 0;
    uint64_t v60 = 0;
    v55[0] = 0;
    uint64_t v56 = 0;
    char v57 = 1;
    sub_18E0C5398((char **)&__p);
    char v61 = 1;
    uint64_t v52 = 0x400000004;
    uint64_t v50 = &unk_1EDD195A8;
    uint64_t v53 = &v54;
    long long v51 = xmmword_18E1F6F70;
    sub_18DFE2CC8((uint64_t)&v50, 0.0);
    uint64_t v4 = *(void *)(a2 + 8);
    if (v4 == a2)
    {
      int v5 = 0;
    }
    else
    {
      int v5 = 0;
      do
      {
        if (*(_DWORD *)(*(void *)(v4 + 24) + 96) == 1 && (*(_DWORD *)(v4 + 192) & 0xFFFFFFFE) == 4)
        {
          uint64_t v6 = *(void *)(v4 + 16);
          long double v7 = *(double *)(v6 + 264);
          double v8 = cos(v7);
          if (*(unsigned char *)(a1 + 2424))
          {
            uint64_t v46 = 0x400000001;
            long long v45 = xmmword_18E1FD6B0;
            uint64_t v44 = &unk_1EDD182E8;
            uint64_t v47 = &v48;
            __double2 v9 = __sincos_stret(*(double *)(v6 + 272));
            *(double *)&long long v48 = -(v8 * v9.__sinval);
            *((double *)&v48 + 1) = -(v8 * v9.__cosval);
            *(double *)&long long v49 = -sin(v7);
            *((void *)&v49 + 1) = 0x3FF0000000000000;
            uint64_t v36 = 0x100000004;
            uint64_t v34 = &unk_1EDD19458;
            uint64_t v37 = v38;
            long long v35 = xmmword_18E1F6F80;
            v38[0] = v48;
            v38[1] = v49;
            uint64_t v41 = 0x400000004;
            uint64_t v39 = &unk_1EDD195A8;
            long long v40 = xmmword_18E1F6F70;
            uint64_t v42 = (double *)v43;
            sub_18DFE2B44((uint64_t)&v34, (uint64_t)&v44, (uint64_t)&v39);
            uint64_t v65 = 0x400000004;
            long long v64 = xmmword_18E1F6F70;
            double v63 = COERCE_DOUBLE(&unk_1EDD195A8);
            int v66 = v67;
            sub_18DFEF1F4((uint64_t)&v50, (uint64_t)&v39, (uint64_t)&v63);
            sub_18DFE2F24((uint64_t)&v50, (uint64_t)&v63);
            long double v7 = *(double *)(*(void *)(v4 + 16) + 264);
          }
          ++v5;
          if (v7 <= 1.3962634 && v7 >= 0.34906585)
          {
            double v10 = *(double *)(*(void *)(v4 + 24) + 120);
            double v11 = *(double *)(v4 + 48);
            uint64_t v41 = 0x100000001;
            uint64_t v39 = &unk_1EDD18048;
            *(void *)&long long v12 = 0x100000001;
            *((void *)&v12 + 1) = 0x100000001;
            long long v40 = v12;
            uint64_t v42 = (double *)v43;
            sub_18DFE2B44(v4 + 56, a1 + 912, (uint64_t)&v39);
            uint64_t v13 = (DWORD1(v40) * v40);
            if ((int)v13 >= 1)
            {
              uint64_t v14 = v42;
              uint64_t v15 = v67;
              do
              {
                double v16 = *v14++;
                *v15++ = v10 - v11 - v16;
                --v13;
              }
              while (v13);
            }
            double v63 = fabs(v67[0]) / v8;
            sub_18E0C4D80((uint64_t)v55, (uint64_t *)&v63, 1.0);
          }
        }
        uint64_t v4 = *(void *)(v4 + 8);
      }
      while (v4 != a2);
    }
    int v17 = *(_DWORD *)(a1 + 2440);
    if (v5 - v17 < 4) {
      goto LABEL_39;
    }
    if (v55[0]) {
      int v18 = (unint64_t)(v59 - (unsigned char *)__p) >> 4;
    }
    else {
      int v18 = 0;
    }
    if (v18 - v17 < 4)
    {
LABEL_31:
      if (*(unsigned char *)(a1 + 2424))
      {
        uint64_t v41 = 0x400000004;
        uint64_t v39 = &unk_1EDD195A8;
        long long v40 = xmmword_18E1F6F70;
        uint64_t v42 = (double *)v43;
        uint64_t v46 = 0x100000004;
        long long v45 = xmmword_18E1F6F80;
        uint64_t v44 = &unk_1EDD19488;
        uint64_t v47 = &v48;
        uint64_t v36 = 0x100000004;
        uint64_t v34 = &unk_1EDD19488;
        long long v35 = xmmword_18E1F6F80;
        uint64_t v37 = v38;
        uint64_t v65 = 0x100000010;
        long long v64 = xmmword_18E1FCEF0;
        double v63 = COERCE_DOUBLE(&unk_1EDD17958);
        int v66 = v67;
        double v25 = sub_18E01D7FC((uint64_t)&v50, (uint64_t)&v44, (uint64_t)&v34, (uint64_t)&v63, (uint64_t)&v39);
        if ((*(void *)&v25 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || v25 >= *(double *)(*(void *)(a1 + 192) + 920))
        {
          LOWORD(v63) = 12;
          LOBYTE(v44) = 4;
          unsigned __int8 v26 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "t,%.3lf, pseudoinverse of design matrix is poorly conditioned, condition number, %.3lf", *(double *)(a1 + 104) + (double)*(uint64_t *)(a1 + 96), v25);
          if (*(char *)(a1 + 231) >= 0) {
            LOBYTE(v32) = v26;
          }
          else {
            uint64_t v32 = *(void *)(a1 + 208);
          }
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v63, (unsigned __int8 *)&v44, "%s", v27, v28, v29, v30, v31, v32);
        }
        else
        {
          *(double *)(a1 + 2448) = sqrt(*v42 + v42[SHIDWORD(v40) + 1]);
        }
      }
LABEL_39:
      if (__p)
      {
        uint64_t v59 = __p;
        operator delete(__p);
      }
      return;
    }
    unsigned int v19 = *(unsigned __int8 *)(a1 + 1024);
    if (v19 > 9) {
      goto LABEL_28;
    }
    int v20 = 1 << v19;
    if ((v20 & 0x393) != 0)
    {
      double v21 = 75.0;
LABEL_30:
      sub_18E0C5470((uint64_t)v55, v21);
      *(void *)(a1 + 2432) = v24;
      goto LABEL_31;
    }
    if ((v20 & 0x4C) != 0)
    {
      unint64_t v22 = *(char *)(a1 + 1016);
      if (v22 <= 6)
      {
        double v21 = dbl_18E21CC00[v22];
        goto LABEL_30;
      }
    }
    else
    {
LABEL_28:
      int v23 = *(unsigned __int8 *)(a1 + 1016);
      if ((v23 - 3) >= 2)
      {
        BOOL v33 = v23 == 6 || v23 == 0;
        double v21 = 35.0;
        if (v33) {
          double v21 = 75.0;
        }
        goto LABEL_30;
      }
    }
    double v21 = 50.0;
    goto LABEL_30;
  }
}

void sub_18E174EA4(_Unwind_Exception *a1)
{
  int v2 = (void *)STACK[0x240];
  if (STACK[0x240])
  {
    STACK[0x248] = (unint64_t)v2;
    operator delete(v2);
  }
  _Unwind_Resume(a1);
}

void raven::RavenSequentialGNSSMeasurementSelector::ComputeInnovationData(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(unsigned char *)a4 = 0;
  *(unsigned char *)(a4 + 16) = 0;
  if (*(unsigned char *)(a3 + 112))
  {
    *(int64x2_t *)a4 = vdupq_n_s64(0x7FF8000000000000uLL);
    *(unsigned char *)(a4 + 16) = 1;
    uint64_t v7 = a3 + 8;
    double v8 = *(double *)a3;
    double v9 = *(double *)(a2 + 120);
    uint64_t v21 = 0x100000001;
    unsigned int v19 = &unk_1EDD18048;
    *(void *)&long long v10 = 0x100000001;
    *((void *)&v10 + 1) = 0x100000001;
    long long v20 = v10;
    unint64_t v22 = (double *)v23;
    sub_18DFE2B44(a3 + 8, a1 + 912, (uint64_t)&v19);
    uint64_t v12 = (DWORD1(v20) * v20);
    if ((int)v12 >= 1)
    {
      uint64_t v13 = v22;
      uint64_t v14 = (double *)v28;
      do
      {
        double v15 = *v13++;
        *v14++ = v9 - v8 - v15;
        --v12;
      }
      while (v12);
      uint64_t v11 = v28[0];
    }
    *(void *)a4 = v11;
    uint64_t v26 = 0x800000001;
    uint64_t v24 = &unk_1EDD18408;
    long long v25 = xmmword_18E215AC0;
    uint64_t v27 = v28;
    sub_18DFE2B44(v7, a1 + 360, (uint64_t)&v24);
    unsigned int v17 = *(_DWORD *)(a3 + 16);
    unsigned int v16 = *(_DWORD *)(a3 + 20);
    uint64_t v21 = 0x100000008;
    unsigned int v19 = &unk_1EDD19CC8;
    *(void *)&long long v20 = __PAIR64__(v17, v16);
    DWORD2(v20) = v17 * v16;
    HIDWORD(v20) = v16;
    unint64_t v22 = (double *)v23;
    sub_18DFE2C64(v7, (uint64_t)&v19);
    uint64_t v31 = 0x100000001;
    uint64_t v29 = &unk_1EDD18048;
    *(void *)&long long v18 = 0x100000001;
    *((void *)&v18 + 1) = 0x100000001;
    long long v30 = v18;
    uint64_t v32 = &v33;
    sub_18DFE2B44((uint64_t)&v24, (uint64_t)&v19, (uint64_t)&v29);
    *(void *)(a4 + 8) = *v32;
  }
}

void raven::RavenSequentialGNSSMeasurementSelector::ComputeMeasurementFunctionOutput(uint64_t a1@<X0>, uint64_t a2@<X1>, long long *a3@<X2>, uint64_t a4@<X8>)
{
  *(unsigned char *)a4 = 0;
  *(unsigned char *)(a4 + 112) = 0;
  uint64_t v332 = 0x100000001;
  *(void *)&long long v8 = 0x100000001;
  *((void *)&v8 + 1) = 0x100000001;
  long long v331 = v8;
  v330[1] = &unk_1EDD18048;
  uint64_t v333 = &v334;
  uint64_t v328 = 0x100000001;
  long long v327 = v8;
  v326[1] = &unk_1EDD18048;
  int v329 = (double *)v330;
  uint64_t v324 = 0x100000001;
  long long v323 = v8;
  v322[8] = &unk_1EDD18048;
  uint64_t v325 = (double *)v326;
  uint64_t v320 = 0x800000001;
  long long v319 = xmmword_18E215AC0;
  v318 = &unk_1EDD18408;
  long long v321 = (double *)v322;
  uint64_t v315 = 0x100000001;
  long long v314 = v8;
  v313 = &unk_1EDD18048;
  long long v316 = &v317;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404CB0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB404CB0))
  {
    sub_18E176EDC();
    __cxa_atexit((void (*)(void *))sub_18DFF26DC, &qword_1EB404CC8, &dword_18DEDB000);
    __cxa_guard_release(&qword_1EB404CB0);
  }
  sub_18DEDE7B0(&v287, "");
  LOBYTE(v288) = 0;
  HIDWORD(v288) = -1;
  long long v289 = 0uLL;
  LOBYTE(v290) = 0;
  *(void *)&long long v291 = 0;
  *((void *)&v290 + 1) = 0;
  BYTE8(v291) = 0;
  long long v292 = 0uLL;
  LOBYTE(v293) = 0;
  *(void *)&long long v294 = 0;
  *((void *)&v293 + 1) = 0;
  *((void *)&v294 + 1) = 0x7FF8000000000000;
  LODWORD(v295) = 0;
  BYTE4(v295) = 0;
  *((void *)&v295 + 1) = 0x7FF8000000000000;
  *(int64x2_t *)&v296[8] = vdupq_n_s64(0x7FF8000000000000uLL);
  *(_OWORD *)&v296[24] = *(_OWORD *)&v296[8];
  *(_OWORD *)&v296[40] = *(_OWORD *)&v296[8];
  *(_DWORD *)int v296 = 2143289344;
  *(_DWORD *)&v296[56] = 2143289344;
  v296[60] = 0;
  LOBYTE(v297) = 0;
  BYTE4(v297) = 0;
  BYTE8(v297) = 0;
  WORD6(v297) = 0;
  BYTE14(v297) = 1;
  long long v298 = *(_OWORD *)&v296[8];
  int v299 = &unk_1EDD0AE58;
  sub_18DEDE7B0(&v300, "");
  LOBYTE(v301) = 0;
  long long v302 = 0u;
  HIDWORD(v301) = -1;
  long long v303 = 0u;
  long long v304 = 0u;
  long long v305 = 0u;
  long long v306 = 0u;
  long long v307 = 0u;
  long long v308 = 0u;
  long long v309 = 0u;
  long long v310 = 0u;
  long long v311 = 0u;
  long long v312 = 0u;
  *(void *)&long long v9 = 0x100000001;
  *((void *)&v9 + 1) = 0x100000001;
  long long v331 = v9;
  long long v327 = v9;
  uint64_t *v333 = *((void *)a3 + 15);
  *int v329 = (float)(*((float *)a3 + 42) * *((float *)a3 + 42));
  long long v10 = a3[3];
  long long v291 = a3[2];
  long long v292 = v10;
  long long v11 = a3[1];
  long long v289 = *a3;
  long long v290 = v11;
  long long v12 = a3[7];
  long long v295 = a3[6];
  *(_OWORD *)int v296 = v12;
  long long v13 = a3[5];
  long long v293 = a3[4];
  long long v294 = v13;
  long long v14 = a3[12];
  long long v15 = a3[10];
  long long v297 = a3[11];
  long long v298 = v14;
  long long v16 = a3[9];
  *(_OWORD *)&v296[16] = a3[8];
  *(_OWORD *)&v296[32] = v16;
  *(_OWORD *)&v296[48] = v15;
  std::string::operator=(&v287, (const std::string *)a2);
  uint64_t v288 = *(void *)(a2 + 24);
  std::string::operator=(&v300, (const std::string *)(a2 + 40));
  uint64_t v301 = *(void *)(a2 + 64);
  long long v17 = *(_OWORD *)(a2 + 184);
  long long v18 = *(_OWORD *)(a2 + 216);
  long long v310 = *(_OWORD *)(a2 + 200);
  long long v311 = v18;
  long long v312 = *(_OWORD *)(a2 + 232);
  long long v19 = *(_OWORD *)(a2 + 120);
  long long v20 = *(_OWORD *)(a2 + 152);
  long long v306 = *(_OWORD *)(a2 + 136);
  long long v307 = v20;
  long long v308 = *(_OWORD *)(a2 + 168);
  long long v309 = v17;
  long long v21 = *(_OWORD *)(a2 + 88);
  long long v302 = *(_OWORD *)(a2 + 72);
  long long v303 = v21;
  long long v304 = *(_OWORD *)(a2 + 104);
  long long v305 = v19;
  switch(*((_DWORD *)a3 + 24))
  {
    case 0:
    case 5:
      LOWORD(v357) = 12;
      LOBYTE(v345) = 4;
      unint64_t v22 = sub_18E017C64(a2);
      char v23 = cnprint::CNLogFormatter::FormatGeneral(a1 + 208, a1 + 96, "#MSR %s unexpected meas type %d", v22, *((_DWORD *)a3 + 24));
      if (*(char *)(a1 + 231) >= 0) {
        LOBYTE(v29) = v23;
      }
      else {
        uint64_t v29 = *(void *)(a1 + 208);
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v357, (unsigned __int8 *)&v345, "%s", v24, v25, v26, v27, v28, v29);
      goto LABEL_159;
    case 1:
      sub_18E1124FC((uint64_t)&v357, (long long *)&v287);
      *(_OWORD *)uint64_t v360 = *(_OWORD *)(a1 + 96);
      int v91 = v358[0];
      unint64_t v92 = (char *)sub_18E017C64((uint64_t)&v287);
      sub_18DEDE7B0(v285, v92);
      sub_18E03F90C((uint64_t)&v357, v91, (long long *)v285);
      if (v286 < 0) {
        operator delete(v285[0]);
      }
      uint64_t v94 = *(void *)(a2 + 312);
      double v93 = *(std::__shared_weak_count **)(a2 + 320);
      if (v93) {
        atomic_fetch_add_explicit(&v93->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v367 = v94;
      int v95 = v368;
      uint64_t v368 = v93;
      if (v95) {
        sub_18DEE4E18(v95);
      }
      __int16 v96 = (char *)__dynamic_cast(&v357, (const struct __class_type_info *)&unk_1EDD02A78, (const struct __class_type_info *)&unk_1EDD05AF8, 0);
      if (!v96)
      {
        LOWORD(v345) = 12;
        LOBYTE(src.f64[0]) = 4;
        double v263 = MEMORY[0x30] + (double)MEMORY[0x28];
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)&src, "time,%.3lf,h-function failure on line %d: %s() %s", v97, v98, v99, v100, v101, SLOBYTE(v263));
        goto LABEL_101;
      }
      long long v102 = v96;
      unsigned int v103 = *(_DWORD *)(a1 + 264);
      unsigned int v104 = *(_DWORD *)(a1 + 268);
      if (v103 <= v104) {
        int v105 = *(_DWORD *)(a1 + 268);
      }
      else {
        int v105 = *(_DWORD *)(a1 + 264);
      }
      if (!v103
        || !v104
        || v105 != 8
        || (dword_1EB404CD0 <= *(_DWORD *)algn_1EB404CD4
          ? (int v106 = *(_DWORD *)algn_1EB404CD4)
          : (int v106 = dword_1EB404CD0),
            !dword_1EB404CD0 || !*(_DWORD *)algn_1EB404CD4 || v106 != 1))
      {
        LOWORD(v345) = 12;
        LOBYTE(src.f64[0]) = 4;
        double v137 = *((double *)v96 + 6) + (double)*((uint64_t *)v96 + 5);
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)&src, "time,%.3lf,h-function failure on line %d: %s() %s", v97, v98, v99, v100, v101, SLOBYTE(v137));
LABEL_101:
        LOWORD(v345) = 12;
        LOBYTE(src.f64[0]) = 4;
        int v148 = sub_18E017C64(a2);
        unsigned int v149 = *((_DWORD *)a3 + 24) - 1;
        if (v149 > 4) {
          int v150 = "UnknownType";
        }
        else {
          int v150 = off_1E55B9E30[v149];
        }
        char v151 = cnprint::CNLogFormatter::FormatGeneral(a1 + 208, a1 + 96, "#MSR %s %s h-function failed", v148, v150);
        if (*(char *)(a1 + 231) >= 0) {
          LOBYTE(v157) = v151;
        }
        else {
          uint64_t v157 = *(void *)(a1 + 208);
        }
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)&src, "%s", v152, v153, v154, v155, v156, v157);
        uint64_t v357 = (uint64_t)&unk_1EDD151C8;
        if (v368) {
          sub_18DEE4E18(v368);
        }
        uint64_t v357 = (uint64_t)&unk_1EDD0A4E8;
        if (SHIBYTE(v359) < 0) {
          operator delete(*(void **)&v358[8]);
        }
        goto LABEL_111;
      }
      uint64_t v273 = (uint64_t)(v96 + 56);
      if (!v96[128])
      {
        LOWORD(v345) = 12;
        LOBYTE(src.f64[0]) = 4;
        double v172 = *((double *)v96 + 6) + (double)*((uint64_t *)v96 + 5);
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)&src, "time,%.3lf,h-function failure on line %d: %s() %s", v97, v98, v99, v100, v101, SLOBYTE(v172));
        LOWORD(v345) = 12;
        LOBYTE(src.f64[0]) = 4;
        uint64_t v173 = *((void *)v102 + 11);
        double v174 = *((double *)v102 + 12);
        sub_18E017C64(v273);
        double v265 = v174 + (double)v173;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)&src, "t,%.3lf,%s,TAI time invalid", v175, v176, v177, v178, v179, SLOBYTE(v265));
        goto LABEL_101;
      }
      long long v107 = *(long long **)(a1 + 288);
      long long v341 = *v107;
      uint64_t v342 = *((void *)v107 + 2);
      v337[0] = (uint64_t)&unk_1EDD0ADE8;
      v336[0] = (uint64_t)&unk_1EDD0AE20;
      v335[0] = 0;
      *(double *)&unint64_t v108 = *((double *)v107 + 6) * 0.000001;
      *(_OWORD *)v277 = 0u;
      v278[0] = 0u;
      float64x2_t src = 0u;
      long long v338 = *(_OWORD *)(v96 + 136);
      v109.i64[1] = *((void *)&v338 + 1);
      v109.i64[0] = *((void *)v96 + 24);
      LOWORD(v345) = 0;
      long long v346 = 0u;
      long long v347 = 0u;
      int v348 = 0;
      uint64_t v350 = 0;
      uint64_t v349 = 0;
      int v351 = 0;
      if (cnnavigation::GNSSPseudorange((uint64_t)&v338, (uint64_t)&v345, (uint64_t)&v341, (uint64_t)(v96 + 296), v337, v336, (double *)v335, 1, v109, (int8x16_t)v108, &src))
      {
        LOWORD(v345) = 12;
        LOBYTE(v338) = 4;
        double v115 = *((double *)v102 + 6) + (double)*((uint64_t *)v102 + 5);
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)&v338, "time,%.3lf,h-function failure on line %d: %s() %s", v110, v111, v112, v113, v114, SLOBYTE(v115));
        if (cnprint::CNPrinter::GetLogLevel(v116) <= 1)
        {
          LOWORD(v345) = 12;
          LOBYTE(v338) = 1;
          uint64_t v117 = *((void *)v102 + 11);
          double v118 = *((double *)v102 + 12);
          sub_18E017C64(v273);
          double v260 = v118 + (double)v117;
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)&v338, "t,%.3lf,%s,GNSSPseudorange returned != 0", v119, v120, v121, v122, v123, SLOBYTE(v260));
        }
        goto LABEL_101;
      }
      *(void *)&long long v213 = 0x100000001;
      *((void *)&v213 + 1) = 0x100000001;
      long long v323 = v213;
      *(void *)&long long v347 = 0x800000001;
      long long v345 = &unk_1EDD18408;
      *((void *)&v347 + 1) = &v348;
      long long v346 = xmmword_18E215AC0;
      sub_18DFE2CC8((uint64_t)&v345, 0.0);
      sub_18DFE2F24((uint64_t)&v318, (uint64_t)&v345);
      uint64_t v214 = *((void *)v102 + 64);
      if (v214)
      {
        double *v325 = *(double *)v335 + *(double *)v214 + *(double *)qword_1EB404CE8;
        uint64_t v215 = *(double **)(v214 + 40);
        long long v216 = v321;
        *long long v321 = *v215;
        uint64_t v217 = *(int *)(v214 + 28);
        int v218 = HIDWORD(v319);
        v216[SHIDWORD(v319)] = v215[v217];
        uint64_t v219 = &v215[2 * v217];
        int v220 = v218;
      }
      else
      {
        double *v325 = *(double *)v335 + *(double *)qword_1EB404CE8;
        long long v216 = v321;
        *long long v321 = *(double *)v277;
        int v220 = HIDWORD(v319);
        v216[SHIDWORD(v319)] = *(double *)&v277[1];
        uint64_t v219 = (double *)v278;
      }
      v216[2 * v220] = *v219;
      v216[6 * v220] = *((double *)v278 + 1) * 0.000001;
      *(void *)&long long v347 = 0x100000001;
      long long v345 = &unk_1EDD18048;
      *((void *)&v347 + 1) = &v348;
      *(void *)&long long v221 = 0x100000001;
      *((void *)&v221 + 1) = 0x100000001;
      long long v346 = v221;
      sub_18DFE2CC8((uint64_t)&v345, 0.0);
      **((void **)&v347 + 1) = 0x3FF0000000000000;
      sub_18DFE2F24((uint64_t)&v313, (uint64_t)&v345);
      if (!cnprint::CNPrinter::GetLogLevel(v222))
      {
        LOWORD(v345) = 12;
        LOBYTE(v338) = 0;
        uint64_t v223 = *((void *)v102 + 11);
        double v224 = *((double *)v102 + 12);
        sub_18E017C64(v273);
        double v269 = v224 + (double)v223;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)&v338, "t,%.3lf,%s,using PSR,predicted,%.3lf,diff,%.3lf,clockEstMtrs,%.2lf,std,%.2lf,multipath,%hhu,cno,%.1lf", v225, v226, v227, v228, v229, SLOBYTE(v269));
      }
      uint64_t v357 = (uint64_t)&unk_1EDD151C8;
      if (v368) {
        sub_18DEE4E18(v368);
      }
      uint64_t v357 = (uint64_t)&unk_1EDD0A4E8;
      if (SHIBYTE(v359) < 0) {
        operator delete(*(void **)&v358[8]);
      }
LABEL_136:
      unsigned __int8 v364 = &unk_1EDD0AE58;
      if (v366 < 0) {
        operator delete(v365);
      }
      unsigned __int8 v364 = &unk_1EDD0A9B8;
      if (SHIBYTE(v361) < 0)
      {
        __CLPK_integer v230 = *(void **)&v360[16];
LABEL_140:
        operator delete(v230);
      }
LABEL_151:
      double v250 = *v325;
      if ((*(void *)v325 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
      {
        LOWORD(v357) = 12;
        LOBYTE(v345) = 4;
        char v251 = cnprint::CNLogFormatter::FormatGeneral(a1 + 208, a1 + 96, "#MSR predicted measurement invalid,%.3lf,type,%d", v250, *((_DWORD *)a3 + 24));
        if (*(char *)(a1 + 231) >= 0) {
          LOBYTE(v257) = v251;
        }
        else {
          uint64_t v257 = *(void *)(a1 + 208);
        }
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v357, (unsigned __int8 *)&v345, "%s", v252, v253, v254, v255, v256, v257);
      }
      long long v363 = 0u;
      long long v362 = 0u;
      long long v361 = 0u;
      *(_OWORD *)&v360[8] = 0u;
      uint64_t v357 = 0x7FF8000000000000;
      uint64_t v359 = 0x800000001;
      *(void *)uint64_t v358 = &unk_1EDD18408;
      *(_OWORD *)&v358[8] = xmmword_18E215AC0;
      *(void *)uint64_t v360 = &v360[8];
      if (*(unsigned char *)(a4 + 112))
      {
        *(void *)(a4 + 8) = &unk_1EDD17478;
        *(unsigned char *)(a4 + 112) = 0;
      }
      *(void *)a4 = 0x7FF8000000000000;
      sub_18E18251C(a4 + 8, (uint64_t)v358);
      *(unsigned char *)(a4 + 112) = 1;
      *(double *)a4 = *v325;
      sub_18DFE2F24(v258, (uint64_t)&v318);
LABEL_159:
      int v299 = &unk_1EDD0AE58;
      if (SHIBYTE(v300.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v300.__r_.__value_.__l.__data_);
      }
      int v299 = &unk_1EDD0A9B8;
      if (SHIBYTE(v287.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v287.__r_.__value_.__l.__data_);
      }
      return;
    case 2:
      sub_18E1127B8((uint64_t)&v357, (long long *)&v287);
      *(_OWORD *)uint64_t v360 = *(_OWORD *)(a1 + 96);
      int v60 = v358[0];
      char v61 = (char *)sub_18E017C64((uint64_t)&v287);
      sub_18DEDE7B0(v283, v61);
      sub_18E03F90C((uint64_t)&v357, v60, (long long *)v283);
      if (v284 < 0) {
        operator delete(v283[0]);
      }
      uint64_t v62 = (char *)__dynamic_cast(&v357, (const struct __class_type_info *)&unk_1EDD02A78, (const struct __class_type_info *)&unk_1EDD05D10, 0);
      if (v62)
      {
        uint64_t v69 = v62;
        unsigned int v70 = *(_DWORD *)(a1 + 264);
        unsigned int v71 = *(_DWORD *)(a1 + 268);
        if (v70 <= v71) {
          int v72 = *(_DWORD *)(a1 + 268);
        }
        else {
          int v72 = *(_DWORD *)(a1 + 264);
        }
        if (v70
          && v71
          && v72 == 8
          && (dword_1EB404CD0 <= *(_DWORD *)algn_1EB404CD4
            ? (int v73 = *(_DWORD *)algn_1EB404CD4)
            : (int v73 = dword_1EB404CD0),
              dword_1EB404CD0 && *(_DWORD *)algn_1EB404CD4 && v73 == 1))
        {
          uint64_t v272 = (uint64_t)(v62 + 56);
          if (v62[128])
          {
            uint64_t v74 = *(long long **)(a1 + 288);
            long long v341 = *v74;
            uint64_t v342 = *((void *)v74 + 2);
            long long v338 = *(long long *)((char *)v74 + 24);
            uint64_t v339 = *((void *)v74 + 5);
            v336[0] = (uint64_t)&unk_1EDD0ADE8;
            v335[0] = (uint64_t)&unk_1EDD0AE20;
            v369.f64[0] = 0.0;
            long long v279 = 0u;
            *(_OWORD *)v277 = 0u;
            memset(v278, 0, sizeof(v278));
            float64x2_t src = 0u;
            *(_OWORD *)long long v337 = *(_OWORD *)(v62 + 136);
            v75.i64[1] = v337[1];
            v75.i64[0] = *((void *)v62 + 24);
            double v76 = *((double *)v74 + 7);
            *(double *)v68.i64 = *((double *)v74 + 6) / 1000000.0;
            LOWORD(v345) = 0;
            long long v346 = 0u;
            long long v347 = 0u;
            int v348 = 0;
            uint64_t v350 = 0;
            uint64_t v349 = 0;
            int v351 = 0;
            if (!cnnavigation::GNSSDopplerShift((uint64_t)v337, (const cnnavigation::GNSSUTCParameters *)&v345, (uint64_t)&v341, (double *)&v338, (uint64_t)(v62 + 296), v336, v335, 1, v75, v68, v76 / 1000000.0, v369.f64, 1u, (uint64_t)&src))
            {
              double v200 = 299792458.0 / *((double *)v69 + 24);
              *(void *)&long long v201 = 0x100000001;
              *((void *)&v201 + 1) = 0x100000001;
              long long v323 = v201;
              double *v325 = *(double *)qword_1EB404CE8 - v200 * v369.f64[0];
              *(void *)&long long v347 = 0x800000001;
              long long v345 = &unk_1EDD18408;
              *((void *)&v347 + 1) = &v348;
              long long v346 = xmmword_18E215AC0;
              sub_18DFE2CC8((uint64_t)&v345, 0.0);
              sub_18DFE2F24((uint64_t)&v318, (uint64_t)&v345);
              double v202 = v321;
              *long long v321 = -(*(double *)v277 * v200);
              uint64_t v203 = SHIDWORD(v319);
              v202[SHIDWORD(v319)] = -(*(double *)&v277[1] * v200);
              v202[2 * v203] = -(*(double *)v278 * v200);
              v202[3 * (int)v203] = -(*((double *)v278 + 1) * v200);
              v202[4 * v203] = -(*(double *)&v278[1] * v200);
              v202[5 * (int)v203] = -(*((double *)&v278[1] + 1) * v200);
              v202[6 * (int)v203] = -(*(double *)&v279 * v200) / 1000000.0;
              v202[7 * (int)v203] = -(*((double *)&v279 + 1) * v200) / 1000000.0;
              *(void *)&long long v347 = 0x100000001;
              long long v345 = &unk_1EDD18048;
              *((void *)&v347 + 1) = &v348;
              *(void *)&long long v204 = 0x100000001;
              *((void *)&v204 + 1) = 0x100000001;
              long long v346 = v204;
              sub_18DFE2CC8((uint64_t)&v345, 0.0);
              **((void **)&v347 + 1) = 0x3FF0000000000000;
              sub_18DFE2F24((uint64_t)&v313, (uint64_t)&v345);
              if (!cnprint::CNPrinter::GetLogLevel(v205))
              {
                LOWORD(v345) = 12;
                LOBYTE(v337[0]) = 0;
                uint64_t v206 = *((void *)v69 + 11);
                double v207 = *((double *)v69 + 12);
                sub_18E017C64(v272);
                double v268 = v207 + (double)v206;
                cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)v337, "t,%.3lf,%s,using Doppler,predicted,%.3lf,obs,%.3lf,diff,%.3lf,clockEstMtrs,%.2lf,clockDriftMps,%.2lf,std,%.2lf,multipath,%hhu,cno,%.1lf", v208, v209, v210, v211, v212, SLOBYTE(v268));
              }
              uint64_t v357 = (uint64_t)&unk_1EDD0A4E8;
              if (SHIBYTE(v359) < 0) {
                operator delete(*(void **)&v358[8]);
              }
              goto LABEL_136;
            }
            LOWORD(v345) = 12;
            LOBYTE(v337[0]) = 4;
            double v82 = *((double *)v69 + 6) + (double)*((uint64_t *)v69 + 5);
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)v337, "time,%.3lf,h-function failure on line %d: %s() %s", v77, v78, v79, v80, v81, SLOBYTE(v82));
            if (cnprint::CNPrinter::GetLogLevel(v83) <= 1)
            {
              LOWORD(v345) = 12;
              LOBYTE(v337[0]) = 1;
              uint64_t v84 = *((void *)v69 + 11);
              double v85 = *((double *)v69 + 12);
              sub_18E017C64(v272);
              double v259 = v85 + (double)v84;
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)v337, "t,%.3lf,%s,GNSSDopplerShift returned != 0", v86, v87, v88, v89, v90, SLOBYTE(v259));
            }
          }
          else
          {
            LOWORD(v345) = 12;
            LOBYTE(src.f64[0]) = 4;
            double v164 = *((double *)v62 + 6) + (double)*((uint64_t *)v62 + 5);
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)&src, "time,%.3lf,h-function failure on line %d: %s() %s", v63, v64, v65, v66, v67, SLOBYTE(v164));
            LOWORD(v345) = 12;
            LOBYTE(src.f64[0]) = 4;
            uint64_t v165 = *((void *)v69 + 11);
            double v166 = *((double *)v69 + 12);
            sub_18E017C64(v272);
            double v264 = v166 + (double)v165;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)&src, "t,%.3lf,%s,TAI time invalid", v167, v168, v169, v170, v171, SLOBYTE(v264));
          }
        }
        else
        {
          LOWORD(v345) = 12;
          LOBYTE(src.f64[0]) = 4;
          double v136 = *((double *)v62 + 6) + (double)*((uint64_t *)v62 + 5);
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)&src, "time,%.3lf,h-function failure on line %d: %s() %s", v63, v64, v65, v66, v67, SLOBYTE(v136));
        }
      }
      else
      {
        LOWORD(v345) = 12;
        LOBYTE(src.f64[0]) = 4;
        double v262 = MEMORY[0x30] + (double)MEMORY[0x28];
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)&src, "time,%.3lf,h-function failure on line %d: %s() %s", v63, v64, v65, v66, v67, SLOBYTE(v262));
      }
      LOWORD(v345) = 12;
      LOBYTE(src.f64[0]) = 4;
      char v138 = sub_18E017C64(a2);
      unsigned int v139 = *((_DWORD *)a3 + 24) - 1;
      if (v139 > 4) {
        uint64_t v140 = "UnknownType";
      }
      else {
        uint64_t v140 = off_1E55B9E30[v139];
      }
      char v141 = cnprint::CNLogFormatter::FormatGeneral(a1 + 208, a1 + 96, "#MSR %s %s h-function failed", v138, v140);
      if (*(char *)(a1 + 231) >= 0) {
        LOBYTE(v147) = v141;
      }
      else {
        uint64_t v147 = *(void *)(a1 + 208);
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)&src, "%s", v142, v143, v144, v145, v146, v147);
      uint64_t v357 = (uint64_t)&unk_1EDD0A4E8;
      if (SHIBYTE(v359) < 0) {
        operator delete(*(void **)&v358[8]);
      }
LABEL_111:
      unsigned __int8 v364 = &unk_1EDD0AE58;
      if (v366 < 0) {
        operator delete(v365);
      }
      unsigned __int8 v364 = &unk_1EDD0A9B8;
      if (SHIBYTE(v361) < 0)
      {
        char v135 = *(void **)&v360[16];
        goto LABEL_115;
      }
      goto LABEL_159;
    case 3:
    case 4:
      sub_18E112A44((uint64_t)&src, (long long *)&v287);
      *(_OWORD *)((char *)v278 + 8) = *(_OWORD *)(a1 + 96);
      int v30 = LOBYTE(src.f64[1]);
      uint64_t v31 = (char *)sub_18E017C64((uint64_t)&v287);
      sub_18DEDE7B0(__p, v31);
      sub_18E03F90C((uint64_t)&src, v30, (long long *)__p);
      if (v275 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v32 = (double *)__dynamic_cast(&src, (const struct __class_type_info *)&unk_1EDD02A78, (const struct __class_type_info *)&unk_1EDD06000, 0);
      if (v32)
      {
        uint64_t v39 = v32;
        unsigned int v40 = *(_DWORD *)(a1 + 264);
        unsigned int v41 = *(_DWORD *)(a1 + 268);
        if (v40 <= v41) {
          int v42 = *(_DWORD *)(a1 + 268);
        }
        else {
          int v42 = *(_DWORD *)(a1 + 264);
        }
        if (v40
          && v41
          && v42 == 8
          && (dword_1EB404CD0 <= *(_DWORD *)algn_1EB404CD4
            ? (int v43 = *(_DWORD *)algn_1EB404CD4)
            : (int v43 = dword_1EB404CD0),
              dword_1EB404CD0 && *(_DWORD *)algn_1EB404CD4 && v43 == 1))
        {
          uint64_t v271 = (uint64_t)(v32 + 7);
          if (*((unsigned char *)v32 + 128))
          {
            v38.i64[0] = (uint64_t)v32[35];
            double v44 = v32[36] - *(double *)v38.i64;
            unint64_t v45 = (unint64_t)(COERCE__INT64(fabs(v44)) - 0x10000000000000) >> 53;
            if ((*(uint64_t *)&v44 <= -1 || v45 >= 0x3FF)
              && (unint64_t)(*(void *)&v44 - 1) >= 0xFFFFFFFFFFFFFLL)
            {
              LOWORD(v357) = 12;
              LOBYTE(v345) = 4;
              double v161 = v32[6] + (double)*((uint64_t *)v32 + 5);
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v357, (unsigned __int8 *)&v345, "time,%.3lf,h-function failure on line %d: %s() %s", v33, v34, v35, v36, v37, SLOBYTE(v161));
              LOWORD(v357) = 12;
              LOBYTE(v345) = 4;
              uint64_t v162 = *((void *)v39 + 11);
              double v163 = v39[12];
              sub_18E017C64(v271);
              double v267 = v163 + (double)v162;
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v357, (unsigned __int8 *)&v345, "t,%.3lf,%s,%s,Invalid time interval,%.2lf", v185, v186, v187, v188, v189, SLOBYTE(v267));
            }
            else
            {
              v373[0] = a1 + 256;
              v373[1] = (uint64_t)v32;
              double v372 = 0.0;
              long long v370 = 0u;
              long long v371 = 0u;
              float64x2_t v369 = 0u;
              *(void *)&v358[16] = 0x800000008;
              *(_OWORD *)uint64_t v358 = xmmword_18E1FD750;
              uint64_t v357 = (uint64_t)&unk_1EDD19DE8;
              uint64_t v359 = (uint64_t)v360;
              *(void *)&long long v346 = 0;
              long long v345 = 0;
              CNTimeSpan::SetTimeSpan((uint64_t *)&v345, 0, v38, (int8x16_t)xmmword_18E1FD750);
              v356[0] = CNTimeSpan::operator+((uint64_t)(v39 + 11), &v345, v48, v49);
              v356[1] = v50;
              if (sub_18E1826E4(v373, (uint64_t)v356, &v372, &v369, (uint64_t)&v357, v51, v52))
              {
                LOWORD(v345) = 12;
                LOBYTE(v341) = 4;
                double v59 = v39[6] + (double)*((uint64_t *)v39 + 5);
                cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v345, (unsigned __int8 *)&v341, "time,%.3lf,h-function failure on line %d: %s() %s", v53, v54, v55, v56, v57, SLOBYTE(v59));
              }
              else
              {
                double v355 = 0.0;
                long long v353 = 0u;
                long long v354 = 0u;
                float64x2_t v352 = 0u;
                *(void *)&long long v347 = 0x800000008;
                v190.i64[1] = 0x800000040;
                long long v346 = xmmword_18E1FD750;
                long long v345 = &unk_1EDD19DE8;
                *((void *)&v347 + 1) = &v348;
                v190.i64[0] = (uint64_t)v39[36];
                long long v341 = 0uLL;
                CNTimeSpan::SetTimeSpan((uint64_t *)&v341, 0, v190, v58);
                v344[0] = CNTimeSpan::operator+((uint64_t)(v39 + 11), &v341, v191, v192);
                v344[1] = v193;
                if (!sub_18E1826E4(v373, (uint64_t)v344, &v355, &v352, (uint64_t)&v345, v194, v195))
                {
                  double v231 = 1.0 / v44 * (299792458.0 / v39[24]);
                  *(void *)&long long v232 = 0x100000001;
                  *((void *)&v232 + 1) = 0x100000001;
                  long long v323 = v232;
                  double v233 = v355 - v372;
                  double *v325 = *(double *)qword_1EB404CE8 + (v355 - v372) * v231;
                  sub_18E11308C(1, 8, (uint64_t)&v341);
                  double v234 = *((double *)&v353 + 1);
                  long long v235 = v343;
                  *long long v343 = v231 * *(double *)&v353;
                  uint64_t v236 = SHIDWORD(v342);
                  v235[SHIDWORD(v342)] = v231 * v234;
                  double v237 = *((double *)&v354 + 1);
                  v235[2 * v236] = v231 * *(double *)&v354;
                  v235[6 * (int)v236] = v231 * v237 * 0.000001;
                  sub_18E11308C(1, 8, (uint64_t)&v338);
                  double v238 = *((double *)&v370 + 1);
                  uint64_t v239 = v340;
                  *long long v340 = v231 * *(double *)&v370;
                  uint64_t v240 = SHIDWORD(v339);
                  v239[SHIDWORD(v339)] = v231 * v238;
                  double v241 = *((double *)&v371 + 1);
                  v239[2 * v240] = v231 * *(double *)&v371;
                  v239[6 * (int)v240] = v231 * v241 * 0.000001;
                  sub_18E11308C(1, 8, (uint64_t)v337);
                  sub_18DFE2F24((uint64_t)&v318, (uint64_t)v337);
                  if (fabs(v39[36]) <= 0.001)
                  {
                    sub_18E1149AC((uint64_t)&v338, (uint64_t)&v357, (uint64_t)v336);
                    sub_18E114968((uint64_t)&v341, (uint64_t)v336, (uint64_t)v337);
                  }
                  else
                  {
                    sub_18E1149AC((uint64_t)&v341, (uint64_t)&v345, (uint64_t)v336);
                    sub_18E1149AC((uint64_t)&v338, (uint64_t)&v357, (uint64_t)v335);
                    sub_18E114968((uint64_t)v336, (uint64_t)v335, (uint64_t)v337);
                  }
                  sub_18DFE2F24((uint64_t)&v318, (uint64_t)v337);
                  v321[7 * SHIDWORD(v319)] = v321[7 * SHIDWORD(v319)] + v231 * v233 * 0.000001;
                  sub_18E071E98(1u, 1u, (uint64_t)v337);
                  sub_18DFE2F24((uint64_t)&v313, (uint64_t)v337);
                  if (!cnprint::CNPrinter::GetLogLevel(v242))
                  {
                    LOWORD(v337[0]) = 12;
                    LOBYTE(v336[0]) = 0;
                    uint64_t v243 = *((void *)v39 + 11);
                    double v244 = v39[12];
                    sub_18E017C64(v271);
                    double v270 = v244 + (double)v243;
                    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v337, (unsigned __int8 *)v336, "t,%.3lf,%s,using average Doppler,predictedCrnt,%.3lf,predictedPrev,%.3lf,diff,%.3lf,std,%.4lf,multipath,%hhu,cno,%.1lf", v245, v246, v247, v248, v249, SLOBYTE(v270));
                  }
                  *(void *)&src.f64[0] = &unk_1EDD0A4E8;
                  if (SBYTE7(v278[0]) < 0) {
                    operator delete(v277[0]);
                  }
                  long long v280 = &unk_1EDD0AE58;
                  if (v282 < 0) {
                    operator delete(v281);
                  }
                  long long v280 = &unk_1EDD0A9B8;
                  if (SHIBYTE(v279) < 0)
                  {
                    __CLPK_integer v230 = (void *)*((void *)&v278[1] + 1);
                    goto LABEL_140;
                  }
                  goto LABEL_151;
                }
                sub_18E06B804((uint64_t)(v39 + 5), (uint64_t)"could not compute expected carrier phase at end", (uint64_t)"h_GnssAverageDoppler_RavenConvergence", 836, v196, v197, v198, v199);
              }
            }
          }
          else
          {
            LOWORD(v357) = 12;
            LOBYTE(v345) = 4;
            double v158 = v32[6] + (double)*((uint64_t *)v32 + 5);
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v357, (unsigned __int8 *)&v345, "time,%.3lf,h-function failure on line %d: %s() %s", v33, v34, v35, v36, v37, SLOBYTE(v158));
            LOWORD(v357) = 12;
            LOBYTE(v345) = 4;
            uint64_t v159 = *((void *)v39 + 11);
            double v160 = v39[12];
            sub_18E017C64(v271);
            double v266 = v160 + (double)v159;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v357, (unsigned __int8 *)&v345, "t,%.3lf,%s,%s,TAI time invalid", v180, v181, v182, v183, v184, SLOBYTE(v266));
          }
        }
        else
        {
          LOWORD(v357) = 12;
          LOBYTE(v345) = 4;
          double v124 = v32[6] + (double)*((uint64_t *)v32 + 5);
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v357, (unsigned __int8 *)&v345, "time,%.3lf,h-function failure on line %d: %s() %s", v33, v34, v35, v36, v37, SLOBYTE(v124));
        }
      }
      else
      {
        LOWORD(v357) = 12;
        LOBYTE(v345) = 4;
        double v261 = MEMORY[0x30] + (double)MEMORY[0x28];
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v357, (unsigned __int8 *)&v345, "time,%.3lf,h-function failure on line %d: %s() %s", v33, v34, v35, v36, v37, SLOBYTE(v261));
      }
      LOWORD(v357) = 12;
      LOBYTE(v345) = 4;
      long long v125 = sub_18E017C64(a2);
      unsigned int v126 = *((_DWORD *)a3 + 24) - 1;
      if (v126 > 4) {
        long long v127 = "UnknownType";
      }
      else {
        long long v127 = off_1E55B9E30[v126];
      }
      char v128 = cnprint::CNLogFormatter::FormatGeneral(a1 + 208, a1 + 96, "#MSR %s %s h-function failed", v125, v127);
      if (*(char *)(a1 + 231) >= 0) {
        LOBYTE(v134) = v128;
      }
      else {
        uint64_t v134 = *(void *)(a1 + 208);
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v357, (unsigned __int8 *)&v345, "%s", v129, v130, v131, v132, v133, v134);
      *(void *)&src.f64[0] = &unk_1EDD0A4E8;
      if (SBYTE7(v278[0]) < 0) {
        operator delete(v277[0]);
      }
      long long v280 = &unk_1EDD0AE58;
      if (v282 < 0) {
        operator delete(v281);
      }
      long long v280 = &unk_1EDD0A9B8;
      if (SHIBYTE(v279) < 0)
      {
        char v135 = (void *)*((void *)&v278[1] + 1);
LABEL_115:
        operator delete(v135);
      }
      goto LABEL_159;
    default:
      goto LABEL_151;
  }
}

void sub_18E176D98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,char a31)
{
  sub_18E1081D8((uint64_t)&a31);
  sub_18E0419E0((uint64_t)&STACK[0x2E0]);
  if (*(unsigned char *)(v31 + 112)) {
    *(void *)(v31 + 8) = &unk_1EDD17478;
  }
  _Unwind_Resume(a1);
}

uint64_t sub_18E176EDC()
{
  qword_1EB404CE0 = 0x100000001;
  qword_1EB404CC8 = (uint64_t)&unk_1EDD18048;
  qword_1EB404CE8 = (uint64_t)&unk_1EB404CF0;
  *(void *)&long long v0 = 0x100000001;
  *((void *)&v0 + 1) = 0x100000001;
  *(_OWORD *)&dword_1EB404CD0 = v0;
  return sub_18DFE2CC8((uint64_t)&qword_1EB404CC8, 0.0);
}

void raven::RavenSequentialGNSSMeasurementSelector::ComputeMeasurementFunctionOutput(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2 != a2)
  {
    uint64_t v5 = a1 + 208;
    uint64_t v6 = a1 + 96;
    do
    {
      raven::RavenSequentialGNSSMeasurementSelector::ComputeMeasurementFunctionOutput(a1, *(void *)(v2 + 16), *(long long **)(v2 + 24), (uint64_t)&v18);
      if (*(unsigned __int8 *)(v2 + 160) == v19[104])
      {
        if (!*(unsigned char *)(v2 + 160)) {
          goto LABEL_9;
        }
        *(void *)(v2 + 48) = v18;
        sub_18DFE2F24(v2 + 56, (uint64_t)v19);
        if (!*(unsigned char *)(v2 + 160)) {
          goto LABEL_9;
        }
      }
      else
      {
        if (*(unsigned char *)(v2 + 160))
        {
          *(void *)(v2 + 56) = &unk_1EDD17478;
          *(unsigned char *)(v2 + 160) = 0;
LABEL_9:
          if (!cnprint::CNPrinter::GetLogLevel(v7))
          {
            LOWORD(v18) = 12;
            unsigned __int8 v17 = 0;
            long long v8 = sub_18E017C64(*(void *)(v2 + 16));
            unsigned int v9 = *(_DWORD *)(*(void *)(v2 + 24) + 96) - 1;
            long long v10 = "UnknownType";
            if (v9 <= 4) {
              long long v10 = off_1E55B9E30[v9];
            }
            cnprint::CNLogFormatter::FormatGeneral(v5, v6, "#MSR %s %s could not get h-function output", v8, v10);
            if (*(char *)(a1 + 231) >= 0) {
              LOBYTE(v16) = v5;
            }
            else {
              uint64_t v16 = *(void *)(a1 + 208);
            }
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v18, &v17, "%s", v11, v12, v13, v14, v15, v16);
          }
          goto LABEL_17;
        }
        *(void *)(v2 + 48) = v18;
        sub_18E18251C(v2 + 56, (uint64_t)v19);
        *(unsigned char *)(v2 + 160) = 1;
      }
LABEL_17:
      uint64_t v2 = *(void *)(v2 + 8);
    }
    while (v2 != a2);
  }
}

double raven::RavenSequentialGNSSMeasurementSelector::ComputeReweightedMeasurementVariance(uint64_t a1, uint64_t a2)
{
  double TargetSigmaCount = raven::RavenSequentialGNSSMeasurementSelector::GetTargetSigmaCount(a1, a2);
  double v5 = COERCE_DOUBLE(raven::RavenSequentialGNSSMeasurementSelector::ComputeReweightedMeasurementVariance(a1, a2, TargetSigmaCount));
  if (!*(unsigned char *)(a2 + 184)) {
    return result;
  }
  uint64_t v8 = *(void *)(a2 + 8);
  int v9 = *(_DWORD *)(v8 + 96);
  if ((v9 - 2) < 2)
  {
    long long v10 = (double *)(*(void *)(a1 + 192) + 2456);
LABEL_6:
    double v11 = *v10;
    goto LABEL_7;
  }
  double v11 = 0.0;
  if (v9 == 1)
  {
    long long v10 = (double *)(*(void *)(a1 + 192) + 2464);
    goto LABEL_6;
  }
LABEL_7:
  double v12 = fabs(*(double *)(a2 + 152));
  if (v11 <= v12) {
    double v11 = v12;
  }
  if (v11 <= *(float *)(v8 + 168)) {
    double v11 = *(float *)(v8 + 168);
  }
  double result = v11 * v11;
  if (v6)
  {
    if (result <= v5) {
      return v5;
    }
  }
  return result;
}

double raven::RavenSequentialGNSSMeasurementSelector::GetTargetSigmaCount(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(double **)(a1 + 192);
  uint64_t v3 = *(void *)(a2 + 8);
  if (*(unsigned char *)(v3 + 188)) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = *(unsigned char *)(a2 + 184) == 0;
  }
  if (v4) {
    return v2[205];
  }
  uint64_t v8 = *(void *)a2;
  double result = *(double *)(*(void *)a2 + 264);
  if (result < v2[309] * 0.0174532925)
  {
    double v9 = v2[205];
    double v10 = 0.2;
    return v9 * v10;
  }
  unsigned int v11 = *(_DWORD *)(v3 + 96);
  if (v11 <= 5)
  {
    int v12 = 1 << v11;
    if ((v12 & 0x31) == 0)
    {
      if ((v12 & 0xC) != 0)
      {
        double v9 = v2[294];
LABEL_13:
        double v10 = v2[205];
        return v9 * v10;
      }
      for (uint64_t i = 0; i != 4; ++i)
      {
        if (*(unsigned char *)(v8 + 304) && *(double *)(v8 + 296) > v2[i + 295])
        {
          double v9 = v2[i + 300];
          goto LABEL_13;
        }
      }
      __int16 v22 = 12;
      unsigned __int8 v21 = 4;
      uint64_t v14 = sub_18E017C64(v8);
      if (!*(unsigned char *)(*(void *)a2 + 304)) {
        sub_18DFF28FC();
      }
      cnprint::CNLogFormatter::FormatGeneral(a1 + 208, a1 + 96, "#MSR no PSR target sigma scale factor found for %s with P(LOS),%.3lf", v14, *(double *)(*(void *)a2 + 296));
      if (*(char *)(a1 + 231) >= 0) {
        LOBYTE(v20) = a1 - 48;
      }
      else {
        uint64_t v20 = *(void *)(a1 + 208);
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v22, &v21, "%s", v15, v16, v17, v18, v19, v20);
    }
    return v2[205];
  }
  return result;
}

unint64_t raven::RavenSequentialGNSSMeasurementSelector::ComputeReweightedMeasurementVariance(uint64_t a1, uint64_t a2, double a3)
{
  double v3 = a3 * a3;
  double v4 = *(double *)(a2 + 160);
  double v5 = *(double *)(a2 + 152) * *(double *)(a2 + 152);
  double v6 = v5 / v3 - v4;
  if (v6 <= 0.0)
  {
    if (!*(unsigned char *)(a2 + 184))
    {
      __int16 v19 = 12;
      unsigned __int8 v18 = 4;
      char v10 = cnprint::CNLogFormatter::FormatGeneral(a1 + 208, a1 + 96, "#MSR computed variance,%.3lf,is not positive,dz2,%.3lf,var_pred,%.3lf,TargetSigmaCountSqr,%.3lf", v5 / v3 - v4, v5, v4, v3);
      if (*(char *)(a1 + 231) >= 0) {
        LOBYTE(v16) = v10;
      }
      else {
        uint64_t v16 = *(void *)(a1 + 208);
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v19, &v18, "%s", v11, v12, v13, v14, v15, v16);
    }
    uint64_t v8 = 0;
    unint64_t v7 = 0;
  }
  else
  {
    unint64_t v7 = *(void *)&v6 & 0xFFFFFFFFFFFFFF00;
    uint64_t v8 = COERCE_UNSIGNED_INT64(v5 / v3 - v4);
  }
  return v7 | v8;
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::Configure(uint64_t a1, uint64_t a2, const std::string *a3)
{
  if (*(unsigned char *)a1)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 2;
    unsigned __int8 v6 = cnprint::CNLogFormatter::FormatWarning((cnprint::CNLogFormatter *)(a1 + 208), "#MSR configured called more than once");
    if (*(char *)(a1 + 231) >= 0) {
      LOBYTE(v12) = v6;
    }
    else {
      uint64_t v12 = *(void *)(a1 + 208);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v58, &v57, "%s", v7, v8, v9, v10, v11, v12);
    *(unsigned char *)a1 = 0;
  }
  if (!a2)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    unsigned __int8 v19 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR not configured; called with null pointer",
                             v56);
    goto LABEL_32;
  }
  if (!*(unsigned char *)(a2 + 33))
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    unsigned __int8 v19 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR not configured; called with uninitialized parameters",
                             v56);
    goto LABEL_32;
  }
  double v13 = *(double *)(a2 + 1640);
  if (v13 <= 0.0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    unsigned __int8 v19 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR not configured; invalid target sigma count for re-weighted measurements",
                             v56);
    goto LABEL_32;
  }
  if ((raven::RavenSequentialGNSSMeasurementSelector::CheckGnssInnovationThresholds(a1, (double *)(a2 + 1656), *(double *)(a2 + 1640)) & 1) == 0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    uint64_t v25 = (const void **)(a1 + 208);
LABEL_29:
    unsigned __int8 v19 = cnprint::CNLogFormatter::FormatGeneral(v25, "#MSR not configured; invalid pseudorange thresholds,line,%d");
    goto LABEL_32;
  }
  if ((raven::RavenSequentialGNSSMeasurementSelector::CheckGnssInnovationThresholds(a1, (double *)(a2 + 1688), v13) & 1) == 0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    uint64_t v26 = (const void **)(a1 + 208);
LABEL_31:
    unsigned __int8 v19 = cnprint::CNLogFormatter::FormatGeneral(v26, "#MSR not configured; invalid Doppler thresholds,line,%d");
    goto LABEL_32;
  }
  if ((raven::RavenSequentialGNSSMeasurementSelector::CheckGnssInnovationThresholds(a1, (double *)(a2 + 1720), v13) & 1) == 0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    uint64_t v25 = (const void **)(a1 + 208);
    goto LABEL_29;
  }
  if ((raven::RavenSequentialGNSSMeasurementSelector::CheckGnssInnovationThresholds(a1, (double *)(a2 + 1752), v13) & 1) == 0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    uint64_t v26 = (const void **)(a1 + 208);
    goto LABEL_31;
  }
  if ((raven::RavenSequentialGNSSMeasurementSelector::CheckGnssInnovationThresholds(a1, (double *)(a2 + 1784), v13) & 1) == 0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    uint64_t v25 = (const void **)(a1 + 208);
    goto LABEL_29;
  }
  if ((raven::RavenSequentialGNSSMeasurementSelector::CheckGnssInnovationThresholds(a1, (double *)(a2 + 1816), v13) & 1) == 0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    uint64_t v26 = (const void **)(a1 + 208);
    goto LABEL_31;
  }
  if ((raven::RavenSequentialGNSSMeasurementSelector::CheckGnssInnovationThresholds(a1, (double *)(a2 + 1848), v13) & 1) == 0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    uint64_t v25 = (const void **)(a1 + 208);
    goto LABEL_29;
  }
  if ((raven::RavenSequentialGNSSMeasurementSelector::CheckGnssInnovationThresholds(a1, (double *)(a2 + 1880), v13) & 1) == 0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    uint64_t v26 = (const void **)(a1 + 208);
    goto LABEL_31;
  }
  if ((raven::RavenSequentialGNSSMeasurementSelector::CheckGnssInnovationThresholds(a1, (double *)(a2 + 1912), v13) & 1) == 0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    uint64_t v25 = (const void **)(a1 + 208);
    goto LABEL_29;
  }
  if ((raven::RavenSequentialGNSSMeasurementSelector::CheckGnssInnovationThresholds(a1, (double *)(a2 + 1944), v13) & 1) == 0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    uint64_t v26 = (const void **)(a1 + 208);
    goto LABEL_31;
  }
  if ((raven::RavenSequentialGNSSMeasurementSelector::CheckGnssInnovationThresholds(a1, (double *)(a2 + 1976), v13) & 1) == 0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    uint64_t v25 = (const void **)(a1 + 208);
    goto LABEL_29;
  }
  if ((raven::RavenSequentialGNSSMeasurementSelector::CheckGnssInnovationThresholds(a1, (double *)(a2 + 2008), v13) & 1) == 0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    uint64_t v26 = (const void **)(a1 + 208);
    goto LABEL_31;
  }
  if ((raven::RavenSequentialGNSSMeasurementSelector::CheckGnssInnovationThresholds(a1, (double *)(a2 + 2040), v13) & 1) == 0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    uint64_t v25 = (const void **)(a1 + 208);
    goto LABEL_29;
  }
  if ((raven::RavenSequentialGNSSMeasurementSelector::CheckGnssInnovationThresholds(a1, (double *)(a2 + 2072), v13) & 1) == 0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    uint64_t v26 = (const void **)(a1 + 208);
    goto LABEL_31;
  }
  if (*(double *)(a2 + 2112) < 0.0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    unsigned __int8 v19 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR not configured; invalid pseudorange L1 vs L5 difference outlier threshold, %0.3f");
LABEL_32:
    if (*(char *)(a1 + 231) >= 0) {
      LOBYTE(v27) = v19;
    }
    else {
      uint64_t v27 = *(void *)(a1 + 208);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v58, &v57, "%s", v20, v21, v22, v23, v24, v27);
    return 0;
  }
  if (*(double *)(a2 + 2120) < 0.0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    unsigned __int8 v19 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR not configured; invalid doppler L1 vs L5 innovation difference outlier threshold, %0.3f");
    goto LABEL_32;
  }
  double v29 = *(double *)(a2 + 2128);
  if (v29 < 0.0 || v29 > 1.0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    unsigned __int8 v19 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR not configured; invalid L1 vs L5 innovation difference inlier threshold fraction, %0.3f");
    goto LABEL_32;
  }
  if (*(double *)(a2 + 2176) < 1.0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    unsigned __int8 v19 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR not configured; invalid L1 vs L5 choice 'if uncertainty worse by' default factor, %0.3f");
    goto LABEL_32;
  }
  if (*(double *)(a2 + 2184) < 1.0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    unsigned __int8 v19 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR not configured; invalid L1 vs L5 choice 'if uncertainty worse by' periodic motion factor, %0.3f");
    goto LABEL_32;
  }
  double v30 = *(double *)(a2 + 2240);
  if ((*(void *)&v30 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v30 < 0.0 || v30 > 1.0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v58, &v57, "#MSR not configured; invalid minimum P(LOS) value for classifying satellite as having high-P(LOS),%.3lf",
      v14,
      v15,
      v16,
      v17,
      v18,
      *(void *)(*(void *)(a1 + 192) + 2240));
    return 0;
  }
  double v31 = *(double *)(a2 + 2272);
  if ((*(void *)&v31 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v31 <= v30)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v58, &v57, "#MSR not configured; invalid minimum best probability los for reliability,%.3lf",
      v14,
      v15,
      v16,
      v17,
      v18,
      SLOBYTE(v31));
    return 0;
  }
  double v32 = *(double *)(a2 + 2352);
  if ((*(void *)&v32 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v32 <= 0.0 || v32 > 1.0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v58, &v57, "#MSR not configured; invalid Doppler target sigma count scale factor for low-P(LOS) measurements,%.3lf",
      v14,
      v15,
      v16,
      v17,
      v18,
      SLOBYTE(v32));
    return 0;
  }
  for (uint64_t i = 0; i != 32; i += 8)
  {
    double v34 = *(double *)(a2 + 2400 + i);
    if ((*(void *)&v34 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && v34 > 0.0 && v34 <= 1.0) {
      continue;
    }
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v58, &v57, "#MSR not configured; invalid PSR target sigma count scale fact,%.3lf",
      v14,
      v15,
      v16,
      v17,
      v18,
      SLOBYTE(v34));
    return 0;
  }
  double v36 = *(double *)(a2 + 2472);
  if ((*(void *)&v36 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v36 < 0.0 || v36 > 90.0)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v58, &v57, "#MSR not configured; invalid minimum satellite elevation threshold for using low-P(LOS) measurement,%.3lf deg",
      v14,
      v15,
      v16,
      v17,
      v18,
      SLOBYTE(v36));
    return 0;
  }
  uint64_t v37 = 0;
  uint64_t v38 = a2 + 2360;
  do
  {
    double v39 = *(double *)(v38 + 8 * v37);
    if (v39 < 0.0 || v39 >= v30)
    {
      __int16 v58 = 12;
      unsigned __int8 v57 = 4;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v58, &v57, "#MSR not configured; invalid lower bound of %dth low-P(LOS) bin,%.1lf",
        v14,
        v15,
        v16,
        v17,
        v18,
        v37);
      return 0;
    }
    if (v37 && *(double *)(v38 + 8 * (v37 - 1)) <= v39)
    {
      __int16 v58 = 12;
      unsigned __int8 v57 = 4;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v58, &v57, "#MSR not configured; non-descending order of lower bounds of low-P(LOS) bins between %dth and %dth bin,(%.1lf < %.1lf)",
        v14,
        v15,
        v16,
        v17,
        v18,
        v37 - 1);
      return 0;
    }
    ++v37;
  }
  while (v37 != 4);
  raven::GNSSMeasurementSelectionParameters::GetExpectedConstellations((unsigned char *)(a2 + 592), (unint64_t *)(a1 + 48));
  double v42 = *(double *)(a2 + 928);
  BOOL v43 = (*(void *)&v42 & 0x7FFFFFFFFFFFFFFFuLL) - 1 < 0xFFFFFFFFFFFFFLL;
  BOOL v44 = v42 < 0.0 && ((*(void *)&v42 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 < 0x3FF;
  if (v42 >= 0.0) {
    BOOL v43 = 0;
  }
  int v45 = (*(void *)&v42 & 0x7FFFFFFFFFFFFFFFLL) == 0x7FF0000000000000 || v43;
  if ((*(void *)&v42 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FF0000000000000) {
    int v45 = 1;
  }
  int v46 = v45 | v44;
  if (v42 > 1.0) {
    int v47 = 1;
  }
  else {
    int v47 = v46;
  }
  if (v47 == 1)
  {
    __int16 v58 = 12;
    unsigned __int8 v57 = 4;
    unsigned __int8 v48 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 208), "#MSR not configured; invalid nonstationary false positive probability,%.3lf",
                             v42);
    if (*(char *)(a1 + 231) >= 0) {
      LOBYTE(v54) = v48;
    }
    else {
      uint64_t v54 = *(void *)(a1 + 208);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v58, &v57, "%s", v49, v50, v51, v52, v53, v54);
  }
  else
  {
    double v55 = cnstatistics::InverseNormal(v41, 1.0 - v42, 0.0, 1.0);
    *(double *)(a1 + 200) = v55 * v55;
    *(void *)(a1 + 192) = a2;
    std::string::operator=((std::string *)(a1 + 232), a3);
    *(unsigned char *)a1 = 1;
  }
  return v47 ^ 1u;
}

void raven::RavenSequentialGNSSMeasurementSelector::EnableLoggingToFile(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 1640))
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) <= 1)
    {
      __int16 v26 = 12;
      unsigned __int8 v25 = 1;
      unsigned __int8 v3 = cnprint::CNLogFormatter::FormatWarning((cnprint::CNLogFormatter *)(a1 + 208), "#MSR logging file already open; no action taken");
      if (*(char *)(a1 + 231) >= 0) {
        LOBYTE(v9) = v3;
      }
      else {
        uint64_t v9 = *(void *)(a1 + 208);
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v26, &v25, "%s", v4, v5, v6, v7, v8, v9);
    }
  }
  else
  {
    uint64_t v11 = (uint64_t *)(a1 + 1512);
    uint64_t v12 = (cnprint::CNPrinter *)std::ofstream::open();
    uint64_t v13 = *v11;
    uint64_t v14 = (char *)v11 + *(void *)(*v11 - 24);
    if ((v14[32] & 5) != 0)
    {
      if (cnprint::CNPrinter::GetLogLevel(v12) <= 1)
      {
        __int16 v24 = 12;
        unsigned __int8 v23 = 1;
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v15 = (const char *)a2;
        }
        else {
          uint64_t v15 = *(const char **)a2;
        }
        unsigned __int8 v16 = cnprint::CNLogFormatter::FormatWarning((cnprint::CNLogFormatter *)(a1 + 208), "#MSR could not open logging file '%s'", v15);
        if (*(char *)(a1 + 231) >= 0) {
          LOBYTE(v22) = v16;
        }
        else {
          uint64_t v22 = *(void *)(a1 + 208);
        }
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v24, &v23, "%s", v17, v18, v19, v20, v21, v22);
      }
      *(unsigned char *)(a1 + 1506) = 0;
    }
    else
    {
      *((_DWORD *)v14 + 2) = *((_DWORD *)v14 + 2) & 0xFFFFFEFB | 4;
      *(_DWORD *)((char *)v11 + *(void *)(v13 - 24) + 8) |= 0x400u;
      *(unsigned char *)(a1 + 1506) = 1;
    }
  }
}

void raven::RavenSequentialGNSSMeasurementSelector::EnsureFirstPseudorangeAprioriInnovationIsAnInlier(uint64_t a1, uint64_t **a2)
{
  if (*(unsigned char *)(a1 + 32))
  {
    unsigned __int8 v3 = *a2;
    uint64_t v4 = a2[1];
    if (*a2 != v4)
    {
      int v6 = 0;
      uint64_t v7 = 0;
      double v8 = *(double *)(a1 + 24);
      double v9 = *(double *)(a1 + 8);
      double v10 = v8 - v9;
      double v11 = v9 - (v8 - v9);
      double v12 = v8 + v10;
      while (2)
      {
        uint64_t v13 = *v3;
        for (uint64_t i = *(void *)(*v3 + 8); i != v13; uint64_t i = *(void *)(i + 8))
        {
          uint64_t v15 = *(void *)(i + 24);
          if (*(_DWORD *)(v15 + 96) == 1)
          {
            if (*(unsigned char *)(i + 160))
            {
              double v16 = *(double *)(v15 + 120) - *(double *)(i + 48);
              if (v16 >= v11 && v16 <= v12)
              {
                if (v6)
                {
                  sub_18E177EDC(v7, v2, v13, (uint64_t *)i);
                  uint64_t v18 = (cnprint::CNPrinter *)raven::RavenSequentialGNSSMeasurementSelector::LogChangePseudorangeReordering((void *)a1, *(void *)(i + 16), v2[2]);
                  if (cnprint::CNPrinter::GetLogLevel(v18) <= 1)
                  {
                    __int16 v28 = 12;
                    unsigned __int8 v27 = 1;
                    uint64_t v19 = sub_18E017C64(v2[2]);
                    uint64_t v20 = sub_18E017C64(*(void *)(i + 16));
                    cnprint::CNLogFormatter::FormatGeneral(a1 + 208, a1 + 96, "#MSR replacing %s with %s as first pseudorange", v19, v20);
                    if (*(char *)(a1 + 231) >= 0) {
                      LOBYTE(v26) = a1 - 48;
                    }
                    else {
                      uint64_t v26 = *(void *)(a1 + 208);
                    }
                    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v28, &v27, "%s", v21, v22, v23, v24, v25, v26);
                  }
                }
                return;
              }
            }
            if (!v6)
            {
              uint64_t v7 = *v3;
              uint64_t v2 = (uint64_t *)i;
            }
            int v6 = 1;
          }
        }
        if (++v3 != v4) {
          continue;
        }
        break;
      }
    }
  }
}

uint64_t sub_18E177EDC(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  if (a2 != a4)
  {
    uint64_t v4 = (uint64_t *)a4[1];
    if (v4 != a2)
    {
      uint64_t v5 = *a4;
      *(void *)(v5 + 8) = v4;
      *(void *)a4[1] = v5;
      uint64_t v6 = *a2;
      *(void *)(v6 + 8) = a4;
      *a4 = v6;
      *a2 = (uint64_t)a4;
      a4[1] = (uint64_t)a2;
      --*(void *)(a3 + 16);
      ++*(void *)(result + 16);
    }
  }
  return result;
}

void *raven::RavenSequentialGNSSMeasurementSelector::LogChangePseudorangeReordering(void *result, uint64_t a2, uint64_t a3)
{
  if (*((unsigned char *)result + 1) && *((unsigned char *)result + 1506))
  {
    uint64_t v5 = sub_18DEDD538(result + 189, (uint64_t)"NOTE: Pseudorange from SV ", 26);
    uint64_t v6 = sub_18E017C64(a2);
    size_t v7 = strlen(v6);
    double v8 = sub_18DEDD538(v5, (uint64_t)v6, v7);
    double v9 = sub_18DEDD538(v8, (uint64_t)" moved before that of SV ", 25);
    double v10 = sub_18E017C64(a3);
    size_t v11 = strlen(v10);
    double v12 = sub_18DEDD538(v9, (uint64_t)v10, v11);
    return sub_18DEDD538(v12, (uint64_t)"\n\n", 2);
  }
  return result;
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::GetUnprocessedMSRData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  sub_18E068ED0(a3);
  uint64_t v5 = *(uint64_t **)(a2 + 96);
  uint64_t v6 = *(uint64_t **)(a2 + 104);
  while (v5 != v6)
  {
    uint64_t v7 = *v5;
    if (*v5)
    {
      uint64_t v8 = *(void *)(v7 + 328);
      uint64_t v9 = *(void *)(v7 + 336);
      while (v8 != v9)
      {
        sub_18E182D4C((uint64_t)a3, 0, 0, *v5, v8);
        uint64_t v10 = *a3;
        uint64_t *v11 = *a3;
        v11[1] = (uint64_t)a3;
        *(void *)(v10 + 8) = v11;
        *a3 = (uint64_t)v11;
        ++a3[2];
        v8 += 208;
      }
    }
    v5 += 2;
  }
  return 1;
}

void raven::RavenSequentialGNSSMeasurementSelector::GetFinalGnssObservable(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v4 = *(_DWORD *)(a2 + 176);
  if ((v4 - 1) >= 3)
  {
    if (!v4)
    {
      uint64_t v7 = *(long long **)(a2 + 8);
      long long v8 = v7[11];
      *(_OWORD *)(a3 + 160) = v7[10];
      *(_OWORD *)(a3 + 176) = v8;
      *(_OWORD *)(a3 + 192) = v7[12];
      long long v9 = v7[7];
      *(_OWORD *)(a3 + 96) = v7[6];
      *(_OWORD *)(a3 + 112) = v9;
      long long v10 = v7[9];
      *(_OWORD *)(a3 + 128) = v7[8];
      *(_OWORD *)(a3 + 144) = v10;
      long long v11 = v7[3];
      *(_OWORD *)(a3 + 32) = v7[2];
      *(_OWORD *)(a3 + 48) = v11;
      long long v12 = v7[5];
      *(_OWORD *)(a3 + 64) = v7[4];
      *(_OWORD *)(a3 + 80) = v12;
      long long v14 = *v7;
      long long v13 = v7[1];
      char v5 = 1;
      *(_OWORD *)a3 = v14;
      *(_OWORD *)(a3 + 16) = v13;
      goto LABEL_7;
    }
    if (*(unsigned char *)(a2 + 200))
    {
      uint64_t v15 = *(void *)(a2 + 8);
      long long v16 = *(_OWORD *)(v15 + 144);
      *(_OWORD *)(a3 + 128) = *(_OWORD *)(v15 + 128);
      *(_OWORD *)(a3 + 144) = v16;
      *(void *)(a3 + 160) = *(void *)(v15 + 160);
      long long v17 = *(_OWORD *)(v15 + 80);
      *(_OWORD *)(a3 + 64) = *(_OWORD *)(v15 + 64);
      *(_OWORD *)(a3 + 80) = v17;
      long long v18 = *(_OWORD *)(v15 + 112);
      *(_OWORD *)(a3 + 96) = *(_OWORD *)(v15 + 96);
      *(_OWORD *)(a3 + 112) = v18;
      long long v19 = *(_OWORD *)(v15 + 16);
      *(_OWORD *)a3 = *(_OWORD *)v15;
      *(_OWORD *)(a3 + 16) = v19;
      long long v20 = *(_OWORD *)(v15 + 48);
      *(_OWORD *)(a3 + 32) = *(_OWORD *)(v15 + 32);
      *(_OWORD *)(a3 + 48) = v20;
      *(_OWORD *)(a3 + 172) = *(_OWORD *)(v15 + 172);
      *(_OWORD *)(a3 + 188) = *(_OWORD *)(v15 + 188);
      *(_DWORD *)(a3 + 204) = *(_DWORD *)(v15 + 204);
      *(float *)&long long v20 = sqrt(*(double *)(a2 + 192));
      *(_DWORD *)(a3 + 168) = v20;
      char v5 = 1;
      goto LABEL_7;
    }
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) <= 1)
    {
      __int16 v32 = 12;
      unsigned __int8 v31 = 1;
      uint64_t v22 = sub_18E017C64(*(void *)a2);
      unsigned int v23 = *(_DWORD *)(*(void *)(a2 + 8) + 96) - 1;
      if (v23 > 4) {
        uint64_t v24 = "UnknownType";
      }
      else {
        uint64_t v24 = off_1E55B9E30[v23];
      }
      cnprint::CNLogFormatter::FormatGeneral(a1 + 208, a1 + 96, "#MSR %s %s no recommended variance", v22, v24);
      if (*(char *)(a1 + 231) >= 0) {
        LOBYTE(v30) = a1 - 48;
      }
      else {
        uint64_t v30 = *(void *)(a1 + 208);
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v32, &v31, "%s", v25, v26, v27, v28, v29, v30);
    }
  }
  char v5 = 0;
  *(unsigned char *)a3 = 0;
LABEL_7:
  *(unsigned char *)(a3 + 208) = v5;
}

uint64_t *raven::RavenSequentialGNSSMeasurementSelector::GetITRCount(uint64_t a1, void *a2, int *a3, int *a4)
{
  double result = sub_18E182DE0(a2, a3);
  if (result)
  {
    double result = sub_18E182DE0(result + 3, a4);
    if (result) {
      return (uint64_t *)*((unsigned int *)result + 5);
    }
  }
  return result;
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::DetermineAndSetInnovationTestResult(uint64_t a1, uint64_t a2, double a3, double a4)
{
  double v11 = a4;
  double v12 = a3;
  uint64_t result = raven::RavenSequentialGNSSMeasurementSelector::TestInnovation(a1, a2, &v12, &v11);
  if (*(unsigned char *)(a2 + 184))
  {
    if ((result - 1) < 2)
    {
      *(_DWORD *)(a2 + 176) = result;
      return result;
    }
    if ((result - 4) >= 2)
    {
      if (result != 3) {
        return result;
      }
      uint64_t v9 = 0x500000002;
      goto LABEL_17;
    }
    int v7 = *(_DWORD *)(*(void *)(a2 + 8) + 96);
    if ((v7 - 2) >= 2)
    {
      if (v7 != 1) {
        goto LABEL_18;
      }
      long long v8 = (double *)(*(void *)(a1 + 192) + 2440);
    }
    else
    {
      long long v8 = (double *)(*(void *)(a1 + 192) + 2432);
    }
    if (fabs(*(double *)(a2 + 152)) > *v8)
    {
      uint64_t v9 = 0x400000002;
LABEL_17:
      *(void *)(a2 + 176) = v9;
      return result;
    }
LABEL_18:
    *(_DWORD *)(a2 + 176) = 4;
    if (result == 5)
    {
      int v10 = 9;
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  *(_DWORD *)(a2 + 176) = result;
  if (result == 3)
  {
    int v10 = 6;
LABEL_21:
    *(_DWORD *)(a2 + 180) = v10;
    return result;
  }
  if (result == 4)
  {
LABEL_20:
    int v10 = 8;
    goto LABEL_21;
  }
  return result;
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::TestInnovation(uint64_t a1, uint64_t a2, double *a3, double *a4)
{
  if (!*(unsigned char *)(a2 + 168))
  {
    __int16 v30 = 12;
    unsigned __int8 v29 = 4;
    double v12 = sub_18E017C64(*(void *)a2);
    unsigned int v13 = *(_DWORD *)(*(void *)(a2 + 8) + 96) - 1;
    if (v13 > 4) {
      long long v14 = "UnknownType";
    }
    else {
      long long v14 = off_1E55B9E30[v13];
    }
    cnprint::CNLogFormatter::FormatGeneral(a1 + 208, a1 + 96, "#MSR %s %s innovation data missing during testing", v12, v14);
    if (*(char *)(a1 + 231) >= 0) {
      LOBYTE(v26) = a1 - 48;
    }
    else {
      uint64_t v26 = *(void *)(a1 + 208);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v30, &v29, "%s", v21, v22, v23, v24, v25, v26);
    return 1;
  }
  if ((*(void *)(a2 + 152) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (double v6 = *(double *)(a2 + 160), (*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    || v6 <= 0.0)
  {
    __int16 v28 = 12;
    unsigned __int8 v27 = 4;
    uint64_t v9 = sub_18E017C64(*(void *)a2);
    unsigned int v10 = *(_DWORD *)(*(void *)(a2 + 8) + 96) - 1;
    if (v10 > 4) {
      double v11 = "UnknownType";
    }
    else {
      double v11 = off_1E55B9E30[v10];
    }
    cnprint::CNLogFormatter::FormatGeneral(a1 + 208, a1 + 96, "#MSR %s %s innovation data invalid during testing", v9, v11);
    if (*(char *)(a1 + 231) >= 0) {
      LOBYTE(v20) = a1 - 48;
    }
    else {
      uint64_t v20 = *(void *)(a1 + 208);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v28, &v27, "%s", v15, v16, v17, v18, v19, v20);
    return 1;
  }
  double v7 = fabs(*(double *)(a2 + 152))
     / sqrt(v6 + (float)(*(float *)(*(void *)(a2 + 8) + 168) * *(float *)(*(void *)(a2 + 8) + 168)));
  if (v7 > fabs(*a3)) {
    return 3;
  }
  if (v7 <= fabs(*a4)) {
    return 5;
  }
  return 4;
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::GetMSRThresholdType(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 144) || !*(unsigned char *)(a2 + 168)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a2 + 8);
  double v5 = *(double *)(a2 + 160) + (float)(*(float *)(v3 + 168) * *(float *)(v3 + 168));
  switch(*(_DWORD *)(v3 + 96))
  {
    case 0:
    case 5:
      LOWORD(v49) = 12;
      LOBYTE(v44) = 4;
      unsigned __int8 v29 = sub_18E017C64(*(void *)a2);
      cnprint::CNLogFormatter::FormatGeneral(a1 + 208, a1 + 96, "#MSR %s unexpected measurement type when selecting thresholds, %d", v29, *(_DWORD *)(*(void *)(a2 + 8) + 96));
      if (*(char *)(a1 + 231) >= 0) {
        LOBYTE(v35) = a1 - 48;
      }
      else {
        uint64_t v35 = *(void *)(a1 + 208);
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v49, (unsigned __int8 *)&v44, "%s", v30, v31, v32, v33, v34, v35);
      return 0;
    case 1:
      if (*(double *)(a2 + 152) / sqrt(v5) >= 0.0) {
        uint64_t result = 1;
      }
      else {
        uint64_t result = 2;
      }
      break;
    case 2:
    case 3:
    case 4:
      int v7 = *(_DWORD *)(a2 + 48);
      int v6 = *(_DWORD *)(a2 + 52);
      uint64_t v41 = 0x100000008;
      double v36 = &unk_1EDD19CC8;
      int v37 = v6;
      int v38 = v7;
      int v39 = v7 * v6;
      int v40 = v6;
      double v42 = &v43;
      sub_18DFE2C64(a2 + 40, (uint64_t)&v36);
      uint64_t v46 = 0x100000008;
      BOOL v44 = &unk_1EDD19CC8;
      long long v45 = xmmword_18E1FD760;
      int v47 = (double *)v48;
      sub_18DFE2B44(a1 + 360, (uint64_t)&v36, (uint64_t)&v44);
      uint64_t v51 = 0x100000008;
      uint64_t v49 = &unk_1EDD19CC8;
      long long v50 = xmmword_18E1FD760;
      uint64_t v52 = &v53;
      v8.f64[0] = 1.0 / v5;
      float64x2_t v9 = sub_18E06E238((uint64_t)&v44, (uint64_t)&v49, v8);
      v9.f64[0] = *(float64_t *)(a2 + 152);
      uint64_t v46 = 0x100000008;
      BOOL v44 = &unk_1EDD19CC8;
      long long v45 = xmmword_18E1FD760;
      int v47 = (double *)v48;
      sub_18E06E238((uint64_t)&v49, (uint64_t)&v44, v9);
      double v10 = v47[3];
      double v11 = v47[4];
      double v12 = v47[5];
      unsigned int v13 = *(double **)(a1 + 288);
      double v14 = v13[3];
      double v15 = v13[4];
      double v16 = v13[5];
      double v17 = v15 * v15 + v14 * v14 + v16 * v16;
      LODWORD(v13) = *(_DWORD *)(a1 + 380);
      uint64_t v18 = *(void *)(a1 + 392);
      double v19 = *(double *)(v18 + 8 * (3 * (int)v13 + 3));
      int v20 = 4 * v13;
      double v21 = *(double *)(v18 + 8 * ((4 * (int)v13) | 3));
      LODWORD(v13) = 5 * v13;
      double v22 = *(double *)(v18 + 8 * ((int)v13 + 3));
      double v23 = *(double *)(v18 + 8 * (v20 + 4));
      double v24 = *(double *)(v18 + 8 * ((int)v13 + 4));
      double v25 = *(double *)(v18 + 8 * ((int)v13 + 5));
      double v26 = ((v14 + v14) * v15 * v21
           + v14 * v14 * v19
           + (v14 + v14) * v16 * v22
           + v15 * v15 * v23
           + (v15 + v15) * v16 * v24
           + v16 * v16 * v25)
          / v17;
      if (v17 < 0.000000015) {
        double v26 = v19 + v21 * 2.0 + v22 * 2.0 + v23 + v24 * 2.0 + v25;
      }
      BOOL v27 = v17 < v26 * *(double *)(a1 + 200) || v17 < v11 * v11 + v10 * v10 + v12 * v12;
      if (v27 || v11 * v15 + v14 * v10 + v16 * v12 >= 0.0) {
        uint64_t result = 1;
      }
      else {
        uint64_t result = 2;
      }
      break;
    default:
      return 0;
  }
  return result;
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::GetUsableLowPLOSMeasurements@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = (uint64_t)a3;
  a3[1] = (uint64_t)a3;
  a3[2] = 0;
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 != a2)
  {
    uint64_t v5 = result;
    double v7 = *(double *)(*(void *)(result + 192) + 2472) * 0.0174532925;
    while (1)
    {
      uint64_t v9 = *(void *)(v3 + 8);
      uint64_t v8 = *(void *)(v3 + 16);
      uint64_t v10 = *(void *)(v5 + 192);
      if (*(unsigned char *)(v8 + 304) && *(double *)(v8 + 296) >= *(double *)(v10 + 2240)) {
        goto LABEL_13;
      }
      if (!*(unsigned char *)(v5 + 88)) {
        break;
      }
      if (*(double *)(v8 + 264) >= v7)
      {
        if ((*(unsigned char *)(v10 + 2394) || *(_DWORD *)(*(void *)(v3 + 24) + 96) != 1)
          && (*(unsigned char *)(v10 + 2393) || (*(_DWORD *)(*(void *)(v3 + 24) + 96) - 2) > 2))
        {
          break;
        }
        *(unsigned char *)(v3 + 200) = 0;
        *(void *)(v3 + 192) = 0x100000002;
      }
LABEL_13:
      uint64_t v3 = v9;
      if (v9 == a2) {
        return result;
      }
    }
    *(unsigned char *)(v3 + 200) = 1;
    *(void *)(v3 + 192) = 0;
    uint64_t result = sub_18E177EDC((uint64_t)a3, a3, a2, (uint64_t *)v3);
    goto LABEL_13;
  }
  return result;
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::LogEpochFooter(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(result + 1))
  {
    uint64_t v3 = result;
    if (*(unsigned char *)(result + 1506))
    {
      raven::RavenSequentialGNSSMeasurementSelector::LogPVT(result, 1, a3);
      if (*(unsigned char *)(*(void *)(v3 + 192) + 3754)) {
        raven::RavenSequentialGNSSMeasurementSelector::LogPLOSBasedUsableMeasurementCount(v3, a2);
      }
      sub_18DEDD538((void *)(v3 + 1512), (uint64_t)"\n", 1);
      return std::ostream::flush();
    }
  }
  return result;
}

void raven::RavenSequentialGNSSMeasurementSelector::LogPVT(uint64_t a1, int a2, uint64_t a3)
{
  sub_18DEDE7B0(&__p, "\n");
  if (*(unsigned char *)(a1 + 1))
  {
    if (*(unsigned char *)(a1 + 1506))
    {
      sub_18DFFDA0C((uint64_t)v133, **(float64_t **)(a1 + 288), *(float64_t *)(*(void *)(a1 + 288) + 8), *(double *)(*(void *)(a1 + 288) + 16));
      if (v133[8])
      {
        int64x2_t v131 = vdupq_n_s64(0x7FF8000000000000uLL);
        uint64_t v132 = 0x7FF8000000000000;
        int64x2_t v129 = v131;
        uint64_t v130 = 0x7FF8000000000000;
        int64x2_t v127 = v131;
        uint64_t v128 = 0x7FF8000000000000;
        if (*(unsigned char *)(a1 + 2304))
        {
          memset(v137, 0, sizeof(v137));
          int v6 = *(float64x2_t **)(a1 + 288);
          double v7 = *(float64x2_t **)(a1 + 2232);
          *(float64x2_t *)double v137 = vsubq_f64(*v6, *v7);
          *(double *)&v137[16] = v6[1].f64[0] - v7[1].f64[0];
          sub_18DEF20E0((uint64_t)v133, (double *)v137, (double *)v131.i64);
        }
        if (*(unsigned char *)(a1 + 2416))
        {
          memset(v137, 0, sizeof(v137));
          uint64_t v8 = *(float64x2_t **)(a1 + 288);
          uint64_t v9 = *(float64x2_t **)(a1 + 2344);
          *(float64x2_t *)double v137 = vsubq_f64(*v8, *v9);
          *(double *)&v137[16] = v8[1].f64[0] - v9[1].f64[0];
          sub_18DEF20E0((uint64_t)v133, (double *)v137, (double *)v129.i64);
        }
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404CB8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB404CB8))
        {
          uint64_t v138 = 0x300000001;
          *(void *)double v137 = &unk_1EDD18258;
          unsigned int v139 = &v140;
          *(_OWORD *)&v137[8] = xmmword_18E1F8560;
          uint64_t v140 = 0x100000000;
          int v141 = 2;
          sub_18DFEC63C((uint64_t)v137, (uint64_t)&unk_1EB404CF8);
          __cxa_atexit((void (*)(void *))sub_18DFE2E9C, &unk_1EB404CF8, &dword_18DEDB000);
          __cxa_guard_release(&qword_1EB404CB8);
        }
        sub_18DFECE30(a1 + 360, (uint64_t)&unk_1EB404CF8, (uint64_t)&unk_1EB404CF8, (uint64_t)v137);
        uint64_t v124 = 0x300000003;
        *(void *)uint64_t v123 = &unk_1EDD18EE8;
        *(_OWORD *)&v123[8] = xmmword_18E1F0010;
        long long v125 = v126;
        sub_18DFFBB34((uint64_t)v133, (uint64_t)v137, (uint64_t)v123);
        float64x2_t v142 = 0uLL;
        double v143 = 0.0;
        uint64_t v10 = *(float64x2_t **)(a1 + 944);
        float64x2_t v142 = *v10;
        double v143 = v10[1].f64[0];
        sub_18DEF20E0((uint64_t)v133, v142.f64, (double *)v127.i64);
        int64x2_t v121 = vdupq_n_s64(0x7FF8000000000000uLL);
        uint64_t v122 = 0x7FF8000000000000;
        int64x2_t v119 = v121;
        uint64_t v120 = 0x7FF8000000000000;
        uint64_t v11 = *(void *)(a1 + 288);
        float64x2_t v142 = *(float64x2_t *)(v11 + 24);
        double v143 = *(double *)(v11 + 40);
        sub_18DEF20E0((uint64_t)v133, v142.f64, (double *)v121.i64);
        if (fabs(*(double *)v121.i64) > 0.0005 || fabs(*(double *)&v121.i64[1]) > 0.0005)
        {
          double v13 = atan2(*(long double *)v121.i64, *(long double *)&v121.i64[1]);
          if (v13 >= 0.0) {
            double v12 = v13;
          }
          else {
            double v12 = v13 + 6.28318531;
          }
          double v116 = v12 * 57.2957795;
        }
        else
        {
          double v12 = NAN;
          double v116 = NAN;
        }
        if (*(unsigned char *)(a1 + 2416))
        {
          uint64_t v14 = *(void *)(a1 + 2344);
          *(_OWORD *)double v137 = *(_OWORD *)(v14 + 24);
          *(void *)&v137[16] = *(void *)(v14 + 40);
          sub_18DEF20E0((uint64_t)v133, (double *)v137, (double *)v123);
          if ((*(void *)&v12 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
            && (fabs(*(double *)v121.i64) > 0.0005 || fabs(*(double *)&v121.i64[1]) > 0.0005))
          {
            double v15 = (v12 - atan2(*(long double *)v123, *(long double *)&v123[8])) * 57.2957795;
            if (fabs(v15) > 180.0) {
              fmod(v15 + dbl_18E1FCBD0[v15 >= 0.0], 360.0);
            }
          }
        }
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404CC0, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB404CC0))
        {
          uint64_t v138 = 0x300000001;
          *(void *)double v137 = &unk_1EDD18258;
          unsigned int v139 = &v140;
          *(_OWORD *)&v137[8] = xmmword_18E1F8560;
          uint64_t v140 = 0x400000003;
          int v141 = 5;
          sub_18DFEC63C((uint64_t)v137, (uint64_t)&unk_1EB404D30);
          __cxa_atexit((void (*)(void *))sub_18DFE2E9C, &unk_1EB404D30, &dword_18DEDB000);
          __cxa_guard_release(&qword_1EB404CC0);
        }
        sub_18DFECE30(a1 + 360, (uint64_t)&unk_1EB404D30, (uint64_t)&unk_1EB404D30, (uint64_t)v137);
        uint64_t v124 = 0x300000003;
        *(void *)uint64_t v123 = &unk_1EDD18EE8;
        *(_OWORD *)&v123[8] = xmmword_18E1F0010;
        long long v125 = v126;
        sub_18DFFBB34((uint64_t)v133, (uint64_t)v137, (uint64_t)v123);
        uint64_t v16 = *(void *)(a1 + 944);
        long long v117 = *(_OWORD *)(v16 + 24);
        uint64_t v118 = *(void *)(v16 + 40);
        sub_18DEF20E0((uint64_t)v133, (double *)&v117, (double *)v119.i64);
        double v17 = (uint64_t *)(a1 + 1512);
        uint64_t v18 = *(void *)(a1 + 1512);
        *(uint64_t *)((char *)v17 + *(void *)(v18 - 24) + 16) = 3;
        *(uint64_t *)((char *)v17 + *(void *)(v18 - 24) + 24) = 11;
        double v19 = sub_18DEDD538((void *)(a1 + 1512), (uint64_t)"PVT ENU", 7);
        *(void *)((char *)v19 + *(void *)(*v19 - 24) + 24) = 2;
        if (a2) {
          int v20 = "+";
        }
        else {
          int v20 = "-";
        }
        double v21 = sub_18DEDD538(v19, (uint64_t)v20, 1);
        *(void *)((char *)v21 + *(void *)(*v21 - 24) + 24) = 14;
        double v22 = sub_18DEDD538(v21, (uint64_t)"[m or m/s] : ", 13);
        *(void *)((char *)v22 + *(void *)(*v22 - 24) + 24) = 13;
        double v23 = (void *)std::ostream::operator<<();
        *(void *)((char *)v23 + *(void *)(*v23 - 24) + 24) = 13;
        double v24 = (void *)std::ostream::operator<<();
        *(void *)((char *)v24 + *(void *)(*v24 - 24) + 24) = 13;
        double v25 = (void *)std::ostream::operator<<();
        *(void *)((char *)v25 + *(void *)(*v25 - 24) + 24) = 13;
        double v26 = (void *)std::ostream::operator<<();
        *(void *)((char *)v26 + *(void *)(*v26 - 24) + 24) = 13;
        BOOL v27 = (void *)std::ostream::operator<<();
        *(void *)((char *)v27 + *(void *)(*v27 - 24) + 24) = 13;
        __int16 v28 = (void *)std::ostream::operator<<();
        *(void *)((char *)v28 + *(void *)(*v28 - 24) + 24) = 13;
        unsigned __int8 v29 = (void *)std::ostream::operator<<();
        *(void *)((char *)v29 + *(void *)(*v29 - 24) + 24) = 13;
        uint64_t v30 = (void *)std::ostream::operator<<();
        *(void *)((char *)v30 + *(void *)(*v30 - 24) + 24) = 13;
        uint64_t v31 = (uint64_t *)std::ostream::operator<<();
        uint64_t v32 = *v31;
        *(uint64_t *)((char *)v31 + *(void *)(*v31 - 24) + 16) = 2;
        *(uint64_t *)((char *)v31 + *(void *)(v32 - 24) + 24) = 13;
        uint64_t v33 = (void *)std::ostream::operator<<();
        if ((v136 & 0x80u) == 0) {
          p_p = &__p;
        }
        else {
          p_p = __p;
        }
        if ((v136 & 0x80u) == 0) {
          uint64_t v35 = v136;
        }
        else {
          uint64_t v35 = v135;
        }
        sub_18DEDD538(v33, (uint64_t)p_p, v35);
        uint64_t v36 = *v17;
        *(uint64_t *)((char *)v17 + *(void *)(*v17 - 24) + 16) = 3;
        *(uint64_t *)((char *)v17 + *(void *)(v36 - 24) + 24) = 11;
        int v37 = sub_18DEDD538((void *)(a1 + 1512), (uint64_t)"PVT ENU Unc", 11);
        *(void *)((char *)v37 + *(void *)(*v37 - 24) + 24) = 2;
        int v38 = sub_18DEDD538(v37, (uint64_t)v20, 1);
        *(void *)((char *)v38 + *(void *)(*v38 - 24) + 24) = 14;
        int v39 = sub_18DEDD538(v38, (uint64_t)"[m or m/s] : ", 13);
        *(void *)((char *)v39 + *(void *)(*v39 - 24) + 24) = 13;
        int v40 = (void *)std::ostream::operator<<();
        *(void *)((char *)v40 + *(void *)(*v40 - 24) + 24) = 13;
        uint64_t v41 = (void *)std::ostream::operator<<();
        *(void *)((char *)v41 + *(void *)(*v41 - 24) + 24) = 13;
        double v42 = (void *)std::ostream::operator<<();
        *(void *)((char *)v42 + *(void *)(*v42 - 24) + 24) = 13;
        uint64_t v43 = (void *)std::ostream::operator<<();
        *(void *)((char *)v43 + *(void *)(*v43 - 24) + 24) = 13;
        BOOL v44 = (void *)std::ostream::operator<<();
        *(void *)((char *)v44 + *(void *)(*v44 - 24) + 24) = 13;
        long long v45 = (void *)std::ostream::operator<<();
        *(void *)((char *)v45 + *(void *)(*v45 - 24) + 24) = 13;
        uint64_t v46 = (void *)std::ostream::operator<<();
        *(void *)((char *)v46 + *(void *)(*v46 - 24) + 24) = 13;
        int v47 = (void *)std::ostream::operator<<();
        if ((v136 & 0x80u) == 0) {
          unsigned __int8 v48 = &__p;
        }
        else {
          unsigned __int8 v48 = __p;
        }
        if ((v136 & 0x80u) == 0) {
          uint64_t v49 = v136;
        }
        else {
          uint64_t v49 = v135;
        }
        sub_18DEDD538(v47, (uint64_t)v48, v49);
        if (a2)
        {
          uint64_t v50 = *v17;
          *(uint64_t *)((char *)v17 + *(void *)(*v17 - 24) + 16) = 3;
          *(uint64_t *)((char *)v17 + *(void *)(v50 - 24) + 24) = 11;
          uint64_t v51 = sub_18DEDD538((void *)(a1 + 1512), (uint64_t)"Cum dx ENU", 10);
          *(void *)((char *)v51 + *(void *)(*v51 - 24) + 24) = 2;
          uint64_t v52 = sub_18DEDD538(v51, (uint64_t)"+", 1);
          *(void *)((char *)v52 + *(void *)(*v52 - 24) + 24) = 14;
          uint64_t v53 = sub_18DEDD538(v52, (uint64_t)"[m or m/s] : ", 13);
          *(void *)((char *)v53 + *(void *)(*v53 - 24) + 24) = 13;
          uint64_t v54 = (void *)std::ostream::operator<<();
          *(void *)((char *)v54 + *(void *)(*v54 - 24) + 24) = 13;
          double v55 = (void *)std::ostream::operator<<();
          *(void *)((char *)v55 + *(void *)(*v55 - 24) + 24) = 13;
          uint64_t v56 = (void *)std::ostream::operator<<();
          *(void *)((char *)v56 + *(void *)(*v56 - 24) + 24) = 13;
          unsigned __int8 v57 = (void *)std::ostream::operator<<();
          *(void *)((char *)v57 + *(void *)(*v57 - 24) + 24) = 13;
          __int16 v58 = (void *)std::ostream::operator<<();
          *(void *)((char *)v58 + *(void *)(*v58 - 24) + 24) = 13;
          double v59 = (void *)std::ostream::operator<<();
          *(void *)((char *)v59 + *(void *)(*v59 - 24) + 24) = 13;
          int v60 = (void *)std::ostream::operator<<();
          *(void *)((char *)v60 + *(void *)(*v60 - 24) + 24) = 13;
          char v61 = (void *)std::ostream::operator<<();
          if ((v136 & 0x80u) == 0) {
            uint64_t v62 = &__p;
          }
          else {
            uint64_t v62 = __p;
          }
          if ((v136 & 0x80u) == 0) {
            uint64_t v63 = v136;
          }
          else {
            uint64_t v63 = v135;
          }
          sub_18DEDD538(v61, (uint64_t)v62, v63);
        }
        uint64_t v64 = *v17;
        *(uint64_t *)((char *)v17 + *(void *)(*v17 - 24) + 16) = 3;
        *(uint64_t *)((char *)v17 + *(void *)(v64 - 24) + 24) = 11;
        uint64_t v65 = sub_18DEDD538((void *)(a1 + 1512), (uint64_t)"dPVT ENU", 8);
        *(void *)((char *)v65 + *(void *)(*v65 - 24) + 24) = 2;
        uint64_t v66 = sub_18DEDD538(v65, (uint64_t)v20, 1);
        *(void *)((char *)v66 + *(void *)(*v66 - 24) + 24) = 14;
        uint64_t v67 = sub_18DEDD538(v66, (uint64_t)"[m or m/s] : ", 13);
        *(void *)((char *)v67 + *(void *)(*v67 - 24) + 24) = 13;
        int8x16_t v68 = (void *)std::ostream::operator<<();
        *(void *)((char *)v68 + *(void *)(*v68 - 24) + 24) = 13;
        uint64_t v69 = (void *)std::ostream::operator<<();
        *(void *)((char *)v69 + *(void *)(*v69 - 24) + 24) = 13;
        unsigned int v70 = (void *)std::ostream::operator<<();
        *(void *)((char *)v70 + *(void *)(*v70 - 24) + 24) = 13;
        unsigned int v71 = (void *)std::ostream::operator<<();
        *(void *)((char *)v71 + *(void *)(*v71 - 24) + 24) = 13;
        int v72 = (void *)std::ostream::operator<<();
        *(void *)((char *)v72 + *(void *)(*v72 - 24) + 24) = 13;
        int v73 = (void *)std::ostream::operator<<();
        *(void *)((char *)v73 + *(void *)(*v73 - 24) + 24) = 13;
        uint64_t v74 = (void *)std::ostream::operator<<();
        *(void *)((char *)v74 + *(void *)(*v74 - 24) + 24) = 13;
        int8x16_t v75 = (void *)std::ostream::operator<<();
        *(void *)((char *)v75 + *(void *)(*v75 - 24) + 24) = 13;
        double v76 = (uint64_t *)std::ostream::operator<<();
        uint64_t v77 = *v76;
        *(uint64_t *)((char *)v76 + *(void *)(*v76 - 24) + 16) = 2;
        *(uint64_t *)((char *)v76 + *(void *)(v77 - 24) + 24) = 13;
        uint64_t v78 = (void *)std::ostream::operator<<();
        if ((v136 & 0x80u) == 0) {
          uint64_t v79 = &__p;
        }
        else {
          uint64_t v79 = __p;
        }
        if ((v136 & 0x80u) == 0) {
          uint64_t v80 = v136;
        }
        else {
          uint64_t v80 = v135;
        }
        sub_18DEDD538(v78, (uint64_t)v79, v80);
        if (a3)
        {
          uint64_t v83 = *(double **)(a1 + 288);
          double v84 = *v83;
          double v85 = v83[1];
          double v86 = v83[2];
          uint64_t v87 = CNTimeSpan::operator-(a1 + 96, (void *)a3, v81, v82);
          double v89 = v88 + (double)v87;
          double v90 = *(double *)(a3 + 56);
          double v91 = *(double *)(a3 + 64);
          double v92 = v85 - (v91 + *(double *)(a3 + 128) * v89);
          v142.f64[0] = v84 - (v90 + *(double *)(a3 + 120) * v89);
          v142.f64[1] = v92;
          double v93 = *(double *)(a3 + 72);
          double v143 = v86 - (v93 + *(double *)(a3 + 136) * v89);
          *(int64x2_t *)uint64_t v123 = vdupq_n_s64(0x7FF8000000000000uLL);
          *(void *)&v123[16] = 0x7FF8000000000000;
          sub_18DFFDA0C((uint64_t)v137, v90, v91, v93);
          if (v137[8]) {
            sub_18DEF20E0((uint64_t)v137, v142.f64, (double *)v123);
          }
          uint64_t v94 = *(void *)(a1 + 288);
          double v95 = *(double *)(v94 + 40);
          float64x2_t v142 = vsubq_f64(*(float64x2_t *)(v94 + 24), *(float64x2_t *)(a3 + 120));
          double v143 = v95 - *(double *)(a3 + 136);
          *(int64x2_t *)uint64_t v123 = vdupq_n_s64(0x7FF8000000000000uLL);
          *(void *)&v123[16] = 0x7FF8000000000000;
          sub_18DFFDA0C((uint64_t)v137, *(float64_t *)(a3 + 56), *(float64_t *)(a3 + 64), *(double *)(a3 + 72));
          if (v137[8]) {
            sub_18DEF20E0((uint64_t)v137, v142.f64, (double *)v123);
          }
          double v96 = *(double *)(a3 + 40);
          if (vabdd_f64(v116, v96) > 180.0) {
            fmod(v116 - v96 + dbl_18E1FCBD0[v116 - v96 >= 0.0], 360.0);
          }
          uint64_t v97 = *(void *)(a1 + 1512);
          *(uint64_t *)((char *)v17 + *(void *)(v97 - 24) + 16) = 3;
          *(uint64_t *)((char *)v17 + *(void *)(v97 - 24) + 24) = 11;
          uint64_t v98 = sub_18DEDD538((void *)(a1 + 1512), (uint64_t)"PVT ENU Err", 11);
          *(void *)((char *)v98 + *(void *)(*v98 - 24) + 24) = 2;
          uint64_t v99 = sub_18DEDD538(v98, (uint64_t)v20, 1);
          *(void *)((char *)v99 + *(void *)(*v99 - 24) + 24) = 14;
          uint64_t v100 = sub_18DEDD538(v99, (uint64_t)"[m or m/s] : ", 13);
          *(void *)((char *)v100 + *(void *)(*v100 - 24) + 24) = 13;
          uint64_t v101 = (void *)std::ostream::operator<<();
          *(void *)((char *)v101 + *(void *)(*v101 - 24) + 24) = 13;
          long long v102 = (void *)std::ostream::operator<<();
          *(void *)((char *)v102 + *(void *)(*v102 - 24) + 24) = 13;
          unsigned int v103 = (void *)std::ostream::operator<<();
          *(void *)((char *)v103 + *(void *)(*v103 - 24) + 24) = 13;
          unsigned int v104 = (void *)std::ostream::operator<<();
          *(void *)((char *)v104 + *(void *)(*v104 - 24) + 24) = 13;
          int v105 = (void *)std::ostream::operator<<();
          *(void *)((char *)v105 + *(void *)(*v105 - 24) + 24) = 13;
          int v106 = (void *)std::ostream::operator<<();
          *(void *)((char *)v106 + *(void *)(*v106 - 24) + 24) = 13;
          long long v107 = (void *)std::ostream::operator<<();
          *(void *)((char *)v107 + *(void *)(*v107 - 24) + 24) = 13;
          unint64_t v108 = (void *)std::ostream::operator<<();
          *(void *)((char *)v108 + *(void *)(*v108 - 24) + 24) = 13;
          int8x16_t v109 = (uint64_t *)std::ostream::operator<<();
          uint64_t v110 = *v109;
          *(uint64_t *)((char *)v109 + *(void *)(*v109 - 24) + 16) = 2;
          *(uint64_t *)((char *)v109 + *(void *)(v110 - 24) + 24) = 13;
          uint64_t v111 = (void *)std::ostream::operator<<();
          if ((v136 & 0x80u) == 0) {
            uint64_t v112 = &__p;
          }
          else {
            uint64_t v112 = __p;
          }
          if ((v136 & 0x80u) == 0) {
            uint64_t v113 = v136;
          }
          else {
            uint64_t v113 = v135;
          }
          sub_18DEDD538(v111, (uint64_t)v112, v113);
        }
        if ((v136 & 0x80u) == 0) {
          uint64_t v114 = &__p;
        }
        else {
          uint64_t v114 = __p;
        }
        if ((v136 & 0x80u) == 0) {
          uint64_t v115 = v136;
        }
        else {
          uint64_t v115 = v135;
        }
        sub_18DEDD538((void *)(a1 + 1512), (uint64_t)v114, v115);
      }
    }
  }
  if ((char)v136 < 0) {
    operator delete(__p);
  }
}

void sub_18E179FFC(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x22F]) < 0) {
    operator delete((void *)STACK[0x218]);
  }
  _Unwind_Resume(a1);
}

void *raven::RavenSequentialGNSSMeasurementSelector::LogPLOSBasedUsableMeasurementCount(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2 != a2)
  {
    int v3 = 0;
    int v4 = 0;
    int v5 = 0;
    int v6 = 0;
    int v7 = 0;
    int v8 = 0;
    int v9 = 0;
    int v10 = 0;
    int v11 = 0;
    int v12 = 0;
    int v13 = 0;
    int v14 = 0;
    int v15 = 0;
    int v16 = 0;
    int v17 = 0;
    int v18 = 0;
    do
    {
      uint64_t v19 = *(void *)(v2 + 24);
      unsigned int v20 = (*(unsigned __int8 *)(v19 + 100) > 9uLL) | (0x144u >> *(unsigned char *)(v19 + 100));
      int v21 = *(_DWORD *)(v2 + 192);
      if ((v21 - 4) >= 2)
      {
        if (v21 == 3)
        {
          int v23 = *(_DWORD *)(v19 + 96);
          if (*(unsigned char *)(v2 + 200))
          {
            if (v23 == 1)
            {
              if (v20) {
                ++v12;
              }
              else {
                ++v11;
              }
            }
            else if (v20)
            {
              ++v10;
            }
            else
            {
              ++v9;
            }
          }
          else if (v23 == 1)
          {
            if (v20) {
              ++v8;
            }
            else {
              ++v7;
            }
          }
          else if (v20)
          {
            ++v6;
          }
          else
          {
            ++v5;
          }
        }
      }
      else
      {
        int v22 = *(_DWORD *)(v19 + 96);
        if (*(unsigned char *)(v2 + 200))
        {
          if (v22 == 1)
          {
            if (v20) {
              ++v3;
            }
            else {
              ++v4;
            }
          }
          else if (v20)
          {
            ++v18;
          }
          else
          {
            ++v17;
          }
        }
        else if (v22 == 1)
        {
          if (v20) {
            ++v16;
          }
          else {
            ++v15;
          }
        }
        else if (v20)
        {
          ++v14;
        }
        else
        {
          ++v13;
        }
      }
      uint64_t v2 = *(void *)(v2 + 8);
    }
    while (v2 != a2);
  }
  double v24 = (void *)(a1 + 1512);
  double v25 = sub_18DEDD538((void *)(a1 + 1512), (uint64_t)"Num H/L-P(LOS) Meas accepts: ", 29);
  sub_18DEDD538(v25, (uint64_t)"  L5PSR (", 9);
  double v26 = (void *)std::ostream::operator<<();
  sub_18DEDD538(v26, (uint64_t)", ", 2);
  BOOL v27 = (void *)std::ostream::operator<<();
  __int16 v28 = sub_18DEDD538(v27, (uint64_t)")", 1);
  sub_18DEDD538(v28, (uint64_t)"  L1PSR (", 9);
  unsigned __int8 v29 = (void *)std::ostream::operator<<();
  sub_18DEDD538(v29, (uint64_t)", ", 2);
  uint64_t v30 = (void *)std::ostream::operator<<();
  uint64_t v31 = sub_18DEDD538(v30, (uint64_t)")", 1);
  sub_18DEDD538(v31, (uint64_t)"  L5Dop (", 9);
  uint64_t v32 = (void *)std::ostream::operator<<();
  sub_18DEDD538(v32, (uint64_t)", ", 2);
  uint64_t v33 = (void *)std::ostream::operator<<();
  uint64_t v34 = sub_18DEDD538(v33, (uint64_t)")", 1);
  sub_18DEDD538(v34, (uint64_t)"  L1Dop (", 9);
  uint64_t v35 = (void *)std::ostream::operator<<();
  sub_18DEDD538(v35, (uint64_t)", ", 2);
  uint64_t v36 = (void *)std::ostream::operator<<();
  int v37 = sub_18DEDD538(v36, (uint64_t)")", 1);
  sub_18DEDD538(v37, (uint64_t)"\n", 1);
  int v38 = sub_18DEDD538(v24, (uint64_t)"Num H/L-P(LOS) Meas rejects: ", 29);
  sub_18DEDD538(v38, (uint64_t)"  L5PSR (", 9);
  int v39 = (void *)std::ostream::operator<<();
  sub_18DEDD538(v39, (uint64_t)", ", 2);
  int v40 = (void *)std::ostream::operator<<();
  uint64_t v41 = sub_18DEDD538(v40, (uint64_t)")", 1);
  sub_18DEDD538(v41, (uint64_t)"  L1PSR (", 9);
  double v42 = (void *)std::ostream::operator<<();
  sub_18DEDD538(v42, (uint64_t)", ", 2);
  uint64_t v43 = (void *)std::ostream::operator<<();
  BOOL v44 = sub_18DEDD538(v43, (uint64_t)")", 1);
  sub_18DEDD538(v44, (uint64_t)"  L5Dop (", 9);
  long long v45 = (void *)std::ostream::operator<<();
  sub_18DEDD538(v45, (uint64_t)", ", 2);
  uint64_t v46 = (void *)std::ostream::operator<<();
  int v47 = sub_18DEDD538(v46, (uint64_t)")", 1);
  sub_18DEDD538(v47, (uint64_t)"  L1Dop (", 9);
  unsigned __int8 v48 = (void *)std::ostream::operator<<();
  sub_18DEDD538(v48, (uint64_t)", ", 2);
  uint64_t v49 = (void *)std::ostream::operator<<();
  uint64_t v50 = sub_18DEDD538(v49, (uint64_t)")", 1);

  return sub_18DEDD538(v50, (uint64_t)"\n", 1);
}

void raven::RavenSequentialGNSSMeasurementSelector::LogEpochHeader(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 1) && *(unsigned char *)(a1 + 1506))
  {
    sub_18DEDE7B0(&v59, "\n");
    BOOL v5 = 0;
    if (*(unsigned char *)(a1 + 112))
    {
      *(_OWORD *)unsigned __int8 v57 = *(_OWORD *)(a1 + 120);
      if (!cnnavigation::iOSTimeToJulianTime((uint64_t)v57, (uint64_t)v55))
      {
        cnnavigation::JulianTimeToGregorianTime((uint64_t)v55, (uint64_t)&v62);
        if (!v4) {
          BOOL v5 = 1;
        }
      }
    }
    if (*(unsigned char *)(a1 + 160))
    {
      *(_OWORD *)unsigned __int8 v57 = *(_OWORD *)(a1 + 168);
      LOWORD(v62) = 0;
      long long v63 = 0u;
      long long v64 = 0u;
      int v65 = 0;
      uint64_t v66 = 0;
      uint64_t v67 = 0;
      int v68 = 0;
      cnnavigation::TAITime::ToGPSTime((cnnavigation::TAITime *)v57, (const cnnavigation::GNSSUTCParameters *)&v62);
    }
    else if (*(unsigned char *)(a1 + 136))
    {
      *(_OWORD *)unsigned __int8 v57 = *(_OWORD *)(a1 + 144);
      LOWORD(v62) = 0;
      long long v63 = 0u;
      long long v64 = 0u;
      int v65 = 0;
      uint64_t v66 = 0;
      uint64_t v67 = 0;
      int v68 = 0;
      cnnavigation::TAITime::ToGPSTime((cnnavigation::TAITime *)v57, (const cnnavigation::GNSSUTCParameters *)&v62);
    }
    int v6 = (void *)(a1 + 1512);
    int v7 = sub_18DEDD538((void *)(a1 + 1512), (uint64_t)"====================================================================================================\n\n", 102);
    *(void *)((char *)v7 + *(void *)(*v7 - 24) + 16) = 3;
    int v8 = sub_18DEDD538(v7, (uint64_t)"Time: ", 6);
    *(void *)((char *)v8 + *(void *)(*v8 - 24) + 24) = 13;
    int v9 = (void *)std::ostream::operator<<();
    int v10 = sub_18DEDD538(v9, (uint64_t)"   ", 3);
    *(void *)((char *)v10 + *(void *)(*v10 - 24) + 24) = 13;
    std::ostream::operator<<();
    *(void *)(a1 + 1512 + *(void *)(*(void *)(a1 + 1512) - 24) + 24) = 13;
    int v11 = (void *)std::ostream::operator<<();
    int v12 = sub_18DEDD538(v11, (uint64_t)"  ", 2);
    *(void *)((char *)v12 + *(void *)(*v12 - 24) + 24) = 4;
    std::ostream::operator<<();
    sub_18DEDD538((void *)(a1 + 1512), (uint64_t)"   ", 3);
    if (v5)
    {
      sub_18E17AE68((void *)(a1 + 1512), 48);
      *(void *)((char *)v6 + *(void *)(*v6 - 24) + 24) = 4;
      int v13 = (void *)std::ostream::operator<<();
      int v14 = sub_18DEDD538(v13, (uint64_t)"/", 1);
      *(void *)((char *)v14 + *(void *)(*v14 - 24) + 24) = 2;
      int v15 = (void *)std::ostream::operator<<();
      int v16 = sub_18DEDD538(v15, (uint64_t)"/", 1);
      *(void *)((char *)v16 + *(void *)(*v16 - 24) + 24) = 2;
      int v17 = (void *)std::ostream::operator<<();
      int v18 = sub_18DEDD538(v17, (uint64_t)" ", 1);
      *(void *)((char *)v18 + *(void *)(*v18 - 24) + 24) = 2;
      uint64_t v19 = (void *)std::ostream::operator<<();
      unsigned int v20 = sub_18DEDD538(v19, (uint64_t)":", 1);
      *(void *)((char *)v20 + *(void *)(*v20 - 24) + 24) = 2;
      int v21 = (void *)std::ostream::operator<<();
      int v22 = sub_18DEDD538(v21, (uint64_t)":", 1);
      *(void *)((char *)v22 + *(void *)(*v22 - 24) + 24) = 6;
      int v23 = (void *)std::ostream::operator<<();
      sub_18E17AE68(v23, 32);
    }
    else
    {
      *(void *)((char *)v6 + *(void *)(*v6 - 24) + 24) = 13;
      std::ostream::operator<<();
    }
    double v24 = sub_18DEDD538((void *)(a1 + 1512), (uint64_t)"   EstAge: ", 11);
    *(void *)((char *)v24 + *(void *)(*v24 - 24) + 24) = 13;
    if (!*(unsigned char *)(a1 + 2192)) {
      sub_18DFF28FC();
    }
    CNTimeSpan::operator-(a1 + 96, (void *)(a1 + 2096), v25, v26);
    std::ostream::operator<<();
    BOOL v27 = sub_18DEDD538((void *)(a1 + 1512), (uint64_t)"   SE: ", 7);
    sub_18DEDE7B0(&v62, off_1E55B9C98[*(char *)(a1 + 1016)]);
    if (v63 >= 0) {
      __int16 v28 = &v62;
    }
    else {
      __int16 v28 = v62;
    }
    if (v63 >= 0) {
      uint64_t v29 = HIBYTE(v63);
    }
    else {
      uint64_t v29 = v63;
    }
    uint64_t v30 = sub_18DEDD538(v27, (uint64_t)v28, v29);
    uint64_t v31 = sub_18DEDD538(v30, (uint64_t)"   Act: ", 8);
    sub_18DEDE7B0(v57, off_1E55B9CD0[*(char *)(a1 + 1024)]);
    if ((v58 & 0x80u) == 0) {
      uint64_t v32 = v57;
    }
    else {
      uint64_t v32 = (void **)v57[0];
    }
    if ((v58 & 0x80u) == 0) {
      uint64_t v33 = v58;
    }
    else {
      uint64_t v33 = (uint64_t)v57[1];
    }
    uint64_t v34 = sub_18DEDD538(v31, (uint64_t)v32, v33);
    uint64_t v35 = sub_18DEDD538(v34, (uint64_t)" ", 1);
    *(void *)((char *)v35 + *(void *)(*v35 - 24) + 16) = 2;
    sub_18DFF161C((double *)(a1 + 1024));
    uint64_t v36 = (void *)std::ostream::operator<<();
    int v37 = sub_18DEDD538(v36, (uint64_t)"   Mnt: ", 8);
    sub_18DEDE7B0(v55, off_1E55B9D20[*(char *)(a1 + 1112)]);
    if ((v56 & 0x80u) == 0) {
      int v38 = v55;
    }
    else {
      int v38 = (void **)v55[0];
    }
    if ((v56 & 0x80u) == 0) {
      uint64_t v39 = v56;
    }
    else {
      uint64_t v39 = (uint64_t)v55[1];
    }
    int v40 = sub_18DEDD538(v37, (uint64_t)v38, v39);
    uint64_t v41 = sub_18DEDD538(v40, (uint64_t)" ", 1);
    *(void *)((char *)v41 + *(void *)(*v41 - 24) + 16) = 2;
    double v42 = (void *)std::ostream::operator<<();
    uint64_t v43 = sub_18DEDD538(v42, (uint64_t)"   Mov: ", 8);
    sub_18DEDE7B0(__p, off_1E55B9D40[*(char *)(a1 + 1152)]);
    if ((v54 & 0x80u) == 0) {
      BOOL v44 = __p;
    }
    else {
      BOOL v44 = (void **)__p[0];
    }
    if ((v54 & 0x80u) == 0) {
      uint64_t v45 = v54;
    }
    else {
      uint64_t v45 = (uint64_t)__p[1];
    }
    uint64_t v46 = sub_18DEDD538(v43, (uint64_t)v44, v45);
    int v47 = sub_18DEDD538(v46, (uint64_t)" ", 1);
    *(void *)((char *)v47 + *(void *)(*v47 - 24) + 16) = 2;
    std::ostream::operator<<();
    if ((char)v54 < 0) {
      operator delete(__p[0]);
    }
    if ((char)v56 < 0) {
      operator delete(v55[0]);
    }
    if ((char)v58 < 0) {
      operator delete(v57[0]);
    }
    if (SHIBYTE(v63) < 0) {
      operator delete(v62);
    }
    if ((v61 & 0x80u) == 0) {
      unsigned __int8 v48 = &v59;
    }
    else {
      unsigned __int8 v48 = v59;
    }
    if ((v61 & 0x80u) == 0) {
      uint64_t v49 = v61;
    }
    else {
      uint64_t v49 = v60;
    }
    uint64_t v50 = sub_18DEDD538((void *)(a1 + 1512), (uint64_t)v48, v49);
    if ((v61 & 0x80u) == 0) {
      uint64_t v51 = &v59;
    }
    else {
      uint64_t v51 = v59;
    }
    if ((v61 & 0x80u) == 0) {
      uint64_t v52 = v61;
    }
    else {
      uint64_t v52 = v60;
    }
    sub_18DEDD538(v50, (uint64_t)v51, v52);
    raven::RavenSequentialGNSSMeasurementSelector::LogPVT(a1, 0, a2);
    if ((char)v61 < 0) {
      operator delete(v59);
    }
  }
}

void sub_18E17AD64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_18E17AE68(void *a1, char a2)
{
  int v4 = (char *)a1 + *(void *)(*a1 - 24);
  if (*((_DWORD *)v4 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    BOOL v5 = std::locale::use_facet(&v8, MEMORY[0x1E4FBA258]);
    int v6 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 32);
    std::locale::~locale(&v8);
    *((_DWORD *)v4 + 36) = v6;
  }
  *((_DWORD *)v4 + 36) = a2;
  return a1;
}

void sub_18E17AF20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void raven::RavenSequentialGNSSMeasurementSelector::LogMSRData(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 1) || !*(unsigned char *)(a1 + 1506)) {
    return;
  }
  uint64_t v274 = 0x100000008;
  uint64_t v272 = &unk_1EDD19CC8;
  long long v273 = xmmword_18E1FD760;
  char v275 = &v276;
  uint64_t v235 = a1 + 912;
  sub_18DFE2AA8(a1 + 256, a1 + 912, (uint64_t)&v272);
  sub_18DEDE7B0(&v269, "\n");
  double v267 = 0;
  std::string __p = 0;
  double v268 = 0;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= 2)
  {
    if ((v4 & 0x8000000000000000) != 0) {
      sub_18DEE1FC8();
    }
    std::string __p = sub_18DFF2948((uint64_t)&v268, v4 >> 1);
    double v267 = (char *)__p;
    double v268 = (char *)__p + 4 * v5;
  }
  uint64_t v234 = a1;
  memset(v264, 0, sizeof(v264));
  int v265 = 1065353216;
  memset(v262, 0, sizeof(v262));
  int v263 = 1065353216;
  for (uint64_t i = *(void *)(a2 + 8); i != a2; uint64_t i = *(void *)(i + 8))
  {
    int data = *(_DWORD *)(*(void *)(i + 16) + 28) + 1000 * *(unsigned __int8 *)(*(void *)(i + 16) + 24);
    LODWORD(__b.__r_.__value_.__l.__data_) = data;
    std::locale v8 = (char *)__p;
    int v9 = v267;
    int v10 = (char *)__p;
    if (__p != v267)
    {
      int v10 = (char *)__p;
      while (*(_DWORD *)v10 != data)
      {
        v10 += 4;
        if (v10 == v267) {
          goto LABEL_13;
        }
      }
    }
    if (v10 == v267)
    {
LABEL_13:
      if (v267 >= v268)
      {
        uint64_t v12 = (v267 - (unsigned char *)__p) >> 2;
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 62) {
          sub_18DEE1FC8();
        }
        uint64_t v14 = v268 - (unsigned char *)__p;
        if ((v268 - (unsigned char *)__p) >> 1 > v13) {
          unint64_t v13 = v14 >> 1;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v13;
        }
        if (v15)
        {
          int v16 = (char *)sub_18DFF2948((uint64_t)&v268, v15);
          int v9 = v267;
          std::locale v8 = (char *)__p;
        }
        else
        {
          int v16 = 0;
        }
        int v17 = (int *)&v16[4 * v12];
        *int v17 = data;
        int v11 = (char *)(v17 + 1);
        while (v9 != v8)
        {
          int v18 = *((_DWORD *)v9 - 1);
          v9 -= 4;
          *--int v17 = v18;
        }
        std::string __p = v17;
        double v267 = v11;
        double v268 = &v16[4 * v15];
        if (v8) {
          operator delete(v8);
        }
      }
      else
      {
        *(_DWORD *)double v267 = data;
        int v11 = v9 + 4;
      }
      double v267 = v11;
      int data = (int)__b.__r_.__value_.__l.__data_;
    }
    uint64_t v19 = sub_18E182F54((uint64_t)v264, data, &__b);
    unsigned int v20 = (uint64_t *)operator new(0xF0uLL);
    int v21 = v20;
    uint64_t *v20 = 0;
    v20[1] = 0;
    long long v22 = *(_OWORD *)(i + 32);
    *((_OWORD *)v20 + 1) = *(_OWORD *)(i + 16);
    *((_OWORD *)v20 + 2) = v22;
    *((unsigned char *)v20 + 48) = 0;
    *((unsigned char *)v20 + 160) = 0;
    if (*(unsigned char *)(i + 160))
    {
      v20[6] = *(void *)(i + 48);
      sub_18E18251C((uint64_t)(v20 + 7), i + 56);
      *((unsigned char *)v21 + 160) = 1;
    }
    *(_OWORD *)(v21 + 21) = *(_OWORD *)(i + 168);
    long long v23 = *(_OWORD *)(i + 184);
    long long v24 = *(_OWORD *)(i + 200);
    long long v25 = *(_OWORD *)(i + 216);
    v21[29] = *(void *)(i + 232);
    *(_OWORD *)(v21 + 27) = v25;
    *(_OWORD *)(v21 + 25) = v24;
    *(_OWORD *)(v21 + 23) = v23;
    v21[1] = (uint64_t)(v19 + 3);
    uint64_t v26 = v19[3];
    *int v21 = v26;
    *(void *)(v26 + 8) = v21;
    v19[3] = (uint64_t)v21;
    ++v19[5];
    uint64_t v27 = *(void *)(i + 24);
    unint64_t v28 = *(char *)(v27 + 100);
    if (v28 > 0xA) {
      unsigned __int8 v29 = 1;
    }
    else {
      unsigned __int8 v29 = byte_18E21CC38[v28];
    }
    v249.__r_.__value_.__s.__data_[0] = v29;
    float v30 = *(float *)(v27 + 112);
    uint64_t v31 = (uint64_t **)sub_18E1833CC(v262, data, &__b);
    *((_DWORD *)sub_18E183828(v31 + 3, v29, &v249) + 8) = llroundf(v30);
  }
  uint64_t v32 = *(unsigned __int8 **)(v234 + 192);
  int v240 = v32[3754];
  if (v32[3754]) {
    uint64_t v33 = 86;
  }
  else {
    uint64_t v33 = 52;
  }
  unint64_t __len = v33;
  int v34 = v32[641];
  int v222 = v32[2562];
  uint64_t v223 = (char *)operator new(1uLL);
  *uint64_t v223 = 1;
  uint64_t v35 = v223 + 1;
  int v239 = v34;
  if (v34)
  {
    uint64_t v36 = (char *)operator new(2uLL);
    *(_WORD *)uint64_t v36 = 513;
    uint64_t v35 = v36 + 2;
    operator delete(v223);
    uint64_t v223 = v36;
  }
  int v37 = (uint64_t *)(v234 + 1512);
  *(void *)(v234 + 1512 + *(void *)(*(void *)(v234 + 1512) - 24) + 24) = 25;
  sub_18DEDD538((void *)(v234 + 1512), (uint64_t)" ", 1);
  double v233 = (unsigned __int8 *)v35;
  if (v223 != v35)
  {
    size_t v38 = (2 * __len + 5);
    uint64_t v39 = v223;
    do
    {
      sub_18DEDE7B0(&__dst, off_1E55B9D60[*v39]);
      int v40 = std::string::insert(&__dst, 0, " ", 1uLL);
      long long v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
      v249.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v249.__r_.__value_.__l.__data_ = v41;
      v40->__r_.__value_.__l.__size_ = 0;
      v40->__r_.__value_.__r.__words[2] = 0;
      v40->__r_.__value_.__r.__words[0] = 0;
      double v42 = std::string::append(&v249, " Band ", 6uLL);
      long long v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
      v261.__r_.__value_.__r.__words[2] = v42->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v261.__r_.__value_.__l.__data_ = v43;
      v42->__r_.__value_.__l.__size_ = 0;
      v42->__r_.__value_.__r.__words[2] = 0;
      v42->__r_.__value_.__r.__words[0] = 0;
      std::string::size_type size = HIBYTE(v261.__r_.__value_.__r.__words[2]);
      if ((v261.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = v261.__r_.__value_.__l.__size_;
      }
      if (size + 2 >= v38)
      {
        std::string __b = v261;
        memset(&v261, 0, sizeof(v261));
      }
      else
      {
        sub_18DEDD864(&__b, v38, 45);
        if ((__b.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_b = &__b;
        }
        else {
          p_b = (std::string *)__b.__r_.__value_.__r.__words[0];
        }
        p_b->__r_.__value_.__s.__data_[0] = 124;
        std::string::size_type v46 = HIBYTE(__b.__r_.__value_.__r.__words[2]);
        if ((__b.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          int v47 = &__b;
        }
        else {
          int v47 = (std::string *)__b.__r_.__value_.__r.__words[0];
        }
        if ((__b.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v46 = __b.__r_.__value_.__l.__size_;
        }
        v47->__r_.__value_.__s.__data_[v46 - 1] = 124;
        if ((v261.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v48 = HIBYTE(v261.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v48 = v261.__r_.__value_.__l.__size_;
        }
        if ((v261.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v49 = &v261;
        }
        else {
          uint64_t v49 = (std::string *)v261.__r_.__value_.__r.__words[0];
        }
        std::string::replace(&__b, (v38 - v48) >> 1, v48, (const std::string::value_type *)v49, v48);
      }
      if ((__b.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v50 = &__b;
      }
      else {
        uint64_t v50 = (std::string *)__b.__r_.__value_.__r.__words[0];
      }
      if ((__b.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v51 = HIBYTE(__b.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v51 = __b.__r_.__value_.__l.__size_;
      }
      sub_18DEDD538(v37, (uint64_t)v50, v51);
      if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__b.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v261.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v261.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v249.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v249.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      ++v39;
    }
    while (v39 != v35);
  }
  if (v34)
  {
    uint64_t v52 = sub_18DEDD538(v37, (uint64_t)" ", 1);
    sub_18DEDE7B0(&v260, " (L5-L1) ");
    if ((v260.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v53 = HIBYTE(v260.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v53 = v260.__r_.__value_.__l.__size_;
    }
    if (v53 + 2 >= 0x14)
    {
      std::string __b = v260;
      memset(&v260, 0, sizeof(v260));
    }
    else
    {
      *((unsigned char *)&__b.__r_.__value_.__s + 23) = 20;
      strcpy((char *)&__b, "|------------------|");
      if ((v260.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unsigned __int8 v54 = &v260;
      }
      else {
        unsigned __int8 v54 = (std::string *)v260.__r_.__value_.__r.__words[0];
      }
      std::string::replace(&__b, (20 - v53) >> 1, v53, (const std::string::value_type *)v54, v53);
    }
    if ((__b.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      double v55 = &__b;
    }
    else {
      double v55 = (std::string *)__b.__r_.__value_.__r.__words[0];
    }
    if ((__b.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v56 = HIBYTE(__b.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v56 = __b.__r_.__value_.__l.__size_;
    }
    sub_18DEDD538(v52, (uint64_t)v55, v56);
    if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__b.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v260.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v260.__r_.__value_.__l.__data_);
    }
    unsigned __int8 v57 = sub_18DEDD538(v37, (uint64_t)" ", 1);
    sub_18DEDE7B0(&v259, " Use ");
    int v58 = SHIBYTE(v259.__r_.__value_.__r.__words[2]);
    if ((v259.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v59 = HIBYTE(v259.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v59 = v259.__r_.__value_.__l.__size_;
    }
    if (v59 + 2 >= 0x28)
    {
      std::string __b = v259;
      memset(&v259, 0, sizeof(v259));
    }
    else
    {
      uint64_t v60 = (char *)operator new(0x30uLL);
      __b.__r_.__value_.__r.__words[0] = (std::string::size_type)v60;
      *(_OWORD *)&__b.__r_.__value_.__r.__words[1] = xmmword_18E21CBD0;
      *(void *)&long long v61 = 0x2D2D2D2D2D2D2D2DLL;
      *((void *)&v61 + 1) = 0x2D2D2D2D2D2D2D2DLL;
      *(_OWORD *)(v60 + 1) = v61;
      *(_OWORD *)(v60 + 17) = v61;
      strcpy(v60 + 31, "--------|");
      *uint64_t v60 = 124;
      if (v58 >= 0) {
        uint64_t v62 = &v259;
      }
      else {
        uint64_t v62 = (std::string *)v259.__r_.__value_.__r.__words[0];
      }
      std::string::replace(&__b, (40 - v59) >> 1, v59, (const std::string::value_type *)v62, v59);
    }
    if ((__b.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v63 = &__b;
    }
    else {
      long long v63 = (std::string *)__b.__r_.__value_.__r.__words[0];
    }
    if ((__b.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v64 = HIBYTE(__b.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v64 = __b.__r_.__value_.__l.__size_;
    }
    sub_18DEDD538(v57, (uint64_t)v63, v64);
    if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__b.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v259.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v259.__r_.__value_.__l.__data_);
    }
  }
  if ((v271 & 0x80u) == 0) {
    int v65 = &v269;
  }
  else {
    int v65 = v269;
  }
  if ((v271 & 0x80u) == 0) {
    uint64_t v66 = v271;
  }
  else {
    uint64_t v66 = v270;
  }
  sub_18DEDD538(v37, (uint64_t)v65, v66);
  *(uint64_t *)((char *)v37 + *(void *)(*v37 - 24) + 24) = 25;
  sub_18DEDD538(v37, (uint64_t)" ", 1);
  uint64_t v246 = v234 + 1536;
  unint64_t v236 = v233 - (unsigned __int8 *)v223;
  if (v233 != (unsigned __int8 *)v223)
  {
    uint64_t v67 = 0;
    uint64_t v68 = v233 - (unsigned __int8 *)v223;
    if (v236 <= 1) {
      uint64_t v68 = 1;
    }
    uint64_t v241 = v68;
    do
    {
      *(void *)(v246 + *(void *)(*v37 - 24)) = 5;
      sub_18DEDD538(v37, (uint64_t)" ", 1);
      for (uint64_t j = 0; j != 2; ++j)
      {
        memset(&__b, 0, sizeof(__b));
        switch(dword_18E21CBF0[j])
        {
          case 0:
            *((unsigned char *)&__b.__r_.__value_.__s + 23) = 7;
            qmemcpy(&__b, "Unknown", 7);
            break;
          case 1:
            *((unsigned char *)&__b.__r_.__value_.__s + 23) = 11;
            *(_DWORD *)((char *)__b.__r_.__value_.__r.__words + 7) = 1701277281;
            unsigned int v70 = "Pseudorange";
            goto LABEL_132;
          case 2:
            *((unsigned char *)&__b.__r_.__value_.__s + 23) = 11;
            *(_DWORD *)((char *)__b.__r_.__value_.__r.__words + 7) = 1380204847;
            unsigned int v70 = "Doppler/ADR";
LABEL_132:
            __b.__r_.__value_.__r.__words[0] = *(void *)v70;
            break;
          case 3:
            *((unsigned char *)&__b.__r_.__value_.__s + 23) = 5;
            qmemcpy(&__b, "Other", 5);
            break;
          default:
            break;
        }
        *(void *)(v246 + *(void *)(*v37 - 24)) = __len;
        std::operator+<char>();
        unsigned int v71 = std::string::append(&__dst, " ", 1uLL);
        long long v72 = *(_OWORD *)&v71->__r_.__value_.__l.__data_;
        v258.__r_.__value_.__r.__words[2] = v71->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v258.__r_.__value_.__l.__data_ = v72;
        v71->__r_.__value_.__l.__size_ = 0;
        v71->__r_.__value_.__r.__words[2] = 0;
        v71->__r_.__value_.__r.__words[0] = 0;
        std::string::size_type v73 = HIBYTE(v258.__r_.__value_.__r.__words[2]);
        if ((v258.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v73 = v258.__r_.__value_.__l.__size_;
        }
        if (v73 + 2 >= __len)
        {
          std::string v249 = v258;
          memset(&v258, 0, sizeof(v258));
        }
        else
        {
          sub_18DEDD864(&v249, __len, 45);
          if ((v249.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v74 = &v249;
          }
          else {
            uint64_t v74 = (std::string *)v249.__r_.__value_.__r.__words[0];
          }
          v74->__r_.__value_.__s.__data_[0] = 124;
          std::string::size_type v75 = HIBYTE(v249.__r_.__value_.__r.__words[2]);
          if ((v249.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            double v76 = &v249;
          }
          else {
            double v76 = (std::string *)v249.__r_.__value_.__r.__words[0];
          }
          if ((v249.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v75 = v249.__r_.__value_.__l.__size_;
          }
          v76->__r_.__value_.__s.__data_[v75 - 1] = 124;
          if ((v258.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v77 = HIBYTE(v258.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v77 = v258.__r_.__value_.__l.__size_;
          }
          if ((v258.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v78 = &v258;
          }
          else {
            uint64_t v78 = (std::string *)v258.__r_.__value_.__r.__words[0];
          }
          std::string::replace(&v249, (__len - v77) >> 1, v77, (const std::string::value_type *)v78, v77);
        }
        if ((v249.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v79 = &v249;
        }
        else {
          uint64_t v79 = (std::string *)v249.__r_.__value_.__r.__words[0];
        }
        if ((v249.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v80 = HIBYTE(v249.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v80 = v249.__r_.__value_.__l.__size_;
        }
        sub_18DEDD538(v37, (uint64_t)v79, v80);
        if (SHIBYTE(v249.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v249.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v258.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v258.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__b.__r_.__value_.__l.__data_);
        }
      }
      ++v67;
    }
    while (v67 != v241);
  }
  if (v239)
  {
    char v81 = 0;
    size_t v82 = 10;
    do
    {
      char v242 = v81;
      sub_18DEDD538(v37, (uint64_t)" ", 1);
      for (uint64_t k = 0; k != 2; ++k)
      {
        memset(&__b, 0, sizeof(__b));
        switch(dword_18E21CBF0[k])
        {
          case 0:
            *((unsigned char *)&__b.__r_.__value_.__s + 23) = 3;
            LOWORD(__b.__r_.__value_.__l.__data_) = 28245;
            std::string::value_type v84 = 107;
            goto LABEL_175;
          case 1:
            *((unsigned char *)&__b.__r_.__value_.__s + 23) = 2;
            LOWORD(__b.__r_.__value_.__l.__data_) = 21072;
            break;
          case 2:
            *((unsigned char *)&__b.__r_.__value_.__s + 23) = 4;
            LODWORD(__b.__r_.__value_.__l.__data_) = 1380200260;
            break;
          case 3:
            *((unsigned char *)&__b.__r_.__value_.__s + 23) = 3;
            LOWORD(__b.__r_.__value_.__l.__data_) = 29775;
            std::string::value_type v84 = 104;
LABEL_175:
            __b.__r_.__value_.__s.__data_[2] = v84;
            break;
          default:
            break;
        }
        *(void *)(v246 + *(void *)(*v37 - 24)) = v82;
        std::operator+<char>();
        double v85 = std::string::append(&__dst, " ", 1uLL);
        long long v86 = *(_OWORD *)&v85->__r_.__value_.__l.__data_;
        v257.__r_.__value_.__r.__words[2] = v85->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v257.__r_.__value_.__l.__data_ = v86;
        v85->__r_.__value_.__l.__size_ = 0;
        v85->__r_.__value_.__r.__words[2] = 0;
        v85->__r_.__value_.__r.__words[0] = 0;
        std::string::size_type v87 = HIBYTE(v257.__r_.__value_.__r.__words[2]);
        if ((v257.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v87 = v257.__r_.__value_.__l.__size_;
        }
        if (v87 + 2 >= v82)
        {
          std::string v249 = v257;
          memset(&v257, 0, sizeof(v257));
        }
        else
        {
          sub_18DEDD864(&v249, v82, 45);
          if ((v249.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            double v88 = &v249;
          }
          else {
            double v88 = (std::string *)v249.__r_.__value_.__r.__words[0];
          }
          v88->__r_.__value_.__s.__data_[0] = 124;
          std::string::size_type v89 = HIBYTE(v249.__r_.__value_.__r.__words[2]);
          if ((v249.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            double v90 = &v249;
          }
          else {
            double v90 = (std::string *)v249.__r_.__value_.__r.__words[0];
          }
          if ((v249.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v89 = v249.__r_.__value_.__l.__size_;
          }
          v90->__r_.__value_.__s.__data_[v89 - 1] = 124;
          if ((v257.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v91 = HIBYTE(v257.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v91 = v257.__r_.__value_.__l.__size_;
          }
          if ((v257.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            double v92 = &v257;
          }
          else {
            double v92 = (std::string *)v257.__r_.__value_.__r.__words[0];
          }
          std::string::replace(&v249, (v82 - v91) >> 1, v91, (const std::string::value_type *)v92, v91);
        }
        if ((v249.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          double v93 = &v249;
        }
        else {
          double v93 = (std::string *)v249.__r_.__value_.__r.__words[0];
        }
        if ((v249.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v94 = HIBYTE(v249.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v94 = v249.__r_.__value_.__l.__size_;
        }
        sub_18DEDD538(v37, (uint64_t)v93, v94);
        if (SHIBYTE(v249.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v249.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v257.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v257.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__b.__r_.__value_.__l.__data_);
        }
      }
      char v81 = 1;
      size_t v82 = 20;
    }
    while ((v242 & 1) == 0);
  }
  if ((v271 & 0x80u) == 0) {
    double v95 = &v269;
  }
  else {
    double v95 = v269;
  }
  if ((v271 & 0x80u) == 0) {
    uint64_t v96 = v271;
  }
  else {
    uint64_t v96 = v270;
  }
  sub_18DEDD538(v37, (uint64_t)v95, v96);
  uint64_t v97 = v234 + 1536;
  *(uint64_t *)((char *)v37 + *(void *)(*v37 - 24) + 24) = 7;
  uint64_t v98 = sub_18DEDD538(v37, (uint64_t)"SVID", 4);
  *(void *)((char *)v98 + *(void *)(*v98 - 24) + 24) = 4;
  uint64_t v99 = sub_18DEDD538(v98, (uint64_t)"Az", 2);
  *(void *)((char *)v99 + *(void *)(*v99 - 24) + 24) = 3;
  uint64_t v100 = sub_18DEDD538(v99, (uint64_t)"El", 2);
  *(void *)((char *)v100 + *(void *)(*v100 - 24) + 24) = 5;
  uint64_t v101 = sub_18DEDD538(v100, (uint64_t)"LOS", 3);
  *(void *)((char *)v101 + *(void *)(*v101 - 24) + 24) = 6;
  sub_18DEDD538(v101, (uint64_t)"RT", 2);
  if (v223 != (char *)v233)
  {
    uint64_t v102 = 0;
    uint64_t v103 = v233 - (unsigned __int8 *)v223;
    if (v236 <= 1) {
      uint64_t v103 = 1;
    }
    uint64_t v237 = v103;
    do
    {
      uint64_t v243 = v102;
      *(void *)(v97 + *(void *)(*v37 - 24)) = 5;
      sub_18DEDD538(v37, (uint64_t)"CN0", 3);
      for (uint64_t m = 0; m != 2; ++m)
      {
        *(void *)(v246 + *(void *)(*v37 - 24)) = 6;
        sub_18DEDD538(v37, (uint64_t)"err", 3);
        *(void *)(v246 + *(void *)(*v37 - 24)) = 10;
        sub_18DEDD538(v37, (uint64_t)"dz_pre", 6);
        if (v240)
        {
          *(void *)(v246 + *(void *)(*v37 - 24)) = 10;
          int v105 = sub_18DEDD538(v37, (uint64_t)"M_innov", 7);
          *(void *)((char *)v105 + *(void *)(*v105 - 24) + 24) = 9;
          int v106 = sub_18DEDD538(v105, (uint64_t)"P-sigma", 7);
          *(void *)((char *)v106 + *(void *)(*v106 - 24) + 24) = 9;
          sub_18DEDD538(v106, (uint64_t)"M-sigma", 7);
        }
        *(void *)(v246 + *(void *)(*v37 - 24)) = 9;
        long long v107 = sub_18DEDD538(v37, (uint64_t)"R-sigma", 7);
        *(void *)((char *)v107 + *(void *)(*v107 - 24) + 24) = 9;
        unint64_t v108 = sub_18DEDD538(v107, (uint64_t)"I-sigma", 7);
        *(void *)((char *)v108 + *(void *)(*v108 - 24) + 24) = 5;
        int8x16_t v109 = sub_18DEDD538(v108, (uint64_t)"Res", 3);
        *(void *)((char *)v109 + *(void *)(*v109 - 24) + 24) = 10;
        uint64_t v110 = sub_18DEDD538(v109, (uint64_t)"dz_post", 7);
        *(void *)((char *)v110 + *(void *)(*v110 - 24) + 24) = 3;
        if (dword_18E21CBF0[m] == 1) {
          uint64_t v111 = "M";
        }
        else {
          uint64_t v111 = "D";
        }
        sub_18DEDD538(v110, (uint64_t)v111, 1);
        if (v240)
        {
          *(void *)(v246 + *(void *)(*v37 - 24)) = 3;
          sub_18DEDD538(v37, (uint64_t)"G", 1);
          *(void *)(v246 + *(void *)(*v37 - 24)) = 3;
          sub_18DEDD538(v37, (uint64_t)"Or", 2);
        }
      }
      uint64_t v102 = v243 + 1;
      uint64_t v97 = v234 + 1536;
    }
    while (v243 + 1 != v237);
  }
  uint64_t v112 = (char *)v233;
  if (v239)
  {
    uint64_t v113 = sub_18DEDD538(v37, (uint64_t)" ", 1);
    *(void *)((char *)v113 + *(void *)(*v113 - 24) + 24) = 10;
    uint64_t v114 = sub_18DEDD538(v113, (uint64_t)"PR_err", 6);
    *(void *)((char *)v114 + *(void *)(*v114 - 24) + 24) = 10;
    sub_18DEDD538(v114, (uint64_t)"Dopp_err", 8);
    uint64_t v115 = sub_18DEDD538(v37, (uint64_t)" ", 1);
    *(void *)((char *)v115 + *(void *)(*v115 - 24) + 24) = 10;
    double v116 = sub_18DEDD538(v115, (uint64_t)"dz_pre", 6);
    *(void *)((char *)v116 + *(void *)(*v116 - 24) + 24) = 10;
    sub_18DEDD538(v116, (uint64_t)"dz_pre", 6);
    long long v117 = sub_18DEDD538(v37, (uint64_t)" ", 1);
    *(void *)((char *)v117 + *(void *)(*v117 - 24) + 24) = 10;
    uint64_t v118 = sub_18DEDD538(v117, (uint64_t)"dz_post", 7);
    *(void *)((char *)v118 + *(void *)(*v118 - 24) + 24) = 10;
    int64x2_t v119 = sub_18DEDD538(v118, (uint64_t)"R-sigma", 7);
    *(void *)((char *)v119 + *(void *)(*v119 - 24) + 24) = 10;
    uint64_t v120 = sub_18DEDD538(v119, (uint64_t)"dz_post", 7);
    *(void *)((char *)v120 + *(void *)(*v120 - 24) + 24) = 10;
    sub_18DEDD538(v120, (uint64_t)"R-sigma", 7);
  }
  if (v240)
  {
    *(uint64_t *)((char *)v37 + *(void *)(*v37 - 24) + 24) = 6;
    sub_18DEDD538(v37, (uint64_t)"URE", 3);
    *(uint64_t *)((char *)v37 + *(void *)(*v37 - 24) + 24) = 6;
    sub_18DEDD538(v37, (uint64_t)"Iono", 4);
    *(uint64_t *)((char *)v37 + *(void *)(*v37 - 24) + 24) = 6;
    sub_18DEDD538(v37, (uint64_t)"Trop", 4);
    *(uint64_t *)((char *)v37 + *(void *)(*v37 - 24) + 24) = 6;
    sub_18DEDD538(v37, (uint64_t)"TXGD", 4);
    *(uint64_t *)((char *)v37 + *(void *)(*v37 - 24) + 24) = 8;
    sub_18DEDD538(v37, (uint64_t)"RFTB", 4);
    if (v222)
    {
      *(uint64_t *)((char *)v37 + *(void *)(*v37 - 24) + 24) = 6;
      sub_18DEDD538(v37, (uint64_t)"DCBC", 4);
    }
  }
  if ((v271 & 0x80u) == 0) {
    int64x2_t v121 = &v269;
  }
  else {
    int64x2_t v121 = v269;
  }
  if ((v271 & 0x80u) == 0) {
    uint64_t v122 = v271;
  }
  else {
    uint64_t v122 = v270;
  }
  uint64_t v123 = sub_18DEDD538(v37, (uint64_t)v121, v122);
  if ((v271 & 0x80u) == 0) {
    uint64_t v124 = &v269;
  }
  else {
    uint64_t v124 = v269;
  }
  if ((v271 & 0x80u) == 0) {
    uint64_t v125 = v271;
  }
  else {
    uint64_t v125 = v270;
  }
  sub_18DEDD538(v123, (uint64_t)v124, v125);
  unsigned int v126 = (int *)__p;
  double v224 = (int *)v267;
  if (__p == v267) {
    goto LABEL_405;
  }
  uint64_t v127 = v234 + 1528;
  uint64_t v128 = 0x404CA5DC1A63C1F8;
  uint64_t v238 = v234 + 1528;
  do
  {
    int64x2_t v129 = sub_18E182F54((uint64_t)v264, *v126, v126);
    uint64_t v130 = v129;
    if (!v129[5]) {
      goto LABEL_404;
    }
    uint64_t v225 = v129[4];
    int64x2_t v131 = *(long long **)(v225 + 16);
    if (*((char *)v131 + 23) < 0)
    {
      sub_18DEDE668(&__dst, *(void **)v131, *((void *)v131 + 1));
    }
    else
    {
      long long v132 = *v131;
      __dst.__r_.__value_.__r.__words[2] = *((void *)v131 + 2);
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v132;
    }
    uint64_t v256 = *((void *)v131 + 3);
    *(void *)(v97 + *(void *)(*v37 - 24)) = 3;
    sub_18DEDE7B0(&__b, off_1E55B9DF8[*(char *)(*(void *)(v225 + 16) + 24)]);
    if ((__b.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v133 = &__b;
    }
    else {
      uint64_t v133 = (std::string *)__b.__r_.__value_.__r.__words[0];
    }
    if ((__b.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v134 = HIBYTE(__b.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v134 = __b.__r_.__value_.__l.__size_;
    }
    uint64_t v135 = sub_18DEDD538(v37, (uint64_t)v133, v134);
    *(void *)((char *)v135 + *(void *)(*v135 - 24) + 24) = 4;
    unsigned __int8 v136 = (void *)std::ostream::operator<<();
    *(void *)((char *)v136 + *(void *)(*v136 - 24) + 24) = 4;
    double v137 = (void *)std::ostream::operator<<();
    *(void *)((char *)v137 + *(void *)(*v137 - 24) + 24) = 3;
    std::ostream::operator<<();
    if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__b.__r_.__value_.__l.__data_);
    }
    if (*(unsigned char *)(*(void *)(v225 + 16) + 304))
    {
      *(void *)(v97 + *(void *)(*v37 - 24)) = 5;
      std::ostream::operator<<();
    }
    else
    {
      *(void *)(v97 + *(void *)(*v37 - 24)) = 5;
      sub_18DEDD538(v37, (uint64_t)"-", 1);
    }
    uint64_t v138 = *(void *)(*(void *)(v225 + 16) + 312);
    uint64_t v139 = *v37;
    *(void *)(v97 + *(void *)(*v37 - 24)) = 6;
    if (v138)
    {
      *(void *)(v127 + *(void *)(v139 - 24)) = 1;
      std::ostream::operator<<();
    }
    else
    {
      sub_18DEDD538(v37, (uint64_t)"-", 1);
    }
    if (v223 == v112)
    {
      double v232 = NAN;
      double v141 = NAN;
      uint64_t v226 = 0x7FF8000000000000;
      uint64_t v227 = 0x7FF8000000000000;
      uint64_t v228 = 0x7FF8000000000000;
      uint64_t v229 = 0x7FF8000000000000;
      goto LABEL_378;
    }
    uint64_t v140 = v130 + 3;
    uint64_t v227 = 0x7FF8000000000000;
    uint64_t v228 = 0x7FF8000000000000;
    uint64_t v226 = 0x7FF8000000000000;
    double v141 = NAN;
    double v232 = NAN;
    double v142 = NAN;
    uint64_t v229 = 0x7FF8000000000000;
    double v230 = NAN;
    double v244 = (unsigned __int8 *)v223;
    double v231 = v126;
    do
    {
      double v143 = sub_18E1833CC(v262, *v126, v126);
      uint64_t v146 = v143[4];
      uint64_t v144 = v143 + 4;
      uint64_t v145 = v146;
      if (!v146) {
        goto LABEL_282;
      }
      unsigned int v147 = *v244;
      int v148 = v144;
      do
      {
        unsigned int v149 = *(unsigned __int8 *)(v145 + 28);
        BOOL v150 = v149 >= v147;
        if (v149 >= v147) {
          char v151 = (uint64_t *)v145;
        }
        else {
          char v151 = (uint64_t *)(v145 + 8);
        }
        if (v150) {
          int v148 = (void *)v145;
        }
        uint64_t v145 = *v151;
      }
      while (*v151);
      if (v148 == v144 || v147 < *((unsigned __int8 *)v148 + 28)) {
LABEL_282:
      }
        int v148 = v144;
      uint64_t v152 = sub_18E1833CC(v262, *v126, v126);
      *(void *)(v246 + *(void *)(*v37 - 24)) = 5;
      if (v148 == v152 + 4)
      {
        sub_18DEDD538(v37, (uint64_t)" ", 1);
      }
      else
      {
        uint64_t v153 = (uint64_t **)sub_18E1833CC(v262, *v126, v126);
        sub_18E183828(v153 + 3, *v244, v244);
        std::ostream::operator<<();
      }
      uint64_t v154 = (char *)dword_18E21CBF0;
      do
      {
        uint64_t v155 = v130;
        uint64_t v156 = v130[4];
        if ((uint64_t *)v156 == v140) {
          goto LABEL_298;
        }
        int v157 = *(_DWORD *)v154;
        while (1)
        {
          uint64_t v158 = *(void *)(v156 + 24);
          int v159 = *(_DWORD *)(v158 + 96) - 1;
          int v160 = v159 > 3 ? 0 : dword_18E21CBE0[v159];
          if (v160 == v157)
          {
            unint64_t v161 = *(char *)(v158 + 100);
            int v162 = v161 > 0xA ? 1 : byte_18E21CC38[v161];
            if (v162 == *v244) {
              break;
            }
          }
          uint64_t v156 = *(void *)(v156 + 8);
          if ((uint64_t *)v156 == v140) {
            goto LABEL_298;
          }
        }
        if ((uint64_t *)v156 == v140)
        {
LABEL_298:
          *(void *)(v246 + *(void *)(*v37 - 24)) = __len;
          sub_18DEDD538(v37, (uint64_t)" ", 1);
          uint64_t v130 = v155;
          goto LABEL_299;
        }
        double v163 = *(double *)(v158 + 120);
        double v164 = *(double *)(v156 + 48);
        uint64_t v250 = 0x100000001;
        v249.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1EDD18048;
        *(void *)&long long v165 = 0x100000001;
        *((void *)&v165 + 1) = 0x100000001;
        *(_OWORD *)&v249.__r_.__value_.__r.__words[1] = v165;
        char v251 = (double *)&v252;
        sub_18DFE2B44(v156 + 56, v235, (uint64_t)&v249);
        uint64_t v166 = v128;
        double v167 = v163 - v164;
        uint64_t v168 = (HIDWORD(v249.__r_.__value_.__r.__words[1]) * LODWORD(v249.__r_.__value_.__r.__words[1]));
        if ((int)v168 >= 1)
        {
          uint64_t v169 = v251;
          uint64_t v170 = &v254;
          do
          {
            double v171 = *v169++;
            *v170++ = v167 - v171;
            --v168;
          }
          while (v168);
        }
        double v172 = v254;
        if (*(unsigned char *)(v156 + 216)) {
          double v173 = sqrt(*(double *)(v156 + 208));
        }
        else {
          double v173 = NAN;
        }
        sub_18DEDE7B0(&v249, off_1E55B9D78[*(int *)(v156 + 192)]);
        sub_18DEDE7B0(v247, *((char **)&off_1E55B9DA8 + *(int *)(v156 + 196)));
        if ((v248 & 0x80u) == 0) {
          double v174 = v247;
        }
        else {
          double v174 = (void **)v247[0];
        }
        if ((v248 & 0x80u) == 0) {
          std::string::size_type v175 = v248;
        }
        else {
          std::string::size_type v175 = (std::string::size_type)v247[1];
        }
        uint64_t v176 = std::string::append(&v249, (const std::string::value_type *)v174, v175);
        long long v177 = *(_OWORD *)&v176->__r_.__value_.__l.__data_;
        __b.__r_.__value_.__r.__words[2] = v176->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__b.__r_.__value_.__l.__data_ = v177;
        v176->__r_.__value_.__l.__size_ = 0;
        v176->__r_.__value_.__r.__words[2] = 0;
        v176->__r_.__value_.__r.__words[0] = 0;
        if ((char)v248 < 0) {
          operator delete(v247[0]);
        }
        if (SHIBYTE(v249.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v249.__r_.__value_.__l.__data_);
        }
        if (*(unsigned char *)(*(void *)(v156 + 24) + 188))
        {
          if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0)
          {
            uint64_t v179 = (std::string *)__b.__r_.__value_.__r.__words[0];
            int v178 = *__b.__r_.__value_.__l.__data_;
            if (v178 == 42) {
              goto LABEL_323;
            }
          }
          else
          {
            LOBYTE(v178) = __b.__r_.__value_.__s.__data_[0];
            if (__b.__r_.__value_.__s.__data_[0] == 42)
            {
              uint64_t v179 = &__b;
LABEL_323:
              v179->__r_.__value_.__s.__data_[0] = 126;
              goto LABEL_333;
            }
          }
          if ((v178 & 0x80) != 0) {
            int v180 = __maskrune((char)v178, 0x8000uLL);
          }
          else {
            int v180 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v178 + 60) & 0x8000;
          }
          if (v180)
          {
            uint64_t v181 = &__b;
            if ((__b.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              uint64_t v181 = (std::string *)__b.__r_.__value_.__r.__words[0];
            }
            std::string::value_type v182 = __tolower(v181->__r_.__value_.__s.__data_[0]);
            uint64_t v183 = &__b;
            if ((__b.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              uint64_t v183 = (std::string *)__b.__r_.__value_.__r.__words[0];
            }
            v183->__r_.__value_.__s.__data_[0] = v182;
          }
        }
LABEL_333:
        if (v157 == 1) {
          LOBYTE(v184) = 1;
        }
        else {
          LOBYTE(v184) = 2;
        }
        uint64_t v185 = *v37;
        uint64_t v186 = *(void *)(*v37 - 24);
        if (*(void *)(v156 + 232))
        {
          uint64_t v184 = v184;
          uint64_t v187 = v234 + 1528;
          *(void *)(v238 + v186) = v184;
          uint64_t v188 = v234 + 1536;
          *(void *)(v246 + *(void *)(v185 - 24)) = 6;
          std::ostream::operator<<();
        }
        else
        {
          *(void *)(v246 + v186) = 6;
          sub_18DEDD538(v37, (uint64_t)"-", 1);
          uint64_t v184 = v184;
          uint64_t v188 = v234 + 1536;
          uint64_t v187 = v234 + 1528;
        }
        uint64_t v189 = *v37;
        *(void *)(v187 + *(void *)(*v37 - 24)) = v184;
        *(void *)(v188 + *(void *)(v189 - 24)) = 10;
        std::ostream::operator<<();
        if (v240)
        {
          *(void *)(v246 + *(void *)(*v37 - 24)) = 10;
          int8x16_t v190 = (void *)std::ostream::operator<<();
          *(void *)((char *)v190 + *(void *)(*v190 - 24) + 24) = 9;
          int8x16_t v191 = (void *)std::ostream::operator<<();
          *(void *)((char *)v191 + *(void *)(*v191 - 24) + 24) = 9;
          std::ostream::operator<<();
        }
        *(void *)(v246 + *(void *)(*v37 - 24)) = 9;
        int8x16_t v192 = (void *)std::ostream::operator<<();
        *(void *)((char *)v192 + *(void *)(*v192 - 24) + 24) = 9;
        uint64_t v193 = (void *)std::ostream::operator<<();
        *(void *)((char *)v193 + *(void *)(*v193 - 24) + 24) = 5;
        if ((__b.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          int8x16_t v194 = &__b;
        }
        else {
          int8x16_t v194 = (std::string *)__b.__r_.__value_.__r.__words[0];
        }
        if ((__b.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v195 = HIBYTE(__b.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v195 = __b.__r_.__value_.__l.__size_;
        }
        uint64_t v196 = sub_18DEDD538(v193, (uint64_t)v194, v195);
        *(void *)((char *)v196 + *(void *)(*v196 - 24) + 24) = 10;
        std::ostream::operator<<();
        *(void *)(v246 + *(void *)(*v37 - 24)) = 3;
        std::ostream::operator<<();
        if (v240)
        {
          *(void *)(v246 + *(void *)(*v37 - 24)) = 3;
          std::ostream::operator<<();
          *(void *)(v246 + *(void *)(*v37 - 24)) = 3;
          std::ostream::operator<<();
        }
        if (v239)
        {
          if (v157 == 2)
          {
            int v198 = *v244;
            if (v198 == 1)
            {
              uint64_t v228 = *(void *)&v167;
            }
            else if (v198 == 2)
            {
              uint64_t v227 = *(void *)&v167;
            }
          }
          else if (v157 == 1)
          {
            int v197 = *v244;
            if (v197 == 1)
            {
              uint64_t v229 = *(void *)&v167;
            }
            else if (v197 == 2)
            {
              uint64_t v226 = *(void *)&v167;
            }
          }
          uint64_t v128 = v166;
          if ((*(_DWORD *)(v156 + 192) & 0xFFFFFFFE) == 4)
          {
            if (v157 == 2)
            {
              uint64_t v130 = v155;
              if ((*(void *)&v232 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                || (*(void *)&v230 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
              {
                double v230 = v173;
                double v232 = v172;
              }
              else
              {
                double v203 = 1.0 / (v230 * v230);
                double v204 = 1.0 / (v173 * v173);
                double v205 = v172 * v204 + v203 * v232;
                double v206 = 1.0 / (v203 + v204);
                double v232 = v205 * v206;
                double v230 = sqrt(v206);
              }
            }
            else
            {
              uint64_t v130 = v155;
              if (v157 == 1)
              {
                if ((*(void *)&v141 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                  || (*(void *)&v142 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                {
                  double v142 = v173;
                  double v141 = v172;
                }
                else
                {
                  double v199 = 1.0 / (v142 * v142);
                  double v200 = 1.0 / (v173 * v173);
                  double v201 = v172 * v200 + v199 * v141;
                  double v202 = 1.0 / (v199 + v200);
                  double v141 = v201 * v202;
                  double v142 = sqrt(v202);
                }
              }
            }
            goto LABEL_373;
          }
        }
        else
        {
          uint64_t v128 = v166;
        }
        uint64_t v130 = v155;
LABEL_373:
        if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__b.__r_.__value_.__l.__data_);
        }
LABEL_299:
        v154 += 4;
      }
      while (v154 != &byte_18E21CBF8);
      ++v244;
      unsigned int v126 = v231;
    }
    while (v244 != v233);
LABEL_378:
    uint64_t v112 = (char *)v233;
    uint64_t v97 = v234 + 1536;
    uint64_t v127 = v234 + 1528;
    if (v239)
    {
      double v207 = sub_18DEDD538(v37, (uint64_t)" ", 1);
      *(void *)((char *)v207 + *(void *)(*v207 - 24) + 16) = 1;
      if ((v229 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (v226 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        *(void *)(v246 + *(void *)(*v37 - 24)) = 10;
        sub_18DEDD538(v37, (uint64_t)" ", 1);
      }
      else
      {
        *(void *)(v246 + *(void *)(*v37 - 24)) = 10;
        std::ostream::operator<<();
      }
      uint64_t v208 = *v37;
      *(void *)(v238 + *(void *)(*v37 - 24)) = 2;
      if ((v228 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (v227 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        *(void *)(v246 + *(void *)(v208 - 24)) = 10;
        sub_18DEDD538(v37, (uint64_t)" ", 1);
      }
      else
      {
        *(void *)(v246 + *(void *)(v208 - 24)) = 10;
        std::ostream::operator<<();
      }
      uint64_t v209 = sub_18DEDD538(v37, (uint64_t)" ", 1);
      *(void *)((char *)v209 + *(void *)(*v209 - 24) + 16) = 1;
      uint64_t v210 = *(void *)(*v37 - 24);
      if ((*(void *)&v141 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        *(void *)(v246 + v210) = 20;
        sub_18DEDD538(v37, (uint64_t)" ", 1);
      }
      else
      {
        *(void *)(v246 + v210) = 10;
        std::ostream::operator<<();
        *(void *)(v246 + *(void *)(*v37 - 24)) = 10;
        std::ostream::operator<<();
      }
      uint64_t v211 = *v37;
      *(void *)(v238 + *(void *)(*v37 - 24)) = 2;
      uint64_t v212 = *(void *)(v211 - 24);
      if ((*(void *)&v232 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        *(void *)(v246 + v212) = 20;
        sub_18DEDD538(v37, (uint64_t)" ", 1);
      }
      else
      {
        *(void *)(v246 + v212) = 10;
        std::ostream::operator<<();
        *(void *)(v246 + *(void *)(*v37 - 24)) = 10;
        std::ostream::operator<<();
      }
    }
    if (v240)
    {
      uint64_t v213 = *v37;
      *(void *)(v238 + *(void *)(*v37 - 24)) = 1;
      *(void *)(v246 + *(void *)(v213 - 24)) = 6;
      uint64_t v214 = (void *)std::ostream::operator<<();
      *(void *)((char *)v214 + *(void *)(*v214 - 24) + 24) = 6;
      uint64_t v215 = (void *)std::ostream::operator<<();
      *(void *)((char *)v215 + *(void *)(*v215 - 24) + 24) = 6;
      long long v216 = (void *)std::ostream::operator<<();
      *(void *)((char *)v216 + *(void *)(*v216 - 24) + 24) = 6;
      uint64_t v217 = (void *)std::ostream::operator<<();
      *(void *)((char *)v217 + *(void *)(*v217 - 24) + 24) = 8;
      std::ostream::operator<<();
      if (v222)
      {
        *(void *)(v246 + *(void *)(*v37 - 24)) = 6;
        std::ostream::operator<<();
      }
    }
    if ((v271 & 0x80u) == 0) {
      int v218 = &v269;
    }
    else {
      int v218 = v269;
    }
    if ((v271 & 0x80u) == 0) {
      uint64_t v219 = v271;
    }
    else {
      uint64_t v219 = v270;
    }
    sub_18DEDD538(v37, (uint64_t)v218, v219);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
LABEL_404:
    ++v126;
  }
  while (v126 != v224);
LABEL_405:
  if ((v271 & 0x80u) == 0) {
    int v220 = &v269;
  }
  else {
    int v220 = v269;
  }
  if ((v271 & 0x80u) == 0) {
    uint64_t v221 = v271;
  }
  else {
    uint64_t v221 = v270;
  }
  sub_18DEDD538(v37, (uint64_t)v220, v221);
  operator delete(v223);
  sub_18E182EF4((uint64_t)v262);
  sub_18E182E94((uint64_t)v264);
  if (__p)
  {
    double v267 = (char *)__p;
    operator delete(__p);
  }
  if ((char)v271 < 0) {
    operator delete(v269);
  }
}

void sub_18E17D4D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,void *a60,uint64_t a61,int a62,__int16 a63)
{
  if (a44 < 0) {
    operator delete(__p);
  }
  if (a65 < 0) {
    operator delete(a60);
  }
  operator delete(a11);
  sub_18E182EF4((uint64_t)&a72);
  sub_18E182E94((uint64_t)&STACK[0x200]);
  std::string::size_type v73 = (void *)STACK[0x228];
  if (STACK[0x228])
  {
    STACK[0x230] = (unint64_t)v73;
    operator delete(v73);
  }
  if (SLOBYTE(STACK[0x257]) < 0) {
    operator delete((void *)STACK[0x240]);
  }
  _Unwind_Resume(a1);
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::PrefilterGNSSMeasurementsAsUseOrNotUse(void *a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  uint64_t v7 = a2;
  std::locale v8 = a1;
  uint64_t v9 = a1[24];
  int v82 = *(unsigned __int8 *)(v9 + 3818);
  memset(v102, 0, 32);
  v102[8] = 1.0;
  int v10 = *(uint64_t **)(a2 + 96);
  std::string::size_type v77 = *(uint64_t **)(a2 + 104);
  if (v10 != v77)
  {
    int v75 = 0;
    int v76 = 0;
    uint64_t v81 = (uint64_t)(a1 + 12);
    double v12 = 0.0;
    while (1)
    {
      uint64_t v13 = *v10;
      if (*v10) {
        break;
      }
LABEL_54:
      v10 += 2;
      if (v10 == v77)
      {
        uint64_t v9 = v8[24];
        uint64_t v7 = a2;
        int v42 = v75;
        uint64_t v5 = a4;
        int v43 = v76;
        goto LABEL_57;
      }
    }
    if (*(unsigned char *)(v13 + 304))
    {
      double v14 = *(double *)(v13 + 296);
      double v15 = *(double *)(v8[24] + 2240);
      uint64_t v16 = *(void *)(v13 + 312);
      BOOL v79 = v16 == 0;
      BOOL v80 = v14 < v15;
      if (v14 < v15 && v16 == 0)
      {
        a1 = sub_18E17E0EC(v102, *(unsigned char *)(v13 + 24));
        ++*((_DWORD *)a1 + 1);
        ++v75;
        BOOL v79 = 1;
        BOOL v80 = 1;
        goto LABEL_13;
      }
    }
    else
    {
      BOOL v79 = *(void *)(v13 + 312) == 0;
      BOOL v80 = 0;
    }
    a1 = sub_18E17E0EC(v102, *(unsigned char *)(v13 + 24));
    ++*(_DWORD *)a1;
    ++v76;
LABEL_13:
    if (*(unsigned char *)(v13 + 304))
    {
      double v18 = *(double *)(v13 + 296);
      if (v18 <= v12) {
        double v18 = v12;
      }
      double v12 = v18;
    }
    uint64_t v20 = *(void *)(v13 + 328);
    uint64_t v19 = *(void *)(v13 + 336);
    while (v20 != v19)
    {
      double v21 = *(double *)(v20 + 200) - *(double *)(v20 + 192);
      unint64_t v22 = (unint64_t)(COERCE__INT64(fabs(v21)) - 0x10000000000000) >> 53;
      if ((*(uint64_t *)&v21 <= -1 || v22 >= 0x3FF) && (unint64_t)(*(void *)&v21 - 1) >= 0xFFFFFFFFFFFFFLL)
      {
        LOWORD(v88) = 12;
        LOBYTE(__p[0]) = 4;
        unsigned __int8 v29 = sub_18E017C64(v13);
        unsigned int v30 = *(_DWORD *)(v20 + 96) - 1;
        uint64_t v31 = "UnknownType";
        if (v30 <= 4) {
          uint64_t v31 = off_1E55B9E30[v30];
        }
        cnprint::CNLogFormatter::FormatGeneral((uint64_t)(v8 + 26), v81, "#MSR %s %s invalid meas interval,%3.lf", v29, v31, *(double *)(v20 + 200) - *(double *)(v20 + 192));
        if (*((char *)v8 + 231) >= 0) {
          LOBYTE(v37) = (_BYTE)v8 - 48;
        }
        else {
          uint64_t v37 = v8[26];
        }
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v88, (unsigned __int8 *)__p, "%s", v32, v33, v34, v35, v36, v37);
      }
      else
      {
        uint64_t v88 = v13;
        uint64_t v89 = v20;
        uint64_t v25 = (uint64_t)(*(double *)(v20 + 104) + 0.5);
        int v90 = *(_DWORD *)(v13 + 28) + 1000 * *(unsigned __int8 *)(v13 + 24);
        uint64_t v91 = v25;
        char v92 = 0;
        v95[32] = 0;
        v95[40] = 0;
        v95[56] = 0;
        char v98 = 0;
        char v99 = 0;
        int v100 = 0;
        uint64_t v101 = 0;
        char v97 = 0;
        uint64_t v96 = 0;
        if (a5)
        {
          uint64_t v26 = *(void *)(a5 + 16);
          uint64_t v27 = *(void *)(a5 + 24);
          if (v26 == v27)
          {
LABEL_33:
            uint64_t v26 = 0;
          }
          else
          {
            while (*(unsigned __int8 *)(v26 + 48) != *(unsigned __int8 *)(v13 + 24)
                 || *(_DWORD *)(v26 + 52) != *(_DWORD *)(v13 + 28)
                 || *(unsigned __int8 *)(v26 + 8) != *(unsigned __int8 *)(v20 + 100)
                 || *(_DWORD *)(v26 + 16) != *(_DWORD *)(v20 + 96))
            {
              v26 += 56;
              if (v26 == v27) {
                goto LABEL_33;
              }
            }
          }
          uint64_t v101 = v26;
        }
        if (v82 && *(unsigned char *)(v20 + 188))
        {
          a1 = sub_18E1838FC((uint64_t)&v88);
          a1[1] = a3;
          uint64_t v28 = *a3;
          *a1 = *a3;
          *(void *)(v28 + 8) = a1;
          *a3 = (uint64_t)a1;
          ++a3[2];
        }
        else if (v80)
        {
          if (v79 || *(_DWORD *)(v20 + 96) != 1)
          {
            uint64_t v96 = 0x100000002;
            a1 = sub_18E1838FC((uint64_t)&v88);
            a1[1] = a4;
            uint64_t v41 = *a4;
            *a1 = *a4;
            *(void *)(v41 + 8) = a1;
            *a4 = a1;
            ++a4[2];
          }
          else
          {
            a1 = sub_18E1838FC((uint64_t)&v88);
            a1[1] = a3;
            uint64_t v38 = *a3;
            *a1 = *a3;
            *(void *)(v38 + 8) = a1;
            *a3 = (uint64_t)a1;
            ++a3[2];
            ++*((_DWORD *)v8 + 520);
            ++*((_DWORD *)v8 + 522);
          }
        }
        else
        {
          a1 = sub_18E1838FC((uint64_t)&v88);
          a1[1] = a3;
          uint64_t v39 = *a3;
          *a1 = *a3;
          *(void *)(v39 + 8) = a1;
          *a3 = (uint64_t)a1;
          ++a3[2];
          int v40 = *(_DWORD *)(v89 + 96);
          if (v40 == 1)
          {
            ++*((_DWORD *)v8 + 520);
          }
          else if ((v40 - 2) <= 2)
          {
            ++*((_DWORD *)v8 + 521);
          }
        }
      }
      v20 += 208;
    }
    goto LABEL_54;
  }
  int v43 = 0;
  int v42 = 0;
  double v12 = 0.0;
LABEL_57:
  if (v12 >= *(double *)(v9 + 2272))
  {
    int v44 = *(_DWORD *)(v9 + 2280);
    *((unsigned char *)v8 + 88) = v43 >= v44;
    if (v43 >= v44) {
      goto LABEL_74;
    }
  }
  else
  {
    *((unsigned char *)v8 + 88) = 0;
  }
  if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) <= 1)
  {
    LOWORD(v88) = 12;
    LOBYTE(__p[0]) = 1;
    char v45 = cnprint::CNLogFormatter::FormatGeneral((uint64_t)(v8 + 26), (uint64_t)(v8 + 12), "#MSR LOS HMM unreliable, adding back low-P(LOS) measurements, best P(LOS) %5.3f, high-P(LOS) count %2d,  low-P(LOS) count %2d", v12, v43, v42);
    if (*((char *)v8 + 231) >= 0) {
      LOBYTE(v51) = v45;
    }
    else {
      uint64_t v51 = v8[26];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v88, (unsigned __int8 *)__p, "%s", v46, v47, v48, v49, v50, v51);
  }
  uint64_t v52 = (unsigned __int8 *)v8[6];
  std::string::size_type v53 = (unsigned __int8 *)v8[7];
  while (v52 != v53)
  {
    unsigned __int8 v54 = sub_18E17E0EC(v102, *v52);
    *(void *)unsigned __int8 v54 = (*(_DWORD *)v54 + *((_DWORD *)v54 + 1));
    ++v52;
  }
  if (!*((unsigned char *)v8 + 1272) || !*(unsigned char *)(v8[24] + 2392))
  {
    for (uint64_t i = (void *)v5[1]; i != v5; uint64_t i = (void *)i[1])
      i[24] = 0;
    sub_18E12D688((uint64_t)a3, a3, v5);
  }
LABEL_74:
  LOBYTE(v88) = 1;
  if (cnprint::CNPrinter::WillPrint((cnprint::CNPrinter *)&v88))
  {
    sub_18DF06614((uint64_t)&v88);
    std::string::size_type v56 = (cnprint::CNPrinter *)sub_18DEDD538(&v88, (uint64_t)"#MSR LOS HMM satellite counts (accept,reject)", 45);
    unsigned __int8 v57 = (unsigned __int8 *)v8[6];
    for (uint64_t j = (unsigned __int8 *)v8[7]; v57 != j; ++v57)
    {
      sub_18E17E0EC(v102, *v57);
      std::string::size_type v59 = sub_18DEDD538(&v88, (uint64_t)",", 1);
      sub_18DEDE7B0(__p, off_1E55B9DF8[(char)*v57]);
      if ((v87 & 0x80u) == 0) {
        uint64_t v60 = __p;
      }
      else {
        uint64_t v60 = (void **)__p[0];
      }
      if ((v87 & 0x80u) == 0) {
        uint64_t v61 = v87;
      }
      else {
        uint64_t v61 = (uint64_t)__p[1];
      }
      uint64_t v62 = sub_18DEDD538(v59, (uint64_t)v60, v61);
      sub_18DEDD538(v62, (uint64_t)",", 1);
      long long v63 = (void *)std::ostream::operator<<();
      sub_18DEDD538(v63, (uint64_t)",", 1);
      std::string::size_type v56 = (cnprint::CNPrinter *)std::ostream::operator<<();
      if ((char)v87 < 0) {
        operator delete(__p[0]);
      }
    }
    if (cnprint::CNPrinter::GetLogLevel(v56) <= 1)
    {
      __int16 v85 = 12;
      unsigned __int8 v84 = 1;
      v83[0] = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
      v83[1] = v64;
      sub_18DEDD9B8((uint64_t)&v89, __p);
      int v65 = (v87 & 0x80u) == 0 ? (const char *)__p : (const char *)__p[0];
      char v66 = cnprint::CNLogFormatter::FormatGeneral((uint64_t)(v8 + 26), (uint64_t)v83, "%s", v65);
      if (*((char *)v8 + 231) >= 0) {
        LOBYTE(v72) = v66;
      }
      else {
        uint64_t v72 = v8[26];
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v85, &v84, "%s", v67, v68, v69, v70, v71, v72);
      if ((char)v87 < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v88 = *MEMORY[0x1E4FBA418];
    *(uint64_t *)((char *)&v88 + *(void *)(v88 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
    uint64_t v89 = MEMORY[0x1E4FBA470] + 16;
    if (v94 < 0) {
      operator delete(v93);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    MEMORY[0x192FA6190](v95);
  }
  return sub_18E011990((uint64_t)v102);
}

void sub_18E17E080(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29)
{
  sub_18DF067AC((uint64_t)&a29);
  sub_18E011990(v29 - 176);
  _Unwind_Resume(a1);
}

char *sub_18E17E0EC(float *a1, unsigned __int8 a2)
{
  unint64_t v4 = a2;
  unint64_t v5 = *((void *)a1 + 1);
  if (v5)
  {
    uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)v5);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      unint64_t v2 = a2;
      if (v5 <= a2) {
        unint64_t v2 = a2 % v5;
      }
    }
    else
    {
      unint64_t v2 = (v5 - 1) & a2;
    }
    uint64_t v7 = *(void ***)(*(void *)a1 + 8 * v2);
    if (v7)
    {
      std::locale v8 = *v7;
      if (*v7)
      {
        do
        {
          unint64_t v9 = v8[1];
          if (v9 == a2)
          {
            if (*((unsigned __int8 *)v8 + 16) == a2) {
              return (char *)v8 + 20;
            }
          }
          else
          {
            if (v6.u32[0] > 1uLL)
            {
              if (v9 >= v5) {
                v9 %= v5;
              }
            }
            else
            {
              v9 &= v5 - 1;
            }
            if (v9 != v2) {
              break;
            }
          }
          std::locale v8 = (void *)*v8;
        }
        while (v8);
      }
    }
  }
  std::locale v8 = operator new(0x20uLL);
  *std::locale v8 = 0;
  v8[1] = v4;
  *((unsigned char *)v8 + 16) = v4;
  *(void *)((char *)v8 + 20) = 0;
  float v10 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v11 = a1[8];
  if (!v5 || (float)(v11 * (float)v5) < v10)
  {
    BOOL v12 = (v5 & (v5 - 1)) == 0;
    if (v5 < 3) {
      BOOL v12 = 0;
    }
    unint64_t v13 = (2 * v5) | !v12;
    unint64_t v14 = vcvtps_u32_f32(v10 / v11);
    if (v13 <= v14) {
      int8x8_t prime = (int8x8_t)v14;
    }
    else {
      int8x8_t prime = (int8x8_t)v13;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v5 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v5) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v5)
    {
      unint64_t v22 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v5 < 3 || (uint8x8_t v23 = (uint8x8_t)vcnt_s8((int8x8_t)v5), v23.i16[0] = vaddlv_u8(v23), v23.u32[0] > 1uLL))
      {
        unint64_t v22 = std::__next_prime(v22);
      }
      else
      {
        uint64_t v24 = 1 << -(char)__clz(v22 - 1);
        if (v22 >= 2) {
          unint64_t v22 = v24;
        }
      }
      if (*(void *)&prime <= v22) {
        int8x8_t prime = (int8x8_t)v22;
      }
      if (*(void *)&prime >= v5)
      {
        unint64_t v5 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            sub_18DEDF7D4();
          }
          uint64_t v16 = operator new(8 * *(void *)&prime);
          int v17 = *(void **)a1;
          *(void *)a1 = v16;
          if (v17) {
            operator delete(v17);
          }
          uint64_t v18 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v18++) = 0;
          while (*(void *)&prime != v18);
          uint64_t v19 = (void *)*((void *)a1 + 2);
          if (v19)
          {
            unint64_t v20 = v19[1];
            uint8x8_t v21 = (uint8x8_t)vcnt_s8(prime);
            v21.i16[0] = vaddlv_u8(v21);
            if (v21.u32[0] > 1uLL)
            {
              if (v20 >= *(void *)&prime) {
                v20 %= *(void *)&prime;
              }
            }
            else
            {
              v20 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v20) = a1 + 4;
            uint64_t v25 = (void *)*v19;
            if (*v19)
            {
              do
              {
                unint64_t v26 = v25[1];
                if (v21.u32[0] > 1uLL)
                {
                  if (v26 >= *(void *)&prime) {
                    v26 %= *(void *)&prime;
                  }
                }
                else
                {
                  v26 &= *(void *)&prime - 1;
                }
                if (v26 != v20)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v26))
                  {
                    *(void *)(*(void *)a1 + 8 * v26) = v19;
                    goto LABEL_55;
                  }
                  void *v19 = *v25;
                  *uint64_t v25 = **(void **)(*(void *)a1 + 8 * v26);
                  **(void **)(*(void *)a1 + 8 * v26) = v25;
                  uint64_t v25 = v19;
                }
                unint64_t v26 = v20;
LABEL_55:
                uint64_t v19 = v25;
                uint64_t v25 = (void *)*v25;
                unint64_t v20 = v26;
              }
              while (v25);
            }
          }
          unint64_t v5 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v31 = *(void **)a1;
        *(void *)a1 = 0;
        if (v31) {
          operator delete(v31);
        }
        unint64_t v5 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v5 & (v5 - 1)) != 0)
    {
      if (v5 <= v4) {
        unint64_t v2 = v4 % v5;
      }
      else {
        unint64_t v2 = v4;
      }
    }
    else
    {
      unint64_t v2 = (v5 - 1) & v4;
    }
  }
  uint64_t v27 = *(void **)a1;
  uint64_t v28 = *(void **)(*(void *)a1 + 8 * v2);
  if (v28)
  {
    *std::locale v8 = *v28;
LABEL_72:
    *uint64_t v28 = v8;
    goto LABEL_73;
  }
  *std::locale v8 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v8;
  v27[v2] = a1 + 4;
  if (*v8)
  {
    unint64_t v29 = *(void *)(*v8 + 8);
    if ((v5 & (v5 - 1)) != 0)
    {
      if (v29 >= v5) {
        v29 %= v5;
      }
    }
    else
    {
      v29 &= v5 - 1;
    }
    uint64_t v28 = (void *)(*(void *)a1 + 8 * v29);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return (char *)v8 + 20;
}

void sub_18E17E4C4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *raven::RavenSequentialGNSSMeasurementSelector::ProcessMSRDataContainer(uint64_t a1, uint64_t *a2)
{
  uint64_t result = raven::RavenSequentialGNSSMeasurementSelector::TestInnovationsAndUpdateEstimator(a1, a2, *(unsigned __int8 *)(*(void *)(a1 + 192) + 2104), v5);
  if (v6)
  {
    uint64_t result = (void *)raven::RavenSequentialGNSSMeasurementSelector::ReTestInnovationsAndUpdateEstimator(a1, v5, a2);
    if (v6) {
      return sub_18E068ED0(v5);
    }
  }
  return result;
}

void sub_18E17E53C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a12) {
    sub_18E068ED0(&a9);
  }
  _Unwind_Resume(exception_object);
}

void *raven::RavenSequentialGNSSMeasurementSelector::TestInnovationsAndUpdateEstimator@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  int v162 = (uint64_t *)&v162;
  double v163 = &v162;
  uint64_t v164 = 0;
  unint64_t v9 = (uint64_t *)a2[1];
  if (v9 == a2) {
    goto LABEL_144;
  }
  uint64_t v13 = a1 + 96;
  uint64_t v14 = a1 + 208;
  uint64_t v152 = (double *)(a1 + 1288);
  uint64_t v153 = (double *)(a1 + 1280);
  BOOL v150 = (double *)(a1 + 1304);
  char v151 = (double *)(a1 + 1296);
  uint64_t v156 = (double *)(a1 + 1320);
  int v157 = (double *)(a1 + 1312);
  uint64_t v154 = (double *)(a1 + 1336);
  uint64_t v155 = (double *)(a1 + 1328);
  do
  {
    double v15 = (uint64_t *)v9[1];
    uint64_t v16 = v9 + 2;
    if (!*((unsigned char *)v9 + 160))
    {
      LOWORD(__p[0]) = 12;
      LOBYTE(v161) = 4;
      uint64_t v37 = sub_18E017C64(*v16);
      unsigned int v38 = *(_DWORD *)(v9[3] + 96) - 1;
      uint64_t v39 = "UnknownType";
      if (v38 <= 4) {
        uint64_t v39 = off_1E55B9E30[v38];
      }
      cnprint::CNLogFormatter::FormatGeneral(v14, v13, "#MSR no measurement function data for %s %s", v37, v39);
      if (*(char *)(a1 + 231) >= 0) {
        LOBYTE(v45) = v14;
      }
      else {
        uint64_t v45 = *(void *)(a1 + 208);
      }
      goto LABEL_122;
    }
    if ((v9[24] & 0xFFFFFFFE) == 2) {
      goto LABEL_123;
    }
    __int16 v17 = *(_WORD *)(a1 + 1504) + 1;
    *(_WORD *)(a1 + 1504) = v17;
    *((_WORD *)v9 + 113) = v17;
    BOOL ShouldMeasurementBeUsedToUpdateEstimator = raven::RavenSequentialGNSSMeasurementSelector::ShouldMeasurementBeUsedToUpdateEstimator(a1, (uint64_t)(v9 + 2));
    if (ShouldMeasurementBeUsedToUpdateEstimator)
    {
      raven::RavenSequentialGNSSMeasurementSelector::ComputeInnovationData(a1, v9[3], (uint64_t)(v9 + 6), (uint64_t)__p);
      *(_OWORD *)(v9 + 21) = *(_OWORD *)__p;
      char v19 = (char)__p[2];
      *((unsigned char *)v9 + 184) = __p[2];
      if (v19)
      {
        updated = raven::RavenSequentialGNSSMeasurementSelector::UpdateTIVsForMeasurement((uint64_t *)a1, (uint64_t)(v9 + 2));
        unint64_t v22 = v156;
        uint8x8_t v21 = v157;
        uint64_t v24 = v154;
        uint8x8_t v23 = v155;
        switch(*(_DWORD *)(v9[3] + 96))
        {
          case 0:
          case 5:
            if (!cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)updated))
            {
              LOWORD(__p[0]) = 12;
              LOBYTE(v161) = 0;
              int v58 = sub_18E017C64(*v16);
              int v59 = *(_DWORD *)(v9[3] + 96);
              uint64_t v60 = "UnknownType";
              if ((v59 - 1) <= 4) {
                uint64_t v60 = off_1E55B9E30[v59 - 1];
              }
              cnprint::CNLogFormatter::FormatGeneral(v14, v13, "#MSR %s %s invalid measurement type, %d", v58, v60, v59);
              if (*(char *)(a1 + 231) >= 0) {
                LOBYTE(v45) = v14;
              }
              else {
                uint64_t v45 = *(void *)(a1 + 208);
              }
              break;
            }
            goto LABEL_123;
          case 1:
            goto LABEL_9;
          case 2:
          case 3:
          case 4:
            unint64_t v22 = v152;
            uint8x8_t v21 = v153;
            uint64_t v24 = v150;
            uint8x8_t v23 = v151;
LABEL_9:
            double v4 = *v21;
            double v5 = *v22;
            double v6 = *v23;
            double v7 = *v24;
            goto LABEL_10;
          default:
LABEL_10:
            MSRThresholdType = (cnprint::CNPrinter *)raven::RavenSequentialGNSSMeasurementSelector::GetMSRThresholdType(a1, (uint64_t)(v9 + 2));
            if (MSRThresholdType)
            {
              if (MSRThresholdType == 1)
              {
                MSRThresholdType = (cnprint::CNPrinter *)cnprint::CNPrinter::GetLogLevel(MSRThresholdType);
                double v26 = v6;
                double v27 = v7;
                if (!MSRThresholdType)
                {
                  LOWORD(__p[0]) = 12;
                  LOBYTE(v161) = 0;
                  uint64_t v64 = sub_18E017C64(*v16);
                  unsigned int v65 = *(_DWORD *)(v9[3] + 96) - 1;
                  char v66 = "UnknownType";
                  if (v65 <= 4) {
                    char v66 = off_1E55B9E30[v65];
                  }
                  cnprint::CNLogFormatter::FormatGeneral(v14, v13, "#MSR %s %s using positive-side thresholds,reweight,%.3lf,reject,%.3lf", v64, v66, v6, v7);
                  if (*(char *)(a1 + 231) >= 0) {
                    LOBYTE(v72) = v14;
                  }
                  else {
                    uint64_t v72 = *(void *)(a1 + 208);
                  }
                  cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v161, "%s", v67, v68, v69, v70, v71, v72);
                  double v26 = v6;
                  double v27 = v7;
                }
              }
              else
              {
                double v26 = 0.0;
                double v27 = 0.0;
                if (MSRThresholdType == 2)
                {
                  MSRThresholdType = (cnprint::CNPrinter *)cnprint::CNPrinter::GetLogLevel(MSRThresholdType);
                  double v26 = v5;
                  double v27 = v4;
                  if (!MSRThresholdType)
                  {
                    LOWORD(__p[0]) = 12;
                    LOBYTE(v161) = 0;
                    uint64_t v28 = sub_18E017C64(*v16);
                    unsigned int v29 = *(_DWORD *)(v9[3] + 96) - 1;
                    unsigned int v30 = "UnknownType";
                    if (v29 <= 4) {
                      unsigned int v30 = off_1E55B9E30[v29];
                    }
                    cnprint::CNLogFormatter::FormatGeneral(v14, v13, "#MSR %s %s using negative-side thresholds,reweight,%.3lf,reject,%.3lf", v28, v30, v5, v4);
                    if (*(char *)(a1 + 231) >= 0) {
                      LOBYTE(v36) = v14;
                    }
                    else {
                      uint64_t v36 = *(void *)(a1 + 208);
                    }
                    cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v161, "%s", v31, v32, v33, v34, v35, v36);
                    double v26 = v5;
                    double v27 = v4;
                  }
                }
              }
              if (*(unsigned char *)(*(void *)(a1 + 192) + 3812) && *(unsigned char *)(v9[3] + 188))
              {
                *((_DWORD *)v9 + 48) = 5;
                if (!cnprint::CNPrinter::GetLogLevel(MSRThresholdType))
                {
                  uint64_t v73 = a3;
                  uint64_t v74 = a4;
                  __int16 v161 = 12;
                  unsigned __int8 v160 = 0;
                  uint64_t v75 = v9[3];
                  int v76 = sub_18E017C64(v9[2]);
                  uint64_t v77 = v9[3];
                  unsigned int v78 = *(_DWORD *)(v77 + 96) - 1;
                  BOOL v79 = "UnknownType";
                  if (v78 <= 4) {
                    BOOL v79 = off_1E55B9E30[v78];
                  }
                  int v80 = *(unsigned __int8 *)(v77 + 100);
                  memset(__p, 0, 24);
                  switch(v80)
                  {
                    case 0:
                      HIBYTE(__p[2]) = 4;
                      int v81 = 543911509;
                      goto LABEL_134;
                    case 1:
                      HIBYTE(__p[2]) = 4;
                      int v81 = 1094922572;
                      goto LABEL_134;
                    case 2:
                      HIBYTE(__p[2]) = 4;
                      int v81 = 538981708;
                      goto LABEL_134;
                    case 3:
                      HIBYTE(__p[2]) = 4;
                      int v81 = 543568204;
                      goto LABEL_134;
                    case 4:
                      HIBYTE(__p[2]) = 4;
                      int v81 = 541667650;
                      goto LABEL_134;
                    case 5:
                      HIBYTE(__p[2]) = 4;
                      int v81 = 541274434;
                      goto LABEL_134;
                    case 6:
                      HIBYTE(__p[2]) = 4;
                      int v81 = 543240770;
                      goto LABEL_134;
                    case 7:
                      HIBYTE(__p[2]) = 4;
                      int v81 = 538980677;
                      goto LABEL_134;
                    case 8:
                      HIBYTE(__p[2]) = 4;
                      int v81 = 543241541;
                      goto LABEL_134;
                    case 9:
                      HIBYTE(__p[2]) = 4;
                      int v81 = 1112748364;
LABEL_134:
                      LODWORD(__p[0]) = v81;
                      break;
                    case 10:
                      HIBYTE(__p[2]) = 3;
                      qmemcpy(__p, "NL5", 3);
                      break;
                    default:
                      break;
                  }
                  cnprint::CNLogFormatter::FormatGeneral(v14, v75, "#MSR Skip Innovation Testing for %s %s %s with externally set uncertainty %.2f", v76, v79, (const char *)__p, *(float *)(v77 + 168));
                  if (*(char *)(a1 + 231) >= 0) {
                    LOBYTE(v142) = v14;
                  }
                  else {
                    uint64_t v142 = *(void *)(a1 + 208);
                  }
                  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v161, &v160, "%s", v137, v138, v139, v140, v141, v142);
                  a4 = v74;
                  if (SHIBYTE(__p[2]) < 0) {
                    operator delete(__p[0]);
                  }
                  a3 = v73;
                }
              }
              else
              {
                raven::RavenSequentialGNSSMeasurementSelector::DetermineAndSetInnovationTestResult(a1, (uint64_t)(v9 + 2), v27, v26);
              }
              int v82 = raven::RavenSequentialGNSSMeasurementSelector::UpdateITRsForMeasurement((uint64_t **)a1, (uint64_t)(v9 + 2));
              switch(*((_DWORD *)v9 + 48))
              {
                case 0:
                  if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v82)) {
                    goto LABEL_123;
                  }
                  LOWORD(__p[0]) = 12;
                  LOBYTE(v161) = 0;
                  uint64_t v83 = v9[3];
                  unsigned __int8 v84 = sub_18E017C64(v9[2]);
                  unsigned int v85 = *(_DWORD *)(v9[3] + 96) - 1;
                  long long v86 = "UnknownType";
                  if (v85 <= 4) {
                    long long v86 = off_1E55B9E30[v85];
                  }
                  cnprint::CNLogFormatter::FormatGeneral(v14, v83, "#MSR no decision for %s %s", v84, v86);
                  if (*(char *)(a1 + 231) >= 0) {
                    LOBYTE(v45) = v14;
                  }
                  else {
                    uint64_t v45 = *(void *)(a1 + 208);
                  }
                  goto LABEL_122;
                case 1:
                  LOWORD(__p[0]) = 12;
                  LOBYTE(v161) = 4;
                  uint64_t v87 = v9[3];
                  uint64_t v88 = sub_18E017C64(v9[2]);
                  unsigned int v89 = *(_DWORD *)(v9[3] + 96) - 1;
                  int v90 = "UnknownType";
                  if (v89 <= 4) {
                    int v90 = off_1E55B9E30[v89];
                  }
                  cnprint::CNLogFormatter::FormatGeneral(v14, v87, "#MSR error for %s %s", v88, v90);
                  if (*(char *)(a1 + 231) >= 0) {
                    LOBYTE(v45) = v14;
                  }
                  else {
                    uint64_t v45 = *(void *)(a1 + 208);
                  }
                  goto LABEL_122;
                case 2:
                  if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v82)) {
                    goto LABEL_123;
                  }
                  LOWORD(__p[0]) = 12;
                  LOBYTE(v161) = 0;
                  uint64_t v91 = v9[3];
                  char v92 = sub_18E017C64(v9[2]);
                  unsigned int v93 = *(_DWORD *)(v9[3] + 96) - 1;
                  char v94 = "UnknownType";
                  if (v93 <= 4) {
                    char v94 = off_1E55B9E30[v93];
                  }
                  cnprint::CNLogFormatter::FormatGeneral(v14, v91, "#MSR ignoring %s %s", v92, v94);
                  if (*(char *)(a1 + 231) >= 0) {
                    LOBYTE(v45) = v14;
                  }
                  else {
                    uint64_t v45 = *(void *)(a1 + 208);
                  }
                  goto LABEL_122;
                case 3:
                  if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v82)) {
                    goto LABEL_123;
                  }
                  LOWORD(__p[0]) = 12;
                  LOBYTE(v161) = 0;
                  uint64_t v95 = v9[3];
                  uint64_t v96 = sub_18E017C64(v9[2]);
                  unsigned int v97 = *(_DWORD *)(v9[3] + 96) - 1;
                  char v98 = "UnknownType";
                  if (v97 <= 4) {
                    char v98 = off_1E55B9E30[v97];
                  }
                  cnprint::CNLogFormatter::FormatGeneral(v14, v95, "#MSR rejecting %s %s", v96, v98);
                  if (*(char *)(a1 + 231) >= 0) {
                    LOBYTE(v45) = v14;
                  }
                  else {
                    uint64_t v45 = *(void *)(a1 + 208);
                  }
                  goto LABEL_122;
                case 4:
                  if (a3)
                  {
                    if (*((unsigned char *)v9 + 184)) {
                      *((unsigned char *)v9 + 184) = 0;
                    }
                    *((_DWORD *)v9 + 48) = 0;
                    char v99 = raven::RavenSequentialGNSSMeasurementSelector::UpdateITRsForMeasurement((uint64_t **)a1, (uint64_t)(v9 + 2));
                    if (&v162 != (uint64_t **)v9)
                    {
                      int v100 = (uint64_t **)v9[1];
                      if (v100 != &v162)
                      {
                        uint64_t v101 = *v9;
                        *(void *)(v101 + 8) = v100;
                        *(void *)v9[1] = v101;
                        uint64_t v102 = v162;
                        v162[1] = (uint64_t)v9;
                        *unint64_t v9 = (uint64_t)v102;
                        v9[1] = (uint64_t)&v162;
                        --a2[2];
                        int v162 = v9;
                        ++v164;
                      }
                    }
                    if (!cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v99))
                    {
                      LOWORD(__p[0]) = 12;
                      LOBYTE(v161) = 0;
                      uint64_t v103 = v9[3];
                      unsigned int v104 = sub_18E017C64(v9[2]);
                      unsigned int v105 = *(_DWORD *)(v9[3] + 96) - 1;
                      int v106 = "UnknownType";
                      if (v105 <= 4) {
                        int v106 = off_1E55B9E30[v105];
                      }
                      cnprint::CNLogFormatter::FormatGeneral(v14, v103, "#MSR %s %s delaying evaluation", v104, v106);
                      if (*(char *)(a1 + 231) >= 0) {
                        LOBYTE(v45) = v14;
                      }
                      else {
                        uint64_t v45 = *(void *)(a1 + 208);
                      }
                      goto LABEL_122;
                    }
                  }
                  else
                  {
                    raven::RavenSequentialGNSSMeasurementSelector::ComputeReweightedMeasurementVariance(a1, (uint64_t)(v9 + 2));
                    v9[26] = (uint64_t)v119;
                    *((unsigned char *)v9 + 216) = v120;
                    if (!v120)
                    {
                      LOWORD(__p[0]) = 12;
                      LOBYTE(v161) = 4;
                      uint64_t v133 = v9[3];
                      std::string::size_type v134 = sub_18E017C64(v9[2]);
                      unsigned int v135 = *(_DWORD *)(v9[3] + 96) - 1;
                      unsigned __int8 v136 = "UnknownType";
                      if (v135 <= 4) {
                        unsigned __int8 v136 = off_1E55B9E30[v135];
                      }
                      cnprint::CNLogFormatter::FormatGeneral(v14, v133, "#MSR %s %s could not be re-weighted", v134, v136);
                      if (*(char *)(a1 + 231) >= 0) {
                        LOBYTE(v45) = v14;
                      }
                      else {
                        uint64_t v45 = *(void *)(a1 + 208);
                      }
                      goto LABEL_122;
                    }
                    if (!cnprint::CNPrinter::GetLogLevel(v119))
                    {
                      uint64_t v121 = a3;
                      uint64_t v122 = a4;
                      LOWORD(__p[0]) = 12;
                      LOBYTE(v161) = 0;
                      uint64_t v123 = v9[3];
                      uint64_t v124 = sub_18E017C64(v9[2]);
                      unsigned int v125 = *(_DWORD *)(v9[3] + 96) - 1;
                      unsigned int v126 = "UnknownType";
                      if (v125 <= 4) {
                        unsigned int v126 = off_1E55B9E30[v125];
                      }
                      cnprint::CNLogFormatter::FormatGeneral(v14, v123, "#MSR Re-weighting %s measurement from %s", v124, v126);
                      if (*(char *)(a1 + 231) >= 0) {
                        LOBYTE(v132) = v14;
                      }
                      else {
                        uint64_t v132 = *(void *)(a1 + 208);
                      }
                      cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v161, "%s", v127, v128, v129, v130, v131, v132);
                      a4 = v122;
                      a3 = v121;
                    }
LABEL_101:
                    __p[3] = (void *)0x100000008;
                    __p[0] = &unk_1EDD19CC8;
                    *(_OWORD *)&__p[1] = xmmword_18E1FD760;
                    __p[4] = &v159;
                    uint64_t v108 = raven::RavenSequentialGNSSMeasurementSelector::UpdateEstimator(a1, (uint64_t)(v9 + 2));
                    if ((v108 & 1) == 0
                      && cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v108) <= 1)
                    {
                      __int16 v161 = 12;
                      unsigned __int8 v160 = 1;
                      uint64_t v109 = v9[3];
                      uint64_t v110 = sub_18E017C64(v9[2]);
                      unsigned int v111 = *(_DWORD *)(v9[3] + 96) - 1;
                      uint64_t v112 = "UnknownType";
                      if (v111 <= 4) {
                        uint64_t v112 = off_1E55B9E30[v111];
                      }
                      cnprint::CNLogFormatter::FormatGeneral(v14, v109, "#MSR %s %s could not be used to update estimator", v110, v112);
                      if (*(char *)(a1 + 231) >= 0) {
                        LOBYTE(v118) = v14;
                      }
                      else {
                        uint64_t v118 = *(void *)(a1 + 208);
                      }
                      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v161, &v160, "%s", v113, v114, v115, v116, v117, v118);
                    }
                  }
                  break;
                case 5:
                  double v107 = *(float *)(v9[3] + 168);
                  *((double *)v9 + 26) = v107 * v107;
                  *((unsigned char *)v9 + 216) = 1;
                  goto LABEL_101;
                default:
                  goto LABEL_101;
              }
              goto LABEL_123;
            }
            LOWORD(__p[0]) = 12;
            LOBYTE(v161) = 4;
            uint64_t v61 = sub_18E017C64(*v16);
            unsigned int v62 = *(_DWORD *)(v9[3] + 96) - 1;
            long long v63 = "UnknownType";
            if (v62 <= 4) {
              long long v63 = off_1E55B9E30[v62];
            }
            cnprint::CNLogFormatter::FormatGeneral(v14, v13, "#MSR %s %s could not determine MSR threshold", v61, v63);
            if (*(char *)(a1 + 231) >= 0) {
              LOBYTE(v45) = v14;
            }
            else {
              uint64_t v45 = *(void *)(a1 + 208);
            }
            break;
        }
      }
      else
      {
        LOWORD(__p[0]) = 12;
        LOBYTE(v161) = 4;
        double v55 = sub_18E017C64(*v16);
        unsigned int v56 = *(_DWORD *)(v9[3] + 96) - 1;
        unsigned __int8 v57 = "UnknownType";
        if (v56 <= 4) {
          unsigned __int8 v57 = off_1E55B9E30[v56];
        }
        cnprint::CNLogFormatter::FormatGeneral(v14, v13, "#MSR could not compute innovations from %s %s", v55, v57);
        if (*(char *)(a1 + 231) >= 0) {
          LOBYTE(v45) = v14;
        }
        else {
          uint64_t v45 = *(void *)(a1 + 208);
        }
      }
LABEL_122:
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v161, "%s", v40, v41, v42, v43, v44, v45);
      goto LABEL_123;
    }
    if (!cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)ShouldMeasurementBeUsedToUpdateEstimator))
    {
      LOWORD(__p[0]) = 12;
      LOBYTE(v161) = 0;
      uint64_t v46 = sub_18E017C64(*v16);
      unsigned int v47 = *(_DWORD *)(v9[3] + 96) - 1;
      uint64_t v48 = "UnknownType";
      if (v47 <= 4) {
        uint64_t v48 = off_1E55B9E30[v47];
      }
      cnprint::CNLogFormatter::FormatGeneral(v14, v13, "#MSR should not use %s %s", v46, v48);
      if (*(char *)(a1 + 231) >= 0) {
        LOBYTE(v54) = v14;
      }
      else {
        uint64_t v54 = *(void *)(a1 + 208);
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v161, "%s", v49, v50, v51, v52, v53, v54);
    }
    v9[24] = 0x200000002;
LABEL_123:
    unint64_t v9 = v15;
  }
  while (v15 != a2);
  uint64_t v143 = v164;
  if (!v164)
  {
LABEL_144:
    char v148 = 0;
    *(unsigned char *)a4 = 0;
    goto LABEL_145;
  }
  *a4 = (uint64_t)a4;
  a4[1] = (uint64_t)a4;
  uint64_t v145 = v162;
  uint64_t v144 = v163;
  uint64_t v146 = *v163;
  v146[1] = v162[1];
  *(void *)v145[1] = v146;
  unsigned int v147 = (uint64_t *)*a4;
  v147[1] = (uint64_t)v144;
  *uint64_t v144 = v147;
  *a4 = (uint64_t)v145;
  v145[1] = (uint64_t)a4;
  a4[2] = v143;
  uint64_t v164 = 0;
  char v148 = 1;
LABEL_145:
  *((unsigned char *)a4 + 24) = v148;
  return sub_18E068ED0(&v162);
}

void sub_18E17F2F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  sub_18E068ED0((void *)(v32 - 160));
  _Unwind_Resume(a1);
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::ReTestInnovationsAndUpdateEstimator(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  raven::RavenSequentialGNSSMeasurementSelector::TestInnovationsAndUpdateEstimator(a1, a2, 0, v6);
  if (v7) {
    sub_18E068ED0(v6);
  }
  return sub_18E12D688((uint64_t)a3, a3, a2);
}

void raven::RavenSequentialGNSSMeasurementSelector::ResetEpochSpecificMembers(raven::RavenSequentialGNSSMeasurementSelector *this)
{
  *((unsigned char *)this + 1) = 0;
  if (*((unsigned char *)this + 32)) {
    *((unsigned char *)this + 32) = 0;
  }
  *((unsigned char *)this + 40) = 0;
  *((void *)this + 306) = 0x7FF8000000000000;
  *((void *)this + 304) = 0x7FF8000000000000;
  if (*((unsigned char *)this + 80)) {
    *((unsigned char *)this + 80) = 0;
  }
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 22) = 0;
  *((void *)this + 23) = 0x7FF8000000000000;
  *((void *)this + 33) = 0;
  *((void *)this + 34) = 0;
  *((void *)this + 46) = 0;
  *((void *)this + 47) = 0;
  uint64_t v4 = 0x100000008;
  unint64_t v2 = &unk_1EDD19CC8;
  double v5 = &v6;
  long long v3 = xmmword_18E1FD760;
  sub_18DFE2CC8((uint64_t)&v2, 0.0);
  sub_18DFE2F24((uint64_t)this + 912, (uint64_t)&v2);
  *((unsigned char *)this + 1016) = 0;
  *((void *)this + 128) = 0;
  *((void *)this + 129) = 0x3FF0000000000000;
  *((_OWORD *)this + 65) = 0u;
  *((_OWORD *)this + 66) = 0u;
  *((_OWORD *)this + 67) = 0u;
  *((_OWORD *)this + 68) = 0u;
  *((_OWORD *)this + 69) = 0u;
  *((void *)this + 140) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1128) = 0u;
  *(_OWORD *)((char *)this + 1144) = 0u;
  *((void *)this + 145) = 0x3FF0000000000000;
  *((void *)this + 146) = 0;
  *((void *)this + 148) = 0;
  *((void *)this + 147) = 0;
  *((unsigned char *)this + 88) = 1;
  *((void *)this + 305) = 0;
  *((void *)this + 260) = 0;
  *((_DWORD *)this + 522) = 0;
  sub_18E012A10((uint64_t)this + 1200, *((void **)this + 151));
  *((void *)this + 150) = (char *)this + 1208;
  *((void *)this + 152) = 0;
  *((void *)this + 151) = 0;
  *((void *)this + 306) = 0x7FF8000000000000;
  sub_18E012A10((uint64_t)this + 1224, *((void **)this + 154));
  *((void *)this + 153) = (char *)this + 1232;
  *((void *)this + 155) = 0;
  *((void *)this + 154) = 0;
  sub_18E012A10((uint64_t)this + 1248, *((void **)this + 157));
  *((void *)this + 156) = (char *)this + 1256;
  *((void *)this + 158) = 0;
  *((void *)this + 157) = 0;
  *((_OWORD *)this + 80) = 0u;
  *((_OWORD *)this + 81) = 0u;
  *((_OWORD *)this + 82) = 0u;
  *((_OWORD *)this + 83) = 0u;
  sub_18E1839D0((uint64_t)this + 1344);
  sub_18E1839D0((uint64_t)this + 1384);
  sub_18E183A28((uint64_t)this + 1424);
  sub_18E183A28((uint64_t)this + 1464);
  *((_WORD *)this + 752) = 0;
}

void raven::RavenSequentialGNSSMeasurementSelector::Reset(raven::RavenSequentialGNSSMeasurementSelector *this)
{
  if (*((unsigned char *)this + 2192)) {
    *((unsigned char *)this + 2192) = 0;
  }
  if (*((unsigned char *)this + 2416))
  {
    *((void *)this + 289) = &unk_1EDD17478;
    *((unsigned char *)this + 2416) = 0;
  }
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::SelectMeasurements(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  sub_18E068ED0(a3);
  if (*(unsigned char *)(a4 + 8)) {
    *(unsigned char *)(a4 + 8) = 0;
  }
  if (!*(unsigned char *)a1)
  {
    LOWORD(v127) = 12;
    LOBYTE(v124) = 4;
    char v34 = a1 - 48;
    uint64_t v130 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    uint64_t v131 = v35;
    cnprint::CNLogFormatter::FormatGeneral(a1 + 208, (uint64_t)&v130, "#MSR selector not configured");
LABEL_36:
    if (*(char *)(a1 + 231) >= 0) {
      LOBYTE(v42) = v34;
    }
    else {
      uint64_t v42 = *(void *)(a1 + 208);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v127, (unsigned __int8 *)&v124, "%s", v36, v37, v38, v39, v40, v42);
    return 0;
  }
  if (!*(unsigned char *)(a1 + 1))
  {
    LOWORD(v127) = 12;
    LOBYTE(v124) = 4;
    char v34 = a1 - 48;
    uint64_t v130 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    uint64_t v131 = v41;
    cnprint::CNLogFormatter::FormatGeneral(a1 + 208, (uint64_t)&v130, "#MSR selector uninitialized");
    goto LABEL_36;
  }
  uint64_t v8 = *(void *)(a1 + 192);
  int v9 = *(unsigned __int8 *)(v8 + 3753);
  float v10 = *(uint64_t **)(v8 + 64);
  uint64_t v107 = a4;
  if (!v10) {
    goto LABEL_42;
  }
  uint64_t v127 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  uint64_t v128 = *(uint64_t **)&v11;
  *(double *)v17.i64 = v11;
  *(double *)v18.i64 = v11 + (double)v127;
  double v19 = fabs(*(double *)v18.i64);
  if ((unint64_t)(*(void *)&v19 - 0x10000000000000) >> 53 >= 0x3FF
    && (unint64_t)(*(void *)&v19 - 1) >= 0xFFFFFFFFFFFFFLL
    && COERCE__INT64(v11 + (double)v127) != 0)
  {
    LOWORD(v130) = 12;
    LOBYTE(v124) = 4;
    uint64_t v44 = "Cannot find GMAT data capture: Invalid desired time supplied";
LABEL_41:
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v130, (unsigned __int8 *)&v124, v44, v12, v13, v14, v15, v16, v106);
    goto LABEL_42;
  }
  uint64_t v23 = *v10;
  unint64_t v22 = (double *)v10[1];
  if ((double *)*v10 == v22)
  {
    LOWORD(v130) = 12;
    LOBYTE(v124) = 4;
    uint64_t v44 = "Cannot find GMAT data capture: GMAT data capture container is empty";
    goto LABEL_41;
  }
  uint64_t v24 = (double *)v10[3];
  if (v24 != v22)
  {
    BOOL v25 = sub_18DEE4C00(v24, (double *)&v127);
    uint64_t v26 = 3;
    if (v25) {
      uint64_t v26 = 0;
    }
    uint64_t v23 = v10[v26];
    unint64_t v22 = (double *)v10[1];
  }
  if ((double *)v23 != v22)
  {
    for (uint64_t i = v23; ; i += 144)
    {
      uint64_t v28 = CNTimeSpan::operator-(v23, &v127, v18, v17);
      uint64_t v30 = v28;
      uint64_t v130 = v28;
      uint64_t v131 = *(uint64_t **)&v29;
      double v31 = v29;
      if (v28 < 0 || (*(double *)v18.i64 = v29, v29 < 0.0))
      {
        uint64_t v28 = CNTimeSpan::operator-((double *)&v130, v18, v17);
        v18.i64[0] = v32;
        if (v28)
        {
LABEL_24:
          if (v28 < 0) {
            goto LABEL_93;
          }
          goto LABEL_28;
        }
      }
      else if (v28)
      {
        goto LABEL_24;
      }
      if (*(double *)v18.i64 <= 0.5)
      {
LABEL_93:
        double v10[3] = i;
        uint64_t v33 = v23;
        goto LABEL_43;
      }
LABEL_28:
      v23 += 144;
      uint64_t v33 = 0;
      if (v30)
      {
        if (v30 > 0) {
          goto LABEL_43;
        }
      }
      else if (v31 > 0.5)
      {
        goto LABEL_43;
      }
      if ((double *)v23 == v22) {
        goto LABEL_43;
      }
    }
  }
LABEL_42:
  uint64_t v33 = 0;
LABEL_43:
  raven::RavenSequentialGNSSMeasurementSelector::LogEpochHeader(a1, v33);
  uint64_t v130 = (uint64_t)&v130;
  uint64_t v131 = &v130;
  uint64_t v132 = 0;
  uint64_t v127 = (uint64_t)&v127;
  uint64_t v128 = &v127;
  uint64_t v129 = 0;
  raven::RavenSequentialGNSSMeasurementSelector::PrefilterGNSSMeasurementsAsUseOrNotUse((void *)a1, a2, &v130, &v127, v33);
  raven::RavenSequentialGNSSMeasurementSelector::ComputeMeasurementFunctionOutput(a1, (uint64_t)&v130);
  if (!*(unsigned char *)(*(void *)(a1 + 192) + 3818)
    && v129
    && raven::RavenSequentialGNSSMeasurementSelector::ShouldLowPLOSMeasurementsBeConsideredInEstimator(a1, (uint64_t)&v130))
  {
    raven::RavenSequentialGNSSMeasurementSelector::GetUsableLowPLOSMeasurements(a1, (uint64_t)&v127, (uint64_t *)&v124);
    if (v126)
    {
      raven::RavenSequentialGNSSMeasurementSelector::ComputeMeasurementFunctionOutput(a1, (uint64_t)&v124);
      uint64_t v45 = v126;
      if (v126)
      {
        uint64_t v47 = (uint64_t)v124;
        uint64_t v46 = v125;
        uint64_t v48 = *v125;
        *(void *)(v48 + 8) = v124[1];
        **(void **)(v47 + 8) = v48;
        uint64_t v49 = v130;
        *(void *)(v130 + 8) = v46;
        uint64_t *v46 = v49;
        *(void *)(v47 + 8) = &v130;
        uint64_t v130 = v47;
        v132 += v45;
        uint64_t v126 = 0;
      }
    }
    sub_18E068ED0(&v124);
  }
  if (v9) {
    raven::RavenSequentialGNSSMeasurementSelector::ComputeMeasurementFunctionOutput(a1, (uint64_t)&v127);
  }
  raven::RavenSequentialGNSSMeasurementSelector::CheckForAndHandleGrossClockOffsetError(a1, (uint64_t)&v130);
  uint64_t v124 = &v124;
  unsigned int v125 = (uint64_t *)&v124;
  uint64_t v126 = 0;
  uint64_t v121 = &v121;
  uint64_t v122 = (uint64_t *)&v121;
  uint64_t v123 = 0;
  uint64_t v118 = &v118;
  int64x2_t v119 = (uint64_t *)&v118;
  uint64_t v120 = 0;
  uint64_t v115 = &v115;
  uint64_t v116 = (uint64_t *)&v115;
  uint64_t v117 = 0;
  uint64_t v112 = &v112;
  uint64_t v113 = (uint64_t *)&v112;
  uint64_t v114 = 0;
  uint64_t v109 = &v109;
  uint64_t v110 = (uint64_t *)&v109;
  uint64_t v111 = 0;
  uint64_t v50 = v131;
  if (v131 != &v130)
  {
    while (1)
    {
      uint64_t v51 = (uint64_t)(v50 + 2);
      uint64_t v52 = v50[3];
      int v53 = *(unsigned __int8 *)(v52 + 189);
      unsigned int v54 = *(unsigned __int8 *)(v52 + 100);
      if (v54 > 9 || ((1 << v54) & 0x2BB) == 0) {
        break;
      }
      if (!*((unsigned char *)v50 + 200))
      {
        if (v53 != 1 && (v54 != 5 || !*(unsigned char *)(*(void *)(a1 + 192) + 640)))
        {
          *((_WORD *)v50 + 112) = 2;
          long long v63 = sub_18E1838FC(v51);
          uint64_t v64 = (uint64_t)v118;
          *long long v63 = v118;
          v63[1] = &v118;
          *(void *)(v64 + 8) = v63;
          uint64_t v118 = v63;
          int v58 = &v120;
          goto LABEL_66;
        }
LABEL_62:
        *((_WORD *)v50 + 112) = 4;
        int v59 = sub_18E1838FC(v51);
        uint64_t v60 = (uint64_t)v115;
        *int v59 = v115;
        v59[1] = &v115;
        *(void *)(v60 + 8) = v59;
        uint64_t v115 = v59;
        int v58 = &v117;
        goto LABEL_66;
      }
      *((_WORD *)v50 + 112) = 6;
      unsigned int v56 = sub_18E1838FC(v51);
      uint64_t v57 = (uint64_t)v109;
      *unsigned int v56 = v109;
      v56[1] = &v109;
      *(void *)(v57 + 8) = v56;
      uint64_t v109 = v56;
      int v58 = &v111;
LABEL_66:
      ++*v58;
      uint64_t v50 = (uint64_t *)v50[1];
      if (v50 == &v130) {
        goto LABEL_72;
      }
    }
    if (*((unsigned char *)v50 + 200))
    {
      *((_WORD *)v50 + 112) = 5;
      uint64_t v61 = sub_18E1838FC(v51);
      uint64_t v62 = (uint64_t)v112;
      *uint64_t v61 = v112;
      v61[1] = &v112;
      *(void *)(v62 + 8) = v61;
      uint64_t v112 = v61;
      int v58 = &v114;
      goto LABEL_66;
    }
    if (v54 != 10)
    {
      if (v53 == 1)
      {
        *((_WORD *)v50 + 112) = 3;
        unsigned int v65 = sub_18E1838FC(v51);
        uint64_t v66 = (uint64_t)v121;
        *unsigned int v65 = v121;
        v65[1] = &v121;
        *(void *)(v66 + 8) = v65;
        uint64_t v121 = v65;
        int v58 = &v123;
      }
      else
      {
        *((_WORD *)v50 + 112) = 1;
        uint64_t v67 = sub_18E1838FC(v51);
        uint64_t v68 = (uint64_t)v124;
        *uint64_t v67 = v124;
        v67[1] = &v124;
        *(void *)(v68 + 8) = v67;
        uint64_t v124 = v67;
        int v58 = &v126;
      }
      goto LABEL_66;
    }
    goto LABEL_62;
  }
LABEL_72:
  uint64_t v69 = (uint64_t *)operator new(0x20uLL);
  v108[1] = v69 + 4;
  float64x2_t v108[2] = v69 + 4;
  *uint64_t v69 = (uint64_t)&v124;
  v69[1] = (uint64_t)&v118;
  v69[2] = (uint64_t)&v121;
  v69[3] = (uint64_t)&v115;
  v108[0] = v69;
  raven::RavenSequentialGNSSMeasurementSelector::EnsureFirstPseudorangeAprioriInnovationIsAnInlier(a1, v108);
  operator delete(v69);
  raven::RavenSequentialGNSSMeasurementSelector::ProcessMSRDataContainer(a1, (uint64_t *)&v124);
  raven::RavenSequentialGNSSMeasurementSelector::ProcessMSRDataContainer(a1, (uint64_t *)&v118);
  raven::RavenSequentialGNSSMeasurementSelector::ProcessMSRDataContainer(a1, (uint64_t *)&v121);
  raven::RavenSequentialGNSSMeasurementSelector::ProcessMSRDataContainer(a1, (uint64_t *)&v115);
  raven::RavenSequentialGNSSMeasurementSelector::ProcessMSRDataContainer(a1, (uint64_t *)&v112);
  raven::RavenSequentialGNSSMeasurementSelector::ProcessMSRDataContainer(a1, (uint64_t *)&v109);
  uint64_t v70 = v126;
  if (v126)
  {
    uint64_t v72 = (uint64_t)v124;
    uint64_t v71 = v125;
    uint64_t v73 = *v125;
    *(void *)(v73 + 8) = v124[1];
    **(void **)(v72 + 8) = v73;
    uint64_t v74 = *a3;
    *(void *)(v74 + 8) = v71;
    *uint64_t v71 = v74;
    *a3 = v72;
    *(void *)(v72 + 8) = a3;
    a3[2] += v70;
    uint64_t v126 = 0;
  }
  uint64_t v75 = v120;
  if (v120)
  {
    uint64_t v77 = (uint64_t)v118;
    int v76 = v119;
    uint64_t v78 = *v119;
    *(void *)(v78 + 8) = v118[1];
    **(void **)(v77 + 8) = v78;
    uint64_t v79 = *a3;
    *(void *)(v79 + 8) = v76;
    *int v76 = v79;
    *a3 = v77;
    *(void *)(v77 + 8) = a3;
    a3[2] += v75;
    uint64_t v120 = 0;
  }
  uint64_t v80 = v123;
  if (v123)
  {
    uint64_t v82 = (uint64_t)v121;
    int v81 = v122;
    uint64_t v83 = *v122;
    *(void *)(v83 + 8) = v121[1];
    **(void **)(v82 + 8) = v83;
    uint64_t v84 = *a3;
    *(void *)(v84 + 8) = v81;
    *int v81 = v84;
    *a3 = v82;
    *(void *)(v82 + 8) = a3;
    a3[2] += v80;
    uint64_t v123 = 0;
  }
  uint64_t v85 = v117;
  if (v117)
  {
    uint64_t v87 = (uint64_t)v115;
    long long v86 = v116;
    uint64_t v88 = *v116;
    *(void *)(v88 + 8) = v115[1];
    **(void **)(v87 + 8) = v88;
    uint64_t v89 = *a3;
    *(void *)(v89 + 8) = v86;
    *long long v86 = v89;
    *a3 = v87;
    *(void *)(v87 + 8) = a3;
    a3[2] += v85;
    uint64_t v117 = 0;
  }
  uint64_t v90 = v114;
  if (v114)
  {
    uint64_t v92 = (uint64_t)v112;
    uint64_t v91 = v113;
    uint64_t v93 = *v113;
    *(void *)(v93 + 8) = v112[1];
    **(void **)(v92 + 8) = v93;
    uint64_t v94 = *a3;
    *(void *)(v94 + 8) = v91;
    *uint64_t v91 = v94;
    *a3 = v92;
    *(void *)(v92 + 8) = a3;
    a3[2] += v90;
    uint64_t v114 = 0;
  }
  uint64_t v95 = v111;
  if (v111)
  {
    uint64_t v97 = (uint64_t)v109;
    uint64_t v96 = v110;
    uint64_t v98 = *v110;
    *(void *)(v98 + 8) = v109[1];
    **(void **)(v97 + 8) = v98;
    uint64_t v99 = *a3;
    *(void *)(v99 + 8) = v96;
    *uint64_t v96 = v99;
    *a3 = v97;
    *(void *)(v97 + 8) = a3;
    a3[2] += v95;
    uint64_t v111 = 0;
  }
  if (*(unsigned char *)(*(void *)(a1 + 192) + 641))
  {
    int v100 = raven::RavenSequentialGNSSMeasurementSelector::Count_L1_L5_PseudorangesWithSimilarITRAndPostFilter_L1_vs_L5_Measurements((uint64_t **)a1, (uint64_t)a3);
    if (*(unsigned char *)(*(void *)(a1 + 192) + 641)) {
      raven::RavenSequentialGNSSMeasurementSelector::ReduceNumberOfLowPLOSMeasurementsForL5SupportingHardware((uint64_t)v100, (uint64_t)a3);
    }
  }
  if (v9)
  {
    uint64_t v101 = v129;
    if (v129)
    {
      uint64_t v103 = v127;
      uint64_t v102 = v128;
      uint64_t v104 = *v128;
      *(void *)(v104 + 8) = *(void *)(v127 + 8);
      **(void **)(v103 + 8) = v104;
      uint64_t v105 = *a3;
      *(void *)(v105 + 8) = v102;
      *uint64_t v102 = v105;
      *a3 = v103;
      *(void *)(v103 + 8) = a3;
      a3[2] += v101;
      uint64_t v129 = 0;
    }
  }
  raven::RavenSequentialGNSSMeasurementSelector::ComputeHorizontalPositionMisclosureAndHDOP(a1, (uint64_t)a3);
  raven::RavenSequentialGNSSMeasurementSelector::UpdateITRCounts((cnprint::CNPrinter *)a1, (uint64_t)a3);
  if (*(unsigned char *)(a1 + 80))
  {
    *(double *)uint64_t v107 = *(double *)(a1 + 72) * 0.000001;
    *(unsigned char *)(v107 + 8) = 1;
  }
  raven::RavenSequentialGNSSMeasurementSelector::LogMSRData(a1, (uint64_t)a3);
  raven::RavenSequentialGNSSMeasurementSelector::LogEpochFooter(a1, (uint64_t)a3, v33);
  sub_18E068ED0(&v109);
  sub_18E068ED0(&v112);
  sub_18E068ED0(&v115);
  sub_18E068ED0(&v118);
  sub_18E068ED0(&v121);
  sub_18E068ED0(&v124);
  sub_18E068ED0(&v127);
  sub_18E068ED0(&v130);
  return 1;
}

void sub_18E17FF64(_Unwind_Exception *a1)
{
  sub_18E068ED0((void *)(v1 - 176));
  sub_18E068ED0((void *)(v1 - 152));
  sub_18E068ED0((void *)(v1 - 128));
  _Unwind_Resume(a1);
}

BOOL raven::RavenSequentialGNSSMeasurementSelector::ShouldLowPLOSMeasurementsBeConsideredInEstimator(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 192);
  if (!*(unsigned char *)(v2 + 2392) || !*(unsigned char *)(a1 + 1272)) {
    return 0;
  }
  if (!*(unsigned char *)(a1 + 88)) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 2088)) {
    return 0;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 2080);
  if (v4 > 0x14) {
    return 0;
  }
  unsigned int v5 = *(_DWORD *)(a1 + 2084);
  if (v5 > 0x14) {
    return 0;
  }
  BOOL result = 1;
  if (v4 >= 4 && v5 >= 4)
  {
    double v7 = COERCE_DOUBLE(sub_18E180D04(a2, *(double *)(v2 + 2240)));
    return v8 && *(double *)(*(void *)(a1 + 192) + 2448) <= v7;
  }
  return result;
}

uint64_t **raven::RavenSequentialGNSSMeasurementSelector::Count_L1_L5_PseudorangesWithSimilarITRAndPostFilter_L1_vs_L5_Measurements(uint64_t **result, uint64_t a2)
{
  result[305] = 0;
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2 != a2)
  {
    unsigned int v4 = result;
    while (1)
    {
      uint64_t v5 = v2;
      uint64_t v6 = v2 + 16;
      uint64_t v7 = *(void *)(v2 + 16);
      uint64_t v2 = *(void *)(v2 + 8);
      int v8 = *(unsigned __int8 *)(v7 + 24);
      if ((v8 - 3) < 4 || v8 == 1)
      {
        unsigned int v10 = *(_DWORD *)(v5 + 192);
        if (v10 >= 3)
        {
          if (v10 == 3)
          {
            uint64_t v11 = *(void *)(v5 + 24);
            if (*(_DWORD *)(v11 + 96) != 1) {
              goto LABEL_45;
            }
            int v12 = 1;
          }
          else
          {
            uint64_t v11 = *(void *)(v5 + 24);
            int v12 = *(_DWORD *)(v11 + 96);
          }
          unsigned int v13 = *(unsigned __int8 *)(v11 + 100) - 2;
          int v14 = v13 > 8 ? 2 : byte_18E21CC43[(char)v13];
          if (v2 != a2) {
            break;
          }
        }
      }
LABEL_45:
      if (v2 == a2) {
        return result;
      }
    }
    unsigned int v15 = v12 - 2;
    if ((v12 - 2) < 3) {
      int v12 = 2;
    }
    uint64_t v16 = v2;
    while (1)
    {
      unsigned int v17 = *(_DWORD *)(v16 + 192);
      if (v17 < 3 || v17 == 3 && *(_DWORD *)(*(void *)(v16 + 24) + 96) != 1) {
        goto LABEL_44;
      }
      uint64_t v18 = *(void *)(v16 + 16);
      if (*(unsigned __int8 *)(v18 + 24) != v8 || *(_DWORD *)(v18 + 28) != *(_DWORD *)(v7 + 28)) {
        goto LABEL_44;
      }
      uint64_t v19 = *(void *)(v16 + 24);
      int v20 = *(_DWORD *)(v19 + 96);
      BOOL result = (uint64_t **)(v20 - 2);
      if (result < 3) {
        int v20 = 2;
      }
      if (v20 != v12) {
        goto LABEL_44;
      }
      BOOL result = (uint64_t **)*(unsigned __int8 *)(v19 + 100);
      int v21 = 1;
      if (result <= 0xA)
      {
        if (((1 << (char)result) & 0x544) != 0)
        {
          int v21 = 2;
        }
        else if (!*(unsigned char *)(v19 + 100))
        {
          goto LABEL_44;
        }
      }
      if (v21 == v14)
      {
        if (v10 == 3 || v17 == 3)
        {
          if (v10 == 3 && v17 == 3) {
            ++*((_DWORD *)v4 + 611);
          }
        }
        else if ((*(void *)(v11 + 120) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL {
               && *(unsigned char *)(v5 + 160)
        }
               && (*(void *)(v19 + 120) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
               && *(unsigned char *)(v16 + 160))
        {
          unint64_t v22 = v4[24];
          if (v15 >= 3) {
            uint64_t v23 = 264;
          }
          else {
            uint64_t v23 = 265;
          }
          if (*((unsigned char *)v22 + 3793)
            && (double v24 = *(double *)(v11 + 120) - *(double *)(v5 + 48),
                double v25 = *(double *)(v19 + 120) - *(double *)(v16 + 48),
                double v26 = *(double *)&v22[v23],
                vabdd_f64(v25, v24) > v26))
          {
            double v27 = v26 * *((double *)v22 + 266);
            double v28 = fabs(v25);
            double v29 = fabs(v24);
            if (v28 <= v27 && v29 > v26)
            {
              *(void *)(v5 + 192) = 0x700000003;
              goto LABEL_69;
            }
            if (v28 <= v26 || v29 > v27)
            {
              *(void *)(v5 + 192) = 0x700000003;
              *(void *)(v16 + 192) = 0x700000003;
              raven::RavenSequentialGNSSMeasurementSelector::UpdateITRsForMeasurement(v4, v6);
            }
            else
            {
              *(void *)(v16 + 192) = 0x700000003;
            }
LABEL_68:
            uint64_t v6 = v16 + 16;
LABEL_69:
            BOOL result = raven::RavenSequentialGNSSMeasurementSelector::UpdateITRsForMeasurement(v4, v6);
            uint64_t v11 = *(void *)(v5 + 24);
          }
          else if (*((unsigned char *)v22 + 3794) && *(unsigned char *)(v5 + 216) && *(unsigned char *)(v16 + 216))
          {
            double v32 = *(double *)(v16 + 208);
            double v33 = *((double *)v4 + 149);
            double v34 = *(double *)(v5 + 208);
            if (v32 > v33 * v34)
            {
              *(void *)(v16 + 192) = 0x300000002;
              goto LABEL_68;
            }
            if (v34 > v32 * v33)
            {
              *(void *)(v5 + 192) = 0x300000002;
              goto LABEL_69;
            }
          }
          if (*(_DWORD *)(v11 + 96) == 1
            && (*(_DWORD *)(v5 + 192) & 0xFFFFFFFE) == 4
            && (*(_DWORD *)(v16 + 192) & 0xFFFFFFFE) == 4)
          {
            ++*((_DWORD *)v4 + 610);
          }
          goto LABEL_45;
        }
      }
LABEL_44:
      uint64_t v16 = *(void *)(v16 + 8);
      if (v16 == a2) {
        goto LABEL_45;
      }
    }
  }
  return result;
}

void raven::RavenSequentialGNSSMeasurementSelector::ReduceNumberOfLowPLOSMeasurementsForL5SupportingHardware(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2 != a2)
  {
    int v3 = 0;
    int v4 = 0;
    int v5 = 0;
    uint64_t v6 = *(void *)(a2 + 8);
    do
    {
      uint64_t v7 = v6;
      uint64_t v6 = *(void *)(v6 + 8);
      if ((*(_DWORD *)(v7 + 192) & 0xFFFFFFFE) == 4)
      {
        uint64_t v8 = *(void *)(v7 + 24);
        int v9 = *(_DWORD *)(v8 + 96);
        if (*(unsigned char *)(v7 + 200))
        {
          if (v9 == 4) {
            ++v5;
          }
          uint64_t v10 = *(void *)(v7 + 16);
          int v11 = *(unsigned __int8 *)(v10 + 24);
          if ((v11 - 3) < 4 || v11 == 1)
          {
            unsigned int v13 = *(unsigned __int8 *)(v8 + 100);
            int v14 = v13 - 2 > 8 ? 2 : byte_18E21CC43[(char)(v13 - 2)];
            if (v6 != a2)
            {
              if ((v9 - 2) >= 3) {
                int v15 = v9;
              }
              else {
                int v15 = 2;
              }
              if (v9 == 4) {
                int v16 = -1;
              }
              else {
                int v16 = 0;
              }
              uint64_t v17 = v6;
              do
              {
                uint64_t v18 = *(void *)(v17 + 16);
                if (*(unsigned __int8 *)(v18 + 24) == v11
                  && *(_DWORD *)(v18 + 28) == *(_DWORD *)(v10 + 28)
                  && *(unsigned char *)(v17 + 200)
                  && (*(_DWORD *)(v17 + 192) & 0xFFFFFFFE) == 4)
                {
                  uint64_t v19 = *(void *)(v17 + 24);
                  unsigned int v20 = *(unsigned __int8 *)(v19 + 100);
                  int v21 = 1;
                  if (v20 > 0xA) {
                    goto LABEL_33;
                  }
                  if (((1 << v20) & 0x544) != 0)
                  {
                    int v21 = 2;
LABEL_33:
                    if (v21 == v14)
                    {
                      int v22 = *(_DWORD *)(v19 + 96);
                      if ((v22 - 2) < 3) {
                        int v22 = 2;
                      }
                      if (v22 == v15)
                      {
                        if (*(unsigned char *)(v7 + 200) && (v13 > 9 || ((1 << v13) & 0x2BB) == 0))
                        {
                          *(void *)(v17 + 192) = 0x100000002;
                          *(unsigned char *)(v17 + 200) = 0;
                        }
                        else
                        {
                          BOOL v23 = v20 > 9;
                          int v24 = (1 << v20) & 0x2BB;
                          if (v23 || v24 == 0)
                          {
                            *(void *)(v7 + 192) = 0x100000002;
                            *(unsigned char *)(v7 + 200) = 0;
                            v5 += v16;
                          }
                        }
                      }
                    }
                    goto LABEL_47;
                  }
                  if (*(unsigned char *)(v19 + 100)) {
                    goto LABEL_33;
                  }
                }
LABEL_47:
                uint64_t v17 = *(void *)(v17 + 8);
              }
              while (v17 != a2);
            }
          }
        }
        else if (v9 == 1)
        {
          ++v3;
        }
        else
        {
          ++v4;
        }
      }
    }
    while (v6 != a2);
    int v26 = 0;
    int v27 = 0;
    int v28 = 0;
    do
    {
      if (!*(unsigned char *)(v2 + 200) || (*(_DWORD *)(v2 + 192) & 0xFFFFFFFE) != 4) {
        goto LABEL_66;
      }
      int v29 = *(_DWORD *)(*(void *)(v2 + 24) + 96);
      if ((v29 - 2) < 2)
      {
        if ((++v27 + v5) <= 4 && (v27 + v5 + v4) < 0xB) {
          goto LABEL_66;
        }
LABEL_65:
        *(void *)(v2 + 192) = 0x100000002;
        *(unsigned char *)(v2 + 200) = 0;
        goto LABEL_66;
      }
      if (v29 == 4)
      {
        if (++v26 > 4) {
          goto LABEL_65;
        }
        unsigned int v30 = v26 + v4;
      }
      else
      {
        if (v29 != 1) {
          goto LABEL_66;
        }
        if (++v28 > 4) {
          goto LABEL_65;
        }
        unsigned int v30 = v28 + v3;
      }
      if (v30 > 0xA) {
        goto LABEL_65;
      }
LABEL_66:
      uint64_t v2 = *(void *)(v2 + 8);
    }
    while (v2 != a2);
  }
}

void raven::RavenSequentialGNSSMeasurementSelector::UpdateITRCounts(cnprint::CNPrinter *a1, uint64_t a2)
{
  unsigned int v54 = a1;
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == a2) {
    return;
  }
  uint64_t v55 = (uint64_t)a1 + 1424;
  unsigned int v56 = (_DWORD *)((char *)a1 + 1384);
  uint64_t v57 = (uint64_t)a1 + 1464;
  int v58 = (_DWORD *)((char *)a1 + 1344);
  do
  {
    uint64_t v5 = *(void *)(v3 + 24);
    unsigned int v6 = *(unsigned __int8 *)(v5 + 100);
    uint64_t v7 = v58;
    if (v6 <= 0xA)
    {
      if (((1 << v6) & 0x544) != 0)
      {
        uint64_t v7 = v56;
      }
      else
      {
        uint64_t v7 = v58;
        if (!*(unsigned char *)(v5 + 100))
        {
          if (!cnprint::CNPrinter::GetLogLevel(a1))
          {
            LOWORD(v60[0]) = 12;
            unsigned __int8 v59 = 0;
            uint64_t v44 = sub_18E017C64(*(void *)(v3 + 16));
            uint64_t v45 = *(void *)(v3 + 24);
            unsigned int v46 = *(_DWORD *)(v45 + 96) - 1;
            if (v46 > 4) {
              uint64_t v47 = "UnknownType";
            }
            else {
              uint64_t v47 = off_1E55B9E30[v46];
            }
            cnprint::CNLogFormatter::FormatGeneral((uint64_t)v54 + 208, (uint64_t)v54 + 96, "#MSR %s %s unsupported band family, %d", v44, v47, *(unsigned __int8 *)(v45 + 100));
            if (*((char *)v54 + 231) >= 0) {
              LOBYTE(v53) = (_BYTE)v54 - 48;
            }
            else {
              uint64_t v53 = *((void *)v54 + 26);
            }
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)v60, &v59, "%s", v48, v49, v50, v51, v52, v53);
          }
          return;
        }
      }
    }
    if (*(void *)(*(void *)(v3 + 16) + 312))
    {
      uint64_t v8 = sub_18E183A80(v55, *(_DWORD *)(v5 + 96), (_DWORD *)(v5 + 96)) + 3;
      unint64_t v2 = *(unsigned int *)(v3 + 192);
      if (sub_18E183F00(v8, *(_DWORD *)(v3 + 192)))
      {
        int v9 = sub_18E1843C4((uint64_t)v8, v2, (_DWORD *)(v3 + 192));
        ++*((_DWORD *)v9 + 5);
      }
      else
      {
        sub_18E183FB4((uint64_t)v8, v2, v2, 1);
      }
    }
    uint64_t v10 = *(void *)(v3 + 16);
    unint64_t v11 = *(unsigned __int8 *)(v10 + 24);
    unint64_t v12 = *((void *)v7 + 1);
    if (v12)
    {
      uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
      v13.i16[0] = vaddlv_u8(v13);
      if (v13.u32[0] > 1uLL)
      {
        unint64_t v2 = *(unsigned __int8 *)(v10 + 24);
        if (v12 <= v11) {
          unint64_t v2 = v11 % v12;
        }
      }
      else
      {
        unint64_t v2 = (v12 - 1) & v11;
      }
      int v14 = *(uint64_t ***)(*(void *)v7 + 8 * v2);
      if (v14)
      {
        for (uint64_t i = *v14; i; uint64_t i = (uint64_t *)*i)
        {
          unint64_t v16 = i[1];
          if (v16 == v11)
          {
            if (*((unsigned __int8 *)i + 16) == v11) {
              goto LABEL_84;
            }
          }
          else
          {
            if (v13.u32[0] > 1uLL)
            {
              if (v16 >= v12) {
                v16 %= v12;
              }
            }
            else
            {
              v16 &= v12 - 1;
            }
            if (v16 != v2) {
              break;
            }
          }
        }
      }
    }
    uint64_t v17 = v7 + 4;
    uint64_t v18 = (char *)operator new(0x40uLL);
    v60[0] = v18;
    v60[1] = v7 + 4;
    *(void *)uint64_t v18 = 0;
    *((void *)v18 + 1) = v11;
    v18[16] = *(unsigned char *)(v10 + 24);
    *(_OWORD *)(v18 + 40) = 0u;
    *(_OWORD *)(v18 + 24) = 0u;
    *((_DWORD *)v18 + 14) = 1065353216;
    char v61 = 1;
    float v19 = (float)(unint64_t)(*((void *)v7 + 3) + 1);
    float v20 = *((float *)v7 + 8);
    if (v12 && (float)(v20 * (float)v12) >= v19)
    {
      unint64_t v11 = v2;
      goto LABEL_74;
    }
    BOOL v21 = (v12 & (v12 - 1)) != 0;
    if (v12 < 3) {
      BOOL v21 = 1;
    }
    unint64_t v22 = v21 | (2 * v12);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      int8x8_t prime = (int8x8_t)v23;
    }
    else {
      int8x8_t prime = (int8x8_t)v22;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v12 = *((void *)v7 + 1);
    }
    if (*(void *)&prime <= v12)
    {
      if (*(void *)&prime >= v12) {
        goto LABEL_70;
      }
      unint64_t v31 = vcvtps_u32_f32((float)*((unint64_t *)v7 + 3) / *((float *)v7 + 8));
      if (v12 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
      {
        unint64_t v31 = std::__next_prime(v31);
      }
      else
      {
        uint64_t v33 = 1 << -(char)__clz(v31 - 1);
        if (v31 >= 2) {
          unint64_t v31 = v33;
        }
      }
      if (*(void *)&prime <= v31) {
        int8x8_t prime = (int8x8_t)v31;
      }
      if (*(void *)&prime >= v12)
      {
        unint64_t v12 = *((void *)v7 + 1);
        goto LABEL_70;
      }
      if (!*(void *)&prime)
      {
        uint64_t v42 = *(void **)v7;
        *(void *)uint64_t v7 = 0;
        if (v42) {
          operator delete(v42);
        }
        unint64_t v12 = 0;
        *((void *)v7 + 1) = 0;
        goto LABEL_70;
      }
    }
    if (*(void *)&prime >> 61) {
      sub_18DEDF7D4();
    }
    double v25 = operator new(8 * *(void *)&prime);
    int v26 = *(void **)v7;
    *(void *)uint64_t v7 = v25;
    if (v26) {
      operator delete(v26);
    }
    uint64_t v27 = 0;
    *((int8x8_t *)v7 + 1) = prime;
    do
      *(void *)(*(void *)v7 + 8 * v27++) = 0;
    while (*(void *)&prime != v27);
    int v28 = (void *)*v17;
    if (*v17)
    {
      unint64_t v29 = v28[1];
      uint8x8_t v30 = (uint8x8_t)vcnt_s8(prime);
      v30.i16[0] = vaddlv_u8(v30);
      if (v30.u32[0] > 1uLL)
      {
        if (v29 >= *(void *)&prime) {
          v29 %= *(void *)&prime;
        }
      }
      else
      {
        v29 &= *(void *)&prime - 1;
      }
      *(void *)(*(void *)v7 + 8 * v29) = v17;
      double v34 = (void *)*v28;
      if (*v28)
      {
        do
        {
          unint64_t v35 = v34[1];
          if (v30.u32[0] > 1uLL)
          {
            if (v35 >= *(void *)&prime) {
              v35 %= *(void *)&prime;
            }
          }
          else
          {
            v35 &= *(void *)&prime - 1;
          }
          if (v35 != v29)
          {
            if (!*(void *)(*(void *)v7 + 8 * v35))
            {
              *(void *)(*(void *)v7 + 8 * v35) = v28;
              goto LABEL_66;
            }
            *int v28 = *v34;
            *double v34 = **(void **)(*(void *)v7 + 8 * v35);
            **(void **)(*(void *)v7 + 8 * v35) = v34;
            double v34 = v28;
          }
          unint64_t v35 = v29;
LABEL_66:
          int v28 = v34;
          double v34 = (void *)*v34;
          unint64_t v29 = v35;
        }
        while (v34);
      }
    }
    unint64_t v12 = (unint64_t)prime;
LABEL_70:
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v12 <= v11) {
        v11 %= v12;
      }
    }
    else
    {
      unint64_t v11 = (v12 - 1) & v11;
    }
LABEL_74:
    uint64_t v36 = *(void **)(*(void *)v7 + 8 * v11);
    uint64_t i = (uint64_t *)v60[0];
    if (v36)
    {
      *(void *)v60[0] = *v36;
LABEL_82:
      void *v36 = i;
      goto LABEL_83;
    }
    *(void *)v60[0] = *((void *)v7 + 2);
    *((void *)v7 + 2) = i;
    *(void *)(*(void *)v7 + 8 * v11) = v17;
    if (*i)
    {
      unint64_t v37 = *(void *)(*i + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v37 >= v12) {
          v37 %= v12;
        }
      }
      else
      {
        v37 &= v12 - 1;
      }
      uint64_t v36 = (void *)(*(void *)v7 + 8 * v37);
      goto LABEL_82;
    }
LABEL_83:
    v60[0] = 0;
    ++*((void *)v7 + 3);
    sub_18E1845D4((uint64_t)v60);
LABEL_84:
    uint64_t v38 = sub_18E183A80((uint64_t)(i + 3), *(_DWORD *)(*(void *)(v3 + 24) + 96), (_DWORD *)(*(void *)(v3 + 24) + 96))+ 3;
    int v39 = *(_DWORD *)(v3 + 192);
    if (sub_18E183F00(v38, v39))
    {
      uint64_t v40 = sub_18E1843C4((uint64_t)v38, v39, (_DWORD *)(v3 + 192));
      ++*((_DWORD *)v40 + 5);
    }
    else
    {
      sub_18E183FB4((uint64_t)v38, v39, v39, 1);
    }
    uint64_t v41 = sub_18E183A80(v57, *(_DWORD *)(*(void *)(v3 + 24) + 96), (_DWORD *)(*(void *)(v3 + 24) + 96)) + 3;
    unint64_t v2 = *(unsigned int *)(v3 + 192);
    if (sub_18E183F00(v41, *(_DWORD *)(v3 + 192)))
    {
      a1 = (cnprint::CNPrinter *)sub_18E1843C4((uint64_t)v41, v2, (_DWORD *)(v3 + 192));
      ++*((_DWORD *)a1 + 5);
    }
    else
    {
      sub_18E183FB4((uint64_t)v41, v2, v2, 1);
    }
    uint64_t v3 = *(void *)(v3 + 8);
  }
  while (v3 != a2);
}

void sub_18E180C88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_18E1845D4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t **raven::RavenSequentialGNSSMeasurementSelector::UpdateITRsForMeasurement(uint64_t **result, uint64_t a2)
{
  int v2 = *(_DWORD *)(*(void *)(a2 + 8) + 96);
  if ((v2 - 2) >= 3)
  {
    if (v2 != 1) {
      return result;
    }
    uint64_t v4 = a2 + 16;
    int v3 = *(_DWORD *)(a2 + 16);
    int v5 = *(_DWORD *)(v4 + 160);
    unsigned int v6 = result + 153;
  }
  else
  {
    uint64_t v4 = a2 + 16;
    int v3 = *(_DWORD *)(a2 + 16);
    int v5 = *(_DWORD *)(v4 + 160);
    unsigned int v6 = result + 150;
  }
  BOOL result = sub_18E18462C(v6, v3, *(uint64_t **)(v4 + 8), (_OWORD *)v4);
  *((_DWORD *)result + 12) = v5;
  return result;
}

unint64_t sub_18E180D04(uint64_t a1, double a2)
{
  unint64_t v31 = 0;
  uint8x8_t v32 = 0;
  uint64_t v33 = 0;
  v28[0] = 0;
  uint64_t v29 = 0;
  char v30 = 1;
  sub_18E0C5398((char **)&v31);
  char v34 = 1;
  std::string __p = 0;
  double v25 = 0;
  uint64_t v26 = 0;
  v21[0] = 0;
  uint64_t v22 = 0;
  char v23 = 1;
  sub_18E0C5398((char **)&__p);
  char v27 = 1;
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 == a1)
  {
LABEL_22:
    uint64_t v17 = 0;
    unint64_t v16 = 0;
    goto LABEL_24;
  }
  int v5 = 0;
  do
  {
    uint64_t v6 = *(void *)(v4 + 24);
    if (*(_DWORD *)(v6 + 96) == 1)
    {
      uint64_t v7 = *(void *)(v4 + 16);
      if (*(unsigned char *)(v7 + 304))
      {
        double v8 = *(double *)(v7 + 296);
        if (v8 == a2) {
          unsigned __int8 v9 = 0;
        }
        else {
          unsigned __int8 v9 = -127;
        }
        if (v8 > a2) {
          unsigned __int8 v9 = 1;
        }
        if (v8 < a2) {
          unsigned __int8 v9 = -1;
        }
      }
      else
      {
        unsigned __int8 v9 = -1;
      }
      if ((v9 == 129 || (v9 & 0x80) == 0) && (*(_DWORD *)(v4 + 192) & 0xFFFFFFFE) != 2)
      {
        double v20 = *(double *)(v6 + 120) - *(double *)(v4 + 48);
        sub_18E0C4D80((uint64_t)v28, (uint64_t *)&v20, 1.0);
        double v19 = fabs(v20);
        sub_18E0C4D80((uint64_t)v21, (uint64_t *)&v19, 1.0);
        if (++v5 > 9) {
          break;
        }
      }
    }
    uint64_t v4 = *(void *)(v4 + 8);
  }
  while (v4 != a1);
  if (v5)
  {
    if (v5 == 1
      || (sub_18E0C5470((uint64_t)v28, 75.0),
          double v11 = v10,
          sub_18E0C5470((uint64_t)v28, 25.0),
          double v13 = v12,
          sub_18E0C5470((uint64_t)v28, 50.0),
          v11 - v13 > v14 * 0.3))
    {
      sub_18E0C5470((uint64_t)v21, 50.0);
      unint64_t v16 = v15 & 0xFFFFFFFFFFFFFF00;
      uint64_t v17 = v15;
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  uint64_t v17 = 0;
  unint64_t v16 = 0;
LABEL_24:
  if (__p)
  {
    double v25 = __p;
    operator delete(__p);
  }
  if (v31)
  {
    uint8x8_t v32 = v31;
    operator delete(v31);
  }
  return v16 | v17;
}

void sub_18E180F0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22)
{
  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  _Unwind_Resume(exception_object);
}

BOOL raven::RavenSequentialGNSSMeasurementSelector::ShouldMeasurementBeUsedToUpdateEstimator(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(*(void *)(a2 + 8) + 96);
  if ((v4 - 2) >= 3)
  {
    BOOL v11 = v4 == 5 || v4 == 0;
    if (v11 && !cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1))
    {
      __int16 v22 = 12;
      unsigned __int8 v21 = 0;
      double v12 = sub_18E017C64(*(void *)a2);
      cnprint::CNLogFormatter::FormatGeneral(a1 + 208, a1 + 96, "#MSR %s unexpected measurement type %d", v12, *(_DWORD *)(*(void *)(a2 + 8) + 96));
      if (*(char *)(a1 + 231) >= 0) {
        LOBYTE(v18) = a1 - 48;
      }
      else {
        uint64_t v18 = *(void *)(a1 + 208);
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v22, &v21, "%s", v13, v14, v15, v16, v17, v18);
    }
    return 1;
  }
  int v5 = *(_DWORD *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v7 = sub_18E18266C(a1 + 1200, v5, v6);
  if (a1 + 1208 != v7 && (*(_DWORD *)(v7 + 48) & 0xFFFFFFFE) == 4) {
    return 0;
  }
  if (!*(unsigned char *)(a1 + 40)) {
    return 1;
  }
  uint64_t v8 = sub_18E18266C(a1 + 1224, v5, v6);
  if (a1 + 1232 == v8) {
    return 0;
  }
  unsigned int v9 = *(_DWORD *)(v8 + 48);
  if (v9 < 4) {
    return 0;
  }
  if (v9 != 4) {
    return 1;
  }
  uint64_t v19 = sub_18E18266C(a1 + 1248, v5, v6);
  if (a1 + 1256 == v19) {
    double v20 = 999.0;
  }
  else {
    double v20 = fabs(*(double *)(v19 + 48));
  }
  return v20 < *(double *)(*(void *)(a1 + 192) + 1648);
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::StringOfMeasurementCountsByConstellationForFrequency@<X0>(uint64_t a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  sub_18DF06614((uint64_t)&v54);
  int v5 = sub_18DEDD538(&v54, (uint64_t)"#MSR GNSS measurement counts by constellation,", 46);
  int v6 = *(char *)(a1 + 23);
  if (v6 >= 0) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = *(void *)a1;
  }
  if (v6 >= 0) {
    uint64_t v8 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v8 = *(void *)(a1 + 8);
  }
  unsigned int v9 = sub_18DEDD538(v5, v7, v8);
  uint64_t v10 = (uint64_t)sub_18DEDD538(v9, (uint64_t)",(type,used,rejected)", 21);
  BOOL v11 = &byte_18E21CBF8;
  uint64_t v40 = a2;
  do
  {
    int8x8_t v12 = (int8x8_t)a2[1];
    unint64_t v13 = *v11;
    if (v12)
    {
      uint8x8_t v14 = (uint8x8_t)vcnt_s8(v12);
      v14.i16[0] = vaddlv_u8(v14);
      if (v14.u32[0] > 1uLL)
      {
        unint64_t v15 = *v11;
        if (*(void *)&v12 <= v13) {
          unint64_t v15 = v13 % *(void *)&v12;
        }
      }
      else
      {
        unint64_t v15 = (v12.i32[0] - 1) & v13;
      }
      uint64_t v16 = *(uint64_t ***)(*a2 + 8 * v15);
      if (v16)
      {
        for (uint64_t i = *v16; i; uint64_t i = (uint64_t *)*i)
        {
          unint64_t v18 = i[1];
          if (v18 == v13)
          {
            if (*((unsigned __int8 *)i + 16) == v13)
            {
              uint64_t v26 = i + 3;
              LODWORD(__p[0]) = 3;
              int v53 = 5;
              ITRCount = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount(v10, i + 3, (int *)__p, &v53);
              int v51 = 4;
              int v52 = 3;
              int v28 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)ITRCount, v26, &v52, &v51);
              int v49 = 5;
              int v50 = 2;
              uint64_t v29 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v28, v26, &v50, &v49);
              int v48 = 2;
              int v47 = 4;
              char v30 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v29, v26, &v48, &v47);
              int v45 = 5;
              int v46 = 4;
              unint64_t v31 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v30, v26, &v46, &v45);
              int v43 = 4;
              int v44 = 4;
              uint8x8_t v32 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v31, v26, &v44, &v43);
              LODWORD(__p[0]) = 3;
              int v53 = 3;
              uint64_t v33 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v32, v26, (int *)__p, &v53);
              int v51 = 3;
              int v52 = 2;
              char v34 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v33, v26, &v52, &v51);
              int v49 = 3;
              int v50 = 4;
              unint64_t v35 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v34, v26, &v50, &v49);
              LODWORD(__p[0]) = 1;
              int v53 = 5;
              uint64_t v36 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v35, v26, (int *)__p, &v53);
              int v51 = 4;
              int v52 = 1;
              unint64_t v37 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v36, v26, &v52, &v51);
              LODWORD(__p[0]) = 1;
              int v53 = 3;
              raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v37, v26, (int *)__p, &v53);
              a2 = v40;
              break;
            }
          }
          else
          {
            if (v14.u32[0] > 1uLL)
            {
              if (v18 >= *(void *)&v12) {
                v18 %= *(void *)&v12;
              }
            }
            else
            {
              v18 &= *(void *)&v12 - 1;
            }
            if (v18 != v15) {
              break;
            }
          }
        }
      }
    }
    uint64_t v19 = sub_18DEDD538(&v54, (uint64_t)",", 1);
    sub_18DEDE7B0(__p, off_1E55B9DF8[(char)v13]);
    if ((v42 & 0x80u) == 0) {
      double v20 = __p;
    }
    else {
      double v20 = (void **)__p[0];
    }
    if ((v42 & 0x80u) == 0) {
      uint64_t v21 = v42;
    }
    else {
      uint64_t v21 = (uint64_t)__p[1];
    }
    __int16 v22 = sub_18DEDD538(v19, (uint64_t)v20, v21);
    sub_18DEDD538(v22, (uint64_t)",pr,", 4);
    char v23 = (void *)std::ostream::operator<<();
    sub_18DEDD538(v23, (uint64_t)",", 1);
    int v24 = (void *)std::ostream::operator<<();
    sub_18DEDD538(v24, (uint64_t)",dop,", 5);
    double v25 = (void *)std::ostream::operator<<();
    sub_18DEDD538(v25, (uint64_t)",", 1);
    uint64_t v10 = std::ostream::operator<<();
    if ((char)v42 < 0) {
      operator delete(__p[0]);
    }
    ++v11;
  }
  while (v11 != (char *)&unk_18E21CBFD);
  sub_18DEDD9B8((uint64_t)v55, a3);
  uint64_t v54 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v55[-1] + *(void *)(v54 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v55[0] = MEMORY[0x1E4FBA470] + 16;
  if (v56 < 0) {
    operator delete((void *)v55[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x192FA6190](&v57);
}

void sub_18E1815B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void raven::RavenSequentialGNSSMeasurementSelector::StringOfL1MeasurementCountsByConstellation(raven::RavenSequentialGNSSMeasurementSelector *this@<X0>, void *a2@<X8>)
{
  sub_18DEDE7B0(__p, "L1");
  raven::RavenSequentialGNSSMeasurementSelector::StringOfMeasurementCountsByConstellationForFrequency((uint64_t)__p, (void *)this + 168, a2);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_18E181670(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *raven::RavenSequentialGNSSMeasurementSelector::GetITRCountForAllBandsAllConstellations(uint64_t a1, int *a2, int *a3)
{
  return raven::RavenSequentialGNSSMeasurementSelector::GetITRCount(a1, (void *)(a1 + 1464), a2, a3);
}

void raven::RavenSequentialGNSSMeasurementSelector::StringOfL5MeasurementCountsByConstellation(raven::RavenSequentialGNSSMeasurementSelector *this@<X0>, void *a2@<X8>)
{
  sub_18DEDE7B0(__p, "L5");
  raven::RavenSequentialGNSSMeasurementSelector::StringOfMeasurementCountsByConstellationForFrequency((uint64_t)__p, (void *)this + 173, a2);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_18E1816F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::StringOfOverallMeasurementSelectionCountsForRayTracedMeasurements@<X0>(raven::RavenSequentialGNSSMeasurementSelector *this@<X0>, void *a2@<X8>)
{
  sub_18DF06614((uint64_t)&v27);
  sub_18DEDD538(&v27, (uint64_t)"#MSR ray traced GNSS measurement counts (accept,reject,reweight)", 64);
  int v26 = 1;
  int v4 = sub_18DEDD538(&v27, (uint64_t)",psr,", 5);
  this = (raven::RavenSequentialGNSSMeasurementSelector *)((char *)this + 1424);
  int v25 = 5;
  raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v4, this, &v26, &v25);
  char v5 = (void *)std::ostream::operator<<();
  int v6 = sub_18DEDD538(v5, (uint64_t)",", 1);
  int v24 = 3;
  raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v6, this, &v26, &v24);
  uint64_t v7 = (void *)std::ostream::operator<<();
  uint64_t v8 = sub_18DEDD538(v7, (uint64_t)",", 1);
  int v23 = 4;
  raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v8, this, &v26, &v23);
  uint64_t v9 = std::ostream::operator<<();
  int v25 = 5;
  int v26 = 3;
  ITRCount = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount(v9, this, &v26, &v25);
  int v23 = 5;
  int v24 = 4;
  BOOL v11 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)ITRCount, this, &v24, &v23);
  int v25 = 3;
  int v26 = 3;
  int8x8_t v12 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v11, this, &v26, &v25);
  int v23 = 3;
  int v24 = 4;
  unint64_t v13 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v12, this, &v24, &v23);
  int v25 = 4;
  int v26 = 3;
  uint8x8_t v14 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v13, this, &v26, &v25);
  int v23 = 4;
  int v24 = 4;
  raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v14, this, &v24, &v23);
  sub_18DEDD538(&v27, (uint64_t)",avg_doppler,", 13);
  unint64_t v15 = (void *)std::ostream::operator<<();
  sub_18DEDD538(v15, (uint64_t)",", 1);
  uint64_t v16 = (void *)std::ostream::operator<<();
  sub_18DEDD538(v16, (uint64_t)",", 1);
  std::ostream::operator<<();
  int v26 = 2;
  uint64_t v17 = sub_18DEDD538(&v27, (uint64_t)",inst_doppler,", 14);
  int v25 = 5;
  raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v17, this, &v26, &v25);
  unint64_t v18 = (void *)std::ostream::operator<<();
  uint64_t v19 = sub_18DEDD538(v18, (uint64_t)",", 1);
  int v24 = 3;
  raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v19, this, &v26, &v24);
  double v20 = (void *)std::ostream::operator<<();
  uint64_t v21 = sub_18DEDD538(v20, (uint64_t)",", 1);
  int v23 = 4;
  raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v21, this, &v26, &v23);
  std::ostream::operator<<();
  sub_18DEDD9B8((uint64_t)v28, a2);
  uint64_t v27 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v28[-1] + *(void *)(v27 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v28[0] = MEMORY[0x1E4FBA470] + 16;
  if (v29 < 0) {
    operator delete((void *)v28[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x192FA6190](&v30);
}

void sub_18E181AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_18DF067AC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::StringOfOverallMeasurementSelectionCounts@<X0>(raven::RavenSequentialGNSSMeasurementSelector *this@<X0>, void *a2@<X8>)
{
  sub_18DF06614((uint64_t)&v27);
  sub_18DEDD538(&v27, (uint64_t)"#MSR Overall GNSS measurement counts (accept,reject,reweight)", 61);
  int v26 = 1;
  int v4 = sub_18DEDD538(&v27, (uint64_t)",psr,", 5);
  this = (raven::RavenSequentialGNSSMeasurementSelector *)((char *)this + 1464);
  int v25 = 5;
  raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v4, this, &v26, &v25);
  char v5 = (void *)std::ostream::operator<<();
  int v6 = sub_18DEDD538(v5, (uint64_t)",", 1);
  int v24 = 3;
  raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v6, this, &v26, &v24);
  uint64_t v7 = (void *)std::ostream::operator<<();
  uint64_t v8 = sub_18DEDD538(v7, (uint64_t)",", 1);
  int v23 = 4;
  raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v8, this, &v26, &v23);
  uint64_t v9 = std::ostream::operator<<();
  int v25 = 5;
  int v26 = 3;
  ITRCount = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount(v9, this, &v26, &v25);
  int v23 = 5;
  int v24 = 4;
  BOOL v11 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)ITRCount, this, &v24, &v23);
  int v25 = 3;
  int v26 = 3;
  int8x8_t v12 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v11, this, &v26, &v25);
  int v23 = 3;
  int v24 = 4;
  unint64_t v13 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v12, this, &v24, &v23);
  int v25 = 4;
  int v26 = 3;
  uint8x8_t v14 = raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v13, this, &v26, &v25);
  int v23 = 4;
  int v24 = 4;
  raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v14, this, &v24, &v23);
  sub_18DEDD538(&v27, (uint64_t)",avg_doppler,", 13);
  unint64_t v15 = (void *)std::ostream::operator<<();
  sub_18DEDD538(v15, (uint64_t)",", 1);
  uint64_t v16 = (void *)std::ostream::operator<<();
  sub_18DEDD538(v16, (uint64_t)",", 1);
  std::ostream::operator<<();
  int v26 = 2;
  uint64_t v17 = sub_18DEDD538(&v27, (uint64_t)",inst_doppler,", 14);
  int v25 = 5;
  raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v17, this, &v26, &v25);
  unint64_t v18 = (void *)std::ostream::operator<<();
  uint64_t v19 = sub_18DEDD538(v18, (uint64_t)",", 1);
  int v24 = 3;
  raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v19, this, &v26, &v24);
  double v20 = (void *)std::ostream::operator<<();
  uint64_t v21 = sub_18DEDD538(v20, (uint64_t)",", 1);
  int v23 = 4;
  raven::RavenSequentialGNSSMeasurementSelector::GetITRCount((uint64_t)v21, this, &v26, &v23);
  std::ostream::operator<<();
  sub_18DEDD9B8((uint64_t)v28, a2);
  uint64_t v27 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v28[-1] + *(void *)(v27 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v28[0] = MEMORY[0x1E4FBA470] + 16;
  if (v29 < 0) {
    operator delete((void *)v28[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x192FA6190](&v30);
}

void sub_18E181EDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_18DF067AC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *raven::RavenSequentialGNSSMeasurementSelector::UpdateTIVsForMeasurement(uint64_t *result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 168) && *(_DWORD *)(*(void *)(a2 + 8) + 96) == 1)
  {
    int v2 = result;
    int v4 = (_OWORD *)(a2 + 16);
    int v3 = *(_DWORD *)(a2 + 16);
    char v5 = *(uint64_t **)(a2 + 152);
    int v6 = (uint64_t *)result[157];
    if (v6)
    {
      uint64_t v7 = *(uint64_t **)(a2 + 24);
      while (1)
      {
        while (1)
        {
          uint64_t v8 = (uint64_t **)v6;
          int v9 = *((_DWORD *)v6 + 8);
          uint64_t v10 = v8[5];
          BOOL v11 = (uint64_t)v10 > (uint64_t)v7;
          if (v9 != v3) {
            BOOL v11 = v9 > v3;
          }
          if (!v11) {
            break;
          }
          int v6 = *v8;
          int8x8_t v12 = v8;
          if (!*v8) {
            goto LABEL_16;
          }
        }
        BOOL v13 = (uint64_t)v10 < (uint64_t)v7;
        BOOL v14 = v9 == v3;
        BOOL v15 = v9 < v3;
        if (v14) {
          BOOL v15 = v13;
        }
        if (!v15) {
          break;
        }
        int v6 = v8[1];
        if (!v6)
        {
          int8x8_t v12 = v8 + 1;
          goto LABEL_16;
        }
      }
    }
    else
    {
      int8x8_t v12 = (uint64_t **)(result + 157);
      uint64_t v8 = (uint64_t **)(result + 157);
LABEL_16:
      uint64_t v16 = (uint64_t *)v8;
      uint64_t v8 = (uint64_t **)operator new(0x38uLL);
      *((_OWORD *)v8 + 2) = *v4;
      v8[6] = 0;
      *uint64_t v8 = 0;
      v8[1] = 0;
      v8[2] = v16;
      *int8x8_t v12 = (uint64_t *)v8;
      uint64_t v17 = *(void *)v2[156];
      unint64_t v18 = (uint64_t *)v8;
      if (v17)
      {
        v2[156] = v17;
        unint64_t v18 = *v12;
      }
      BOOL result = sub_18DEEDADC((uint64_t *)v2[157], v18);
      ++v2[158];
    }
    v8[6] = v5;
  }
  return result;
}

uint64_t raven::RavenSequentialGNSSMeasurementSelector::UpdateEstimator(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 144))
  {
    LOWORD(v44) = 12;
    LOBYTE(v39) = 4;
    uint64_t v21 = a1 + 208;
    uint64_t v22 = a1 + 96;
    sub_18E017C64(*(void *)a2);
    cnprint::CNLogFormatter::FormatGeneral(v21, v22, "#MSR %s %s h-function data missing at update");
LABEL_13:
    if (*(char *)(a1 + 231) >= 0) {
      LOBYTE(v30) = v21;
    }
    else {
      uint64_t v30 = *(void *)(a1 + 208);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v44, (unsigned __int8 *)&v39, "%s", v24, v25, v26, v27, v28, v30);
    return 0;
  }
  if (!*(unsigned char *)(a2 + 168))
  {
    LOWORD(v44) = 12;
    LOBYTE(v39) = 4;
    uint64_t v21 = a1 + 208;
    uint64_t v23 = a1 + 96;
    sub_18E017C64(*(void *)a2);
    cnprint::CNLogFormatter::FormatGeneral(v21, v23, "#MSR %s %s innovation data missing at update");
    goto LABEL_13;
  }
  if (!*(unsigned char *)(a2 + 200))
  {
    LOWORD(v44) = 12;
    LOBYTE(v39) = 4;
    uint64_t v21 = a1 + 208;
    uint64_t v29 = a1 + 96;
    sub_18E017C64(*(void *)a2);
    cnprint::CNLogFormatter::FormatGeneral(v21, v29, "#MSR %s %s recommended variance missing at update");
    goto LABEL_13;
  }
  double v4 = *(double *)(a2 + 160);
  double v5 = *(double *)(a2 + 192);
  unsigned int v7 = *(_DWORD *)(a2 + 48);
  unsigned int v6 = *(_DWORD *)(a2 + 52);
  uint64_t v46 = 0x100000008;
  int v44 = &unk_1EDD19CC8;
  *(void *)&long long v45 = __PAIR64__(v7, v6);
  DWORD2(v45) = v7 * v6;
  HIDWORD(v45) = v6;
  int v47 = v48;
  sub_18DFE2C64(a2 + 40, (uint64_t)&v44);
  uint64_t v61 = 0x100000008;
  long long v60 = xmmword_18E1FD760;
  unsigned __int8 v59 = &unk_1EDD19CC8;
  uint64_t v62 = &v63;
  sub_18DFE2B44(a1 + 360, (uint64_t)&v44, (uint64_t)&v59);
  uint64_t v56 = 0x100000008;
  long long v55 = xmmword_18E1FD760;
  uint64_t v54 = &unk_1EDD19CC8;
  uint64_t v57 = &v58;
  v8.f64[0] = 1.0 / (v4 + v5);
  float64x2_t v9 = sub_18E06E238((uint64_t)&v59, (uint64_t)&v54, v8);
  v9.f64[0] = *(float64_t *)(a2 + 152);
  uint64_t v51 = 0x100000008;
  long long v50 = xmmword_18E1FD760;
  int v49 = &unk_1EDD19CC8;
  int v52 = &v53;
  sub_18E06E238((uint64_t)&v54, (uint64_t)&v49, v9);
  uint64_t v46 = 0x100000008;
  long long v45 = xmmword_18E1FD760;
  int v44 = &unk_1EDD19CC8;
  int v47 = v48;
  sub_18DFEF1F4(a1 + 256, (uint64_t)&v49, (uint64_t)&v44);
  sub_18DFE2F24(a1 + 256, (uint64_t)&v44);
  int v11 = v60;
  int v10 = DWORD1(v60);
  uint64_t v36 = 0x800000001;
  unint64_t v31 = &unk_1EDD18408;
  unint64_t v37 = v38;
  int v32 = DWORD1(v60);
  int v33 = v60;
  int v34 = v60 * DWORD1(v60);
  int v35 = DWORD1(v60);
  if (DWORD1(v60))
  {
    int v12 = 0;
    int v13 = 0;
    int v14 = HIDWORD(v60);
    BOOL v15 = v62;
    do
    {
      int v16 = v12;
      int v17 = v13;
      for (int i = v11; i; --i)
      {
        v38[v17] = v15[v16];
        v17 += v10;
        ++v16;
      }
      ++v13;
      v12 += v14;
    }
    while (v13 != v10);
  }
  uint64_t v41 = 0x800000008;
  int v39 = &unk_1EDD19DE8;
  long long v40 = xmmword_18E1FD750;
  unsigned __int8 v42 = &v43;
  sub_18DFE2B44((uint64_t)&v54, (uint64_t)&v31, (uint64_t)&v39);
  uint64_t v46 = 0x800000008;
  long long v45 = xmmword_18E1FD750;
  int v44 = &unk_1EDD19DE8;
  int v47 = v48;
  sub_18DFE2AA8(a1 + 360, (uint64_t)&v39, (uint64_t)&v44);
  sub_18DFE2F24(a1 + 360, (uint64_t)&v44);
  uint64_t v19 = a1 + 912;
  uint64_t v46 = 0x100000008;
  long long v45 = xmmword_18E1FD760;
  int v44 = &unk_1EDD19CC8;
  int v47 = v48;
  sub_18DFEF1F4(v19, (uint64_t)&v49, (uint64_t)&v44);
  sub_18DFE2F24(v19, (uint64_t)&v44);
  return 1;
}

__n128 sub_18E18251C(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0x800000001;
  *(void *)(a1 + 24) = 0x800000001;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EDD18408;
  if (a1 == a2)
  {
    int v17 = "this != &(A)";
    int v18 = 603;
    goto LABEL_16;
  }
  int v3 = *(_DWORD *)(a2 + 8);
  int v4 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = (v4 * v3);
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  unsigned int v6 = (unint64_t *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 1u)
  {
    int v17 = "this->max_num_rows_ >= A.num_rows_";
    int v18 = 616;
    goto LABEL_16;
  }
  if (*(_DWORD *)(a2 + 12) >= 9u)
  {
    int v17 = "this->max_num_cols_ >= A.num_cols_";
    int v18 = 617;
LABEL_16:
    __assert_rtn("CNMatrix", "cnmatrix.h", v18, v17);
  }
  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    int v11 = *(long long **)(a2 + 32);
    uint64_t v12 = (v7 - 1) >> 1;
    int v13 = v11;
    int v14 = (_OWORD *)(a1 + 40);
    do
    {
      long long v15 = *v13++;
      *v14++ = v15;
      --v12;
    }
    while (v12);
    uint64_t v16 = v10;
    __n128 result = *(__n128 *)((char *)v11 + v16 * 8);
    *(__n128 *)&v6[v16] = result;
  }
  else if ((int)v5 >= 1)
  {
    float64x2_t v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *v6++ = v9;
      --v5;
    }
    while (v5);
  }
  return result;
}

void sub_18E18264C(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

uint64_t sub_18E18266C(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v3 = a1 + 8;
  uint64_t v4 = v5;
  if (!v5) {
    return v3;
  }
  uint64_t v6 = v3;
  do
  {
    int v7 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v7 == a2;
    BOOL v8 = v7 < a2;
    if (v9) {
      BOOL v8 = *(void *)(v4 + 40) < a3;
    }
    BOOL v9 = !v8;
    if (v8) {
      uint64_t v10 = (uint64_t *)(v4 + 8);
    }
    else {
      uint64_t v10 = (uint64_t *)v4;
    }
    if (v9) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v10;
  }
  while (*v10);
  if (v6 == v3) {
    return v3;
  }
  int v11 = *(_DWORD *)(v6 + 32);
  BOOL v9 = v11 == a2;
  BOOL v12 = v11 > a2;
  if (v9) {
    BOOL v12 = *(void *)(v6 + 40) > a3;
  }
  if (v12) {
    return v3;
  }
  return v6;
}

uint64_t sub_18E1826E4(uint64_t *a1, uint64_t a2, double *a3, float64x2_t *a4, uint64_t a5, int8x16_t a6, int8x16_t a7)
{
  uint64_t v11 = a1[1];
  uint64_t v12 = CNTimeSpan::operator-(a2, (void *)(v11 + 88), a6, a7);
  double v14 = v13;
  long long v15 = *(long long **)(*a1 + 32);
  long long v122 = *v15;
  uint64_t v123 = *((void *)v15 + 2);
  double v16 = *((double *)v15 + 6);
  *(void *)&long long v64 = 0x800000008;
  uint64_t v62 = &unk_1EDD19DE8;
  *((void *)&v64 + 1) = &v65;
  long long v63 = xmmword_18E1FD750;
  sub_18DFE2CC8((uint64_t)&v62, 0.0);
  int v17 = 0;
  int v18 = HIDWORD(v63) + 1;
  uint64_t v19 = 8;
  uint64_t v20 = *((void *)&v64 + 1);
  do
  {
    *(void *)(v20 + 8 * v17) = 0x3FF0000000000000;
    v17 += v18;
    --v19;
  }
  while (v19);
  double v21 = v14 + (double)v12;
  __n128 v22 = sub_18DFE2F24(a5, (uint64_t)&v62);
  v23.i64[0] = 0x3F50624DD2F1A9FCLL;
  if (fabs(v21) > 0.001)
  {
    double v121 = v14 + (double)v12;
    *(void *)&long long v65 = 0x700000006;
    uint64_t v118 = 0x100000008;
    uint64_t v116 = &unk_1EDD19CF8;
    long long v117 = xmmword_18E1FD1A0;
    int64x2_t v119 = &v120;
    uint64_t v120 = 0x700000006;
    uint64_t v113 = 0x100000008;
    uint64_t v111 = &unk_1EDD19CC8;
    uint64_t v114 = &v115;
    long long v112 = xmmword_18E1FD1A0;
    sub_18DFE2CC8((uint64_t)&v111, 0.0);
    uint64_t v108 = 0x100000008;
    long long v107 = xmmword_18E1FD760;
    char v106 = &unk_1EDD19CC8;
    uint64_t v109 = (double *)&v110;
    uint64_t v103 = 0x800000008;
    uint64_t v101 = &unk_1EDD19DE8;
    long long v102 = xmmword_18E1FD750;
    uint64_t v104 = &v105;
    uint64_t v98 = 0x800000008;
    uint64_t v96 = &unk_1EDD19DE8;
    long long v97 = xmmword_18E1FD750;
    uint64_t v99 = &v100;
    sub_18E074D00(*a1, (uint64_t)&v116, (uint64_t)&v62);
    uint64_t v26 = (cnprint::CNPrinter *)sub_18E03E8E0((uint64_t)&v62, (uint64_t)&v111, (uint64_t *)&v121, (uint64_t)&v106, (uint64_t)&v101, (uint64_t)&v96, v24, v25);
    if (v26)
    {
      if (cnprint::CNPrinter::GetLogLevel(v26) <= 1)
      {
        LOWORD(v62) = 12;
        LOBYTE(v74) = 1;
        uint64_t v28 = *(void *)(v11 + 88);
        double v27 = *(double *)(v11 + 96);
        sub_18E017C64(a1[1] + 56);
        double v60 = v27 + (double)v28;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v62, (unsigned __int8 *)&v74, "t,%.3lf,%s,f_TwoStateOscillator failed", v29, v30, v31, v32, v33, SLOBYTE(v60));
      }
      return 0xFFFFFFFFLL;
    }
    uint64_t v34 = 0;
    double v95 = v14 + (double)v12;
    do
    {
      *((_DWORD *)&v65 + v34) = v34;
      ++v34;
    }
    while (v34 != 6);
    uint64_t v91 = 0x100000008;
    uint64_t v89 = &unk_1EDD19CF8;
    uint64_t v92 = &v93;
    long long v90 = xmmword_18E1FD770;
    long long v93 = v65;
    uint64_t v94 = v66;
    uint64_t v86 = 0x100000008;
    uint64_t v84 = &unk_1EDD19CC8;
    uint64_t v87 = &v88;
    long long v85 = xmmword_18E1FD770;
    sub_18DFE2CC8((uint64_t)&v84, 0.0);
    uint64_t v81 = 0x100000008;
    long long v80 = xmmword_18E1FD760;
    uint64_t v79 = &unk_1EDD19CC8;
    uint64_t v82 = &v83;
    uint64_t v76 = 0x800000008;
    uint64_t v74 = &unk_1EDD19DE8;
    long long v75 = xmmword_18E1FD750;
    uint64_t v77 = &v78;
    uint64_t v71 = 0x800000008;
    uint64_t v69 = &unk_1EDD19DE8;
    long long v70 = xmmword_18E1FD750;
    uint64_t v72 = &v73;
    sub_18E074D00(*a1, (uint64_t)&v89, (uint64_t)&v62);
    unint64_t v37 = (cnprint::CNPrinter *)sub_18E03E654((uint64_t)&v62, (uint64_t)&v84, (uint64_t *)&v95, (uint64_t)&v79, (uint64_t)&v74, (uint64_t)&v69, v35, v36);
    if (v37)
    {
      if (cnprint::CNPrinter::GetLogLevel(v37) <= 1)
      {
        LOWORD(v62) = 12;
        unsigned __int8 v68 = 1;
        uint64_t v38 = *(void *)(v11 + 88);
        double v39 = *(double *)(v11 + 96);
        sub_18E017C64(a1[1] + 56);
        double v61 = v39 + (double)v38;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v62, &v68, "t,%.3lf,%s,f_SixStateNearlyConstantVelocity failed", v40, v41, v42, v43, v44, SLOBYTE(v61));
      }
      return 0xFFFFFFFFLL;
    }
    uint64_t v45 = v82[2];
    long long v122 = *(_OWORD *)v82;
    uint64_t v123 = v45;
    double v16 = *v109;
    sub_18E075B48((uint64_t)&v62, a5, (uint64_t)&v89, (uint64_t)&v89);
    sub_18E074E1C((uint64_t)&v62, (uint64_t)&v74);
    sub_18E075B48((uint64_t)&v62, a5, (uint64_t)&v116, (uint64_t)&v116);
    sub_18E074E1C((uint64_t)&v62, (uint64_t)&v101);
  }
  uint64_t v46 = a1[1];
  uint64_t v62 = 0;
  *(void *)&long long v63 = 0;
  v22.n128_f64[0] = v21;
  CNTimeSpan::SetTimeSpan((uint64_t *)&v62, 0, (int8x16_t)v22, v23);
  uint64_t v101 = (void *)CNTimeSpan::operator+(v46 + 136, &v62, v47, v48);
  *(void *)&long long v102 = v49;
  v50.i64[0] = *(void *)(v46 + 192);
  *(double *)v51.i64 = v16 * 0.000001;
  uint64_t v96 = &unk_1EDD0ADE8;
  uint64_t v74 = &unk_1EDD0AE20;
  LOWORD(v62) = 0;
  long long v63 = 0u;
  long long v64 = 0u;
  LODWORD(v65) = 0;
  *((void *)&v65 + 1) = 0;
  uint64_t v66 = 0;
  int v67 = 0;
  uint64_t result = cnnavigation::GNSSCarrierPhase((uint64_t)&v101, (uint64_t)&v62, (uint64_t)&v122, v46 + 296, (uint64_t *)&v96, (uint64_t *)&v74, a3, 1, v50, v51, 0.0, a4);
  if (!result) {
    return result;
  }
  if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)result) <= 1)
  {
    LOWORD(v62) = 12;
    LOBYTE(v96) = 1;
    uint64_t v53 = a1[1];
    double v54 = *(double *)(v53 + 96) + (double)*(uint64_t *)(v53 + 88);
    sub_18E017C64(v53 + 56);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v62, (unsigned __int8 *)&v96, "t,%.3lf,%s,GNSSCarrierPhase,start,returned != 0", v55, v56, v57, v58, v59, SLOBYTE(v54));
  }
  return 0xFFFFFFFFLL;
}

double sub_18E182D4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v9 = operator new(0xF0uLL);
  *BOOL v9 = a2;
  v9[1] = a3;
  double result = *(double *)(a5 + 104) + 0.5;
  v9[2] = a4;
  v9[3] = a5;
  *((_DWORD *)v9 + 8) = *(_DWORD *)(a4 + 28) + 1000 * *(unsigned __int8 *)(a4 + 24);
  v9[5] = (uint64_t)result;
  *((unsigned char *)v9 + 48) = 0;
  *((unsigned char *)v9 + 160) = 0;
  *((unsigned char *)v9 + 168) = 0;
  *((unsigned char *)v9 + 184) = 0;
  *((unsigned char *)v9 + 208) = 0;
  *((unsigned char *)v9 + 216) = 0;
  *((_DWORD *)v9 + 56) = 0;
  v9[29] = 0;
  v9[24] = 0;
  *((unsigned char *)v9 + 200) = 0;
  return result;
}

uint64_t *sub_18E182DE0(void *a1, int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v2 - 1) & v3;
  }
  uint64_t v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (double result = *v6; result; double result = (uint64_t *)*result)
  {
    unint64_t v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_18E182E94(uint64_t a1)
{
  int8x8_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      sub_18E068ED0(v2 + 3);
      operator delete(v2);
      int8x8_t v2 = v3;
    }
    while (v3);
  }
  uint8x8_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_18E182EF4(uint64_t a1)
{
  int8x8_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = *v2;
      sub_18DF064FC(v2[4]);
      operator delete(v2);
      int8x8_t v2 = (void **)v3;
    }
    while (v3);
  }
  uint8x8_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t *sub_18E182F54(uint64_t a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    BOOL v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (int i = *v9; i; int i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t v12 = (void *)(a1 + 16);
  double v13 = operator new(0x30uLL);
  v35[0] = v13;
  v35[1] = a1 + 16;
  *double v13 = 0;
  v13[1] = v6;
  *((_DWORD *)v13 + 4) = *a3;
  v13[3] = v13 + 3;
  v13[4] = v13 + 3;
  v13[5] = 0;
  char v36 = 1;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      int8x8_t prime = (int8x8_t)v18;
    }
    else {
      int8x8_t prime = (int8x8_t)v17;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }
      else
      {
        uint64_t v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }
      if (*(void *)&prime <= v26) {
        int8x8_t prime = (int8x8_t)v26;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = *(void *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            sub_18DEDF7D4();
          }
          uint64_t v20 = operator new(8 * *(void *)&prime);
          double v21 = *(void **)a1;
          *(void *)a1 = v20;
          if (v21) {
            operator delete(v21);
          }
          uint64_t v22 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v22++) = 0;
          while (*(void *)&prime != v22);
          int8x16_t v23 = (void *)*v12;
          if (*v12)
          {
            unint64_t v24 = v23[1];
            uint8x8_t v25 = (uint8x8_t)vcnt_s8(prime);
            v25.i16[0] = vaddlv_u8(v25);
            if (v25.u32[0] > 1uLL)
            {
              if (v24 >= *(void *)&prime) {
                v24 %= *(void *)&prime;
              }
            }
            else
            {
              v24 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v24) = v12;
            uint64_t v29 = (void *)*v23;
            if (*v23)
            {
              do
              {
                unint64_t v30 = v29[1];
                if (v25.u32[0] > 1uLL)
                {
                  if (v30 >= *(void *)&prime) {
                    v30 %= *(void *)&prime;
                  }
                }
                else
                {
                  v30 &= *(void *)&prime - 1;
                }
                if (v30 != v24)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v30))
                  {
                    *(void *)(*(void *)a1 + 8 * v30) = v23;
                    goto LABEL_55;
                  }
                  *int8x16_t v23 = *v29;
                  *uint64_t v29 = **(void **)(*(void *)a1 + 8 * v30);
                  **(void **)(*(void *)a1 + 8 * v30) = v29;
                  uint64_t v29 = v23;
                }
                unint64_t v30 = v24;
LABEL_55:
                int8x16_t v23 = v29;
                uint64_t v29 = (void *)*v29;
                unint64_t v24 = v30;
              }
              while (v29);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v34 = *(void **)a1;
        *(void *)a1 = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v7 = 0;
        *(void *)(a1 + 8) = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v31 = *(void **)(*(void *)a1 + 8 * v3);
  int i = (uint64_t *)v35[0];
  if (v31)
  {
    *(void *)v35[0] = *v31;
LABEL_72:
    *uint64_t v31 = i;
    goto LABEL_73;
  }
  *(void *)v35[0] = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(*(void *)a1 + 8 * v3) = v12;
  if (*i)
  {
    unint64_t v32 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    uint64_t v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  v35[0] = 0;
  ++*(void *)(a1 + 24);
  sub_18E183374((uint64_t)v35);
  return i;
}

void sub_18E183360(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_18E183374((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_18E183374(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_18E068ED0(v1 + 3);
    }
    operator delete(v1);
  }
}

void *sub_18E1833CC(uint64_t *a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    BOOL v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v12 = a1 + 2;
  uint64_t v10 = operator new(0x30uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[5] = 0;
  v10[4] = 0;
  double v10[3] = v10 + 4;
  float v13 = (float)(unint64_t)(a1[3] + 1);
  float v14 = *((float *)a1 + 8);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      int8x8_t prime = (int8x8_t)v17;
    }
    else {
      int8x8_t prime = (int8x8_t)v16;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = a1[1];
    }
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (*(void *)&prime <= v25) {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            sub_18DEDF7D4();
          }
          uint64_t v19 = operator new(8 * *(void *)&prime);
          uint64_t v20 = (void *)*a1;
          *a1 = (uint64_t)v19;
          if (v20) {
            operator delete(v20);
          }
          uint64_t v21 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v21++) = 0;
          while (*(void *)&prime != v21);
          uint64_t v22 = (void *)*v12;
          if (*v12)
          {
            unint64_t v23 = v22[1];
            uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }
            else
            {
              v23 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v23) = v12;
            uint64_t v28 = (void *)*v22;
            if (*v22)
            {
              do
              {
                unint64_t v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(void *)&prime) {
                    v29 %= *(void *)&prime;
                  }
                }
                else
                {
                  v29 &= *(void *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(void *)(*a1 + 8 * v29))
                  {
                    *(void *)(*a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  *uint64_t v22 = *v28;
                  *uint64_t v28 = **(void **)(*a1 + 8 * v29);
                  **(void **)(*a1 + 8 * v29) = v28;
                  uint64_t v28 = v22;
                }
                unint64_t v29 = v23;
LABEL_55:
                uint64_t v22 = v28;
                uint64_t v28 = (void *)*v28;
                unint64_t v23 = v29;
              }
              while (v28);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v34 = (void *)*a1;
        *a1 = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v7 = 0;
        a1[1] = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v30 = *a1;
  uint64_t v31 = *(void **)(*a1 + 8 * v3);
  if (v31)
  {
    void *v10 = *v31;
LABEL_72:
    *uint64_t v31 = v10;
    goto LABEL_73;
  }
  void *v10 = *v12;
  *uint64_t v12 = v10;
  *(void *)(v30 + 8 * v3) = v12;
  if (*v10)
  {
    unint64_t v32 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    uint64_t v31 = (void *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return v10;
}

void sub_18E1837B8(_Unwind_Exception *a1)
{
  sub_18E1837D0(1, v1);
  _Unwind_Resume(a1);
}

void sub_18E1837D0(char a1, void **a2)
{
  if (a1)
  {
    sub_18DF064FC(a2[4]);
  }
  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

void *sub_18E183828(uint64_t **a1, unsigned __int8 a2, unsigned char *a3)
{
  unint64_t v6 = a1 + 1;
  unint64_t v5 = (unsigned __int8 *)a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v7 = v5;
        unsigned int v8 = v5[28];
        if (v8 <= a2) {
          break;
        }
        unint64_t v5 = (unsigned __int8 *)*v7;
        unint64_t v6 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      unint64_t v5 = (unsigned __int8 *)v7[1];
      if (!v5)
      {
        unint64_t v6 = (uint64_t **)(v7 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    unint64_t v7 = a1 + 1;
LABEL_9:
    BOOL v9 = v7;
    unint64_t v7 = operator new(0x28uLL);
    *((unsigned char *)v7 + 28) = *a3;
    *((_DWORD *)v7 + 8) = 0;
    void *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *unint64_t v6 = v7;
    uint64_t v10 = (uint64_t *)**a1;
    unint64_t v11 = v7;
    if (v10)
    {
      *a1 = v10;
      unint64_t v11 = *v6;
    }
    sub_18DEEDADC(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void *sub_18E1838FC(uint64_t a1)
{
  int8x8_t v2 = operator new(0xF0uLL);
  unint64_t v3 = v2;
  *int8x8_t v2 = 0;
  v2[1] = 0;
  long long v4 = *(_OWORD *)(a1 + 16);
  *((_OWORD *)v2 + 1) = *(_OWORD *)a1;
  *((_OWORD *)v2 + 2) = v4;
  *((unsigned char *)v2 + 48) = 0;
  *((unsigned char *)v2 + 160) = 0;
  if (*(unsigned char *)(a1 + 144))
  {
    v2[6] = *(void *)(a1 + 32);
    sub_18E18251C((uint64_t)(v2 + 7), a1 + 40);
    *((unsigned char *)v3 + 160) = 1;
  }
  *(_OWORD *)(v3 + 23) = *(_OWORD *)(a1 + 168);
  *(_OWORD *)(v3 + 25) = *(_OWORD *)(a1 + 184);
  *(_OWORD *)(v3 + 27) = *(_OWORD *)(a1 + 200);
  v3[29] = *(void *)(a1 + 216);
  *(_OWORD *)(v3 + 21) = *(_OWORD *)(a1 + 152);
  return v3;
}

void sub_18E183998(_Unwind_Exception *a1)
{
  if (v1[160]) {
    *int8x8_t v2 = &unk_1EDD17478;
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_18E1839D0(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_18E066148(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void sub_18E183A28(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_18E0660C8(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

uint64_t *sub_18E183A80(uint64_t a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    BOOL v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t v12 = (void *)(a1 + 16);
  float v13 = (char *)operator new(0x40uLL);
  v35[0] = v13;
  v35[1] = a1 + 16;
  *(void *)float v13 = 0;
  *((void *)v13 + 1) = v6;
  *((_DWORD *)v13 + 4) = *a3;
  *(_OWORD *)(v13 + 24) = 0u;
  *(_OWORD *)(v13 + 40) = 0u;
  *((_DWORD *)v13 + 14) = 1065353216;
  char v36 = 1;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      int8x8_t prime = (int8x8_t)v18;
    }
    else {
      int8x8_t prime = (int8x8_t)v17;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }
      else
      {
        uint64_t v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }
      if (*(void *)&prime <= v26) {
        int8x8_t prime = (int8x8_t)v26;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = *(void *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            sub_18DEDF7D4();
          }
          uint64_t v20 = operator new(8 * *(void *)&prime);
          uint64_t v21 = *(void **)a1;
          *(void *)a1 = v20;
          if (v21) {
            operator delete(v21);
          }
          uint64_t v22 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v22++) = 0;
          while (*(void *)&prime != v22);
          unint64_t v23 = (void *)*v12;
          if (*v12)
          {
            unint64_t v24 = v23[1];
            uint8x8_t v25 = (uint8x8_t)vcnt_s8(prime);
            v25.i16[0] = vaddlv_u8(v25);
            if (v25.u32[0] > 1uLL)
            {
              if (v24 >= *(void *)&prime) {
                v24 %= *(void *)&prime;
              }
            }
            else
            {
              v24 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v24) = v12;
            unint64_t v29 = (void *)*v23;
            if (*v23)
            {
              do
              {
                unint64_t v30 = v29[1];
                if (v25.u32[0] > 1uLL)
                {
                  if (v30 >= *(void *)&prime) {
                    v30 %= *(void *)&prime;
                  }
                }
                else
                {
                  v30 &= *(void *)&prime - 1;
                }
                if (v30 != v24)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v30))
                  {
                    *(void *)(*(void *)a1 + 8 * v30) = v23;
                    goto LABEL_55;
                  }
                  *unint64_t v23 = *v29;
                  *unint64_t v29 = **(void **)(*(void *)a1 + 8 * v30);
                  **(void **)(*(void *)a1 + 8 * v30) = v29;
                  unint64_t v29 = v23;
                }
                unint64_t v30 = v24;
LABEL_55:
                unint64_t v23 = v29;
                unint64_t v29 = (void *)*v29;
                unint64_t v24 = v30;
              }
              while (v29);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v34 = *(void **)a1;
        *(void *)a1 = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v7 = 0;
        *(void *)(a1 + 8) = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v31 = *(void **)(*(void *)a1 + 8 * v3);
  uint64_t i = (uint64_t *)v35[0];
  if (v31)
  {
    *(void *)v35[0] = *v31;
LABEL_72:
    *uint64_t v31 = i;
    goto LABEL_73;
  }
  *(void *)v35[0] = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(*(void *)a1 + 8 * v3) = v12;
  if (*i)
  {
    unint64_t v32 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    uint64_t v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  v35[0] = 0;
  ++*(void *)(a1 + 24);
  sub_18E183EA8((uint64_t)v35);
  return i;
}

void sub_18E183E94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_18E183EA8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_18E183EA8(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_18E011990((uint64_t)v1 + 24);
    }
    operator delete(v1);
  }
}

uint64_t *sub_18E183F00(void *a1, int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  unint64_t v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (double result = *v5; result; double result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void sub_18E183FB4(uint64_t a1, int a2, int a3, int a4)
{
  unint64_t v8 = a2;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (v9 <= a2) {
        unint64_t v4 = a2 % v9;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & a2;
    }
    unint64_t v11 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4) {
            break;
          }
        }
      }
    }
  }
  float v14 = operator new(0x18uLL);
  *float v14 = 0;
  v14[1] = v8;
  *((_DWORD *)v14 + 4) = a3;
  *((_DWORD *)v14 + 5) = a4;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    BOOL v17 = 1;
    if (v9 >= 3) {
      BOOL v17 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v9);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    sub_18E1841C8(a1, v20);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v9 <= v8) {
        unint64_t v4 = v8 % v9;
      }
      else {
        unint64_t v4 = v8;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & v8;
    }
  }
  uint64_t v21 = *(void *)a1;
  uint64_t v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *float v14 = *v22;
LABEL_38:
    *uint64_t v22 = v14;
    goto LABEL_39;
  }
  *float v14 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v14;
  *(void *)(v21 + 8 * v4) = a1 + 16;
  if (*v14)
  {
    unint64_t v23 = *(void *)(*v14 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v23 >= v9) {
        v23 %= v9;
      }
    }
    else
    {
      v23 &= v9 - 1;
    }
    uint64_t v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
}

void sub_18E1841B4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_18E1841C8(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      float v16 = *(void **)a1;
      *(void *)a1 = 0;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    sub_18DEDF7D4();
  }
  unint64_t v5 = operator new(8 * prime);
  unint64_t v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  unint64_t v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }
    else
    {
      v9 &= prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    float v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *unint64_t v8 = *v14;
          *float v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          float v14 = v8;
        }
        size_t v15 = v9;
LABEL_31:
        unint64_t v8 = v14;
        float v14 = (void *)*v14;
        size_t v9 = v15;
      }
      while (v14);
    }
  }
}

void *sub_18E1843C4(uint64_t a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    size_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint8x8_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint8x8_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint8x8_t v10 = operator new(0x18uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_18E1841C8(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  unint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    unint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_18E1845C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_18E1845D4(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_18E06608C((uint64_t)v1 + 24);
    }
    operator delete(v1);
  }
}

uint64_t **sub_18E18462C(uint64_t **a1, int a2, uint64_t *a3, _OWORD *a4)
{
  unint64_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        uint8x8_t v8 = (uint64_t **)v6;
        int v9 = *((_DWORD *)v6 + 8);
        uint8x8_t v10 = v8[5];
        BOOL v11 = (uint64_t)v10 > (uint64_t)a3;
        if (v9 != a2) {
          BOOL v11 = v9 > a2;
        }
        if (!v11) {
          break;
        }
        unint64_t v6 = *v8;
        unint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_13;
        }
      }
      BOOL v12 = (uint64_t)v10 < (uint64_t)a3;
      BOOL v13 = v9 == a2;
      BOOL v14 = v9 < a2;
      if (v13) {
        BOOL v14 = v12;
      }
      if (!v14) {
        break;
      }
      unint64_t v6 = v8[1];
      if (!v6)
      {
        unint64_t v7 = v8 + 1;
        goto LABEL_13;
      }
    }
  }
  else
  {
    uint8x8_t v8 = a1 + 1;
LABEL_13:
    unint64_t v15 = (uint64_t *)v8;
    uint8x8_t v8 = (uint64_t **)operator new(0x38uLL);
    *((_OWORD *)v8 + 2) = *a4;
    *((_DWORD *)v8 + 12) = 0;
    *uint8x8_t v8 = 0;
    v8[1] = 0;
    v8[2] = v15;
    void *v7 = (uint64_t *)v8;
    unint64_t v16 = (uint64_t *)**a1;
    size_t v17 = (uint64_t *)v8;
    if (v16)
    {
      *a1 = v16;
      size_t v17 = *v7;
    }
    sub_18DEEDADC(a1[1], v17);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v8;
}

uint64_t raven::RavenLineOfSightEstimator::GetCurrentTime(raven::RavenLineOfSightEstimator *this)
{
  return *((void *)this + 23);
}

double raven::RavenLineOfSightEstimator::GetHMMProbabilitySumThreshold(raven::RavenLineOfSightEstimator *this)
{
  return *((double *)this + 18);
}

double raven::RavenLineOfSightEstimator::GetProbabilityLOS(raven::RavenLineOfSightEstimator *this)
{
  if (!*(unsigned char *)this) {
    return NAN;
  }
  uint64_t v5 = 0x100000002;
  unint64_t v3 = &unk_1EDD18B28;
  long long v4 = xmmword_18E1FD1A0;
  unint64_t v6 = &v7;
  if (*((_DWORD *)this + 34)) {
    uint64_t v1 = (char *)this + 80;
  }
  else {
    uint64_t v1 = (char *)this + 24;
  }
  sub_18DFE2F24((uint64_t)&v3, (uint64_t)v1);
  return *(double *)v6;
}

uint64_t raven::RavenLineOfSightEstimator::IsInitialized(raven::RavenLineOfSightEstimator *this)
{
  return *(unsigned __int8 *)this;
}

char *raven::RavenLineOfSightEstimator::GetSatelliteID@<X0>(char *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2 = this;
  if (this[175] < 0)
  {
    this = (char *)sub_18DEDE668((unsigned char *)a2, *((void **)this + 19), *((void *)this + 20));
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)(this + 152);
    *(void *)(a2 + 16) = *((void *)this + 21);
  }
  *(void *)(a2 + 24) = *((void *)v2 + 22);
  return this;
}

uint64_t raven::RavenLineOfSightEstimator::Initialize(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned char *)a1)
  {
    __int16 v54 = 12;
    unsigned __int8 v53 = 2;
    char v4 = sub_18E017C64((uint64_t)(a2 + 3));
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v54, &v53, "WARNING: LOSEstimator being re-initialized,svid,%s", v5, v6, v7, v8, v9, v4);
    *(unsigned char *)a1 = 0;
  }
  double v10 = *(double *)a2;
  if (!*a2)
  {
    __int16 v54 = 12;
    unsigned __int8 v53 = 4;
    char v52 = sub_18E017C64((uint64_t)(a2 + 3));
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v54, &v53, "LOSEstimator,invalid pointer to RavenParameters,%s", v19, v20, v21, v22, v23, v52);
    return 0xFFFFFFFFLL;
  }
  double v11 = *(double *)(*(void *)&v10 + 2256);
  if ((*(void *)&v11 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (v11 >= 0.0 ? (BOOL v12 = v11 <= 1.0) : (BOOL v12 = 0), !v12))
  {
    __int16 v54 = 12;
    unsigned __int8 v53 = 4;
    char v13 = sub_18E017C64((uint64_t)(a2 + 3));
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v54, &v53, "LOSEstimator,invalid P(LOS|LOS),%s,%.3lf", v14, v15, v16, v17, v18, v13);
    return 0xFFFFFFFFLL;
  }
  double v24 = *(double *)(*(void *)&v10 + 2264);
  if ((*(void *)&v24 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (v24 >= 0.0 ? (BOOL v25 = v24 <= 1.0) : (BOOL v25 = 0), !v25))
  {
    __int16 v54 = 12;
    unsigned __int8 v53 = 4;
    char v26 = sub_18E017C64((uint64_t)(a2 + 3));
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v54, &v53, "LOSEstimator,invalid P(NLOS|NLOS),%s,%.3lf", v27, v28, v29, v30, v31, v26);
    return 0xFFFFFFFFLL;
  }
  if ((*(void *)(*(void *)&v10 + 2248) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || *(double *)(*(void *)&v10 + 2248) <= 0.0)
  {
    __int16 v54 = 12;
    unsigned __int8 v53 = 4;
    char v41 = sub_18E017C64((uint64_t)(a2 + 3));
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v54, &v53, "LOSEstimator,invalid transition probability time interval,%s,%.3lf", v42, v43, v44, v45, v46, v41);
    return 0xFFFFFFFFLL;
  }
  double v33 = *((double *)a2 + 2) + (double)a2[1];
  if (COERCE__INT64(fabs(v33)) > 0x7FEFFFFFFFFFFFFFLL || v33 < 0.0)
  {
    __int16 v54 = 12;
    unsigned __int8 v53 = 4;
    sub_18E017C64((uint64_t)(a2 + 3));
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v54, &v53, "LOSEstimator,invalid input time,%.3lf,%s", v47, v48, v49, v50, v51, SLOBYTE(v33));
    return 0xFFFFFFFFLL;
  }
  *(void *)(a1 + 144) = 0x3DDB7CDFD9D7BDBBLL;
  sub_18E184AE8(a1 + 16);
  *(void *)(a1 + 8) = *a2;
  uint64_t v34 = std::string::operator=((std::string *)(a1 + 152), (const std::string *)a2 + 1);
  *(void *)(a1 + 176) = a2[6];
  *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 1);
  *(unsigned char *)a1 = 1;
  if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v34) <= 1)
  {
    __int16 v54 = 12;
    unsigned __int8 v53 = 1;
    double v35 = *((double *)a2 + 2) + (double)a2[1];
    sub_18E017C64((uint64_t)(a2 + 3));
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v54, &v53, "LOSEstimator initialized,time,%.3lf,svid,%s", v36, v37, v38, v39, v40, SLOBYTE(v35));
  }
  return 0;
}

void sub_18E184AE8(uint64_t a1)
{
  uint64_t v32 = 0x100000002;
  uint64_t v30 = &unk_1EDD18B28;
  double v33 = v34;
  long long v22 = xmmword_18E1FD1A0;
  long long v31 = xmmword_18E1FD1A0;
  sub_18DFE2CC8((uint64_t)&v30, 1.0);
  uint64_t v25 = 0x100000002;
  uint64_t v23 = &unk_1EDD18B28;
  *(void *)&v3.f64[1] = 0x200000002;
  long long v24 = xmmword_18E1FD1A0;
  char v26 = &v27;
  v3.f64[0] = 0.5;
  sub_18DFE3240((uint64_t)&v30, (uint64_t)&v23, v3);
  double v5 = *(double *)(a1 + 128);
  uint64_t v6 = DWORD1(v24);
  if (DWORD1(v24))
  {
    uint64_t v7 = 0;
    unsigned int v8 = v24;
    uint64_t v9 = v26;
    uint64_t v10 = v24 - 1;
    int v11 = 1;
    do
    {
      double v12 = *(double *)&v9[v8 * v7];
      unsigned int v13 = v11;
      uint64_t v14 = v10;
      if (v8 >= 2)
      {
        do
        {
          double v12 = v12 + *(double *)&v9[v13++];
          --v14;
        }
        while (v14);
      }
      v34[v7++] = v12;
      v11 += v8;
    }
    while (v7 != v6);
    double v1 = v34[0];
  }
  unsigned int v15 = DWORD2(v24);
  if (fabs(v1 + -1.0) > v5 && cnprint::CNPrinter::GetLogLevel(v4) <= 1)
  {
    LOWORD(v30) = 2;
    v28[0] = 1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v30, v28, "WARNING: HMM initialized with non-normalized probability vector.", v16, v17, v18, v19, v20, 2);
  }
  sub_18E024D90((uint64_t)v28, (uint64_t)&v23);
  float64x2_t v21 = (float64x2_t)vdupq_lane_s32((int32x2_t)(v15 | 0x100000000), 0);
  HIDWORD(v21.f64[0]) = 1;
  float64x2_t v29 = v21;
  uint64_t v32 = 0x100000002;
  uint64_t v30 = &unk_1EDD18B28;
  *(void *)&v21.f64[1] = 0x200000002;
  long long v31 = v22;
  double v33 = v34;
  v21.f64[0] = 1.0 / v1;
  sub_18DFE3240((uint64_t)v28, (uint64_t)&v30, v21);
  sub_18DFE2F24(a1 + 8, (uint64_t)&v30);
  sub_18DFE2F24(a1 + 64, a1 + 8);
  *(_DWORD *)(a1 + 120) = 1;
}

uint64_t raven::RavenLineOfSightEstimator::Predict(uint64_t a1, uint64_t a2, double a3, int8x16_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!*(unsigned char *)a1)
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) <= 1)
    {
      *(_WORD *)uint64_t v83 = 12;
      LOBYTE(v87) = 1;
      double v72 = *(double *)(a2 + 8) + (double)*(uint64_t *)a2;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v83, (unsigned __int8 *)&v87, "WARNING:LOSEstimator,time,%.3lf,predicting uninitialized", v23, v24, v25, v26, v27, SLOBYTE(v72));
    }
    return 0xFFFFFFFFLL;
  }
  a4.i64[0] = *(void *)(a2 + 8);
  if (COERCE__INT64(fabs(*(double *)a4.i64 + (double)*(uint64_t *)a2)) > 0x7FEFFFFFFFFFFFFFLL
    || *(double *)a4.i64 + (double)*(uint64_t *)a2 < 0.0)
  {
    *(_WORD *)uint64_t v83 = 12;
    LOBYTE(v87) = 4;
    double v73 = *(double *)(a1 + 192) + (double)*(uint64_t *)(a1 + 184);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v83, (unsigned __int8 *)&v87, "LOSEstimator,time,%.3lf,invalid prediction time,%.3lf", a6, a7, a8, a9, a10, SLOBYTE(v73));
    return 0xFFFFFFFFLL;
  }
  long long v74 = *(_OWORD *)(a1 + 184);
  *(_OWORD *)uint64_t v83 = *(_OWORD *)(a1 + 184);
  uint64_t v12 = CNTimeSpan::operator-(a2, v83, *(int8x16_t *)v83, a4);
  double v75 = v13 + (double)v12;
  uint64_t v14 = *(void *)(a1 + 8);
  long long v76 = *(_OWORD *)(v14 + 2256);
  uint64_t v77 = *(void *)(v14 + 2248);
  if (!*(_DWORD *)(a1 + 136)) {
    sub_18DFE2F24(a1 + 80, a1 + 24);
  }
  unsigned int v15 = *(_DWORD *)(a1 + 88);
  unsigned int v16 = *(_DWORD *)(a1 + 92);
  if (v15) {
    BOOL v17 = v16 == 0;
  }
  else {
    BOOL v17 = 1;
  }
  int v18 = v17;
  if (v15 <= v16) {
    unsigned int v19 = *(_DWORD *)(a1 + 92);
  }
  else {
    unsigned int v19 = *(_DWORD *)(a1 + 88);
  }
  if (v18) {
    unint64_t v20 = 0;
  }
  else {
    unint64_t v20 = v19;
  }
  if (v18 == 1)
  {
    uint64_t v89 = 0x100000002;
    uint64_t v87 = &unk_1EDD18B28;
    long long v90 = v91;
    long long v88 = xmmword_18E1F8710;
    sub_18DFE2CC8((uint64_t)&v87, 1.0);
    uint64_t v84 = 0x100000002;
    *(void *)uint64_t v83 = &unk_1EDD18B28;
    *(void *)&v21.f64[1] = 0x200000002;
    *(_OWORD *)&v83[8] = xmmword_18E1FD1A0;
    long long v85 = (double *)v86;
    v21.f64[0] = INFINITY;
    long long v22 = &v87;
LABEL_28:
    sub_18DFE3240((uint64_t)v22, (uint64_t)v83, v21);
    goto LABEL_31;
  }
  double v28 = *(double *)(a1 + 144);
  uint64_t v84 = 0x100000002;
  *(void *)uint64_t v83 = &unk_1EDD18B28;
  *(_OWORD *)&v83[8] = xmmword_18E1FD1A0;
  long long v85 = (double *)v86;
  float64x2_t v29 = (cnprint::CNPrinter *)sub_18DFF2FDC(a1 + 80, 1, (uint64_t)v83);
  double v30 = *v85;
  if (fabs(*v85 + -1.0) > v28)
  {
    if (cnprint::CNPrinter::GetLogLevel(v29) <= 1)
    {
      *(_WORD *)uint64_t v83 = 2;
      LOBYTE(v87) = 1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v83, (unsigned __int8 *)&v87, "WARNING: HMM prediction passed a non-normalized probability vector.", v31, v32, v33, v34, v35, v71);
    }
    if ((v19 & 0x80000000) == 0)
    {
      sub_18E024D90((uint64_t)&v87, a1 + 80);
      int32x4_t v36 = vdupq_lane_s32((int32x2_t)(v19 | 0x100000000), 0);
      v36.i32[1] = 1;
      long long v88 = (__int128)v36;
      uint64_t v84 = 0x100000002;
      *(void *)uint64_t v83 = &unk_1EDD18B28;
      *(void *)&v21.f64[1] = 0x200000002;
      *(_OWORD *)&v83[8] = xmmword_18E1FD1A0;
      long long v85 = (double *)v86;
      v21.f64[0] = 1.0 / v30;
      goto LABEL_28;
    }
LABEL_51:
    __assert_rtn("Reshape", "cnmatrix.h", 2936, "nr >= 0");
  }
  if ((v19 & 0x80000000) != 0) {
    goto LABEL_51;
  }
  sub_18E024D90((uint64_t)v83, a1 + 80);
  int32x4_t v37 = vdupq_lane_s32((int32x2_t)(v19 | 0x100000000), 0);
  v37.i32[1] = 1;
  *(int32x4_t *)&v83[8] = v37;
LABEL_31:
  sub_18DFE2F24(a1 + 80, (uint64_t)v83);
  *(_DWORD *)(a1 + 136) = 1;
  uint64_t v84 = 0x200000002;
  *(void *)uint64_t v83 = &unk_1EDD18BB8;
  *(_OWORD *)&v83[8] = xmmword_18E1FD1B0;
  long long v85 = (double *)v86;
  uint64_t v44 = (cnprint::CNPrinter *)sub_18E1852E8((uint64_t)&v74, (uint64_t)v83, v38, v39, v40, v41, v42, v43);
  if (v44)
  {
    LOWORD(v87) = 2;
    LOBYTE(v78) = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v87, (unsigned __int8 *)&v78, "ERROR: HMM transition probability function failed.", v45, v46, v47, v48, v49, v71);
LABEL_33:
    *(_WORD *)uint64_t v83 = 12;
    LOBYTE(v87) = 4;
    double v50 = *(double *)(a1 + 192) + (double)*(uint64_t *)(a1 + 184);
    sub_18E017C64(a1 + 152);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v83, (unsigned __int8 *)&v87, "LOSEstimator,time,%.3lf,failed to predict,%s,code,%d", v51, v52, v53, v54, v55, SLOBYTE(v50));
    return 0xFFFFFFFFLL;
  }
  if (v20)
  {
    unint64_t v57 = 0;
    BOOL v58 = 0;
    uint64_t v59 = v85;
LABEL_37:
    double v60 = 0.0;
    double v61 = v59;
    unint64_t v62 = v20;
    while (1)
    {
      double v63 = *v61;
      if (*v61 < 0.0 || v63 > 1.0) {
        break;
      }
      double v60 = v60 + v63;
      ++v61;
      if (!--v62)
      {
        if (fabs(v60 + -1.0) <= *(double *)(a1 + 144))
        {
          ++v57;
          v59 += *(int *)&v83[20];
          BOOL v58 = v57 >= v20;
          if (v57 != v20) {
            goto LABEL_37;
          }
        }
        break;
      }
    }
    if (!v58)
    {
      if (cnprint::CNPrinter::GetLogLevel(v44) <= 1)
      {
        LOWORD(v87) = 2;
        LOBYTE(v78) = 1;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v87, (unsigned __int8 *)&v78, "ERROR: HMM transition probability matrix is invalid.", v66, v67, v68, v69, v70, v71);
      }
      goto LABEL_33;
    }
  }
  uint64_t v89 = 0x100000002;
  long long v88 = xmmword_18E1FD1A0;
  uint64_t v87 = &unk_1EDD18B28;
  long long v90 = v91;
  sub_18DFE2B44((uint64_t)v83, a1 + 80, (uint64_t)&v87);
  sub_18DFE2F24(a1 + 24, (uint64_t)&v87);
  uint64_t v80 = 0x100000002;
  uint64_t v78 = &unk_1EDD18B28;
  long long v79 = xmmword_18E1FD1A0;
  uint64_t v81 = (double *)&v82;
  sub_18DFF2FDC(a1 + 24, 1, (uint64_t)&v78);
  v65.f64[0] = 1.0 / *v81;
  uint64_t v89 = 0x100000002;
  long long v88 = xmmword_18E1FD1A0;
  uint64_t v87 = &unk_1EDD18B28;
  long long v90 = v91;
  sub_18DFE3240(a1 + 24, (uint64_t)&v87, v65);
  sub_18DFE2F24(a1 + 24, (uint64_t)&v87);
  uint64_t result = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 184) = *(_OWORD *)a2;
  return result;
}

uint64_t sub_18E1852E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v8 = *(double *)(a1 + 16);
  if ((*(void *)&v8 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v8 < 0.0)
  {
    v54[0] = 12;
    unsigned __int8 v55 = 4;
    double v11 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    goto LABEL_10;
  }
  double v9 = *(double *)(a1 + 24);
  if ((*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (v9 >= 0.0 ? (BOOL v10 = v9 <= 1.0) : (BOOL v10 = 0), !v10))
  {
    v54[0] = 12;
    unsigned __int8 v55 = 4;
    double v11 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
LABEL_10:
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v54, &v55, "time,%.3lf,t-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v11));
    return 0xFFFFFFFFLL;
  }
  double v13 = *(double *)(a1 + 32);
  if ((*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (v13 >= 0.0 ? (BOOL v14 = v13 <= 1.0) : (BOOL v14 = 0), !v14))
  {
    v54[0] = 12;
    unsigned __int8 v55 = 4;
    double v11 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    goto LABEL_10;
  }
  double v15 = *(double *)(a1 + 40);
  if ((*(void *)&v15 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v15 < 0.0)
  {
    BOOL v17 = "invalid transition time";
    uint64_t v18 = 234;
LABEL_50:
    sub_18E186550(a1, (uint64_t)v17, (uint64_t)"t_LineOfSight", v18, a5, a6, a7, a8);
    return 0xFFFFFFFFLL;
  }
  if (fabs(v8) < 2.22044605e-16)
  {
    sub_18E1865A8((uint64_t)v54);
    sub_18DFE2F24(a2, (uint64_t)v54);
    return 0;
  }
  double v19 = 1.0 - v13;
  double v20 = 1.0 - v9;
  double v21 = sqrt((v9 * v13 - (1.0 - v13) * (1.0 - v9)) * -4.0 + (v9 + v13) * (v9 + v13));
  double v22 = (v9 + v13 + v21) * 0.5;
  double v23 = (v9 + v13 - v21) * 0.5;
  double v24 = v9 + 1.0 - v13;
  double v25 = 1.0 - v9 + v13;
  double v26 = (1.0 - v9) / (v22 - v13);
  double v27 = (v22 - v13) / (1.0 - v9);
  if (1.0 - v9 <= vabdd_f64(v22, v13)) {
    double v27 = 1.0;
  }
  else {
    double v26 = 1.0;
  }
  double v28 = v23 - v13;
  BOOL v10 = v20 <= vabdd_f64(v23, v13);
  double v29 = v20 / (v23 - v13);
  double v30 = v28 / v20;
  if (v10) {
    double v30 = 1.0;
  }
  else {
    double v29 = 1.0;
  }
  double v31 = v19 / (v22 - v9);
  double v32 = (v22 - v9) / v19;
  if (v19 > vabdd_f64(v22, v9)) {
    double v31 = 1.0;
  }
  else {
    double v32 = 1.0;
  }
  double v33 = v23 - v9;
  BOOL v10 = v19 <= vabdd_f64(v23, v9);
  double v34 = v19 / (v23 - v9);
  double v35 = v33 / v19;
  if (v10)
  {
    double v35 = 1.0;
    double v36 = v34;
  }
  else
  {
    double v36 = 1.0;
  }
  if (v24 > v25) {
    double v37 = v32;
  }
  else {
    double v37 = v26;
  }
  if (v24 > v25) {
    double v38 = v31;
  }
  else {
    double v38 = v27;
  }
  if (v24 <= v25)
  {
    double v39 = v30;
  }
  else
  {
    double v29 = v35;
    double v39 = v36;
  }
  double v40 = sqrt(v37 * v37 + v38 * v38);
  if (fabs(v40) < 2.22044605e-16)
  {
    BOOL v17 = "eigenvector 1 has zero norm";
    uint64_t v18 = 332;
    goto LABEL_50;
  }
  double v41 = sqrt(v29 * v29 + v39 * v39);
  if (fabs(v41) < 2.22044605e-16)
  {
    BOOL v17 = "eigenvector 2 has zero norm";
    uint64_t v18 = 341;
    goto LABEL_50;
  }
  double v42 = v38 / v40;
  double v43 = v37 / v40;
  double v44 = v39 / v41;
  double v45 = v29 / v41;
  double v46 = v38 / v40 * (v29 / v41) - v37 / v40 * (v39 / v41);
  if (fabs(v46) < 2.22044605e-16)
  {
    BOOL v17 = "singular matrix";
    uint64_t v18 = 351;
    goto LABEL_50;
  }
  long double v47 = v8 / v15;
  double v48 = pow(v22, v8 / v15);
  long double v49 = pow(v23, v47);
  uint64_t result = 0;
  *(_OWORD *)(a2 + 8) = xmmword_18E1FD1B0;
  long double v50 = v49 * v44;
  double v51 = (v48 * v42 * v45 - v50 * v43) / v46;
  uint64_t v52 = *(double **)(a2 + 32);
  long double v53 = (v42 * v50 + -(v48 * v42) * v44) / v46;
  *uint64_t v52 = v51;
  v52[1] = 1.0 - v51;
  v52[2] = v53;
  v52[3] = 1.0 - v53;
  return result;
}

uint64_t raven::RavenLineOfSightEstimator::Reset(uint64_t this)
{
  *(unsigned char *)this = 0;
  *(void *)(this + 184) = 0;
  *(void *)(this + 192) = 0x7FF8000000000000;
  return this;
}

uint64_t raven::RavenLineOfSightEstimator::Update(uint64_t a1, double *a2)
{
  if (!*(unsigned char *)a1)
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) <= 1)
    {
      LOWORD(v20[0]) = 12;
      LOBYTE(v19) = 1;
      double v17 = a2[3] + (double)*((uint64_t *)a2 + 2);
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v20, (unsigned __int8 *)&v19, "WARNING:LOSEstimator,time,%.3lf,trying to update uninitialized estimator", v12, v13, v14, v15, v16, SLOBYTE(v17));
    }
    return 0xFFFFFFFFLL;
  }
  long long v4 = *(_OWORD *)a2;
  v20[0] = *((_OWORD *)a2 + 1);
  v20[1] = v4;
  uint64_t result = sub_18E1858E4(a1 + 16, (uint64_t)sub_18E1857B0, (uint64_t)v20);
  if (result)
  {
    __int16 v19 = 12;
    unsigned __int8 v18 = 4;
    double v6 = *(double *)(a1 + 192) + (double)*(uint64_t *)(a1 + 184);
    sub_18E017C64(a1 + 152);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v19, &v18, "LOSEstimator,time,%.3lf,failed updating with the given signal characteristic evidences,%s,code,%d", v7, v8, v9, v10, v11, SLOBYTE(v6));
    return 0xFFFFFFFFLL;
  }
  *(_OWORD *)(a1 + 184) = *((_OWORD *)a2 + 1);
  return result;
}

uint64_t sub_18E1857B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v8 = *(double *)(a1 + 16);
  if ((*(void *)&v8 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (v8 >= 0.0 ? (BOOL v9 = v8 <= 1.0) : (BOOL v9 = 0), v9))
  {
    double v10 = *(double *)(a1 + 24);
    if ((*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && v10 >= 0.0 && v10 <= 1.0)
    {
      uint64_t v12 = 0;
      *(_OWORD *)(a2 + 8) = xmmword_18E1FD1A0;
      uint64_t v14 = *(void *)(a2 + 32);
      *(double *)uint64_t v14 = v8;
      *(void *)(v14 + 8) = *(void *)(a1 + 24);
      return v12;
    }
    __int16 v20 = 12;
    unsigned __int8 v19 = 4;
    double v16 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v20, &v19, "time,%.3lf,e-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v16));
  }
  else
  {
    __int16 v18 = 12;
    unsigned __int8 v17 = 4;
    double v15 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v18, &v17, "time,%.3lf,e-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v15));
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_18E1858E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 120) == 1) {
    sub_18DFE2F24(a1 + 8, a1 + 64);
  }
  uint64_t v74 = 0x100000001;
  v72[2] = &unk_1EDD17F28;
  *(void *)&long long v6 = 0x100000001;
  *((void *)&v6 + 1) = 0x100000001;
  long long v73 = v6;
  double v75 = &v76;
  uint64_t v76 = a2;
  uint64_t v70 = 0x100000002;
  uint64_t v68 = &unk_1EDD18AC8;
  long long v69 = v6;
  char v71 = v72;
  v72[0] = a3;
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  unsigned int v8 = *(_DWORD *)(a1 + 20);
  sub_18DFF2DB8((uint64_t)v66, (uint64_t)&v68);
  if (v7 <= v8) {
    unsigned int v9 = v8;
  }
  else {
    unsigned int v9 = v7;
  }
  if (v8) {
    BOOL v10 = v7 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = v9;
  }
  double v12 = *(double *)(a1 + 128);
  if (!*(_DWORD *)(a1 + 16) || !*(_DWORD *)(a1 + 20))
  {
    if ((v11 & 0x80000000) != 0) {
      __assert_rtn("Ones", "cnmatrix.h", 2317, "nr >= 0");
    }
    uint64_t v85 = 0x100000002;
    uint64_t v83 = &unk_1EDD18B28;
    uint64_t v86 = (double *)v87;
    *(void *)&long long v84 = v11 | 0x100000000;
    double v20 = 1.0 / (double)(int)v11;
    DWORD2(v84) = v11;
    HIDWORD(v84) = v11;
    sub_18DFE2CC8((uint64_t)&v83, 1.0);
    uint64_t v90 = 0x100000002;
    *(void *)&v22.f64[1] = 0x200000002;
    long long v89 = xmmword_18E1FD1A0;
    long long v88 = &unk_1EDD18B28;
    uint64_t v91 = (double *)v92;
    double v21 = &v83;
    goto LABEL_21;
  }
  uint64_t v90 = 0x100000002;
  long long v64 = xmmword_18E1FD1A0;
  long long v89 = xmmword_18E1FD1A0;
  long long v88 = &unk_1EDD18B28;
  uint64_t v91 = (double *)v92;
  uint64_t v13 = (cnprint::CNPrinter *)sub_18DFF2FDC(a1 + 8, 1, (uint64_t)&v88);
  double v14 = *v91;
  if (fabs(*v91 + -1.0) > v12)
  {
    if (cnprint::CNPrinter::GetLogLevel(v13) <= 1)
    {
      LOWORD(v88) = 2;
      LOBYTE(v83) = 1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v88, (unsigned __int8 *)&v83, "WARNING: HMM update passed a non-normalized probability vector.", v15, v16, v17, v18, v19, 2);
    }
    if ((v11 & 0x80000000) == 0)
    {
      double v20 = 1.0 / v14;
      sub_18E024D90((uint64_t)&v83, a1 + 8);
      float64x2_t v22 = (float64x2_t)vdupq_lane_s32((int32x2_t)(v11 | 0x100000000), 0);
      HIDWORD(v22.f64[0]) = 1;
      long long v84 = (__int128)v22;
      uint64_t v90 = 0x100000002;
      *(void *)&v22.f64[1] = 0x200000002;
      long long v89 = v64;
      long long v88 = &unk_1EDD18B28;
      uint64_t v91 = (double *)v92;
LABEL_21:
      v22.f64[0] = v20;
      sub_18DFE3240((uint64_t)v21, (uint64_t)&v88, v22);
      goto LABEL_24;
    }
LABEL_60:
    __assert_rtn("Reshape", "cnmatrix.h", 2936, "nr >= 0");
  }
  if ((v11 & 0x80000000) != 0) {
    goto LABEL_60;
  }
  sub_18E024D90((uint64_t)&v88, a1 + 8);
  int32x4_t v23 = vdupq_lane_s32((int32x2_t)(v11 | 0x100000000), 0);
  v23.i32[1] = 1;
  long long v89 = (__int128)v23;
LABEL_24:
  sub_18DFE2F24(a1 + 8, (uint64_t)&v88);
  sub_18E024D90((uint64_t)&v88, a1 + 8);
  double v24 = (uint64_t (*)(void, void **))*v75;
  uint64_t v85 = 0x100000002;
  uint64_t v83 = &unk_1EDD18B28;
  long long v65 = xmmword_18E1FD1A0;
  long long v84 = xmmword_18E1FD1A0;
  uint64_t v86 = (double *)v87;
  double v25 = (cnprint::CNPrinter *)v24(*v67, &v83);
  if (v25)
  {
    LOWORD(v77) = 2;
    unsigned __int8 v82 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v77, &v82, "ERROR: HMM emission function failed.", v26, v27, v28, v29, v30, 2);
    return 29;
  }
  if (v11)
  {
    double v33 = 0.0;
    double v34 = v86;
    double v35 = v86;
    uint64_t v36 = v11;
    do
    {
      double v37 = *v35;
      if (*v35 < 0.0 || v37 > 1.0)
      {
        LOWORD(v77) = 2;
        unsigned __int8 v82 = 4;
        long double v50 = "ERROR: HMM emission probability matrix is invalid.";
        goto LABEL_46;
      }
      double v33 = v33 + v37;
      ++v35;
      --v36;
    }
    while (v36);
    if (fabs(v33) > v12)
    {
      double v39 = v91;
      do
      {
        double v40 = *v34++;
        v31.n128_f64[0] = v40 * *v39;
        *v39++ = v31.n128_f64[0];
        --v11;
      }
      while (v11);
      goto LABEL_39;
    }
  }
  else if (v12 < 0.0)
  {
LABEL_39:
    uint64_t v41 = DWORD1(v89);
    if (DWORD1(v89))
    {
      uint64_t v42 = 0;
      uint64_t v43 = v89;
      double v44 = v91;
      int v45 = 1;
      long long v46 = xmmword_18E1FD1A0;
      do
      {
        double v47 = v44[(v43 * v42)];
        unsigned int v48 = v45;
        uint64_t v49 = v43 - 1;
        if (v43 >= 2)
        {
          do
          {
            double v47 = v47 + v44[v48++];
            --v49;
          }
          while (v49);
        }
        v81[v42++] = v47;
        v45 += v43;
      }
      while (v42 != v41);
      v31.n128_f64[0] = v81[0];
    }
    else
    {
      long long v46 = xmmword_18E1FD1A0;
    }
    if (fabs(v31.n128_f64[0]) < 2.22044605e-16)
    {
      if (cnprint::CNPrinter::GetLogLevel(v25) <= 1)
      {
        LOWORD(v77) = 2;
        unsigned __int8 v82 = 1;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v77, &v82, "HMM state is null vector after update; revert to input state",
          v51,
          v52,
          v53,
          v54,
          v55,
          2);
      }
      __n128 v31 = sub_18DFE2F24((uint64_t)&v88, a1 + 8);
      uint64_t v56 = DWORD1(v89);
      if (DWORD1(v89))
      {
        uint64_t v57 = 0;
        uint64_t v58 = v89;
        uint64_t v59 = v91;
        int v60 = 1;
        long long v46 = v65;
        do
        {
          double v61 = v59[(v58 * v57)];
          unsigned int v62 = v60;
          uint64_t v63 = v58 - 1;
          if (v58 >= 2)
          {
            do
            {
              double v61 = v61 + v59[v62++];
              --v63;
            }
            while (v63);
          }
          v81[v57++] = v61;
          v60 += v58;
        }
        while (v57 != v56);
        v31.n128_f64[0] = v81[0];
      }
      else
      {
        long long v46 = v65;
      }
    }
    uint64_t v79 = 0x100000002;
    long long v78 = v46;
    uint64_t v77 = &unk_1EDD18B28;
    uint64_t v80 = v81;
    v31.n128_f64[0] = 1.0 / v31.n128_f64[0];
    sub_18DFE3240((uint64_t)&v88, (uint64_t)&v77, (float64x2_t)v31);
    sub_18DFE2F24((uint64_t)&v88, (uint64_t)&v77);
    sub_18DFE2F24(a1 + 64, (uint64_t)&v88);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 120) = 1;
    return result;
  }
  LOWORD(v77) = 2;
  unsigned __int8 v82 = 4;
  long double v50 = "ERROR: HMM emission probability matrix is null matrix";
LABEL_46:
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v77, &v82, v50, v26, v27, v28, v29, v30, 2);
  return 30;
}

uint64_t raven::RavenLineOfSightEstimator::Update(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a1)
  {
    uint64_t result = sub_18E1858E4(a1 + 16, (uint64_t)sub_18E185FC4, a2);
    if (!result) {
      return result;
    }
    __int16 v18 = 12;
    unsigned __int8 v17 = 4;
    double v5 = *(double *)(a1 + 192) + (double)*(uint64_t *)(a1 + 184);
    sub_18E017C64(a1 + 152);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v18, &v17, "LOSEstimator,time,%.3lf,failed WiFi cross-check,%s,code,%d", v6, v7, v8, v9, v10, SLOBYTE(v5));
  }
  else if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) <= 1)
  {
    __int16 v20 = 12;
    unsigned __int8 v19 = 1;
    double v16 = *(double *)(a2 + 8) + (double)*(uint64_t *)a2;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v20, &v19, "WARNING:LOSEstimator,time,%.3lf,trying to update uninitialized estimator", v11, v12, v13, v14, v15, SLOBYTE(v16));
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_18E185FC4(uint64_t a1, uint64_t a2, double a3, int8x16_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (*(_DWORD *)(a1 + 112) != 1)
  {
    __int16 v35 = 12;
    v42[0] = 4;
    double v11 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    goto LABEL_13;
  }
  if (!*(unsigned char *)(a1 + 56))
  {
    __int16 v35 = 12;
    v42[0] = 4;
    double v11 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    goto LABEL_13;
  }
  if ((*(void *)(a1 + 136) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    __int16 v35 = 12;
    v42[0] = 4;
    double v11 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    goto LABEL_13;
  }
  if ((*(_DWORD *)(a1 + 184) & 0x7FFFFFFFu) > 0x7F7FFFFF || *(float *)(a1 + 184) <= 0.0)
  {
    __int16 v35 = 12;
    v42[0] = 4;
    double v11 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    goto LABEL_13;
  }
  unsigned int v10 = *(unsigned __int8 *)(a1 + 640);
  if (v10 <= 0xF && ((1 << v10) & 0xF7EF) != 0)
  {
    __int16 v35 = 12;
    v42[0] = 4;
    double v11 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
LABEL_13:
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v35, v42, "time,%.3lf,e-function failure on line %d: %s() %s", a6, a7, a8, a9, a10, SLOBYTE(v11));
    return 0xFFFFFFFFLL;
  }
  if (!*(unsigned char *)(a1 + 720))
  {
    uint64_t v15 = "invalid wifi position";
    uint64_t v16 = 310;
    goto LABEL_31;
  }
  a4.i64[0] = *(void *)(a1 + 800);
  if ((a4.i64[0] & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    uint64_t v15 = "invalid clock offset";
    uint64_t v16 = 317;
    goto LABEL_31;
  }
  if ((*(void *)(a1 + 808) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || *(double *)(a1 + 808) <= 0.0)
  {
    uint64_t v15 = "invalid clock offset uncertainty";
    uint64_t v16 = 324;
    goto LABEL_31;
  }
  if ((*(void *)(a1 + 816) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || *(double *)(a1 + 816) < 0.0)
  {
    uint64_t v15 = "invalid minimum NLOS path delay";
    uint64_t v16 = 331;
    goto LABEL_31;
  }
  double v13 = *(double *)(a1 + 824);
  if ((*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v13 < 0.0 || v13 > 1.0)
  {
    uint64_t v15 = "invalid minimum emission probability";
    uint64_t v16 = 338;
    goto LABEL_31;
  }
  long long v54 = *(_OWORD *)(a1 + 728);
  uint64_t v55 = *(void *)(a1 + 744);
  uint64_t v53 = &unk_1EDD0ADE8;
  double v51 = 0.0;
  uint64_t v52 = &unk_1EDD0AE20;
  long long v49 = 0u;
  long long v50 = 0u;
  float64x2_t v48 = 0u;
  *(_OWORD *)uint64_t v42 = *(_OWORD *)(a1 + 64);
  v14.i64[1] = *(void *)&v42[8];
  v14.i64[0] = *(void *)(a1 + 120);
  *(double *)a4.i64 = *(double *)a4.i64 * 0.000001;
  uint64_t v30 = a1;
  __int16 v35 = 0;
  long long v36 = 0u;
  long long v37 = 0u;
  int v38 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  int v41 = 0;
  if (cnnavigation::GNSSPseudorange((uint64_t)v42, (uint64_t)&v35, (uint64_t)&v54, a1 + 224, (uint64_t *)&v53, (uint64_t *)&v52, &v51, 1, v14, a4, &v48))
  {
    uint64_t v15 = "could not predict pseudorange";
    a1 = v30;
    uint64_t v16 = 369;
LABEL_31:
    sub_18E186620(a1, (uint64_t)v15, (uint64_t)"e_LineOfSight_CrosscheckPseudorangeAndWiFiPosition", v16, a7, a8, a9, a10);
    return 0xFFFFFFFFLL;
  }
  uint64_t v43 = 0x400000001;
  *(_OWORD *)&char v42[8] = xmmword_18E1FD6B0;
  long long v45 = v49;
  *(void *)uint64_t v42 = &unk_1EDD182E8;
  double v44 = &v45;
  uint64_t v46 = v50;
  double v47 = *((double *)&v50 + 1) * 0.000001;
  sub_18E0961B4(4, 4, (uint64_t)&v35);
  uint64_t v17 = *((void *)&v37 + 1);
  **((void **)&v37 + 1) = *(void *)(v30 + 752);
  uint64_t v18 = SHIDWORD(v36);
  *(void *)(v17 + 8 * SHIDWORD(v36)) = *(void *)(v30 + 760);
  *(void *)(v17 + 16 * v18) = *(void *)(v30 + 768);
  *(void *)(v17 + 8) = *(void *)(v17 + 8 * v18);
  *(void *)(v17 + 8 * ((int)v18 + 1)) = *(void *)(v30 + 776);
  uint64_t v19 = *(void *)(v30 + 784);
  uint64_t v20 = v17 + 16 * v18;
  *(void *)(v20 + 8) = v19;
  *(void *)(v17 + 16) = *(void *)(v17 + 16 * v18);
  *(void *)(v17 + 8 * ((int)v18 + 2)) = v19;
  *(void *)(v20 + 16) = *(void *)(v30 + 792);
  *(double *)(v17 + 8 * (3 * (int)v18 + 3)) = *(double *)(v30 + 808) * *(double *)(v30 + 808);
  sub_18E1866FC((uint64_t)v32, (uint64_t)v42, (uint64_t)&v35);
  sub_18E186788((uint64_t)v31, (uint64_t)v42);
  sub_18E186678((uint64_t)v33, (uint64_t)v32, (uint64_t)v31);
  double v21 = *(double *)(v30 + 136);
  double v22 = v51;
  double v23 = v21 - v51;
  double v24 = sqrt(*v34 + (float)(*(float *)(v30 + 184) * *(float *)(v30 + 184)));
  *(_OWORD *)(a2 + 8) = xmmword_18E1FD1A0;
  double v27 = cnstatistics::NormalCDF(v25, -vabdd_f64(v21, v22), 0.0, v24);
  if (v27 <= *(double *)(v30 + 824)) {
    double v27 = *(double *)(v30 + 824);
  }
  **(double **)(a2 + 32) = v27 + v27;
  double v28 = cnstatistics::NormalCDF(v26, v23, *(double *)(v30 + 816), v24);
  uint64_t result = 0;
  if (v28 <= *(double *)(v30 + 824)) {
    double v28 = *(double *)(v30 + 824);
  }
  *(double *)(*(void *)(a2 + 32) + 8) = v28;
  return result;
}

double sub_18E186550(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v11 = 12;
  unsigned __int8 v10 = 4;
  double v8 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v11, &v10, "time,%.3lf,t-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v8));
  return result;
}

uint64_t sub_18E1865A8(uint64_t a1)
{
  *(void *)(a1 + 24) = 0x200000002;
  *(void *)a1 = &unk_1EDD18BB8;
  *(void *)(a1 + 32) = a1 + 40;
  *(_OWORD *)(a1 + 8) = xmmword_18E1FD1B0;
  uint64_t result = sub_18DFE2CC8(a1, 0.0);
  int v3 = *(_DWORD *)(a1 + 20) + 1;
  long long v4 = *(void **)(a1 + 32);
  *long long v4 = 0x3FF0000000000000;
  v4[v3] = 0x3FF0000000000000;
  return result;
}

double sub_18E186620(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v11 = 12;
  unsigned __int8 v10 = 4;
  double v8 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v11, &v10, "time,%.3lf,e-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v8));
  return result;
}

__n128 sub_18E186678(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 24) = 0x100000001;
  *(void *)a1 = &unk_1EDD18048;
  *(void *)&long long v3 = 0x100000001;
  *((void *)&v3 + 1) = 0x100000001;
  *(_OWORD *)(a1 + 8) = v3;
  *(void *)(a1 + 32) = a1 + 40;
  sub_18DFE2B44(a2, a3, a1);
  return result;
}

void sub_18E1866DC(_Unwind_Exception *a1)
{
  *double v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

void sub_18E1866FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 24) = 0x400000001;
  *(void *)a1 = &unk_1EDD182E8;
  *(_OWORD *)(a1 + 8) = xmmword_18E1FD6B0;
  *(void *)(a1 + 32) = a1 + 40;
  sub_18DFE2B44(a2, a3, a1);
}

void sub_18E186768(_Unwind_Exception *a1)
{
  *double v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

uint64_t sub_18E186788(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 8);
  int v2 = *(_DWORD *)(a2 + 12);
  *(void *)(a1 + 24) = 0x100000004;
  *(void *)a1 = &unk_1EDD19458;
  *(_DWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 12) = v3;
  *(_DWORD *)(a1 + 16) = v3 * v2;
  *(_DWORD *)(a1 + 20) = v2;
  *(void *)(a1 + 32) = a1 + 40;
  return sub_18DFE2C64(a2, a1);
}

uint64_t raven::GNSSPreprocessedMeasurementsChecker::Configure(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  if (!*a2 || !*(unsigned char *)(v8 + 33))
  {
    __int16 v22 = 12;
    unsigned __int8 v21 = 4;
    uint64_t v18 = "Error: GNSSPreprocessedMeasurementsChecker could not be configured. Raven parameters are not initialized.";
LABEL_28:
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v22, &v21, v18, a4, a5, a6, a7, a8, v20);
    return 0xFFFFFFFFLL;
  }
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 168) = v8;
  double v9 = *(double *)(v8 + 616);
  if (v9 < -90.0 || v9 > 90.0)
  {
    __int16 v22 = 12;
    unsigned __int8 v21 = 4;
    uint64_t v18 = "Error: GNSSPreprocessedMeasurementsChecker could not be configured. Invalid gnss_minimum_elevation";
    goto LABEL_28;
  }
  double v10 = *(double *)(v8 + 2232);
  if ((*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v10 < 0.0)
  {
    __int16 v22 = 12;
    unsigned __int8 v21 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v22, &v21, "Error: GNSSPreprocessedMeasurementsChecker invalid minimum expected NLOS path delay,%.3lf", a4, a5, a6, a7, a8, SLOBYTE(v10));
    return 0xFFFFFFFFLL;
  }
  double v11 = *(double *)(v8 + 2224);
  if ((*(void *)&v11 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v11 < 0.0)
  {
    __int16 v22 = 12;
    unsigned __int8 v21 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v22, &v21, "Error: GNSSPreprocessedMeasurementsChecker invalid distance travelled for WiFi crosschecks,%.3lfm", a4, a5, a6, a7, a8, SLOBYTE(v11));
    return 0xFFFFFFFFLL;
  }
  double v12 = *(double *)(v8 + 2288);
  if ((*(void *)&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v12 < 0.0)
  {
    __int16 v22 = 12;
    unsigned __int8 v21 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v22, &v21, "Error: GNSSPreprocessedMeasurementsChecker invalid duration for WiFi crosschecks (non-pedestrian),%.3lf", a4, a5, a6, a7, a8, SLOBYTE(v12));
    return 0xFFFFFFFFLL;
  }
  double v13 = *(double *)(v8 + 2296);
  if ((*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v13 < 0.0)
  {
    __int16 v22 = 12;
    unsigned __int8 v21 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v22, &v21, "Error: GNSSPreprocessedMeasurementsChecker invalid duration for WiFi crosschecks (pedestrian),%.3lf", a4, a5, a6, a7, a8, SLOBYTE(v13));
    return 0xFFFFFFFFLL;
  }
  double v14 = *(double *)(v8 + 1568);
  if ((*(void *)&v14 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v14 < 0.0)
  {
    __int16 v22 = 12;
    unsigned __int8 v21 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v22, &v21, "Error: GNSSPreprocessedMeasurementsChecker invalid maximum non-ADR dwell time,%.3lf", a4, a5, a6, a7, a8, SLOBYTE(v14));
    return 0xFFFFFFFFLL;
  }
  double v15 = *(double *)(v8 + 1544);
  if ((*(void *)&v15 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v15 < 0.0 || v15 > 1.0)
  {
    __int16 v22 = 12;
    unsigned __int8 v21 = 4;
    char v20 = LOBYTE(v15);
    uint64_t v18 = "Error: GNSSPreprocessedMeasurementsChecker invalid fraction of sensor cache allowed for back-propagation,%.3lf";
    goto LABEL_28;
  }
  double v16 = *(double *)(v8 + 2216);
  if (v16 <= 0.0)
  {
    __int16 v22 = 12;
    unsigned __int8 v21 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v22, &v21, "GNSSPreprocessedMeasurementsChecker: Invalid maximum allowed duration since last LOS HMM  WiFi cross-check update,%.3lf", a4, a5, a6, a7, a8, SLOBYTE(v16));
    return 0xFFFFFFFFLL;
  }
  uint64_t v17 = 0;
  *(double *)(a1 + 24) = v9 * 0.0174532925;
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(v8 + 2305);
  *(unsigned char *)(a1 + 80) = 5;
  *(unsigned char *)(a1 + 8) = 1;
  return v17;
}

uint64_t raven::GNSSPreprocessedMeasurementsChecker::CanSvAndMeasurementDataBeIncluded(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24)) {
    BOOL v2 = *(_DWORD *)(a1 + 28) == -1;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    return 0;
  }
  switch(*(unsigned char *)(a1 + 24))
  {
    case 1:
      if (!*(unsigned char *)(a2 + 595)) {
        return 0;
      }
      break;
    case 2:
      if (!*(unsigned char *)(a2 + 594)) {
        return 0;
      }
      break;
    case 3:
      if (!*(unsigned char *)(a2 + 593)) {
        return 0;
      }
      break;
    case 4:
      if (!*(unsigned char *)(a2 + 592)) {
        return 0;
      }
      break;
    case 5:
      if (!*(unsigned char *)(a2 + 596)) {
        return 0;
      }
      break;
    default:
      break;
  }
  uint64_t v4 = *(void *)(a1 + 328);
  if (*(void *)(a1 + 336) == v4) {
    return 0;
  }
  double v5 = *(double *)(a1 + 264);
  uint64_t result = 1;
  if (fabs(v5) <= 1.57079633 && v5 < *(double *)(a2 + 616) * 0.0174532925)
  {
    uint64_t v7 = *(void *)v4;
    double v8 = *(double *)(v4 + 8);
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)1) <= 1)
    {
      __int16 v16 = 12;
      unsigned __int8 v15 = 1;
      sub_18E017C64(a1);
      double v14 = v8 + (double)v7;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v16, &v15, "t,%.3lf,%s,GnssPreprocessedMeasurementChecker: Sat excluded,low elevation,%.2f rad, mask,%.2f rad", v9, v10, v11, v12, v13, SLOBYTE(v14));
    }
    return 0;
  }
  return result;
}

uint64_t raven::GNSSPreprocessedMeasurementsChecker::CanObservableBeIncluded(uint64_t a1, uint64_t a2, double *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 96);
  if (!v8) {
    return 0;
  }
  double v10 = *(double *)(a1 + 104);
  if (v10 <= 0.0) {
    return 0;
  }
  float v11 = *(float *)(a1 + 168);
  if (v11 <= 0.0 || *(unsigned char *)(a1 + 40) == 0) {
    return 0;
  }
  if (*(float *)(a1 + 112) < *(float *)(a4 + 612)) {
    return 0;
  }
  double v13 = *(double *)(a1 + 120);
  if ((*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (LODWORD(v11) & 0x7FFFFFFFu) > 0x7F7FFFFF
    || (*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    return 0;
  }
  switch(*(unsigned char *)(a1 + 100))
  {
    case 1:
      if (!*(unsigned char *)(a4 + 602) && *(unsigned char *)(a2 + 24) == 1) {
        return 0;
      }
      if (*(unsigned char *)(a4 + 604)) {
        goto LABEL_30;
      }
      goto LABEL_21;
    case 2:
      if (!*(unsigned char *)(a4 + 603) && *(unsigned char *)(a2 + 24) == 1) {
        return 0;
      }
      if (*(unsigned char *)(a4 + 605)) {
        goto LABEL_30;
      }
LABEL_21:
      if (*(unsigned char *)(a2 + 24) == 5) {
        return 0;
      }
LABEL_30:
      if ((v8 - 2) >= 3)
      {
        if (v8 != 1)
        {
          if (v8 == 5) {
            return 0;
          }
          goto LABEL_51;
        }
        if (*(unsigned char *)(a4 + 607))
        {
          switch(*(unsigned char *)(a2 + 24))
          {
            case 0:
              __int16 v41 = 12;
              unsigned __int8 v40 = 4;
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v41, &v40, "GNSSPreprocessedMeasurementsChecker invalid constellation,%d", a4, a5, a6, a7, a8, 0);
              return 0;
            case 1:
            case 2:
            case 3:
              if (v13 < 15000000.0) {
                goto LABEL_65;
              }
              double v15 = 30000000.0;
              goto LABEL_50;
            case 4:
              unsigned int v27 = *(_DWORD *)(a2 + 28);
              if (v27 <= 0x3F && ((1 << v27) & 0xF80000000000003ELL) != 0
                || a3[11] * a3[11] + a3[15] * a3[15] + a3[19] * a3[19] > 9.0e14)
              {
                if (v13 >= 30000000.0 && v13 <= 45000000.0) {
                  goto LABEL_51;
                }
                if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) <= 1)
                {
                  __int16 v41 = 12;
                  unsigned __int8 v40 = 1;
                  char v28 = sub_18E017C64(a2);
                  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v41, &v40, "Satellite %s invalid GEO/IGSO range %f", v29, v30, v31, v32, v33, v28);
                }
              }
              else
              {
                if (v13 >= 15000000.0 && v13 <= 30000000.0) {
                  goto LABEL_51;
                }
                if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) <= 1)
                {
                  __int16 v41 = 12;
                  unsigned __int8 v40 = 1;
                  char v34 = sub_18E017C64(a2);
                  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v41, &v40, "Satellite %s invalid MEO range %f", v35, v36, v37, v38, v39, v34);
                }
              }
              break;
            case 5:
            case 6:
              if (v13 < 30000000.0) {
                goto LABEL_65;
              }
              double v15 = 45000000.0;
LABEL_50:
              if (v13 <= v15) {
                goto LABEL_51;
              }
LABEL_65:
              if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) <= 1)
              {
                __int16 v41 = 12;
                unsigned __int8 v40 = 1;
                char v21 = sub_18E017C64(a2);
                cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v41, &v40, "Satellite %s invalid range %f", v22, v23, v24, v25, v26, v21);
              }
              return 0;
            default:
              goto LABEL_51;
          }
        }
        return 0;
      }
      if (!*(unsigned char *)(a4 + 606)) {
        return 0;
      }
      if (v8 == 3)
      {
        if (!*(unsigned char *)(a4 + 609)) {
          return 0;
        }
      }
      else if (v8 == 4)
      {
        if (!*(unsigned char *)(a4 + 608)) {
          return 0;
        }
      }
      else if (!*(unsigned char *)(a4 + 610))
      {
        return 0;
      }
      if (fabs(v13 / (299792458.0 / v10)) > 15000.0) {
        return 0;
      }
LABEL_51:
      double v16 = *(double *)(a4 + 1568);
      double v17 = *(double *)(a4 + 648) * 350.0;
      if (v17 >= *(double *)(a4 + 656) * 350.0) {
        double v17 = *(double *)(a4 + 656) * 350.0;
      }
      if ((v8 - 1) < 2) {
        return *(double *)(a1 + 200) - *(double *)(a1 + 192) <= v16;
      }
      if ((v8 - 3) >= 2) {
        return v8 != 5;
      }
      double v18 = -(v17 * *(double *)(a4 + 1544));
      if (*(unsigned char *)(a4 + 544)) {
        return *(double *)(a1 + 192) >= v18;
      }
      uint64_t result = 0;
      double v20 = *(double *)(a1 + 192);
      if (*(double *)(a1 + 200) - v20 <= v16 && v20 >= v18) {
        return 1;
      }
      return result;
    case 4:
    case 5:
      if (!*(unsigned char *)(a4 + 598)) {
        return 0;
      }
      goto LABEL_30;
    case 6:
      if (!*(unsigned char *)(a4 + 599)) {
        return 0;
      }
      goto LABEL_30;
    case 7:
      if (!*(unsigned char *)(a4 + 600)) {
        return 0;
      }
      goto LABEL_30;
    case 8:
      if (!*(unsigned char *)(a4 + 601)) {
        return 0;
      }
      goto LABEL_30;
    case 0xA:
      if (!*(unsigned char *)(a4 + 597)) {
        return 0;
      }
      goto LABEL_30;
    default:
      goto LABEL_30;
  }
}

uint64_t raven::GNSSPreprocessedMeasurementsChecker::HandleEvent(raven::GNSSPreprocessedMeasurementsChecker *this, const raven::GnssPreprocessedMeasurementsEvent *a2, raven::GnssPreprocessedMeasurementsEvent *a3)
{
  if (!*((unsigned char *)this + 8))
  {
    LOWORD(v28[0]) = 12;
    unsigned __int8 v29 = 4;
    uint64_t v20 = (*(uint64_t (**)(const raven::GnssPreprocessedMeasurementsEvent *, const raven::GnssPreprocessedMeasurementsEvent *, raven::GnssPreprocessedMeasurementsEvent *))(*(void *)a2 + 16))(a2, a2, a3);
    double v27 = v21 + (double)v20;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v28, &v29, "t,%.3lf,GNSSPreprocessedMeasurementsChecker, not configured", v22, v23, v24, v25, v26, SLOBYTE(v27));
    return 0xFFFFFFFFLL;
  }
  if (raven::GNSSMeasurementSelectionParameters::AllMeasurementsExcluded((raven::GNSSMeasurementSelectionParameters *)(*((void *)this + 21) + 592))) {
    return 0xFFFFFFFFLL;
  }
  int v6 = *((unsigned __int8 *)this + 9);
  long long v7 = *(_OWORD *)((char *)a2 + 8);
  *(_OWORD *)((char *)a3 + 24) = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)a3 + 8) = v7;
  long long v8 = *(_OWORD *)((char *)a2 + 40);
  long long v9 = *(_OWORD *)((char *)a2 + 56);
  long long v10 = *(_OWORD *)((char *)a2 + 72);
  *((void *)a3 + 11) = *((void *)a2 + 11);
  *(_OWORD *)((char *)a3 + 72) = v10;
  *(_OWORD *)((char *)a3 + 56) = v9;
  *(_OWORD *)((char *)a3 + 40) = v8;
  if (v6)
  {
    if (a3 != a2) {
      sub_18E021A70((uint64_t)a3 + 96, *((uint64_t **)a2 + 12), *((uint64_t **)a2 + 13), (uint64_t)(*((void *)a2 + 13) - *((void *)a2 + 12)) >> 4);
    }
    raven::GNSSPreprocessedMeasurementsChecker::UpdateAndPopulateProbabilityLOS(this, (uint64_t **)a3);
    v28[0] = (*(uint64_t (**)(const raven::GnssPreprocessedMeasurementsEvent *))(*(void *)a2 + 16))(a2);
    v28[1] = v11;
    raven::GNSSPreprocessedMeasurementsChecker::RemoveOldLOSEstimators(this, (uint64_t)v28, v12, v13);
    uint64_t v15 = *((void *)a3 + 12);
    uint64_t v14 = *((void *)a3 + 13);
    if (v15 != v14)
    {
      uint64_t v16 = v15 + 16;
      do
      {
        uint64_t v17 = *(void *)(v16 - 16);
        if (v17) {
          BOOL v18 = 1;
        }
        else {
          BOOL v18 = v16 == v14;
        }
        v16 += 16;
      }
      while (!v18);
      if (v17) {
        return 0;
      }
      else {
        return 0xFFFFFFFFLL;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (a3 != a2) {
    sub_18E021A70((uint64_t)a3 + 96, *((uint64_t **)a2 + 12), *((uint64_t **)a2 + 13), (uint64_t)(*((void *)a2 + 13) - *((void *)a2 + 12)) >> 4);
  }
  return 0;
}

void raven::GNSSPreprocessedMeasurementsChecker::UpdateAndPopulateProbabilityLOS(raven::GNSSPreprocessedMeasurementsChecker *this, uint64_t **a2)
{
  if (!*(unsigned char *)(*((void *)this + 21) + 3816)) {
    return;
  }
  double v5 = (unsigned __int8 *)*((void *)this + 2);
  if (v5[664]) {
    BOOL v6 = v5[776] - 3 < 2;
  }
  else {
    BOOL v6 = 0;
  }
  unsigned int v8 = v5[56];
  long long v7 = v5 + 56;
  if (v8 >= 2)
  {
    long long v9 = *((_OWORD *)v7 + 1);
    *((_OWORD *)this + 5) = *(_OWORD *)v7;
    *((_OWORD *)this + 6) = v9;
    long long v10 = *((_OWORD *)v7 + 2);
    long long v11 = *((_OWORD *)v7 + 3);
    long long v12 = *((_OWORD *)v7 + 4);
    *((void *)this + 20) = *((void *)v7 + 10);
    *((_OWORD *)this + 8) = v11;
    *((_OWORD *)this + 9) = v12;
    *((_OWORD *)this + 7) = v10;
  }
  unint64_t v13 = *((unsigned __int8 *)this + 80);
  BOOL v177 = 0;
  uint64_t v217 = ((uint64_t (*)(uint64_t **))(*a2)[2])(a2);
  double v218 = v14;
  uint64_t v215 = &unk_1EDD137C0;
  memset(v216, 0, 17);
  memset(&v216[3], 0, 17);
  memset(&v216[6], 0, 17);
  v216[10] = 0;
  v216[9] = 0;
  v216[11] = 0x7FF8000000000000;
  memset(&v216[12], 0, 17);
  memset(&v216[15], 0, 17);
  memset(&v216[18], 0, 17);
  v216[21] = 0;
  v216[22] = 0;
  v216[23] = 0x7FF8000000000000;
  LOWORD(v216[24]) = 0;
  BYTE2(v216[24]) = 0;
  int8x16_t v21 = (int8x16_t)vdupq_n_s64(0x7FF8000000000000uLL);
  *(int8x16_t *)&v216[25] = v21;
  *(int8x16_t *)&v216[27] = v21;
  *(int8x16_t *)&v216[29] = v21;
  *(int8x16_t *)&v216[31] = v21;
  v216[33] = 0x7FF8000000000000;
  LOBYTE(v216[34]) = 0;
  *(int8x16_t *)&v216[35] = v21;
  *(int8x16_t *)&v216[37] = v21;
  *(int8x16_t *)&v216[39] = v21;
  *(int8x16_t *)&v216[41] = v21;
  v216[43] = 0x7FF8000000000000;
  double v214 = NAN;
  uint64_t v169 = (char *)this + 80;
  if (*(unsigned char *)(*((void *)this + 21) + 3817)) {
    BOOL v22 = v6;
  }
  else {
    BOOL v22 = 0;
  }
  double v213 = NAN;
  if (v22)
  {
    if (raven::GNSSPreprocessedMeasurementsChecker::GetWiFiPositionForCrossCheck((uint64_t)this, (uint64_t)&v217, (double *)&v215, v15, v16, v17, v18, v19, *(double *)v21.i64, v20))BOOL v177 = raven::GNSSPreprocessedMeasurementsChecker::GetClockOffsetForCrossCheck(this, (const raven::GnssPreprocessedMeasurementsEvent *)a2, &v214, &v213); {
    else
    }
      BOOL v177 = 0;
  }
  int v23 = *((unsigned __int8 *)this + 192);
  if (*((unsigned char *)this + 192))
  {
    uint64_t v24 = CNTimeSpan::operator-((uint64_t)&v217, (void *)this + 22, v21, v20);
    *(void *)&v180.f64[0] = v24;
    v180.f64[1] = v25;
    if (v24 < 0 || v25 < 0.0)
    {
      uint64_t v29 = CNTimeSpan::operator-(v180.f64, v26, v27);
      double v28 = v30;
    }
    else
    {
      double v28 = v25;
      uint64_t v29 = v24;
    }
    v26.i64[0] = *(void *)(*((void *)this + 21) + 2216);
    double v212 = 0.0;
    uint64_t v211 = 0;
    uint64_t v31 = CNTimeSpan::SetTimeSpan(&v211, 0, v26, v27);
    if (v29 || (*(void *)&v28 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
    {
      if (!v211)
      {
        double v32 = v212;
        if ((*(void *)&v212 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
        {
LABEL_25:
          if (v32 < v28)
          {
LABEL_26:
            if (!cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v31))
            {
              LOWORD(v211) = 12;
              unsigned __int8 v210 = 0;
              double v162 = v218 + (double)v217;
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v211, &v210, "GNSSPreprocessedMeasurementsChecker, gating the usage of LOS Estimator other evidence as no wifi cross-check seen recently,t,%.3lf, time_since,%.3lf", v33, v34, v35, v36, v37, SLOBYTE(v162));
            }
            int v23 = 0;
            goto LABEL_31;
          }
LABEL_30:
          int v23 = 1;
          goto LABEL_31;
        }
      }
      if (v29 != v211)
      {
        if (v29 >= v211) {
          goto LABEL_26;
        }
        goto LABEL_30;
      }
    }
    double v32 = v212;
    goto LABEL_25;
  }
LABEL_31:
  unsigned int v38 = (v13 < 0xA) & (0xCu >> v13);
  uint64_t v39 = *((void *)this + 21);
  if (*(unsigned char *)(v39 + 2192))
  {
    if (*((unsigned char *)this + 72)) {
      int v40 = v23;
    }
    else {
      int v40 = 0;
    }
    HIDWORD(v171) = v38 & v40 & v6;
  }
  else
  {
    HIDWORD(v171) = 0;
  }
  if (*(unsigned char *)(v39 + 2193))
  {
    if (!*((unsigned char *)this + 72)) {
      int v23 = 0;
    }
    LODWORD(v171) = v38 & v23 & v6;
  }
  else
  {
    LODWORD(v171) = 0;
  }
  double v173 = a2[13];
  int v178 = a2[12];
  if (v178 != v173)
  {
    double v174 = (void *)((char *)this + 48);
    int64x2_t v175 = vdupq_n_s64(0x7FF8000000000000uLL);
    __asm { FMOV            V0.2D, #1.0 }
    float64x2_t v168 = _Q0;
    while (1)
    {
      uint64_t v45 = *v178;
      if (!*v178) {
        goto LABEL_169;
      }
      unint64_t v46 = *(int *)(v45 + 28) + 1000 * *(unsigned __int8 *)(v45 + 24);
      unint64_t v47 = *((void *)this + 5);
      uint64_t v179 = *v178;
      if (v47)
      {
        uint8x8_t v48 = (uint8x8_t)vcnt_s8((int8x8_t)v47);
        v48.i16[0] = vaddlv_u8(v48);
        if (v48.u32[0] > 1uLL)
        {
          uint64_t v2 = *(int *)(v45 + 28) + 1000 * *(unsigned __int8 *)(v45 + 24);
          if (v47 <= v46) {
            uint64_t v2 = v46 % v47;
          }
        }
        else
        {
          uint64_t v2 = (v47 - 1) & v46;
        }
        long long v49 = *(float64_t **)(*((void *)this + 4) + 8 * v2);
        if (v49)
        {
          float64_t v50 = *v49;
          if (*(void *)v49)
          {
            do
            {
              unint64_t v51 = *(void *)(*(void *)&v50 + 8);
              if (v51 == v46)
              {
                if (*(_DWORD *)(*(void *)&v50 + 16) == v46) {
                  goto LABEL_118;
                }
              }
              else
              {
                if (v48.u32[0] > 1uLL)
                {
                  if (v51 >= v47) {
                    v51 %= v47;
                  }
                }
                else
                {
                  v51 &= v47 - 1;
                }
                if (v51 != v2) {
                  break;
                }
              }
              float64_t v50 = **(double **)&v50;
            }
            while (v50 != 0.0);
          }
        }
      }
      uint64_t v52 = (char *)operator new(0xE0uLL);
      *(void *)&v180.f64[0] = v52;
      *(void *)&v180.f64[1] = (char *)this + 48;
      LOBYTE(__p[0]) = 0;
      *(void *)uint64_t v52 = 0;
      *((void *)v52 + 1) = v46;
      *((_DWORD *)v52 + 4) = v46;
      *(_OWORD *)(v52 + 40) = 0u;
      *(_OWORD *)(v52 + 24) = 0u;
      *(_OWORD *)(v52 + 56) = 0u;
      *(_OWORD *)(v52 + 72) = 0u;
      *(_OWORD *)(v52 + 120) = 0u;
      *(_OWORD *)(v52 + 136) = 0u;
      *(_OWORD *)(v52 + 152) = 0u;
      *(_OWORD *)(v52 + 168) = 0u;
      *(_OWORD *)(v52 + 184) = 0u;
      *(_OWORD *)(v52 + 200) = 0u;
      *((void *)v52 + 27) = 0;
      *(_OWORD *)(v52 + 104) = 0u;
      *(_OWORD *)(v52 + 88) = 0u;
      *((void *)v52 + 5) = &unk_1EDD0A470;
      *((void *)v52 + 9) = 0x100000002;
      *((void *)v52 + 6) = &unk_1EDD18B28;
      *((void *)v52 + 7) = 0;
      *((void *)v52 + 10) = v52 + 88;
      *((void *)v52 + 16) = 0x100000002;
      *((void *)v52 + 13) = &unk_1EDD18B28;
      *((void *)v52 + 17) = v52 + 144;
      *((void *)v52 + 21) = 0x3DDB7CDFD9D7BDBBLL;
      *((void *)v52 + 8) = 0;
      *((void *)v52 + 14) = 0;
      *((void *)v52 + 15) = 0;
      *((_DWORD *)v52 + 40) = 1;
      sub_18DEDE7B0((void *)v52 + 22, "");
      v52[200] = 0;
      *((_DWORD *)v52 + 51) = -1;
      *((void *)v52 + 26) = 0;
      *((void *)v52 + 27) = 0x7FF8000000000000;
      LOBYTE(__p[0]) = 1;
      float v53 = (float)(unint64_t)(*((void *)this + 7) + 1);
      float v54 = *((float *)this + 16);
      uint64_t v45 = v179;
      if (!v47 || (float)(v54 * (float)v47) < v53) {
        break;
      }
LABEL_108:
      char v71 = *(void **)(*((void *)this + 4) + 8 * v2);
      float64_t v50 = v180.f64[0];
      if (v71)
      {
        **(void **)&v180.f64[0] = *v71;
      }
      else
      {
        **(void **)&v180.f64[0] = *((void *)this + 6);
        *((float64_t *)this + 6) = v50;
        *(void *)(*((void *)this + 4) + 8 * v2) = v174;
        if (!**(void **)&v50) {
          goto LABEL_117;
        }
        unint64_t v72 = *(void *)(**(void **)&v50 + 8);
        if ((v47 & (v47 - 1)) != 0)
        {
          if (v72 >= v47) {
            v72 %= v47;
          }
        }
        else
        {
          v72 &= v47 - 1;
        }
        char v71 = (void *)(*((void *)this + 4) + 8 * v72);
      }
      *(float64_t *)char v71 = v50;
LABEL_117:
      v180.f64[0] = 0.0;
      ++*((void *)this + 7);
      sub_18E1890D8((uint64_t)&v180);
LABEL_118:
      if (!*(unsigned char *)(*(void *)&v50 + 24))
      {
        float64x2_t v180 = 0uLL;
        __p[0] = (void *)0x7FF8000000000000;
        sub_18DEDE7B0(&__p[1], "");
        LOBYTE(v183) = 0;
        DWORD1(v183) = -1;
        v180.f64[0] = *((float64_t *)this + 21);
        *(void *)&v180.f64[1] = sub_18E128CBC(v45);
        __p[0] = v90;
        std::string::operator=((std::string *)&__p[1], (const std::string *)v45);
        *(void *)&long long v183 = *(void *)(v45 + 24);
        if (raven::RavenLineOfSightEstimator::Initialize(*(void *)&v50 + 24, (uint64_t *)&v180))
        {
          LOWORD(v211) = 12;
          unsigned __int8 v210 = 4;
          char v91 = sub_18E017C64(v45);
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v211, &v210, "GNSSPreprocessedMeasurementsChecker could not initialize LOS estimator,svid,%s", v92, v93, v94, v95, v96, v91);
          if (SHIBYTE(v182) < 0) {
            operator delete(__p[1]);
          }
          goto LABEL_169;
        }
        uint64_t v176 = (raven::RavenLineOfSightEstimator *)(*(void *)&v50 + 24);
        if (SHIBYTE(v182) < 0) {
          operator delete(__p[1]);
        }
LABEL_127:
        uint64_t v98 = *(void *)(v45 + 328);
        uint64_t v97 = *(void *)(v45 + 336);
        if (v98 == v97)
        {
LABEL_168:
          *(double *)(v45 + 296) = raven::RavenLineOfSightEstimator::GetProbabilityLOS(v176);
          *(unsigned char *)(v45 + 304) = 1;
          goto LABEL_169;
        }
        int v170 = (int)(*(double *)(v45 + 264) * 57.2957795 + 0.5);
        __str = (std::string *)(v45 + 40);
        uint64_t v99 = (long long *)(v45 + 72);
        while (2)
        {
          int v100 = *(_DWORD *)(v98 + 96);
          if (v100) {
            _ZF = v100 == 5;
          }
          else {
            _ZF = 1;
          }
          if (_ZF)
          {
            LOWORD(v180.f64[0]) = 12;
            LOBYTE(v211) = 4;
            uint64_t v103 = *(void *)v98;
            double v102 = *(double *)(v98 + 8);
            sub_18E017C64(v45);
            double v163 = v102 + (double)v103;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v180, (unsigned __int8 *)&v211, "GNSSPreprocessedMeasurementsChecker,t,%.3lf,invalid measurement type,svid,%s,type,%d", v104, v105, v106, v107, v108, SLOBYTE(v163));
          }
          else if (v100 == 1)
          {
            if (v177)
            {
              v180.f64[0] = 0.0;
              v180.f64[1] = NAN;
              __p[0] = 0;
              __p[1] = 0;
              LOBYTE(v182) = 0;
              *((void *)&v182 + 1) = 0;
              *(void *)&long long v183 = 0;
              BYTE8(v183) = 0;
              long long v184 = 0uLL;
              LOBYTE(v185) = 0;
              *((void *)&v185 + 1) = 0;
              *(void *)&long long v186 = 0;
              *((void *)&v186 + 1) = 0x7FF8000000000000;
              LODWORD(v187) = 0;
              BYTE4(v187) = 0;
              *((void *)&v187 + 1) = 0x7FF8000000000000;
              *(int64x2_t *)&v188[8] = v175;
              *(int64x2_t *)&v188[24] = v175;
              *(int64x2_t *)&v188[40] = v175;
              *(_DWORD *)uint64_t v188 = 2143289344;
              *(_DWORD *)&v188[56] = 2143289344;
              v188[60] = 0;
              LOBYTE(v189) = 0;
              BYTE4(v189) = 0;
              BYTE8(v189) = 0;
              WORD6(v189) = 0;
              BYTE14(v189) = 1;
              int64x2_t v190 = v175;
              uint64_t v2 = (uint64_t)&unk_1EDD0AE58;
              int8x16_t v191 = &unk_1EDD0AE58;
              uint64_t v109 = (std::string *)sub_18DEDE7B0(&v192, "");
              LOBYTE(v194) = 0;
              HIDWORD(v194) = -1;
              long long v195 = 0u;
              long long v196 = 0u;
              long long v197 = 0u;
              long long v198 = 0u;
              long long v199 = 0u;
              long long v200 = 0u;
              long long v201 = 0u;
              long long v202 = 0u;
              long long v203 = 0u;
              long long v204 = 0u;
              long long v205 = 0u;
              memset(v207, 0, 17);
              *((void *)&v207[1] + 1) = 0;
              *(void *)&v207[2] = 0;
              BYTE8(v207[2]) = 0;
              memset(&v207[3], 0, 17);
              *((void *)&v207[4] + 1) = 0;
              *(void *)&v207[5] = 0;
              double v206 = &unk_1EDD137C0;
              *((void *)&v207[5] + 1) = 0x7FF8000000000000;
              memset(&v207[6], 0, 17);
              *((void *)&v207[7] + 1) = 0;
              *(void *)&v207[8] = 0;
              BYTE8(v207[8]) = 0;
              memset(&v207[9], 0, 17);
              *((void *)&v207[10] + 1) = 0;
              *(void *)&v207[11] = 0;
              *((void *)&v207[11] + 1) = 0x7FF8000000000000;
              LOWORD(v207[12]) = 0;
              BYTE2(v207[12]) = 0;
              *((void *)&v207[12] + 1) = 0x7FF8000000000000;
              v207[13] = v175;
              v207[14] = v175;
              v207[15] = v175;
              v207[16] = v175;
              LOBYTE(v207[17]) = 0;
              *((void *)&v207[17] + 1) = 0x7FF8000000000000;
              v207[18] = v175;
              v207[19] = v175;
              v207[20] = v175;
              v207[21] = v175;
              long long v208 = 0u;
              long long v209 = 0u;
              float64x2_t v180 = *(float64x2_t *)(*(void *)&v50 + 208);
              long long v110 = *(_OWORD *)(v98 + 144);
              long long v111 = *(_OWORD *)(v98 + 160);
              long long v112 = *(_OWORD *)(v98 + 176);
              int64x2_t v190 = *(int64x2_t *)(v98 + 192);
              *(_OWORD *)std::string __p = *(_OWORD *)v98;
              long long v113 = *(_OWORD *)(v98 + 16);
              long long v114 = *(_OWORD *)(v98 + 32);
              long long v115 = *(_OWORD *)(v98 + 64);
              long long v184 = *(_OWORD *)(v98 + 48);
              long long v185 = v115;
              long long v182 = v113;
              long long v183 = v114;
              long long v116 = *(_OWORD *)(v98 + 80);
              long long v117 = *(_OWORD *)(v98 + 96);
              long long v118 = *(_OWORD *)(v98 + 128);
              *(_OWORD *)uint64_t v188 = *(_OWORD *)(v98 + 112);
              *(_OWORD *)&v188[16] = v118;
              long long v186 = v116;
              long long v187 = v117;
              *(_OWORD *)&v188[48] = v111;
              long long v189 = v112;
              *(_OWORD *)&v188[32] = v110;
              std::string::operator=(v109, __str);
              uint64_t v194 = *(void *)(v179 + 64);
              long long v119 = *v99;
              long long v120 = v99[2];
              long long v196 = v99[1];
              long long v197 = v120;
              long long v195 = v119;
              long long v121 = v99[3];
              long long v122 = v99[4];
              long long v123 = v99[6];
              long long v200 = v99[5];
              long long v201 = v123;
              long long v198 = v121;
              long long v199 = v122;
              long long v124 = v99[7];
              long long v125 = v99[8];
              long long v126 = v99[10];
              long long v204 = v99[9];
              long long v205 = v126;
              long long v202 = v124;
              long long v203 = v125;
              memcpy(v207, v216, sizeof(v207));
              *(double *)&long long v208 = v214;
              *((double *)&v208 + 1) = v213;
              *(void *)&long long v209 = *(void *)(*((void *)this + 21) + 2232);
              *((void *)&v209 + 1) = *(void *)(*(void *)&v50 + 168);
              int v127 = raven::RavenLineOfSightEstimator::Update((uint64_t)v176, (uint64_t)&v180);
              if (v127)
              {
                LOWORD(v211) = 12;
                unsigned __int8 v210 = 4;
                uint64_t v128 = *(void *)v98;
                double v129 = *(double *)(v98 + 8);
                sub_18E017C64(v179);
                double v164 = v129 + (double)v128;
                cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v211, &v210, "GNSSPreprocessedMeasurementsChecker,t,%.3lf,could not update LOS estimator using WiFi cross-check,svid,%s", v130, v131, v132, v133, v134, SLOBYTE(v164));
              }
              else
              {
                int v135 = *((unsigned __int8 *)this + 192);
                *((_OWORD *)this + 11) = *(_OWORD *)(*(void *)&v50 + 208);
                if (!v135) {
                  *((unsigned char *)this + 192) = 1;
                }
              }
              int8x16_t v191 = &unk_1EDD0AE58;
              if (v193 < 0) {
                operator delete(v192);
              }
              char v136 = BYTE4(v171) | v171;
              if (v127) {
                char v136 = 0;
              }
              uint64_t v45 = v179;
              if (v136)
              {
LABEL_148:
                float64x2_t v180 = 0uLL;
                *(_OWORD *)std::string __p = *(_OWORD *)(*(void *)&v50 + 208);
                uint64_t v2 = *((void *)this + 21) + 2304;
                if (HIDWORD(v171))
                {
                  CN0Likelihoods = (cnprint::CNPrinter *)raven::RavenLosEstimatorLookupTables::LosEstimatorLookupTablesAccessor::GetCN0Likelihoods(*((void *)this + 21) + 2304, (char *)(v98 + 100), v170, *(float *)(v98 + 112), (uint64_t)v169, v180.f64, &v180.f64[1], v82, v83);
                  if (CN0Likelihoods
                    || (CN0Likelihoods = (cnprint::CNPrinter *)raven::RavenLineOfSightEstimator::Update((uint64_t)v176, v180.f64), CN0Likelihoods))
                  {
                    if (cnprint::CNPrinter::GetLogLevel(CN0Likelihoods) <= 1)
                    {
                      LOWORD(v211) = 12;
                      unsigned __int8 v210 = 1;
                      uint64_t v138 = *(void *)v98;
                      double v139 = *(double *)(v98 + 8);
                      sub_18E017C64(v179);
                      double v165 = v139 + (double)v138;
                      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v211, &v210, "GNSSPreprocessedMeasurementsChecker,t,%.3lf,could not update LOS estimator using C/N0 likelihoods,svid,%s,lookuptableReturnCode,%d", v140, v141, v142, v143, v144, SLOBYTE(v165));
                    }
                  }
                }
                if (v171)
                {
                  unsigned int v145 = *(unsigned __int8 *)(v98 + 100);
                  if (v145 > 0xA)
                  {
LABEL_157:
                    MPFSetLikelihoods = (cnprint::CNPrinter *)raven::RavenLosEstimatorLookupTables::LosEstimatorLookupTablesAccessor::GetMPFSetLikelihoods(v2, (char *)(v98 + 100), v170, (uint64_t)v169, v180.f64, &v180.f64[1], v82, v83);
                    if (MPFSetLikelihoods)
                    {
                      if (cnprint::CNPrinter::GetLogLevel(MPFSetLikelihoods) <= 1)
                      {
                        LOWORD(v211) = 12;
                        unsigned __int8 v210 = 1;
                        uint64_t v147 = *(void *)v98;
                        double v148 = *(double *)(v98 + 8);
                        sub_18E017C64(v179);
                        double v166 = v148 + (double)v147;
                        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v211, &v210, "GNSSPreprocessedMeasurementsChecker,t,%.3lf,LOS estimator could not get MPF Set likelihoods from lookup tables,svid,%s,lookuptableReturnCode,%d", v149, v150, v151, v152, v153, SLOBYTE(v166));
                      }
                    }
                    else
                    {
                      if (*(unsigned char *)(v98 + 189) != 1) {
                        float64x2_t v180 = vsubq_f64(v168, v180);
                      }
                      if (raven::RavenLineOfSightEstimator::Update((uint64_t)v176, v180.f64))
                      {
                        LOWORD(v211) = 12;
                        unsigned __int8 v210 = 4;
                        uint64_t v154 = *(void *)v98;
                        double v155 = *(double *)(v98 + 8);
                        sub_18E017C64(v179);
                        double v167 = v155 + (double)v154;
                        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v211, &v210, "GNSSPreprocessedMeasurementsChecker,t,%.3lf,could not update LOS estimator using MPF Set likelihoods,svid,%s", v156, v157, v158, v159, v160, SLOBYTE(v167));
                      }
                    }
                  }
                  else if (((1 << v145) & 0x544) != 0)
                  {
                    if (*(float *)(v98 + 112) > *(float *)(*((void *)this + 21) + 2208)) {
                      goto LABEL_157;
                    }
                  }
                  else if (*(unsigned char *)(v98 + 100))
                  {
                    goto LABEL_157;
                  }
                }
                uint64_t v45 = v179;
              }
            }
            else if (v171)
            {
              goto LABEL_148;
            }
          }
          v98 += 208;
          if (v98 == v97) {
            goto LABEL_168;
          }
          continue;
        }
      }
      v180.f64[0] = 0.0;
      v180.f64[1] = NAN;
      *(void *)&v180.f64[0] = sub_18E128CBC(v45);
      v180.f64[1] = v73;
      if (!raven::RavenLineOfSightEstimator::Predict(*(void *)&v50 + 24, (uint64_t)&v180, v80, v81, v74, v75, v76, v77, v78, v79))
      {
        uint64_t v176 = (raven::RavenLineOfSightEstimator *)(*(void *)&v50 + 24);
        goto LABEL_127;
      }
      LOWORD(v211) = 12;
      unsigned __int8 v210 = 4;
      char v84 = sub_18E017C64(v45);
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v211, &v210, "GNSSPreprocessedMeasurementsChecker could not predict LOS estimator,svid,%s", v85, v86, v87, v88, v89, v84);
      *(unsigned char *)(*(void *)&v50 + 24) = 0;
      *(void *)(*(void *)&v50 + 208) = 0;
      *(void *)(*(void *)&v50 + 216) = 0x7FF8000000000000;
LABEL_169:
      v178 += 2;
      if (v178 == v173) {
        return;
      }
    }
    BOOL v55 = v47 < 3 || (v47 & (v47 - 1)) != 0;
    unint64_t v56 = v55 | (2 * v47);
    unint64_t v57 = vcvtps_u32_f32(v53 / v54);
    if (v56 <= v57) {
      int8x8_t prime = (int8x8_t)v57;
    }
    else {
      int8x8_t prime = (int8x8_t)v56;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v47 = *((void *)this + 5);
    if (*(void *)&prime > v47) {
      goto LABEL_74;
    }
    if (*(void *)&prime < v47)
    {
      unint64_t v65 = vcvtps_u32_f32((float)*((unint64_t *)this + 7) / *((float *)this + 16));
      if (v47 < 3 || (uint8x8_t v66 = (uint8x8_t)vcnt_s8((int8x8_t)v47), v66.i16[0] = vaddlv_u8(v66), v66.u32[0] > 1uLL))
      {
        unint64_t v65 = std::__next_prime(v65);
      }
      else
      {
        uint64_t v67 = 1 << -(char)__clz(v65 - 1);
        if (v65 >= 2) {
          unint64_t v65 = v67;
        }
      }
      if (*(void *)&prime <= v65) {
        int8x8_t prime = (int8x8_t)v65;
      }
      if (*(void *)&prime >= v47)
      {
        unint64_t v47 = *((void *)this + 5);
      }
      else
      {
        if (prime)
        {
LABEL_74:
          if (*(void *)&prime >> 61) {
            sub_18DEDF7D4();
          }
          uint64_t v59 = operator new(8 * *(void *)&prime);
          int v60 = (void *)*((void *)this + 4);
          *((void *)this + 4) = v59;
          if (v60) {
            operator delete(v60);
          }
          uint64_t v61 = 0;
          *((int8x8_t *)this + 5) = prime;
          do
            *(void *)(*((void *)this + 4) + 8 * v61++) = 0;
          while (*(void *)&prime != v61);
          unsigned int v62 = (void *)*v174;
          if (*v174)
          {
            unint64_t v63 = v62[1];
            uint8x8_t v64 = (uint8x8_t)vcnt_s8(prime);
            v64.i16[0] = vaddlv_u8(v64);
            if (v64.u32[0] > 1uLL)
            {
              if (v63 >= *(void *)&prime) {
                v63 %= *(void *)&prime;
              }
            }
            else
            {
              v63 &= *(void *)&prime - 1;
            }
            *(void *)(*((void *)this + 4) + 8 * v63) = v174;
            uint64_t v68 = (void *)*v62;
            if (*v62)
            {
              do
              {
                unint64_t v69 = v68[1];
                if (v64.u32[0] > 1uLL)
                {
                  if (v69 >= *(void *)&prime) {
                    v69 %= *(void *)&prime;
                  }
                }
                else
                {
                  v69 &= *(void *)&prime - 1;
                }
                if (v69 != v63)
                {
                  uint64_t v70 = *((void *)this + 4);
                  if (!*(void *)(v70 + 8 * v69))
                  {
                    *(void *)(v70 + 8 * v69) = v62;
                    goto LABEL_99;
                  }
                  *unsigned int v62 = *v68;
                  *uint64_t v68 = **(void **)(*((void *)this + 4) + 8 * v69);
                  **(void **)(*((void *)this + 4) + 8 * v69) = v68;
                  uint64_t v68 = v62;
                }
                unint64_t v69 = v63;
LABEL_99:
                unsigned int v62 = v68;
                uint64_t v68 = (void *)*v68;
                unint64_t v63 = v69;
              }
              while (v68);
            }
          }
          unint64_t v47 = (unint64_t)prime;
          goto LABEL_103;
        }
        __int16 v161 = (void *)*((void *)this + 4);
        *((void *)this + 4) = 0;
        if (v161) {
          operator delete(v161);
        }
        unint64_t v47 = 0;
        *((void *)this + 5) = 0;
      }
    }
LABEL_103:
    if ((v47 & (v47 - 1)) != 0)
    {
      if (v47 <= v46) {
        uint64_t v2 = v46 % v47;
      }
      else {
        uint64_t v2 = v46;
      }
    }
    else
    {
      uint64_t v2 = (v47 - 1) & v46;
    }
    goto LABEL_108;
  }
}

void sub_18E188204(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,void *__p,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
}

void raven::GNSSPreprocessedMeasurementsChecker::RemoveOldLOSEstimators(void *a1, uint64_t a2, double a3, int8x16_t a4)
{
  uint64_t v4 = (char *)(a1 + 6);
  double v5 = (char *)a1[6];
  if (v5)
  {
    while (1)
    {
      *(_OWORD *)std::string __p = *((_OWORD *)v5 + 13);
      unsigned int v8 = (cnprint::CNPrinter *)CNTimeSpan::operator-(a2, __p, *(int8x16_t *)__p, a4);
      *(double *)a4.i64 = (double)(uint64_t)v8;
      if (v9 + (double)(uint64_t)v8 > *(double *)(a1[21] + 2200)) {
        break;
      }
      long long v12 = *(char **)v5;
LABEL_37:
      double v5 = v12;
      if (!v12) {
        return;
      }
    }
    if (cnprint::CNPrinter::GetLogLevel(v8) <= 1)
    {
      __int16 v33 = 12;
      unsigned __int8 v32 = 1;
      uint64_t v10 = *(void *)a2;
      double v11 = *(double *)(a2 + 8);
      if (v5[199] < 0)
      {
        sub_18DEDE668(__p, *((void **)v5 + 22), *((void *)v5 + 23));
      }
      else
      {
        *(_OWORD *)std::string __p = *((_OWORD *)v5 + 11);
        uint64_t v30 = *((void *)v5 + 24);
      }
      uint64_t v31 = *((void *)v5 + 25);
      sub_18E017C64((uint64_t)__p);
      double v28 = v11 + (double)v10;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v33, &v32, "GNSSPreprocessedMeasurementsChecker,t,%.3lf,removing LOS estimator,%s,age,%.2lf,max_age,%.2lf", v13, v14, v15, v16, v17, SLOBYTE(v28));
      if (SHIBYTE(v30) < 0) {
        operator delete(__p[0]);
      }
    }
    int8x8_t v18 = (int8x8_t)a1[5];
    long long v12 = *(char **)v5;
    unint64_t v19 = *((void *)v5 + 1);
    uint8x8_t v20 = (uint8x8_t)vcnt_s8(v18);
    v20.i16[0] = vaddlv_u8(v20);
    if (v20.u32[0] > 1uLL)
    {
      if (v19 >= *(void *)&v18) {
        v19 %= *(void *)&v18;
      }
    }
    else
    {
      v19 &= *(void *)&v18 - 1;
    }
    uint64_t v21 = a1[4];
    BOOL v22 = *(char **)(v21 + 8 * v19);
    do
    {
      int v23 = v22;
      BOOL v22 = *(char **)v22;
    }
    while (v22 != v5);
    if (v23 == v4) {
      goto LABEL_40;
    }
    unint64_t v24 = *((void *)v23 + 1);
    if (v20.u32[0] > 1uLL)
    {
      if (v24 >= *(void *)&v18) {
        v24 %= *(void *)&v18;
      }
    }
    else
    {
      v24 &= *(void *)&v18 - 1;
    }
    uint64_t v25 = *(void *)v5;
    if (v24 != v19)
    {
LABEL_40:
      if (v12)
      {
        unint64_t v26 = *((void *)v12 + 1);
        if (v20.u32[0] > 1uLL)
        {
          if (v26 >= *(void *)&v18) {
            v26 %= *(void *)&v18;
          }
        }
        else
        {
          v26 &= *(void *)&v18 - 1;
        }
        uint64_t v25 = *(void *)v5;
        if (v26 == v19) {
          goto LABEL_30;
        }
      }
      *(void *)(v21 + 8 * v19) = 0;
      uint64_t v25 = *(void *)v5;
    }
    if (!v25)
    {
LABEL_36:
      *(void *)int v23 = v25;
      *(void *)double v5 = 0;
      --a1[7];
      __p[0] = v5;
      __p[1] = v4;
      LOBYTE(v30) = 1;
      sub_18E1890D8((uint64_t)__p);
      goto LABEL_37;
    }
LABEL_30:
    unint64_t v27 = *(void *)(v25 + 8);
    if (v20.u32[0] > 1uLL)
    {
      if (v27 >= *(void *)&v18) {
        v27 %= *(void *)&v18;
      }
    }
    else
    {
      v27 &= *(void *)&v18 - 1;
    }
    if (v27 != v19)
    {
      *(void *)(a1[4] + 8 * v27) = v23;
      uint64_t v25 = *(void *)v5;
    }
    goto LABEL_36;
  }
}

void sub_18E188538(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL raven::GNSSPreprocessedMeasurementsChecker::GetClockOffsetForCrossCheck(raven::GNSSPreprocessedMeasurementsChecker *this, const raven::GnssPreprocessedMeasurementsEvent *a2, double *a3, double *a4)
{
  if (!*((unsigned char *)this + 8)) {
    return 0;
  }
  unsigned int v8 = (cnprint::CNPrinter *)(*(uint64_t (**)(const raven::GnssPreprocessedMeasurementsEvent *))(*(void *)a2 + 16))(a2);
  uint64_t v9 = (uint64_t)v8;
  v64[0] = v8;
  *(double *)&v64[1] = v10;
  double v11 = v10;
  if (!*((unsigned char *)a2 + 48) || !*((unsigned char *)a2 + 32) || !*((unsigned char *)a2 + 64))
  {
    if (cnprint::CNPrinter::GetLogLevel(v8) <= 1)
    {
      LOWORD(v62) = 12;
      LOBYTE(v61[0]) = 1;
      double v53 = v11 + (double)v9;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v62, (unsigned __int8 *)v61, "GNSSPreprocessedMeasurementsChecker,t,%.3lf,cannot determine the time of previous GNSS measurement", v24, v25, v26, v27, v28, SLOBYTE(v53));
    }
    return 0;
  }
  long long v12 = sub_18DFF465C((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E21CC78);
  if (!v12 || (uint64_t v15 = v12, !*((unsigned char *)v12 + 2008)))
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v12) <= 1)
    {
      LOWORD(v62) = 12;
      LOBYTE(v61[0]) = 1;
      double v54 = v11 + (double)v9;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v62, (unsigned __int8 *)v61, "GNSSPreprocessedMeasurementsChecker,no clock bias estimate available,%.3lf", v30, v31, v32, v33, v34, SLOBYTE(v54));
    }
    return 0;
  }
  v13.i64[0] = *(void *)(*((void *)this + 21) + 3472);
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  CNTimeSpan::SetTimeSpan(&v62, 0, v13, v14);
  uint64_t v18 = CNTimeSpan::operator-((uint64_t)v64, v15 + 149, v16, v17);
  uint64_t v22 = v18;
  *(void *)&v61[0] = v18;
  v61[1] = v19;
  double v23 = v19;
  if (v18 < 0 || v19 < 0.0)
  {
    uint64_t v18 = CNTimeSpan::operator-(v61, v20, v21);
    v20.i64[0] = v35;
    if (v18) {
      goto LABEL_18;
    }
  }
  else
  {
    *(double *)v20.i64 = v19;
    if (v18) {
      goto LABEL_18;
    }
  }
  if ((v20.i64[0] & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
    goto LABEL_21;
  }
LABEL_18:
  if (!v62)
  {
    v21.i64[0] = v63;
    if ((v63 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
      goto LABEL_22;
    }
  }
  BOOL v36 = v18 <= v62;
  if (v18 == v62)
  {
LABEL_21:
    v21.i64[0] = v63;
LABEL_22:
    BOOL v36 = *(double *)v20.i64 <= *(double *)v21.i64;
  }
  if (!v36)
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v18) <= 1)
    {
      LOWORD(v59) = 12;
      LOBYTE(v58[0]) = 1;
      double v55 = v11 + (double)v9;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v59, (unsigned __int8 *)v58, "GNSSPreprocessedMeasurementsChecker,time difference too large for clock bias prediction,t_gps,%.3lf,t_wifi,%.3lf", v37, v38, v39, v40, v41, SLOBYTE(v55));
    }
    return 0;
  }
  if (!*((unsigned char *)a2 + 64)) {
    goto LABEL_34;
  }
  v20.i64[0] = *((void *)a2 + 7);
  v58[0] = 0;
  v58[1] = 0;
  CNTimeSpan::SetTimeSpan(v58, 0, v20, v21);
  uint64_t v59 = CNTimeSpan::operator-((uint64_t)v64, v58, v42, v43);
  double v60 = v44;
  BOOL v45 = sub_18DEE4CB8((double *)v15 + 149, (double *)&v59);
  BOOL v46 = v45;
  if (v45)
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v45) <= 1)
    {
      LOWORD(v58[0]) = 12;
      unsigned __int8 v57 = 1;
      double v56 = v60 + (double)v59;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v58, &v57, "GNSSPreprocessedMeasurementsChecker,stale solution,t_last_gps,%.3lf,t_wifi,%.3lf", v47, v48, v49, v50, v51, SLOBYTE(v56));
    }
    return !v46;
  }
  if (!*((unsigned char *)a2 + 32) || !*((unsigned char *)a2 + 48)) {
LABEL_34:
  }
    sub_18DFF28FC();
  double v52 = v23 + (double)v22;
  *a3 = (*((double *)a2 + 3) - *((double *)a2 + 5) + *((double *)v15 + 252) + *((double *)v15 + 253) * v52) * 1000000.0;
  *a4 = sqrt(*((double *)v15 + 254) + (v52 * *((double *)v15 + 256) + *((double *)v15 + 255) * 2.0) * v52) * 1000000.0;
  return !v46;
}

uint64_t raven::GNSSPreprocessedMeasurementsChecker::GetWiFiPositionForCrossCheck(uint64_t a1, uint64_t a2, double *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, int8x16_t a10)
{
  if (!*(unsigned char *)(a1 + 8)) {
    return 0;
  }
  a10.i64[0] = *(void *)(a2 + 8);
  double v11 = *(double *)a10.i64 + (double)*(uint64_t *)a2;
  if (COERCE__INT64(fabs(v11)) > 0x7FEFFFFFFFFFFFFFLL || v11 < 0.0)
  {
    v42.i16[0] = 12;
    LOBYTE(v41[0]) = 4;
    LOBYTE(v38) = LOBYTE(v11);
    int8x16_t v16 = "GNSSPreprocessedMeasurementsChecker,invalid time,%.3lf";
    goto LABEL_14;
  }
  int8x16_t v13 = *(unsigned char **)(a1 + 16);
  if (!v13[1152] || !v13[1440])
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) > 1) {
      return 0;
    }
    v42.i16[0] = 12;
    LOBYTE(v41[0]) = 1;
    double v38 = *(double *)(a2 + 8) + (double)*(uint64_t *)a2;
    int8x16_t v16 = "GNSSPreprocessedMeasurementsChecker,no wifi solution to cross-check,%.3lf";
    goto LABEL_14;
  }
  unsigned int v14 = v13[1360];
  if (v14 <= 0xF && ((1 << v14) & 0xF7EF) != 0)
  {
    v42.i16[0] = 12;
    LOBYTE(v41[0]) = 4;
    LOBYTE(v38) = LOBYTE(v11);
    int8x16_t v16 = "GNSSPreprocessedMeasurementsChecker,wifi solution has non-wifi source,time,%.3lf,source,%d";
LABEL_14:
    int8x16_t v17 = &v42;
    uint64_t v18 = (unsigned __int8 *)v41;
LABEL_15:
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v17, v18, v16, a4, a5, a6, a7, a8, SLOBYTE(v38));
    return 0;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_1EB404D70, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(qword_1EB404D70))
  {
    qword_1EB404DA0 = 0;
    xmmword_1EB404D80 = 0u;
    xmmword_1EB404D90 = 0u;
    __cxa_guard_release(qword_1EB404D70);
  }
  int8x16_t v21 = *(int8x16_t **)(a1 + 16);
  if (!v21[72].i8[0]) {
    goto LABEL_50;
  }
  int8x16_t v42 = v21[79];
  *(double *)v23.i64 = (double)CNTimeSpan::operator-((uint64_t)&xmmword_1EB404D80, &v42, v42, a10);
  if (v24 + *(double *)v23.i64 != 0.0)
  {
    qword_1EB404DA0 = 0;
    xmmword_1EB404D80 = 0u;
    xmmword_1EB404D90 = 0u;
    uint64_t v25 = *(void *)(a1 + 16);
    if (!*(unsigned char *)(v25 + 1152)) {
      goto LABEL_50;
    }
    xmmword_1EB404D80 = *(_OWORD *)(v25 + 1264);
    v22.i64[1] = *((void *)&xmmword_1EB404D80 + 1);
    xmmword_1EB404D90 = xmmword_1EB404D80;
    int8x16_t v21 = *(int8x16_t **)(a1 + 16);
  }
  uint64_t v26 = 2288;
  if ((*(unsigned char *)(a1 + 80) & 0xFE) == 2) {
    uint64_t v26 = 2296;
  }
  v22.i64[0] = *(void *)(*(void *)(a1 + 168) + v26);
  int8x16_t v42 = 0uLL;
  CNTimeSpan::SetTimeSpan(v42.i64, 0, v22, v23);
  if (!v21[72].i8[0]) {
LABEL_50:
  }
    __assert_rtn("operator->", "optional.hpp", 1221, "this->is_initialized()");
  uint64_t v29 = v21[79].i64[1];
  v41[0] = v21[79].i64[0];
  v41[1] = v29;
  uint64_t v30 = CNTimeSpan::operator-(a2, v41, v27, v28);
  if (v30)
  {
    if (v30 < 0) {
      goto LABEL_43;
    }
  }
  else
  {
    if ((*(void *)&v31 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
    {
      if (v31 < 0.0) {
        goto LABEL_43;
      }
LABEL_36:
      double v32 = *(double *)&v42.i64[1];
      goto LABEL_37;
    }
    if (v31 < 0.0) {
      goto LABEL_43;
    }
  }
  if (v42.i64[0] || (double v32 = *(double *)&v42.i64[1], (v42.i64[1] & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000))
  {
    if (v30 != v42.i64[0])
    {
      if (v30 <= v42.i64[0]) {
        goto LABEL_38;
      }
LABEL_43:
      if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v30)) {
        return 0;
      }
      __int16 v40 = 12;
      char v39 = 0;
      double v38 = *(double *)(a2 + 8) + (double)*(uint64_t *)a2;
      int8x16_t v16 = "GNSSPreprocessedMeasurementsChecker,time misalignment too large for WiFi cross-check,t_gps,%.3lf,t_wifi,%.3lf";
      goto LABEL_47;
    }
    goto LABEL_36;
  }
LABEL_37:
  if (v32 < v31) {
    goto LABEL_43;
  }
LABEL_38:
  uint64_t v33 = sub_18DFF465C((int8x16_t *)v21[1].i64, (unsigned __int8 *)&unk_18E21CC78);
  if (!v33 || !*((unsigned char *)v33 + 1368))
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v33) > 1) {
      return 0;
    }
    __int16 v40 = 12;
    char v39 = 1;
    double v38 = *(double *)(a2 + 8) + (double)*(uint64_t *)a2;
    int8x16_t v16 = "GNSSPreprocessedMeasurementsChecker,no user speed to account for time misalignment,t_gps,%.3lf,t_wifi,%.3lf";
LABEL_47:
    int8x16_t v17 = (int8x16_t *)&v40;
    uint64_t v18 = (unsigned __int8 *)&v39;
    goto LABEL_15;
  }
  uint64_t v34 = (cnprint::CNPrinter *)sub_18E188CB8((double *)a2, *((double *)v33 + 172));
  double v35 = *(double *)&qword_1EB404DA0;
  if (*(double *)&qword_1EB404DA0 > *(double *)(*(void *)(a1 + 168) + 2224))
  {
    if (cnprint::CNPrinter::GetLogLevel(v34)) {
      return 0;
    }
    __int16 v40 = 12;
    char v39 = 0;
    double v38 = *(double *)(a2 + 8) + (double)*(uint64_t *)a2;
    int8x16_t v16 = "GNSSPreprocessedMeasurementsChecker,distance travelled too large for WiFi cross-check,t_gps,%.3lf,dist_travelled,%.3lf";
    goto LABEL_47;
  }
  uint64_t v36 = *(void *)(a1 + 16);
  if (!*(unsigned char *)(v36 + 1152)) {
    __assert_rtn("get", "optional.hpp", 1211, "this->is_initialized()");
  }
  memcpy(a3 + 1, (const void *)(v36 + 1168), 0x160uLL);
  double v37 = v35 * v35 * 0.333333333;
  a3[39] = v37 + a3[39];
  a3[42] = v37 + a3[42];
  a3[44] = v37 + a3[44];
  return 1;
}

uint64_t sub_18E188CB8(double *a1, double a2)
{
  uint64_t result = sub_18DEE4C00(a1, (double *)&xmmword_1EB404D90);
  if (result)
  {
    uint64_t result = CNTimeSpan::operator-((uint64_t)a1, &xmmword_1EB404D90, v5, v6);
    *(double *)&qword_1EB404DA0 = *(double *)&qword_1EB404DA0 + a2 * (v7 + (double)result);
    xmmword_1EB404D90 = *(_OWORD *)a1;
  }
  return result;
}

void raven::GNSSPreprocessedMeasurementsChecker::Reset(raven::GNSSPreprocessedMeasurementsChecker *this)
{
  if (*((void *)this + 7))
  {
    sub_18E188EDC(*((void **)this + 6));
    *((void *)this + 6) = 0;
    uint64_t v2 = *((void *)this + 5);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*((void *)this + 4) + 8 * i) = 0;
    }
    *((void *)this + 7) = 0;
  }
  if (*((unsigned char *)this + 192)) {
    *((unsigned char *)this + 192) = 0;
  }
}

uint64_t sub_18E188D88(uint64_t a1)
{
  *(void *)(a1 + 224) = &unk_1EDD0AE58;
  if (*(char *)(a1 + 255) < 0) {
    operator delete(*(void **)(a1 + 232));
  }
  *(void *)(a1 + 224) = &unk_1EDD0A9B8;
  return a1;
}

void *sub_18E188DF8(void *a1)
{
  *a1 = &unk_1EDD15800;
  sub_18E188EA0((uint64_t)(a1 + 4));
  return a1;
}

void sub_18E188E3C(void *a1)
{
  *a1 = &unk_1EDD15800;
  sub_18E188EA0((uint64_t)(a1 + 4));

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E188EA0(uint64_t a1)
{
  sub_18E188EDC(*(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_18E188EDC(void *a1)
{
  if (a1)
  {
    double v1 = a1;
    do
    {
      uint64_t v2 = (void *)*v1;
      sub_18E188F20((uint64_t)(v1 + 2));
      operator delete(v1);
      double v1 = v2;
    }
    while (v2);
  }
}

void sub_18E188F20(uint64_t a1)
{
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  *(void *)(a1 + 24) = &unk_1EDD0A470;
  *(void *)(a1 + 88) = &unk_1EDD17478;
  *(void *)(a1 + 32) = &unk_1EDD17478;
}

void *sub_18E188FB0(void *result)
{
  *uint64_t result = &unk_1EDD0A470;
  result[8] = &unk_1EDD17478;
  result[1] = &unk_1EDD17478;
  return result;
}

void sub_18E189010(void *a1)
{
  *a1 = &unk_1EDD0A470;
  a1[8] = &unk_1EDD17478;
  a1[1] = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

double sub_18E189080@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 24) = 0x100000002;
  *(void *)a2 = &unk_1EDD18B28;
  *(_OWORD *)(a2 + 8) = xmmword_18E1FD1A0;
  *(void *)(a2 + 32) = a2 + 40;
  if (*(_DWORD *)(a1 + 120)) {
    uint64_t v2 = a1 + 64;
  }
  else {
    uint64_t v2 = a1 + 8;
  }
  *(void *)&double result = sub_18DFE2F24(a2, v2).n128_u64[0];
  return result;
}

void sub_18E1890D8(uint64_t a1)
{
  double v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_18E188F20((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

raven::RavenLosEstimatorLookupTables::CN0StandardNormalCDF *raven::RavenLosEstimatorLookupTables::CN0StandardNormalCDF::CN0StandardNormalCDF(raven::RavenLosEstimatorLookupTables::CN0StandardNormalCDF *this)
{
  for (unint64_t i = 0; i != 99; ++i)
  {
    float v3 = (float)((float)((float)i * 10.0) / 99.0) + -5.0;
    *((double *)this + i + 50) = cnstatistics::NormalCDF(this, v3, 0.0, 1.0);
    *((float *)this + i) = v3;
  }
  uint64_t v7 = 0x4014000000000000;
  long long v6 = xmmword_18E1FD940;
  sub_18DFE3D74((double *)&v6, (double *)&v7);
  *((void *)this + 149) = v4;
  *((_DWORD *)this + 99) = 1084227584;
  return this;
}

double raven::RavenLosEstimatorLookupTables::CN0StandardNormalCDF::GetCDFValue(raven::RavenLosEstimatorLookupTables::CN0StandardNormalCDF *this, float a2)
{
  if (a2 <= -5.0) {
    return *((double *)this + 50);
  }
  if (a2 >= 5.0) {
    return *((double *)this + 149);
  }
  unint64_t v2 = (unint64_t)((float)((float)(a2 + 5.0) * 10.0) + 0.5);
  if (v2 >= 0x64) {
    return *((double *)this + 149);
  }
  float v4 = vabds_f32(a2, *((float *)this + v2));
  if (v2 == 99) {
    goto LABEL_9;
  }
  unint64_t v5 = v2 + 1;
  if (v4 <= vabds_f32(a2, *((float *)this + v2 + 1)))
  {
    if (v2)
    {
LABEL_9:
      unint64_t v5 = (unint64_t)((float)((float)(a2 + 5.0) * 10.0) + 0.5);
      if (v4 > vabds_f32(a2, *((float *)this + v2 - 1))) {
        unint64_t v5 = v2 - 1;
      }
      goto LABEL_12;
    }
    unint64_t v5 = 0;
  }
LABEL_12:
  unint64_t v6 = v5 - 1;
  if (!v5) {
    unint64_t v6 = 0;
  }
  uint64_t v7 = 98;
  if (v5 < 0x62) {
    uint64_t v7 = v5;
  }
  return (*((double *)this + v6 + 50) + *((double *)this + v5 + 50) + *((double *)this + v7 + 51)) * 0.333333333;
}

BOOL raven::RavenLosEstimatorLookupTables::LosEstimatorLookupTablesAccessor::Initialize(raven::RavenLosEstimatorLookupTables::LosEstimatorLookupTablesAccessor *this, const raven::RavenPlatformInfo *a2)
{
  *((unsigned char *)this + 1) = 1;
  GnssChipset = (cnprint::CNPrinter *)CNPlatformInfo::GetGnssChipset(a2);
  switch((int)GnssChipset)
  {
    case 4:
      if (!qword_1EB404DA8) {
        operator new[]();
      }
      *((void *)this + 4) = qword_1EB404DA8;
      uint64_t v5 = qword_1EB404DB0;
      if (!qword_1EB404DB0) {
        operator new[]();
      }
      goto LABEL_25;
    case 6:
      if (!qword_1EB404DB8) {
        operator new[]();
      }
      *((void *)this + 4) = qword_1EB404DB8;
      uint64_t v5 = qword_1EB404DC0;
      if (!qword_1EB404DC0) {
        operator new[]();
      }
      goto LABEL_25;
    case 7:
    case 8:
      if (!qword_1EB404DC8) {
        operator new[]();
      }
      *((void *)this + 4) = qword_1EB404DC8;
      uint64_t v5 = qword_1EB404DD0;
      if (!qword_1EB404DD0) {
        operator new[]();
      }
      goto LABEL_25;
    case 9:
    case 10:
      if (!qword_1EB404DD8) {
        operator new[]();
      }
      *((void *)this + 4) = qword_1EB404DD8;
      uint64_t v5 = qword_1EB404DE0;
      if (!qword_1EB404DE0) {
        operator new[]();
      }
      goto LABEL_25;
    case 11:
      if (!qword_1EB404DE8) {
        operator new[]();
      }
      *((void *)this + 4) = qword_1EB404DE8;
      uint64_t v5 = qword_1EB404DF0;
      if (!qword_1EB404DF0) {
        operator new[]();
      }
LABEL_25:
      *((void *)this + 5) = v5;
      if (!*((unsigned char *)this + 1)) {
        goto LABEL_29;
      }
      double v11 = operator new(0x4C8uLL);
      v11[1] = 0;
      v11[2] = 0;
      void *v11 = &unk_1EDD1E650;
      long long v12 = raven::RavenLosEstimatorLookupTables::CN0StandardNormalCDF::CN0StandardNormalCDF((raven::RavenLosEstimatorLookupTables::CN0StandardNormalCDF *)(v11 + 3));
      int8x16_t v13 = (std::__shared_weak_count *)*((void *)this + 3);
      *((void *)this + 2) = v12;
      *((void *)this + 3) = v11;
      if (v13) {
        sub_18DEE4E18(v13);
      }
      *((void *)this + 1) = a2;
      BOOL result = 1;
      *(unsigned char *)this = 1;
      break;
    default:
      if (cnprint::CNPrinter::GetLogLevel(GnssChipset) <= 1)
      {
        __int16 v17 = 12;
        unsigned __int8 v16 = 1;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v17, &v16, "LOS Estimator C/N0 and/or MPF lookup tables not supported for this HW/platform type", v6, v7, v8, v9, v10, v15);
      }
      *((unsigned char *)this + 1) = 0;
LABEL_29:
      BOOL result = *(unsigned char *)this != 0;
      break;
  }
  return result;
}

void sub_18E18A508(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

uint64_t raven::RavenLosEstimatorLookupTables::LosEstimatorLookupTablesAccessor::GetCN0Likelihoods(uint64_t a1, char *a2, int a3, float a4, uint64_t a5, double *a6, double *a7, uint64_t a8, uint64_t a9)
{
  *a6 = INFINITY;
  *a7 = INFINITY;
  if (!*(unsigned char *)(a1 + 1)) {
    return 4294967294;
  }
  if (!*(void *)(a1 + 16)) {
    return 4294967291;
  }
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  if (raven::RavenLosEstimatorLookupTables::LosEstimatorLookupTablesAccessor::GetGnssBandElevBandIndices(a1, a2, a3, &v37, (uint64_t)a6, (uint64_t)a7, a8, a9))return 0xFFFFFFFFLL; {
  uint64_t v14 = *(void *)(a1 + 32);
  }
  uint64_t v15 = v37;
  uint64_t v16 = v38;
  float v17 = *(float *)(v14 + 56 * v37 + 4 * v38);
  float v18 = *(float *)(v14 + 24);
  uint64_t result = 4294967292;
  BOOL v20 = v17 <= 50.0 && v17 >= 10.0 && v18 <= 10.0;
  if (v20 && v18 > 0.0)
  {
    float v21 = fmaxf(a4 + -2.0, 0.0);
    float v22 = fminf(a4 + 2.0, 50.0);
    float v23 = (float)(v22 - v17) / v18;
    double v24 = *(raven::RavenLosEstimatorLookupTables::CN0StandardNormalCDF **)(a1 + 16);
    double CDFValue = raven::RavenLosEstimatorLookupTables::CN0StandardNormalCDF::GetCDFValue(v24, (float)(v21 - v17) / v18);
    double v26 = raven::RavenLosEstimatorLookupTables::CN0StandardNormalCDF::GetCDFValue(v24, v23) - CDFValue;
    *a6 = v26;
    if (v26 >= 0.0 && v26 <= 1.0)
    {
      uint64_t v28 = *(void *)(a1 + 40);
      float v29 = *(float *)(v28 + 56 * v15 + 4 * v16);
      float v30 = *(float *)(v28 + 24);
      uint64_t result = 4294967292;
      BOOL v32 = v29 <= 50.0 && v29 >= 10.0 && v30 <= 10.0;
      if (v32 && v30 > 0.0)
      {
        float v33 = (float)(v22 - v29) / v30;
        double v34 = raven::RavenLosEstimatorLookupTables::CN0StandardNormalCDF::GetCDFValue(v24, (float)(v21 - v29) / v30);
        double v35 = raven::RavenLosEstimatorLookupTables::CN0StandardNormalCDF::GetCDFValue(v24, v33) - v34;
        *a7 = v35;
        if (v35 > 1.0 || v35 < 0.0) {
          return 4294967293;
        }
        else {
          return 0;
        }
      }
    }
    else
    {
      return 4294967293;
    }
  }
  return result;
}

uint64_t raven::RavenLosEstimatorLookupTables::LosEstimatorLookupTablesAccessor::GetGnssBandElevBandIndices(uint64_t a1, char *a2, int a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 0;
  char v9 = *a2;
  switch(*a2)
  {
    case 0:
    case 9:
      __int16 v14 = 12;
      unsigned __int8 v13 = 4;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v14, &v13, "Invalid GNSS Band type: LOS Estimator C/N0 (or MPF set) likelihoods not found for GNSS band,%d", (uint64_t)a4, a5, a6, a7, a8, v9);
      return 0xFFFFFFFFLL;
    case 2:
      uint64_t v8 = 4;
      break;
    case 3:
      uint64_t v8 = 3;
      break;
    case 4:
    case 5:
      uint64_t v8 = 2;
      break;
    case 6:
      uint64_t v8 = 6;
      break;
    case 7:
      uint64_t v8 = 1;
      break;
    case 8:
      uint64_t v8 = 5;
      break;
    default:
      break;
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  while (dword_18E21CD58[v10] < a3)
  {
    ++v11;
    if (++v10 == 6) {
      return 0xFFFFFFFFLL;
    }
  }
  uint64_t result = 0;
  *a4 = v8;
  a4[1] = v11;
  return result;
}

uint64_t raven::RavenLosEstimatorLookupTables::LosEstimatorLookupTablesAccessor::GetMPFSetLikelihoods(uint64_t a1, char *a2, int a3, uint64_t a4, double *a5, double *a6, uint64_t a7, uint64_t a8)
{
  *a5 = INFINITY;
  *a6 = INFINITY;
  if (!*(unsigned char *)(a1 + 1)) {
    return 4294967294;
  }
  if (!*(unsigned char *)(*(void *)(a1 + 32) + 52)) {
    return 4294967290;
  }
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  if (raven::RavenLosEstimatorLookupTables::LosEstimatorLookupTablesAccessor::GetGnssBandElevBandIndices(a1, a2, a3, &v18, (uint64_t)a5, (uint64_t)a6, a7, a8))return 0xFFFFFFFFLL; {
  uint64_t v12 = v18;
  }
  uint64_t v13 = v19;
  float v14 = *(float *)(*(void *)(a1 + 32) + 56 * v18 + 4 * v19 + 28);
  *a5 = v14;
  uint64_t result = 4294967293;
  if (v14 >= 0.0 && v14 <= 1.0)
  {
    float v16 = *(float *)(*(void *)(a1 + 40) + 56 * v12 + 4 * v13 + 28);
    *a6 = v16;
    if (v16 > 1.0 || v16 < 0.0) {
      return 4294967293;
    }
    else {
      return 0;
    }
  }
  return result;
}

void sub_18E18A90C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EDD1E650;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_18E18A92C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EDD1E650;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x192FA6240);
}

uint64_t raven::StepCountChecker::Configure(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 16) = a3;
  if (*(unsigned char *)(a1 + 24)) {
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(unsigned char *)(a1 + 8) = 1;
  return 0;
}

uint64_t raven::StepCountChecker::HandleEvent(raven::StepCountChecker *this, const raven::StepCountEvent *a2, raven::StepCountEvent *a3)
{
  if (!*((unsigned char *)this + 8))
  {
    __int16 v52 = 12;
    unsigned __int8 v51 = 4;
    uint64_t v15 = (*(uint64_t (**)(const raven::StepCountEvent *, const raven::StepCountEvent *, raven::StepCountEvent *))(*(void *)a2 + 16))(a2, a2, a3);
    double v50 = v16 + (double)v15;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v52, &v51, "t,%.3lf,StepCountChecker, not configured", v17, v18, v19, v20, v21, SLOBYTE(v50));
    return 0xFFFFFFFFLL;
  }
  if (!*((unsigned char *)this + 24))
  {
    uint64_t result = 0;
    *((void *)this + 4) = &unk_1EDD139E0;
    long long v23 = *(_OWORD *)((char *)a2 + 8);
    *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 24);
    *(_OWORD *)((char *)this + 40) = v23;
    long long v24 = *(_OWORD *)((char *)a2 + 40);
    long long v25 = *(_OWORD *)((char *)a2 + 56);
    long long v26 = *(_OWORD *)((char *)a2 + 72);
    *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)a2 + 88);
    *(_OWORD *)((char *)this + 104) = v26;
    *(_OWORD *)((char *)this + 88) = v25;
    *(_OWORD *)((char *)this + 72) = v24;
    long long v27 = *(_OWORD *)((char *)a2 + 104);
    long long v28 = *(_OWORD *)((char *)a2 + 120);
    long long v29 = *(_OWORD *)((char *)a2 + 136);
    uint64_t v30 = *((void *)a2 + 19);
    goto LABEL_19;
  }
  uint64_t v6 = (*(uint64_t (**)(const raven::StepCountEvent *))(*(void *)a2 + 16))(a2);
  if (!*((unsigned char *)this + 24)) {
    goto LABEL_32;
  }
  uint64_t v8 = v6;
  double v9 = v7;
  double v10 = v7;
  uint64_t v11 = (*(uint64_t (**)(char *))(*((void *)this + 4) + 16))((char *)this + 32);
  BOOL v13 = v8 || (*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
  if (v13
    && (!v11 ? (BOOL v14 = (*(void *)&v12 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000) : (BOOL v14 = 1), v14 && v8 != v11))
  {
    if (v8 < v11) {
      goto LABEL_24;
    }
  }
  else if (v10 <= v12)
  {
LABEL_24:
    if (*((unsigned char *)this + 24)) {
      *((unsigned char *)this + 24) = 0;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*((unsigned char *)this + 24)) {
LABEL_32:
  }
    __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
  if (*((_DWORD *)a2 + 38) <= *((_DWORD *)this + 46) || *((_DWORD *)a2 + 39) < *((_DWORD *)this + 47)) {
    goto LABEL_24;
  }
  long long v31 = *(_OWORD *)((char *)a2 + 8);
  *(_OWORD *)((char *)a3 + 24) = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)a3 + 8) = v31;
  long long v32 = *(_OWORD *)((char *)a2 + 40);
  long long v33 = *(_OWORD *)((char *)a2 + 56);
  long long v34 = *(_OWORD *)((char *)a2 + 72);
  *(_OWORD *)((char *)a3 + 88) = *(_OWORD *)((char *)a2 + 88);
  *(_OWORD *)((char *)a3 + 72) = v34;
  *(_OWORD *)((char *)a3 + 56) = v33;
  *(_OWORD *)((char *)a3 + 40) = v32;
  long long v35 = *(_OWORD *)((char *)a2 + 104);
  long long v36 = *(_OWORD *)((char *)a2 + 120);
  long long v37 = *(_OWORD *)((char *)a2 + 136);
  *((void *)a3 + 19) = *((void *)a2 + 19);
  *(_OWORD *)((char *)a3 + 136) = v37;
  *(_OWORD *)((char *)a3 + 120) = v36;
  *(_OWORD *)((char *)a3 + 104) = v35;
  if (*((unsigned char *)this + 9))
  {
    uint64_t v38 = (long long *)((char *)a2 + 8);
    if (*((unsigned char *)this + 24))
    {
      uint64_t result = 0;
      long long v39 = *v38;
      *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 24);
      *(_OWORD *)((char *)this + 40) = v39;
      long long v40 = *(_OWORD *)((char *)a2 + 40);
      long long v41 = *(_OWORD *)((char *)a2 + 56);
      long long v42 = *(_OWORD *)((char *)a2 + 72);
      *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)a2 + 88);
      *(_OWORD *)((char *)this + 104) = v42;
      *(_OWORD *)((char *)this + 88) = v41;
      *(_OWORD *)((char *)this + 72) = v40;
      long long v43 = *(_OWORD *)((char *)a2 + 104);
      long long v44 = *(_OWORD *)((char *)a2 + 120);
      long long v45 = *(_OWORD *)((char *)a2 + 136);
      *((void *)this + 23) = *((void *)a2 + 19);
      *(_OWORD *)((char *)this + 168) = v45;
      *(_OWORD *)((char *)this + 152) = v44;
      *(_OWORD *)((char *)this + 136) = v43;
      return result;
    }
    uint64_t result = 0;
    *((void *)this + 4) = &unk_1EDD139E0;
    long long v46 = *v38;
    *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 24);
    *(_OWORD *)((char *)this + 40) = v46;
    long long v47 = *(_OWORD *)((char *)a2 + 40);
    long long v48 = *(_OWORD *)((char *)a2 + 56);
    long long v49 = *(_OWORD *)((char *)a2 + 72);
    *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)a2 + 88);
    *(_OWORD *)((char *)this + 104) = v49;
    *(_OWORD *)((char *)this + 88) = v48;
    *(_OWORD *)((char *)this + 72) = v47;
    long long v27 = *(_OWORD *)((char *)a2 + 104);
    long long v28 = *(_OWORD *)((char *)a2 + 120);
    long long v29 = *(_OWORD *)((char *)a2 + 136);
    uint64_t v30 = *((void *)a2 + 19);
LABEL_19:
    *((void *)this + 23) = v30;
    *(_OWORD *)((char *)this + 168) = v29;
    *(_OWORD *)((char *)this + 152) = v28;
    *(_OWORD *)((char *)this + 136) = v27;
    *((unsigned char *)this + 24) = 1;
    return result;
  }
  return 0;
}

uint64_t raven::StepCountChecker::Reset(uint64_t this)
{
  if (*(unsigned char *)(this + 24)) {
    *(unsigned char *)(this + 24) = 0;
  }
  return this;
}

uint64_t sub_18E18ACF8(uint64_t result)
{
  *(void *)uint64_t result = &unk_1EDD13D50;
  if (*(unsigned char *)(result + 24)) {
    *(unsigned char *)(result + 24) = 0;
  }
  return result;
}

void sub_18E18AD24(uint64_t a1)
{
  *(void *)a1 = &unk_1EDD13D50;
  if (*(unsigned char *)(a1 + 24)) {
    *(unsigned char *)(a1 + 24) = 0;
  }
  JUMPOUT(0x192FA6240);
}

BOOL raven::RavenPlatformInfo::IsRavenSupportedKarooGnss(raven::RavenPlatformInfo *this)
{
  return CNPlatformInfo::GetGnssChipset(this) - 1 < 2;
}

BOOL raven::RavenPlatformInfo::IsRavenSupportedEurekaGnss(raven::RavenPlatformInfo *this)
{
  return CNPlatformInfo::GetGnssChipset(this) - 3 < 6;
}

BOOL raven::RavenPlatformInfo::IsRavenSupportedMav21orNewerEurekaGnss(raven::RavenPlatformInfo *this)
{
  return CNPlatformInfo::GetGnssChipset(this) - 4 < 5;
}

BOOL raven::RavenPlatformInfo::IsRavenSupportedMav22orNewerEurekaGnss(raven::RavenPlatformInfo *this)
{
  return CNPlatformInfo::GetGnssChipset(this) - 6 < 3;
}

BOOL raven::RavenPlatformInfo::IsRavenSupportedFireGnss(raven::RavenPlatformInfo *this)
{
  return CNPlatformInfo::GetGnssChipset(this) - 9 < 3;
}

BOOL raven::RavenPlatformInfo::IsRavenSupportedFire7orNewerGnss(raven::RavenPlatformInfo *this)
{
  int GnssChipset = CNPlatformInfo::GetGnssChipset(this);
  return GnssChipset != 10 && (GnssChipset & 0xFFFFFFFE) == 10;
}

BOOL raven::RavenPlatformInfo::IsRavenSupportedFire7orNewerPhone(raven::RavenPlatformInfo *this)
{
  int GnssChipset = CNPlatformInfo::GetGnssChipset(this);
  BOOL result = 0;
  if (GnssChipset != 10 && (GnssChipset & 0xFFFFFFFE) == 0xA) {
    return *((_DWORD *)this + 14) == 1;
  }
  return result;
}

BOOL raven::RavenPlatformInfo::IsRavenSupportedFire7orNewerWatch(raven::RavenPlatformInfo *this)
{
  int GnssChipset = CNPlatformInfo::GetGnssChipset(this);
  BOOL result = 0;
  if (GnssChipset != 10 && (GnssChipset & 0xFFFFFFFE) == 0xA) {
    return *((_DWORD *)this + 14) == 3;
  }
  return result;
}

BOOL raven::RavenPlatformInfo::IsRavenSupportedIndusGnss(raven::RavenPlatformInfo *this)
{
  return CNPlatformInfo::GetGnssChipset(this) == 12;
}

BOOL raven::RavenPlatformInfo::IsRavenSupportedIndus25orNewerIndusGnss(raven::RavenPlatformInfo *this)
{
  return CNPlatformInfo::GetGnssChipset(this) == 12;
}

void raven::RavenIonosphereEstimatorActiveObject::RavenIonosphereEstimatorActiveObject(uint64_t a1, unsigned char *a2)
{
  cnframework::ActiveObjectBase::ActiveObjectBase(a1, a2);
  *(void *)uint64_t v2 = &unk_1EDD15A00;
  *(_WORD *)(v2 + 480) = 256;
  *(unsigned char *)(v2 + 488) = 0;
  *(unsigned char *)(v2 + 1320) = 0;
  *(unsigned char *)(v2 + 1328) = 0;
  *(unsigned char *)(v2 + 2160) = 0;
  *(_OWORD *)(v2 + 2168) = 0u;
  *(_OWORD *)(v2 + 2184) = 0u;
  *(_OWORD *)(v2 + 2200) = 0u;
  *(void *)(v2 + 2216) = 0;
  *(void *)(v2 + 2224) = 850045863;
  *(_OWORD *)(v2 + 2232) = 0u;
  *(_OWORD *)(v2 + 2248) = 0u;
  *(_OWORD *)(v2 + 2264) = 0u;
  *(void *)(v2 + 2280) = 0;
  raven::RavenIonosphereEstimator::RavenIonosphereEstimator((raven::RavenIonosphereEstimator *)(v2 + 2288));
}

void sub_18E18B034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_18E18CAEC(v18);
  std::mutex::~mutex(v17);
  sub_18E00CA08(v16);
  cnframework::ActiveObjectBase::~ActiveObjectBase(v15);
  _Unwind_Resume(a1);
}

uint64_t raven::RavenIonosphereEstimatorActiveObject::Configure(cnframework::ActiveObjectBase *this, uint64_t *a2)
{
  if (*((unsigned char *)this + 480) && cnprint::CNPrinter::GetLogLevel(this) <= 1)
  {
    LOWORD(v43) = 12;
    LOBYTE(v42) = 1;
    (*(void (**)(void **__return_ptr, cnframework::ActiveObjectBase *))(*(void *)this + 16))(__p, this);
    if (v45 >= 0) {
      double v9 = __p;
    }
    else {
      LOBYTE(v9) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v43, (unsigned __int8 *)&v42, "Warning: %s configured more than once.", v4, v5, v6, v7, v8, (char)v9);
    if (v45 < 0) {
      operator delete(__p[0]);
    }
  }
  *((unsigned char *)this + 480) = 0;
  uint64_t v10 = *a2;
  if (!*a2 || !*(unsigned char *)(v10 + 33))
  {
    LOWORD(v43) = 12;
    LOBYTE(v42) = 4;
    (*(void (**)(void **__return_ptr, cnframework::ActiveObjectBase *))(*(void *)this + 16))(__p, this);
    if (v45 >= 0) {
      float v22 = __p;
    }
    else {
      LOBYTE(v22) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v43, (unsigned __int8 *)&v42, "Error: %s could not be configured. p_raven_parameters is not initialized.", v17, v18, v19, v20, v21, (char)v22);
    if (v45 < 0) {
      operator delete(__p[0]);
    }
    return 0xFFFFFFFFLL;
  }
  *((void *)this + 277) = v10;
  cnframework::ActiveObjectBase::SetEventQueueDelay(this, 1.0);
  uint64_t v43 = *a2;
  if (raven::RavenIonosphereEstimator::Configure((uint64_t)this + 2288, (uint64_t)&v43))
  {
    __int16 v42 = 12;
    unsigned __int8 v41 = 4;
    (*(void (**)(void **__return_ptr, cnframework::ActiveObjectBase *))(*(void *)this + 16))(__p, this);
    if (v45 >= 0) {
      uint64_t v16 = __p;
    }
    else {
      LOBYTE(v16) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v42, &v41, "Error: %s could not be configured. Configuration of ionosphere estimator failed", v11, v12, v13, v14, v15, (char)v16);
    if (v45 < 0) {
      operator delete(__p[0]);
    }
    *((unsigned char *)this + 480) = 0;
    return 0xFFFFFFFFLL;
  }
  double v23 = *(double *)(*a2 + 3104);
  if ((*(void *)&v23 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (v23 <= 90.0 ? (BOOL v24 = v23 < -10.0) : (BOOL v24 = 1), v24))
  {
    LOWORD(__p[0]) = 12;
    LOBYTE(v42) = 4;
    unsigned __int8 v25 = cnprint::CNLogFormatter::FormatGeneral((const void **)this + 271, "Configure() failed, invalid satellite elevation mask specified,mask,%.2lf", v23);
    if (*((char *)this + 2191) >= 0) {
      LOBYTE(v31) = v25;
    }
    else {
      uint64_t v31 = *((void *)this + 271);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v42, "%s", v26, v27, v28, v29, v30, v31);
    return 0xFFFFFFFFLL;
  }
  *((unsigned char *)this + 480) = 1;
  long long v33 = (cnprint::CNPrinter *)(*(uint64_t (**)(cnframework::ActiveObjectBase *))(*(void *)this + 48))(this);
  unsigned int LogLevel = cnprint::CNPrinter::GetLogLevel(v33);
  if (LogLevel <= 1)
  {
    __int16 v42 = 12;
    unsigned __int8 v41 = 1;
    (*(void (**)(void **__return_ptr, cnframework::ActiveObjectBase *))(*(void *)this + 16))(__p, this);
    if (v45 >= 0) {
      long long v40 = __p;
    }
    else {
      LOBYTE(v40) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v42, &v41, "%s configured successfully.", v35, v36, v37, v38, v39, (char)v40);
    if (v45 < 0) {
      operator delete(__p[0]);
    }
  }
  return 0;
}

void sub_18E18B3C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t raven::RavenIonosphereEstimatorActiveObject::IsConfigured(raven::RavenIonosphereEstimatorActiveObject *this)
{
  return *((unsigned __int8 *)this + 480);
}

void *raven::RavenIonosphereEstimatorActiveObject::GetActiveObjectName@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenIonosphereEstimatorActiveObject");
}

void raven::RavenIonosphereEstimatorActiveObject::HandleEvent(raven::RavenIonosphereEstimatorActiveObject *this, const raven::GnssPreprocessedMeasurementsEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    if (*((unsigned char *)this + 481))
    {
      std::mutex::lock((std::mutex *)((char *)this + 2224));
      raven::RavenIonosphereEstimator::HandleEvent((raven::RavenIonosphereEstimatorActiveObject *)((char *)this + 2288), a2, v4, v5);
      std::mutex::unlock((std::mutex *)((char *)this + 2224));
    }
  }
  else
  {
    __int16 v14 = 12;
    unsigned __int8 v13 = 2;
    unsigned __int8 v6 = cnprint::CNLogFormatter::FormatGeneral((const void **)this + 271, "RavenIonosphereEstimatorActiveObject: not configured");
    if (*((char *)this + 2191) >= 0) {
      LOBYTE(v12) = v6;
    }
    else {
      uint64_t v12 = *((void *)this + 271);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v14, &v13, "%s", v7, v8, v9, v10, v11, v12);
  }
}

void sub_18E18B4CC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void raven::RavenIonosphereEstimatorActiveObject::HandleEvent(raven::RavenIonosphereEstimatorActiveObject *this, const raven::KlobucharParametersEvent *a2)
{
  __int16 v20 = 12;
  unsigned __int8 v19 = 2;
  double v4 = (const void **)((char *)this + 2168);
  cnprint::CNLogFormatter::FormatGeneral((const void **)this + 271, "RavenIonosphereEstimatorActiveObject: received KlobucharParametersEvent");
  if (*((char *)this + 2191) >= 0) {
    LOBYTE(v10) = (_BYTE)v4;
  }
  else {
    uint64_t v10 = *((void *)this + 271);
  }
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v20, &v19, "%s", v5, v6, v7, v8, v9, v10);
  if (*((unsigned char *)this + 480))
  {
    if (*((unsigned char *)this + 481))
    {
      std::mutex::lock((std::mutex *)((char *)this + 2224));
      raven::RavenIonosphereEstimator::HandleEvent((const void **)this + 286, a2);
      std::mutex::unlock((std::mutex *)((char *)this + 2224));
    }
  }
  else
  {
    __int16 v18 = 12;
    unsigned __int8 v17 = 2;
    cnprint::CNLogFormatter::FormatGeneral(v4, "RavenIonosphereEstimatorActiveObject: not configured");
    if (*((char *)this + 2191) >= 0) {
      LOBYTE(v16) = (_BYTE)v4;
    }
    else {
      uint64_t v16 = *((void *)this + 271);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v18, &v17, "%s", v11, v12, v13, v14, v15, v16);
  }
}

void sub_18E18B5FC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void raven::RavenIonosphereEstimatorActiveObject::HandleEvent(const void **this, const raven::RavenSolutionEvent *a2)
{
  uint64_t v2 = this;
  if (!*((unsigned char *)this + 480))
  {
    __int16 v52 = 12;
    unsigned __int8 v51 = 2;
    unsigned __int8 v6 = cnprint::CNLogFormatter::FormatGeneral(this + 271, "RavenIonosphereEstimatorActiveObject: not configured");
    goto LABEL_15;
  }
  if (*((unsigned char *)a2 + 1464))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404E00, memory_order_acquire) & 1) == 0)
    {
      this = (const void **)__cxa_guard_acquire(&qword_1EB404E00);
      if (this)
      {
        qword_1EB404DF8 = 0x400DDB3D742C2656;
        __cxa_guard_release(&qword_1EB404E00);
      }
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404E10, memory_order_acquire) & 1) == 0)
    {
      this = (const void **)__cxa_guard_acquire(&qword_1EB404E10);
      if (this)
      {
        *(double *)&qword_1EB404E08 = *(double *)&qword_1EB404DF8 * *(double *)&qword_1EB404DF8;
        __cxa_guard_release(&qword_1EB404E10);
      }
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404E20, memory_order_acquire) & 1) == 0)
    {
      this = (const void **)__cxa_guard_acquire(&qword_1EB404E20);
      if (this)
      {
        qword_1EB404E18 = 0x400DA639B642E9CDLL;
        __cxa_guard_release(&qword_1EB404E20);
      }
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404E30, memory_order_acquire) & 1) == 0)
    {
      this = (const void **)__cxa_guard_acquire(&qword_1EB404E30);
      if (this)
      {
        *(double *)&qword_1EB404E28 = *(double *)&qword_1EB404E18 * *(double *)&qword_1EB404E18;
        __cxa_guard_release(&qword_1EB404E30);
      }
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404E40, memory_order_acquire) & 1) == 0)
    {
      this = (const void **)__cxa_guard_acquire(&qword_1EB404E40);
      if (this)
      {
        qword_1EB404E38 = 0x3FFBB67AE8584CA8;
        __cxa_guard_release(&qword_1EB404E40);
      }
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404E50, memory_order_acquire) & 1) == 0)
    {
      this = (const void **)__cxa_guard_acquire(&qword_1EB404E50);
      if (this)
      {
        *(double *)&qword_1EB404E48 = *(double *)&qword_1EB404E38 * *(double *)&qword_1EB404E38;
        __cxa_guard_release(&qword_1EB404E50);
      }
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404E60, memory_order_acquire) & 1) == 0)
    {
      this = (const void **)__cxa_guard_acquire(&qword_1EB404E60);
      if (this)
      {
        qword_1EB404E58 = 0x3FFB99F88590841FLL;
        __cxa_guard_release(&qword_1EB404E60);
      }
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404E70, memory_order_acquire) & 1) == 0)
    {
      this = (const void **)__cxa_guard_acquire(&qword_1EB404E70);
      if (this)
      {
        *(double *)&qword_1EB404E68 = *(double *)&qword_1EB404E58 * *(double *)&qword_1EB404E58;
        __cxa_guard_release(&qword_1EB404E70);
      }
    }
    double v4 = *((double *)a2 + 186);
    double v5 = *((double *)a2 + 185) * *((double *)a2 + 185) + *((double *)a2 + 184) * *((double *)a2 + 184);
    if (fabs(v5) >= 2.22044605e-16)
    {
      double v13 = v4 * v4 / v5;
    }
    else
    {
      if (fabs(v4) < 2.22044605e-16)
      {
        __int16 v52 = 12;
        unsigned __int8 v51 = 2;
        unsigned __int8 v6 = cnprint::CNLogFormatter::FormatGeneral(v2 + 271, "Warning: RavenIonosphereEstimatorActiveObject: Receiver location is at the center of the earth. Cannot handle RavenSolutionEvent");
LABEL_15:
        if (*((char *)v2 + 2191) >= 0) {
          LOBYTE(v12) = v6;
        }
        else {
          uint64_t v12 = v2[271];
        }
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v52, &v51, "%s", v7, v8, v9, v10, v11, (char)v12);
        return;
      }
      double v13 = INFINITY;
    }
    if (v13 <= *(double *)&qword_1EB404E08)
    {
      if (v13 > *(double *)&qword_1EB404E48 && *((unsigned char *)v2 + 481))
      {
        if (!cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)this))
        {
          __int16 v52 = 12;
          unsigned __int8 v51 = 0;
          unsigned __int8 v21 = cnprint::CNLogFormatter::FormatGeneral(v2 + 271, "RavenIonosphereEstimatorActiveObject: Receiver location is at a high latitude, but not too high to not run the estimator; run the estimator with an adjusted elevation mas"
                                   "k,tanlat,%.3lf,latthresh,%.3lf,tan_of_abs_lat_thresh_to_use_adjusted_elev_mask_squared,%.3lf",
                                   v13,
                                   *(double *)&qword_1EB404E48,
                                   *(double *)&qword_1EB404E08);
          if (*((char *)v2 + 2191) >= 0) {
            LOBYTE(v27) = v21;
          }
          else {
            uint64_t v27 = v2[271];
          }
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v52, &v51, "%s", v22, v23, v24, v25, v26, (char)v27);
        }
        double v28 = *((double *)v2[277] + 388);
        if (v28 < 15.0) {
          double v28 = 15.0;
        }
        *((double *)v2 + 286) = v28;
      }
      else
      {
        if (v13 <= *(double *)&qword_1EB404E68)
        {
          if (!cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)this))
          {
            __int16 v52 = 12;
            unsigned __int8 v51 = 0;
            unsigned __int8 v36 = cnprint::CNLogFormatter::FormatGeneral(v2 + 271, "RavenIonosphereEstimatorActiveObject: Receiver location is at a low enough latitude to run the estimator without an adjusted elevation mask,tanlat,%.3lf,latthresh,%.3lf", v13, *(double *)&qword_1EB404E68);
            if (*((char *)v2 + 2191) >= 0) {
              LOBYTE(v42) = v36;
            }
            else {
              __int16 v42 = v2[271];
            }
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v52, &v51, "%s", v37, v38, v39, v40, v41, (char)v42);
          }
          double v43 = *((double *)v2[277] + 388);
        }
        else
        {
          if (v13 > *(double *)&qword_1EB404E28 || *((unsigned char *)v2 + 481))
          {
            if (!cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)this))
            {
              __int16 v52 = 12;
              unsigned __int8 v51 = 0;
              unsigned __int8 v29 = cnprint::CNLogFormatter::FormatGeneral(v2 + 271, "RavenIonosphereEstimatorActiveObject: Do nothing. Maintain the current state. This can happen if we are within the hysteresis region,tanlat,%.3lf,tan_of_abs_lat_minus_hysteresis_adjusted_elev_mask_thresh_squared,%.3lf,tan_of_abs_lat_thresh_squared,%.3lf", v13, *(double *)&qword_1EB404E28, *(double *)&qword_1EB404E48);
              if (*((char *)v2 + 2191) >= 0) {
                LOBYTE(v35) = v29;
              }
              else {
                uint64_t v35 = v2[271];
              }
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v52, &v51, "%s", v30, v31, v32, v33, v34, (char)v35);
            }
            goto LABEL_54;
          }
          if (!cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)this))
          {
            __int16 v52 = 12;
            unsigned __int8 v51 = 0;
            unsigned __int8 v44 = cnprint::CNLogFormatter::FormatGeneral(v2 + 271, "RavenIonosphereEstimatorActiveObject: Receiver location is at a high latitude, but no longer at a prohibitively high latitude; run the estimator with an adjusted elev"
                                     "ation mask,tanlat,%.3lf,latthresh,%.3lf",
                                     v13,
                                     *(double *)&qword_1EB404E28);
            if (*((char *)v2 + 2191) >= 0) {
              LOBYTE(v50) = v44;
            }
            else {
              double v50 = v2[271];
            }
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v52, &v51, "%s", v45, v46, v47, v48, v49, (char)v50);
          }
          double v43 = *((double *)v2[277] + 388);
          if (v43 < 15.0) {
            double v43 = 15.0;
          }
        }
        *((double *)v2 + 286) = v43;
        *((unsigned char *)v2 + 481) = 1;
      }
    }
    else if (*((unsigned char *)v2 + 481))
    {
      if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)this) <= 1)
      {
        __int16 v52 = 12;
        unsigned __int8 v51 = 1;
        unsigned __int8 v14 = cnprint::CNLogFormatter::FormatGeneral(v2 + 271, "RavenIonosphereEstimatorActiveObject: Receiver location is at too high of a latitude to run the estimator, disabling the estimator,tanlat,%.3lf,latthresh,%.3lf", v13, *(double *)&qword_1EB404E08);
        if (*((char *)v2 + 2191) >= 0) {
          LOBYTE(v20) = v14;
        }
        else {
          __int16 v20 = v2[271];
        }
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v52, &v51, "%s", v15, v16, v17, v18, v19, (char)v20);
      }
      *((unsigned char *)v2 + 481) = 0;
      raven::RavenIonosphereEstimator::Reset((raven::RavenIonosphereEstimator *)(v2 + 286));
    }
  }
LABEL_54:
  if (*((unsigned char *)v2 + 481))
  {
    std::mutex::lock((std::mutex *)(v2 + 278));
    raven::RavenIonosphereEstimator::HandleEvent((raven::RavenIonosphereEstimator *)(v2 + 286), a2);
    std::mutex::unlock((std::mutex *)(v2 + 278));
  }
}

void sub_18E18BBF8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void raven::RavenIonosphereEstimatorActiveObject::HandleEvent(raven::RavenIonosphereEstimatorActiveObject *this, const raven::TimeMarkEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    if (*((unsigned char *)this + 481))
    {
      double v4 = (std::mutex *)((char *)this + 2224);
      std::mutex::lock((std::mutex *)((char *)this + 2224));
      raven::RavenIonosphereEstimator::HandleEvent((raven::RavenIonosphereEstimatorActiveObject *)((char *)this + 2288), a2);
      if (!*((unsigned char *)this + 2160)
        || (uint64_t v59 = (*(uint64_t (**)(char *))(*((void *)this + 166) + 16))((char *)this + 1328),
            uint64_t v60 = v5,
            uint64_t v57 = 1,
            uint64_t v58 = 0,
            uint64_t v24 = (void *)CNTimeSpan::operator+((uint64_t)&v59, &v57, v6, v7),
            *(void *)&long long v25 = v8,
            sub_18DEE4D28((double *)a2 + 1, (double *)&v24)))
      {
        uint64_t v24 = &unk_1EDD15758;
        __int16 v31 = 0;
        uint64_t v32 = 0;
        uint64_t v33 = 0;
        int64x2_t v34 = vdupq_n_s64(0x7FF8000000000000uLL);
        uint64_t v35 = 0x7FF8000000000000;
        uint64_t v36 = 0;
        int64x2_t v38 = v34;
        int64x2_t v39 = v34;
        int64x2_t v40 = v34;
        int64x2_t v41 = v34;
        int64x2_t v42 = v34;
        int64x2_t v43 = v34;
        uint64_t v37 = 0;
        uint64_t v44 = 0x7FF8000000000000;
        uint64_t v45 = 0x7FF8000000000000;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v50 = 0u;
        uint64_t v51 = 0;
        uint64_t v52 = 0x7FF8000000000000;
        char v53 = 0;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v56 = 0u;
        long long v27 = *(_OWORD *)((char *)a2 + 40);
        long long v28 = *(_OWORD *)((char *)a2 + 56);
        long long v29 = *(_OWORD *)((char *)a2 + 72);
        long long v30 = *(_OWORD *)((char *)a2 + 88);
        long long v25 = *(_OWORD *)((char *)a2 + 8);
        long long v26 = *(_OWORD *)((char *)a2 + 24);
        if (!raven::RavenIonosphereEstimator::PopulateEvent((raven::RavenIonosphereEstimatorActiveObject *)((char *)this + 2288), (raven::ThinShellIonosphereParametersEvent *)&v24))
        {
          uint64_t v9 = operator new(0x60uLL);
          v9[1] = 0;
          v9[2] = 0;
          *uint64_t v9 = &unk_1EDD1E458;
          v9[3] = &unk_1EDD0A260;
          uint64_t v10 = MEMORY[0x1E4FBA3D8];
          *((unsigned char *)v9 + 32) = 0;
          v9[5] = 0;
          v9[6] = v10;
          v9[7] = 0;
          v9[8] = 0;
          sub_18DEDE7B0(v9 + 9, "");
          *((unsigned char *)v9 + 32) = 1;
          operator new();
        }
      }
      if (!*((unsigned char *)this + 1320)
        || (uint64_t v59 = (*(uint64_t (**)(char *))(*((void *)this + 61) + 16))((char *)this + 488),
            uint64_t v60 = v18,
            uint64_t v57 = 1,
            uint64_t v58 = 0,
            uint64_t v24 = (void *)CNTimeSpan::operator+((uint64_t)&v59, &v57, v19, v20),
            *(void *)&long long v25 = v21,
            sub_18DEE4D28((double *)a2 + 1, (double *)&v24)))
      {
        uint64_t v24 = &unk_1EDD15958;
        __int16 v31 = 0;
        uint64_t v32 = 0;
        uint64_t v33 = 0;
        v34.i8[0] = 0;
        v34.i64[1] = 0;
        uint64_t v35 = 0;
        LOBYTE(v36) = 0;
        uint64_t v37 = 0;
        v38.i64[0] = 0;
        v38.i8[8] = 0;
        int64x2_t v39 = 0uLL;
        int64x2_t v40 = vdupq_n_s64(0x7FF8000000000000uLL);
        int64x2_t v41 = v40;
        int64x2_t v42 = v40;
        int64x2_t v43 = v40;
        uint64_t v44 = 0x7FF8000000000000;
        uint64_t v45 = 0x7FF8000000000000;
        long long v49 = 0u;
        long long v50 = 0u;
        long long v47 = 0u;
        long long v48 = 0u;
        long long v46 = 0u;
        uint64_t v51 = 0;
        uint64_t v52 = 0x7FF8000000000000;
        char v53 = 0;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v56 = 0u;
        long long v27 = *(_OWORD *)((char *)a2 + 40);
        long long v28 = *(_OWORD *)((char *)a2 + 56);
        long long v29 = *(_OWORD *)((char *)a2 + 72);
        long long v30 = *(_OWORD *)((char *)a2 + 88);
        long long v25 = *(_OWORD *)((char *)a2 + 8);
        long long v26 = *(_OWORD *)((char *)a2 + 24);
        if (!raven::RavenIonosphereEstimator::PopulateEvent((int8x16_t *)this + 143, (int8x16_t *)&v24))
        {
          uint64_t v22 = operator new(0x60uLL);
          v22[1] = 0;
          v22[2] = 0;
          *uint64_t v22 = &unk_1EDD1E458;
          v22[3] = &unk_1EDD0A260;
          uint64_t v23 = MEMORY[0x1E4FBA3D8];
          *((unsigned char *)v22 + 32) = 0;
          v22[5] = 0;
          v22[6] = v23;
          v22[7] = 0;
          v22[8] = 0;
          sub_18DEDE7B0(v22 + 9, "");
          *((unsigned char *)v22 + 32) = 1;
          operator new();
        }
      }
      std::mutex::unlock(v4);
    }
  }
  else
  {
    LOWORD(v24) = 12;
    LOBYTE(v59) = 2;
    unsigned __int8 v11 = cnprint::CNLogFormatter::FormatGeneral((const void **)this + 271, "RavenIonosphereEstimatorActiveObject: not configured");
    if (*((char *)this + 2191) >= 0) {
      LOBYTE(v17) = v11;
    }
    else {
      uint64_t v17 = *((void *)this + 271);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v24, (unsigned __int8 *)&v59, "%s", v12, v13, v14, v15, v16, v17);
  }
}

void sub_18E18C3F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10)
{
  uint64_t v14 = *(std::__shared_weak_count **)(v12 - 104);
  if (v14) {
    sub_18DEE4E18(v14);
  }
  sub_18DEE4E18(v10);
  std::mutex::unlock(v11);
  _Unwind_Resume(a1);
}

void raven::RavenIonosphereEstimatorActiveObject::Reset(raven::RavenIonosphereEstimatorActiveObject *this)
{
  cnframework::ActiveObjectBase::ResetCurrentTime(this);
  cnframework::ActiveObjectBase::ResetEventQueue(this);
  if (*((unsigned char *)this + 1320)) {
    *((unsigned char *)this + 1320) = 0;
  }
  if (*((unsigned char *)this + 2160)) {
    *((unsigned char *)this + 2160) = 0;
  }
  *((unsigned char *)this + 481) = 1;
  std::mutex::lock((std::mutex *)((char *)this + 2224));
  raven::RavenIonosphereEstimator::Reset((raven::RavenIonosphereEstimatorActiveObject *)((char *)this + 2288));

  std::mutex::unlock((std::mutex *)((char *)this + 2224));
}

void sub_18E18C58C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

std::string *raven::RavenIonosphereEstimatorActiveObject::SetLogPrefix(uint64_t a1, const std::string *a2)
{
  std::string::operator=((std::string *)(a1 + 2192), a2);
  std::string::operator=((std::string *)(a1 + 6128), a2);

  return std::string::operator=((std::string *)(a1 + 8520), a2);
}

uint64_t raven::RavenIonosphereEstimatorActiveObject::GetIonosphereParameters(uint64_t a1, _OWORD *a2)
{
  if (!*(unsigned char *)(a1 + 480))
  {
    LOWORD(v19[0]) = 12;
    unsigned __int8 v51 = 2;
    unsigned __int8 v6 = cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 2168), "RavenIonosphereEstimatorActiveObject: not configured");
    if (*(char *)(a1 + 2191) >= 0) {
      LOBYTE(v12) = v6;
    }
    else {
      uint64_t v12 = *(void *)(a1 + 2168);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v19, &v51, "%s", v7, v8, v9, v10, v11, v12);
    return 0xFFFFFFFFLL;
  }
  if (!*(unsigned char *)(a1 + 481)) {
    return 0xFFFFFFFFLL;
  }
  double v4 = (std::mutex *)(a1 + 2224);
  std::mutex::lock((std::mutex *)(a1 + 2224));
  v19[1] = 0;
  void v19[2] = 0;
  v19[0] = &unk_1EDD15758;
  char v20 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  char v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  char v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0x7FF8000000000000;
  LOWORD(v30) = 0;
  *((void *)&v30 + 1) = 0;
  *(void *)__int16 v31 = 0;
  *(int64x2_t *)&v31[8] = vdupq_n_s64(0x7FF8000000000000uLL);
  *(void *)&v31[24] = 0x7FF8000000000000;
  long long v32 = 0uLL;
  long long v33 = *(_OWORD *)&v31[8];
  long long v34 = *(_OWORD *)&v31[8];
  long long v35 = *(_OWORD *)&v31[8];
  long long v36 = *(_OWORD *)&v31[8];
  long long v37 = *(_OWORD *)&v31[8];
  long long v38 = *(_OWORD *)&v31[8];
  *(void *)&long long v39 = 0x7FF8000000000000;
  *((void *)&v39 + 1) = 0x7FF8000000000000;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  uint64_t v45 = 0;
  uint64_t v46 = 0x7FF8000000000000;
  char v47 = 0;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  if (raven::RavenIonosphereEstimator::PopulateEvent((raven::RavenIonosphereEstimator *)(a1 + 2288), (raven::ThinShellIonosphereParametersEvent *)v19))
  {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v5 = 0;
    long long v13 = v38;
    a2[8] = v37;
    a2[9] = v13;
    a2[10] = v39;
    long long v14 = v34;
    a2[4] = v33;
    a2[5] = v14;
    long long v15 = v36;
    a2[6] = v35;
    a2[7] = v15;
    long long v16 = *(_OWORD *)v31;
    *a2 = v30;
    a2[1] = v16;
    long long v17 = v32;
    a2[2] = *(_OWORD *)&v31[16];
    a2[3] = v17;
  }
  std::mutex::unlock(v4);
  return v5;
}

void sub_18E18C7AC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_18E18C7C0(uint64_t a1)
{
  uint64_t v2 = (char *)(a1 + 6127);
  *(void *)a1 = &unk_1EDD15A00;
  sub_18E14C32C((uint64_t *)(a1 + 10520));
  *(void *)(a1 + 10448) = &unk_1EDD0A6A8;
  *(void *)(a1 + 6152) = &unk_1EDD0A758;
  *(void *)(a1 + 9504) = &unk_1EDD17478;
  *(void *)(a1 + 9384) = &unk_1EDD17478;
  *(void *)(a1 + 8544) = &unk_1EDD17478;
  sub_18E14DC00(a1 + 6152);
  if (v2[24] < 0) {
    operator delete(*(void **)(a1 + 6128));
  }
  if (*v2 < 0) {
    operator delete(*(void **)(a1 + 6104));
  }
  if (*(unsigned char *)(a1 + 2736)) {
    *(void *)(a1 + 2536) = &unk_1EDD146B8;
  }
  std::mutex::~mutex((std::mutex *)(a1 + 2224));
  if (*(char *)(a1 + 2215) < 0) {
    operator delete(*(void **)(a1 + 2192));
  }
  if (*(char *)(a1 + 2191) < 0) {
    operator delete(*(void **)(a1 + 2168));
  }

  cnframework::ActiveObjectBase::~ActiveObjectBase((cnframework::ActiveObjectBase *)a1);
}

void sub_18E18C94C(uint64_t a1)
{
  uint64_t v2 = (char *)(a1 + 6127);
  *(void *)a1 = &unk_1EDD15A00;
  sub_18E14C32C((uint64_t *)(a1 + 10520));
  *(void *)(a1 + 10448) = &unk_1EDD0A6A8;
  *(void *)(a1 + 6152) = &unk_1EDD0A758;
  *(void *)(a1 + 9504) = &unk_1EDD17478;
  *(void *)(a1 + 9384) = &unk_1EDD17478;
  *(void *)(a1 + 8544) = &unk_1EDD17478;
  sub_18E14DC00(a1 + 6152);
  if (v2[24] < 0) {
    operator delete(*(void **)(a1 + 6128));
  }
  if (*v2 < 0) {
    operator delete(*(void **)(a1 + 6104));
  }
  if (*(unsigned char *)(a1 + 2736)) {
    *(void *)(a1 + 2536) = &unk_1EDD146B8;
  }
  std::mutex::~mutex((std::mutex *)(a1 + 2224));
  if (*(char *)(a1 + 2215) < 0) {
    operator delete(*(void **)(a1 + 2192));
  }
  if (*(char *)(a1 + 2191) < 0) {
    operator delete(*(void **)(a1 + 2168));
  }
  cnframework::ActiveObjectBase::~ActiveObjectBase((cnframework::ActiveObjectBase *)a1);

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E18CAEC(uint64_t a1)
{
  *(void *)(a1 + 8160) = &unk_1EDD0A6A8;
  *(void *)(a1 + 3864) = &unk_1EDD0A758;
  *(void *)(a1 + 7216) = &unk_1EDD17478;
  *(void *)(a1 + 7096) = &unk_1EDD17478;
  *(void *)(a1 + 6256) = &unk_1EDD17478;
  sub_18E14DC00(a1 + 3864);
  if (*(char *)(a1 + 3863) < 0) {
    operator delete(*(void **)(a1 + 3840));
  }
  if (*(char *)(a1 + 3839) < 0) {
    operator delete(*(void **)(a1 + 3816));
  }
  if (*(unsigned char *)(a1 + 448)) {
    *(void *)(a1 + 248) = &unk_1EDD146B8;
  }
  return a1;
}

void sub_18E18CC1C()
{
}

void *sub_18E18CC30()
{
}

void sub_18E18CC3C()
{
}

void sub_18E18CCCC()
{
}

void *sub_18E18CCE0()
{
}

void sub_18E18CCEC()
{
}

uint64_t raven::RavenActivityStateEstimator::GetCurrentTime(raven::RavenActivityStateEstimator *this)
{
  return *((void *)this + 35);
}

double raven::RavenActivityStateEstimator::GetHMMProbabilitySumThreshold(raven::RavenActivityStateEstimator *this)
{
  return *((double *)this + 34);
}

uint64_t raven::RavenActivityStateEstimator::GetMostProbableState(uint64_t a1, unsigned int *a2)
{
  uint64_t v12 = 0x10000000ALL;
  uint64_t v10 = &unk_1EDD17628;
  long long v11 = xmmword_18E200CF0;
  long long v13 = &v14;
  if (*(_DWORD *)(a1 + 264)) {
    uint64_t v3 = a1 + 144;
  }
  else {
    uint64_t v3 = a1 + 24;
  }
  sub_18DFE2F24((uint64_t)&v10, v3);
  if (!DWORD2(v11)) {
    goto LABEL_19;
  }
  unsigned int v4 = 0;
  unsigned int v5 = -1;
  double v6 = -INFINITY;
  do
  {
    if (*(double *)&v13[v4] > v6)
    {
      double v6 = *(double *)&v13[v4];
      unsigned int v5 = v4;
    }
    ++v4;
  }
  while (DWORD2(v11) != v4);
  BOOL v7 = v5 < 0xA && (*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL;
  if (v7 && (v6 >= 0.0 ? (BOOL v8 = v6 > 1.0) : (BOOL v8 = 1), !v8))
  {
    uint64_t result = 1;
  }
  else
  {
LABEL_19:
    unsigned int v5 = 0;
    uint64_t result = 0;
  }
  *a2 = v5;
  return result;
}

uint64_t raven::RavenActivityStateEstimator::Initialize(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)a1)
  {
    LOWORD(v51) = 12;
    v49[0] = 2;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v51, v49, "WARNING: ActivityStateEstimator being re-initialized", a4, a5, a6, a7, a8, v42);
    *(unsigned char *)a1 = 0;
  }
  double v11 = *(double *)a2;
  if (!*a2)
  {
    LOWORD(v51) = 12;
    v49[0] = 4;
    uint64_t v27 = "ActivityStateEstimator,invalid pointer to RavenParameters";
LABEL_22:
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v51, v49, v27, a4, a5, a6, a7, a8, v42);
    return 0;
  }
  double v12 = *((double *)a2 + 2) + (double)a2[1];
  double v13 = fabs(v12);
  if ((unint64_t)(*(void *)&v13 - 0x10000000000000) >> 53 >= 0x3FF
    && (unint64_t)(*(void *)&v13 - 1) >= 0xFFFFFFFFFFFFFLL
    && *(void *)&v12 != 0)
  {
    LOWORD(v51) = 12;
    v49[0] = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v51, v49, "ActivityStateEstimator,invalid input time,%.3lf", a4, a5, a6, a7, a8, SLOBYTE(v12));
    return 0;
  }
  if ((*(void *)(*(void *)&v11 + 872) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || *(double *)(*(void *)&v11 + 872) < 0.0)
  {
    LOWORD(v51) = 12;
    v49[0] = 4;
    uint64_t v42 = *(void *)(*(void *)(a1 + 8) + 872);
    uint64_t v27 = "ActivityStateEstimator,invalid estimator prediction interval,%.3lf";
    goto LABEL_22;
  }
  *(void *)(a1 + 272) = 0x3DDB7CDFD9D7BDBBLL;
  uint64_t v46 = 0x10000000ALL;
  long long v44 = &unk_1EDD17628;
  char v47 = &v48;
  long long v45 = xmmword_18E200CF0;
  long long v16 = (cnprint::CNPrinter *)sub_18DFE2CC8((uint64_t)&v44, 0.0);
  long long v17 = v47;
  *char v47 = 0x3FF0000000000000;
  double v18 = *(double *)(a1 + 272);
  uint64_t v19 = DWORD1(v45);
  if (DWORD1(v45))
  {
    uint64_t v20 = 0;
    unsigned int v21 = v45;
    uint64_t v22 = v45 - 1;
    int v23 = 1;
    do
    {
      double v24 = *(double *)&v17[v21 * v20];
      unsigned int v25 = v23;
      uint64_t v26 = v22;
      if (v21 >= 2)
      {
        do
        {
          double v24 = v24 + *(double *)&v17[v25++];
          --v26;
        }
        while (v26);
      }
      v55[v20++] = v24;
      v23 += v21;
    }
    while (v20 != v19);
    double v8 = v55[0];
  }
  unsigned int v29 = DWORD2(v45);
  if (fabs(v8 + -1.0) > v18 && cnprint::CNPrinter::GetLogLevel(v16) <= 1)
  {
    LOWORD(v51) = 2;
    v49[0] = 1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v51, v49, "WARNING: HMM initialized with non-normalized probability vector.", v30, v31, v32, v33, v34, v42);
  }
  sub_18E14E5D4((uint64_t)v49, (uint64_t)&v44);
  float64x2_t v35 = (float64x2_t)vdupq_lane_s32((int32x2_t)(v29 | 0x100000000), 0);
  HIDWORD(v35.f64[0]) = 1;
  float64x2_t v50 = v35;
  uint64_t v53 = 0x10000000ALL;
  *(void *)&v35.f64[1] = 0xA0000000ALL;
  long long v52 = xmmword_18E200CF0;
  unsigned __int8 v51 = &unk_1EDD17628;
  long long v54 = v55;
  v35.f64[0] = 1.0 / v8;
  sub_18DFE3240((uint64_t)v49, (uint64_t)&v51, v35);
  sub_18DFE2F24(a1 + 24, (uint64_t)&v51);
  sub_18DFE2F24(a1 + 144, a1 + 24);
  *(_DWORD *)(a1 + 264) = 1;
  *(void *)(a1 + 8) = *a2;
  *(_OWORD *)(a1 + 280) = *(_OWORD *)(a2 + 1);
  *(unsigned char *)a1 = 1;
  if (cnprint::CNPrinter::GetLogLevel(v36) <= 1)
  {
    LOWORD(v51) = 12;
    v49[0] = 1;
    double v43 = *((double *)a2 + 2) + (double)a2[1];
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v51, v49, "ActivityStateEstimator initialized,time,%.3lf", v37, v38, v39, v40, v41, SLOBYTE(v43));
  }
  return 1;
}

uint64_t raven::RavenActivityStateEstimator::IsInitialized(raven::RavenActivityStateEstimator *this)
{
  return *(unsigned __int8 *)this;
}

uint64_t raven::RavenActivityStateEstimator::PopulateActivityStateEvent(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  long long v37 = 0uLL;
  long long v39 = 0uLL;
  long long v36 = 0uLL;
  float64x2_t v35 = &unk_1EDD140B8;
  memset(v38, 0, sizeof(v38));
  *(void *)&long long v40 = 0;
  *((void *)&v40 + 1) = 0x7FF8000000000000;
  *(void *)&long long v41 = 0;
  *((void *)&v41 + 1) = 0x3FF0000000000000;
  uint64_t v46 = 0;
  long long v45 = 0u;
  long long v44 = 0u;
  long long v43 = 0u;
  long long v42 = 0u;
  *(_OWORD *)(a3 + 56) = 0uLL;
  *(_OWORD *)(a3 + 40) = 0uLL;
  *(_OWORD *)(a3 + 24) = 0uLL;
  *(_OWORD *)(a3 + 8) = 0uLL;
  long long v3 = v39;
  long long v4 = v40;
  long long v5 = v41;
  *(_OWORD *)(a3 + 120) = v42;
  *(_OWORD *)(a3 + 104) = v5;
  *(_OWORD *)(a3 + 88) = v4;
  *(_OWORD *)(a3 + 72) = v3;
  long long v6 = v43;
  long long v7 = v44;
  long long v8 = v45;
  *(void *)(a3 + 184) = v46;
  *(_OWORD *)(a3 + 168) = v8;
  *(_OWORD *)(a3 + 152) = v7;
  *(_OWORD *)(a3 + 136) = v6;
  if (!*(unsigned char *)a1) {
    return 0;
  }
  long long v11 = a2[1];
  *(_OWORD *)(a3 + 8) = *a2;
  *(_OWORD *)(a3 + 24) = v11;
  long long v12 = a2[2];
  long long v13 = a2[3];
  long long v14 = a2[5];
  *(_OWORD *)(a3 + 72) = a2[4];
  *(_OWORD *)(a3 + 88) = v14;
  *(_OWORD *)(a3 + 40) = v12;
  *(_OWORD *)(a3 + 56) = v13;
  unsigned int v34 = 0;
  uint64_t MostProbableState = raven::RavenActivityStateEstimator::GetMostProbableState(a1, &v34);
  uint64_t v21 = MostProbableState;
  if (MostProbableState)
  {
    switch(v34)
    {
      case 0u:
        *(unsigned char *)(a3 + 104) = 0;
        break;
      case 1u:
        char v27 = 1;
        goto LABEL_18;
      case 2u:
        char v27 = 2;
        goto LABEL_18;
      case 3u:
        char v27 = 3;
        goto LABEL_18;
      case 4u:
        char v27 = 4;
        goto LABEL_18;
      case 5u:
        char v27 = 5;
        goto LABEL_18;
      case 6u:
        char v27 = 6;
        goto LABEL_18;
      case 7u:
        char v27 = 7;
        goto LABEL_18;
      case 8u:
        char v27 = 8;
        goto LABEL_18;
      case 9u:
        char v27 = 9;
LABEL_18:
        *(unsigned char *)(a3 + 104) = v27;
        break;
      case 0xAu:
        LOWORD(v35) = 12;
        unsigned __int8 v33 = 4;
        double v32 = *(double *)(a1 + 288) + (double)*(uint64_t *)(a1 + 280);
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v35, &v33, "ActivityStateEstimator,time,%.3lf,invalid state", v16, v17, v18, v19, v20, SLOBYTE(v32));
        break;
      default:
        break;
    }
    *(void *)&long long v37 = 0x10000000ALL;
    float64x2_t v35 = &unk_1EDD17628;
    long long v36 = xmmword_18E200CF0;
    *((void *)&v37 + 1) = v38;
    if (*(_DWORD *)(a1 + 264)) {
      uint64_t v28 = a1 + 144;
    }
    else {
      uint64_t v28 = a1 + 24;
    }
    sub_18DFE2F24((uint64_t)&v35, v28);
    unsigned int v29 = (void *)*((void *)&v37 + 1);
    *(void *)(a3 + 112) = **((void **)&v37 + 1);
    *(void *)(a3 + 120) = v29[1];
    *(void *)(a3 + 128) = v29[2];
    *(void *)(a3 + 136) = v29[3];
    *(void *)(a3 + 144) = v29[4];
    *(void *)(a3 + 152) = v29[5];
    *(void *)(a3 + 160) = v29[6];
    *(void *)(a3 + 168) = v29[7];
    *(void *)(a3 + 176) = v29[8];
    *(void *)(a3 + 184) = v29[9];
  }
  else if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)MostProbableState) <= 1)
  {
    LOWORD(v35) = 12;
    unsigned __int8 v33 = 1;
    double v31 = *(double *)(a1 + 288) + (double)*(uint64_t *)(a1 + 280);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v35, &v33, "ActivityStateEstimator,time,%.3lf,could not find most probable state", v22, v23, v24, v25, v26, SLOBYTE(v31));
  }
  return v21;
}

BOOL raven::RavenActivityStateEstimator::Predict(uint64_t a1, uint64_t a2, int8x16_t a3, int8x16_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!*(unsigned char *)a1)
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) <= 1)
    {
      LOWORD(v287) = 12;
      LOBYTE(v268) = 1;
      double v256 = *(double *)(a2 + 8) + (double)*(uint64_t *)a2;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v287, (unsigned __int8 *)&v268, "WARNING: ActivityStateEstimator,time,%.3lf,predicting uninitialized", v36, v37, v38, v39, v40, SLOBYTE(v256));
    }
    return 0;
  }
  uint64_t v11 = a1;
  a4.i64[0] = *(void *)(a2 + 8);
  *(double *)a3.i64 = *(double *)a4.i64 + (double)*(uint64_t *)a2;
  double v12 = fabs(*(double *)a3.i64);
  BOOL v14 = (unint64_t)(*(void *)&v12 - 0x10000000000000) >> 53 < 0x3FF
     || (unint64_t)(*(void *)&v12 - 1) < 0xFFFFFFFFFFFFFLL
     || COERCE__INT64(*(double *)a4.i64 + (double)*(uint64_t *)a2) == 0;
  if (!v14)
  {
    LOWORD(v287) = 12;
    LOBYTE(v268) = 4;
    double v257 = *(double *)(a1 + 288) + (double)*(uint64_t *)(a1 + 280);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v287, (unsigned __int8 *)&v268, "ActivityStateEstimator,time,%.3lf,invalid prediction time,%.3lf", a6, a7, a8, a9, a10, SLOBYTE(v257));
    return 0;
  }
  uint64_t v15 = *(void *)(a1 + 280);
  double v16 = *(double *)(a1 + 288);
  std::string v287 = (long long *)v15;
  *(double *)&long long v288 = v16;
  uint64_t v17 = CNTimeSpan::operator-(a2, &v287, a3, a4);
  uint64_t v280 = v17;
  double v281 = v18;
  *(double *)v25.i64 = v18;
  if (v17)
  {
    if ((v17 & 0x8000000000000000) == 0) {
      goto LABEL_12;
    }
LABEL_28:
    LOWORD(v287) = 12;
    LOBYTE(v268) = 4;
    double v258 = v16 + (double)v15;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v287, (unsigned __int8 *)&v268, "ActivityStateEstimator,time,%.3lf,negative prediction interval,%.3lf", v19, v20, v21, v22, v23, SLOBYTE(v258));
    return 0;
  }
  if (v18 < 0.0) {
    goto LABEL_28;
  }
LABEL_12:
  unsigned int v26 = *(unsigned __int8 *)(a2 + 200) - 2;
  if (*(unsigned char *)(a2 + 304)) {
    BOOL v27 = v26 >= 8;
  }
  else {
    BOOL v27 = 1;
  }
  int v28 = !v27;
  int v29 = *(unsigned __int8 *)(a2 + 544);
  if (*(unsigned char *)(a2 + 544))
  {
    uint64_t v30 = CNTimeSpan::operator-(a2 + 416, (void *)a2, v25, v24);
    std::string v287 = (long long *)v30;
    *(double *)&long long v288 = v31;
    if (v30 < 0 || (*(double *)v32.i64 = v31, v31 < 0.0))
    {
      uint64_t v30 = CNTimeSpan::operator-((double *)&v287, v32, v33);
      v32.i64[0] = v34;
    }
    if (*(double *)v32.i64 + (double)v30 <= 6.0)
    {
      int v29 = *(unsigned __int8 *)(a2 + 512) - 1 < 6;
      BOOL v35 = *(unsigned __int8 *)(a2 + 513) - 1 < 6;
      goto LABEL_32;
    }
    int v29 = 0;
  }
  BOOL v35 = 0;
LABEL_32:
  long long v43 = *(_OWORD *)(v11 + 280);
  uint64_t v279 = *(void *)(v11 + 272);
  memset(&v269[1], 0, 64);
  long long v268 = v43;
  v269[0] = xmmword_18E21DF30;
  v270[2] = xmmword_18E21DC80;
  v270[3] = unk_18E21DC90;
  v270[0] = xmmword_18E21DC60;
  v270[1] = unk_18E21DC70;
  v271[1] = unk_18E21DCC0;
  v271[2] = xmmword_18E21DCD0;
  v271[3] = unk_18E21DCE0;
  v271[4] = xmmword_18E21DCF0;
  v270[4] = xmmword_18E21DCA0;
  v271[0] = xmmword_18E21DCB0;
  v272[2] = xmmword_18E21DD20;
  v272[3] = unk_18E21DD30;
  v272[0] = xmmword_18E21DD00;
  v272[1] = unk_18E21DD10;
  v272[4] = xmmword_18E21DD40;
  v273[0] = xmmword_18E21DD50;
  memset(&v273[3], 0, 32);
  v273[1] = unk_18E21DD60;
  v273[2] = xmmword_18E21DD70;
  v274[2] = xmmword_18E21DDC0;
  memset(&v274[3], 0, 32);
  v274[0] = xmmword_18E21DDA0;
  v274[1] = unk_18E21DDB0;
  v275[0] = xmmword_18E21DDF0;
  v275[3] = unk_18E21DE20;
  v275[4] = xmmword_18E21DE30;
  v275[1] = unk_18E21DE00;
  v275[2] = xmmword_18E21DE10;
  v276[2] = xmmword_18E21DE60;
  v276[3] = unk_18E21DE70;
  v276[0] = xmmword_18E21DE40;
  v276[1] = unk_18E21DE50;
  v276[4] = xmmword_18E21DE80;
  v277[0] = xmmword_18E21DE90;
  v277[4] = xmmword_18E21DED0;
  memset(&v277[1], 0, 48);
  v278[4] = unk_18E21DF20;
  memset(&v278[1], 0, 48);
  v278[0] = xmmword_18E21DEE0;
  if (((v28 | v29) & 1) != 0 || v35)
  {
    long long v288 = 0uLL;
    std::string v287 = &v288;
    if (v28)
    {
      switch(v26)
      {
        case 0u:
          sub_18E1902B4((uint64_t *)&v287, 2, 2);
          break;
        case 1u:
          sub_18E1902B4((uint64_t *)&v287, 3, 3);
          break;
        case 2u:
          sub_18E1902B4((uint64_t *)&v287, 4, 4);
          break;
        case 3u:
          sub_18E1902B4((uint64_t *)&v287, 6, 6);
          break;
        case 4u:
          sub_18E1902B4((uint64_t *)&v287, 7, 7);
          break;
        case 5u:
          sub_18E1902B4((uint64_t *)&v287, 2, 2);
          sub_18E1902B4((uint64_t *)&v287, 3, 3);
          break;
        case 6u:
        case 7u:
          sub_18E1902B4((uint64_t *)&v287, 1, 1);
          break;
        default:
          break;
      }
    }
    else
    {
      long long v292 = &v287;
      if (v29) {
        sub_18E18F28C((uint64_t **)&v292, *(unsigned char *)(a2 + 512));
      }
      if (v35) {
        sub_18E18F28C((uint64_t **)&v292, *(unsigned char *)(a2 + 513));
      }
    }
    if (!*((void *)&v288 + 1)) {
      goto LABEL_331;
    }
    double v44 = (double)*((unint64_t *)&v288 + 1);
    double v45 = 0.975 / (double)*((unint64_t *)&v288 + 1);
    uint64_t v46 = (uint64_t)v287;
    if (v287 == &v288)
    {
      double v55 = 1.0;
    }
    else
    {
      double v47 = 0.0;
      uint64_t v48 = (uint64_t)v287;
      do
      {
        long long v49 = *(long long **)(v48 + 8);
        float64x2_t v50 = (long long *)v48;
        if (v49)
        {
          do
          {
            unsigned __int8 v51 = v49;
            long long v49 = *(long long **)v49;
          }
          while (v49);
        }
        else
        {
          do
          {
            unsigned __int8 v51 = (long long *)*((void *)v50 + 2);
            BOOL v14 = *(void *)v51 == (void)v50;
            float64x2_t v50 = v51;
          }
          while (!v14);
        }
        double v47 = v47 + *((double *)v269 + *(int *)(v48 + 28));
        uint64_t v48 = (uint64_t)v51;
      }
      while (v51 != &v288);
      if (vabdd_f64(1.0, v47) < 2.22044605e-16)
      {
        uint64_t v52 = (uint64_t)v287;
        do
        {
          *((double *)v269 + *(unsigned int *)(v52 + 28)) = 1.0 / v44;
          uint64_t v53 = *(long long **)(v52 + 8);
          if (v53)
          {
            do
            {
              long long v54 = v53;
              uint64_t v53 = *(long long **)v53;
            }
            while (v53);
          }
          else
          {
            do
            {
              long long v54 = *(long long **)(v52 + 16);
              BOOL v14 = *(void *)v54 == v52;
              uint64_t v52 = (uint64_t)v54;
            }
            while (!v14);
          }
          uint64_t v52 = (uint64_t)v54;
        }
        while (v54 != &v288);
        goto LABEL_71;
      }
      double v55 = 1.0 - v47;
    }
    uint64_t v56 = 0;
    uint64_t v57 = (uint64_t **)v288;
    double v58 = 0.025 / v55;
    do
    {
      if (!v57)
      {
LABEL_68:
        double v61 = v58 * *((double *)v269 + v56);
        goto LABEL_70;
      }
      uint64_t v59 = v57;
      while (1)
      {
        uint64_t v60 = *((int *)v59 + 7);
        if (v56 >= v60) {
          break;
        }
LABEL_67:
        uint64_t v59 = (uint64_t **)*v59;
        if (!v59) {
          goto LABEL_68;
        }
      }
      if (v56 > v60)
      {
        ++v59;
        goto LABEL_67;
      }
      double v61 = v45;
LABEL_70:
      *((double *)v269 + v56++) = v61;
    }
    while (v56 != 10);
LABEL_71:
    if ((long long *)v46 == &v288)
    {
      double v70 = 1.0;
    }
    else
    {
      double v62 = 0.0;
      uint64_t v63 = (long long *)v46;
      do
      {
        uint8x8_t v64 = (long long *)*((void *)v63 + 1);
        unint64_t v65 = v63;
        if (v64)
        {
          do
          {
            uint8x8_t v66 = v64;
            uint8x8_t v64 = *(long long **)v64;
          }
          while (v64);
        }
        else
        {
          do
          {
            uint8x8_t v66 = (long long *)*((void *)v65 + 2);
            BOOL v14 = *(void *)v66 == (void)v65;
            unint64_t v65 = v66;
          }
          while (!v14);
        }
        double v62 = v62 + *((double *)v270 + *((int *)v63 + 7));
        uint64_t v63 = v66;
      }
      while (v66 != &v288);
      if (vabdd_f64(1.0, v62) < 2.22044605e-16)
      {
        uint64_t v67 = (long long *)v46;
        do
        {
          *((double *)v270 + *((unsigned int *)v67 + 7)) = 1.0 / v44;
          uint64_t v68 = (long long *)*((void *)v67 + 1);
          if (v68)
          {
            do
            {
              unint64_t v69 = v68;
              uint64_t v68 = *(long long **)v68;
            }
            while (v68);
          }
          else
          {
            do
            {
              unint64_t v69 = (long long *)*((void *)v67 + 2);
              BOOL v14 = *(void *)v69 == (void)v67;
              uint64_t v67 = v69;
            }
            while (!v14);
          }
          uint64_t v67 = v69;
        }
        while (v69 != &v288);
        goto LABEL_100;
      }
      double v70 = 1.0 - v62;
    }
    uint64_t v71 = 0;
    unint64_t v72 = (uint64_t **)v288;
    double v73 = 0.025 / v70;
LABEL_91:
    if (!v72)
    {
LABEL_97:
      double v76 = v73 * *((double *)v270 + v71);
      goto LABEL_99;
    }
    uint64_t v74 = v72;
    while (1)
    {
      uint64_t v75 = *((int *)v74 + 7);
      if (v71 >= v75)
      {
        if (v71 <= v75)
        {
          double v76 = v45;
LABEL_99:
          *((double *)v270 + v71++) = v76;
          if (v71 == 10)
          {
LABEL_100:
            if ((long long *)v46 == &v288)
            {
              double v85 = 1.0;
            }
            else
            {
              double v77 = 0.0;
              uint64_t v78 = (long long *)v46;
              do
              {
                uint64_t v79 = (long long *)*((void *)v78 + 1);
                double v80 = v78;
                if (v79)
                {
                  do
                  {
                    int8x16_t v81 = v79;
                    uint64_t v79 = *(long long **)v79;
                  }
                  while (v79);
                }
                else
                {
                  do
                  {
                    int8x16_t v81 = (long long *)*((void *)v80 + 2);
                    BOOL v14 = *(void *)v81 == (void)v80;
                    double v80 = v81;
                  }
                  while (!v14);
                }
                double v77 = v77 + *((double *)v271 + *((int *)v78 + 7));
                uint64_t v78 = v81;
              }
              while (v81 != &v288);
              if (vabdd_f64(1.0, v77) < 2.22044605e-16)
              {
                uint64_t v82 = (long long *)v46;
                do
                {
                  *((double *)v271 + *((unsigned int *)v82 + 7)) = 1.0 / v44;
                  uint64_t v83 = (long long *)*((void *)v82 + 1);
                  if (v83)
                  {
                    do
                    {
                      char v84 = v83;
                      uint64_t v83 = *(long long **)v83;
                    }
                    while (v83);
                  }
                  else
                  {
                    do
                    {
                      char v84 = (long long *)*((void *)v82 + 2);
                      BOOL v14 = *(void *)v84 == (void)v82;
                      uint64_t v82 = v84;
                    }
                    while (!v14);
                  }
                  uint64_t v82 = v84;
                }
                while (v84 != &v288);
                goto LABEL_129;
              }
              double v85 = 1.0 - v77;
            }
            uint64_t v86 = 0;
            uint64_t v87 = (uint64_t **)v288;
            double v88 = 0.025 / v85;
LABEL_120:
            if (!v87)
            {
LABEL_126:
              double v91 = v88 * *((double *)v271 + v86);
              goto LABEL_128;
            }
            uint64_t v89 = v87;
            while (1)
            {
              uint64_t v90 = *((int *)v89 + 7);
              if (v86 >= v90)
              {
                if (v86 <= v90)
                {
                  double v91 = v45;
LABEL_128:
                  *((double *)v271 + v86++) = v91;
                  if (v86 != 10) {
                    goto LABEL_120;
                  }
LABEL_129:
                  if ((long long *)v46 == &v288)
                  {
                    double v100 = 1.0;
                  }
                  else
                  {
                    double v92 = 0.0;
                    uint64_t v93 = (long long *)v46;
                    do
                    {
                      uint64_t v94 = (long long *)*((void *)v93 + 1);
                      uint64_t v95 = v93;
                      if (v94)
                      {
                        do
                        {
                          uint64_t v96 = v94;
                          uint64_t v94 = *(long long **)v94;
                        }
                        while (v94);
                      }
                      else
                      {
                        do
                        {
                          uint64_t v96 = (long long *)*((void *)v95 + 2);
                          BOOL v14 = *(void *)v96 == (void)v95;
                          uint64_t v95 = v96;
                        }
                        while (!v14);
                      }
                      double v92 = v92 + *((double *)v272 + *((int *)v93 + 7));
                      uint64_t v93 = v96;
                    }
                    while (v96 != &v288);
                    if (vabdd_f64(1.0, v92) < 2.22044605e-16)
                    {
                      uint64_t v97 = (long long *)v46;
                      do
                      {
                        *((double *)v272 + *((unsigned int *)v97 + 7)) = 1.0 / v44;
                        uint64_t v98 = (long long *)*((void *)v97 + 1);
                        if (v98)
                        {
                          do
                          {
                            uint64_t v99 = v98;
                            uint64_t v98 = *(long long **)v98;
                          }
                          while (v98);
                        }
                        else
                        {
                          do
                          {
                            uint64_t v99 = (long long *)*((void *)v97 + 2);
                            BOOL v14 = *(void *)v99 == (void)v97;
                            uint64_t v97 = v99;
                          }
                          while (!v14);
                        }
                        uint64_t v97 = v99;
                      }
                      while (v99 != &v288);
                      goto LABEL_158;
                    }
                    double v100 = 1.0 - v92;
                  }
                  uint64_t v101 = 0;
                  double v102 = (uint64_t **)v288;
                  double v103 = 0.025 / v100;
LABEL_149:
                  if (!v102)
                  {
LABEL_155:
                    double v106 = v103 * *((double *)v272 + v101);
                    goto LABEL_157;
                  }
                  uint64_t v104 = v102;
                  while (1)
                  {
                    uint64_t v105 = *((int *)v104 + 7);
                    if (v101 >= v105)
                    {
                      if (v101 <= v105)
                      {
                        double v106 = v45;
LABEL_157:
                        *((double *)v272 + v101++) = v106;
                        if (v101 == 10)
                        {
LABEL_158:
                          if ((long long *)v46 == &v288)
                          {
                            double v115 = 1.0;
                          }
                          else
                          {
                            double v107 = 0.0;
                            uint64_t v108 = (long long *)v46;
                            do
                            {
                              uint64_t v109 = (long long *)*((void *)v108 + 1);
                              long long v110 = v108;
                              if (v109)
                              {
                                do
                                {
                                  long long v111 = v109;
                                  uint64_t v109 = *(long long **)v109;
                                }
                                while (v109);
                              }
                              else
                              {
                                do
                                {
                                  long long v111 = (long long *)*((void *)v110 + 2);
                                  BOOL v14 = *(void *)v111 == (void)v110;
                                  long long v110 = v111;
                                }
                                while (!v14);
                              }
                              double v107 = v107 + *((double *)v273 + *((int *)v108 + 7));
                              uint64_t v108 = v111;
                            }
                            while (v111 != &v288);
                            if (vabdd_f64(1.0, v107) < 2.22044605e-16)
                            {
                              long long v112 = (long long *)v46;
                              do
                              {
                                *((double *)v273 + *((unsigned int *)v112 + 7)) = 1.0 / v44;
                                long long v113 = (long long *)*((void *)v112 + 1);
                                if (v113)
                                {
                                  do
                                  {
                                    long long v114 = v113;
                                    long long v113 = *(long long **)v113;
                                  }
                                  while (v113);
                                }
                                else
                                {
                                  do
                                  {
                                    long long v114 = (long long *)*((void *)v112 + 2);
                                    BOOL v14 = *(void *)v114 == (void)v112;
                                    long long v112 = v114;
                                  }
                                  while (!v14);
                                }
                                long long v112 = v114;
                              }
                              while (v114 != &v288);
                              goto LABEL_187;
                            }
                            double v115 = 1.0 - v107;
                          }
                          uint64_t v116 = 0;
                          long long v117 = (uint64_t **)v288;
                          double v118 = 0.025 / v115;
LABEL_178:
                          if (!v117)
                          {
LABEL_184:
                            double v121 = v118 * *((double *)v273 + v116);
                            goto LABEL_186;
                          }
                          long long v119 = v117;
                          while (1)
                          {
                            uint64_t v120 = *((int *)v119 + 7);
                            if (v116 >= v120)
                            {
                              if (v116 <= v120)
                              {
                                double v121 = v45;
LABEL_186:
                                *((double *)v273 + v116++) = v121;
                                if (v116 != 10) {
                                  goto LABEL_178;
                                }
LABEL_187:
                                if ((long long *)v46 == &v288)
                                {
                                  double v130 = 1.0;
                                }
                                else
                                {
                                  double v122 = 0.0;
                                  long long v123 = (long long *)v46;
                                  do
                                  {
                                    long long v124 = (long long *)*((void *)v123 + 1);
                                    long long v125 = v123;
                                    if (v124)
                                    {
                                      do
                                      {
                                        long long v126 = v124;
                                        long long v124 = *(long long **)v124;
                                      }
                                      while (v124);
                                    }
                                    else
                                    {
                                      do
                                      {
                                        long long v126 = (long long *)*((void *)v125 + 2);
                                        BOOL v14 = *(void *)v126 == (void)v125;
                                        long long v125 = v126;
                                      }
                                      while (!v14);
                                    }
                                    double v122 = v122 + *((double *)v274 + *((int *)v123 + 7));
                                    long long v123 = v126;
                                  }
                                  while (v126 != &v288);
                                  if (vabdd_f64(1.0, v122) < 2.22044605e-16)
                                  {
                                    int v127 = (long long *)v46;
                                    do
                                    {
                                      *((double *)v274 + *((unsigned int *)v127 + 7)) = 1.0 / v44;
                                      uint64_t v128 = (long long *)*((void *)v127 + 1);
                                      if (v128)
                                      {
                                        do
                                        {
                                          double v129 = v128;
                                          uint64_t v128 = *(long long **)v128;
                                        }
                                        while (v128);
                                      }
                                      else
                                      {
                                        do
                                        {
                                          double v129 = (long long *)*((void *)v127 + 2);
                                          BOOL v14 = *(void *)v129 == (void)v127;
                                          int v127 = v129;
                                        }
                                        while (!v14);
                                      }
                                      int v127 = v129;
                                    }
                                    while (v129 != &v288);
                                    goto LABEL_216;
                                  }
                                  double v130 = 1.0 - v122;
                                }
                                uint64_t v131 = 0;
                                uint64_t v132 = (uint64_t **)v288;
                                double v133 = 0.025 / v130;
LABEL_207:
                                if (!v132)
                                {
LABEL_213:
                                  double v136 = v133 * *((double *)v274 + v131);
                                  goto LABEL_215;
                                }
                                uint64_t v134 = v132;
                                while (1)
                                {
                                  uint64_t v135 = *((int *)v134 + 7);
                                  if (v131 >= v135)
                                  {
                                    if (v131 <= v135)
                                    {
                                      double v136 = v45;
LABEL_215:
                                      *((double *)v274 + v131++) = v136;
                                      if (v131 == 10)
                                      {
LABEL_216:
                                        if ((long long *)v46 == &v288)
                                        {
                                          double v145 = 1.0;
                                        }
                                        else
                                        {
                                          double v137 = 0.0;
                                          uint64_t v138 = (long long *)v46;
                                          do
                                          {
                                            double v139 = (long long *)*((void *)v138 + 1);
                                            uint64_t v140 = v138;
                                            if (v139)
                                            {
                                              do
                                              {
                                                uint64_t v141 = v139;
                                                double v139 = *(long long **)v139;
                                              }
                                              while (v139);
                                            }
                                            else
                                            {
                                              do
                                              {
                                                uint64_t v141 = (long long *)*((void *)v140 + 2);
                                                BOOL v14 = *(void *)v141 == (void)v140;
                                                uint64_t v140 = v141;
                                              }
                                              while (!v14);
                                            }
                                            double v137 = v137 + *((double *)v275 + *((int *)v138 + 7));
                                            uint64_t v138 = v141;
                                          }
                                          while (v141 != &v288);
                                          if (vabdd_f64(1.0, v137) < 2.22044605e-16)
                                          {
                                            uint64_t v142 = (long long *)v46;
                                            do
                                            {
                                              *((double *)v275 + *((unsigned int *)v142 + 7)) = 1.0 / v44;
                                              uint64_t v143 = (long long *)*((void *)v142 + 1);
                                              if (v143)
                                              {
                                                do
                                                {
                                                  uint64_t v144 = v143;
                                                  uint64_t v143 = *(long long **)v143;
                                                }
                                                while (v143);
                                              }
                                              else
                                              {
                                                do
                                                {
                                                  uint64_t v144 = (long long *)*((void *)v142 + 2);
                                                  BOOL v14 = *(void *)v144 == (void)v142;
                                                  uint64_t v142 = v144;
                                                }
                                                while (!v14);
                                              }
                                              uint64_t v142 = v144;
                                            }
                                            while (v144 != &v288);
                                            goto LABEL_245;
                                          }
                                          double v145 = 1.0 - v137;
                                        }
                                        uint64_t v146 = 0;
                                        uint64_t v147 = (uint64_t **)v288;
                                        double v148 = 0.025 / v145;
LABEL_236:
                                        if (!v147)
                                        {
LABEL_242:
                                          double v151 = v148 * *((double *)v275 + v146);
                                          goto LABEL_244;
                                        }
                                        uint64_t v149 = v147;
                                        while (1)
                                        {
                                          uint64_t v150 = *((int *)v149 + 7);
                                          if (v146 >= v150)
                                          {
                                            if (v146 <= v150)
                                            {
                                              double v151 = v45;
LABEL_244:
                                              *((double *)v275 + v146++) = v151;
                                              if (v146 != 10) {
                                                goto LABEL_236;
                                              }
LABEL_245:
                                              if ((long long *)v46 == &v288)
                                              {
                                                double v160 = 1.0;
                                              }
                                              else
                                              {
                                                double v152 = 0.0;
                                                uint64_t v153 = (long long *)v46;
                                                do
                                                {
                                                  uint64_t v154 = (long long *)*((void *)v153 + 1);
                                                  double v155 = v153;
                                                  if (v154)
                                                  {
                                                    do
                                                    {
                                                      uint64_t v156 = v154;
                                                      uint64_t v154 = *(long long **)v154;
                                                    }
                                                    while (v154);
                                                  }
                                                  else
                                                  {
                                                    do
                                                    {
                                                      uint64_t v156 = (long long *)*((void *)v155 + 2);
                                                      BOOL v14 = *(void *)v156 == (void)v155;
                                                      double v155 = v156;
                                                    }
                                                    while (!v14);
                                                  }
                                                  double v152 = v152 + *((double *)v276 + *((int *)v153 + 7));
                                                  uint64_t v153 = v156;
                                                }
                                                while (v156 != &v288);
                                                if (vabdd_f64(1.0, v152) < 2.22044605e-16)
                                                {
                                                  uint64_t v157 = (long long *)v46;
                                                  do
                                                  {
                                                    *((double *)v276 + *((unsigned int *)v157 + 7)) = 1.0 / v44;
                                                    uint64_t v158 = (long long *)*((void *)v157 + 1);
                                                    if (v158)
                                                    {
                                                      do
                                                      {
                                                        uint64_t v159 = v158;
                                                        uint64_t v158 = *(long long **)v158;
                                                      }
                                                      while (v158);
                                                    }
                                                    else
                                                    {
                                                      do
                                                      {
                                                        uint64_t v159 = (long long *)*((void *)v157 + 2);
                                                        BOOL v14 = *(void *)v159 == (void)v157;
                                                        uint64_t v157 = v159;
                                                      }
                                                      while (!v14);
                                                    }
                                                    uint64_t v157 = v159;
                                                  }
                                                  while (v159 != &v288);
                                                  goto LABEL_274;
                                                }
                                                double v160 = 1.0 - v152;
                                              }
                                              uint64_t v161 = 0;
                                              double v162 = (uint64_t **)v288;
                                              double v163 = 0.025 / v160;
LABEL_265:
                                              if (!v162)
                                              {
LABEL_271:
                                                double v166 = v163 * *((double *)v276 + v161);
                                                goto LABEL_273;
                                              }
                                              double v164 = v162;
                                              while (1)
                                              {
                                                uint64_t v165 = *((int *)v164 + 7);
                                                if (v161 >= v165)
                                                {
                                                  if (v161 <= v165)
                                                  {
                                                    double v166 = v45;
LABEL_273:
                                                    *((double *)v276 + v161++) = v166;
                                                    if (v161 == 10)
                                                    {
LABEL_274:
                                                      if ((long long *)v46 == &v288)
                                                      {
                                                        double v175 = 1.0;
                                                      }
                                                      else
                                                      {
                                                        double v167 = 0.0;
                                                        float64x2_t v168 = (long long *)v46;
                                                        do
                                                        {
                                                          uint64_t v169 = (long long *)*((void *)v168 + 1);
                                                          int v170 = v168;
                                                          if (v169)
                                                          {
                                                            do
                                                            {
                                                              uint64_t v171 = v169;
                                                              uint64_t v169 = *(long long **)v169;
                                                            }
                                                            while (v169);
                                                          }
                                                          else
                                                          {
                                                            do
                                                            {
                                                              uint64_t v171 = (long long *)*((void *)v170 + 2);
                                                              BOOL v14 = *(void *)v171 == (void)v170;
                                                              int v170 = v171;
                                                            }
                                                            while (!v14);
                                                          }
                                                          double v167 = v167 + *((double *)v277 + *((int *)v168 + 7));
                                                          float64x2_t v168 = v171;
                                                        }
                                                        while (v171 != &v288);
                                                        if (vabdd_f64(1.0, v167) < 2.22044605e-16)
                                                        {
                                                          double v172 = (long long *)v46;
                                                          do
                                                          {
                                                            *((double *)v277 + *((unsigned int *)v172 + 7)) = 1.0 / v44;
                                                            double v173 = (long long *)*((void *)v172 + 1);
                                                            if (v173)
                                                            {
                                                              do
                                                              {
                                                                double v174 = v173;
                                                                double v173 = *(long long **)v173;
                                                              }
                                                              while (v173);
                                                            }
                                                            else
                                                            {
                                                              do
                                                              {
                                                                double v174 = (long long *)*((void *)v172 + 2);
                                                                BOOL v14 = *(void *)v174 == (void)v172;
                                                                double v172 = v174;
                                                              }
                                                              while (!v14);
                                                            }
                                                            double v172 = v174;
                                                          }
                                                          while (v174 != &v288);
                                                          goto LABEL_303;
                                                        }
                                                        double v175 = 1.0 - v167;
                                                      }
                                                      uint64_t v176 = 0;
                                                      BOOL v177 = (uint64_t **)v288;
                                                      double v178 = 0.025 / v175;
LABEL_294:
                                                      if (!v177)
                                                      {
LABEL_300:
                                                        double v181 = v178 * *((double *)v277 + v176);
                                                        goto LABEL_302;
                                                      }
                                                      uint64_t v179 = v177;
                                                      while (1)
                                                      {
                                                        uint64_t v180 = *((int *)v179 + 7);
                                                        if (v176 >= v180)
                                                        {
                                                          if (v176 <= v180)
                                                          {
                                                            double v181 = v45;
LABEL_302:
                                                            *((double *)v277 + v176++) = v181;
                                                            if (v176 != 10) {
                                                              goto LABEL_294;
                                                            }
LABEL_303:
                                                            if ((long long *)v46 == &v288)
                                                            {
                                                              double v189 = 1.0;
                                                            }
                                                            else
                                                            {
                                                              double v182 = 0.0;
                                                              long long v183 = (long long *)v46;
                                                              do
                                                              {
                                                                long long v184 = (long long *)*((void *)v183 + 1);
                                                                long long v185 = v183;
                                                                if (v184)
                                                                {
                                                                  do
                                                                  {
                                                                    long long v186 = v184;
                                                                    long long v184 = *(long long **)v184;
                                                                  }
                                                                  while (v184);
                                                                }
                                                                else
                                                                {
                                                                  do
                                                                  {
                                                                    long long v186 = (long long *)*((void *)v185 + 2);
                                                                    BOOL v14 = *(void *)v186 == (void)v185;
                                                                    long long v185 = v186;
                                                                  }
                                                                  while (!v14);
                                                                }
                                                                double v182 = v182 + *((double *)v278 + *((int *)v183 + 7));
                                                                long long v183 = v186;
                                                              }
                                                              while (v186 != &v288);
                                                              if (vabdd_f64(1.0, v182) < 2.22044605e-16)
                                                              {
                                                                do
                                                                {
                                                                  *((double *)v278 + *(unsigned int *)(v46 + 28)) = 1.0 / v44;
                                                                  long long v187 = *(long long **)(v46 + 8);
                                                                  if (v187)
                                                                  {
                                                                    do
                                                                    {
                                                                      uint64_t v188 = v187;
                                                                      long long v187 = *(long long **)v187;
                                                                    }
                                                                    while (v187);
                                                                  }
                                                                  else
                                                                  {
                                                                    do
                                                                    {
                                                                      uint64_t v188 = *(long long **)(v46 + 16);
                                                                      BOOL v14 = *(void *)v188 == v46;
                                                                      uint64_t v46 = (uint64_t)v188;
                                                                    }
                                                                    while (!v14);
                                                                  }
                                                                  uint64_t v46 = (uint64_t)v188;
                                                                }
                                                                while (v188 != &v288);
                                                                goto LABEL_331;
                                                              }
                                                              double v189 = 1.0 - v182;
                                                            }
                                                            uint64_t v190 = 0;
                                                            int8x16_t v191 = (uint64_t **)v288;
                                                            double v192 = 0.025 / v189;
LABEL_322:
                                                            if (!v191)
                                                            {
LABEL_328:
                                                              double v195 = v192 * *((double *)v278 + v190);
                                                              goto LABEL_330;
                                                            }
                                                            char v193 = v191;
                                                            while (1)
                                                            {
                                                              uint64_t v194 = *((int *)v193 + 7);
                                                              if (v190 >= v194)
                                                              {
                                                                if (v190 <= v194)
                                                                {
                                                                  double v195 = v45;
LABEL_330:
                                                                  *((double *)v278 + v190++) = v195;
                                                                  if (v190 == 10)
                                                                  {
LABEL_331:
                                                                    sub_18DF064FC((void *)v288);
                                                                    goto LABEL_332;
                                                                  }
                                                                  goto LABEL_322;
                                                                }
                                                                ++v193;
                                                              }
                                                              char v193 = (uint64_t **)*v193;
                                                              if (!v193) {
                                                                goto LABEL_328;
                                                              }
                                                            }
                                                          }
                                                          ++v179;
                                                        }
                                                        uint64_t v179 = (uint64_t **)*v179;
                                                        if (!v179) {
                                                          goto LABEL_300;
                                                        }
                                                      }
                                                    }
                                                    goto LABEL_265;
                                                  }
                                                  ++v164;
                                                }
                                                double v164 = (uint64_t **)*v164;
                                                if (!v164) {
                                                  goto LABEL_271;
                                                }
                                              }
                                            }
                                            ++v149;
                                          }
                                          uint64_t v149 = (uint64_t **)*v149;
                                          if (!v149) {
                                            goto LABEL_242;
                                          }
                                        }
                                      }
                                      goto LABEL_207;
                                    }
                                    ++v134;
                                  }
                                  uint64_t v134 = (uint64_t **)*v134;
                                  if (!v134) {
                                    goto LABEL_213;
                                  }
                                }
                              }
                              ++v119;
                            }
                            long long v119 = (uint64_t **)*v119;
                            if (!v119) {
                              goto LABEL_184;
                            }
                          }
                        }
                        goto LABEL_149;
                      }
                      ++v104;
                    }
                    uint64_t v104 = (uint64_t **)*v104;
                    if (!v104) {
                      goto LABEL_155;
                    }
                  }
                }
                ++v89;
              }
              uint64_t v89 = (uint64_t **)*v89;
              if (!v89) {
                goto LABEL_126;
              }
            }
          }
          goto LABEL_91;
        }
        ++v74;
      }
      uint64_t v74 = (uint64_t **)*v74;
      if (!v74) {
        goto LABEL_97;
      }
    }
  }
LABEL_332:
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404E78, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB404E78))
  {
    qword_1EB404E80 = 10;
    unk_1EB404E88 = 0;
    __cxa_guard_release(&qword_1EB404E78);
  }
  if (sub_18DEE4C00((double *)&v280, (double *)&qword_1EB404E80))
  {
    LOWORD(v287) = 12;
    LOBYTE(v292) = 4;
    double v259 = *(double *)(v11 + 288) + (double)*(uint64_t *)(v11 + 280);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v287, (unsigned __int8 *)&v292, "ActivityStateEstimator,time,%.3lf,resetting because prediction interval too large,%.3lf", v196, v197, v198, v199, v200, SLOBYTE(v259));
    BOOL v41 = 0;
    *(unsigned char *)uint64_t v11 = 0;
    *(void *)(v11 + 280) = 0;
    *(void *)(v11 + 288) = 0x7FF8000000000000;
    return v41;
  }
  double v203 = *(double *)(*(void *)(v11 + 8) + 872);
  *(double *)v201.i64 = v203 + v203;
  uint64_t v266 = 0;
  double v267 = 0.0;
  CNTimeSpan::SetTimeSpan(&v266, 0, v201, v202);
  std::string v260 = (_OWORD *)(v11 + 280);
  if (!v280)
  {
    double v204 = v281;
    if ((*(void *)&v281 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
      goto LABEL_341;
    }
  }
  if (!v266)
  {
    double v205 = v267;
    if ((*(void *)&v267 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
    {
      double v204 = v281;
LABEL_345:
      if (v204 > v205)
      {
LABEL_346:
        unsigned int v261 = vcvtpd_u64_f64((v204 + (double)v280) / v203);
        if (!v261)
        {
LABEL_388:
          *std::string v260 = *(_OWORD *)a2;
          return 1;
        }
        goto LABEL_349;
      }
      goto LABEL_348;
    }
  }
  if (v280 == v266)
  {
    double v204 = v281;
LABEL_341:
    double v205 = v267;
    goto LABEL_345;
  }
  if (v280 >= v266)
  {
    double v204 = v281;
    goto LABEL_346;
  }
LABEL_348:
  unsigned int v261 = 1;
LABEL_349:
  BOOL v41 = 0;
  int v206 = 0;
  uint64_t v265 = v11 + 144;
  uint64_t v263 = v11 + 24;
  BOOL v207 = *(_DWORD *)(v11 + 264) == 0;
  uint64_t v262 = v11;
  uint64_t v208 = v11 + 24;
  while (1)
  {
    int v264 = v206;
    if (v207) {
      sub_18DFE2F24(v265, v263);
    }
    unsigned int v209 = *(_DWORD *)(v11 + 152);
    unsigned int v210 = *(_DWORD *)(v11 + 156);
    if (v209) {
      BOOL v211 = v210 == 0;
    }
    else {
      BOOL v211 = 1;
    }
    int v212 = v211;
    uint64_t v213 = v11;
    if (v209 <= v210) {
      unsigned int v214 = *(_DWORD *)(v11 + 156);
    }
    else {
      unsigned int v214 = *(_DWORD *)(v11 + 152);
    }
    if (v212) {
      unint64_t v215 = 0;
    }
    else {
      unint64_t v215 = v214;
    }
    if (v212 == 1)
    {
      uint64_t v294 = 0x10000000ALL;
      long long v292 = (long long **)&unk_1EDD17628;
      long long v295 = v296;
      long long v293 = xmmword_18E1F8710;
      sub_18DFE2CC8((uint64_t)&v292, 1.0);
      uint64_t v289 = 0x10000000ALL;
      *(void *)&v216.f64[1] = 0xA0000000ALL;
      long long v288 = xmmword_18E200CF0;
      std::string v287 = (long long *)&unk_1EDD17628;
      long long v290 = (double *)v291;
      v216.f64[0] = INFINITY;
      sub_18DFE3240((uint64_t)&v292, (uint64_t)&v287, v216);
      uint64_t v217 = v265;
LABEL_371:
      sub_18DFE2F24(v217, (uint64_t)&v287);
      goto LABEL_374;
    }
    double v218 = *(double *)(v213 + 272);
    uint64_t v289 = 0x10000000ALL;
    long long v288 = xmmword_18E200CF0;
    std::string v287 = (long long *)&unk_1EDD17628;
    long long v290 = (double *)v291;
    uint64_t v219 = (cnprint::CNPrinter *)sub_18DFF2FDC(v265, 1, (uint64_t)&v287);
    double v220 = *v290;
    if (fabs(*v290 + -1.0) > v218)
    {
      if (cnprint::CNPrinter::GetLogLevel(v219) <= 1)
      {
        LOWORD(v287) = 2;
        LOBYTE(v292) = 1;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v287, (unsigned __int8 *)&v292, "WARNING: HMM prediction passed a non-normalized probability vector.", v221, v222, v223, v224, v225, v255);
      }
      if ((v214 & 0x80000000) != 0) {
LABEL_399:
      }
        __assert_rtn("Reshape", "cnmatrix.h", 2936, "nr >= 0");
      sub_18E14E5D4((uint64_t)&v292, v265);
      float64x2_t v226 = (float64x2_t)vdupq_lane_s32((int32x2_t)(v214 | 0x100000000), 0);
      HIDWORD(v226.f64[0]) = 1;
      long long v293 = (__int128)v226;
      uint64_t v289 = 0x10000000ALL;
      *(void *)&v226.f64[1] = 0xA0000000ALL;
      long long v288 = xmmword_18E200CF0;
      std::string v287 = (long long *)&unk_1EDD17628;
      long long v290 = (double *)v291;
      v226.f64[0] = 1.0 / v220;
      sub_18DFE3240((uint64_t)&v292, (uint64_t)&v287, v226);
      uint64_t v217 = v265;
      goto LABEL_371;
    }
    if ((v214 & 0x80000000) != 0) {
      goto LABEL_399;
    }
    sub_18E14E5D4((uint64_t)&v287, v265);
    int32x4_t v233 = vdupq_lane_s32((int32x2_t)(v214 | 0x100000000), 0);
    v233.i32[1] = 1;
    long long v288 = (__int128)v233;
    sub_18DFE2F24(v265, (uint64_t)&v287);
LABEL_374:
    uint64_t v11 = v262;
    *(_DWORD *)(v262 + 264) = 1;
    uint64_t v289 = 0xA0000000ALL;
    long long v288 = xmmword_18E1FD870;
    std::string v287 = (long long *)&unk_1EDD175C8;
    long long v290 = (double *)v291;
    sub_18E18EBC0((uint64_t)&v268, (uint64_t)&v287, v227, v228, v229, v230, v231, v232);
    if (v234)
    {
      LOWORD(v292) = 2;
      LOBYTE(v282) = 4;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v292, (unsigned __int8 *)&v282, "ERROR: HMM transition probability function failed.", v235, v236, v237, v238, v239, v255);
      goto LABEL_392;
    }
    if (v215)
    {
      unint64_t v240 = 0;
      BOOL v241 = 0;
      char v242 = v290;
LABEL_377:
      double v243 = 0.0;
      double v244 = v242;
      unint64_t v245 = v215;
      while (1)
      {
        double v246 = *v244;
        if (*v244 < 0.0 || v246 > 1.0) {
          break;
        }
        double v243 = v243 + v246;
        ++v244;
        if (!--v245)
        {
          if (fabs(v243 + -1.0) <= *(double *)(v262 + 272))
          {
            ++v240;
            v242 += SHIDWORD(v288);
            BOOL v241 = v240 >= v215;
            if (v240 != v215) {
              goto LABEL_377;
            }
          }
          break;
        }
      }
      if (!v241) {
        break;
      }
    }
    uint64_t v294 = 0x10000000ALL;
    long long v293 = xmmword_18E200CF0;
    long long v292 = (long long **)&unk_1EDD17628;
    long long v295 = v296;
    sub_18DFE2B44((uint64_t)&v287, v265, (uint64_t)&v292);
    sub_18DFE2F24(v208, (uint64_t)&v292);
    uint64_t v284 = 0x10000000ALL;
    long long v283 = xmmword_18E200CF0;
    char v282 = &unk_1EDD17628;
    long long v285 = (double *)&v286;
    BOOL v207 = 1;
    sub_18DFF2FDC(v208, 1, (uint64_t)&v282);
    v248.f64[0] = 1.0 / *v285;
    uint64_t v294 = 0x10000000ALL;
    long long v293 = xmmword_18E200CF0;
    long long v292 = (long long **)&unk_1EDD17628;
    long long v295 = v296;
    sub_18DFE3240(v208, (uint64_t)&v292, v248);
    sub_18DFE2F24(v208, (uint64_t)&v292);
    *(_DWORD *)(v262 + 264) = 0;
    int v206 = v264 + 1;
    BOOL v41 = v264 + 1 >= v261;
    if (v264 + 1 == v261) {
      goto LABEL_388;
    }
  }
  if (cnprint::CNPrinter::GetLogLevel(v234) <= 1)
  {
    LOWORD(v292) = 2;
    LOBYTE(v282) = 1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v292, (unsigned __int8 *)&v282, "ERROR: HMM transition probability matrix is invalid.", v249, v250, v251, v252, v253, v255);
  }
LABEL_392:
  LOWORD(v287) = 12;
  LOBYTE(v292) = 4;
  double v254 = *(double *)(v262 + 288) + (double)*(uint64_t *)(v262 + 280);
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v287, (unsigned __int8 *)&v292, "ActivityStateEstimator,time,%.3lf,failed to predict,code,%d,iteration,%u", v249, v250, v251, v252, v253, SLOBYTE(v254));
  return v41;
}

void sub_18E18EB6C(_Unwind_Exception *a1)
{
}

double sub_18E18EBC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v8 = *(double *)(a1 + 816);
  if ((*(void *)&v8 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (v8 > 0.0 ? (BOOL v9 = v8 < 1.0) : (BOOL v9 = 0), v9))
  {
    uint64_t v11 = a1 + 16;
    double v12 = 0.0;
    for (uint64_t i = 16; i != 96; i += 8)
    {
      double v14 = *(double *)(a1 + i);
      if ((*(void *)&v14 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        goto LABEL_16;
      }
      if (v14 < 0.0 || v14 > 1.0) {
        goto LABEL_16;
      }
      double v12 = v12 + v14;
    }
    if (fabs(v12 + -1.0) > v8)
    {
LABEL_16:
      __int16 v81 = 12;
      unsigned __int8 v80 = 4;
      double v75 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v81, &v80, "time,%.3lf,t-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v75));
      return result;
    }
    uint64_t v16 = a1 + 96;
    double v17 = 0.0;
    for (uint64_t j = 96; j != 176; j += 8)
    {
      double v19 = *(double *)(a1 + j);
      if ((*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        goto LABEL_26;
      }
      if (v19 < 0.0 || v19 > 1.0) {
        goto LABEL_26;
      }
      double v17 = v17 + v19;
    }
    if (fabs(v17 + -1.0) > v8)
    {
LABEL_26:
      __int16 v83 = 12;
      unsigned __int8 v82 = 4;
      double v76 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v83, &v82, "time,%.3lf,t-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v76));
      return result;
    }
    uint64_t v21 = a1 + 176;
    double v22 = 0.0;
    for (uint64_t k = 176; k != 256; k += 8)
    {
      double v24 = *(double *)(a1 + k);
      if ((*(void *)&v24 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        goto LABEL_36;
      }
      if (v24 < 0.0 || v24 > 1.0) {
        goto LABEL_36;
      }
      double v22 = v22 + v24;
    }
    if (fabs(v22 + -1.0) > v8)
    {
LABEL_36:
      __int16 v85 = 12;
      unsigned __int8 v84 = 4;
      double v77 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v85, &v84, "time,%.3lf,t-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v77));
      return result;
    }
    uint64_t v26 = a1 + 256;
    double v27 = 0.0;
    for (uint64_t m = 256; m != 336; m += 8)
    {
      double v29 = *(double *)(a1 + m);
      if ((*(void *)&v29 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        goto LABEL_46;
      }
      if (v29 < 0.0 || v29 > 1.0) {
        goto LABEL_46;
      }
      double v27 = v27 + v29;
    }
    if (fabs(v27 + -1.0) > v8)
    {
LABEL_46:
      double v31 = "invalid transition probabilities from running state";
      uint64_t v32 = 119;
      return sub_18E186550(a1, (uint64_t)v31, (uint64_t)"t_ActivityState", v32, a5, a6, a7, a8);
    }
    uint64_t v33 = a1 + 336;
    double v34 = 0.0;
    for (uint64_t n = 336; n != 416; n += 8)
    {
      double v36 = *(double *)(a1 + n);
      if ((*(void *)&v36 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        goto LABEL_57;
      }
      if (v36 < 0.0 || v36 > 1.0) {
        goto LABEL_57;
      }
      double v34 = v34 + v36;
    }
    if (fabs(v34 + -1.0) > v8)
    {
LABEL_57:
      double v31 = "invalid transition probabilities from cycling state";
      uint64_t v32 = 124;
      return sub_18E186550(a1, (uint64_t)v31, (uint64_t)"t_ActivityState", v32, a5, a6, a7, a8);
    }
    uint64_t v38 = a1 + 416;
    double v39 = 0.0;
    for (iuint64_t i = 416; ii != 496; ii += 8)
    {
      double v41 = *(double *)(a1 + ii);
      if ((*(void *)&v41 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        goto LABEL_67;
      }
      if (v41 < 0.0 || v41 > 1.0) {
        goto LABEL_67;
      }
      double v39 = v39 + v41;
    }
    if (fabs(v39 + -1.0) > v8)
    {
LABEL_67:
      double v31 = "invalid transition probabilities from driving state";
      uint64_t v32 = 129;
      return sub_18E186550(a1, (uint64_t)v31, (uint64_t)"t_ActivityState", v32, a5, a6, a7, a8);
    }
    uint64_t v43 = a1 + 496;
    double v44 = 0.0;
    for (juint64_t j = 496; jj != 576; jj += 8)
    {
      double v46 = *(double *)(a1 + jj);
      if ((*(void *)&v46 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        goto LABEL_77;
      }
      if (v46 < 0.0 || v46 > 1.0) {
        goto LABEL_77;
      }
      double v44 = v44 + v46;
    }
    if (fabs(v44 + -1.0) > v8)
    {
LABEL_77:
      double v31 = "invalid transition probabilities from swimming state";
      uint64_t v32 = 134;
      return sub_18E186550(a1, (uint64_t)v31, (uint64_t)"t_ActivityState", v32, a5, a6, a7, a8);
    }
    uint64_t v48 = a1 + 576;
    double v49 = 0.0;
    for (kuint64_t k = 576; kk != 656; kk += 8)
    {
      double v51 = *(double *)(a1 + kk);
      if ((*(void *)&v51 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        goto LABEL_87;
      }
      if (v51 < 0.0 || v51 > 1.0) {
        goto LABEL_87;
      }
      double v49 = v49 + v51;
    }
    if (fabs(v49 + -1.0) > v8)
    {
LABEL_87:
      double v31 = "invalid transition probabilities from wheelschair state";
      uint64_t v32 = 139;
      return sub_18E186550(a1, (uint64_t)v31, (uint64_t)"t_ActivityState", v32, a5, a6, a7, a8);
    }
    uint64_t v53 = a1 + 656;
    double v54 = 0.0;
    for (muint64_t m = 656; mm != 736; mm += 8)
    {
      double v56 = *(double *)(a1 + mm);
      if ((*(void *)&v56 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        goto LABEL_97;
      }
      if (v56 < 0.0 || v56 > 1.0) {
        goto LABEL_97;
      }
      double v54 = v54 + v56;
    }
    if (fabs(v54 + -1.0) > v8)
    {
LABEL_97:
      double v31 = "invalid transition probabilities from highspeed state";
      uint64_t v32 = 144;
      return sub_18E186550(a1, (uint64_t)v31, (uint64_t)"t_ActivityState", v32, a5, a6, a7, a8);
    }
    uint64_t v58 = a1 + 736;
    double v59 = 0.0;
    for (nuint64_t n = 736; nn != 816; nn += 8)
    {
      double v61 = *(double *)(a1 + nn);
      a5 = *(void *)&v61 & 0x7FFFFFFFFFFFFFFFLL;
      if ((*(void *)&v61 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        goto LABEL_107;
      }
      if (v61 < 0.0 || v61 > 1.0) {
        goto LABEL_107;
      }
      double v59 = v59 + v61;
    }
    if (fabs(v59 + -1.0) > v8)
    {
LABEL_107:
      double v31 = "invalid transition probabilities from airborne state";
      uint64_t v32 = 149;
      return sub_18E186550(a1, (uint64_t)v31, (uint64_t)"t_ActivityState", v32, a5, a6, a7, a8);
    }
    uint64_t v63 = 0;
    *(_OWORD *)(a2 + 8) = xmmword_18E1FD870;
    uint64_t v64 = *(void *)(a2 + 32);
    do
    {
      *(void *)(v64 + v63) = *(void *)(v11 + v63);
      v63 += 8;
    }
    while (v63 != 80);
    for (uint64_t i1 = 0; i1 != 80; i1 += 8)
      *(void *)(v64 + 80 + i1) = *(void *)(v16 + i1);
    for (uint64_t i2 = 0; i2 != 80; i2 += 8)
      *(void *)(v64 + 160 + i2) = *(void *)(v21 + i2);
    for (uint64_t i3 = 0; i3 != 80; i3 += 8)
      *(void *)(v64 + 240 + i3) = *(void *)(v26 + i3);
    for (uint64_t i4 = 0; i4 != 80; i4 += 8)
      *(void *)(v64 + 320 + i4) = *(void *)(v33 + i4);
    for (uint64_t i5 = 0; i5 != 80; i5 += 8)
      *(void *)(v64 + 400 + i5) = *(void *)(v38 + i5);
    for (uint64_t i6 = 0; i6 != 80; i6 += 8)
      *(void *)(v64 + 480 + i6) = *(void *)(v43 + i6);
    for (uint64_t i7 = 0; i7 != 80; i7 += 8)
      *(void *)(v64 + 560 + i7) = *(void *)(v48 + i7);
    for (uint64_t i8 = 0; i8 != 80; i8 += 8)
      *(void *)(v64 + 640 + i8) = *(void *)(v53 + i8);
    for (uint64_t i9 = 0; i9 != 80; i9 += 8)
    {
      double result = *(double *)(v58 + i9);
      *(double *)(v64 + 720 + i9) = result;
    }
  }
  else
  {
    __int16 v79 = 12;
    unsigned __int8 v78 = 4;
    double v74 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v79, &v78, "time,%.3lf,t-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v74));
  }
  return result;
}

uint64_t **sub_18E18F28C(uint64_t **result, char a2)
{
  uint64_t v2 = result;
  switch(a2)
  {
    case 4:
      long long v3 = *result;
      int v4 = 4;
      int v5 = 4;
      break;
    case 2:
      long long v3 = *result;
      int v4 = 5;
      int v5 = 5;
      break;
    case 1:
      sub_18E1902B4(*result, 2, 2);
      long long v3 = *v2;
      int v4 = 3;
      int v5 = 3;
      break;
    default:
      return result;
  }

  return (uint64_t **)sub_18E1902B4(v3, v4, v5);
}

uint64_t raven::RavenActivityStateEstimator::Reset(uint64_t this)
{
  *(unsigned char *)this = 0;
  *(void *)(this + 280) = 0;
  *(void *)(this + 288) = 0x7FF8000000000000;
  return this;
}

BOOL raven::RavenActivityStateEstimator::Update(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)a1)
  {
    long long v10 = xmmword_18E21DB70;
    long long v11 = 0uLL;
    int64x2_t v12 = 0uLL;
    int64x2_t v13 = 0uLL;
    int64x2_t v14 = 0uLL;
    switch(*a3)
    {
      case 0:
        memset_pattern16(__b, &unk_18E21DC50, 0x50uLL);
        long long v11 = __b[0];
        int64x2_t v12 = (int64x2_t)__b[1];
        int64x2_t v13 = (int64x2_t)__b[2];
        int64x2_t v14 = (int64x2_t)__b[3];
        long long v10 = __b[4];
        break;
      case 1:
        int64x2_t v14 = vdupq_n_s64(0x3F50624DD2F1A9FCuLL);
        int64x2_t v13 = (int64x2_t)xmmword_18E21DC10;
        int64x2_t v12 = (int64x2_t)xmmword_18E21DC20;
        long long v11 = xmmword_18E21DC30;
        goto LABEL_8;
      case 2:
        int64x2_t v14 = vdupq_n_s64(0x3F50624DD2F1A9FCuLL);
        int64x2_t v13 = (int64x2_t)xmmword_18E21DBE0;
        int64x2_t v12 = (int64x2_t)xmmword_18E21DBF0;
        long long v11 = xmmword_18E21DC00;
LABEL_8:
        long long v10 = (__int128)v14;
        break;
      case 3:
        int64x2_t v13 = vdupq_n_s64(0x3F50624DD2F1A9FCuLL);
        int64x2_t v12 = (int64x2_t)xmmword_18E21DBD0;
        goto LABEL_17;
      case 4:
        int64x2_t v13 = (int64x2_t)xmmword_18E21DBC0;
        goto LABEL_12;
      case 5:
        int64x2_t v13 = (int64x2_t)xmmword_18E21DBB0;
LABEL_12:
        int64x2_t v12 = vdupq_n_s64(0x3F50624DD2F1A9FCuLL);
        int64x2_t v14 = v12;
        long long v10 = (__int128)v12;
        break;
      case 6:
        int64x2_t v14 = (int64x2_t)xmmword_18E21DBA0;
        goto LABEL_15;
      case 7:
        int64x2_t v14 = (int64x2_t)xmmword_18E21DB70;
LABEL_15:
        long long v10 = 0uLL;
        break;
      case 9:
        int64x2_t v13 = vdupq_n_s64(0x3F50624DD2F1A9FCuLL);
        int64x2_t v12 = (int64x2_t)xmmword_18E21DB80;
        long long v11 = xmmword_18E21DB90;
LABEL_17:
        int64x2_t v14 = v13;
        long long v10 = (__int128)v13;
        break;
      case 0xA:
        LOWORD(v33[0]) = 12;
        LOBYTE(__b[0]) = 4;
        double v30 = *(double *)(a2 + 8) + (double)*(uint64_t *)a2;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)v33, (unsigned __int8 *)__b, "ActivityStateEstimator,time,%.3lf,invalid activity input type,%d", a4, a5, a6, a7, a8, SLOBYTE(v30));
        return 0;
      default:
        break;
    }
    v33[0] = *(_OWORD *)a2;
    v33[1] = v11;
    v33[2] = v12;
    v33[3] = v13;
    v33[4] = v14;
    v33[5] = v10;
    int v20 = sub_18E18FAEC(a1 + 16, (uint64_t)v33);
    BOOL v26 = v20 == 0;
    if (v20)
    {
      __int16 v32 = 12;
      unsigned __int8 v31 = 4;
      double v27 = *(double *)(a1 + 288) + (double)*(uint64_t *)(a1 + 280);
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v32, &v31, "ActivityStateEstimator,time,%.3lf,failed RavenActivityInput update,code,%d", v21, v22, v23, v24, v25, SLOBYTE(v27));
    }
  }
  else
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) <= 1)
    {
      LOWORD(v33[0]) = 12;
      LOBYTE(__b[0]) = 1;
      double v29 = *(double *)(a2 + 8) + (double)*(uint64_t *)a2;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v33, (unsigned __int8 *)__b, "WARNING: ActivityStateEstimator,time,%.3lf,trying to update uninitialized estimator", v15, v16, v17, v18, v19, SLOBYTE(v29));
    }
    return 0;
  }
  return v26;
}

uint64_t sub_18E18F5E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v8 = *(double *)(a1 + 16);
  if ((*(uint64_t *)&v8 <= -1 || ((*(void *)&v8 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 >= 0x3FF)
    && (unint64_t)(*(void *)&v8 - 1) >= 0xFFFFFFFFFFFFFLL
    && (*(void *)&v8 & 0x7FFFFFFFFFFFFFFFLL) != 0
    || v8 > 1.0)
  {
    __int16 v61 = 12;
    unsigned __int8 v60 = 4;
    double v55 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v61, &v60, "time,%.3lf,e-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v55));
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = *(void *)(a1 + 24);
  if ((v13 <= -1 || ((v13 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 >= 0x3FF)
    && (unint64_t)(v13 - 1) >= 0xFFFFFFFFFFFFFLL
    && (v13 & 0x7FFFFFFFFFFFFFFFLL) != 0
    || *(double *)(a1 + 24) > 1.0)
  {
    __int16 v63 = 12;
    unsigned __int8 v62 = 4;
    double v56 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v63, &v62, "time,%.3lf,e-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v56));
    return 0xFFFFFFFFLL;
  }
  uint64_t v18 = *(void *)(a1 + 32);
  BOOL v21 = v18 > -1 && ((v18 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 < 0x3FF
     || (unint64_t)(v18 - 1) < 0xFFFFFFFFFFFFFLL
     || (v18 & 0x7FFFFFFFFFFFFFFFLL) == 0;
  if (!v21 || *(double *)(a1 + 32) > 1.0)
  {
    __int16 v65 = 12;
    unsigned __int8 v64 = 4;
    double v57 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v65, &v64, "time,%.3lf,e-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v57));
    return 0xFFFFFFFFLL;
  }
  uint64_t v22 = *(void *)(a1 + 40);
  BOOL v25 = v22 > -1 && ((v22 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 < 0x3FF
     || (unint64_t)(v22 - 1) < 0xFFFFFFFFFFFFFLL
     || (v22 & 0x7FFFFFFFFFFFFFFFLL) == 0;
  if (!v25 || *(double *)(a1 + 40) > 1.0)
  {
    __int16 v67 = 12;
    unsigned __int8 v66 = 4;
    double v58 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v67, &v66, "time,%.3lf,e-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v58));
    return 0xFFFFFFFFLL;
  }
  uint64_t v26 = *(void *)(a1 + 48);
  BOOL v29 = v26 > -1 && ((v26 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 < 0x3FF
     || (unint64_t)(v26 - 1) < 0xFFFFFFFFFFFFFLL
     || (v26 & 0x7FFFFFFFFFFFFFFFLL) == 0;
  if (!v29 || *(double *)(a1 + 48) > 1.0)
  {
    __int16 v69 = 12;
    unsigned __int8 v68 = 4;
    double v59 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v69, &v68, "time,%.3lf,e-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v59));
    return 0xFFFFFFFFLL;
  }
  uint64_t v30 = *(void *)(a1 + 56);
  BOOL v33 = v30 > -1 && ((v30 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 < 0x3FF
     || (unint64_t)(v30 - 1) < 0xFFFFFFFFFFFFFLL
     || (v30 & 0x7FFFFFFFFFFFFFFFLL) == 0;
  if (!v33 || *(double *)(a1 + 56) > 1.0)
  {
    uint64_t v53 = "invalid likelihood (driving state)";
    uint64_t v54 = 115;
LABEL_138:
    sub_18E186620(a1, (uint64_t)v53, (uint64_t)"e_ActivityState", v54, a5, a6, a7, a8);
    return 0xFFFFFFFFLL;
  }
  uint64_t v34 = *(void *)(a1 + 64);
  BOOL v37 = v34 > -1 && ((v34 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 < 0x3FF
     || (unint64_t)(v34 - 1) < 0xFFFFFFFFFFFFFLL
     || (v34 & 0x7FFFFFFFFFFFFFFFLL) == 0;
  if (!v37 || *(double *)(a1 + 64) > 1.0)
  {
    uint64_t v53 = "invalid likelihood (swimming state)";
    uint64_t v54 = 121;
    goto LABEL_138;
  }
  uint64_t v38 = *(void *)(a1 + 72);
  BOOL v41 = v38 > -1 && ((v38 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 < 0x3FF
     || (unint64_t)(v38 - 1) < 0xFFFFFFFFFFFFFLL
     || (v38 & 0x7FFFFFFFFFFFFFFFLL) == 0;
  if (!v41 || *(double *)(a1 + 72) > 1.0)
  {
    uint64_t v53 = "invalid likelihood (wheelchair state)";
    uint64_t v54 = 127;
    goto LABEL_138;
  }
  uint64_t v42 = *(void *)(a1 + 80);
  BOOL v45 = v42 > -1 && ((v42 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 < 0x3FF
     || (unint64_t)(v42 - 1) < 0xFFFFFFFFFFFFFLL
     || (v42 & 0x7FFFFFFFFFFFFFFFLL) == 0;
  if (!v45 || *(double *)(a1 + 80) > 1.0)
  {
    uint64_t v53 = "invalid likelihood (highspeed state)";
    uint64_t v54 = 133;
    goto LABEL_138;
  }
  uint64_t v46 = *(void *)(a1 + 88);
  BOOL v49 = v46 > -1 && ((v46 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 < 0x3FF
     || (unint64_t)(v46 - 1) < 0xFFFFFFFFFFFFFLL
     || (v46 & 0x7FFFFFFFFFFFFFFFLL) == 0;
  if (!v49 || *(double *)(a1 + 88) > 1.0)
  {
    uint64_t v53 = "invalid likelihood (airborne state)";
    uint64_t v54 = 139;
    goto LABEL_138;
  }
  uint64_t v50 = 0;
  *(_OWORD *)(a2 + 8) = xmmword_18E200CF0;
  uint64_t v51 = *(void *)(a2 + 32);
  *(double *)uint64_t v51 = v8;
  *(void *)(v51 + 8) = *(void *)(a1 + 24);
  *(void *)(v51 + 16) = *(void *)(a1 + 32);
  *(void *)(v51 + 24) = *(void *)(a1 + 40);
  *(void *)(v51 + 32) = *(void *)(a1 + 48);
  *(void *)(v51 + 40) = *(void *)(a1 + 56);
  *(void *)(v51 + 48) = *(void *)(a1 + 64);
  *(void *)(v51 + 56) = *(void *)(a1 + 72);
  *(void *)(v51 + 64) = *(void *)(a1 + 80);
  *(void *)(v51 + 72) = *(void *)(a1 + 88);
  return v50;
}

uint64_t sub_18E18FAEC(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 248) == 1) {
    sub_18DFE2F24(a1 + 8, a1 + 128);
  }
  uint64_t v72 = 0x100000001;
  *(void *)&long long v4 = 0x100000001;
  *((void *)&v4 + 1) = 0x100000001;
  long long v71 = v4;
  v70[10] = &unk_1EDD17EC8;
  double v73 = &v74;
  double v74 = sub_18E18F5E0;
  uint64_t v68 = 0x10000000ALL;
  unsigned __int8 v66 = &unk_1EDD175F8;
  long long v67 = v4;
  __int16 v69 = v70;
  v70[0] = a2;
  unsigned int v5 = *(_DWORD *)(a1 + 16);
  unsigned int v6 = *(_DWORD *)(a1 + 20);
  sub_18DFF2DB8((uint64_t)v64, (uint64_t)&v66);
  if (v5 <= v6) {
    unsigned int v7 = v6;
  }
  else {
    unsigned int v7 = v5;
  }
  if (v6) {
    BOOL v8 = v5 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = v7;
  }
  double v10 = *(double *)(a1 + 256);
  if (!*(_DWORD *)(a1 + 16) || !*(_DWORD *)(a1 + 20))
  {
    if ((v9 & 0x80000000) != 0) {
      __assert_rtn("Ones", "cnmatrix.h", 2317, "nr >= 0");
    }
    uint64_t v83 = 0x10000000ALL;
    __int16 v81 = &unk_1EDD17628;
    unsigned __int8 v84 = (double *)v85;
    *(void *)&long long v82 = v9 | 0x100000000;
    double v18 = 1.0 / (double)(int)v9;
    DWORD2(v82) = v9;
    HIDWORD(v82) = v9;
    sub_18DFE2CC8((uint64_t)&v81, 1.0);
    uint64_t v88 = 0x10000000ALL;
    float64x2_t v20 = (float64x2_t)xmmword_18E200CF0;
    goto LABEL_21;
  }
  uint64_t v88 = 0x10000000ALL;
  long long v62 = xmmword_18E200CF0;
  long long v87 = xmmword_18E200CF0;
  uint64_t v86 = &unk_1EDD17628;
  uint64_t v89 = (double *)v90;
  long long v11 = (cnprint::CNPrinter *)sub_18DFF2FDC(a1 + 8, 1, (uint64_t)&v86);
  double v12 = *v89;
  if (fabs(*v89 + -1.0) > v10)
  {
    if (cnprint::CNPrinter::GetLogLevel(v11) <= 1)
    {
      LOWORD(v86) = 2;
      LOBYTE(v81) = 1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v86, (unsigned __int8 *)&v81, "WARNING: HMM update passed a non-normalized probability vector.", v13, v14, v15, v16, v17, 10);
    }
    if ((v9 & 0x80000000) == 0)
    {
      double v18 = 1.0 / v12;
      sub_18E14E5D4((uint64_t)&v81, a1 + 8);
      int32x4_t v19 = vdupq_lane_s32((int32x2_t)(v9 | 0x100000000), 0);
      v19.i32[1] = 1;
      long long v82 = (__int128)v19;
      uint64_t v88 = 0x10000000ALL;
      float64x2_t v20 = (float64x2_t)v62;
LABEL_21:
      long long v87 = (__int128)v20;
      uint64_t v86 = &unk_1EDD17628;
      uint64_t v89 = (double *)v90;
      v20.f64[0] = v18;
      sub_18DFE3240((uint64_t)&v81, (uint64_t)&v86, v20);
      goto LABEL_24;
    }
LABEL_60:
    __assert_rtn("Reshape", "cnmatrix.h", 2936, "nr >= 0");
  }
  if ((v9 & 0x80000000) != 0) {
    goto LABEL_60;
  }
  sub_18E14E5D4((uint64_t)&v86, a1 + 8);
  int32x4_t v21 = vdupq_lane_s32((int32x2_t)(v9 | 0x100000000), 0);
  v21.i32[1] = 1;
  long long v87 = (__int128)v21;
LABEL_24:
  sub_18DFE2F24(a1 + 8, (uint64_t)&v86);
  sub_18E14E5D4((uint64_t)&v86, a1 + 8);
  uint64_t v22 = *v73;
  uint64_t v83 = 0x10000000ALL;
  __int16 v81 = &unk_1EDD17628;
  long long v63 = xmmword_18E200CF0;
  long long v82 = xmmword_18E200CF0;
  unsigned __int8 v84 = (double *)v85;
  uint64_t v23 = (cnprint::CNPrinter *)((uint64_t (*)(void, void **))v22)(*v65, &v81);
  if (v23)
  {
    LOWORD(v75) = 2;
    unsigned __int8 v80 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v75, &v80, "ERROR: HMM emission function failed.", v24, v25, v26, v27, v28, 10);
    return 29;
  }
  if (v9)
  {
    double v31 = 0.0;
    __int16 v32 = v84;
    BOOL v33 = v84;
    uint64_t v34 = v9;
    do
    {
      double v35 = *v33;
      if (*v33 < 0.0 || v35 > 1.0)
      {
        LOWORD(v75) = 2;
        unsigned __int8 v80 = 4;
        uint64_t v48 = "ERROR: HMM emission probability matrix is invalid.";
        goto LABEL_46;
      }
      double v31 = v31 + v35;
      ++v33;
      --v34;
    }
    while (v34);
    if (fabs(v31) > v10)
    {
      BOOL v37 = v89;
      do
      {
        double v38 = *v32++;
        v29.n128_f64[0] = v38 * *v37;
        *v37++ = v29.n128_f64[0];
        --v9;
      }
      while (v9);
      goto LABEL_39;
    }
  }
  else if (v10 < 0.0)
  {
LABEL_39:
    uint64_t v39 = DWORD1(v87);
    if (DWORD1(v87))
    {
      uint64_t v40 = 0;
      uint64_t v41 = v87;
      uint64_t v42 = v89;
      int v43 = 1;
      long long v44 = xmmword_18E200CF0;
      do
      {
        double v45 = v42[(v41 * v40)];
        unsigned int v46 = v43;
        uint64_t v47 = v41 - 1;
        if (v41 >= 2)
        {
          do
          {
            double v45 = v45 + v42[v46++];
            --v47;
          }
          while (v47);
        }
        v79[v40++] = v45;
        v43 += v41;
      }
      while (v40 != v39);
      v29.n128_f64[0] = v79[0];
    }
    else
    {
      long long v44 = xmmword_18E200CF0;
    }
    if (fabs(v29.n128_f64[0]) < 2.22044605e-16)
    {
      if (cnprint::CNPrinter::GetLogLevel(v23) <= 1)
      {
        LOWORD(v75) = 2;
        unsigned __int8 v80 = 1;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v75, &v80, "HMM state is null vector after update; revert to input state",
          v49,
          v50,
          v51,
          v52,
          v53,
          10);
      }
      __n128 v29 = sub_18DFE2F24((uint64_t)&v86, a1 + 8);
      uint64_t v54 = DWORD1(v87);
      if (DWORD1(v87))
      {
        uint64_t v55 = 0;
        uint64_t v56 = v87;
        double v57 = v89;
        int v58 = 1;
        long long v44 = v63;
        do
        {
          double v59 = v57[(v56 * v55)];
          unsigned int v60 = v58;
          uint64_t v61 = v56 - 1;
          if (v56 >= 2)
          {
            do
            {
              double v59 = v59 + v57[v60++];
              --v61;
            }
            while (v61);
          }
          v79[v55++] = v59;
          v58 += v56;
        }
        while (v55 != v54);
        v29.n128_f64[0] = v79[0];
      }
      else
      {
        long long v44 = v63;
      }
    }
    uint64_t v77 = 0x10000000ALL;
    long long v76 = v44;
    double v75 = &unk_1EDD17628;
    unsigned __int8 v78 = v79;
    v29.n128_f64[0] = 1.0 / v29.n128_f64[0];
    sub_18DFE3240((uint64_t)&v86, (uint64_t)&v75, (float64x2_t)v29);
    sub_18DFE2F24((uint64_t)&v86, (uint64_t)&v75);
    sub_18DFE2F24(a1 + 128, (uint64_t)&v86);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 248) = 1;
    return result;
  }
  LOWORD(v75) = 2;
  unsigned __int8 v80 = 4;
  uint64_t v48 = "ERROR: HMM emission probability matrix is null matrix";
LABEL_46:
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v75, &v80, v48, v24, v25, v26, v27, v28, 10);
  return 30;
}

uint64_t raven::RavenActivityStateEstimator::Update(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)a1)
  {
    if ((*(void *)a3 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || *(double *)a3 > 6.4)
    {
      BOOL v11 = 1;
      if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) <= 1)
      {
        LOWORD(v34[0]) = 12;
        LOBYTE(v33) = 1;
        double v30 = *(double *)(a1 + 288) + (double)*(uint64_t *)(a1 + 280);
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)v34, (unsigned __int8 *)&v33, "ActivityStateEstimator,time,%.3lf,step count age invalid or too old,%.3lf", v17, v18, v19, v20, v21, SLOBYTE(v30));
      }
    }
    else if (*(_DWORD *)(a3 + 8))
    {
      v34[0] = *(_OWORD *)a2;
      v34[1] = xmmword_18E21DC40;
      double v34[2] = vdupq_n_s64(0x3FEE666666666666uLL);
      int64x2_t v35 = vdupq_n_s64(0x3FA999999999999AuLL);
      int64x2_t v36 = v35;
      int64x2_t v37 = v35;
      int v5 = sub_18E18FAEC(a1 + 16, (uint64_t)v34);
      BOOL v11 = v5 == 0;
      if (v5)
      {
        __int16 v33 = 12;
        unsigned __int8 v32 = 4;
        double v28 = *(double *)(a1 + 288) + (double)*(uint64_t *)(a1 + 280);
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v33, &v32, "ActivityStateEstimator,time,%.3lf,failed StepCountArgs update,code,%d", v6, v7, v8, v9, v10, SLOBYTE(v28));
      }
    }
    else
    {
      if (!cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1))
      {
        LOWORD(v34[0]) = 12;
        LOBYTE(v33) = 0;
        double v31 = *(double *)(a1 + 288) + (double)*(uint64_t *)(a1 + 280);
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)v34, (unsigned __int8 *)&v33, "ActivityStateEstimator,time,%.3lf,no update due to absence of steps", v22, v23, v24, v25, v26, SLOBYTE(v31));
      }
      return 1;
    }
  }
  else
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) <= 1)
    {
      LOWORD(v34[0]) = 12;
      LOBYTE(v33) = 1;
      double v29 = *(double *)(a2 + 8) + (double)*(uint64_t *)a2;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v34, (unsigned __int8 *)&v33, "WARNING: ActivityStateEstimator,time,%.3lf,trying to update uninitialized estimator", v12, v13, v14, v15, v16, SLOBYTE(v29));
    }
    return 0;
  }
  return v11;
}

uint64_t *sub_18E1902B4(uint64_t *result, int a2, int a3)
{
  long long v4 = result;
  uint64_t v6 = (uint64_t **)(result + 1);
  uint64_t v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (void *)v5;
        int v8 = *(_DWORD *)(v5 + 28);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = (uint64_t **)(v7 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = result + 1;
LABEL_9:
    uint64_t v9 = operator new(0x20uLL);
    v9[7] = a3;
    *(void *)uint64_t v9 = 0;
    *((void *)v9 + 1) = 0;
    *((void *)v9 + 2) = v7;
    *uint64_t v6 = (uint64_t *)v9;
    uint64_t v10 = *(void *)*v4;
    if (v10)
    {
      *long long v4 = v10;
      BOOL v11 = *v6;
    }
    else
    {
      BOOL v11 = (uint64_t *)v9;
    }
    uint64_t result = sub_18DEEDADC((uint64_t *)v4[1], v11);
    ++v4[2];
  }
  return result;
}

void *sub_18E19036C(void *result)
{
  *uint64_t result = &unk_1EDD173B8;
  return result;
}

void *sub_18E19038C(void *result)
{
  *uint64_t result = &unk_1EDD17148;
  return result;
}

void sub_18E1903AC(void *a1)
{
  *a1 = &unk_1EDD17148;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1903DC(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E1903E8(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(&v9, v4);
      if (v4 >= 3)
      {
        int v6 = v9;
        uint64_t v7 = 8;
        int v8 = v3 + v1 - v5;
        do
        {
          if (!v6)
          {
            *(void *)(*(void *)(a1 + 32) + 8 * (v8 % (v4 - 1))) = *(void *)(*(void *)(a1 + 32) + v7);
            int v6 = 1;
          }
          v8 += v3 + v1 - v5;
          v7 += 8;
        }
        while (8 * (v4 - 1) != v7);
      }
    }
  }
}

void sub_18E1904A0(void *a1)
{
  *a1 = &unk_1EDD173B8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1904D0(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E1904DC(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = 1;
        do
        {
          int v8 = &v13[v7];
          if (!v13[v7])
          {
            uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8 * v7);
            int v10 = v7;
            do
            {
              int v10 = (int)(v10 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v11 = *(void *)(a1 + 32);
              uint64_t v12 = *(void *)(v11 + 8 * v10);
              *(void *)(v11 + 8 * v10) = v9;
              *int v8 = 1;
              int v8 = &v13[v10];
              uint64_t v9 = v12;
            }
            while (!*v8);
          }
          ++v7;
        }
        while (v7 != v6);
      }
    }
  }
}

uint64_t raven::MovingStateChecker::Configure(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 16) = a3;
  *(unsigned char *)(a1 + 8) = 1;
  return 0;
}

uint64_t raven::MovingStateChecker::HandleEvent(raven::MovingStateChecker *this, const raven::MovingStateEvent *a2, raven::MovingStateEvent *a3)
{
  if (!*((unsigned char *)this + 8))
  {
    __int16 v39 = 12;
    unsigned __int8 v38 = 4;
    uint64_t v20 = (*(uint64_t (**)(const raven::MovingStateEvent *))(*(void *)a2 + 16))(a2);
    double v34 = v21 + (double)v20;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v39, &v38, "t,%.3lf,MovingStateChecker,Checker is not configured. Cannot perform checks", v22, v23, v24, v25, v26, SLOBYTE(v34));
    return 0xFFFFFFFFLL;
  }
  if (*((unsigned __int8 *)a2 + 104) >= 4u)
  {
    __int16 v37 = 12;
    unsigned __int8 v36 = 4;
    uint64_t v27 = (*(uint64_t (**)(const raven::MovingStateEvent *))(*(void *)a2 + 16))(a2);
    double v35 = v28 + (double)v27;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v37, &v36, "t,%.3lf, Warning: Invalid type detected in moving state integrity check.", v29, v30, v31, v32, v33, SLOBYTE(v35));
    return 0xFFFFFFFFLL;
  }
  double v3 = *((double *)a2 + 14);
  if (v3 < 0.0 || (*((void *)a2 + 14) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || v3 > 1.0) {
    return 0xFFFFFFFFLL;
  }
  double v6 = *((double *)a2 + 15);
  BOOL v7 = v6 < 0.0 || (*((void *)a2 + 15) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000;
  if (v7 || v6 > 1.0) {
    return 0xFFFFFFFFLL;
  }
  double v9 = *((double *)a2 + 16);
  BOOL v10 = v9 < 0.0 || (*((void *)a2 + 16) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000;
  if (v10 || v9 > 1.0) {
    return 0xFFFFFFFFLL;
  }
  double v12 = *((double *)a2 + 17);
  uint64_t result = 0xFFFFFFFFLL;
  if (v12 >= 0.0
    && (*((void *)a2 + 17) & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
    && v12 <= 1.0
    && fabs(v9 + v3 + v6 + v12 + -1.0) < 2.22044605e-16)
  {
    uint64_t result = 0;
    *(_OWORD *)((char *)a3 + 8) = *(_OWORD *)((char *)a2 + 8);
    long long v14 = *(_OWORD *)((char *)a2 + 24);
    long long v15 = *(_OWORD *)((char *)a2 + 40);
    long long v16 = *(_OWORD *)((char *)a2 + 56);
    *(_OWORD *)((char *)a3 + 72) = *(_OWORD *)((char *)a2 + 72);
    *(_OWORD *)((char *)a3 + 56) = v16;
    *(_OWORD *)((char *)a3 + 40) = v15;
    *(_OWORD *)((char *)a3 + 24) = v14;
    long long v17 = *(_OWORD *)((char *)a2 + 88);
    long long v18 = *(_OWORD *)((char *)a2 + 104);
    long long v19 = *(_OWORD *)((char *)a2 + 120);
    *((void *)a3 + 17) = *((void *)a2 + 17);
    *(_OWORD *)((char *)a3 + 120) = v19;
    *(_OWORD *)((char *)a3 + 104) = v18;
    *(_OWORD *)((char *)a3 + 88) = v17;
  }
  return result;
}

void sub_18E190804()
{
}

uint64_t raven::GNSSUncertaintyScaling::Fire7orNewerPhoneGNSSUncertaintyWrapper::Instance(raven::GNSSUncertaintyScaling::Fire7orNewerPhoneGNSSUncertaintyWrapper *this)
{
  uint64_t result = qword_1E91CA040;
  if (!qword_1E91CA040) {
    operator new();
  }
  return result;
}

uint64_t raven::GNSSUncertaintyScaling::Fire7orNewerPhoneGNSSUncertaintyWrapper::GetUncertaintyScaleFactorCore(uint64_t a1, _DWORD *a2, unsigned char *a3, unsigned __int8 *a4, char *a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  if (!a8)
  {
    uint64_t v43 = v8;
    uint64_t v44 = v9;
    unsigned int v16 = *a4;
    if (v16 > 6)
    {
      uint64_t v25 = 0;
      uint64_t v22 = 0;
      uint64_t v21 = 0;
      uint64_t v20 = 0;
      goto LABEL_26;
    }
    int v17 = 1 << v16;
    if ((v17 & 0x27) != 0)
    {
      unsigned int v18 = *a5;
      if (v18 <= 6 && ((1 << v18) & 0x4C) != 0)
      {
LABEL_9:
        uint64_t v20 = sub_18E191368();
        uint64_t v21 = sub_18E191468();
        uint64_t v22 = sub_18E191568();
        uint64_t v23 = sub_18E191668();
LABEL_25:
        uint64_t v25 = v23;
LABEL_26:
        unsigned int v27 = 0;
        switch(*a3)
        {
          case 0:
          case 4:
          case 9:
            __int16 v42 = 12;
            unsigned __int8 v41 = 4;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v42, &v41, "Invalid GNSS Band type: GNSS uncertainty parameters not found for obs_type,%d,band,%d,se,%d,activity,%d", (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *a2);
LABEL_62:
            float v11 = 1.0;
LABEL_69:
            uint64_t v10 = 0x100000000;
            return v10 | LODWORD(v11);
          case 1:
          case 0xA:
            unsigned int v27 = 5;
            break;
          case 2:
            unsigned int v27 = 6;
            break;
          case 3:
            unsigned int v27 = 4;
            break;
          case 6:
            unsigned int v27 = 1;
            break;
          case 7:
            unsigned int v27 = 2;
            break;
          case 8:
            unsigned int v27 = 3;
            break;
          default:
            break;
        }
        unsigned int v28 = v27;
        switch(*a2)
        {
          case 1:
            if (!v20)
            {
              __int16 v42 = 12;
              unsigned __int8 v41 = 5;
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v42, &v41, "Invalid range unc scale pointer - activity_state = %d, signal_environment = %hu, band_as_int = %d", (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *a5);
              goto LABEL_62;
            }
            uint64_t v29 = a6[1];
            if (!*(_WORD *)(v20 + 356 * v27 + 32 * *a6 + 2 * v29)) {
              goto LABEL_62;
            }
            float v30 = *(float *)(v20 + 356 * v27 + 352);
            float v31 = (float)*(unsigned __int16 *)(v20 + 356 * v27 + 32 * *a6 + 2 * v29);
            goto LABEL_68;
          case 2:
            if (v21)
            {
              uint64_t v32 = v21 + 356 * v27;
              float v30 = *(float *)(v32 + 352);
              uint64_t v33 = *a6;
              uint64_t v34 = a6[1];
              goto LABEL_66;
            }
            __int16 v42 = 12;
            unsigned __int8 v41 = 5;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v42, &v41, "Invalid doppler unc scale pointer - activity_state = %d, signal_environment = %hu, band_as_int = %d", (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *a5);
            float v11 = 4.0;
            goto LABEL_69;
          case 3:
            if (!v22) {
              goto LABEL_52;
            }
            uint64_t v35 = v22 + 356 * v27;
            float v30 = *(float *)(v35 + 352);
            uint64_t v33 = *a6;
            uint64_t v34 = a6[1];
            unsigned int v36 = *(unsigned __int16 *)(v35 + 32 * *a6 + 2 * v34);
            if (!v36) {
              goto LABEL_64;
            }
            goto LABEL_51;
          case 4:
            if (!v25)
            {
LABEL_52:
              __int16 v42 = 12;
              unsigned __int8 v41 = 5;
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v42, &v41, "Invalid doppler unc scale pointer - activity_state = %d, signal_environment = %hu, band_as_int = %d", (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *a5);
              float v11 = 2.0;
              goto LABEL_69;
            }
            uint64_t v37 = v25 + 356 * v27;
            float v30 = *(float *)(v37 + 352);
            uint64_t v33 = *a6;
            uint64_t v34 = a6[1];
            unsigned int v36 = *(unsigned __int16 *)(v37 + 32 * *a6 + 2 * v34);
            if (v36) {
              BOOL v38 = 1;
            }
            else {
              BOOL v38 = v22 == 0;
            }
            if (v38) {
              goto LABEL_51;
            }
            unsigned int v36 = *(unsigned __int16 *)(v22 + 356 * v28 + 32 * v33 + 2 * v34);
            if (*(_WORD *)(v22 + 356 * v28 + 32 * v33 + 2 * v34))
            {
              float v30 = *(float *)(v22 + 356 * v28 + 352);
LABEL_51:
              float v31 = (float)v36;
            }
            else
            {
LABEL_64:
              if (!v21) {
                goto LABEL_71;
              }
              uint64_t v32 = v21 + 356 * v28;
LABEL_66:
              unsigned int v39 = *(unsigned __int16 *)(v32 + 32 * v33 + 2 * v34);
              if (!v39)
              {
LABEL_71:
                uint64_t v10 = 0x100000000;
                float v11 = v30 / 0.01;
                return v10 | LODWORD(v11);
              }
              float v31 = (float)v39;
            }
LABEL_68:
            float v11 = v30 * v31;
            goto LABEL_69;
          default:
            __int16 v42 = 12;
            unsigned __int8 v41 = 5;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v42, &v41, "Invalid obs type - activity_state = %d, signal_environment = %hu, band_as_int = %d", (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *a5);
            goto LABEL_62;
        }
      }
    }
    else
    {
      if ((v17 & 0x18) != 0)
      {
        unsigned int v24 = *a5;
        if (v24 <= 6 && ((1 << v24) & 0x4C) != 0)
        {
          uint64_t v20 = qword_1EB404E90;
          if (!qword_1EB404E90) {
            operator new();
          }
          uint64_t v21 = qword_1EB404E98;
          if (!qword_1EB404E98) {
            operator new();
          }
          uint64_t v22 = qword_1EB404EA0;
          if (!qword_1EB404EA0) {
            operator new();
          }
          uint64_t v25 = qword_1EB404EA8;
          if (!qword_1EB404EA8) {
            operator new();
          }
        }
        else
        {
          uint64_t v20 = qword_1EB404EB0;
          if (!qword_1EB404EB0) {
            operator new();
          }
          uint64_t v21 = qword_1EB404EB8;
          if (!qword_1EB404EB8) {
            operator new();
          }
          uint64_t v22 = qword_1EB404EC0;
          if (!qword_1EB404EC0) {
            operator new();
          }
          uint64_t v25 = qword_1EB404EC8;
          if (!qword_1EB404EC8) {
            operator new();
          }
        }
        goto LABEL_26;
      }
      unsigned int v26 = *a5;
      if (v26 <= 6 && ((1 << v26) & 0x4C) != 0) {
        goto LABEL_9;
      }
    }
    uint64_t v20 = sub_18E191768();
    uint64_t v21 = sub_18E191868();
    uint64_t v22 = sub_18E191968();
    uint64_t v23 = sub_18E191A68();
    goto LABEL_25;
  }
  uint64_t v10 = 0;
  float v11 = 0.0;
  return v10 | LODWORD(v11);
}

uint64_t sub_18E191368()
{
  if (!qword_1E91C9B58) {
    operator new();
  }
  return qword_1E91C9B58;
}

uint64_t sub_18E191468()
{
  if (!qword_1E91C9B60) {
    operator new();
  }
  return qword_1E91C9B60;
}

uint64_t sub_18E191568()
{
  if (!qword_1E91C9B68) {
    operator new();
  }
  return qword_1E91C9B68;
}

uint64_t sub_18E191668()
{
  if (!qword_1E91C9B70) {
    operator new();
  }
  return qword_1E91C9B70;
}

uint64_t sub_18E191768()
{
  if (!qword_1E91C9720) {
    operator new();
  }
  return qword_1E91C9720;
}

uint64_t sub_18E191868()
{
  if (!qword_1E91C9730) {
    operator new();
  }
  return qword_1E91C9730;
}

uint64_t sub_18E191968()
{
  if (!qword_1E91C9728) {
    operator new();
  }
  return qword_1E91C9728;
}

uint64_t sub_18E191A68()
{
  if (!qword_1E91C9738) {
    operator new();
  }
  return qword_1E91C9738;
}

uint64_t raven::GNSSUncertaintyScaling::Fire7orNewerPhoneGNSSUncertaintyWrapper::GetScaleFactorTableIndices(float a1, double a2, uint64_t a3, unint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  for (unint64_t i = 0; i != 10; ++i)
  {
    if (flt_18E21E098[i] >= a1) {
      break;
    }
  }
  for (unint64_t j = 0; j != 15; ++j)
  {
    if (dbl_18E21E0D8[j] >= a2) {
      break;
    }
  }
  BOOL v12 = i >= 0xB || j >= 0x10;
  uint64_t v13 = !v12;
  if (v12)
  {
    __int16 v17 = 12;
    unsigned __int8 v16 = 5;
    double v14 = a1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v17, &v16, "invalid index found,cn0,%.3f,cn0_bin,%zu,elev,%.3lf,elev_bin,%zu,", a6, a7, a8, a9, a10, SLOBYTE(v14));
  }
  else
  {
    *a4 = i;
    a4[1] = j;
  }
  return v13;
}

uint64_t raven::GNSSUncertaintyScaling::Fire7orNewerWatchGNSSUncertaintyWrapper::Instance(raven::GNSSUncertaintyScaling::Fire7orNewerWatchGNSSUncertaintyWrapper *this)
{
  uint64_t result = qword_1E91CA078;
  if (!qword_1E91CA078) {
    operator new();
  }
  return result;
}

uint64_t raven::GNSSUncertaintyScaling::Fire7orNewerWatchGNSSUncertaintyWrapper::GetUncertaintyScaleFactorCore(uint64_t a1, _DWORD *a2, unsigned char *a3, unsigned __int8 *a4, char *a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  if (!a8)
  {
    uint64_t v38 = v8;
    uint64_t v39 = v9;
    unsigned int v16 = *a4;
    if (v16 > 6)
    {
      uint64_t v21 = 0;
      uint64_t v20 = 0;
      uint64_t v19 = 0;
      uint64_t v18 = 0;
    }
    else
    {
      int v17 = 1 << v16;
      if ((v17 & 0x27) != 0 || (v17 & 0x18) == 0)
      {
        uint64_t v18 = sub_18E192094();
        uint64_t v19 = sub_18E1922E0();
        uint64_t v20 = sub_18E19252C();
        uint64_t v21 = sub_18E192778();
      }
      else
      {
        uint64_t v18 = sub_18E1929C4();
        uint64_t v19 = sub_18E192C10();
        uint64_t v20 = sub_18E192E5C();
        uint64_t v21 = sub_18E1930A8();
      }
    }
    unsigned int v22 = 0;
    switch(*a3)
    {
      case 0:
      case 4:
      case 9:
        __int16 v37 = 12;
        unsigned __int8 v36 = 4;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v37, &v36, "Invalid GNSS Band type: GNSS uncertainty parameters not found for obs_type,%d,band,%d,se,%d,activity,%d", (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *a2);
LABEL_38:
        float v11 = 1.0;
LABEL_45:
        uint64_t v10 = 0x100000000;
        return v10 | LODWORD(v11);
      case 1:
      case 0xA:
        unsigned int v22 = 5;
        break;
      case 2:
        unsigned int v22 = 6;
        break;
      case 3:
        unsigned int v22 = 4;
        break;
      case 6:
        unsigned int v22 = 1;
        break;
      case 7:
        unsigned int v22 = 2;
        break;
      case 8:
        unsigned int v22 = 3;
        break;
      default:
        break;
    }
    unsigned int v23 = v22;
    switch(*a2)
    {
      case 1:
        if (!v18)
        {
          __int16 v37 = 12;
          unsigned __int8 v36 = 5;
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v37, &v36, "Invalid range unc scale pointer - activity_state = %d, signal_environment = %hu, band_as_int = %d", (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *a5);
          goto LABEL_38;
        }
        uint64_t v24 = a6[1];
        if (!*(_WORD *)(v18 + 228 * v22 + 32 * *a6 + 2 * v24)) {
          goto LABEL_38;
        }
        float v25 = *(float *)(v18 + 228 * v22 + 224);
        float v26 = (float)*(unsigned __int16 *)(v18 + 228 * v22 + 32 * *a6 + 2 * v24);
        goto LABEL_44;
      case 2:
        if (v19)
        {
          uint64_t v27 = v19 + 228 * v22;
          float v25 = *(float *)(v27 + 224);
          uint64_t v28 = *a6;
          uint64_t v29 = a6[1];
          goto LABEL_42;
        }
        __int16 v37 = 12;
        unsigned __int8 v36 = 5;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v37, &v36, "Invalid doppler unc scale pointer - activity_state = %d, signal_environment = %hu, band_as_int = %d", (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *a5);
        float v11 = 4.0;
        goto LABEL_45;
      case 3:
        if (!v20) {
          goto LABEL_36;
        }
        uint64_t v30 = v20 + 228 * v22;
        float v25 = *(float *)(v30 + 224);
        uint64_t v28 = *a6;
        uint64_t v29 = a6[1];
        unsigned int v31 = *(unsigned __int16 *)(v30 + 32 * *a6 + 2 * v29);
        if (!v31) {
          goto LABEL_40;
        }
        goto LABEL_35;
      case 4:
        if (!v21)
        {
LABEL_36:
          __int16 v37 = 12;
          unsigned __int8 v36 = 5;
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v37, &v36, "Invalid doppler unc scale pointer - activity_state = %d, signal_environment = %hu, band_as_int = %d", (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *a5);
          float v11 = 2.0;
          goto LABEL_45;
        }
        uint64_t v32 = v21 + 228 * v22;
        float v25 = *(float *)(v32 + 224);
        uint64_t v28 = *a6;
        uint64_t v29 = a6[1];
        unsigned int v31 = *(unsigned __int16 *)(v32 + 32 * *a6 + 2 * v29);
        if (v31) {
          BOOL v33 = 1;
        }
        else {
          BOOL v33 = v20 == 0;
        }
        if (v33) {
          goto LABEL_35;
        }
        unsigned int v31 = *(unsigned __int16 *)(v20 + 228 * v23 + 32 * v28 + 2 * v29);
        if (*(_WORD *)(v20 + 228 * v23 + 32 * v28 + 2 * v29))
        {
          float v25 = *(float *)(v20 + 228 * v23 + 224);
LABEL_35:
          float v26 = (float)v31;
        }
        else
        {
LABEL_40:
          if (!v19) {
            goto LABEL_47;
          }
          uint64_t v27 = v19 + 228 * v23;
LABEL_42:
          unsigned int v34 = *(unsigned __int16 *)(v27 + 32 * v28 + 2 * v29);
          if (!v34)
          {
LABEL_47:
            uint64_t v10 = 0x100000000;
            float v11 = v25 / 0.01;
            return v10 | LODWORD(v11);
          }
          float v26 = (float)v34;
        }
LABEL_44:
        float v11 = v25 * v26;
        goto LABEL_45;
      default:
        __int16 v37 = 12;
        unsigned __int8 v36 = 5;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v37, &v36, "Invalid obs type - activity_state = %d, signal_environment = %hu, band_as_int = %d", (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *a5);
        goto LABEL_38;
    }
  }
  uint64_t v10 = 0;
  float v11 = 0.0;
  return v10 | LODWORD(v11);
}

uint64_t sub_18E192094()
{
  uint64_t result = qword_1E91C9B78;
  if (!qword_1E91C9B78) {
    operator new();
  }
  return result;
}

uint64_t sub_18E1922E0()
{
  uint64_t result = qword_1E91C9B80;
  if (!qword_1E91C9B80) {
    operator new();
  }
  return result;
}

uint64_t sub_18E19252C()
{
  uint64_t result = qword_1E91C9B88;
  if (!qword_1E91C9B88) {
    operator new();
  }
  return result;
}

uint64_t sub_18E192778()
{
  uint64_t result = qword_1E91C9B90;
  if (!qword_1E91C9B90) {
    operator new();
  }
  return result;
}

uint64_t sub_18E1929C4()
{
  uint64_t result = qword_1E91C9B98;
  if (!qword_1E91C9B98) {
    operator new();
  }
  return result;
}

uint64_t sub_18E192C10()
{
  uint64_t result = qword_1E91C9BA0;
  if (!qword_1E91C9BA0) {
    operator new();
  }
  return result;
}

uint64_t sub_18E192E5C()
{
  uint64_t result = qword_1E91C9BA8;
  if (!qword_1E91C9BA8) {
    operator new();
  }
  return result;
}

uint64_t sub_18E1930A8()
{
  uint64_t result = qword_1E91C9BB0;
  if (!qword_1E91C9BB0) {
    operator new();
  }
  return result;
}

uint64_t raven::GNSSUncertaintyScaling::Fire7orNewerWatchGNSSUncertaintyWrapper::GetScaleFactorTableIndices(float a1, double a2, uint64_t a3, unint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  for (unint64_t i = 0; i != 6; ++i)
  {
    if (flt_18E21E0C0[i] >= a1) {
      break;
    }
  }
  for (unint64_t j = 0; j != 15; ++j)
  {
    if (dbl_18E21E0D8[j] >= a2) {
      break;
    }
  }
  BOOL v12 = i >= 7 || j >= 0x10;
  uint64_t v13 = !v12;
  if (v12)
  {
    __int16 v17 = 12;
    unsigned __int8 v16 = 5;
    double v14 = a1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v17, &v16, "invalid index found,cn0,%.3f,cn0_bin,%zu,elev,%.3lf,elev_bin,%zu,", a6, a7, a8, a9, a10, SLOBYTE(v14));
  }
  else
  {
    *a4 = i;
    a4[1] = j;
  }
  return v13;
}

void sub_18E1933B8()
{
}

void sub_18E1933D0()
{
}

uint64_t raven::RavenPositionContextEstimatorActiveObject::RavenPositionContextEstimatorActiveObject(uint64_t a1, unsigned char *a2)
{
  cnframework::ActiveObjectBase::ActiveObjectBase(a1, a2);
  *(void *)uint64_t v3 = &unk_1EDD15E90;
  *(unsigned char *)(v3 + 480) = 0;
  *(void *)(v3 + 488) = 0;
  *(void *)(v3 + 496) = 0;
  *(void *)(v3 + 504) = 1;
  *(void *)(v3 + 584) = 0;
  *(_OWORD *)(v3 + 512) = 0u;
  *(_OWORD *)(v3 + 528) = 0u;
  *(_OWORD *)(v3 + 544) = 0u;
  *(_OWORD *)(v3 + 560) = 0u;
  *(_WORD *)(v3 + 576) = 0;
  *(void *)(v3 + 592) = &unk_1EDD0A498;
  *(void *)(v3 + 624) = 0x100000002;
  *(void *)(v3 + 600) = &unk_1EDD18B28;
  *(void *)(v3 + 632) = v3 + 640;
  *(void *)(v3 + 680) = 0x100000002;
  *(void *)(v3 + 656) = &unk_1EDD18B28;
  *(void *)(v3 + 688) = v3 + 696;
  *(void *)(v3 + 720) = 0x3DDB7CDFD9D7BDBBLL;
  *(void *)(v3 + 616) = 0;
  *(void *)(v3 + 608) = 0;
  *(void *)(v3 + 664) = 0;
  *(void *)(v3 + 672) = 0;
  *(_DWORD *)(v3 + 712) = 1;
  *(void *)(v3 + 728) = 0;
  *(_OWORD *)(v3 + 736) = xmmword_18E1FD1C0;
  *(unsigned char *)(v3 + 752) = 0;
  *(void *)(v3 + 760) = &unk_1EDD145D0;
  *(void *)(v3 + 768) = 0;
  *(void *)(v3 + 776) = 0;
  *(unsigned char *)(v3 + 784) = 0;
  *(void *)(v3 + 792) = 0;
  *(void *)(v3 + 800) = 0;
  *(unsigned char *)(v3 + 808) = 0;
  *(void *)(v3 + 816) = 0;
  *(void *)(v3 + 824) = 0;
  *(unsigned char *)(v3 + 832) = 0;
  *(void *)(v3 + 848) = 0;
  *(void *)(v3 + 840) = 0;
  *(void *)(v3 + 856) = 0x7FF8000000000000;
  *(unsigned char *)(v3 + 864) = 0;
  *(void *)(v3 + 872) = &unk_1EDD14738;
  *(unsigned char *)(v3 + 896) = 0;
  *(void *)(v3 + 880) = 0;
  *(void *)(v3 + 888) = 0;
  *(unsigned char *)(v3 + 920) = 0;
  *(void *)(v3 + 912) = 0;
  *(void *)(v3 + 904) = 0;
  *(unsigned char *)(v3 + 944) = 0;
  *(void *)(v3 + 936) = 0;
  *(void *)(v3 + 928) = 0;
  *(void *)(v3 + 960) = 0;
  *(void *)(v3 + 952) = 0;
  *(void *)(v3 + 968) = 0x7FF8000000000000;
  *(unsigned char *)(v3 + 976) = 0;
  *(void *)(v3 + 984) = 0x3FE0000000000000;
  *(void *)(v3 + 992) = 0x3FE0000000000000;
  *(_OWORD *)(v3 + 1016) = 0u;
  *(_OWORD *)(v3 + 1032) = 0u;
  *(_OWORD *)(v3 + 1000) = 0u;
  sub_18DEDE7B0(&__str, "<PositionContext> ");
  std::string::operator=((std::string *)(a1 + 544), &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  sub_18DEDE7B0(&__str, "<PositionContext> ");
  std::string::operator=((std::string *)(a1 + 1024), &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  return a1;
}

void sub_18E193634(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_18E19367C((uint64_t)v15 + 576);
  sub_18E00CA08((uint64_t)v15 + 520);
  cnframework::ActiveObjectBase::~ActiveObjectBase(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_18E19367C(uint64_t a1)
{
  if (*(char *)(a1 + 471) < 0) {
    operator delete(*(void **)(a1 + 448));
  }
  if (*(char *)(a1 + 447) < 0) {
    operator delete(*(void **)(a1 + 424));
  }
  *(void *)(a1 + 16) = &unk_1EDD0A498;
  *(void *)(a1 + 80) = &unk_1EDD17478;
  *(void *)(a1 + 24) = &unk_1EDD17478;
  return a1;
}

void raven::RavenPositionContextEstimatorActiveObject::~RavenPositionContextEstimatorActiveObject(void **this)
{
  *this = &unk_1EDD15E90;
  if (*((char *)this + 1047) < 0) {
    operator delete(this[128]);
  }
  if (*((char *)this + 1023) < 0) {
    operator delete(this[125]);
  }
  this[74] = &unk_1EDD0A498;
  this[82] = &unk_1EDD17478;
  this[75] = &unk_1EDD17478;
  if (*((char *)this + 567) < 0) {
    operator delete(this[68]);
  }
  if (*((char *)this + 543) < 0) {
    operator delete(this[65]);
  }

  cnframework::ActiveObjectBase::~ActiveObjectBase((cnframework::ActiveObjectBase *)this);
}

{
  uint64_t vars8;

  raven::RavenPositionContextEstimatorActiveObject::~RavenPositionContextEstimatorActiveObject(this);

  JUMPOUT(0x192FA6240);
}

uint64_t raven::RavenPositionContextEstimatorActiveObject::Configure(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned char *)(a1 + 480) && cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1) <= 1)
  {
    LOWORD(v37) = 12;
    LOBYTE(v36) = 1;
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 16))(__p, a1);
    int v4 = v39 >= 0 ? (const char *)__p : (const char *)__p[0];
    cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 520), "Warning: %s configured more than once.", v4);
    if (*(char *)(a1 + 543) >= 0) {
      LOBYTE(v10) = a1 + 8;
    }
    else {
      uint64_t v10 = *(void *)(a1 + 520);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v37, (unsigned __int8 *)&v36, "%s", v5, v6, v7, v8, v9, v10);
    if (v39 < 0) {
      operator delete(__p[0]);
    }
  }
  *(unsigned char *)(a1 + 480) = 0;
  uint64_t v11 = *a2;
  if (!*a2 || !*(unsigned char *)(v11 + 33))
  {
    LOWORD(v37) = 12;
    LOBYTE(v36) = 4;
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 16))(__p, a1);
    if (v39 >= 0) {
      uint64_t v19 = __p;
    }
    else {
      uint64_t v19 = (void **)__p[0];
    }
    cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 520), "Error: %s could not be configured. p_raven_parameters is not initialized.", (const char *)v19);
    if (*(char *)(a1 + 543) >= 0) {
      LOBYTE(v25) = a1 + 8;
    }
    else {
      uint64_t v25 = *(void *)(a1 + 520);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v37, (unsigned __int8 *)&v36, "%s", v20, v21, v22, v23, v24, v25);
    goto LABEL_28;
  }
  *(void *)(a1 + 568) = v11;
  uint64_t v37 = v11;
  if (raven::RavenPositionContextEstimator::Configure(a1 + 576, &v37))
  {
    __int16 v36 = 12;
    unsigned __int8 v35 = 4;
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 16))(__p, a1);
    if (v39 >= 0) {
      BOOL v12 = __p;
    }
    else {
      BOOL v12 = (void **)__p[0];
    }
    cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 520), "Error: %s could not be configured. Configuration of position context estimator failed.", (const char *)v12);
    if (*(char *)(a1 + 543) >= 0) {
      LOBYTE(v18) = a1 + 8;
    }
    else {
      uint64_t v18 = *(void *)(a1 + 520);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v36, &v35, "%s", v13, v14, v15, v16, v17, v18);
LABEL_28:
    if (v39 < 0) {
      operator delete(__p[0]);
    }
    return 0xFFFFFFFFLL;
  }
  cnframework::ActiveObjectBase::SetEventQueueDelay((cnframework::ActiveObjectBase *)a1, 0.0);
  *(unsigned char *)(a1 + 480) = 1;
  uint64_t v27 = (cnprint::CNPrinter *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
  if (cnprint::CNPrinter::GetLogLevel(v27) <= 1)
  {
    __int16 v36 = 12;
    unsigned __int8 v35 = 1;
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 16))(__p, a1);
    uint64_t v28 = v39 >= 0 ? (const char *)__p : (const char *)__p[0];
    cnprint::CNLogFormatter::FormatGeneral((const void **)(a1 + 520), "%s configured successfully.", v28);
    if (*(char *)(a1 + 543) >= 0) {
      LOBYTE(v34) = a1 + 8;
    }
    else {
      uint64_t v34 = *(void *)(a1 + 520);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v36, &v35, "%s", v29, v30, v31, v32, v33, v34);
    if (v39 < 0) {
      operator delete(__p[0]);
    }
  }
  return 0;
}

void sub_18E193B88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void raven::RavenPositionContextEstimatorActiveObject::HandleEvent(raven::RavenPositionContextEstimatorActiveObject *this, const raven::ActivityStateEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    uint64_t v3 = (raven::RavenPositionContextEstimatorActiveObject *)((char *)this + 576);
    raven::RavenPositionContextEstimator::HandleEvent(v3, a2);
  }
  else
  {
    __int16 v13 = 12;
    unsigned __int8 v12 = 2;
    v11[0] = (*(uint64_t (**)(const raven::ActivityStateEvent *))(*(void *)a2 + 16))(a2);
    v11[1] = v4;
    cnprint::CNLogFormatter::FormatGeneral((uint64_t)this + 520, (uint64_t)v11, "RavenPositionContextEstimatorActiveObject is not configured.");
    if (*((char *)this + 543) >= 0) {
      LOBYTE(v10) = (_BYTE)this + 8;
    }
    else {
      uint64_t v10 = *((void *)this + 65);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v13, &v12, "%s", v5, v6, v7, v8, v9, v10);
  }
}

void raven::RavenPositionContextEstimatorActiveObject::HandleEvent(raven::RavenPositionContextEstimatorActiveObject *this, const raven::GnssAvailabilityEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    uint64_t v3 = (raven::RavenPositionContextEstimatorActiveObject *)((char *)this + 576);
    raven::RavenPositionContextEstimator::HandleEvent(v3, a2);
  }
  else
  {
    __int16 v13 = 12;
    unsigned __int8 v12 = 2;
    v11[0] = (*(uint64_t (**)(const raven::GnssAvailabilityEvent *))(*(void *)a2 + 16))(a2);
    v11[1] = v4;
    cnprint::CNLogFormatter::FormatGeneral((uint64_t)this + 520, (uint64_t)v11, "RavenPositionContextEstimatorActiveObject is not configured.");
    if (*((char *)this + 543) >= 0) {
      LOBYTE(v10) = (_BYTE)this + 8;
    }
    else {
      uint64_t v10 = *((void *)this + 65);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v13, &v12, "%s", v5, v6, v7, v8, v9, v10);
  }
}

void raven::RavenPositionContextEstimatorActiveObject::HandleEvent(raven::RavenPositionContextEstimatorActiveObject *this, const raven::GnssPreprocessedMeasurementsEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    uint64_t v3 = (raven::RavenPositionContextEstimatorActiveObject *)((char *)this + 576);
    raven::RavenPositionContextEstimator::HandleEvent(v3, a2);
  }
  else
  {
    __int16 v13 = 12;
    unsigned __int8 v12 = 2;
    v11[0] = (*(uint64_t (**)(const raven::GnssPreprocessedMeasurementsEvent *))(*(void *)a2 + 16))(a2);
    v11[1] = v4;
    cnprint::CNLogFormatter::FormatGeneral((uint64_t)this + 520, (uint64_t)v11, "RavenPositionContextEstimatorActiveObject is not configured.");
    if (*((char *)this + 543) >= 0) {
      LOBYTE(v10) = (_BYTE)this + 8;
    }
    else {
      uint64_t v10 = *((void *)this + 65);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v13, &v12, "%s", v5, v6, v7, v8, v9, v10);
  }
}

void raven::RavenPositionContextEstimatorActiveObject::HandleEvent(raven::RavenPositionContextEstimatorActiveObject *this, const raven::RavenSolutionEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    *((void *)this + 93) = *((void *)a2 + 169);
    *((unsigned char *)this + 752) = *((unsigned char *)a2 + 1344);
  }
  else
  {
    __int16 v12 = 12;
    unsigned __int8 v11 = 2;
    v10[0] = (*(uint64_t (**)(const raven::RavenSolutionEvent *))(*(void *)a2 + 16))(a2);
    v10[1] = v3;
    cnprint::CNLogFormatter::FormatGeneral((uint64_t)this + 520, (uint64_t)v10, "RavenPositionContextEstimatorActiveObject is not configured.");
    if (*((char *)this + 543) >= 0) {
      LOBYTE(v9) = (_BYTE)this + 8;
    }
    else {
      uint64_t v9 = *((void *)this + 65);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v12, &v11, "%s", v4, v5, v6, v7, v8, v9);
  }
}

void raven::RavenPositionContextEstimatorActiveObject::HandleEvent(raven::RavenPositionContextEstimatorActiveObject *this, const raven::SignalEnvironmentEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    long long v3 = *(_OWORD *)((char *)a2 + 8);
    long long v4 = *(_OWORD *)((char *)a2 + 40);
    *((_OWORD *)this + 49) = *(_OWORD *)((char *)a2 + 24);
    *((_OWORD *)this + 50) = v4;
    *((_OWORD *)this + 48) = v3;
    long long v5 = *(_OWORD *)((char *)a2 + 56);
    long long v6 = *(_OWORD *)((char *)a2 + 72);
    long long v7 = *(_OWORD *)((char *)a2 + 88);
    *((unsigned char *)this + 864) = *((unsigned char *)a2 + 104);
    *((_OWORD *)this + 52) = v6;
    *((_OWORD *)this + 53) = v7;
    *((_OWORD *)this + 51) = v5;
  }
  else
  {
    __int16 v17 = 12;
    unsigned __int8 v16 = 2;
    v15[0] = (*(uint64_t (**)(const raven::SignalEnvironmentEvent *))(*(void *)a2 + 16))(a2);
    v15[1] = v8;
    cnprint::CNLogFormatter::FormatGeneral((uint64_t)this + 520, (uint64_t)v15, "RavenPositionContextEstimatorActiveObject is not configured.");
    if (*((char *)this + 543) >= 0) {
      LOBYTE(v14) = (_BYTE)this + 8;
    }
    else {
      uint64_t v14 = *((void *)this + 65);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v17, &v16, "%s", v9, v10, v11, v12, v13, v14);
  }
}

void raven::RavenPositionContextEstimatorActiveObject::HandleEvent(raven::RavenPositionContextEstimatorActiveObject *this, const raven::TimeMarkEvent *a2)
{
  if (*((unsigned char *)this + 480))
  {
    raven::RavenPositionContextEstimator::HandleEvent((raven::RavenPositionContextEstimatorActiveObject *)((char *)this + 576), a2);
    long long v4 = (long long *)((char *)a2 + 8);
    uint64_t v7 = CNTimeSpan::operator-((uint64_t)v4, (void *)this + 61, v5, v6);
    *(void *)&v37[0] = v7;
    v37[1] = v8;
    if (v7 < 0 || (*(double *)v9.i64 = v8, v8 < 0.0)) {
      uint64_t v7 = CNTimeSpan::operator-(v37, v9, v10);
    }
    uint64_t v28 = (void *)v7;
    *(double *)&long long v29 = v8;
    if (sub_18DEE4D28((double *)&v28, (double *)this + 63))
    {
      __asm { FMOV            V0.2D, #0.5 }
      long long v36 = _Q0;
      long long v16 = v4[3];
      long long v31 = v4[2];
      long long v32 = v16;
      long long v17 = v4[5];
      long long v33 = v4[4];
      long long v34 = v17;
      long long v18 = v4[1];
      long long v29 = *v4;
      long long v30 = v18;
      uint64_t v28 = &unk_1EDD14738;
      char v35 = 0;
      if (!raven::RavenPositionContextEstimator::PopulateEvent((raven::RavenPositionContextEstimatorActiveObject *)((char *)this + 576), (raven::PositionContextStateEvent *)&v28))
      {
        uint64_t v19 = operator new(0x60uLL);
        v19[1] = 0;
        void v19[2] = 0;
        void *v19 = &unk_1EDD1E458;
        void v19[3] = &unk_1EDD0A260;
        uint64_t v20 = MEMORY[0x1E4FBA3D8];
        *((unsigned char *)v19 + 32) = 0;
        v19[5] = 0;
        v19[6] = v20;
        v19[7] = 0;
        v19[8] = 0;
        sub_18DEDE7B0(v19 + 9, "");
        *((unsigned char *)v19 + 32) = 1;
        operator new();
      }
      *(_OWORD *)((char *)this + 488) = *v4;
    }
  }
  else
  {
    LOWORD(v38) = 12;
    LOBYTE(v37[0]) = 2;
    uint64_t v28 = (void *)(*(uint64_t (**)(const raven::TimeMarkEvent *))(*(void *)a2 + 16))(a2);
    *(void *)&long long v29 = v21;
    cnprint::CNLogFormatter::FormatGeneral((uint64_t)this + 520, (uint64_t)&v28, "RavenPositionContextEstimatorActiveObject is not configured.");
    if (*((char *)this + 543) >= 0) {
      LOBYTE(v27) = (_BYTE)this + 8;
    }
    else {
      uint64_t v27 = *((void *)this + 65);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v38, (unsigned __int8 *)v37, "%s", v22, v23, v24, v25, v26, v27);
  }
}

void sub_18E19436C(_Unwind_Exception *a1)
{
  long long v4 = *(std::__shared_weak_count **)(v2 - 80);
  if (v4) {
    sub_18DEE4E18(v4);
  }
  sub_18DEE4E18(v1);
  _Unwind_Resume(a1);
}

std::string *raven::RavenPositionContextEstimatorActiveObject::SetLogPrefix(uint64_t a1, const std::string *a2)
{
  std::string::operator=((std::string *)(a1 + 544), a2);

  return std::string::operator=((std::string *)(a1 + 1024), a2);
}

void *sub_18E194430@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenPositionContextEstimatorActiveObject");
}

double sub_18E194440(uint64_t a1)
{
  *(unsigned char *)(a1 + 576) = 0;
  *(void *)(a1 + 728) = 0;
  *(unsigned char *)(a1 + 864) = 0;
  double result = NAN;
  *(_OWORD *)(a1 + 736) = xmmword_18E1FD1C0;
  *(unsigned char *)(a1 + 752) = 0;
  *(unsigned char *)(a1 + 976) = 0;
  *(void *)(a1 + 984) = 0x3FE0000000000000;
  *(void *)(a1 + 992) = 0x3FE0000000000000;
  return result;
}

void *sub_18E194470(void *result)
{
  *double result = &unk_1EDD0A498;
  result[8] = &unk_1EDD17478;
  result[1] = &unk_1EDD17478;
  return result;
}

void sub_18E1944D0(void *a1)
{
  *a1 = &unk_1EDD0A498;
  a1[8] = &unk_1EDD17478;
  a1[1] = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

void sub_18E194544()
{
}

void *sub_18E194558()
{
}

void sub_18E194564()
{
}

uint64_t raven::PositionChecker::Configure(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  *(void *)(a1 + 16) = a3;
  uint64_t v4 = *a2;
  *(void *)(a1 + 40) = *(void *)(*a2 + 920);
  *(void *)(a1 + 32) = *(void *)(v4 + 2512);
  *(unsigned char *)(a1 + 48) = raven::GNSSMeasurementSelectionParameters::AllMeasurementsExcluded((raven::GNSSMeasurementSelectionParameters *)(v4 + 592)) ^ 1;
  double v10 = *(double *)(v4 + 2136);
  if ((*(uint64_t *)&v10 <= -1 || ((*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 >= 0x3FF)
    && (unint64_t)(*(void *)&v10 - 1) >= 0xFFFFFFFFFFFFFLL)
  {
    __int16 v29 = 12;
    unsigned __int8 v28 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v29, &v28, "PositionChecker: Invalid innovation reweighting threshold %.1lg", v5, v6, v7, v8, v9, SLOBYTE(v10));
  }
  else
  {
    double v13 = *(double *)(v4 + 2144);
    if ((*(uint64_t *)&v13 <= -1 || ((*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 >= 0x3FF)
      && (unint64_t)(*(void *)&v13 - 1) >= 0xFFFFFFFFFFFFFLL)
    {
      __int16 v29 = 12;
      unsigned __int8 v28 = 4;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v29, &v28, "PositionChecker:Invalid innovation rejection threshold %.1lg", v5, v6, v7, v8, v9, SLOBYTE(v13));
    }
    else
    {
      double v16 = *(double *)(v4 + 2160);
      if ((*(uint64_t *)&v16 <= -1 || ((*(void *)&v16 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 >= 0x3FF)
        && (unint64_t)(*(void *)&v16 - 1) >= 0xFFFFFFFFFFFFFLL)
      {
        __int16 v29 = 12;
        unsigned __int8 v28 = 4;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v29, &v28, "PositionChecker: Invalid target horizontal sigma value %.1lg", v5, v6, v7, v8, v9, SLOBYTE(v16));
      }
      else
      {
        double v19 = *(double *)(v4 + 2168);
        if ((*(uint64_t *)&v19 <= -1 || ((*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 >= 0x3FF)
          && (unint64_t)(*(void *)&v19 - 1) >= 0xFFFFFFFFFFFFFLL)
        {
          __int16 v29 = 12;
          unsigned __int8 v28 = 4;
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v29, &v28, "PositionChecker: Invalid vertical target sigma value %.1lg", v5, v6, v7, v8, v9, SLOBYTE(v19));
        }
        else
        {
          uint64_t v22 = *(void *)(v4 + 3200);
          if ((v22 <= -1 || ((v22 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 >= 0x3FF)
            && (unint64_t)(v22 - 1) >= 0xFFFFFFFFFFFFFLL)
          {
            __int16 v29 = 12;
            unsigned __int8 v28 = 4;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v29, &v28, "PositionChecker: Invalid VL position uncertainty default scale factor %.1lg", v5, v6, v7, v8, v9, v22);
          }
          else if (v16 <= v10)
          {
            if (v19 <= v10)
            {
              double v25 = *(double *)(v4 + 3480);
              double v26 = *(double *)(v4 + 3488);
              if (v25 > 0.0 && v26 >= 0.0)
              {
                uint64_t result = 0;
                *(double *)(a1 + 56) = v10 * v10;
                *(double *)(a1 + 64) = v13 * v13;
                *(void *)(a1 + 72) = *(void *)(v4 + 2152);
                *(double *)(a1 + 80) = v16 * v16;
                *(double *)(a1 + 88) = v19 * v19;
                *(void *)(a1 + 96) = v22;
                *(double *)(a1 + 104) = v25;
                *(double *)(a1 + 112) = v26;
                *(unsigned char *)(a1 + 24) = *(unsigned char *)(v4 + 3813);
                *(unsigned char *)(a1 + 25) = *(unsigned char *)(v4 + 3815);
                *(unsigned char *)(a1 + 26) = *(unsigned char *)(v4 + 3814);
                *(unsigned char *)(a1 + 8) = 1;
                return result;
              }
              __int16 v29 = 12;
              unsigned __int8 v28 = 4;
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v29, &v28, "PositionChecker: Invalid hybrid 2D WiFi + DEM altitude threshold values, unc %.1lg age %.1lg", v5, v6, v7, v8, v9, SLOBYTE(v25));
            }
            else
            {
              __int16 v29 = 12;
              unsigned __int8 v28 = 4;
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v29, &v28, "PositionChecker: Invalid vertical target sigma count: value of %.1lg is greater than reweight-sigma threshold %.1lg", v5, v6, v7, v8, v9, SLOBYTE(v19));
            }
          }
          else
          {
            __int16 v29 = 12;
            unsigned __int8 v28 = 4;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v29, &v28, "PositionChecker: Invalid horizontal target sigma count: value of %.1lg is greater than reweight-sigma threshold %.1lg", v5, v6, v7, v8, v9, SLOBYTE(v16));
          }
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t raven::PositionChecker::TestInnovationAndReweight(raven::PositionChecker *this, raven::PositionEvent *a2)
{
  if (!sub_18DFF465C((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0))
  {
    if (cnprint::CNPrinter::GetLogLevel(0) <= 1)
    {
      LOWORD(v143) = 12;
      LOBYTE(v115) = 1;
      uint64_t v40 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
      double v83 = v41 + (double)v40;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v143, (unsigned __int8 *)&v115, "t,%.3lf skipped position measurement innovation test: invalid raven solution", v42, v43, v44, v45, v46, SLOBYTE(v83));
    }
    return 5;
  }
  uint64_t v4 = sub_18DFF465C((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0);
  if (!v4) {
    sub_18DEDE720("unordered_map::at: key not found");
  }
  uint64_t v5 = v4;
  if (!*((unsigned char *)v4 + 1488))
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v4) <= 1)
    {
      LOWORD(v143) = 12;
      LOBYTE(v115) = 1;
      uint64_t v47 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
      double v84 = v48 + (double)v47;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v143, (unsigned __int8 *)&v115, "t,%.3lf skipped position measurement innovation test: invalid device position", v49, v50, v51, v52, v53, SLOBYTE(v84));
    }
    return 5;
  }
  if (!*((unsigned char *)v4 + 1568))
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v4) <= 1)
    {
      LOWORD(v143) = 12;
      LOBYTE(v115) = 1;
      uint64_t v54 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
      double v85 = v55 + (double)v54;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v143, (unsigned __int8 *)&v115, "t,%.3lf skipped position measurement innovation test: invalid device velocity", v56, v57, v58, v59, v60, SLOBYTE(v85));
    }
    return 5;
  }
  uint64_t v168 = 0x100000003;
  double v166 = &unk_1EDD18D98;
  long long v167 = xmmword_18E1F6F60;
  uint64_t v169 = &v170;
  long long v170 = *((_OWORD *)a2 + 18);
  uint64_t v171 = *((void *)a2 + 38);
  uint64_t v160 = 0x100000006;
  uint64_t v158 = &unk_1EDD19728;
  long long v159 = xmmword_18E1FD770;
  uint64_t v161 = &v162;
  long long v162 = *(_OWORD *)(v4 + 187);
  double v163 = v4[189];
  long long v164 = *(_OWORD *)(v4 + 197);
  uint64_t v165 = v4[199];
  uint64_t v155 = 0x300000003;
  uint64_t v153 = &unk_1EDD18EE8;
  long long v154 = xmmword_18E1F0010;
  uint64_t v156 = &v157;
  uint64_t v150 = 0x300000003;
  double v148 = &unk_1EDD18EE8;
  long long v149 = xmmword_18E1F0010;
  double v151 = &v152;
  BOOL v6 = sub_18E10D288((uint64_t)(v4 + 149), (uint64_t)&v153);
  if (!v6)
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v6) <= 1)
    {
      LOWORD(v143) = 12;
      LOBYTE(v115) = 1;
      uint64_t v61 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
      double v86 = v62 + (double)v61;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v143, (unsigned __int8 *)&v115, "t,%.3lf skipped position measurement innovation test: failed to get raven position solution covariance", v63, v64, v65, v66, v67, SLOBYTE(v86));
    }
    return 5;
  }
  BOOL v7 = sub_18DFF61B0((uint64_t)(v5 + 149), (uint64_t)&v148);
  if (!v7)
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v7) <= 1)
    {
      LOWORD(v143) = 12;
      LOBYTE(v115) = 1;
      uint64_t v68 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
      double v87 = v69 + (double)v68;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v143, (unsigned __int8 *)&v115, "t,%.3lf skipped position measurement innovation test: failed to get raven velocity solution covariance", v70, v71, v72, v73, v74, SLOBYTE(v87));
    }
    return 5;
  }
  uint64_t v145 = 0x600000006;
  uint64_t v143 = &unk_1EDD197B8;
  uint64_t v146 = &v147;
  long long v144 = xmmword_18E1F8570;
  sub_18DFE2CC8((uint64_t)&v143, 0.0);
  uint64_t v139 = 0x100000003;
  double v137 = &unk_1EDD18DC8;
  long long v138 = xmmword_18E1F6F60;
  int v142 = 2;
  uint64_t v140 = &v141;
  uint64_t v141 = 0x100000000;
  uint64_t v119 = 0x400000003;
  uint64_t v133 = 0x100000003;
  uint64_t v131 = &unk_1EDD18DC8;
  long long v132 = xmmword_18E1F6F60;
  int v136 = 5;
  uint64_t v134 = &v135;
  uint64_t v135 = 0x400000003;
  sub_18DFEE864((uint64_t)&v115, (uint64_t)&v143, (uint64_t)&v137, (uint64_t)&v137);
  sub_18DFEC6E4((uint64_t)&v115, (uint64_t)&v153);
  sub_18DFEE864((uint64_t)&v115, (uint64_t)&v143, (uint64_t)&v131, (uint64_t)&v131);
  sub_18DFEC6E4((uint64_t)&v115, (uint64_t)&v148);
  uint64_t v128 = 0x100000006;
  long long v126 = &unk_1EDD19728;
  double v129 = &v130;
  long long v127 = xmmword_18E1FD770;
  sub_18DFE2CC8((uint64_t)&v126, 0.0);
  uint64_t v123 = 0x100000006;
  double v121 = &unk_1EDD19728;
  long long v124 = &v125;
  long long v122 = xmmword_18E1FD770;
  sub_18DFE2CC8((uint64_t)&v121, 0.0);
  double v115 = (void *)(*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
  *(void *)&long long v116 = v8;
  long long v110 = (void *)((uint64_t (*)(uint64_t **))v5[3][2])(v5 + 3);
  *(void *)&long long v111 = v9;
  uint64_t v12 = CNTimeSpan::operator-((uint64_t)&v115, &v110, v10, v11);
  double v120 = v13 + (double)v12;
  uint64_t v117 = 0x600000006;
  double v115 = &unk_1EDD197B8;
  long long v116 = xmmword_18E1F8570;
  double v118 = &v119;
  uint64_t v112 = 0x600000006;
  long long v110 = &unk_1EDD197B8;
  long long v111 = xmmword_18E1F8570;
  long long v113 = &v114;
  sub_18E06C950((uint64_t)&v158, (uint64_t)&v121, (uint64_t *)&v120, (uint64_t)&v126, (uint64_t)&v115, (uint64_t)&v110, v14, v15);
  uint64_t v102 = 0x600000006;
  double v100 = &unk_1EDD197B8;
  long long v101 = xmmword_18E1F8570;
  double v103 = v104;
  sub_18DFE2B44((uint64_t)&v115, (uint64_t)&v143, (uint64_t)&v100);
  int v17 = v116;
  int v16 = DWORD1(v116);
  uint64_t v97 = 0x600000006;
  double v92 = &unk_1EDD197B8;
  uint64_t v98 = v99;
  int v93 = DWORD1(v116);
  int v94 = v116;
  int v95 = v116 * DWORD1(v116);
  int v96 = DWORD1(v116);
  if (DWORD1(v116))
  {
    int v18 = 0;
    int v19 = 0;
    int v20 = HIDWORD(v116);
    uint64_t v21 = v118;
    do
    {
      int v22 = v18;
      int v23 = v19;
      for (int i = v17; i; --i)
      {
        v99[v23] = v21[v22];
        v23 += v16;
        ++v22;
      }
      ++v19;
      v18 += v20;
    }
    while (v19 != v16);
  }
  uint64_t v107 = 0x600000006;
  uint64_t v105 = &unk_1EDD197B8;
  long long v106 = xmmword_18E1F8570;
  uint64_t v108 = &v109;
  sub_18DFE2B44((uint64_t)&v100, (uint64_t)&v92, (uint64_t)&v105);
  sub_18DFECE30((uint64_t)&v105, (uint64_t)&v137, (uint64_t)&v137, (uint64_t)&v92);
  sub_18E06DD64((uint64_t)&v100, (uint64_t)&v126, (uint64_t)&v137);
  sub_18DFF2980((uint64_t)v91, (uint64_t)&v100);
  uint64_t v102 = 0x300000003;
  double v100 = &unk_1EDD18EE8;
  long long v101 = xmmword_18E1F0010;
  double v103 = v104;
  if ((sub_18E10C944((uint64_t)a2, (uint64_t)&v100) & 1) == 0)
  {
    __int16 v90 = 12;
    unsigned __int8 v89 = 4;
    uint64_t v75 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
    double v88 = v76 + (double)v75;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v90, &v89, "t,%.3lf positionevent failure: unable to obtain measurement variance", v77, v78, v79, v80, v81, SLOBYTE(v88));
    return 1;
  }
  uint64_t result = raven::PositionChecker::InnovationTestingAndReweighting((double *)this, (uint64_t)&v166, (uint64_t)&v100, (uint64_t)v91, (uint64_t)&v92);
  if (result == 4)
  {
    char v32 = sub_18E195984(a2, (uint64_t)&v100, v26, v27, v28, v29, v30, v31);
    uint64_t result = 4;
    if ((v32 & 1) == 0)
    {
      __int16 v90 = 12;
      unsigned __int8 v89 = 4;
      uint64_t v33 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
      double v82 = v34 + (double)v33;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v90, &v89, "t,%.3lf positionevent failure: unable to set reweighted measurement variance", v35, v36, v37, v38, v39, SLOBYTE(v82));
      return 1;
    }
  }
  return result;
}

uint64_t raven::PositionChecker::InnovationTestingAndReweighting(double *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v5.i64[0] = *(void *)(a2 + 8);
  v6.i64[0] = *(void *)(a3 + 8);
  v5.i64[1] = *(void *)(a4 + 8);
  v6.i64[1] = *(void *)(a5 + 8);
  v7.i64[0] = 0x300000003;
  v7.i64[1] = 0x300000003;
  if (vmaxv_u8((uint8x8_t)vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqq_s32(v5, (int32x4_t)xmmword_18E22ADE0), (int16x8_t)vceqq_s32(v6, v7))))))return 1; {
  uint64_t v131 = 0x100000003;
  }
  long long v130 = xmmword_18E1F6F60;
  double v129 = &unk_1EDD18D98;
  long long v132 = &v133;
  sub_18DFE2AA8(a2, a4, (uint64_t)&v129);
  sub_18DFFDA0C((uint64_t)v128, **(float64_t **)(a4 + 32), *(float64_t *)(*(void *)(a4 + 32) + 8), *(double *)(*(void *)(a4 + 32) + 16));
  uint64_t v125 = 0x100000003;
  long long v124 = xmmword_18E1F6F60;
  uint64_t v123 = &unk_1EDD18D98;
  long long v126 = (double *)&v127;
  uint64_t v120 = 0x300000003;
  long long v119 = xmmword_18E1F0010;
  double v118 = &unk_1EDD18EE8;
  double v121 = &v122;
  uint64_t v115 = 0x300000003;
  long long v114 = xmmword_18E1F0010;
  long long v113 = &unk_1EDD18EE8;
  long long v116 = &v117;
  sub_18E168AB8((uint64_t)v128, (uint64_t)&v129, (uint64_t)&v123);
  if (!v17 || !sub_18DFFBB34((uint64_t)v128, a3, (uint64_t)&v118) || !sub_18DFFBB34((uint64_t)v128, a5, (uint64_t)&v113))
  {
    __int16 v68 = 12;
    LOBYTE(v108) = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v68, (unsigned __int8 *)&v108, "Failed to transform information from ECEF to ENU", v12, v13, v14, v15, v16, v67);
    return 1;
  }
  uint64_t v110 = 0x300000003;
  long long v109 = xmmword_18E1F0010;
  uint64_t v108 = &unk_1EDD18EE8;
  long long v111 = &v112;
  sub_18DFEF1F4((uint64_t)&v113, (uint64_t)&v118, (uint64_t)&v108);
  uint64_t v73 = 0x100000000;
  uint64_t v105 = 0x100000002;
  double v103 = &unk_1EDD18B58;
  long long v106 = &v107;
  long long v104 = xmmword_18E1FD1A0;
  uint64_t v107 = 0x100000000;
  sub_18E070534((uint64_t)&v68, (uint64_t)&v123, (uint64_t)&v103);
  int v19 = v69;
  int v18 = v70;
  uint64_t v90 = 0x200000001;
  double v85 = &unk_1EDD181C8;
  double v91 = v92;
  int v86 = v70;
  int v87 = v69;
  int v88 = v69 * v70;
  int v89 = v70;
  if (v70)
  {
    int v20 = 0;
    int v21 = 0;
    int v22 = v71;
    uint64_t v23 = v72;
    do
    {
      int v24 = v20;
      int v25 = v21;
      for (int i = v19; i; --i)
      {
        v92[v25] = *(void *)(v23 + 8 * v24);
        v25 += v18;
        ++v24;
      }
      ++v21;
      v20 += v22;
    }
    while (v21 != v18);
  }
  sub_18E195A4C((uint64_t)&v108, (uint64_t)&v103, (uint64_t)&v103, (uint64_t)v79);
  uint64_t v82 = 0x200000002;
  long long v81 = xmmword_18E1FD1B0;
  uint64_t v80 = &unk_1EDD18BB8;
  double v83 = &v84;
  uint64_t v136 = 0x100000002;
  long long v135 = xmmword_18E1FD1A0;
  uint64_t v134 = &unk_1EDD18B58;
  double v137 = &v138;
  uint64_t v76 = 0x100000008;
  long long v75 = xmmword_18E1FD760;
  uint64_t v74 = &unk_1EDD19CC8;
  uint64_t v77 = &v78;
  sub_18E01BFEC((uint64_t)v79, (uint64_t)&v134, (uint64_t)&v74, (uint64_t)&v80);
  uint64_t v95 = 0x200000001;
  long long v94 = xmmword_18E1FD740;
  int v93 = &unk_1EDD181C8;
  int v96 = &v97;
  sub_18DFE2B44((uint64_t)&v85, (uint64_t)&v80, (uint64_t)&v93);
  sub_18E070534((uint64_t)&v74, (uint64_t)&v123, (uint64_t)&v103);
  uint64_t v100 = 0x100000001;
  *(void *)&long long v27 = 0x100000001;
  *((void *)&v27 + 1) = 0x100000001;
  long long v99 = v27;
  uint64_t v98 = &unk_1EDD18048;
  long long v101 = (double *)&v102;
  sub_18DFE2B44((uint64_t)&v93, (uint64_t)&v74, (uint64_t)&v98);
  double v28 = *v101;
  cnstatistics::InverseChi2(v29, a1[9], 2.0);
  if (v28 <= v31)
  {
    int v45 = 0;
LABEL_23:
    double v47 = v126[2] * v126[2];
    double v48 = v47 / *(double *)&v111[2 * SHIDWORD(v109) + 2];
    if (v48 <= a1[7]
      || (double v49 = v47 / a1[11] - *(double *)&v116[2 * SHIDWORD(v114) + 2],
          (*(void *)&v49 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      || (uint64_t v50 = 2 * SHIDWORD(v119) + 2, v49 <= *(double *)&v121[v50]))
    {
      if (!v45) {
        return 5;
      }
    }
    else
    {
      *(double *)&v121[v50] = v49;
      if (cnprint::CNPrinter::GetLogLevel(LogLevel) <= 1)
      {
        __int16 v68 = 12;
        LOBYTE(v74) = 1;
        double v56 = sqrt(v48);
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v68, (unsigned __int8 *)&v74, "PositionChecker: measurement reweighted for axis# 2 normalized innovatiouint64_t n = %.1lg", v51, v52, v53, v54, v55, SLOBYTE(v56));
      }
    }
    sub_18E074368((uint64_t)&v68, **(float64_t **)(a4 + 32), *(float64_t *)(*(void *)(a4 + 32) + 8), *(double *)(*(void *)(a4 + 32) + 16));
    if (sub_18DFFBB34((uint64_t)&v68, (uint64_t)&v118, a3)) {
      return 4;
    }
    LOWORD(v74) = 12;
    LOBYTE(v80) = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v74, (unsigned __int8 *)&v80, "PositionChecker: Failed to transform information from ENU to ECEF frame", v57, v58, v59, v60, v61, v67);
    return 1;
  }
  uint64_t v32 = 0;
  char v33 = 0;
  char v34 = 1;
  while (1)
  {
    char v35 = v34;
    double v36 = v126[v32] * v126[v32];
    double v37 = v36 / *(double *)&v111[(int)v32 + (int)v32 * HIDWORD(v109)];
    if (v37 > a1[8]) {
      break;
    }
    if (v37 > a1[7])
    {
      double v38 = v36 / a1[10] - *(double *)&v116[(int)v32 + (int)v32 * HIDWORD(v114)];
      if ((*(void *)&v38 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        int v39 = v32 + v32 * HIDWORD(v119);
        if (v38 > *(double *)&v121[v39])
        {
          *(double *)&v121[v39] = v38;
          unsigned int LogLevel = (cnprint::CNPrinter *)cnprint::CNPrinter::GetLogLevel(LogLevel);
          char v33 = 1;
          if (LogLevel <= 1)
          {
            __int16 v68 = 12;
            LOBYTE(v74) = 1;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v68, (unsigned __int8 *)&v74, "PositionChecker: measurement reweighted for axis# %d normalized innovatiouint64_t n = %.1lg", v40, v41, v42, v43, v44, v32);
          }
        }
      }
    }
    char v34 = 0;
    uint64_t v32 = 1;
    if ((v35 & 1) == 0)
    {
      int v45 = v33 & 1;
      goto LABEL_23;
    }
  }
  if (cnprint::CNPrinter::GetLogLevel(LogLevel) <= 1)
  {
    __int16 v68 = 12;
    LOBYTE(v74) = 1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v68, (unsigned __int8 *)&v74, "PositionChecker: measurement rejected, normalized innovation for axis# %d = %.1lg", v62, v63, v64, v65, v66, v32);
  }
  return 3;
}

uint64_t sub_18E195984(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8 = *(_DWORD *)(a2 + 8) == 3 && *(_DWORD *)(a2 + 12) == 3;
  uint64_t v9 = v8;
  if (v8)
  {
    int8x16_t v10 = *(void **)(a2 + 32);
    a1[39] = *v10;
    uint64_t v11 = *(int *)(a2 + 20);
    a1[40] = v10[v11];
    a1[41] = v10[2 * v11];
    a1[40] = v10[1];
    a1[42] = v10[(int)v11 + 1];
    uint64_t v12 = &v10[2 * (int)v11];
    a1[43] = v12[1];
    a1[41] = v10[2];
    a1[43] = v10[(int)v11 + 2];
    a1[44] = v12[2];
  }
  else
  {
    __int16 v16 = 12;
    unsigned __int8 v15 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v16, &v15, "Failed to set ECEF covariance matrix: Invalid input matrix size", a4, a5, a6, a7, a8, v14);
  }
  return v9;
}

uint64_t sub_18E195A4C@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  int v4 = *(_DWORD *)(a2 + 16);
  int v5 = *(_DWORD *)(a3 + 16);
  *(void *)(a4 + 24) = 0x200000002;
  *(void *)a4 = &unk_1EDD18BB8;
  *(_DWORD *)(a4 + 8) = v4;
  *(_DWORD *)(a4 + 12) = v5;
  *(_DWORD *)(a4 + 16) = v5 * v4;
  *(_DWORD *)(a4 + 20) = v4;
  uint64_t v6 = a4 + 40;
  *(void *)(a4 + 32) = a4 + 40;
  if (v5)
  {
    int v7 = 0;
    int v8 = 0;
    uint64_t v9 = *(void *)(a2 + 32);
    uint64_t v10 = *(void *)(a3 + 32);
    do
    {
      if (v4)
      {
        int v11 = 0;
        int v12 = *(_DWORD *)(result + 20) * *(_DWORD *)(v10 + 4 * v8);
        uint64_t v13 = *(void *)(result + 32);
        do
        {
          *(void *)(v6 + 8 * (v7 + v11)) = *(void *)(v13
                                                                       + 8
                                                                       * (*(_DWORD *)(v9 + 4 * v11) + v12));
          ++v11;
        }
        while (v4 != v11);
      }
      ++v8;
      v7 += v4;
    }
    while (v8 != v5);
  }
  return result;
}

uint64_t raven::PositionChecker::HandleEvent(raven::PositionChecker *this, const raven::PositionEvent *a2, raven::PositionEvent *a3)
{
  if (!*((unsigned char *)this + 8))
  {
    LOWORD(v134) = 12;
    LOBYTE(v126) = 4;
    uint64_t v33 = (*(uint64_t (**)(const raven::PositionEvent *, const raven::PositionEvent *, raven::PositionEvent *))(*(void *)a2 + 16))(a2, a2, a3);
    double v119 = v39 + (double)v33;
    uint64_t v40 = "t,%.3lf,PositionChecker, not configured";
    uint64_t v41 = (cnprint::CNPrinter *)&v134;
    uint64_t v42 = (unsigned __int8 *)&v126;
LABEL_41:
    cnprint::CNPrinter::Print(v41, v42, v40, v34, v35, v36, v37, v38, SLOBYTE(v119));
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = (char *)a3 + 8;
  memcpy((char *)a3 + 8, (char *)a2 + 8, 0x160uLL);
  BOOL v8 = *((unsigned char *)a3 + 200) == 4 && *((unsigned char *)a3 + 201) != 0 && *((unsigned char *)a3 + 202) == 0;
  if (v8
    && *((unsigned char *)this + 26)
    && raven::PositionChecker::Supplement2DWiFiWithAltitudeAssistance(this, a3))
  {
    return 0xFFFFFFFFLL;
  }
  if (sub_18E0B99D0((uint64_t)a3)) {
    sub_18E0B9CE0((uint64_t)a3);
  }
  if (!*((unsigned char *)a3 + 280)) {
    return 0xFFFFFFFFLL;
  }
  double v9 = *((double *)a3 + 36);
  if ((*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return 0xFFFFFFFFLL;
  }
  double v10 = *((double *)a3 + 37);
  if ((*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return 0xFFFFFFFFLL;
  }
  double v11 = *((double *)a3 + 38);
  if ((*(void *)&v11 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || sqrt(v10 * v10 + v9 * v9 + v11 * v11) <= 3185504.5)
  {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if ((*((void *)a3 + 39) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || *((double *)a3 + 39) <= 0.0
    || (*((void *)a3 + 42) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || *((double *)a3 + 42) <= 0.0
    || (*((void *)a3 + 44) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || *((double *)a3 + 44) <= 0.0
    || (*((void *)a3 + 40) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (*((void *)a3 + 41) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (*((void *)a3 + 43) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    return result;
  }
  uint64_t v136 = 0x300000003;
  long long v135 = xmmword_18E1F0010;
  uint64_t v134 = &unk_1EDD18EE8;
  double v137 = (double *)&v138;
  if (!sub_18E10C944((uint64_t)a3, (uint64_t)&v134)
    || sub_18E01D104((uint64_t)&v134) > *((double *)this + 5))
  {
    return 0xFFFFFFFFLL;
  }
  uint64_t v14 = *((void *)this + 2);
  if (*(unsigned char *)(v14 + 656) || *(unsigned char *)(v14 + 658))
  {
    double v129 = (void *)(*(uint64_t (**)(const raven::PositionEvent *))(*(void *)a2 + 16))(a2);
    *(void *)&long long v130 = v15;
    v123[0] = (*(uint64_t (**)(uint64_t))(*(void *)(v14 + 432) + 16))(v14 + 432);
    v123[1] = v16;
    uint64_t LogLevel = CNTimeSpan::operator-((uint64_t)&v129, v123, v17, v18);
    uint64_t v126 = LogLevel;
    double v127 = v19;
    if (LogLevel < 0 || (*(double *)v20.i64 = v19, v19 < 0.0))
    {
      uint64_t LogLevel = CNTimeSpan::operator-((double *)&v126, v20, v21);
      v20.i64[0] = v22;
    }
    double v23 = *(double *)v20.i64 + (double)LogLevel;
    BOOL v24 = v23 < 30.0;
    if (v23 < 30.0)
    {
      int v25 = *((unsigned __int8 *)a3 + 200);
      if (v25 == 16 || v25 == 4)
      {
        uint64_t LogLevel = cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)LogLevel);
        if (LogLevel <= 1)
        {
          LOWORD(v129) = 12;
          LOBYTE(v123[0]) = 1;
          uint64_t v26 = (*(uint64_t (**)(const raven::PositionEvent *))(*(void *)a2 + 16))(a2);
          double v118 = v27 + (double)v26;
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v129, (unsigned __int8 *)v123, "t,%.3lf, CPI is rejected at tunnel,is_tunnel,%d,is_close_to_tunnel,%d", v28, v29, v30, v31, v32, SLOBYTE(v118));
        }
      }
    }
  }
  else
  {
    BOOL v24 = 0;
  }
  unsigned int v43 = *((unsigned __int8 *)a3 + 200);
  if (v43 > 8)
  {
    if (v43 != 9)
    {
      if (v43 != 16) {
        goto LABEL_55;
      }
      goto LABEL_51;
    }
  }
  else if (v43 != 1)
  {
    if (v43 != 4)
    {
LABEL_55:
      if ((v43 & 0xFE) != 0xE) {
        return 0xFFFFFFFFLL;
      }
      goto LABEL_56;
    }
LABEL_51:
    if (!v24) {
      goto LABEL_56;
    }
    goto LABEL_55;
  }
  if (*((unsigned char *)this + 48)) {
    return 0xFFFFFFFFLL;
  }
LABEL_56:
  if (!*((unsigned char *)this + 9)) {
    return 0;
  }
  if (v43 != 16)
  {
    if (v43 == 14)
    {
      uint64_t v55 = *((void *)this + 2);
      if (*(unsigned char *)(v55 + 272) && *(unsigned char *)(v55 + 384) != 2)
      {
        if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)LogLevel) > 1) {
          return 0xFFFFFFFFLL;
        }
        LOWORD(v126) = 12;
        LOBYTE(v129) = 1;
        uint64_t v104 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a3 + 16))(a3);
        double v119 = v105 + (double)v104;
        uint64_t v40 = "t,%.3lf,PositionChecker: ARSession is not in running state, VL localization position dropped";
        goto LABEL_98;
      }
      double v56 = (cnprint::CNPrinter *)raven::PositionChecker::VLPositionTestingAndReweighting(this, a3);
      if ((v56 & 1) == 0)
      {
        if (cnprint::CNPrinter::GetLogLevel(v56) > 1) {
          return 0xFFFFFFFFLL;
        }
        LOWORD(v126) = 12;
        LOBYTE(v129) = 1;
        uint64_t v57 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a3 + 16))(a3);
        double v119 = v58 + (double)v57;
        uint64_t v40 = "t,%.3lf,PositionChecker: VL localization position dropped, consistency check returned failure";
        goto LABEL_98;
      }
      goto LABEL_82;
    }
    if (v43 != 4) {
      goto LABEL_82;
    }
  }
  if (*((unsigned char *)this + 25))
  {
    uint64_t v44 = (cnprint::CNPrinter *)raven::PositionChecker::TestInnovationAndReweight(this, a3);
    switch(v44)
    {
      case 1:
        LOWORD(v126) = 12;
        LOBYTE(v129) = 4;
        uint64_t v100 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a3 + 16))(a3);
        double v119 = v101 + (double)v100;
        uint64_t v40 = "t,%.3lf error in position measurement innovation testing";
        goto LABEL_98;
      case 3:
        if (cnprint::CNPrinter::GetLogLevel(v44)) {
          return 0xFFFFFFFFLL;
        }
        LOWORD(v126) = 12;
        LOBYTE(v129) = 0;
        uint64_t v102 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a3 + 16))(a3);
        double v119 = v103 + (double)v102;
        uint64_t v40 = "t,%.3lf Innovation test failed: Position-Measurement rejected";
        goto LABEL_98;
      case 2:
        LOWORD(v126) = 12;
        LOBYTE(v129) = 4;
        uint64_t v45 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a3 + 16))(a3);
        double v119 = v46 + (double)v45;
        uint64_t v40 = "t,%.3lf unexpected innovation test result";
LABEL_98:
        uint64_t v41 = (cnprint::CNPrinter *)&v126;
        uint64_t v42 = (unsigned __int8 *)&v129;
        goto LABEL_41;
    }
  }
  if (*((unsigned char *)this + 120))
  {
    double v129 = (void *)(*(uint64_t (**)(raven::PositionEvent *))(*(void *)a3 + 16))(a3);
    *(void *)&long long v130 = v47;
    if (!*((unsigned char *)this + 120)) {
      __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
    }
    uint64_t v50 = CNTimeSpan::operator-((uint64_t)&v129, (void *)this + 17, v48, v49);
    uint64_t v126 = v50;
    double v127 = v51;
    if (v50 < 0 || (*(double *)v52.i64 = v51, v51 < 0.0))
    {
      uint64_t v50 = CNTimeSpan::operator-((double *)&v126, v52, v53);
      v52.i64[0] = v54;
    }
    if (*(double *)v52.i64 + (double)v50 < 30.0
      && fabs(sqrt((v10 - *((double *)this + 53)) * (v10 - *((double *)this + 53))+ (v9 - *((double *)this + 52)) * (v9 - *((double *)this + 52))+ (v11 - *((double *)this + 54)) * (v11 - *((double *)this + 54)))) <= 0.01)
    {
      if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v50) > 1) {
        return 0xFFFFFFFFLL;
      }
      LOWORD(v126) = 12;
      LOBYTE(v129) = 1;
      uint64_t v108 = (*(uint64_t (**)(const raven::PositionEvent *))(*(void *)a2 + 16))(a2);
      double v119 = v109 + (double)v108;
      uint64_t v40 = "t,%.3lf,PositionChecker: duplicate PositionEvent,returning check failed";
      goto LABEL_98;
    }
    memcpy((char *)this + 136, v6, 0x160uLL);
  }
  else
  {
    *((void *)this + 16) = &unk_1EDD137C0;
    memcpy((char *)this + 136, v6, 0x160uLL);
    *((unsigned char *)this + 120) = 1;
  }
  if (sub_18DFF465C((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0))
  {
    if (*((unsigned char *)sub_18DFF6184((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0) + 1344))
    {
      uint64_t v59 = (double *)sub_18DFF6184((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0);
      if (v59[169] > 13.4112)
      {
        if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v59) > 1) {
          return 0xFFFFFFFFLL;
        }
        LOWORD(v126) = 12;
        LOBYTE(v129) = 1;
        uint64_t v106 = (*(uint64_t (**)(const raven::PositionEvent *))(*(void *)a2 + 16))(a2);
        double v119 = v107 + (double)v106;
        uint64_t v40 = "t,%.3lf,PositionChecker: Speed too large,returning check failed,%.3lf";
        goto LABEL_98;
      }
    }
  }
LABEL_82:
  uint64_t result = (uint64_t)sub_18DFF465C((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0);
  if (result)
  {
    if (*((unsigned char *)sub_18DFF6184((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0) + 1464))
    {
      double v60 = *((double *)sub_18DFF6184((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0) + 184);
      double v61 = *((double *)sub_18DFF6184((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0) + 185);
      double v62 = *((double *)sub_18DFF6184((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0) + 186);
      if (!sub_18E10C944((uint64_t)a3, (uint64_t)&v134)) {
        return 0xFFFFFFFFLL;
      }
      double v63 = *v137;
      uint64_t v64 = sub_18DFF6184((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0);
      uint64_t v65 = v137;
      *double v137 = v63 + *((double *)v64 + 187);
      double v66 = v65[SHIDWORD(v135)];
      char v67 = sub_18DFF6184((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0);
      uint64_t v68 = SHIDWORD(v135);
      int v69 = v137;
      v137[SHIDWORD(v135)] = v66 + *((double *)v67 + 188);
      double v70 = v69[2 * v68];
      int v71 = sub_18DFF6184((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0);
      uint64_t v72 = v137;
      v137[2 * SHIDWORD(v135)] = v70 + *((double *)v71 + 189);
      double v73 = v72[1];
      uint64_t v74 = sub_18DFF6184((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0);
      long long v75 = v137;
      v137[1] = v73 + *((double *)v74 + 188);
      double v76 = v75[SHIDWORD(v135) + 1];
      uint64_t v77 = sub_18DFF6184((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0);
      int v78 = HIDWORD(v135);
      uint64_t v79 = v137;
      v137[HIDWORD(v135) + 1] = v76 + *((double *)v77 + 190);
      double v80 = v79[(2 * v78) | 1];
      long long v81 = sub_18DFF6184((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0);
      uint64_t v82 = v137;
      v137[2 * SHIDWORD(v135) + 1] = v80 + *((double *)v81 + 191);
      double v83 = v82[2];
      uint64_t v84 = sub_18DFF6184((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0);
      double v85 = v137;
      v137[2] = v83 + *((double *)v84 + 189);
      double v86 = v85[SHIDWORD(v135) + 2];
      int v87 = sub_18DFF6184((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0);
      int v88 = HIDWORD(v135);
      int v89 = v137;
      v137[HIDWORD(v135) + 2] = v86 + *((double *)v87 + 191);
      double v90 = v89[2 * v88 + 2];
      double v91 = sub_18DFF6184((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0);
      v137[2 * SHIDWORD(v135) + 2] = v90 + *((double *)v91 + 192);
      uint64_t v131 = 0x100000003;
      long long v130 = xmmword_18E1F6F60;
      long long v132 = v133;
      v133[0] = v9 - v60;
      v133[1] = v10 - v61;
      v133[2] = v11 - v62;
      double v128 = INFINITY;
      double v129 = &unk_1EDD18D98;
      sub_18E01D280((uint64_t)&v134, &v128, (uint64_t)&v126);
      if ((*(void *)&v128 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v128 > *((double *)this + 5))
      {
        if (cnprint::CNPrinter::GetLogLevel(v92) <= 1)
        {
          LOWORD(v123[0]) = 12;
          v122[0] = 1;
          uint64_t v93 = (*(uint64_t (**)(const raven::PositionEvent *))(*(void *)a2 + 16))(a2);
          double v120 = v94 + (double)v93;
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)v123, v122, "t,%.3lf,PositionChecker: Poorly conditioned joint covariance matrix,returning check failed", v95, v96, v97, v98, v99, SLOBYTE(v120));
        }
        return 0xFFFFFFFFLL;
      }
      sub_18E01D4D4((uint64_t)&v129, (uint64_t)v122);
      sub_18E01D450((uint64_t)v122, (uint64_t)&v126, (uint64_t)v123);
      sub_18E01D3D4((uint64_t)v123, (uint64_t)&v129, (uint64_t)v124);
      if (fabs(sqrt(*v125)) > *((double *)this + 4) || !*((unsigned char *)this + 8))
      {
        if (cnprint::CNPrinter::GetLogLevel(v110) <= 1)
        {
          LOWORD(v123[0]) = 12;
          v122[0] = 1;
          uint64_t v111 = (*(uint64_t (**)(const raven::PositionEvent *))(*(void *)a2 + 16))(a2);
          double v121 = v112 + (double)v111;
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)v123, v122, "t,%.3lf,PositionChecker: failed sigma sanity test, %.2lf > %.2lf, returning check failed, src,%d", v113, v114, v115, v116, v117, SLOBYTE(v121));
        }
        return 0xFFFFFFFFLL;
      }
    }
    return 0;
  }
  return result;
}

uint64_t raven::PositionChecker::Supplement2DWiFiWithAltitudeAssistance(raven::PositionChecker *this, raven::PositionEvent *a2)
{
  if (*((unsigned char *)a2 + 200) != 4 || *((unsigned char *)a2 + 201) == 0 || *((unsigned char *)a2 + 202) != 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = *((void *)this + 2);
  if (!*(unsigned char *)(v5 + 144)) {
    return 0xFFFFFFFFLL;
  }
  v52[0] = (*(uint64_t (**)(void))(*(void *)(v5 + 152) + 16))();
  v52[1] = v7;
  int8x16_t v51 = *(int8x16_t *)((char *)a2 + 104);
  uint64_t v9 = CNTimeSpan::operator-((uint64_t)&v51, v52, v51, v8);
  uint64_t v13 = v9;
  *(void *)&v50[0] = v9;
  v50[1] = v10;
  double v14 = v10;
  BOOL v16 = v10 < 0.0 || v9 < 0;
  double v17 = v10;
  uint64_t v18 = v9;
  if (v16)
  {
    uint64_t v18 = CNTimeSpan::operator-(v50, v11, v12);
    double v17 = v19;
  }
  v11.i64[0] = *((void *)this + 14);
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  int8x16_t v20 = (cnprint::CNPrinter *)CNTimeSpan::SetTimeSpan(&v48, 0, v11, v12);
  if (!v18 && (*(void *)&v17 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
LABEL_23:
    v21.i64[0] = v49;
    goto LABEL_24;
  }
  if (v48 || (v21.i64[0] = v49, (v49 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000))
  {
    if (v18 != v48)
    {
      if (v18 > v48)
      {
LABEL_25:
        if (!cnprint::CNPrinter::GetLogLevel(v20))
        {
          LOWORD(v48) = 12;
          unsigned __int8 v47 = 0;
          uint64_t v23 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
          double v45 = v24 + (double)v23;
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v48, &v47, "t,%.3lf PositionChecker: Altitude Event age outside the use threshold for hybrid 2D WiFi Position, time_diff,%.3lf", v25, v26, v27, v28, v29, SLOBYTE(v45));
        }
        return 0xFFFFFFFFLL;
      }
      goto LABEL_29;
    }
    goto LABEL_23;
  }
LABEL_24:
  if (*(double *)v21.i64 < v17) {
    goto LABEL_25;
  }
LABEL_29:
  if (v16)
  {
    int8x16_t v20 = (cnprint::CNPrinter *)CNTimeSpan::operator-(v50, v21, v22);
    uint64_t v13 = (uint64_t)v20;
    double v14 = v31;
  }
  uint64_t v32 = *((void *)this + 2);
  if (!*(unsigned char *)(v32 + 144)) {
    goto LABEL_45;
  }
  double v33 = fmax(v14 + (double)v13, 1.0) * 1.5 + *(double *)(v32 + 264);
  if (v33 <= *((double *)this + 13)) {
    double v33 = *((double *)this + 13);
  }
  double v34 = v33 * v33;
  double v35 = *((double *)a2 + 29);
  if (v35 <= *((double *)a2 + 32)) {
    double v35 = *((double *)a2 + 32);
  }
  if (v34 <= v35) {
    double v34 = v35;
  }
  double v36 = v34;
  if (cnprint::CNPrinter::GetLogLevel(v20) <= 1)
  {
    LOWORD(v48) = 12;
    unsigned __int8 v47 = 1;
    uint64_t v37 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
    if (!*(unsigned char *)(*((void *)this + 2) + 144)) {
      goto LABEL_45;
    }
    double v46 = v38 + (double)v37;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v48, &v47, "t,%.3lf PositionChecker: Altitude Event is added to the 2D WiFi Pos, age,%.3lf,alt,%.3lf,unc,%.3lf", v39, v40, v41, v42, v43, SLOBYTE(v46));
  }
  uint64_t v44 = *((void *)this + 2);
  if (!*(unsigned char *)(v44 + 144)) {
LABEL_45:
  }
    __assert_rtn("operator->", "optional.hpp", 1221, "this->is_initialized()");
  *((void *)a2 + 28) = *(void *)(v44 + 256);
  *((unsigned char *)a2 + 202) = 1;
  *((double *)a2 + 34) = v36;
  *((void *)a2 + 31) = 0;
  *((void *)a2 + 33) = 0;
  if (sub_18E0B99D0((uint64_t)a2)) {
    sub_18E0B9CE0((uint64_t)a2);
  }
  uint64_t result = 0;
  *((unsigned char *)a2 + 200) = 16;
  return result;
}

uint64_t raven::PositionChecker::VLPositionTestingAndReweighting(raven::PositionChecker *this, raven::PositionEvent *a2)
{
  uint64_t v145 = 0x300000003;
  long long v144 = xmmword_18E1F0010;
  uint64_t v143 = &unk_1EDD18EE8;
  uint64_t v146 = &v147;
  uint64_t v4 = sub_18E10C944((uint64_t)a2, (uint64_t)&v143);
  if ((v4 & 1) == 0)
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v4) <= 1)
    {
      *(_WORD *)long long v154 = 12;
      v126[0] = 1;
      uint64_t v10 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
      double v106 = v11 + (double)v10;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v154, v126, "t,%.3lf PositionChecker: VL localization crosscheck failure: unable to get position ECEF var-cov", v12, v13, v14, v15, v16, SLOBYTE(v106));
    }
    return 0;
  }
  double v6 = *((double *)this + 12) * *((double *)this + 12);
  uint64_t v7 = v144;
  if ((int)v144 < 1)
  {
    v5.n128_u64[0] = 0;
    long long v9 = xmmword_18E1F0010;
LABEL_10:
    uint64_t v155 = 0x300000003;
    *(_OWORD *)&v154[8] = v9;
    *(void *)long long v154 = &unk_1EDD18EE8;
    uint64_t v156 = &v157;
    v5.n128_f64[0] = 1.0 / v5.n128_f64[0];
    sub_18E06E238((uint64_t)&v143, (uint64_t)v154, (float64x2_t)v5);
    __n128 v5 = sub_18DFE2F24((uint64_t)&v143, (uint64_t)v154);
    long long v9 = xmmword_18E1F0010;
    goto LABEL_11;
  }
  int v8 = 0;
  v5.n128_u64[0] = 0;
  long long v9 = xmmword_18E1F0010;
  do
  {
    v5.n128_f64[0] = v5.n128_f64[0] + *(double *)&v146[v8];
    v8 += HIDWORD(v144) + 1;
    --v7;
  }
  while (v7);
  if (v5.n128_f64[0] < 1.0) {
    goto LABEL_10;
  }
LABEL_11:
  uint64_t v155 = 0x300000003;
  *(_OWORD *)&v154[8] = v9;
  *(void *)long long v154 = &unk_1EDD18EE8;
  uint64_t v156 = &v157;
  v5.n128_f64[0] = v6;
  sub_18E06E238((uint64_t)&v143, (uint64_t)v154, (float64x2_t)v5);
  sub_18DFE2F24((uint64_t)&v143, (uint64_t)v154);
  uint64_t v23 = sub_18E195984(a2, (uint64_t)&v143, v17, v18, v19, v20, v21, v22);
  if ((v23 & 1) == 0)
  {
LABEL_57:
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v23) <= 1)
    {
      *(_WORD *)long long v154 = 12;
      v126[0] = 1;
      uint64_t v82 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
      double v111 = v83 + (double)v82;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v154, v126, "t,%.3lf PositionChecker: VL localization crosscheck failure: unable to set reweighted position variance", v84, v85, v86, v87, v88, SLOBYTE(v111));
    }
    return 0;
  }
  if (!*((unsigned char *)this + 24)) {
    return 1;
  }
  if (*((unsigned char *)a2 + 280))
  {
    uint64_t v139 = 0x100000003;
    long long v138 = xmmword_18E1F6F60;
    double v137 = &unk_1EDD18D98;
    uint64_t v140 = &v141;
    long long v141 = *((_OWORD *)a2 + 18);
    uint64_t v142 = *((void *)a2 + 38);
    uint64_t v24 = *((void *)this + 2);
    if (!*(unsigned char *)(v24 + 784) || !*(unsigned char *)(v24 + 1072))
    {
LABEL_22:
      int v36 = 0;
      BOOL v37 = 0;
      goto LABEL_23;
    }
    *(_OWORD *)long long v154 = *(_OWORD *)((char *)a2 + 104);
    *(_OWORD *)uint64_t v126 = *(_OWORD *)(v24 + 896);
    uint64_t v25 = CNTimeSpan::operator-((uint64_t)v154, v126, *(int8x16_t *)v126, (int8x16_t)xmmword_18E1F6F60);
    uint64_t v27 = v25;
    double v28 = v26;
    if (v25 != 30)
    {
      if (v25)
      {
        if (v25 >= 31)
        {
LABEL_20:
          if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v25) <= 1)
          {
            *(_WORD *)long long v154 = 12;
            v126[0] = 1;
            uint64_t v29 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
            double v107 = v30 + (double)v29;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)v154, v126, "t,%.3lf,PositionChecker: VL localization cross-check, previous VL is too old: %.2lf > %.2lf", v31, v32, v33, v34, v35, SLOBYTE(v107));
          }
          goto LABEL_22;
        }
LABEL_61:
        uint64_t v133 = 0x100000003;
        long long v132 = xmmword_18E1F6F60;
        uint64_t v131 = &unk_1EDD18D98;
        uint64_t v134 = &v135;
        uint64_t v127 = 0x300000003;
        *(_OWORD *)&v126[8] = xmmword_18E1F0010;
        *(void *)uint64_t v126 = &unk_1EDD18EE8;
        double v128 = (double *)v129;
        long long v135 = *(_OWORD *)(v24 + 1080);
        uint64_t v136 = *(void *)(v24 + 1096);
        uint64_t v89 = *(void *)(v24 + 1112);
        uint64_t v90 = *(void *)(v24 + 1120);
        v129[0] = *(void *)(v24 + 1104);
        v129[1] = v89;
        uint64_t v91 = *(void *)(v24 + 1128);
        v129[2] = v90;
        v129[3] = v89;
        long long v92 = *(_OWORD *)(v24 + 1136);
        v129[4] = v91;
        v129[5] = v92;
        v129[6] = v90;
        long long v130 = v92;
        uint64_t v123 = 0x100000003;
        long long v122 = xmmword_18E1F6F60;
        double v121 = &unk_1EDD18D98;
        long long v124 = &v125;
        sub_18DFE2AA8((uint64_t)&v137, (uint64_t)&v131, (uint64_t)&v121);
        uint64_t v115 = 0x100000003;
        uint64_t v113 = &unk_1EDD18D98;
        long long v114 = xmmword_18E1F6F60;
        uint64_t v116 = v117;
        uint64_t v155 = 0x100000134;
        *(_OWORD *)&v154[8] = xmmword_18E1F6FB0;
        *(void *)long long v154 = &unk_1EDD18C48;
        uint64_t v156 = &v157;
        uint64_t v150 = 0x100000003;
        long long v149 = xmmword_18E1F6F60;
        double v148 = &unk_1EDD18D98;
        double v151 = &v152;
        sub_18DFE345C((uint64_t)&v121, (uint64_t)&v113, (uint64_t)v154, (uint64_t)&v148, "2");
        if (v93 <= 1.0)
        {
          BOOL v37 = 1;
        }
        else
        {
          double v94 = (v28 + (double)v27) * 2.5 * ((v28 + (double)v27) * 2.5);
          uint64_t v95 = v128;
          *double v128 = v94 + *v128;
          int v96 = *(_DWORD *)&v126[20];
          v95[*(_DWORD *)&v126[20] + 1] = v94 + v95[*(_DWORD *)&v126[20] + 1];
          v95[2 * v96 + 2] = v94 + v95[2 * v96 + 2];
          sub_18E01E39C((uint64_t)v126, (uint64_t)&v143, (uint64_t)v154);
          sub_18E01D4D4((uint64_t)&v121, (uint64_t)v118);
          sub_18E01E3DC((uint64_t)v154, (uint64_t)&v113);
          sub_18E01D450((uint64_t)v118, (uint64_t)&v113, (uint64_t)&v148);
          sub_18E01D3D4((uint64_t)&v148, (uint64_t)&v121, (uint64_t)v119);
          BOOL v37 = *v120 <= 6.25139;
          if (*v120 > 6.25139 && cnprint::CNPrinter::GetLogLevel(v97) <= 1)
          {
            LOWORD(v113) = 12;
            LOBYTE(v148) = 1;
            uint64_t v98 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
            double v112 = v99 + (double)v98;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v113, (unsigned __int8 *)&v148, "t,%.3lf,PositionChecker: VL localization crosscheck, failed, normalized delta position %.3lf > %.3lf (test threshold)", v100, v101, v102, v103, v104, SLOBYTE(v112));
          }
        }
        int v36 = 1;
LABEL_23:
        double v38 = sub_18DFF465C((void *)(*((void *)this + 2) + 16), (unsigned __int8 *)&unk_18E22ADF0);
        uint64_t v40 = *((void *)this + 2);
        if (v38 && *((unsigned char *)v38 + 1288))
        {
          uint64_t v150 = 0x100000003;
          long long v149 = xmmword_18E1F6F60;
          double v148 = &unk_1EDD18D98;
          double v151 = &v152;
          long long v152 = *((_OWORD *)v38 + 81);
          uint64_t v153 = v38[164];
          uint64_t v133 = 0x100000003;
          long long v132 = xmmword_18E1F6F60;
          uint64_t v131 = &unk_1EDD18D98;
          uint64_t v134 = &v135;
          sub_18DFE2AA8((uint64_t)&v137, (uint64_t)&v148, (uint64_t)&v131);
          uint64_t v127 = 0x100000003;
          *(_OWORD *)&v126[8] = xmmword_18E1F6F60;
          *(void *)uint64_t v126 = &unk_1EDD18D98;
          double v128 = (double *)v129;
          uint64_t v155 = 0x100000134;
          *(_OWORD *)&v154[8] = xmmword_18E1F6FB0;
          *(void *)long long v154 = &unk_1EDD18C48;
          uint64_t v156 = &v157;
          uint64_t v115 = 0x100000003;
          uint64_t v113 = &unk_1EDD18D98;
          long long v114 = xmmword_18E1F6F60;
          uint64_t v116 = v117;
          sub_18DFE345C((uint64_t)&v131, (uint64_t)v126, (uint64_t)v154, (uint64_t)&v113, "2");
          int v41 = 0;
          BOOL v43 = v42 <= 100.0;
          int v44 = 1;
LABEL_37:
          uint64_t LogLevel = (cnprint::CNPrinter *)cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v38);
          if (!LogLevel)
          {
            *(_WORD *)long long v154 = 12;
            v126[0] = 0;
            uint64_t v56 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
            double v109 = v57 + (double)v56;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)v154, v126, "t,%.3lf PositionChecker: VL localization MSR, cross-check valid,%d,%d,%d passed,%d,%d, vl_distance,%.3lf", v58, v59, v60, v61, v62, SLOBYTE(v109));
          }
          if (((v37 | v36 ^ 1) & 1) == 0 && ((v44 | v41) ^ 1 | v43) != 1) {
            return 0;
          }
          uint64_t v63 = v144;
          if ((int)v144 < 1)
          {
            double v65 = 0.0;
          }
          else
          {
            int v64 = 0;
            double v65 = 0.0;
            do
            {
              double v65 = v65 + *(double *)&v146[v64];
              v64 += HIDWORD(v144) + 1;
              --v63;
            }
            while (v63);
          }
          if (v36 | v44 | v41) {
            double v66 = 1.0;
          }
          else {
            double v66 = 100.0;
          }
          if (((v36 & v37 ^ 1 | v43) & 1) == 0)
          {
            if (v65 >= 400.0) {
              double v66 = 1.0;
            }
            else {
              double v66 = 400.0 / v65;
            }
          }
          if (!cnprint::CNPrinter::GetLogLevel(LogLevel))
          {
            *(_WORD *)long long v154 = 12;
            v126[0] = 0;
            uint64_t v67 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
            double v110 = v68 + (double)v67;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)v154, v126, "t,%.3lf PositionChecker: VL localization MSR Re-weight unc_sf,%.3lf", v69, v70, v71, v72, v73, SLOBYTE(v110));
          }
          uint64_t v155 = 0x300000003;
          *(void *)&v74.f64[1] = 0x300000009;
          *(_OWORD *)&v154[8] = xmmword_18E1F0010;
          *(void *)long long v154 = &unk_1EDD18EE8;
          uint64_t v156 = &v157;
          v74.f64[0] = v66;
          sub_18E06E238((uint64_t)&v143, (uint64_t)v154, v74);
          sub_18DFE2F24((uint64_t)&v143, (uint64_t)v154);
          uint64_t v23 = sub_18E195984(a2, (uint64_t)&v143, v75, v76, v77, v78, v79, v80);
          if (v23) {
            return 1;
          }
          goto LABEL_57;
        }
        if (!*(unsigned char *)(v40 + 1152)
          || !*(unsigned char *)(v40 + 1440)
          || (int v45 = *(unsigned __int8 *)(v40 + 1360), v45 != 11) && v45 != 4)
        {
LABEL_36:
          int v44 = 0;
          int v41 = 0;
          BOOL v43 = 0;
          goto LABEL_37;
        }
        *(_OWORD *)long long v154 = *(_OWORD *)((char *)a2 + 104);
        *(_OWORD *)uint64_t v126 = *(_OWORD *)(v40 + 1264);
        uint64_t v46 = CNTimeSpan::operator-((uint64_t)v154, v126, *(int8x16_t *)v126, v39);
        if (v46 != 6)
        {
          if (v46)
          {
            if (v46 >= 7)
            {
LABEL_34:
              double v38 = (uint64_t **)cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v46);
              if (!v38)
              {
                *(_WORD *)long long v154 = 12;
                v126[0] = 0;
                uint64_t v48 = (*(uint64_t (**)(raven::PositionEvent *))(*(void *)a2 + 16))(a2);
                double v108 = v49 + (double)v48;
                cnprint::CNPrinter::Print((cnprint::CNPrinter *)v154, v126, "t,%.3lf,PositionChecker: VL localization crosscheck, previous WiFi pos is too old: %.2lf > %.2lf", v50, v51, v52, v53, v54, SLOBYTE(v108));
              }
              goto LABEL_36;
            }
LABEL_68:
            uint64_t v155 = 0x100000003;
            *(_OWORD *)&v154[8] = xmmword_18E1F6F60;
            *(void *)long long v154 = &unk_1EDD18D98;
            uint64_t v156 = &v157;
            long long v157 = *(_OWORD *)(v40 + 1448);
            uint64_t v158 = *(void *)(v40 + 1464);
            sub_18E01E318((uint64_t)&v137, (uint64_t)v154, (uint64_t)v126);
            sub_18E03017C((uint64_t)v126);
            int v44 = 0;
            BOOL v43 = v105 <= 100.0;
            int v41 = 1;
            goto LABEL_37;
          }
          if ((*(void *)&v47 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000) {
            goto LABEL_68;
          }
        }
        if (v47 > 0.0) {
          goto LABEL_34;
        }
        goto LABEL_68;
      }
      if ((*(void *)&v26 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000) {
        goto LABEL_61;
      }
    }
    if (v26 > 0.0) {
      goto LABEL_20;
    }
    goto LABEL_61;
  }
  return 0;
}

uint64_t raven::PositionChecker::Reset(uint64_t this)
{
  if (*(unsigned char *)(this + 120)) {
    *(unsigned char *)(this + 120) = 0;
  }
  return this;
}

uint64_t sub_18E197730(uint64_t result)
{
  *(void *)uint64_t result = &unk_1EDD13B10;
  if (*(unsigned char *)(result + 120)) {
    *(unsigned char *)(result + 120) = 0;
  }
  return result;
}

void sub_18E19775C(uint64_t a1)
{
  *(void *)a1 = &unk_1EDD13B10;
  if (*(unsigned char *)(a1 + 120)) {
    *(unsigned char *)(a1 + 120) = 0;
  }
  JUMPOUT(0x192FA6240);
}

raven::RavenPredictor *raven::RavenPredictor::RavenPredictor(raven::RavenPredictor *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &unk_1EDD0B168;
  *((void *)this + 323) = &unk_1EDD0AEF8;
  *((_OWORD *)this + 162) = 0u;
  *((_OWORD *)this + 163) = 0u;
  *((_OWORD *)this + 164) = 0u;
  *((_OWORD *)this + 165) = 0u;
  *((_OWORD *)this + 166) = 0u;
  *((_OWORD *)this + 167) = 0u;
  *((_OWORD *)this + 168) = 0u;
  *((_OWORD *)this + 169) = 0u;
  *(_OWORD *)((char *)this + 2713) = 0u;
  *((unsigned char *)this + 24) = 0;
  *((_OWORD *)this + 2) = xmmword_18E1FD640;
  *((void *)this + 6) = 0x40C3880000000000;
  *((_DWORD *)this + 644) = 0;
  *((_DWORD *)this + 684) = 10;
  *((void *)this + 343) = &unk_1EDD0B0C0;
  *((void *)this + 344) = &unk_1EDD0B168;
  *((void *)this + 665) = &unk_1EDD0AEF8;
  *(_OWORD *)((char *)this + 5449) = 0u;
  *((_OWORD *)this + 340) = 0u;
  *((_OWORD *)this + 339) = 0u;
  *((_OWORD *)this + 338) = 0u;
  *((_OWORD *)this + 337) = 0u;
  *((_OWORD *)this + 336) = 0u;
  *((_OWORD *)this + 335) = 0u;
  *((_OWORD *)this + 334) = 0u;
  *((_OWORD *)this + 333) = 0u;
  *((unsigned char *)this + 2760) = 0;
  *((_OWORD *)this + 173) = xmmword_18E1FD640;
  *((void *)this + 348) = 0x40C3880000000000;
  *((_DWORD *)this + 1328) = 0;
  *((_DWORD *)this + 1368) = 10;
  sub_18DFF49CC((uint64_t)this + 5480);
  *((void *)this + 989) = &unk_1EDD13820;
  *((void *)this + 991) = 0;
  *((void *)this + 990) = 0;
  *((unsigned char *)this + 7936) = 0;
  *((void *)this + 994) = 0;
  *((void *)this + 993) = 0;
  *((unsigned char *)this + 7960) = 0;
  *((void *)this + 997) = 0;
  *((void *)this + 996) = 0;
  *((unsigned char *)this + 7984) = 0;
  *((void *)this + 1000) = 0;
  *((void *)this + 999) = 0;
  *((void *)this + 1001) = 0x7FF8000000000000;
  *(_WORD *)this = 0;
  return this;
}

void sub_18E197970(_Unwind_Exception *a1)
{
  *double v6 = v2;
  void *v7 = &unk_1EDD0A858;
  *__n128 v5 = &unk_1EDD0A858;
  *long long v3 = v1;
  *uint64_t v4 = &unk_1EDD0A858;
  _Unwind_Resume(a1);
}

uint64_t raven::RavenPredictor::Configure(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  if (!*a2 || !*(unsigned char *)(v8 + 33))
  {
    __int16 v19 = 12;
    unsigned __int8 v18 = 4;
    uint64_t v12 = "RavenPredictor::Configure called with uninitialized parameters.";
    goto LABEL_9;
  }
  *(_WORD *)a1 = 0;
  *(void *)(a1 + 8) = v8;
  if (!*(unsigned char *)(v8 + 3656))
  {
    int v14 = *(_DWORD *)(v8 + 3652);
    if (v14)
    {
      __int16 v19 = 12;
      unsigned __int8 v18 = 4;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v19, &v18, "Error: RavenPredictor::Configure() failed to load gravity parameters becasue of invalid model type: %d.", a4, a5, a6, a7, a8, v14);
      return 0xFFFFFFFFLL;
    }
    if (sub_18E02ABDC(a1 + 16, (uint64_t)&unk_18E22AE68, (uint64_t)&unk_18E22AF64, (uint64_t)&unk_18E22B060, (uint64_t)&unk_18E22B258, (uint64_t)&unk_18E22B450, (uint64_t)&unk_18E22B648))
    {
      __int16 v19 = 12;
      unsigned __int8 v18 = 4;
      uint64_t v12 = "Error: RavenPredictor::Configure() failed to load EGM96 gravity parameters.";
      goto LABEL_9;
    }
LABEL_16:
    *(_DWORD *)(a1 + 2576) = 1;
    uint64_t v15 = *(void *)(a1 + 8);
    if (*(_DWORD *)(v15 + 3652))
    {
      __int16 v19 = 12;
      unsigned __int8 v18 = 4;
      uint64_t v12 = "Error: RavenPredictor::Configure() failed to set EGM96 model constants.";
    }
    else
    {
      *(_OWORD *)(a1 + 32) = xmmword_18E1FD640;
      *(void *)(a1 + 48) = 0x40E86A0000000000;
      int v16 = *(_DWORD *)(v15 + 3688);
      if ((v16 - 11) <= 0xFFFFFFF6) {
        __assert_rtn("SetTruncationDegree", "sphericalharmonicsgravitymodel.h", 471, "trunc >= 2 && trunc <= max_degree");
      }
      *(_DWORD *)(a1 + 2736) = v16;
      if (*(unsigned char *)(a1 + 24))
      {
        sub_18E06E600(a1 + 2752, a1 + 16);
        uint64_t result = 0;
        *(unsigned char *)a1 = 1;
        return result;
      }
      __int16 v19 = 12;
      unsigned __int8 v18 = 4;
      uint64_t v12 = "Error: RavenPredictor::Configure() gravity parameters are invalid.";
    }
    goto LABEL_9;
  }
  uint64_t v10 = a1 + 16;
  double v11 = (char *)(v8 + 3664);
  if (*(char *)(v8 + 3687) < 0) {
    double v11 = *(char **)v11;
  }
  if (!sub_18E02AB00(v10, v11)) {
    goto LABEL_16;
  }
  __int16 v19 = 12;
  unsigned __int8 v18 = 4;
  uint64_t v12 = "Error: RavenPredictor::Configure() failed to load gravity parameters from file.";
LABEL_9:
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v19, &v18, v12, a4, a5, a6, a7, a8, v17);
  return 0xFFFFFFFFLL;
}

uint64_t raven::RavenPredictor::Reset(uint64_t this)
{
  *(unsigned char *)(this + 1) = 0;
  return this;
}

uint64_t raven::RavenPredictor::HandleEvent(raven::RavenPredictor *this, const raven::RavenSolutionEvent *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(unsigned char *)this)
  {
    __int16 v14 = 12;
    unsigned __int8 v13 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v14, &v13, "Error: RavenPredictor::HandleEvent(RavenSolutionEvent) failed. Predictor is not configured.", a4, a5, a6, a7, a8, v12);
    return 0xFFFFFFFFLL;
  }
  BOOL v9 = *((unsigned char *)a2 + 208) == 4 && *((unsigned char *)a2 + 209) == 2;
  if (!v9 || !*((unsigned char *)a2 + 1464)) {
    return 0;
  }
  if (!*((unsigned char *)this + 1))
  {
    *((unsigned char *)this + 1) = 1;
    goto LABEL_13;
  }
  uint64_t result = sub_18DEE4C00((double *)a2 + 146, (double *)this + 831);
  if (result)
  {
LABEL_13:
    memcpy((char *)this + 5488, (char *)a2 + 8, 0x971uLL);
    return 0;
  }
  return result;
}

uint64_t raven::RavenPredictor::IsConfigured(raven::RavenPredictor *this)
{
  return *(unsigned __int8 *)this;
}

uint64_t raven::RavenPredictor::IsInitialized(raven::RavenPredictor *this)
{
  return *((unsigned __int8 *)this + 1);
}

uint64_t raven::RavenPredictor::HandleEvent(raven::RavenPredictor *this, const raven::TimeMarkEvent *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)this)
  {
    uint64_t v8 = (_OWORD *)((char *)a2 + 8);
    BOOL v9 = (_OWORD *)((char *)this + 7920);
    uint64_t result = sub_18DEE4C00((double *)a2 + 1, (double *)this + 990);
    if (result)
    {
      uint64_t result = 0;
      long long v11 = v8[1];
      *BOOL v9 = *v8;
      v9[1] = v11;
      long long v12 = v8[2];
      long long v13 = v8[3];
      long long v14 = v8[5];
      v9[4] = v8[4];
      v9[5] = v14;
      v9[2] = v12;
      v9[3] = v13;
    }
  }
  else
  {
    __int16 v17 = 12;
    unsigned __int8 v16 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v17, &v16, "Error: RavenPredictor::HandleEvent(TimeMarkEvent) failed. Predictor is not configured.", a4, a5, a6, a7, a8, v15);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t raven::RavenPredictor::Predict(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  if (!*(unsigned char *)a1)
  {
    LOWORD(v72) = 12;
    v81.i8[0] = 4;
    double v28 = "RavenPredictor::Predict() failed. Predictor is not configured.";
LABEL_23:
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v72, (unsigned __int8 *)&v81, v28, a4, a5, a6, a7, a8, v61);
    return 0xFFFFFFFFLL;
  }
  if (!*(unsigned char *)(a1 + 1))
  {
    LOWORD(v72) = 12;
    v81.i8[0] = 2;
    double v28 = "RavenPredictor::Predict() failed. Predictor is not initialized.";
    goto LABEL_23;
  }
  if (!*(unsigned char *)(a1 + 5688))
  {
    LOWORD(v72) = 12;
    v81.i8[0] = 4;
    double v28 = "RavenPredictor::Predict() failed. Current raven estimator type is not initialized.";
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 5689) != 2)
  {
    LOWORD(v72) = 12;
    v81.i8[0] = 2;
    double v28 = "RavenPredictor::Predict() failed. Current raven solution is not healthy.";
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 5688) != 4)
  {
    LOWORD(v72) = 12;
    v81.i8[0] = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v72, (unsigned __int8 *)&v81, "RavenPredictor::Predict() failed. Expected raven estimator type %u, but received %u.", a4, a5, a6, a7, a8, 4);
    return 0xFFFFFFFFLL;
  }
  if (!*(unsigned char *)(a1 + 6744))
  {
    LOWORD(v72) = 12;
    v81.i8[0] = 4;
    double v28 = "RavenPredictor::Predict() failed. Current user position is not valid.";
    goto LABEL_23;
  }
  long long v13 = (long long *)(a1 + 6648);
  uint64_t v14 = CNTimeSpan::operator-(a2, (void *)(a1 + 6648), a9, a10);
  uint64_t v23 = v14;
  *(void *)&v87[0] = v14;
  v87[1] = v15;
  double v24 = v15;
  BOOL v26 = v15 < 0.0 || v14 < 0;
  *(double *)v21.i64 = v15;
  if (v26)
  {
    uint64_t v14 = CNTimeSpan::operator-(v87, v21, v22);
    v21.i64[0] = v27;
  }
  *(double *)v21.i64 = *(double *)v21.i64 + (double)v14;
  *(double *)v22.i64 = fabs(*(double *)(*(void *)(a1 + 8) + 3472));
  if (*(double *)v21.i64 > *(double *)v22.i64)
  {
    LOWORD(v72) = 12;
    v81.i8[0] = 4;
    double v62 = *(double *)(a2 + 8) + (double)*(uint64_t *)a2;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v72, (unsigned __int8 *)&v81, "RavenPredictor::Predict() failed. Exceeded maximum prediction duration. Given input time: %.3lf (s). Current raven solution time: %.3lf (s)", v16, v17, v18, v19, v20, SLOBYTE(v62));
    return 0xFFFFFFFFLL;
  }
  if (v26)
  {
    uint64_t v23 = CNTimeSpan::operator-(v87, v21, v22);
    double v24 = v30;
  }
  if (fabs(v24 + (double)v23) < 2.22044605e-16)
  {
    memcpy((void *)(a3 + 8), (const void *)(a1 + 5488), 0x971uLL);
    return 0;
  }
  sub_18DFF4C24(a3);
  memcpy((void *)(a3 + 104), (const void *)(a1 + 5584), 0x428uLL);
  memcpy((void *)(a3 + 2032), (const void *)(a1 + 7512), 0x189uLL);
  long long v83 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  *(void *)&long long v86 = 0;
  *((void *)&v86 + 1) = 0x7FF8000000000000;
  int8x16_t v31 = *(int8x16_t *)a2;
  int8x16_t v81 = *(int8x16_t *)a2;
  long long v82 = 0u;
  if (!*(unsigned char *)(a1 + 7464)) {
    goto LABEL_32;
  }
  uint64_t v74 = 0x10000001CLL;
  long long v73 = xmmword_18E1FD5F0;
  uint64_t v72 = &unk_1EDD188B8;
  uint64_t v75 = v76;
  uint64_t v65 = 0x100000002;
  uint64_t v63 = &unk_1EDD18B28;
  long long v64 = xmmword_18E1FD1A0;
  double v66 = v67;
  long long v71 = *v13;
  *(_OWORD *)&v76[152] = *(_OWORD *)(a1 + 7472);
  if (sub_18E078D00(a2, &v71, (uint64_t)&v72, (uint64_t)&v63))
  {
    v69.i16[0] = 12;
    v68.i8[0] = 2;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v69, (unsigned __int8 *)&v68, "RavenPNTEstimatorHelper::IntegrateDeviceOscillatorStateEstimate failed to predict clock states in RavenPredictor::Predict().", v32, v33, v34, v35, v36, v61);
LABEL_32:
    *(_OWORD *)(a3 + 1992) = *(_OWORD *)(a1 + 7472);
    int8x16_t v38 = *(int8x16_t *)(a1 + 7488);
    *(int8x16_t *)(a3 + 2008) = v38;
    v38.i64[0] = *(void *)(a1 + 7504);
    *(void *)(a3 + 2024) = v38.i64[0];
    raven::PopulateAllTimeFields((uint64_t)&v81, a1 + 7920, v38, v31);
    goto LABEL_34;
  }
  int8x16_t v39 = v66;
  v37.i64[0] = *v66;
  *(void *)(a3 + 1992) = *v66;
  *(void *)(a3 + 2000) = v39[1];
  int8x16_t v40 = *(int8x16_t *)(a1 + 7488);
  *(int8x16_t *)(a3 + 2008) = v40;
  *(void *)(a3 + 2024) = *(void *)(a1 + 7504);
  *(double *)v40.i64 = sqrt(*(double *)(a1 + 7488));
  uint64_t v70 = v40.i64[0];
  int8x16_t v68 = 0uLL;
  CNTimeSpan::SetTimeSpan(v68.i64, 0, v37, v40);
  int8x16_t v69 = v68;
  raven::PopulateAllTimeFields((uint64_t)&v81, a1 + 7920, &v69, &v70, v68, v41);
LABEL_34:
  int v42 = *(unsigned __int8 *)(a1 + 6824);
  if (*(unsigned char *)(a1 + 6824) && *(unsigned char *)(a1 + 6825))
  {
    uint64_t v74 = 0x10000001CLL;
    long long v73 = xmmword_18E1FD5F0;
    uint64_t v72 = &unk_1EDD188B8;
    uint64_t v75 = v76;
    uint64_t v65 = 0x100000007;
    uint64_t v63 = &unk_1EDD197E8;
    long long v64 = xmmword_18E1FD680;
    double v66 = v67;
    long long v71 = *v13;
    long long v77 = *(_OWORD *)(a1 + 6752);
    uint64_t v78 = *(void *)(a1 + 6768);
    long long v79 = *(_OWORD *)(a1 + 6832);
    long long v80 = *(_OWORD *)(a1 + 6848);
    if (sub_18E06C3A8(a2, &v71, (uint64_t)&v72, 0, (uint64_t)&v63))
    {
      v69.i16[0] = 12;
      v68.i8[0] = 2;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v69, (unsigned __int8 *)&v68, "RavenPNTEstimatorHelper::IntegrateUserStateEstimate failed to predict user states in RavenPredictor::Predict().", v43, v44, v45, v46, v47, v61);
      return 0xFFFFFFFFLL;
    }
    *(unsigned char *)(a3 + 1264) = 1;
    *(_WORD *)(a3 + 1344) = 257;
    uint64_t v48 = v66;
    *(void *)(a3 + 1272) = *v66;
    *(void *)(a3 + 1280) = v48[1];
    *(void *)(a3 + 1288) = v48[2];
    *(_OWORD *)(a3 + 1296) = *(_OWORD *)(a1 + 6776);
    *(_OWORD *)(a3 + 1312) = *(_OWORD *)(a1 + 6792);
    *(_OWORD *)(a3 + 1328) = *(_OWORD *)(a1 + 6808);
    *(void *)(a3 + 1352) = v48[3];
    *(void *)(a3 + 1360) = v48[4];
    *(void *)(a3 + 1368) = v48[5];
    *(void *)(a3 + 1376) = v48[6];
    *(_OWORD *)(a3 + 1384) = *(_OWORD *)(a1 + 6864);
    *(_OWORD *)(a3 + 1400) = *(_OWORD *)(a1 + 6880);
    *(_OWORD *)(a3 + 1416) = *(_OWORD *)(a1 + 6896);
    *(_OWORD *)(a3 + 1432) = *(_OWORD *)(a1 + 6912);
    *(_OWORD *)(a3 + 1448) = *(_OWORD *)(a1 + 6928);
  }
  else
  {
    *(unsigned char *)(a3 + 1264) = 1;
    *(_OWORD *)(a3 + 1272) = *(_OWORD *)(a1 + 6752);
    *(_OWORD *)(a3 + 1288) = *(_OWORD *)(a1 + 6768);
    *(_OWORD *)(a3 + 1304) = *(_OWORD *)(a1 + 6784);
    *(_OWORD *)(a3 + 1320) = *(_OWORD *)(a1 + 6800);
    *(void *)(a3 + 1336) = *(void *)(a1 + 6816);
    if (v42)
    {
      *(unsigned char *)(a3 + 1344) = 1;
      *(void *)(a3 + 1352) = *(void *)(a1 + 6832);
      *(void *)(a3 + 1384) = *(void *)(a1 + 6864);
    }
  }
  uint64_t result = 0;
  long long v49 = v83;
  long long v50 = v84;
  long long v51 = v83;
  long long v52 = v84;
  *(_OWORD *)(a3 + 40) = v83;
  *(_OWORD *)(a3 + 56) = v50;
  long long v53 = v85;
  long long v54 = v86;
  *(_OWORD *)(a3 + 72) = v85;
  *(_OWORD *)(a3 + 1232) = v53;
  long long v56 = v85;
  long long v55 = v86;
  *(_OWORD *)(a3 + 88) = v86;
  *(_OWORD *)(a3 + 1200) = v49;
  *(_OWORD *)(a3 + 1216) = v50;
  int8x16_t v57 = v81;
  *(int8x16_t *)(a3 + 8) = v81;
  *(_OWORD *)(a3 + 1248) = v55;
  *(int8x16_t *)(a3 + 1168) = v57;
  int8x16_t v59 = v81;
  long long v58 = v82;
  long long v60 = v82;
  *(_OWORD *)(a3 + 24) = v82;
  *(_OWORD *)(a3 + 1184) = v58;
  *(unsigned char *)(a3 + 208) = 5;
  *(_OWORD *)(a3 + 144) = v51;
  *(_OWORD *)(a3 + 160) = v52;
  *(_OWORD *)(a3 + 176) = v56;
  *(_OWORD *)(a3 + 192) = v54;
  *(int8x16_t *)(a3 + 112) = v59;
  *(_OWORD *)(a3 + 128) = v60;
  return result;
}

BOOL raven::RavenDeltaVIOEstimateActiveObject::ApplyDefaultUncertaintyInflation(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 1082)) {
    return 1;
  }
  uint64_t v4 = a2 + 200;
  __n128 v5 = sub_18DFE2FA8((uint64_t)v24, a2 + 408);
  uint64_t v6 = v25;
  if (v25 < 1)
  {
    double v8 = 0.0;
  }
  else
  {
    int v7 = 0;
    double v8 = 0.0;
    do
    {
      double v8 = v8 + *(double *)(v27 + 8 * v7);
      v7 += v26 + 1;
      --v6;
    }
    while (v6);
    v5.n128_u64[0] = 4.0;
    if (v8 >= 1.0) {
      goto LABEL_11;
    }
  }
  v5.n128_u64[0] = 4.0;
  if (fabs(v8) >= 2.22044605e-16) {
    v5.n128_f64[0] = 1.0 / v8 * 4.0;
  }
LABEL_11:
  uint64_t v21 = 0x300000003;
  uint64_t v19 = &unk_1EDD18EE8;
  long long v20 = xmmword_18E1F0010;
  int8x16_t v22 = &v23;
  sub_18E06E238((uint64_t)v24, (uint64_t)&v19, (float64x2_t)v5);
  sub_18DFE2F24((uint64_t)v24, (uint64_t)&v19);
  BOOL result = cntransformation::CNRigidTransformation::SetPpp(v4, (uint64_t)v24);
  if (!result) {
    return result;
  }
  __n128 v9 = sub_18DFE2FA8((uint64_t)&v19, a2 + 296);
  uint64_t v10 = v20;
  if ((int)v20 < 1)
  {
    double v12 = 0.0;
    long long v13 = xmmword_18E1F0010;
    goto LABEL_18;
  }
  int v11 = 0;
  double v12 = 0.0;
  do
  {
    double v12 = v12 + *(double *)&v22[v11];
    v11 += HIDWORD(v20) + 1;
    --v10;
  }
  while (v10);
  v9.n128_u64[0] = 16.0;
  long long v13 = xmmword_18E1F0010;
  if (v12 < 0.00121846968)
  {
LABEL_18:
    v9.n128_u64[0] = 16.0;
    if (fabs(v12) >= 2.22044605e-16) {
      v9.n128_f64[0] = 0.00121846968 / v12 * 16.0;
    }
  }
  uint64_t v16 = 0x300000003;
  uint64_t v14 = &unk_1EDD18EE8;
  long long v15 = v13;
  uint64_t v17 = &v18;
  sub_18E06E238((uint64_t)&v19, (uint64_t)&v14, (float64x2_t)v9);
  sub_18DFE2F24((uint64_t)&v19, (uint64_t)&v14);
  BOOL result = cntransformation::CNRigidTransformation::SetPrr(v4, (uint64_t)&v19);
  if (result) {
    *(unsigned char *)(a2 + 1082) = 1;
  }
  return result;
}

double *raven::RavenDeltaVIOEstimateActiveObject::ApplyVIOYawCorrection(double *this, double a2)
{
  if (fabs(a2) > 0.01 && *((unsigned char *)this + 736) != 0)
  {
    long long v3 = this + 1089;
    __double2 v4 = __sincos_stret(a2);
    uint64_t v12 = 0x300000003;
    uint64_t v10 = &unk_1EDD18EE8;
    long long v13 = (double *)&v14;
    long long v11 = xmmword_18E1F0010;
    sub_18DFE2CC8((uint64_t)&v10, 0.0);
    __n128 v5 = v13;
    *long long v13 = v4.__cosval;
    v5[1] = v4.__sinval;
    int v6 = HIDWORD(v11);
    v5[SHIDWORD(v11)] = -v4.__sinval;
    v5[v6 + 1] = v4.__cosval;
    v5[2 * v6 + 2] = 1.0;
    sub_18DFE20A0((uint64_t)v9, (uint64_t)&v10);
    this = cnrotation::Cat(v3, (const cnrotation::CNRotation *)v9, (double *)v8);
    if (v3 != (double *)v8)
    {
      long long v7 = v8[1];
      *(_OWORD *)long long v3 = v8[0];
      *((_OWORD *)v3 + 1) = v7;
    }
  }
  return this;
}

uint64_t raven::RavenDeltaVIOEstimateActiveObject::ComputeCovarianceFromSigmaCorrelationMatrix(cnprint::CNPrinter *a1, uint64_t a2, uint64_t a3)
{
  BOOL v3 = *(_DWORD *)(a2 + 8) == 3 && *(_DWORD *)(a2 + 12) == 3;
  uint64_t v4 = v3;
  if (v3)
  {
    *(_OWORD *)(a3 + 8) = xmmword_18E1F0010;
    __n128 v5 = *(double **)(a2 + 32);
    int v6 = *(double **)(a3 + 32);
    *int v6 = *v5 * *v5;
    int v7 = *(_DWORD *)(a2 + 20);
    v6[4] = v5[v7 + 1] * v5[v7 + 1];
    int v8 = 2 * v7 + 2;
    v6[8] = v5[v8] * v5[v8];
    double v9 = v5[1] * v5[v7 + 1] * *v5;
    v6[1] = v9;
    double v10 = v5[2] * v5[v8] * *v5;
    v6[2] = v10;
    double v11 = v5[v7 + 2] * v5[v8] * v5[v7 + 1];
    uint64_t v6[3] = v9;
    v6[5] = v11;
    v6[6] = v10;
    v6[7] = v11;
  }
  else
  {
    unsigned int LogLevel = cnprint::CNPrinter::GetLogLevel(a1);
    if (LogLevel <= 1)
    {
      __int16 v24 = 12;
      unsigned __int8 v23 = 1;
      (*(void (**)(void **__return_ptr, cnprint::CNPrinter *))(*(void *)a1 + 16))(__p, a1);
      if (v22 >= 0) {
        uint64_t v19 = __p;
      }
      else {
        LOBYTE(v19) = __p[0];
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v24, &v23, "%s, Input sigma-correlation matrix has wrong dimensions, expected 3x3", v14, v15, v16, v17, v18, (char)v19);
      if (v22 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  return v4;
}

void sub_18E1987D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t raven::RavenDeltaVIOEstimateActiveObject::ComputeSigmaCorrelationMatrixFromCovariance(cnprint::CNPrinter *a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a2 + 8) == 3 && *(_DWORD *)(a2 + 12) == 3)
  {
    *(_OWORD *)(a3 + 8) = xmmword_18E1F0010;
    double v11 = *(double **)(a2 + 32);
    double v12 = sqrt(*v11);
    long long v13 = *(double **)(a3 + 32);
    *long long v13 = v12;
    int v14 = *(_DWORD *)(a2 + 20);
    double v15 = sqrt(v11[v14 + 1]);
    v13[4] = v15;
    double v16 = sqrt(v11[2 * v14 + 2]);
    v13[8] = v16;
    if (fabs(v12 * v15) >= 2.22044605e-16)
    {
      double v17 = v11[1] / (v12 * v15);
      v13[1] = v17;
      double v18 = v12 * v16;
      if (fabs(v18) >= 2.22044605e-16)
      {
        double v19 = v11[2] / v18;
        v13[2] = v19;
        double v20 = v15 * v16;
        if (fabs(v20) >= 2.22044605e-16)
        {
          double v22 = v11[v14 + 2];
          v13[3] = v17;
          double v23 = v22 / v20;
          v13[5] = v23;
          v13[6] = v19;
          v13[7] = v23;
          return 1;
        }
      }
    }
  }
  else if (cnprint::CNPrinter::GetLogLevel(a1) <= 1)
  {
    __int16 v27 = 12;
    unsigned __int8 v26 = 1;
    (*(void (**)(void **__return_ptr, cnprint::CNPrinter *))(*(void *)a1 + 16))(__p, a1);
    if (v25 >= 0) {
      double v10 = __p;
    }
    else {
      LOBYTE(v10) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v27, &v26, "%s, Input variance-covariance matrix has wrong dimensions, expected 3x3", v5, v6, v7, v8, v9, (char)v10);
    if (v25 < 0) {
      operator delete(__p[0]);
    }
  }
  return 0;
}

void sub_18E198978(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t raven::RavenDeltaVIOEstimateActiveObject::Configure(cnframework::ActiveObjectBase *this, uint64_t *a2)
{
  if (*((unsigned char *)this + 480))
  {
    __int16 v35 = 12;
    unsigned __int8 v34 = 2;
    (*(void (**)(void **__return_ptr, cnframework::ActiveObjectBase *))(*(void *)this + 16))(__p, this);
    if (v33 >= 0) {
      uint64_t v9 = __p;
    }
    else {
      LOBYTE(v9) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v35, &v34, "Warning: %s configured more than once", v4, v5, v6, v7, v8, (char)v9);
    if (v33 < 0) {
      operator delete(__p[0]);
    }
  }
  *((unsigned char *)this + 480) = 0;
  uint64_t v10 = *a2;
  if (!*a2 || !*(unsigned char *)(v10 + 33))
  {
    __int16 v35 = 12;
    unsigned __int8 v34 = 4;
    (*(void (**)(void **__return_ptr, cnframework::ActiveObjectBase *))(*(void *)this + 16))(__p, this);
    if (v33 >= 0) {
      unsigned __int8 v26 = __p;
    }
    else {
      LOBYTE(v26) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v35, &v34, "%s could not be configured - invalid RavenParameters", v21, v22, v23, v24, v25, (char)v26);
    if (v33 < 0) {
      operator delete(__p[0]);
    }
    return 0xFFFFFFFFLL;
  }
  *((void *)this + 61) = v10;
  if ((*(void *)(v10 + 3184) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
    && (*(void *)(v10 + 3176) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
    && *(double *)(v10 + 3184) < *(double *)(v10 + 3176))
  {
    if (cnprint::CNPrinter::GetLogLevel(this) <= 1)
    {
      LOWORD(__p[0]) = 12;
      LOBYTE(v35) = 1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v35, "#WARNING, Incompatible Raven VIO Parameters, delta_VIO sampling period smaller than VIO estimate period [%.3lf < %.3lf]", v27, v28, v29, v30, v31, *(void *)(*((void *)this + 61) + 3184));
    }
    return 0xFFFFFFFFLL;
  }
  cnframework::ActiveObjectBase::SetEventQueueDelay(this, 0.0);
  uint64_t v12 = *a2;
  *((void *)this + 1242) = *(void *)(*a2 + 920);
  *((void *)this + 1235) = *(void *)(v12 + 792);
  *((unsigned char *)this + 480) = 1;
  long long v13 = (cnprint::CNPrinter *)(*(uint64_t (**)(cnframework::ActiveObjectBase *))(*(void *)this + 48))(this);
  if (cnprint::CNPrinter::GetLogLevel(v13) <= 1)
  {
    __int16 v35 = 12;
    unsigned __int8 v34 = 1;
    (*(void (**)(void **__return_ptr, cnframework::ActiveObjectBase *))(*(void *)this + 16))(__p, this);
    if (v33 >= 0) {
      double v19 = __p;
    }
    else {
      LOBYTE(v19) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v35, &v34, "%s configured successfully", v14, v15, v16, v17, v18, (char)v19);
    if (v33 < 0) {
      operator delete(__p[0]);
    }
  }
  return 0;
}

void sub_18E198C28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t raven::RavenDeltaVIOEstimateActiveObject::IsConfigured(raven::RavenDeltaVIOEstimateActiveObject *this)
{
  return *((unsigned __int8 *)this + 480);
}

void raven::RavenDeltaVIOEstimateActiveObject::CreateAndRaiseDeltaVIOEstimates(int8x16_t *this, double a2, int8x16_t a3)
{
  unint64_t v3 = this[620].u64[1];
  if (v3 >= 2)
  {
    uint64_t v5 = this + 618;
    unint64_t v6 = this[620].u64[0];
    unint64_t v7 = v3 + v6 - 1;
    uint64_t v8 = this[618].i64[1];
    unint64_t v9 = v7 >> 4;
    unsigned int v10 = v7 & 0xF;
    v58[0] = *(_OWORD *)(*(void *)(v8 + 8 * (v7 >> 4)) + 1088 * (v7 & 0xF));
    double v11 = this + 421;
    if (this[489].i8[0])
    {
      v57[0] = this[421];
      uint64_t v12 = CNTimeSpan::operator-((uint64_t)v58, v57, v57[0], a3);
      if (v13 + (double)v12 + (v13 + (double)v12) * 0.05 < *(double *)(this[30].i64[1] + 3184)) {
        return;
      }
      uint64_t v14 = *(void *)(v8 + 8 * v9);
    }
    else
    {
      uint64_t v15 = (int8x16_t *)(*(void *)(v8 + ((v6 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 1088 * (v6 & 0xF));
      v57[0] = *v15;
      uint64_t v16 = CNTimeSpan::operator-((uint64_t)v58, v57, v57[0], a3);
      if (v17 + (double)v16 + (v17 + (double)v16) * 0.05 < *(double *)(this[30].i64[1] + 3184)) {
        return;
      }
      if (!raven::RavenDeltaVIOEstimateActiveObject::ApplyDefaultUncertaintyInflation(v16, (uint64_t)v15))
      {
        sub_18E19918C((uint64_t)v5);
        return;
      }
      uint64_t v12 = sub_18E199214((uint64_t)v11, (uint64_t)v15);
      if (!v11[68].i8[0]) {
        sub_18DFF28FC();
      }
      unint64_t v18 = this[620].i64[1] + this[620].i64[0] - 1;
      unsigned int v10 = v18 & 0xF;
      uint64_t v14 = *(void *)(this[618].i64[1] + ((v18 >> 1) & 0x7FFFFFFFFFFFFFF8));
    }
    double v19 = (long long *)(v14 + 1088 * v10);
    if (raven::RavenDeltaVIOEstimateActiveObject::ApplyDefaultUncertaintyInflation(v12, (uint64_t)v19))
    {
      cntransformation::Inv((float64x2_t *)(v14 + 1088 * v10 + 200), (uint64_t)v57);
      cntransformation::Cat((cntransformation *)v57, (const cntransformation::CNRigidTransformation *)&this[433].u64[1], (uint64_t)&v54);
      v31[16] = &unk_1EDD14210;
      uint64_t v46 = 0x100000003;
      long long v45 = xmmword_18E1F6F60;
      uint64_t v44 = &unk_1EDD18D98;
      uint64_t v47 = &v48;
      uint64_t v51 = 0x300000003;
      long long v50 = xmmword_18E1F0010;
      long long v49 = &unk_1EDD18EE8;
      long long v52 = &v53;
      long long v20 = *v19;
      long long v33 = v19[1];
      long long v32 = v20;
      long long v21 = v19[2];
      long long v22 = v19[3];
      long long v23 = v19[4];
      long long v37 = v19[5];
      long long v36 = v23;
      long long v35 = v22;
      long long v34 = v21;
      int8x16_t v24 = v11[3];
      int8x16_t v40 = v11[2];
      int8x16_t v41 = v24;
      int8x16_t v25 = v11[5];
      int8x16_t v42 = v11[4];
      int8x16_t v43 = v25;
      int8x16_t v26 = v11[1];
      int8x16_t v38 = *v11;
      int8x16_t v39 = v26;
      uint64_t v29 = 0x100000003;
      long long v28 = xmmword_18E1F6F60;
      uint64_t v27 = &unk_1EDD18D98;
      uint64_t v30 = v31;
      sub_18DFEF380((uint64_t)&v55, (uint64_t)&v27);
      sub_18DFE2F24((uint64_t)&v44, (uint64_t)&v27);
      sub_18DFE2F24((uint64_t)&v49, (uint64_t)&v56);
      sub_18E0D2244();
    }
    sub_18E19934C(v5);
  }
}

void sub_18E19918C(uint64_t a1)
{
  sub_18E0B8DAC((void *)(*(void *)(*(void *)(a1 + 8) + ((*(void *)(a1 + 32) >> 1) & 0x7FFFFFFFFFFFFFF8))
                         + 1088 * (*(void *)(a1 + 32) & 0xFLL)));
  int64x2_t v2 = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_18E1EF670);
  *(int64x2_t *)(a1 + 32) = v2;
  if (v2.i64[0] >= 0x20uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 16;
  }
}

uint64_t sub_18E199214(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 1088))
  {
    *(_OWORD *)a1 = *(_OWORD *)a2;
    long long v4 = *(_OWORD *)(a2 + 16);
    long long v5 = *(_OWORD *)(a2 + 32);
    long long v6 = *(_OWORD *)(a2 + 64);
    *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 64) = v6;
    *(_OWORD *)(a1 + 16) = v4;
    *(_OWORD *)(a1 + 32) = v5;
    long long v7 = *(_OWORD *)(a2 + 80);
    long long v8 = *(_OWORD *)(a2 + 96);
    long long v9 = *(_OWORD *)(a2 + 128);
    *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
    *(_OWORD *)(a1 + 128) = v9;
    *(_OWORD *)(a1 + 80) = v7;
    *(_OWORD *)(a1 + 96) = v8;
    long long v10 = *(_OWORD *)(a2 + 144);
    long long v11 = *(_OWORD *)(a2 + 160);
    long long v12 = *(_OWORD *)(a2 + 176);
    *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
    *(_OWORD *)(a1 + 160) = v11;
    *(_OWORD *)(a1 + 176) = v12;
    *(_OWORD *)(a1 + 144) = v10;
    if (a1 != a2)
    {
      *(_OWORD *)(a1 + 200) = *(_OWORD *)(a2 + 200);
      *(_OWORD *)(a1 + 216) = *(_OWORD *)(a2 + 216);
    }
    sub_18DFE2F24(a1 + 232, a2 + 232);
    sub_18DFE2F24(a1 + 296, a2 + 296);
    sub_18DFE2F24(a1 + 408, a2 + 408);
    sub_18DFE2F24(a1 + 520, a2 + 520);
    *(unsigned char *)(a1 + 632) = *(unsigned char *)(a2 + 632);
    if (a1 != a2)
    {
      *(_OWORD *)(a1 + 640) = *(_OWORD *)(a2 + 640);
      *(_OWORD *)(a1 + 656) = *(_OWORD *)(a2 + 656);
    }
    sub_18DFE2F24(a1 + 672, a2 + 672);
    sub_18DFE2F24(a1 + 736, a2 + 736);
    sub_18DFE2F24(a1 + 848, a2 + 848);
    sub_18DFE2F24(a1 + 960, a2 + 960);
    *(unsigned char *)(a1 + 1072) = *(unsigned char *)(a2 + 1072);
    __int16 v13 = *(_WORD *)(a2 + 1080);
    *(unsigned char *)(a1 + 1082) = *(unsigned char *)(a2 + 1082);
    *(_WORD *)(a1 + 1080) = v13;
  }
  else
  {
    sub_18E0C6F80(a1, a2);
    *(unsigned char *)(a1 + 1088) = 1;
  }
  return a1;
}

BOOL sub_18E19934C(void *a1)
{
  unint64_t v2 = a1[5] + a1[4] - 1;
  sub_18E0B8DAC((void *)(*(void *)(a1[1] + ((v2 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 1088 * (v2 & 0xF)));
  --a1[5];

  return sub_18E19E850(a1);
}

uint64_t raven::RavenDeltaVIOEstimateActiveObject::CreateAndRaisePositionEvent(uint64_t this, double a2, int8x16_t a3)
{
  if (*(unsigned char *)(this + 736))
  {
    uint64_t v3 = this;
    uint64_t v4 = *(void *)(this + 9928);
    if (v4)
    {
      long long v5 = (int8x16_t *)(*(void *)(*(void *)(this + 9896)
                                   + (((unint64_t)(v4 + *(void *)(this + 9920) - 1) >> 1) & 0x7FFFFFFFFFFFFFF8))
                       + 1088 * ((v4 + *(_DWORD *)(this + 9920) - 1) & 0xF));
      int8x16_t v6 = *v5;
      int8x16_t v58 = *v5;
      if (!*(unsigned char *)(this + 9848)
        || (this = CNTimeSpan::operator-((uint64_t)&v58, (void *)(this + 9832), v6, a3),
            v7 + (double)this + (v7 + (double)this) * 0.05 > *(double *)(v3 + 9880)))
      {
        uint64_t v8 = sub_18E0C6F80((uint64_t)&v50, (uint64_t)v5);
        if (raven::RavenDeltaVIOEstimateActiveObject::ApplyDefaultUncertaintyInflation(v8, (uint64_t)&v50))
        {
          if (*(unsigned char *)(v3 + 520))
          {
            if (!*(unsigned char *)(v3 + 9872)
              || (uint64_t v11 = CNTimeSpan::operator-((uint64_t)&v58, (void *)(v3 + 9856), v9, v10), v12 + (double)v11 >= 20.0))
            {
              double v42 = 0.0;
              if (raven::RavenDeltaVIOEstimateActiveObject::ShouldApplyVIOYawCorrection((raven::RavenDeltaVIOEstimateActiveObject *)v3, &v42))
              {
                double v13 = v42;
                raven::RavenDeltaVIOEstimateActiveObject::ApplyVIOYawCorrection((double *)v3, v42);
                *(double *)(v3 + 504) = v13 + *(double *)(v3 + 504);
                int v14 = *(unsigned __int8 *)(v3 + 9872);
                *(int8x16_t *)(v3 + 9856) = v58;
                if (!v14) {
                  *(unsigned char *)(v3 + 9872) = 1;
                }
              }
            }
          }
          uint64_t v44 = 0x100000003;
          *(void *)&double v42 = &unk_1EDD18D98;
          long long v43 = xmmword_18E1F6F60;
          long long v45 = &v46;
          sub_18DFE2AA8((uint64_t)v57, v3 + 9656, (uint64_t)&v42);
          sub_18DFE2F24((uint64_t)v57, (uint64_t)&v42);
          cntransformation::Cat((cntransformation *)(v3 + 8712), (const cntransformation::CNRigidTransformation *)&v56, (uint64_t)&v42);
          uint64_t v36 = 0;
          uint64_t v30 = 15;
          int64x2_t v31 = vdupq_n_s64(0x7FF8000000000000uLL);
          int64x2_t v32 = v31;
          int64x2_t v33 = v31;
          int64x2_t v34 = v31;
          int64x2_t v37 = v31;
          int64x2_t v38 = v31;
          int64x2_t v39 = v31;
          int64x2_t v40 = v31;
          long long v20 = v52;
          long long v21 = v53;
          long long v22 = v54;
          long long v23 = v55;
          long long v18 = v50;
          long long v19 = v51;
          long long v25 = v51;
          long long v24 = v50;
          long long v28 = v54;
          long long v27 = v53;
          long long v26 = v52;
          double v17 = &unk_1EDD137C0;
          uint64_t v35 = 0x7FF8000000000000;
          uint64_t v41 = 0x7FF8000000000000;
          long long v29 = v55;
          int64x2_t v37 = *v47;
          v38.i64[0] = v47[1].i64[0];
          v38.i64[1] = *v49;
          uint64_t v15 = &v49[v48];
          v39.i64[0] = *v15;
          v39.i64[1] = v49[2 * v48];
          v40.i64[0] = v15[1];
          uint64_t v16 = &v49[2 * v48];
          v40.i64[1] = v16[1];
          uint64_t v41 = v16[2];
          LOBYTE(v36) = 1;
          if (sub_18E0B99D0((uint64_t)&v17)) {
            sub_18E0B9CE0((uint64_t)&v17);
          }
          sub_18E0D1BAC();
        }
        return sub_18E19934C((void *)(v3 + 9888));
      }
    }
  }
  return this;
}

uint64_t raven::RavenDeltaVIOEstimateActiveObject::ShouldApplyVIOYawCorrection(raven::RavenDeltaVIOEstimateActiveObject *this, double *a2)
{
  *a2 = 0.0;
  BOOL v4 = *((unsigned char *)this + 584)
    && *((unsigned char *)this + 704)
    && vabdd_f64(*((double *)this + 72), *((double *)this + 87)) < *((double *)this + 87) * 0.1;
  BOOL v5 = *((unsigned char *)this + 552)
    && *((unsigned char *)this + 704)
    && vabdd_f64(*((double *)this + 68), *((double *)this + 87)) < *((double *)this + 87) * 0.25;
  double v6 = 0.0;
  if (!*((unsigned char *)this + 536)) {
    goto LABEL_31;
  }
  if (!*((unsigned char *)this + 5616)) {
    goto LABEL_31;
  }
  if (!*((unsigned char *)this + 4528)) {
    goto LABEL_31;
  }
  if (!*((unsigned char *)this + 4529)) {
    goto LABEL_31;
  }
  if (!*((unsigned char *)this + 733)) {
    goto LABEL_31;
  }
  double v7 = *((double *)this + 567);
  uint64_t v42 = 0x100000003;
  int64x2_t v40 = &unk_1EDD18D98;
  long long v41 = xmmword_18E1F6F60;
  long long v43 = &v44;
  float64x2_t v44 = vmulq_n_f64(*((float64x2_t *)this + 284), v7);
  double v45 = v7 * *((double *)this + 570);
  uint64_t v37 = 0x100000003;
  uint64_t v35 = &unk_1EDD18D98;
  long long v36 = xmmword_18E1F6F60;
  int64x2_t v38 = &v39;
  sub_18DFE2B44((uint64_t)this + 9720, (uint64_t)&v40, (uint64_t)&v35);
  long double v8 = *(double *)v38;
  long double v9 = *((double *)v38 + 1);
  if (hypot(*(long double *)v38, v9) < 1.0 || fabs(v8) <= 0.005 && fabs(v9) <= 0.005) {
    goto LABEL_31;
  }
  if (!*((unsigned char *)this + 536)) {
    sub_18DFF28FC();
  }
  double v10 = atan2(v8, v9);
  double v11 = v10 + 6.28318531;
  if (v10 >= 0.0) {
    double v11 = v10;
  }
  double v12 = *((double *)this + 66);
  double v13 = vabdd_f64(v11, v12);
  if (6.28318531 - v13 < v13) {
    double v13 = 6.28318531 - v13;
  }
  if (v13 < 0.104719755)
  {
    int v14 = *((unsigned __int8 *)this + 568);
    if (*((unsigned char *)this + 568))
    {
      double v15 = *((double *)this + 70);
      double v16 = vabdd_f64(v15, v12);
      double v17 = 6.28318531 - v16;
      if (6.28318531 - v16 >= v16) {
        double v17 = v16;
      }
      double v6 = v17;
      if (v12 > v15 || (int v14 = 0, v15 > 3.14159265) && v12 < 3.14159265)
      {
        int v14 = 0;
        double v6 = -v17;
      }
    }
  }
  else
  {
LABEL_31:
    int v14 = 1;
  }
  if (!*((unsigned char *)this + 520) || !*((unsigned char *)this + 720) || !*((unsigned char *)this + 584)) {
    goto LABEL_49;
  }
  int v18 = !v4;
  if (*((double *)this + 72) <= 20.0) {
    int v18 = 1;
  }
  if (((v14 | !v5 | v18) & 1) == 0
    && *((double *)this + 64) > 5.0
    && (double v19 = fabs(v6), v19 > 0.034906585)
    && v19 < 0.174532925)
  {
    *a2 = v6;
    unsigned int LogLevel = cnprint::CNPrinter::GetLogLevel(this);
    uint64_t result = 1;
    if (LogLevel <= 1)
    {
      LOWORD(v35) = 12;
      unsigned __int8 v34 = 1;
      (*(void (**)(void **__return_ptr, raven::RavenDeltaVIOEstimateActiveObject *))(*(void *)this + 16))(&v40, this);
      if (!*((unsigned char *)this + 584)) {
        sub_18DFF28FC();
      }
      if (v41 >= 0) {
        long long v27 = &v40;
      }
      else {
        LOBYTE(v27) = (_BYTE)v40;
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v35, &v34, "%s: VIO t,%.3lf VIO yaw correction,%.3lf [deg] detected, distance moved,%.3lf, cross-track distance to passthrough,%.3lf, accum_yaw_corr,%.3lf [deg]", v22, v23, v24, v25, v26, (char)v27);
      if (SHIBYTE(v41) < 0) {
        operator delete(v40);
      }
      return 1;
    }
  }
  else
  {
LABEL_49:
    LOWORD(v35) = 12;
    unsigned __int8 v34 = 2;
    (*(void (**)(void **__return_ptr, raven::RavenDeltaVIOEstimateActiveObject *))(*(void *)this + 16))(&v40, this);
    if (v41 >= 0) {
      int64x2_t v33 = &v40;
    }
    else {
      LOBYTE(v33) = (_BYTE)v40;
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v35, &v34, "%s: curr_VIO t,%.3lf VIO yaw correction criteria, distance moved,%.3lf, cross-track distance to passthrough,%.3lf, course difference ,%.3lf, accum_yaw_corr,%.3lf, [deg] flags [%d %d %d %d %d]", v28, v29, v30, v31, v32, (char)v33);
    if (SHIBYTE(v41) < 0) {
      operator delete(v40);
    }
    return 0;
  }
  return result;
}

void sub_18E199C7C(_Unwind_Exception *exception_object)
{
}

unsigned char *raven::RavenDeltaVIOEstimateActiveObject::HandleEvent(unsigned char *this, const raven::ARSessionStatusEvent *a2)
{
  if (this[480])
  {
    uint64_t v3 = this;
    int v4 = *((unsigned __int8 *)a2 + 104);
    this[496] = v4;
    if (v4 != 2)
    {
      __int16 v18 = 12;
      unsigned __int8 v17 = 2;
      (*(void (**)(void **__return_ptr, unsigned char *))(*(void *)this + 16))(v15, this);
      int v5 = v16;
      char v6 = (char)v15[0];
      sub_18E13E6B8((uint64_t)a2, &__p);
      if (v5 >= 0) {
        double v12 = v15;
      }
      else {
        LOBYTE(v12) = v6;
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v18, &v17, "%s: AR Session is not Running, ARStatus, %s", v7, v8, v9, v10, v11, (char)v12);
      if (v14 < 0) {
        operator delete(__p);
      }
      if (v16 < 0) {
        operator delete(v15[0]);
      }
      return (unsigned char *)(*(uint64_t (**)(unsigned char *))(*(void *)v3 + 48))(v3);
    }
  }
  return this;
}

void sub_18E199DCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void raven::RavenDeltaVIOEstimateActiveObject::HandleEvent(raven::RavenDeltaVIOEstimateActiveObject *this, int8x16_t *a2, double a3, int8x16_t a4)
{
  if (!*((unsigned char *)this + 480))
  {
    *(_WORD *)uint64_t v74 = 12;
    v69[0] = 2;
    (*(void (**)(void **__return_ptr, raven::RavenDeltaVIOEstimateActiveObject *, int8x16_t *))(*(void *)this + 16))(__p, this, a2);
    if (v73 >= 0) {
      uint64_t v25 = __p;
    }
    else {
      LOBYTE(v25) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v74, v69, "%s: not configured", v20, v21, v22, v23, v24, (char)v25);
    if ((SHIBYTE(v73) & 0x80000000) == 0) {
      return;
    }
    uint64_t v26 = __p[0];
    goto LABEL_16;
  }
  uint64_t v5 = *((void *)this + 1241);
  if (!v5 || !*((unsigned char *)this + 736)) {
    return;
  }
  uint64_t v7 = &a2->i8[8];
  *(_OWORD *)std::string __p = *(_OWORD *)(*(void *)(*((void *)this + 1237)
                                         + (((unint64_t)(v5 + *((void *)this + 1240) - 1) >> 1) & 0x7FFFFFFFFFFFFFF8))
                             + 1088 * ((v5 + *((_DWORD *)this + 2480) - 1) & 0xF));
  uint64_t v8 = (cnprint::CNPrinter *)CNTimeSpan::operator-((uint64_t)&a2->i64[1], __p, *(int8x16_t *)__p, a4);
  if (v9 + (double)(uint64_t)v8 > 6.0)
  {
    if (cnprint::CNPrinter::GetLogLevel(v8) < 2)
    {
      *(_WORD *)int8x16_t v69 = 12;
      LOBYTE(v63) = 1;
      (*(void (**)(void **__return_ptr, raven::RavenDeltaVIOEstimateActiveObject *))(*(void *)this + 16))(__p, this);
      int v10 = SHIBYTE(v73);
      char v11 = (char)__p[0];
      unint64_t v12 = *((void *)this + 1241) + *((void *)this + 1240) - 1;
      *(_OWORD *)uint64_t v74 = *(_OWORD *)(*(void *)(*((void *)this + 1237) + ((v12 >> 1) & 0x7FFFFFFFFFFFFFF8))
                                 + 1088 * (v12 & 0xF));
      CNTimeSpan::operator-((uint64_t)v7, v74, *(int8x16_t *)v74, v13);
      if (v10 >= 0) {
        double v19 = __p;
      }
      else {
        LOBYTE(v19) = v11;
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v69, (unsigned __int8 *)&v63, "%s: ravel_sol t,%.3lf VIO Buffer is flushed due to no VIO activity for %.3lf [s]", v14, v15, v16, v17, v18, (char)v19);
      if (SHIBYTE(v73) < 0) {
        operator delete(__p[0]);
      }
    }
    (*(void (**)(raven::RavenDeltaVIOEstimateActiveObject *))(*(void *)this + 48))(this);
    return;
  }
  if (a2[13].i8[1] != 2 || !a2[91].i8[8]) {
    return;
  }
  int v27 = a2[13].u8[0];
  if ((v27 - 2) >= 2)
  {
    if (v27 == 1)
    {
      if (*((unsigned char *)this + 5616))
      {
        memcpy((char *)this + 3192, v7, 0x971uLL);
      }
      else
      {
        *((void *)this + 398) = &unk_1EDD14150;
        memcpy((char *)this + 3192, v7, 0x971uLL);
        *((unsigned char *)this + 5616) = 1;
      }
    }
  }
  else
  {
    if (!*((unsigned char *)this + 3176))
    {
      *((void *)this + 93) = &unk_1EDD14150;
      memcpy((char *)this + 752, v7, 0x971uLL);
      *((unsigned char *)this + 3176) = 1;
      return;
    }
    int8x16_t v28 = a2[73];
    int8x16_t v79 = *(int8x16_t *)((char *)this + 1912);
    int8x16_t v80 = v28;
    uint64_t v29 = CNTimeSpan::operator-((uint64_t)&v80, &v79, v79, v28);
    if (v30 + (double)v29 >= 3.0)
    {
      memcpy((char *)this + 752, v7, 0x971uLL);
      if (*((unsigned char *)this + 520))
      {
        uint64_t v75 = 0x100000003;
        *(_OWORD *)&v74[8] = xmmword_18E1F6F60;
        *(void *)uint64_t v74 = &unk_1EDD18D98;
        uint64_t v76 = (float64_t *)&v77;
        int8x16_t v77 = a2[92];
        uint64_t v78 = a2[93].i64[0];
        if (*((unsigned char *)this + 732))
        {
          if (!*((unsigned char *)this + 733)) {
            return;
          }
          goto LABEL_37;
        }
        sub_18DFE2F24((uint64_t)this + 9592, (uint64_t)v74);
        *((unsigned char *)this + 732) = 1;
        sub_18DFFDA0C((uint64_t)__p, *v76, v76[1], v76[2]);
        if (LOBYTE(__p[1]))
        {
          sub_18DFE2F24((uint64_t)this + 9720, (uint64_t)&v73);
          *((unsigned char *)this + 733) = 1;
LABEL_37:
          sub_18E01E318((uint64_t)v74, (uint64_t)this + 9592, (uint64_t)__p);
          sub_18E0300B4((uint64_t)this + 9720, (uint64_t)__p, (uint64_t)v69);
          uint64_t v31 = v71;
          long double v32 = hypot(*v71, v71[1]);
          *((long double *)this + 72) = v32;
          *((unsigned char *)this + 584) = 1;
          if (v32 >= 1.0)
          {
            long double v33 = v31[1];
            if (fabs(*v31) > 0.005 || fabs(v33) > 0.005)
            {
              double v34 = atan2(*v31, v33);
              *((double *)this + 70) = v34;
              *((unsigned char *)this + 568) = 1;
              if (v34 < 0.0) {
                *((double *)this + 70) = v34 + 6.28318531;
              }
            }
          }
          if (*((unsigned char *)this + 5616))
          {
            if (*((unsigned char *)this + 4648))
            {
              uint64_t v65 = 0x100000003;
              long long v64 = xmmword_18E1F6F60;
              uint64_t v63 = &unk_1EDD18D98;
              double v66 = (long double *)&v67;
              long long v67 = *((_OWORD *)this + 291);
              uint64_t v68 = *((void *)this + 584);
              sub_18E01E318((uint64_t)&v63, (uint64_t)this + 9592, (uint64_t)v62);
              sub_18E0300B4((uint64_t)this + 9720, (uint64_t)v62, (uint64_t)v60);
              long double v35 = *v61;
              long double v36 = v61[1];
              double v37 = hypot(*v61, v36);
              if (v37 >= 1.0 && (fabs(v35) > 0.005 || fabs(v36) > 0.005))
              {
                double v38 = atan2(v35, v36);
                *((double *)this + 66) = v38;
                *((unsigned char *)this + 536) = 1;
                if (v38 < 0.0)
                {
                  double v38 = v38 + 6.28318531;
                  *((double *)this + 66) = v38;
                }
                *((double *)this + 68) = v37;
                *((unsigned char *)this + 552) = 1;
                if (v37 > 0.0 && *((unsigned char *)this + 568))
                {
                  double v39 = vabdd_f64(*((double *)this + 70), v38);
                  if (6.28318531 - v39 >= v39) {
                    double v40 = v39;
                  }
                  else {
                    double v40 = 6.28318531 - v39;
                  }
                  *((double *)this + 64) = v37 * v40;
                }
              }
            }
          }
          uint64_t v41 = *((void *)this + 1237);
          unint64_t v42 = *((void *)this + 1240);
          long long v43 = (uint64_t *)(v41 + 8 * (v42 >> 4));
          if (*((void *)this + 1238) == v41)
          {
            uint64_t v44 = 0;
            uint64_t v47 = 0;
            uint64_t v46 = (char *)(v41 + 8 * ((*((void *)this + 1241) + v42) >> 4));
          }
          else
          {
            uint64_t v44 = *v43 + 1088 * (*((void *)this + 1240) & 0xFLL);
            unint64_t v45 = *((void *)this + 1241) + v42;
            uint64_t v46 = (char *)(v41 + 8 * (v45 >> 4));
            uint64_t v47 = *(void *)v46 + 1088 * (v45 & 0xF);
          }
          uint64_t v48 = sub_18E19A628(v43, v44, v46, v47, (double *)a2[73].i64);
          uint64_t v49 = *((void *)this + 1237);
          if (*((void *)this + 1238) == v49)
          {
            uint64_t v51 = 0;
          }
          else
          {
            unint64_t v50 = *((void *)this + 1241) + *((void *)this + 1240);
            uint64_t v51 = *(void *)(v49 + ((v50 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 1088 * (v50 & 0xF);
          }
          if (v51 != v48)
          {
            sub_18E01E318(v48 + 232, (uint64_t)this + 632, (uint64_t)&v63);
            long long v52 = v66;
            *((long double *)this + 87) = hypot(*v66, v66[1]);
            *((unsigned char *)this + 704) = 1;
            double v53 = atan2(*v52, v52[1]);
            *((double *)this + 77) = v53;
            *((unsigned char *)this + 624) = 1;
            if (v53 < 0.0) {
              *((double *)this + 77) = v53 + 6.28318531;
            }
          }
          return;
        }
        LOWORD(v63) = 12;
        v62[0] = 2;
        (*(void (**)(unsigned __int8 *__return_ptr, raven::RavenDeltaVIOEstimateActiveObject *))(*(void *)this + 16))(v69, this);
        if (v70 >= 0) {
          int8x16_t v59 = v69;
        }
        else {
          LOBYTE(v59) = v69[0];
        }
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v63, v62, "%s, curr_ravel_sol,%.3lf Raven Solution position Jecef2enu computation failed.", v54, v55, v56, v57, v58, (char)v59);
        if ((v70 & 0x80000000) == 0) {
          return;
        }
        uint64_t v26 = *(void **)v69;
LABEL_16:
        operator delete(v26);
      }
    }
  }
}

void sub_18E19A5D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  if (a44 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E19A628(uint64_t *a1, uint64_t a2, char *a3, uint64_t a4, double *a5)
{
  uint64_t v5 = a2;
  if (a4 != a2)
  {
    char v6 = a1;
    unint64_t v7 = 0xF0F0F0F0F0F0F0F1 * ((a4 - *(void *)a3) >> 6)
       + 2 * (a3 - (char *)a1)
       + 0xF0F0F0F0F0F0F0FLL * ((a2 - *a1) >> 6);
    if (v7)
    {
      do
      {
        unint64_t v9 = v7 >> 1;
        char v11 = v6;
        unint64_t v12 = (long long *)v5;
        sub_18E19E7DC(&v11, v7 >> 1);
        long long v13 = *v12;
        if (sub_18DEE4CB8((double *)&v13, a5))
        {
          char v6 = v11;
          uint64_t v5 = (uint64_t)(v12 + 68);
          unint64_t v12 = (long long *)v5;
          if (v5 - *v11 == 17408)
          {
            char v6 = v11 + 1;
            uint64_t v5 = v11[1];
          }
          unint64_t v9 = v7 + ~v9;
        }
        unint64_t v7 = v9;
      }
      while (v9);
    }
  }
  return v5;
}

void raven::RavenDeltaVIOEstimateActiveObject::HandleEvent(raven::RavenDeltaVIOEstimateActiveObject *this, const raven::VIOEstimateEvent *a2, double a3, int8x16_t a4)
{
  if (!*((unsigned char *)this + 480)) {
    return;
  }
  if (*((unsigned char *)a2 + 1184))
  {
    if (*((unsigned char *)a2 + 296) == 1)
    {
      char v6 = (long long *)((char *)a2 + 104);
      unint64_t v7 = (void *)((char *)this + 9888);
      uint64_t v8 = *((void *)this + 1241);
      if (v8)
      {
        uint64_t v9 = *((void *)a2 + 13);
        unint64_t v10 = v8 + *((void *)this + 1240) - 1;
        uint64_t v11 = *(void *)(*((void *)this + 1237) + ((v10 >> 1) & 0x7FFFFFFFFFFFFFF8));
        double v12 = *((double *)a2 + 14);
        unsigned int v13 = v10 & 0xF;
        uint64_t v14 = (uint64_t *)(v11 + 1088 * v13);
        uint64_t v15 = *v14;
        a4.i64[0] = v14[1];
        if ((v9 || (*(void *)&v12 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
          && (!v15 ? (BOOL v16 = (a4.i64[0] & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000) : (BOOL v16 = 1), v16 && v9 != v15))
        {
          if (v9 < v15)
          {
LABEL_14:
            if (cnprint::CNPrinter::GetLogLevel(this) < 2)
            {
              LOWORD(v184[0]) = 12;
              LOBYTE(v187) = 1;
              (*(void (**)(void **__return_ptr, raven::RavenDeltaVIOEstimateActiveObject *))(*(void *)this + 16))(__p, this);
              if (v189 >= 0) {
                uint64_t v22 = __p;
              }
              else {
                LOBYTE(v22) = __p[0];
              }
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)v184, (unsigned __int8 *)&v187, "%s, Current VIO estimate's Time %.3lf is before the previous VIO estimate %.3lf", v17, v18, v19, v20, v21, (char)v22);
              if (v189 < 0) {
                operator delete(__p[0]);
              }
            }
            goto LABEL_89;
          }
        }
        else if (v12 < *(double *)a4.i64)
        {
          goto LABEL_14;
        }
        *(_OWORD *)std::string __p = *(_OWORD *)((char *)a2 + 200);
        *(_OWORD *)long long v184 = *(_OWORD *)(v11 + 1088 * v13 + 96);
        uint64_t v56 = (cnprint::CNPrinter *)CNTimeSpan::operator-((uint64_t)__p, v184, *(int8x16_t *)v184, a4);
        v58.i64[0] = 0x3CB0000000000000;
        if (fabs(v57 + (double)(uint64_t)v56) < 2.22044605e-16)
        {
          double v37 = (char *)this + 488;
          goto LABEL_58;
        }
        if (cnprint::CNPrinter::GetLogLevel(v56) < 2)
        {
          LOWORD(v184[0]) = 12;
          LOBYTE(v187) = 1;
          (*(void (**)(void **__return_ptr, raven::RavenDeltaVIOEstimateActiveObject *))(*(void *)this
                                                                                                  + 16))(__p, this);
          if (v189 >= 0) {
            long long v64 = __p;
          }
          else {
            LOBYTE(v64) = __p[0];
          }
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)v184, (unsigned __int8 *)&v187, "%s, VIO estimate session start time changed, possible change in VIO reference frame, time, current VIO %.3lf previous VIO %.3lf", v59, v60, v61, v62, v63, (char)v64);
          if (v189 < 0) {
            operator delete(__p[0]);
          }
        }
        (*(void (**)(raven::RavenDeltaVIOEstimateActiveObject *))(*(void *)this + 48))(this);
        uint64_t v8 = *((void *)this + 1241);
        double v37 = (char *)this + 488;
        if (v8)
        {
LABEL_58:
          uint64_t v65 = *(void *)(*((void *)this + 61) + 3184);
          double v66 = (cnprint::CNPrinter *)*((void *)a2 + 13);
          double v67 = *((double *)a2 + 14);
          *(_OWORD *)std::string __p = *(_OWORD *)(*(void *)(*((void *)this + 1237)
                                                 + (((unint64_t)(v8 + *((void *)this + 1240) - 1) >> 1) & 0x7FFFFFFFFFFFFFF8))
                                     + 1088 * ((v8 + *((_DWORD *)this + 2480) - 1) & 0xF));
          v68.i64[1] = (uint64_t)__p[1];
          v184[0] = 0;
          v184[1] = 0;
          v68.i64[0] = v65;
          CNTimeSpan::SetTimeSpan((uint64_t *)v184, 0, v68, v58);
          long long v71 = (cnprint::CNPrinter *)CNTimeSpan::operator+((uint64_t)__p, v184, v69, v70);
          double v74 = v72;
          if (!v66 && (*(void *)&v67 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
            || !v71 && (*(void *)&v72 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
            || (BOOL v75 = (uint64_t)v66 <= (uint64_t)v71, v66 == v71))
          {
            BOOL v75 = v67 <= v72;
          }
          if (v75) {
            goto LABEL_84;
          }
          if (cnprint::CNPrinter::GetLogLevel(v71) < 2)
          {
            LOWORD(v184[0]) = 12;
            LOBYTE(v187) = 1;
            (*(void (**)(void **__return_ptr, raven::RavenDeltaVIOEstimateActiveObject *))(*(void *)this + 16))(__p, this);
            if (v189 >= 0) {
              int8x16_t v81 = __p;
            }
            else {
              LOBYTE(v81) = __p[0];
            }
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)v184, (unsigned __int8 *)&v187, "%s, Large gap in incoming VIO estimate, time, current VIO %.3lf previous VIO %.3lf, gap tolerance, %.3lf", v76, v77, v78, v79, v80, (char)v81);
            if (v189 < 0) {
              operator delete(__p[0]);
            }
          }
          (*(void (**)(raven::RavenDeltaVIOEstimateActiveObject *))(*(void *)this + 48))(this);
          unint64_t v38 = *((void *)this + 1241);
          if (v38)
          {
LABEL_84:
            if ((raven::RavenDeltaVIOEstimateActiveObject::IsVIOPositionConsistent(this, (uint64_t)a2 + 104, v74, v73) & 1) == 0)
            {
LABEL_89:
              (*(void (**)(raven::RavenDeltaVIOEstimateActiveObject *))(*(void *)this + 48))(this);
              return;
            }
            unint64_t v38 = *((void *)this + 1241);
            if (v38 >= 0x19)
            {
              uint64_t v97 = (v38 - 24);
              if ((int)v97 >= 1)
              {
                uint64_t v98 = *((void *)this + 1237);
                unint64_t v99 = *((void *)this + 1240);
                uint64_t v100 = (char *)(v98 + 8 * (v99 >> 4));
                if (*((void *)this + 1238) == v98) {
                  uint64_t v101 = 0;
                }
                else {
                  uint64_t v101 = (void *)(*(void *)v100 + 1088 * (*((void *)this + 1240) & 0xFLL));
                }
                __p[0] = (void *)(v98 + 8 * (v99 >> 4));
                __p[1] = v101;
                sub_18E19E7DC((uint64_t **)__p, v97);
                sub_18E19BB7C((void *)this + 1236, v100, (uint64_t *)v101, (char *)__p[0], (uint64_t *)__p[1]);
                unint64_t v38 = *((void *)this + 1241);
              }
            }
          }
LABEL_34:
          double v39 = (char *)*((void *)this + 1238);
          double v40 = (char *)*((void *)this + 1237);
          uint64_t v41 = v39 - v40;
          if (v39 == v40) {
            uint64_t v42 = 0;
          }
          else {
            uint64_t v42 = 2 * (v39 - v40) - 1;
          }
          unint64_t v43 = *((void *)this + 1240);
          if (v42 != v38 + v43) {
            goto LABEL_146;
          }
          if (v43 < 0x10)
          {
            long long v183 = v37;
            uint64_t v82 = v41 >> 3;
            long long v83 = (char *)*((void *)this + 1239);
            long long v84 = (char *)*((void *)this + 1236);
            if (v41 >> 3 >= (unint64_t)((v83 - v84) >> 3))
            {
              if (v83 == v84) {
                unint64_t v87 = 1;
              }
              else {
                unint64_t v87 = (v83 - v84) >> 2;
              }
              uint64_t v88 = (char *)sub_18DEE2FBC(v87);
              uint64_t v90 = v89;
              uint64_t v91 = operator new(0x4400uLL);
              long long v92 = &v88[8 * v82];
              double v93 = &v88[8 * v90];
              if (v82 == v90)
              {
                uint64_t v94 = 8 * v82;
                if (v41 < 1)
                {
                  uint64_t v134 = v91;
                  uint64_t v135 = v94 >> 2;
                  if (v39 == v40) {
                    unint64_t v136 = 1;
                  }
                  else {
                    unint64_t v136 = v135;
                  }
                  double v137 = (char *)sub_18DEE2FBC(v136);
                  long long v92 = &v137[8 * (v136 >> 2)];
                  double v93 = &v137[8 * v138];
                  if (v88) {
                    operator delete(v88);
                  }
                  uint64_t v88 = v137;
                  uint64_t v91 = v134;
                }
                else
                {
                  uint64_t v95 = v94 >> 3;
                  if (v95 >= -1) {
                    unint64_t v96 = v95 + 1;
                  }
                  else {
                    unint64_t v96 = v95 + 2;
                  }
                  v92 -= 8 * (v96 >> 1);
                }
              }
              *(void *)long long v92 = v91;
              double v39 = v92 + 8;
              for (uint64_t i = *((void *)this + 1238); i != *((void *)this + 1237); i -= 8)
              {
                if (v92 == v88)
                {
                  if (v39 >= v93)
                  {
                    if (v93 == v88) {
                      unint64_t v144 = 1;
                    }
                    else {
                      unint64_t v144 = (v93 - v88) >> 2;
                    }
                    uint64_t v145 = (char *)sub_18DEE2FBC(v144);
                    uint64_t v147 = v145;
                    long long v92 = &v145[(2 * v144 + 6) & 0xFFFFFFFFFFFFFFF8];
                    uint64_t v149 = v39 - v88;
                    BOOL v148 = v39 == v88;
                    double v39 = v92;
                    if (!v148)
                    {
                      double v39 = &v92[v149 & 0xFFFFFFFFFFFFFFF8];
                      uint64_t v150 = 8 * (v149 >> 3);
                      double v151 = v92;
                      long long v152 = v88;
                      do
                      {
                        uint64_t v153 = *(void *)v152;
                        v152 += 8;
                        *(void *)double v151 = v153;
                        v151 += 8;
                        v150 -= 8;
                      }
                      while (v150);
                    }
                    double v93 = &v145[8 * v146];
                    if (v88) {
                      operator delete(v88);
                    }
                    uint64_t v88 = v147;
                  }
                  else
                  {
                    uint64_t v140 = (v93 - v39) >> 3;
                    if (v140 >= -1) {
                      uint64_t v141 = v140 + 1;
                    }
                    else {
                      uint64_t v141 = v140 + 2;
                    }
                    uint64_t v142 = v141 >> 1;
                    long long v92 = &v88[8 * (v141 >> 1)];
                    uint64_t v143 = v88;
                    if (v39 != v88)
                    {
                      memmove(v92, v88, v39 - v88);
                      uint64_t v143 = v39;
                    }
                    double v39 = &v143[8 * v142];
                  }
                }
                uint64_t v154 = *(void *)(i - 8);
                *((void *)v92 - 1) = v154;
                v92 -= 8;
              }
              uint64_t v155 = (void *)*((void *)this + 1236);
              *((void *)this + 1236) = v88;
              *((void *)this + 1237) = v92;
              *((void *)this + 1238) = v39;
              *((void *)this + 1239) = v93;
              double v37 = v183;
              char v6 = (long long *)((char *)a2 + 104);
              if (v155)
              {
                operator delete(v155);
                double v39 = (char *)*((void *)this + 1238);
              }
              goto LABEL_145;
            }
            long long v85 = operator new(0x4400uLL);
            long long v86 = v85;
            if (v83 != v39)
            {
              *(void *)double v39 = v85;
              double v39 = (char *)(*((void *)this + 1238) + 8);
              *((void *)this + 1238) = v39;
              double v37 = v183;
              char v6 = (long long *)((char *)a2 + 104);
LABEL_145:
              double v40 = (char *)*((void *)this + 1237);
LABEL_146:
              if (v39 == v40)
              {
                uint64_t v157 = 0;
              }
              else
              {
                unint64_t v156 = *((void *)this + 1241) + *((void *)this + 1240);
                uint64_t v157 = *(void *)&v40[(v156 >> 1) & 0x7FFFFFFFFFFFFFF8] + 1088 * (v156 & 0xF);
              }
              sub_18E0C6F80(v157, (uint64_t)v6);
              ++*((void *)this + 1241);
              if (*((unsigned char *)this + 608))
              {
                *(_OWORD *)std::string __p = *(_OWORD *)(*(void *)(*((void *)this + 1237)
                                                       + ((*((void *)this + 1240) >> 1) & 0x7FFFFFFFFFFFFFF8))
                                           + 1088 * (*((void *)this + 1240) & 0xFLL));
                BOOL v158 = sub_18DEE4C00((double *)__p, (double *)this + 74);
                if (v158)
                {
                  unint64_t v161 = *((void *)this + 1241) + *((void *)this + 1240) - 1;
                  BOOL v162 = raven::RavenDeltaVIOEstimateActiveObject::ApplyDefaultUncertaintyInflation(v158, *(void *)(*((void *)this + 1237) + ((v161 >> 1) & 0x7FFFFFFFFFFFFFF8))+ 1088 * (v161 & 0xF));
                  if (v162
                    && raven::RavenDeltaVIOEstimateActiveObject::ApplyDefaultUncertaintyInflation(v162, *(void *)(*((void *)this + 1237) + ((*((void *)this + 1240) >> 1) & 0x7FFFFFFFFFFFFFF8))+ 1088 * (*((void *)this + 1240) & 0xFLL)))
                  {
                    raven::RavenDeltaVIOEstimateActiveObject::VIOUserCourseTurnDetection((uint64_t)this, *(void *)(*((void *)this + 1237)+ (((unint64_t)(*((void *)this + 1241) + *((void *)this + 1240) - 1) >> 1) & 0x7FFFFFFFFFFFFFF8))+ 1088 * ((*((_DWORD *)this + 2482) + *((void *)this + 1240) - 1) & 0xF), *(void *)(*((void *)this + 1237) + ((*((void *)this + 1240) >> 1) & 0x7FFFFFFFFFFFFFF8))+ 1088 * (*((void *)this + 1240) & 0xFLL), v163, v160);
                  }
                  int v164 = *((unsigned __int8 *)this + 608);
                  long long v159 = *v6;
                  *((_OWORD *)this + 37) = *v6;
                  if (!v164) {
                    *((unsigned char *)this + 608) = 1;
                  }
                }
              }
              else
              {
                *((_OWORD *)this + 37) = *(_OWORD *)((char *)a2 + 104);
                *((unsigned char *)this + 608) = 1;
                *(void *)&long long v159 = sub_18DFE2F24((uint64_t)this + 632, (uint64_t)a2 + 336).n128_u64[0];
              }
              if (*((unsigned char *)this + 736)
                || *((unsigned char *)this + 6728)
                && (*(_OWORD *)std::string __p = *((_OWORD *)this + 358),
                    *(_OWORD *)long long v184 = *v6,
                    uint64_t v171 = CNTimeSpan::operator-((uint64_t)__p, v184, *(int8x16_t *)v184, v160),
                    v160.i64[0] = *(void *)(*((void *)this + 61) + 3184),
                    *(double *)&long long v159 = fabs(v172 + (double)v171),
                    *(double *)&v159 <= *(double *)v160.i64)
                && (raven::RavenDeltaVIOEstimateActiveObject::HandleEvent(this, (raven::RavenDeltaVIOEstimateActiveObject *)((char *)this + 5624)), *((unsigned char *)this + 736)))
              {
                if (!*((unsigned char *)this + 6728)) {
                  goto LABEL_161;
                }
                __p[0] = (void *)(*(uint64_t (**)(const raven::VIOEstimateEvent *))(*(void *)a2 + 16))(a2);
                __p[1] = v165;
                if (!*((unsigned char *)this + 6728)) {
                  sub_18DFF28FC();
                }
                v184[0] = (void *)(*(uint64_t (**)(char *))(*((void *)this + 703) + 16))((char *)this + 5624);
                v184[1] = v166;
                uint64_t v169 = CNTimeSpan::operator-((uint64_t)__p, v184, v167, v168);
                *(double *)&long long v159 = v170 + (double)v169;
                v160.i64[0] = *((void *)this + 1235);
                if (*(double *)&v159 >= *(double *)v160.i64) {
LABEL_161:
                }
                  raven::RavenDeltaVIOEstimateActiveObject::CreateAndRaisePositionEvent((uint64_t)this, *(double *)&v159, v160);
              }
              if (*(unsigned char *)(*(void *)v37 + 3804) || *(unsigned char *)(*(void *)v37 + 3789)) {
                raven::RavenDeltaVIOEstimateActiveObject::CreateAndRaiseDeltaVIOEstimates((int8x16_t *)this, *(double *)&v159, v160);
              }
              return;
            }
            if (v40 == v84)
            {
              if (v39 == v40) {
                unint64_t v112 = 1;
              }
              else {
                unint64_t v112 = (v83 - v40) >> 2;
              }
              uint64_t v113 = 2 * v112;
              long long v114 = (char *)sub_18DEE2FBC(v112);
              double v40 = &v114[(v113 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v116 = (uint64_t *)*((void *)this + 1237);
              uint64_t v117 = v40;
              uint64_t v118 = *((void *)this + 1238) - (void)v116;
              if (v118)
              {
                uint64_t v117 = &v40[v118 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v119 = 8 * (v118 >> 3);
                double v120 = &v114[(v113 + 6) & 0xFFFFFFFFFFFFFFF8];
                do
                {
                  uint64_t v121 = *v116++;
                  *(void *)double v120 = v121;
                  v120 += 8;
                  v119 -= 8;
                }
                while (v119);
              }
              long long v122 = (void *)*((void *)this + 1236);
              *((void *)this + 1236) = v114;
              *((void *)this + 1237) = v40;
              *((void *)this + 1238) = v117;
              *((void *)this + 1239) = &v114[8 * v115];
              if (v122)
              {
                operator delete(v122);
                double v40 = (char *)*((void *)this + 1237);
              }
            }
            *((void *)v40 - 1) = v86;
            uint64_t v123 = (char *)*((void *)this + 1237);
            *((void *)this + 1237) = v123 - 8;
            uint64_t v124 = *((void *)v123 - 1);
            *((void *)this + 1237) = v123;
            uint64_t v125 = (char *)*((void *)this + 1238);
            double v37 = v183;
            char v6 = (long long *)((char *)a2 + 104);
            if (v125 == *((char **)this + 1239))
            {
              uint64_t v126 = (uint64_t)&v123[-*v7];
              if ((unint64_t)v123 <= *v7)
              {
                if (v125 == (char *)*v7) {
                  unint64_t v173 = 1;
                }
                else {
                  unint64_t v173 = (uint64_t)&v125[-*v7] >> 2;
                }
                double v174 = (char *)sub_18DEE2FBC(v173);
                uint64_t v176 = &v174[8 * (v173 >> 2)];
                BOOL v177 = (uint64_t *)*((void *)this + 1237);
                uint64_t v125 = v176;
                uint64_t v178 = *((void *)this + 1238) - (void)v177;
                if (v178)
                {
                  uint64_t v125 = &v176[v178 & 0xFFFFFFFFFFFFFFF8];
                  uint64_t v179 = 8 * (v178 >> 3);
                  uint64_t v180 = &v174[8 * (v173 >> 2)];
                  do
                  {
                    uint64_t v181 = *v177++;
                    *(void *)uint64_t v180 = v181;
                    v180 += 8;
                    v179 -= 8;
                  }
                  while (v179);
                }
                double v182 = (void *)*((void *)this + 1236);
                *((void *)this + 1236) = v174;
                *((void *)this + 1237) = v176;
                *((void *)this + 1238) = v125;
                *((void *)this + 1239) = &v174[8 * v175];
                if (v182)
                {
                  operator delete(v182);
                  uint64_t v125 = (char *)*((void *)this + 1238);
                }
              }
              else
              {
                uint64_t v127 = v126 >> 3;
                BOOL v16 = v126 >> 3 < -1;
                uint64_t v128 = (v126 >> 3) + 2;
                if (v16) {
                  uint64_t v129 = v128;
                }
                else {
                  uint64_t v129 = v127 + 1;
                }
                uint64_t v130 = -(v129 >> 1);
                uint64_t v131 = v129 >> 1;
                long long v132 = &v123[-8 * v131];
                int64_t v133 = v125 - v123;
                if (v125 != v123)
                {
                  memmove(&v123[-8 * v131], v123, v125 - v123);
                  uint64_t v123 = (char *)*((void *)this + 1237);
                }
                uint64_t v125 = &v132[v133];
                *((void *)this + 1238) = &v132[v133];
                *((void *)this + 1237) = &v123[8 * v130];
              }
            }
            *(void *)uint64_t v125 = v124;
          }
          else
          {
            *((void *)this + 1240) = v43 - 16;
            uint64_t v46 = *(void *)v40;
            uint64_t v44 = v40 + 8;
            uint64_t v45 = v46;
            *((void *)this + 1237) = v44;
            if (v39 == *((char **)this + 1239))
            {
              uint64_t v47 = (uint64_t)&v44[-*v7];
              if ((unint64_t)v44 <= *v7)
              {
                if (v39 == (char *)*v7) {
                  unint64_t v102 = 1;
                }
                else {
                  unint64_t v102 = (uint64_t)&v39[-*v7] >> 2;
                }
                uint64_t v103 = (char *)sub_18DEE2FBC(v102);
                double v105 = &v103[8 * (v102 >> 2)];
                double v106 = (uint64_t *)*((void *)this + 1237);
                double v39 = v105;
                uint64_t v107 = *((void *)this + 1238) - (void)v106;
                if (v107)
                {
                  double v39 = &v105[v107 & 0xFFFFFFFFFFFFFFF8];
                  uint64_t v108 = 8 * (v107 >> 3);
                  double v109 = &v103[8 * (v102 >> 2)];
                  do
                  {
                    uint64_t v110 = *v106++;
                    *(void *)double v109 = v110;
                    v109 += 8;
                    v108 -= 8;
                  }
                  while (v108);
                }
                double v111 = (void *)*((void *)this + 1236);
                *((void *)this + 1236) = v103;
                *((void *)this + 1237) = v105;
                *((void *)this + 1238) = v39;
                *((void *)this + 1239) = &v103[8 * v104];
                if (v111)
                {
                  operator delete(v111);
                  double v39 = (char *)*((void *)this + 1238);
                }
              }
              else
              {
                uint64_t v48 = v47 >> 3;
                BOOL v16 = v47 >> 3 < -1;
                uint64_t v49 = (v47 >> 3) + 2;
                if (v16) {
                  uint64_t v50 = v49;
                }
                else {
                  uint64_t v50 = v48 + 1;
                }
                uint64_t v51 = -(v50 >> 1);
                uint64_t v52 = v50 >> 1;
                double v53 = &v44[-8 * v52];
                int64_t v54 = v39 - v44;
                if (v39 != v44)
                {
                  memmove(&v44[-8 * v52], v44, v39 - v44);
                  double v39 = (char *)*((void *)this + 1237);
                }
                uint64_t v55 = &v39[8 * v51];
                double v39 = &v53[v54];
                *((void *)this + 1238) = &v53[v54];
                *((void *)this + 1237) = v55;
              }
            }
            *(void *)double v39 = v45;
          }
          double v39 = (char *)(*((void *)this + 1238) + 8);
          *((void *)this + 1238) = v39;
          goto LABEL_145;
        }
      }
      else
      {
        double v37 = (char *)this + 488;
      }
      unint64_t v38 = 0;
      goto LABEL_34;
    }
    if (cnprint::CNPrinter::GetLogLevel(this) > 1) {
      return;
    }
    __int16 v187 = 12;
    unsigned __int8 v186 = 1;
    (*(void (**)(void **__return_ptr, raven::RavenDeltaVIOEstimateActiveObject *))(*(void *)this + 16))(__p, this);
    int v29 = v189;
    char v30 = (char)__p[0];
    sub_18DEDE7B0(v184, off_1E55B9E58[*((char *)a2 + 296)]);
    if (v29 >= 0) {
      long double v36 = __p;
    }
    else {
      LOBYTE(v36) = v30;
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v187, &v186, "%s, Current VIO estimate is not in Nominal Tracking State [Status: %s]", v31, v32, v33, v34, v35, (char)v36);
    if (v185 < 0) {
      operator delete(v184[0]);
    }
  }
  else
  {
    LOWORD(v184[0]) = 12;
    LOBYTE(v187) = 2;
    (*(void (**)(void **__return_ptr, raven::RavenDeltaVIOEstimateActiveObject *))(*(void *)this + 16))(__p, this);
    if (v189 >= 0) {
      int8x16_t v28 = __p;
    }
    else {
      LOBYTE(v28) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v184, (unsigned __int8 *)&v187, "%s, Current VIO estimate of IMU pose is not Valid.", v23, v24, v25, v26, v27, (char)v28);
  }
  if (v189 < 0) {
    operator delete(__p[0]);
  }
}

void sub_18E19B524(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  operator delete(v27);
  if (v28) {
    operator delete(v28);
  }
  _Unwind_Resume(a1);
}

uint64_t raven::RavenDeltaVIOEstimateActiveObject::IsVIOPositionConsistent(void *a1, uint64_t a2, double a3, int8x16_t a4)
{
  uint64_t v4 = a1[1241];
  if (!v4) {
    return 1;
  }
  uint64_t v7 = a2 + 232;
  *(_OWORD *)uint64_t v52 = *(_OWORD *)a2;
  uint64_t v8 = (_OWORD *)(*(void *)(a1[1237] + (((unint64_t)(v4 + a1[1240] - 1) >> 1) & 0x7FFFFFFFFFFFFFF8))
                + 1088 * ((v4 + *((_DWORD *)a1 + 2480) - 1) & 0xF));
  *(_OWORD *)uint64_t v56 = *v8;
  uint64_t v9 = CNTimeSpan::operator-((uint64_t)v52, v56, *(int8x16_t *)v56, a4);
  double v11 = v10;
  uint64_t v44 = 0x100000003;
  uint64_t v42 = &unk_1EDD18D98;
  long long v43 = xmmword_18E1F6F60;
  uint64_t v45 = &v46;
  sub_18DFE2AA8(v7, (uint64_t)v8 + 232, (uint64_t)&v42);
  uint64_t v57 = 0x100000003;
  *(_OWORD *)&v56[8] = xmmword_18E1F6F60;
  *(void *)uint64_t v56 = &unk_1EDD18D98;
  int8x16_t v58 = v59;
  uint64_t v53 = 0x100000134;
  *(_OWORD *)&v52[8] = xmmword_18E1F6FB0;
  *(void *)uint64_t v52 = &unk_1EDD18C48;
  int64_t v54 = v55;
  uint64_t v49 = 0x100000003;
  uint64_t v47 = &unk_1EDD18D98;
  long long v48 = xmmword_18E1F6F60;
  uint64_t v50 = v51;
  sub_18DFE345C((uint64_t)&v42, (uint64_t)v56, (uint64_t)v52, (uint64_t)&v47, "2");
  double v13 = fabs((v11 + (double)v9) * 2.5) * 3.0;
  if (v14 <= v13)
  {
    if (*(unsigned char *)(a2 + 1081))
    {
      unint64_t v24 = a1[1241] + a1[1240] - 1;
      if (*(unsigned char *)(*(void *)(a1[1237] + ((v24 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 1088 * (v24 & 0xF) + 1081))
      {
        uint64_t v57 = 0x100000003;
        *(_OWORD *)&v56[8] = xmmword_18E1F6F60;
        *(void *)uint64_t v56 = &unk_1EDD18D98;
        int8x16_t v58 = v59;
        uint64_t v53 = 0x100000134;
        *(_OWORD *)&v52[8] = xmmword_18E1F6FB0;
        *(void *)uint64_t v52 = &unk_1EDD18C48;
        int64_t v54 = v55;
        uint64_t v49 = 0x100000003;
        uint64_t v47 = &unk_1EDD18D98;
        long long v48 = xmmword_18E1F6F60;
        uint64_t v50 = v51;
        sub_18DFE345C(a2 + 672, (uint64_t)v56, (uint64_t)v52, (uint64_t)&v47, "2");
        double v26 = v25;
        unint64_t v27 = a1[1241] + a1[1240] - 1;
        uint64_t v28 = *(void *)(a1[1237] + ((v27 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 1088 * (v27 & 0xF) + 672;
        uint64_t v57 = 0x100000003;
        *(_OWORD *)&v56[8] = xmmword_18E1F6F60;
        *(void *)uint64_t v56 = &unk_1EDD18D98;
        int8x16_t v58 = v59;
        uint64_t v53 = 0x100000134;
        *(_OWORD *)&v52[8] = xmmword_18E1F6FB0;
        *(void *)uint64_t v52 = &unk_1EDD18C48;
        int64_t v54 = v55;
        uint64_t v49 = 0x100000003;
        uint64_t v47 = &unk_1EDD18D98;
        long long v48 = xmmword_18E1F6F60;
        uint64_t v50 = v51;
        sub_18DFE345C(v28, (uint64_t)v56, (uint64_t)v52, (uint64_t)&v47, "2");
        if (vabdd_f64(v26, v30) > v13)
        {
          if (cnprint::CNPrinter::GetLogLevel(v29) > 1) {
            return 0;
          }
          *(_WORD *)uint64_t v56 = 12;
          LOBYTE(v47) = 1;
          (*(void (**)(unsigned char *__return_ptr, void *))(*a1 + 16))(v52, a1);
          if (v52[23] >= 0) {
            double v37 = v52;
          }
          else {
            LOBYTE(v37) = v52[0];
          }
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)v56, (unsigned __int8 *)&v47, "%s, Device position jump in ARKit camera frame for the incoming VIO estimate, t current VIO %.3lf delta-time,%.3lf, distance moved,%.3lf > %.3lf", v32, v33, v34, v35, v36, (char)v37);
          if ((v52[23] & 0x80000000) == 0) {
            return 0;
          }
          uint64_t v23 = *(void **)v52;
          goto LABEL_8;
        }
      }
    }
    return 1;
  }
  if (cnprint::CNPrinter::GetLogLevel(v12) > 1) {
    return 0;
  }
  __int16 v41 = 12;
  unsigned __int8 v40 = 1;
  (*(void (**)(void **__return_ptr, void *))(*a1 + 16))(__p, a1);
  int v15 = v39;
  char v16 = (char)__p[0];
  uint64_t v57 = 0x100000003;
  *(_OWORD *)&v56[8] = xmmword_18E1F6F60;
  *(void *)uint64_t v56 = &unk_1EDD18D98;
  int8x16_t v58 = v59;
  uint64_t v53 = 0x100000134;
  *(_OWORD *)&v52[8] = xmmword_18E1F6FB0;
  *(void *)uint64_t v52 = &unk_1EDD18C48;
  int64_t v54 = v55;
  uint64_t v49 = 0x100000003;
  uint64_t v47 = &unk_1EDD18D98;
  long long v48 = xmmword_18E1F6F60;
  uint64_t v50 = v51;
  sub_18DFE345C((uint64_t)&v42, (uint64_t)v56, (uint64_t)v52, (uint64_t)&v47, "2");
  uint64_t v22 = __p;
  if (v15 < 0) {
    LOBYTE(v22) = v16;
  }
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v41, &v40, "%s, IMU position jump in incoming VIO estimate, t current VIO %.3lf delta-time,%.3lf, distance moved,%.3lf > %.3lf", v17, v18, v19, v20, v21, (char)v22);
  if ((v39 & 0x80000000) == 0) {
    return 0;
  }
  uint64_t v23 = __p[0];
LABEL_8:
  operator delete(v23);
  return 0;
}

void sub_18E19BB40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (a47 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **sub_18E19BB7C(void *a1, char *a2, uint64_t *a3, char *a4, uint64_t *a5)
{
  if (a5 == a3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = 0xF0F0F0F0F0F0F0F1 * (((uint64_t)a5 - *(void *)a4) >> 6)
  }
       + 2 * (a4 - a2)
       + 0xF0F0F0F0F0F0F0FLL * (((uint64_t)a3 - *(void *)a2) >> 6);
  unint64_t v7 = a1[4];
  uint64_t v9 = (void **)a1[1];
  uint64_t v8 = (void **)a1[2];
  double v10 = (uint64_t *)&v9[v7 >> 4];
  if (v8 == v9) {
    double v11 = 0;
  }
  else {
    double v11 = (uint64_t *)(*v10 + 1088 * (a1[4] & 0xFLL));
  }
  if (a3 == v11) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = 0xF0F0F0F0F0F0F0F1 * (((uint64_t)a3 - *(void *)a2) >> 6)
  }
        + 2 * (a2 - (char *)v10)
        + 0xF0F0F0F0F0F0F0FLL * (((uint64_t)v11 - *v10) >> 6);
  uint64_t v45 = (uint64_t *)&v9[v7 >> 4];
  uint64_t v46 = v11;
  sub_18E19E7DC(&v45, v12);
  if (v6 >= 1)
  {
    double v13 = v45;
    uint64_t v14 = (uint64_t)v46;
    unint64_t v15 = v12;
    uint64_t v16 = a1[5];
    if (v15 <= (unint64_t)(v16 - v6) >> 1)
    {
      uint64_t v12 = v15;
      sub_18E19E7DC(&v45, v6);
      uint64_t v20 = v45;
      uint64_t i = (uint64_t)v46;
      if (v10 == v13)
      {
        uint64_t v26 = (uint64_t)v11;
        uint64_t v25 = v14;
      }
      else
      {
        uint64_t v23 = *v13;
        uint64_t v22 = v13 - 1;
        sub_18E19E8B8(&v45, v23, v14, v45, (uint64_t)v46);
        uint64_t v20 = v46;
        for (uint64_t i = (uint64_t)v47; v22 != v10; uint64_t i = (uint64_t)v47)
        {
          uint64_t v24 = *v22--;
          sub_18E19E8B8(&v45, v24, v24 + 17408, v20, i);
          uint64_t v20 = v46;
        }
        uint64_t v25 = *v10 + 17408;
        uint64_t v26 = (uint64_t)v11;
      }
      sub_18E19E8B8(&v45, v26, v25, v20, i);
      uint64_t v33 = v47;
      while (v11 != v33)
      {
        sub_18E0B8DAC(v11);
        v11 += 136;
        if ((uint64_t *)((char *)v11 - *v10) == (uint64_t *)17408)
        {
          uint64_t v34 = (uint64_t *)v10[1];
          ++v10;
          double v11 = v34;
        }
      }
      uint64_t v35 = a1[5] - v6;
      unint64_t v7 = a1[4] + v6;
      a1[4] = v7;
      a1[5] = v35;
      uint64_t v9 = (void **)a1[1];
      if (v7 >= 0x20)
      {
        do
        {
          operator delete(*v9);
          uint64_t v9 = (void **)(a1[1] + 8);
          a1[1] = v9;
          unint64_t v7 = a1[4] - 16;
          a1[4] = v7;
        }
        while (v7 > 0x1F);
      }
    }
    else
    {
      uint64_t v44 = v15;
      sub_18E19E7DC(&v45, v6);
      uint64_t v17 = (uint64_t)v46;
      uint64_t v18 = (uint64_t *)&v9[(v16 + v7) >> 4];
      if (v8 == v9) {
        uint64_t v19 = 0;
      }
      else {
        uint64_t v19 = *v18 + 1088 * (((_BYTE)v16 + (_BYTE)v7) & 0xF);
      }
      uint64_t v27 = v6;
      if (v18 == v45)
      {
        uint64_t v32 = v19;
        int v29 = v13;
        uint64_t j = v14;
      }
      else
      {
        uint64_t v28 = v45 + 1;
        sub_18E19EAE4(&v45, (uint64_t)v46, *v45 + 17408, v13, v14);
        int v29 = v46;
        for (uint64_t j = (uint64_t)v47; v28 != v18; uint64_t j = (uint64_t)v47)
        {
          uint64_t v31 = *v28++;
          sub_18E19EAE4(&v45, v31, v31 + 17408, v29, j);
          int v29 = v46;
        }
        uint64_t v17 = *v18;
        uint64_t v32 = v19;
      }
      sub_18E19EAE4(&v45, v17, v32, v29, j);
      double v37 = v46;
      uint64_t v36 = v47;
      uint64_t v38 = a1[1];
      if (a1[2] == v38)
      {
        uint64_t v40 = 0;
      }
      else
      {
        unint64_t v39 = a1[5] + a1[4];
        uint64_t v40 = *(void *)(v38 + ((v39 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 1088 * (v39 & 0xF);
      }
      if ((uint64_t *)v40 != v47)
      {
        do
        {
          sub_18E0B8DAC(v36);
          v36 += 136;
          if ((uint64_t *)((char *)v36 - *v37) == (uint64_t *)17408)
          {
            __int16 v41 = (uint64_t *)v37[1];
            ++v37;
            uint64_t v36 = v41;
          }
        }
        while (v36 != (uint64_t *)v40);
      }
      a1[5] -= v27;
      while (sub_18E19E850(a1))
        ;
      uint64_t v9 = (void **)a1[1];
      unint64_t v7 = a1[4];
      uint64_t v12 = v44;
    }
  }
  if ((void **)a1[2] == v9) {
    uint64_t v42 = 0;
  }
  else {
    uint64_t v42 = (uint64_t)v9[v7 >> 4] + 1088 * (v7 & 0xF);
  }
  uint64_t v45 = (uint64_t *)&v9[v7 >> 4];
  uint64_t v46 = (uint64_t *)v42;
  return sub_18E19E7DC(&v45, v12);
}

uint64_t raven::RavenDeltaVIOEstimateActiveObject::VIOUserCourseTurnDetection(uint64_t a1, uint64_t a2, uint64_t a3, int8x16_t a4, int8x16_t a5)
{
  uint64_t v8 = *(void **)a2;
  double v9 = *(double *)(a2 + 8);
  *(double *)a4.i64 = v9;
  double v10 = *(void **)a3;
  double v11 = *(double *)(a3 + 8);
  *(double *)a5.i64 = v11;
  if (*(void *)a2) {
    BOOL v12 = 1;
  }
  else {
    BOOL v12 = (*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
  }
  if (v12
    && (!v10 ? (BOOL v13 = (*(void *)&v11 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000) : (BOOL v13 = 1), v13 && v8 != v10))
  {
    if ((uint64_t)v8 < (uint64_t)v10) {
      return 0;
    }
  }
  else if (v9 <= v11)
  {
    return 0;
  }
  int8x16_t v73 = *(void **)a2;
  *(double *)&long long v74 = v9;
  int8x16_t v68 = v10;
  *(double *)&long long v69 = v11;
  uint64_t v15 = CNTimeSpan::operator-((uint64_t)&v73, &v68, a4, a5);
  double v17 = v16 + (double)v15;
  if (v17 >= *(double *)(a1 + 9880))
  {
    uint64_t v85 = 0x100000003;
    long long v84 = xmmword_18E1F6F60;
    long long v83 = &unk_1EDD18D98;
    long long v86 = &v87;
    sub_18DFE2AA8(a2 + 232, a3 + 232, (uint64_t)&v83);
    uint64_t v18 = (double *)v86;
    long double v20 = *(double *)v86;
    long double v19 = *((double *)v86 + 1);
    double v21 = hypot(*(long double *)v86, v19);
    if (v21 < 1.0 || v21 > fabs(v17 * 2.5) * 3.0 || fabs(v20) <= 0.005 && fabs(v19) <= 0.005)
    {
      *(unsigned char *)(a1 + 520) = 0;
      return 1;
    }
    *(unsigned char *)(a1 + 520) = 1;
    double v22 = atan2(v20, v19);
    if (v22 >= 0.0) {
      double v23 = v22;
    }
    else {
      double v23 = v22 + 6.28318531;
    }
    uint64_t v80 = 0x200000001;
    long long v79 = xmmword_18E1FD740;
    uint64_t v78 = &unk_1EDD181C8;
    int8x16_t v81 = v82;
    v82[0] = v19 / (v21 * v21);
    v82[1] = -*v18 / (v21 * v21);
    uint64_t v75 = 0x300000003;
    long long v74 = xmmword_18E1F0010;
    int8x16_t v73 = &unk_1EDD18EE8;
    uint64_t v76 = &v77;
    sub_18DFEF1F4(a2 + 408, a3 + 408, (uint64_t)&v73);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404ED0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB404ED0))
    {
      uint64_t v70 = 0x200000001;
      int8x16_t v68 = &unk_1EDD181F8;
      long long v71 = &v72;
      long long v69 = xmmword_18E1FD740;
      uint64_t v72 = 0x100000000;
      sub_18E059674((uint64_t)&v68, (uint64_t)&unk_1EB404ED8);
      __cxa_atexit((void (*)(void *))sub_18E05971C, &unk_1EB404ED8, &dword_18DEDB000);
      __cxa_guard_release(&qword_1EB404ED0);
    }
    sub_18E195A4C((uint64_t)&v73, (uint64_t)&unk_1EB404ED8, (uint64_t)&unk_1EB404ED8, (uint64_t)&v68);
    uint64_t v60 = 0x200000001;
    std::string __p = &unk_1EDD181C8;
    long long v59 = xmmword_18E1FD740;
    uint64_t v61 = &v62;
    sub_18DFE2B44((uint64_t)&v78, (uint64_t)&v68, (uint64_t)&__p);
    int v25 = v79;
    int v24 = DWORD1(v79);
    uint64_t v55 = 0x100000002;
    uint64_t v50 = &unk_1EDD18B28;
    uint64_t v56 = v57;
    int v51 = DWORD1(v79);
    int v52 = v79;
    int v53 = v79 * DWORD1(v79);
    int v54 = DWORD1(v79);
    if (DWORD1(v79))
    {
      int v26 = 0;
      int v27 = 0;
      int v28 = HIDWORD(v79);
      int v29 = v81;
      do
      {
        int v30 = v26;
        int v31 = v27;
        for (int i = v25; i; --i)
        {
          v57[v31] = *(void *)&v29[v30];
          v31 += v24;
          ++v30;
        }
        ++v27;
        v26 += v28;
      }
      while (v27 != v24);
    }
    uint64_t v65 = 0x100000001;
    uint64_t v63 = &unk_1EDD18048;
    *(void *)&long long v33 = 0x100000001;
    *((void *)&v33 + 1) = 0x100000001;
    long long v64 = v33;
    double v66 = (double *)&v67;
    sub_18DFE2B44((uint64_t)&__p, (uint64_t)&v50, (uint64_t)&v63);
    double v35 = *v66;
    if ((*(void *)v66 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && v35 >= 0.0)
    {
      double v36 = sqrt(v35);
      if (v36 <= 1.57079633)
      {
        if (*(unsigned char *)(a1 + 720))
        {
          double v37 = *(double *)(a1 + 712);
        }
        else
        {
          if (v36 >= 0.785398163) {
            return 1;
          }
          *(double *)(a1 + 712) = v23;
          *(unsigned char *)(a1 + 720) = 1;
          double v37 = v23;
        }
        double v38 = vabdd_f64(v23, v37);
        if (6.28318531 - v38 < v38) {
          double v38 = 6.28318531 - v38;
        }
        double v39 = *(double *)(a1 + 504);
        if (v39 > 0.0) {
          double v39 = -v39;
        }
        unsigned int v40 = *(_DWORD *)(a1 + 728);
        if (v38 + v39 <= 0.261799388)
        {
          if (v40 < 2) {
            goto LABEL_48;
          }
          int v41 = -1;
        }
        else
        {
          int v41 = 1;
        }
        v40 += v41;
        *(_DWORD *)(a1 + 728) = v40;
LABEL_48:
        BOOL v43 = v38 + v39 > 0.785398163 && v40 > 2;
        if (v40 > 4 || v43)
        {
          if (cnprint::CNPrinter::GetLogLevel(v34) <= 1)
          {
            LOWORD(v50) = 12;
            LOBYTE(v63) = 1;
            (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 16))(&__p, a1);
            if (!*(unsigned char *)(a1 + 720)) {
              sub_18DFF28FC();
            }
            p_p = &__p;
            if (v59 < 0) {
              LOBYTE(p_p) = (_BYTE)__p;
            }
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v50, (unsigned __int8 *)&v63, "%s: VIO t,%.3lf dt_time,%.3lf VIO user turn detected, init course,%.3lf, change in course,%.3lf, accum_yaw_corr,%.3lf, [deg] VIO delta position,%.3lf, score%u", v44, v45, v46, v47, v48, (char)p_p);
            if (SHIBYTE(v59) < 0) {
              operator delete(__p);
            }
          }
          *(unsigned char *)(a1 + 732) = 0;
          *(_DWORD *)(a1 + 728) = 0;
          if (*(unsigned char *)(a1 + 720)) {
            *(unsigned char *)(a1 + 720) = 0;
          }
          sub_18DFE2F24(a1 + 632, a2 + 232);
          *(void *)(a1 + 504) = 0;
        }
        return 1;
      }
    }
    return 0;
  }
  return 1;
}

void sub_18E19C578(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
}

void raven::RavenDeltaVIOEstimateActiveObject::HandleEvent(raven::RavenDeltaVIOEstimateActiveObject *this, const raven::VLLocalizationEvent *a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](this);
  if (*(unsigned char *)(v2 + 480)) {
    BOOL v4 = *(unsigned char *)(v3 + 1080) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return;
  }
  uint64_t v5 = v3;
  uint64_t v6 = v2;
  uint64_t v7 = v2 + 6256;
  uint64_t v8 = v2 + 5624;
  if (*(unsigned char *)(v2 + 6728))
  {
    long long v9 = *(_OWORD *)(v3 + 8);
    long long v10 = *(_OWORD *)(v3 + 24);
    long long v11 = *(_OWORD *)(v3 + 40);
    *(_OWORD *)(v2 + 5680) = *(_OWORD *)(v3 + 56);
    *(_OWORD *)(v2 + 5664) = v11;
    *(_OWORD *)(v2 + 5648) = v10;
    *(_OWORD *)(v2 + 5632) = v9;
    long long v12 = *(_OWORD *)(v3 + 72);
    long long v13 = *(_OWORD *)(v3 + 88);
    long long v14 = *(_OWORD *)(v3 + 104);
    *(_OWORD *)(v2 + 5744) = *(_OWORD *)(v3 + 120);
    *(_OWORD *)(v2 + 5728) = v14;
    *(_OWORD *)(v2 + 5712) = v13;
    *(_OWORD *)(v2 + 5696) = v12;
    long long v15 = *(_OWORD *)(v3 + 136);
    long long v16 = *(_OWORD *)(v3 + 152);
    long long v17 = *(_OWORD *)(v3 + 168);
    *(_OWORD *)(v2 + 5808) = *(_OWORD *)(v3 + 184);
    *(_OWORD *)(v2 + 5792) = v17;
    *(_OWORD *)(v2 + 5776) = v16;
    *(_OWORD *)(v2 + 5760) = v15;
    if (v8 != v3)
    {
      *(_OWORD *)(v2 + 5824) = *(_OWORD *)(v3 + 200);
      *(_OWORD *)(v2 + 5840) = *(_OWORD *)(v3 + 216);
    }
    uint64_t v18 = (long long *)(v3 + 1080);
    sub_18DFE2F24(v2 + 5856, v3 + 232);
    sub_18DFE2F24(v6 + 5920, v5 + 296);
    sub_18DFE2F24(v6 + 6032, v5 + 408);
    sub_18DFE2F24(v6 + 6144, v5 + 520);
    *(unsigned char *)uint64_t v7 = *(unsigned char *)(v5 + 632);
    if (v8 != v5)
    {
      *(_OWORD *)(v7 + 8) = *(_OWORD *)(v5 + 640);
      *(_OWORD *)(v7 + 24) = *(_OWORD *)(v5 + 656);
    }
    sub_18DFE2F24(v6 + 6296, v5 + 672);
    sub_18DFE2F24(v6 + 6360, v5 + 736);
    sub_18DFE2F24(v6 + 6472, v5 + 848);
    sub_18DFE2F24(v6 + 6584, v5 + 960);
    *(unsigned char *)(v7 + 440) = *(unsigned char *)(v5 + 1072);
    long long v19 = *v18;
    *(void *)(v6 + 6720) = *(void *)(v5 + 1096);
    *(_OWORD *)(v6 + 6704) = v19;
  }
  else
  {
    sub_18E0C7480(v2 + 5624, v3);
    *(unsigned char *)(v7 + 472) = 1;
  }
  if (!*(void *)(v6 + 9928))
  {
LABEL_29:
    *(unsigned char *)(v6 + 736) = 0;
    return;
  }
  v85[1] = 0;
  v85[0] = 0;
  char v86 = 0;
  uint64_t v88 = 0;
  uint64_t v87 = 0;
  char v89 = 0;
  uint64_t v91 = 0;
  uint64_t v90 = 0;
  char v92 = 0;
  uint64_t v94 = 0;
  uint64_t v93 = 0;
  uint64_t v97 = 0;
  uint64_t v95 = 0x7FF8000000000000;
  uint64_t v96 = 0;
  char v98 = 0;
  uint64_t v100 = 0;
  uint64_t v99 = 0;
  char v101 = 0;
  uint64_t v103 = 0;
  uint64_t v102 = 0;
  char v104 = 0;
  uint64_t v105 = 0;
  uint64_t v106 = 0;
  uint64_t v107 = 0x7FF8000000000000;
  char v108 = 0;
  cntransformation::CNRigidTransformation::CNRigidTransformation((cntransformation::CNRigidTransformation *)v109);
  cntransformation::CNRigidTransformation::CNRigidTransformation((cntransformation::CNRigidTransformation *)v111);
  __int16 v116 = 0;
  char v117 = 0;
  *(_OWORD *)std::string __p = *(_OWORD *)(v5 + 104);
  uint64_t v21 = raven::RavenDeltaVIOEstimateActiveObject::SynchronizeVIOdataTo((cnprint::CNPrinter *)v6, (double *)__p, (uint64_t)v85, *(int8x16_t *)__p, v20);
  if ((v21 & 1) == 0)
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v21) <= 1)
    {
      LOWORD(v82[0]) = 12;
      v75[0] = 1;
      (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v6 + 16))(__p, v6);
      int v28 = v84;
      char v29 = (char)__p[0];
      (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
      double v35 = __p;
      if (v28 < 0) {
        LOBYTE(v35) = v29;
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v82, v75, "%s, vl_evt_t,%.3lf vl_app_t,%.3lf for VL sample there is no corresponding VIO to use or interpolate.", v30, v31, v32, v33, v34, (char)v35);
      if (v84 < 0) {
        operator delete(__p[0]);
      }
    }
    goto LABEL_29;
  }
  cntransformation::Cat((cntransformation *)v111, (const cntransformation::CNRigidTransformation *)v109, (uint64_t)__p);
  cntransformation::CNRigidTransformation::CNRigidTransformation((cntransformation::CNRigidTransformation *)v82);
  uint64_t v79 = 0x300000003;
  uint64_t v77 = &unk_1EDD18EE8;
  uint64_t v80 = &v81;
  long long v78 = xmmword_18E1F0010;
  sub_18DFE2CC8((uint64_t)&v77, 0.0);
  uint64_t v22 = SHIDWORD(v78);
  double v23 = v80;
  v80[2 * SHIDWORD(v78)] = 0x3FF0000000000000;
  v23[1] = 0x3FF0000000000000;
  v23[v22 + 2] = 0x3FF0000000000000;
  sub_18DFE20A0((uint64_t)v76, (uint64_t)&v77);
  v82[0] = v76[0];
  v82[1] = v76[1];
  cntransformation::Cat((cntransformation *)(v5 + 200), (const cntransformation::CNRigidTransformation *)v82, (uint64_t)v75);
  cntransformation::Cat((cntransformation *)v75, (const cntransformation::CNRigidTransformation *)__p, (uint64_t)v68);
  if ((unsigned char *)(v6 + 7832) != v68)
  {
    long long v24 = *(_OWORD *)&v68[16];
    *(_OWORD *)(v6 + 7832) = *(_OWORD *)v68;
    *(_OWORD *)(v6 + 7848) = v24;
  }
  sub_18DFE2F24(v6 + 7864, (uint64_t)&v69);
  sub_18DFE2F24(v6 + 7928, (uint64_t)v71);
  sub_18DFE2F24(v6 + 8040, (uint64_t)v72);
  sub_18DFE2F24(v6 + 8152, (uint64_t)v73);
  *(unsigned char *)(v6 + 8264) = v74;
  *(unsigned char *)(v6 + 734) = 1;
  *(_OWORD *)int8x16_t v68 = v111[0];
  *(_OWORD *)&v68[16] = v111[1];
  sub_18DFF2980((uint64_t)&v69, (uint64_t)&v112);
  sub_18DFE2FA8((uint64_t)v71, (uint64_t)&v113);
  sub_18DFE2FA8((uint64_t)v72, (uint64_t)&v114);
  sub_18DFE2FA8((uint64_t)v73, (uint64_t)v115);
  char v74 = v115[112];
  cntransformation::Inv((float64x2_t *)v68, (uint64_t)v61);
  sub_18DFE2F24(v6 + 9656, (uint64_t)&v62);
  uint64_t v58 = 0x100000003;
  uint64_t v56 = &unk_1EDD18D98;
  long long v59 = v60;
  long long v57 = xmmword_18E1F6F60;
  sub_18DFE2CC8((uint64_t)&v56, 0.0);
  sub_18DFE2F24((uint64_t)&v69, (uint64_t)&v56);
  cntransformation::Cat((cntransformation *)v75, (const cntransformation::CNRigidTransformation *)v68, (uint64_t)&v50);
  if ((long long *)(v6 + 8712) != &v50)
  {
    long long v25 = v51;
    *(_OWORD *)(v6 + 8712) = v50;
    *(_OWORD *)(v6 + 8728) = v25;
  }
  sub_18DFE2F24(v6 + 8744, (uint64_t)&v52);
  sub_18DFE2F24(v6 + 8808, (uint64_t)&v53);
  sub_18DFE2F24(v6 + 8920, (uint64_t)&v54);
  sub_18DFE2F24(v6 + 9032, (uint64_t)v55);
  *(unsigned char *)(v6 + 9144) = v55[112];
  *(unsigned char *)(v6 + 736) = 1;
  sub_18DFE2F24(v6 + 9592, v6 + 7864);
  *(unsigned char *)(v6 + 732) = 1;
  sub_18DFFDA0C((uint64_t)&v50, **(float64_t **)(v6 + 7896), *(float64_t *)(*(void *)(v6 + 7896) + 8), *(double *)(*(void *)(v6 + 7896) + 16));
  if (BYTE8(v50))
  {
    sub_18DFE2F24(v6 + 9720, (uint64_t)&v51);
    *(unsigned char *)(v6 + 733) = 1;
    uint64_t v58 = 0x100000003;
    long long v57 = xmmword_18E1F6F60;
    uint64_t v56 = &unk_1EDD18D98;
    long long v59 = v60;
    sub_18DFE2B44(v6 + 9720, v6 + 7864, (uint64_t)&v56);
    sub_18DFE20A0((uint64_t)v49, v6 + 9720);
    cntransformation::CNRigidTransformation::CNRigidTransformation((cntransformation::CNRigidTransformation *)v68);
    *(_OWORD *)int8x16_t v68 = v49[0];
    *(_OWORD *)&v68[16] = v49[1];
    uint64_t v46 = 0x100000003;
    uint64_t v44 = &unk_1EDD18D98;
    long long v45 = xmmword_18E1F6F60;
    uint64_t v47 = &v48;
    sub_18DFE2B44(v6 + 9720, v6 + 7864, (uint64_t)&v44);
    *(void *)&v61[24] = 0x100000003;
    *(_OWORD *)&v61[8] = xmmword_18E1F6F60;
    *(void *)uint64_t v61 = &unk_1EDD18D98;
    uint64_t v62 = &v63;
    sub_18DFE2AA8((uint64_t)&v56, (uint64_t)&v44, (uint64_t)v61);
    sub_18DFE2F24((uint64_t)&v69, (uint64_t)v61);
    cntransformation::Cat((cntransformation *)v68, (const cntransformation::CNRigidTransformation *)(v6 + 7832), (uint64_t)v61);
    if ((unsigned char *)(v6 + 8272) != v61)
    {
      long long v26 = *(_OWORD *)&v61[16];
      *(_OWORD *)(v6 + 8272) = *(_OWORD *)v61;
      *(_OWORD *)(v6 + 8288) = v26;
    }
    sub_18DFE2F24(v6 + 8304, (uint64_t)&v62);
    sub_18DFE2F24(v6 + 8368, (uint64_t)v64);
    sub_18DFE2F24(v6 + 8480, (uint64_t)v65);
    sub_18DFE2F24(v6 + 8592, (uint64_t)v66);
    *(unsigned char *)(v6 + 8704) = v67;
    *(unsigned char *)(v6 + 735) = 1;
    *(void *)&v68[24] = 0x100000003;
    *(void *)int8x16_t v68 = &unk_1EDD18D98;
    *(_OWORD *)&v68[8] = xmmword_18E1F6F60;
    long long v69 = &v70;
    sub_18DFE2AA8((uint64_t)v110, v6 + 9656, (uint64_t)v68);
    sub_18DFE2F24((uint64_t)v110, (uint64_t)v68);
    cntransformation::Inv(v109, (uint64_t)v68);
    cntransformation::Cat((cntransformation *)(v6 + 8272), (const cntransformation::CNRigidTransformation *)v68, (uint64_t)v61);
    if ((unsigned char *)(v6 + 9152) != v61)
    {
      long long v27 = *(_OWORD *)&v61[16];
      *(_OWORD *)(v6 + 9152) = *(_OWORD *)v61;
      *(_OWORD *)(v6 + 9168) = v27;
    }
    sub_18DFE2F24(v6 + 9184, (uint64_t)&v62);
    sub_18DFE2F24(v6 + 9248, (uint64_t)v64);
    sub_18DFE2F24(v6 + 9360, (uint64_t)v65);
    sub_18DFE2F24(v6 + 9472, (uint64_t)v66);
    *(unsigned char *)(v6 + 9584) = v67;
  }
  else
  {
    *(_WORD *)uint64_t v61 = 12;
    LOBYTE(v56) = 2;
    (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v6 + 16))(v68, v6);
    int v36 = v68[23];
    char v37 = v68[0];
    (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
    BOOL v43 = v68;
    if (v36 < 0) {
      LOBYTE(v43) = v37;
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v61, (unsigned __int8 *)&v56, "%s, vl_evt_t,%.3lf vl_app_t,%.3lf, VLF position Jecef2enu computation failed.", v38, v39, v40, v41, v42, (char)v43);
    if ((v68[23] & 0x80000000) != 0) {
      operator delete(*(void **)v68);
    }
  }
}

void sub_18E19CF34(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x467]) < 0) {
    operator delete((void *)STACK[0x450]);
  }
  _Unwind_Resume(a1);
}

uint64_t raven::RavenDeltaVIOEstimateActiveObject::SynchronizeVIOdataTo(cnprint::CNPrinter *a1, double *a2, uint64_t a3, int8x16_t a4, int8x16_t a5)
{
  uint64_t v5 = *((void *)a1 + 1241);
  if (!v5) {
    return 0;
  }
  long long v9 = (void *)((char *)a1 + 9888);
  if (v5 == 1)
  {
    unint64_t v10 = *((void *)a1 + 1240);
    uint64_t v11 = *(void *)(*((void *)a1 + 1237) + ((v10 >> 1) & 0x7FFFFFFFFFFFFFF8));
    unsigned int v12 = v10 & 0xF;
    uint64_t v13 = v11 + 1088 * (v10 & 0xF);
    uint64_t v14 = *(void *)(v13 + 8);
    v117[0].i64[0] = *(void *)v13;
    v117[0].i64[1] = v14;
    long long v15 = (cnprint::CNPrinter *)CNTimeSpan::operator-((uint64_t)a2, v117, a4, a5);
    if (fabs(v16 + (double)(uint64_t)v15) <= 0.001)
    {
      *(_OWORD *)a3 = *(_OWORD *)v13;
      long long v50 = *(_OWORD *)(v13 + 16);
      long long v51 = *(_OWORD *)(v13 + 32);
      long long v52 = *(_OWORD *)(v13 + 64);
      *(_OWORD *)(a3 + 48) = *(_OWORD *)(v13 + 48);
      *(_OWORD *)(a3 + 64) = v52;
      *(_OWORD *)(a3 + 16) = v50;
      *(_OWORD *)(a3 + 32) = v51;
      long long v53 = *(_OWORD *)(v13 + 80);
      long long v54 = *(_OWORD *)(v13 + 96);
      long long v55 = *(_OWORD *)(v13 + 128);
      *(_OWORD *)(a3 + 112) = *(_OWORD *)(v13 + 112);
      *(_OWORD *)(a3 + 128) = v55;
      *(_OWORD *)(a3 + 80) = v53;
      *(_OWORD *)(a3 + 96) = v54;
      long long v56 = *(_OWORD *)(v13 + 144);
      long long v57 = *(_OWORD *)(v13 + 160);
      long long v58 = *(_OWORD *)(v13 + 176);
      *(unsigned char *)(a3 + 192) = *(unsigned char *)(v13 + 192);
      *(_OWORD *)(a3 + 160) = v57;
      *(_OWORD *)(a3 + 176) = v58;
      *(_OWORD *)(a3 + 144) = v56;
      uint64_t v59 = v11 + 1088 * v12;
      if (a3 != v59)
      {
        *(_OWORD *)(a3 + 200) = *(_OWORD *)(v59 + 200);
        *(_OWORD *)(a3 + 216) = *(_OWORD *)(v59 + 216);
      }
      uint64_t v60 = v11 + 1088 * v12;
      sub_18DFE2F24(a3 + 232, v60 + 232);
      sub_18DFE2F24(a3 + 296, v60 + 296);
      sub_18DFE2F24(a3 + 408, v60 + 408);
      sub_18DFE2F24(a3 + 520, v60 + 520);
      *(unsigned char *)(a3 + 632) = *(unsigned char *)(v60 + 632);
      if (a3 != v60)
      {
        *(_OWORD *)(a3 + 640) = *(_OWORD *)(v60 + 640);
        *(_OWORD *)(a3 + 656) = *(_OWORD *)(v60 + 656);
      }
      uint64_t v61 = v11 + 1088 * v12;
      sub_18DFE2F24(a3 + 672, v61 + 672);
      sub_18DFE2F24(a3 + 736, v61 + 736);
      sub_18DFE2F24(a3 + 848, v61 + 848);
      sub_18DFE2F24(a3 + 960, v61 + 960);
      *(unsigned char *)(a3 + 1072) = *(unsigned char *)(v61 + 1072);
      __int16 v62 = *(_WORD *)(v61 + 1080);
      *(unsigned char *)(a3 + 1082) = *(unsigned char *)(v61 + 1082);
      *(_WORD *)(a3 + 1080) = v62;
      if (raven::RavenDeltaVIOEstimateActiveObject::ApplyDefaultUncertaintyInflation(v63, a3)) {
        return 1;
      }
      sub_18E19918C((uint64_t)v9);
      return 0;
    }
    if (cnprint::CNPrinter::GetLogLevel(v15) <= 1)
    {
      LOWORD(v112[0]) = 12;
      LOBYTE(v121) = 1;
      (*(void (**)(void **__return_ptr, cnprint::CNPrinter *))(*(void *)a1 + 16))(__p, a1);
      CNTimeSpan::operator-((uint64_t)a2, v117, v17, v18);
      LOBYTE(v24) = __p[0];
      if (v119 >= 0) {
        long long v24 = __p;
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v112, (unsigned __int8 *)&v121, "%s, The only VIO sample is not time aligned to sync time, tsync,%.3lf vio_at,%.3lf dt,%.3lf, tol,%.3lf", v19, v20, v21, v22, v23, (char)v24);
      goto LABEL_19;
    }
    return 0;
  }
  unint64_t v25 = *((void *)a1 + 1240);
  uint64_t v26 = *((void *)a1 + 1237);
  long long v121 = *(_OWORD *)(*(void *)(v26 + (((v5 + v25 - 1) >> 1) & 0x7FFFFFFFFFFFFFF8))
                   + 1088 * ((v5 + v25 - 1) & 0xF));
  long long v120 = *(_OWORD *)(*(void *)(v26 + ((v25 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 1088 * (v25 & 0xF));
  BOOL v27 = sub_18DEE4D28(a2, (double *)&v120);
  if (!v27 || !(BOOL v27 = sub_18DEE8C5C(a2, (double *)&v121)))
  {
    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v27) <= 1)
    {
      v117[0].i16[0] = 12;
      LOBYTE(v112[0]) = 1;
      (*(void (**)(void **__return_ptr, cnprint::CNPrinter *))(*(void *)a1 + 16))(__p, a1);
      if (v119 >= 0) {
        uint64_t v49 = __p;
      }
      else {
        LOBYTE(v49) = __p[0];
      }
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v117, (unsigned __int8 *)v112, "%s, For the given sync time there is no corresponding VIO to use or interpolate, tsync,%.3lf oldest_VIO,%.3lf latest_VIO,%.3lf", v44, v45, v46, v47, v48, (char)v49);
LABEL_19:
      if (v119 < 0) {
        operator delete(__p[0]);
      }
    }
    return 0;
  }
  uint64_t v30 = CNTimeSpan::operator-((uint64_t)a2, &v120, v28, v29);
  *(double *)v32.i64 = v31;
  *(double *)v33.i64 = fabs(v31 + (double)v30);
  if (*(double *)v33.i64 <= 0.001)
  {
    unint64_t v65 = *((void *)a1 + 1240);
    uint64_t v66 = *(void *)(*((void *)a1 + 1237) + ((v65 >> 1) & 0x7FFFFFFFFFFFFFF8));
    unsigned int v67 = v65 & 0xF;
    uint64_t v68 = v66 + 1088 * (v65 & 0xF);
    long long v69 = *(_OWORD *)(v68 + 64);
    long long v71 = *(_OWORD *)(v68 + 16);
    long long v70 = *(_OWORD *)(v68 + 32);
    *(_OWORD *)(a3 + 48) = *(_OWORD *)(v68 + 48);
    *(_OWORD *)(a3 + 64) = v69;
    *(_OWORD *)(a3 + 16) = v71;
    *(_OWORD *)(a3 + 32) = v70;
    long long v72 = *(_OWORD *)(v68 + 128);
    long long v74 = *(_OWORD *)(v68 + 80);
    long long v73 = *(_OWORD *)(v68 + 96);
    *(_OWORD *)(a3 + 112) = *(_OWORD *)(v68 + 112);
    *(_OWORD *)(a3 + 128) = v72;
    *(_OWORD *)(a3 + 80) = v74;
    *(_OWORD *)(a3 + 96) = v73;
    long long v76 = *(_OWORD *)(v68 + 160);
    long long v75 = *(_OWORD *)(v68 + 176);
    long long v77 = *(_OWORD *)(v68 + 144);
    *(unsigned char *)(a3 + 192) = *(unsigned char *)(v68 + 192);
    *(_OWORD *)(a3 + 160) = v76;
    *(_OWORD *)(a3 + 176) = v75;
    *(_OWORD *)(a3 + 144) = v77;
    *(_OWORD *)a3 = *(_OWORD *)v68;
    if (a3 != v68)
    {
      *(_OWORD *)(a3 + 200) = *(_OWORD *)(v68 + 200);
      *(_OWORD *)(a3 + 216) = *(_OWORD *)(v68 + 216);
    }
    uint64_t v78 = v66 + 1088 * (v65 & 0xF);
    sub_18DFE2F24(a3 + 232, v78 + 232);
    sub_18DFE2F24(a3 + 296, v78 + 296);
    sub_18DFE2F24(a3 + 408, v78 + 408);
    sub_18DFE2F24(a3 + 520, v78 + 520);
    *(unsigned char *)(a3 + 632) = *(unsigned char *)(v78 + 632);
    if (a3 != v78)
    {
      *(_OWORD *)(a3 + 640) = *(_OWORD *)(v78 + 640);
      *(_OWORD *)(a3 + 656) = *(_OWORD *)(v78 + 656);
    }
    uint64_t v79 = v66 + 1088 * v67;
    sub_18DFE2F24(a3 + 672, v79 + 672);
    sub_18DFE2F24(a3 + 736, v79 + 736);
    sub_18DFE2F24(a3 + 848, v79 + 848);
    sub_18DFE2F24(a3 + 960, v79 + 960);
    *(unsigned char *)(a3 + 1072) = *(unsigned char *)(v79 + 1072);
    __int16 v81 = *(_WORD *)(v79 + 1080);
    *(unsigned char *)(a3 + 1082) = *(unsigned char *)(v79 + 1082);
    *(_WORD *)(a3 + 1080) = v81;
    goto LABEL_35;
  }
  *(double *)v34.i64 = (double)CNTimeSpan::operator-((uint64_t)&v121, a2, v33, v32);
  unint64_t v36 = *((void *)a1 + 1240);
  if (fabs(v35 + *(double *)v34.i64) <= 0.001)
  {
    uint64_t v80 = sub_18E19E1C8(a3, *(void *)(*((void *)a1 + 1237) + (((v36 + *((void *)a1 + 1241) - 1) >> 1) & 0x7FFFFFFFFFFFFFF8))+ 1088 * ((v36 + *((_DWORD *)a1 + 2482) - 1) & 0xF));
LABEL_35:
    if (raven::RavenDeltaVIOEstimateActiveObject::ApplyDefaultUncertaintyInflation(v80, a3))
    {
      int v84 = 1;
      LODWORD(result) = 1;
      goto LABEL_68;
    }
    uint64_t v85 = CNTimeSpan::operator-((uint64_t)&v121, a2, v82, v83);
    if (fabs(v86 + (double)v85) <= 0.001) {
      sub_18E19918C((uint64_t)v9);
    }
    else {
      sub_18E19934C(v9);
    }
    goto LABEL_66;
  }
  uint64_t v37 = *((void *)a1 + 1237);
  uint64_t v38 = (char *)(v37 + 8 * (v36 >> 4));
  uint64_t v39 = *((void *)a1 + 1238);
  if (v39 == v37)
  {
    uint64_t v40 = 0;
    uint64_t v43 = 0;
    uint64_t v42 = (char *)(v37 + 8 * ((*((void *)a1 + 1241) + v36) >> 4));
  }
  else
  {
    uint64_t v40 = (_OWORD *)(*(void *)v38 + 1088 * (*((void *)a1 + 1240) & 0xFLL));
    unint64_t v41 = *((void *)a1 + 1241) + v36;
    uint64_t v42 = (char *)(v37 + 8 * (v41 >> 4));
    uint64_t v43 = *(void *)v42 + 1088 * (v41 & 0xF);
  }
  if ((_OWORD *)v43 != v40)
  {
    unint64_t v87 = 0xF0F0F0F0F0F0F0F1 * ((v43 - *(void *)v42) >> 6)
        + 2 * (v42 - v38)
        + 0xF0F0F0F0F0F0F0FLL * (((uint64_t)v40 - *(void *)v38) >> 6);
    if (v87)
    {
      do
      {
        unint64_t v88 = v87 >> 1;
        v117[0].i64[0] = (uint64_t)v38;
        v117[0].i64[1] = (uint64_t)v40;
        sub_18E19E7DC((uint64_t **)v117, v87 >> 1);
        *(_OWORD *)std::string __p = *(_OWORD *)v117[0].i64[1];
        if (sub_18DEE4CB8((double *)__p, a2))
        {
          uint64_t v38 = (char *)v117[0].i64[0];
          uint64_t v40 = (_OWORD *)(v117[0].i64[1] + 1088);
          v117[0].i64[1] = (uint64_t)v40;
          if ((_OWORD *)((char *)v40 - *(void *)v117[0].i64[0]) == (_OWORD *)17408)
          {
            uint64_t v38 = (char *)(v117[0].i64[0] + 8);
            uint64_t v40 = *(_OWORD **)(v117[0].i64[0] + 8);
          }
          unint64_t v88 = v87 + ~v88;
        }
        unint64_t v87 = v88;
      }
      while (v88);
      uint64_t v37 = *((void *)a1 + 1237);
      uint64_t v39 = *((void *)a1 + 1238);
    }
  }
  if (v39 == v37)
  {
    uint64_t v90 = 0;
  }
  else
  {
    unint64_t v89 = *((void *)a1 + 1241) + *((void *)a1 + 1240);
    uint64_t v90 = *(void *)(v37 + ((v89 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 1088 * (v89 & 0xF);
  }
  if ((_OWORD *)v90 == v40) {
    goto LABEL_66;
  }
  *(_OWORD *)std::string __p = *v40;
  uint64_t v91 = CNTimeSpan::operator-((uint64_t)a2, __p, *(int8x16_t *)__p, v34);
  if (fabs(v92 + (double)v91) <= 0.001)
  {
    uint64_t v94 = sub_18E19E1C8(a3, (uint64_t)v40);
    LODWORD(result) = raven::RavenDeltaVIOEstimateActiveObject::ApplyDefaultUncertaintyInflation(v94, a3);
LABEL_67:
    int v84 = 1;
    goto LABEL_68;
  }
  __p[0] = v38;
  __p[1] = v40;
  sub_18E19E7DC((uint64_t **)__p, -1);
  uint64_t v93 = v39 == v37
      ? 0
      : (void *)(*(void *)(v37 + ((*((void *)a1 + 1240) >> 1) & 0x7FFFFFFFFFFFFFF8))
               + 1088 * (*((void *)a1 + 1240) & 0xFLL));
  if (v93 == __p[1])
  {
LABEL_66:
    LODWORD(result) = 0;
    goto LABEL_67;
  }
  sub_18E0C6F80((uint64_t)__p, (uint64_t)v40);
  v112[0] = v38;
  v112[1] = v40;
  sub_18E19E7DC((uint64_t **)v112, -1);
  sub_18E0C6F80((uint64_t)v117, (uint64_t)v112[1]);
  double v95 = *(double *)(*((void *)a1 + 61) + 3184);
  *(_OWORD *)uint64_t v112 = *(_OWORD *)__p;
  int8x16_t v116 = v117[0];
  uint64_t v97 = (cnprint::CNPrinter *)CNTimeSpan::operator-((uint64_t)v112, &v116, v117[0], v96);
  if (v98 + (double)(uint64_t)v97 <= v95)
  {
    BOOL v109 = raven::RavenDeltaVIOEstimateActiveObject::ApplyDefaultUncertaintyInflation((uint64_t)v97, (uint64_t)v117);
    if (v109 && raven::RavenDeltaVIOEstimateActiveObject::ApplyDefaultUncertaintyInflation(v109, (uint64_t)__p))
    {
      sub_18E19E1C8(a3, (uint64_t)__p);
      int v110 = raven::RavenDeltaVIOEstimateActiveObject::InterpolateVIOdata(a1, a2, v117[0].i64, (uint64_t *)__p, a3);
      int v84 = 1;
      if (v110)
      {
        *(_OWORD *)(a3 + 48) = 0u;
        *(_OWORD *)(a3 + 64) = 0u;
        *(_OWORD *)(a3 + 16) = 0u;
        *(_OWORD *)(a3 + 32) = 0u;
        *(_OWORD *)a3 = 0u;
        *(void *)(a3 + 80) = 0;
        *(void *)(a3 + 88) = 0x7FF8000000000000;
        *(_OWORD *)a3 = *(_OWORD *)a2;
        *(unsigned char *)(a3 + 1082) = 1;
        int v84 = 0;
      }
      goto LABEL_76;
    }
    goto LABEL_75;
  }
  unsigned int LogLevel = cnprint::CNPrinter::GetLogLevel(v97);
  int v84 = 1;
  if (LogLevel <= 1)
  {
    __int16 v115 = 12;
    unsigned __int8 v114 = 1;
    (*(void (**)(void **__return_ptr, cnprint::CNPrinter *))(*(void *)a1 + 16))(v112, a1);
    int v100 = v113;
    char v101 = (char)v112[0];
    int8x16_t v116 = *(int8x16_t *)__p;
    int8x16_t v111 = v117[0];
    CNTimeSpan::operator-((uint64_t)&v116, &v111, v117[0], v102);
    if (v100 >= 0) {
      char v108 = v112;
    }
    else {
      LOBYTE(v108) = v101;
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v115, &v114, "%s, tsync,%.3lf For the given sync time there is large gaps in VIO data to interpolate, dt,%.3lf > %.3lf", v103, v104, v105, v106, v107, (char)v108);
    if (v113 < 0) {
      operator delete(v112[0]);
    }
LABEL_75:
    int v84 = 1;
  }
LABEL_76:
  LODWORD(result) = 0;
LABEL_68:
  if (v84) {
    return result;
  }
  else {
    return 1;
  }
}

void sub_18E19D928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t raven::RavenDeltaVIOEstimateActiveObject::InterpolateVIOdata(cnprint::CNPrinter *a1, double *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  *(_OWORD *)long long v52 = *(_OWORD *)a3;
  if (sub_18DEE4CB8(a2, (double *)v52)) {
    return 0;
  }
  *(_OWORD *)uint64_t v48 = *(_OWORD *)a4;
  if (sub_18DEE4C00(a2, (double *)v48)) {
    return 0;
  }
  uint64_t v13 = *a4;
  uint64_t v12 = a4[1];
  *(void *)long long v52 = *a4;
  *(void *)&v52[8] = v12;
  uint64_t v14 = *a3;
  uint64_t v15 = a3[1];
  *(void *)uint64_t v48 = *a3;
  *(void *)&v48[8] = v15;
  uint64_t v16 = CNTimeSpan::operator-((uint64_t)v52, v48, v10, v11);
  double v18 = v17 + (double)v16;
  *(double *)v19.i64 = fabs(v18);
  v20.i64[0] = 0x3CB0000000000000;
  if (*(double *)v19.i64 < 2.22044605e-16) {
    return 0;
  }
  *(void *)long long v52 = v13;
  *(void *)&v52[8] = v12;
  *(double *)v21.i64 = (double)CNTimeSpan::operator-((uint64_t)v52, a2, v19, v20);
  *(double *)v23.i64 = v22 + *(double *)v21.i64;
  double v24 = (v22 + *(double *)v21.i64) / v18;
  *(void *)long long v52 = v14;
  *(void *)&v52[8] = v15;
  uint64_t v25 = CNTimeSpan::operator-((uint64_t)a2, v52, v23, v21);
  double v27 = (v26 + (double)v25) / v18;
  uint64_t v53 = 0x100000003;
  *(void *)&v28.f64[1] = 0x300000003;
  *(_OWORD *)&v52[8] = xmmword_18E1F6F60;
  *(void *)long long v52 = &unk_1EDD18D98;
  long long v54 = v55;
  v28.f64[0] = v24;
  sub_18DFE3240((uint64_t)(a3 + 29), (uint64_t)v52, v28);
  uint64_t v49 = 0x100000003;
  *(void *)&v29.f64[1] = 0x300000003;
  *(_OWORD *)&v48[8] = xmmword_18E1F6F60;
  *(void *)uint64_t v48 = &unk_1EDD18D98;
  long long v50 = v51;
  v29.f64[0] = v27;
  sub_18DFE3240((uint64_t)(a4 + 29), (uint64_t)v48, v29);
  uint64_t v64 = 0x100000003;
  __int16 v62 = &unk_1EDD18D98;
  long long v63 = xmmword_18E1F6F60;
  unint64_t v65 = &v66;
  sub_18DFEF1F4((uint64_t)v52, (uint64_t)v48, (uint64_t)&v62);
  sub_18DFE2F24(a5 + 232, (uint64_t)&v62);
  long long v60 = 0uLL;
  *(void *)&long long v61 = 0;
  *((void *)&v61 + 1) = 0x3FF0000000000000;
  if (cnrotation::Slerp((cnrotation *)(a3 + 25), (const cnrotation::CNRotation *)(a4 + 25), (const cnrotation::CNRotation *)&v60, v27, (cnrotation::CNRotation *)8))return 0; {
  if ((long long *)(a5 + 200) != &v60)
  }
  {
    long long v30 = v61;
    *(_OWORD *)(a5 + 200) = v60;
    *(_OWORD *)(a5 + 216) = v30;
  }
  cnrotation::Inv((float64x2_t *)(a3 + 25), (float64x2_t *)v52);
  cnrotation::Cat((double *)(a5 + 200), (const cnrotation::CNRotation *)v52, &v56);
  cnrotation::CNRotation::RotationMatrix((cnrotation::CNRotation *)&v56, (uint64_t)v47);
  uint64_t v49 = 0x300000003;
  *(_OWORD *)&v48[8] = xmmword_18E1F0010;
  *(void *)uint64_t v48 = &unk_1EDD18EE8;
  long long v50 = v51;
  sub_18DFE2B44((uint64_t)v47, (uint64_t)(a3 + 37), (uint64_t)v48);
  double v31 = sqrt(v57 * v57 + v56 * v56 + v58 * v58 + v59 * v59);
  if (fabs(v31) >= 2.22044605e-16)
  {
    double v33 = -v56 / v31;
    double v34 = -v57 / v31;
    double v35 = -v58 / v31;
    double v32 = v59 / v31;
  }
  else
  {
    double v32 = 1.0;
    double v33 = 0.0;
    double v34 = 0.0;
    double v35 = 0.0;
  }
  *(double *)uint64_t v45 = v33;
  *(double *)&v45[1] = v34;
  *(double *)&v45[2] = v35;
  *(double *)&v45[3] = v32;
  cnrotation::CNRotation::RotationMatrix((cnrotation::CNRotation *)v45, (uint64_t)v46);
  uint64_t v53 = 0x300000003;
  *(_OWORD *)&v52[8] = xmmword_18E1F0010;
  *(void *)long long v52 = &unk_1EDD18EE8;
  long long v54 = v55;
  sub_18DFE2B44((uint64_t)v48, (uint64_t)v46, (uint64_t)v52);
  if (!cntransformation::CNRigidTransformation::SetPrr(a5 + 200, (uint64_t)v52)) {
    return 0;
  }
  cnrotation::CNRotation::RotationMatrix((cnrotation::CNRotation *)&v56, (uint64_t)v48);
  uint64_t v53 = 0x300000003;
  *(_OWORD *)&v52[8] = xmmword_18E1F0010;
  *(void *)long long v52 = &unk_1EDD18EE8;
  long long v54 = v55;
  sub_18DFE2B44((uint64_t)v48, (uint64_t)(a3 + 65), (uint64_t)v52);
  if (*(void *)&v52[8] == 0x300000003)
  {
    sub_18DFE2F24(a5 + 520, (uint64_t)v52);
    *(unsigned char *)(a5 + 632) = 1;
  }
  uint64_t v53 = 0x300000003;
  *(void *)long long v52 = &unk_1EDD18EE8;
  long long v54 = v55;
  *(_OWORD *)&v52[8] = xmmword_18E1F0010;
  sub_18DFE2CC8((uint64_t)v52, 0.0);
  if ((raven::RavenDeltaVIOEstimateActiveObject::ComputeSigmaCorrelationMatrixFromCovariance(a1, (uint64_t)(a3 + 51), (uint64_t)v52) & 1) == 0)return 0; {
  sub_18DFEB238(3, 3, (uint64_t)v48);
  }
  if ((raven::RavenDeltaVIOEstimateActiveObject::ComputeSigmaCorrelationMatrixFromCovariance(a1, (uint64_t)(a4 + 51), (uint64_t)v48) & 1) == 0)return 0; {
  v36.f64[0] = v24;
  }
  sub_18E042024((uint64_t)v52, (uint64_t)v46, v36);
  v37.f64[0] = v27;
  sub_18E042024((uint64_t)v48, (uint64_t)v45, v37);
  sub_18E01E39C((uint64_t)v46, (uint64_t)v45, (uint64_t)v47);
  sub_18DFEB238(3, 3, (uint64_t)v46);
  uint64_t result = raven::RavenDeltaVIOEstimateActiveObject::ComputeCovarianceFromSigmaCorrelationMatrix(a1, (uint64_t)v47, (uint64_t)v46);
  if (!result) {
    return result;
  }
  if (!cntransformation::CNRigidTransformation::SetPpp(a5 + 200, (uint64_t)v46)) {
    return 0;
  }
  uint64_t result = 1;
  if (*((unsigned char *)a3 + 1081) && *((unsigned char *)a4 + 1081))
  {
    v39.f64[0] = v24;
    sub_18E053C38((uint64_t)(a3 + 84), (uint64_t)&v43, v39);
    v40.f64[0] = v27;
    sub_18E053C38((uint64_t)(a4 + 84), (uint64_t)v42, v40);
    sub_18E053CBC((uint64_t)&v43, (uint64_t)v42, (uint64_t)v45);
    sub_18DFE2F24(a5 + 672, (uint64_t)v45);
    long long v43 = 0uLL;
    *(void *)&long long v44 = 0;
    *((void *)&v44 + 1) = 0x3FF0000000000000;
    if (cnrotation::Slerp((cnrotation *)(a3 + 80), (const cnrotation::CNRotation *)(a4 + 80), (const cnrotation::CNRotation *)&v43, v27, (cnrotation::CNRotation *)8))return 0; {
    if ((long long *)(a5 + 640) != &v43)
    }
    {
      long long v41 = v44;
      *(_OWORD *)(a5 + 640) = v43;
      *(_OWORD *)(a5 + 656) = v41;
    }
    return 1;
  }
  return result;
}

BOOL raven::RavenDeltaVIOEstimateActiveObject::IsVIOEstimateSensible(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(a2 + 440);
  if ((*v2 < 0 || ((*v2 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE)
    && (unint64_t)(*v2 - 1) > 0xFFFFFFFFFFFFELL)
  {
    return 0;
  }
  uint64_t v6 = *(int *)(a2 + 428);
  uint64_t v7 = v2[v6 + 1];
  BOOL v8 = v7 < 0 || ((v7 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE;
  if (v8 && (unint64_t)(v7 - 1) > 0xFFFFFFFFFFFFELL) {
    return 0;
  }
  uint64_t v10 = v2[2 * (int)v6 + 2];
  BOOL v11 = v10 < 0 || ((v10 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE;
  if (v11 && (unint64_t)(v10 - 1) > 0xFFFFFFFFFFFFELL) {
    return 0;
  }
  if ((v2[v6] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return 0;
  }
  if ((*(uint64_t *)((char *)v2 + ((16 * v6) | 8)) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return 0;
  }
  if ((v2[2 * v6] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return 0;
  }
  double v27 = INFINITY;
  sub_18E01D280(a2 + 408, &v27, (uint64_t)v26);
  if ((*(void *)&v27 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v27 > *(double *)(a1 + 9936)) {
    return 0;
  }
  uint64_t v14 = *(uint64_t **)(a2 + 328);
  BOOL v15 = *v14 < 0 || ((*v14 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE;
  if (v15 && (unint64_t)(*v14 - 1) > 0xFFFFFFFFFFFFELL) {
    return 0;
  }
  uint64_t v17 = *(int *)(a2 + 316);
  uint64_t v18 = v14[v17 + 1];
  BOOL v19 = v18 < 0 || ((v18 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE;
  if (v19 && (unint64_t)(v18 - 1) > 0xFFFFFFFFFFFFELL) {
    return 0;
  }
  uint64_t v21 = v14[2 * (int)v17 + 2];
  BOOL v22 = v21 < 0 || ((v21 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE;
  if (v22 && (unint64_t)(v21 - 1) > 0xFFFFFFFFFFFFELL) {
    return 0;
  }
  if ((v14[v17] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return 0;
  }
  if ((*(uint64_t *)((char *)v14 + ((16 * v17) | 8)) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return 0;
  }
  if ((v14[2 * v17] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return 0;
  }
  sub_18E01D280(a2 + 296, &v27, (uint64_t)v25);
  sub_18DFE2F24((uint64_t)v26, (uint64_t)v25);
  return (*(void *)&v27 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && v27 <= *(double *)(a1 + 9936);
}

uint64_t sub_18E19E1C8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  long long v4 = *(_OWORD *)(a2 + 16);
  long long v5 = *(_OWORD *)(a2 + 32);
  long long v6 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 16) = v4;
  *(_OWORD *)(a1 + 32) = v5;
  long long v7 = *(_OWORD *)(a2 + 80);
  long long v8 = *(_OWORD *)(a2 + 96);
  long long v9 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 128) = v9;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 96) = v8;
  long long v10 = *(_OWORD *)(a2 + 144);
  long long v11 = *(_OWORD *)(a2 + 160);
  long long v12 = *(_OWORD *)(a2 + 176);
  *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
  *(_OWORD *)(a1 + 160) = v11;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 144) = v10;
  if (a1 != a2)
  {
    *(_OWORD *)(a1 + 200) = *(_OWORD *)(a2 + 200);
    *(_OWORD *)(a1 + 216) = *(_OWORD *)(a2 + 216);
  }
  sub_18DFE2F24(a1 + 232, a2 + 232);
  sub_18DFE2F24(a1 + 296, a2 + 296);
  sub_18DFE2F24(a1 + 408, a2 + 408);
  sub_18DFE2F24(a1 + 520, a2 + 520);
  *(unsigned char *)(a1 + 632) = *(unsigned char *)(a2 + 632);
  if (a1 != a2)
  {
    *(_OWORD *)(a1 + 640) = *(_OWORD *)(a2 + 640);
    *(_OWORD *)(a1 + 656) = *(_OWORD *)(a2 + 656);
  }
  sub_18DFE2F24(a1 + 672, a2 + 672);
  sub_18DFE2F24(a1 + 736, a2 + 736);
  sub_18DFE2F24(a1 + 848, a2 + 848);
  sub_18DFE2F24(a1 + 960, a2 + 960);
  *(unsigned char *)(a1 + 1072) = *(unsigned char *)(a2 + 1072);
  __int16 v13 = *(_WORD *)(a2 + 1080);
  *(unsigned char *)(a1 + 1082) = *(unsigned char *)(a2 + 1082);
  *(_WORD *)(a1 + 1080) = v13;
  return a1;
}

void raven::RavenDeltaVIOEstimateActiveObject::Reset(raven::RavenDeltaVIOEstimateActiveObject *this)
{
  *((unsigned char *)this + 496) = 0;
  *((void *)this + 63) = 0;
  *((void *)this + 64) = 0;
  *((unsigned char *)this + 520) = 0;
  if (*((unsigned char *)this + 536)) {
    *((unsigned char *)this + 536) = 0;
  }
  if (*((unsigned char *)this + 552)) {
    *((unsigned char *)this + 552) = 0;
  }
  if (*((unsigned char *)this + 568)) {
    *((unsigned char *)this + 568) = 0;
  }
  if (*((unsigned char *)this + 584)) {
    *((unsigned char *)this + 584) = 0;
  }
  if (*((unsigned char *)this + 608)) {
    *((unsigned char *)this + 608) = 0;
  }
  if (*((unsigned char *)this + 624)) {
    *((unsigned char *)this + 624) = 0;
  }
  uint64_t v16 = 0x100000003;
  uint64_t v14 = &unk_1EDD18D98;
  uint64_t v17 = v18;
  long long v15 = xmmword_18E1F6F60;
  sub_18DFE2CC8((uint64_t)&v14, 0.0);
  sub_18DFE2F24((uint64_t)this + 632, (uint64_t)&v14);
  if (*((unsigned char *)this + 704)) {
    *((unsigned char *)this + 704) = 0;
  }
  uint64_t v2 = (char *)this + 5616;
  if (*((unsigned char *)this + 720)) {
    *((unsigned char *)this + 720) = 0;
  }
  *((unsigned char *)this + 736) = 0;
  *((void *)this + 91) = 0;
  if (*((unsigned char *)this + 3176)) {
    *((unsigned char *)this + 3176) = 0;
  }
  if (*v2) {
    *uint64_t v2 = 0;
  }
  uint64_t v3 = (char *)this + 9848;
  if (*((unsigned char *)this + 6728))
  {
    raven::VLLocalizationEvent::~VLLocalizationEvent((raven::RavenDeltaVIOEstimateActiveObject *)((char *)this + 5624));
    *((unsigned char *)this + 6728) = 0;
  }
  if (*((unsigned char *)this + 7824))
  {
    *((void *)this + 962) = &unk_1EDD17478;
    *((void *)this + 948) = &unk_1EDD17478;
    *((void *)this + 934) = &unk_1EDD17478;
    *((void *)this + 926) = &unk_1EDD17478;
    *((void *)this + 907) = &unk_1EDD17478;
    *((void *)this + 893) = &unk_1EDD17478;
    *((void *)this + 879) = &unk_1EDD17478;
    *((void *)this + 871) = &unk_1EDD17478;
    *((unsigned char *)this + 7824) = 0;
  }
  sub_18DFECED0((uint64_t)this + 7832);
  sub_18DFECED0((uint64_t)this + 8272);
  sub_18DFECED0((uint64_t)this + 8712);
  sub_18DFECED0((uint64_t)this + 9152);
  uint64_t v16 = 0x100000003;
  uint64_t v14 = &unk_1EDD18D98;
  uint64_t v17 = v18;
  long long v15 = xmmword_18E1F6F60;
  sub_18DFE2CC8((uint64_t)&v14, 0.0);
  sub_18DFE2F24((uint64_t)this + 9592, (uint64_t)&v14);
  uint64_t v16 = 0x100000003;
  uint64_t v14 = &unk_1EDD18D98;
  uint64_t v17 = v18;
  long long v15 = xmmword_18E1F6F60;
  sub_18DFE2CC8((uint64_t)&v14, 0.0);
  sub_18DFE2F24((uint64_t)this + 9656, (uint64_t)&v14);
  uint64_t v16 = 0x300000003;
  uint64_t v14 = &unk_1EDD18EE8;
  uint64_t v17 = v18;
  long long v15 = xmmword_18E1F0010;
  sub_18DFE2CC8((uint64_t)&v14, 0.0);
  sub_18DFE2F24((uint64_t)this + 9720, (uint64_t)&v14);
  if (*v3) {
    *uint64_t v3 = 0;
  }
  if (*((unsigned char *)this + 9872)) {
    *((unsigned char *)this + 9872) = 0;
  }
  long long v4 = (void **)*((void *)this + 1237);
  long long v5 = (void **)*((void *)this + 1238);
  if (v5 == v4)
  {
    long long v9 = (void *)((char *)this + 9928);
    long long v5 = (void **)*((void *)this + 1237);
  }
  else
  {
    unint64_t v6 = *((void *)this + 1240);
    long long v7 = &v4[v6 >> 4];
    long long v8 = (char *)*v7 + 1088 * (v6 & 0xF);
    long long v9 = (void *)((char *)this + 9928);
    uint64_t v10 = *(uint64_t *)((char *)v4 + (((*((void *)this + 1241) + v6) >> 1) & 0x7FFFFFFFFFFFFFF8))
        + 1088 * ((*((_DWORD *)this + 2482) + (int)v6) & 0xF);
    if (v8 != (char *)v10)
    {
      do
      {
        sub_18E0B8DAC(v8);
        v8 += 1088;
        if (v8 - (unsigned char *)*v7 == 17408)
        {
          long long v11 = (char *)v7[1];
          ++v7;
          long long v8 = v11;
        }
      }
      while (v8 != (char *)v10);
      long long v5 = (void **)*((void *)this + 1238);
      long long v4 = (void **)*((void *)this + 1237);
    }
  }
  *long long v9 = 0;
  unint64_t v12 = (char *)v5 - (char *)v4;
  if (v12 >= 0x11)
  {
    do
    {
      operator delete(*v4);
      long long v4 = (void **)(*((void *)this + 1237) + 8);
      *((void *)this + 1237) = v4;
      unint64_t v12 = *((void *)this + 1238) - (void)v4;
    }
    while (v12 > 0x10);
  }
  if (v12 >> 3 == 1)
  {
    uint64_t v13 = 8;
    goto LABEL_42;
  }
  if (v12 >> 3 == 2)
  {
    uint64_t v13 = 16;
LABEL_42:
    *((void *)this + 1240) = v13;
  }
  cnframework::ActiveObjectBase::ResetCurrentTime(this);
  cnframework::ActiveObjectBase::ResetEventQueue(this);
}

void *raven::RavenDeltaVIOEstimateActiveObject::GetActiveObjectName@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "RavenDeltaVIOEstimateActiveObject");
}

void sub_18E19E7A4(uint64_t a1)
{
  sub_18E0B8920(a1);

  JUMPOUT(0x192FA6240);
}

uint64_t **sub_18E19E7DC(uint64_t **result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *result;
    uint64_t v3 = a2 - 0xF0F0F0F0F0F0F0FLL * (((uint64_t)result[1] - **result) >> 6);
    if (v3 < 1)
    {
      unint64_t v7 = 15 - v3;
      long long v8 = &v2[-(v7 >> 4)];
      *uint64_t result = v8;
      uint64_t v5 = *v8;
      unsigned int v6 = ~v7 & 0xF;
    }
    else
    {
      long long v4 = (uint64_t *)((char *)v2 + (((unint64_t)v3 >> 1) & 0x7FFFFFFFFFFFFFF8));
      *uint64_t result = v4;
      uint64_t v5 = *v4;
      unsigned int v6 = v3 & 0xF;
    }
    result[1] = (uint64_t *)(v5 + 1088 * v6);
  }
  return result;
}

BOOL sub_18E19E850(void *a1)
{
  uint64_t v2 = a1[1];
  uint64_t v1 = a1[2];
  if (v1 == v2) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = 2 * (v1 - v2) - 1;
  }
  unint64_t v4 = v3 - (a1[5] + a1[4]);
  if (v4 >= 0x20)
  {
    operator delete(*(void **)(v1 - 8));
    a1[2] -= 8;
  }
  return v4 > 0x1F;
}

void *sub_18E19E8B8(void *result, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  unsigned int v6 = a4;
  uint64_t v7 = a2;
  if (a2 != a3)
  {
    long long v30 = result;
    uint64_t v8 = *a4;
    uint64_t v9 = a3;
    while (1)
    {
      int64_t v10 = 0xF0F0F0F0F0F0F0F1 * ((a5 - v8) >> 6);
      if ((uint64_t)(0xF0F0F0F0F0F0F0F1 * ((v9 - v7) >> 6)) >= v10) {
        unint64_t v11 = v10;
      }
      else {
        unint64_t v11 = 0xF0F0F0F0F0F0F0F1 * ((v9 - v7) >> 6);
      }
      if (v11)
      {
        uint64_t v12 = 0;
        do
        {
          uint64_t v13 = a5 + v12;
          uint64_t v14 = v9 + v12;
          uint64_t v15 = a5 + v12 - 1088;
          *(_OWORD *)uint64_t v15 = *(_OWORD *)(v9 + v12 - 1088);
          long long v16 = *(_OWORD *)(v9 + v12 - 1072);
          long long v17 = *(_OWORD *)(v9 + v12 - 1056);
          long long v18 = *(_OWORD *)(v9 + v12 - 1024);
          *(_OWORD *)(v15 + 48) = *(_OWORD *)(v9 + v12 - 1040);
          *(_OWORD *)(v15 + 64) = v18;
          *(_OWORD *)(v15 + 16) = v16;
          *(_OWORD *)(v15 + 32) = v17;
          long long v19 = *(_OWORD *)(v9 + v12 - 1008);
          long long v20 = *(_OWORD *)(v9 + v12 - 992);
          long long v21 = *(_OWORD *)(v9 + v12 - 960);
          *(_OWORD *)(v15 + 112) = *(_OWORD *)(v9 + v12 - 976);
          *(_OWORD *)(v15 + 128) = v21;
          *(_OWORD *)(v15 + 80) = v19;
          *(_OWORD *)(v15 + 96) = v20;
          long long v22 = *(_OWORD *)(v9 + v12 - 944);
          long long v23 = *(_OWORD *)(v9 + v12 - 928);
          long long v24 = *(_OWORD *)(v9 + v12 - 912);
          *(unsigned char *)(v15 + 192) = *(unsigned char *)(v9 + v12 - 896);
          *(_OWORD *)(v15 + 160) = v23;
          *(_OWORD *)(v15 + 176) = v24;
          *(_OWORD *)(v15 + 144) = v22;
          if (v9 != a5)
          {
            *(_OWORD *)(v13 - 888) = *(_OWORD *)(v14 - 888);
            *(_OWORD *)(v13 - 872) = *(_OWORD *)(v14 - 872);
          }
          sub_18DFE2F24(v13 - 856, v14 - 856);
          sub_18DFE2F24(v13 - 792, v14 - 792);
          sub_18DFE2F24(v13 - 680, v14 - 680);
          sub_18DFE2F24(v13 - 568, v14 - 568);
          *(unsigned char *)(v13 - 456) = *(unsigned char *)(v14 - 456);
          if (v14 != v13)
          {
            *(_OWORD *)(a5 + v12 - 448) = *(_OWORD *)(v9 + v12 - 448);
            *(_OWORD *)(a5 + v12 - 432) = *(_OWORD *)(v9 + v12 - 432);
          }
          uint64_t v25 = a5 + v12;
          sub_18DFE2F24(a5 + v12 - 416, v9 + v12 - 416);
          sub_18DFE2F24(a5 + v12 - 352, v9 + v12 - 352);
          sub_18DFE2F24(a5 + v12 - 240, v9 + v12 - 240);
          sub_18DFE2F24(a5 + v12 - 128, v9 + v12 - 128);
          *(unsigned char *)(v25 - 16) = *(unsigned char *)(v9 + v12 - 16);
          __int16 v26 = *(_WORD *)(v9 + v12 - 8);
          *(unsigned char *)(v25 - 6) = *(unsigned char *)(v9 + v12 - 6);
          *(_WORD *)(v25 - 8) = v26;
          v12 -= 1088;
        }
        while (-1088 * v11 != v12);
        a5 += v12;
      }
      v9 -= 1088 * v11;
      if (v9 == v7) {
        break;
      }
      uint64_t v27 = *--v6;
      uint64_t v8 = v27;
      a5 = v27 + 17408;
    }
    if (*v6 + 17408 == a5)
    {
      uint64_t v28 = v6[1];
      ++v6;
      a5 = v28;
    }
    uint64_t v7 = a3;
    uint64_t result = v30;
  }
  *uint64_t result = v7;
  result[1] = v6;
  result[2] = a5;
  return result;
}

void *sub_18E19EAE4(void *result, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  unsigned int v6 = a4;
  uint64_t v7 = a2;
  if (a2 == a3)
  {
    uint64_t v8 = a2;
  }
  else
  {
    uint64_t v8 = a3;
    uint64_t v28 = result;
    uint64_t v9 = *a4;
    while (1)
    {
      int64_t v10 = 0xF0F0F0F0F0F0F0F1 * ((v9 - a5 + 17408) >> 6);
      if ((uint64_t)(0xF0F0F0F0F0F0F0F1 * ((v8 - v7) >> 6)) < v10) {
        int64_t v10 = 0xF0F0F0F0F0F0F0F1 * ((v8 - v7) >> 6);
      }
      if (v10)
      {
        uint64_t v11 = 0;
        uint64_t v12 = v7 + 1088 * v10;
        do
        {
          uint64_t v13 = v7 + v11;
          uint64_t v14 = a5 + v11;
          *(_OWORD *)uint64_t v14 = *(_OWORD *)(v7 + v11);
          long long v15 = *(_OWORD *)(v7 + v11 + 16);
          long long v16 = *(_OWORD *)(v7 + v11 + 32);
          long long v17 = *(_OWORD *)(v7 + v11 + 64);
          *(_OWORD *)(v14 + 48) = *(_OWORD *)(v7 + v11 + 48);
          *(_OWORD *)(v14 + 64) = v17;
          *(_OWORD *)(v14 + 16) = v15;
          *(_OWORD *)(v14 + 32) = v16;
          long long v18 = *(_OWORD *)(v7 + v11 + 80);
          long long v19 = *(_OWORD *)(v7 + v11 + 96);
          long long v20 = *(_OWORD *)(v7 + v11 + 128);
          *(_OWORD *)(v14 + 112) = *(_OWORD *)(v7 + v11 + 112);
          *(_OWORD *)(v14 + 128) = v20;
          *(_OWORD *)(v14 + 80) = v18;
          *(_OWORD *)(v14 + 96) = v19;
          long long v21 = *(_OWORD *)(v7 + v11 + 144);
          long long v22 = *(_OWORD *)(v7 + v11 + 160);
          long long v23 = *(_OWORD *)(v7 + v11 + 176);
          *(unsigned char *)(v14 + 192) = *(unsigned char *)(v7 + v11 + 192);
          *(_OWORD *)(v14 + 160) = v22;
          *(_OWORD *)(v14 + 176) = v23;
          *(_OWORD *)(v14 + 144) = v21;
          if (a5 != v7)
          {
            *(_OWORD *)(v14 + 200) = *(_OWORD *)(v13 + 200);
            *(_OWORD *)(v14 + 216) = *(_OWORD *)(v13 + 216);
          }
          sub_18DFE2F24(v14 + 232, v13 + 232);
          sub_18DFE2F24(v14 + 296, v13 + 296);
          sub_18DFE2F24(v14 + 408, v13 + 408);
          sub_18DFE2F24(v14 + 520, v13 + 520);
          *(unsigned char *)(v14 + 632) = *(unsigned char *)(v13 + 632);
          if (v14 != v13)
          {
            uint64_t v24 = a5 + v11;
            *(_OWORD *)(v24 + 640) = *(_OWORD *)(v7 + v11 + 640);
            *(_OWORD *)(v24 + 656) = *(_OWORD *)(v7 + v11 + 656);
          }
          sub_18DFE2F24(v14 + 672, v13 + 672);
          sub_18DFE2F24(v14 + 736, v13 + 736);
          sub_18DFE2F24(v14 + 848, v13 + 848);
          sub_18DFE2F24(v14 + 960, v13 + 960);
          *(unsigned char *)(v14 + 1072) = *(unsigned char *)(v13 + 1072);
          __int16 v25 = *(_WORD *)(v13 + 1080);
          *(unsigned char *)(v14 + 1082) = *(unsigned char *)(v13 + 1082);
          *(_WORD *)(v14 + 1080) = v25;
          v11 += 1088;
        }
        while (v13 + 1088 != v12);
        a5 += v11;
        uint64_t v7 = v12;
      }
      if (v7 == v8) {
        break;
      }
      uint64_t v26 = v6[1];
      ++v6;
      uint64_t v9 = v26;
      a5 = v26;
    }
    if (*v6 + 17408 == a5)
    {
      uint64_t v27 = v6[1];
      ++v6;
      a5 = v27;
    }
    uint64_t result = v28;
  }
  *uint64_t result = v8;
  result[1] = v6;
  result[2] = a5;
  return result;
}

swan::BatchedGNSSDataSmoother *swan::BatchedGNSSDataSmoother::BatchedGNSSDataSmoother(swan::BatchedGNSSDataSmoother *this)
{
  *(void *)this = &unk_1EDD161B0;
  sub_18DEDE7B0((void *)this + 1, "");
  *(void *)this = &unk_1EDD125A8;
  *(_WORD *)((char *)this + 33) = 0;
  *((unsigned char *)this + 35) = 0;
  *(_WORD *)((char *)this + 291) = 0;
  *((_WORD *)this + 274) = 0;
  *(_WORD *)((char *)this + 805) = 0;
  *((unsigned char *)this + 1062) = 0;
  *((_WORD *)this + 659) = 0;
  *((unsigned char *)this + 1575) = 0;
  *((void *)this + 197) = 0x4014000000000000;
  *((_OWORD *)this + 99) = xmmword_18E22B8E0;
  *((_OWORD *)this + 100) = xmmword_18E22B8F0;
  *((_OWORD *)this + 101) = xmmword_18E22B900;
  *((void *)this + 204) = 0x4006A09E667F3BCCLL;
  return this;
}

uint64_t sub_18E19EDB8(uint64_t a1)
{
  *(void *)a1 = &unk_1EDD161B0;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t swan::BatchedGNSSDataSmoother::Configure(swan::BatchedGNSSDataSmoother *this, const char *a2)
{
  return sub_18E19EE2C((uint64_t)this, (uint64_t)a2, 0) - 1;
}

uint64_t sub_18E19EE2C(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3 = a1;
  v37[19] = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 32) = a3;
  sub_18DEDE4A4(v35);
  uint64_t v9 = v35[0];
  if ((v36[*(void *)(v35[0] - 24) + 16] & 5) != 0)
  {
    LOWORD(__str.__r_.__value_.__l.__data_) = 0;
    v32.__r_.__value_.__s.__data_[0] = 2;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&__str, (unsigned __int8 *)&v32, "ConfigLoader: could not open config file, using default values", v4, v5, v6, v7, v8, v30);
  }
  else
  {
    int64_t v10 = (std::string *)(v3 + 8);
    uint64_t v31 = v3;
    if (*(char *)(v3 + 31) < 0)
    {
      *(void *)(v3 + 16) = 0;
      uint64_t v11 = *(unsigned char **)(v3 + 8);
    }
    else
    {
      *(unsigned char *)(v3 + 31) = 0;
      uint64_t v11 = (unsigned char *)(v3 + 8);
    }
    unsigned char *v11 = 0;
    memset(&__str, 0, sizeof(__str));
    uint64_t v12 = (std::locale::id *)MEMORY[0x1E4FBA258];
    while (1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)v35 + *(void *)(v9 - 24)));
      uint64_t v13 = std::locale::use_facet((const std::locale *)&v32, v12);
      unsigned __int8 v14 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
      std::locale::~locale((std::locale *)&v32);
      long long v15 = sub_18E00F294(v35, (uint64_t)&__str, v14);
      std::string::size_type v16 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      LOBYTE(v17) = *((unsigned char *)&__str.__r_.__value_.__s + 23);
      if ((*((unsigned char *)v15 + *(void *)(*v15 - 24) + 32) & 5) != 0) {
        break;
      }
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int64_t v19 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      }
      else {
        int64_t v19 = __str.__r_.__value_.__l.__size_;
      }
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_str = &__str;
      }
      else {
        p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      if (v19 >= 1)
      {
        long long v21 = (char *)p_str + v19;
        long long v22 = p_str;
        do
        {
          long long v23 = memchr(v22, 35, v19);
          if (!v23) {
            break;
          }
          if (*v23 == 35)
          {
            if (v23 != v21 && v23 - (unsigned char *)p_str != -1)
            {
              std::string::basic_string(&v32, &__str, 0, v23 - (unsigned char *)p_str, (std::allocator<char> *)&v34);
              if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__str.__r_.__value_.__l.__data_);
              }
              std::string __str = v32;
              std::string::size_type v16 = HIBYTE(v32.__r_.__value_.__r.__words[2]);
              std::string::size_type size = v32.__r_.__value_.__l.__size_;
              std::string::size_type v17 = HIBYTE(v32.__r_.__value_.__r.__words[2]);
            }
            break;
          }
          long long v22 = (std::string *)(v23 + 1);
          int64_t v19 = v21 - (unsigned char *)v22;
        }
        while (v21 - (unsigned char *)v22 >= 1);
      }
      if ((v17 & 0x80u) != 0) {
        std::string::size_type v16 = size;
      }
      sub_18DF06474((uint64_t)&v32, v16 + 1);
      if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v24 = &v32;
      }
      else {
        uint64_t v24 = (std::string *)v32.__r_.__value_.__r.__words[0];
      }
      if (v16)
      {
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          __int16 v25 = &__str;
        }
        else {
          __int16 v25 = (std::string *)__str.__r_.__value_.__r.__words[0];
        }
        memmove(v24, v25, v16);
      }
      *(_WORD *)((char *)&v24->__r_.__value_.__l.__data_ + v16) = 10;
      if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v26 = &v32;
      }
      else {
        uint64_t v26 = (std::string *)v32.__r_.__value_.__r.__words[0];
      }
      if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v27 = HIBYTE(v32.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v27 = v32.__r_.__value_.__l.__size_;
      }
      std::string::append(v10, (const std::string::value_type *)v26, v27);
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v32.__r_.__value_.__l.__data_);
      }
      uint64_t v9 = v35[0];
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    uint64_t v3 = v31;
  }
  uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 32))(v3);
  v35[0] = *MEMORY[0x1E4FBA3F8];
  *(uint64_t *)((char *)v35 + *(void *)(v35[0] - 24)) = *(void *)(MEMORY[0x1E4FBA3F8] + 24);
  MEMORY[0x192FA5DA0](v36);
  std::istream::~istream();
  MEMORY[0x192FA6190](v37);
  return v28;
}

void sub_18E19F200(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23)
{
}

uint64_t swan::BatchedGNSSDataSmoother::Configure(uint64_t a1, uint64_t a2)
{
  std::string::operator=((std::string *)(a1 + 8), (const std::string *)(a2 + 8));
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  memcpy((void *)(a1 + 33), (const void *)(a2 + 33), 0x647uLL);
  return 0;
}

uint64_t swan::BatchedGNSSDataSmoother::Run(char *a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  int v8 = a1[34];
  if (!a1[34] && !a1[291]) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = (char *)operator new(0x79180uLL);
  uint64_t v38 = v9 + 496000;
  float64x2_t v39 = v9 + 496000;
  unint64_t v36 = 0;
  float64x2_t v37 = v9;
  if (v8)
  {
    sub_18DEDE7B0(&v33, a1 + 35);
    sub_18DEDE7B0(&v30, a1 + 1062);
    uint64_t v29 = 0;
    long long v27 = 0u;
    long long v28 = 0u;
    *(_OWORD *)__int16 v25 = 0u;
    long long v26 = 0u;
    if (a1[33])
    {
      if (!swan::BatchLogParser::parseGPSBatchIntoASCII((uint64_t)v25))
      {
        sub_18DEDE7B0(&v22, a1 + 1062);
        sub_18DEDE7B0(__p, ".4.csv");
        if ((v21 & 0x80u) == 0) {
          int64_t v10 = __p;
        }
        else {
          int64_t v10 = (void **)__p[0];
        }
        if ((v21 & 0x80u) == 0) {
          std::string::size_type v11 = v21;
        }
        else {
          std::string::size_type v11 = (std::string::size_type)__p[1];
        }
        uint64_t v12 = std::string::append(&v22, (const std::string::value_type *)v10, v11);
        long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
        std::string::size_type v24 = v12->__r_.__value_.__r.__words[2];
        *(_OWORD *)long long v23 = v13;
        v12->__r_.__value_.__l.__size_ = 0;
        v12->__r_.__value_.__r.__words[2] = 0;
        v12->__r_.__value_.__r.__words[0] = 0;
        if ((char)v21 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v22.__r_.__value_.__l.__data_);
        }
        int v14 = swan::BatchLogParser::convertASCIIToStruct((uint64_t)v25);
        goto LABEL_25;
      }
    }
    else if (!swan::BatchLogParser::parseGPSSaIntoASCII((uint64_t)v25))
    {
      sub_18DEDE7B0(v23, a1 + 1062);
      int v14 = swan::BatchLogParser::convertASCIIToStruct((uint64_t)v25);
      --v36;
LABEL_25:
      if (SHIBYTE(v24) < 0)
      {
        operator delete(v23[0]);
        if (v14) {
          goto LABEL_27;
        }
      }
      else if (v14)
      {
        goto LABEL_27;
      }
      sub_18E1A3308((void *)&v26 + 1);
      if (SBYTE7(v26) < 0) {
        operator delete(v25[0]);
      }
      if (SHIBYTE(v32) < 0) {
        operator delete(v30);
      }
      if (SHIBYTE(v35) < 0) {
        operator delete(v33);
      }
      goto LABEL_42;
    }
LABEL_27:
    sub_18E1A3308((void *)&v26 + 1);
    if (SBYTE7(v26) < 0) {
      operator delete(v25[0]);
    }
    if (SHIBYTE(v32) < 0) {
      operator delete(v30);
    }
    if (SHIBYTE(v35) < 0) {
      operator delete(v33);
    }
    goto LABEL_34;
  }
  if (a1[291])
  {
    sub_18DEDE7B0(&v33, a1 + 292);
    uint64_t v29 = 0;
    long long v27 = 0u;
    long long v28 = 0u;
    *(_OWORD *)__int16 v25 = 0u;
    long long v26 = 0u;
    int v15 = swan::BatchLogParser::convertASCIIToStruct((uint64_t)v25);
    sub_18E1A3308((void *)&v26 + 1);
    if (SBYTE7(v26) < 0) {
      operator delete(v25[0]);
    }
    if (SHIBYTE(v35) < 0)
    {
      operator delete(v33);
      if (!v15) {
        goto LABEL_42;
      }
    }
    else if (!v15)
    {
      goto LABEL_42;
    }
LABEL_34:
    char v16 = 0;
    uint64_t v17 = 0xFFFFFFFFLL;
    goto LABEL_54;
  }
LABEL_42:
  LODWORD(v22.__r_.__value_.__l.__data_) = 0;
  v25[0] = 0;
  v25[1] = 0;
  *(void *)&long long v26 = 0;
  sub_18E0E8750(v25, v36);
  double v33 = 0;
  char v34 = 0;
  uint64_t v35 = 0;
  sub_18E0E8750(&v33, v36);
  char v30 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  sub_18E0E8750(&v33, v36);
  v23[0] = 0;
  v23[1] = 0;
  std::string::size_type v24 = 0;
  sub_18E19F7C4((uint64_t)v23, v36);
  int v18 = swan::BatchedGNSSDataSmoother::Run((uint64_t)a1, (uint64_t *)&v37, v36, &v22, v25, &v33, &v30, a2, a3, a4, (uint64_t *)v23);
  if (v18 | LODWORD(v22.__r_.__value_.__l.__data_)) {
    uint64_t v17 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v17 = 0;
  }
  if (v23[0]) {
    operator delete(v23[0]);
  }
  if (v30)
  {
    uint64_t v31 = v30;
    operator delete(v30);
  }
  if (v33)
  {
    char v34 = v33;
    operator delete(v33);
  }
  if (v25[0])
  {
    v25[1] = v25[0];
    operator delete(v25[0]);
  }
  char v16 = 1;
LABEL_54:
  if (v37)
  {
    uint64_t v38 = v37;
    operator delete(v37);
  }
  if ((v16 & 1) == 0) {
    return 0xFFFFFFFFLL;
  }
  return v17;
}

void sub_18E19F674(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  sub_18E19F788((uint64_t)&a32);
  if (*(char *)(v33 - 121) < 0) {
    operator delete(*(void **)(v33 - 144));
  }
  if (*(char *)(v33 - 97) < 0) {
    operator delete(*(void **)(v33 - 120));
  }
  uint64_t v35 = *(void **)(v33 - 88);
  if (v35)
  {
    *(void *)(v33 - 80) = v35;
    operator delete(v35);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_18E19F788(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_18E19F7C4(uint64_t a1, unint64_t a2)
{
  if (a2 > *(void *)(a1 + 16) << 6)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      sub_18DEE1FC8();
    }
    long long v17 = 0uLL;
    uint64_t v3 = (uint64_t *)sub_18DEDF808((uint64_t)&v17 + 8, ((a2 - 1) >> 6) + 1);
    uint64_t v4 = *(void **)a1;
    unint64_t v5 = *(void *)(a1 + 8);
    int v6 = v5 & 0x3F;
    *(void *)&long long v17 = v5;
    *((void *)&v17 + 1) = v7;
    unint64_t v8 = (v5 - 1) >> 6;
    if (v5 < 0x41) {
      unint64_t v8 = 0;
    }
    v3[v8] = 0;
    if (v5 > 0x3F || (v5 & 0x3F) != 0)
    {
      int v9 = 0;
      int v10 = 0;
      std::string::size_type v11 = &v4[v5 >> 6];
      uint64_t v12 = v4;
      long long v13 = v3;
      do
      {
        uint64_t v14 = 1 << v9;
        if ((*v12 >> v10)) {
          uint64_t v15 = *v13 | v14;
        }
        else {
          uint64_t v15 = *v13 & ~v14;
        }
        *long long v13 = v15;
        v12 += v10 == 63;
        if (v10 == 63) {
          int v10 = 0;
        }
        else {
          ++v10;
        }
        v13 += v9 == 63;
        if (v9 == 63) {
          int v9 = 0;
        }
        else {
          ++v9;
        }
      }
      while (v10 != v6 || v12 != v11);
    }
    *(void *)a1 = v3;
    long long v16 = *(_OWORD *)(a1 + 8);
    *(_OWORD *)(a1 + 8) = v17;
    *((void *)&v17 + 1) = *((void *)&v16 + 1);
    if (v4) {
      operator delete(v4);
    }
  }
}

void sub_18E19F8E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t swan::BatchedGNSSDataSmoother::Run(uint64_t a1, uint64_t *a2, unint64_t a3, _DWORD *a4, void *a5, void *a6, void *a7, uint64_t a8, uint64_t a9, unint64_t *a10, uint64_t *a11)
{
  if (a5[1] != *a5 || a6[1] != *a6 || a7[1] != *a7 || *(void *)(a8 + 8) != *(void *)a8) {
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(a9 + 8) != *(void *)a9 || a11[1] != 0) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v19 = a3;
  sub_18E0F6058(v65, a3);
  sub_18E1A3460(v64, v19);
  sub_18E1A3530(v63, v19);
  sub_18E1A3530(v62, v19);
  sub_18E0F6058(v61, v19);
  sub_18E0F6058(v60, v19);
  sub_18E1A3460(v59, v19);
  sub_18E1A35C8(v58, v19);
  sub_18E1A3460(v57, v19);
  std::string v22 = sub_18E1A35C8(v56, v19);
  if (*(unsigned char *)(a1 + 805))
  {
    unint64_t v19 = 224;
    swan::BatchedGNSSDataSmoother::LoadMATLAB((uint64_t)v22, (const char *)(a1 + 806), 0xE0uLL, v65, v64, v63, v62, (uint64_t)v82, (uint64_t)v66, v61, v60);
  }
  else
  {
    sub_18E0C4D50((uint64_t)a6, v19);
    sub_18E1A05B4(a7, v19);
    if (swan::BatchedGNSSDataSmoother::formatData((double *)a1, a2, v19, (uint64_t)v82, (uint64_t)v66, v65, (uint64_t *)v64, (double **)v63, (double **)v62, a6, a7))goto LABEL_53; {
    if (v19)
    }
    {
      uint64_t v29 = 0;
      char v30 = v61[0];
      uint64_t v31 = v60[0];
      do
      {
        v30[v29] = *(void *)(a1 + 1584);
        v31[v29++] = *(void *)(a1 + 1592);
      }
      while (v19 > v29);
    }
  }
  v55[1] = 0x4202A05F20000000;
  if (!swan::ForwardBackwardFixedIntervalSmoother::Update(a1 + 1640, (uint64_t)v82, (uint64_t)v66, v19, (uint64_t)v65, (uint64_t)v64, (uint64_t)v63, (uint64_t)v62, (double **)v61, (double **)v60, 1))
  {
    if (v19)
    {
      unint64_t v23 = v19;
      do
      {
        unint64_t v24 = a11[1];
        uint64_t v25 = a11[2];
        if (v24 == v25 << 6)
        {
          if ((uint64_t)(v24 + 1) < 0) {
            sub_18DEE1FC8();
          }
          unint64_t v26 = v25 << 7;
          if (v26 <= (v24 & 0xFFFFFFFFFFFFFFC0) + 64) {
            unint64_t v26 = (v24 & 0xFFFFFFFFFFFFFFC0) + 64;
          }
          if (v24 <= 0x3FFFFFFFFFFFFFFELL) {
            unint64_t v27 = v26;
          }
          else {
            unint64_t v27 = 0x7FFFFFFFFFFFFFFFLL;
          }
          sub_18E19F7C4((uint64_t)a11, v27);
          unint64_t v24 = a11[1];
        }
        a11[1] = v24 + 1;
        *(void *)(*a11 + ((v24 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v24;
        --v23;
      }
      while (v23);
    }
    if (!*(unsigned char *)(a1 + 1575)) {
      goto LABEL_50;
    }
    v55[0] = 0;
    sub_18E13B61C(__p, v19);
    sub_18E1A0E28(__p, v19);
    if (swan::PositionVelocityDataEditor::TestNormalizedInnovations(*(double *)(a1 + 1576), a1 + 1641, v19, (uint64_t *)v59, (double **)v58, v55, (uint64_t *)__p))goto LABEL_27; {
    unint64_t v32 = v55[0];
    }
    uint64_t v33 = v55[0] - 1;
    if (v55[0] - 1 >= vcvtad_u64_f64((double)v19 * 0.1)) {
      goto LABEL_46;
    }
    if (v19)
    {
      unint64_t v34 = 0;
      unsigned int v35 = 0;
      uint64_t v36 = *a11;
      do
      {
        *(void *)(v36 + 8 * (v34 >> 6)) &= ~(1 << v34);
        if (*(void *)__p[0] != v34)
        {
          unint64_t v37 = 0;
          while (v33 != v37)
          {
            uint64_t v38 = *((void *)__p[0] + ++v37);
            if (v38 == v34)
            {
              if (v37 < v32) {
                goto LABEL_42;
              }
              break;
            }
          }
          *((void *)v65[0] + v35) = *((void *)v65[0] + v34);
          float64x2_t v39 = (long long *)((char *)v64[0] + 48 * v34);
          float64x2_t v40 = (char *)v64[0] + 48 * v35;
          long long v41 = v39[2];
          long long v42 = *v39;
          v40[1] = v39[1];
          void v40[2] = v41;
          *float64x2_t v40 = v42;
          long long v43 = (char *)v63[0] + 24 * v34;
          long long v44 = (char *)v63[0] + 24 * v35;
          long long v45 = *(_OWORD *)v43;
          *((void *)v44 + 2) = *((void *)v43 + 2);
          *(_OWORD *)long long v44 = v45;
          uint64_t v46 = (char *)v62[0] + 24 * v34;
          uint64_t v47 = (char *)v62[0] + 24 * v35;
          long long v48 = *(_OWORD *)v46;
          *((void *)v47 + 2) = *((void *)v46 + 2);
          *(_OWORD *)uint64_t v47 = v48;
          *(void *)(*a6 + 8 * v35) = *(void *)(*a6 + 8 * v34);
          *(_DWORD *)(*a7 + 4 * v35) = *(_DWORD *)(*a7 + 4 * v34);
          uint64_t v36 = *a11;
          *(void *)(*a11 + 8 * (v34 >> 6)) |= 1 << v34;
          ++v35;
        }
LABEL_42:
        ++v34;
      }
      while (v34 != v19);
    }
    uint64_t v49 = 0;
    long long v50 = (char *)v64[0];
    do
    {
      *(void *)&v82[v49] = *(void *)&v50[v49];
      v49 += 8;
    }
    while (v49 != 48);
    long long v80 = 0u;
    long long v81 = 0u;
    long long v78 = 0u;
    long long v79 = 0u;
    long long v76 = 0u;
    long long v77 = 0u;
    long long v74 = 0u;
    long long v75 = 0u;
    long long v72 = 0u;
    long long v73 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v67 = 0u;
    memset(v66, 0, sizeof(v66));
    double v51 = *((double *)v63[0] + 1) * *((double *)v63[0] + 1);
    v66[0] = *(double *)v63[0] * *(double *)v63[0];
    *((double *)&v67 + 1) = v51;
    *(double *)&long long v71 = *((double *)v63[0] + 2) * *((double *)v63[0] + 2);
    *((double *)&v74 + 1) = *(double *)v62[0] * *(double *)v62[0];
    *(double *)&long long v78 = *((double *)v62[0] + 1) * *((double *)v62[0] + 1);
    *((double *)&v81 + 1) = *((double *)v62[0] + 2) * *((double *)v62[0] + 2);
    v19 -= v32;
    if (swan::ForwardBackwardFixedIntervalSmoother::Update(a1 + 1640, (uint64_t)v82, (uint64_t)v66, v19, (uint64_t)v65, (uint64_t)v64, (uint64_t)v63, (uint64_t)v62, (double **)v61, (double **)v60, 1))LABEL_27:char v28 = 0; {
    else
    }
LABEL_46:
      char v28 = 1;
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v28)
    {
LABEL_50:
      __p[0] = 0;
      uint64_t updated = swan::ConsistencyChecker::UpdateNormalizedInnovationsSquared(a1 + 1642, v19, 6u, v59, v58, (double *)__p);
      *a4 = 0;
      uint64_t v53 = swan::BatchedGNSSDataSmoother::CopySmootherOutputs(updated, v19, (uint64_t *)v65, v57, v56, (uint64_t)a5, (void **)a8, (void **)a9);
      if (*(unsigned char *)(a1 + 548)) {
        swan::BatchedGNSSDataSmoother::SaveToDisk(v53, (const char *)(a1 + 549), v19, v65, v57, v56, v59, v58);
      }
      uint64_t v15 = 0;
      *a10 = v19;
      goto LABEL_54;
    }
  }
LABEL_53:
  uint64_t v15 = 0xFFFFFFFFLL;
LABEL_54:
  if (v56[0])
  {
    v56[1] = v56[0];
    operator delete(v56[0]);
  }
  if (v57[0])
  {
    v57[1] = v57[0];
    operator delete(v57[0]);
  }
  if (v58[0])
  {
    v58[1] = v58[0];
    operator delete(v58[0]);
  }
  if (v59[0])
  {
    v59[1] = v59[0];
    operator delete(v59[0]);
  }
  if (v60[0])
  {
    v60[1] = v60[0];
    operator delete(v60[0]);
  }
  if (v61[0])
  {
    v61[1] = v61[0];
    operator delete(v61[0]);
  }
  if (v62[0])
  {
    v62[1] = v62[0];
    operator delete(v62[0]);
  }
  if (v63[0])
  {
    v63[1] = v63[0];
    operator delete(v63[0]);
  }
  if (v64[0])
  {
    v64[1] = v64[0];
    operator delete(v64[0]);
  }
  if (v65[0])
  {
    v65[1] = v65[0];
    operator delete(v65[0]);
  }
  return v15;
}

void sub_18E19FF94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53)
{
  if (__p) {
    operator delete(__p);
  }
  if (a25) {
    operator delete(a25);
  }
  if (a28) {
    operator delete(a28);
  }
  if (a31) {
    operator delete(a31);
  }
  if (a34) {
    operator delete(a34);
  }
  if (a37) {
    operator delete(a37);
  }
  if (a40) {
    operator delete(a40);
  }
  if (a43) {
    operator delete(a43);
  }
  if (a46) {
    operator delete(a46);
  }
  if (a49) {
    operator delete(a49);
  }
  if (a52) {
    operator delete(a52);
  }
  _Unwind_Resume(exception_object);
}

uint64_t swan::BatchedGNSSDataSmoother::LoadMATLAB(uint64_t a1, const char *a2, unint64_t a3, void *a4, void *a5, void *a6, void *a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x100uLL, "%s%s", a2, "t_noisy.txt");
  int v18 = fopen(__str, "r");
  if (!v18) {
    goto LABEL_32;
  }
  unint64_t v19 = v18;
  uint64_t v52 = a8;
  long long v20 = a2;
  if (a3)
  {
    uint64_t v21 = 0;
    unint64_t v22 = a3;
    do
    {
      fscanf(v19, "%lf\n", *a4 + v21);
      v21 += 8;
      --v22;
    }
    while (v22);
  }
  fclose(v19);
  snprintf(__str, 0x100uLL, "%s%s", a2, "x_noisy.txt");
  unint64_t v23 = fopen(__str, "r");
  if (!v23) {
    goto LABEL_32;
  }
  unint64_t v24 = v23;
  if (a3)
  {
    unint64_t v25 = 0;
    unsigned int v26 = 1;
    do
    {
      uint64_t v27 = *a5 + 48 * v25;
      fscanf(v24, "%lf %lf %lf %lf %lf %lf\n", v27, v27 + 8, v27 + 16, v27 + 24, v27 + 32, v27 + 40);
      unint64_t v25 = v26++;
    }
    while (v25 < a3);
  }
  fclose(v24);
  char v28 = v20;
  snprintf(__str, 0x100uLL, "%s%s", v20, "sigma_x.txt");
  uint64_t v29 = fopen(__str, "r");
  if (!v29) {
    goto LABEL_32;
  }
  char v30 = v29;
  if (a3)
  {
    unint64_t v31 = 0;
    unsigned int v32 = 1;
    do
    {
      fscanf(v30, "%lf %lf %lf\n", *a6 + 24 * v31, *a6 + 24 * v31 + 8, *a6 + 24 * v31 + 16);
      unint64_t v31 = v32++;
    }
    while (v31 < a3);
  }
  fclose(v30);
  snprintf(__str, 0x100uLL, "%s%s", v20, "sigma_vx.txt");
  uint64_t v33 = fopen(__str, "r");
  if (!v33) {
    goto LABEL_32;
  }
  unint64_t v34 = v33;
  if (a3)
  {
    unint64_t v35 = 0;
    unsigned int v36 = 1;
    do
    {
      fscanf(v34, "%lf %lf %lf\n", *a7 + 24 * v35, *a7 + 24 * v35 + 8, *a7 + 24 * v35 + 16);
      unint64_t v35 = v36++;
    }
    while (v35 < a3);
  }
  fclose(v34);
  snprintf(__str, 0x100uLL, "%s%s", v20, "x0.txt");
  unint64_t v37 = fopen(__str, "r");
  if (!v37) {
    goto LABEL_32;
  }
  uint64_t v38 = v37;
  for (uint64_t i = 0; i != 48; i += 8)
    fscanf(v38, "%lf\n", v52 + i);
  fclose(v38);
  snprintf(__str, 0x100uLL, "%s%s", v20, "P0.txt");
  float64x2_t v40 = fopen(__str, "r");
  if (!v40) {
    goto LABEL_32;
  }
  long long v41 = v40;
  for (uint64_t j = 0; j != 288; j += 48)
    fscanf(v41, "%lf %lf %lf %lf %lf %lf\n", a9 + j, a9 + j + 8, a9 + j + 16, a9 + j + 24, a9 + j + 32, a9 + j + 40);
  fclose(v41);
  snprintf(__str, 0x100uLL, "%s%s", v28, "sigma_wx_horizontal.txt");
  long long v43 = fopen(__str, "r");
  if (!v43) {
    goto LABEL_32;
  }
  if (a3)
  {
    long long v44 = v43;
    unint64_t v45 = 0;
    unsigned int v46 = 1;
    do
    {
      fscanf(v44, "%lf\n", *a10 + 8 * v45);
      unint64_t v45 = v46++;
    }
    while (v45 < a3);
  }
  snprintf(__str, 0x100uLL, "%s%s", v28, "sigma_wx_vertical.txt");
  uint64_t v47 = fopen(__str, "r");
  if (v47)
  {
    long long v48 = v47;
    if (a3)
    {
      unint64_t v49 = 0;
      unsigned int v50 = 1;
      do
      {
        fscanf(v48, "%lf\n", *a11 + 8 * v49);
        unint64_t v49 = v50++;
      }
      while (v49 < a3);
    }
    fclose(v48);
    return 0;
  }
  else
  {
LABEL_32:
    printf("Error opening %s. Exiting.\n", __str);
    return 0xFFFFFFFFLL;
  }
}

void sub_18E1A05B4(void *a1, unint64_t a2)
{
  uint64_t v3 = (char *)*a1;
  uint64_t v4 = (char *)a1[1];
  unint64_t v5 = (uint64_t)&v4[-*a1] >> 2;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    long long v20 = &v3[4 * a2];
    goto LABEL_15;
  }
  unint64_t v6 = a2 - v5;
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2];
  if (a2 - v5 <= (v8 - (uint64_t)v4) >> 2)
  {
    bzero(v4, 4 * v6);
    long long v20 = &v4[4 * v6];
LABEL_15:
    a1[1] = v20;
    return;
  }
  if (a2 >> 62) {
    sub_18DEE1FC8();
  }
  uint64_t v9 = v8 - (void)v3;
  uint64_t v10 = v9 >> 1;
  if (v9 >> 1 <= a2) {
    uint64_t v10 = a2;
  }
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v11 = v10;
  }
  uint64_t v12 = (char *)sub_18DFF2948(v7, v11);
  long long v13 = (char *)*a1;
  uint64_t v14 = (char *)a1[1];
  uint64_t v15 = &v12[4 * v5];
  long long v17 = &v12[4 * v16];
  bzero(v15, 4 * v6);
  int v18 = &v15[4 * v6];
  while (v14 != v13)
  {
    int v19 = *((_DWORD *)v14 - 1);
    v14 -= 4;
    *((_DWORD *)v15 - 1) = v19;
    v15 -= 4;
  }
  *a1 = v15;
  a1[1] = v18;
  a1[2] = v17;
  if (v13)
  {
    operator delete(v13);
  }
}

uint64_t swan::BatchedGNSSDataSmoother::formatData(double *a1, uint64_t *a2, unint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t *a7, double **a8, double **a9, void *a10, void *a11)
{
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    uint64_t v15 = 0;
    int v64 = *(_DWORD *)(*a2 + 92);
    double v63 = *(double *)(*a2 + 96) / 1000.0;
    int v16 = 1;
    float64x2_t v62 = (float64x2_t)vdupq_n_s64(0x400921FB54442D18uLL);
    float64x2_t v61 = (float64x2_t)vdupq_n_s64(0x4066800000000000uLL);
    while (1)
    {
      uint64_t v17 = *a2;
      uint64_t v18 = *a2 + 248 * v15;
      int v19 = *(_DWORD *)(v18 + 92);
      *(double *)(*a6 + 8 * v15) = *(double *)(v18 + 96) / 1000.0 - v63 + (double)(v19 - v64) * 604800.0;
      *(double *)(*a10 + 8 * v15) = *(double *)(v18 + 96) / 1000.0;
      *(_DWORD *)(*a11 + 4 * v15) = v19;
      float64x2_t v99 = vdivq_f64(vmulq_f64(*(float64x2_t *)(v18 + 8), v62), v61);
      uint64_t v100 = *(void *)(v18 + 64);
      if (cnnavigation::LLAToECEF(v99.f64, 1, (double *)&v97, 0, (uint64_t)&v78)) {
        break;
      }
      uint64_t v20 = *a7 + 48 * v15;
      *(_OWORD *)uint64_t v20 = v97;
      *(void *)(v20 + 16) = v98;
      double v21 = *(double *)(v17 + 248 * v15 + 56);
      double v22 = 0.0;
      double v23 = 0.0;
      if (v21 > 0.0)
      {
        double v24 = *(double *)(v17 + 248 * v15 + 48);
        __double2 v25 = __sincos_stret(v21 * 3.14159265 / 180.0);
        double v22 = v25.__cosval * v24;
        double v23 = v25.__sinval * v24;
      }
      v95.f64[0] = v22;
      v95.f64[1] = v23;
      double v26 = *(double *)(v17 + 248 * v15 + 232);
      if (v26 > a1[201]) {
        double v26 = 0.0;
      }
      double v96 = v26;
      uint64_t v27 = cnnavigation::ENUToECEF((long long *)&v95, 1, 0, (uint64_t)&v97, 1, &v93);
      if (v27) {
        break;
      }
      uint64_t v28 = *a7;
      uint64_t v29 = *a7 + 48 * v15;
      *(float64x2_t *)(v29 + 24) = v93;
      *(void *)(v29 + 40) = v94;
      if (!v15)
      {
        for (uint64_t i = 0; i != 48; i += 8)
          *(void *)(a4 + i) = *(void *)(v28 + i);
      }
      uint64_t v90 = 0x200000002;
      long long v89 = xmmword_18E1FD1B0;
      unint64_t v88 = &unk_1EDD18BB8;
      uint64_t v91 = (double *)&v92;
      swan::BatchedGNSSDataSmoother::convertErrorEllipseToCovariance(*(double *)(*a2 + 248 * v15 + 128), *(double *)(*a2 + 248 * v15 + 136), *(double *)(*a2 + 248 * v15 + 144) * 3.14159265 / 180.0, v27, (uint64_t)&v88);
      uint64_t v85 = 0x300000003;
      long long v84 = xmmword_18E1F0010;
      int8x16_t v83 = &unk_1EDD18EE8;
      double v86 = (double *)&v87;
      *(void *)&long long v80 = 0x300000003;
      long long v78 = &unk_1EDD18EE8;
      *((void *)&v80 + 1) = v81;
      long long v79 = xmmword_18E1F0010;
      sub_18DFE2CC8((uint64_t)&v78, 0.0);
      sub_18DFE2F24((uint64_t)&v83, (uint64_t)&v78);
      unint64_t v31 = v91;
      unsigned int v32 = v86;
      *double v86 = *v91;
      uint64_t v33 = &v31[SHIDWORD(v89)];
      int v34 = HIDWORD(v84);
      v32[SHIDWORD(v84)] = *v33;
      v32[1] = v31[1];
      v32[v34 + 1] = v33[1];
      double v35 = *(double *)(*a2 + 248 * v15 + 72);
      v32[2 * v34 + 2] = v35 * v35;
      LOBYTE(v79) = 0;
      v81[0] = 0x300000003;
      long long v80 = xmmword_18E1F0010;
      *((void *)&v79 + 1) = &unk_1EDD18EE8;
      v81[1] = &v82;
      long long v78 = &unk_1EDD0AB90;
      if (cnnavigation::ENUToECEF(&v97, 1, 0, (uint64_t)&v97, 1, &v95, (uint64_t)&v78)) {
        break;
      }
      uint64_t v75 = 0x300000003;
      long long v73 = &unk_1EDD18EE8;
      long long v74 = xmmword_18E1F0010;
      long long v76 = (double *)&v77;
      sub_18DFFBB34((uint64_t)&v78, (uint64_t)&v83, (uint64_t)&v73);
      unsigned int v36 = v76;
      unint64_t v37 = &(*a8)[3 * v15];
      *unint64_t v37 = sqrt(*v76);
      int v38 = HIDWORD(v74);
      v37[1] = sqrt(v36[HIDWORD(v74) + 1]);
      double v37[2] = sqrt(v36[2 * v38 + 2]);
      float64x2_t v39 = (double *)(*a2 + 248 * v15);
      double v40 = v39[14] / 1.41421356;
      double v41 = v39[6];
      if (fabs(v41) < 2.22044605e-16 && v40 < a1[202]) {
        double v40 = a1[202];
      }
      double v42 = v39[30];
      uint64_t v43 = *a2 + 248 * v15;
      double v44 = *(double *)(v43 + 120);
      double v45 = fabs(v44);
      if (v44 < 0.0 || v45 < 2.22044605e-16) {
        double v47 = 21.2132;
      }
      else {
        double v47 = v40;
      }
      if (sqrt(*(double *)(v43 + 232) * *(double *)(v43 + 232) + v41 * v41) > a1[203]) {
        double v47 = a1[204];
      }
      uint64_t v70 = 0x300000003;
      long long v68 = &unk_1EDD18EE8;
      long long v71 = &v72;
      long long v69 = xmmword_18E1F0010;
      sub_18DFE2CC8((uint64_t)&v68, 0.0);
      sub_18DFE2F24((uint64_t)&v83, (uint64_t)&v68);
      long long v48 = v86;
      *double v86 = v47 * v47;
      int v49 = HIDWORD(v84);
      v48[HIDWORD(v84) + 1] = v47 * v47;
      v48[2 * v49 + 2] = v42 * v42;
      sub_18DFFBB34((uint64_t)&v78, (uint64_t)&v83, (uint64_t)&v73);
      unsigned int v50 = v76;
      double v51 = sqrt(*v76);
      uint64_t v52 = *a9;
      uint64_t v53 = &(*a9)[3 * v15];
      *uint64_t v53 = v51;
      int v54 = HIDWORD(v74);
      double v55 = sqrt(v50[HIDWORD(v74) + 1]);
      v53[1] = v55;
      double v56 = sqrt(v50[2 * v54 + 2]);
      v53[2] = v56;
      double v57 = a1[200];
      *uint64_t v53 = v51 * v57;
      v53[1] = v55 * v57;
      v53[2] = v56 * v57;
      if (!v15)
      {
        *(_OWORD *)(a5 + 256) = 0u;
        *(_OWORD *)(a5 + 272) = 0u;
        *(_OWORD *)(a5 + 224) = 0u;
        *(_OWORD *)(a5 + 240) = 0u;
        *(_OWORD *)(a5 + 192) = 0u;
        *(_OWORD *)(a5 + 208) = 0u;
        *(_OWORD *)(a5 + 160) = 0u;
        *(_OWORD *)(a5 + 176) = 0u;
        *(_OWORD *)(a5 + 128) = 0u;
        *(_OWORD *)(a5 + 144) = 0u;
        *(_OWORD *)(a5 + 96) = 0u;
        *(_OWORD *)(a5 + 112) = 0u;
        *(_OWORD *)(a5 + 64) = 0u;
        *(_OWORD *)(a5 + 80) = 0u;
        *(_OWORD *)(a5 + 32) = 0u;
        *(_OWORD *)(a5 + 48) = 0u;
        *(_OWORD *)a5 = 0u;
        *(_OWORD *)(a5 + 16) = 0u;
        double v58 = *a8;
        *(double *)a5 = **a8 * **a8;
        *(double *)(a5 + 56) = v58[1] * v58[1];
        *(double *)(a5 + 112) = v58[2] * v58[2];
        *(double *)(a5 + 168) = *v52 * *v52;
        *(double *)(a5 + 224) = v52[1] * v52[1];
        *(double *)(a5 + 280) = v52[2] * v52[2];
      }
      int v16 = ++v15 < a3;
      if (v15 == a3) {
        goto LABEL_27;
      }
    }
  }
  else
  {
LABEL_27:
    int v16 = 0;
  }
  return (v16 << 31 >> 31);
}

void sub_18E1A0E28(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    unint64_t v6 = (char *)sub_18DEDF808(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    uint64_t v9 = &v6[8 * v8];
    uint64_t v10 = (char *)*a1;
    unint64_t v11 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v11 != *a1)
    {
      uint64_t v12 = v7;
      do
      {
        uint64_t v13 = *((void *)v11 - 1);
        v11 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t swan::BatchedGNSSDataSmoother::CopySmootherOutputs(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, void *a5, uint64_t a6, void **a7, void **a8)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v14 = 0;
    uint64_t v62 = a6 + 16;
    do
    {
      uint64_t v15 = *a3;
      uint64_t v17 = *(void **)(a6 + 8);
      unint64_t v16 = *(void *)(a6 + 16);
      if ((unint64_t)v17 >= v16)
      {
        int v19 = *(void **)a6;
        uint64_t v20 = ((uint64_t)v17 - *(void *)a6) >> 3;
        unint64_t v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) >> 61) {
          sub_18DEE1FC8();
        }
        uint64_t v22 = v16 - (void)v19;
        if (v22 >> 2 > v21) {
          unint64_t v21 = v22 >> 2;
        }
        if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v23 = v21;
        }
        if (v23)
        {
          double v24 = (char *)sub_18DEDF808(v62, v23);
          int v19 = *(void **)a6;
          uint64_t v17 = *(void **)(a6 + 8);
        }
        else
        {
          double v24 = 0;
        }
        __double2 v25 = &v24[8 * v20];
        *(void *)__double2 v25 = *(void *)(v15 + 8 * v14);
        uint64_t v18 = v25 + 8;
        while (v17 != v19)
        {
          uint64_t v26 = *--v17;
          *((void *)v25 - 1) = v26;
          v25 -= 8;
        }
        *(void *)a6 = v25;
        *(void *)(a6 + 8) = v18;
        *(void *)(a6 + 16) = &v24[8 * v23];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        *uint64_t v17 = *(void *)(v15 + 8 * v14);
        uint64_t v18 = v17 + 1;
      }
      *(void *)(a6 + 8) = v18;
      uint64_t v27 = (_OWORD *)(*a4 + 48 * v14);
      long long v28 = v27[1];
      __dst[0] = *v27;
      __dst[1] = v28;
      __dst[2] = v27[2];
      uint64_t v29 = a7[1];
      unint64_t v30 = (unint64_t)a7[2];
      if ((unint64_t)v29 >= v30)
      {
        unint64_t v34 = 0xAAAAAAAAAAAAAAABLL * (((char *)v29 - (unsigned char *)*a7) >> 4);
        unint64_t v35 = v34 + 1;
        if (v34 + 1 > 0x555555555555555) {
          sub_18DEE1FC8();
        }
        if (0x5555555555555556 * ((uint64_t)(v30 - (void)*a7) >> 4) > v35) {
          unint64_t v35 = 0x5555555555555556 * ((uint64_t)(v30 - (void)*a7) >> 4);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v30 - (void)*a7) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v36 = 0x555555555555555;
        }
        else {
          unint64_t v36 = v35;
        }
        if (v36) {
          unint64_t v36 = (unint64_t)sub_18E1A34E8(v36);
        }
        else {
          uint64_t v37 = 0;
        }
        int v38 = (_OWORD *)(v36 + 48 * v34);
        long long v39 = __dst[1];
        _OWORD *v38 = __dst[0];
        v38[1] = v39;
        _OWORD v38[2] = __dst[2];
        double v41 = (char *)*a7;
        double v40 = (char *)a7[1];
        double v42 = v38;
        if (v40 != *a7)
        {
          do
          {
            long long v43 = *((_OWORD *)v40 - 3);
            long long v44 = *((_OWORD *)v40 - 1);
            *(v42 - 2) = *((_OWORD *)v40 - 2);
            *(v42 - 1) = v44;
            *(v42 - 3) = v43;
            v42 -= 3;
            v40 -= 48;
          }
          while (v40 != v41);
          double v40 = (char *)*a7;
        }
        uint64_t v33 = v38 + 3;
        *a7 = v42;
        a7[1] = v38 + 3;
        a7[2] = (void *)(v36 + 48 * v37);
        if (v40) {
          operator delete(v40);
        }
      }
      else
      {
        long long v31 = *v27;
        long long v32 = v27[2];
        v29[1] = v27[1];
        void v29[2] = v32;
        *uint64_t v29 = v31;
        uint64_t v33 = v29 + 3;
      }
      a7[1] = v33;
      ++v14;
    }
    while (v14 != a2);
    uint64_t v45 = 0;
    unsigned int v46 = (char *)a8[1];
    do
    {
      double v47 = (const void *)(*a5 + 288 * v45);
      memcpy(__dst, v47, sizeof(__dst));
      unint64_t v48 = (unint64_t)a8[2];
      if ((unint64_t)v46 >= v48)
      {
        unint64_t v49 = 0x8E38E38E38E38E39 * ((v46 - (unsigned char *)*a8) >> 5);
        unint64_t v50 = v49 + 1;
        if (v49 + 1 > 0xE38E38E38E38E3) {
          sub_18DEE1FC8();
        }
        unint64_t v51 = 0x8E38E38E38E38E39 * ((uint64_t)(v48 - (void)*a8) >> 5);
        if (2 * v51 > v50) {
          unint64_t v50 = 2 * v51;
        }
        if (v51 >= 0x71C71C71C71C71) {
          unint64_t v52 = 0xE38E38E38E38E3;
        }
        else {
          unint64_t v52 = v50;
        }
        if (v52)
        {
          uint64_t v53 = (char *)sub_18E1A3654(v52);
          uint64_t v55 = v54;
        }
        else
        {
          uint64_t v53 = 0;
          uint64_t v55 = 0;
        }
        double v56 = &v53[288 * v49];
        memcpy(v56, __dst, 0x120uLL);
        double v58 = (char *)*a8;
        double v57 = (char *)a8[1];
        double v59 = v56;
        if (v57 != *a8)
        {
          do
          {
            v59 -= 288;
            v57 -= 288;
            memcpy(v59, v57, 0x120uLL);
          }
          while (v57 != v58);
          double v57 = (char *)*a8;
        }
        long long v60 = &v53[288 * v55];
        unsigned int v46 = v56 + 288;
        *a8 = v59;
        a8[1] = v56 + 288;
        a8[2] = v60;
        if (v57) {
          operator delete(v57);
        }
      }
      else
      {
        memmove(v46, v47, 0x120uLL);
        v46 += 288;
      }
      a8[1] = v46;
      ++v45;
    }
    while (v45 != a2);
  }
  return 0;
}

uint64_t swan::BatchedGNSSDataSmoother::SaveToDisk(uint64_t a1, const char *a2, unint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x100uLL, "%s%s", a2, "t_out.txt");
  uint64_t v15 = fopen(__str, "w");
  if (!v15) {
    goto LABEL_26;
  }
  unint64_t v16 = v15;
  if (a3)
  {
    uint64_t v17 = 0;
    do
      fprintf(v16, "%.15le\n", *(double *)(*a4 + 8 * v17++));
    while (a3 != v17);
  }
  fclose(v16);
  snprintf(__str, 0x100uLL, "%s%s", a2, "x_out.txt");
  uint64_t v18 = fopen(__str, "w");
  if (!v18) {
    goto LABEL_26;
  }
  int v19 = v18;
  if (a3)
  {
    uint64_t v20 = 0;
    unint64_t v21 = a3;
    do
    {
      uint64_t v22 = (double *)(*a5 + v20);
      fprintf(v19, "%.15le %.15le %.15le %.15le %.15le %.15le\n", *v22, v22[1], v22[2], v22[3], v22[4], v22[5]);
      v20 += 48;
      --v21;
    }
    while (v21);
  }
  fclose(v19);
  snprintf(__str, 0x100uLL, "%s%s", a2, "P_out.txt");
  unint64_t v23 = fopen(__str, "w");
  if (!v23) {
    goto LABEL_26;
  }
  double v24 = v23;
  if (a3)
  {
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    do
    {
      for (uint64_t i = 0; i != 288; i += 48)
      {
        long long v28 = (double *)(*a6 + v25 + i);
        fprintf(v24, "%.15le %.15le %.15le %.15le %.15le %.15le\n", *v28, v28[1], v28[2], v28[3], v28[4], v28[5]);
      }
      ++v26;
      v25 += 288;
    }
    while (v26 != a3);
  }
  fclose(v24);
  snprintf(__str, 0x100uLL, "%s%s", a2, "nu.txt");
  uint64_t v29 = fopen(__str, "w");
  if (!v29) {
    goto LABEL_26;
  }
  unint64_t v30 = v29;
  if (a3)
  {
    unint64_t v31 = 0;
    unsigned int v32 = 1;
    do
    {
      uint64_t v33 = (double *)(*a7 + 48 * v31);
      fprintf(v30, "%.15le %.15le %.15le %.15le %.15le %.15le\n", *v33, v33[1], v33[2], v33[3], v33[4], v33[5]);
      unint64_t v31 = v32++;
    }
    while (v31 < a3);
  }
  fclose(v30);
  snprintf(__str, 0x100uLL, "%s%s", a2, "P_nu.txt");
  unint64_t v34 = fopen(__str, "w");
  if (v34)
  {
    unint64_t v35 = v34;
    if (a3)
    {
      LODWORD(v36) = 0;
      do
      {
        for (uint64_t j = 0; j != 288; j += 48)
        {
          int v38 = (double *)(*a8 + 288 * v36 + j);
          fprintf(v35, "%.15le %.15le %.15le %.15le %.15le %.15le\n", *v38, v38[1], v38[2], v38[3], v38[4], v38[5]);
        }
        unint64_t v36 = (v36 + 1);
      }
      while (v36 < a3);
    }
    fclose(v35);
    return 0;
  }
  else
  {
LABEL_26:
    printf("Error opening %s. Exiting.\n", __str);
    return 0xFFFFFFFFLL;
  }
}

uint64_t swan::BatchedGNSSDataSmoother::SaveToDisk(uint64_t a1, const char *a2, unint64_t a3, double *a4, uint64_t a5, void *a6, void *a7, void *a8, void *a9)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x100uLL, "%s%s", a2, "t_in.txt");
  unint64_t v16 = fopen(__str, "w");
  if (!v16) {
    goto LABEL_22;
  }
  uint64_t v17 = v16;
  if (a3)
  {
    unint64_t v18 = 0;
    unsigned int v19 = 1;
    do
    {
      fprintf(v17, "%.15le\n", *(double *)(*a6 + 8 * v18));
      unint64_t v18 = v19++;
    }
    while (v18 < a3);
  }
  fclose(v17);
  snprintf(__str, 0x100uLL, "%s%s", a2, "x_in.txt");
  uint64_t v20 = fopen(__str, "w");
  if (!v20) {
    goto LABEL_22;
  }
  unint64_t v21 = v20;
  if (a3)
  {
    unint64_t v22 = 0;
    unsigned int v23 = 1;
    do
    {
      double v24 = (double *)(*a7 + 48 * v22);
      fprintf(v21, "%.15le %.15le %.15le %.15le %.15le %.15le\n", *v24, v24[1], v24[2], v24[3], v24[4], v24[5]);
      unint64_t v22 = v23++;
    }
    while (v22 < a3);
  }
  fclose(v21);
  snprintf(__str, 0x100uLL, "%s%s", a2, "P0.txt");
  uint64_t v25 = fopen(__str, "w");
  if (!v25) {
    goto LABEL_22;
  }
  uint64_t v26 = v25;
  for (uint64_t i = 0; i != 288; i += 48)
  {
    uint64_t v28 = a5 + 24;
    fprintf(v26, "%.15le %.15le %.15le %.15le %.15le %.15le\n", *(double *)(v28 + i - 24), *(double *)(v28 + i - 16), *(double *)(v28 + i - 8), *(double *)(v28 + i), *(double *)(v28 + i + 8), *(double *)(v28 + i + 16));
  }
  fclose(v26);
  snprintf(__str, 0x100uLL, "%s%s", a2, "x0.txt");
  uint64_t v29 = fopen(__str, "w");
  if (!v29) {
    goto LABEL_22;
  }
  unint64_t v30 = v29;
  fprintf(v29, "%.15le %.15le %.15le %.15le %.15le %.15le\n", *a4, a4[1], a4[2], a4[3], a4[4], a4[5]);
  fclose(v30);
  snprintf(__str, 0x100uLL, "%s%s", a2, "sigma_x.txt");
  unint64_t v31 = fopen(__str, "w");
  if (!v31) {
    goto LABEL_22;
  }
  unsigned int v32 = v31;
  if (a3)
  {
    unint64_t v33 = 0;
    unsigned int v34 = 1;
    do
    {
      fprintf(v32, "%.15le %.15le %.15le\n", *(double *)(*a8 + 24 * v33), *(double *)(*a8 + 24 * v33 + 8), *(double *)(*a8 + 24 * v33 + 16));
      unint64_t v33 = v34++;
    }
    while (v33 < a3);
  }
  fclose(v32);
  snprintf(__str, 0x100uLL, "%s%s", a2, "sigma_vx.txt");
  unint64_t v35 = fopen(__str, "w");
  if (v35)
  {
    unint64_t v36 = v35;
    if (a3)
    {
      unint64_t v37 = 0;
      unsigned int v38 = 1;
      do
      {
        fprintf(v36, "%.15le %.15le %.15le\n", *(double *)(*a9 + 24 * v37), *(double *)(*a9 + 24 * v37 + 8), *(double *)(*a9 + 24 * v37 + 16));
        unint64_t v37 = v38++;
      }
      while (v37 < a3);
    }
    fclose(v36);
    return 0;
  }
  else
  {
LABEL_22:
    printf("Error opening %s. Exiting.\n", __str);
    return 0xFFFFFFFFLL;
  }
}

void swan::BatchedGNSSDataSmoother::convertErrorEllipseToCovariance(double a1, double a2, double a3, uint64_t a4, uint64_t a5)
{
  uint64_t v46 = 0x200000002;
  long long v45 = xmmword_18E1FD1B0;
  long long v44 = &unk_1EDD18BB8;
  double v47 = (double *)&v48;
  uint64_t v41 = 0x200000002;
  long long v39 = &unk_1EDD18BB8;
  double v42 = v43;
  long long v40 = xmmword_18E1FD1B0;
  sub_18DFE2CC8((uint64_t)&v39, 0.0);
  sub_18DFE2F24((uint64_t)&v44, (uint64_t)&v39);
  uint64_t v9 = v47;
  *double v47 = a1 * a1 * 0.1669041;
  v9[SHIDWORD(v45) + 1] = a2 * a2 * 0.1669041;
  if (a3 == 0.0)
  {
    uint64_t v20 = &v44;
  }
  else
  {
    uint64_t v41 = 0x200000002;
    long long v40 = xmmword_18E1FD1B0;
    long long v39 = &unk_1EDD18BB8;
    double v42 = v43;
    __double2 v10 = __sincos_stret(a3);
    v43[0] = *(void *)&v10.__cosval;
    v43[1] = *(void *)&v10.__sinval;
    *(double *)&v43[2] = -v10.__sinval;
    v43[3] = *(void *)&v10.__cosval;
    uint64_t v31 = 0x200000002;
    uint64_t v29 = &unk_1EDD18BB8;
    long long v30 = xmmword_18E1FD1B0;
    unsigned int v32 = &v33;
    sub_18DFE2B44((uint64_t)&v39, (uint64_t)&v44, (uint64_t)&v29);
    int v12 = v40;
    int v11 = DWORD1(v40);
    uint64_t v26 = 0x200000002;
    unint64_t v21 = &unk_1EDD18BB8;
    uint64_t v27 = v28;
    int v22 = DWORD1(v40);
    int v23 = v40;
    int v24 = v40 * DWORD1(v40);
    int v25 = DWORD1(v40);
    if (DWORD1(v40))
    {
      int v13 = 0;
      int v14 = 0;
      int v15 = HIDWORD(v40);
      unint64_t v16 = v42;
      do
      {
        int v17 = v13;
        int v18 = v14;
        for (int i = v12; i; --i)
        {
          v28[v18] = v16[v17];
          v18 += v11;
          ++v17;
        }
        ++v14;
        v13 += v15;
      }
      while (v14 != v11);
    }
    uint64_t v36 = 0x200000002;
    long long v35 = xmmword_18E1FD1B0;
    unsigned int v34 = &unk_1EDD18BB8;
    unint64_t v37 = &v38;
    sub_18DFE2B44((uint64_t)&v29, (uint64_t)&v21, (uint64_t)&v34);
    uint64_t v20 = &v34;
  }
  sub_18DFE2F24(a5, (uint64_t)v20);
}

uint64_t swan::BatchedGNSSDataSmoother::formatData(double *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, double *a8, double *a9)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    uint64_t v12 = 0;
    int v48 = *(_DWORD *)(*a2 + 24);
    double v13 = *(double *)(*a2 + 16);
    float64x2_t v46 = (float64x2_t)vdupq_n_s64(0x4066800000000000uLL);
    float64x2_t v47 = (float64x2_t)vdupq_n_s64(0x400921FB54442D18uLL);
    do
    {
      uint64_t v14 = *a2;
      uint64_t v15 = *a2 + 264 * v12;
      *(double *)(a6 + 8 * v12) = *(double *)(v15 + 16) - v13 + (double)(*(_DWORD *)(v15 + 24) - v48) * 604800.0;
      float64x2_t v82 = vdivq_f64(vmulq_f64(*(float64x2_t *)(v15 + 48), v47), v46);
      uint64_t v83 = *(void *)(v15 + 64);
      if (cnnavigation::LLAToECEF(v82.f64, 1, (double *)&v80, 0, (uint64_t)&v61)) {
        break;
      }
      uint64_t v16 = a7 + 48 * v12;
      *(_OWORD *)uint64_t v16 = v80;
      *(void *)(v16 + 16) = v81;
      uint64_t v17 = v14 + 264 * v12;
      v78.f64[0] = *(float64_t *)(v17 + 152);
      v78.f64[1] = *(float64_t *)(v17 + 152);
      uint64_t v79 = *(void *)(v17 + 160);
      uint64_t v18 = cnnavigation::ENUToECEF((long long *)&v78, 1, 0, (uint64_t)&v80, 1, &v76);
      if (v18) {
        break;
      }
      *(float64x2_t *)(v16 + 24) = v76;
      *(void *)(v16 + 40) = v77;
      if (!v12)
      {
        for (uint64_t i = 0; i != 48; i += 8)
          *(void *)(a4 + i) = *(void *)(a7 + i);
      }
      uint64_t v73 = 0x200000002;
      long long v72 = xmmword_18E1FD1B0;
      long long v71 = &unk_1EDD18BB8;
      long long v74 = (double *)&v75;
      swan::BatchedGNSSDataSmoother::convertErrorEllipseToCovariance(*(double *)(*a2 + 264 * v12 + 120), *(double *)(*a2 + 264 * v12 + 128), *(double *)(*a2 + 264 * v12 + 136) * 3.14159265 / 180.0, v18, (uint64_t)&v71);
      uint64_t v68 = 0x300000003;
      long long v67 = xmmword_18E1F0010;
      uint64_t v66 = &unk_1EDD18EE8;
      long long v69 = (double *)&v70;
      *(void *)&long long v63 = 0x300000003;
      float64x2_t v61 = &unk_1EDD18EE8;
      *((void *)&v63 + 1) = v64;
      long long v62 = xmmword_18E1F0010;
      sub_18DFE2CC8((uint64_t)&v61, 0.0);
      sub_18DFE2F24((uint64_t)&v66, (uint64_t)&v61);
      uint64_t v20 = v74;
      unint64_t v21 = v69;
      *long long v69 = *v74;
      int v22 = &v20[SHIDWORD(v72)];
      int v23 = HIDWORD(v67);
      v21[SHIDWORD(v67)] = *v22;
      v21[1] = v20[1];
      v21[v23 + 1] = v22[1];
      double v24 = *(double *)(*a2 + 264 * v12 + 144);
      v21[2 * v23 + 2] = v24 * v24;
      LOBYTE(v62) = 0;
      v64[0] = 0x300000003;
      long long v63 = xmmword_18E1F0010;
      *((void *)&v62 + 1) = &unk_1EDD18EE8;
      v64[1] = &v65;
      float64x2_t v61 = &unk_1EDD0AB90;
      int v25 = cnnavigation::ENUToECEF(&v80, 1, 0, (uint64_t)&v80, 1, &v78, (uint64_t)&v61);
      if (!v25)
      {
        uint64_t v58 = 0x300000003;
        double v56 = &unk_1EDD18EE8;
        long long v57 = xmmword_18E1F0010;
        double v59 = (double *)&v60;
        sub_18DFFBB34((uint64_t)&v61, (uint64_t)&v66, (uint64_t)&v56);
        uint64_t v26 = v59;
        uint64_t v27 = &a8[3 * v12];
        *uint64_t v27 = sqrt(*v59);
        int v28 = HIDWORD(v57);
        v27[1] = sqrt(v26[HIDWORD(v57) + 1]);
        uint64_t v27[2] = sqrt(v26[2 * v28 + 2]);
        uint64_t v29 = (double *)(*a2 + 264 * v12);
        double v30 = v29[22] / 1.41421356;
        double v31 = v29[19];
        if (fabs(v31) < 2.22044605e-16 && v30 < a1[202]) {
          double v30 = a1[202];
        }
        double v32 = v29[23];
        if (sqrt(*(double *)(*a2 + 264 * v12 + 160) * *(double *)(*a2 + 264 * v12 + 160) + v31 * v31) > a1[203]) {
          double v30 = a1[204];
        }
        uint64_t v53 = 0x300000003;
        unint64_t v51 = &unk_1EDD18EE8;
        uint64_t v54 = &v55;
        long long v52 = xmmword_18E1F0010;
        sub_18DFE2CC8((uint64_t)&v51, 0.0);
        sub_18DFE2F24((uint64_t)&v66, (uint64_t)&v51);
        uint64_t v33 = v69;
        *long long v69 = v30 * v30;
        int v34 = HIDWORD(v67);
        v33[HIDWORD(v67) + 1] = v30 * v30;
        v33[2 * v34 + 2] = v32 * v32;
        sub_18DFFBB34((uint64_t)&v61, (uint64_t)&v66, (uint64_t)&v56);
        long long v35 = v59;
        double v36 = sqrt(*v59);
        unint64_t v37 = &a9[3 * v12];
        *unint64_t v37 = v36;
        int v38 = HIDWORD(v57);
        double v39 = sqrt(v35[HIDWORD(v57) + 1]);
        v37[1] = v39;
        double v40 = sqrt(v35[2 * v38 + 2]);
        double v37[2] = v40;
        double v41 = a1[200];
        *unint64_t v37 = v36 * v41;
        v37[1] = v39 * v41;
        double v37[2] = v40 * v41;
        if (!v12)
        {
          *(_OWORD *)(a5 + 256) = 0u;
          *(_OWORD *)(a5 + 272) = 0u;
          *(_OWORD *)(a5 + 224) = 0u;
          *(_OWORD *)(a5 + 240) = 0u;
          *(_OWORD *)(a5 + 192) = 0u;
          *(_OWORD *)(a5 + 208) = 0u;
          *(_OWORD *)(a5 + 160) = 0u;
          *(_OWORD *)(a5 + 176) = 0u;
          *(_OWORD *)(a5 + 128) = 0u;
          *(_OWORD *)(a5 + 144) = 0u;
          *(_OWORD *)(a5 + 96) = 0u;
          *(_OWORD *)(a5 + 112) = 0u;
          *(_OWORD *)(a5 + 64) = 0u;
          *(_OWORD *)(a5 + 80) = 0u;
          *(_OWORD *)(a5 + 32) = 0u;
          *(_OWORD *)(a5 + 48) = 0u;
          *(_OWORD *)a5 = 0u;
          *(_OWORD *)(a5 + 16) = 0u;
          *(double *)a5 = *a8 * *a8;
          *(double *)(a5 + 56) = a8[1] * a8[1];
          *(double *)(a5 + 112) = a8[2] * a8[2];
          *(double *)(a5 + 168) = *a9 * *a9;
          *(double *)(a5 + 224) = a9[1] * a9[1];
          *(double *)(a5 + 280) = a9[2] * a9[2];
        }
      }
      if (v25) {
        break;
      }
      ++v12;
    }
    while (v12 != a3);
  }
  return 0xFFFFFFFFLL;
}

void sub_18E1A2370(uint64_t a1)
{
  *(void *)a1 = &unk_1EDD161B0;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1A23E0(uint64_t a1, char *a2, char a3)
{
  *(unsigned char *)(a1 + 32) = a3;
  sub_18DF0642C((std::string *)(a1 + 8), a2);
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 32);

  return v4(a1);
}

uint64_t sub_18E1A2440(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (unsigned char *)(a1 + 34);
  if (sub_18E1A2F78(a1, (char *)(a1 + 34), "use_input_locationd_data_file", a4, a5, a6, a7, a8))
  {
    if (*v9 && (sub_18E1A2AE8(a1, (_OWORD *)(a1 + 35), "input_locationd_data_file", v10, v11, v12, v13, v14) & 1) == 0)
    {
      uint64_t v15 = sub_18DEDD538(MEMORY[0x1E4FBA250], (uint64_t)"Invalid input_locationd_batched_data_file", 41);
      std::ios_base::getloc((const std::ios_base *)((char *)v15 + *(void *)(*v15 - 24)));
      uint64_t v16 = std::locale::use_facet(&v100, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 10);
LABEL_29:
      std::locale::~locale(&v100);
      std::ostream::put();
      std::ostream::flush();
      return 0;
    }
  }
  else
  {
    *uint64_t v9 = 0;
  }
  if ((sub_18E1A2F78(a1, (char *)(a1 + 33), "load_batched_data_from_locationd", v10, v11, v12, v13, v14) & 1) == 0) {
    *(unsigned char *)(a1 + 33) = 0;
  }
  int v22 = (unsigned char *)(a1 + 291);
  if (sub_18E1A2F78(a1, (char *)(a1 + 291), "use_input_ascii_batched_data_file", v17, v18, v19, v20, v21))
  {
    if (*v22
      && (sub_18E1A2AE8(a1, (_OWORD *)(a1 + 292), "input_ascii_batched_data_file", v23, v24, v25, v26, v27) & 1) == 0)
    {
      int v28 = sub_18DEDD538(MEMORY[0x1E4FBA250], (uint64_t)"Invalid input_ascii_batched_data_file", 37);
      std::ios_base::getloc((const std::ios_base *)((char *)v28 + *(void *)(*v28 - 24)));
      uint64_t v29 = std::locale::use_facet(&v100, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v29->__vftable[2].~facet_0)(v29, 10);
      goto LABEL_29;
    }
  }
  else
  {
    *int v22 = 0;
  }
  double v30 = (unsigned char *)(a1 + 548);
  if (sub_18E1A2F78(a1, (char *)(a1 + 548), "save_results_to_disk", v23, v24, v25, v26, v27))
  {
    if (*v30 && (sub_18E1A2AE8(a1, (_OWORD *)(a1 + 549), "save_results_path", v31, v32, v33, v34, v35) & 1) == 0)
    {
      double v36 = sub_18DEDD538(MEMORY[0x1E4FBA250], (uint64_t)"Invalid save_results_path", 25);
      std::ios_base::getloc((const std::ios_base *)((char *)v36 + *(void *)(*v36 - 24)));
      unint64_t v37 = std::locale::use_facet(&v100, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v37->__vftable[2].~facet_0)(v37, 10);
      goto LABEL_29;
    }
  }
  else
  {
    *double v30 = 0;
  }
  int v38 = (unsigned char *)(a1 + 805);
  if (sub_18E1A2F78(a1, (char *)(a1 + 805), "load_matlab_inputs", v31, v32, v33, v34, v35))
  {
    if (*v38 && (sub_18E1A2AE8(a1, (_OWORD *)(a1 + 806), "load_matlab_inputs_path", v39, v40, v41, v42, v43) & 1) == 0)
    {
      long long v44 = sub_18DEDD538(MEMORY[0x1E4FBA250], (uint64_t)"Invalid load_matlab_inputs_path", 31);
      std::ios_base::getloc((const std::ios_base *)((char *)v44 + *(void *)(*v44 - 24)));
      long long v45 = std::locale::use_facet(&v100, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v45->__vftable[2].~facet_0)(v45, 10);
      goto LABEL_29;
    }
  }
  else
  {
    unsigned char *v38 = 0;
  }
  if ((sub_18E1A2AE8(a1, (_OWORD *)(a1 + 1062), "temp_writable_path", v39, v40, v41, v42, v43) & 1) == 0)
  {
    double v59 = sub_18DEDD538(MEMORY[0x1E4FBA250], (uint64_t)"Invalid temp_writable_path", 26);
    std::ios_base::getloc((const std::ios_base *)((char *)v59 + *(void *)(*v59 - 24)));
    uint64_t v60 = std::locale::use_facet(&v100, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v60->__vftable[2].~facet_0)(v60, 10);
    goto LABEL_29;
  }
  unint64_t v51 = (unsigned char *)(a1 + 1318);
  if (sub_18E1A2F78(a1, (char *)(a1 + 1318), "use_truth_reference", v46, v47, v48, v49, v50))
  {
    if (*v51
      && (sub_18E1A2AE8(a1, (_OWORD *)(a1 + 1319), "truth_reference_filename", v52, v53, v54, v55, v56) & 1) == 0)
    {
      long long v57 = sub_18DEDD538(MEMORY[0x1E4FBA250], (uint64_t)"Invalid truth_reference_filename", 32);
      std::ios_base::getloc((const std::ios_base *)((char *)v57 + *(void *)(*v57 - 24)));
      uint64_t v58 = std::locale::use_facet(&v100, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v58->__vftable[2].~facet_0)(v58, 10);
      goto LABEL_29;
    }
  }
  else
  {
    unsigned char *v51 = 0;
  }
  long long v62 = (unsigned char *)(a1 + 1575);
  if (sub_18E1A2F78(a1, (char *)(a1 + 1575), "enable_data_editing", v52, v53, v54, v55, v56))
  {
    if (*v62
      && (sub_18E1A31A4(a1, (void *)(a1 + 1576), "data_editing_sigma_threshold", v63, v64, v65, v66, v67) & 1) == 0)
    {
      *(void *)(a1 + 1576) = 0x4008000000000000;
      uint64_t v68 = sub_18DEDD538(MEMORY[0x1E4FBA250], (uint64_t)"Invalid data_editing_sigma_threshold", 36);
      std::ios_base::getloc((const std::ios_base *)((char *)v68 + *(void *)(*v68 - 24)));
      long long v69 = std::locale::use_facet(&v100, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v69->__vftable[2].~facet_0)(v69, 10);
      goto LABEL_29;
    }
  }
  else
  {
    *long long v62 = 0;
  }
  if ((sub_18E1A31A4(a1, (void *)(a1 + 1584), "horizontal_position_process_noise", v63, v64, v65, v66, v67) & 1) == 0) {
    *(void *)(a1 + 1584) = 0x3FF0000000000000;
  }
  if ((sub_18E1A31A4(a1, (void *)(a1 + 1592), "vertical_position_process_noise", v70, v71, v72, v73, v74) & 1) == 0) {
    *(void *)(a1 + 1592) = 0x3FB999999999999ALL;
  }
  if ((sub_18E1A31A4(a1, (void *)(a1 + 1600), "velocity_sigma_fudge_factor", v75, v76, v77, v78, v79) & 1) == 0) {
    *(void *)(a1 + 1600) = 0x3FF0000000000000;
  }
  if ((sub_18E1A31A4(a1, (void *)(a1 + 1608), "vertical_speed_limit", v80, v81, v82, v83, v84) & 1) == 0) {
    *(void *)(a1 + 1608) = 0x4049000000000000;
  }
  if ((sub_18E1A31A4(a1, (void *)(a1 + 1616), "minimum_single_component_speed_standard_deviation", v85, v86, v87, v88, v89) & 1) == 0)*(void *)(a1 + 1616) = 0x3FD6A09E667F3BD1; {
  if ((sub_18E1A31A4(a1, (void *)(a1 + 1624), "mimimum_driving_speed_that_requires_speed_uncertainty_inflation", v90, v91, v92, v93, v94) & 1) == 0)*(void *)(a1 + 1624) = 0x4024000000000000;
  }
  if ((sub_18E1A31A4(a1, (void *)(a1 + 1632), "minimum_driving_speed_standard_deviation", v95, v96, v97, v98, v99) & 1) == 0) {
    *(void *)(a1 + 1632) = 0x4006A09E667F3BCCLL;
  }
  return 1;
}

void sub_18E1A2AB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

uint64_t sub_18E1A2AE8(uint64_t a1, _OWORD *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(char *)(a1 + 31) & 0x80000000) == 0)
  {
    if (!*(unsigned char *)(a1 + 31)) {
      goto LABEL_99;
    }
LABEL_5:
    sub_18DEDE7B0(&v61, "\n");
    std::string::size_type v11 = strlen(a3);
    uint64_t v12 = std::string::append(&v61, a3, v11);
    uint64_t v13 = std::string::append(v12, ":", 1uLL);
    uint64_t v14 = (uint64_t *)(a1 + 8);
    int v15 = *(char *)(a1 + 31);
    __s = (char *)a3;
    if (v15 < 0)
    {
      uint64_t v17 = *(char **)(a1 + 8);
      uint64_t v16 = *(void *)(a1 + 16);
    }
    else
    {
      uint64_t v16 = *(unsigned __int8 *)(a1 + 31);
      uint64_t v17 = (char *)(a1 + 8);
    }
    int v18 = SHIBYTE(v13->__r_.__value_.__r.__words[2]);
    if (v18 >= 0) {
      uint64_t v19 = v13;
    }
    else {
      uint64_t v19 = (std::string *)v13->__r_.__value_.__r.__words[0];
    }
    if (v18 >= 0) {
      int64_t size = HIBYTE(v13->__r_.__value_.__r.__words[2]);
    }
    else {
      int64_t size = v13->__r_.__value_.__l.__size_;
    }
    if (size)
    {
      if (v16 >= size)
      {
        uint64_t v25 = &v17[v16];
        int v26 = v19->__r_.__value_.__s.__data_[0];
        uint64_t v27 = v17;
        do
        {
          uint64_t v28 = v16 - size;
          if (v28 == -1) {
            break;
          }
          uint64_t v29 = (char *)memchr(v27, v26, v28 + 1);
          if (!v29) {
            break;
          }
          double v30 = v29;
          if (!memcmp(v29, v19, size))
          {
            if (v30 != v25)
            {
              int64_t v24 = v30 - v17;
              if (v30 - v17 != -1) {
                goto LABEL_48;
              }
            }
            break;
          }
          uint64_t v27 = v30 + 1;
          uint64_t v16 = v25 - (v30 + 1);
        }
        while (v16 >= size);
      }
      sub_18DF0642C(&v61, __s);
      uint64_t v21 = std::string::append(&v61, ":", 1uLL);
      int v15 = *(char *)(a1 + 31);
      if (v15 < 0)
      {
        uint64_t v23 = *(char **)(a1 + 8);
        uint64_t v22 = *(void *)(a1 + 16);
      }
      else
      {
        uint64_t v22 = *(unsigned __int8 *)(a1 + 31);
        uint64_t v23 = (char *)(a1 + 8);
      }
      int v31 = SHIBYTE(v21->__r_.__value_.__r.__words[2]);
      if (v31 >= 0) {
        uint64_t v32 = v21;
      }
      else {
        uint64_t v32 = (std::string *)v21->__r_.__value_.__r.__words[0];
      }
      if (v31 >= 0) {
        int64_t v33 = HIBYTE(v21->__r_.__value_.__r.__words[2]);
      }
      else {
        int64_t v33 = v21->__r_.__value_.__l.__size_;
      }
      if (v33)
      {
        if (v22 >= v33)
        {
          uint64_t v35 = &v23[v22];
          int v36 = v32->__r_.__value_.__s.__data_[0];
          unint64_t v37 = v23;
          do
          {
            uint64_t v38 = v22 - v33;
            if (v38 == -1) {
              break;
            }
            uint64_t v39 = (char *)memchr(v37, v36, v38 + 1);
            if (!v39) {
              break;
            }
            uint64_t v40 = v39;
            if (!memcmp(v39, v32, v33))
            {
              char v34 = 1;
              if (v40 == v35) {
                goto LABEL_35;
              }
              LOBYTE(a3) = (_BYTE)__s;
              if (v40 != v23) {
                goto LABEL_97;
              }
              goto LABEL_47;
            }
            unint64_t v37 = v40 + 1;
            uint64_t v22 = v35 - (v40 + 1);
          }
          while (v22 >= v33);
        }
        char v34 = 1;
LABEL_35:
        LOBYTE(a3) = (_BYTE)__s;
LABEL_97:
        if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v61.__r_.__value_.__l.__data_);
          if (v34) {
            goto LABEL_99;
          }
        }
        else if (v34)
        {
          goto LABEL_99;
        }
        return 1;
      }
LABEL_47:
      int64_t v24 = 0;
    }
    else
    {
      int64_t v24 = 0;
    }
LABEL_48:
    std::string::size_type v41 = HIBYTE(v61.__r_.__value_.__r.__words[2]);
    if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v41 = v61.__r_.__value_.__l.__size_;
    }
    unint64_t v42 = v41 + v24;
    if ((v15 & 0x80) != 0) {
      goto LABEL_53;
    }
LABEL_51:
    unint64_t v43 = v15;
    if (v42 < v15)
    {
      while (v43 > v42)
      {
        uint64_t v44 = a1 + 8;
        if ((v15 & 0x80) != 0) {
          uint64_t v44 = *v14;
        }
        if (*(unsigned char *)(v44 + v42) != 58)
        {
          unint64_t v45 = v15;
          if ((v15 & 0x80) != 0) {
            unint64_t v45 = *(void *)(a1 + 16);
          }
          if (v45 <= v42) {
            break;
          }
          uint64_t v46 = a1 + 8;
          if ((v15 & 0x80) != 0) {
            uint64_t v46 = *v14;
          }
          if (*(unsigned char *)(v46 + v42) != 32)
          {
            unint64_t v47 = v15;
            if ((v15 & 0x80) != 0) {
              unint64_t v47 = *(void *)(a1 + 16);
            }
            if (v47 <= v42) {
              break;
            }
            uint64_t v48 = a1 + 8;
            if ((v15 & 0x80) != 0) {
              uint64_t v48 = *v14;
            }
            if (*(unsigned char *)(v48 + v42) != 9) {
              goto LABEL_72;
            }
          }
        }
        ++v42;
        if ((v15 & 0x80) == 0) {
          goto LABEL_51;
        }
LABEL_53:
        unint64_t v43 = *(void *)(a1 + 16);
        if (v42 >= v43) {
          goto LABEL_72;
        }
      }
      sub_18DEDE708();
    }
LABEL_72:
    uint64_t v49 = 0;
    LOBYTE(a3) = (_BYTE)__s;
    do
    {
      unint64_t v50 = v42 + v49;
      unint64_t v51 = *(unsigned __int8 *)(a1 + 31);
      if (*(char *)(a1 + 31) < 0)
      {
        if (v50 >= *(void *)(a1 + 16)) {
          break;
        }
      }
      else if (v50 >= v51)
      {
        break;
      }
      uint64_t v52 = a1 + 8;
      if ((v51 & 0x80) != 0) {
        uint64_t v52 = *v14;
      }
      if (*(unsigned char *)(v52 + v49 + v42) == 10) {
        break;
      }
      if ((v51 & 0x80) != 0) {
        unint64_t v53 = *(void *)(a1 + 16);
      }
      else {
        unint64_t v53 = *(unsigned __int8 *)(a1 + 31);
      }
      if (v53 <= v50) {
LABEL_105:
      }
        sub_18DEDE708();
      uint64_t v54 = a1 + 8;
      if ((v51 & 0x80) != 0) {
        uint64_t v54 = *v14;
      }
      if (*(unsigned char *)(v54 + v49 + v42) == 13) {
        break;
      }
      if ((v51 & 0x80) != 0) {
        unint64_t v55 = *(void *)(a1 + 16);
      }
      else {
        unint64_t v55 = *(unsigned __int8 *)(a1 + 31);
      }
      if (v55 <= v50) {
        goto LABEL_105;
      }
      uint64_t v56 = a1 + 8;
      if ((v51 & 0x80) != 0) {
        uint64_t v56 = *v14;
      }
      *((unsigned char *)a2 + v49) = *(unsigned char *)(v56 + v49 + v42);
      ++v49;
    }
    while (v49 != 255);
    *((unsigned char *)a2 + v49) = 0;
    if (*(unsigned char *)(a1 + 32))
    {
      __int16 v60 = 0;
      unsigned __int8 v59 = 2;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v60, &v59, "ConfigLoader: \"%s\" loaded value \"%s\"", a4, a5, a6, a7, a8, (char)__s);
    }
    char v34 = 0;
    goto LABEL_97;
  }
  if (*(void *)(a1 + 16)) {
    goto LABEL_5;
  }
LABEL_99:
  a2[14] = 0u;
  a2[15] = 0u;
  a2[12] = 0u;
  a2[13] = 0u;
  a2[10] = 0u;
  a2[11] = 0u;
  a2[8] = 0u;
  a2[9] = 0u;
  a2[6] = 0u;
  a2[7] = 0u;
  a2[4] = 0u;
  a2[5] = 0u;
  a2[2] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  if (*(unsigned char *)(a1 + 32))
  {
    LOWORD(v61.__r_.__value_.__l.__data_) = 0;
    LOBYTE(v60) = 2;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v61, (unsigned __int8 *)&v60, "ConfigLoader: \"%s\" using default value \"%s\"", a4, a5, a6, a7, a8, (char)a3);
  }
  return 0;
}

void sub_18E1A2F50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E1A2F78(uint64_t a1, char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!sub_18E1A2AE8(a1, __s, a3, a4, a5, a6, a7, a8)) {
    return 0;
  }
  if (!__s[0])
  {
    uint64_t v16 = 0;
    *a2 = 0;
    return v16;
  }
  p_p = (char *)&__p;
  sub_18DEDE7B0(&__p, __s);
  unsigned __int8 v10 = v25;
  std::string::size_type v11 = (void **)__p;
  if ((v25 & 0x80u) == 0) {
    uint64_t v12 = (char *)&__p + v25;
  }
  else {
    uint64_t v12 = (char *)__p + v24;
  }
  if ((v25 & 0x80u) != 0) {
    p_p = (char *)__p;
  }
  if (p_p != v12)
  {
    do
    {
      char *p_p = __tolower(*p_p);
      ++p_p;
    }
    while (p_p != v12);
    unsigned __int8 v10 = v25;
    std::string::size_type v11 = (void **)__p;
  }
  if ((v10 & 0x80u) == 0) {
    uint64_t v13 = &__p;
  }
  else {
    uint64_t v13 = v11;
  }
  int v14 = *(unsigned __int8 *)v13;
  if (v14 == 49) {
    goto LABEL_15;
  }
  if ((v10 & 0x80u) == 0) {
    uint64_t v17 = v10;
  }
  else {
    uint64_t v17 = v24;
  }
  if (v17 == 1)
  {
    if (v14 == 48 || v14 == 110) {
      goto LABEL_35;
    }
    if (v14 == 121)
    {
LABEL_15:
      char v15 = 1;
LABEL_36:
      uint64_t v16 = 1;
      goto LABEL_37;
    }
    goto LABEL_48;
  }
  if (v17 == 3)
  {
    if (*(_WORD *)v13 == 25977 && *((unsigned char *)v13 + 2) == 115) {
      goto LABEL_15;
    }
  }
  else if (v17 == 4 && *(_DWORD *)v13 == 1702195828)
  {
    goto LABEL_15;
  }
  if (v14 == 48)
  {
LABEL_35:
    char v15 = 0;
    goto LABEL_36;
  }
  if (v17 != 2)
  {
    if (v17 == 5)
    {
      char v15 = 0;
      uint64_t v16 = 0;
      int v20 = *(_DWORD *)v13;
      int v21 = *((unsigned __int8 *)v13 + 4);
      if (v20 != 1936482662 || v21 != 101) {
        goto LABEL_37;
      }
      goto LABEL_36;
    }
LABEL_48:
    char v15 = 0;
    uint64_t v16 = 0;
    goto LABEL_37;
  }
  char v15 = 0;
  uint64_t v16 = 0;
  if (*(_WORD *)v13 == 28526) {
    goto LABEL_36;
  }
LABEL_37:
  *a2 = v15;
  if ((v10 & 0x80) != 0) {
    operator delete(v11);
  }
  return v16;
}

void sub_18E1A3180(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

uint64_t sub_18E1A31A4(uint64_t a1, void *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t result = sub_18E1A2AE8(a1, __s, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v10 = 0;
    v11[0] = (unsigned __int8 *)__s;
    v11[1] = (unsigned __int8 *)&__s[strlen(__s)];
    if ((sub_18E00CF18(v11, (double *)&v10) & 1) == 0)
    {
      std::bad_cast::bad_cast(&v12);
      v12.__vftable = (std::bad_cast_vtbl *)&unk_1EDD12A68;
      uint64_t v13 = MEMORY[0x1E4FBA308];
      uint64_t v14 = MEMORY[0x1E4FBA388];
      sub_18E00D464((uint64_t)&v12);
    }
    *a2 = v10;
    return 1;
  }
  return result;
}

void sub_18E1A3288(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::exception a13, long long a14)
{
  std::exception::~exception(&a13);
  if (a2 == 1)
  {
    exception_ptr = (char *)__cxa_get_exception_ptr(a1);
    a13.__vftable = (std::exception_vtbl *)&unk_1EDD12A68;
    a14 = *(_OWORD *)(exception_ptr + 8);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a13);
    __cxa_end_catch();
    JUMPOUT(0x18E1A3210);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_18E1A3308(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    uint64_t v4 = a1 + 5;
    uint64_t v3 = (void **)a1[1];
  }
  else
  {
    uint64_t v4 = a1 + 5;
    unint64_t v5 = a1[4];
    unint64_t v6 = &v2[v5 / 0xAA];
    unint64_t v7 = (unint64_t)*v6;
    unint64_t v8 = (unint64_t)*v6 + 24 * (v5 % 0xAA);
    unint64_t v9 = (unint64_t)v2[(a1[5] + v5) / 0xAA] + 24 * ((a1[5] + v5) % 0xAA);
    if (v8 != v9)
    {
      do
      {
        if (*(char *)(v8 + 23) < 0)
        {
          operator delete(*(void **)v8);
          unint64_t v7 = (unint64_t)*v6;
        }
        v8 += 24;
        if (v8 - v7 == 4080)
        {
          unint64_t v10 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v10;
          unint64_t v8 = v10;
        }
      }
      while (v8 != v9);
      uint64_t v2 = (void **)a1[1];
      uint64_t v3 = (void **)a1[2];
    }
  }
  *uint64_t v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 85;
  }
  else
  {
    if (v12 != 2) {
      goto LABEL_18;
    }
    uint64_t v13 = 170;
  }
  a1[4] = v13;
LABEL_18:
  while (v2 != v3)
  {
    uint64_t v14 = *v2++;
    operator delete(v14);
  }

  return sub_18DEE1F78((uint64_t)a1);
}

void *sub_18E1A3460(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >= 0x555555555555556) {
      sub_18DEE1FC8();
    }
    uint64_t v4 = (char *)sub_18E1A34E8(a2);
    *a1 = v4;
    a1[1] = &v4[48 * a2];
    a1[2] = &v4[48 * v5];
  }
  return a1;
}

void sub_18E1A34CC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_18E1A34E8(unint64_t a1)
{
  if (a1 >= 0x555555555555556) {
    sub_18DEDF7D4();
  }
  return operator new(48 * a1);
}

void *sub_18E1A3530(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      sub_18DEE1FC8();
    }
    uint64_t v4 = 24 * a2;
    uint64_t v5 = (char *)operator new(24 * a2);
    *a1 = v5;
    a1[1] = &v5[v4];
    a1[2] = &v5[24 * a2];
  }
  return a1;
}

void sub_18E1A35AC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_18E1A35C8(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >= 0xE38E38E38E38E4) {
      sub_18DEE1FC8();
    }
    uint64_t v4 = (char *)sub_18E1A3654(a2);
    *a1 = v4;
    a1[1] = &v4[288 * a2];
    a1[2] = &v4[288 * v5];
  }
  return a1;
}

void sub_18E1A3638(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_18E1A3654(unint64_t a1)
{
  if (a1 >= 0xE38E38E38E38E4) {
    sub_18DEDF7D4();
  }
  return operator new(288 * a1);
}

uint64_t swan::LoadMATLABData::Load(uint64_t a1, const char *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x100uLL, "%s%s", a2, "t_noisy.txt");
  int v18 = fopen(__str, "r");
  if (!v18) {
    goto LABEL_26;
  }
  uint64_t v19 = v18;
  if (a3)
  {
    unint64_t v20 = 0;
    unsigned int v21 = 1;
    do
    {
      fscanf(v19, "%lf\n", a4 + 8 * v20);
      unint64_t v20 = v21++;
    }
    while (v20 < a3);
  }
  fclose(v19);
  snprintf(__str, 0x100uLL, "%s%s", a2, "x_noisy.txt");
  uint64_t v22 = fopen(__str, "r");
  if (!v22) {
    goto LABEL_26;
  }
  uint64_t v23 = v22;
  if (a3)
  {
    unint64_t v24 = 0;
    unsigned int v25 = 1;
    do
    {
      fscanf(v23, "%lf %lf %lf %lf %lf %lf\n", a5 + 48 * v24, a5 + 48 * v24 + 8, a5 + 48 * v24 + 16, a5 + 48 * v24 + 24, a5 + 48 * v24 + 32, a5 + 48 * v24 + 40);
      unint64_t v24 = v25++;
    }
    while (v24 < a3);
  }
  fclose(v23);
  snprintf(__str, 0x100uLL, "%s%s", a2, "sigma_x.txt");
  int v26 = fopen(__str, "r");
  if (!v26) {
    goto LABEL_26;
  }
  uint64_t v27 = v26;
  if (a3)
  {
    unint64_t v28 = 0;
    unsigned int v29 = 1;
    do
    {
      fscanf(v27, "%lf %lf %lf\n", a6 + 24 * v28, a6 + 24 * v28 + 8, a6 + 24 * v28 + 16);
      unint64_t v28 = v29++;
    }
    while (v28 < a3);
  }
  fclose(v27);
  snprintf(__str, 0x100uLL, "%s%s", a2, "sigma_vx.txt");
  double v30 = fopen(__str, "r");
  if (!v30) {
    goto LABEL_26;
  }
  int v31 = v30;
  if (a3)
  {
    unint64_t v32 = 0;
    unsigned int v33 = 1;
    do
    {
      fscanf(v31, "%lf %lf %lf\n", a7 + 24 * v32, a7 + 24 * v32 + 8, a7 + 24 * v32 + 16);
      unint64_t v32 = v33++;
    }
    while (v32 < a3);
  }
  fclose(v31);
  snprintf(__str, 0x100uLL, "%s%s", a2, "x0.txt");
  char v34 = fopen(__str, "r");
  if (!v34) {
    goto LABEL_26;
  }
  uint64_t v35 = v34;
  for (uint64_t i = 0; i != 48; i += 8)
    fscanf(v35, "%lf\n", a8 + i);
  fclose(v35);
  snprintf(__str, 0x100uLL, "%s%s", a2, "P0.txt");
  unint64_t v37 = fopen(__str, "r");
  if (!v37) {
    goto LABEL_26;
  }
  uint64_t v38 = v37;
  for (uint64_t j = 0; j != 48; j += 8)
    fscanf(v38, "%lf %lf %lf %lf %lf %lf\n", *(void *)(a9 + j), *(void *)(a9 + j) + 8, *(void *)(a9 + j) + 16, *(void *)(a9 + j) + 24, *(void *)(a9 + j) + 32, *(void *)(a9 + j) + 40);
  fclose(v38);
  snprintf(__str, 0x100uLL, "%s%s", a2, "sigma_wx_horizontal.txt");
  uint64_t v40 = fopen(__str, "r");
  if (v40
    && (fscanf(v40, "%lf\n", a10),
        snprintf(__str, 0x100uLL, "%s%s", a2, "sigma_wx_vertical.txt"),
        (std::string::size_type v41 = fopen(__str, "r")) != 0))
  {
    unint64_t v42 = v41;
    fscanf(v41, "%lf\n", a11);
    fclose(v42);
  }
  else
  {
LABEL_26:
    printf("Error opening %s. Exiting.\n", __str);
  }
  return 0xFFFFFFFFLL;
}

double swan::BatchLogParser::BatchLogParser(swan::BatchLogParser *this)
{
  *((void *)this + 8) = 0;
  double result = 0.0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

{
  double result;

  *((void *)this + 8) = 0;
  double result = 0.0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

BOOL swan::BatchLogParser::contains(swan::BatchLogParser *this, char *__s1, const char *__s2)
{
  BOOL result = 0;
  if (__s1)
  {
    if (__s2) {
      return strstr(__s1, __s2) != 0;
    }
  }
  return result;
}

void swan::BatchLogParser::trimField(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (v2) {
    operator new[]();
  }
}

BOOL swan::BatchLogParser::getField(void *a1, std::string *this, unint64_t a3)
{
  unint64_t v4 = a1[8];
  if (v4 > a3) {
    std::string::operator=(this, (const std::string *)(*(void *)(a1[4] + 8 * ((a1[7] + a3) / 0xAA)) + 24 * ((a1[7] + a3) % 0xAA)));
  }
  return v4 > a3;
}

BOOL swan::BatchLogParser::getField(void *a1, std::string *this, unsigned __int8 *a3, uint64_t a4)
{
  unint64_t v4 = a1[8];
  if (!v4) {
    return 0;
  }
  for (unint64_t i = 0; i < v4; ++i)
  {
    uint64_t v9 = a1[7];
    uint64_t v10 = a1[4];
    unint64_t v11 = (unsigned __int8 *)(*(void *)(v10 + 8 * ((v9 + i) / 0xAA)) + 24 * ((v9 + i) % 0xAA));
    uint64_t v12 = v11[23];
    if ((v12 & 0x80u) == 0) {
      uint64_t v13 = v11[23];
    }
    else {
      uint64_t v13 = *((void *)v11 + 1);
    }
    uint64_t v14 = a3[23];
    int v15 = (char)v14;
    if ((v14 & 0x80u) != 0) {
      uint64_t v14 = *((void *)a3 + 1);
    }
    if (v13 != v14) {
      continue;
    }
    if (v15 >= 0) {
      uint64_t v16 = a3;
    }
    else {
      uint64_t v16 = *(unsigned __int8 **)a3;
    }
    if ((v12 & 0x80) != 0)
    {
      if (memcmp(*(const void **)v11, v16, *((void *)v11 + 1))) {
        continue;
      }
    }
    else if (v11[23])
    {
      while (*v11 == *v16)
      {
        ++v11;
        ++v16;
        if (!--v12) {
          goto LABEL_18;
        }
      }
      continue;
    }
LABEL_18:
    if (i + a4 >= v4) {
      return 0;
    }
    std::string::operator=(this, (const std::string *)(*(void *)(v10 + 8 * ((v9 + i + a4) / 0xAA)) + 24 * ((v9 + i + a4) % 0xAA)));
    unint64_t v4 = a1[8];
  }
  std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((size & 0x80u) != 0) {
    std::string::size_type size = this->__r_.__value_.__l.__size_;
  }
  return size != 0;
}

BOOL swan::BatchLogParser::getField(swan::BatchLogParser *this, double *a2, unint64_t a3)
{
  memset(&v10, 0, sizeof(v10));
  unint64_t v4 = *((void *)this + 8);
  if (v4 > a3)
  {
    std::string::operator=(&v10, (const std::string *)(*(void *)(*((void *)this + 4) + 8 * ((*((void *)this + 7) + a3) / 0xAA))+ 24 * ((*((void *)this + 7) + a3) % 0xAA)));
    int v6 = SHIBYTE(v10.__r_.__value_.__r.__words[2]);
    unint64_t v7 = (void *)v10.__r_.__value_.__r.__words[0];
    if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v8 = &v10;
    }
    else {
      unint64_t v8 = (std::string *)v10.__r_.__value_.__r.__words[0];
    }
    *a2 = atof((const char *)v8);
    if (v6 < 0) {
      operator delete(v7);
    }
  }
  return v4 > a3;
}

void sub_18E1A3FD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL swan::BatchLogParser::getField(void *a1, double *a2, uint64_t a3, uint64_t a4)
{
  memset(&v13, 0, sizeof(v13));
  if (*(char *)(a3 + 23) < 0)
  {
    sub_18DEDE668(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v12 = *(void *)(a3 + 16);
  }
  BOOL Field = swan::BatchLogParser::getField(a1, &v13, (unsigned __int8 *)__p, a4);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  int v8 = SHIBYTE(v13.__r_.__value_.__r.__words[2]);
  if (Field)
  {
    if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v9 = &v13;
    }
    else {
      uint64_t v9 = (std::string *)v13.__r_.__value_.__r.__words[0];
    }
    *a2 = atof((const char *)v9);
  }
  if (v8 < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
  return Field;
}

void sub_18E1A40AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL swan::BatchLogParser::getField(swan::BatchLogParser *this, int *a2, unint64_t a3)
{
  memset(&v10, 0, sizeof(v10));
  unint64_t v4 = *((void *)this + 8);
  if (v4 > a3)
  {
    std::string::operator=(&v10, (const std::string *)(*(void *)(*((void *)this + 4) + 8 * ((*((void *)this + 7) + a3) / 0xAA))+ 24 * ((*((void *)this + 7) + a3) % 0xAA)));
    int v6 = SHIBYTE(v10.__r_.__value_.__r.__words[2]);
    unint64_t v7 = (void *)v10.__r_.__value_.__r.__words[0];
    if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v8 = &v10;
    }
    else {
      int v8 = (std::string *)v10.__r_.__value_.__r.__words[0];
    }
    *a2 = atoi((const char *)v8);
    if (v6 < 0) {
      operator delete(v7);
    }
  }
  return v4 > a3;
}

void sub_18E1A4198(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL swan::BatchLogParser::getField(swan::BatchLogParser *this, uint64_t *a2, unint64_t a3)
{
  memset(&v10, 0, sizeof(v10));
  unint64_t v4 = *((void *)this + 8);
  if (v4 > a3)
  {
    std::string::operator=(&v10, (const std::string *)(*(void *)(*((void *)this + 4) + 8 * ((*((void *)this + 7) + a3) / 0xAA))+ 24 * ((*((void *)this + 7) + a3) % 0xAA)));
    int v6 = SHIBYTE(v10.__r_.__value_.__r.__words[2]);
    unint64_t v7 = (void *)v10.__r_.__value_.__r.__words[0];
    if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v8 = &v10;
    }
    else {
      int v8 = (std::string *)v10.__r_.__value_.__r.__words[0];
    }
    *a2 = atoll((const char *)v8);
    if (v6 < 0) {
      operator delete(v7);
    }
  }
  return v4 > a3;
}

void sub_18E1A426C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL swan::BatchLogParser::getField(swan::BatchLogParser *this, unsigned int *a2, unint64_t a3)
{
  memset(&__str, 0, sizeof(__str));
  unint64_t v4 = *((void *)this + 8);
  if (v4 > a3)
  {
    std::string::operator=(&__str, (const std::string *)(*(void *)(*((void *)this + 4) + 8 * ((*((void *)this + 7) + a3) / 0xAA))+ 24 * ((*((void *)this + 7) + a3) % 0xAA)));
    *a2 = std::stoul(&__str, 0, 10);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
  return v4 > a3;
}

void sub_18E1A4334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL swan::BatchLogParser::getField(void *a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  memset(&__str, 0, sizeof(__str));
  if (*(char *)(a3 + 23) < 0)
  {
    sub_18DEDE668(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v11 = *(void *)(a3 + 16);
  }
  BOOL Field = swan::BatchLogParser::getField(a1, &__str, (unsigned __int8 *)__p, a4);
  BOOL v8 = Field;
  if (SHIBYTE(v11) < 0)
  {
    operator delete(__p[0]);
    if (!v8) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  if (Field) {
LABEL_8:
  }
    *a2 = std::stoul(&__str, 0, 10);
LABEL_9:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  return v8;
}

void sub_18E1A4414(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL swan::BatchLogParser::getField(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  memset(&v13, 0, sizeof(v13));
  if (*(char *)(a3 + 23) < 0)
  {
    sub_18DEDE668(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v12 = *(void *)(a3 + 16);
  }
  BOOL Field = swan::BatchLogParser::getField(a1, &v13, (unsigned __int8 *)__p, a4);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  int v8 = SHIBYTE(v13.__r_.__value_.__r.__words[2]);
  if (Field)
  {
    if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v9 = &v13;
    }
    else {
      uint64_t v9 = (std::string *)v13.__r_.__value_.__r.__words[0];
    }
    *a2 = atoll((const char *)v9);
  }
  if (v8 < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
  return Field;
}

void sub_18E1A4508(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL swan::BatchLogParser::getField(void *a1, int *a2, uint64_t a3, uint64_t a4)
{
  memset(&v13, 0, sizeof(v13));
  if (*(char *)(a3 + 23) < 0)
  {
    sub_18DEDE668(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v12 = *(void *)(a3 + 16);
  }
  BOOL Field = swan::BatchLogParser::getField(a1, &v13, (unsigned __int8 *)__p, a4);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  int v8 = SHIBYTE(v13.__r_.__value_.__r.__words[2]);
  if (Field)
  {
    if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v9 = &v13;
    }
    else {
      uint64_t v9 = (std::string *)v13.__r_.__value_.__r.__words[0];
    }
    *a2 = atoi((const char *)v9);
  }
  if (v8 < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
  return Field;
}

void sub_18E1A45FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void swan::BatchLogParser::wipef()
{
  sub_18E1A8DD4(&v0);
  uint64_t v3 = 0;
  long long v2 = 0u;
  long long v1 = 0u;
  sub_18E1A8E34();
}

void sub_18E1A4BE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,std::locale a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  sub_18E1A4C7C(&a26);
  _Unwind_Resume(a1);
}

void sub_18E1A4C7C(std::locale *this)
{
  locale = (std::__shared_weak_count *)this[6].__locale_;
  if (locale) {
    sub_18DEE4E18(locale);
  }

  std::locale::~locale(this);
}

void swan::BatchLogParser::update(std::string *a1, const std::string *a2)
{
  std::string::operator=(a1, a2);
  swan::BatchLogParser::wipef();
}

void sub_18E1A5364(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  operator delete(v18);
  if (v17) {
    operator delete(v17);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void swan::BatchLogParser::updateEnforceCsv(std::string *a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    sub_18DEDE668(&__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    for (uint64_t i = 0; i != size; ++i)
    {
      char v5 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      std::string::size_type v6 = __p.__r_.__value_.__r.__words[0];
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if (p_p->__r_.__value_.__s.__data_[i] == 58)
      {
        p_p->__r_.__value_.__s.__data_[i] = 44;
        char v5 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        std::string::size_type v6 = __p.__r_.__value_.__r.__words[0];
      }
      if (v5 >= 0) {
        int v8 = &__p;
      }
      else {
        int v8 = (std::string *)v6;
      }
      if (v8->__r_.__value_.__s.__data_[i] == 93)
      {
        v8->__r_.__value_.__s.__data_[i] = 44;
        char v5 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        std::string::size_type v6 = __p.__r_.__value_.__r.__words[0];
      }
      if (v5 >= 0) {
        uint64_t v9 = &__p;
      }
      else {
        uint64_t v9 = (std::string *)v6;
      }
      if (v9->__r_.__value_.__s.__data_[i] == 61) {
        v9->__r_.__value_.__s.__data_[i] = 44;
      }
    }
  }
  swan::BatchLogParser::update(a1, &__p);
}

void sub_18E1A54B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t swan::BatchLogParser::convertASCIIToStruct(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  long long v2 = v1;
  unint64_t v4 = v3;
  unint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  bzero(&v34, 0xF8uLL);
  if (*(char *)(v10 + 23) >= 0) {
    uint64_t v11 = (const char *)v10;
  }
  else {
    uint64_t v11 = *(const char **)v10;
  }
  uint64_t v12 = fopen(v11, "r");
  if (v12)
  {
    std::string v13 = v12;
    sub_18DEDE7B0(&__p, "%%1:deviceTime(s),2:Latitude(deg),3:Longitude(deg),4:Accuracy(m),5:TTFF(s),6:TTF(s),7:Speed(m/s),8:Course(deg),9:Altitude(m),10:VerticalAccuracy(m),11:AssistanceTime,12:AssistanceLocation,13:AssistanceEph,14:GpsTimeOfWeeks(ms),15:GpsWeek,16:Undulation(m),17:SpeedAccuracy(m/s),18:CourseAccuracy(deg),19:A(m),20:B(m),21:AZ(deg),22:HDOP,23:VDOP,24:ODOM,25:LP,26:SA,27:R,28:VTOW,29:CTOW,30:TUNC,31:NS,32:MS,33:AgeOfPowerMode,34:SQI,35:verticalSpeed(m/s),36:vertcalSpeedAccuracy(m/s)\n");
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    *long long v2 = 0;
    while (1)
    {
      do
      {
        if (feof(v13) || !fgets(v50, 0x2000, v13)) {
          goto LABEL_14;
        }
      }
      while (v50[0] == 37);
      if (sscanf(v50, "%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%d,%d,%d,%d,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%d,%d,%d,%d,%d,%lf,%d,%d,%lf,%d,%lf,%lf\n", &v34, (char *)&v34 + 8, &v35, (char *)&v35 + 8, &v36, (char *)&v36 + 8, &v37, (char *)&v37 + 8, &v38, (char *)&v38 + 8, &v39, (char *)&v39 + 4, (char *)&v39 + 8, (char *)&v39 + 12, &v40, (char *)&v40 + 8,
             &v41,
             (char *)&v41 + 8,
             &v42,
             (char *)&v42 + 8,
             &v43,
             (char *)&v43 + 8,
             &v44,
             (char *)&v44 + 8,
             &v45,
             (char *)&v45 + 4,
             (char *)&v45 + 8,
             (char *)&v45 + 12,
             &v46,
             (char *)&v46 + 8,
             &v47,
             (char *)&v47 + 4,
             (char *)&v47 + 8,
             &v48,
             (char *)&v48 + 8,
             &v49) != 36)
        break;
      uint64_t v16 = *v4 + 248 * v15;
      long long v17 = v34;
      long long v18 = v35;
      long long v19 = v37;
      *(_OWORD *)(v16 + 32) = v36;
      *(_OWORD *)(v16 + 48) = v19;
      *(_OWORD *)uint64_t v16 = v17;
      *(_OWORD *)(v16 + 16) = v18;
      long long v20 = v38;
      long long v21 = v39;
      long long v22 = v41;
      *(_OWORD *)(v16 + 96) = v40;
      *(_OWORD *)(v16 + 112) = v22;
      *(_OWORD *)(v16 + 64) = v20;
      *(_OWORD *)(v16 + 80) = v21;
      long long v23 = v42;
      long long v24 = v43;
      long long v25 = v45;
      *(_OWORD *)(v16 + 160) = v44;
      *(_OWORD *)(v16 + 176) = v25;
      *(_OWORD *)(v16 + 128) = v23;
      *(_OWORD *)(v16 + 144) = v24;
      long long v26 = v46;
      long long v27 = v47;
      long long v28 = v48;
      *(void *)(v16 + 240) = v49;
      *(_OWORD *)(v16 + 208) = v27;
      *(_OWORD *)(v16 + 224) = v28;
      *(_OWORD *)(v16 + 192) = v26;
      if (++v14 > v6) {
        ++v15;
      }
      if (v15 == v8)
      {
        uint64_t v15 = v8;
LABEL_14:
        uint64_t v29 = 0;
        *long long v2 = v15;
        goto LABEL_15;
      }
    }
    uint64_t v29 = 0xFFFFFFFFLL;
LABEL_15:
    if (v33 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    if (*(char *)(v10 + 23) >= 0) {
      double v30 = (const char *)v10;
    }
    else {
      double v30 = *(const char **)v10;
    }
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Unable to open %s\n", v30);
    return 0xFFFFFFFFLL;
  }
  return v29;
}

{
  void *v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  FILE *v7;
  FILE *v8;
  uint64_t v9;
  const char *v10;
  uint64_t v12;
  void *__p;
  char v14;
  char __src[264];
  char v16[8192];
  uint64_t v17;

  MEMORY[0x1F4188790](a1);
  long long v2 = v1;
  uint64_t v12 = v3;
  unint64_t v5 = v4;
  long long v17 = *MEMORY[0x1E4F143B8];
  bzero(__src, 0x108uLL);
  if (*(char *)(v5 + 23) >= 0) {
    unint64_t v6 = (const char *)v5;
  }
  else {
    unint64_t v6 = *(const char **)v5;
  }
  uint64_t v7 = fopen(v6, "r");
  if (v7)
  {
    uint64_t v8 = v7;
    sub_18DEDE7B0(&__p, "%%1:deviceTime(s),2:Latitude(deg),3:Longitude(deg),4:Accuracy(m),5:TTFF(s),6:TTF(s),7:Speed(m/s),8:Course(deg),9:Altitude(m),10:VerticalAccuracy(m),11:AssistanceTime,12:AssistanceLocation,13:AssistanceEph,14:GpsTimeOfWeeks(ms),15:GpsWeek,16:Undulation(m),17:SpeedAccuracy(m/s),18:CourseAccuracy(deg),19:A(m),20:B(m),21:AZ(deg),22:HDOP,23:VDOP,24:ODOM,25:LP,26:SA,27:R,28:VTOW,29:CTOW,30:TUNC,31:NS,32:MS,33:AgeOfPowerMode,34:SQI,35:verticalSpeed(m/s),36:vertcalSpeedAccuracy(m/s)\n");
    *long long v2 = 0;
    if (!feof(v8))
    {
      while (fgets(v16, 0x2000, v8))
      {
        if (v16[0] != 37)
        {
          if (sscanf(v16, "%lf,%x,%lf,%d,%d,%lld,%d,%lf,%lf,%lf,%lf,%lf,%d,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%d,%lf,%lf,%lf,%d,%lf,%lf,%lf,%lf\n", __src, &__src[8], &__src[16], &__src[24], &__src[28], &__src[32], &__src[40], &__src[48], &__src[56], &__src[64], &__src[72], &__src[80], &__src[88], &__src[96], &__src[104], &__src[112],
                 &__src[120],
                 &__src[128],
                 &__src[136],
                 &__src[144],
                 &__src[152],
                 &__src[160],
                 &__src[168],
                 &__src[176],
                 &__src[184],
                 &__src[192],
                 &__src[200],
                 &__src[208],
                 &__src[216],
                 &__src[224],
                 &__src[232],
                 &__src[240],
                 &__src[248],
                 &__src[256]) != 34)
          {
            uint64_t v9 = 0xFFFFFFFFLL;
            goto LABEL_7;
          }
          memcpy((void *)(v12 + 264 * *v2), __src, 0x108uLL);
          ++*v2;
        }
        if (feof(v8)) {
          break;
        }
      }
    }
    uint64_t v9 = 0;
LABEL_7:
    if (v14 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    if (*(char *)(v5 + 23) >= 0) {
      uint64_t v10 = (const char *)v5;
    }
    else {
      uint64_t v10 = *(const char **)v5;
    }
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Unable to open %s\n", v10);
    return 0;
  }
  return v9;
}

uint64_t swan::BatchLogParser::parseGPSBatchIntoASCII(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  long long v2 = v1;
  uint64_t v4 = v3;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  bzero(v43, 0x108uLL);
  if (*(char *)(v4 + 23) >= 0) {
    unint64_t v5 = (const char *)v4;
  }
  else {
    unint64_t v5 = *(const char **)v4;
  }
  unint64_t v6 = fopen(v5, "r");
  if (!v6)
  {
    if (*(char *)(v4 + 23) >= 0) {
      double v30 = (const char *)v4;
    }
    else {
      double v30 = *(const char **)v4;
    }
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Unable to open %s\n", v30);
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = v6;
  if (*((char *)v2 + 23) >= 0) {
    size_t v8 = *((unsigned __int8 *)v2 + 23);
  }
  else {
    size_t v8 = (size_t)v2[1];
  }
  p_p = &__p;
  sub_18DF06474((uint64_t)&__p, v8 + 6);
  if (v42 < 0) {
    p_p = __p;
  }
  if (v8)
  {
    if (*((char *)v2 + 23) >= 0) {
      uint64_t v10 = v2;
    }
    else {
      uint64_t v10 = *v2;
    }
    memmove(p_p, v10, v8);
  }
  strcpy((char *)p_p + v8, ".1.csv");
  if (v42 >= 0) {
    uint64_t v11 = (const char *)&__p;
  }
  else {
    uint64_t v11 = (const char *)__p;
  }
  uint64_t v12 = fopen(v11, "w");
  if (!v12)
  {
    int v31 = (const char *)&__p;
    if (v42 < 0) {
      int v31 = (const char *)__p;
    }
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Unable to open %s\n", v31);
    uint64_t v29 = 0xFFFFFFFFLL;
    goto LABEL_84;
  }
  sub_18DEDE7B0(v38, "%%1:deviceTime(s),2:Latitude(deg),3:Longitude(deg),4:Accuracy(m),5:TTFF(s),6:TTF(s),7:Speed(m/s),8:Course(deg),9:Altitude(m),10:VerticalAccuracy(m),11:AssistanceTime,12:AssistanceLocation,13:AssistanceEph,14:GpsTimeOfWeeks(ms),15:GpsWeek,16:Undulation(m),17:SpeedAccuracy(m/s),18:CourseAccuracy(deg),19:A(m),20:B(m),21:AZ(deg),22:HDOP,23:VDOP,24:ODOM,25:LP,26:SA,27:R,28:VTOW,29:CTOW,30:TUNC,31:NS,32:MS,33:AgeOfPowerMode,34:SQI,35:verticalSpeed(m/s),36:vertcalSpeedAccuracy(m/s)\n");
  if (v39 >= 0) {
    std::string v13 = v38;
  }
  else {
    std::string v13 = (void **)v38[0];
  }
  fputs((const char *)v13, v12);
  int v14 = 1;
  unsigned int v33 = -1;
  while (!feof(v7) && fgets(__s1, 0x2000, v7))
  {
    uint64_t v37 = 0;
    memset(v36, 0, sizeof(v36));
    if (strstr(__s1, "Batched results processed"))
    {
      fclose(v12);
      if (*((char *)v2 + 23) >= 0) {
        size_t v15 = *((unsigned __int8 *)v2 + 23);
      }
      else {
        size_t v15 = (size_t)v2[1];
      }
      sub_18DF06474((uint64_t)&v35, v15 + 1);
      if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v16 = &v35;
      }
      else {
        uint64_t v16 = (std::string *)v35.__r_.__value_.__r.__words[0];
      }
      if (v15)
      {
        if (*((char *)v2 + 23) >= 0) {
          long long v17 = v2;
        }
        else {
          long long v17 = *v2;
        }
        memmove(v16, v17, v15);
      }
      ++v14;
      *(_WORD *)((char *)&v16->__r_.__value_.__l.__data_ + v15) = 46;
      std::to_string(&v34, v14);
      if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v18 = &v34;
      }
      else {
        long long v18 = (std::string *)v34.__r_.__value_.__r.__words[0];
      }
      if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v34.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v34.__r_.__value_.__l.__size_;
      }
      long long v20 = std::string::append(&v35, (const std::string::value_type *)v18, size);
      long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
      v46[0].__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v46[0].__r_.__value_.__l.__data_ = v21;
      v20->__r_.__value_.__l.__size_ = 0;
      v20->__r_.__value_.__r.__words[2] = 0;
      v20->__r_.__value_.__r.__words[0] = 0;
      long long v22 = std::string::append(v46, ".csv", 4uLL);
      long long v23 = (void *)v22->__r_.__value_.__r.__words[0];
      v44[0] = v22->__r_.__value_.__l.__size_;
      *(void *)((char *)v44 + 7) = *(std::string::size_type *)((char *)&v22->__r_.__value_.__r.__words[1] + 7);
      char v24 = HIBYTE(v22->__r_.__value_.__r.__words[2]);
      v22->__r_.__value_.__l.__size_ = 0;
      v22->__r_.__value_.__r.__words[2] = 0;
      v22->__r_.__value_.__r.__words[0] = 0;
      if (v42 < 0) {
        operator delete(__p);
      }
      std::string __p = v23;
      *(void *)long long v41 = v44[0];
      *(void *)&v41[7] = *(void *)((char *)v44 + 7);
      char v42 = v24;
      if (SHIBYTE(v46[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v46[0].__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v34.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v35.__r_.__value_.__l.__data_);
      }
      if (v42 >= 0) {
        long long v25 = (const char *)&__p;
      }
      else {
        long long v25 = (const char *)__p;
      }
      uint64_t v12 = fopen(v25, "w");
      if (!v12)
      {
        long long v28 = (const char *)&__p;
        if (v42 < 0) {
          long long v28 = (const char *)__p;
        }
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "Unable to open %s\n", v28);
        char v27 = 0;
        goto LABEL_67;
      }
      sub_18DEDE7B0(v46, "%%1:deviceTime(s),2:Latitude(deg),3:Longitude(deg),4:Accuracy(m),5:TTFF(s),6:TTF(s),7:Speed(m/s),8:Course(deg),9:Altitude(m),10:VerticalAccuracy(m),11:AssistanceTime,12:AssistanceLocation,13:AssistanceEph,14:GpsTimeOfWeeks(ms),15:GpsWeek,16:Undulation(m),17:SpeedAccuracy(m/s),18:CourseAccuracy(deg),19:A(m),20:B(m),21:AZ(deg),22:HDOP,23:VDOP,24:ODOM,25:LP,26:SA,27:R,28:VTOW,29:CTOW,30:TUNC,31:NS,32:MS,33:AgeOfPowerMode,34:SQI,35:verticalSpeed(m/s),36:vertcalSpeedAccuracy(m/s)\n");
      if ((v46[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v26 = v46;
      }
      else {
        long long v26 = (std::string *)v46[0].__r_.__value_.__r.__words[0];
      }
      fputs((const char *)v26, v12);
      if (SHIBYTE(v46[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v46[0].__r_.__value_.__l.__data_);
      }
      unsigned int v33 = 0;
    }
    if (strstr(__s1, ",CL-GPS,BATCHED,"))
    {
      sub_18DEDE7B0(v46, __s1);
      swan::BatchLogParser::updateEnforceCsv((std::string *)v36, (uint64_t)v46);
    }
    char v27 = 1;
LABEL_67:
    sub_18E1A3308(&v36[24]);
    if ((v36[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)v36);
      if ((v27 & 1) == 0)
      {
LABEL_71:
        uint64_t v29 = 0;
        goto LABEL_79;
      }
    }
    else if ((v27 & 1) == 0)
    {
      goto LABEL_71;
    }
  }
  if (v12) {
    fclose(v12);
  }
  fclose(v7);
  uint64_t v29 = v33;
LABEL_79:
  if (v39 < 0) {
    operator delete(v38[0]);
  }
LABEL_84:
  if (v42 < 0) {
    operator delete(__p);
  }
  return v29;
}

void sub_18E1A68EC(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x4B7]) < 0) {
    operator delete((void *)STACK[0x4A0]);
  }
  _Unwind_Resume(a1);
}

uint64_t swan::BatchLogParser::parseGPSSaIntoASCII(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v2 = v1;
  int v4 = v3;
  uint64_t v6 = v5;
  __p[128] = *(void **)MEMORY[0x1E4F143B8];
  bzero(&v27, 0xF8uLL);
  if (*(char *)(v6 + 23) >= 0) {
    uint64_t v7 = (const char *)v6;
  }
  else {
    uint64_t v7 = *(const char **)v6;
  }
  size_t v8 = fopen(v7, "r");
  if (!v8)
  {
    long long v20 = (FILE *)*MEMORY[0x1E4F143C8];
    if (*(char *)(v6 + 23) >= 0) {
      long long v21 = (const char *)v6;
    }
    else {
      long long v21 = *(const char **)v6;
    }
    goto LABEL_26;
  }
  uint64_t v9 = v8;
  int v10 = *(char *)(v6 + 23);
  if (v10 >= 0) {
    uint64_t v11 = v6;
  }
  else {
    uint64_t v11 = *(void *)v6;
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(v6 + 23);
  }
  else {
    uint64_t v12 = *(void *)(v6 + 8);
  }
  std::string v13 = sub_18DEDD538(MEMORY[0x1E4FBA250], v11, v12);
  std::ios_base::getloc((const std::ios_base *)((char *)v13 + *(void *)(*v13 - 24)));
  int v14 = std::locale::use_facet((const std::locale *)__p, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10);
  std::locale::~locale((std::locale *)__p);
  std::ostream::put();
  std::ostream::flush();
  if (*(char *)(v2 + 23) >= 0) {
    size_t v15 = (const char *)v2;
  }
  else {
    size_t v15 = *(const char **)v2;
  }
  uint64_t v16 = fopen(v15, "w");
  if (!v16)
  {
    long long v20 = (FILE *)*MEMORY[0x1E4F143C8];
    if (*(char *)(v2 + 23) >= 0) {
      long long v21 = (const char *)v2;
    }
    else {
      long long v21 = *(const char **)v2;
    }
LABEL_26:
    fprintf(v20, "Unable to open %s\n", v21);
    return 0;
  }
  long long v17 = v16;
  sub_18DEDE7B0(v25, "%%1:deviceTime(s),2:Latitude(deg),3:Longitude(deg),4:Accuracy(m),5:TTFF(s),6:TTF(s),7:Speed(m/s),8:Course(deg),9:Altitude(m),10:VerticalAccuracy(m),11:AssistanceTime,12:AssistanceLocation,13:AssistanceEph,14:GpsTimeOfWeeks(ms),15:GpsWeek,16:Undulation(m),17:SpeedAccuracy(m/s),18:CourseAccuracy(deg),19:A(m),20:B(m),21:AZ(deg),22:HDOP,23:VDOP,24:ODOM,25:LP,26:SA,27:R,28:VTOW,29:CTOW,30:TUNC,31:NS,32:MS,33:AgeOfPowerMode,34:SQI,35:verticalSpeed(m/s),36:vertcalSpeedAccuracy(m/s)\n");
  if (v26 >= 0) {
    long long v18 = v25;
  }
  else {
    long long v18 = (void **)v25[0];
  }
  fputs((const char *)v18, v17);
  if (feof(v9))
  {
    uint64_t v19 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v19 = 0xFFFFFFFFLL;
    do
    {
      if (!fgets(__s1, 0x2000, v9)) {
        break;
      }
      uint64_t v24 = 0;
      memset(v23, 0, sizeof(v23));
      if (strstr(__s1, "Type,CL-GPSsa,Pos,") && !strstr(__s1, "TTFF") && (v4 & 1) == 0
        || strstr(__s1, ",Type,CL-BATCHED,Pos,") && v4)
      {
        sub_18DEDE7B0(__p, __s1);
        swan::BatchLogParser::updateEnforceCsv((std::string *)v23, (uint64_t)__p);
      }
      sub_18E1A3308(&v23[24]);
      if ((v23[23] & 0x80000000) != 0) {
        operator delete(*(void **)v23);
      }
    }
    while (!feof(v9));
  }
  fclose(v17);
  fclose(v9);
  if (v26 < 0) {
    operator delete(v25[0]);
  }
  return v19;
}

void sub_18E1A7910(_Unwind_Exception *a1)
{
}

uint64_t swan::BatchLogParser::parseRavenFixIntoRouteSmootherEpoch(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v2 = v1;
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  long long v23 = xmmword_18E22B980;
  long long v24 = xmmword_18E200CE0;
  __asm { FMOV            V0.2D, #-1.0 }
  long long v25 = xmmword_18E200CE0;
  long long v26 = _Q0;
  long long v27 = _Q0;
  long long v28 = _Q0;
  unint64_t v29 = 0xBFF0000000000000;
  char v30 = 0;
  if (*(char *)(v1 + 23) >= 0) {
    size_t v8 = (const char *)v1;
  }
  else {
    size_t v8 = *(const char **)v1;
  }
  uint64_t v9 = fopen(v8, "r");
  if (v9)
  {
    int v10 = v9;
    int v11 = *(char *)(v2 + 23);
    if (v11 >= 0) {
      uint64_t v12 = v2;
    }
    else {
      uint64_t v12 = *(void *)v2;
    }
    if (v11 >= 0) {
      uint64_t v13 = *(unsigned __int8 *)(v2 + 23);
    }
    else {
      uint64_t v13 = *(void *)(v2 + 8);
    }
    int v14 = sub_18DEDD538(MEMORY[0x1E4FBA250], v12, v13);
    std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(void *)(*v14 - 24)));
    size_t v15 = std::locale::use_facet(v20, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10);
    std::locale::~locale(v20);
    std::ostream::put();
    std::ostream::flush();
    if (feof(v10))
    {
      uint64_t v16 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v16 = 0xFFFFFFFFLL;
      do
      {
        if (!fgets(__s1, 0x2000, v10)) {
          break;
        }
        uint64_t v22 = 0;
        *(_OWORD *)&v20[0].__locale_ = 0u;
        memset(v21, 0, sizeof(v21));
        if (strstr(__s1, "Raven,Fix,1,solution_type,5"))
        {
          sub_18DEDE7B0(&__p, __s1);
          swan::BatchLogParser::updateEnforceCsv((std::string *)v20, (uint64_t)&__p);
        }
        if (strstr(__s1, "CL,Pos,1"))
        {
          sub_18DEDE7B0(&__p, __s1);
          swan::BatchLogParser::updateEnforceCsv((std::string *)v20, (uint64_t)&__p);
        }
        sub_18E1A3308((void *)v21 + 1);
        if (SBYTE7(v21[0]) < 0) {
          operator delete(v20[0].__locale_);
        }
      }
      while (!feof(v10));
    }
    fclose(v10);
  }
  else
  {
    if (*(char *)(v2 + 23) >= 0) {
      long long v17 = (const char *)v2;
    }
    else {
      long long v17 = *(const char **)v2;
    }
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Unable to open %s\n", v17);
    return 0;
  }
  return v16;
}

void sub_18E1A8458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,std::locale a61)
{
}

uint64_t swan::BatchLogParser::parseCLRSFixIntoRouteSmootherEpoch(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  int v3 = v2;
  uint64_t v4 = v1;
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  long long v25 = xmmword_18E22B980;
  long long v26 = xmmword_18E200CE0;
  __asm { FMOV            V0.2D, #-1.0 }
  long long v27 = xmmword_18E200CE0;
  long long v28 = _Q0;
  long long v29 = _Q0;
  long long v30 = _Q0;
  unint64_t v31 = 0xBFF0000000000000;
  char v32 = 0;
  if (*(char *)(v1 + 23) >= 0) {
    int v10 = (const char *)v1;
  }
  else {
    int v10 = *(const char **)v1;
  }
  int v11 = fopen(v10, "r");
  if (v11)
  {
    uint64_t v12 = v11;
    int v13 = *(char *)(v4 + 23);
    if (v13 >= 0) {
      uint64_t v14 = v4;
    }
    else {
      uint64_t v14 = *(void *)v4;
    }
    if (v13 >= 0) {
      uint64_t v15 = *(unsigned __int8 *)(v4 + 23);
    }
    else {
      uint64_t v15 = *(void *)(v4 + 8);
    }
    uint64_t v16 = sub_18DEDD538(MEMORY[0x1E4FBA250], v14, v15);
    std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(void *)(*v16 - 24)));
    long long v17 = std::locale::use_facet(v22, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
    std::locale::~locale(v22);
    std::ostream::put();
    std::ostream::flush();
    if (feof(v12))
    {
      uint64_t v18 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v18 = 0xFFFFFFFFLL;
      do
      {
        if (!fgets(__s1, 0x2000, v12)) {
          break;
        }
        uint64_t v24 = 0;
        *(_OWORD *)&v22[0].__locale_ = 0u;
        memset(v23, 0, sizeof(v23));
        if (strstr(__s1, "CLRS,") && strstr(__s1, "PreMMRaw,latitude,"))
        {
          sub_18DEDE7B0(__p, __s1);
          swan::BatchLogParser::updateEnforceCsv((std::string *)v22, (uint64_t)__p);
        }
        if (strstr(__s1, "CLRS,Smoothing,PreMM,dataCount,")) {
          v3[1] = *v3;
        }
        sub_18E1A3308((void *)v23 + 1);
        if (SBYTE7(v23[0]) < 0) {
          operator delete(v22[0].__locale_);
        }
      }
      while (!feof(v12));
    }
    fclose(v12);
  }
  else
  {
    if (*(char *)(v4 + 23) >= 0) {
      uint64_t v19 = (const char *)v4;
    }
    else {
      uint64_t v19 = *(const char **)v4;
    }
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Unable to open %s\n", v19);
    return 0;
  }
  return v18;
}

void sub_18E1A8C5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,std::locale a55)
{
}

void *sub_18E1A8D88(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x24924924924924ALL) {
    sub_18DEDF7D4();
  }
  return operator new(112 * a2);
}

const std::locale *sub_18E1A8DD4(const std::locale *a1)
{
  uint64_t v2 = (const std::locale *)MEMORY[0x192FA6100]();
  a1[1].__locale_ = (std::locale::__imp *)std::locale::use_facet(v2, MEMORY[0x1E4FBA258]);
  a1[2].__locale_ = (std::locale::__imp *)std::locale::use_facet(a1, MEMORY[0x1E4FBA280]);
  return a1;
}

void sub_18E1A8E20(_Unwind_Exception *a1)
{
  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

void sub_18E1A8E34()
{
}

void sub_18E1A9268(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  _Unwind_Resume(a1);
}

void sub_18E1A92CC()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x192FA5CA0](exception, 17);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_18E1A9310(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *sub_18E1A9324(_DWORD *a1, unsigned __int8 *a2, char *a3)
{
  uint64_t v6 = a2;
  do
  {
    uint64_t v7 = v6;
    uint64_t v6 = sub_18E1A9A18(a1, v6, a3);
  }
  while (v6 != v7);
  if (v7 == a2) {
    operator new();
  }
  if (v7 != (unsigned __int8 *)a3)
  {
    if (*v7 == 124)
    {
      size_t v8 = v7 + 1;
      uint64_t v9 = v7 + 1;
      do
      {
        int v10 = v9;
        uint64_t v9 = sub_18E1A9A18(a1, v9, a3);
      }
      while (v9 != v10);
      if (v10 == v8) {
        operator new();
      }
      sub_18E1A9910();
    }
    return (char *)v7;
  }
  return a3;
}

unsigned __int8 *sub_18E1A9484(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  int v3 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v4 = a3;
  if (*a2 == 94) {
    sub_18E1AA324();
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v6 = v3;
      int v3 = sub_18E1B0830(a1, v3, v4);
    }
    while (v3 != v6);
    if (v6 != v4)
    {
      if (v6 + 1 == v4 && *v6 == 36) {
        sub_18E1AA3A8();
      }
      sub_18E1B07D8();
    }
  }
  return v4;
}

unsigned __int8 *sub_18E1A9534(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  int v3 = a3;
  uint64_t v6 = sub_18E1B0D58(a1, a2, a3);
  if (v6 == a2) {
LABEL_8:
  }
    sub_18E1B07D8();
  if (v6 != (unsigned __int8 *)v3)
  {
    if (*v6 == 124)
    {
      if (sub_18E1B0D58(a1, v6 + 1, v3) != v6 + 1) {
        sub_18E1A9910();
      }
      goto LABEL_8;
    }
    return v6;
  }
  return (unsigned __int8 *)v3;
}

void sub_18E1A95D8()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x192FA5CA0](exception, 14);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_18E1A961C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_18E1A9634()
{
}

void sub_18E1A9648(uint64_t a1, _DWORD *a2)
{
  *a2 = -1000;
}

void sub_18E1A9660(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1A9698(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_18E1A96C8(uint64_t a1, uint64_t a2)
{
  if (sub_18DEE4C68(a2, (uint64_t)&unk_1EDD09258)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_18E1A970C(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_18E1A9778(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1A9804(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void *sub_18E1A9818(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_18E1A9884(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x192FA6240);
}

void sub_18E1A9910()
{
}

unsigned __int8 *sub_18E1A9A18(_DWORD *a1, unsigned __int8 *a2, char *a3)
{
  if (a2 == (unsigned __int8 *)a3) {
    return a2;
  }
  int v6 = (char)*a2;
  int v7 = *a2;
  if (v6 > 91)
  {
    if (v6 == 92)
    {
      if (a2 + 1 != (unsigned __int8 *)a3)
      {
        int v13 = a2[1];
        if (v13 == 66 || v13 == 98) {
          sub_18E1AA42C();
        }
      }
    }
    else if (v6 == 94)
    {
      sub_18E1AA324();
    }
  }
  else
  {
    if (v6 == 36) {
      sub_18E1AA3A8();
    }
    BOOL v9 = v6 == 40;
    size_t v8 = (char *)(a2 + 1);
    BOOL v9 = !v9 || v8 == a3;
    if (!v9)
    {
      BOOL v9 = *v8 == 63;
      int v10 = (char *)(a2 + 2);
      if (v9 && v10 != a3)
      {
        int v12 = *v10;
        if (v12 == 33)
        {
          sub_18E1A8DD4(v27);
          long long v28 = 0u;
          uint64_t v30 = 0;
          long long v29 = 0u;
          LODWORD(v28) = a1[6];
          sub_18E1A8E34(v27, a2 + 3, a3);
          sub_18E1AA4C0();
        }
        if (v12 == 61)
        {
          sub_18E1A8DD4(v27);
          long long v28 = 0u;
          uint64_t v30 = 0;
          long long v29 = 0u;
          LODWORD(v28) = a1[6];
          sub_18E1A8E34(v27, a2 + 3, a3);
          sub_18E1AA4C0();
        }
      }
    }
  }
  if ((char)v7 <= 91)
  {
    uint64_t result = a2;
    switch((char)v7)
    {
      case '$':
      case ')':
        return result;
      case '%':
      case '&':
      case '\'':
      case ',':
      case '-':
        goto LABEL_51;
      case '(':
        if (a2 + 1 == (unsigned __int8 *)a3) {
          goto LABEL_79;
        }
        if (a2 + 2 != (unsigned __int8 *)a3 && a2[1] == 63 && a2[2] == 58)
        {
          uint64_t v15 = a1 + 9;
          ++a1[9];
          uint64_t v16 = (char *)sub_18E1A9324(a1, a2 + 3, a3);
          if (v16 == a3) {
            goto LABEL_79;
          }
          long long v17 = v16;
          if (*v16 != 41) {
            goto LABEL_79;
          }
        }
        else
        {
          sub_18E1AC884((uint64_t)a1);
          uint64_t v15 = a1 + 9;
          ++a1[9];
          long long v23 = (char *)sub_18E1A9324(a1, a2 + 1, a3);
          if (v23 == a3 || (long long v17 = v23, *v23 != 41)) {
LABEL_79:
          }
            sub_18E1AA590();
          sub_18E1AC908((uint64_t)a1);
        }
        --*v15;
        uint64_t v19 = (unsigned __int8 *)(v17 + 1);
        goto LABEL_48;
      case '*':
      case '+':
        goto LABEL_56;
      case '.':
        operator new();
      default:
        if ((char)v7 == 91)
        {
          uint64_t v19 = sub_18E1ABBA8((uint64_t)a1, a2, a3);
          goto LABEL_48;
        }
        if ((char)v7 != 63) {
          goto LABEL_51;
        }
        goto LABEL_56;
    }
  }
  uint64_t v18 = ((char)v7 - 92);
  if (v18 > 0x21) {
LABEL_51:
  }
    sub_18E1ACF18((uint64_t)a1);
  if (((1 << (v7 - 92)) & 0x300000006) != 0) {
    return a2;
  }
  if ((char)v7 != 92)
  {
    if (v18 == 31) {
LABEL_56:
    }
      sub_18E1AC984();
    goto LABEL_51;
  }
  if (v7 != 92) {
    return a2;
  }
  long long v20 = a2 + 1;
  if (a2 + 1 == (unsigned __int8 *)a3) {
    sub_18E1ACAD4();
  }
  int v21 = *v20;
  unsigned int v22 = v21 - 48;
  if (v21 == 48) {
    sub_18E1ACF18((uint64_t)a1);
  }
  if ((v21 - 49) <= 8)
  {
    uint64_t v24 = (char *)(a2 + 2);
    if (a2 + 2 == (unsigned __int8 *)a3) {
      goto LABEL_63;
    }
    do
    {
      int v25 = *v24;
      if ((v25 - 48) > 9) {
        break;
      }
      if (v22 >= 0x19999999) {
        goto LABEL_80;
      }
      ++v24;
      unsigned int v22 = v25 + 10 * v22 - 48;
    }
    while (v24 != a3);
    if (v22)
    {
LABEL_63:
      if (v22 <= a1[7]) {
        sub_18E1AD15C((uint64_t)a1);
      }
    }
LABEL_80:
    sub_18E1AD104();
  }
  if ((char)v21 > 99)
  {
    if ((char)v21 == 119) {
      goto LABEL_74;
    }
    if ((char)v21 == 115) {
LABEL_78:
    }
      sub_18E1ADCE8();
    if ((char)v21 != 100) {
      goto LABEL_75;
    }
LABEL_73:
    sub_18E1ADCE8();
  }
  switch((char)v21)
  {
    case 'D':
      goto LABEL_73;
    case 'S':
      goto LABEL_78;
    case 'W':
LABEL_74:
      sub_18E1ADCE8();
  }
LABEL_75:
  long long v26 = sub_18E1ACB2C((uint64_t)a1, a2 + 1, (unsigned __int8 *)a3, 0);
  if (v26 == v20) {
    uint64_t v19 = a2;
  }
  else {
    uint64_t v19 = v26;
  }
LABEL_48:
  uint64_t result = a2;
  if (v19 != a2)
  {
    return sub_18E1AA028((uint64_t)a1, v19, (unsigned __int8 *)a3);
  }
  return result;
}

void sub_18E1A9FDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
}

unsigned __int8 *sub_18E1AA028(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3) {
    return a2;
  }
  int v4 = (char)*a2;
  if (v4 <= 62)
  {
    if (v4 == 42 || v4 == 43) {
LABEL_18:
    }
      sub_18E1B01D8();
    return a2;
  }
  if (v4 == 63) {
    goto LABEL_18;
  }
  if (v4 == 123)
  {
    uint64_t v5 = a2 + 1;
    int v6 = sub_18E1B0368(a2 + 1, a3, &v12);
    if (v6 == v5) {
      goto LABEL_23;
    }
    if (v6 != a3)
    {
      int v7 = (char)*v6;
      if (v7 != 44)
      {
        if (v7 == 125) {
          goto LABEL_18;
        }
LABEL_23:
        sub_18E1B0404();
      }
      size_t v8 = v6 + 1;
      if (v6 + 1 == a3) {
        goto LABEL_23;
      }
      if (*v8 == 125) {
        goto LABEL_18;
      }
      int v11 = -1;
      int v10 = sub_18E1B0368(v6 + 1, a3, &v11);
      if (v10 != v8 && v10 != a3 && *v10 == 125)
      {
        if (v11 >= v12) {
          goto LABEL_18;
        }
        goto LABEL_23;
      }
    }
    sub_18E1B045C();
  }
  return a2;
}

void sub_18E1AA324()
{
}

void sub_18E1AA3A8()
{
}

void sub_18E1AA42C()
{
}

void sub_18E1AA4C0()
{
}

void sub_18E1AA590()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x192FA5CA0](exception, 6);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_18E1AA5D4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_18E1AA5E8(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_18E1AA654(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1AA6E0(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 92))
  {
    if (*(void *)(a2 + 16) != *(void *)(a2 + 8) || (*(unsigned char *)(a2 + 88) & 1) != 0)
    {
LABEL_12:
      uint64_t v4 = 0;
      *(_DWORD *)a2 = -993;
      goto LABEL_13;
    }
  }
  else
  {
    if (!*(unsigned char *)(result + 16)) {
      goto LABEL_12;
    }
    int v2 = *(unsigned __int8 *)(*(void *)(a2 + 16) - 1);
    if (v2 != 13 && v2 != 10) {
      goto LABEL_12;
    }
  }
  *(_DWORD *)a2 = -994;
  uint64_t v4 = *(void *)(result + 8);
LABEL_13:
  *(void *)(a2 + 80) = v4;
  return result;
}

void *sub_18E1AA740(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_18E1AA7AC(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1AA838(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) && (*(unsigned char *)(a2 + 88) & 2) == 0
    || *(unsigned char *)(result + 16) && ((v3 = *v2, v3 != 13) ? (BOOL v4 = v3 == 10) : (BOOL v4 = 1), v4))
  {
    *(_DWORD *)a2 = -994;
    uint64_t v5 = *(void *)(result + 8);
  }
  else
  {
    uint64_t v5 = 0;
    *(_DWORD *)a2 = -993;
  }
  *(void *)(a2 + 80) = v5;
  return result;
}

std::locale *sub_18E1AA888(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E220;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E280;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void sub_18E1AA914(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E220;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E280;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1AA9C0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 8);
  int v3 = *(unsigned __int8 **)(a2 + 24);
  if (v2 == v3) {
    goto LABEL_17;
  }
  BOOL v4 = *(unsigned __int8 **)(a2 + 16);
  if (v4 == v3)
  {
    if ((*(unsigned char *)(a2 + 88) & 8) == 0)
    {
      uint64_t v6 = *(v3 - 1);
      goto LABEL_13;
    }
LABEL_17:
    int v10 = 0;
    goto LABEL_25;
  }
  if (v4 == v2)
  {
    int v5 = *(_DWORD *)(a2 + 88);
    if ((v5 & 0x80) == 0)
    {
      if ((v5 & 4) == 0)
      {
        uint64_t v6 = *v2;
LABEL_13:
        if (v6 == 95
          || (v6 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v6) & 0x500) != 0)
        {
          int v10 = 1;
          goto LABEL_25;
        }
        goto LABEL_17;
      }
      goto LABEL_17;
    }
  }
  uint64_t v7 = *(v4 - 1);
  uint64_t v8 = *v4;
  int v9 = v7 == 95 || (v7 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v7) & 0x500) != 0;
  int v11 = v8 == 95
     || (v8 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v8) & 0x500) != 0;
  int v10 = v9 != v11;
LABEL_25:
  if (*(unsigned __int8 *)(result + 40) == v10)
  {
    uint64_t v12 = 0;
    int v13 = -993;
  }
  else
  {
    uint64_t v12 = *(void *)(result + 8);
    int v13 = -994;
  }
  *(_DWORD *)a2 = v13;
  *(void *)(a2 + 80) = v12;
  return result;
}

std::locale *sub_18E1AAAD4(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E160;
  uint64_t v2 = a1 + 2;
  locale = (std::__shared_weak_count *)a1[8].__locale_;
  if (locale) {
    sub_18DEE4E18(locale);
  }
  std::locale::~locale(v2);
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E280;
  BOOL v4 = a1[1].__locale_;
  if (v4) {
    (*(void (**)(std::locale::__imp *))(*(void *)v4 + 8))(v4);
  }
  return a1;
}

void sub_18E1AAB74(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E160;
  uint64_t v2 = a1 + 2;
  locale = (std::__shared_weak_count *)a1[8].__locale_;
  if (locale) {
    sub_18DEE4E18(locale);
  }
  std::locale::~locale(v2);
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E280;
  BOOL v4 = a1[1].__locale_;
  if (v4) {
    (*(void (**)(std::locale::__imp *))(*(void *)v4 + 8))(v4);
  }

  JUMPOUT(0x192FA6240);
}

void sub_18E1AAC34(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  char v25 = 0;
  long long v26 = 0uLL;
  char v27 = 0;
  char v28 = 0;
  uint64_t v29 = 0;
  std::string __p = 0;
  uint64_t v19 = 0;
  unint64_t v4 = (*(_DWORD *)(a1 + 44) + 1);
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v20 = 0;
  *(void *)&long long v21 = v5;
  *((void *)&v21 + 1) = v5;
  char v22 = 0;
  sub_18E1AB224((char **)&__p, v4, &v21);
  uint64_t v23 = v6;
  uint64_t v24 = v6;
  char v25 = 0;
  long long v26 = v21;
  char v27 = v22;
  uint64_t v29 = v6;
  char v28 = 1;
  uint64_t v7 = *(void *)(a2 + 16);
  if (*(unsigned char *)(a2 + 92)) {
    BOOL v8 = v7 == *(void *)(a2 + 8);
  }
  else {
    BOOL v8 = 0;
  }
  char v9 = v8;
  if (*(unsigned __int8 *)(a1 + 84) == sub_18E1AADD8(a1 + 16, v7, *(void *)(a2 + 24), (uint64_t *)&__p, *(_DWORD *)(a2 + 88) & 0xFBF | 0x40u, v9))
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
    int v10 = (char *)__p;
    goto LABEL_13;
  }
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 80) = *(void *)(a1 + 8);
  int v10 = (char *)__p;
  unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((v19 - (uint64_t)__p) >> 3);
  if (v11 < 2)
  {
LABEL_13:
    if (!v10) {
      return;
    }
    goto LABEL_14;
  }
  int v12 = 0;
  int v13 = *(_DWORD *)(a1 + 80);
  uint64_t v14 = *(void *)(a2 + 32);
  unint64_t v15 = 1;
  do
  {
    uint64_t v16 = &v10[24 * v15];
    uint64_t v17 = v14 + 24 * (v13 + v12);
    *(_OWORD *)uint64_t v17 = *(_OWORD *)v16;
    *(unsigned char *)(v17 + 16) = v16[16];
    unint64_t v15 = (v12 + 2);
    ++v12;
  }
  while (v11 > v15);
LABEL_14:

  operator delete(v10);
}

void sub_18E1AADBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E1AADD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int a5, char a6)
{
  int64x2_t v45 = 0uLL;
  unint64_t v46 = 0;
  uint64_t v6 = *(void *)(a1 + 40);
  if (v6)
  {
    *(void *)&long long v43 = a3;
    *((void *)&v43 + 1) = a3;
    char v44 = 0;
    *(_DWORD *)long long v40 = 0;
    memset(&v40[8], 0, 48);
    *(_OWORD *)std::string __p = 0u;
    memset(v42, 0, 21);
    v45.i64[1] = (uint64_t)sub_18E1AB780(&v45, (uint64_t)v40);
    if (__p[0]) {
      operator delete(__p[0]);
    }
    if (*(void *)&v40[32]) {
      operator delete(*(void **)&v40[32]);
    }
    long long v38 = a4;
    uint64_t v13 = v45.i64[1];
    *(_DWORD *)(v45.i64[1] - 96) = 0;
    *(void *)(v13 - 88) = a2;
    *(void *)(v13 - 80) = a2;
    *(void *)(v13 - 72) = a3;
    sub_18E1AB42C((void **)(v13 - 64), *(unsigned int *)(a1 + 28), &v43);
    sub_18E1AB5B8((char **)(v45.i64[1] - 40), *(unsigned int *)(a1 + 32));
    uint64_t v14 = v45.i64[1];
    *(void *)(v45.i64[1] - 16) = v6;
    uint64_t v39 = a3;
    signed int v15 = a3 - a2;
    *(_DWORD *)(v14 - 8) = a5;
    *(unsigned char *)(v14 - 4) = a6;
    unsigned int v16 = 1;
    while (2)
    {
      if ((v16 & 0xFFF) != 0 || (int)(v16 >> 12) < v15)
      {
        uint64_t v18 = (void *)(v14 - 16);
        uint64_t v17 = *(void *)(v14 - 16);
        uint64_t v19 = (_OWORD *)(v14 - 96);
        if (v17) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 16))(v17, v14 - 96);
        }
        switch(*(_DWORD *)v19)
        {
          case 0xFFFFFC18:
            uint64_t v20 = *(void *)(v14 - 80);
            if ((a5 & 0x20) != 0 && v20 == a2 || (a5 & 0x1000) != 0 && v20 != v39) {
              goto LABEL_16;
            }
            uint64_t v29 = *v38;
            *(void *)uint64_t v29 = a2;
            *(void *)(v29 + 8) = v20;
            *(unsigned char *)(v29 + 16) = 1;
            uint64_t v30 = *(void *)(v14 - 64);
            uint64_t v31 = *(void *)(v14 - 56) - v30;
            if (v31)
            {
              unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * (v31 >> 3);
              unsigned int v33 = (unsigned char *)(v30 + 16);
              unsigned int v34 = 1;
              do
              {
                uint64_t v35 = v29 + 24 * v34;
                *(_OWORD *)uint64_t v35 = *((_OWORD *)v33 - 1);
                char v36 = *v33;
                v33 += 24;
                *(unsigned char *)(v35 + 16) = v36;
              }
              while (v32 > v34++);
            }
            uint64_t v27 = 1;
            goto LABEL_25;
          case 0xFFFFFC1D:
          case 0xFFFFFC1E:
          case 0xFFFFFC21:
            goto LABEL_23;
          case 0xFFFFFC1F:
LABEL_16:
            uint64_t v21 = v45.i64[1] - 96;
            sub_18E1AB948((void *)(v45.i64[1] - 96));
            v45.i64[1] = v21;
            goto LABEL_23;
          case 0xFFFFFC20:
            long long v22 = *(_OWORD *)(v14 - 80);
            *(_OWORD *)long long v40 = *v19;
            *(_OWORD *)&v40[16] = v22;
            memset(&v40[32], 0, 24);
            sub_18E1AB9F0(&v40[32], *(long long **)(v14 - 64), *(long long **)(v14 - 56), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v14 - 56) - *(void *)(v14 - 64)) >> 3));
            __p[0] = 0;
            __p[1] = 0;
            v42[0] = 0;
            sub_18E1ABA70((char *)__p, *(long long **)(v14 - 40), *(long long **)(v14 - 32), (uint64_t)(*(void *)(v14 - 32) - *(void *)(v14 - 40)) >> 4);
            uint64_t v23 = *v18;
            *(void *)((char *)&v42[1] + 5) = *(void *)(v14 - 11);
            v42[1] = v23;
            (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v18 + 24))(*v18, 1, v14 - 96);
            (*(void (**)(void, void, unsigned char *))(*(void *)v42[1] + 24))(v42[1], 0, v40);
            uint64_t v24 = v45.i64[1];
            if (v45.i64[1] >= v46)
            {
              v45.i64[1] = (uint64_t)sub_18E1AB780(&v45, (uint64_t)v40);
              if (__p[0])
              {
                __p[1] = __p[0];
                operator delete(__p[0]);
              }
            }
            else
            {
              long long v25 = *(_OWORD *)&v40[16];
              *(_OWORD *)v45.i64[1] = *(_OWORD *)v40;
              *(_OWORD *)(v24 + 16) = v25;
              *(void *)(v24 + 32) = 0;
              *(void *)(v24 + 40) = 0;
              *(void *)(v24 + 48) = 0;
              *(void *)(v24 + 56) = 0;
              *(_OWORD *)(v24 + 32) = *(_OWORD *)&v40[32];
              *(void *)(v24 + 48) = *(void *)&v40[48];
              memset(&v40[32], 0, 24);
              *(void *)(v24 + 64) = 0;
              *(void *)(v24 + 72) = 0;
              *(_OWORD *)(v24 + 56) = *(_OWORD *)__p;
              *(void *)(v24 + 72) = v42[0];
              __p[0] = 0;
              __p[1] = 0;
              v42[0] = 0;
              uint64_t v26 = v42[1];
              *(void *)(v24 + 85) = *(void *)((char *)&v42[1] + 5);
              *(void *)(v24 + 80) = v26;
              v45.i64[1] = v24 + 96;
            }
            if (*(void *)&v40[32])
            {
              *(void *)&v40[40] = *(void *)&v40[32];
              operator delete(*(void **)&v40[32]);
            }
LABEL_23:
            uint64_t v14 = v45.i64[1];
            ++v16;
            if (v45.i64[0] == v45.i64[1]) {
              goto LABEL_24;
            }
            continue;
          default:
            sub_18E1AB728();
        }
      }
      break;
    }
    sub_18E1AB6D0();
  }
LABEL_24:
  uint64_t v27 = 0;
LABEL_25:
  *(void *)long long v40 = &v45;
  sub_18E1ABB24((void ***)v40);
  return v27;
}

void sub_18E1AB1A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  sub_18E1AB3E8(&a11);
  a11 = v16 - 112;
  sub_18E1ABB24((void ***)&a11);
  _Unwind_Resume(a1);
}

char *sub_18E1AB224(char **a1, unint64_t a2, long long *a3)
{
  uint64_t v6 = (uint64_t)a1[2];
  uint64_t result = *a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)result) >> 3) >= a2)
  {
    signed int v15 = a1[1];
    unint64_t v16 = (v15 - result) / 24;
    if (v16 >= a2) {
      uint64_t v17 = a2;
    }
    else {
      uint64_t v17 = (v15 - result) / 24;
    }
    if (v17)
    {
      uint64_t v18 = result;
      do
      {
        *(_OWORD *)uint64_t v18 = *a3;
        v18[16] = *((unsigned char *)a3 + 16);
        v18 += 24;
        --v17;
      }
      while (v17);
    }
    if (a2 <= v16)
    {
      a1[1] = &result[24 * a2];
    }
    else
    {
      uint64_t v19 = &v15[24 * (a2 - v16)];
      uint64_t v20 = 24 * a2 - 24 * v16;
      do
      {
        long long v21 = *a3;
        *((void *)v15 + 2) = *((void *)a3 + 2);
        *(_OWORD *)signed int v15 = v21;
        v15 += 24;
        v20 -= 24;
      }
      while (v20);
      a1[1] = v19;
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_18DEE1FC8();
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 3);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= a2) {
      uint64_t v9 = a2;
    }
    if (v8 >= 0x555555555555555) {
      unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v9;
    }
    uint64_t result = sub_18E1AB398(a1, v10);
    unint64_t v11 = a1[1];
    int v12 = &v11[24 * a2];
    uint64_t v13 = 24 * a2;
    do
    {
      long long v14 = *a3;
      *((void *)v11 + 2) = *((void *)a3 + 2);
      *(_OWORD *)unint64_t v11 = v14;
      v11 += 24;
      v13 -= 24;
    }
    while (v13);
    a1[1] = v12;
  }
  return result;
}

char *sub_18E1AB398(void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_18DEE1FC8();
  }
  uint64_t result = (char *)sub_18E12E008(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *sub_18E1AB3E8(void *a1)
{
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  int v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_18E1AB42C(void **a1, unint64_t a2, long long *a3)
{
  uint64_t v6 = (char *)*a1;
  uint64_t v5 = (char *)a1[1];
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (unsigned char *)*a1) >> 3);
  unint64_t v8 = a2 - v7;
  if (a2 <= v7)
  {
    if (a2 < v7) {
      a1[1] = &v6[24 * a2];
    }
  }
  else
  {
    unint64_t v10 = a1[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v10 - v5) >> 3) >= v8)
    {
      long long v25 = &v5[24 * v8];
      uint64_t v26 = 24 * a2 - 8 * ((v5 - (unsigned char *)*a1) >> 3);
      do
      {
        long long v27 = *a3;
        *((void *)v5 + 2) = *((void *)a3 + 2);
        *(_OWORD *)uint64_t v5 = v27;
        v5 += 24;
        v26 -= 24;
      }
      while (v26);
      a1[1] = v25;
    }
    else
    {
      if (a2 > 0xAAAAAAAAAAAAAAALL) {
        sub_18DEE1FC8();
      }
      unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v6) >> 3);
      uint64_t v12 = 2 * v11;
      if (2 * v11 <= a2) {
        uint64_t v12 = a2;
      }
      if (v11 >= 0x555555555555555) {
        unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v13 = v12;
      }
      long long v14 = (char *)sub_18E12E008(v13);
      unint64_t v16 = &v14[24 * v7];
      uint64_t v17 = &v14[24 * a2];
      uint64_t v18 = v16;
      uint64_t v19 = 24 * a2 - 24 * v7;
      do
      {
        long long v20 = *a3;
        *((void *)v18 + 2) = *((void *)a3 + 2);
        *(_OWORD *)uint64_t v18 = v20;
        v18 += 24;
        v19 -= 24;
      }
      while (v19);
      long long v21 = &v14[24 * v15];
      uint64_t v23 = (char *)*a1;
      long long v22 = (char *)a1[1];
      if (v22 != *a1)
      {
        do
        {
          long long v24 = *(_OWORD *)(v22 - 24);
          *((void *)v16 - 1) = *((void *)v22 - 1);
          *(_OWORD *)(v16 - 24) = v24;
          v16 -= 24;
          v22 -= 24;
        }
        while (v22 != v23);
        long long v22 = (char *)*a1;
      }
      *a1 = v16;
      a1[1] = v17;
      a1[2] = v21;
      if (v22)
      {
        operator delete(v22);
      }
    }
  }
}

void sub_18E1AB5B8(char **a1, unint64_t a2)
{
  int v3 = *a1;
  uint64_t v4 = a1[1];
  unint64_t v5 = (v4 - *a1) >> 4;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    uint64_t v18 = &v3[16 * a2];
    goto LABEL_19;
  }
  unint64_t v6 = a2 - v5;
  unint64_t v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 4)
  {
    bzero(a1[1], 16 * v6);
    uint64_t v18 = &v4[16 * v6];
LABEL_19:
    a1[1] = v18;
    return;
  }
  if (a2 >> 60) {
    sub_18DEE1FC8();
  }
  uint64_t v8 = v7 - v3;
  uint64_t v9 = v8 >> 3;
  if (v8 >> 3 <= a2) {
    uint64_t v9 = a2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  unint64_t v11 = (char *)sub_18E12E050(v10);
  uint64_t v12 = &v11[16 * v5];
  long long v14 = &v11[16 * v13];
  bzero(v12, 16 * v6);
  uint64_t v15 = &v12[16 * v6];
  uint64_t v17 = *a1;
  unint64_t v16 = a1[1];
  if (v16 != *a1)
  {
    do
    {
      *((_OWORD *)v12 - 1) = *((_OWORD *)v16 - 1);
      v12 -= 16;
      v16 -= 16;
    }
    while (v16 != v17);
    unint64_t v16 = *a1;
  }
  *a1 = v12;
  a1[1] = v15;
  a1[2] = v14;
  if (v16)
  {
    operator delete(v16);
  }
}

void sub_18E1AB6D0()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x192FA5CA0](exception, 12);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_18E1AB714(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_18E1AB728()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x192FA5CA0](exception, 16);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_18E1AB76C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *sub_18E1AB780(int64x2_t *a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((a1->i64[1] - a1->i64[0]) >> 5);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x2AAAAAAAAAAAAAALL) {
    sub_18DEE1FC8();
  }
  if (0x5555555555555556 * ((a1[1].i64[0] - a1->i64[0]) >> 5) > v3) {
    unint64_t v3 = 0x5555555555555556 * ((a1[1].i64[0] - a1->i64[0]) >> 5);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[1].i64[0] - a1->i64[0]) >> 5) >= 0x155555555555555) {
    unint64_t v6 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  long long v27 = a1 + 1;
  if (v6)
  {
    if (v6 > 0x2AAAAAAAAAAAAAALL) {
      sub_18DEDF7D4();
    }
    unint64_t v7 = (char *)operator new(96 * v6);
  }
  else
  {
    unint64_t v7 = 0;
  }
  long long v8 = *(_OWORD *)(a2 + 16);
  uint64_t v9 = &v7[96 * v2];
  *(_OWORD *)uint64_t v9 = *(_OWORD *)a2;
  *((_OWORD *)v9 + 1) = v8;
  unint64_t v10 = &v7[96 * v6];
  *((_OWORD *)v9 + 2) = *(_OWORD *)(a2 + 32);
  *((void *)v9 + 6) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(v9 + 85) = *(void *)(a2 + 85);
  uint64_t v11 = *(void *)(a2 + 72);
  uint64_t v12 = *(void *)(a2 + 80);
  *((void *)v9 + 9) = 0;
  *((void *)v9 + 10) = v12;
  *(_OWORD *)(v9 + 56) = *(_OWORD *)(a2 + 56);
  *((void *)v9 + 9) = v11;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  uint64_t v13 = v9 + 96;
  v25.i64[1] = (uint64_t)(v9 + 96);
  uint64_t v26 = v10;
  uint64_t v15 = a1->i64[0];
  unint64_t v14 = a1->u64[1];
  if (v14 == a1->i64[0])
  {
    int64x2_t v21 = vdupq_n_s64(v14);
  }
  else
  {
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = &v9[v16];
      uint64_t v18 = v14 + v16;
      long long v19 = *(_OWORD *)(v14 + v16 - 80);
      *((_OWORD *)v17 - 6) = *(_OWORD *)(v14 + v16 - 96);
      *((_OWORD *)v17 - 5) = v19;
      *((void *)v17 - 7) = 0;
      *((void *)v17 - 6) = 0;
      *((void *)v17 - 8) = 0;
      *((_OWORD *)v17 - 4) = *(_OWORD *)(v14 + v16 - 64);
      *((void *)v17 - 6) = *(void *)(v14 + v16 - 48);
      *(void *)(v18 - 64) = 0;
      *(void *)(v18 - 56) = 0;
      *(void *)(v18 - 48) = 0;
      *((void *)v17 - 5) = 0;
      *((void *)v17 - 4) = 0;
      *((void *)v17 - 3) = 0;
      *(_OWORD *)(v17 - 40) = *(_OWORD *)(v14 + v16 - 40);
      *((void *)v17 - 3) = *(void *)(v14 + v16 - 24);
      *(void *)(v18 - 40) = 0;
      *(void *)(v18 - 32) = 0;
      *(void *)(v18 - 24) = 0;
      uint64_t v20 = *(void *)(v14 + v16 - 16);
      *(void *)(v17 - 11) = *(void *)(v14 + v16 - 11);
      *((void *)v17 - 2) = v20;
      v16 -= 96;
    }
    while (v14 + v16 != v15);
    int64x2_t v21 = *a1;
    v9 += v16;
    uint64_t v13 = (char *)v25.i64[1];
    unint64_t v10 = v26;
  }
  a1->i64[0] = (uint64_t)v9;
  a1->i64[1] = (uint64_t)v13;
  int64x2_t v25 = v21;
  long long v22 = (char *)a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)v10;
  uint64_t v26 = v22;
  uint64_t v24 = v21.i64[0];
  sub_18E1AB9A0((uint64_t)&v24);
  return v13;
}

void sub_18E1AB948(void *a1)
{
  unint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
}

uint64_t sub_18E1AB9A0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 96;
    sub_18E1AB948((void *)(i - 96));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *sub_18E1AB9F0(char *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = sub_18E1AB398(result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      long long v8 = *a2;
      *(void *)(v7 + 16) = *((void *)a2 + 2);
      *(_OWORD *)uint64_t v7 = v8;
      v7 += 24;
      a2 = (long long *)((char *)a2 + 24);
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_18E1ABA54(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_18E1ABA70(char *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = sub_18E1ABAE4(result, a4);
    uint64_t v7 = (_OWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      long long v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_18E1ABAC8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_18E1ABAE4(void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    sub_18DEE1FC8();
  }
  uint64_t result = (char *)sub_18E12E050(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void sub_18E1ABB24(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 12;
        sub_18E1AB948(v4);
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

unsigned char *sub_18E1ABBA8(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  if (a2 != a3 && *a2 == 91)
  {
    if (a2 + 1 != a3) {
      sub_18E1ADCE8();
    }
    sub_18E1AEF88();
  }
  return a2;
}

void sub_18E1AC754(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  *(void *)(v46 + 144) = v47;
  if (a46 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v48 - 145) < 0) {
    operator delete(*(void **)(v48 - 168));
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E1AC884(uint64_t result)
{
  if ((*(unsigned char *)(result + 24) & 2) == 0) {
    operator new();
  }
  return result;
}

uint64_t sub_18E1AC908(uint64_t result)
{
  if ((*(unsigned char *)(result + 24) & 2) == 0) {
    operator new();
  }
  return result;
}

void sub_18E1AC984()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x192FA5CA0](exception, 11);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_18E1AC9C8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_18E1AC9DC(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_18E1ACA48(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x192FA6240);
}

void sub_18E1ACAD4()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x192FA5CA0](exception, 3);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_18E1ACB18(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_18E1ACB2C(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t *a4)
{
  uint64_t v4 = a2;
  if (a2 == a3) {
    return v4;
  }
  uint64_t v5 = *a2;
  if ((char)v5 > 109)
  {
    switch((char)v5)
    {
      case 'n':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v14 = 10;
        goto LABEL_72;
      case 'r':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v14 = 13;
        goto LABEL_72;
      case 't':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v14 = 9;
        goto LABEL_72;
      case 'u':
        if (a2 + 1 != a3)
        {
          int v6 = a2[1];
          if ((v6 & 0xF8) == 0x30 || (v6 & 0xFE) == 0x38 || (v6 | 0x20u) - 97 < 6)
          {
            uint64_t v4 = a2 + 2;
            if (a2 + 2 != a3)
            {
              int v7 = *v4;
              if ((v7 & 0xF8) == 0x30 || (v7 & 0xFE) == 0x38 || (v7 | 0x20u) - 97 < 6) {
                goto LABEL_27;
              }
            }
          }
        }
        goto LABEL_81;
      case 'v':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v14 = 11;
        goto LABEL_72;
      case 'x':
LABEL_27:
        if (v4 + 1 == a3) {
          goto LABEL_81;
        }
        unsigned __int8 v8 = v4[1];
        char v9 = -48;
        if ((v8 & 0xF8) == 0x30 || (v8 & 0xFE) == 0x38) {
          goto LABEL_32;
        }
        v8 |= 0x20u;
        if ((v8 - 97) >= 6u) {
          goto LABEL_81;
        }
        char v9 = -87;
LABEL_32:
        if (v4 + 2 == a3) {
          goto LABEL_81;
        }
        unsigned __int8 v10 = v4[2];
        char v11 = -48;
        if ((v10 & 0xF8) == 0x30 || (v10 & 0xFE) == 0x38) {
          goto LABEL_37;
        }
        v10 |= 0x20u;
        if ((v10 - 97) >= 6u) {
          goto LABEL_81;
        }
        char v11 = -87;
LABEL_37:
        char v12 = v10 + 16 * (v8 + v9) + v11;
        if (!a4) {
          sub_18E1ACF18(a1);
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        *(unsigned char *)a4 = v12;
        *((unsigned char *)a4 + 1) = 0;
        v4 += 3;
        break;
      default:
        goto LABEL_51;
    }
    return v4;
  }
  if ((char)v5 == 48)
  {
    if (!a4) {
      goto LABEL_60;
    }
    if (*((char *)a4 + 23) < 0)
    {
      a4[1] = 1;
      a4 = (uint64_t *)*a4;
    }
    else
    {
      *((unsigned char *)a4 + 23) = 1;
    }
    *(_WORD *)a4 = 0;
    return a2 + 1;
  }
  if ((char)v5 != 99)
  {
    if ((char)v5 == 102)
    {
      if (a4)
      {
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v14 = 12;
LABEL_72:
        *(_WORD *)a4 = v14;
        return a2 + 1;
      }
LABEL_60:
      sub_18E1ACF18(a1);
    }
LABEL_51:
    if ((char)v5 != 95
      && ((char)v5 < 0 || (*(_DWORD *)(*(void *)(*(void *)(a1 + 8) + 16) + 4 * v5) & 0x500) == 0))
    {
      if (!a4) {
        goto LABEL_60;
      }
      if (*((char *)a4 + 23) < 0)
      {
        a4[1] = 1;
        a4 = (uint64_t *)*a4;
      }
      else
      {
        *((unsigned char *)a4 + 23) = 1;
      }
      *(unsigned char *)a4 = v5;
      *((unsigned char *)a4 + 1) = 0;
      return a2 + 1;
    }
LABEL_81:
    sub_18E1ACAD4();
  }
  if (a2 + 1 == a3) {
    goto LABEL_81;
  }
  unsigned __int8 v13 = a2[1];
  if (((v13 & 0xDF) - 65) > 0x19u) {
    goto LABEL_81;
  }
  if (!a4) {
    sub_18E1ACF18(a1);
  }
  if (*((char *)a4 + 23) < 0)
  {
    a4[1] = 1;
    a4 = (uint64_t *)*a4;
  }
  else
  {
    *((unsigned char *)a4 + 23) = 1;
  }
  *(unsigned char *)a4 = v13 & 0x1F;
  *((unsigned char *)a4 + 1) = 0;
  return a2 + 2;
}

void sub_18E1ACF18(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 24);
  if ((v1 & 1) == 0)
  {
    if ((v1 & 8) == 0) {
      operator new();
    }
    operator new();
  }
  operator new();
}

void sub_18E1AD08C(_Unwind_Exception *a1)
{
  std::locale::~locale(v2);
  *int v1 = &unk_1EDD1E280;
  uint64_t v4 = v1[1];
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  MEMORY[0x192FA6240](v1, 0x10E1C4010F5D982);
  _Unwind_Resume(a1);
}

void sub_18E1AD104()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x192FA5CA0](exception, 4);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_18E1AD148(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_18E1AD15C(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 24);
  if ((v1 & 1) == 0)
  {
    if ((v1 & 8) == 0) {
      operator new();
    }
    operator new();
  }
  operator new();
}

std::locale *sub_18E1AD28C(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E368;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E280;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void sub_18E1AD318(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E368;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E280;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1AD3C4(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(char **)(a2 + 16);
  if (v3 == *(char **)(a2 + 24)
    || (uint64_t v4 = result,
        uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(result + 24) + 40))(*(void *)(result + 24), *v3), *(unsigned __int8 *)(v4 + 40) != result))
  {
    uint64_t v5 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    ++*(void *)(a2 + 16);
    uint64_t v5 = *(void *)(v4 + 8);
  }
  *(void *)(a2 + 80) = v5;
  return result;
}

std::locale *sub_18E1AD458(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E3F8;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E280;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void sub_18E1AD4E4(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E3F8;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E280;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1AD590(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 40))
  {
    uint64_t v3 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }
  *(void *)(a2 + 80) = v3;
  return result;
}

void *sub_18E1AD5D8(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_18E1AD644(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1AD6D0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 16))
  {
    uint64_t v3 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }
  *(void *)(a2 + 80) = v3;
  return result;
}

std::locale *sub_18E1AD718(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E250;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E280;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void sub_18E1AD7A4(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E250;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E280;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1AD850(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 40) - 1);
  if (*(unsigned char *)(v3 + 16))
  {
    uint64_t v4 = *(void *)(v3 + 8) - *(void *)v3;
    uint64_t v5 = *(void *)(a2 + 16);
    if (*(void *)(a2 + 24) - v5 >= v4)
    {
      uint64_t v7 = result;
      if (v4 < 1)
      {
LABEL_9:
        *(_DWORD *)a2 = -994;
        *(void *)(a2 + 16) = v5 + v4;
        uint64_t v6 = *(void *)(v7 + 8);
        goto LABEL_10;
      }
      uint64_t v8 = 0;
      while (1)
      {
        int v9 = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40))(*(void *)(v7 + 24), *(char *)(*(void *)v3 + v8));
        uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40))(*(void *)(v7 + 24), *(char *)(*(void *)(a2 + 16) + v8));
        if (v9 != result) {
          break;
        }
        if (v4 == ++v8)
        {
          uint64_t v5 = *(void *)(a2 + 16);
          goto LABEL_9;
        }
      }
    }
  }
  uint64_t v6 = 0;
  *(_DWORD *)a2 = -993;
LABEL_10:
  *(void *)(a2 + 80) = v6;
  return result;
}

std::locale *sub_18E1AD968(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E338;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E280;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void sub_18E1AD9F4(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E338;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E280;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1ADAA0(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 40) - 1;
  uint64_t v3 = *(void *)(a2 + 32);
  if (*(unsigned char *)(v3 + 24 * v2 + 16))
  {
    uint64_t v4 = (unsigned __int8 **)(v3 + 24 * v2);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1] - *v4;
    uint64_t v7 = *(void *)(a2 + 16);
    if (*(void *)(a2 + 24) - v7 >= v6)
    {
      if (v6 < 1)
      {
LABEL_8:
        *(_DWORD *)a2 = -994;
        *(void *)(a2 + 16) = v7 + v6;
        uint64_t v8 = *(void *)(result + 8);
        goto LABEL_9;
      }
      uint64_t v9 = v6;
      unsigned __int8 v10 = *(unsigned __int8 **)(a2 + 16);
      while (1)
      {
        int v12 = *v5++;
        int v11 = v12;
        int v13 = *v10++;
        if (v11 != v13) {
          break;
        }
        if (!--v9) {
          goto LABEL_8;
        }
      }
    }
  }
  uint64_t v8 = 0;
  *(_DWORD *)a2 = -993;
LABEL_9:
  *(void *)(a2 + 80) = v8;
  return result;
}

void *sub_18E1ADB30(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_18E1ADB9C(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x192FA6240);
}

unsigned int *sub_18E1ADC28(unsigned int *result, uint64_t a2)
{
  unint64_t v2 = result[4];
  uint64_t v3 = *(void *)(a2 + 32);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a2 + 40) - v3) >> 3) < v2) {
    sub_18E1AD104();
  }
  unsigned int v5 = v2 - 1;
  if (*(unsigned char *)(v3 + 24 * v5 + 16)
    && (uint64_t v6 = result,
        uint64_t v7 = v3 + 24 * v5,
        uint64_t result = *(unsigned int **)v7,
        int64_t v8 = *(void *)(v7 + 8) - *(void *)v7,
        uint64_t v9 = *(void *)(a2 + 16),
        *(void *)(a2 + 24) - v9 >= v8)
    && (uint64_t result = (unsigned int *)memcmp(result, *(const void **)(a2 + 16), v8), !result))
  {
    *(_DWORD *)a2 = -994;
    *(void *)(a2 + 16) = v9 + v8;
    uint64_t v10 = *((void *)v6 + 1);
  }
  else
  {
    uint64_t v10 = 0;
    *(_DWORD *)a2 = -993;
  }
  *(void *)(a2 + 80) = v10;
  return result;
}

void sub_18E1ADCE8()
{
}

void sub_18E1ADE70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  std::locale::~locale((std::locale *)&a9);
  a10 = v10 + 17;
  sub_18E00C268((void ***)&a10);
  uint64_t v15 = (void *)v10[14];
  if (v15)
  {
    v10[15] = v15;
    operator delete(v15);
  }
  sub_18E1AEABC((void ***)&a10);
  uint64_t v16 = (void *)v10[8];
  if (v16)
  {
    v10[9] = v16;
    operator delete(v16);
  }
  uint64_t v17 = *v13;
  if (*v13)
  {
    v10[6] = v17;
    operator delete(v17);
  }
  std::locale::~locale(v12);
  void *v10 = v11;
  uint64_t v18 = v10[1];
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  MEMORY[0x192FA6240](v10, 0x10F1C4061CF1F02);
  _Unwind_Resume(a1);
}

void sub_18E1ADF20(uint64_t a1, uint64_t a2)
{
  char v2 = a2;
  if (*(unsigned char *)(a1 + 169))
  {
    char v2 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2);
    unsigned int v5 = *(unsigned char **)(a1 + 48);
    unint64_t v4 = *(void *)(a1 + 56);
    if ((unint64_t)v5 >= v4)
    {
      unint64_t v6 = *(void *)(a1 + 40);
      uint64_t v7 = &v5[-v6];
      uint64_t v8 = (uint64_t)&v5[-v6 + 1];
      if (v8 >= 0)
      {
        unint64_t v9 = v4 - v6;
        if (2 * v9 > v8) {
          uint64_t v8 = 2 * v9;
        }
        if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v10 = v8;
        }
        if (v10) {
          uint64_t v11 = operator new(v10);
        }
        else {
          uint64_t v11 = 0;
        }
        long long v19 = &v7[(void)v11];
        uint64_t v20 = (char *)v11 + v10;
        v7[(void)v11] = v2;
        uint64_t v18 = (uint64_t)&v7[(void)v11 + 1];
        if (v5 != (unsigned char *)v6)
        {
          int64x2_t v21 = &v5[~v6];
          do
          {
            char v22 = *--v5;
            (v21--)[(void)v11] = v22;
          }
          while (v5 != (unsigned char *)v6);
LABEL_45:
          unsigned int v5 = *(unsigned char **)(a1 + 40);
          goto LABEL_47;
        }
        goto LABEL_46;
      }
LABEL_50:
      sub_18DEE1FC8();
    }
    goto LABEL_22;
  }
  unsigned int v5 = *(unsigned char **)(a1 + 48);
  unint64_t v12 = *(void *)(a1 + 56);
  if (!*(unsigned char *)(a1 + 170))
  {
    if ((unint64_t)v5 >= v12)
    {
      unint64_t v23 = *(void *)(a1 + 40);
      uint64_t v24 = &v5[-v23];
      uint64_t v25 = (uint64_t)&v5[-v23 + 1];
      if (v25 >= 0)
      {
        unint64_t v26 = v12 - v23;
        if (2 * v26 > v25) {
          uint64_t v25 = 2 * v26;
        }
        if (v26 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v27 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v27 = v25;
        }
        if (v27) {
          uint64_t v11 = operator new(v27);
        }
        else {
          uint64_t v11 = 0;
        }
        long long v19 = &v24[(void)v11];
        uint64_t v20 = (char *)v11 + v27;
        v24[(void)v11] = v2;
        uint64_t v18 = (uint64_t)&v24[(void)v11 + 1];
        if (v5 != (unsigned char *)v23)
        {
          uint64_t v30 = &v5[~v23];
          do
          {
            char v31 = *--v5;
            (v30--)[(void)v11] = v31;
          }
          while (v5 != (unsigned char *)v23);
          goto LABEL_45;
        }
        goto LABEL_46;
      }
      goto LABEL_50;
    }
LABEL_22:
    *unsigned int v5 = v2;
    uint64_t v18 = (uint64_t)(v5 + 1);
    goto LABEL_49;
  }
  if ((unint64_t)v5 < v12) {
    goto LABEL_22;
  }
  unint64_t v13 = *(void *)(a1 + 40);
  __int16 v14 = &v5[-v13];
  uint64_t v15 = (uint64_t)&v5[-v13 + 1];
  if (v15 < 0) {
    goto LABEL_50;
  }
  unint64_t v16 = v12 - v13;
  if (2 * v16 > v15) {
    uint64_t v15 = 2 * v16;
  }
  if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v17 = v15;
  }
  if (v17) {
    uint64_t v11 = operator new(v17);
  }
  else {
    uint64_t v11 = 0;
  }
  long long v19 = &v14[(void)v11];
  uint64_t v20 = (char *)v11 + v17;
  v14[(void)v11] = v2;
  uint64_t v18 = (uint64_t)&v14[(void)v11 + 1];
  if (v5 != (unsigned char *)v13)
  {
    char v28 = &v5[~v13];
    do
    {
      char v29 = *--v5;
      (v28--)[(void)v11] = v29;
    }
    while (v5 != (unsigned char *)v13);
    goto LABEL_45;
  }
LABEL_46:
  uint64_t v11 = v19;
LABEL_47:
  *(void *)(a1 + 40) = v11;
  *(void *)(a1 + 48) = v18;
  *(void *)(a1 + 56) = v20;
  if (v5) {
    operator delete(v5);
  }
LABEL_49:
  *(void *)(a1 + 48) = v18;
}

void sub_18E1AE158(std::locale *a1)
{
  sub_18E1AEB98(a1);

  JUMPOUT(0x192FA6240);
}

void sub_18E1AE190(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(char **)(a2 + 16);
  unsigned int v5 = *(char **)(a2 + 24);
  if (v4 == v5)
  {
    uint64_t v10 = 0;
    LODWORD(v11) = *(unsigned __int8 *)(a1 + 168);
    goto LABEL_180;
  }
  if (!*(unsigned char *)(a1 + 171) || v4 + 1 == v5) {
    goto LABEL_36;
  }
  char v6 = *v4;
  LOBYTE(v92) = *v4;
  char v7 = v4[1];
  HIBYTE(v92) = v7;
  if (*(unsigned char *)(a1 + 169))
  {
    LOBYTE(v92) = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v6);
    HIBYTE(v92) = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v7);
  }
  *((unsigned char *)&__s.__r_.__value_.__s + 23) = 2;
  LOWORD(__s.__r_.__value_.__l.__data_) = v92;
  __s.__r_.__value_.__s.__data_[2] = 0;
  std::__get_collation_name(&v93, (const char *)&__s);
  std::string __p = v93;
  std::string::size_type size = HIBYTE(v93.__r_.__value_.__r.__words[2]);
  int v9 = SHIBYTE(v93.__r_.__value_.__r.__words[2]);
  if ((v93.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v93.__r_.__value_.__l.__size_;
  }
  if (size) {
    goto LABEL_9;
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__s.__r_.__value_.__l.__size_ >= 3) {
      goto LABEL_9;
    }
  }
  else if (HIBYTE(__s.__r_.__value_.__r.__words[2]) >= 3u)
  {
    goto LABEL_14;
  }
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 32) + 32))(&v93);
  if (v9 < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::string __p = v93;
  if ((SHIBYTE(v93.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (HIBYTE(v93.__r_.__value_.__r.__words[2]) != 12 && HIBYTE(v93.__r_.__value_.__r.__words[2]) != 1)
    {
      __p.__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
      goto LABEL_9;
    }
    goto LABEL_117;
  }
  if (__p.__r_.__value_.__l.__size_ == 1 || __p.__r_.__value_.__l.__size_ == 12)
  {
LABEL_117:
    std::string::operator=(&__p, &__s);
    goto LABEL_9;
  }
  *__p.__r_.__value_.__l.__data_ = 0;
  __p.__r_.__value_.__l.__size_ = 0;
LABEL_9:
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
LABEL_14:
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
      goto LABEL_16;
    }
LABEL_36:
    uint64_t v11 = 0;
    uint64_t v10 = 1;
    goto LABEL_37;
  }
  std::string::size_type v22 = __p.__r_.__value_.__l.__size_;
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!v22) {
    goto LABEL_36;
  }
LABEL_16:
  uint64_t v12 = *(void *)(a1 + 112);
  uint64_t v13 = *(void *)(a1 + 120) - v12;
  if (v13)
  {
    uint64_t v14 = v13 >> 1;
    if ((unint64_t)(v13 >> 1) <= 1) {
      uint64_t v14 = 1;
    }
    uint64_t v15 = (unsigned __int8 *)(v12 + 1);
    while (v92 != *(v15 - 1) || HIBYTE(v92) != *v15)
    {
      v15 += 2;
      if (!--v14) {
        goto LABEL_25;
      }
    }
    goto LABEL_177;
  }
LABEL_25:
  if (!*(unsigned char *)(a1 + 170) || *(void *)(a1 + 88) == *(void *)(a1 + 96))
  {
    LODWORD(v11) = 0;
    goto LABEL_124;
  }
  sub_18E1AEC80((uint64_t)&__s, a1 + 16, (char *)&v92, (char *)&v93);
  size_t v17 = *(void **)(a1 + 88);
  uint64_t v18 = *(void *)(a1 + 96) - (void)v17;
  if (v18)
  {
    unint64_t v19 = v18 / 48;
    if (v19 <= 1) {
      uint64_t v20 = 1;
    }
    else {
      uint64_t v20 = v19;
    }
    while ((int)(sub_18E1AED44(v17, &__s) << 24) > 0xFFFFFF
         || (int)(sub_18E1AED44(&__s, v17 + 3) << 24) >= 0x1000000)
    {
      v17 += 6;
      if (!--v20) {
        goto LABEL_34;
      }
    }
    char v21 = 0;
    uint64_t v11 = 1;
  }
  else
  {
LABEL_34:
    uint64_t v11 = 0;
    char v21 = 1;
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
  if ((v11 & 1) == 0)
  {
LABEL_124:
    if (*(void *)(a1 + 136) == *(void *)(a1 + 144)) {
      goto LABEL_159;
    }
    sub_18E1AEE6C((uint64_t)&__s, a1 + 16, (char *)&v92, (char *)&v93);
    uint64_t v60 = *(void *)(a1 + 136);
    uint64_t v61 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
    uint64_t v62 = *(void *)(a1 + 144) - v60;
    if (v62)
    {
      unint64_t v63 = 0;
      unint64_t v64 = v62 / 24;
      std::string::size_type v66 = __s.__r_.__value_.__l.__size_;
      uint64_t v65 = (const void *)__s.__r_.__value_.__r.__words[0];
      if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v67 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v67 = __s.__r_.__value_.__l.__size_;
      }
      if (v64 <= 1) {
        uint64_t v68 = 1;
      }
      else {
        uint64_t v68 = v62 / 24;
      }
      for (BOOL i = 1; ; BOOL i = v63 < v64)
      {
        uint64_t v70 = v60 + 24 * v63;
        uint64_t v71 = *(unsigned __int8 *)(v70 + 23);
        int v72 = (char)v71;
        if ((v71 & 0x80u) != 0) {
          uint64_t v71 = *(void *)(v70 + 8);
        }
        if (v67 != v71) {
          goto LABEL_145;
        }
        uint64_t v73 = v72 >= 0 ? (unsigned __int8 *)(v60 + 24 * v63) : *(unsigned __int8 **)v70;
        if ((v61 & 0x80) == 0) {
          break;
        }
        BOOL v88 = i;
        uint64_t v75 = v68;
        uint64_t v90 = v60;
        uint64_t v76 = v65;
        std::string::size_type v77 = v66;
        if (!memcmp(v65, v73, v66))
        {
          operator delete(__s.__r_.__value_.__l.__data_);
          if (!v88)
          {
LABEL_158:
            LODWORD(v11) = 1;
            goto LABEL_159;
          }
LABEL_151:
          LODWORD(v11) = 1;
LABEL_179:
          uint64_t v10 = 2;
          goto LABEL_180;
        }
        ++v63;
        uint64_t v68 = v75;
        std::string::size_type v66 = v77;
        uint64_t v65 = v76;
        uint64_t v60 = v90;
        if (v63 == v75) {
          goto LABEL_153;
        }
LABEL_149:
        ;
      }
      if (!v61)
      {
LABEL_150:
        if (!i) {
          goto LABEL_158;
        }
        goto LABEL_151;
      }
      uint64_t v74 = 0;
      while (__s.__r_.__value_.__s.__data_[v74] == v73[v74])
      {
        if (v61 == ++v74) {
          goto LABEL_150;
        }
      }
LABEL_145:
      if (++v63 == v68) {
        goto LABEL_152;
      }
      goto LABEL_149;
    }
LABEL_152:
    if ((v61 & 0x80) != 0) {
LABEL_153:
    }
      operator delete(__s.__r_.__value_.__l.__data_);
LABEL_159:
    if ((char)v92 < 0)
    {
      int v81 = *(_DWORD *)(a1 + 164);
    }
    else
    {
      int v78 = *(_DWORD *)(a1 + 160);
      uint64_t v79 = *(void *)(*(void *)(a1 + 24) + 16);
      int v80 = *(_DWORD *)(v79 + 4 * v92);
      if (((v80 & v78) != 0 || v92 == 95 && (v78 & 0x80) != 0)
        && (SHIBYTE(v92) & 0x80000000) == 0
        && ((*(_DWORD *)(v79 + 4 * HIBYTE(v92)) & v78) != 0 || (v78 & 0x80) != 0 && HIBYTE(v92) == 95))
      {
        goto LABEL_177;
      }
      int v81 = *(_DWORD *)(a1 + 164);
      if ((v81 & v80) != 0 || v92 == 95 && (v81 & 0x80) != 0)
      {
LABEL_176:
        int v82 = v11;
LABEL_178:
        LODWORD(v11) = v82;
        goto LABEL_179;
      }
    }
    if ((SHIBYTE(v92) & 0x80000000) == 0)
    {
      if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16) + 4 * HIBYTE(v92)) & v81) == 0)
      {
        int v82 = 1;
        if (HIBYTE(v92) != 95 || (v81 & 0x80) == 0) {
          goto LABEL_178;
        }
      }
      goto LABEL_176;
    }
LABEL_177:
    int v82 = 1;
    goto LABEL_178;
  }
  if ((v21 & 1) == 0) {
    goto LABEL_179;
  }
  uint64_t v10 = 2;
LABEL_37:
  unsigned __int8 v23 = **(unsigned char **)(a2 + 16);
  v93.__r_.__value_.__s.__data_[0] = v23;
  if (*(unsigned char *)(a1 + 169))
  {
    unsigned __int8 v23 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), (char)v23);
    v93.__r_.__value_.__s.__data_[0] = v23;
  }
  uint64_t v24 = *(unsigned __int8 **)(a1 + 40);
  unint64_t v25 = *(void *)(a1 + 48) - (void)v24;
  if (v25)
  {
    if (v25 <= 1) {
      unint64_t v25 = 1;
    }
    while (1)
    {
      int v26 = *v24++;
      if (v26 == v23) {
        break;
      }
      if (!--v25) {
        goto LABEL_44;
      }
    }
LABEL_114:
    LODWORD(v11) = 1;
    goto LABEL_180;
  }
LABEL_44:
  unsigned int v27 = *(_DWORD *)(a1 + 164);
  if (v27 || *(void *)(a1 + 64) != *(void *)(a1 + 72))
  {
    if ((v23 & 0x80) != 0 || (*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16) + 4 * v23) & v27) == 0)
    {
      int v29 = (v27 >> 7) & 1;
      char v28 = v23 == 95 ? v29 : 0;
    }
    else
    {
      char v28 = 1;
    }
    uint64_t v30 = *(void **)(a1 + 72);
    char v31 = memchr(*(void **)(a1 + 64), (char)v23, (size_t)v30 - *(void *)(a1 + 64));
    unint64_t v32 = v31 ? v31 : v30;
    if ((v28 & 1) == 0 && v32 == v30) {
      goto LABEL_114;
    }
  }
  unsigned int v34 = *(char **)(a1 + 88);
  unsigned int v33 = *(char **)(a1 + 96);
  if (v34 != v33)
  {
    if (*(unsigned char *)(a1 + 170))
    {
      sub_18E1AEC80((uint64_t)&__s, a1 + 16, (char *)&v93, &v93.__r_.__value_.__s.__data_[1]);
      unsigned int v34 = *(char **)(a1 + 88);
      unsigned int v33 = *(char **)(a1 + 96);
    }
    else
    {
      *((unsigned char *)&__s.__r_.__value_.__s + 23) = 1;
      LOWORD(__s.__r_.__value_.__l.__data_) = v23;
    }
    uint64_t v35 = v33 - v34;
    if (v35)
    {
      unint64_t v36 = 0;
      unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * (v35 >> 4);
      while ((int)(sub_18E1AED44(v34, &__s) << 24) > 0xFFFFFF
           || (int)(sub_18E1AED44(&__s, (void *)v34 + 3) << 24) >= 0x1000000)
      {
        ++v36;
        v34 += 48;
        if (v36 >= v37) {
          goto LABEL_67;
        }
      }
      char v38 = 1;
      uint64_t v11 = 1;
    }
    else
    {
LABEL_67:
      char v38 = 0;
    }
    if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__s.__r_.__value_.__l.__data_);
    }
    if (v38) {
      goto LABEL_180;
    }
  }
  if (*(void *)(a1 + 136) == *(void *)(a1 + 144))
  {
LABEL_109:
    if (v93.__r_.__value_.__s.__data_[0] < 0) {
      goto LABEL_180;
    }
    unsigned int v58 = *(_DWORD *)(a1 + 160);
    if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16) + 4 * v93.__r_.__value_.__s.__data_[0]) & v58) == 0)
    {
      int v59 = (v58 >> 7) & 1;
      if (v93.__r_.__value_.__s.__data_[0] != 95) {
        int v59 = 0;
      }
      if (v59 != 1) {
        goto LABEL_180;
      }
    }
    goto LABEL_114;
  }
  sub_18E1AEE6C((uint64_t)&__s, a1 + 16, (char *)&v93, &v93.__r_.__value_.__s.__data_[1]);
  uint64_t v39 = *(void *)(a1 + 136);
  uint64_t v40 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
  uint64_t v41 = *(void *)(a1 + 144) - v39;
  if (!v41)
  {
LABEL_107:
    if ((v40 & 0x80) != 0) {
LABEL_108:
    }
      operator delete(__s.__r_.__value_.__l.__data_);
    goto LABEL_109;
  }
  unint64_t v42 = 0;
  unint64_t v43 = v41 / 24;
  std::string::size_type v45 = __s.__r_.__value_.__l.__size_;
  char v44 = (const void *)__s.__r_.__value_.__r.__words[0];
  if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v46 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v46 = __s.__r_.__value_.__l.__size_;
  }
  if (v43 <= 1) {
    uint64_t v47 = 1;
  }
  else {
    uint64_t v47 = v41 / 24;
  }
  for (BOOL j = 1; ; BOOL j = v42 < v43)
  {
    uint64_t v49 = (unsigned __int8 **)(v39 + 24 * v42);
    unint64_t v50 = (unsigned __int8 *)*((unsigned __int8 *)v49 + 23);
    int v51 = (char)v50;
    if ((char)v50 < 0) {
      unint64_t v50 = v49[1];
    }
    if ((unsigned __int8 *)v46 != v50) {
      goto LABEL_100;
    }
    if (v51 >= 0) {
      uint64_t v52 = (unsigned __int8 *)(v39 + 24 * v42);
    }
    else {
      uint64_t v52 = *v49;
    }
    if ((v40 & 0x80) == 0)
    {
      if (!v40)
      {
LABEL_105:
        LODWORD(v11) = 1;
        if (!j) {
          goto LABEL_109;
        }
        goto LABEL_180;
      }
      uint64_t v53 = 0;
      while (__s.__r_.__value_.__s.__data_[v53] == v52[v53])
      {
        if (v40 == ++v53) {
          goto LABEL_105;
        }
      }
LABEL_100:
      if (++v42 == v47) {
        goto LABEL_107;
      }
      continue;
    }
    BOOL v85 = j;
    uint64_t v86 = v39;
    std::string::size_type v87 = v46;
    uint64_t v54 = v11;
    unint64_t v55 = v43;
    uint64_t v89 = v10;
    uint64_t v56 = v44;
    std::string::size_type v57 = v45;
    if (!memcmp(v44, v52, v45)) {
      break;
    }
    ++v42;
    std::string::size_type v45 = v57;
    char v44 = v56;
    std::string::size_type v46 = v87;
    uint64_t v10 = v89;
    unint64_t v43 = v55;
    uint64_t v11 = v54;
    uint64_t v39 = v86;
    if (v42 == v47) {
      goto LABEL_108;
    }
  }
  operator delete(__s.__r_.__value_.__l.__data_);
  LODWORD(v11) = 1;
  uint64_t v10 = v89;
  if (!v85) {
    goto LABEL_109;
  }
LABEL_180:
  if (v11 == *(unsigned __int8 *)(a1 + 168))
  {
    uint64_t v83 = 0;
    int v84 = -993;
  }
  else
  {
    *(void *)(a2 + 16) += v10;
    uint64_t v83 = *(void *)(a1 + 8);
    int v84 = -995;
  }
  *(_DWORD *)a2 = v84;
  *(void *)(a2 + 80) = v83;
}

void sub_18E1AEA80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(exception_object);
}

void sub_18E1AEABC(void ***a1)
{
  uint64_t v1 = *a1;
  char v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unsigned int v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        sub_18E1AEB40(v4);
      }
      while ((void *)v4 != v2);
      unsigned int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_18E1AEB40(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    char v2 = *(void **)a1;
    operator delete(v2);
  }
}

std::locale *sub_18E1AEB98(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E398;
  char v7 = a1 + 17;
  sub_18E00C268((void ***)&v7);
  locale = a1[14].__locale_;
  if (locale)
  {
    a1[15].__locale_ = locale;
    operator delete(locale);
  }
  char v7 = a1 + 11;
  sub_18E1AEABC((void ***)&v7);
  uint64_t v3 = a1[8].__locale_;
  if (v3)
  {
    a1[9].__locale_ = v3;
    operator delete(v3);
  }
  uint64_t v4 = a1[5].__locale_;
  if (v4)
  {
    a1[6].__locale_ = v4;
    operator delete(v4);
  }
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_1EDD1E280;
  unsigned int v5 = a1[1].__locale_;
  if (v5) {
    (*(void (**)(std::locale::__imp *))(*(void *)v5 + 8))(v5);
  }
  return a1;
}

void sub_18E1AEC80(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  sub_18E1AEDC4(__p, a3, a4, a4 - a3);
  unint64_t v5 = v8;
  if ((v8 & 0x80u) == 0) {
    char v6 = __p;
  }
  else {
    char v6 = (void **)__p[0];
  }
  if ((v8 & 0x80u) != 0) {
    unint64_t v5 = (unint64_t)__p[1];
  }
  (*(void (**)(void, void **, char *))(**(void **)(a2 + 16) + 32))(*(void *)(a2 + 16), v6, (char *)v6 + v5);
  if ((char)v8 < 0) {
    operator delete(__p[0]);
  }
}

void sub_18E1AED28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E1AED44(void *a1, void *a2)
{
  size_t v2 = a1[1];
  if (*((char *)a1 + 23) >= 0)
  {
    size_t v3 = *((unsigned __int8 *)a1 + 23);
  }
  else
  {
    a1 = (void *)*a1;
    size_t v3 = v2;
  }
  size_t v4 = a2[1];
  if (*((char *)a2 + 23) >= 0)
  {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = (void *)*a2;
    size_t v5 = v4;
  }
  if (v5 >= v3) {
    size_t v6 = v3;
  }
  else {
    size_t v6 = v5;
  }
  int v7 = memcmp(a1, a2, v6);
  if (v7)
  {
    if ((v7 & 0x80000000) == 0) {
      return 1;
    }
  }
  else
  {
    if (v3 == v5) {
      return 0;
    }
    if (v3 >= v5) {
      return 1;
    }
  }
  return 255;
}

void *sub_18E1AEDC4(void *result, char *a2, char *a3, unint64_t a4)
{
  size_t v4 = result;
  if (a4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_18DEDD910();
  }
  if (a4 > 0x16)
  {
    uint64_t v8 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17) {
      uint64_t v8 = a4 | 7;
    }
    uint64_t v9 = v8 + 1;
    uint64_t result = operator new(v8 + 1);
    v4[1] = a4;
    void v4[2] = v9 | 0x8000000000000000;
    *size_t v4 = result;
    size_t v4 = result;
  }
  else
  {
    *((unsigned char *)result + 23) = a4;
  }
  while (a2 != a3)
  {
    char v10 = *a2++;
    *(unsigned char *)size_t v4 = v10;
    size_t v4 = (void *)((char *)v4 + 1);
  }
  *(unsigned char *)size_t v4 = 0;
  return result;
}

void sub_18E1AEE6C(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  sub_18E1AEDC4(__p, a3, a4, a4 - a3);
  unint64_t v6 = v12;
  if ((v12 & 0x80u) == 0) {
    int v7 = __p;
  }
  else {
    int v7 = (void **)__p[0];
  }
  if ((v12 & 0x80u) != 0) {
    unint64_t v6 = (unint64_t)__p[1];
  }
  (*(void (**)(void, void **, char *))(**(void **)(a2 + 16) + 32))(*(void *)(a2 + 16), v7, (char *)v7 + v6);
  uint64_t v8 = *(unsigned __int8 *)(a1 + 23);
  int v9 = (char)v8;
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(a1 + 8);
  }
  if (v8 != 1)
  {
    if (v8 == 12)
    {
      if (v9 >= 0) {
        char v10 = (unsigned char *)a1;
      }
      else {
        char v10 = *(unsigned char **)a1;
      }
      v10[11] = v10[3];
    }
    else if (v9 < 0)
    {
      **(unsigned char **)a1 = 0;
      *(void *)(a1 + 8) = 0;
    }
    else
    {
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 23) = 0;
    }
  }
  if ((char)v12 < 0) {
    operator delete(__p[0]);
  }
}

void sub_18E1AEF6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_18E1AEF88()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x192FA5CA0](exception, 5);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_18E1AEFCC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_18E1AEFE0(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_15;
  }
  for (uint64_t i = 0; a2[i] != 46 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i) {
      goto LABEL_15;
    }
  }
  if (&a2[i] == a3) {
LABEL_15:
  }
    sub_18E1AEF88();
  sub_18E1AFA4C((uint64_t)&v10, a1, a2, &a2[i]);
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  *(_OWORD *)a4 = v10;
  unint64_t v7 = v11;
  *(void *)(a4 + 16) = v11;
  unint64_t v8 = HIBYTE(v7);
  if ((v8 & 0x80u) != 0) {
    unint64_t v8 = *(void *)(a4 + 8);
  }
  if (v8 - 1 >= 2) {
    sub_18E1AF9F4();
  }
  return (uint64_t)&a2[i + 2];
}

unsigned __int8 *sub_18E1AF0CC(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5)
{
  if (a2 == a3) {
    sub_18E1ACAD4();
  }
  int v7 = (char)*a2;
  if (v7 > 97)
  {
    if (v7 > 114)
    {
      if (v7 != 115)
      {
        if (v7 == 119)
        {
          *(_DWORD *)(a5 + 160) |= 0x500u;
          sub_18E1ADF20(a5, 95);
          return a2 + 1;
        }
        goto LABEL_27;
      }
      int v9 = *(_DWORD *)(a5 + 160) | 0x4000;
    }
    else
    {
      if (v7 == 98)
      {
        if (*(char *)(a4 + 23) < 0)
        {
          *(void *)(a4 + 8) = 1;
          a4 = *(void *)a4;
        }
        else
        {
          *(unsigned char *)(a4 + 23) = 1;
        }
        *(_WORD *)a4 = 8;
        return a2 + 1;
      }
      if (v7 != 100) {
        goto LABEL_27;
      }
      int v9 = *(_DWORD *)(a5 + 160) | 0x400;
    }
    *(_DWORD *)(a5 + 160) = v9;
    return a2 + 1;
  }
  if (v7 <= 82)
  {
    if (!*a2)
    {
      if (*(char *)(a4 + 23) < 0)
      {
        *(void *)(a4 + 8) = 1;
        a4 = *(void *)a4;
      }
      else
      {
        *(unsigned char *)(a4 + 23) = 1;
      }
      *(unsigned char *)a4 = 0;
      *(unsigned char *)(a4 + 1) = 0;
      return a2 + 1;
    }
    if (v7 == 68)
    {
      int v8 = *(_DWORD *)(a5 + 164) | 0x400;
LABEL_24:
      *(_DWORD *)(a5 + 164) = v8;
      return a2 + 1;
    }
    goto LABEL_27;
  }
  if (v7 == 83)
  {
    int v8 = *(_DWORD *)(a5 + 164) | 0x4000;
    goto LABEL_24;
  }
  if (v7 == 87)
  {
    *(_DWORD *)(a5 + 164) |= 0x500u;
    if (*(unsigned char *)(a5 + 169))
    {
      char v10 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a5 + 24) + 40))(*(void *)(a5 + 24), 95);
      char v11 = v10;
      uint64_t v13 = *(unsigned char **)(a5 + 72);
      unint64_t v12 = *(void *)(a5 + 80);
      if ((unint64_t)v13 < v12)
      {
        *uint64_t v13 = v10;
        uint64_t v14 = (uint64_t)(v13 + 1);
LABEL_62:
        *(void *)(a5 + 72) = v14;
        return a2 + 1;
      }
      unint64_t v24 = *(void *)(a5 + 64);
      unint64_t v25 = &v13[-v24];
      uint64_t v26 = (uint64_t)&v13[-v24 + 1];
      if (v26 >= 0)
      {
        unint64_t v27 = v12 - v24;
        if (2 * v27 > v26) {
          uint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v28 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v28 = v26;
        }
        if (v28) {
          int v29 = operator new(v28);
        }
        else {
          int v29 = 0;
        }
        char v31 = &v29[v28];
        v25[(void)v29] = v11;
        uint64_t v14 = (uint64_t)&v25[(void)v29 + 1];
        if (v13 == (unsigned char *)v24)
        {
          int v29 = &v25[(void)v29];
        }
        else
        {
          unint64_t v32 = &v13[~v24];
          do
          {
            char v33 = *--v13;
            (v32--)[(void)v29] = v33;
          }
          while (v13 != (unsigned char *)v24);
          uint64_t v13 = *(unsigned char **)(a5 + 64);
        }
        *(void *)(a5 + 64) = v29;
        *(void *)(a5 + 72) = v14;
        *(void *)(a5 + 80) = v31;
        if (v13) {
          operator delete(v13);
        }
        goto LABEL_62;
      }
LABEL_87:
      sub_18DEE1FC8();
    }
    size_t v17 = *(unsigned char **)(a5 + 72);
    unint64_t v16 = *(void *)(a5 + 80);
    if (*(unsigned char *)(a5 + 170))
    {
      if ((unint64_t)v17 >= v16)
      {
        unint64_t v18 = *(void *)(a5 + 64);
        unint64_t v19 = &v17[-v18];
        uint64_t v20 = (uint64_t)&v17[-v18 + 1];
        if (v20 < 0) {
          goto LABEL_87;
        }
        unint64_t v21 = v16 - v18;
        if (2 * v21 > v20) {
          uint64_t v20 = 2 * v21;
        }
        if (v21 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v22 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v22 = v20;
        }
        if (v22) {
          unsigned __int8 v23 = operator new(v22);
        }
        else {
          unsigned __int8 v23 = 0;
        }
        uint64_t v39 = &v19[(void)v23];
        uint64_t v40 = (char *)v23 + v22;
        v19[(void)v23] = 95;
        uint64_t v30 = (uint64_t)&v19[(void)v23 + 1];
        if (v17 != (unsigned char *)v18)
        {
          uint64_t v41 = &v17[~v18];
          do
          {
            char v42 = *--v17;
            (v41--)[(void)v23] = v42;
          }
          while (v17 != (unsigned char *)v18);
LABEL_80:
          size_t v17 = *(unsigned char **)(a5 + 64);
          goto LABEL_82;
        }
        goto LABEL_81;
      }
    }
    else if ((unint64_t)v17 >= v16)
    {
      unint64_t v34 = *(void *)(a5 + 64);
      uint64_t v35 = &v17[-v34];
      uint64_t v36 = (uint64_t)&v17[-v34 + 1];
      if (v36 < 0) {
        goto LABEL_87;
      }
      unint64_t v37 = v16 - v34;
      if (2 * v37 > v36) {
        uint64_t v36 = 2 * v37;
      }
      if (v37 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v38 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v38 = v36;
      }
      if (v38) {
        unsigned __int8 v23 = operator new(v38);
      }
      else {
        unsigned __int8 v23 = 0;
      }
      uint64_t v39 = &v35[(void)v23];
      uint64_t v40 = (char *)v23 + v38;
      v35[(void)v23] = 95;
      uint64_t v30 = (uint64_t)&v35[(void)v23 + 1];
      if (v17 != (unsigned char *)v34)
      {
        unint64_t v43 = &v17[~v34];
        do
        {
          char v44 = *--v17;
          (v43--)[(void)v23] = v44;
        }
        while (v17 != (unsigned char *)v34);
        goto LABEL_80;
      }
LABEL_81:
      unsigned __int8 v23 = v39;
LABEL_82:
      *(void *)(a5 + 64) = v23;
      *(void *)(a5 + 72) = v30;
      *(void *)(a5 + 80) = v40;
      if (v17) {
        operator delete(v17);
      }
      goto LABEL_84;
    }
    *size_t v17 = 95;
    uint64_t v30 = (uint64_t)(v17 + 1);
LABEL_84:
    *(void *)(a5 + 72) = v30;
    return a2 + 1;
  }
LABEL_27:

  return sub_18E1ACB2C(a1, a2, a3, (uint64_t *)a4);
}

char *sub_18E1AF49C(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  if (a2 == a3) {
LABEL_78:
  }
    sub_18E1ACAD4();
  int v4 = *a2;
  char v5 = *a2;
  if (v4 > 97)
  {
    switch(*a2)
    {
      case 'n':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v11 = 10;
        goto LABEL_75;
      case 'o':
      case 'p':
      case 'q':
      case 's':
      case 'u':
        goto LABEL_25;
      case 'r':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v11 = 13;
        goto LABEL_75;
      case 't':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v11 = 9;
        goto LABEL_75;
      case 'v':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v11 = 11;
        goto LABEL_75;
      default:
        if (v4 == 98)
        {
          if (!a4) {
            goto LABEL_60;
          }
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((unsigned char *)a4 + 23) = 1;
          }
          __int16 v11 = 8;
        }
        else
        {
          if (v4 != 102) {
            goto LABEL_25;
          }
          if (!a4) {
            goto LABEL_60;
          }
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((unsigned char *)a4 + 23) = 1;
          }
          __int16 v11 = 12;
        }
        break;
    }
    goto LABEL_75;
  }
  if (v4 > 91)
  {
    if (v4 == 92) {
      goto LABEL_16;
    }
    if (v4 != 97) {
      goto LABEL_25;
    }
    if (!a4) {
      goto LABEL_60;
    }
    if (*((char *)a4 + 23) < 0)
    {
      a4[1] = 1;
      a4 = (uint64_t *)*a4;
    }
    else
    {
      *((unsigned char *)a4 + 23) = 1;
    }
    __int16 v11 = 7;
LABEL_75:
    *(_WORD *)a4 = v11;
    return a2 + 1;
  }
  if (v4 == 34 || v4 == 47)
  {
LABEL_16:
    if (a4)
    {
      if (*((char *)a4 + 23) < 0)
      {
        a4[1] = 1;
        a4 = (uint64_t *)*a4;
      }
      else
      {
        *((unsigned char *)a4 + 23) = 1;
      }
      *(unsigned char *)a4 = v5;
      *((unsigned char *)a4 + 1) = 0;
      return a2 + 1;
    }
LABEL_60:
    sub_18E1ACF18(a1);
  }
LABEL_25:
  if ((v5 & 0xF8) != 0x30) {
    goto LABEL_78;
  }
  char v6 = v4 - 48;
  int v7 = a2 + 1;
  if (a2 + 1 == a3)
  {
LABEL_48:
    int v7 = a3;
    goto LABEL_49;
  }
  if ((*v7 & 0xF8) == 0x30)
  {
    char v6 = *v7 + 8 * v6 - 48;
    if (a2 + 2 != a3)
    {
      char v8 = a2[2];
      int v9 = v8 & 0xF8;
      char v10 = v8 + 8 * v6 - 48;
      if (v9 == 48) {
        int v7 = a2 + 3;
      }
      else {
        int v7 = a2 + 2;
      }
      if (v9 == 48) {
        char v6 = v10;
      }
      goto LABEL_49;
    }
    goto LABEL_48;
  }
LABEL_49:
  if (!a4) {
    sub_18E1ACF18(a1);
  }
  if (*((char *)a4 + 23) < 0)
  {
    a4[1] = 1;
    a4 = (uint64_t *)*a4;
  }
  else
  {
    *((unsigned char *)a4 + 23) = 1;
  }
  *(unsigned char *)a4 = v6;
  *((unsigned char *)a4 + 1) = 0;
  return v7;
}

void sub_18E1AF7B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a1 + 169))
  {
    __int16 v6 = a2 | (unsigned __int16)((_WORD)a3 << 8);
    char v8 = *(_WORD **)(a1 + 120);
    unint64_t v16 = *(void *)(a1 + 128);
    if (*(unsigned char *)(a1 + 170))
    {
      if ((unint64_t)v8 < v16) {
        goto LABEL_24;
      }
      uint64_t v17 = *(void *)(a1 + 112);
      uint64_t v18 = (uint64_t)v8 - v17;
      if ((uint64_t)v8 - v17 > -3)
      {
        uint64_t v19 = v18 >> 1;
        unint64_t v20 = v16 - v17;
        if (v20 <= (v18 >> 1) + 1) {
          unint64_t v21 = v19 + 1;
        }
        else {
          unint64_t v21 = v20;
        }
        if (v20 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v22 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v22 = v21;
        }
        if (v22) {
          uint64_t v22 = (uint64_t)sub_18E1AFF4C(v22);
        }
        else {
          uint64_t v23 = 0;
        }
        unint64_t v25 = (_WORD *)(v22 + 2 * v19);
        uint64_t v26 = v22 + 2 * v23;
        *unint64_t v25 = v6;
        unint64_t v24 = v25 + 1;
        unint64_t v37 = *(char **)(a1 + 112);
        unint64_t v27 = *(char **)(a1 + 120);
        if (v27 == v37) {
          goto LABEL_46;
        }
        do
        {
          __int16 v38 = *((_WORD *)v27 - 1);
          v27 -= 2;
          *--unint64_t v25 = v38;
        }
        while (v27 != v37);
        goto LABEL_45;
      }
    }
    else
    {
      if ((unint64_t)v8 < v16) {
        goto LABEL_24;
      }
      uint64_t v30 = *(void *)(a1 + 112);
      uint64_t v31 = (uint64_t)v8 - v30;
      if ((uint64_t)v8 - v30 > -3)
      {
        uint64_t v32 = v31 >> 1;
        unint64_t v33 = v16 - v30;
        if (v33 <= (v31 >> 1) + 1) {
          unint64_t v34 = v32 + 1;
        }
        else {
          unint64_t v34 = v33;
        }
        if (v33 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v35 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v35 = v34;
        }
        if (v35) {
          uint64_t v35 = (uint64_t)sub_18E1AFF4C(v35);
        }
        else {
          uint64_t v36 = 0;
        }
        unint64_t v25 = (_WORD *)(v35 + 2 * v32);
        uint64_t v26 = v35 + 2 * v36;
        *unint64_t v25 = v6;
        unint64_t v24 = v25 + 1;
        uint64_t v39 = *(char **)(a1 + 112);
        unint64_t v27 = *(char **)(a1 + 120);
        if (v27 == v39) {
          goto LABEL_46;
        }
        do
        {
          __int16 v40 = *((_WORD *)v27 - 1);
          v27 -= 2;
          *--unint64_t v25 = v40;
        }
        while (v27 != v39);
        goto LABEL_45;
      }
    }
LABEL_49:
    sub_18DEE1FC8();
  }
  unsigned __int8 v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2);
  __int16 v6 = v5 | (unsigned __int16)((*(unsigned __int16 (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a3) << 8);
  char v8 = *(_WORD **)(a1 + 120);
  unint64_t v7 = *(void *)(a1 + 128);
  if ((unint64_t)v8 < v7)
  {
LABEL_24:
    *char v8 = v6;
    unint64_t v24 = v8 + 1;
    goto LABEL_48;
  }
  uint64_t v9 = *(void *)(a1 + 112);
  uint64_t v10 = (uint64_t)v8 - v9;
  if ((uint64_t)v8 - v9 <= -3) {
    goto LABEL_49;
  }
  uint64_t v11 = v10 >> 1;
  unint64_t v12 = v7 - v9;
  if (v12 <= (v10 >> 1) + 1) {
    unint64_t v13 = v11 + 1;
  }
  else {
    unint64_t v13 = v12;
  }
  if (v12 >= 0x7FFFFFFFFFFFFFFELL) {
    uint64_t v14 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v14 = v13;
  }
  if (v14) {
    uint64_t v14 = (uint64_t)sub_18E1AFF4C(v14);
  }
  else {
    uint64_t v15 = 0;
  }
  unint64_t v25 = (_WORD *)(v14 + 2 * v11);
  uint64_t v26 = v14 + 2 * v15;
  *unint64_t v25 = v6;
  unint64_t v24 = v25 + 1;
  size_t v28 = *(char **)(a1 + 112);
  unint64_t v27 = *(char **)(a1 + 120);
  if (v27 == v28) {
    goto LABEL_46;
  }
  do
  {
    __int16 v29 = *((_WORD *)v27 - 1);
    v27 -= 2;
    *--unint64_t v25 = v29;
  }
  while (v27 != v28);
LABEL_45:
  unint64_t v27 = *(char **)(a1 + 112);
LABEL_46:
  *(void *)(a1 + 112) = v25;
  *(void *)(a1 + 120) = v24;
  *(void *)(a1 + 128) = v26;
  if (v27) {
    operator delete(v27);
  }
LABEL_48:
  *(void *)(a1 + 120) = v24;
}

void sub_18E1AF9F4()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x192FA5CA0](exception, 1);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_18E1AFA38(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_18E1AFA4C(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  sub_18E1AEDC4(&__s, a3, a4, a4 - a3);
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!__s.__r_.__value_.__l.__size_) {
      goto LABEL_9;
    }
    p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&__s.__r_.__value_.__s + 23)) {
      return;
    }
    p_s = &__s;
  }
  std::__get_collation_name(&v11, (const char *)p_s);
  *(_OWORD *)a1 = *(_OWORD *)&v11.__r_.__value_.__l.__data_;
  unint64_t v7 = v11.__r_.__value_.__r.__words[2];
  *(void *)(a1 + 16) = *((void *)&v11.__r_.__value_.__l + 2);
  unint64_t v8 = HIBYTE(v7);
  if ((v8 & 0x80u) != 0) {
    unint64_t v8 = *(void *)(a1 + 8);
  }
  if (v8) {
    goto LABEL_9;
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__s.__r_.__value_.__l.__size_ >= 3) {
      goto LABEL_9;
    }
  }
  else if (HIBYTE(__s.__r_.__value_.__r.__words[2]) >= 3u)
  {
    return;
  }
  (*(void (**)(std::string *__return_ptr))(**(void **)(a2 + 16) + 32))(&v11);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(std::string *)a1 = v11;
  if ((*(char *)(a1 + 23) & 0x80000000) == 0)
  {
    int v9 = *(unsigned __int8 *)(a1 + 23);
    if (v9 != 12 && v9 != 1)
    {
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 23) = 0;
      goto LABEL_9;
    }
    goto LABEL_23;
  }
  uint64_t v10 = *(void *)(a1 + 8);
  if (v10 == 1 || v10 == 12)
  {
LABEL_23:
    std::string::operator=((std::string *)a1, &__s);
    goto LABEL_9;
  }
  **(unsigned char **)a1 = 0;
  *(void *)(a1 + 8) = 0;
LABEL_9:
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
}

void sub_18E1AFBD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (*(char *)(v17 + 23) < 0) {
    operator delete(*(void **)v17);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_18E1AFC08()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x192FA5CA0](exception, 2);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_18E1AFC4C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_18E1AFC60(void **a1, long long *a2)
{
  int v4 = (char *)a1[1];
  unsigned __int8 v5 = (char *)a1[2];
  if (v4 >= v5)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v4 - (unsigned char *)*a1) >> 4);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0x555555555555555) {
      sub_18DEE1FC8();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (unsigned char *)*a1) >> 4);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x555555555555555;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 > 0x555555555555555) {
        sub_18DEDF7D4();
      }
      unint64_t v13 = (char *)operator new(48 * v12);
    }
    else
    {
      unint64_t v13 = 0;
    }
    uint64_t v14 = &v13[48 * v9];
    *(_OWORD *)uint64_t v14 = *a2;
    *((void *)v14 + 2) = *((void *)a2 + 2);
    long long v15 = *(long long *)((char *)a2 + 24);
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    *(void *)a2 = 0;
    *((void *)a2 + 1) = 0;
    *(_OWORD *)(v14 + 24) = v15;
    *((void *)v14 + 5) = *((void *)a2 + 5);
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    unint64_t v16 = (char *)*a1;
    uint64_t v17 = (char *)a1[1];
    if (v17 == *a1)
    {
      unint64_t v8 = v14 + 48;
      *a1 = v14;
      a1[1] = v14 + 48;
      a1[2] = &v13[48 * v12];
    }
    else
    {
      uint64_t v18 = &v13[48 * v9];
      do
      {
        long long v19 = *((_OWORD *)v17 - 3);
        *((void *)v18 - 4) = *((void *)v17 - 4);
        *((_OWORD *)v18 - 3) = v19;
        *((void *)v17 - 5) = 0;
        *((void *)v17 - 4) = 0;
        *((void *)v17 - 6) = 0;
        long long v20 = *(_OWORD *)(v17 - 24);
        *((void *)v18 - 1) = *((void *)v17 - 1);
        *(_OWORD *)(v18 - 24) = v20;
        v18 -= 48;
        *((void *)v17 - 2) = 0;
        *((void *)v17 - 1) = 0;
        *((void *)v17 - 3) = 0;
        v17 -= 48;
      }
      while (v17 != v16);
      uint64_t v17 = (char *)*a1;
      uint64_t v21 = (uint64_t)a1[1];
      unint64_t v8 = v14 + 48;
      *a1 = v18;
      a1[1] = v14 + 48;
      a1[2] = &v13[48 * v12];
      while ((char *)v21 != v17)
      {
        v21 -= 48;
        sub_18E1AEB40(v21);
      }
    }
    if (v17) {
      operator delete(v17);
    }
  }
  else
  {
    long long v6 = *a2;
    *((void *)v4 + 2) = *((void *)a2 + 2);
    *(_OWORD *)int v4 = v6;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v7 = *(long long *)((char *)a2 + 24);
    *((void *)v4 + 5) = *((void *)a2 + 5);
    *(_OWORD *)(v4 + 24) = v7;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    unint64_t v8 = v4 + 48;
  }
  a1[1] = v8;
}

void sub_18E1AFE30(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  sub_18E1AEDC4(__p, a3, a4, a4 - a3);
  unint64_t v5 = v8;
  if ((v8 & 0x80u) == 0) {
    long long v6 = __p;
  }
  else {
    long long v6 = (void **)__p[0];
  }
  if ((v8 & 0x80u) != 0) {
    unint64_t v5 = (unint64_t)__p[1];
  }
  (*(void (**)(void, void **, char *))(**(void **)(a2 + 16) + 32))(*(void *)(a2 + 16), v6, (char *)v6 + v5);
  if ((char)v8 < 0) {
    operator delete(__p[0]);
  }
}

void sub_18E1AFED8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_18E1AFEF4()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x192FA5CA0](exception, 9);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_18E1AFF38(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_18E1AFF4C(uint64_t a1)
{
  if (a1 < 0) {
    sub_18DEDF7D4();
  }
  return operator new(2 * a1);
}

void *sub_18E1AFF80(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_18E1AFFEC(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1B0078(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(*(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 16) - 1)) = *(void *)(a2 + 16);
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void *sub_18E1B00A8(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_18E1B0114(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1B01A0(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  uint64_t v2 = *(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 16) - 1);
  *(void *)(v2 + 8) = *(void *)(a2 + 16);
  *(unsigned char *)(v2 + 16) = 1;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_18E1B01D8()
{
}

void sub_18E1B0330(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_18E1B0368(unsigned __int8 *result, unsigned __int8 *a2, int *a3)
{
  if (result != a2)
  {
    int v3 = *result;
    if ((v3 & 0xF8) == 0x30 || (v3 & 0xFE) == 0x38)
    {
      int v4 = v3 - 48;
      *a3 = v4;
      if (++result == a2)
      {
        return a2;
      }
      else
      {
        while (1)
        {
          int v5 = *result;
          if ((v5 & 0xF8) != 0x30 && (v5 & 0xFE) != 0x38) {
            break;
          }
          if (v4 >= 214748364) {
            sub_18E1B0404();
          }
          int v4 = v5 + 10 * v4 - 48;
          *a3 = v4;
          if (++result == a2) {
            return a2;
          }
        }
      }
    }
  }
  return result;
}

void sub_18E1B0404()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x192FA5CA0](exception, 8);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_18E1B0448(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_18E1B045C()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x192FA5CA0](exception, 7);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_18E1B04A0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_18E1B04B8(void *a1)
{
  sub_18E1B0610(a1);

  JUMPOUT(0x192FA6240);
}

unsigned int *sub_18E1B04F0(unsigned int *result, void *a2)
{
  uint64_t v2 = result[10];
  uint64_t v3 = a2[7];
  int v4 = (unint64_t *)(v3 + 16 * v2);
  if (*(_DWORD *)a2 == -991)
  {
    unint64_t v5 = *v4 + 1;
    *int v4 = v5;
    unint64_t v6 = *((void *)result + 3);
    unint64_t v7 = *((void *)result + 4);
    BOOL v8 = v5 < v7;
    if (v5 < v7 && v5 >= v6)
    {
      uint64_t v10 = *(void *)(v3 + 16 * v2 + 8);
      BOOL v8 = v5 < v7 && v10 != a2[2];
    }
    if (!v8 || v5 < v6)
    {
      *(_DWORD *)a2 = -994;
      if (!v8) {
        goto LABEL_25;
      }
LABEL_22:
      a2[10] = *((void *)result + 1);
      return sub_18E1B06C4(result, a2);
    }
    goto LABEL_23;
  }
  *int v4 = 0;
  if (*((void *)result + 4))
  {
    if (*((void *)result + 3))
    {
      *(_DWORD *)a2 = -994;
      goto LABEL_22;
    }
LABEL_23:
    *(_DWORD *)a2 = -992;
    return result;
  }
  *(_DWORD *)a2 = -994;
LABEL_25:
  a2[10] = *((void *)result + 2);
  return result;
}

unsigned int *sub_18E1B05A4(unsigned int *result, int a2, void *a3)
{
  *(_DWORD *)a3 = -994;
  if (*((unsigned __int8 *)result + 52) == a2)
  {
    a3[10] = *((void *)result + 2);
  }
  else
  {
    a3[10] = *((void *)result + 1);
    return sub_18E1B06C4(result, a3);
  }
  return result;
}

void sub_18E1B05D8(void *a1)
{
  sub_18E1B0610(a1);

  JUMPOUT(0x192FA6240);
}

void *sub_18E1B0610(void *a1)
{
  *a1 = &unk_1EDD1E2B0;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_1EDD1E280;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

unsigned int *sub_18E1B06C4(unsigned int *result, void *a2)
{
  unsigned int v2 = result[11];
  *(void *)(a2[7] + 16 * result[10] + 8) = a2[2];
  unsigned int v3 = result[12];
  if (v2 != v3)
  {
    uint64_t v4 = v2 - 1;
    uint64_t v5 = a2[3];
    uint64_t v6 = v3 - 1 - v4;
    unint64_t v7 = (unsigned char *)(a2[4] + 24 * v4 + 16);
    do
    {
      *((void *)v7 - 2) = v5;
      *((void *)v7 - 1) = v5;
      unsigned char *v7 = 0;
      v7 += 24;
      --v6;
    }
    while (v6);
  }
  return result;
}

void sub_18E1B0718()
{
}

uint64_t sub_18E1B072C(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -991;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_18E1B0744(void *a1)
{
  sub_18E1B0610(a1);

  JUMPOUT(0x192FA6240);
}

void sub_18E1B077C(uint64_t a1, _DWORD *a2)
{
  *a2 = -992;
}

uint64_t sub_18E1B0788(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)a3 = -994;
  uint64_t v3 = 8;
  if (a2) {
    uint64_t v3 = 16;
  }
  *(void *)(a3 + 80) = *(void *)(result + v3);
  return result;
}

void sub_18E1B07B0()
{
}

uint64_t sub_18E1B07C4(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_18E1B07D8()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x192FA5CA0](exception, 15);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_18E1B081C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_18E1B0830(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3 = a2;
  if (a2 != a3)
  {
    unint64_t v7 = a2 + 1;
    int v6 = *a2;
    if (a2 + 1 != a3 || v6 != 36)
    {
      if ((v6 - 46) > 0x2E || ((1 << (v6 - 46)) & 0x600000000001) == 0) {
        sub_18E1ACF18(a1);
      }
      if (v7 == a3 || v6 != 92)
      {
        if (v6 == 46) {
          operator new();
        }
      }
      else
      {
        unsigned int v14 = (char)*v7 - 36;
        if (v14 <= 0x3A && ((1 << v14) & 0x580000000000441) != 0) {
          sub_18E1ACF18(a1);
        }
      }
    }
    BOOL v8 = sub_18E1ABBA8(a1, a2, a3);
    unint64_t v9 = v8;
    if (v8 == v3 && v8 != a3)
    {
      if (v7 == a3 || *v3 != 92) {
        return v3;
      }
      int v10 = *v7;
      if (v10 == 40)
      {
        uint64_t v11 = (uint64_t)(v3 + 2);
        sub_18E1AC884(a1);
        do
        {
          unint64_t v12 = (unsigned __int8 *)v11;
          uint64_t v11 = sub_18E1B0830(a1, v11, a3);
        }
        while ((unsigned __int8 *)v11 != v12);
        if (v12 == a3 || v12 + 1 == a3 || *v12 != 92 || v12[1] != 41) {
          sub_18E1AA590();
        }
        unint64_t v9 = v12 + 2;
        sub_18E1AC908(a1);
      }
      else
      {
        int v15 = sub_18E1B0CF8(a1, v10);
        uint64_t v16 = 2;
        if (!v15) {
          uint64_t v16 = 0;
        }
        unint64_t v9 = &v3[v16];
      }
    }
    if (v9 != v3)
    {
      if (v9 == a3)
      {
        return a3;
      }
      else
      {
        int v17 = *v9;
        if (v17 == 42) {
          sub_18E1B01D8();
        }
        if (v9 + 1 != a3 && v17 == 92 && v9[1] == 123)
        {
          int v24 = 0;
          uint64_t v18 = sub_18E1B0368(v9 + 2, a3, &v24);
          if (v18 == v9 + 2) {
            goto LABEL_48;
          }
          if (v18 != a3)
          {
            long long v19 = v18 + 1;
            int v20 = *v18;
            if (v20 == 44)
            {
              int v23 = -1;
              uint64_t v21 = sub_18E1B0368(v18 + 1, a3, &v23);
              if (v21 != a3 && v21 + 1 != a3 && *v21 == 92 && v21[1] == 125)
              {
                if (v23 != -1 && v23 < v24) {
LABEL_48:
                }
                  sub_18E1B0404();
LABEL_53:
                sub_18E1B01D8();
              }
            }
            else if (v19 != a3 && v20 == 92 && *v19 == 125)
            {
              goto LABEL_53;
            }
          }
          sub_18E1B045C();
        }
        return v9;
      }
    }
  }
  return v3;
}

void *sub_18E1B0BC0(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_18E1B0C2C(void *a1)
{
  *a1 = &unk_1EDD1E280;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1B0CB8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned char **)(a2 + 16);
  if (v2 == *(unsigned char **)(a2 + 24) || !*v2)
  {
    uint64_t v3 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }
  *(void *)(a2 + 80) = v3;
  return result;
}

uint64_t sub_18E1B0CF8(uint64_t a1, unsigned __int8 a2)
{
  if (((a2 & 0xF8) == 0x30 || (a2 & 0xFE) == 0x38) && a2 - 49 <= 8)
  {
    if (a2 - 48 <= *(_DWORD *)(a1 + 28)) {
      sub_18E1AD15C(a1);
    }
    sub_18E1AD104();
  }
  return 0;
}

unsigned __int8 *sub_18E1B0D58(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  int v6 = sub_18E1B0DB8(a1, a2, a3);
  if (v6 == a2) {
    sub_18E1B07D8();
  }
  do
  {
    unint64_t v7 = v6;
    int v6 = sub_18E1B0DB8(a1, v6, a3);
  }
  while (v6 != v7);
  return v7;
}

unsigned __int8 *sub_18E1B0DB8(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  if (a2 == (unsigned __int8 *)a3)
  {
LABEL_24:
    uint64_t v11 = sub_18E1ABBA8(a1, a2, a3);
    goto LABEL_25;
  }
  int v6 = (char)*a2;
  int v7 = *a2;
  uint64_t v8 = (v6 - 36);
  if (v8 > 0x3A) {
    goto LABEL_13;
  }
  if (((1 << (v6 - 36)) & 0x5800000080004D1) == 0)
  {
    if (v8 == 5)
    {
      if (*(_DWORD *)(a1 + 36)) {
        goto LABEL_4;
      }
LABEL_14:
      sub_18E1ACF18(a1);
    }
LABEL_13:
    if ((v6 - 123) < 2) {
      goto LABEL_4;
    }
    goto LABEL_14;
  }
LABEL_4:
  unint64_t v9 = a2 + 1;
  if (a2 + 1 == (unsigned __int8 *)a3 || v7 != 92)
  {
LABEL_22:
    if (v7 == 46) {
      operator new();
    }
    goto LABEL_24;
  }
  int v10 = (char)*v9;
  if ((v10 - 36) <= 0x3A && ((1 << (v10 - 36)) & 0x5800000080004F1) != 0
    || (v10 - 123) < 3)
  {
    sub_18E1ACF18(a1);
  }
  if ((*(_DWORD *)(a1 + 24) & 0x1F0) == 0x40)
  {
    uint64_t v11 = (unsigned __int8 *)sub_18E1AF49C(a1, (char *)a2 + 1, a3, 0);
  }
  else
  {
    int v12 = sub_18E1B0CF8(a1, *v9);
    uint64_t v13 = 2;
    if (!v12) {
      uint64_t v13 = 0;
    }
    uint64_t v11 = &a2[v13];
  }
  if (v11 == a2)
  {
    int v7 = *a2;
    goto LABEL_22;
  }
LABEL_25:
  if (v11 == a2 && v11 != (unsigned __int8 *)a3)
  {
    int v14 = (char)*a2;
    if (v14 == 36) {
      sub_18E1AA3A8();
    }
    if (v14 != 40)
    {
      if (v14 == 94) {
        sub_18E1AA324();
      }
      return a2;
    }
    sub_18E1AC884(a1);
    ++*(_DWORD *)(a1 + 36);
    int v15 = (char *)sub_18E1A9534(a1, a2 + 1, a3);
    if (v15 == a3 || (uint64_t v16 = v15, *v15 != 41)) {
      sub_18E1AA590();
    }
    sub_18E1AC908(a1);
    --*(_DWORD *)(a1 + 36);
    uint64_t v11 = (unsigned __int8 *)(v16 + 1);
  }
  if (v11 == a2) {
    return a2;
  }

  return sub_18E1AA028(a1, v11, (unsigned __int8 *)a3);
}

BOOL sub_18E1B1080(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a1 + 32;
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(v6 + 8);
  uint64_t v9 = a2 + 32;
  uint64_t v7 = *(void *)(a2 + 32);
  uint64_t v8 = *(void *)(v9 + 8);
  BOOL v10 = v8 == v7 && v5 == v4;
  if (v5 != v4 && v8 != v7) {
    return *(void *)a1 == *(void *)a2
  }
        && *(void *)(a1 + 8) == *(void *)(a2 + 8)
        && *(void *)(a1 + 16) == *(void *)(a2 + 16)
        && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24)
        && sub_18E1B2EC8(v4, v7) == 0;
  return v10;
}

uint64_t sub_18E1B1118(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if ((a5 & 0x80) != 0) {
    int v9 = a5 & 0xFFA;
  }
  else {
    int v9 = a5;
  }
  int v10 = *(_DWORD *)(a1 + 28);
  *(void *)(a4 + 24) = a3;
  uint64_t v11 = (long long *)(a4 + 24);
  *(void *)(a4 + 32) = a3;
  *(unsigned char *)(a4 + 40) = 0;
  sub_18E1AB224((char **)a4, (v10 + 1), (long long *)(a4 + 24));
  *(void *)(a4 + 48) = a2;
  *(void *)(a4 + 56) = a2;
  *(unsigned char *)(a4 + 64) = 0;
  *(_OWORD *)(a4 + 72) = *v11;
  *(unsigned char *)(a4 + 88) = *(unsigned char *)(a4 + 40);
  if ((v9 & 0x800) == 0) {
    *(void *)(a4 + 104) = a2;
  }
  *(unsigned char *)(a4 + 96) = 1;
  if (!sub_18E1B15F8(a1, a2, a3, (uint64_t *)a4, v9, (v9 & 0x800) == 0))
  {
    if (a2 == a3 || (v9 & 0x40) != 0) {
      goto LABEL_18;
    }
    int v18 = v9 | 0x80;
    uint64_t v19 = a2 + 1;
    if (v19 != a3)
    {
      do
      {
        sub_18E1AB224((char **)a4, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3), v11);
        int v20 = sub_18E1B15F8(a1, v19, a3, (uint64_t *)a4, v18, 0);
        uint64_t v13 = *(char **)a4;
        int v12 = *(char **)(a4 + 8);
        if (v20) {
          goto LABEL_8;
        }
        sub_18E1AB224((char **)a4, 0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 3), v11);
      }
      while (++v19 != a3);
    }
    sub_18E1AB224((char **)a4, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3), v11);
    if (!sub_18E1B15F8(a1, a3, a3, (uint64_t *)a4, v18, 0))
    {
LABEL_18:
      uint64_t result = 0;
      *(void *)(a4 + 8) = *(void *)a4;
      return result;
    }
  }
  uint64_t v13 = *(char **)a4;
  int v12 = *(char **)(a4 + 8);
LABEL_8:
  if (v12 == v13) {
    int v14 = (uint64_t *)v11;
  }
  else {
    int v14 = (uint64_t *)v13;
  }
  uint64_t v15 = *v14;
  *(void *)(a4 + 56) = *v14;
  *(unsigned char *)(a4 + 64) = *(void *)(a4 + 48) != v15;
  uint64_t v16 = v14[1];
  *(void *)(a4 + 72) = v16;
  *(unsigned char *)(a4 + 88) = v16 != *(void *)(a4 + 80);
  return 1;
}

void sub_18E1B12F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, char a5)
{
  char v5 = a5;
  uint64_t v10 = a4[6];
  unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3);
  uint64_t v13 = *(char **)a1;
  int v12 = *(char **)(a1 + 8);
  unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v12[-*(void *)a1] >> 3);
  unint64_t v15 = v11 - v14;
  if (v11 <= v14)
  {
    uint64_t v22 = *(char **)(a1 + 8);
    if (v11 >= v14) {
      goto LABEL_24;
    }
    uint64_t v22 = &v13[8 * ((a4[1] - *a4) >> 3)];
    goto LABEL_20;
  }
  uint64_t v16 = *(void *)(a1 + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((v16 - (uint64_t)v12) >> 3) >= v15)
  {
    uint64_t v22 = &v12[24 * v15];
    uint64_t v27 = 8 * ((a4[1] - *a4) >> 3) - 8 * ((uint64_t)&v12[-*(void *)a1] >> 3);
    do
    {
      *(void *)int v12 = 0;
      *((void *)v12 + 1) = 0;
      v12[16] = 0;
      v12 += 24;
      v27 -= 24;
    }
    while (v27);
LABEL_20:
    *(void *)(a1 + 8) = v22;
    goto LABEL_24;
  }
  if (v11 > 0xAAAAAAAAAAAAAAALL) {
    sub_18DEE1FC8();
  }
  unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((v16 - (uint64_t)v13) >> 3);
  unint64_t v18 = 0x5555555555555556 * ((v16 - (uint64_t)v13) >> 3);
  if (v18 <= v11) {
    unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3);
  }
  if (v17 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v18;
  }
  if (v19 > 0xAAAAAAAAAAAAAAALL) {
    sub_18DEDF7D4();
  }
  int v20 = (char *)operator new(24 * v19);
  uint64_t v21 = &v20[24 * v14];
  uint64_t v22 = &v20[24 * v11];
  int v23 = v21;
  uint64_t v24 = 24 * v11 - 24 * v14;
  do
  {
    *(void *)int v23 = 0;
    *((void *)v23 + 1) = 0;
    v23[16] = 0;
    v23 += 24;
    v24 -= 24;
  }
  while (v24);
  unint64_t v25 = &v20[24 * v19];
  if (v12 == v13)
  {
    char v5 = a5;
  }
  else
  {
    char v5 = a5;
    do
    {
      long long v26 = *(_OWORD *)(v12 - 24);
      *((void *)v21 - 1) = *((void *)v12 - 1);
      *(_OWORD *)(v21 - 24) = v26;
      v21 -= 24;
      v12 -= 24;
    }
    while (v12 != v13);
    int v12 = v13;
  }
  *(void *)a1 = v21;
  *(void *)(a1 + 8) = v22;
  *(void *)(a1 + 16) = v25;
  if (v12)
  {
    operator delete(v12);
    uint64_t v22 = *(char **)(a1 + 8);
  }
LABEL_24:
  size_t v28 = *(char **)a1;
  if (v22 != *(char **)a1)
  {
    uint64_t v29 = 0;
    unint64_t v30 = 0;
    uint64_t v32 = *a4;
    uint64_t v31 = a4[1];
    do
    {
      unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * ((v31 - v32) >> 3);
      unint64_t v34 = (void *)(v32 + v29);
      if (v33 <= v30) {
        uint64_t v35 = a4 + 3;
      }
      else {
        uint64_t v35 = v34;
      }
      *(void *)&v28[v29] = a2 + *v35 - v10;
      if (0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3) <= v30) {
        uint64_t v36 = a4 + 3;
      }
      else {
        uint64_t v36 = (uint64_t *)(*a4 + v29);
      }
      *(void *)(*(void *)a1 + v29 + 8) = a2 + v36[1] - v10;
      uint64_t v32 = *a4;
      uint64_t v31 = a4[1];
      if (0xAAAAAAAAAAAAAAABLL * ((v31 - *a4) >> 3) <= v30) {
        unint64_t v37 = a4 + 3;
      }
      else {
        unint64_t v37 = (uint64_t *)(*a4 + v29);
      }
      char v38 = *((unsigned char *)v37 + 16);
      size_t v28 = *(char **)a1;
      uint64_t v39 = *(void *)(a1 + 8);
      *(unsigned char *)(*(void *)a1 + v29 + 16) = v38;
      ++v30;
      v29 += 24;
    }
    while (v30 < 0xAAAAAAAAAAAAAAABLL * ((v39 - (uint64_t)v28) >> 3));
  }
  *(void *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = a3;
  *(unsigned char *)(a1 + 40) = 0;
  uint64_t v40 = a2 + a4[6] - v10;
  *(void *)(a1 + 48) = v40;
  *(void *)(a1 + 56) = a2 + a4[7] - v10;
  *(unsigned char *)(a1 + 64) = *((unsigned char *)a4 + 64);
  *(void *)(a1 + 72) = a2 + a4[9] - v10;
  *(void *)(a1 + 80) = a2 + a4[10] - v10;
  *(unsigned char *)(a1 + 88) = *((unsigned char *)a4 + 88);
  if ((v5 & 1) == 0) {
    *(void *)(a1 + 104) = v40;
  }
  *(unsigned char *)(a1 + 96) = *((unsigned char *)a4 + 96);
}

uint64_t sub_18E1B15F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int a5, char a6)
{
  int v7 = a5;
  uint64_t v9 = a3;
  uint64_t v10 = a2;
  if ((*(_WORD *)(a1 + 24) & 0x1F0) != 0)
  {
    uint64_t v165 = (char *)(a3 - a2);
    __int16 v164 = a5;
    if (*(_DWORD *)(a1 + 28))
    {
      v166[0] = 0;
      v166[1] = 0;
      *(void *)&long long v167 = 0;
      uint64_t v12 = *(void *)(a1 + 40);
      if (v12)
      {
        *(void *)&long long v172 = a3;
        *((void *)&v172 + 1) = a3;
        char v173 = 0;
        *(_DWORD *)uint64_t v169 = 0;
        memset(&v169[8], 0, 48);
        *(_OWORD *)std::string __p = 0u;
        memset(v171, 0, 21);
        v166[1] = sub_18E1AB780((int64x2_t *)v166, (uint64_t)v169);
        if (__p[0]) {
          operator delete(__p[0]);
        }
        if (*(void *)&v169[32]) {
          operator delete(*(void **)&v169[32]);
        }
        long long v152 = a4;
        uint64_t v13 = (void **)v166[1];
        *((_DWORD *)v166[1] - 24) = 0;
        *(v13 - 11) = (void *)v10;
        *(v13 - 10) = (void *)v10;
        *(v13 - 9) = (void *)v9;
        sub_18E1AB42C(v13 - 8, *(unsigned int *)(a1 + 28), &v172);
        sub_18E1AB5B8((char **)v166[1] - 5, *(unsigned int *)(a1 + 32));
        BOOL v158 = 0;
        int8x16_t v160 = 0;
        uint64_t v154 = 0;
        uint64_t v155 = 0;
        unint64_t v156 = 0;
        uint64_t v157 = 0;
        unint64_t v14 = 0;
        char v15 = 0;
        unsigned int v16 = 0;
        unint64_t v17 = v166[1];
        *((void *)v166[1] - 2) = v12;
        *(v17 - 2) = v7;
        *((unsigned char *)v17 - 4) = a6;
        do
        {
          BOOL v18 = (++v16 & 0xFFF) != 0 || (int)(v16 >> 12) < (int)v165;
          if (!v18) {
            sub_18E1AB6D0();
          }
          int v20 = v17 - 4;
          uint64_t v19 = *((void *)v17 - 2);
          uint64_t v21 = v17 - 24;
          if (v19) {
            (*(void (**)(uint64_t, _DWORD *))(*(void *)v19 + 16))(v19, v17 - 24);
          }
          switch(*(_DWORD *)v21)
          {
            case 0xFFFFFC18:
              uint64_t v22 = *((void *)v17 - 10);
              if ((v164 & 0x20) != 0 && v22 == v10 || (v164 & 0x1000) != 0 && v22 != a3) {
                goto LABEL_21;
              }
              if ((v15 & ((uint64_t)v14 >= v22 - *((void *)v17 - 11))) != 0)
              {
                uint64_t v29 = v160;
                unint64_t v30 = v156;
              }
              else
              {
                uint64_t v32 = (long long *)*((void *)v17 - 8);
                uint64_t v31 = (long long *)*((void *)v17 - 7);
                unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * (((char *)v31 - (char *)v32) >> 3);
                unint64_t v34 = v160;
                double v151 = (char *)(v22 - *((void *)v17 - 11));
                if (0xAAAAAAAAAAAAAAABLL * ((v155 - (uint64_t)v157) >> 3) >= v33)
                {
                  if (0xAAAAAAAAAAAAAAABLL * ((v160 - v157) >> 3) >= v33)
                  {
                    if (v32 == v31)
                    {
                      uint64_t v47 = v157;
                      uint64_t v48 = v157;
                    }
                    else
                    {
                      uint64_t v47 = v157;
                      uint64_t v48 = v157;
                      uint64_t v49 = v157;
                      do
                      {
                        *(_OWORD *)uint64_t v49 = *v32;
                        v49[16] = *((unsigned char *)v32 + 16);
                        v48 += 24;
                        uint64_t v32 = (long long *)((char *)v32 + 24);
                        v49 += 24;
                      }
                      while (v32 != v31);
                    }
                    int64_t v46 = v48 - v47;
                    unint64_t v34 = v47;
                  }
                  else
                  {
                    uint64_t v41 = (long long *)((char *)v32 + 8 * ((v160 - v157) >> 3));
                    if (v160 != v157)
                    {
                      char v42 = v157;
                      do
                      {
                        *(_OWORD *)char v42 = *v32;
                        v42[16] = *((unsigned char *)v32 + 16);
                        uint64_t v32 = (long long *)((char *)v32 + 24);
                        v42 += 24;
                      }
                      while (v32 != v41);
                    }
                    unint64_t v43 = v160;
                    if (v41 != v31)
                    {
                      char v44 = v160;
                      do
                      {
                        long long v45 = *v41;
                        *((void *)v44 + 2) = *((void *)v41 + 2);
                        *(_OWORD *)char v44 = v45;
                        v44 += 24;
                        uint64_t v41 = (long long *)((char *)v41 + 24);
                        v43 += 24;
                      }
                      while (v41 != v31);
                    }
                    int64_t v46 = v43 - v160;
                  }
                }
                else
                {
                  if (v157)
                  {
                    operator delete(v157);
                    uint64_t v155 = 0;
                  }
                  if (v33 > 0xAAAAAAAAAAAAAAALL) {
                    goto LABEL_220;
                  }
                  unint64_t v35 = 0x5555555555555556 * (v155 >> 3);
                  if (v35 <= v33) {
                    unint64_t v35 = 0xAAAAAAAAAAAAAAABLL * (((char *)v31 - (char *)v32) >> 3);
                  }
                  unint64_t v36 = 0xAAAAAAAAAAAAAAABLL * (v155 >> 3) >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v35;
                  if (v36 > 0xAAAAAAAAAAAAAAALL) {
LABEL_220:
                  }
                    sub_18DEE1FC8();
                  unint64_t v37 = (char *)sub_18E12E008(v36);
                  unint64_t v34 = v37;
                  uint64_t v39 = v37;
                  while (v32 != v31)
                  {
                    long long v40 = *v32;
                    *((void *)v39 + 2) = *((void *)v32 + 2);
                    *(_OWORD *)uint64_t v39 = v40;
                    v39 += 24;
                    uint64_t v32 = (long long *)((char *)v32 + 24);
                  }
                  uint64_t v155 = (uint64_t)&v37[24 * v38];
                  int64_t v46 = v39 - v37;
                  uint64_t v157 = v37;
                }
                int v51 = (char *)*((void *)v17 - 5);
                unint64_t v50 = (char *)*((void *)v17 - 4);
                unint64_t v52 = (v50 - v51) >> 4;
                if (v52 <= (v154 - (uint64_t)v158) >> 4)
                {
                  unint64_t v59 = (v156 - v158) >> 4;
                  if (v59 >= v52)
                  {
                    if (v51 == v50)
                    {
                      std::string::size_type v66 = v158;
                      unint64_t v14 = v151;
                    }
                    else
                    {
                      uint64_t v65 = v158;
                      std::string::size_type v66 = v158;
                      unint64_t v14 = v151;
                      do
                      {
                        *(void *)uint64_t v65 = *(void *)v51;
                        *((void *)v65 + 1) = *((void *)v51 + 1);
                        v66 += 16;
                        v51 += 16;
                        v65 += 16;
                      }
                      while (v51 != v50);
                    }
                    int64_t v67 = v66 - v158;
                    unint64_t v55 = v158;
                  }
                  else
                  {
                    uint64_t v60 = &v51[16 * v59];
                    if (v156 != v158)
                    {
                      uint64_t v61 = v158;
                      do
                      {
                        *(void *)uint64_t v61 = *(void *)v51;
                        *((void *)v61 + 1) = *((void *)v51 + 1);
                        v51 += 16;
                        v61 += 16;
                      }
                      while (v51 != v60);
                    }
                    unint64_t v14 = v151;
                    if (v60 == v50)
                    {
                      unint64_t v55 = v156;
                      uint64_t v62 = v156;
                    }
                    else
                    {
                      unint64_t v55 = v156;
                      uint64_t v62 = v156;
                      unint64_t v63 = v156;
                      do
                      {
                        long long v64 = *(_OWORD *)v60;
                        v60 += 16;
                        *(_OWORD *)unint64_t v63 = v64;
                        v63 += 16;
                        v62 += 16;
                      }
                      while (v60 != v50);
                    }
                    int64_t v67 = v62 - v55;
                  }
                }
                else
                {
                  if (v158)
                  {
                    operator delete(v158);
                    uint64_t v154 = 0;
                  }
                  if (v50 - v51 < 0) {
                    goto LABEL_219;
                  }
                  uint64_t v53 = v154 >> 3;
                  if (v154 >> 3 <= v52) {
                    uint64_t v53 = (v50 - v51) >> 4;
                  }
                  unint64_t v54 = (unint64_t)v154 >= 0x7FFFFFFFFFFFFFF0 ? 0xFFFFFFFFFFFFFFFLL : v53;
                  if (v54 >> 60) {
LABEL_219:
                  }
                    sub_18DEE1FC8();
                  unint64_t v55 = (char *)sub_18E12E050(v54);
                  std::string::size_type v57 = v55;
                  if (v51 == v50)
                  {
                    unint64_t v14 = v151;
                  }
                  else
                  {
                    unint64_t v14 = v151;
                    do
                    {
                      long long v58 = *(_OWORD *)v51;
                      v51 += 16;
                      *(_OWORD *)std::string::size_type v57 = v58;
                      v57 += 16;
                    }
                    while (v51 != v50);
                  }
                  uint64_t v154 = (uint64_t)&v55[16 * v56];
                  int64_t v67 = v57 - v55;
                  BOOL v158 = v55;
                }
                uint64_t v29 = &v34[v46];
                unint64_t v30 = &v55[v67];
              }
              int8x16_t v160 = v29;
              uint64_t v68 = v166[1];
              unint64_t v156 = v30;
              if (v14 == v165)
              {
                long long v69 = v166[0];
                while (v68 != v69)
                {
                  v68 -= 12;
                  sub_18E1AB948(v68);
                }
                v166[1] = v69;
                char v15 = 1;
                unint64_t v14 = v165;
              }
              else
              {
                uint64_t v70 = (char *)v166[1] - 96;
                sub_18E1AB948((void *)v166[1] - 12);
                v166[1] = v70;
                char v15 = 1;
              }
              break;
            case 0xFFFFFC1D:
            case 0xFFFFFC1E:
            case 0xFFFFFC21:
              break;
            case 0xFFFFFC1F:
LABEL_21:
              int v23 = (char *)v166[1] - 96;
              sub_18E1AB948((void *)v166[1] - 12);
              v166[1] = v23;
              break;
            case 0xFFFFFC20:
              long long v24 = *((_OWORD *)v17 - 5);
              *(_OWORD *)uint64_t v169 = *v21;
              *(_OWORD *)&v169[16] = v24;
              memset(&v169[32], 0, 24);
              sub_18E1AB9F0(&v169[32], *((long long **)v17 - 8), *((long long **)v17 - 7), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v17 - 7) - *((void *)v17 - 8)) >> 3));
              __p[0] = 0;
              __p[1] = 0;
              v171[0] = 0;
              sub_18E1ABA70((char *)__p, *((long long **)v17 - 5), *((long long **)v17 - 4), (uint64_t)(*((void *)v17 - 4) - *((void *)v17 - 5)) >> 4);
              uint64_t v25 = *v20;
              *(void *)((char *)&v171[1] + 5) = *(void *)((char *)v17 - 11);
              v171[1] = v25;
              (*(void (**)(void, uint64_t, _DWORD *))(*(void *)*v20 + 24))(*v20, 1, v17 - 24);
              (*(void (**)(void, void, unsigned char *))(*(void *)v171[1] + 24))(v171[1], 0, v169);
              long long v26 = (char *)v166[1];
              if (v166[1] >= (void *)v167)
              {
                v166[1] = sub_18E1AB780((int64x2_t *)v166, (uint64_t)v169);
                if (__p[0])
                {
                  __p[1] = __p[0];
                  operator delete(__p[0]);
                }
              }
              else
              {
                long long v27 = *(_OWORD *)&v169[16];
                *(_OWORD *)v166[1] = *(_OWORD *)v169;
                *((_OWORD *)v26 + 1) = v27;
                *((void *)v26 + 4) = 0;
                *((void *)v26 + 5) = 0;
                *((void *)v26 + 6) = 0;
                *((void *)v26 + 7) = 0;
                *((_OWORD *)v26 + 2) = *(_OWORD *)&v169[32];
                *((void *)v26 + 6) = *(void *)&v169[48];
                memset(&v169[32], 0, 24);
                *((void *)v26 + 8) = 0;
                *((void *)v26 + 9) = 0;
                *(_OWORD *)(v26 + 56) = *(_OWORD *)__p;
                *((void *)v26 + 9) = v171[0];
                __p[0] = 0;
                __p[1] = 0;
                v171[0] = 0;
                uint64_t v28 = v171[1];
                *(void *)(v26 + 85) = *(void *)((char *)&v171[1] + 5);
                *((void *)v26 + 10) = v28;
                v166[1] = v26 + 96;
              }
              if (*(void *)&v169[32])
              {
                *(void *)&v169[40] = *(void *)&v169[32];
                operator delete(*(void **)&v169[32]);
              }
              break;
            default:
              sub_18E1AB728();
          }
          unint64_t v17 = v166[1];
        }
        while (v166[0] != v166[1]);
        if (v15)
        {
          uint64_t v72 = *v152;
          *(void *)uint64_t v72 = v10;
          *(void *)(v72 + 8) = &v14[v10];
          *(unsigned char *)(v72 + 16) = 1;
          uint64_t v73 = v157;
          if (v160 != v157)
          {
            uint64_t v74 = v157 + 16;
            unsigned int v75 = 1;
            do
            {
              uint64_t v76 = v72 + 24 * v75;
              *(_OWORD *)uint64_t v76 = *((_OWORD *)v74 - 1);
              char v77 = *v74;
              v74 += 24;
              *(unsigned char *)(v76 + 16) = v77;
              BOOL v18 = 0xAAAAAAAAAAAAAAABLL * ((v160 - v157) >> 3) > v75++;
            }
            while (v18);
          }
        }
        else
        {
          uint64_t v73 = v157;
        }
        if (v158) {
          operator delete(v158);
        }
        if (v73) {
          operator delete(v73);
        }
      }
      else
      {
        char v15 = 0;
      }
      *(void *)uint64_t v169 = v166;
      sub_18E1ABB24((void ***)v169);
    }
    else
    {
      long long v167 = 0u;
      int64x2_t v168 = 0u;
      *(_OWORD *)double v166 = 0u;
      uint64_t v78 = *(void *)(a1 + 40);
      if (v78)
      {
        *(_DWORD *)uint64_t v169 = 0;
        memset(&v169[8], 0, 48);
        *(_OWORD *)std::string __p = 0uLL;
        memset(v171, 0, 21);
        sub_18E1B27F8(v166, (uint64_t)v169);
        if (__p[0]) {
          operator delete(__p[0]);
        }
        if (*(void *)&v169[32]) {
          operator delete(*(void **)&v169[32]);
        }
        uint64_t v153 = a4;
        uint64_t v79 = v166[1];
        unint64_t v80 = v168.i64[1] + v168.i64[0] - 1;
        unint64_t v81 = v80 / 0x2A;
        uint64_t v82 = *((void *)v166[1] + v80 / 0x2A);
        unint64_t v83 = 3 * (v80 % 0x2A);
        uint64_t v84 = v82 + 32 * v83;
        *(_DWORD *)uint64_t v84 = 0;
        *(void *)(v84 + 8) = v10;
        *(void *)(v79[v81] + 32 * v83 + 16) = v10;
        *(void *)(v79[v81] + 32 * v83 + 24) = v9;
        sub_18E1AB5B8((char **)(v79[v81] + 32 * v83 + 56), *(unsigned int *)(a1 + 32));
        char v161 = 0;
        unsigned int v85 = 0;
        long long v159 = 0;
        uint64_t v86 = v168.i64[1];
        std::string::size_type v87 = v166[1];
        unint64_t v88 = v168.i64[1] + v168.i64[0] - 1;
        unint64_t v89 = v88 / 0x2A;
        unint64_t v90 = 3 * (v88 % 0x2A);
        *(void *)(*((void *)v166[1] + v89) + 32 * v90 + 80) = v78;
        uint64_t v91 = v87[v89] + 32 * v90;
        *(_DWORD *)(v91 + 88) = v7;
        *(unsigned char *)(v91 + 92) = a6;
        while (2)
        {
          if ((++v85 & 0xFFF) == 0 && (int)(v85 >> 12) >= (int)v165) {
            sub_18E1AB6D0();
          }
          unint64_t v93 = v86 + v168.i64[0] - 1;
          uint64_t v94 = *((void *)v166[1] + v93 / 0x2A);
          unint64_t v95 = v93 % 0x2A;
          uint64_t v96 = v94 + 96 * (v93 % 0x2A);
          uint64_t v98 = (void *)(v96 + 80);
          uint64_t v97 = *(void *)(v96 + 80);
          if (v97) {
            (*(void (**)(uint64_t, unint64_t))(*(void *)v97 + 16))(v97, v94 + 96 * v95);
          }
          switch(*(_DWORD *)v96)
          {
            case 0xFFFFFC18:
              uint64_t v99 = *(void *)(v94 + 96 * v95 + 16);
              BOOL v100 = (v7 & 0x1000) == 0 || v99 == v9;
              char v101 = v100;
              BOOL v102 = v99 != v10 || (v7 & 0x20) == 0;
              if (!v102 || (v101 & 1) == 0) {
                goto LABEL_203;
              }
              uint64_t v103 = v99 - *(void *)(v94 + 96 * v95 + 8);
              uint64_t v104 = v159;
              if ((v161 & ((uint64_t)v159 >= v103)) == 0) {
                uint64_t v104 = (char *)v103;
              }
              if (v104 != v165)
              {
                long long v159 = v104;
                sub_18E1B2C9C(v166);
                char v161 = 1;
                goto LABEL_204;
              }
              uint64_t v105 = (void **)v166[1];
              uint64_t v106 = (unsigned char *)v167;
              if ((void *)v167 == v166[1])
              {
                uint64_t v106 = v166[1];
              }
              else
              {
                uint64_t v107 = v10;
                char v108 = (char *)v166[1] + 8 * (v168.i64[0] / 0x2AuLL);
                BOOL v109 = (void *)(*v108 + 96 * (v168.i64[0] % 0x2AuLL));
                unint64_t v110 = *((void *)v166[1] + (v168.i64[1] + v168.i64[0]) / 0x2AuLL)
                     + 96 * ((v168.i64[1] + v168.i64[0]) % 0x2AuLL);
                if (v109 != (void *)v110)
                {
                  do
                  {
                    sub_18E1AB948(v109);
                    v109 += 12;
                    if ((void *)((char *)v109 - *v108) == (void *)4032)
                    {
                      int8x16_t v111 = (void *)v108[1];
                      ++v108;
                      BOOL v109 = v111;
                    }
                  }
                  while (v109 != (void *)v110);
                  uint64_t v105 = (void **)v166[1];
                  uint64_t v106 = (unsigned char *)v167;
                }
                uint64_t v10 = v107;
              }
              v168.i64[1] = 0;
              unint64_t v141 = v106 - (unsigned char *)v105;
              if (v141 >= 0x11)
              {
                do
                {
                  operator delete(*v105);
                  uint64_t v105 = (void **)((char *)v166[1] + 8);
                  v166[1] = v105;
                  unint64_t v141 = v167 - (void)v105;
                }
                while ((void)v167 - (void)v105 > 0x10uLL);
              }
              if (v141 >> 3 == 1)
              {
                uint64_t v142 = 21;
              }
              else
              {
                if (v141 >> 3 != 2) {
                  goto LABEL_191;
                }
                uint64_t v142 = 42;
              }
              v168.i64[0] = v142;
LABEL_191:
              char v161 = 1;
              long long v159 = v165;
LABEL_204:
              uint64_t v86 = v168.i64[1];
              if (v168.i64[1]) {
                continue;
              }
              if ((v161 & 1) == 0) {
                goto LABEL_207;
              }
              uint64_t v150 = *v153;
              *(void *)uint64_t v150 = v10;
              *(void *)(v150 + 8) = &v159[v10];
              char v15 = 1;
              *(unsigned char *)(v150 + 16) = 1;
              break;
            case 0xFFFFFC19:
            case 0xFFFFFC1E:
            case 0xFFFFFC21:
              goto LABEL_204;
            case 0xFFFFFC1D:
              unint64_t v112 = v168.i64[0];
              char v113 = (char *)v166[1];
              unsigned __int8 v114 = (char *)v167;
              if (!v168.i64[0])
              {
                unint64_t v117 = (uint64_t)(v167 - (unint64_t)v166[1]) >> 3;
                uint64_t v118 = 42 * v117 - 1;
                if ((void *)v167 == v166[1]) {
                  uint64_t v118 = 0;
                }
                if ((unint64_t)(v118 - v168.i64[1]) < 0x2A)
                {
                  if (v117 >= (uint64_t)(*((void *)&v167 + 1) - (unint64_t)v166[0]) >> 3)
                  {
                    if (*((void **)&v167 + 1) == v166[0]) {
                      unint64_t v119 = 1;
                    }
                    else {
                      unint64_t v119 = (uint64_t)(*((void *)&v167 + 1) - (unint64_t)v166[0]) >> 2;
                    }
                    *(void *)&v169[32] = (char *)&v167 + 8;
                    *(void *)uint64_t v169 = sub_18DEE2FBC(v119);
                    *(void *)&v169[8] = *(void *)v169;
                    *(void *)&v169[16] = *(void *)v169;
                    *(void *)&v169[24] = *(void *)v169 + 8 * v120;
                    uint64_t v163 = v10;
                    *(void *)&long long v172 = operator new(0xFC0uLL);
                    sub_18E021864(v169, &v172);
                    long long v121 = (uint64_t *)v166[1];
                    for (uint64_t i = *(char **)&v169[16]; v121 != (uint64_t *)v167; *(void *)&v169[16] += 8)
                    {
                      if (i == *(char **)&v169[24])
                      {
                        uint64_t v123 = *(char **)&v169[8];
                        uint64_t v124 = *(void **)v169;
                        if (*(void *)&v169[8] <= *(void *)v169)
                        {
                          if (i == *(char **)v169) {
                            unint64_t v131 = 1;
                          }
                          else {
                            unint64_t v131 = (uint64_t)&i[-*(void *)v169] >> 2;
                          }
                          long long v132 = (char *)sub_18DEE2FBC(v131);
                          uint64_t v134 = i - v123;
                          BOOL v100 = i == v123;
                          uint64_t i = &v132[8 * (v131 >> 2)];
                          if (!v100)
                          {
                            uint64_t i = &v132[8 * (v131 >> 2) + (v134 & 0xFFFFFFFFFFFFFFF8)];
                            uint64_t v135 = 8 * (v134 >> 3);
                            unint64_t v136 = &v132[8 * (v131 >> 2)];
                            do
                            {
                              uint64_t v137 = *(void *)v123;
                              v123 += 8;
                              *(void *)unint64_t v136 = v137;
                              v136 += 8;
                              v135 -= 8;
                            }
                            while (v135);
                          }
                          *(void *)uint64_t v169 = v132;
                          *(void *)&v169[8] = &v132[8 * (v131 >> 2)];
                          *(void *)&v169[16] = i;
                          *(void *)&v169[24] = &v132[8 * v133];
                          if (v124) {
                            operator delete(v124);
                          }
                        }
                        else
                        {
                          uint64_t v125 = (uint64_t)(*(void *)&v169[8] - *(void *)v169) >> 3;
                          if (v125 >= -1) {
                            uint64_t v126 = v125 + 1;
                          }
                          else {
                            uint64_t v126 = v125 + 2;
                          }
                          uint64_t v127 = *(void *)&v169[8] - 8 * (v126 >> 1);
                          size_t v128 = (size_t)&i[-*(void *)&v169[8]];
                          if (i != *(char **)&v169[8])
                          {
                            uint64_t v129 = (void *)(*(void *)&v169[8] - 8 * (v126 >> 1));
                            memmove(v129, *(const void **)&v169[8], v128);
                            uint64_t v127 = (uint64_t)v129;
                            uint64_t i = v123;
                          }
                          uint64_t v130 = &i[-8 * (v126 >> 1)];
                          uint64_t i = (char *)(v127 + v128);
                          *(void *)&v169[8] = v130;
                          *(void *)&v169[16] = v127 + v128;
                        }
                      }
                      uint64_t v138 = *v121++;
                      *(void *)uint64_t i = v138;
                      uint64_t i = (char *)(*(void *)&v169[16] + 8);
                    }
                    uint64_t v139 = v166[0];
                    *(_OWORD *)double v166 = *(_OWORD *)v169;
                    *(void *)&long long v167 = i;
                    *((void *)&v167 + 1) = *(void *)&v169[24];
                    uint64_t v140 = 21;
                    if (&i[-*(void *)&v169[8]] != (char *)8) {
                      uint64_t v140 = v168.i64[0] + 42;
                    }
                    v168.i64[0] = v140;
                    uint64_t v10 = v163;
                    if (v139) {
                      operator delete(v139);
                    }
                    LOWORD(v7) = v164;
                    uint64_t v9 = a3;
                  }
                  else
                  {
                    if (v166[1] == v166[0])
                    {
                      *(void *)uint64_t v169 = operator new(0xFC0uLL);
                      sub_18E021864(v166, v169);
                      *(void *)uint64_t v169 = *(void *)(v167 - 8);
                      *(void *)&long long v167 = v167 - 8;
                    }
                    else
                    {
                      *(void *)uint64_t v169 = operator new(0xFC0uLL);
                    }
                    sub_18E02174C((uint64_t)v166, v169);
                    uint64_t v143 = 21;
                    if ((void)v167 - (unint64_t)v166[1] != 8) {
                      uint64_t v143 = v168.i64[0] + 42;
                    }
                    v168.i64[0] = v143;
                  }
                }
                else
                {
                  v168.i64[0] = 42;
                  *(void *)uint64_t v169 = *(void *)(v167 - 8);
                  *(void *)&long long v167 = v167 - 8;
                  sub_18E02174C((uint64_t)v166, v169);
                }
                unint64_t v112 = v168.i64[0];
                char v113 = (char *)v166[1];
                unsigned __int8 v114 = (char *)v167;
              }
              unint64_t v144 = &v113[8 * (v112 / 0x2A)];
              unint64_t v145 = *(void *)v144 + 96 * (v112 % 0x2A);
              if (v114 == v113) {
                uint64_t v146 = 0;
              }
              else {
                uint64_t v146 = v145;
              }
              if (v146 == *(void *)v144) {
                uint64_t v146 = *((void *)v144 - 1) + 4032;
              }
              long long v147 = *(_OWORD *)(v96 + 16);
              *(_OWORD *)(v146 - 96) = *(_OWORD *)v96;
              *(_OWORD *)(v146 - 80) = v147;
              uint64_t v148 = v94 + 96 * v95;
              *(void *)(v146 - 56) = 0;
              *(void *)(v146 - 48) = 0;
              *(void *)(v146 - 64) = 0;
              *(_OWORD *)(v146 - 64) = *(_OWORD *)(v148 + 32);
              *(void *)(v146 - 48) = *(void *)(v148 + 48);
              *(void *)(v148 + 32) = 0;
              *(void *)(v148 + 40) = 0;
              *(void *)(v148 + 48) = 0;
              *(void *)(v146 - 40) = 0;
              *(void *)(v146 - 32) = 0;
              *(void *)(v146 - 24) = 0;
              *(_OWORD *)(v146 - 40) = *(_OWORD *)(v148 + 56);
              *(void *)(v146 - 24) = *(void *)(v148 + 72);
              *(void *)(v148 + 56) = 0;
              *(void *)(v148 + 64) = 0;
              *(void *)(v148 + 72) = 0;
              uint64_t v149 = *v98;
              *(void *)(v146 - 11) = *(void *)(v96 + 85);
              *(void *)(v146 - 16) = v149;
              int64x2_t v168 = vaddq_s64(v168, (int64x2_t)xmmword_18E1FC130);
              goto LABEL_203;
            case 0xFFFFFC1F:
LABEL_203:
              sub_18E1B2C9C(v166);
              goto LABEL_204;
            case 0xFFFFFC20:
              long long v115 = *(_OWORD *)(v96 + 16);
              *(_OWORD *)uint64_t v169 = *(_OWORD *)v96;
              *(_OWORD *)&v169[16] = v115;
              memset(&v169[32], 0, 24);
              sub_18E1AB9F0(&v169[32], *(long long **)(v94 + 96 * v95 + 32), *(long long **)(v94 + 96 * v95 + 40), 0xAAAAAAAAAAAAAAABLL* ((uint64_t)(*(void *)(v94 + 96 * v95 + 40) - *(void *)(v94 + 96 * v95 + 32)) >> 3));
              __p[0] = 0;
              __p[1] = 0;
              v171[0] = 0;
              sub_18E1ABA70((char *)__p, *(long long **)(v94 + 96 * v95 + 56), *(long long **)(v94 + 96 * v95 + 64), (uint64_t)(*(void *)(v94 + 96 * v95 + 64) - *(void *)(v94 + 96 * v95 + 56)) >> 4);
              uint64_t v116 = *v98;
              *(void *)((char *)&v171[1] + 5) = *(void *)(v96 + 85);
              v171[1] = v116;
              (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v98 + 24))(*v98, 1, v96);
              (*(void (**)(void, void, unsigned char *))(*(void *)v171[1] + 24))(v171[1], 0, v169);
              sub_18E1B27F8(v166, (uint64_t)v169);
              if (__p[0])
              {
                __p[1] = __p[0];
                operator delete(__p[0]);
              }
              if (*(void *)&v169[32])
              {
                *(void *)&v169[40] = *(void *)&v169[32];
                operator delete(*(void **)&v169[32]);
              }
              goto LABEL_204;
            default:
              sub_18E1AB728();
          }
          break;
        }
      }
      else
      {
LABEL_207:
        char v15 = 0;
      }
      sub_18E1B2D4C((uint64_t)v166);
    }
    return v15 & 1;
  }
  else
  {
    return sub_18E1AADD8(a1, a2, a3, a4, a5, a6);
  }
}

void sub_18E1B2674(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37)
{
  operator delete(v37);
  if (__p) {
    operator delete(__p);
  }
  sub_18E1B2D4C((uint64_t)&a23);
  _Unwind_Resume(a1);
}

__n128 sub_18E1B27F8(void *a1, uint64_t a2)
{
  uint64_t v4 = (char *)a1[1];
  char v5 = (char *)a1[2];
  unint64_t v6 = (v5 - v4) >> 3;
  if (v5 == v4) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = 42 * v6 - 1;
  }
  unint64_t v8 = a1[4];
  unint64_t v9 = a1[5] + v8;
  if (v7 == v9)
  {
    if (v8 < 0x2A)
    {
      int v23 = (char *)a1[3];
      uint64_t v24 = (uint64_t)&v23[-*a1];
      if (v6 >= v24 >> 3)
      {
        if (v23 == (char *)*a1) {
          unint64_t v25 = 1;
        }
        else {
          unint64_t v25 = v24 >> 2;
        }
        std::string::size_type v87 = a1 + 3;
        unint64_t v83 = (char *)sub_18DEE2FBC(v25);
        uint64_t v84 = &v83[8 * v6];
        unsigned int v85 = v84;
        uint64_t v86 = &v83[8 * v26];
        uint64_t v82 = operator new(0xFC0uLL);
        sub_18E021864(&v83, &v82);
        uint64_t v28 = v83;
        long long v27 = v84;
        uint64_t v29 = v85;
        unint64_t v30 = v86;
        uint64_t v31 = a1[2];
        if (v31 == a1[1])
        {
          uint64_t v47 = v84;
        }
        else
        {
          do
          {
            if (v27 == v28)
            {
              if (v29 >= v30)
              {
                if (v30 == v27) {
                  unint64_t v37 = 1;
                }
                else {
                  unint64_t v37 = (v30 - v27) >> 2;
                }
                uint64_t v38 = (char *)sub_18DEE2FBC(v37);
                uint64_t v28 = v38;
                uint64_t v32 = &v38[(2 * v37 + 6) & 0xFFFFFFFFFFFFFFF8];
                uint64_t v41 = v29 - v27;
                BOOL v40 = v29 == v27;
                uint64_t v29 = v32;
                if (!v40)
                {
                  uint64_t v29 = &v32[v41 & 0xFFFFFFFFFFFFFFF8];
                  uint64_t v42 = 8 * (v41 >> 3);
                  unint64_t v43 = v32;
                  char v44 = v27;
                  do
                  {
                    uint64_t v45 = *(void *)v44;
                    v44 += 8;
                    *(void *)unint64_t v43 = v45;
                    v43 += 8;
                    v42 -= 8;
                  }
                  while (v42);
                }
                unint64_t v30 = &v38[8 * v39];
                if (v27) {
                  operator delete(v27);
                }
              }
              else
              {
                uint64_t v33 = (v30 - v29) >> 3;
                if (v33 >= -1) {
                  uint64_t v34 = v33 + 1;
                }
                else {
                  uint64_t v34 = v33 + 2;
                }
                uint64_t v35 = v34 >> 1;
                uint64_t v32 = &v27[8 * (v34 >> 1)];
                unint64_t v36 = v27;
                if (v29 != v27)
                {
                  memmove(v32, v27, v29 - v27);
                  unint64_t v36 = v29;
                }
                uint64_t v29 = &v36[8 * v35];
                uint64_t v28 = v27;
              }
            }
            else
            {
              uint64_t v32 = v27;
            }
            uint64_t v46 = *(void *)(v31 - 8);
            v31 -= 8;
            *((void *)v32 - 1) = v46;
            uint64_t v47 = v32 - 8;
            long long v27 = v47;
          }
          while (v31 != a1[1]);
        }
        uint64_t v62 = (char *)*a1;
        *a1 = v28;
        a1[1] = v47;
        a1[2] = v29;
        a1[3] = v30;
        if (v62) {
          operator delete(v62);
        }
        goto LABEL_54;
      }
      if (v23 != v5)
      {
        unint64_t v83 = (char *)operator new(0xFC0uLL);
        sub_18E021864(a1, &v83);
LABEL_54:
        uint64_t v4 = (char *)a1[1];
        unint64_t v9 = a1[5] + a1[4];
        goto LABEL_55;
      }
      unint64_t v83 = (char *)operator new(0xFC0uLL);
      sub_18E02174C((uint64_t)a1, &v83);
      unint64_t v59 = (void *)a1[1];
      char v5 = (char *)a1[2];
      uint64_t v61 = *v59;
      uint64_t v60 = (char *)(v59 + 1);
      uint64_t v11 = v61;
      a1[1] = v60;
      if (v5 == (char *)a1[3])
      {
        uint64_t v67 = (uint64_t)&v60[-*a1];
        if ((unint64_t)v60 > *a1)
        {
          uint64_t v68 = v67 >> 3;
          BOOL v15 = v67 >> 3 < -1;
          uint64_t v69 = (v67 >> 3) + 2;
          if (v15) {
            uint64_t v70 = v69;
          }
          else {
            uint64_t v70 = v68 + 1;
          }
          uint64_t v71 = -(v70 >> 1);
          uint64_t v72 = v70 >> 1;
          uint64_t v73 = &v60[-8 * v72];
          int64_t v74 = v5 - v60;
          if (v5 != v60)
          {
            memmove(&v60[-8 * v72], v60, v5 - v60);
            uint64_t v60 = (char *)a1[1];
          }
          char v5 = &v73[v74];
          uint64_t v22 = &v60[8 * v71];
          goto LABEL_14;
        }
        if (v5 == (char *)*a1) {
          unint64_t v75 = 1;
        }
        else {
          unint64_t v75 = (uint64_t)&v5[-*a1] >> 2;
        }
        uint64_t v49 = (char *)sub_18DEE2FBC(v75);
        unint64_t v50 = &v49[8 * (v75 >> 2)];
        unint64_t v52 = &v49[8 * v76];
        char v77 = (uint64_t *)a1[1];
        char v5 = v50;
        uint64_t v78 = a1[2] - (void)v77;
        if (v78)
        {
          char v5 = &v50[v78 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v79 = 8 * (v78 >> 3);
          unint64_t v80 = &v49[8 * (v75 >> 2)];
          do
          {
            uint64_t v81 = *v77++;
            *(void *)unint64_t v80 = v81;
            v80 += 8;
            v79 -= 8;
          }
          while (v79);
        }
LABEL_47:
        long long v58 = (char *)*a1;
        *a1 = v49;
        a1[1] = v50;
        a1[2] = v5;
        a1[3] = v52;
        if (v58)
        {
          operator delete(v58);
          char v5 = (char *)a1[2];
        }
      }
    }
    else
    {
      a1[4] = v8 - 42;
      uint64_t v12 = *(void *)v4;
      uint64_t v10 = v4 + 8;
      uint64_t v11 = v12;
      a1[1] = v10;
      if (v5 == (char *)a1[3])
      {
        uint64_t v13 = (uint64_t)&v10[-*a1];
        if ((unint64_t)v10 > *a1)
        {
          uint64_t v14 = v13 >> 3;
          BOOL v15 = v13 >> 3 < -1;
          uint64_t v16 = (v13 >> 3) + 2;
          if (v15) {
            uint64_t v17 = v16;
          }
          else {
            uint64_t v17 = v14 + 1;
          }
          uint64_t v18 = -(v17 >> 1);
          uint64_t v19 = v17 >> 1;
          int v20 = &v10[-8 * v19];
          int64_t v21 = v5 - v10;
          if (v5 != v10)
          {
            memmove(&v10[-8 * v19], v10, v5 - v10);
            char v5 = (char *)a1[1];
          }
          uint64_t v22 = &v5[8 * v18];
          char v5 = &v20[v21];
LABEL_14:
          a1[1] = v22;
          a1[2] = v5;
          goto LABEL_50;
        }
        if (v5 == (char *)*a1) {
          unint64_t v48 = 1;
        }
        else {
          unint64_t v48 = (uint64_t)&v5[-*a1] >> 2;
        }
        uint64_t v49 = (char *)sub_18DEE2FBC(v48);
        unint64_t v50 = &v49[8 * (v48 >> 2)];
        unint64_t v52 = &v49[8 * v51];
        uint64_t v53 = (uint64_t *)a1[1];
        char v5 = v50;
        uint64_t v54 = a1[2] - (void)v53;
        if (v54)
        {
          char v5 = &v50[v54 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v55 = 8 * (v54 >> 3);
          uint64_t v56 = &v49[8 * (v48 >> 2)];
          do
          {
            uint64_t v57 = *v53++;
            *(void *)uint64_t v56 = v57;
            v56 += 8;
            v55 -= 8;
          }
          while (v55);
        }
        goto LABEL_47;
      }
    }
LABEL_50:
    *(void *)char v5 = v11;
    a1[2] += 8;
    goto LABEL_54;
  }
LABEL_55:
  unint64_t v63 = *(void *)&v4[8 * (v9 / 0x2A)] + 96 * (v9 % 0x2A);
  long long v64 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v63 = *(_OWORD *)a2;
  *(_OWORD *)(v63 + 16) = v64;
  *(void *)(v63 + 40) = 0;
  *(void *)(v63 + 48) = 0;
  *(void *)(v63 + 32) = 0;
  *(_OWORD *)(v63 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(v63 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(v63 + 56) = 0;
  *(void *)(v63 + 64) = 0;
  *(void *)(v63 + 72) = 0;
  __n128 result = *(__n128 *)(a2 + 56);
  *(__n128 *)(v63 + 56) = result;
  *(void *)(v63 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  uint64_t v66 = *(void *)(a2 + 80);
  *(void *)(v63 + 85) = *(void *)(a2 + 85);
  *(void *)(v63 + 80) = v66;
  ++a1[5];
  return result;
}

void sub_18E1B2C6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  operator delete(v10);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_18E1B2C9C(void *a1)
{
  unint64_t v2 = a1[5] + a1[4] - 1;
  sub_18E1AB948((void *)(*(void *)(a1[1] + 8 * (v2 / 0x2A)) + 96 * (v2 % 0x2A)));
  uint64_t v3 = a1[2];
  BOOL v4 = v3 == a1[1];
  uint64_t v5 = 42 * ((v3 - a1[1]) >> 3) - 1;
  uint64_t v7 = a1[4];
  uint64_t v6 = a1[5];
  a1[5] = v6 - 1;
  if (v4) {
    uint64_t v5 = 0;
  }
  if ((unint64_t)(v5 - (v6 + v7) - 83) <= 0xFFFFFFFFFFFFFFABLL)
  {
    operator delete(*(void **)(v3 - 8));
    a1[2] -= 8;
  }
}

uint64_t sub_18E1B2D4C(uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    BOOL v4 = (void *)(a1 + 40);
    uint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    BOOL v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = &v2[v5 / 0x2A];
    uint64_t v7 = (char *)*v6 + 96 * (v5 % 0x2A);
    unint64_t v8 = (unint64_t)v2[(*(void *)(a1 + 40) + v5) / 0x2A] + 96 * ((*(void *)(a1 + 40) + v5) % 0x2A);
    if (v7 != (char *)v8)
    {
      do
      {
        sub_18E1AB948(v7);
        v7 += 96;
        if (v7 - (unsigned char *)*v6 == 4032)
        {
          unint64_t v9 = (char *)v6[1];
          ++v6;
          uint64_t v7 = v9;
        }
      }
      while (v7 != (char *)v8);
      unint64_t v2 = *(void ***)(a1 + 8);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
  }
  *BOOL v4 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      unint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 21;
    goto LABEL_14;
  }
  if (v11 == 2)
  {
    uint64_t v12 = 42;
LABEL_14:
    *(void *)(a1 + 32) = v12;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v13 = *v2++;
      operator delete(v13);
    }
    while (v2 != v3);
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v14 = *(void *)(a1 + 16);
    if (v14 != v15) {
      *(void *)(a1 + 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_18E1B2EC8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    sub_18E1AEDC4(&__p, *(char **)a1, *(char **)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
  }
  else
  {
    std::string __p = 0;
    size_t v19 = 0;
    uint64_t v20 = 0;
  }
  if (*(unsigned char *)(a2 + 16))
  {
    sub_18E1AEDC4(&v15, *(char **)a2, *(char **)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    unsigned int v3 = HIBYTE(v17);
    unint64_t v5 = v15;
    size_t v4 = v16;
  }
  else
  {
    size_t v4 = 0;
    unint64_t v5 = 0;
    unsigned int v3 = 0;
    uint64_t v15 = 0;
    size_t v16 = 0;
    uint64_t v17 = 0;
  }
  char v6 = HIBYTE(v20);
  if (v20 >= 0) {
    size_t v7 = HIBYTE(v20);
  }
  else {
    size_t v7 = v19;
  }
  if (v20 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if ((v3 & 0x80u) == 0) {
    size_t v9 = v3;
  }
  else {
    size_t v9 = v4;
  }
  if ((v3 & 0x80u) == 0) {
    unint64_t v10 = (void **)&v15;
  }
  else {
    unint64_t v10 = v5;
  }
  if (v9 >= v7) {
    size_t v11 = v7;
  }
  else {
    size_t v11 = v9;
  }
  unsigned int v12 = memcmp(p_p, v10, v11);
  if ((v3 & 0x80) != 0)
  {
    operator delete(v5);
    if ((v20 & 0x8000000000000000) == 0) {
      goto LABEL_24;
    }
  }
  else if ((v6 & 0x80) == 0)
  {
    goto LABEL_24;
  }
  operator delete(__p);
LABEL_24:
  unsigned int v13 = v9 < v7;
  if (v7 < v9) {
    unsigned int v13 = -1;
  }
  if (v12) {
    return v12;
  }
  else {
    return v13;
  }
}

void sub_18E1B2FDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t swan::FixedLagSmoother::Initialize(uint64_t a1, char a2, uint64_t a3, uint64_t a4, unsigned int a5, double a6, double a7)
{
  uint64_t v12 = 0;
  uint64_t v13 = 102;
  do
  {
    uint64_t v14 = a1 + v12;
    *(_OWORD *)(v14 + 8) = xmmword_18E1F8570;
    *(_OWORD *)(v14 + 336) = xmmword_18E1FD770;
    *(_OWORD *)(a1 + v12 + 424) = xmmword_18E1F8570;
    *(_OWORD *)(v14 + 752) = xmmword_18E1F8570;
    sub_18DFE2CC8(a1 + v12, 0.0);
    sub_18DFE2CC8(a1 + v12 + 328, 0.0);
    sub_18DFE2CC8(a1 + v12 + 416, 0.0);
    sub_18DFE2CC8(a1 + v12 + 744, 0.0);
    *(void *)(v14 + 1072) = 0;
    *(unsigned char *)(v14 + 1080) = 0;
    *(void *)(v14 + 1088) = 0x7FF0000000000000;
    *(unsigned char *)(v14 + 1096) = 0;
    v12 += 1104;
    *(_DWORD *)(v14 + 1100) = 0;
    --v13;
  }
  while (v13);
  sub_18DFE2F24(a1 + 328, a3);
  sub_18DFE2F24(a1 + 416, a4);
  sub_18DFE2F24(a1 + 744, a1 + 416);
  *(double *)(a1 + 1072) = a6;
  *(unsigned char *)(a1 + 1080) = a2;
  if (a5 >= 0x64) {
    int v15 = 100;
  }
  else {
    int v15 = a5;
  }
  *(_DWORD *)(a1 + 1100) = v15;
  *(double *)(a1 + 1088) = a7;
  sub_18DFE2CC8(a1, 0.0);
  sub_18DFE2CC8(a1 + 113272, 0.0);
  sub_18DFE2CC8(a1 + 112616, 0.0);
  *(unsigned char *)(a1 + 1096) = 1;
  sub_18DFE2F24(a1 + 1104, a1);
  sub_18DFE2F24(a1 + 1432, a1 + 328);
  sub_18DFE2F24(a1 + 1520, a1 + 416);
  sub_18DFE2F24(a1 + 1848, a1 + 744);
  *(_OWORD *)(a1 + 2176) = *(_OWORD *)(a1 + 1072);
  *(_OWORD *)(a1 + 2192) = *(_OWORD *)(a1 + 1088);
  *(unsigned char *)(a1 + 112608) = 1;
  return 0;
}

uint64_t swan::FixedLagSmoother::Update(uint64_t a1, char a2, uint64_t a3, uint64_t a4, int a5, double a6, double a7, double a8)
{
  uint64_t v153 = *MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404F08, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB404F08))
  {
    sub_18E1B4538();
    __cxa_atexit((void (*)(void *))sub_18DFECE10, &qword_1EB404F18, &dword_18DEDB000);
    __cxa_guard_release(&qword_1EB404F08);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB404F10, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB404F10))
  {
    sub_18E073A9C((uint64_t)&qword_1EB404F18, (uint64_t)&unk_1EB405060);
    __cxa_atexit((void (*)(void *))sub_18DFECE10, &unk_1EB405060, &dword_18DEDB000);
    __cxa_guard_release(&qword_1EB404F10);
  }
  uint64_t v147 = 0x600000006;
  unint64_t v145 = &unk_1EDD197B8;
  uint64_t v148 = (double *)&v149;
  long long v146 = xmmword_18E1F8570;
  sub_18DFE2CC8((uint64_t)&v145, 0.0);
  uint64_t v142 = 0x600000006;
  uint64_t v140 = &unk_1EDD197B8;
  uint64_t v143 = &v144;
  long long v141 = xmmword_18E1F8570;
  sub_18DFE2CC8((uint64_t)&v140, 0.0);
  int v15 = 0;
  int v16 = HIDWORD(v141);
  int v17 = HIDWORD(v141) + 1;
  uint64_t v18 = 6;
  size_t v19 = v143;
  do
  {
    v19[v15] = 0x3FF0000000000000;
    v15 += v17;
    --v18;
  }
  while (v18);
  *(double *)&uint64_t v20 = a6 - *(double *)(a1 + 2176);
  v19[3 * v16] = v20;
  v19[(4 * v16) | 1] = v20;
  v19[5 * v16 + 2] = v20;
  double v21 = *(double *)&v20 * *(double *)&v20;
  double v22 = fabs(*(double *)&v20 * 0.5);
  int v23 = HIDWORD(v146);
  int v24 = 3 * HIDWORD(v146);
  int v25 = 3 * HIDWORD(v146) + 3;
  uint64_t v26 = v148;
  double v27 = a7 * a7 * v21;
  v148[v25] = v27;
  double v28 = v27 * v22;
  v26[v24] = v28;
  v26[3] = v28;
  double v29 = v22 * v26[v24];
  *uint64_t v26 = v29;
  v26[v23 + 1] = v29;
  v26[4 * v23 + 4] = v26[v25];
  v26[(4 * v23) | 1] = v26[v24];
  v26[v23 + 4] = v26[3];
  double v30 = a8 * a8 * v21;
  v26[5 * v23 + 5] = v30;
  int v31 = 5 * v23 + 2;
  double v32 = v22 * v30;
  v26[v31] = v32;
  v23 *= 2;
  v26[v23 + 5] = v32;
  v26[v23 + 2] = v22 * v26[v31];
  char v134 = 0;
  uint64_t v137 = 0x300000003;
  long long v136 = xmmword_18E1F0010;
  uint64_t v135 = &unk_1EDD18EE8;
  uint64_t v138 = &v139;
  uint64_t v133 = &unk_1EDD0AB68;
  uint64_t v33 = *(float64x2_t **)(a1 + 1464);
  float64x2_t v151 = *v33;
  double v152 = v33[1].f64[0];
  cnnavigation::ECEFToENU(&v151, 1, 0, &v151, 1, (uint64_t)v150, (uint64_t)&v133, v152);
  uint64_t v130 = 0x300000003;
  long long v129 = xmmword_18E1F0010;
  size_t v128 = &unk_1EDD18EE8;
  unint64_t v131 = &v132;
  if (v134) {
    sub_18DFE2F24((uint64_t)&v128, (uint64_t)&v135);
  }
  uint64_t v125 = 0x600000006;
  uint64_t v123 = &unk_1EDD197B8;
  uint64_t v126 = &v127;
  long long v124 = xmmword_18E1F8570;
  sub_18DFE2CC8((uint64_t)&v123, 0.0);
  uint64_t v34 = v131;
  uint64_t v35 = v126;
  *uint64_t v126 = *v131;
  uint64_t v36 = SHIDWORD(v129);
  uint64_t v37 = SHIDWORD(v124);
  v35[SHIDWORD(v124)] = v34[SHIDWORD(v129)];
  v35[2 * v37] = v34[2 * v36];
  v35[1] = v34[1];
  int v38 = v36 + 1;
  v35[(int)v37 + 1] = v34[(int)v36 + 1];
  uint64_t v39 = &v34[2 * (int)v36];
  BOOL v40 = &v35[2 * (int)v37];
  v40[1] = v39[1];
  uint64_t v35[2] = v34[2];
  int v41 = v36 + 2;
  v35[(int)v37 + 2] = v34[(int)v36 + 2];
  void v40[2] = v39[2];
  LODWORD(v40) = 3 * v37;
  v35[(int)v40 + 3] = *v34;
  v35[(int)((4 * v37) | 3)] = v34[v36];
  uint64_t v42 = v34[2 * v36];
  LODWORD(v36) = 5 * v37;
  v35[5 * (int)v37 + 3] = v42;
  v35[(int)v40 + 4] = v34[1];
  LODWORD(v37) = 4 * v37;
  v35[(int)v37 + 4] = v34[v38];
  v35[(int)v36 + 4] = v39[1];
  v35[(int)v40 + 5] = v34[2];
  v35[(int)v37 + 5] = v34[v41];
  v35[(int)v36 + 5] = v39[2];
  int v43 = DWORD1(v124);
  int v44 = v124;
  uint64_t v110 = 0x600000006;
  char v108 = &unk_1EDD197B8;
  int8x16_t v111 = v112;
  *(void *)&long long v109 = __PAIR64__(v124, DWORD1(v124));
  DWORD2(v109) = v124 * DWORD1(v124);
  HIDWORD(v109) = DWORD1(v124);
  if (DWORD1(v124))
  {
    int v45 = 0;
    int v46 = 0;
    int v47 = HIDWORD(v124);
    unint64_t v48 = v126;
    do
    {
      int v49 = v45;
      int v50 = v46;
      for (int i = v44; i; --i)
      {
        v112[v50] = v48[v49];
        v50 += v43;
        ++v49;
      }
      ++v46;
      v45 += v47;
    }
    while (v46 != v43);
  }
  uint64_t v115 = 0x600000006;
  long long v114 = xmmword_18E1F8570;
  char v113 = &unk_1EDD197B8;
  uint64_t v116 = v117;
  sub_18DFE2B44((uint64_t)&v108, (uint64_t)&v145, (uint64_t)&v113);
  uint64_t v52 = a4;
  uint64_t v120 = 0x600000006;
  long long v119 = xmmword_18E1F8570;
  uint64_t v118 = &unk_1EDD197B8;
  long long v121 = v122;
  sub_18DFE2B44((uint64_t)&v113, (uint64_t)&v123, (uint64_t)&v118);
  uint64_t v53 = a1 + 112944;
  sub_18DFE2F24(a1 + 112944, (uint64_t)&v118);
  uint64_t v54 = a1 + 112616;
  uint64_t v120 = 0x600000006;
  long long v119 = xmmword_18E1F8570;
  uint64_t v118 = &unk_1EDD197B8;
  long long v121 = v122;
  sub_18DFE2B44((uint64_t)&v140, a1 + 112616, (uint64_t)&v118);
  sub_18DFE2F24(a1, (uint64_t)&v118);
  uint64_t v110 = 0x600000006;
  long long v109 = xmmword_18E1F8570;
  char v108 = &unk_1EDD197B8;
  int8x16_t v111 = v112;
  sub_18DFE2B44(a1, (uint64_t)&qword_1EB404F18, (uint64_t)&v108);
  uint64_t v78 = a1 + 1104;
  uint64_t v55 = a1 + 1432;
  uint64_t v115 = 0x600000006;
  long long v114 = xmmword_18E1F8570;
  char v113 = &unk_1EDD197B8;
  uint64_t v116 = v117;
  sub_18DFE2AA8((uint64_t)&v140, (uint64_t)&v108, (uint64_t)&v113);
  int v56 = DWORD1(v114);
  int v57 = v114;
  uint64_t v120 = 0x600000006;
  uint64_t v118 = &unk_1EDD197B8;
  long long v121 = v122;
  *(void *)&long long v119 = __PAIR64__(v114, DWORD1(v114));
  DWORD2(v119) = v114 * DWORD1(v114);
  HIDWORD(v119) = DWORD1(v114);
  if (DWORD1(v114))
  {
    int v58 = 0;
    int v59 = 0;
    int v60 = HIDWORD(v114);
    uint64_t v61 = v116;
    do
    {
      int v62 = v58;
      int v63 = v59;
      for (int j = v57; j; --j)
      {
        v122[v63] = *(void *)&v61[8 * v62];
        v63 += v56;
        ++v62;
      }
      ++v59;
      v58 += v60;
    }
    while (v59 != v56);
  }
  uint64_t v81 = a1;
  uint64_t v65 = a1 + 110816;
  uint64_t v66 = -101;
  long long v67 = xmmword_18E1F8570;
  do
  {
    if (*(unsigned char *)(v65 + 680))
    {
      uint64_t v115 = 0x600000006;
      long long v114 = v67;
      char v113 = &unk_1EDD197B8;
      uint64_t v116 = v117;
      sub_18DFE2B44(v65, (uint64_t)&v118, (uint64_t)&v113);
      sub_18DFE2F24(v65 + 1104, (uint64_t)&v113);
      long long v67 = xmmword_18E1F8570;
    }
    v65 -= 1104;
  }
  while (!__CFADD__(v66++, 1));
  uint64_t v77 = v55;
  uint64_t v110 = 0x100000006;
  long long v109 = xmmword_18E1FD770;
  char v108 = &unk_1EDD19728;
  int8x16_t v111 = v112;
  sub_18DFE2B44((uint64_t)&v140, v81 + 328, (uint64_t)&v108);
  uint64_t v105 = 0x100000006;
  long long v104 = xmmword_18E1FD770;
  uint64_t v103 = &unk_1EDD19728;
  uint64_t v106 = v107;
  uint64_t v82 = v81 + 113272;
  sub_18DFE2B44(v81, v81 + 113272, (uint64_t)&v103);
  uint64_t v115 = 0x100000006;
  long long v114 = xmmword_18E1FD770;
  char v113 = &unk_1EDD19728;
  uint64_t v116 = v117;
  sub_18DFEF1F4((uint64_t)&v108, (uint64_t)&v103, (uint64_t)&v113);
  sub_18DFE2F24(v81 + 328, (uint64_t)&v113);
  uint64_t v105 = 0x600000006;
  long long v104 = xmmword_18E1F8570;
  uint64_t v103 = &unk_1EDD197B8;
  uint64_t v106 = v107;
  uint64_t v79 = v81 + 416;
  sub_18DFE2B44((uint64_t)&v140, v81 + 416, (uint64_t)&v103);
  uint64_t v110 = 0x600000006;
  long long v109 = xmmword_18E1F8570;
  char v108 = &unk_1EDD197B8;
  int8x16_t v111 = v112;
  sub_18DFE2B44((uint64_t)&v103, (uint64_t)&v118, (uint64_t)&v108);
  uint64_t v115 = 0x600000006;
  long long v114 = xmmword_18E1F8570;
  char v113 = &unk_1EDD197B8;
  uint64_t v116 = v117;
  sub_18DFEF1F4((uint64_t)&v108, v53, (uint64_t)&v113);
  sub_18DFE2F24(v81 + 416, (uint64_t)&v113);
  sub_18DFE2F24(v81 + 744, v81 + 416);
  *(unsigned char *)(v81 + 1096) = 1;
  *(_DWORD *)(v81 + 1100) = a5;
  *(double *)(v81 + 1072) = a6;
  uint64_t v105 = 0x600000006;
  long long v104 = xmmword_18E1F8570;
  uint64_t v103 = &unk_1EDD197B8;
  uint64_t v106 = v107;
  sub_18DFE2B44((uint64_t)&qword_1EB404F18, v81 + 416, (uint64_t)&v103);
  uint64_t v110 = 0x600000006;
  long long v109 = xmmword_18E1F8570;
  char v108 = &unk_1EDD197B8;
  int8x16_t v111 = v112;
  sub_18DFE2B44((uint64_t)&v103, (uint64_t)&unk_1EB405060, (uint64_t)&v108);
  uint64_t v115 = 0x600000006;
  long long v114 = xmmword_18E1F8570;
  char v113 = &unk_1EDD197B8;
  uint64_t v116 = v117;
  sub_18DFEF1F4(v52, (uint64_t)&v108, (uint64_t)&v113);
  uint64_t v105 = 0x600000006;
  long long v104 = xmmword_18E1F8570;
  uint64_t v103 = &unk_1EDD197B8;
  uint64_t v106 = v107;
  uint64_t v95 = 0x100000006;
  long long v94 = xmmword_18E1FD770;
  unint64_t v93 = &unk_1EDD19758;
  uint64_t v96 = v97;
  uint64_t v90 = 0x100000006;
  unint64_t v88 = &unk_1EDD19758;
  long long v89 = xmmword_18E1FD770;
  uint64_t v91 = v92;
  uint64_t v100 = 0x100000018;
  long long v99 = xmmword_18E1FD9C0;
  uint64_t v98 = &unk_1EDD18618;
  char v101 = v102;
  double v69 = sub_18E01D7FC((uint64_t)&v113, (uint64_t)&v93, (uint64_t)&v88, (uint64_t)&v98, (uint64_t)&v103);
  uint64_t v110 = 0x600000006;
  long long v109 = xmmword_18E1F8570;
  char v108 = &unk_1EDD197B8;
  int8x16_t v111 = v112;
  sub_18DFE2B44((uint64_t)&unk_1EB405060, (uint64_t)&v103, (uint64_t)&v108);
  if (v69 > 100000000.0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v105 = 0x600000006;
  long long v104 = xmmword_18E1F8570;
  uint64_t v103 = &unk_1EDD197B8;
  uint64_t v106 = v107;
  sub_18DFE2B44(v81 + 416, (uint64_t)&v108, (uint64_t)&v103);
  sub_18DFE2F24(v54, (uint64_t)&v103);
  uint64_t v100 = 0x100000006;
  long long v99 = xmmword_18E1FD770;
  uint64_t v98 = &unk_1EDD19728;
  char v101 = v102;
  sub_18DFE2B44((uint64_t)&qword_1EB404F18, v81 + 328, (uint64_t)&v98);
  uint64_t v105 = 0x100000006;
  long long v104 = xmmword_18E1FD770;
  uint64_t v103 = &unk_1EDD19728;
  uint64_t v106 = v107;
  sub_18DFE2AA8(a3, (uint64_t)&v98, (uint64_t)&v103);
  sub_18DFE2F24(v82, (uint64_t)&v103);
  uint64_t v71 = v81 + 110728;
  for (unint64_t k = 101; k >= 2; --k)
  {
    if (*(unsigned char *)(v71 + 768))
    {
      *(void *)(v71 + 1848) = *(void *)(v71 + 744);
      *(unsigned char *)(v71 + 1856) = *(unsigned char *)(v71 + 752);
      *(void *)(v71 + 1864) = *(void *)(v71 + 760);
      *(_DWORD *)(v71 + 1876) = *(_DWORD *)(v71 + 772);
      uint64_t v105 = 0x600000006;
      long long v104 = xmmword_18E1F8570;
      uint64_t v103 = &unk_1EDD197B8;
      uint64_t v106 = v107;
      sub_18DFE2B44(v71 + 88, (uint64_t)&v108, (uint64_t)&v103);
      sub_18DFE2F24(v71 + 776, (uint64_t)&v103);
      uint64_t v95 = 0x600000006;
      long long v94 = xmmword_18E1F8570;
      unint64_t v93 = &unk_1EDD197B8;
      uint64_t v96 = v97;
      sub_18DFE2B44(v71 + 88, (uint64_t)&unk_1EB405060, (uint64_t)&v93);
      unsigned int v73 = *(_DWORD *)(v71 + 788);
      unsigned int v74 = *(_DWORD *)(v71 + 784);
      uint64_t v90 = 0x600000006;
      unint64_t v88 = &unk_1EDD197B8;
      *(void *)&long long v89 = __PAIR64__(v74, v73);
      DWORD2(v89) = v74 * v73;
      HIDWORD(v89) = v73;
      uint64_t v91 = v92;
      sub_18DFE2C64(v71 + 776, (uint64_t)&v88);
      uint64_t v100 = 0x600000006;
      long long v99 = xmmword_18E1F8570;
      uint64_t v98 = &unk_1EDD197B8;
      char v101 = v102;
      sub_18DFE2B44((uint64_t)&v93, (uint64_t)&v88, (uint64_t)&v98);
      uint64_t v105 = 0x600000006;
      long long v104 = xmmword_18E1F8570;
      uint64_t v103 = &unk_1EDD197B8;
      uint64_t v106 = v107;
      sub_18DFE2AA8(v71 + 416, (uint64_t)&v98, (uint64_t)&v103);
      sub_18DFE2F24(v71 + 1520, (uint64_t)&v103);
      LOBYTE(v93) = 0;
      uint64_t v85 = 0x600000006;
      unint64_t v83 = &unk_1EDD197B8;
      long long v84 = xmmword_18E1F8570;
      uint64_t v86 = &v87;
      sub_18DFEEFE8(v71 + 1520, (uint64_t)&v83, (BOOL *)&v93);
      unint64_t v83 = &unk_1EDD17478;
      if (!(_BYTE)v93) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v100 = 0x100000006;
      long long v99 = xmmword_18E1FD770;
      uint64_t v98 = &unk_1EDD19728;
      char v101 = v102;
      sub_18DFE2B44(v71 + 776, v82, (uint64_t)&v98);
      uint64_t v105 = 0x100000006;
      long long v104 = xmmword_18E1FD770;
      uint64_t v103 = &unk_1EDD19728;
      uint64_t v106 = v107;
      sub_18DFEF1F4(v71, (uint64_t)&v98, (uint64_t)&v103);
      sub_18DFE2F24(v71 + 1104, (uint64_t)&v103);
      *(unsigned char *)(v71 + 1872) = 1;
    }
    v71 -= 1104;
  }
  *(double *)(v81 + 2176) = a6;
  *(unsigned char *)(v81 + 2184) = a2;
  *(double *)(v81 + 2192) = a7;
  *(_DWORD *)(v81 + 2204) = a5;
  uint64_t v105 = 0x600000006;
  long long v104 = xmmword_18E1F8570;
  uint64_t v103 = &unk_1EDD197B8;
  uint64_t v106 = v107;
  sub_18DFE2B44(v79, (uint64_t)&v108, (uint64_t)&v103);
  sub_18DFE2F24(v78, (uint64_t)&v103);
  uint64_t v95 = 0x600000006;
  long long v94 = xmmword_18E1F8570;
  unint64_t v93 = &unk_1EDD197B8;
  uint64_t v96 = v97;
  sub_18DFE2B44(v79, (uint64_t)&unk_1EB405060, (uint64_t)&v93);
  unsigned int v75 = *(_DWORD *)(v81 + 1116);
  unsigned int v76 = *(_DWORD *)(v81 + 1112);
  uint64_t v90 = 0x600000006;
  unint64_t v88 = &unk_1EDD197B8;
  *(void *)&long long v89 = __PAIR64__(v76, v75);
  DWORD2(v89) = v76 * v75;
  HIDWORD(v89) = v75;
  uint64_t v91 = v92;
  sub_18DFE2C64(v78, (uint64_t)&v88);
  uint64_t v100 = 0x600000006;
  long long v99 = xmmword_18E1F8570;
  uint64_t v98 = &unk_1EDD197B8;
  char v101 = v102;
  sub_18DFE2B44((uint64_t)&v93, (uint64_t)&v88, (uint64_t)&v98);
  uint64_t v105 = 0x600000006;
  long long v104 = xmmword_18E1F8570;
  uint64_t v103 = &unk_1EDD197B8;
  uint64_t v106 = v107;
  sub_18DFE2AA8(v81 + 744, (uint64_t)&v98, (uint64_t)&v103);
  sub_18DFE2F24(v81 + 1848, (uint64_t)&v103);
  uint64_t v100 = 0x100000006;
  long long v99 = xmmword_18E1FD770;
  uint64_t v98 = &unk_1EDD19728;
  char v101 = v102;
  sub_18DFE2B44(v78, v82, (uint64_t)&v98);
  uint64_t v105 = 0x100000006;
  long long v104 = xmmword_18E1FD770;
  uint64_t v103 = &unk_1EDD19728;
  uint64_t v106 = v107;
  sub_18DFEF1F4(v81 + 328, (uint64_t)&v98, (uint64_t)&v103);
  sub_18DFE2F24(v77, (uint64_t)&v103);
  uint64_t result = 0;
  *(unsigned char *)(v81 + 2200) = 1;
  return result;
}

void sub_18E1B44B0(_Unwind_Exception *a1)
{
}

uint64_t sub_18E1B4538()
{
  qword_1EB404F30 = 0x600000006;
  qword_1EB404F18 = (uint64_t)&unk_1EDD197B8;
  qword_1EB404F38 = (uint64_t)&unk_1EB404F40;
  unk_1EB404F20 = xmmword_18E1F8570;
  uint64_t result = sub_18DFE2CC8((uint64_t)&qword_1EB404F18, 0.0);
  int v1 = 0;
  int v2 = dword_1EB404F2C + 1;
  uint64_t v3 = qword_1EB404F38;
  uint64_t v4 = 6;
  do
  {
    *(void *)(v3 + 8 * v1) = 0x3FF0000000000000;
    v1 += v2;
    --v4;
  }
  while (v4);
  return result;
}

uint64_t swan::FixedLagSmoother::ExtractOutput(uint64_t a1, char **a2, unint64_t *a3, char **a4, void *a5, void *a6, int a7)
{
  uint64_t v13 = (void (***)(void))*a5;
  uint64_t v12 = a5[1];
  if (v12 != *a5)
  {
    uint64_t v14 = v12 - 88;
    int v15 = (void (***)(void))(v12 - 88);
    int v16 = (void (***)(void))(v12 - 88);
    do
    {
      int v17 = *v16;
      v16 -= 11;
      (*v17)(v15);
      v14 -= 88;
      BOOL v25 = v15 == v13;
      int v15 = v16;
    }
    while (!v25);
  }
  a5[1] = v13;
  size_t v19 = (void (***)(void))*a6;
  uint64_t v18 = a6[1];
  if (v18 != *a6)
  {
    uint64_t v20 = v18 - 328;
    double v21 = (void (***)(void))(v18 - 328);
    do
    {
      (**v21)(v21);
      v20 -= 328;
      BOOL v25 = v21 == v19;
      v21 -= 41;
    }
    while (!v25);
  }
  a6[1] = v19;
  a4[1] = *a4;
  a2[1] = *a2;
  uint64_t v94 = (uint64_t)(a4 + 2);
  uint64_t v22 = 102;
  uint64_t v23 = 101;
  int v24 = a3;
  a3[1] = *a3;
  uint64_t v98 = a4;
  while (1)
  {
    uint64_t v100 = a1 + 1104 * v23;
    if (*(unsigned char *)(v100 + 1096)) {
      break;
    }
LABEL_97:
    uint64_t v22 = v23--;
    if (!v23) {
      return 0;
    }
  }
  BOOL v25 = v22 - 2 < (unint64_t)*(unsigned int *)(a1 + 1104 * v23 + 1100) && a7 == 0;
  if (!v25)
  {
    uint64_t v26 = (void *)(a1 + 1104 * v23 + 1072);
    double v28 = a2[1];
    unint64_t v27 = (unint64_t)a2[2];
    if ((unint64_t)v28 >= v27)
    {
      double v30 = *a2;
      uint64_t v31 = (v28 - *a2) >> 3;
      unint64_t v32 = v31 + 1;
      if ((unint64_t)(v31 + 1) >> 61) {
        sub_18DEE1FC8();
      }
      uint64_t v33 = v27 - (void)v30;
      if (v33 >> 2 > v32) {
        unint64_t v32 = v33 >> 2;
      }
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v34 = v32;
      }
      if (v34)
      {
        uint64_t v35 = (char *)sub_18DEDF808((uint64_t)(a2 + 2), v34);
        double v30 = *a2;
        double v28 = a2[1];
      }
      else
      {
        uint64_t v35 = 0;
      }
      uint64_t v36 = &v35[8 * v31];
      *(void *)uint64_t v36 = *v26;
      double v29 = v36 + 8;
      while (v28 != v30)
      {
        uint64_t v37 = *((void *)v28 - 1);
        v28 -= 8;
        *((void *)v36 - 1) = v37;
        v36 -= 8;
      }
      *a2 = v36;
      a2[1] = v29;
      a2[2] = &v35[8 * v34];
      if (v30) {
        operator delete(v30);
      }
    }
    else
    {
      *(void *)double v28 = *v26;
      double v29 = v28 + 8;
    }
    a2[1] = v29;
    int v38 = (unsigned char *)(a1 + 1104 * v23 + 1080);
    BOOL v40 = (unsigned char *)v24[1];
    unint64_t v39 = v24[2];
    if ((unint64_t)v40 >= v39)
    {
      unint64_t v42 = *v24;
      int v43 = &v40[-*v24];
      unint64_t v44 = (unint64_t)(v43 + 1);
      if ((uint64_t)(v43 + 1) < 0) {
        sub_18DEE1FC8();
      }
      unint64_t v45 = v39 - v42;
      if (2 * v45 > v44) {
        unint64_t v44 = 2 * v45;
      }
      if (v45 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v46 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v46 = v44;
      }
      if (v46) {
        int v47 = (char *)operator new(v46);
      }
      else {
        int v47 = 0;
      }
      unint64_t v48 = &v43[(void)v47];
      v43[(void)v47] = *v38;
      uint64_t v41 = (uint64_t)&v43[(void)v47 + 1];
      if (v40 == (unsigned char *)v42)
      {
        int v24 = a3;
      }
      else
      {
        int v49 = &v40[~v42];
        int v24 = a3;
        do
        {
          char v50 = *--v40;
          (v49--)[(void)v47] = v50;
        }
        while (v40 != (unsigned char *)v42);
        unint64_t v48 = v47;
      }
      *int v24 = (unint64_t)v48;
      v24[1] = v41;
      uint64_t v24[2] = (unint64_t)&v47[v46];
      if (v42) {
        operator delete((void *)v42);
      }
      a4 = v98;
    }
    else
    {
      *BOOL v40 = *v38;
      uint64_t v41 = (uint64_t)(v40 + 1);
    }
    v24[1] = v41;
    uint64_t v51 = (void *)(a1 + 1104 * v23 + 1088);
    uint64_t v53 = a4[1];
    unint64_t v52 = (unint64_t)a4[2];
    if ((unint64_t)v53 >= v52)
    {
      uint64_t v55 = *a4;
      uint64_t v56 = (v53 - *a4) >> 3;
      unint64_t v57 = v56 + 1;
      if ((unint64_t)(v56 + 1) >> 61) {
        sub_18DEE1FC8();
      }
      uint64_t v58 = v52 - (void)v55;
      if (v58 >> 2 > v57) {
        unint64_t v57 = v58 >> 2;
      }
      if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v59 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v59 = v57;
      }
      if (v59)
      {
        int v60 = (char *)sub_18DEDF808(v94, v59);
        uint64_t v55 = *a4;
        uint64_t v53 = a4[1];
      }
      else
      {
        int v60 = 0;
      }
      uint64_t v61 = &v60[8 * v56];
      *(void *)uint64_t v61 = *v51;
      uint64_t v54 = v61 + 8;
      while (v53 != v55)
      {
        uint64_t v62 = *((void *)v53 - 1);
        v53 -= 8;
        *((void *)v61 - 1) = v62;
        v61 -= 8;
      }
      *a4 = v61;
      a4[1] = v54;
      a4[2] = &v60[8 * v59];
      if (v55) {
        operator delete(v55);
      }
    }
    else
    {
      *(void *)uint64_t v53 = *v51;
      uint64_t v54 = v53 + 8;
    }
    a4[1] = v54;
    unint64_t v64 = a5[1];
    unint64_t v63 = a5[2];
    if (v64 >= v63)
    {
      uint64_t v66 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v64 - *a5) >> 3);
      unint64_t v67 = v66 + 1;
      if ((unint64_t)(v66 + 1) > 0x2E8BA2E8BA2E8BALL) {
        sub_18DEE1FC8();
      }
      unint64_t v68 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v63 - *a5) >> 3);
      if (2 * v68 > v67) {
        unint64_t v67 = 2 * v68;
      }
      if (v68 >= 0x1745D1745D1745DLL) {
        unint64_t v69 = 0x2E8BA2E8BA2E8BALL;
      }
      else {
        unint64_t v69 = v67;
      }
      uint64_t v103 = a5 + 2;
      if (v69) {
        uint64_t v70 = (char *)sub_18E1B4E78((uint64_t)(a5 + 2), v69);
      }
      else {
        uint64_t v70 = 0;
      }
      char v101 = v70;
      *(void *)BOOL v102 = &v70[88 * v66];
      *(void *)&v102[8] = *(void *)v102;
      *(void *)&v102[16] = &v70[88 * v69];
      sub_18E1B4D28(*(uint64_t *)v102, a1 + 1104 * v23 + 328);
      uint64_t v71 = 0;
      uint64_t v72 = *(void *)v102;
      *(void *)&v102[8] += 88;
      unsigned int v74 = (void (***)(void))*a5;
      for (uint64_t i = a5[1]; (void (***)(void))(i + v71) != v74; sub_18E1B4D28(v71 + v72, v71 + i))
        v71 -= 88;
      uint64_t v75 = a5[2];
      long long v76 = *(_OWORD *)&v102[8];
      unint64_t v95 = *(void *)&v102[8];
      long long v77 = *(_OWORD *)a5;
      *a5 = v72 + v71;
      *(_OWORD *)BOOL v102 = v77;
      *(_OWORD *)(a5 + 1) = v76;
      *(void *)&v102[16] = v75;
      char v101 = (char *)v77;
      sub_18E1B4EC4((uint64_t)&v101);
      unint64_t v65 = v95;
      int v24 = a3;
    }
    else
    {
      sub_18E1B4D28(a5[1], a1 + 1104 * v23 + 328);
      unint64_t v65 = v64 + 88;
      a5[1] = v64 + 88;
    }
    a5[1] = v65;
    unint64_t v79 = a6[1];
    unint64_t v78 = a6[2];
    if (v79 >= v78)
    {
      unint64_t v81 = 0x8F9C18F9C18F9C19 * ((uint64_t)(v79 - *a6) >> 3);
      unint64_t v82 = v81 + 1;
      if (v81 + 1 > 0xC7CE0C7CE0C7CELL) {
        sub_18DEE1FC8();
      }
      unint64_t v83 = 0x8F9C18F9C18F9C19 * ((uint64_t)(v78 - *a6) >> 3);
      if (2 * v83 > v82) {
        unint64_t v82 = 2 * v83;
      }
      if (v83 >= 0x63E7063E7063E7) {
        unint64_t v84 = 0xC7CE0C7CE0C7CELL;
      }
      else {
        unint64_t v84 = v82;
      }
      uint64_t v103 = a6 + 2;
      a4 = v98;
      if (v84) {
        uint64_t v85 = (char *)sub_18E1B4F30((uint64_t)(a6 + 2), v84);
      }
      else {
        uint64_t v85 = 0;
      }
      char v101 = v85;
      *(void *)BOOL v102 = &v85[328 * v81];
      *(void *)&v102[8] = *(void *)v102;
      *(void *)&v102[16] = &v85[328 * v84];
      sub_18E074428(*(uint64_t *)v102, a1 + 1104 * v23 + 744);
      uint64_t v86 = 0;
      uint64_t v87 = *(void *)v102;
      *(void *)&v102[8] += 328;
      long long v89 = (void (***)(void))*a6;
      for (uint64_t j = a6[1]; (void (***)(void))(j + v86) != v89; sub_18E074428(v86 + v87, v86 + j))
        v86 -= 328;
      uint64_t v90 = a6[2];
      long long v91 = *(_OWORD *)&v102[8];
      unint64_t v96 = *(void *)&v102[8];
      long long v92 = *(_OWORD *)a6;
      *a6 = v87 + v86;
      *(_OWORD *)BOOL v102 = v92;
      *(_OWORD *)(a6 + 1) = v91;
      *(void *)&v102[16] = v90;
      char v101 = (char *)v92;
      sub_18E1B4F7C((uint64_t)&v101);
      unint64_t v80 = v96;
      int v24 = a3;
    }
    else
    {
      sub_18E074428(a6[1], a1 + 1104 * v23 + 744);
      unint64_t v80 = v79 + 328;
      a6[1] = v79 + 328;
      a4 = v98;
    }
    a6[1] = v80;
    *(unsigned char *)(v100 + 1096) = 0;
    goto LABEL_97;
  }
  return 0;
}

void sub_18E1B4C64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  sub_18E1B4F7C((uint64_t)va);
  _Unwind_Resume(a1);
}

__n128 sub_18E1B4D28(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0x100000006;
  *(void *)(a1 + 24) = 0x100000006;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EDD19728;
  if (a1 == a2)
  {
    int v17 = "this != &(A)";
    int v18 = 603;
    goto LABEL_16;
  }
  int v3 = *(_DWORD *)(a2 + 8);
  int v4 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = (v4 * v3);
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  char v6 = (unint64_t *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 6u)
  {
    int v17 = "this->max_num_rows_ >= A.num_rows_";
    int v18 = 616;
    goto LABEL_16;
  }
  if (*(_DWORD *)(a2 + 12) >= 2u)
  {
    int v17 = "this->max_num_cols_ >= A.num_cols_";
    int v18 = 617;
LABEL_16:
    __assert_rtn("CNMatrix", "cnmatrix.h", v18, v17);
  }
  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    size_t v11 = *(long long **)(a2 + 32);
    uint64_t v12 = (v7 - 1) >> 1;
    uint64_t v13 = v11;
    uint64_t v14 = (_OWORD *)(a1 + 40);
    do
    {
      long long v15 = *v13++;
      *v14++ = v15;
      --v12;
    }
    while (v12);
    uint64_t v16 = v10;
    __n128 result = *(__n128 *)((char *)v11 + v16 * 8);
    *(__n128 *)&v6[v16] = result;
  }
  else if ((int)v5 >= 1)
  {
    unint64_t v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *v6++ = v9;
      --v5;
    }
    while (v5);
  }
  return result;
}

void sub_18E1B4E58(_Unwind_Exception *a1)
{
  *int v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

void *sub_18E1B4E78(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2E8BA2E8BA2E8BBLL) {
    sub_18DEDF7D4();
  }
  return operator new(88 * a2);
}

uint64_t sub_18E1B4EC4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    int v4 = *(void (***)(void))(i - 88);
    *(void *)(a1 + 16) = i - 88;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_18E1B4F30(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xC7CE0C7CE0C7CFLL) {
    sub_18DEDF7D4();
  }
  return operator new(328 * a2);
}

uint64_t sub_18E1B4F7C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 328;
    (**(void (***)(void))(i - 328))();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t swan::RouteSmoother::ConfigureFromFile(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    a2 = *(void *)a2;
  }
  if (sub_18E19EE2C(a1, a2, 0)) {
    return (*(char *)(a1 + 296) - 1);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t swan::RouteSmoother::Configure(uint64_t a1, uint64_t a2)
{
  std::string::operator=((std::string *)(a1 + 8), (const std::string *)(a2 + 8));
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  std::string::operator=((std::string *)(a1 + 40), (const std::string *)(a2 + 40));
  long long v4 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v4;
  long long v6 = *(_OWORD *)(a2 + 112);
  long long v5 = *(_OWORD *)(a2 + 128);
  long long v7 = *(_OWORD *)(a2 + 96);
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 112) = v6;
  *(_OWORD *)(a1 + 128) = v5;
  *(_OWORD *)(a1 + 96) = v7;
  uint64_t v71 = a1;
  uint64_t v72 = a2;
  if (a1 == a2) {
    goto LABEL_119;
  }
  unint64_t v8 = (uint64_t **)(a1 + 152);
  unint64_t v9 = *(void **)(a2 + 152);
  uint64_t v10 = (void *)(v72 + 160);
  if (*(void *)(a1 + 168))
  {
    uint64_t v12 = (uint64_t **)(a1 + 160);
    uint64_t v11 = *(void *)(v71 + 160);
    uint64_t v13 = *(void *)(v71 + 152);
    *(void *)(v71 + 152) = v71 + 160;
    *(void *)(v11 + 16) = 0;
    *(void *)(v71 + 160) = 0;
    *(void *)(v71 + 168) = 0;
    if (*(void *)(v13 + 8)) {
      uint64_t v14 = *(void *)(v13 + 8);
    }
    else {
      uint64_t v14 = v13;
    }
    if (!v14)
    {
      int v24 = 0;
LABEL_32:
      sub_18DF064FC(v24);
      goto LABEL_33;
    }
    long long v15 = sub_18E1B74B8(v14);
    if (v9 == v10)
    {
      int v17 = (void *)v14;
    }
    else
    {
      uint64_t v16 = v9;
      do
      {
        int v17 = v15;
        unsigned int v18 = *((unsigned __int8 *)v16 + 28);
        *(unsigned char *)(v14 + 28) = v18;
        *(_DWORD *)(v14 + 32) = *((_DWORD *)v16 + 8);
        size_t v19 = *v12;
        uint64_t v20 = (uint64_t **)(v71 + 160);
        double v21 = (uint64_t **)(v71 + 160);
        if (*v12)
        {
          do
          {
            while (1)
            {
              uint64_t v20 = (uint64_t **)v19;
              if (v18 >= *((unsigned __int8 *)v19 + 28)) {
                break;
              }
              size_t v19 = (uint64_t *)*v19;
              double v21 = v20;
              if (!*v20) {
                goto LABEL_15;
              }
            }
            size_t v19 = (uint64_t *)v19[1];
          }
          while (v19);
          double v21 = v20 + 1;
        }
LABEL_15:
        sub_18E01BD84(v8, (uint64_t)v20, v21, (uint64_t *)v14);
        if (v15) {
          long long v15 = sub_18E1B74B8((uint64_t)v15);
        }
        else {
          long long v15 = 0;
        }
        uint64_t v22 = (void *)v16[1];
        if (v22)
        {
          do
          {
            unint64_t v9 = v22;
            uint64_t v22 = (void *)*v22;
          }
          while (v22);
        }
        else
        {
          do
          {
            unint64_t v9 = (void *)v16[2];
            BOOL v23 = *v9 == (void)v16;
            uint64_t v16 = v9;
          }
          while (!v23);
        }
        if (!v17) {
          break;
        }
        uint64_t v14 = (uint64_t)v17;
        uint64_t v16 = v9;
      }
      while (v9 != v10);
    }
    sub_18DF064FC(v17);
    if (v15)
    {
      for (uint64_t i = (void *)v15[2]; i; uint64_t i = (void *)i[2])
        long long v15 = i;
      int v24 = v15;
      goto LABEL_32;
    }
  }
LABEL_33:
  if (v9 != v10)
  {
    uint64_t v26 = (uint64_t **)(v71 + 160);
    do
    {
      uint64_t v27 = *(void *)((char *)v9 + 28);
      double v28 = (uint64_t *)operator new(0x28uLL);
      *(uint64_t *)((char *)v28 + 28) = v27;
      double v29 = *v26;
      double v30 = (uint64_t **)(v71 + 160);
      uint64_t v31 = (uint64_t **)(v71 + 160);
      if (*v26)
      {
        do
        {
          while (1)
          {
            double v30 = (uint64_t **)v29;
            if (*((unsigned __int8 *)v29 + 28) <= v27) {
              break;
            }
            double v29 = (uint64_t *)*v29;
            uint64_t v31 = v30;
            if (!*v30) {
              goto LABEL_41;
            }
          }
          double v29 = (uint64_t *)v29[1];
        }
        while (v29);
        uint64_t v31 = v30 + 1;
      }
LABEL_41:
      sub_18E01BD84(v8, (uint64_t)v30, v31, v28);
      unint64_t v32 = (void *)v9[1];
      if (v32)
      {
        do
        {
          uint64_t v33 = v32;
          unint64_t v32 = (void *)*v32;
        }
        while (v32);
      }
      else
      {
        do
        {
          uint64_t v33 = (void *)v9[2];
          BOOL v23 = *v33 == (void)v9;
          unint64_t v9 = v33;
        }
        while (!v23);
      }
      unint64_t v9 = v33;
    }
    while (v33 != v10);
  }
  sub_18E1B750C((uint64_t **)(v71 + 176), *(void **)(v72 + 176), (void *)(v72 + 184));
  unint64_t v34 = *(void **)(v72 + 200);
  unsigned int v74 = (void *)(v72 + 208);
  if (*(void *)(v71 + 216))
  {
    uint64_t v36 = (uint64_t **)(v71 + 208);
    uint64_t v35 = *(void *)(v71 + 208);
    uint64_t v37 = *(void **)(v71 + 200);
    *(void *)(v71 + 200) = v71 + 208;
    *(void *)(v35 + 16) = 0;
    *(void *)(v71 + 208) = 0;
    *(void *)(v71 + 216) = 0;
    if (v37[1]) {
      int v38 = (void *)v37[1];
    }
    else {
      int v38 = v37;
    }
    uint64_t v75 = v71 + 200;
    long long v76 = v38;
    long long v77 = v38;
    if (!v38 || (long long v76 = sub_18E1B74B8((uint64_t)v38), v34 == v74))
    {
      int v43 = v34;
    }
    else
    {
      do
      {
        *((unsigned char *)v38 + 32) = *((unsigned char *)v34 + 32);
        if (v38 != v34)
        {
          sub_18E1B750C((uint64_t **)v38 + 5, (void *)v34[5], v34 + 6);
          int v38 = v77;
        }
        unint64_t v39 = *v36;
        BOOL v40 = (uint64_t **)(v71 + 208);
        uint64_t v41 = (uint64_t **)(v71 + 208);
        if (*v36)
        {
          do
          {
            while (1)
            {
              BOOL v40 = (uint64_t **)v39;
              if (*((unsigned __int8 *)v38 + 32) >= *((unsigned __int8 *)v39 + 32)) {
                break;
              }
              unint64_t v39 = (uint64_t *)*v39;
              uint64_t v41 = v40;
              if (!*v40) {
                goto LABEL_61;
              }
            }
            unint64_t v39 = (uint64_t *)v39[1];
          }
          while (v39);
          uint64_t v41 = v40 + 1;
        }
LABEL_61:
        sub_18E01BD84((uint64_t **)(v71 + 200), (uint64_t)v40, v41, v38);
        int v38 = v76;
        long long v77 = v76;
        if (v76) {
          long long v76 = sub_18E1B74B8((uint64_t)v76);
        }
        unint64_t v42 = (void *)v34[1];
        if (v42)
        {
          do
          {
            int v43 = v42;
            unint64_t v42 = (void *)*v42;
          }
          while (v42);
        }
        else
        {
          do
          {
            int v43 = (void *)v34[2];
            BOOL v23 = *v43 == (void)v34;
            unint64_t v34 = v43;
          }
          while (!v23);
        }
        if (!v38) {
          break;
        }
        unint64_t v34 = v43;
      }
      while (v43 != v74);
    }
    sub_18E1B7758((uint64_t)&v75);
    unint64_t v34 = v43;
  }
  if (v34 != v74)
  {
    unsigned int v73 = (uint64_t **)(v71 + 208);
    while (1)
    {
      unint64_t v44 = (char *)operator new(0x40uLL);
      unint64_t v45 = (uint64_t *)v44;
      v44[32] = *((unsigned char *)v34 + 32);
      *((void *)v44 + 6) = 0;
      size_t v46 = (uint64_t *)(v44 + 48);
      *((void *)v44 + 5) = v44 + 48;
      int v47 = (uint64_t **)(v44 + 40);
      *((void *)v44 + 7) = 0;
      unint64_t v48 = (void *)v34[5];
      if (v48 != v34 + 6) {
        break;
      }
LABEL_107:
      uint64_t v62 = (uint64_t **)(v71 + 208);
      unint64_t v63 = *v73;
      unint64_t v64 = (uint64_t **)(v71 + 208);
      if (*v73)
      {
        do
        {
          while (1)
          {
            unint64_t v64 = (uint64_t **)v63;
            if (*((unsigned __int8 *)v45 + 32) >= *((unsigned __int8 *)v63 + 32)) {
              break;
            }
            unint64_t v63 = (uint64_t *)*v63;
            uint64_t v62 = v64;
            if (!*v64) {
              goto LABEL_113;
            }
          }
          unint64_t v63 = (uint64_t *)v63[1];
        }
        while (v63);
        uint64_t v62 = v64 + 1;
      }
LABEL_113:
      sub_18E01BD84((uint64_t **)(v71 + 200), (uint64_t)v64, v62, v45);
      unint64_t v65 = (void *)v34[1];
      if (v65)
      {
        do
        {
          uint64_t v66 = v65;
          unint64_t v65 = (void *)*v65;
        }
        while (v65);
      }
      else
      {
        do
        {
          uint64_t v66 = (void *)v34[2];
          BOOL v23 = *v66 == (void)v34;
          unint64_t v34 = v66;
        }
        while (!v23);
      }
      unint64_t v34 = v66;
      if (v66 == v74) {
        goto LABEL_119;
      }
    }
    int v49 = 0;
    char v50 = (uint64_t *)(v44 + 48);
    while (1)
    {
      unsigned int v51 = *((unsigned __int8 *)v48 + 32);
      unint64_t v52 = v46;
      if (v50 == v46) {
        goto LABEL_83;
      }
      uint64_t v53 = v49;
      uint64_t v54 = v46;
      if (v49)
      {
        do
        {
          unint64_t v52 = v53;
          uint64_t v53 = (uint64_t *)v53[1];
        }
        while (v53);
      }
      else
      {
        do
        {
          unint64_t v52 = (uint64_t *)v54[2];
          BOOL v23 = *v52 == (void)v54;
          uint64_t v54 = v52;
        }
        while (v23);
      }
      if (*((unsigned __int8 *)v52 + 32) < v51)
      {
LABEL_83:
        if (v49) {
          uint64_t v55 = (uint64_t **)v52;
        }
        else {
          uint64_t v55 = (uint64_t **)v46;
        }
        if (v49) {
          uint64_t v56 = (uint64_t **)(v52 + 1);
        }
        else {
          uint64_t v56 = (uint64_t **)v46;
        }
        if (!*v56)
        {
LABEL_99:
          unint64_t v59 = (uint64_t *)operator new(0x30uLL);
          *((_OWORD *)v59 + 2) = *((_OWORD *)v48 + 2);
          sub_18E01BD84(v47, (uint64_t)v55, v56, v59);
        }
      }
      else
      {
        uint64_t v56 = (uint64_t **)v46;
        uint64_t v55 = (uint64_t **)v46;
        if (!v49) {
          goto LABEL_99;
        }
        unint64_t v57 = v49;
        while (1)
        {
          while (1)
          {
            uint64_t v55 = (uint64_t **)v57;
            unsigned int v58 = *((unsigned __int8 *)v57 + 32);
            if (v58 <= v51) {
              break;
            }
            unint64_t v57 = *v55;
            uint64_t v56 = v55;
            if (!*v55) {
              goto LABEL_99;
            }
          }
          if (v58 >= v51) {
            break;
          }
          unint64_t v57 = v55[1];
          if (!v57)
          {
            uint64_t v56 = v55 + 1;
            goto LABEL_99;
          }
        }
      }
      int v60 = (void *)v48[1];
      if (v60)
      {
        do
        {
          uint64_t v61 = v60;
          int v60 = (void *)*v60;
        }
        while (v60);
      }
      else
      {
        do
        {
          uint64_t v61 = (void *)v48[2];
          BOOL v23 = *v61 == (void)v48;
          unint64_t v48 = v61;
        }
        while (!v23);
      }
      if (v61 == v34 + 6) {
        goto LABEL_107;
      }
      int v49 = (uint64_t *)*v46;
      char v50 = *v47;
      unint64_t v48 = v61;
    }
  }
LABEL_119:
  *(_OWORD *)(v71 + 224) = *(_OWORD *)(v72 + 224);
  long long v67 = *(_OWORD *)(v72 + 240);
  long long v68 = *(_OWORD *)(v72 + 256);
  long long v69 = *(_OWORD *)(v72 + 272);
  *(_OWORD *)(v71 + 281) = *(_OWORD *)(v72 + 281);
  *(_OWORD *)(v71 + 256) = v68;
  *(_OWORD *)(v71 + 272) = v69;
  *(_OWORD *)(v71 + 240) = v67;
  return 0;
}

void sub_18E1B5624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_18E1B7758((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t swan::RouteSmoother::RunPlayback(uint64_t a1, void **a2)
{
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  if (*(char *)(a1 + 63) < 0)
  {
    sub_18DEDE668(__dst, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)(a1 + 40);
    uint64_t v34 = *(void *)(a1 + 56);
  }
  uint64_t v32 = 0;
  *(_OWORD *)std::string __p = 0u;
  memset(v31, 0, sizeof(v31));
  if (swan::BatchLogParser::parseRavenFixIntoRouteSmootherEpoch((uint64_t)__p)
    && swan::BatchLogParser::parseCLRSFixIntoRouteSmootherEpoch((uint64_t)__p))
  {
LABEL_6:
    uint64_t v3 = 0xFFFFFFFFLL;
    goto LABEL_29;
  }
  sub_18DEDD538(MEMORY[0x1E4FBA250], (uint64_t)"Found ", 6);
  long long v4 = (void *)std::ostream::operator<<();
  long long v5 = sub_18DEDD538(v4, (uint64_t)" epochs to smooth", 17);
  std::ios_base::getloc((const std::ios_base *)((char *)v5 + *(void *)(*v5 - 24)));
  long long v6 = std::locale::use_facet(&v38, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 10);
  std::locale::~locale(&v38);
  std::ostream::put();
  std::ostream::flush();
  std::chrono::steady_clock::now();
  unint64_t v8 = (unsigned __int8 *)v35;
  long long v7 = v36;
  if (v35 != v36)
  {
    do
    {
      unsigned int v9 = *(unsigned __int8 *)(a1 + 224);
      uint64_t v10 = *(uint64_t **)(a1 + 208);
      uint64_t v11 = (uint64_t **)(a1 + 208);
      uint64_t v12 = (uint64_t **)(a1 + 208);
      if (v10)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v12 = (uint64_t **)v10;
            unsigned int v13 = *((unsigned __int8 *)v10 + 32);
            if (v13 <= v9) {
              break;
            }
            uint64_t v10 = *v12;
            uint64_t v11 = v12;
            if (!*v12) {
              goto LABEL_15;
            }
          }
          if (v13 >= v9) {
            break;
          }
          uint64_t v10 = v12[1];
          if (!v10)
          {
            uint64_t v11 = v12 + 1;
            goto LABEL_15;
          }
        }
      }
      else
      {
LABEL_15:
        uint64_t v14 = operator new(0x40uLL);
        v14[32] = v9;
        *((void *)v14 + 7) = 0;
        *((void *)v14 + 6) = 0;
        *((void *)v14 + 5) = v14 + 48;
        sub_18E01BD84((uint64_t **)(a1 + 200), (uint64_t)v12, v11, (uint64_t *)v14);
        uint64_t v12 = (uint64_t **)v14;
      }
      int v17 = v12[6];
      uint64_t v16 = v12 + 6;
      uint64_t v15 = (uint64_t)v17;
      if (v17)
      {
        unsigned int v18 = v8[104];
        while (1)
        {
          while (1)
          {
            uint64_t v19 = v15;
            unsigned int v20 = *(unsigned __int8 *)(v15 + 32);
            if (v20 <= v18) {
              break;
            }
            uint64_t v15 = *(void *)v19;
            double v21 = (uint64_t **)v19;
            if (!*(void *)v19) {
              goto LABEL_25;
            }
          }
          if (v20 >= v18) {
            break;
          }
          uint64_t v15 = *(void *)(v19 + 8);
          if (!v15)
          {
            double v21 = (uint64_t **)(v19 + 8);
            goto LABEL_25;
          }
        }
      }
      else
      {
        double v21 = v16;
        uint64_t v19 = (uint64_t)v16;
LABEL_25:
        uint64_t v22 = operator new(0x30uLL);
        v22[32] = v8[104];
        *((void *)v22 + 5) = 0;
        sub_18E01BD84(v16 - 1, v19, v21, (uint64_t *)v22);
        uint64_t v19 = (uint64_t)v22;
      }
      if (swan::RouteSmoother::Update(a1, (uint64_t)v8, (double *)(v19 + 40), (double *)(a1 + 232), a2)) {
        goto LABEL_6;
      }
      v8 += 112;
    }
    while (v8 != v7);
  }
  uint64_t v3 = swan::RouteSmoother::Finish(a1, a2);
  std::chrono::steady_clock::now();
  sub_18DEDD538(MEMORY[0x1E4FBA250], (uint64_t)"Elapsed time in milliseconds for entire smoother Run(): ", 56);
  BOOL v23 = (void *)std::ostream::operator<<();
  int v24 = sub_18DEDD538(v23, (uint64_t)" ms", 3);
  std::ios_base::getloc((const std::ios_base *)((char *)v24 + *(void *)(*v24 - 24)));
  BOOL v25 = std::locale::use_facet(&v38, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v25->__vftable[2].~facet_0)(v25, 10);
  std::locale::~locale(&v38);
  std::ostream::put();
  std::ostream::flush();
  sub_18DEDD538(MEMORY[0x1E4FBA250], (uint64_t)"retVal: ", 8);
  uint64_t v26 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v26 + *(void *)(*v26 - 24)));
  uint64_t v27 = std::locale::use_facet(&v38, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v27->__vftable[2].~facet_0)(v27, 10);
  std::locale::~locale(&v38);
  std::ostream::put();
  std::ostream::flush();
LABEL_29:
  sub_18E1A3308((void *)v31 + 1);
  if (SBYTE7(v31[0]) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v34) < 0) {
    operator delete(__dst[0]);
  }
  if (v35)
  {
    uint64_t v36 = (unsigned __int8 *)v35;
    operator delete(v35);
  }
  return v3;
}

void sub_18E1B5AD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a27)
  {
    a28 = (uint64_t)a27;
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

uint64_t swan::RouteSmoother::Update(uint64_t a1, uint64_t a2, double *a3, double *a4, void **a5)
{
  v79[0] = 0.0;
  uint64_t v76 = 0x100000006;
  unsigned int v74 = &unk_1EDD19728;
  long long v77 = &v78;
  long long v75 = xmmword_18E1FD770;
  sub_18DFE2CC8((uint64_t)&v74, 0.0);
  uint64_t v71 = 0x600000006;
  long long v69 = &unk_1EDD197B8;
  uint64_t v72 = &v73;
  long long v70 = xmmword_18E1F8570;
  sub_18DFE2CC8((uint64_t)&v69, 0.0);
  if (swan::RouteSmoother::ConvertRouteSmootherEpochToSmootherInput((double *)a1, a2, v79, (uint64_t)&v74, (uint64_t)&v69))return 0xFFFFFFFFLL; {
  double v10 = v79[0];
  }
  char v13 = *(unsigned char *)(a2 + 104);
  uint64_t v11 = (unsigned char *)(a2 + 104);
  char v12 = v13;
  double v14 = *a3;
  if (*(unsigned char *)(a1 + 112912))
  {
    double v15 = *a4;
    uint64_t v16 = sub_18E1B797C((uint64_t **)(a1 + 152), v12, v11);
    if (swan::FixedLagSmoother::Update(a1 + 304, v12, (uint64_t)&v74, (uint64_t)&v69, *((_DWORD *)v16 + 8), v10, v14, v15))return 0xFFFFFFFFLL; {
  }
    }
  else
  {
    uint64_t v19 = sub_18E1B797C((uint64_t **)(a1 + 152), v12, v11);
    if (swan::FixedLagSmoother::Initialize(a1 + 304, v12, (uint64_t)&v74, (uint64_t)&v69, *((_DWORD *)v19 + 8), v10, v14))return 0xFFFFFFFFLL; {
  }
    }
  uint64_t v66 = 0;
  long long v67 = 0;
  uint64_t v68 = 0;
  unint64_t v63 = 0;
  unint64_t v64 = 0;
  uint64_t v65 = 0;
  std::string __p = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  uint64_t v59 = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  uint64_t v20 = swan::FixedLagSmoother::ExtractOutput(a1 + 304, (char **)&v66, (unint64_t *)&v63, (char **)&__p, &v57, &v54, 0);
  if (v64 - (unsigned char *)v63 == (v67 - (unsigned char *)v66) >> 3
    && (unint64_t v21 = (v67 - (unsigned char *)v66) >> 3, v21 == (v61 - (unsigned char *)__p) >> 3)
    && 0x2E8BA2E8BA2E8BA3 * ((v58 - v57) >> 3) == v21
    && 0x8F9C18F9C18F9C19 * ((v55 - v54) >> 3) == v21)
  {
    if (v67 == v66)
    {
LABEL_34:
      int v24 = 0;
    }
    else
    {
      uint64_t v22 = 0;
      if (v21 <= 1) {
        uint64_t v23 = 1;
      }
      else {
        uint64_t v23 = (v67 - (unsigned char *)v66) >> 3;
      }
      int v24 = 1;
      __asm { FMOV            V0.2D, #-1.0 }
      long long v46 = _Q0;
      while (1)
      {
        long long v47 = xmmword_18E22B980;
        long long v48 = xmmword_18E200CE0;
        long long v49 = xmmword_18E200CE0;
        long long v50 = v46;
        long long v51 = v46;
        long long v52 = v46;
        *(void *)&long long v53 = 0xBFF0000000000000;
        BYTE8(v53) = 0;
        uint64_t v20 = swan::RouteSmoother::ConvertSmootherOutputToRouteSmootherEpoch(*((double *)v66 + v22), *((double *)__p + v22), v20, *((unsigned char *)v63 + v22), v57 + 88 * v22, v54 + 328 * v22, (uint64_t)&v47);
        if (v20) {
          break;
        }
        double v30 = (long long *)a5[1];
        unint64_t v31 = (unint64_t)a5[2];
        if ((unint64_t)v30 >= v31)
        {
          uint64_t v33 = 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (unsigned char *)*a5) >> 4);
          unint64_t v34 = v33 + 1;
          if ((unint64_t)(v33 + 1) > 0x249249249249249) {
            sub_18DEE1FC8();
          }
          unint64_t v35 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v31 - (void)*a5) >> 4);
          if (2 * v35 > v34) {
            unint64_t v34 = 2 * v35;
          }
          if (v35 >= 0x124924924924924) {
            unint64_t v36 = 0x249249249249249;
          }
          else {
            unint64_t v36 = v34;
          }
          if (v36) {
            uint64_t v20 = (uint64_t)sub_18E1A8D88((uint64_t)(a5 + 2), v36);
          }
          else {
            uint64_t v20 = 0;
          }
          uint64_t v37 = (long long *)(v20 + 112 * v33);
          *uint64_t v37 = v47;
          v37[1] = v48;
          double v37[2] = v49;
          v37[6] = v53;
          v37[5] = v52;
          v37[4] = v51;
          v37[3] = v50;
          unint64_t v39 = (char *)*a5;
          std::locale v38 = (char *)a5[1];
          BOOL v40 = v37;
          if (v38 != *a5)
          {
            do
            {
              long long v41 = *((_OWORD *)v38 - 7);
              long long v42 = *((_OWORD *)v38 - 5);
              *(v40 - 6) = *((_OWORD *)v38 - 6);
              *(v40 - 5) = v42;
              *(v40 - 7) = v41;
              long long v43 = *((_OWORD *)v38 - 4);
              long long v44 = *((_OWORD *)v38 - 3);
              long long v45 = *((_OWORD *)v38 - 2);
              *(long long *)((char *)v40 - 23) = *(_OWORD *)(v38 - 23);
              *(v40 - 3) = v44;
              *(v40 - 2) = v45;
              *(v40 - 4) = v43;
              v40 -= 7;
              v38 -= 112;
            }
            while (v38 != v39);
            std::locale v38 = (char *)*a5;
          }
          uint64_t v32 = v37 + 7;
          *a5 = v40;
          a5[1] = v37 + 7;
          a5[2] = (void *)(v20 + 112 * v36);
          if (v38) {
            operator delete(v38);
          }
        }
        else
        {
          v30[3] = v50;
          v30[4] = v51;
          v30[5] = v52;
          v30[6] = v53;
          *double v30 = v47;
          v30[1] = v48;
          void v30[2] = v49;
          uint64_t v32 = v30 + 7;
        }
        a5[1] = v32;
        int v24 = ++v22 < v21;
        if (v22 == v23) {
          goto LABEL_34;
        }
      }
    }
    uint64_t v17 = (v24 << 31 >> 31);
  }
  else
  {
    uint64_t v17 = 0xFFFFFFFFLL;
  }
  *(void *)&long long v47 = &v54;
  sub_18E1B77FC((void ***)&v47);
  *(void *)&long long v47 = &v57;
  sub_18E1B78BC((void ***)&v47);
  if (__p)
  {
    uint64_t v61 = __p;
    operator delete(__p);
  }
  if (v63)
  {
    unint64_t v64 = v63;
    operator delete(v63);
  }
  if (v66)
  {
    long long v67 = v66;
    operator delete(v66);
  }
  return v17;
}

void sub_18E1B605C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45)
{
  a17 = &a32;
  sub_18E1B77FC((void ***)&a17);
  a17 = &a35;
  sub_18E1B78BC((void ***)&a17);
  if (__p)
  {
    a39 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a41)
  {
    a42 = (uint64_t)a41;
    operator delete(a41);
  }
  if (a44)
  {
    a45 = (uint64_t)a44;
    operator delete(a44);
  }
  _Unwind_Resume(a1);
}

uint64_t swan::RouteSmoother::Finish(uint64_t a1, void **a2)
{
  long long v51 = 0;
  long long v52 = 0;
  uint64_t v53 = 0;
  long long v48 = 0;
  long long v49 = 0;
  uint64_t v50 = 0;
  long long v45 = 0;
  long long v46 = 0;
  uint64_t v47 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v3 = swan::FixedLagSmoother::ExtractOutput(a1 + 304, &v51, (unint64_t *)&v48, &v45, &v42, &v39, 1);
  if (v49 - v48 == (v52 - v51) >> 3
    && (unint64_t v4 = (v52 - v51) >> 3, v4 == (v46 - v45) >> 3)
    && 0x2E8BA2E8BA2E8BA3 * ((v43 - v42) >> 3) == v4
    && 0x8F9C18F9C18F9C19 * ((v40 - v39) >> 3) == v4)
  {
    if (v52 == v51)
    {
LABEL_28:
      int v7 = 0;
    }
    else
    {
      uint64_t v5 = 0;
      if (v4 <= 1) {
        uint64_t v6 = 1;
      }
      else {
        uint64_t v6 = (v52 - v51) >> 3;
      }
      int v7 = 1;
      __asm { FMOV            V0.2D, #-1.0 }
      long long v31 = _Q0;
      while (1)
      {
        long long v32 = xmmword_18E22B980;
        long long v33 = xmmword_18E200CE0;
        long long v34 = xmmword_18E200CE0;
        long long v35 = v31;
        long long v36 = v31;
        long long v37 = v31;
        *(void *)&long long v38 = 0xBFF0000000000000;
        BYTE8(v38) = 0;
        uint64_t v3 = swan::RouteSmoother::ConvertSmootherOutputToRouteSmootherEpoch(*(double *)&v51[8 * v5], *(double *)&v45[8 * v5], v3, v48[v5], v42 + 88 * v5, v39 + 328 * v5, (uint64_t)&v32);
        if (v3) {
          break;
        }
        char v13 = (long long *)a2[1];
        unint64_t v14 = (unint64_t)a2[2];
        if ((unint64_t)v13 >= v14)
        {
          uint64_t v16 = 0x6DB6DB6DB6DB6DB7 * (((char *)v13 - (unsigned char *)*a2) >> 4);
          unint64_t v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) > 0x249249249249249) {
            sub_18DEE1FC8();
          }
          unint64_t v18 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v14 - (void)*a2) >> 4);
          if (2 * v18 > v17) {
            unint64_t v17 = 2 * v18;
          }
          if (v18 >= 0x124924924924924) {
            unint64_t v19 = 0x249249249249249;
          }
          else {
            unint64_t v19 = v17;
          }
          if (v19) {
            uint64_t v3 = (uint64_t)sub_18E1A8D88((uint64_t)(a2 + 2), v19);
          }
          else {
            uint64_t v3 = 0;
          }
          uint64_t v20 = (long long *)(v3 + 112 * v16);
          long long *v20 = v32;
          v20[1] = v33;
          std::locale v20[2] = v34;
          v20[6] = v38;
          v20[5] = v37;
          unsigned char v20[4] = v36;
          v20[3] = v35;
          uint64_t v22 = (char *)*a2;
          unint64_t v21 = (char *)a2[1];
          uint64_t v23 = v20;
          if (v21 != *a2)
          {
            do
            {
              long long v24 = *((_OWORD *)v21 - 7);
              long long v25 = *((_OWORD *)v21 - 5);
              *(v23 - 6) = *((_OWORD *)v21 - 6);
              *(v23 - 5) = v25;
              *(v23 - 7) = v24;
              long long v26 = *((_OWORD *)v21 - 4);
              long long v27 = *((_OWORD *)v21 - 3);
              long long v28 = *((_OWORD *)v21 - 2);
              *(long long *)((char *)v23 - 23) = *(_OWORD *)(v21 - 23);
              *(v23 - 3) = v27;
              *(v23 - 2) = v28;
              *(v23 - 4) = v26;
              v23 -= 7;
              v21 -= 112;
            }
            while (v21 != v22);
            unint64_t v21 = (char *)*a2;
          }
          double v15 = v20 + 7;
          *a2 = v23;
          a2[1] = v20 + 7;
          a2[2] = (void *)(v3 + 112 * v19);
          if (v21) {
            operator delete(v21);
          }
        }
        else
        {
          v13[3] = v35;
          v13[4] = v36;
          v13[5] = v37;
          v13[6] = v38;
          *char v13 = v32;
          v13[1] = v33;
          v13[2] = v34;
          double v15 = v13 + 7;
        }
        a2[1] = v15;
        int v7 = ++v5 < v4;
        if (v5 == v6) {
          goto LABEL_28;
        }
      }
    }
    uint64_t v29 = (v7 << 31 >> 31);
  }
  else
  {
    uint64_t v29 = 0xFFFFFFFFLL;
  }
  *(void *)&long long v32 = &v39;
  sub_18E1B77FC((void ***)&v32);
  *(void *)&long long v32 = &v42;
  sub_18E1B78BC((void ***)&v32);
  if (v45)
  {
    long long v46 = v45;
    operator delete(v45);
  }
  if (v48)
  {
    long long v49 = v48;
    operator delete(v48);
  }
  if (v51)
  {
    long long v52 = v51;
    operator delete(v51);
  }
  return v29;
}

void sub_18E1B6474(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  a17 = (void **)&a31;
  sub_18E1B77FC(&a17);
  a17 = (void **)(v31 - 184);
  sub_18E1B78BC(&a17);
  long long v33 = *(void **)(v31 - 160);
  if (v33)
  {
    *(void *)(v31 - 152) = v33;
    operator delete(v33);
  }
  long long v34 = *(void **)(v31 - 136);
  if (v34)
  {
    *(void *)(v31 - 128) = v34;
    operator delete(v34);
  }
  long long v35 = *(void **)(v31 - 112);
  if (v35)
  {
    *(void *)(v31 - 104) = v35;
    operator delete(v35);
  }
  _Unwind_Resume(a1);
}

uint64_t swan::RouteSmoother::ConvertRouteSmootherEpochToSmootherInput(double *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  *a3 = *(void *)a2;
  float64x2_t v81 = vmulq_f64(*(float64x2_t *)(a2 + 8), (float64x2_t)vdupq_n_s64(0x3F91DF46A2529D39uLL));
  uint64_t v82 = *(void *)(a2 + 32);
  if (cnnavigation::LLAToECEF(v81.f64, 1, v83, 0, (uint64_t)&v49)) {
    return 0xFFFFFFFFLL;
  }
  *(_OWORD *)(a4 + 8) = xmmword_18E1FD770;
  unsigned int v9 = *(double **)(a4 + 32);
  *unsigned int v9 = v83[0];
  v9[1] = v83[1];
  v9[2] = v83[2];
  long double v10 = *(double *)(a2 + 64);
  double v11 = *(double *)(a2 + 48);
  __double2 v12 = __sincos_stret(v11 * 0.0174532925);
  double v13 = *(double *)(a2 + 56);
  double v14 = v10 * v12.__sinval;
  if (v11 >= 0.0) {
    double v15 = v10 * v12.__cosval;
  }
  else {
    double v15 = 0.0;
  }
  if (v11 < 0.0) {
    double v14 = 0.0;
  }
  *(double *)&long long v77 = v14;
  *((double *)&v77 + 1) = v15;
  double v17 = *(double *)(a2 + 72);
  double v16 = *(double *)(a2 + 80);
  double v78 = v16;
  double v18 = a1[31];
  if (fabs(v16) > v18 || (*(void *)&v16 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    double v19 = 1.0;
    if (v16 <= 0.0)
    {
      double v19 = -1.0;
      if (v16 >= 0.0) {
        double v19 = 0.0;
      }
    }
    double v78 = v18 * v19;
  }
  char v71 = 0;
  uint64_t v74 = 0x300000003;
  long long v73 = xmmword_18E1F0010;
  uint64_t v72 = &unk_1EDD18EE8;
  long long v75 = &v76;
  long long v70 = &unk_1EDD0AB90;
  if (cnnavigation::ENUToECEF(&v77, 1, 0, (uint64_t)v83, 1, &v79, (uint64_t)&v70)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v21 = *(void *)(a4 + 32);
  *(float64x2_t *)(v21 + 24) = v79;
  *(void *)(v21 + 40) = v80;
  uint64_t v67 = 0x300000003;
  uint64_t v65 = &unk_1EDD18EE8;
  uint64_t v68 = (double *)&v69;
  long long v66 = xmmword_18E1F0010;
  sub_18DFE2CC8((uint64_t)&v65, 0.0);
  double v22 = *(double *)(a2 + 24) * *(double *)(a2 + 24) * 0.5;
  uint64_t v23 = v68;
  *uint64_t v68 = v22;
  int v24 = HIDWORD(v66);
  v23[HIDWORD(v66) + 1] = v22;
  v23[2 * v24 + 2] = *(double *)(a2 + 40) * *(double *)(a2 + 40);
  uint64_t v62 = 0x300000003;
  long long v61 = xmmword_18E1F0010;
  int v60 = &unk_1EDD18EE8;
  unint64_t v63 = &v64;
  sub_18DFFBB34((uint64_t)&v70, (uint64_t)&v65, (uint64_t)&v60);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB4051A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB4051A8))
  {
    uint64_t v51 = 0x300000001;
    long long v49 = &unk_1EDD18258;
    long long v52 = &v53;
    long long v50 = xmmword_18E1F8560;
    uint64_t v53 = 0x100000000;
    LODWORD(v54) = 2;
    sub_18DFEC63C((uint64_t)&v49, (uint64_t)&unk_1EB4051D8);
    __cxa_atexit((void (*)(void *))sub_18DFE2E9C, &unk_1EB4051D8, &dword_18DEDB000);
    __cxa_guard_release(&qword_1EB4051A8);
  }
  uint64_t v51 = 0x600000006;
  long long v49 = &unk_1EDD197B8;
  long long v52 = &v53;
  long long v50 = xmmword_18E1F8570;
  sub_18DFE2CC8((uint64_t)&v49, 0.0);
  sub_18DFE2F24(a5, (uint64_t)&v49);
  sub_18DFEE864((uint64_t)&v49, a5, (uint64_t)&unk_1EB4051D8, (uint64_t)&unk_1EB4051D8);
  sub_18DFEC6E4((uint64_t)&v49, (uint64_t)&v60);
  double v25 = v17 * v17;
  double v42 = *(double *)(a2 + 88) * *(double *)(a2 + 88);
  double v26 = sqrt(v17 * v17);
  uint64_t v51 = 0x300000003;
  long long v49 = &unk_1EDD18EE8;
  long long v52 = &v53;
  long long v50 = xmmword_18E1F0010;
  double v27 = sqrt(v13 * 0.0174532925 * (v13 * 0.0174532925));
  sub_18DFE2CC8((uint64_t)&v49, 0.0);
  sub_18DFE2F24((uint64_t)&v65, (uint64_t)&v49);
  double v28 = a1[36];
  BOOL v29 = v10 >= v26 * a1[35] && v27 < v28;
  if (v29
    && v13 >= 0.0
    && v17 >= 0.0
    && (*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
    && (*(void *)&v17 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    uint64_t v51 = 0x300000003;
    long long v50 = xmmword_18E1F0010;
    long long v49 = &unk_1EDD18EE8;
    long long v52 = &v53;
    *(double *)&uint64_t v53 = v17 * v17;
    uint64_t v55 = 0;
    double v56 = v13 * 0.0174532925 * (v13 * 0.0174532925);
    uint64_t v58 = 0;
    long long v54 = 0u;
    long long v57 = 0u;
    double v59 = v42;
    sub_18DFEB238(3, 3, (uint64_t)v46);
    uint64_t v40 = v48;
    double *v48 = v12.__sinval;
    int v41 = v47;
    v40[v47] = v10 * v12.__cosval;
    v40[1] = v12.__cosval;
    v40[v41 + 1] = -(v10 * v12.__sinval);
    v40[2 * v41 + 2] = 1.0;
    sub_18DFF6360((uint64_t)v46, (uint64_t)&v49, (uint64_t)v44);
    sub_18DFF63E0((uint64_t)v46, (uint64_t)v43);
    sub_18DFF6360((uint64_t)v44, (uint64_t)v43, (uint64_t)v45);
    sub_18DFE2F24((uint64_t)&v65, (uint64_t)v45);
  }
  else
  {
    if (v27 >= v28
      || v13 < 0.0
      || v17 < 0.0
      || (*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v17 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      if (v17 < 0.0 || (*(void *)&v17 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        double v32 = a1[34];
      }
      else {
        double v32 = (v10 + v26 * 3.0) / 3.0;
      }
      double v33 = v32 * v32;
      double v30 = v68;
      *uint64_t v68 = v33;
      int v31 = HIDWORD(v66);
      v30[HIDWORD(v66) + 1] = v33;
    }
    else
    {
      double v30 = v68;
      *uint64_t v68 = v25;
      int v31 = HIDWORD(v66);
      v30[HIDWORD(v66) + 1] = v25;
    }
    v30[2 * v31 + 2] = v42;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB4051B8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB4051B8))
  {
    *(double *)&qword_1EB4051B0 = a1[30] * a1[30];
    __cxa_guard_release(&qword_1EB4051B8);
  }
  long long v34 = v68;
  *uint64_t v68 = *(double *)&qword_1EB4051B0 * *v68;
  uint64_t v35 = SHIDWORD(v66);
  uint64_t v36 = SHIDWORD(v66) + 1;
  v34[v36] = *(double *)&qword_1EB4051B0 * v34[v36];
  v34[2 * v35 + 2] = *(double *)&qword_1EB4051B0 * v34[2 * v35 + 2];
  double v37 = a1[32];
  if (v10 > v37 || hypot(v10, *(long double *)(a2 + 80)) > v37)
  {
    double v38 = a1[33] * a1[33];
    double v39 = *v34;
    if (*v34 <= v38) {
      double v39 = a1[33] * a1[33];
    }
    *long long v34 = v39;
    if (v34[v36] > v38) {
      double v38 = v34[v36];
    }
    v34[v36] = v38;
  }
  sub_18DFFBB34((uint64_t)&v70, (uint64_t)&v65, (uint64_t)&v60);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB4051C0, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1EB4051C0))
    {
      uint64_t v51 = 0x300000001;
      long long v49 = &unk_1EDD18258;
      long long v52 = &v53;
      long long v50 = xmmword_18E1F8560;
      uint64_t v53 = 0x400000003;
      LODWORD(v54) = 5;
      sub_18DFEC63C((uint64_t)&v49, (uint64_t)&unk_1EB405210);
      __cxa_atexit((void (*)(void *))sub_18DFE2E9C, &unk_1EB405210, &dword_18DEDB000);
      __cxa_guard_release(&qword_1EB4051C0);
    }
  }
  sub_18DFEE864((uint64_t)&v49, a5, (uint64_t)&unk_1EB405210, (uint64_t)&unk_1EB405210);
  sub_18DFEC6E4((uint64_t)&v49, (uint64_t)&v60);
  return 0;
}

void sub_18E1B6D30(_Unwind_Exception *a1)
{
}

uint64_t swan::RouteSmoother::ConvertSmootherOutputToRouteSmootherEpoch(double a1, double a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(double *)a7 = a1;
  uint64_t v11 = *(void *)(a5 + 32);
  float64x2_t v85 = *(float64x2_t *)v11;
  uint64_t v86 = *(void *)(v11 + 16);
  if (cnnavigation::ECEFToLLA(&v85, 1, v83.f64, 0, (uint64_t)&v76)) {
    return 0xFFFFFFFFLL;
  }
  *(float64x2_t *)(a7 + 8) = vmulq_f64(v83, (float64x2_t)vdupq_n_s64(0x404CA5DC1A63C1F8uLL));
  *(void *)(a7 + 32) = v84;
  char v77 = 0;
  uint64_t v80 = 0x300000003;
  long long v79 = xmmword_18E1F0010;
  double v78 = &unk_1EDD18EE8;
  float64x2_t v81 = &v82;
  uint64_t v76 = &unk_1EDD0AB68;
  float64x2_t v71 = *(float64x2_t *)(v11 + 24);
  double v72 = *(double *)(v11 + 40);
  cnnavigation::ECEFToENU(&v71, 1, 0, &v85, 1, (uint64_t)&__x, (uint64_t)&v76, v72);
  if (v12) {
    return 0xFFFFFFFFLL;
  }
  *(long double *)(a7 + 64) = hypot(__x, __y);
  *(void *)(a7 + 80) = v75;
  uint64_t v68 = 0x300000003;
  long long v67 = xmmword_18E1F0010;
  long long v66 = &unk_1EDD18EE8;
  uint64_t v69 = &v70;
  uint64_t v63 = 0x300000003;
  long long v62 = xmmword_18E1F0010;
  long long v61 = &unk_1EDD18EE8;
  uint64_t v64 = (double *)&v65;
  if (v77) {
    sub_18DFE2F24((uint64_t)&v66, (uint64_t)&v78);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB4051C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB4051C8))
  {
    uint64_t v57 = 0x300000001;
    uint64_t v55 = &unk_1EDD18258;
    uint64_t v58 = (double *)&v59;
    long long v56 = xmmword_18E1F8560;
    uint64_t v59 = 0x100000000;
    int v60 = 2;
    sub_18DFEC63C((uint64_t)&v55, (uint64_t)&unk_1EB405248);
    __cxa_atexit((void (*)(void *))sub_18DFE2E9C, &unk_1EB405248, &dword_18DEDB000);
    __cxa_guard_release(&qword_1EB4051C8);
  }
  sub_18DFECE30(a6, (uint64_t)&unk_1EB405248, (uint64_t)&unk_1EB405248, (uint64_t)v47);
  uint64_t v52 = 0x300000003;
  long long v51 = xmmword_18E1F0010;
  long long v50 = &unk_1EDD18EE8;
  uint64_t v53 = &v54;
  sub_18DFE2B44((uint64_t)&v66, (uint64_t)v47, (uint64_t)&v50);
  int v13 = DWORD1(v67);
  int v14 = v67;
  uint64_t v44 = 0x300000003;
  double v39 = &unk_1EDD18EE8;
  long long v45 = v46;
  int v40 = DWORD1(v67);
  int v41 = v67;
  int v42 = v67 * DWORD1(v67);
  int v43 = DWORD1(v67);
  if (DWORD1(v67))
  {
    int v15 = 0;
    int v16 = 0;
    int v17 = HIDWORD(v67);
    double v18 = v69;
    do
    {
      int v19 = v15;
      int v20 = v16;
      for (int i = v14; i; --i)
      {
        v46[v20] = v18[v19];
        v20 += v13;
        ++v19;
      }
      ++v16;
      v15 += v17;
    }
    while (v16 != v13);
  }
  uint64_t v57 = 0x300000003;
  long long v56 = xmmword_18E1F0010;
  uint64_t v55 = &unk_1EDD18EE8;
  uint64_t v58 = (double *)&v59;
  sub_18DFE2B44((uint64_t)&v50, (uint64_t)&v39, (uint64_t)&v55);
  sub_18DFE2F24((uint64_t)&v61, (uint64_t)&v55);
  double v22 = v64;
  double v23 = *v64;
  if (*v64 < 0.0) {
    return 0xFFFFFFFFLL;
  }
  int v24 = HIDWORD(v62);
  double v25 = v64[HIDWORD(v62) + 1];
  if (v25 < 0.0) {
    return 0xFFFFFFFFLL;
  }
  if ((*(void *)&v23 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return 0xFFFFFFFFLL;
  }
  if ((*(void *)&v25 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
    return 0xFFFFFFFFLL;
  }
  *(double *)(a7 + 24) = sqrt(v23 + v25);
  double v26 = v22[2 * v24 + 2];
  if (v26 < 0.0 || (*(void *)&v26 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return 0xFFFFFFFFLL;
  }
  *(double *)(a7 + 40) = sqrt(v26);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB4051D0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB4051D0))
  {
    uint64_t v57 = 0x300000001;
    uint64_t v55 = &unk_1EDD18258;
    uint64_t v58 = (double *)&v59;
    long long v56 = xmmword_18E1F8560;
    uint64_t v59 = 0x400000003;
    int v60 = 5;
    sub_18DFEC63C((uint64_t)&v55, (uint64_t)&unk_1EB405280);
    __cxa_atexit((void (*)(void *))sub_18DFE2E9C, &unk_1EB405280, &dword_18DEDB000);
    __cxa_guard_release(&qword_1EB4051D0);
  }
  sub_18DFECE30(a6, (uint64_t)&unk_1EB405280, (uint64_t)&unk_1EB405280, (uint64_t)v47);
  sub_18DFF6360((uint64_t)&v66, (uint64_t)v47, (uint64_t)&v50);
  sub_18DFF63E0((uint64_t)&v66, (uint64_t)&v39);
  sub_18DFF6360((uint64_t)&v50, (uint64_t)&v39, (uint64_t)&v55);
  sub_18DFE2F24((uint64_t)&v61, (uint64_t)&v55);
  if (*v64 < 0.0) {
    return 0xFFFFFFFFLL;
  }
  double v27 = v64[SHIDWORD(v62) + 1];
  if (v27 < 0.0
    || (*(void *)v64 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (*(void *)&v27 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    return 0xFFFFFFFFLL;
  }
  long double v28 = atan2(__x, __y);
  double v29 = fmod(v28 * 57.2957795 + 360.0, 360.0);
  *(double *)(a7 + 48) = v29;
  double v30 = *(double *)(a7 + 64);
  sub_18DFEB238(3, 3, (uint64_t)&v55);
  __double2 v31 = __sincos_stret(v29 * 0.0174532925);
  double v32 = v58;
  *uint64_t v58 = v31.__sinval;
  int v33 = HIDWORD(v56);
  v32[SHIDWORD(v56)] = v30 * v31.__cosval;
  v32[1] = v31.__cosval;
  v32[v33 + 1] = -(v30 * v31.__sinval);
  v32[2 * v33 + 2] = 1.0;
  sub_18E01E3DC((uint64_t)&v55, (uint64_t)&v50);
  sub_18DFF6360((uint64_t)&v50, (uint64_t)&v61, (uint64_t)&v39);
  sub_18DFF63E0((uint64_t)&v50, (uint64_t)v38);
  sub_18DFF6360((uint64_t)&v39, (uint64_t)v38, (uint64_t)v47);
  uint64_t result = 0;
  uint64_t v35 = v49;
  *(double *)(a7 + 72) = sqrt(*v49);
  int v36 = v48;
  *(double *)(a7 + 56) = sqrt(v35[v48 + 1]) * 57.2957795;
  double v37 = v35[2 * v36 + 2];
  *(unsigned char *)(a7 + 104) = a4;
  *(double *)(a7 + 88) = sqrt(v37);
  *(double *)(a7 + 96) = a2;
  return result;
}

void sub_18E1B7440(_Unwind_Exception *a1)
{
}

uint64_t swan::RouteSmoother::Reset(swan::RouteSmoother *this)
{
  *((unsigned char *)this + 112912) = 0;
  return 0;
}

void *sub_18E1B74B8(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 16);
  if (result)
  {
    uint64_t v3 = (void *)*result;
    if (*result == a1)
    {
      *uint64_t result = 0;
      while (1)
      {
        unint64_t v4 = (void *)result[1];
        if (!v4) {
          break;
        }
        do
        {
          uint64_t result = v4;
          unint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; uint64_t v3 = (void *)result[1])
      {
        do
        {
          uint64_t result = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t **sub_18E1B750C(uint64_t **result, void *a2, void *a3)
{
  uint64_t v5 = result;
  if (result[2])
  {
    uint64_t v6 = *result;
    unint64_t v8 = result + 1;
    int v7 = result[1];
    *uint64_t result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      uint64_t v9 = v6[1];
    }
    else {
      uint64_t v9 = (uint64_t)v6;
    }
    double v26 = result;
    double v27 = (void *)v9;
    uint64_t v28 = v9;
    if (v9)
    {
      long double v10 = sub_18E1B74B8(v9);
      double v27 = v10;
      if (a2 != a3)
      {
        uint64_t v11 = a2;
        do
        {
          uint64_t v12 = (uint64_t)v10;
          unsigned int v13 = *((unsigned __int8 *)v11 + 32);
          *(unsigned char *)(v9 + 32) = v13;
          *(void *)(v9 + 40) = v11[5];
          int v14 = *v8;
          int v15 = v5 + 1;
          int v16 = v5 + 1;
          if (*v8)
          {
            do
            {
              while (1)
              {
                int v15 = (uint64_t **)v14;
                if (v13 >= *((unsigned __int8 *)v14 + 32)) {
                  break;
                }
                int v14 = (uint64_t *)*v14;
                int v16 = v15;
                if (!*v15) {
                  goto LABEL_14;
                }
              }
              int v14 = (uint64_t *)v14[1];
            }
            while (v14);
            int v16 = v15 + 1;
          }
LABEL_14:
          sub_18E01BD84(v5, (uint64_t)v15, v16, (uint64_t *)v9);
          if (v12) {
            long double v10 = sub_18E1B74B8(v12);
          }
          else {
            long double v10 = 0;
          }
          int v17 = (void *)v11[1];
          if (v17)
          {
            do
            {
              a2 = v17;
              int v17 = (void *)*v17;
            }
            while (v17);
          }
          else
          {
            do
            {
              a2 = (void *)v11[2];
              BOOL v18 = *a2 == (void)v11;
              uint64_t v11 = a2;
            }
            while (!v18);
          }
          if (!v12) {
            break;
          }
          uint64_t v9 = v12;
          uint64_t v11 = a2;
        }
        while (a2 != a3);
        double v27 = v10;
        uint64_t v28 = v12;
      }
    }
    uint64_t result = (uint64_t **)sub_18E1B7708((uint64_t)&v26);
  }
  if (a2 != a3)
  {
    int v19 = v5 + 1;
    do
    {
      int v20 = (unsigned __int8 *)operator new(0x30uLL);
      *((_OWORD *)v20 + 2) = *((_OWORD *)a2 + 2);
      uint64_t v21 = *v19;
      double v22 = v5 + 1;
      double v23 = v5 + 1;
      if (*v19)
      {
        do
        {
          while (1)
          {
            double v22 = (uint64_t **)v21;
            if (v20[32] >= *((unsigned __int8 *)v21 + 32)) {
              break;
            }
            uint64_t v21 = (uint64_t *)*v21;
            double v23 = v22;
            if (!*v22) {
              goto LABEL_34;
            }
          }
          uint64_t v21 = (uint64_t *)v21[1];
        }
        while (v21);
        double v23 = v22 + 1;
      }
LABEL_34:
      uint64_t result = (uint64_t **)sub_18E01BD84(v5, (uint64_t)v22, v23, (uint64_t *)v20);
      int v24 = (void *)a2[1];
      if (v24)
      {
        do
        {
          double v25 = v24;
          int v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          double v25 = (void *)a2[2];
          BOOL v18 = *v25 == (void)a2;
          a2 = v25;
        }
        while (!v18);
      }
      a2 = v25;
    }
    while (v25 != a3);
  }
  return result;
}

uint64_t sub_18E1B7708(uint64_t a1)
{
  sub_18DF064FC(*(void **)(a1 + 16));
  int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        int v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_18DF064FC(v2);
  }
  return a1;
}

uint64_t sub_18E1B7758(uint64_t a1)
{
  sub_18E1B77A8(*(void **)(a1 + 16));
  int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        int v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_18E1B77A8(v2);
  }
  return a1;
}

void sub_18E1B77A8(void *a1)
{
  if (a1)
  {
    sub_18E1B77A8(*a1);
    sub_18E1B77A8(a1[1]);
    sub_18DF064FC((void *)a1[6]);
    operator delete(a1);
  }
}

void sub_18E1B77FC(void ***a1)
{
  int v1 = *a1;
  int v2 = (void (***)(void))**a1;
  if (v2)
  {
    unint64_t v4 = (void (***)(void))v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 41;
      int v7 = v4 - 41;
      do
      {
        (**v7)(v7);
        v6 -= 41;
        BOOL v8 = v7 == v2;
        v7 -= 41;
      }
      while (!v8);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_18E1B78BC(void ***a1)
{
  int v1 = *a1;
  int v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 88;
      int v7 = v4 - 88;
      BOOL v8 = v4 - 88;
      do
      {
        uint64_t v9 = *(void (***)(char *))v8;
        v8 -= 88;
        (*v9)(v7);
        v6 -= 88;
        BOOL v10 = v7 == v2;
        int v7 = v8;
      }
      while (!v10);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t **sub_18E1B797C(uint64_t **a1, unsigned __int8 a2, unsigned char *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int v7 = (uint64_t **)v5;
        unsigned int v8 = *((unsigned __int8 *)v5 + 28);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    int v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = operator new(0x28uLL);
    v9[28] = *a3;
    *((_DWORD *)v9 + 8) = 0;
    sub_18E01BD84(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t swan::ForwardBackwardFixedIntervalSmoother::Update(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double **a9, double **a10, char a11)
{
  MEMORY[0x1F4188790](a1);
  long long v92 = v14;
  unint64_t v93 = v15;
  uint64_t v94 = v16;
  uint64_t v91 = v17;
  uint64_t v172 = *MEMORY[0x1E4F143B8];
  if (v13 >= 2)
  {
    unint64_t v18 = v13;
    uint64_t v19 = v12;
    uint64_t v20 = v11;
    uint64_t v166 = 0x600000006;
    __int16 v164 = &unk_1EDD197B8;
    long long v167 = (double *)&v168;
    long long v165 = xmmword_18E1F8570;
    sub_18DFE2CC8((uint64_t)&v164, 0.0);
    int v21 = 0;
    int v22 = HIDWORD(v165) + 1;
    uint64_t v23 = 6;
    int v24 = v167;
    do
    {
      v24[v21] = 1.0;
      v21 += v22;
      --v23;
    }
    while (v23);
    uint64_t v161 = 0x600000006;
    long long v159 = &unk_1EDD197B8;
    BOOL v162 = &v163;
    long long v160 = xmmword_18E1F8570;
    sub_18DFE2CC8((uint64_t)&v159, 0.0);
    int v25 = 0;
    int v26 = HIDWORD(v160) + 1;
    uint64_t v27 = 6;
    uint64_t v28 = v162;
    do
    {
      v28[v25] = 0x3FF0000000000000;
      v25 += v26;
      --v27;
    }
    while (v27);
    uint64_t v156 = 0x600000006;
    uint64_t v154 = &unk_1EDD197B8;
    uint64_t v157 = &v158;
    long long v155 = xmmword_18E1F8570;
    sub_18DFE2CC8((uint64_t)&v154, 0.0);
    int v29 = 0;
    int v30 = HIDWORD(v155) + 1;
    uint64_t v31 = 6;
    double v32 = v157;
    do
    {
      v32[v29] = 0x3FF0000000000000;
      v29 += v30;
      --v31;
    }
    while (v31);
    uint64_t v151 = 0x600000006;
    uint64_t v149 = &unk_1EDD197B8;
    double v152 = (double *)&v153;
    long long v150 = xmmword_18E1F8570;
    sub_18DFE2CC8((uint64_t)&v149, 0.0);
    uint64_t v146 = 0x600000006;
    uint64_t v144 = &unk_1EDD197B8;
    long long v145 = xmmword_18E1F8570;
    uint64_t v147 = &v148;
    uint64_t v141 = 0x600000006;
    uint64_t v139 = &unk_1EDD197B8;
    uint64_t v142 = &v143;
    long long v140 = xmmword_18E1F8570;
    sub_18DFE2CC8((uint64_t)&v139, 0.0);
    int v33 = 0;
    int v34 = HIDWORD(v140) + 1;
    uint64_t v35 = 6;
    int v36 = v142;
    do
    {
      v36[v33] = 0x3FF0000000000000;
      v33 += v34;
      --v35;
    }
    while (v35);
    uint64_t v136 = 0x100000006;
    long long v135 = xmmword_18E1FD770;
    v134[3] = &unk_1EDD19728;
    uint64_t v137 = &v138;
    sub_18E1B9C44(v134, v18);
    sub_18E1B9D2C(v133, v18);
    sub_18E1B9C44(v132, v18);
    sub_18E1B9D2C(v131, v18);
    sub_18E1B9D2C(v130, v18);
    uint64_t v37 = 0;
    uint64_t v38 = *(void *)(v134[0] + 32);
    double v39 = *(void **)(v133[0] + 32);
    uint64_t v40 = 8 * *(int *)(v133[0] + 20);
    do
    {
      uint64_t v41 = 0;
      *(void *)(v38 + 8 * v37) = *(void *)(v20 + 8 * v37);
      int v42 = v39;
      do
      {
        void *v42 = *(void *)(v19 + v41);
        v41 += 8;
        int v42 = (void *)((char *)v42 + v40);
      }
      while (v41 != 48);
      ++v37;
      ++v39;
      v19 += 48;
    }
    while (v37 != 6);
    uint64_t v43 = 0;
    uint64_t v44 = *v94;
    long long v45 = v137;
    do
    {
      v45[v43] = *(void *)(v44 + v43 * 8);
      ++v43;
    }
    while (v43 != 6);
    long long v46 = *v92;
    int v47 = v167;
    *long long v167 = **v92 * **v92;
    int v48 = HIDWORD(v165);
    v47[HIDWORD(v165) + 1] = v46[1] * v46[1];
    v47[2 * v48 + 2] = v46[2] * v46[2];
    long long v49 = *v93;
    v47[3 * v48 + 3] = **v93 * **v93;
    v47[4 * v48 + 4] = v49[1] * v49[1];
    v47[5 * v48 + 5] = v49[2] * v49[2];
    uint64_t v50 = v130[0];
    *(_OWORD *)(v130[0] + 8) = xmmword_18E1F8570;
    sub_18DFE2CC8(v50, 0.0);
    int v51 = 0;
    int v52 = *(_DWORD *)(v50 + 20) + 1;
    uint64_t v53 = *(void *)(v50 + 32);
    uint64_t v54 = 6;
    do
    {
      *(void *)(v53 + 8 * v51) = 0x3FF0000000000000;
      v51 += v52;
      --v54;
    }
    while (v54);
    double v55 = *(double *)(*(void *)v91 + 8) - **(double **)v91;
    int v56 = *(_DWORD *)(v130[0] + 20);
    uint64_t v57 = *(void *)(v130[0] + 32);
    *(double *)(v57 + 24 * v56) = v55;
    *(double *)(v57 + 8 * ((4 * v56) | 1)) = v55;
    *(double *)(v57 + 8 * (5 * v56 + 2)) = v55;
    double v58 = v55 * v55;
    double v59 = v55 * 0.5;
    LODWORD(v57) = HIDWORD(v150);
    int v60 = 3 * HIDWORD(v150);
    int v61 = 3 * HIDWORD(v150) + 3;
    long long v62 = v152;
    double v63 = v58 * (**a9 * **a9);
    v152[v61] = v63;
    double v64 = v59 * v63;
    v62[v60] = v64;
    v62[3] = v64;
    double v65 = v59 * v62[v60];
    *long long v62 = v65;
    v62[(int)v57 + 1] = v65;
    v62[4 * (int)v57 + 4] = v62[v61];
    double v66 = v62[3];
    v62[(int)((4 * v57) | 1)] = v66;
    v62[(int)v57 + 4] = v66;
    double v67 = v58 * (**a10 * **a10);
    v62[5 * (int)v57 + 5] = v67;
    int v68 = 5 * v57 + 2;
    double v69 = v59 * v67;
    v62[v68] = v69;
    LODWORD(v57) = 2 * v57;
    v62[(int)v57 + 5] = v69;
    v62[(int)v57 + 2] = v59 * v62[v68];
    if (a11)
    {
      LOBYTE(v101) = 0;
      uint64_t v104 = 0x300000003;
      long long v103 = xmmword_18E1F0010;
      BOOL v102 = &unk_1EDD18EE8;
      uint64_t v105 = &v106;
      uint64_t v100 = &unk_1EDD0AB68;
      uint64_t v70 = *(float64x2_t **)(v134[0] + 32);
      float64x2_t v170 = *v70;
      double v171 = v70[1].f64[0];
      cnnavigation::ECEFToENU(&v170, 1, 0, &v170, 1, (uint64_t)&v169, (uint64_t)&v100, v171);
      uint64_t v97 = 0x300000003;
      unint64_t v95 = &unk_1EDD18EE8;
      long long v96 = xmmword_18E1F0010;
      uint64_t v98 = &v99;
      if ((_BYTE)v101) {
        sub_18DFE2F24((uint64_t)&v95, (uint64_t)&v102);
      }
      uint64_t v127 = 0x600000006;
      uint64_t v125 = &unk_1EDD197B8;
      size_t v128 = &v129;
      long long v126 = xmmword_18E1F8570;
      sub_18DFE2CC8((uint64_t)&v125, 0.0);
      float64x2_t v71 = v98;
      double v72 = v128;
      *size_t v128 = *v98;
      uint64_t v73 = SHIDWORD(v96);
      uint64_t v74 = SHIDWORD(v126);
      v72[SHIDWORD(v126)] = v71[SHIDWORD(v96)];
      v72[2 * v74] = v71[2 * v73];
      v72[1] = v71[1];
      int v75 = v73 + 1;
      v72[(int)v74 + 1] = v71[(int)v73 + 1];
      uint64_t v76 = &v71[2 * (int)v73];
      char v77 = &v72[2 * (int)v74];
      v77[1] = v76[1];
      v72[2] = v71[2];
      int v78 = v73 + 2;
      v72[(int)v74 + 2] = v71[(int)v73 + 2];
      v77[2] = v76[2];
      LODWORD(v77) = 3 * v74;
      v72[(int)v77 + 3] = *v71;
      v72[(int)((4 * v74) | 3)] = v71[v73];
      uint64_t v79 = v71[2 * v73];
      LODWORD(v73) = 5 * v74;
      v72[5 * (int)v74 + 3] = v79;
      v72[(int)v77 + 4] = v71[1];
      LODWORD(v74) = 4 * v74;
      v72[(int)v74 + 4] = v71[v75];
      v72[(int)v73 + 4] = v76[1];
      v72[(int)v77 + 5] = v71[2];
      v72[(int)v74 + 5] = v71[v78];
      v72[(int)v73 + 5] = v76[2];
      int v80 = DWORD1(v126);
      int v81 = v126;
      uint64_t v112 = 0x600000006;
      uint64_t v107 = &unk_1EDD197B8;
      char v113 = v114;
      int v108 = DWORD1(v126);
      int v109 = v126;
      int v110 = v126 * DWORD1(v126);
      int v111 = DWORD1(v126);
      if (DWORD1(v126))
      {
        int v82 = 0;
        int v83 = 0;
        int v84 = HIDWORD(v126);
        float64x2_t v85 = v128;
        do
        {
          int v86 = v82;
          int v87 = v83;
          for (int i = v81; i; --i)
          {
            v114[v87] = v85[v86];
            v87 += v80;
            ++v86;
          }
          ++v83;
          v82 += v84;
        }
        while (v83 != v80);
      }
      uint64_t v117 = 0x600000006;
      long long v116 = xmmword_18E1F8570;
      uint64_t v115 = &unk_1EDD197B8;
      uint64_t v118 = &v119;
      sub_18DFE2B44((uint64_t)&v107, (uint64_t)&v149, (uint64_t)&v115);
      uint64_t v122 = 0x600000006;
      long long v121 = xmmword_18E1F8570;
      uint64_t v120 = &unk_1EDD197B8;
      uint64_t v123 = &v124;
      sub_18DFE2B44((uint64_t)&v115, (uint64_t)&v125, (uint64_t)&v120);
      long long v89 = &v120;
    }
    else
    {
      long long v89 = &v149;
    }
    sub_18DFE2F24((uint64_t)&v144, (uint64_t)v89);
    sub_18E1B9A70();
  }
  return 0xFFFFFFFFLL;
}

void sub_18E1B9970(_Unwind_Exception *a1)
{
  STACK[0x768] = (unint64_t)&STACK[0x8C8];
  sub_18E1B77FC((void ***)&STACK[0x768]);
  STACK[0x768] = (unint64_t)&STACK[0x8E0];
  sub_18E1B78BC((void ***)&STACK[0x768]);
  STACK[0x768] = (unint64_t)&STACK[0x8F8];
  sub_18E1B77FC((void ***)&STACK[0x768]);
  STACK[0x768] = (unint64_t)&STACK[0x910];
  sub_18E1B78BC((void ***)&STACK[0x768]);
  _Unwind_Resume(a1);
}

void sub_18E1B9A70()
{
}

void sub_18E1B9C08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  sub_18E1B9FFC(va);
  _Unwind_Resume(a1);
}

void *sub_18E1B9C44(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 >= 0x2E8BA2E8BA2E8BBLL) {
    sub_18DEE1FC8();
  }
  unint64_t v4 = (char *)sub_18E1B4E78((uint64_t)(a1 + 2), a2);
  *a1 = v4;
  a1[1] = v4;
  a1[2] = &v4[88 * v5];
  uint64_t v6 = 88 * a2;
  int v7 = &v4[88 * a2];
  unsigned int v8 = v4 + 40;
  do
  {
    *((void *)v8 - 2) = 0x100000006;
    *((void *)v8 - 5) = &unk_1EDD19728;
    *((_OWORD *)v8 - 2) = xmmword_18E1FD770;
    *((void *)v8 - 1) = v8;
    v8 += 88;
    v4 += 88;
    v6 -= 88;
  }
  while (v6);
  a1[1] = v7;
  return a1;
}

void sub_18E1B9D18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void *sub_18E1B9D2C(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 >= 0xC7CE0C7CE0C7CFLL) {
    sub_18DEE1FC8();
  }
  unint64_t v4 = (char *)sub_18E1B4F30((uint64_t)(a1 + 2), a2);
  *a1 = v4;
  a1[1] = v4;
  a1[2] = &v4[328 * v5];
  uint64_t v6 = 328 * a2;
  int v7 = &v4[328 * a2];
  unsigned int v8 = v4 + 40;
  do
  {
    *((void *)v8 - 2) = 0x600000006;
    *((void *)v8 - 5) = &unk_1EDD197B8;
    *((_OWORD *)v8 - 2) = xmmword_18E1F8570;
    *((void *)v8 - 1) = v8;
    v8 += 328;
    v4 += 328;
    v6 -= 328;
  }
  while (v6);
  a1[1] = v7;
  return a1;
}

void sub_18E1B9DFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_18E1B9E14(void *a1)
{
  sub_18E1B9FFC(a1);

  JUMPOUT(0x192FA6240);
}

void sub_18E1B9E4C()
{
}

void sub_18E1B9E78()
{
}

void sub_18E1B9F80()
{
}

void *sub_18E1B9FFC(void *a1)
{
  *a1 = &unk_1EDD176E8;
  uint64_t v2 = a1[5];
  a1[5] = 0;
  if (v2) {
    MEMORY[0x192FA6220](v2, 0x1000C8000313F17);
  }
  *a1 = &unk_1EDD17478;
  return a1;
}

uint64_t swan::PositionVelocityDataEditor::TestNormalizedInnovations(double a1, uint64_t a2, uint64_t a3, uint64_t *a4, double **a5, void *a6, uint64_t *a7)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    uint64_t v7 = 0;
    unsigned int v8 = 0;
    uint64_t v9 = *a4;
    BOOL v10 = *a5;
    uint64_t v11 = *a7;
    do
    {
      uint64_t v12 = 0;
      unint64_t v13 = v10;
      do
      {
        int v14 = v13 + 7;
        float64_t v15 = *v13;
        v13 += 14;
        v16.f64[0] = v15;
        v16.f64[1] = *v14;
        *(float64x2_t *)&v19[v12] = vdivq_f64(vabsq_f64(*(float64x2_t *)(v9 + v12)), vsqrtq_f64(v16));
        v12 += 16;
      }
      while (v12 != 48);
      uint64_t v17 = 0;
      while (*(double *)&v19[v17] <= a1)
      {
        v17 += 8;
        if (v17 == 48) {
          goto LABEL_10;
        }
      }
      *(void *)(v11 + 8 * v8++) = v7;
LABEL_10:
      ++v7;
      v10 += 36;
      v9 += 48;
    }
    while (v7 != a3);
  }
  else
  {
    unsigned int v8 = 0;
  }
  *a6 = v8;
  return 0;
}

BOOL swan::PositionVelocityDataEditor::isIndexInArray(uint64_t a1, uint64_t a2, unint64_t a3, void **a4)
{
  if (!a3) {
    return 0;
  }
  if (**a4 == a2) {
    return 1;
  }
  uint64_t v5 = 1;
  do
  {
    unint64_t v6 = v5;
    if (a3 == v5) {
      break;
    }
    uint64_t v7 = (*a4)[v5++];
  }
  while (v7 != a2);
  return v6 < a3;
}

uint64_t swan::ConsistencyChecker::UpdateNormalizedInnovationsSquared(uint64_t a1, unint64_t a2, unsigned int a3, void *a4, void *a5, double *a6)
{
  *a6 = 0.0;
  uint64_t v72 = 0x100000006;
  double v67 = &unk_1EDD19728;
  unsigned int v68 = a3;
  int v69 = 1;
  unsigned int v70 = a3;
  unsigned int v71 = a3;
  uint64_t v73 = &v74;
  uint64_t v64 = 0x600000006;
  double v59 = &unk_1EDD197B8;
  unsigned int v60 = a3;
  unsigned int v61 = a3;
  int v62 = a3 * a3;
  unsigned int v63 = a3;
  double v65 = &v66;
  if (a2)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = a3;
    do
    {
      if (a3)
      {
        uint64_t v11 = 0;
        uint64_t v12 = *a4 + 48 * v9;
        unint64_t v13 = v73;
        unsigned int v14 = v63;
        float64_t v15 = v65;
        float64x2_t v16 = (uint64_t *)(*a5 + v8);
        do
        {
          v13[(int)v11] = *(void *)(v12 + 8 * v11);
          uint64_t v17 = v16;
          int v18 = v11;
          uint64_t v19 = v10;
          do
          {
            uint64_t v20 = *v17++;
            v15[v18] = v20;
            v18 += v14;
            --v19;
          }
          while (v19);
          ++v11;
          v16 += 6;
        }
        while (v11 != v10);
      }
      int v21 = v69;
      unsigned int v22 = v68;
      uint64_t v46 = 0x600000001;
      uint64_t v41 = &unk_1EDD18348;
      int v47 = v48;
      int v42 = v69;
      unsigned int v43 = v68;
      int v44 = v68 * v69;
      int v45 = v69;
      if (v69)
      {
        int v23 = 0;
        int v24 = 0;
        unsigned int v25 = v71;
        int v26 = v73;
        do
        {
          int v27 = v23;
          int v28 = v24;
          for (unsigned int i = v22; i; --i)
          {
            v48[v28] = v26[v27];
            v28 += v21;
            ++v27;
          }
          ++v24;
          v23 += v25;
        }
        while (v24 != v21);
      }
      uint64_t v38 = 0x600000006;
      int v36 = &unk_1EDD197B8;
      long long v37 = xmmword_18E1F8570;
      double v39 = &v40;
      uint64_t v82 = 0x100000006;
      int v80 = &unk_1EDD19758;
      long long v81 = xmmword_18E1FD770;
      int v83 = &v84;
      uint64_t v77 = 0x100000018;
      int v75 = &unk_1EDD18618;
      long long v76 = xmmword_18E1FD9C0;
      int v78 = &v79;
      sub_18E01BFEC((uint64_t)&v59, (uint64_t)&v80, (uint64_t)&v75, (uint64_t)&v36);
      uint64_t v51 = 0x600000001;
      long long v50 = xmmword_18E1FD840;
      long long v49 = &unk_1EDD18348;
      int v52 = &v53;
      sub_18DFE2B44((uint64_t)&v41, (uint64_t)&v36, (uint64_t)&v49);
      uint64_t v56 = 0x100000001;
      *(void *)&long long v30 = 0x100000001;
      *((void *)&v30 + 1) = 0x100000001;
      long long v55 = v30;
      uint64_t v54 = &unk_1EDD18048;
      uint64_t v57 = (double *)&v58;
      sub_18DFE2B44((uint64_t)&v49, (uint64_t)&v67, (uint64_t)&v54);
      double v31 = *v57 + *a6;
      *a6 = v31;
      ++v9;
      v8 += 288;
    }
    while (v9 != a2);
  }
  else
  {
    double v31 = 0.0;
  }
  *a6 = v31 / (double)a2;
  return 0;
}

uint64_t swan::ConsistencyChecker::UpdateNormalizedStateEstimationErrorSquared(uint64_t a1, unint64_t a2, unsigned int a3, uint64_t a4, uint64_t *a5, uint64_t a6, double *a7)
{
  *a7 = 0.0;
  uint64_t v83 = 0x100000006;
  int v78 = &unk_1EDD19728;
  unsigned int v79 = a3;
  int v80 = 1;
  unsigned int v81 = a3;
  unsigned int v82 = a3;
  uint64_t v84 = &v85;
  uint64_t v75 = 0x600000006;
  unsigned int v70 = &unk_1EDD197B8;
  unsigned int v71 = a3;
  unsigned int v72 = a3;
  int v73 = a3 * a3;
  unsigned int v74 = a3;
  long long v76 = &v77;
  uint64_t v67 = 0x100000006;
  int v62 = &unk_1EDD19728;
  unsigned int v63 = a3;
  int v64 = 1;
  unsigned int v65 = a3;
  unsigned int v66 = a3;
  unsigned int v68 = &v69;
  if (a2)
  {
    uint64_t v10 = 0;
    uint64_t v11 = a3;
    do
    {
      if (a3)
      {
        uint64_t v12 = 0;
        unint64_t v13 = v84;
        unsigned int v14 = v68;
        unsigned int v15 = v74;
        float64x2_t v16 = v76;
        uint64_t v17 = a5;
        do
        {
          uint64_t v18 = (int)v12;
          v13[v18] = *(void *)(a4 + 48 * v10 + 8 * v12);
          v14[v18] = *(void *)(a6 + 48 * v10 + 8 * v12);
          uint64_t v19 = v17;
          int v20 = v12;
          unsigned int v21 = a3;
          do
          {
            uint64_t v22 = *v19++;
            v16[v20] = v22;
            v20 += v15;
            --v21;
          }
          while (v21);
          ++v12;
          v17 += 6;
        }
        while (v12 != v11);
      }
      uint64_t v49 = 0x100000006;
      int v47 = &unk_1EDD19728;
      long long v48 = xmmword_18E1FD770;
      long long v50 = &v51;
      sub_18DFE2AA8((uint64_t)&v78, (uint64_t)&v62, (uint64_t)&v47);
      uint64_t v44 = 0x600000006;
      int v42 = &unk_1EDD197B8;
      long long v43 = xmmword_18E1F8570;
      int v45 = &v46;
      uint64_t v39 = 0x100000006;
      long long v37 = &unk_1EDD19758;
      long long v38 = xmmword_18E1FD770;
      uint64_t v40 = v41;
      uint64_t v88 = 0x100000018;
      int v86 = &unk_1EDD18618;
      long long v87 = xmmword_18E1FD9C0;
      long long v89 = v90;
      sub_18E01BFEC((uint64_t)&v70, (uint64_t)&v37, (uint64_t)&v86, (uint64_t)&v42);
      uint64_t v54 = 0x600000006;
      long long v53 = xmmword_18E1F8570;
      int v52 = &unk_1EDD197B8;
      long long v55 = &v56;
      sub_18DFE2B44((uint64_t)&v47, (uint64_t)&v42, (uint64_t)&v52);
      uint64_t v39 = 0x100000006;
      long long v37 = &unk_1EDD19728;
      long long v38 = xmmword_18E1FD770;
      uint64_t v40 = v41;
      sub_18DFE2AA8((uint64_t)&v78, (uint64_t)&v62, (uint64_t)&v37);
      int v24 = v38;
      int v23 = DWORD1(v38);
      uint64_t v88 = 0x600000001;
      int v86 = &unk_1EDD18348;
      long long v89 = v90;
      *(void *)&long long v87 = __PAIR64__(v38, DWORD1(v38));
      DWORD2(v87) = v38 * DWORD1(v38);
      HIDWORD(v87) = DWORD1(v38);
      if (DWORD1(v38))
      {
        int v25 = 0;
        int v26 = 0;
        int v27 = HIDWORD(v38);
        int v28 = v40;
        do
        {
          int v29 = v25;
          int v30 = v26;
          for (int i = v24; i; --i)
          {
            v90[v30] = *(void *)&v28[8 * v29];
            v30 += v23;
            ++v29;
          }
          ++v26;
          v25 += v27;
        }
        while (v26 != v23);
      }
      uint64_t v59 = 0x600000006;
      uint64_t v57 = &unk_1EDD197B8;
      long long v58 = xmmword_18E1F8570;
      unsigned int v60 = (double *)&v61;
      sub_18DFE2B44((uint64_t)&v52, (uint64_t)&v86, (uint64_t)&v57);
      double v32 = *v60 + *a7;
      *a7 = v32;
      ++v10;
      a5 += 36;
    }
    while (v10 != a2);
  }
  else
  {
    double v32 = 0.0;
  }
  *a7 = v32 / (double)a2;
  return 0;
}

uint64_t trackrun::ConvertProtobufToGEOMapRunningTrackDataEvent(trackrun *this, const CoreNavigation::CLP::LogEntry::PrivateData::GEOMapTropicalSavannaData *a2, trackrun::GEOMapRunningTrackDataEvent *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  if ((*((unsigned char *)this + 48) & 1) == 0) {
    return 0;
  }
  uint64_t v13 = *((void *)this + 1);
  if (!v13)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
    uint64_t v13 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::GEOMapTropicalSavannaData::default_instance_ + 8);
  }
  int v14 = trackrun::ConvertProtobufToTrackRunTime(v13, (uint64_t)a2 + 32, 0, a4, a5, a6, a7, a8, a9, a10);
  uint64_t v10 = 0;
  if (v14)
  {
    uint64_t v15 = *((void *)a2 + 1);
    uint64_t v199 = (uint64_t *)((char *)a2 + 8);
    for (uint64_t i = *((void *)a2 + 2); i != v15; sub_18E1BDAAC(i))
      i -= 104;
    *((void *)a2 + 2) = v15;
    uint64_t v17 = (char *)sub_18E1BBEB4(v199, *((int *)this + 6));
    if ((*((unsigned char *)this + 48) & 4) != 0) {
      *((unsigned char *)a2 + 80) = *((unsigned char *)this + 40);
    }
    uint64_t v23 = *((int *)this + 6);
    uint64_t v10 = 1;
    if (v23)
    {
      int v24 = (void *)*((void *)this + 2);
      uint64_t v200 = &v24[v23];
      uint64_t v198 = (char *)a2 + 24;
      int8x16_t v201 = a2;
      while (1)
      {
        int8x16_t v202 = v24;
        uint64_t v25 = *v24;
        v209[0] = 0;
        v209[1] = 0;
        unsigned int v210 = 0;
        LOBYTE(v214) = 0;
        BYTE8(v214) = 0;
        unint64_t v215 = 0;
        long long v212 = 0u;
        memset(v213, 0, 20);
        uint64_t v203 = v25;
        unint64_t v26 = *(int *)(v25 + 24);
        if (v26)
        {
          if ((v26 & 0x80000000) != 0) {
            sub_18DEE1FC8();
          }
          *((void *)&v206 + 1) = v213;
          __p[0] = sub_18E1BDD00((uint64_t)v213, v26);
          __p[1] = __p[0];
          unint64_t v205 = (unint64_t)__p[0];
          *(void *)&long long v206 = (char *)__p[0] + 72 * v27;
          sub_18E1BDC88((uint64_t *)&v212, __p);
          uint64_t v17 = (char *)sub_18E1BDE84((uint64_t)__p);
          uint64_t v28 = *(int *)(v203 + 24);
          if (v28)
          {
            int v29 = *(uint64_t **)(v203 + 16);
            int v30 = &v29[v28];
            do
            {
              uint64_t v31 = *v29;
              if (*(_DWORD *)(*v29 + 16))
              {
                BYTE8(v206) = 0;
                LOBYTE(v207) = 0;
                BYTE8(v207) = 0;
                LOBYTE(v208) = 0;
                __p[1] = 0;
                unint64_t v205 = 0;
                LODWORD(v206) = 0;
                __p[0] = 0;
                *((void *)&v208 + 1) = 0xBFF0000000000000;
                sub_18E12F808(__p, *(int *)(v31 + 16));
                uint64_t v32 = *(int *)(v31 + 16);
                if (v32)
                {
                  int v33 = *(uint64_t **)(v31 + 8);
                  int v34 = &v33[v32];
                  do
                  {
                    uint64_t v35 = *v33;
                    if ((~*(_DWORD *)(*v33 + 28) & 3) != 0)
                    {
                      LOWORD(v217[0]) = 13;
                      unsigned __int8 v216 = 2;
                      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v217, &v216, "Warning,coordinate has no data", v18, v19, v20, v21, v22, v197);
                    }
                    else
                    {
                      double v36 = *(double *)(v35 + 8);
                      if (v36 < -90.0 || v36 > 90.0)
                      {
                        LOWORD(v217[0]) = 13;
                        unsigned __int8 v216 = 4;
                        cnprint::CNPrinter::Print((cnprint::CNPrinter *)v217, &v216, "Coordinate has invalid latitude,%.7lf", v18, v19, v20, v21, v22, SLOBYTE(v36));
                      }
                      else
                      {
                        double v37 = *(double *)(v35 + 16);
                        if (v37 < -180.0 || v37 > 360.0)
                        {
                          LOWORD(v217[0]) = 13;
                          unsigned __int8 v216 = 4;
                          cnprint::CNPrinter::Print((cnprint::CNPrinter *)v217, &v216, "Coordinate has invalid longitude,%.7lf", v18, v19, v20, v21, v22, SLOBYTE(v37));
                        }
                        else
                        {
                          long long v38 = (double *)__p[1];
                          if (__p[1] >= (void *)v205)
                          {
                            int64_t v40 = ((char *)__p[1] - (char *)__p[0]) >> 4;
                            unint64_t v41 = v40 + 1;
                            if ((unint64_t)(v40 + 1) >> 60) {
                              sub_18DEE1FC8();
                            }
                            uint64_t v42 = v205 - (unint64_t)__p[0];
                            if ((uint64_t)(v205 - (unint64_t)__p[0]) >> 3 > v41) {
                              unint64_t v41 = v42 >> 3;
                            }
                            if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF0) {
                              unint64_t v43 = 0xFFFFFFFFFFFFFFFLL;
                            }
                            else {
                              unint64_t v43 = v41;
                            }
                            if (v43) {
                              uint64_t v44 = (char *)sub_18DFF7B64((uint64_t)&v205, v43);
                            }
                            else {
                              uint64_t v44 = 0;
                            }
                            int v45 = (double *)&v44[16 * v40];
                            *int v45 = v36;
                            v45[1] = v37;
                            int v47 = (char *)__p[0];
                            uint64_t v46 = (char *)__p[1];
                            long long v48 = v45;
                            if (__p[1] != __p[0])
                            {
                              do
                              {
                                *((_OWORD *)v48 - 1) = *((_OWORD *)v46 - 1);
                                v48 -= 2;
                                v46 -= 16;
                              }
                              while (v46 != v47);
                              uint64_t v46 = (char *)__p[0];
                            }
                            uint64_t v39 = v45 + 2;
                            __p[0] = v48;
                            __p[1] = v45 + 2;
                            unint64_t v205 = (unint64_t)&v44[16 * v43];
                            if (v46) {
                              operator delete(v46);
                            }
                          }
                          else
                          {
                            *(double *)__p[1] = v36;
                            v38[1] = v37;
                            uint64_t v39 = v38 + 2;
                          }
                          __p[1] = v39;
                        }
                      }
                    }
                    ++v33;
                  }
                  while (v33 != v34);
                }
                uint64_t v17 = (char *)__p[0];
                if (__p[0] != __p[1])
                {
                  double v49 = *(double *)__p[0];
                  double v50 = *((double *)__p[1] - 2);
                  if (*(double *)__p[0] != v50)
                  {
                    if ((*(void *)&v49 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                      || (*(void *)&v50 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                    {
                      goto LABEL_66;
                    }
                    double v84 = vabdd_f64(v49, v50);
                    double v85 = fabs(v49);
                    double v86 = fabs(v50);
                    if (v85 < v86) {
                      double v85 = v86;
                    }
                    double v87 = v85 >= 1.0 ? v85 * 2.22044605e-16 : 2.22044605e-16;
                    if (v84 > v87) {
                      goto LABEL_66;
                    }
                  }
                  *(void *)&long long v51 = *((void *)__p[0] + 1);
                  double v52 = *((double *)__p[1] - 1);
                  if (*(double *)&v51 != v52)
                  {
                    if (((unint64_t)v51 & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL
                      || (*(void *)&v52 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                    {
                      goto LABEL_66;
                    }
                    double v54 = vabdd_f64(*(double *)&v51, v52);
                    double v55 = fabs(*(double *)&v51);
                    double v56 = fabs(v52);
                    if (v55 < v56) {
                      double v55 = v56;
                    }
                    *(double *)&long long v51 = v55 >= 1.0 ? v55 * 2.22044605e-16 : 2.22044605e-16;
                    if (v54 > *(double *)&v51)
                    {
LABEL_66:
                      LOWORD(v217[0]) = 13;
                      unsigned __int8 v216 = 2;
                      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v217, &v216, "Warning,Lane is not closed, as expected. Closing it", v18, v19, v20, v21, v22, v197);
                      long long v58 = __p[1];
                      uint64_t v60 = *((void *)__p[1] - 2);
                      uint64_t v59 = *((void *)__p[1] - 1);
                      if (__p[1] >= (void *)v205)
                      {
                        int64_t v62 = ((char *)__p[1] - (char *)__p[0]) >> 4;
                        unint64_t v63 = v62 + 1;
                        if ((unint64_t)(v62 + 1) >> 60) {
                          sub_18DEE1FC8();
                        }
                        uint64_t v64 = v205 - (unint64_t)__p[0];
                        if ((uint64_t)(v205 - (unint64_t)__p[0]) >> 3 > v63) {
                          unint64_t v63 = v64 >> 3;
                        }
                        if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF0) {
                          unint64_t v65 = 0xFFFFFFFFFFFFFFFLL;
                        }
                        else {
                          unint64_t v65 = v63;
                        }
                        if (v65) {
                          unsigned int v66 = (char *)sub_18DFF7B64((uint64_t)&v205, v65);
                        }
                        else {
                          unsigned int v66 = 0;
                        }
                        uint64_t v67 = &v66[16 * v62];
                        *(void *)uint64_t v67 = v60;
                        *((void *)v67 + 1) = v59;
                        uint64_t v69 = (char *)__p[0];
                        unsigned int v68 = (char *)__p[1];
                        unsigned int v70 = v67;
                        if (__p[1] != __p[0])
                        {
                          do
                          {
                            long long v51 = *((_OWORD *)v68 - 1);
                            *((_OWORD *)v70 - 1) = v51;
                            v70 -= 16;
                            v68 -= 16;
                          }
                          while (v68 != v69);
                          unsigned int v68 = (char *)__p[0];
                        }
                        uint64_t v61 = v67 + 16;
                        __p[0] = v70;
                        __p[1] = v67 + 16;
                        unint64_t v205 = (unint64_t)&v66[16 * v65];
                        if (v68) {
                          operator delete(v68);
                        }
                      }
                      else
                      {
                        *(void *)__p[1] = v60;
                        v58[1] = v59;
                        uint64_t v61 = v58 + 2;
                      }
                      __p[1] = v61;
                    }
                  }
                  int v71 = *(_DWORD *)(v31 + 32);
                  if (v71 == 3) {
                    int v72 = 2;
                  }
                  else {
                    int v72 = v71 == 2;
                  }
                  LODWORD(v206) = v72;
                  LODWORD(v51) = *(_DWORD *)(v31 + 40);
                  *((double *)&v208 + 1) = (double)(unint64_t)v51 * 0.001;
                  uint64_t v73 = *((void *)&v212 + 1);
                  if (*((void *)&v212 + 1) >= *(void *)v213)
                  {
                    unint64_t v77 = 0x8E38E38E38E38E39 * ((uint64_t)(*((void *)&v212 + 1) - v212) >> 3);
                    unint64_t v78 = v77 + 1;
                    if (v77 + 1 > 0x38E38E38E38E38ELL) {
                      sub_18DEE1FC8();
                    }
                    if (0x1C71C71C71C71C72 * ((uint64_t)(*(void *)v213 - v212) >> 3) > v78) {
                      unint64_t v78 = 0x1C71C71C71C71C72 * ((uint64_t)(*(void *)v213 - v212) >> 3);
                    }
                    if (0x8E38E38E38E38E39 * ((uint64_t)(*(void *)v213 - v212) >> 3) >= 0x1C71C71C71C71C7) {
                      unint64_t v79 = 0x38E38E38E38E38ELL;
                    }
                    else {
                      unint64_t v79 = v78;
                    }
                    v217[4] = v213;
                    if (v79) {
                      int v80 = (char *)sub_18E1BDD00((uint64_t)v213, v79);
                    }
                    else {
                      int v80 = 0;
                    }
                    unsigned int v81 = &v80[72 * v77];
                    v217[0] = v80;
                    v217[1] = v81;
                    v217[3] = &v80[72 * v79];
                    *(void *)unsigned int v81 = 0;
                    *((void *)v81 + 1) = 0;
                    *((void *)v81 + 2) = 0;
                    *(_OWORD *)unsigned int v81 = *(_OWORD *)__p;
                    *((void *)v81 + 2) = v205;
                    __p[0] = 0;
                    __p[1] = 0;
                    unint64_t v205 = 0;
                    long long v82 = v208;
                    long long v83 = v206;
                    *(_OWORD *)(v81 + 40) = v207;
                    *(_OWORD *)(v81 + 24) = v83;
                    *(_OWORD *)(v81 + 56) = v82;
                    v217[2] = v81 + 72;
                    sub_18E1BDC88((uint64_t *)&v212, v217);
                    uint64_t v76 = *((void *)&v212 + 1);
                    sub_18E1BDE84((uint64_t)v217);
                    uint64_t v17 = (char *)__p[0];
                  }
                  else
                  {
                    uint64_t v17 = 0;
                    **((void **)&v212 + 1) = 0;
                    *(void *)(v73 + 8) = 0;
                    *(void *)(v73 + 16) = 0;
                    *(_OWORD *)uint64_t v73 = *(_OWORD *)__p;
                    *(void *)(v73 + 16) = v205;
                    __p[0] = 0;
                    __p[1] = 0;
                    unint64_t v205 = 0;
                    long long v75 = v207;
                    long long v74 = v208;
                    *(_OWORD *)(v73 + 24) = v206;
                    *(_OWORD *)(v73 + 40) = v75;
                    *(_OWORD *)(v73 + 56) = v74;
                    uint64_t v76 = v73 + 72;
                  }
                  *((void *)&v212 + 1) = v76;
                }
                if (v17)
                {
                  __p[1] = v17;
                  operator delete(v17);
                }
              }
              else
              {
                LOWORD(__p[0]) = 13;
                LOBYTE(v217[0]) = 2;
                cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)v217, "Warning,lane has no coordinates", v18, v19, v20, v21, v22, v197);
              }
              ++v29;
            }
            while (v29 != v30);
          }
        }
        int v88 = *(_DWORD *)(v203 + 76);
        if ((v88 & 0x40) != 0) {
          break;
        }
        if (*((void *)&v212 + 1) != (void)v212)
        {
          unint64_t v89 = 0x8E38E38E38E38E39 * ((uint64_t)(*((void *)&v212 + 1) - v212) >> 3);
LABEL_114:
          unint64_t v215 = v89;
          goto LABEL_115;
        }
        unint64_t v89 = v215;
LABEL_115:
        if (v89)
        {
          if (v88)
          {
            uint64_t v90 = *(void *)(v203 + 8);
            if (!v90)
            {
              CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v17);
              uint64_t v90 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::GEOMapFeatureTropicalSavanna::default_instance_
                              + 8);
            }
            if (*(int *)(v90 + 48) >= 4)
            {
              uint64_t v91 = *(void *)(v203 + 8);
              if (!v91)
              {
                CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v17);
                uint64_t v91 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::GEOMapFeatureTropicalSavanna::default_instance_
                                + 8);
              }
              uint64_t v92 = *(int *)(v91 + 48);
              if (v92)
              {
                unint64_t v93 = *(uint64_t **)(v91 + 40);
                uint64_t v94 = &v93[v92];
                do
                {
                  uint64_t v95 = *v93;
                  if ((~*(_DWORD *)(*v93 + 28) & 3) != 0)
                  {
                    LOWORD(__p[0]) = 13;
                    LOBYTE(v217[0]) = 2;
                    cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)v217, "Warning,coordinate has no data", v18, v19, v20, v21, v22, v197);
                  }
                  else
                  {
                    double v96 = *(double *)(v95 + 8);
                    if (v96 < -90.0 || v96 > 90.0)
                    {
                      LOWORD(__p[0]) = 13;
                      LOBYTE(v217[0]) = 4;
                      cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)v217, "Coordinate has invalid latitude,%.7lf", v18, v19, v20, v21, v22, SLOBYTE(v96));
                    }
                    else
                    {
                      double v97 = *(double *)(v95 + 16);
                      if (v97 < -180.0 || v97 > 360.0)
                      {
                        LOWORD(__p[0]) = 13;
                        LOBYTE(v217[0]) = 4;
                        cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)v217, "Coordinate has invalid longitude,%.7lf", v18, v19, v20, v21, v22, SLOBYTE(v97));
                      }
                      else
                      {
                        uint64_t v98 = (double *)v209[1];
                        if (v209[1] >= v210)
                        {
                          int64_t v100 = ((char *)v209[1] - (char *)v209[0]) >> 4;
                          unint64_t v101 = v100 + 1;
                          if ((unint64_t)(v100 + 1) >> 60) {
                            sub_18DEE1FC8();
                          }
                          uint64_t v102 = v210 - (char *)v209[0];
                          if ((v210 - (char *)v209[0]) >> 3 > v101) {
                            unint64_t v101 = v102 >> 3;
                          }
                          if ((unint64_t)v102 >= 0x7FFFFFFFFFFFFFF0) {
                            unint64_t v103 = 0xFFFFFFFFFFFFFFFLL;
                          }
                          else {
                            unint64_t v103 = v101;
                          }
                          if (v103) {
                            uint64_t v17 = (char *)sub_18DFF7B64((uint64_t)&v210, v103);
                          }
                          else {
                            uint64_t v17 = 0;
                          }
                          uint64_t v104 = (double *)&v17[16 * v100];
                          *uint64_t v104 = v96;
                          v104[1] = v97;
                          uint64_t v106 = (char *)v209[0];
                          uint64_t v105 = (char *)v209[1];
                          uint64_t v107 = v104;
                          if (v209[1] != v209[0])
                          {
                            do
                            {
                              *((_OWORD *)v107 - 1) = *((_OWORD *)v105 - 1);
                              v107 -= 2;
                              v105 -= 16;
                            }
                            while (v105 != v106);
                            uint64_t v105 = (char *)v209[0];
                          }
                          uint64_t v99 = v104 + 2;
                          v209[0] = v107;
                          v209[1] = v104 + 2;
                          unsigned int v210 = &v17[16 * v103];
                          if (v105) {
                            operator delete(v105);
                          }
                        }
                        else
                        {
                          *(double *)v209[1] = v96;
                          v98[1] = v97;
                          uint64_t v99 = v98 + 2;
                        }
                        v209[1] = v99;
                      }
                    }
                  }
                  ++v93;
                }
                while (v93 != v94);
              }
              goto LABEL_243;
            }
          }
          int v108 = *(void **)(v203 + 8);
          if (v108)
          {
            uint64_t v109 = v108[1];
            goto LABEL_156;
          }
          CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v17);
          int v108 = *(void **)(v203 + 8);
          uint64_t v109 = *(void *)(*(void *)(CoreNavigation::CLP::LogEntry::PrivateData::GEOMapFeatureTropicalSavanna::default_instance_
                                       + 8)
                           + 8);
          if (v108)
          {
LABEL_156:
            uint64_t v110 = v108[4];
            goto LABEL_157;
          }
          CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v17);
          int v108 = *(void **)(v203 + 8);
          uint64_t v110 = *(void *)(*(void *)(CoreNavigation::CLP::LogEntry::PrivateData::GEOMapFeatureTropicalSavanna::default_instance_
                                       + 8)
                           + 32);
          if (v108)
          {
LABEL_157:
            uint64_t v111 = v108[1];
          }
          else
          {
            CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v17);
            int v108 = *(void **)(v203 + 8);
            uint64_t v111 = *(void *)(*(void *)(CoreNavigation::CLP::LogEntry::PrivateData::GEOMapFeatureTropicalSavanna::default_instance_
                                         + 8)
                             + 8);
            if (!v108)
            {
              CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v17);
              int v108 = *(void **)(v203 + 8);
              uint64_t v112 = *(void *)(*(void *)(CoreNavigation::CLP::LogEntry::PrivateData::GEOMapFeatureTropicalSavanna::default_instance_
                                           + 8)
                               + 16);
              if (!v108)
              {
                CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v17);
                int v108 = *(void **)(v203 + 8);
                uint64_t v113 = *(void *)(*(void *)(CoreNavigation::CLP::LogEntry::PrivateData::GEOMapFeatureTropicalSavanna::default_instance_
                                             + 8)
                                 + 24);
                if (!v108)
                {
                  CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v17);
                  int v108 = *(void **)(v203 + 8);
                  uint64_t v114 = *(void *)(*(void *)(CoreNavigation::CLP::LogEntry::PrivateData::GEOMapFeatureTropicalSavanna::default_instance_
                                               + 8)
                                   + 16);
                  if (!v108)
                  {
                    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v17);
                    int v108 = *(void **)(v203 + 8);
                    uint64_t v115 = *(void *)(*(void *)(CoreNavigation::CLP::LogEntry::PrivateData::GEOMapFeatureTropicalSavanna::default_instance_
                                                 + 8)
                                     + 24);
                    if (!v108)
                    {
                      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v17);
                      int v108 = *(void **)(CoreNavigation::CLP::LogEntry::PrivateData::GEOMapFeatureTropicalSavanna::default_instance_
                                        + 8);
                    }
                    goto LABEL_162;
                  }
LABEL_161:
                  uint64_t v115 = v108[3];
LABEL_162:
                  uint64_t v116 = v108[4];
                  uint64_t v117 = v209[1];
                  if (v209[1] >= v210)
                  {
                    int64_t v119 = ((char *)v209[1] - (char *)v209[0]) >> 4;
                    unint64_t v120 = v119 + 1;
                    if ((unint64_t)(v119 + 1) >> 60) {
                      goto LABEL_297;
                    }
                    uint64_t v121 = v210 - (char *)v209[0];
                    if ((v210 - (char *)v209[0]) >> 3 > v120) {
                      unint64_t v120 = v121 >> 3;
                    }
                    if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF0) {
                      unint64_t v122 = 0xFFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v122 = v120;
                    }
                    if (v122) {
                      uint64_t v17 = (char *)sub_18DFF7B64((uint64_t)&v210, v122);
                    }
                    else {
                      uint64_t v17 = 0;
                    }
                    uint64_t v123 = &v17[16 * v119];
                    *(void *)uint64_t v123 = v109;
                    *((void *)v123 + 1) = v110;
                    uint64_t v125 = (char *)v209[0];
                    uint64_t v124 = (char *)v209[1];
                    long long v126 = v123;
                    if (v209[1] != v209[0])
                    {
                      do
                      {
                        *((_OWORD *)v126 - 1) = *((_OWORD *)v124 - 1);
                        v126 -= 16;
                        v124 -= 16;
                      }
                      while (v124 != v125);
                      uint64_t v124 = (char *)v209[0];
                    }
                    uint64_t v118 = v123 + 16;
                    v209[0] = v126;
                    v209[1] = v123 + 16;
                    unsigned int v210 = &v17[16 * v122];
                    if (v124) {
                      operator delete(v124);
                    }
                  }
                  else
                  {
                    *(void *)v209[1] = v109;
                    v117[1] = v110;
                    uint64_t v118 = (char *)(v117 + 2);
                  }
                  v209[1] = v118;
                  if (v118 >= v210)
                  {
                    uint64_t v128 = (v118 - (char *)v209[0]) >> 4;
                    if ((unint64_t)(v128 + 1) >> 60) {
                      goto LABEL_297;
                    }
                    unint64_t v129 = (v210 - (char *)v209[0]) >> 3;
                    if (v129 <= v128 + 1) {
                      unint64_t v129 = v128 + 1;
                    }
                    if ((unint64_t)(v210 - (char *)v209[0]) >= 0x7FFFFFFFFFFFFFF0) {
                      unint64_t v130 = 0xFFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v130 = v129;
                    }
                    if (v130) {
                      uint64_t v17 = (char *)sub_18DFF7B64((uint64_t)&v210, v130);
                    }
                    else {
                      uint64_t v17 = 0;
                    }
                    unint64_t v131 = &v17[16 * v128];
                    *(void *)unint64_t v131 = v111;
                    *((void *)v131 + 1) = v112;
                    uint64_t v133 = (char *)v209[0];
                    uint64_t v132 = (char *)v209[1];
                    char v134 = v131;
                    if (v209[1] != v209[0])
                    {
                      do
                      {
                        *((_OWORD *)v134 - 1) = *((_OWORD *)v132 - 1);
                        v134 -= 16;
                        v132 -= 16;
                      }
                      while (v132 != v133);
                      uint64_t v132 = (char *)v209[0];
                    }
                    uint64_t v127 = v131 + 16;
                    v209[0] = v134;
                    v209[1] = v131 + 16;
                    unsigned int v210 = &v17[16 * v130];
                    if (v132) {
                      operator delete(v132);
                    }
                  }
                  else
                  {
                    *(void *)uint64_t v118 = v111;
                    *((void *)v118 + 1) = v112;
                    uint64_t v127 = v118 + 16;
                  }
                  v209[1] = v127;
                  if (v127 >= v210)
                  {
                    uint64_t v136 = (v127 - (char *)v209[0]) >> 4;
                    if ((unint64_t)(v136 + 1) >> 60) {
                      goto LABEL_297;
                    }
                    unint64_t v137 = (v210 - (char *)v209[0]) >> 3;
                    if (v137 <= v136 + 1) {
                      unint64_t v137 = v136 + 1;
                    }
                    if ((unint64_t)(v210 - (char *)v209[0]) >= 0x7FFFFFFFFFFFFFF0) {
                      unint64_t v138 = 0xFFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v138 = v137;
                    }
                    if (v138) {
                      uint64_t v17 = (char *)sub_18DFF7B64((uint64_t)&v210, v138);
                    }
                    else {
                      uint64_t v17 = 0;
                    }
                    uint64_t v139 = &v17[16 * v136];
                    *(void *)uint64_t v139 = v113;
                    *((void *)v139 + 1) = v114;
                    uint64_t v141 = (char *)v209[0];
                    long long v140 = (char *)v209[1];
                    uint64_t v142 = v139;
                    if (v209[1] != v209[0])
                    {
                      do
                      {
                        *((_OWORD *)v142 - 1) = *((_OWORD *)v140 - 1);
                        v142 -= 16;
                        v140 -= 16;
                      }
                      while (v140 != v141);
                      long long v140 = (char *)v209[0];
                    }
                    long long v135 = v139 + 16;
                    v209[0] = v142;
                    v209[1] = v139 + 16;
                    unsigned int v210 = &v17[16 * v138];
                    if (v140) {
                      operator delete(v140);
                    }
                  }
                  else
                  {
                    *(void *)uint64_t v127 = v113;
                    *((void *)v127 + 1) = v114;
                    long long v135 = v127 + 16;
                  }
                  v209[1] = v135;
                  if (v135 >= v210)
                  {
                    uint64_t v144 = (v135 - (char *)v209[0]) >> 4;
                    if ((unint64_t)(v144 + 1) >> 60) {
                      goto LABEL_297;
                    }
                    unint64_t v145 = (v210 - (char *)v209[0]) >> 3;
                    if (v145 <= v144 + 1) {
                      unint64_t v145 = v144 + 1;
                    }
                    if ((unint64_t)(v210 - (char *)v209[0]) >= 0x7FFFFFFFFFFFFFF0) {
                      unint64_t v146 = 0xFFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v146 = v145;
                    }
                    if (v146) {
                      uint64_t v17 = (char *)sub_18DFF7B64((uint64_t)&v210, v146);
                    }
                    else {
                      uint64_t v17 = 0;
                    }
                    uint64_t v147 = &v17[16 * v144];
                    *(void *)uint64_t v147 = v115;
                    *((void *)v147 + 1) = v116;
                    uint64_t v149 = (char *)v209[0];
                    uint64_t v148 = (char *)v209[1];
                    long long v150 = v147;
                    if (v209[1] != v209[0])
                    {
                      do
                      {
                        *((_OWORD *)v150 - 1) = *((_OWORD *)v148 - 1);
                        v150 -= 16;
                        v148 -= 16;
                      }
                      while (v148 != v149);
                      uint64_t v148 = (char *)v209[0];
                    }
                    uint64_t v143 = v147 + 16;
                    v209[0] = v150;
                    v209[1] = v147 + 16;
                    unsigned int v210 = &v17[16 * v146];
                    if (v148) {
                      operator delete(v148);
                    }
                  }
                  else
                  {
                    *(void *)long long v135 = v115;
                    *((void *)v135 + 1) = v116;
                    uint64_t v143 = v135 + 16;
                  }
                  v209[1] = v143;
                  if (v143 >= v210)
                  {
                    uint64_t v152 = (v143 - (char *)v209[0]) >> 4;
                    if ((unint64_t)(v152 + 1) >> 60) {
LABEL_297:
                    }
                      sub_18DEE1FC8();
                    unint64_t v153 = (v210 - (char *)v209[0]) >> 3;
                    if (v153 <= v152 + 1) {
                      unint64_t v153 = v152 + 1;
                    }
                    if ((unint64_t)(v210 - (char *)v209[0]) >= 0x7FFFFFFFFFFFFFF0) {
                      unint64_t v154 = 0xFFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v154 = v153;
                    }
                    if (v154) {
                      uint64_t v17 = (char *)sub_18DFF7B64((uint64_t)&v210, v154);
                    }
                    else {
                      uint64_t v17 = 0;
                    }
                    long long v155 = &v17[16 * v152];
                    *(void *)long long v155 = v109;
                    *((void *)v155 + 1) = v110;
                    uint64_t v157 = (char *)v209[0];
                    uint64_t v156 = (char *)v209[1];
                    uint64_t v158 = v155;
                    if (v209[1] != v209[0])
                    {
                      do
                      {
                        *((_OWORD *)v158 - 1) = *((_OWORD *)v156 - 1);
                        v158 -= 16;
                        v156 -= 16;
                      }
                      while (v156 != v157);
                      uint64_t v156 = (char *)v209[0];
                    }
                    uint64_t v151 = v155 + 16;
                    v209[0] = v158;
                    v209[1] = v155 + 16;
                    unsigned int v210 = &v17[16 * v154];
                    if (v156) {
                      operator delete(v156);
                    }
                  }
                  else
                  {
                    *(void *)uint64_t v143 = v109;
                    *((void *)v143 + 1) = v110;
                    uint64_t v151 = v143 + 16;
                  }
                  v209[1] = v151;
LABEL_243:
                  if ((void *)((char *)v209[1] - (char *)v209[0]) <= (void *)0x10)
                  {
                    if (v209[1] == v209[0])
                    {
                      v217[0] = &unk_1EDD136B8;
                      __p[0] = "/AppleInternal/Library/BuildRoots/cb09429a-9ee5-11ef-b491-ce2c30f2a3e7/Applications/Xcode"
                               ".app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.2.Internal."
                               "sdk/usr/local/include/boost/geometry/algorithms/centroid.hpp";
                      __p[1] = "BOOL boost::geometry::detail::centroid::range_ok(const Range &, Point &) [Point = boost::"
                               "geometry::model::d2::point_xy<double>, Range = boost::geometry::model::ring<boost::geomet"
                               "ry::model::d2::point_xy<double>, false>]";
                      unint64_t v205 = 159;
                      sub_18E1BDFC4((int8x16_t *)__p);
                    }
                    long long v211 = *(_OWORD *)v209[0];
                    uint64_t v159 = v203;
                  }
                  else
                  {
                    uint64_t v159 = v203;
                    if (v209[0] != v209[1])
                    {
                      double v160 = *(double *)v209[0];
                      if ((char *)v209[0] + 16 != v209[1])
                      {
                        double v161 = *((double *)v209[0] + 1);
                        double v162 = v161 - v161;
                        double v163 = v160 - v160;
                        double v164 = 0.0;
                        uint64_t v165 = 16;
                        double v166 = 0.0;
                        double v167 = 0.0;
                        do
                        {
                          uint64_t v168 = (char *)v209[0] + v165 + 16;
                          double v169 = *(double *)((char *)v209[0] + v165) - v160;
                          double v170 = *(double *)((char *)v209[0] + v165 + 8) - v161;
                          double v171 = v163 * v170 - v162 * v169;
                          double v164 = v164 + v171;
                          double v166 = v166 + v171 * (v163 + v169);
                          double v167 = v167 + v171 * (v162 + v170);
                          v165 += 16;
                          double v162 = v170;
                          double v163 = v169;
                        }
                        while (v168 != v209[1]);
                        if (v164 != 0.0)
                        {
                          if ((*(void *)&v164 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                            goto LABEL_253;
                          }
                          double v172 = fabs(v164);
                          double v173 = 2.22044605e-16;
                          if (v172 >= 1.0) {
                            double v173 = v172 * 2.22044605e-16;
                          }
                          if (v172 > v173)
                          {
LABEL_253:
                            double v174 = v164 * 3.0;
                            if ((*(void *)&v174 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                            {
                              *(double *)&long long v211 = v166 / v174;
                              *((double *)&v211 + 1) = v167 / v174;
                              *(double *)&long long v211 = v166 / v174 + *(double *)v209[0];
                              double v175 = v167 / v174 + *((double *)v209[0] + 1);
                              goto LABEL_259;
                            }
                          }
                        }
                      }
                    }
                  }
                  if (v209[0] != v209[1])
                  {
                    *(void *)&long long v211 = *(void *)v209[0];
                    double v175 = *((double *)v209[0] + 1);
LABEL_259:
                    *((double *)&v211 + 1) = v175;
                  }
                  if ((void *)((char *)v209[1] - (char *)v209[0]) < (void *)0x31)
                  {
                    LOWORD(__p[0]) = 13;
                    LOBYTE(v217[0]) = 4;
                    cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)v217, "Bounding box doesn't have at least four coordinates", v18, v19, v20, v21, v22, v197);
                  }
                  else
                  {
                    if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v17) <= 1)
                    {
                      LOWORD(__p[0]) = 13;
                      LOBYTE(v217[0]) = 1;
                      cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)v217, "bbox,1,%.8lf,%.8lf,2,%.8lf,%.8lf,3,%.8lf,%.8lf,4,%.8lf,%.8lf,center,%.8lf,%.8lf", v176, v177, v178, v179, v180, *(_OWORD *)v209[0]);
                    }
                    if ((void *)((char *)v209[1] - (char *)v209[0]) >= (void *)0x51)
                    {
                      LOWORD(__p[0]) = 13;
                      LOBYTE(v217[0]) = 3;
                      cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)v217, "Warning: Received a non-rectangular bounding box, which is handleable, but unexpected,number of coordinates,%lu", v176, v177, v178, v179, v180, ((char *)v209[1] - (char *)v209[0]) >> 4);
                    }
                  }
                  int v181 = *(_DWORD *)(v159 + 48);
                  if (v181 == 3) {
                    int v182 = 2;
                  }
                  else {
                    int v182 = v181 == 2;
                  }
                  *(_DWORD *)&v213[16] = v182;
                  *(void *)&v213[8] = *(void *)(v159 + 40);
                  unint64_t v183 = *((void *)v201 + 2);
                  unint64_t v184 = *((void *)v201 + 3);
                  if (v183 >= v184)
                  {
                    uint64_t v188 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v183 - *v199) >> 3);
                    unint64_t v189 = v188 + 1;
                    if ((unint64_t)(v188 + 1) > 0x276276276276276) {
                      sub_18DEE1FC8();
                    }
                    unint64_t v190 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v184 - *v199) >> 3);
                    if (2 * v190 > v189) {
                      unint64_t v189 = 2 * v190;
                    }
                    if (v190 >= 0x13B13B13B13B13BLL) {
                      unint64_t v191 = 0x276276276276276;
                    }
                    else {
                      unint64_t v191 = v189;
                    }
                    *((void *)&v206 + 1) = v198;
                    if (v191) {
                      double v192 = (char *)sub_18E1BDB6C((uint64_t)v198, v191);
                    }
                    else {
                      double v192 = 0;
                    }
                    char v193 = &v192[104 * v188];
                    __p[0] = v192;
                    __p[1] = v193;
                    *(void *)&long long v206 = &v192[104 * v191];
                    *(void *)char v193 = 0;
                    *((void *)v193 + 1) = 0;
                    *((void *)v193 + 2) = 0;
                    *(_OWORD *)char v193 = *(_OWORD *)v209;
                    *((void *)v193 + 2) = v210;
                    v209[1] = 0;
                    unsigned int v210 = 0;
                    v209[0] = 0;
                    *(_OWORD *)(v193 + 24) = v211;
                    *((void *)v193 + 6) = 0;
                    *((void *)v193 + 7) = 0;
                    *((void *)v193 + 5) = 0;
                    *(_OWORD *)(v193 + 40) = v212;
                    *((void *)v193 + 7) = *(void *)v213;
                    long long v212 = 0uLL;
                    *(void *)uint64_t v213 = 0;
                    long long v194 = *(_OWORD *)&v213[8];
                    long long v195 = v214;
                    *((void *)v193 + 12) = v215;
                    *((_OWORD *)v193 + 4) = v194;
                    *((_OWORD *)v193 + 5) = v195;
                    unint64_t v205 = (unint64_t)(v193 + 104);
                    sub_18E1BDAF4(v199, __p);
                    unint64_t v187 = *((void *)v201 + 2);
                    sub_18E1BDC38((uint64_t)__p);
                  }
                  else
                  {
                    *(void *)(v183 + 8) = 0;
                    *(void *)(v183 + 16) = 0;
                    *(void *)unint64_t v183 = 0;
                    *(_OWORD *)unint64_t v183 = *(_OWORD *)v209;
                    *(void *)(v183 + 16) = v210;
                    v209[0] = 0;
                    v209[1] = 0;
                    unsigned int v210 = 0;
                    *(_OWORD *)(v183 + 24) = v211;
                    *(void *)(v183 + 48) = 0;
                    *(void *)(v183 + 56) = 0;
                    *(void *)(v183 + 40) = 0;
                    *(_OWORD *)(v183 + 40) = v212;
                    *(void *)(v183 + 56) = *(void *)v213;
                    long long v212 = 0uLL;
                    *(void *)uint64_t v213 = 0;
                    long long v185 = *(_OWORD *)&v213[8];
                    long long v186 = v214;
                    *(void *)(v183 + 96) = v215;
                    *(_OWORD *)(v183 + 64) = v185;
                    *(_OWORD *)(v183 + 80) = v186;
                    unint64_t v187 = v183 + 104;
                  }
                  *((void *)v201 + 2) = v187;
                  goto LABEL_282;
                }
LABEL_160:
                uint64_t v114 = v108[2];
                goto LABEL_161;
              }
LABEL_159:
              uint64_t v113 = v108[3];
              goto LABEL_160;
            }
          }
          uint64_t v112 = v108[2];
          goto LABEL_159;
        }
        LOWORD(__p[0]) = 13;
        LOBYTE(v217[0]) = 3;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)v217, "Warning,track has no lanes", v18, v19, v20, v21, v22, v197);
LABEL_282:
        __p[0] = &v212;
        sub_18E1BDF18((void ***)__p);
        uint64_t v17 = (char *)v209[0];
        if (v209[0])
        {
          v209[1] = v209[0];
          operator delete(v209[0]);
        }
        int v24 = v202 + 1;
        if (v202 + 1 == v200) {
          return 1;
        }
      }
      unint64_t v89 = *(void *)(v203 + 64);
      goto LABEL_114;
    }
  }
  return v10;
}

void sub_18E1BBD1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
}

uint64_t trackrun::ConvertProtobufToTrackRunTime(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  unsigned int v10 = *(_DWORD *)(a1 + 36);
  if ((v10 & 4) != 0)
  {
    a9.i64[0] = *(void *)(a1 + 24);
    long long v19 = 0uLL;
    CNTimeSpan::SetTimeSpan((uint64_t *)&v19, 0, a9, a10);
    v15.i64[1] = *((void *)&v19 + 1);
    *(_OWORD *)(a2 + 8) = v19;
    *(unsigned char *)a2 = 1;
    if (a3 & 1) != 0 && (*(unsigned char *)(a1 + 36))
    {
      v15.i64[0] = *(void *)(a1 + 8);
      long long v19 = 0uLL;
      CNTimeSpan::SetTimeSpan((uint64_t *)&v19, 0, v15, v14);
      *(_OWORD *)(a2 + 32) = v19;
      *(unsigned char *)(a2 + 24) = 1;
    }
    else
    {
      *(unsigned char *)(a2 + 24) = 0;
    }
  }
  else
  {
    LOWORD(v19) = 13;
    unsigned __int8 v18 = 3;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v19, &v18, "ConvertProtobufToTrackRunTime,mach continuous time not present", a4, a5, a6, a7, a8, v17);
  }
  return (v10 >> 2) & 1;
}

{
  unsigned int v10;
  int8x16_t v14;
  int8x16_t v15;
  char v17;
  unsigned __int8 v18;
  long long v19;

  unsigned int v10 = *(_DWORD *)(a1 + 36);
  if ((v10 & 4) != 0)
  {
    a9.i64[0] = *(void *)(a1 + 24);
    long long v19 = 0uLL;
    CNTimeSpan::SetTimeSpan((uint64_t *)&v19, 0, a9, a10);
    v15.i64[1] = *((void *)&v19 + 1);
    *(_OWORD *)(a2 + 8) = v19;
    *(unsigned char *)a2 = 1;
    if (a3 & 1) != 0 && (*(unsigned char *)(a1 + 36))
    {
      v15.i64[0] = *(void *)(a1 + 8);
      long long v19 = 0uLL;
      CNTimeSpan::SetTimeSpan((uint64_t *)&v19, 0, v15, v14);
      *(_OWORD *)(a2 + 32) = v19;
      *(unsigned char *)(a2 + 24) = 1;
    }
    else
    {
      *(unsigned char *)(a2 + 24) = 0;
    }
  }
  else
  {
    LOWORD(v19) = 13;
    unsigned __int8 v18 = 3;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v19, &v18, "ConvertProtobufToTrackRunTime,mach continuous time not present", a4, a5, a6, a7, a8, v17);
  }
  return (v10 >> 2) & 1;
}

uint64_t sub_18E1BBEB4(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0x4EC4EC4EC4EC4EC5 * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x276276276276277) {
      sub_18DEE1FC8();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = sub_18E1BDB6C(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 104 * v6;
    sub_18E1BDAF4(a1, v7);
    return sub_18E1BDC38((uint64_t)v7);
  }
  return result;
}

void sub_18E1BBF60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_18E1BDC38((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t trackrun::ConvertProtobufToRunningTrackLaneType(_DWORD *a1)
{
  if (*a1 == 3) {
    return 2;
  }
  else {
    return *a1 == 2;
  }
}

uint64_t trackrun::ConvertProtobufToRunningTrackType(_DWORD *a1)
{
  if (*a1 == 3) {
    return 2;
  }
  else {
    return *a1 == 2;
  }
}

uint64_t sub_18E1BBFAC(uint64_t a1)
{
  uint64_t v4 = (void **)(a1 + 40);
  sub_18E1BDF18(&v4);
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t trackrun::ConvertProtobufToMovingStateEvent(trackrun *this, const CoreNavigation::CLP::LogEntry::PrivateData::MotionState *a2, trackrun::MovingStateEvent *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  if ((*((unsigned char *)this + 32) & 1) == 0) {
    return 0;
  }
  uint64_t v12 = *((void *)this + 1);
  if (!v12)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
    uint64_t v12 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionState::default_instance_ + 8);
  }
  uint64_t result = trackrun::ConvertProtobufToTrackRunTime(v12, (uint64_t)a2 + 8, 1, a4, a5, a6, a7, a8, a9, a10);
  if (result)
  {
    if ((*((unsigned char *)this + 32) & 4) == 0) {
      return 0;
    }
    uint64_t v14 = *((void *)this + 2);
    if (!v14)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      uint64_t v14 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionState::default_instance_ + 16);
    }
    if ((*(unsigned char *)(v14 + 92) & 1) == 0) {
      return 0;
    }
    uint64_t v15 = *((void *)this + 2);
    if (!v15)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      uint64_t v15 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionState::default_instance_ + 16);
    }
    if ((*(unsigned char *)(v15 + 92) & 2) == 0) {
      return 0;
    }
    uint64_t v16 = *((void *)this + 2);
    if (!v16)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      uint64_t v16 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionState::default_instance_ + 16);
    }
    int v17 = *(_DWORD *)(v16 + 8);
    uint64_t result = 1;
    if (v17 <= 11804)
    {
      if (v17 <= 2009)
      {
        char v18 = 0;
        switch(v17)
        {
          case 0:
            goto LABEL_76;
          case 1:
          case 2:
          case 10:
          case 11:
            char v18 = 1;
            goto LABEL_76;
          case 3:
          case 4:
          case 5:
          case 6:
          case 8:
          case 9:
            goto LABEL_75;
          case 7:
            goto LABEL_71;
          default:
            if ((v17 - 41) <= 0x3B && ((1 << (v17 - 41)) & 0x800000003F08801) != 0) {
              goto LABEL_75;
            }
            break;
        }
        return result;
      }
      if (v17 > 2100)
      {
        if (v17 <= 2149)
        {
          if (v17 == 2101) {
            goto LABEL_75;
          }
          if (v17 != 2105) {
            return result;
          }
        }
        else if (v17 != 2150 && v17 != 3015)
        {
          if (v17 != 3016) {
            return result;
          }
          goto LABEL_75;
        }
LABEL_71:
        char v18 = 2;
LABEL_76:
        *((unsigned char *)a2 + 56) = v18;
        return result;
      }
      char v20 = v17 + 38;
      if ((v17 - 2010) > 0x3D) {
        return result;
      }
      if (((1 << v20) & 0x2480000000005400) == 0)
      {
        if (((1 << v20) & 0x8004000000001) == 0) {
          return result;
        }
        goto LABEL_71;
      }
LABEL_75:
      char v18 = 3;
      goto LABEL_76;
    }
    if (v17 > 15651)
    {
      if (v17 <= 18199)
      {
        if (v17 <= 15732)
        {
          uint64_t v21 = (v17 - 15652);
          if (v21 > 0x3A) {
            return result;
          }
          if (((1 << (v17 - 36)) & 0x400000000800101) == 0)
          {
            if (v21 != 18) {
              return result;
            }
            goto LABEL_71;
          }
          goto LABEL_75;
        }
        if (v17 == 15733 || v17 == 17150) {
          goto LABEL_75;
        }
        int v19 = 18070;
      }
      else if (v17 > 19149)
      {
        if (v17 <= 90602)
        {
          if (v17 == 19150) {
            goto LABEL_75;
          }
          int v19 = 19160;
        }
        else
        {
          if (v17 == 90603 || v17 == 515621) {
            goto LABEL_75;
          }
          int v19 = 515652;
        }
      }
      else
      {
        if ((v17 - 18200) <= 0x28 && ((1 << (v17 - 24)) & 0x10002000001) != 0
          || v17 == 19030)
        {
          goto LABEL_75;
        }
        int v19 = 19090;
      }
    }
    else if (v17 > 15329)
    {
      if ((v17 - 15562) <= 0x3A && ((1 << (v17 + 54)) & 0x401000040000001) != 0
        || (v17 - 15330) <= 0x1E && ((1 << (v17 + 30)) & 0x40100001) != 0)
      {
        goto LABEL_75;
      }
      int v19 = 15460;
    }
    else if (v17 <= 15054)
    {
      if (v17 == 11805 || v17 == 12150) {
        goto LABEL_75;
      }
      int v19 = 15030;
    }
    else
    {
      if ((v17 - 15100) <= 0x32 && ((1 << (v17 + 4)) & 0x4000000000401) != 0
        || (v17 - 15230) <= 0x19 && ((1 << (v17 - 126)) & 0x2000401) != 0)
      {
        goto LABEL_75;
      }
      int v19 = 15055;
    }
    if (v17 != v19) {
      return result;
    }
    goto LABEL_75;
  }
  return result;
}

uint64_t trackrun::ConvertProtobufToLocationType(unsigned int a1)
{
  if (a1 >= 0xE) {
    return 1;
  }
  else {
    return a1;
  }
}

cnprint::CNPrinter *trackrun::ConvertProtobufToPositionEvent(trackrun *this, const CoreNavigation::CLP::LogEntry::PrivateData::Location *a2, trackrun::PositionEvent *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  uint64_t result = 0;
  v75[0] = 0;
  uint64_t v76 = 0;
  uint64_t v77 = 0;
  char v78 = 0;
  uint64_t v79 = 0;
  uint64_t v80 = 0;
  if (*((unsigned char *)this + 100))
  {
    uint64_t v13 = *((void *)this + 1);
    if (!v13)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
      uint64_t v13 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 8);
    }
    int v14 = trackrun::ConvertProtobufToTrackRunTime(v13, (uint64_t)v75, 0, a4, a5, a6, a7, a8, a9, a10);
    uint64_t result = 0;
    if (v14)
    {
      uint64_t v17 = *((void *)this + 3);
      if (!v17)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
        uint64_t v17 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 24);
      }
      if ((*(unsigned char *)(v17 + 362) & 0x10) == 0)
      {
        if (cnprint::CNPrinter::GetLogLevel(result) <= 1)
        {
          v73.i16[0] = 13;
          unsigned __int8 v74 = 1;
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v73, &v74, "location private does not have mach continuous time for position event", v18, v19, v20, v21, v22, v72);
        }
        return 0;
      }
      uint64_t v23 = *((void *)this + 3);
      if (!v23)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(result);
        uint64_t v23 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 24);
      }
      v15.i64[0] = *(void *)(v23 + 128);
      int8x16_t v73 = 0uLL;
      CNTimeSpan::SetTimeSpan(v73.i64, 0, v15, v16);
      int8x16_t v24 = v73;
      *((int8x16_t *)a2 + 1) = v73;
      *((unsigned char *)a2 + 8) = 1;
      unint64_t v26 = (CoreNavigation::CLP::LogEntry::PrivateData *)trackrun::PopulateAllTimeFields((uint64_t)a2 + 8, (uint64_t)v75, v24, v25);
      uint64_t v29 = *((void *)this + 2);
      if (!v29)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
        uint64_t v29 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
      }
      if ((*(unsigned char *)(v29 + 153) & 0x10) != 0)
      {
        uint64_t v32 = *((void *)this + 2);
        if (!v32)
        {
          CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
          uint64_t v32 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
        }
        unint64_t v26 = (CoreNavigation::CLP::LogEntry::PrivateData *)trackrun::ConvertProtobufToLocationType(*(_DWORD *)(v32 + 104));
        *((unsigned char *)a2 + 104) = (_BYTE)v26;
        if ((v26 - 12) < 2) {
          return 0;
        }
        if (v26 == 9 || v26 == 1)
        {
          uint64_t v33 = *((void *)this + 3);
          if (!v33)
          {
            CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
            uint64_t v33 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 24);
          }
          if ((*(unsigned char *)(v33 + 360) & 8) != 0)
          {
            uint64_t v34 = *((void *)this + 3);
            if (!v34)
            {
              CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
              uint64_t v34 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 24);
            }
            v27.i64[0] = *(void *)(v34 + 32);
            goto LABEL_35;
          }
        }
      }
      else
      {
        *((unsigned char *)a2 + 104) = 0;
      }
      uint64_t v30 = *((void *)this + 2);
      if (!v30)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
        uint64_t v30 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
      }
      if ((*(unsigned char *)(v30 + 153) & 2) == 0)
      {
        char v31 = 0;
        goto LABEL_36;
      }
      uint64_t v35 = *((void *)this + 2);
      if (!v35)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
        uint64_t v35 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
      }
      v27.i64[0] = *(void *)(v35 + 80);
LABEL_35:
      int8x16_t v73 = 0uLL;
      unint64_t v26 = (CoreNavigation::CLP::LogEntry::PrivateData *)CNTimeSpan::SetTimeSpan(v73.i64, 0, v27, v28);
      *(int8x16_t *)((char *)a2 + 40) = v73;
      char v31 = 1;
LABEL_36:
      *((unsigned char *)a2 + 32) = v31;
      long long v36 = *(_OWORD *)((char *)a2 + 24);
      *(_OWORD *)((char *)a2 + 56) = *(_OWORD *)((char *)a2 + 8);
      *(_OWORD *)((char *)a2 + 72) = v36;
      *(_OWORD *)((char *)a2 + 88) = *(_OWORD *)((char *)a2 + 40);
      uint64_t v37 = *((void *)this + 2);
      if (!v37)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
        uint64_t v37 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
      }
      if (*(double *)(v37 + 16) <= 0.0) {
        goto LABEL_53;
      }
      uint64_t v38 = *((void *)this + 2);
      if (!v38)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
        uint64_t v38 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
      }
      if ((*(void *)(v38 + 16) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
LABEL_53:
        *((unsigned char *)a2 + 105) = 0;
        *((void *)a2 + 14) = 0;
        *((void *)a2 + 15) = 0;
        goto LABEL_66;
      }
      uint64_t v39 = *((void *)this + 2);
      if (!v39)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
        uint64_t v39 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
      }
      uint64_t v40 = *(void *)(v39 + 8);
      if (!v40)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
        uint64_t v40 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::DaemonLocation::default_instance_ + 8);
      }
      if (fabs(*(double *)(v40 + 8)) >= 2.22044605e-16)
      {
        *((void *)a2 + 14) = 0;
        uint64_t v44 = (void *)((char *)a2 + 112);
        *((unsigned char *)a2 + 105) = 1;
        *((void *)a2 + 15) = 0;
      }
      else
      {
        uint64_t v41 = *((void *)this + 2);
        if (!v41)
        {
          CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
          uint64_t v41 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
        }
        uint64_t v42 = *(void *)(v41 + 8);
        if (!v42)
        {
          CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
          uint64_t v42 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::DaemonLocation::default_instance_ + 8);
        }
        double v43 = fabs(*(double *)(v42 + 16));
        *((void *)a2 + 14) = 0;
        uint64_t v44 = (void *)((char *)a2 + 112);
        *((unsigned char *)a2 + 105) = v43 >= 2.22044605e-16;
        *((void *)a2 + 15) = 0;
        if (v43 < 2.22044605e-16)
        {
LABEL_66:
          uint64_t v50 = *((void *)this + 2);
          if (!v50)
          {
            CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
            uint64_t v50 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
          }
          if (*(double *)(v50 + 32) <= 0.0)
          {
            *((unsigned char *)a2 + 106) = 0;
            *((void *)a2 + 16) = 0;
          }
          else
          {
            uint64_t v51 = *((void *)this + 2);
            if (!v51)
            {
              CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
              uint64_t v51 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
            }
            uint64_t v52 = *(void *)(v51 + 32) & 0x7FFFFFFFFFFFFFFFLL;
            *((unsigned char *)a2 + 106) = v52 < 0x7FF0000000000000;
            *((void *)a2 + 16) = 0;
            if (v52 <= 0x7FEFFFFFFFFFFFFFLL)
            {
              uint64_t v53 = *((void *)this + 2);
              if (!v53)
              {
                CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
                uint64_t v53 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
              }
              double v54 = *(double *)(v53 + 24);
              uint64_t v55 = *((void *)this + 3);
              if (!v55)
              {
                CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
                uint64_t v55 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 24);
              }
              *((double *)a2 + 16) = v54 + *(float *)(v55 + 100);
              uint64_t v56 = *((void *)this + 2);
              if (!v56)
              {
                CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
                uint64_t v56 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
              }
              *((void *)a2 + 18) = *(void *)(v56 + 32);
            }
          }
          uint64_t v57 = *((void *)this + 3);
          if (!v57)
          {
            CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
            uint64_t v57 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 24);
          }
          if ((*(unsigned char *)(v57 + 360) & 1) == 0) {
            goto LABEL_104;
          }
          uint64_t v58 = *((void *)this + 3);
          if (!v58)
          {
            CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
            uint64_t v58 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 24);
          }
          if ((*(unsigned char *)(v58 + 360) & 2) == 0) {
            goto LABEL_104;
          }
          uint64_t v59 = *((void *)this + 3);
          if (!v59)
          {
            CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
            uint64_t v59 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 24);
          }
          if ((*(unsigned char *)(v59 + 360) & 4) == 0) {
            goto LABEL_104;
          }
          uint64_t v60 = *((void *)this + 3);
          if (!v60)
          {
            CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
            uint64_t v60 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 24);
          }
          if ((*(void *)(v60 + 8) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
            goto LABEL_104;
          }
          uint64_t v61 = *((void *)this + 3);
          if (!v61)
          {
            CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
            uint64_t v61 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 24);
          }
          if ((*(void *)(v61 + 16) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
            goto LABEL_104;
          }
          uint64_t v62 = *((void *)this + 3);
          if (!v62)
          {
            CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
            uint64_t v62 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 24);
          }
          if ((*(void *)(v62 + 24) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
            goto LABEL_104;
          }
          uint64_t v63 = *((void *)this + 3);
          if (!v63)
          {
            CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
            uint64_t v63 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 24);
          }
          if (*(double *)(v63 + 8) < 0.0) {
            goto LABEL_104;
          }
          uint64_t v64 = *((void *)this + 3);
          if (!v64)
          {
            CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
            uint64_t v64 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 24);
          }
          if (*(double *)(v64 + 16) < 0.0)
          {
LABEL_104:
            *((unsigned char *)a2 + 184) = 0;
            goto LABEL_105;
          }
          uint64_t v69 = *((void *)this + 3);
          if (!v69)
          {
            CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
            uint64_t v69 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 24);
          }
          double v70 = *(double *)(v69 + 24);
          *((unsigned char *)a2 + 184) = v70 > 0.0;
          if (v70 <= 0.0)
          {
LABEL_105:
            unint64_t v65 = (void *)*((void *)this + 2);
            if (v65)
            {
              *((void *)a2 + 19) = v65[8];
            }
            else
            {
              CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
              unint64_t v65 = (void *)*((void *)this + 2);
              *((void *)a2 + 19) = *(void *)(*(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_
                                                           + 16)
                                               + 64);
              if (!v65)
              {
                CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v66);
                unint64_t v65 = (void *)*((void *)this + 2);
                *((void *)a2 + 21) = *(void *)(*(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_
                                                             + 16)
                                                 + 40);
                if (!v65)
                {
                  CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v67);
                  unint64_t v65 = (void *)*((void *)this + 2);
                  *((void *)a2 + 22) = *(void *)(*(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_
                                                               + 16)
                                                   + 56);
                  if (!v65)
                  {
                    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v68);
                    unint64_t v65 = *(void **)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
                  }
                  goto LABEL_110;
                }
LABEL_109:
                *((void *)a2 + 22) = v65[7];
LABEL_110:
                *((void *)a2 + 20) = v65[9];
                return (cnprint::CNPrinter *)(*((unsigned char *)a2 + 105) != 0);
              }
            }
            *((void *)a2 + 21) = v65[5];
            goto LABEL_109;
          }
          int v71 = (void *)*((void *)this + 3);
          if (v71)
          {
            *((void *)a2 + 24) = v71[1];
          }
          else
          {
            CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
            int v71 = (void *)*((void *)this + 3);
            *((void *)a2 + 24) = *(void *)(*(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_
                                                         + 24)
                                             + 8);
            if (!v71)
            {
              CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
              int v71 = (void *)*((void *)this + 3);
              *((void *)a2 + 25) = *(void *)(*(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_
                                                           + 24)
                                               + 16);
              if (!v71)
              {
                CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
                int v71 = *(void **)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 24);
              }
              goto LABEL_122;
            }
          }
          *((void *)a2 + 25) = v71[2];
LABEL_122:
          *((void *)a2 + 26) = v71[3];
          goto LABEL_105;
        }
      }
      uint64_t v45 = *((void *)this + 2);
      if (!v45)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
        uint64_t v45 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
      }
      uint64_t v46 = *(void *)(v45 + 8);
      if (!v46)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
        uint64_t v46 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::DaemonLocation::default_instance_ + 8);
      }
      *uint64_t v44 = *(void *)(v46 + 8);
      uint64_t v47 = *((void *)this + 2);
      if (!v47)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
        uint64_t v47 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
      }
      uint64_t v48 = *(void *)(v47 + 8);
      if (!v48)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
        uint64_t v48 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::DaemonLocation::default_instance_ + 8);
      }
      *((void *)a2 + 15) = *(void *)(v48 + 16);
      uint64_t v49 = *((void *)this + 2);
      if (!v49)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v26);
        uint64_t v49 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::Location::default_instance_ + 16);
      }
      *((void *)a2 + 17) = *(void *)(v49 + 16);
      goto LABEL_66;
    }
  }
  return result;
}

uint64_t trackrun::ConvertProtobufToTrackRunHintEvent(trackrun *this, const CoreNavigation::CLP::LogEntry::TropicalSavanna::TropicalSavannaHint *a2, trackrun::TrackRunHintEvent *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  if ((*((unsigned char *)this + 36) & 2) == 0) {
    return 0;
  }
  uint64_t v12 = *((void *)this + 2);
  if (!v12)
  {
    CoreNavigation::CLP::LogEntry::TropicalSavanna::protobuf_AddDesc_CoreNavigationCLPTropicalSavannaLogEntry_2eproto(0);
    uint64_t v12 = *(void *)(CoreNavigation::CLP::LogEntry::TropicalSavanna::TropicalSavannaHint::default_instance_ + 16);
  }
  int v18 = trackrun::ConvertProtobufToTrackRunTime(v12, (uint64_t)a2 + 8, 0, a4, a5, a6, a7, a8, a9, a10);
  uint64_t result = 0;
  if (v18)
  {
    if ((*((unsigned char *)this + 36) & 4) != 0)
    {
      int v20 = *((_DWORD *)this + 6);
      if ((v20 - 256) > 0xFFFFFF00)
      {
        *((unsigned char *)a2 + 56) = v20;
        return 1;
      }
      __int16 v22 = 13;
      unsigned __int8 v21 = 4;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v22, &v21, "Invalid lane number,%d", v13, v14, v15, v16, v17, v20);
    }
    return 0;
  }
  return result;
}

uint64_t trackrun::ConvertProtobufToVisitEvent(trackrun *this, const CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit *a2, trackrun::VisitEvent *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  if ((*((unsigned char *)this + 68) & 1) == 0) {
    goto LABEL_5;
  }
  uint64_t v12 = *((void *)this + 1);
  if (!v12)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
    uint64_t v12 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit::default_instance_ + 8);
  }
  if ((trackrun::ConvertProtobufToTrackRunTime(v12, (uint64_t)a2 + 8, 1, a4, a5, a6, a7, a8, a9, a10) & 1) == 0)
  {
LABEL_5:
    __int16 v38 = 13;
    unsigned __int8 v37 = 3;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v38, &v37, "Warning: ConvertProtobufToTrackRunTime,receipt time not present. Proceeding but this is unexpected.", a4, a5, a6, a7, a8, v36);
  }
  if ((*((unsigned char *)this + 68) & 2) == 0) {
    goto LABEL_10;
  }
  uint64_t v15 = *((void *)this + 2);
  if (!v15)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
    uint64_t v15 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit::default_instance_ + 16);
  }
  if ((trackrun::ConvertProtobufToTrackRunTime(v15, (uint64_t)a2 + 56, 1, a4, a5, a6, a7, a8, v13, v14) & 1) == 0)
  {
LABEL_10:
    __int16 v38 = 13;
    unsigned __int8 v37 = 3;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v38, &v37, "ConvertProtobufToTrackRunTime,Arrival time not present. User probably isn't in a known visit location.", a4, a5, a6, a7, a8, v36);
  }
  if ((*((unsigned char *)this + 68) & 4) == 0) {
    goto LABEL_15;
  }
  uint64_t v18 = *((void *)this + 3);
  if (!v18)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
    uint64_t v18 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit::default_instance_ + 24);
  }
  if ((trackrun::ConvertProtobufToTrackRunTime(v18, (uint64_t)a2 + 104, 1, a4, a5, a6, a7, a8, v16, v17) & 1) == 0)
  {
LABEL_15:
    __int16 v38 = 13;
    unsigned __int8 v37 = 3;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v38, &v37, "ConvertProtobufToTrackRunTime,Departure time is not present. User has arrived at a known visit location", a4, a5, a6, a7, a8, v36);
  }
  if ((*((unsigned char *)this + 68) & 8) == 0) {
    goto LABEL_20;
  }
  uint64_t v21 = *((void *)this + 4);
  if (!v21)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
    uint64_t v21 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit::default_instance_ + 32);
  }
  uint64_t v22 = trackrun::ConvertProtobufToTrackRunTime(v21, (uint64_t)a2 + 152, 1, a4, a5, a6, a7, a8, v19, v20);
  if ((v22 & 1) == 0)
  {
LABEL_20:
    __int16 v38 = 13;
    unsigned __int8 v37 = 3;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v38, &v37, "Warning: ConvertProtobufToTrackRunTime,detection time not present. Proceeding, but this is unexpected.", a4, a5, a6, a7, a8, v36);
  }
  if ((*((unsigned char *)this + 68) & 0x20) == 0)
  {
    __int16 v38 = 13;
    unsigned __int8 v37 = 4;
    uint64_t v23 = "ConvertProtobufToTrackRunTime,coordinate not present. Cannot create visit event.";
LABEL_39:
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v38, &v37, v23, a4, a5, a6, a7, a8, v36);
    return 0;
  }
  uint64_t v24 = *((void *)this + 6);
  if (v24)
  {
    *((void *)a2 + 25) = *(void *)(v24 + 8);
  }
  else
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v22);
    uint64_t v24 = *((void *)this + 6);
    *((void *)a2 + 25) = *(void *)(*(void *)(CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit::default_instance_
                                                 + 48)
                                     + 8);
    if (!v24)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v22);
      uint64_t v24 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit::default_instance_ + 48);
    }
  }
  *((void *)a2 + 26) = *(void *)(v24 + 16);
  int v25 = *((_DWORD *)this + 17);
  if ((v25 & 0x40) == 0)
  {
    __int16 v38 = 13;
    unsigned __int8 v37 = 4;
    uint64_t v23 = "Visit does not have an estimated radius. Cannot create visit event.";
    goto LABEL_39;
  }
  *((void *)a2 + 27) = *((void *)this + 7);
  if ((v25 & 0x10) == 0)
  {
    __int16 v38 = 13;
    unsigned __int8 v37 = 4;
    uint64_t v23 = "Visit does not have a place inference. Cannot create visit event";
    goto LABEL_39;
  }
  uint64_t v26 = *((void *)this + 5);
  if (!v26)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v22);
    uint64_t v26 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit::default_instance_ + 40);
  }
  if ((*(unsigned char *)(v26 + 36) & 1) == 0)
  {
    __int16 v38 = 13;
    unsigned __int8 v37 = 4;
    uint64_t v23 = "Visit does not have a user specific place type. Cannot create visit event";
    goto LABEL_39;
  }
  uint64_t v27 = *((void *)this + 5);
  if (!v27)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v22);
    uint64_t v27 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit::default_instance_ + 40);
  }
  if ((*(unsigned char *)(v27 + 36) & 2) == 0)
  {
    __int16 v38 = 13;
    unsigned __int8 v37 = 4;
    uint64_t v23 = "Visit does not have a place inference place type. Cannot create visit event";
    goto LABEL_39;
  }
  uint64_t v29 = *((void *)this + 5);
  if (!v29)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v22);
    uint64_t v29 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit::default_instance_ + 40);
  }
  unsigned int v30 = *(_DWORD *)(v29 + 8);
  if (v30 <= 4) {
    *((unsigned char *)a2 + 224) = v30;
  }
  uint64_t v31 = *((void *)this + 5);
  if (!v31)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v22);
    uint64_t v31 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit::default_instance_ + 40);
  }
  unsigned int v32 = *(_DWORD *)(v31 + 12);
  if (v32 <= 2) {
    *((unsigned char *)a2 + 225) = v32 + 1;
  }
  uint64_t v33 = *((void *)this + 5);
  uint64_t v34 = v33;
  if (!v33)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v22);
    uint64_t v34 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit::default_instance_ + 40);
    uint64_t v33 = *((void *)this + 5);
  }
  if ((*(unsigned char *)(v34 + 36) & 4) != 0)
  {
    if (!v33)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v22);
      uint64_t v33 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit::default_instance_ + 40);
    }
    uint64_t v22 = (uint64_t)std::string::operator=((std::string *)((char *)a2 + 232), *(const std::string **)(v33 + 16));
    uint64_t v33 = *((void *)this + 5);
  }
  if (!v33)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v22);
    uint64_t v33 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit::default_instance_ + 40);
  }
  if ((*(unsigned char *)(v33 + 36) & 8) != 0)
  {
    uint64_t v35 = *((void *)this + 5);
    if (!v35)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)v22);
      uint64_t v35 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit::default_instance_ + 40);
    }
    std::string::operator=((std::string *)((char *)a2 + 256), *(const std::string **)(v35 + 24));
  }
  return 1;
}

uint64_t trackrun::ConvertProtobufToWatchStateEvent(trackrun *this, const CoreNavigation::CLP::LogEntry::PrivateData::WatchState *a2, trackrun::WatchStateEvent *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  if ((*((unsigned char *)this + 40) & 1) == 0) {
    return 0;
  }
  uint64_t v13 = *((void *)this + 1);
  if (!v13)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
    uint64_t v13 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::WatchState::default_instance_ + 8);
  }
  int v14 = trackrun::ConvertProtobufToTrackRunTime(v13, (uint64_t)a2 + 8, 0, a4, a5, a6, a7, a8, a9, a10);
  uint64_t result = 0;
  if (v14)
  {
    if ((*((unsigned char *)this + 40) & 4) == 0) {
      return 0;
    }
    uint64_t v15 = *((void *)this + 2);
    if (!v15)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
      uint64_t v15 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::WatchState::default_instance_ + 16);
    }
    if (*(unsigned char *)(v15 + 20))
    {
      uint64_t v17 = *((void *)this + 2);
      if (!v17)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
        uint64_t v17 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::WatchState::default_instance_ + 16);
      }
      unsigned int v18 = *(_DWORD *)(v17 + 8);
      if (v18 > 3)
      {
LABEL_16:
        uint64_t v19 = *((void *)this + 2);
        if (!v19)
        {
          CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
          uint64_t v19 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::WatchState::default_instance_ + 16);
        }
        if ((*(unsigned char *)(v19 + 20) & 2) != 0)
        {
          uint64_t v21 = *((void *)this + 2);
          if (!v21)
          {
            CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
            uint64_t v21 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::WatchState::default_instance_ + 16);
          }
          unsigned int v22 = *(_DWORD *)(v21 + 12);
          if (v22 > 3) {
            return 1;
          }
          unsigned int v20 = 0x2010000u >> (8 * v22);
        }
        else
        {
          LOBYTE(v20) = 0;
        }
        *((unsigned char *)a2 + 56) = v20;
        return 1;
      }
      unsigned int v16 = 0x2010000u >> (8 * v18);
    }
    else
    {
      LOBYTE(v16) = 0;
    }
    *((unsigned char *)a2 + 57) = v16;
    goto LABEL_16;
  }
  return result;
}

uint64_t trackrun::ConvertProtobufToWorkoutSessionEvent(trackrun *this, const CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator *a2, trackrun::WorkoutSessionEvent *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  if ((*((unsigned char *)this + 32) & 1) == 0) {
    return 0;
  }
  uint64_t v13 = *((void *)this + 1);
  if (!v13)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
    uint64_t v13 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 8);
  }
  int v19 = trackrun::ConvertProtobufToTrackRunTime(v13, (uint64_t)a2 + 8, 0, a4, a5, a6, a7, a8, a9, a10);
  uint64_t result = 0;
  if (v19)
  {
    if ((*((unsigned char *)this + 32) & 4) == 0) {
      return 0;
    }
    uint64_t v22 = *((void *)this + 2);
    if (!v22)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
      uint64_t v22 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 16);
    }
    if ((*(unsigned char *)(v22 + 48) & 4) == 0) {
      return 0;
    }
    uint64_t v23 = *((void *)this + 2);
    if (!v23)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      uint64_t v23 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 16);
    }
    if ((*(unsigned char *)(v23 + 48) & 1) == 0) {
      return 0;
    }
    uint64_t v24 = *((void *)this + 2);
    if (!v24)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      uint64_t v24 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 16);
    }
    if ((*(unsigned char *)(v24 + 48) & 0x10) == 0) {
      return 0;
    }
    uint64_t v25 = *((void *)this + 2);
    if (!v25)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      uint64_t v25 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 16);
    }
    uint64_t v26 = *(void *)(v25 + 32);
    if (!v26)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      uint64_t v26 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::WorkoutEvent::default_instance_ + 32);
    }
    if ((*(unsigned char *)(v26 + 40) & 4) == 0) {
      return 0;
    }
    uint64_t v27 = (void *)*((void *)this + 2);
    int8x16_t v28 = v27;
    if (!v27)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      int8x16_t v28 = *(void **)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 16);
      uint64_t v27 = (void *)*((void *)this + 2);
    }
    if ((v28[6] & 8) != 0)
    {
      if (!v27)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
        uint64_t v27 = *(void **)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 16);
      }
      uint64_t v29 = v27[3];
      if (!v29)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
        uint64_t v29 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::WorkoutEvent::default_instance_ + 24);
      }
      unsigned int v30 = (CoreNavigation::CLP::LogEntry::PrivateData *)trackrun::ConvertProtobufToTrackRunTime(v29, (uint64_t)a2 + 8, 1, v14, v15, v16, v17, v18, v20, v21);
      uint64_t v38 = *((void *)this + 2);
      if (!v38)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(v30);
        uint64_t v38 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 16);
      }
      uint64_t v39 = *(void *)(v38 + 24);
      if (!v39)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
        uint64_t v39 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::WorkoutEvent::default_instance_ + 24);
      }
      uint64_t result = trackrun::ConvertProtobufToTrackRunTime(v39, (uint64_t)a2 + 184, 1, v31, v32, v33, v34, v35, v36, v37);
      uint64_t v27 = (void *)*((void *)this + 2);
    }
    uint64_t v40 = v27;
    if (!v27)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      uint64_t v40 = *(void **)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 16);
      uint64_t v27 = (void *)*((void *)this + 2);
    }
    if (v40[6])
    {
      if (!v27)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
        uint64_t v27 = *(void **)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 16);
      }
      uint64_t v41 = v27[1];
      if (!v41)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
        uint64_t v41 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::WorkoutEvent::default_instance_ + 8);
      }
      uint64_t result = trackrun::ConvertProtobufToTrackRunTime(v41, (uint64_t)a2 + 88, 1, v14, v15, v16, v17, v18, v20, v21);
      uint64_t v27 = (void *)*((void *)this + 2);
    }
    uint64_t v42 = v27;
    if (!v27)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      uint64_t v42 = *(void **)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 16);
      uint64_t v27 = (void *)*((void *)this + 2);
    }
    if ((v42[6] & 2) != 0)
    {
      if (!v27)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
        uint64_t v27 = *(void **)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 16);
      }
      uint64_t v43 = v27[2];
      if (!v43)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
        uint64_t v43 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::WorkoutEvent::default_instance_ + 16);
      }
      uint64_t result = trackrun::ConvertProtobufToTrackRunTime(v43, (uint64_t)a2 + 136, 1, v14, v15, v16, v17, v18, v20, v21);
      uint64_t v27 = (void *)*((void *)this + 2);
    }
    if (!v27)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      uint64_t v27 = *(void **)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 16);
    }
    uint64_t v44 = v27[4];
    if (!v44)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      uint64_t v44 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::WorkoutEvent::default_instance_ + 32);
    }
    uint64_t v45 = *((void *)this + 2);
    if (*(unsigned char *)(v44 + 40))
    {
      if (!v45)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
        uint64_t v45 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 16);
      }
      uint64_t v46 = *(void *)(v45 + 32);
      if (!v46)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
        uint64_t v46 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::WorkoutEvent::default_instance_ + 32);
      }
      uint64_t result = (uint64_t)std::string::operator=((std::string *)((char *)a2 + 64), *(const std::string **)(v46 + 8));
      uint64_t v45 = *((void *)this + 2);
    }
    if (!v45)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      uint64_t v45 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 16);
    }
    uint64_t v47 = *(void *)(v45 + 32);
    if (!v47)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      uint64_t v47 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::WorkoutEvent::default_instance_ + 32);
    }
    uint64_t v48 = *(int *)(v47 + 24);
    if (v48 <= 0x42) {
      *((unsigned char *)a2 + 56) = byte_18E22BEEA[v48];
    }
    uint64_t v49 = *((void *)this + 2);
    if (!v49)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      uint64_t v49 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator::default_instance_ + 16);
    }
    uint64_t v50 = *(int *)(v49 + 40);
    if (v50 <= 0x12) {
      *((unsigned char *)a2 + 57) = byte_18E22BF2D[v50];
    }
    return 1;
  }
  return result;
}

uint64_t trackrun::ConvertProtobufToWorkoutSessionEvent(trackrun *this, const CoreNavigation::CLP::LogEntry::PrivateData::MotionStateObserver *a2, trackrun::WorkoutSessionEvent *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  if ((*((unsigned char *)this + 32) & 1) == 0) {
    return 0;
  }
  uint64_t v12 = *((void *)this + 1);
  if (!v12)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
    uint64_t v12 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateObserver::default_instance_ + 8);
  }
  int v18 = trackrun::ConvertProtobufToTrackRunTime(v12, (uint64_t)a2 + 8, 0, a4, a5, a6, a7, a8, a9, a10);
  uint64_t result = 0;
  if (!v18) {
    return result;
  }
  if ((*((unsigned char *)this + 32) & 4) == 0) {
    return 0;
  }
  uint64_t v22 = *((void *)this + 2);
  if (!v22)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
    uint64_t v22 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateObserver::default_instance_ + 16);
  }
  if ((*(unsigned char *)(v22 + 36) & 1) == 0) {
    return 0;
  }
  uint64_t v23 = *((void *)this + 2);
  if (!v23)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
    uint64_t v23 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateObserver::default_instance_ + 16);
  }
  if ((*(unsigned char *)(v23 + 36) & 4) == 0) {
    return 0;
  }
  uint64_t v24 = *((void *)this + 2);
  uint64_t v25 = v24;
  if (!v24)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
    uint64_t v25 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateObserver::default_instance_ + 16);
    uint64_t v24 = *((void *)this + 2);
  }
  if ((*(unsigned char *)(v25 + 36) & 4) != 0)
  {
    if (!v24)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
      uint64_t v24 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateObserver::default_instance_ + 16);
    }
    uint64_t v26 = *(void *)(v24 + 24);
    if (!v26)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(0);
      uint64_t v26 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::WorkoutUpdate::default_instance_ + 24);
    }
    uint64_t result = trackrun::ConvertProtobufToTrackRunTime(v26, (uint64_t)a2 + 88, 1, v13, v14, v15, v16, v17, v19, v20);
    uint64_t v24 = *((void *)this + 2);
  }
  if (!v24)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto((CoreNavigation::CLP::LogEntry::PrivateData *)result);
    uint64_t v24 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::MotionStateObserver::default_instance_ + 16);
  }
  int v27 = *(_DWORD *)(v24 + 16);
  uint64_t result = 1;
  if (v27 > 11804)
  {
    if (v27 <= 15651)
    {
      if (v27 > 15329)
      {
        if ((v27 - 15562) <= 0x3A && ((1 << (v27 + 54)) & 0x401000040000001) != 0
          || (v27 - 15330) <= 0x1E && ((1 << (v27 + 30)) & 0x40100001) != 0)
        {
          goto LABEL_77;
        }
        int v29 = 15460;
        goto LABEL_76;
      }
      if (v27 > 15054)
      {
        if (((v27 - 15100) > 0x32 || ((1 << (v27 + 4)) & 0x4000000000401) == 0)
          && ((v27 - 15230) > 0x19 || ((1 << (v27 - 126)) & 0x2000401) == 0))
        {
          int v29 = 15055;
          goto LABEL_76;
        }
LABEL_77:
        char v28 = 1;
        goto LABEL_78;
      }
      if (v27 != 11805)
      {
        if (v27 == 12150) {
          goto LABEL_77;
        }
        int v29 = 15030;
        goto LABEL_76;
      }
LABEL_73:
      char v28 = 7;
LABEL_78:
      *((unsigned char *)a2 + 56) = v28;
      return result;
    }
    if (v27 <= 18199)
    {
      if (v27 <= 15732)
      {
        if ((v27 - 15652) > 0x3A || ((1 << (v27 - 36)) & 0x400000000840101) == 0) {
          return result;
        }
        goto LABEL_77;
      }
      if (v27 == 15733 || v27 == 17150) {
        goto LABEL_77;
      }
      int v29 = 18070;
    }
    else
    {
      if (v27 <= 19149)
      {
        if ((v27 - 18200) <= 0x28 && ((1 << (v27 - 24)) & 0x10002000001) != 0
          || v27 == 19030)
        {
          goto LABEL_77;
        }
        int v29 = 19090;
        goto LABEL_76;
      }
      if (v27 <= 90602)
      {
        if (v27 == 19150) {
          goto LABEL_77;
        }
        int v29 = 19160;
        goto LABEL_76;
      }
      if (v27 == 90603) {
        goto LABEL_73;
      }
      if (v27 == 515621) {
        goto LABEL_77;
      }
      int v29 = 515652;
    }
LABEL_76:
    if (v27 != v29) {
      return result;
    }
    goto LABEL_77;
  }
  if (v27 <= 2009)
  {
    char v28 = 0;
    switch(v27)
    {
      case 0:
        goto LABEL_78;
      case 1:
      case 2:
      case 3:
      case 5:
      case 6:
      case 7:
      case 9:
      case 10:
      case 11:
        goto LABEL_77;
      case 4:
        goto LABEL_50;
      case 8:
        char v28 = 4;
        goto LABEL_78;
      default:
        if ((v27 - 41) > 0x3B) {
          return result;
        }
        if (((1 << (v27 - 41)) & 0x800000003F08800) != 0) {
          goto LABEL_77;
        }
        if (v27 != 41) {
          return result;
        }
LABEL_50:
        char v28 = 3;
        break;
    }
    goto LABEL_78;
  }
  if ((v27 - 2010) <= 0x3D && ((1 << (v27 + 38)) & 0x2488004000005401) != 0
    || (v27 - 2101) <= 0x31 && ((1 << (v27 - 53)) & 0x2000000000011) != 0
    || (v27 - 3015) < 2)
  {
    goto LABEL_77;
  }
  return result;
}

void sub_18E1BDAAC(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 40);
  sub_18E1BDF18(&v3);
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
}

void sub_18E1BDAF4(uint64_t *a1, void *a2)
{
  sub_18E1BDBB8((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v4;
  uint64_t v5 = *a1;
  *a1 = v4;
  a2[1] = v5;
  uint64_t v6 = a1[1];
  a1[1] = a2[2];
  a2[2] = v6;
  uint64_t v7 = a1[2];
  a1[2] = a2[3];
  a2[3] = v7;
  *a2 = a2[1];
}

void *sub_18E1BDB6C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277) {
    sub_18DEDF7D4();
  }
  return operator new(104 * a2);
}

__n128 sub_18E1BDBB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  if (a3 != a5)
  {
    uint64_t v8 = a7 - 104;
    do
    {
      *(void *)uint64_t v8 = 0;
      *(void *)(v8 + 8) = 0;
      *(void *)(v8 + 16) = 0;
      long long v9 = *(_OWORD *)(a3 - 104);
      a3 -= 104;
      *(_OWORD *)uint64_t v8 = v9;
      *(void *)(v8 + 16) = *(void *)(a3 + 16);
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      *(void *)a3 = 0;
      *(_OWORD *)(v8 + 24) = *(_OWORD *)(a3 + 24);
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(void *)(v8 + 40) = 0;
      *(_OWORD *)(v8 + 40) = *(_OWORD *)(a3 + 40);
      *(void *)(v8 + 56) = *(void *)(a3 + 56);
      *(void *)(a3 + 40) = 0;
      *(void *)(a3 + 48) = 0;
      *(void *)(a3 + 56) = 0;
      __n128 result = *(__n128 *)(a3 + 64);
      long long v11 = *(_OWORD *)(a3 + 80);
      *(void *)(v8 + 96) = *(void *)(a3 + 96);
      *(__n128 *)(v8 + 64) = result;
      *(_OWORD *)(v8 + 80) = v11;
      v8 -= 104;
      v7 -= 104;
    }
    while (a3 != a5);
  }
  return result;
}

uint64_t sub_18E1BDC38(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 104;
    sub_18E1BDAAC(i - 104);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_18E1BDC88(uint64_t *a1, void *a2)
{
  uint64_t result = sub_18E1BDD4C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_18E1BDD00(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL) {
    sub_18DEDF7D4();
  }
  return operator new(72 * a2);
}

uint64_t sub_18E1BDD4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 72) = 0;
      *(void *)(v7 - 64) = 0;
      *(void *)(v7 - 56) = 0;
      long long v8 = *(_OWORD *)(a3 - 72);
      a3 -= 72;
      *(_OWORD *)(v7 - 72) = v8;
      *(void *)(v7 - 56) = *(void *)(a3 + 16);
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      long long v9 = *(_OWORD *)(a3 + 56);
      long long v10 = *(_OWORD *)(a3 + 24);
      *(_OWORD *)(v7 - 32) = *(_OWORD *)(a3 + 40);
      *(_OWORD *)(v7 - 16) = v9;
      *(_OWORD *)(v7 - 48) = v10;
      uint64_t v7 = *((void *)&v16 + 1) - 72;
      *((void *)&v16 + 1) -= 72;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  sub_18E1BDE04((uint64_t)v13);
  return v11;
}

uint64_t sub_18E1BDE04(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_18E1BDE3C(a1);
  }
  return a1;
}

void sub_18E1BDE3C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)v1;
    if (*(void *)v1)
    {
      *(void *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 72;
  }
}

uint64_t sub_18E1BDE84(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_18E1BDEBC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    uint64_t v5 = *(void **)(v2 - 72);
    *(void *)(a1 + 16) = v2 - 72;
    if (v5)
    {
      *(void *)(v2 - 64) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 72;
    }
  }
}

void sub_18E1BDF18(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_18E1BDF6C((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_18E1BDF6C(uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 72);
      v4 -= 72;
      uint64_t v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 64) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void sub_18E1BDFC4(int8x16_t *a1)
{
  exceptiouint64_t n = __cxa_allocate_exception(0x38uLL);
  sub_18E1BE008((uint64_t)exception, a1);
  __cxa_throw(v3, (struct type_info *)&unk_1EDD04800, (void (*)(void *))sub_18E1BE084);
}

int8x16_t sub_18E1BE008(uint64_t a1, int8x16_t *a2)
{
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_1EDD128B0;
  *(void *)(a1 + 8) = &unk_1EDD128E0;
  *(void *)(a1 + 16) = &unk_1EDD12908;
  *(_DWORD *)(a1 + 48) = a2[1].i32[0];
  int8x16_t result = vextq_s8(*a2, *a2, 8uLL);
  *(int8x16_t *)(a1 + 32) = result;
  return result;
}

uint64_t sub_18E1BE084(uint64_t a1)
{
  *(void *)(a1 + 16) = &unk_1EDD136E0;
  sub_18DFE4B84((uint64_t *)(a1 + 24));
  std::exception::~exception((std::exception *)(a1 + 8));
  return a1;
}

void sub_18E1BE0D8()
{
}

void sub_18E1BE298(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_18DFE4B84(&a9);
  sub_18DFE4B84(&a10);
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  _Unwind_Resume(a1);
}

void sub_18E1BE310(uint64_t a1)
{
  exceptiouint64_t n = __cxa_allocate_exception(0x38uLL);
  sub_18E1BE5C4((uint64_t)exception, a1);
  __cxa_throw(exception, (struct type_info *)&unk_1EDD04800, (void (*)(void *))sub_18E1BE084);
}

void sub_18E1BE358(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_18E1BE36C(uint64_t a1)
{
  *(void *)(a1 + 16) = &unk_1EDD136E0;
  sub_18DFE4B84((uint64_t *)(a1 + 24));
  std::exception::~exception((std::exception *)(a1 + 8));

  JUMPOUT(0x192FA6240);
}

void sub_18E1BE3E0(uint64_t a1)
{
  *(void *)(a1 + 8) = &unk_1EDD136E0;
  sub_18DFE4B84((uint64_t *)(a1 + 16));

  std::exception::~exception((std::exception *)a1);
}

void sub_18E1BE43C(uint64_t a1)
{
  *(void *)(a1 + 8) = &unk_1EDD136E0;
  sub_18DFE4B84((uint64_t *)(a1 + 16));
  std::exception::~exception((std::exception *)a1);

  JUMPOUT(0x192FA6240);
}

const char *sub_18E1BE4B4()
{
  return "Boost.Geometry Centroid calculation exception";
}

void sub_18E1BE4C0(void *a1)
{
  *a1 = &unk_1EDD136E0;
  sub_18DFE4B84(a1 + 1);

  std::exception::~exception((std::exception *)a1 - 1);
}

void sub_18E1BE518(void *a1)
{
  *a1 = &unk_1EDD136E0;
  sub_18DFE4B84(a1 + 1);
  std::exception::~exception((std::exception *)a1 - 1);

  JUMPOUT(0x192FA6240);
}

void sub_18E1BE58C(std::exception *a1)
{
  std::exception::~exception(a1);

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1BE5C4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1EDD12A90;
  *(void *)(a1 + 8) = &unk_1EDD136B8;
  uint64_t v4 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = &unk_1EDD136E0;
  *(void *)(a1 + 24) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = v5;
  *(void *)a1 = &unk_1EDD128B0;
  *(void *)(a1 + 8) = &unk_1EDD128E0;
  *(void *)(a1 + 16) = &unk_1EDD12908;
  return a1;
}

void sub_18E1BE6E0(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void trackrun::GEOMapRunningTrackDataEvent::~GEOMapRunningTrackDataEvent(trackrun::GEOMapRunningTrackDataEvent *this)
{
  *(void *)this = &unk_1EDD1A160;
  uint64_t v1 = (void **)((char *)this + 8);
  sub_18E1BEB28(&v1);
}

{
  void **v1;

  *(void *)this = &unk_1EDD1A160;
  uint64_t v1 = (void **)((char *)this + 8);
  sub_18E1BEB28(&v1);
}

{
  void **v2;

  *(void *)this = &unk_1EDD1A160;
  uint64_t v2 = (void **)((char *)this + 8);
  sub_18E1BEB28(&v2);
  MEMORY[0x192FA6240](this, 0x10A1C40BB09DC8BLL);
}

void trackrun::MovingStateEvent::~MovingStateEvent(trackrun::MovingStateEvent *this)
{
}

void trackrun::PositionEvent::~PositionEvent(trackrun::PositionEvent *this)
{
}

void trackrun::TrackRunHintEvent::~TrackRunHintEvent(trackrun::TrackRunHintEvent *this)
{
}

void trackrun::TrackRunSolutionEvent::~TrackRunSolutionEvent(trackrun::TrackRunSolutionEvent *this)
{
}

void trackrun::VisitEvent::~VisitEvent(void **this)
{
  *this = &unk_1EDD19F08;
  if (*((char *)this + 279) < 0) {
    operator delete(this[32]);
  }
  if (*((char *)this + 255) < 0) {
    operator delete(this[29]);
  }
}

{
  uint64_t vars8;

  trackrun::VisitEvent::~VisitEvent(this);

  JUMPOUT(0x192FA6240);
}

void trackrun::WatchStateEvent::~WatchStateEvent(trackrun::WatchStateEvent *this)
{
}

void trackrun::WorkoutSessionEvent::~WorkoutSessionEvent(void **this)
{
  *this = &unk_1EDD1A090;
  if (*((char *)this + 87) < 0) {
    operator delete(this[8]);
  }
}

{
  *this = &unk_1EDD1A090;
  if (*((char *)this + 87) < 0) {
    operator delete(this[8]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EDD1A090;
  if (*((char *)this + 87) < 0) {
    operator delete(this[8]);
  }

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1BEA48(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void *sub_18E1BEA54@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "TrackRunSolutionEvent");
}

uint64_t sub_18E1BEA64(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

void *sub_18E1BEA70@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "GEOMapRunningTrackDataEvent");
}

uint64_t sub_18E1BEA80(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void *sub_18E1BEA8C@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "MovingStateEvent");
}

uint64_t sub_18E1BEA9C(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void *sub_18E1BEAA8@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "PositionEvent");
}

uint64_t sub_18E1BEAB8(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void *sub_18E1BEAC4@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "TrackRunHintEvent");
}

uint64_t sub_18E1BEAD4(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void *sub_18E1BEAE0@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "VisitEvent");
}

uint64_t sub_18E1BEAF0(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void *sub_18E1BEAFC@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "WatchStateEvent");
}

uint64_t sub_18E1BEB0C(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void *sub_18E1BEB18@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "WorkoutSessionEvent");
}

void sub_18E1BEB28(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    long long v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 104;
        sub_18E1BDAAC(v4);
      }
      while ((void *)v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

trackrun::TrackRunParameters *trackrun::TrackRunParameters::TrackRunParameters(trackrun::TrackRunParameters *this, const trackrun::TrackRunPlatformInfo *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  *(_WORD *)this = 0;
  *((unsigned char *)this + 2) = 0;
  sub_18DEDE7B0((void *)this + 1, "trackrun_output.bin");
  *((_WORD *)this + 16) = 1;
  sub_18DEDE7B0((void *)this + 5, "trackrun_debug.txt");
  *((_DWORD *)this + 16) = 256;
  *((_WORD *)this + 34) = 256;
  int v13 = 2;
  uint64_t v14 = 0x40A3880000000000;
  int v15 = 3;
  uint64_t v16 = 0x40A3880000000000;
  int v17 = 4;
  uint64_t v18 = 0x4059000000000000;
  uint64_t v4 = (cnprint::CNPrinter *)sub_18E1BEE04((uint64_t)this + 72, &v13, 3);
  *((void *)this + 14) = 0x410E848000000000;
  *((unsigned char *)this + 120) = 1;
  *((_OWORD *)this + 8) = xmmword_18E22C040;
  *((_OWORD *)this + 9) = xmmword_18E22C050;
  *((_OWORD *)this + 10) = xmmword_18E22C060;
  *((void *)this + 22) = 0x3F50624DD2F1A9FCLL;
  *((void *)this + 23) = 5;
  *((void *)this + 24) = 0x4052C00000000000;
  *((_WORD *)this + 100) = 0;
  *((unsigned char *)this + 202) = 0;
  *((void *)this + 26) = 1;
  *((_WORD *)this + 108) = 256;
  *((_OWORD *)this + 14) = xmmword_18E1FC4D0;
  *((_OWORD *)this + 15) = xmmword_18E22C070;
  *((unsigned char *)this + 256) = 0;
  if (cnprint::CNPrinter::GetLogLevel(v4) <= 1)
  {
    LOWORD(v13) = 13;
    unsigned __int8 v12 = 1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v13, &v12, "Hardware platform %hu received", v5, v6, v7, v8, v9, *(_WORD *)a2);
  }
  if (*(_WORD *)a2)
  {
    *(unsigned char *)this = *((_DWORD *)a2 + 15) == 2;
    char v10 = 1;
  }
  else
  {
    LOWORD(v13) = 13;
    unsigned __int8 v12 = 5;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v13, &v12, "Error: Unsupported hardware type %hu detected", v5, v6, v7, v8, v9, 0);
    char v10 = 0;
  }
  *((unsigned char *)this + 256) = v10;
  return this;
}

void sub_18E1BEDAC(_Unwind_Exception *a1)
{
  sub_18E011990(v4);
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(a1);
}

uint64_t trackrun::TrackRunParameters::IsInitialized(trackrun::TrackRunParameters *this)
{
  return *((unsigned __int8 *)this + 256);
}

uint64_t sub_18E1BEE04(uint64_t a1, int *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 16 * a3;
    do
    {
      sub_18E1BEE7C(a1, a2, a2);
      a2 += 4;
      v5 -= 16;
    }
    while (v5);
  }
  return a1;
}

void sub_18E1BEE68(_Unwind_Exception *a1)
{
  sub_18E011990(v1);
  _Unwind_Resume(a1);
}

void *sub_18E1BEE7C(uint64_t a1, int *a2, _OWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      char v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == v6) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          char v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  char v10 = operator new(0x20uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_OWORD *)v10 + 1) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_18DFF4F38(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_18E1BF084(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t trackrun::PopulateAllTimeFields(uint64_t a1, uint64_t a2, int8x16_t a3, int8x16_t a4)
{
  uint64_t result = CNTimeSpan::operator-(a1 + 8, (void *)(a2 + 8), a3, a4);
  v11[0] = result;
  v11[1] = v9;
  if (*(unsigned char *)(a2 + 24))
  {
    uint64_t result = CNTimeSpan::operator+(a2 + 32, v11, v7, v8);
    *(void *)(a1 + 32) = result;
    *(void *)(a1 + 40) = v10;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return result;
}

uint64_t trackrun::TrackRunLaneEstimator::Configure(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 1497))
  {
    __int16 v28 = 13;
    unsigned __int8 v27 = 2;
    int8x16_t v8 = "TrackRunLaneEstimator::Configure() called more than once";
  }
  else
  {
    uint64_t v10 = *a2;
    if (*a2)
    {
      if (*(unsigned char *)(v10 + 256))
      {
        *(void *)(a1 + 1504) = v10;
        double v11 = *(double *)(v10 + 128);
        if (v11 < 0.0 || (*(void *)(v10 + 128) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || v11 > 1.0) {
          goto LABEL_43;
        }
        double v14 = *(double *)(v10 + 144);
        BOOL v15 = v14 < 0.0 || (*(void *)(v10 + 144) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000;
        if (v15 || v14 > 1.0) {
          goto LABEL_43;
        }
        double v17 = *(double *)(v10 + 152);
        BOOL v18 = v17 < 0.0 || (*(void *)(v10 + 152) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000;
        BOOL v19 = v18 || v17 > 1.0;
        if (v19
          || ((double v20 = *(double *)(v10 + 160), v20 >= 0.0)
            ? (BOOL v21 = (*(void *)(v10 + 160) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
            : (BOOL v21 = 1),
              !v21 ? (BOOL v22 = v20 > 1.0) : (BOOL v22 = 1),
              v22
           || ((double v23 = *(double *)(v10 + 176), v23 >= 0.0)
             ? (BOOL v24 = (*(void *)&v23 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
             : (BOOL v24 = 1),
               !v24 ? (BOOL v25 = v23 > 1.0) : (BOOL v25 = 1),
               v25)))
        {
LABEL_43:
          __int16 v28 = 13;
          unsigned __int8 v27 = 4;
          int8x16_t v8 = "TrackRunPositionContextEstimator::Configure() called with invalid trackrun parameter probabilities";
        }
        else
        {
          if (fabs(v14 + v17 + v20 + -1.0) <= 0.000000015)
          {
            *(unsigned char *)(a1 + 1497) = 1;
            __int16 v28 = 13;
            unsigned __int8 v27 = 2;
            cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v28, &v27, "TrackRunLaneEstimator configured successfully", a4, a5, a6, a7, a8, v26);
            return 0;
          }
          __int16 v28 = 13;
          unsigned __int8 v27 = 4;
          int8x16_t v8 = "TrackRunPositionContextEstimator::Configure() lane transition probabilities don't add up to 1.0";
        }
      }
      else
      {
        __int16 v28 = 13;
        unsigned __int8 v27 = 4;
        int8x16_t v8 = "TrackRunPositionContextEstimator::Configure() called with uninitialized trackrun parameters";
      }
    }
    else
    {
      __int16 v28 = 13;
      unsigned __int8 v27 = 4;
      int8x16_t v8 = "TrackRunPositionContextEstimator::Configure() called with null trackrun parameters";
    }
  }
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v28, &v27, v8, a4, a5, a6, a7, a8, v26);
  return 0xFFFFFFFFLL;
}

uint64_t trackrun::TrackRunLaneEstimator::Initialize(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  *(void *)(v1 + 1488) = 0x3DDB7CDFD9D7BDBBLL;
  int v8 = v2[16];
  *(unsigned char *)(v1 + 1496) = v8;
  if (!v8)
  {
    LOWORD(v125) = 13;
    LOBYTE(v123) = 4;
    BOOL v15 = "TrackRunLaneEstimator::Initialize(), there is not at least one lane on the \t\t\t\t\t\tcurrent track, cannot i"
          "nitialize the lane estimator.";
    goto LABEL_49;
  }
  uint64_t v9 = v2;
  uint64_t v10 = v1;
  int v133 = 1;
  unint64_t v130 = &unk_1EDD17808;
  char v134 = (double *)&v135;
  int v131 = 12;
  long long v132 = xmmword_18E22C090;
  double v11 = (cnprint::CNPrinter *)sub_18DFE2CC8((uint64_t)&v130, 0.0);
  uint64_t v12 = v9[16];
  int v131 = v12;
  LODWORD(v132) = 1;
  DWORD1(v132) = v12;
  DWORD2(v132) = v12;
  uint64_t v13 = *(void *)(v10 + 1504);
  if (*(unsigned char *)(v13 + 120)) {
    double v14 = 1.0 / (double)v12;
  }
  else {
    double v14 = *(double *)(v13 + 128);
  }
  if (v9[88])
  {
    if (v9[80])
    {
      int v16 = v9[80] - 1;
      char v17 = v12 - 1;
      if (v16 < (int)v12 - 1) {
        char v17 = v9[80] - 1;
      }
      if (v12) {
        LOBYTE(v16) = v17;
      }
      double v14 = *(double *)(v13 + 136);
      goto LABEL_14;
    }
    LOWORD(v125) = 13;
    LOBYTE(v123) = 4;
    BOOL v15 = "TrackRunLaneEstimator::Initialize(), provided lane number is invalid. Cannot initialize.";
LABEL_49:
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v125, (unsigned __int8 *)&v123, v15, v3, v4, v5, v6, v7, v63);
    return 0xFFFFFFFFLL;
  }
  LOBYTE(v16) = 0;
LABEL_14:
  if (v12 < 2)
  {
    *char v134 = 1.0;
  }
  else
  {
    uint64_t v18 = v16;
    BOOL v19 = v134;
    uint64_t v20 = v18;
    uint64_t v21 = v12;
    BOOL v22 = v134;
    do
    {
      if (v20) {
        *BOOL v22 = 1.0 / (double)((int)v12 - 1) * (1.0 - v14);
      }
      else {
        v19[v18] = v14;
      }
      ++v22;
      --v20;
      --v21;
    }
    while (v21);
  }
  double v23 = *v134;
  if (v12 >= 2)
  {
    BOOL v24 = v134 + 1;
    uint64_t v25 = v12 - 1;
    do
    {
      double v26 = *v24++;
      double v23 = v23 + v26;
      --v25;
    }
    while (v25);
  }
  if (fabs(v23 + -1.0) > *(double *)(v10 + 1488) && cnprint::CNPrinter::GetLogLevel(v11) <= 1)
  {
    LOWORD(v125) = 2;
    LOBYTE(v123) = 1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v125, (unsigned __int8 *)&v123, "WARNING: HMM initialized with non-normalized probability vector.", v27, v28, v29, v30, v31, v63);
  }
  double v32 = 1.0;
  sub_18E1C1564((uint64_t)&v123, (uint64_t)&v130);
  float64x2_t v33 = (float64x2_t)vdupq_lane_s32((int32x2_t)(v12 | 0x100000000), 0);
  HIDWORD(v33.f64[0]) = 1;
  float64x2_t v124 = v33;
  uint64_t v127 = 0x10000000CLL;
  *(void *)&v33.f64[1] = 0xC0000000CLL;
  long long v126 = xmmword_18E1FD010;
  uint64_t v125 = &unk_1EDD17808;
  uint64_t v128 = &v129;
  v33.f64[0] = 1.0 / v23;
  sub_18DFE3240((uint64_t)&v123, (uint64_t)&v125, v33);
  sub_18DFE2F24(v10 + 1208, (uint64_t)&v125);
  sub_18DFE2F24(v10 + 1344, v10 + 1208);
  *(_DWORD *)(v10 + 1480) = 1;
  uint64_t v39 = *(unsigned __int8 *)(v10 + 1496);
  if (*(unsigned char *)(v10 + 1496))
  {
    double v40 = 0.0;
    double v41 = 0.0;
    int v42 = v39 - 1;
    if (v39 != 1)
    {
      uint64_t v43 = *(double **)(v10 + 1504);
      double v32 = v43[18];
      double v44 = v43[19];
      double v45 = v43[20];
      double v46 = (double)v39 + -3.0;
      if (v46 < 1.0) {
        double v46 = 1.0;
      }
      double v47 = v45 / v46;
      double v48 = v44 + v45;
      if (v39 == 2) {
        double v45 = 0.0;
      }
      if (v39 > 3)
      {
        double v41 = v47;
      }
      else
      {
        double v44 = v48;
        double v41 = v45;
      }
      double v40 = v44 * 0.5;
      if (v39 >= 3 && v41 > v40 + 0.000000015)
      {
        LOWORD(v125) = 13;
        LOBYTE(v123) = 4;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v125, (unsigned __int8 *)&v123, "TrackRunLaneEstimator::Initialize(), probability of moving by one lane is less than the probability of moving by more than one lane, \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trenormalizing to maintain proper transition matrix", v34, v35, v36, v37, v38, v63);
        double v49 = 1.0;
        double v50 = 1.0 - v32;
        if ((double)v42 >= 1.0) {
          double v49 = (double)v42;
        }
        double v40 = v50 / v49;
        double v41 = v50 / v49;
      }
    }
    uint64_t v110 = 0xC0000000CLL;
    uint64_t v105 = &unk_1EDD177A8;
    uint64_t v111 = &v112;
    int v106 = v39;
    int v107 = v39;
    int v108 = v39 * v39;
    int v109 = v39;
    sub_18DFE2CC8((uint64_t)&v105, 0.0);
    int v51 = 0;
    int v52 = v109 + 1;
    uint64_t v53 = v111;
    uint64_t v54 = v39;
    do
    {
      v53[v51] = 0x3FF0000000000000;
      v51 += v52;
      --v54;
    }
    while (v54);
    uint64_t v115 = 0xC0000000CLL;
    uint64_t v113 = &unk_1EDD177A8;
    *(void *)&v55.f64[1] = 0xC00000090;
    long long v114 = xmmword_18E22C0A0;
    uint64_t v116 = &v117;
    v55.f64[0] = v32;
    sub_18DFE3240((uint64_t)&v105, (uint64_t)&v113, v55);
    uint64_t v92 = 0xC0000000CLL;
    double v87 = &unk_1EDD177A8;
    unint64_t v93 = &v94;
    int v88 = v39;
    int v89 = v39;
    int v90 = v39 * v39;
    int v91 = v39;
    sub_18DFE2CC8((uint64_t)&v87, 1.0);
    uint64_t v84 = 0xC0000000CLL;
    uint64_t v79 = &unk_1EDD177A8;
    double v85 = &v86;
    int v80 = v39;
    int v81 = v39;
    int v82 = v39 * v39;
    int v83 = v39;
    sub_18DFE2CC8((uint64_t)&v79, 0.0);
    int v56 = 0;
    int v57 = v83 + 1;
    uint64_t v58 = v85;
    uint64_t v59 = v39;
    do
    {
      v58[v56] = 0x3FF0000000000000;
      v56 += v57;
      --v59;
    }
    while (v59);
    uint64_t v97 = 0xC0000000CLL;
    uint64_t v95 = &unk_1EDD177A8;
    long long v96 = xmmword_18E22C0A0;
    uint64_t v98 = &v99;
    sub_18DFE2AA8((uint64_t)&v87, (uint64_t)&v79, (uint64_t)&v95);
    uint64_t v102 = 0xC0000000CLL;
    int64_t v100 = &unk_1EDD177A8;
    *(void *)&v60.f64[1] = 0xC00000090;
    long long v101 = xmmword_18E22C0A0;
    unint64_t v103 = &v104;
    v60.f64[0] = v41;
    sub_18DFE3240((uint64_t)&v95, (uint64_t)&v100, v60);
    uint64_t v120 = 0xC0000000CLL;
    long long v119 = xmmword_18E22C0A0;
    uint64_t v118 = &unk_1EDD177A8;
    uint64_t v121 = &v122;
    sub_18DFEF1F4((uint64_t)&v113, (uint64_t)&v100, (uint64_t)&v118);
    uint64_t v69 = 0x10000000BLL;
    uint64_t v64 = &unk_1EDD17778;
    double v70 = &v71;
    int v65 = v39 - 1;
    int v66 = 1;
    int v67 = v39 - 1;
    int v68 = v39 - 1;
    sub_18DFE2CC8((uint64_t)&v64, 1.0);
    uint64_t v74 = 0x10000000BLL;
    char v72 = &unk_1EDD17778;
    *(void *)&v61.f64[1] = 0xB0000000BLL;
    long long v73 = xmmword_18E22C0B0;
    long long v75 = &v76;
    v61.f64[0] = v40 - v41;
    sub_18DFE3240((uint64_t)&v64, (uint64_t)&v72, v61);
    sub_18E1C1A7C((uint64_t)v77, (uint64_t)&v72);
    sub_18E1C17E8((uint64_t)v78);
  }
  LOWORD(v125) = 13;
  LOBYTE(v123) = 4;
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v125, (unsigned __int8 *)&v123, "TrackRunLaneEstimator::Initialize(),invalid lane count,%d,could not initialize HMM", v34, v35, v36, v37, v38, 0);
  return 0xFFFFFFFFLL;
}

void sub_18E1BFCC0(_Unwind_Exception *a1)
{
  STACK[0x2C78] = (unint64_t)&unk_1EDD17478;
  sub_18E1C1B68(&STACK[0xBB0]);
  _Unwind_Resume(a1);
}

void *sub_18E1BFD14(void *result)
{
  *uint64_t result = &unk_1EDD17478;
  return result;
}

void *sub_18E1BFD38(void *result)
{
  *uint64_t result = &unk_1EDD17478;
  return result;
}

uint64_t trackrun::TrackRunLaneEstimator::UpdateLaneEstimate(trackrun::TrackRunLaneEstimator *this)
{
  if (!*((unsigned char *)this + 1498)) {
    return 0;
  }
  uint64_t v54 = 0x10000000CLL;
  int v52 = &unk_1EDD17808;
  long long v53 = xmmword_18E1FD010;
  float64x2_t v55 = &v56;
  if (*((_DWORD *)this + 370)) {
    uint64_t v3 = (char *)this + 1344;
  }
  else {
    uint64_t v3 = (char *)this + 1208;
  }
  sub_18DFE2F24((uint64_t)&v52, (uint64_t)v3);
  uint64_t v9 = v53;
  uint64_t v10 = DWORD1(v53);
  if (v53 <= DWORD1(v53)) {
    uint64_t v11 = DWORD1(v53);
  }
  else {
    uint64_t v11 = v53;
  }
  if (v53 && DWORD1(v53) && v11)
  {
    uint64_t v12 = 0;
    uint64_t v13 = v55;
    do
    {
      double v14 = *(double *)((char *)v13 + (v12 >> 29));
      if ((*(void *)&v14 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        return 0;
      }
      if (v14 >= 0.0) {
        double v15 = *(double *)((char *)v13 + (v12 >> 29));
      }
      else {
        double v15 = 0.0;
      }
      if (v14 <= 1.0) {
        double v16 = v15;
      }
      else {
        double v16 = 1.0;
      }
      *(double *)&v13[v12 >> 32] = v16;
      v12 += 0x100000000;
    }
    while (--v11);
  }
  if (v10)
  {
    uint64_t v17 = 0;
    uint64_t v18 = v55;
    int v19 = 1;
    do
    {
      double v20 = *(double *)&v18[(v9 * v17)];
      unsigned int v21 = v19;
      uint64_t v22 = v9 - 1;
      if (v9 >= 2)
      {
        do
        {
          double v20 = v20 + *(double *)&v18[v21++];
          --v22;
        }
        while (v22);
      }
      v51[v17++] = v20;
      v19 += v9;
    }
    while (v17 != v10);
    double v1 = v51[0];
  }
  if (fabs(v1 + -1.0) > 0.000000015)
  {
    LOWORD(v47) = 13;
    LOBYTE(v42) = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v47, (unsigned __int8 *)&v42, "TrackRunPositionContextEstimator::UpdateLaneEstimate() has lane probabilities that don't add up to 1.0,%.3lf,sum_lane_probability. Renormalizing...", v4, v5, v6, v7, v8, SLOBYTE(v1));
    uint64_t v49 = 0x10000000CLL;
    double v47 = &unk_1EDD17808;
    long long v48 = xmmword_18E1FD010;
    double v50 = v51;
    v23.f64[0] = 1.0 / v1;
    sub_18E06E238((uint64_t)&v52, (uint64_t)&v47, v23);
    sub_18DFE2F24((uint64_t)&v52, (uint64_t)&v47);
    uint64_t v29 = DWORD1(v53);
    if (DWORD1(v53))
    {
      uint64_t v30 = 0;
      uint64_t v31 = v53;
      double v32 = v55;
      int v33 = 1;
      do
      {
        double v34 = *(double *)&v32[(v31 * v30)];
        unsigned int v35 = v33;
        uint64_t v36 = v31 - 1;
        if (v31 >= 2)
        {
          do
          {
            double v34 = v34 + *(double *)&v32[v35++];
            --v36;
          }
          while (v36);
        }
        v51[v30++] = v34;
        v33 += v31;
      }
      while (v30 != v29);
      double v37 = v51[0] + -1.0;
    }
    else
    {
      double v37 = NAN;
    }
    if (fabs(v37) > 0.000000015)
    {
      LOWORD(v47) = 13;
      LOBYTE(v42) = 4;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v47, (unsigned __int8 *)&v42, "TrackRunPositionContextEstimator::UpdateLaneEstimate() has lane probabilities that don't add up to 1.0. Cannot update lane estimate.", v24, v25, v26, v27, v28, v41);
      return 0;
    }
  }
  uint64_t v49 = 0x100000001;
  double v47 = &unk_1EDD18048;
  *(void *)&long long v39 = 0x100000001;
  *((void *)&v39 + 1) = 0x100000001;
  long long v48 = v39;
  double v50 = v51;
  uint64_t v44 = 0x100000001;
  int v42 = &unk_1EDD180A8;
  long long v43 = v39;
  double v45 = (int *)&v46;
  sub_18DFE2718((uint64_t)&v52, (uint64_t)&v47, (uint64_t)&v42);
  int v40 = *v45;
  if (!*((unsigned char *)this + 1)) {
    *((unsigned char *)this + 1) = 1;
  }
  *(unsigned char *)this = v40 + 1;
  return 1;
}

void trackrun::TrackRunLaneEstimator::HandleEvidence(trackrun::TrackRunLaneEstimator *a1, double *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v8 = a2[1];
  if (a2[2] > 0.000000015
    && ((double v9 = fabs(*a2), v8 > 0.000000015) ? (v10 = v8 < 20.0) : (v10 = 0), v10 ? (v11 = v9 < 20.0) : (v11 = 0), v11))
  {
    if (!trackrun::TrackRunLaneEstimator::HmmPredictAndUpdate((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8))
    {
      trackrun::TrackRunLaneEstimator::UpdateLaneEstimate(a1);
    }
  }
  else
  {
    __int16 v15 = 13;
    unsigned __int8 v14 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v15, &v14, "Across track distance evidence invalid. Cannot inject into the HMM.", a4, a5, a6, a7, a8, v13);
  }
}

uint64_t trackrun::TrackRunLaneEstimator::HmmPredictAndUpdate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v140[12] = *MEMORY[0x1E4F143B8];
  LOBYTE(v94) = 0;
  char v99 = 0;
  memset(v122, 0, sizeof(v122));
  memset(v137, 0, 23);
  *(_OWORD *)unint64_t v130 = *(_OWORD *)v122;
  *(void *)&v130[16] = *(void *)&v122[16];
  *(void *)&v93[15] = 0;
  *(_OWORD *)unint64_t v93 = *(_OWORD *)v137;
  *(_OWORD *)&v130[7] = *(_OWORD *)(a2 + 24);
  char v90 = 0;
  uint64_t v92 = *(void *)&v130[16];
  long long v91 = *(_OWORD *)v130;
  if (*(unsigned char *)(a1 + 1576))
  {
    uint64_t v94 = &unk_1EDD19FC8;
    long long v95 = *(_OWORD *)(a1 + 1520);
    long long v96 = *(_OWORD *)(a1 + 1536);
    long long v97 = *(_OWORD *)(a1 + 1552);
    char v98 = *(unsigned char *)(a1 + 1568);
    char v99 = 1;
  }
  trackrun::TrackRunLaneEstimator::HmmPredict(a1, (uint64_t)&v90, a3, a4, a5, a6, a7, a8);
  *(void *)unint64_t v130 = 0;
  *(void *)&v130[8] = 0x7FF8000000000000;
  int v133 = 1;
  *(void *)&v130[16] = &unk_1EDD17808;
  char v134 = &v135;
  int v131 = 12;
  long long v132 = xmmword_18E22C090;
  BOOL v10 = (cnstatistics *)sub_18DFE2CC8((uint64_t)&v130[16], 0.0);
  char v136 = 0;
  uint64_t v16 = *(unsigned __int8 *)(a1 + 1496);
  int v131 = v16;
  LODWORD(v132) = 1;
  DWORD1(v132) = v16;
  DWORD2(v132) = v16;
  double v17 = *(double *)(a2 + 16);
  if (fabs(v17) == INFINITY || v17 <= 0.000000015)
  {
    strcpy(v122, "\r");
    v137[0] = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v122, v137, "TrackRunPositionContextEstimator::HmmPredictAndUpdate() failed. Provided evidence has standard deviation with a value of zero or inf,%.1lf", v11, v12, v13, v14, v15, SLOBYTE(v17));
    return 0xFFFFFFFFLL;
  }
  if (v16)
  {
    unint64_t v18 = 0;
    double v19 = *(double *)(a2 + 8);
    double v20 = INFINITY;
    do
    {
      if (v20 >= *(double *)a2 + (double)v18 * v19) {
        double v20 = *(double *)a2 + (double)v18 * v19;
      }
      ++v18;
    }
    while (v16 != v18);
  }
  else
  {
    double v20 = INFINITY;
  }
  if (v20 > v17) {
    double v17 = v20;
  }
  double v21 = v17;
  double v23 = cnstatistics::NormalCDF(v10, *(double *)a2 + *(double *)(a2 + 8) * -0.5, 0.0, v17);
  if (*(unsigned char *)(a1 + 1496))
  {
    double v24 = v23;
    unint64_t v25 = 0;
    do
    {
      double v26 = cnstatistics::NormalCDF(v22, *(double *)a2 + ((double)v25 + 0.5) * *(double *)(a2 + 8), 0.0, v21);
      double v27 = *(double *)(*(void *)(a1 + 1504) + 176);
      if (v27 <= v26 - v24) {
        double v27 = v26 - v24;
      }
      *(double *)&v134[v25++] = v27;
      double v24 = v26;
    }
    while (v25 < *(unsigned __int8 *)(a1 + 1496));
  }
  *(void *)&v122[8] = 0;
  *(void *)&v122[16] = 0x7FF8000000000000;
  uint64_t v125 = 0x10000000CLL;
  uint64_t v123 = &unk_1EDD17808;
  long long v126 = &v127;
  long long v124 = xmmword_18E1FD010;
  sub_18DFE2CC8((uint64_t)&v123, 0.0);
  char v128 = 0;
  long long v129 = *(_OWORD *)(a2 + 24);
  char v136 = *(unsigned char *)(a1 + 1496);
  *(_OWORD *)&v122[8] = *(_OWORD *)v130;
  sub_18DFE2F24((uint64_t)&v123, (uint64_t)&v130[16]);
  char v128 = v136;
  *(void *)uint64_t v122 = sub_18E1C1340;
  if (*(_DWORD *)(a1 + 1480) == 1) {
    sub_18DFE2F24(a1 + 1208, a1 + 1344);
  }
  uint64_t v108 = 0x100000001;
  *(void *)&long long v28 = 0x100000001;
  *((void *)&v28 + 1) = 0x100000001;
  long long v107 = v28;
  v106[12] = &unk_1EDD17EF8;
  int v109 = &v110;
  uint64_t v110 = sub_18E1C1340;
  uint64_t v104 = 0x10000000CLL;
  long long v103 = v28;
  uint64_t v102 = &unk_1EDD177D8;
  uint64_t v105 = v106;
  v106[0] = &v122[8];
  unsigned int v29 = *(_DWORD *)(a1 + 1216);
  unsigned int v30 = *(_DWORD *)(a1 + 1220);
  sub_18DFF2DB8((uint64_t)v100, (uint64_t)&v102);
  if (v29 <= v30) {
    unsigned int v31 = v30;
  }
  else {
    unsigned int v31 = v29;
  }
  if (v30) {
    BOOL v32 = v29 == 0;
  }
  else {
    BOOL v32 = 1;
  }
  if (v32) {
    uint64_t v33 = 0;
  }
  else {
    uint64_t v33 = v31;
  }
  double v34 = *(double *)(a1 + 1488);
  if (!*(_DWORD *)(a1 + 1216) || !*(_DWORD *)(a1 + 1220))
  {
    if ((v33 & 0x80000000) != 0) {
      __assert_rtn("Ones", "cnmatrix.h", 2317, "nr >= 0");
    }
    uint64_t v119 = 0x10000000CLL;
    uint64_t v117 = &unk_1EDD17808;
    uint64_t v120 = (double *)v121;
    *(void *)&long long v118 = v33 | 0x100000000;
    DWORD2(v118) = v33;
    HIDWORD(v118) = v33;
    sub_18DFE2CC8((uint64_t)&v117, 1.0);
    uint64_t v138 = 0x10000000CLL;
    v42.n128_u64[1] = 0xC0000000CLL;
    *(_OWORD *)&v137[8] = xmmword_18E1FD010;
    *(void *)unint64_t v137 = &unk_1EDD17808;
    uint64_t v139 = (double *)v140;
    v42.n128_f64[0] = 1.0 / (double)(int)v33;
    goto LABEL_40;
  }
  uint64_t v138 = 0x10000000CLL;
  *(_OWORD *)&v137[8] = xmmword_18E1FD010;
  *(void *)unint64_t v137 = &unk_1EDD17808;
  uint64_t v139 = (double *)v140;
  unsigned int v35 = (cnprint::CNPrinter *)sub_18DFF2FDC(a1 + 1208, 1, (uint64_t)v137);
  double v36 = *v139;
  if (fabs(*v139 + -1.0) > v34)
  {
    if (cnprint::CNPrinter::GetLogLevel(v35) <= 1)
    {
      *(_WORD *)unint64_t v137 = 2;
      LOBYTE(v117) = 1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v137, (unsigned __int8 *)&v117, "WARNING: HMM update passed a non-normalized probability vector.", v37, v38, v39, v40, v41, v89);
    }
    if ((v33 & 0x80000000) != 0) {
      __assert_rtn("Reshape", "cnmatrix.h", 2936, "nr >= 0");
    }
    __n128 v42 = sub_18E1C1564((uint64_t)&v117, a1 + 1208);
    v42.n128_f64[0] = 1.0 / v36;
    int32x4_t v43 = vdupq_lane_s32((int32x2_t)(v33 | 0x100000000), 0);
    v43.i32[1] = 1;
    long long v118 = (__int128)v43;
    uint64_t v138 = 0x10000000CLL;
    *(_OWORD *)&v137[8] = xmmword_18E1FD010;
    *(void *)unint64_t v137 = &unk_1EDD17808;
    uint64_t v139 = (double *)v140;
LABEL_40:
    sub_18DFE3240((uint64_t)&v117, (uint64_t)v137, (float64x2_t)v42);
    goto LABEL_43;
  }
  if ((v33 & 0x80000000) != 0) {
    __assert_rtn("Reshape", "cnmatrix.h", 2936, "nr >= 0");
  }
  sub_18E1C1564((uint64_t)v137, a1 + 1208);
  int32x4_t v44 = vdupq_lane_s32((int32x2_t)(v33 | 0x100000000), 0);
  v44.i32[1] = 1;
  *(int32x4_t *)&v137[8] = v44;
LABEL_43:
  sub_18DFE2F24(a1 + 1208, (uint64_t)v137);
  sub_18E1C1564((uint64_t)v137, a1 + 1208);
  double v45 = *v109;
  uint64_t v119 = 0x10000000CLL;
  uint64_t v117 = &unk_1EDD17808;
  long long v118 = xmmword_18E1FD010;
  uint64_t v120 = (double *)v121;
  uint64_t v46 = (cnprint::CNPrinter *)((uint64_t (*)(void, void **))v45)(*v101, &v117);
  if (v46)
  {
    LOWORD(v111) = 2;
    unsigned __int8 v116 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v111, &v116, "ERROR: HMM emission function failed.", v47, v48, v49, v50, v51, v89);
    char v58 = 29;
LABEL_66:
    strcpy(v137, "\r");
    LOBYTE(v117) = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v137, (unsigned __int8 *)&v117, "failed to update,code,%d", v53, v54, v55, v56, v57, v58);
    return 0xFFFFFFFFLL;
  }
  if (v33)
  {
    double v59 = 0.0;
    float64x2_t v60 = v120;
    float64x2_t v61 = v120;
    uint64_t v62 = v33;
    do
    {
      double v63 = *v61;
      if (*v61 < 0.0 || v63 > 1.0)
      {
        LOWORD(v111) = 2;
        unsigned __int8 v116 = 4;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v111, &v116, "ERROR: HMM emission probability matrix is invalid.", v47, v48, v49, v50, v51, v89);
        goto LABEL_65;
      }
      double v59 = v59 + v63;
      ++v61;
      --v62;
    }
    while (v62);
    if (fabs(v59) > v34)
    {
      int v65 = v139;
      do
      {
        double v66 = *v60++;
        v52.n128_f64[0] = v66 * *v65;
        *v65++ = v52.n128_f64[0];
        --v33;
      }
      while (v33);
      goto LABEL_58;
    }
LABEL_64:
    LOWORD(v111) = 2;
    unsigned __int8 v116 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v111, &v116, "ERROR: HMM emission probability matrix is null matrix", v47, v48, v49, v50, v51, v89);
LABEL_65:
    char v58 = 30;
    goto LABEL_66;
  }
  if (v34 >= 0.0) {
    goto LABEL_64;
  }
LABEL_58:
  uint64_t v67 = *(unsigned int *)&v137[12];
  if (*(_DWORD *)&v137[12])
  {
    uint64_t v68 = 0;
    uint64_t v69 = *(unsigned int *)&v137[8];
    double v70 = v139;
    int v71 = 1;
    do
    {
      double v72 = v70[(v69 * v68)];
      unsigned int v73 = v71;
      uint64_t v74 = v69 - 1;
      if (v69 >= 2)
      {
        do
        {
          double v72 = v72 + v70[v73++];
          --v74;
        }
        while (v74);
      }
      v115[v68++] = v72;
      v71 += v69;
    }
    while (v68 != v67);
    v52.n128_f64[0] = v115[0];
  }
  if (fabs(v52.n128_f64[0]) < 2.22044605e-16)
  {
    if (cnprint::CNPrinter::GetLogLevel(v46) <= 1)
    {
      LOWORD(v111) = 2;
      unsigned __int8 v116 = 1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v111, &v116, "HMM state is null vector after update; revert to input state",
        v76,
        v77,
        v78,
        v79,
        v80,
        v89);
    }
    __n128 v52 = sub_18DFE2F24((uint64_t)v137, a1 + 1208);
    uint64_t v81 = *(unsigned int *)&v137[12];
    if (*(_DWORD *)&v137[12])
    {
      uint64_t v82 = 0;
      uint64_t v83 = *(unsigned int *)&v137[8];
      uint64_t v84 = v139;
      int v85 = 1;
      do
      {
        double v86 = v84[(v83 * v82)];
        unsigned int v87 = v85;
        uint64_t v88 = v83 - 1;
        if (v83 >= 2)
        {
          do
          {
            double v86 = v86 + v84[v87++];
            --v88;
          }
          while (v88);
        }
        v115[v82++] = v86;
        v85 += v83;
      }
      while (v82 != v81);
      v52.n128_f64[0] = v115[0];
    }
  }
  uint64_t v113 = 0x10000000CLL;
  long long v112 = xmmword_18E1FD010;
  uint64_t v111 = &unk_1EDD17808;
  long long v114 = v115;
  v52.n128_f64[0] = 1.0 / v52.n128_f64[0];
  sub_18DFE3240((uint64_t)v137, (uint64_t)&v111, (float64x2_t)v52);
  sub_18DFE2F24((uint64_t)v137, (uint64_t)&v111);
  sub_18DFE2F24(a1 + 1344, (uint64_t)v137);
  uint64_t result = 0;
  *(_DWORD *)(a1 + 1480) = 1;
  return result;
}

__n128 trackrun::TrackRunLaneEstimator::SetTrackRunHintEvent(__n128 *this, const trackrun::TrackRunHintEvent *a2)
{
  if (this[98].n128_u8[8])
  {
    __n128 result = *(__n128 *)((char *)a2 + 8);
    __n128 v3 = *(__n128 *)((char *)a2 + 24);
    __n128 v4 = *(__n128 *)((char *)a2 + 40);
    this[98].n128_u8[0] = *((unsigned char *)a2 + 56);
    this[97] = v4;
    this[96] = v3;
    this[95] = result;
  }
  else
  {
    this[94].n128_u64[1] = (unint64_t)&unk_1EDD19FC8;
    __n128 result = *(__n128 *)((char *)a2 + 8);
    __n128 v5 = *(__n128 *)((char *)a2 + 24);
    __n128 v6 = *(__n128 *)((char *)a2 + 40);
    this[98].n128_u8[0] = *((unsigned char *)a2 + 56);
    this[97] = v6;
    this[96] = v5;
    this[95] = result;
    this[98].n128_u8[8] = 1;
  }
  return result;
}

uint64_t trackrun::TrackRunLaneEstimator::HmmPredict(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(unsigned char *)(a1 + 1498))
  {
    LOWORD(v81) = 13;
    LOBYTE(v92) = 4;
    int32x4_t v44 = "Failed to predict and update HMM, Uninitialized";
    double v45 = (cnprint::CNPrinter *)&v81;
    uint64_t v46 = &v92;
LABEL_53:
    cnprint::CNPrinter::Print(v45, (unsigned __int8 *)v46, v44, a4, a5, a6, a7, a8, v80);
    return 0xFFFFFFFFLL;
  }
  *(void *)&long long v81 = 0;
  *((void *)&v81 + 1) = 0x7FF8000000000000;
  uint64_t v84 = 0xC0000000CLL;
  uint64_t v82 = &unk_1EDD177A8;
  int v85 = v86;
  long long v83 = xmmword_18E22C0A0;
  sub_18DFE2CC8((uint64_t)&v82, 0.0);
  int v10 = 0;
  int v11 = HIDWORD(v83) + 1;
  uint64_t v12 = 12;
  uint64_t v13 = v85;
  do
  {
    *(void *)&v13[8 * v10] = 0x3FF0000000000000;
    v10 += v11;
    --v12;
  }
  while (v12);
  long long v81 = *(_OWORD *)(a2 + 8);
  LODWORD(v83) = *(unsigned __int8 *)(a1 + 1496);
  DWORD1(v83) = v83;
  DWORD2(v83) = v83 * v83;
  HIDWORD(v83) = v83;
  v86[1152] = v83;
  sub_18DFE2F24((uint64_t)&v82, a1 + 8);
  if (*(unsigned char *)(a2 + 112))
  {
    unsigned int v15 = *(unsigned __int8 *)(a2 + 104);
    if (v15 <= 1) {
      int v16 = 1;
    }
    else {
      int v16 = *(unsigned __int8 *)(a2 + 104);
    }
    if (v15 > *(unsigned __int8 *)(a1 + 1496)) {
      int v16 = *(unsigned __int8 *)(a1 + 1496);
    }
    if (*(unsigned char *)(a1 + 1496)) {
      int v17 = v16;
    }
    else {
      int v17 = *(unsigned __int8 *)(a2 + 104);
    }
    if (cnprint::CNPrinter::GetLogLevel(v14) <= 1)
    {
      LOWORD(v92) = 13;
      LOBYTE(v97) = 1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v92, (unsigned __int8 *)&v97, "HMM Prioritizing lane %d", v18, v19, v20, v21, v22, v17);
    }
    int v23 = DWORD1(v83);
    if (DWORD1(v83))
    {
      int v24 = 0;
      int v25 = 0;
      double v26 = *(double *)(*(void *)(a1 + 1504) + 168);
      int v27 = v17 - 1;
      if (!v17) {
        int v27 = 0;
      }
      long long v28 = v85;
      int v29 = HIDWORD(v83);
      int v30 = v83;
      do
      {
        if (v30)
        {
          double v31 = (1.0 - v26) / (1.0 - *(double *)&v28[8 * v27 + 8 * v25 * v29]);
          int v32 = v24;
          int v33 = v27;
          int v34 = v30;
          do
          {
            double v35 = v31 * *(double *)&v28[8 * v32];
            if (!v33) {
              double v35 = v26;
            }
            *(double *)&v28[8 * v32] = v35;
            --v33;
            ++v32;
            --v34;
          }
          while (v34);
        }
        ++v25;
        v24 += v29;
      }
      while (v25 != v23);
    }
  }
  if (!*(_DWORD *)(a1 + 1480)) {
    sub_18DFE2F24(a1 + 1344, a1 + 1208);
  }
  unsigned int v36 = *(_DWORD *)(a1 + 1352);
  unsigned int v37 = *(_DWORD *)(a1 + 1356);
  if (v36) {
    BOOL v38 = v37 == 0;
  }
  else {
    BOOL v38 = 1;
  }
  int v39 = v38;
  if (v36 <= v37) {
    unsigned int v40 = *(_DWORD *)(a1 + 1356);
  }
  else {
    unsigned int v40 = *(_DWORD *)(a1 + 1352);
  }
  if (v39) {
    unint64_t v41 = 0;
  }
  else {
    unint64_t v41 = v40;
  }
  if (v39 == 1)
  {
    uint64_t v99 = 0x10000000CLL;
    long long v97 = &unk_1EDD17808;
    int64_t v100 = v101;
    long long v98 = xmmword_18E1F8710;
    sub_18DFE2CC8((uint64_t)&v97, 1.0);
    uint64_t v94 = 0x10000000CLL;
    *(void *)&v42.f64[1] = 0xC0000000CLL;
    long long v93 = xmmword_18E1FD010;
    uint64_t v92 = &unk_1EDD17808;
    long long v95 = (double *)v96;
    v42.f64[0] = INFINITY;
    int32x4_t v43 = &v97;
LABEL_47:
    sub_18DFE3240((uint64_t)v43, (uint64_t)&v92, v42);
    goto LABEL_50;
  }
  double v47 = *(double *)(a1 + 1488);
  uint64_t v94 = 0x10000000CLL;
  long long v93 = xmmword_18E1FD010;
  uint64_t v92 = &unk_1EDD17808;
  long long v95 = (double *)v96;
  uint64_t v48 = (cnprint::CNPrinter *)sub_18DFF2FDC(a1 + 1344, 1, (uint64_t)&v92);
  double v49 = *v95;
  if (fabs(*v95 + -1.0) > v47)
  {
    if (cnprint::CNPrinter::GetLogLevel(v48) <= 1)
    {
      LOWORD(v92) = 2;
      LOBYTE(v97) = 1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v92, (unsigned __int8 *)&v97, "WARNING: HMM prediction passed a non-normalized probability vector.", v50, v51, v52, v53, v54, v80);
    }
    if ((v40 & 0x80000000) == 0)
    {
      sub_18E1C1564((uint64_t)&v97, a1 + 1344);
      int32x4_t v55 = vdupq_lane_s32((int32x2_t)(v40 | 0x100000000), 0);
      v55.i32[1] = 1;
      long long v98 = (__int128)v55;
      uint64_t v94 = 0x10000000CLL;
      *(void *)&v42.f64[1] = 0xC0000000CLL;
      long long v93 = xmmword_18E1FD010;
      uint64_t v92 = &unk_1EDD17808;
      long long v95 = (double *)v96;
      v42.f64[0] = 1.0 / v49;
      goto LABEL_47;
    }
LABEL_70:
    __assert_rtn("Reshape", "cnmatrix.h", 2936, "nr >= 0");
  }
  if ((v40 & 0x80000000) != 0) {
    goto LABEL_70;
  }
  sub_18E1C1564((uint64_t)&v92, a1 + 1344);
  int32x4_t v56 = vdupq_lane_s32((int32x2_t)(v40 | 0x100000000), 0);
  v56.i32[1] = 1;
  long long v93 = (__int128)v56;
LABEL_50:
  sub_18DFE2F24(a1 + 1344, (uint64_t)&v92);
  *(_DWORD *)(a1 + 1480) = 1;
  uint64_t v94 = 0xC0000000CLL;
  long long v93 = xmmword_18E22C0A0;
  uint64_t v92 = &unk_1EDD177A8;
  long long v95 = (double *)v96;
  double v63 = (cnprint::CNPrinter *)sub_18E1C12A0((uint64_t)&v81, &v92, v57, v58, v59, v60, v61, v62);
  if (v63)
  {
    LOWORD(v97) = 2;
    LOBYTE(v87) = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v97, (unsigned __int8 *)&v87, "ERROR: HMM transition probability function failed.", v64, v65, v66, v67, v68, v80);
    char v69 = 27;
LABEL_52:
    LOWORD(v92) = 13;
    LOBYTE(v97) = 4;
    char v80 = v69;
    int32x4_t v44 = "failed to predict,code,%d";
    double v45 = (cnprint::CNPrinter *)&v92;
    uint64_t v46 = &v97;
    goto LABEL_53;
  }
  if (v41)
  {
    unint64_t v71 = 0;
    BOOL v72 = 0;
    unsigned int v73 = v95;
LABEL_56:
    double v74 = 0.0;
    long long v75 = v73;
    unint64_t v76 = v41;
    while (1)
    {
      double v77 = *v75;
      if (*v75 < 0.0 || v77 > 1.0) {
        break;
      }
      double v74 = v74 + v77;
      ++v75;
      if (!--v76)
      {
        if (fabs(v74 + -1.0) <= *(double *)(a1 + 1488))
        {
          ++v71;
          v73 += SHIDWORD(v93);
          BOOL v72 = v71 >= v41;
          if (v71 != v41) {
            goto LABEL_56;
          }
        }
        break;
      }
    }
    if (!v72)
    {
      if (cnprint::CNPrinter::GetLogLevel(v63) <= 1)
      {
        LOWORD(v97) = 2;
        LOBYTE(v87) = 1;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v97, (unsigned __int8 *)&v87, "ERROR: HMM transition probability matrix is invalid.", a4, a5, a6, a7, a8, v80);
      }
      char v69 = 28;
      goto LABEL_52;
    }
  }
  uint64_t v99 = 0x10000000CLL;
  long long v98 = xmmword_18E1FD010;
  long long v97 = &unk_1EDD17808;
  int64_t v100 = v101;
  sub_18DFE2B44((uint64_t)&v92, a1 + 1344, (uint64_t)&v97);
  sub_18DFE2F24(a1 + 1208, (uint64_t)&v97);
  uint64_t v89 = 0x10000000CLL;
  long long v88 = xmmword_18E1FD010;
  unsigned int v87 = &unk_1EDD17808;
  char v90 = (double *)&v91;
  sub_18DFF2FDC(a1 + 1208, 1, (uint64_t)&v87);
  v79.f64[0] = 1.0 / *v90;
  uint64_t v99 = 0x10000000CLL;
  long long v98 = xmmword_18E1FD010;
  long long v97 = &unk_1EDD17808;
  int64_t v100 = v101;
  sub_18DFE3240(a1 + 1208, (uint64_t)&v97, v79);
  sub_18DFE2F24(a1 + 1208, (uint64_t)&v97);
  uint64_t result = 0;
  *(_DWORD *)(a1 + 1480) = 0;
  return result;
}

uint64_t sub_18E1C12A0(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(unsigned __int8 *)(a1 + 1208);
  if (v8 < 0xD)
  {
    a2[2] = v8;
    a2[3] = v8;
    a2[4] = v8 * v8;
    a2[5] = v8;
    sub_18DFE2F24((uint64_t)a2, a1 + 16);
    return 0;
  }
  else
  {
    __int16 v12 = 13;
    unsigned __int8 v11 = 4;
    double v9 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v12, &v11, "time,%.3lf,t-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v9));
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_18E1C1340(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned __int8 *)(a1 + 152) <= 0xCu)
  {
    if (!*(unsigned char *)(a1 + 152))
    {
LABEL_18:
      int32x4_t v14 = vdupq_lane_s32((int32x2_t)(*(unsigned __int8 *)(a1 + 152) | 0x100000000), 0);
      v14.i32[1] = 1;
      *(int32x4_t *)(a2 + 8) = v14;
      sub_18DFE2F24(a2, a1 + 16);
      return 0;
    }
    unsigned int v8 = *(uint64_t **)(a1 + 48);
    uint64_t v9 = *(unsigned __int8 *)(a1 + 152);
    while (1)
    {
      uint64_t v10 = *v8 & 0x7FFFFFFFFFFFFFFFLL;
      BOOL v11 = (unint64_t)(v10 - 1) < 0xFFFFFFFFFFFFFLL;
      BOOL v12 = *v8 < 0 && (unint64_t)(v10 - 0x10000000000000) >> 53 < 0x3FF;
      if (*v8 >= 0) {
        BOOL v11 = 0;
      }
      int v13 = v10 == 0x7FF0000000000000 || v11;
      if ((*v8 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FF0000000000000) {
        int v13 = 1;
      }
      if (((v13 | v12) & 1) != 0 || *(double *)v8 > 1.0) {
        break;
      }
      ++v8;
      if (!--v9) {
        goto LABEL_18;
      }
    }
    __int16 v21 = 13;
    unsigned __int8 v20 = 4;
    double v17 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v21, &v20, "time,%.3lf,e-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v17));
  }
  else
  {
    __int16 v19 = 13;
    unsigned __int8 v18 = 4;
    double v16 = *(double *)(a1 + 8) + (double)*(uint64_t *)a1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v19, &v18, "time,%.3lf,e-function failure on line %d: %s() %s", a4, a5, a6, a7, a8, SLOBYTE(v16));
  }
  return 0xFFFFFFFFLL;
}

unsigned char *trackrun::TrackRunLaneEstimator::Reset(unsigned char *this)
{
  this[1498] = 0;
  this[1496] = 0;
  if (this[1]) {
    this[1] = 0;
  }
  if (this[1576]) {
    this[1576] = 0;
  }
  return this;
}

void sub_18E1C14D8(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1C1508(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E1C1514(uint64_t a1)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  sub_18DEF3CF4(a1, v1);
}

__n128 sub_18E1C1564(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0x10000000CLL;
  *(void *)(a1 + 24) = 0x10000000CLL;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EDD17808;
  if (a1 == a2)
  {
    double v17 = "this != &(A)";
    int v18 = 603;
    goto LABEL_16;
  }
  int v3 = *(_DWORD *)(a2 + 8);
  int v4 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = (v4 * v3);
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  __n128 v6 = (unint64_t *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 0xCu)
  {
    double v17 = "this->max_num_rows_ >= A.num_rows_";
    int v18 = 616;
    goto LABEL_16;
  }
  if (*(_DWORD *)(a2 + 12) >= 2u)
  {
    double v17 = "this->max_num_cols_ >= A.num_cols_";
    int v18 = 617;
LABEL_16:
    __assert_rtn("CNMatrix", "cnmatrix.h", v18, v17);
  }
  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    BOOL v11 = *(long long **)(a2 + 32);
    uint64_t v12 = (v7 - 1) >> 1;
    int v13 = v11;
    int32x4_t v14 = (_OWORD *)(a1 + 40);
    do
    {
      long long v15 = *v13++;
      *v14++ = v15;
      --v12;
    }
    while (v12);
    uint64_t v16 = v10;
    __n128 result = *(__n128 *)((char *)v11 + v16 * 8);
    *(__n128 *)&v6[v16] = result;
  }
  else if ((int)v5 >= 1)
  {
    unsigned int v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *v6++ = v9;
      --v5;
    }
    while (v5);
  }
  return result;
}

void sub_18E1C1694(_Unwind_Exception *a1)
{
  *double v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

void sub_18E1C16B4(void *a1)
{
  *a1 = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1C16E4(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E1C16F0(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = 1;
        do
        {
          unint64_t v9 = &v13[v8];
          if (!v13[v8])
          {
            uint64_t v10 = *(void *)(v7 + 8 * v8);
            int v11 = v8;
            do
            {
              int v11 = (int)(v11 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v12 = *(void *)(v7 + 8 * v11);
              *(void *)(v7 + 8 * v11) = v10;
              *unint64_t v9 = 1;
              unint64_t v9 = &v13[v11];
              uint64_t v10 = v12;
            }
            while (!*v9);
          }
          ++v8;
        }
        while (v8 != v6);
      }
    }
  }
}

void sub_18E1C17E8(uint64_t a1)
{
  *(void *)(a1 + 24) = 0x3000000030;
  *(void *)a1 = &unk_1EDD19248;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 8) = xmmword_18E22C0C0;
  sub_18E1C1A00();
}

void sub_18E1C184C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1[5];
  v1[5] = 0;
  if (v3) {
    MEMORY[0x192FA6220](v3, 0x1000C8000313F17);
  }
  *unsigned int v1 = &unk_1EDD17478;
  _Unwind_Resume(exception_object);
}

void sub_18E1C1894(void *a1)
{
  sub_18E1C1B68(a1);

  JUMPOUT(0x192FA6240);
}

void sub_18E1C18CC()
{
}

void sub_18E1C18F8()
{
}

void sub_18E1C1A00()
{
}

double sub_18E1C1A7C(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = 0xC0000000CLL;
  *(void *)(a1 + 24) = 0xC0000000CLL;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EDD177A8;
  int v4 = *(_DWORD *)(a2 + 8);
  int v3 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 8) = v4;
  *(_DWORD *)(a1 + 12) = v3;
  uint64_t v5 = (v3 * v4);
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v4;
  uint64_t v6 = (double *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 0xCu)
  {
    unint64_t v9 = "this->max_num_rows_ >= A.NumRows()";
    int v10 = 567;
    goto LABEL_9;
  }
  if (*(_DWORD *)(a2 + 12) > 0xCu)
  {
    unint64_t v9 = "this->max_num_cols_ >= A.NumCols()";
    int v10 = 568;
LABEL_9:
    __assert_rtn("CNMatrix", "cnmatrix.h", v10, v9);
  }
  if ((int)v5 >= 1)
  {
    uint64_t v7 = *(double **)(a2 + 32);
    do
    {
      double v8 = *v7++;
      double result = v8;
      *v6++ = v8;
      --v5;
    }
    while (v5);
  }
  return result;
}

void sub_18E1C1B48(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1EDD17478;
  _Unwind_Resume(a1);
}

void *sub_18E1C1B68(void *a1)
{
  *a1 = &unk_1EDD19248;
  uint64_t v2 = a1[5];
  a1[5] = 0;
  if (v2) {
    MEMORY[0x192FA6220](v2, 0x1000C8000313F17);
  }
  *a1 = &unk_1EDD17478;
  return a1;
}

void *sub_18E1C1BE4(void *result)
{
  *double result = &unk_1EDD173B8;
  return result;
}

void *sub_18E1C1C04(void *result)
{
  *double result = &unk_1EDD17178;
  return result;
}

void sub_18E1C1C24(void *a1)
{
  *a1 = &unk_1EDD17178;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1C1C54(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E1C1C60(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(&v9, v4);
      if (v4 >= 3)
      {
        int v6 = v9;
        uint64_t v7 = 8;
        int v8 = v3 + v1 - v5;
        do
        {
          if (!v6)
          {
            *(void *)(*(void *)(a1 + 32) + 8 * (v8 % (v4 - 1))) = *(void *)(*(void *)(a1 + 32) + v7);
            int v6 = 1;
          }
          v8 += v3 + v1 - v5;
          v7 += 8;
        }
        while (8 * (v4 - 1) != v7);
      }
    }
  }
}

void sub_18E1C1D18(void *a1)
{
  *a1 = &unk_1EDD173B8;
  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1C1D48(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_18E1C1D54(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
    if (v3 >= 2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      int v5 = *(_DWORD *)(a1 + 20);
      bzero(v13, v4);
      if (v4 >= 3)
      {
        uint64_t v6 = (v4 - 1);
        uint64_t v7 = 1;
        do
        {
          int v8 = &v13[v7];
          if (!v13[v7])
          {
            uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8 * v7);
            int v10 = v7;
            do
            {
              int v10 = (int)(v10 * (v3 + v1 - v5)) % (int)v6;
              uint64_t v11 = *(void *)(a1 + 32);
              uint64_t v12 = *(void *)(v11 + 8 * v10);
              *(void *)(v11 + 8 * v10) = v9;
              *int v8 = 1;
              int v8 = &v13[v10];
              uint64_t v9 = v12;
            }
            while (!*v8);
          }
          ++v7;
        }
        while (v7 != v6);
      }
    }
  }
}

uint64_t trackrun::TrackRunPlatformInfo::TrackRunPlatformInfo(uint64_t this)
{
  *(_OWORD *)(this + 32) = 0u;
  *(_OWORD *)(this + 48) = 0u;
  *(_OWORD *)this = 0u;
  *(_OWORD *)(this + 16) = 0u;
  return sub_18E1C1E60(this);
}

{
  *(_OWORD *)(this + 32) = 0u;
  *(_OWORD *)(this + 48) = 0u;
  *(_OWORD *)this = 0u;
  *(_OWORD *)(this + 16) = 0u;
  return sub_18E1C1E60(this);
}

uint64_t sub_18E1C1E60(uint64_t a1)
{
  *(_WORD *)a1 = 0;
  *(unsigned char *)(a1 + 2) = 0;
  sub_18DEDE7B0((void *)(a1 + 8), "");
  sub_18DEDE7B0((void *)(a1 + 32), "");
  *(void *)(a1 + 56) = 0;
  return a1;
}

void sub_18E1C1EBC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void trackrun::TrackRunEngineActiveObject::PopulateAllStartingLineFields(trackrun::TrackRunEngineActiveObject *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((unsigned char *)this + 2824))
  {
    if (!*((unsigned char *)this + 624)) {
      sub_18DFF28FC();
    }
    double v8 = *((double *)this + 77);
    double v9 = *((double *)this + 80);
    double v10 = (*((double *)this + 332) - v8) * v9;
    double v11 = *((double *)this + 76);
    double v12 = *((double *)this + 79);
    double v13 = (*((double *)this + 331) - v11) * v12;
    *((double *)this + 335) = v10;
    *((double *)this + 336) = v13;
    double v14 = v9 * (*((double *)this + 334) - v8);
    double v15 = v12 * (*((double *)this + 333) - v11);
    *((double *)this + 337) = v14;
    *((double *)this + 338) = v15;
    double v16 = sqrt((v10 - v14) * (v10 - v14) + 0.0 + (v13 - v15) * (v13 - v15));
    double v17 = (v14 - v10) / v16;
    *((double *)this + 345) = v17;
    *((unsigned char *)this + 2768) = 1;
    double v18 = (v15 - v13) / v16;
    *((double *)this + 347) = v18;
    *((unsigned char *)this + 2784) = 1;
    if (!*((unsigned char *)this + 2752)) {
      *((unsigned char *)this + 2752) = 1;
    }
    *((_OWORD *)this + 170) = *(_OWORD *)((char *)this + 2680);
    double v19 = *((double *)this + 340);
    double v20 = *((double *)this + 341);
    double v21 = v17 + v19;
    double v22 = v18 + v20;
    *((double *)this + 342) = v21;
    *((double *)this + 343) = v22;
    double v23 = sqrt((v19 - v21) * (v19 - v21) + 0.0 + (v20 - v22) * (v20 - v22));
    if (fabs(v23 + -1.0) > 0.000000015)
    {
      __int16 v26 = 13;
      unsigned __int8 v25 = 4;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v26, &v25, "#tre_ao,starting line segment unit direction vector length is not unity,length,%.1lf", a4, a5, a6, a7, a8, SLOBYTE(v23));
    }
  }
  else
  {
    __int16 v28 = 13;
    unsigned __int8 v27 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v28, &v27, "#tre_ao,cannot populate starting line fields. No starting line geodetic coordinates available", a4, a5, a6, a7, a8, v24);
  }
}

uint64_t trackrun::TrackRunEngineActiveObject::TrackCoordinateTransform::ConvertLatLonToEastNorth@<X0>(uint64_t result@<X0>, float64x2_t *a2@<X1>, int8x16_t *a3@<X8>)
{
  char v3 = *(unsigned char *)(result + 16);
  if (v3)
  {
    int8x16_t v4 = (int8x16_t)vmulq_f64(vsubq_f64(*a2, *(float64x2_t *)result), *(float64x2_t *)(result + 24));
    *a3 = vextq_s8(v4, v4, 8uLL);
    char v3 = 1;
  }
  else
  {
    a3->i8[0] = 0;
  }
  a3[1].i8[0] = v3;
  return result;
}

void trackrun::TrackRunEngineActiveObject::TrackCoordinateTransform::ConvertEastNorthToLatLon(uint64_t a1@<X0>, float64x2_t *a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t a8@<X8>)
{
  if (*(unsigned char *)(a1 + 16)
    && fabs(*(double *)(a1 + 24)) >= 2.22044605e-16
    && (v9.f64[0] = *(float64_t *)(a1 + 32), fabs(v9.f64[0]) >= 2.22044605e-16))
  {
    v9.f64[1] = *(float64_t *)(a1 + 24);
    int8x16_t v11 = (int8x16_t)vdivq_f64(*a2, v9);
    *(float64x2_t *)a8 = vaddq_f64((float64x2_t)vextq_s8(v11, v11, 8uLL), *(float64x2_t *)a1);
    char v10 = 1;
  }
  else
  {
    __int16 v14 = 13;
    unsigned __int8 v13 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v14, &v13, "#tre_ao,empty origin or zero values scale factors, cannot perform coordinate transform.", a3, a4, a5, a6, a7, v12);
    char v10 = 0;
    *(unsigned char *)a8 = 0;
  }
  *(unsigned char *)(a8 + 16) = v10;
}

int64x2_t trackrun::TrackRunEngineActiveObject::TrackCoordinateTransform::Reset(trackrun::TrackRunEngineActiveObject::TrackCoordinateTransform *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  int64x2_t result = vdupq_n_s64(0x7FF8000000000000uLL);
  *(int64x2_t *)((char *)this + 24) = result;
  return result;
}

BOOL trackrun::TrackRunEngineActiveObject::TrackCoordinateTransform::SetTransformationOriginUsingLatLon(uint64_t a1, double *a2, double *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v8 = *a2;
  if ((*(void *)a2 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || ((void)a2[1] & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    LOWORD(v25) = 13;
    LOBYTE(v24) = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v25, (unsigned __int8 *)&v24, "#tre_ao,invalid origin for track coordinate transform,%.3lf,%.3lf", a4, a5, a6, a7, a8, SLOBYTE(v8));
    return 0;
  }
  if (fabs(v8) > 80.0)
  {
    LOWORD(v25) = 13;
    LOBYTE(v24) = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v25, (unsigned __int8 *)&v24, "#tre_ao,origin too close to poles,lat,%.9lf", a4, a5, a6, a7, a8, SLOBYTE(v8));
    return 0;
  }
  int v13 = *(unsigned __int8 *)(a1 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  if (!v13) {
    *(unsigned char *)(a1 + 16) = 1;
  }
  double v14 = *(double *)a1;
  double v24 = 0.0;
  double v25 = 0.0;
  int v15 = cnnavigation::GeodeticLatLonIncrementsToNorthEastMetersPerRadian((cnnavigation *)&v25, v14 * 0.0174532925, 0.0, &v24, a3);
  BOOL v10 = v15 == 0;
  if (v15)
  {
    __int16 v23 = 13;
    unsigned __int8 v22 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v23, &v22, "#tre_ao,error converting delta lat/lon to delta N/E,lat,%.9lf", v16, v17, v18, v19, v20, SLOBYTE(v14));
  }
  else
  {
    double v21 = v24 * 0.0174532925;
    *(double *)(a1 + 24) = v25 * 0.0174532925;
    *(double *)(a1 + 32) = v21;
  }
  return v10;
}

uint64_t trackrun::TrackRunEngineActiveObject::TrackCoordinateTransform::TransformationHasOrigin(trackrun::TrackRunEngineActiveObject::TrackCoordinateTransform *this)
{
  return *((unsigned __int8 *)this + 16);
}

double trackrun::TrackRunEngineActiveObject::TrackRunEngineActiveObject(uint64_t a1, unsigned char *a2)
{
  uint64_t v2 = (unsigned char *)(a1 + 4600);
  cnframework::ActiveObjectBase::ActiveObjectBase(a1, a2);
  *(void *)uint64_t v3 = &unk_1EDD1A0F0;
  *(unsigned char *)(v3 + 480) = 0;
  double result = 0.0;
  *(_OWORD *)(v3 + 488) = 0u;
  *(_OWORD *)(v3 + 504) = 0u;
  *(_OWORD *)(v3 + 520) = 0u;
  *(void *)(v3 + 536) = 0;
  *(void *)(v3 + 544) = 850045863;
  *(unsigned char *)(v3 + 624) = 0;
  *(_OWORD *)(v3 + 552) = 0u;
  *(_OWORD *)(v3 + 568) = 0u;
  *(_OWORD *)(v3 + 584) = 0u;
  *(_OWORD *)(v3 + 593) = 0u;
  *(void *)(v3 + 632) = 0x7FF8000000000000;
  *(void *)(v3 + 640) = 0x7FF8000000000000;
  *(unsigned char *)(v3 + 648) = 0;
  *(unsigned char *)(v3 + 672) = 0;
  *(unsigned char *)(v3 + 680) = 0;
  *(unsigned char *)(v3 + 704) = 0;
  *(unsigned char *)(v3 + 712) = 0;
  *(unsigned char *)(v3 + 776) = 0;
  *(unsigned char *)(v3 + 784) = 0;
  *(unsigned char *)(v3 + 1000) = 0;
  *(unsigned char *)(v3 + 1008) = 0;
  *(unsigned char *)(v3 + 1072) = 0;
  *(unsigned char *)(v3 + 1080) = 0;
  *(unsigned char *)(v3 + 1360) = 0;
  *(unsigned char *)(v3 + 1368) = 0;
  *(unsigned char *)(v3 + 1432) = 0;
  *(unsigned char *)(v3 + 1440) = 0;
  *(unsigned char *)(v3 + 1672) = 0;
  *(unsigned char *)(v3 + 1680) = 0;
  *(unsigned char *)(v3 + 2056) = 0;
  *(unsigned char *)(v3 + 2064) = 0;
  *(unsigned char *)(v3 + 2440) = 0;
  *(unsigned char *)(v3 + 2448) = 0;
  *(unsigned char *)(v3 + 2536) = 0;
  *(unsigned char *)(v3 + 2544) = 0;
  *(unsigned char *)(v3 + 2632) = 0;
  *(unsigned char *)(v3 + 2640) = 0;
  *(unsigned char *)(v3 + 2648) = 0;
  *(unsigned char *)(v3 + 2824) = 0;
  *(unsigned char *)(v3 + 2832) = 0;
  *(unsigned char *)(v3 + 2992) = 0;
  *(unsigned char *)(v3 + 3000) = 0;
  *(unsigned char *)(v3 + 3048) = 0;
  *(_WORD *)(v3 + 3104) = 0;
  *(_OWORD *)(v3 + 3088) = 0u;
  *(_OWORD *)(v3 + 3072) = 0u;
  *(_OWORD *)(v3 + 3056) = 0u;
  *(void *)(v3 + 3136) = 0xC0000000CLL;
  *(void *)(v3 + 3112) = &unk_1EDD177A8;
  *(void *)(v3 + 3120) = 0;
  *(void *)(v3 + 3128) = 0;
  *(void *)(v3 + 3144) = v3 + 3152;
  *(void *)(v3 + 4304) = &unk_1EDD0A448;
  *(void *)(v3 + 4336) = 0x10000000CLL;
  *(void *)(v3 + 4312) = &unk_1EDD17808;
  *(void *)(v3 + 4344) = v3 + 4352;
  *(void *)(v3 + 4472) = 0x10000000CLL;
  *(void *)(v3 + 4448) = &unk_1EDD17808;
  *(void *)(v3 + 4480) = v3 + 4488;
  *(void *)(v3 + 4592) = 0x3DDB7CDFD9D7BDBBLL;
  *(void *)(v3 + 4328) = 0;
  *(void *)(v3 + 4320) = 0;
  *(void *)(v3 + 4464) = 0;
  *(void *)(v3 + 4456) = 0;
  *(_DWORD *)(v3 + 4584) = 1;
  *(_WORD *)(v3 + 4600) = 0;
  v2[2] = 0;
  *(void *)(v3 + 4608) = 0;
  v2[16] = 0;
  v2[80] = 0;
  *(_WORD *)(v3 + 4688) = 0;
  v2[96] = 0;
  v2[104] = 0;
  *(_OWORD *)(v3 + 4728) = 0u;
  *(_OWORD *)(v3 + 4744) = 0u;
  *(_OWORD *)(v3 + 4712) = 0u;
  return result;
}

uint64_t trackrun::TrackRunEngineActiveObject::Configure(cnframework::ActiveObjectBase *this, uint64_t *a2)
{
  if (*((unsigned char *)this + 480))
  {
    LOWORD(v71) = 13;
    LOBYTE(v70) = 3;
    sub_18DEDE7B0(__p, "TrackRunEngineActiveObject");
    if (v73 >= 0) {
      float64x2_t v9 = __p;
    }
    else {
      LOBYTE(v9) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v71, (unsigned __int8 *)&v70, "Warning: %s configured more than once.", v4, v5, v6, v7, v8, (char)v9);
    if (v73 < 0) {
      operator delete(__p[0]);
    }
  }
  *((unsigned char *)this + 480) = 0;
  uint64_t v10 = *a2;
  if (!*a2 || !*(unsigned char *)(v10 + 256))
  {
    LOWORD(v71) = 13;
    LOBYTE(v70) = 4;
    sub_18DEDE7B0(__p, "TrackRunEngineActiveObject");
    if (v73 >= 0) {
      __int16 v28 = __p;
    }
    else {
      LOBYTE(v28) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v71, (unsigned __int8 *)&v70, "Error: %s could not be configured.", v23, v24, v25, v26, v27, (char)v28);
    goto LABEL_18;
  }
  *((void *)this + 67) = v10;
  cnframework::ActiveObjectBase::SetEventQueueDelay(this, 0.0);
  uint64_t v71 = *a2;
  if (trackrun::TrackRunLaneEstimator::Configure((uint64_t)this + 3104, &v71, v11, v12, v13, v14, v15, v16))
  {
    LOWORD(v70) = 13;
    LOBYTE(v69) = 4;
    sub_18DEDE7B0(__p, "TrackRunEngineActiveObject");
    if (v73 >= 0) {
      unsigned __int8 v22 = __p;
    }
    else {
      LOBYTE(v22) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v70, (unsigned __int8 *)&v69, "Error: %s could not be configured. Configuration of TrackRun lane estimator failed.", v17, v18, v19, v20, v21, (char)v22);
LABEL_18:
    if (v73 < 0) {
      operator delete(__p[0]);
    }
    return 0xFFFFFFFFLL;
  }
  int v30 = (void *)(*((void *)this + 67) + 72);
  if (!sub_18E183F00(v30, 4)) {
    goto LABEL_32;
  }
  LODWORD(__p[0]) = 4;
  if ((sub_18E1CB940((uint64_t)v30, 4, __p)[3] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    goto LABEL_32;
  }
  uint64_t v31 = *((void *)this + 67) + 72;
  int v70 = 4;
  if (*((double *)sub_18E1CB940(v31, 4, &v70) + 3) < 0.0) {
    goto LABEL_32;
  }
  int v32 = (void *)(*((void *)this + 67) + 72);
  if (!sub_18E183F00(v32, 3)) {
    goto LABEL_32;
  }
  int v69 = 3;
  if ((sub_18E1CB940((uint64_t)v32, 3, &v69)[3] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    goto LABEL_32;
  }
  uint64_t v33 = *((void *)this + 67) + 72;
  int v68 = 3;
  if (*((double *)sub_18E1CB940(v33, 3, &v68) + 3) < 0.0) {
    goto LABEL_32;
  }
  int v34 = (void *)(*((void *)this + 67) + 72);
  if (!sub_18E183F00(v34, 2)) {
    goto LABEL_32;
  }
  int v67 = 2;
  if ((sub_18E1CB940((uint64_t)v34, 2, &v67)[3] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    goto LABEL_32;
  }
  uint64_t v35 = *((void *)this + 67) + 72;
  int v66 = 2;
  if (*((double *)sub_18E1CB940(v35, 2, &v66) + 3) < 0.0) {
    goto LABEL_32;
  }
  uint64_t v36 = *((void *)this + 67) + 72;
  int v65 = 2;
  double v37 = *((double *)sub_18E1CB940(v36, 2, &v65) + 3);
  uint64_t v38 = *((void *)this + 67) + 72;
  int v64 = 3;
  if (v37 < *((double *)sub_18E1CB940(v38, 3, &v64) + 3)
    || (uint64_t v39 = *((void *)this + 67) + 72,
        int v63 = 3,
        double v40 = *((double *)sub_18E1CB940(v39, 3, &v63) + 3),
        uint64_t v41 = *((void *)this + 67) + 72,
        int v62 = 4,
        v40 < *((double *)sub_18E1CB940(v41, 4, &v62) + 3)))
  {
LABEL_32:
    LOWORD(v70) = 13;
    LOBYTE(v69) = 4;
    sub_18DEDE7B0(__p, "TrackRunEngineActiveObject");
    if (v73 >= 0) {
      double v47 = __p;
    }
    else {
      LOBYTE(v47) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v70, (unsigned __int8 *)&v69, "Error: %s could not be configured. Proximity distance threshold parameters do not exist or are invalid.", v42, v43, v44, v45, v46, (char)v47);
    goto LABEL_18;
  }
  double v48 = *(double *)(*((void *)this + 67) + 248);
  if (v48 <= 0.0 || (*(void *)&v48 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    LOWORD(v70) = 13;
    LOBYTE(v69) = 4;
    sub_18DEDE7B0(__p, "TrackRunEngineActiveObject");
    if (v73 >= 0) {
      uint64_t v61 = __p;
    }
    else {
      LOBYTE(v61) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v70, (unsigned __int8 *)&v69, "Error: %s could not be configured. Home visit consistency threshold is invalid.", v56, v57, v58, v59, v60, (char)v61);
    goto LABEL_18;
  }
  *((unsigned char *)this + 480) = 1;
  double v49 = (cnprint::CNPrinter *)(*(uint64_t (**)(cnframework::ActiveObjectBase *))(*(void *)this + 48))(this);
  if (cnprint::CNPrinter::GetLogLevel(v49) <= 1)
  {
    LOWORD(v70) = 13;
    LOBYTE(v69) = 1;
    sub_18DEDE7B0(__p, "TrackRunEngineActiveObject");
    if (v73 >= 0) {
      int32x4_t v55 = __p;
    }
    else {
      LOBYTE(v55) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v70, (unsigned __int8 *)&v69, "%s configured successfully.", v50, v51, v52, v53, v54, (char)v55);
    if (v73 < 0) {
      operator delete(__p[0]);
    }
  }
  return 0;
}

void sub_18E1C29A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t trackrun::TrackRunEngineActiveObject::IsConfigured(trackrun::TrackRunEngineActiveObject *this)
{
  return *((unsigned __int8 *)this + 480);
}

void *trackrun::TrackRunEngineActiveObject::GetActiveObjectName@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "TrackRunEngineActiveObject");
}

uint64_t trackrun::TrackRunEngineActiveObject::GetTrackRunSolution(trackrun::TrackRunEngineActiveObject *this, trackrun::TrackRunSolutionEvent *a2)
{
  uint64_t v4 = (std::mutex *)((char *)this + 544);
  std::mutex::lock((std::mutex *)((char *)this + 544));
  if (*((unsigned char *)this + 2056) && *((unsigned char *)this + 2050))
  {
    memcpy((char *)a2 + 8, (char *)this + 1688, 0x16BuLL);
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  std::mutex::unlock(v4);
  return v5;
}

void trackrun::TrackRunEngineActiveObject::HandleEvent(trackrun::TrackRunEngineActiveObject *this, const trackrun::MovingStateEvent *a2)
{
  if (cnprint::CNPrinter::GetLogLevel(this) <= 1)
  {
    LOWORD(v26[0]) = 13;
    LOBYTE(v24[0]) = 1;
    uint64_t v4 = (*(uint64_t (**)(const trackrun::MovingStateEvent *))(*(void *)a2 + 16))(a2);
    double v6 = v5 + (double)v4;
    sub_18DEDE7B0(__p, off_1E55B9E88[*((char *)a2 + 56)]);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)v26, (unsigned __int8 *)v24, "#tre_ao,received MovingStateEvent,time,%.1lf,ios_time,%.1lf,moving_state,%s", v7, v8, v9, v10, v11, SLOBYTE(v6));
    if (v31 < 0) {
      operator delete(__p[0]);
    }
  }
  if (*((unsigned char *)this + 1000))
  {
    __int16 v29 = 13;
    unsigned __int8 v28 = 3;
    char v12 = *((unsigned char *)this + 2640);
    sub_18DEDE7B0(__p, off_1E55B9E88[*((char *)a2 + 56)]);
    trackrun::TrackRunEngineActiveObject::ConvertIosTimeToGregorianString((uint64_t)this, *((void *)a2 + 5), *((void *)a2 + 6), v26);
    if (!*((unsigned char *)this + 1000)) {
      sub_18DFF28FC();
    }
    sub_18DEDE7B0(v24, off_1E55B9E88[*((char *)a2 + 56)]);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v29, &v28, "TrackRun-Moving-%u-%s,viewType,SingleArrowCoordinate,iOSTime,%.1lf,mcTime,%.1lf,gregTime,%s,latitude,%.7lf,longitude,%.7lf,course,%.2lf,speed,%.1lf,moving_state,%s", v13, v14, v15, v16, v17, v12);
    if (v25 < 0) {
      operator delete(v24[0]);
    }
    if (v27 < 0) {
      operator delete(v26[0]);
    }
    if (v31 < 0) {
      operator delete(__p[0]);
    }
  }
  if (*((unsigned char *)this + 776))
  {
    long long v18 = *(_OWORD *)((char *)a2 + 8);
    long long v19 = *(_OWORD *)((char *)a2 + 24);
    long long v20 = *(_OWORD *)((char *)a2 + 40);
    *((unsigned char *)this + 768) = *((unsigned char *)a2 + 56);
    *((_OWORD *)this + 46) = v19;
    *((_OWORD *)this + 47) = v20;
    *((_OWORD *)this + 45) = v18;
  }
  else
  {
    *((void *)this + 89) = &unk_1EDD19F98;
    long long v21 = *(_OWORD *)((char *)a2 + 8);
    long long v22 = *(_OWORD *)((char *)a2 + 24);
    long long v23 = *(_OWORD *)((char *)a2 + 40);
    *((unsigned char *)this + 768) = *((unsigned char *)a2 + 56);
    *((_OWORD *)this + 46) = v22;
    *((_OWORD *)this + 47) = v23;
    *((_OWORD *)this + 45) = v21;
    *((unsigned char *)this + 776) = 1;
  }
}

void sub_18E1C2D04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a37 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *trackrun::TrackRunEngineActiveObject::ConvertIosTimeToGregorianString@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if (*(unsigned char *)(*(void *)(a1 + 536) + 66))
  {
    v5[0] = a2;
    v5[1] = a3;
    return cnnavigation::iOSTimeToLocalTime((uint64_t)v5, a4);
  }
  else
  {
    return sub_18DEDE7B0(a4, "");
  }
}

uint64_t trackrun::TrackRunEngineActiveObject::HandleEvent(trackrun::TrackRunEngineActiveObject *this, const trackrun::VisitEvent *a2)
{
  __int16 v19 = 13;
  unsigned __int8 v18 = 3;
  uint64_t v4 = (*(uint64_t (**)(const trackrun::VisitEvent *))(*(void *)a2 + 16))(a2);
  double v6 = v5;
  sub_18E1C2F34((uint64_t)a2, &v16);
  sub_18E1C2F4C((uint64_t)a2, &__p);
  double v13 = v6 + (double)v4;
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v19, &v18, "#tre_ao,received visit event,time,%.1lf,ios_time,%.1lf,arrival time,%.1lf,user specific place type,%s,place inference place type,%s", v7, v8, v9, v10, v11, SLOBYTE(v13));
  if (v15 < 0) {
    operator delete(__p);
  }
  if (v17 < 0) {
    operator delete(v16);
  }
  return sub_18E1C2F64((uint64_t)this + 1080, (uint64_t)a2);
}

void sub_18E1C2F00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void *sub_18E1C2F34@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_18DEDE7B0(a2, off_1E55B9EA8[*(char *)(a1 + 224)]);
}

void *sub_18E1C2F4C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_18DEDE7B0(a2, off_1E55B9ED0[*(char *)(a1 + 225)]);
}

uint64_t sub_18E1C2F64(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 280))
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
    long long v5 = *(_OWORD *)(a2 + 40);
    long long v6 = *(_OWORD *)(a2 + 56);
    long long v7 = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = v7;
    *(_OWORD *)(a1 + 56) = v6;
    *(_OWORD *)(a1 + 40) = v5;
    long long v8 = *(_OWORD *)(a2 + 104);
    long long v9 = *(_OWORD *)(a2 + 120);
    long long v10 = *(_OWORD *)(a2 + 136);
    *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
    *(_OWORD *)(a1 + 136) = v10;
    *(_OWORD *)(a1 + 120) = v9;
    *(_OWORD *)(a1 + 104) = v8;
    long long v11 = *(_OWORD *)(a2 + 168);
    long long v12 = *(_OWORD *)(a2 + 184);
    long long v13 = *(_OWORD *)(a2 + 200);
    *(_OWORD *)(a1 + 210) = *(_OWORD *)(a2 + 210);
    *(_OWORD *)(a1 + 200) = v13;
    *(_OWORD *)(a1 + 184) = v12;
    *(_OWORD *)(a1 + 168) = v11;
    std::string::operator=((std::string *)(a1 + 232), (const std::string *)(a2 + 232));
    std::string::operator=((std::string *)(a1 + 256), (const std::string *)(a2 + 256));
  }
  else
  {
    sub_18E1CA8F4(a1, a2);
    *(unsigned char *)(a1 + 280) = 1;
  }
  return a1;
}

void trackrun::TrackRunEngineActiveObject::HandleEvent(trackrun::TrackRunEngineActiveObject *this, const trackrun::WatchStateEvent *a2)
{
  __int16 v24 = 13;
  unsigned __int8 v23 = 3;
  uint64_t v4 = (*(uint64_t (**)(const trackrun::WatchStateEvent *))(*(void *)a2 + 16))(a2);
  double v6 = v5;
  sub_18DEDE7B0(&v21, off_1E55B9EF0[*((char *)a2 + 57)]);
  sub_18DEDE7B0(&__p, off_1E55B9EF0[*((char *)a2 + 56)]);
  double v18 = v6 + (double)v4;
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v24, &v23, "#tre_ao,received watch state event,time,%.1lf,ios_time,%.1lf,wrist_orientation,%s,crown_orientation,%s", v7, v8, v9, v10, v11, SLOBYTE(v18));
  if (v20 < 0) {
    operator delete(__p);
  }
  if (v22 < 0) {
    operator delete(v21);
  }
  if (*((unsigned char *)this + 1432))
  {
    long long v12 = *(_OWORD *)((char *)a2 + 8);
    long long v13 = *(_OWORD *)((char *)a2 + 24);
    long long v14 = *(_OWORD *)((char *)a2 + 40);
    *((_WORD *)this + 712) = *((_WORD *)a2 + 28);
    *((_OWORD *)this + 88) = v14;
    *((_OWORD *)this + 87) = v13;
    *((_OWORD *)this + 86) = v12;
  }
  else
  {
    *((void *)this + 171) = &unk_1EDD19F68;
    long long v15 = *(_OWORD *)((char *)a2 + 8);
    long long v16 = *(_OWORD *)((char *)a2 + 24);
    long long v17 = *(_OWORD *)((char *)a2 + 40);
    *((_WORD *)this + 712) = *((_WORD *)a2 + 28);
    *((_OWORD *)this + 88) = v17;
    *((_OWORD *)this + 87) = v16;
    *((_OWORD *)this + 86) = v15;
    *((unsigned char *)this + 1432) = 1;
  }
}

void sub_18E1C31E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void trackrun::TrackRunEngineActiveObject::HandleEvent(trackrun::TrackRunEngineActiveObject *this, const trackrun::WorkoutSessionEvent *a2)
{
  uint64_t v39 = this;
  double v40 = &unk_1EDD1A090;
  uint64_t v4 = (long long *)((char *)a2 + 8);
  long long v5 = *(_OWORD *)((char *)a2 + 24);
  long long v41 = *(_OWORD *)((char *)a2 + 8);
  long long v42 = v5;
  long long v43 = *(_OWORD *)((char *)a2 + 40);
  __int16 v6 = *((_WORD *)a2 + 28);
  __int16 v44 = v6;
  uint64_t v7 = (char *)a2 + 64;
  if (*((char *)a2 + 87) < 0)
  {
    sub_18DEDE668(&v45, *((void **)a2 + 8), *((void *)a2 + 9));
    __int16 v6 = *((_WORD *)a2 + 28);
    BOOL v8 = *((char *)a2 + 87) < 0;
  }
  else
  {
    BOOL v8 = 0;
    long long v45 = *(_OWORD *)v7;
    uint64_t v46 = *((void *)a2 + 10);
  }
  long long v9 = *(_OWORD *)((char *)a2 + 168);
  long long v10 = *(_OWORD *)((char *)a2 + 200);
  long long v53 = *(_OWORD *)((char *)a2 + 184);
  long long v54 = v10;
  long long v55 = *(_OWORD *)((char *)a2 + 216);
  long long v11 = *(_OWORD *)((char *)a2 + 104);
  long long v12 = *(_OWORD *)((char *)a2 + 136);
  long long v49 = *(_OWORD *)((char *)a2 + 120);
  long long v50 = v12;
  long long v51 = *(_OWORD *)((char *)a2 + 152);
  long long v52 = v9;
  long long v47 = *(_OWORD *)((char *)a2 + 88);
  long long v48 = v11;
  char v22 = this;
  unsigned __int8 v23 = &unk_1EDD1A090;
  long long v13 = v4[1];
  long long v24 = *v4;
  long long v25 = v13;
  long long v26 = v4[2];
  __int16 v27 = v6;
  if (v8)
  {
    sub_18DEDE668(&__p, *((void **)a2 + 8), *((void *)a2 + 9));
    LOBYTE(v6) = *((unsigned char *)a2 + 56);
  }
  else
  {
    long long __p = *(_OWORD *)v7;
    uint64_t v29 = *((void *)v7 + 2);
  }
  long long v14 = *(_OWORD *)((char *)a2 + 200);
  long long v36 = *(_OWORD *)((char *)a2 + 184);
  long long v37 = v14;
  long long v38 = *(_OWORD *)((char *)a2 + 216);
  long long v15 = *(_OWORD *)((char *)a2 + 136);
  long long v32 = *(_OWORD *)((char *)a2 + 120);
  long long v33 = v15;
  long long v16 = *(_OWORD *)((char *)a2 + 168);
  long long v34 = *(_OWORD *)((char *)a2 + 152);
  long long v35 = v16;
  long long v17 = *(_OWORD *)((char *)a2 + 104);
  long long v30 = *(_OWORD *)((char *)a2 + 88);
  long long v31 = v17;
  if (v6 > 7u || ((1 << v6) & 0xD8) == 0)
  {
LABEL_16:
    sub_18E1C3518((uint64_t)&v39);
    goto LABEL_20;
  }
  int v18 = *((unsigned __int8 *)a2 + 57);
  if ((v18 - 4) < 2)
  {
LABEL_15:
    sub_18E1C3518((uint64_t)&v39);
    sub_18E1C377C((uint64_t)this + 1440, (uint64_t)a2);
    sub_18E1C38DC((uint64_t)&v22);
    goto LABEL_20;
  }
  if (v18 != 3)
  {
    if (v18 == 2)
    {
      trackrun::TrackRunEngineActiveObject::ResetTrackStateWhenSessionStarts(this);
      int v19 = *((unsigned __int8 *)this + 3048);
      long long v21 = v4[1];
      long long v20 = v4[2];
      *(_OWORD *)((char *)this + 3000) = *v4;
      *(_OWORD *)((char *)this + 3016) = v21;
      *(_OWORD *)((char *)this + 3032) = v20;
      if (!v19) {
        *((unsigned char *)this + 3048) = 1;
      }
      *((unsigned char *)this + 2640) = *((unsigned char *)this + 2640)
                              + 1
                              - 30 * ((2185 * (*((unsigned __int8 *)this + 2640) + 1)) >> 16);
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  if (*((unsigned char *)this + 3048)) {
    *((unsigned char *)this + 3048) = 0;
  }
  sub_18E1C3518((uint64_t)&v39);
  sub_18E1C377C((uint64_t)this + 1440, (uint64_t)a2);
  sub_18E1C38DC((uint64_t)&v22);
  trackrun::TrackRunEngineActiveObject::ResetTrackStateWhenLeaveTrackOrSessionEnds(this);
  *((unsigned char *)this + 2640) = *((unsigned char *)this + 2640)
                          + 1
                          - 30 * ((2185 * (*((unsigned __int8 *)this + 2640) + 1)) >> 16);
LABEL_20:
  unsigned __int8 v23 = &unk_1EDD1A090;
  if (SHIBYTE(v29) < 0) {
    operator delete((void *)__p);
  }
  double v40 = &unk_1EDD1A090;
  if (SHIBYTE(v46) < 0) {
    operator delete((void *)v45);
  }
}

void sub_18E1C34DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a56 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_18E1C3518(uint64_t a1)
{
  __int16 v16 = 13;
  unsigned __int8 v15 = 3;
  uint64_t v1 = a1 + 8;
  uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 8) + 16))(a1 + 8);
  double v4 = v3;
  sub_18E1CAA28(&v13, *(unsigned char *)(v1 + 56));
  sub_18E1CAA3C(&__p, *(unsigned char *)(v1 + 57));
  double v10 = v4 + (double)v2;
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v16, &v15, "#tre_ao,received workout session event,time,%.1lf,ios_time,%.1lf,workout_number,%d,workout_type,%s,workout_event,%s,session_id,%s", v5, v6, v7, v8, v9, SLOBYTE(v10));
  if (v12 < 0) {
    operator delete(__p);
  }
  if (v14 < 0) {
    operator delete(v13);
  }
}

void sub_18E1C364C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

double trackrun::TrackRunEngineActiveObject::ResetTrackStateWhenSessionStarts(trackrun::TrackRunEngineActiveObject *this)
{
  uint64_t v2 = (char *)this + 4600;
  *((unsigned char *)this + 4602) = 0;
  *((unsigned char *)this + 4600) = 0;
  if (*((unsigned char *)this + 3105)) {
    *((unsigned char *)this + 3105) = 0;
  }
  if (*((unsigned char *)this + 4680)) {
    *((unsigned char *)this + 4680) = 0;
  }
  if (*((unsigned char *)this + 2824)) {
    *((unsigned char *)this + 2824) = 0;
  }
  if (*((unsigned char *)this + 2992)) {
    *((unsigned char *)this + 2992) = 0;
  }
  double v3 = (void **)*((void *)this + 383);
  uint64_t v4 = *((void *)this + 384);
  *((void *)this + 387) = 0;
  unint64_t v5 = v4 - (void)v3;
  if (v5 >= 0x11)
  {
    do
    {
      operator delete(*v3);
      double v3 = (void **)(*((void *)this + 383) + 8);
      *((void *)this + 383) = v3;
      unint64_t v5 = *((void *)this + 384) - (void)v3;
    }
    while (v5 > 0x10);
  }
  if (v5 >> 3 == 1)
  {
    uint64_t v6 = 25;
  }
  else
  {
    if (v5 >> 3 != 2) {
      goto LABEL_16;
    }
    uint64_t v6 = 51;
  }
  *((void *)this + 386) = v6;
LABEL_16:
  if (v2[104]) {
    v2[104] = 0;
  }
  *((_WORD *)this + 2344) = 0;
  if (*((unsigned char *)this + 776)) {
    *((unsigned char *)this + 776) = 0;
  }
  if (*((unsigned char *)this + 2440)) {
    *((unsigned char *)this + 2440) = 0;
  }
  double result = 0.0;
  *(_OWORD *)((char *)this + 4728) = 0u;
  *(_OWORD *)((char *)this + 4744) = 0u;
  *(_OWORD *)((char *)this + 4712) = 0u;
  return result;
}

uint64_t sub_18E1C377C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 232))
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    long long v5 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a1 + 24) = v5;
    *(_OWORD *)(a1 + 8) = v4;
    *(_WORD *)(a1 + 56) = *(_WORD *)(a2 + 56);
    std::string::operator=((std::string *)(a1 + 64), (const std::string *)(a2 + 64));
    *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
    long long v6 = *(_OWORD *)(a2 + 120);
    long long v7 = *(_OWORD *)(a2 + 136);
    long long v8 = *(_OWORD *)(a2 + 152);
    *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
    *(_OWORD *)(a1 + 152) = v8;
    *(_OWORD *)(a1 + 136) = v7;
    *(_OWORD *)(a1 + 120) = v6;
    long long v9 = *(_OWORD *)(a2 + 184);
    long long v10 = *(_OWORD *)(a2 + 200);
    long long v11 = *(_OWORD *)(a2 + 216);
    *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
    *(_OWORD *)(a1 + 216) = v11;
    *(_OWORD *)(a1 + 200) = v10;
    *(_OWORD *)(a1 + 184) = v9;
  }
  else
  {
    *(void *)a1 = &unk_1EDD1A090;
    long long v12 = *(_OWORD *)(a2 + 8);
    long long v13 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a1 + 24) = v13;
    *(_OWORD *)(a1 + 8) = v12;
    *(_WORD *)(a1 + 56) = *(_WORD *)(a2 + 56);
    char v14 = (unsigned char *)(a1 + 64);
    if (*(char *)(a2 + 87) < 0)
    {
      sub_18DEDE668(v14, *(void **)(a2 + 64), *(void *)(a2 + 72));
    }
    else
    {
      long long v15 = *(_OWORD *)(a2 + 64);
      *(void *)(a1 + 80) = *(void *)(a2 + 80);
      *(_OWORD *)char v14 = v15;
    }
    *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
    long long v16 = *(_OWORD *)(a2 + 104);
    long long v17 = *(_OWORD *)(a2 + 120);
    long long v18 = *(_OWORD *)(a2 + 136);
    *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
    *(_OWORD *)(a1 + 136) = v18;
    *(_OWORD *)(a1 + 120) = v17;
    *(_OWORD *)(a1 + 104) = v16;
    long long v19 = *(_OWORD *)(a2 + 168);
    long long v20 = *(_OWORD *)(a2 + 184);
    long long v21 = *(_OWORD *)(a2 + 200);
    *(_OWORD *)(a1 + 216) = *(_OWORD *)(a2 + 216);
    *(_OWORD *)(a1 + 200) = v21;
    *(_OWORD *)(a1 + 184) = v20;
    *(_OWORD *)(a1 + 168) = v19;
    *(unsigned char *)(a1 + 232) = 1;
  }
  return a1;
}

void sub_18E1C38DC(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  __int16 v16 = 13;
  unsigned __int8 v15 = 3;
  sub_18E1CAA28(v13, *(unsigned char *)(a1 + 64));
  if (v14 >= 0) {
    double v3 = v13;
  }
  else {
    LOBYTE(v3) = v13[0];
  }
  sub_18E1CAA3C(&v11, *(unsigned char *)(a1 + 65));
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  trackrun::TrackRunEngineActiveObject::ConvertIosTimeToGregorianString(v2, *(void *)(a1 + 48), *(void *)(a1 + 56), &__p);
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v16, &v15, "Workout-%s-%s-%u,viewType,SingleArrowCoordinate,time,%.1lf,iOSTime,%.1lf,start_time,%.1lf,gregTime,%s,latitude,%.7lf,longitude,%.7lf,lane_hint,%d", v4, v5, v6, v7, v8, (char)v3);
  if (v10 < 0) {
    operator delete(__p);
  }
  if (v12 < 0) {
    operator delete(v11);
  }
  if (v14 < 0) {
    operator delete(v13[0]);
  }
}

void sub_18E1C3A9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  _Unwind_Resume(exception_object);
}

double trackrun::TrackRunEngineActiveObject::ResetTrackStateWhenLeaveTrackOrSessionEnds(trackrun::TrackRunEngineActiveObject *this)
{
  if (cnprint::CNPrinter::GetLogLevel(this) <= 1)
  {
    __int16 v10 = 13;
    unsigned __int8 v9 = 1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v10, &v9, "#tre_ao,user has left the track or ended the workout,resetting the track state.", v2, v3, v4, v5, v6, v8);
  }
  if (*((unsigned char *)this + 1072)) {
    *((unsigned char *)this + 1072) = 0;
  }

  return trackrun::TrackRunEngineActiveObject::ResetTrackStateWhenSessionStarts(this);
}

void trackrun::TrackRunEngineActiveObject::HandleEvent(uint64_t this, const trackrun::GEOMapRunningTrackDataEvent *a2, double *a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  if (!*(unsigned char *)(this + 480)) {
    return;
  }
  if (*((void *)a2 + 1) == *((void *)a2 + 2))
  {
    LOWORD(__p[0]) = 13;
    LOBYTE(v143[0]) = 4;
    uint64_t v13 = (*(uint64_t (**)(const trackrun::GEOMapRunningTrackDataEvent *))(*(void *)a2 + 16))(a2);
    double v125 = v14 + (double)v13;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)v143, "#tre_ao,time,%.3lf,running track event has no tracks", v15, v16, v17, v18, v19, SLOBYTE(v125));
    return;
  }
  __int16 v10 = (trackrun::TrackRunEngineActiveObject *)this;
  int v11 = *((unsigned __int8 *)a2 + 80);
  if (!*(unsigned char *)(this + 1000))
  {
    LOWORD(__p[0]) = 13;
    LOBYTE(v143[0]) = 3;
    uint64_t v20 = (*(uint64_t (**)(const trackrun::GEOMapRunningTrackDataEvent *))(*(void *)a2 + 16))(a2);
    double v126 = v21 + (double)v20;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)v143, "#tre_ao,time,%.3lf,no previous position available; caching running track data to process at a future time",
      v22,
      v23,
      v24,
      v25,
      v26,
      SLOBYTE(v126));
    if (v11) {
      uint64_t v27 = (uint64_t)v10 + 2448;
    }
    else {
      uint64_t v27 = (uint64_t)v10 + 2544;
    }
    sub_18E1C4840(v27, (uint64_t)a2);
    return;
  }
  if (!*((unsigned char *)a2 + 80))
  {
    this = sub_18E1C4840(this + 2544, (uint64_t)a2);
    int v31 = *((unsigned __int8 *)v10 + 704);
    if (*(unsigned char *)(*((void *)v10 + 67) + 67)) {
      BOOL v32 = v31 == 0;
    }
    else {
      BOOL v32 = 1;
    }
    int v12 = v32;
    if (*(unsigned char *)(*((void *)v10 + 67) + 67)) {
      BOOL v33 = 1;
    }
    else {
      BOOL v33 = v31 == 0;
    }
    if (v33) {
      goto LABEL_30;
    }
    uint64_t v29 = (char *)v10 + 704;
    long long v30 = (char *)v10 + 680;
    goto LABEL_28;
  }
  if (!*(unsigned char *)(*(void *)(this + 536) + 67) || !*(unsigned char *)(this + 672))
  {
    *(void *)(this + 624) = 0;
    a9 = 0uLL;
    *(_OWORD *)(this + 608) = 0u;
    *(void *)(this + 632) = 0x7FF8000000000000;
    *(void *)(this + 640) = 0x7FF8000000000000;
    if (*(unsigned char *)(this + 2824))
    {
      long long v28 = *(_OWORD *)(this + 2664);
      *(_OWORD *)long long __p = *(_OWORD *)(this + 2648);
      *(_OWORD *)uint64_t v149 = v28;
      memset(&v149[16], 0, 32);
      *(void *)(this + 2688) = 0;
      *(void *)(this + 2680) = 0;
      a9.n128_u64[1] = *(void *)&v149[40];
      *(_OWORD *)(this + 2696) = *(_OWORD *)&v149[32];
      *(_WORD *)(this + 2712) = 0;
      if (*(unsigned char *)(this + 2752)) {
        *(unsigned char *)(this + 2752) = 0;
      }
      *(unsigned char *)(this + 2760) = 0;
      *(unsigned char *)(this + 2768) = 0;
      *(unsigned char *)(this + 2776) = 0;
      *(unsigned char *)(this + 2784) = 0;
      *(unsigned char *)(this + 2792) = 0;
      *(unsigned char *)(this + 2816) = 0;
    }
    if (!*(unsigned char *)(this + 672)) {
      goto LABEL_29;
    }
    uint64_t v29 = (unsigned char *)(this + 672);
    long long v30 = (char *)(this + 648);
LABEL_28:
    __p[0] = v30;
    sub_18E1BEB28((void ***)__p);
    *uint64_t v29 = 0;
LABEL_29:
    int v12 = 1;
    goto LABEL_30;
  }
  int v12 = 0;
LABEL_30:
  if (*((unsigned char *)v10 + 624))
  {
    a9.n128_u64[0] = *((void *)v10 + 80);
  }
  else
  {
    *(_OWORD *)uint64_t v143 = *((_OWORD *)v10 + 56);
    this = trackrun::TrackRunEngineActiveObject::TrackCoordinateTransform::SetTransformationOriginUsingLatLon((uint64_t)v10 + 608, (double *)v143, a3, (uint64_t)a4, a5, a6, a7, a8);
    if (!this || !*((unsigned char *)v10 + 624))
    {
      LOWORD(v154.f64[0]) = 13;
      LOBYTE(v139[0]) = 4;
      uint64_t v37 = (*(uint64_t (**)(const trackrun::GEOMapRunningTrackDataEvent *))(*(void *)a2 + 16))(a2);
      double v39 = v38 + (double)v37;
      sub_18DEDE7B0(__p, "TrackRunEngineActiveObject");
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v154, (unsigned __int8 *)v139, "#tre_ao,time,%.3lf,%s could not configure running track coordinate transform", v40, v41, v42, v43, v44, SLOBYTE(v39));
      if ((v149[7] & 0x80000000) != 0) {
        operator delete(__p[0]);
      }
      return;
    }
    a9.n128_u64[0] = *((void *)v10 + 80);
    if (*((unsigned char *)v10 + 2824)) {
      trackrun::TrackRunEngineActiveObject::PopulateAllStartingLineFields(v10, v35, v36, (uint64_t)a4, a5, a6, a7, a8);
    }
  }
  if (v12)
  {
    __p[0] = 0;
    __p[1] = 0;
    *(void *)uint64_t v149 = 0;
    v149[8] = 1;
    if (v11) {
      long long v34 = (uint64_t *)((char *)v10 + 648);
    }
    else {
      long long v34 = (uint64_t *)((char *)v10 + 680);
    }
    sub_18E1CB2D0((uint64_t)v34, (__n128 *)__p);
    if (v149[8])
    {
      v143[0] = __p;
      sub_18E1BEB28((void ***)v143);
    }
    this = sub_18E1BBEB4(v34, 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*((void *)a2 + 2) - *((void *)a2 + 1)) >> 3));
  }
  uint64_t v45 = *((void *)a2 + 1);
  if (*((void *)a2 + 2) != v45)
  {
    int v133 = 0;
    int v46 = 0;
    unint64_t v47 = 0;
    int v136 = v11;
    while (1)
    {
      uint64_t v48 = v45 + 104 * v47;
      uint64_t v50 = *(void *)(v48 + 96);
      long long v49 = (unint64_t *)(v48 + 96);
      if (v50) {
        break;
      }
      LOWORD(__p[0]) = 13;
      LOBYTE(v143[0]) = 4;
      uint64_t v101 = (*(uint64_t (**)(const trackrun::GEOMapRunningTrackDataEvent *, __n128))(*(void *)a2 + 16))(a2, a9);
      double v129 = v102 + (double)v101;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)v143, "#tre_ao,time,%.3lf,track has no lanes", v103, v104, v105, v106, v107, SLOBYTE(v129));
LABEL_112:
      ++v47;
      uint64_t v45 = *((void *)a2 + 1);
      if (v47 >= 0x4EC4EC4EC4EC4EC5 * ((*((void *)a2 + 2) - v45) >> 3)) {
        goto LABEL_120;
      }
    }
    int v131 = v49;
    uint64_t v132 = v45 + 104 * v47;
    __p[0] = 0;
    __p[1] = 0;
    *(void *)uint64_t v149 = 0;
    LOBYTE(v151) = 0;
    char v152 = 0;
    unint64_t v153 = 0;
    memset(&v149[24], 0, 32);
    int v150 = 0;
    uint64_t v134 = v45;
    unint64_t v135 = v47;
    long long v52 = *(const trackrun::RunningTrackData::RunningTrackLane **)(v132 + 40);
    long long v51 = *(const trackrun::RunningTrackData::RunningTrackLane **)(v132 + 48);
    if (v52 != v51)
    {
      unint64_t v137 = *(const trackrun::RunningTrackData::RunningTrackLane **)(v132 + 48);
      uint64_t v138 = 0;
      do
      {
        BYTE8(v145) = 0;
        LOBYTE(v146) = 0;
        BYTE8(v146) = 0;
        LOBYTE(v147) = 0;
        v143[1] = 0;
        uint64_t v144 = 0;
        v143[0] = 0;
        LODWORD(v145) = 0;
        *((void *)&v147 + 1) = 0xBFF0000000000000;
        if (trackrun::TrackRunEngineActiveObject::CopyTrackLaneData(v10, v52, (trackrun::RunningTrackData::RunningTrackLane *)v143, a4, a5, a6, a7, a8))
        {
          int v53 = v46;
          uint64_t v54 = *(void *)v52;
          if (*(void *)v52 != *((void *)v52 + 1))
          {
            uint64_t v55 = 0;
            do
            {
              LOWORD(v139[0]) = 13;
              LOBYTE(v142) = 3;
              uint64_t v56 = *((void *)a2 + 8);
              double v57 = *((double *)a2 + 9);
              (*(void (**)(const trackrun::GEOMapRunningTrackDataEvent *))(*(void *)a2 + 16))(a2);
              trackrun::TrackRunEngineActiveObject::ConvertIosTimeToGregorianString((uint64_t)v10, *((void *)a2 + 8), *((void *)a2 + 9), &v154);
              double v127 = v57 + (double)v56;
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)v139, (unsigned __int8 *)&v142, "TrackRun-Track,viewType,ConnectedCoordinates,iOSTime,%.1lf,mcTime,%.1lf,gregTime,%s,latitude,%.7lf,longitude,%.7lf,lane,%zu,index,%zu", v58, v59, v60, v61, v62, SLOBYTE(v127));
              if (SHIBYTE(v155) < 0) {
                operator delete(*(void **)&v154.f64[0]);
              }
              ++v55;
              v54 += 16;
            }
            while (v54 != *((void *)v52 + 1));
          }
          uint64_t v63 = *(void *)&v149[32];
          if (*(void *)&v149[32] >= *(void *)&v149[40])
          {
            unint64_t v75 = 0x8E38E38E38E38E39 * ((uint64_t)(*(void *)&v149[32] - *(void *)&v149[24]) >> 3);
            unint64_t v76 = v75 + 1;
            if (v75 + 1 > 0x38E38E38E38E38ELL) {
              sub_18DEE1FC8();
            }
            int v64 = v53;
            if (0x1C71C71C71C71C72 * ((uint64_t)(*(void *)&v149[40] - *(void *)&v149[24]) >> 3) > v76) {
              unint64_t v76 = 0x1C71C71C71C71C72 * ((uint64_t)(*(void *)&v149[40] - *(void *)&v149[24]) >> 3);
            }
            if (0x8E38E38E38E38E39 * ((uint64_t)(*(void *)&v149[40] - *(void *)&v149[24]) >> 3) >= 0x1C71C71C71C71C7) {
              unint64_t v77 = 0x38E38E38E38E38ELL;
            }
            else {
              unint64_t v77 = v76;
            }
            uint64_t v157 = &v149[40];
            int v11 = v136;
            if (v77) {
              uint64_t v78 = (char *)sub_18E1BDD00((uint64_t)&v149[40], v77);
            }
            else {
              uint64_t v78 = 0;
            }
            float64x2_t v79 = &v78[72 * v75];
            *(void *)&v154.f64[0] = v78;
            *(void *)&v154.f64[1] = v79;
            long long v155 = v79;
            uint64_t v156 = &v78[72 * v77];
            *(void *)float64x2_t v79 = 0;
            *((void *)v79 + 1) = 0;
            *((void *)v79 + 2) = 0;
            sub_18E1CB374(v79, v143[0], (uint64_t)v143[1], ((char *)v143[1] - (char *)v143[0]) >> 4);
            char v80 = &v78[72 * v75];
            long long v81 = v147;
            long long v82 = v145;
            *(_OWORD *)(v80 + 40) = v146;
            *(_OWORD *)(v80 + 24) = v82;
            *(_OWORD *)(v80 + 56) = v81;
            v155 += 72;
            sub_18E1BDC88((uint64_t *)&v149[24], &v154);
            uint64_t v67 = *(void *)&v149[32];
            sub_18E1BDE84((uint64_t)&v154);
          }
          else
          {
            **(_OWORD **)&v149[32] = 0uLL;
            *(void *)(v63 + 16) = 0;
            sub_18E1CB374((void *)v63, v143[0], (uint64_t)v143[1], ((char *)v143[1] - (char *)v143[0]) >> 4);
            int v64 = v53;
            long long v65 = v145;
            long long v66 = v146;
            *(_OWORD *)(v63 + 56) = v147;
            *(_OWORD *)(v63 + 40) = v66;
            *(_OWORD *)(v63 + 24) = v65;
            uint64_t v67 = v63 + 72;
            int v11 = v136;
          }
          long long v51 = v137;
          *(void *)&v149[32] = v67;
          ++v138;
          int v46 = v64 + 1;
        }
        else
        {
          LOWORD(v154.f64[0]) = 13;
          LOBYTE(v139[0]) = 4;
          uint64_t v68 = (*(uint64_t (**)(const trackrun::GEOMapRunningTrackDataEvent *))(*(void *)a2 + 16))(a2);
          double v128 = v69 + (double)v68;
          cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v154, (unsigned __int8 *)v139, "#tre_ao,time,%.3lf,cannot add lane data to track", v70, v71, v72, v73, v74, SLOBYTE(v128));
        }
        if (v143[0])
        {
          v143[1] = v143[0];
          operator delete(v143[0]);
        }
        long long v52 = (const trackrun::RunningTrackData::RunningTrackLane *)((char *)v52 + 72);
      }
      while (v52 != v51);
    }
    uint64_t v83 = v134 + 104 * v135;
    *(void *)&v149[48] = *(void *)(v83 + 64);
    int v150 = *(_DWORD *)(v83 + 72);
    v143[0] = 0;
    v143[1] = 0;
    uint64_t v144 = 0;
    sub_18E1CB374(v143, *(const void **)v132, *(void *)(v132 + 8), (uint64_t)(*(void *)(v132 + 8) - *(void *)v132) >> 4);
    char v90 = (char *)v143[0];
    if (v143[0] != v143[1])
    {
      do
      {
        sub_18DEDE7B0(&v154, "");
        if (!v11)
        {
          if (SHIBYTE(v155) < 0)
          {
            *(void *)&v154.f64[1] = 7;
            float64_t v91 = v154.f64[0];
          }
          else
          {
            HIBYTE(v155) = 7;
            float64_t v91 = COERCE_DOUBLE(&v154);
          }
          strcpy(*(char **)&v91, "-sparse");
        }
        __int16 v142 = 13;
        unsigned __int8 v141 = 3;
        if (SHIBYTE(v155) >= 0) {
          uint64_t v92 = &v154;
        }
        else {
          LOBYTE(v92) = LOBYTE(v154.f64[0]);
        }
        (*(void (**)(const trackrun::GEOMapRunningTrackDataEvent *))(*(void *)a2 + 16))(a2);
        trackrun::TrackRunEngineActiveObject::ConvertIosTimeToGregorianString((uint64_t)v10, *((void *)a2 + 8), *((void *)a2 + 9), v139);
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v142, &v141, "TrackRun-Track-Bbox%s,viewType,ConnectedCoordinates,iOSTime,%.1lf,mcTime,%.1lf,gregTime,%s,latitude,%.7lf,longitude,%.7lf", v93, v94, v95, v96, v97, (char)v92);
        if (v140 < 0) {
          operator delete(v139[0]);
        }
        if (SHIBYTE(v155) < 0) {
          operator delete(*(void **)&v154.f64[0]);
        }
        v90 += 16;
      }
      while (v90 != v143[1]);
      long long v98 = (float64x2_t *)v143[0];
      if (v90 != v143[0])
      {
        do
        {
          trackrun::TrackRunEngineActiveObject::ConvertPointLatLonToEastNorth((uint64_t)v10, v98, v84, v85, v86, v87, v88, v89);
          BOOL v32 = v98++ == (float64x2_t *)(v90 - 16);
        }
        while (!v32);
      }
    }
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    *(_OWORD *)long long __p = *(_OWORD *)v143;
    *(void *)uint64_t v149 = v144;
    v143[1] = 0;
    uint64_t v144 = 0;
    v143[0] = 0;
    unint64_t v47 = v135;
    float64x2_t v154 = *(float64x2_t *)(v134 + 104 * v135 + 24);
    trackrun::TrackRunEngineActiveObject::ConvertPointLatLonToEastNorth((uint64_t)v10, &v154, v84, v85, v86, v87, v88, v89);
    *(float64x2_t *)&v149[8] = v154;
    if (v11 && v153 >= 2)
    {
      trackrun::TrackRunEngineActiveObject::FindClosestPointOnRing(**(double ***)&v149[24], (double **)(*(void *)&v149[24] + 72 * v153 - 72), 1, 0);
      double v100 = fabs(v99) / (double)(v153 - 1);
    }
    else
    {
      double v100 = 1.22;
      if (!v11)
      {
        uint64_t v113 = *((void *)v10 + 67);
        int v114 = *(unsigned __int8 *)(v113 + 202);
        uint64_t v115 = (unint64_t *)(v113 + 208);
        if (!v114) {
          uint64_t v115 = v131;
        }
        unint64_t v153 = *v115;
        unint64_t v116 = *((void *)v10 + 86);
        if (v116 >= *((void *)v10 + 87))
        {
          uint64_t v117 = sub_18E1CB3F0((uint64_t *)v10 + 85, (uint64_t)__p);
        }
        else
        {
          sub_18E1CB510(*((void *)v10 + 86), (uint64_t)__p);
          uint64_t v117 = v116 + 104;
          *((void *)v10 + 86) = v116 + 104;
        }
        *((void *)v10 + 86) = v117;
        goto LABEL_107;
      }
    }
    double v151 = v100;
    char v152 = 1;
    uint64_t v108 = *((void *)v10 + 67);
    int v109 = *(unsigned __int8 *)(v108 + 202);
    uint64_t v110 = (unint64_t *)(v108 + 208);
    if (!v109) {
      uint64_t v110 = v131;
    }
    unint64_t v153 = *v110;
    unint64_t v111 = *((void *)v10 + 82);
    if (v111 >= *((void *)v10 + 83))
    {
      uint64_t v112 = sub_18E1CB3F0((uint64_t *)v10 + 81, (uint64_t)__p);
    }
    else
    {
      sub_18E1CB510(*((void *)v10 + 82), (uint64_t)__p);
      uint64_t v112 = v111 + 104;
      *((void *)v10 + 82) = v111 + 104;
    }
    *((void *)v10 + 82) = v112;
LABEL_107:
    if (v143[0])
    {
      v143[1] = v143[0];
      operator delete(v143[0]);
    }
    v143[0] = &v149[24];
    sub_18E1BDF18((void ***)v143);
    this = (uint64_t)__p[0];
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    ++v133;
    goto LABEL_112;
  }
LABEL_120:
  if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)this) < 2)
  {
    LOWORD(__p[0]) = 13;
    LOBYTE(v143[0]) = 1;
    uint64_t v118 = (*(uint64_t (**)(const trackrun::GEOMapRunningTrackDataEvent *))(*(void *)a2 + 16))(a2);
    double v130 = v119 + (double)v118;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)v143, "#tre_ao,time,%.3lf,new track data,num_tracks,%d,num_lanes,%d,num_lane_coordinates,%d,is_sparse_event,%d", v120, v121, v122, v123, v124, SLOBYTE(v130));
  }
  if (v11)
  {
    if (*((unsigned char *)v10 + 2632)) {
      trackrun::TrackRunEngineActiveObject::HandleEvent(v10, (trackrun::TrackRunEngineActiveObject *)((char *)v10 + 2544));
    }
  }
}

void sub_18E1C476C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *__p,uint64_t a49,int a50,__int16 a51,char a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57)
{
  if (a53 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E1C4840(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 88))
  {
    if (a1 != a2)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      uint64_t v6 = *(void *)(a2 + 8);
      uint64_t v5 = *(void *)(a2 + 16);
      unint64_t v7 = 0x4EC4EC4EC4EC4EC5 * ((v5 - v6) >> 3);
      if (0x4EC4EC4EC4EC4EC5 * ((*(void *)(a1 + 24) - v4) >> 3) >= v7)
      {
        if (0x4EC4EC4EC4EC4EC5 * ((*(void *)(a1 + 16) - v4) >> 3) >= v7)
        {
          uint64_t v15 = sub_18E1CAE70(*(void *)(a2 + 8), *(void *)(a2 + 16), v4);
          for (uint64_t i = *(void *)(a1 + 16); i != v15; sub_18E1BDAAC(i))
            i -= 104;
          *(void *)(a1 + 16) = v15;
          goto LABEL_18;
        }
        uint64_t v14 = v6 + 8 * ((*(void *)(a1 + 16) - v4) >> 3);
        sub_18E1CAE70(*(void *)(a2 + 8), v14, v4);
        uint64_t v10 = sub_18E1CAB10(a1 + 24, v14, v5, *(void *)(a1 + 16));
      }
      else
      {
        sub_18E1CAA50((void **)(a1 + 8));
        if (v7 > 0x276276276276276) {
          sub_18DEE1FC8();
        }
        unint64_t v8 = 0x9D89D89D89D89D8ALL * ((uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 8)) >> 3);
        if (v8 <= v7) {
          unint64_t v8 = 0x4EC4EC4EC4EC4EC5 * ((v5 - v6) >> 3);
        }
        if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 8)) >> 3)) >= 0x13B13B13B13B13BLL) {
          unint64_t v9 = 0x276276276276276;
        }
        else {
          unint64_t v9 = v8;
        }
        sub_18E1CAAB8((void *)(a1 + 8), v9);
        uint64_t v10 = sub_18E1CAB10(a1 + 24, v6, v5, *(void *)(a1 + 16));
      }
      *(void *)(a1 + 16) = v10;
    }
LABEL_18:
    long long v17 = *(_OWORD *)(a2 + 32);
    long long v18 = *(_OWORD *)(a2 + 48);
    long long v19 = *(_OWORD *)(a2 + 64);
    *(unsigned char *)(a1 + 80) = *(unsigned char *)(a2 + 80);
    *(_OWORD *)(a1 + 48) = v18;
    *(_OWORD *)(a1 + 64) = v19;
    *(_OWORD *)(a1 + 32) = v17;
    return a1;
  }
  *(void *)a1 = &unk_1EDD1A160;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = 0;
  sub_18E1CB248((void *)(a1 + 8), *(void *)(a2 + 8), *(void *)(a2 + 16), 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 3));
  long long v11 = *(_OWORD *)(a2 + 32);
  long long v12 = *(_OWORD *)(a2 + 48);
  long long v13 = *(_OWORD *)(a2 + 64);
  *(unsigned char *)(a1 + 80) = *(unsigned char *)(a2 + 80);
  *(_OWORD *)(a1 + 48) = v12;
  *(_OWORD *)(a1 + 64) = v13;
  *(_OWORD *)(a1 + 32) = v11;
  *(unsigned char *)(a1 + 88) = 1;
  return a1;
}

void sub_18E1C4A70(_Unwind_Exception *a1)
{
  *(void *)(v1 + 16) = v2;
  _Unwind_Resume(a1);
}

void sub_18E1C4A78(_Unwind_Exception *a1)
{
  *(void *)(v1 + 16) = v2;
  _Unwind_Resume(a1);
}

BOOL trackrun::TrackRunEngineActiveObject::CopyTrackLaneData(trackrun::TrackRunEngineActiveObject *this, const trackrun::RunningTrackData::RunningTrackLane *a2, trackrun::RunningTrackData::RunningTrackLane *a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(char **)a2;
  uint64_t v11 = *((void *)a2 + 1);
  unint64_t v13 = v11 - (void)v10;
  uint64_t v14 = (v11 - (uint64_t)v10) >> 4;
  if ((unint64_t)(v11 - (void)v10) <= 0x20)
  {
    LOWORD(v59.f64[0]) = 13;
    unsigned __int8 v58 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v59, &v58, "#tre_ao,lane has fewer than three coordinates,%lu", v14, a5, a6, a7, a8, (v11 - (uint64_t)v10) >> 4);
  }
  else
  {
    if (a3 != a2) {
      sub_18E1CB078((char *)a3, v10, v11, v14);
    }
    long long v16 = *(_OWORD *)((char *)a2 + 24);
    long long v17 = *(_OWORD *)((char *)a2 + 40);
    *(_OWORD *)((char *)a3 + 56) = *(_OWORD *)((char *)a2 + 56);
    *(_OWORD *)((char *)a3 + 40) = v17;
    *(_OWORD *)((char *)a3 + 24) = v16;
    long long v18 = *(float64x2_t **)a3;
    long long v19 = (float64x2_t *)*((void *)a3 + 1);
    if (*(float64x2_t **)a3 == v19)
    {
      uint64_t v20 = (float64x2_t *)*((void *)a3 + 1);
    }
    else
    {
      do
        trackrun::TrackRunEngineActiveObject::ConvertPointLatLonToEastNorth((uint64_t)this, v18++, v11, v14, a5, a6, a7, a8);
      while (v18 != v19);
      uint64_t v20 = *(float64x2_t **)a3;
      long long v19 = (float64x2_t *)*((void *)a3 + 1);
    }
    uint64_t v21 = (char *)v19 - (char *)v20;
    if ((unint64_t)((char *)v19 - (char *)v20) >= 0x30)
    {
      double v22 = v20->f64[0];
      double v23 = v19[-1].f64[0];
      if (v20->f64[0] != v23)
      {
        if ((*(void *)&v22 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v23 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_28;
        }
        double v54 = vabdd_f64(v22, v23);
        double v55 = fabs(v22);
        double v56 = fabs(v23);
        if (v55 >= v56) {
          double v56 = v55;
        }
        double v57 = v56 >= 1.0 ? v56 * 2.22044605e-16 : 2.22044605e-16;
        if (v54 > v57) {
          goto LABEL_28;
        }
      }
      double v24 = v20->f64[1];
      double v25 = v19[-1].f64[1];
      if (v24 != v25)
      {
        if ((*(void *)&v24 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v25 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_28;
        }
        double v27 = vabdd_f64(v24, v25);
        double v28 = fabs(v24);
        double v29 = fabs(v25);
        if (v28 < v29) {
          double v28 = v29;
        }
        double v30 = v28 >= 1.0 ? v28 * 2.22044605e-16 : 2.22044605e-16;
        if (v27 > v30)
        {
LABEL_28:
          float64_t v32 = v20->f64[1];
          unint64_t v33 = *((void *)a3 + 2);
          if ((unint64_t)v19 >= v33)
          {
            uint64_t v34 = v21 >> 4;
            unint64_t v35 = (v21 >> 4) + 1;
            if (v35 >> 60) {
              sub_18DEE1FC8();
            }
            uint64_t v36 = v33 - (void)v20;
            if (v36 >> 3 > v35) {
              unint64_t v35 = v36 >> 3;
            }
            if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v37 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v37 = v35;
            }
            if (v37) {
              double v38 = (char *)sub_18DFF7B64((uint64_t)a3 + 16, v37);
            }
            else {
              double v38 = 0;
            }
            double v39 = &v38[16 * v34];
            uint64_t v40 = &v38[16 * v37];
            *(double *)double v39 = v22;
            *((float64_t *)v39 + 1) = v32;
            long long v19 = (float64x2_t *)(v39 + 16);
            uint64_t v42 = *(char **)a3;
            uint64_t v41 = (char *)*((void *)a3 + 1);
            if (v41 != *(char **)a3)
            {
              do
              {
                *((_OWORD *)v39 - 1) = *((_OWORD *)v41 - 1);
                v39 -= 16;
                v41 -= 16;
              }
              while (v41 != v42);
              uint64_t v41 = *(char **)a3;
            }
            *(void *)a3 = v39;
            *((void *)a3 + 1) = v19;
            *((void *)a3 + 2) = v40;
            if (v41) {
              operator delete(v41);
            }
          }
          else
          {
            v19->f64[0] = v22;
            v19->f64[1] = v32;
            ++v19;
          }
          *((void *)a3 + 1) = v19;
          uint64_t v20 = *(float64x2_t **)a3;
          uint64_t v21 = (uint64_t)v19 - *(void *)a3;
        }
      }
      uint64_t v43 = v19 - 1;
      if ((unint64_t)v21 >= 0x40 && v43 != v20)
      {
        double v45 = 0.0;
        f64 = v19[-1].f64;
        unint64_t v47 = v19[-1].f64;
        do
        {
          double v48 = *(v47 - 2);
          v47 -= 2;
          double v45 = v45 + (*f64 + v48) * (f64[1] - *(f64 - 1));
          f64 = v47;
        }
        while (v47 != (double *)v20);
        BOOL v49 = v45 * 0.5 >= 0.0 || v20 == v19;
        if (!v49 && v43 > v20)
        {
          unint64_t v51 = (unint64_t)&v20[1];
          do
          {
            float64x2_t v59 = *(float64x2_t *)(v51 - 16);
            *(float64x2_t *)(v51 - 16) = *v43;
            *v43-- = v59;
            BOOL v52 = v51 >= (unint64_t)v43;
            v51 += 16;
          }
          while (!v52);
        }
      }
    }
  }
  return v13 > 0x20;
}

float64x2_t trackrun::TrackRunEngineActiveObject::ConvertPointLatLonToEastNorth(uint64_t a1, float64x2_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 624))
  {
    int8x16_t v9 = (int8x16_t)vmulq_f64(vsubq_f64(*a2, *(float64x2_t *)(a1 + 608)), *(float64x2_t *)(a1 + 632));
  }
  else
  {
    __int16 v13 = 13;
    unsigned __int8 v12 = 4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v13, &v12, "#tre_ao,point coordinate conversion from lat lon to east north could not be completed", a4, a5, a6, a7, a8, v11);
    int8x16_t v9 = 0uLL;
  }
  float64x2_t result = (float64x2_t)vextq_s8(v9, v9, 8uLL);
  *a2 = result;
  return result;
}

double trackrun::TrackRunEngineActiveObject::FindClosestPointOnRing(double *a1, double **a2, int a3, int a4)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  long long v6 = *((_OWORD *)*a2 + 1);
  long long v34 = *(_OWORD *)*a2;
  long long v35 = v6;
  if (v5 != v4)
  {
    unint64_t v7 = v5 + 2;
    if (v5 + 2 == v4)
    {
      double v23 = *v5;
      double v24 = v5[1];
      double v25 = a1[1];
      double v26 = v23 - v23;
      double v27 = v24 - v24;
      double v28 = *a1 - *v5;
      double v29 = (v24 - v24) * (v25 - v24) + v28 * (v23 - v23);
      if (v29 <= 0.0 || (double v30 = v27 * v27 + v26 * v26, v30 <= v29))
      {
        double v32 = v28 * v28 + 0.0 + (v25 - v24) * (v25 - v24);
      }
      else
      {
        double v31 = *a1 - (v23 + v26 * (v29 / v30));
        double v32 = v31 * v31 + 0.0 + (v25 - (v24 + v27 * (v29 / v30))) * (v25 - (v24 + v27 * (v29 / v30)));
      }
      if (v32 < 1.79769313e308)
      {
        long long v34 = *(_OWORD *)v5;
        long long v35 = v34;
      }
    }
    else
    {
      double v8 = *a1;
      double v9 = a1[1];
      double v11 = *v5;
      double v10 = v5[1];
      double v12 = 1.79769313e308;
      do
      {
        double v13 = *v7;
        double v14 = v7[1];
        double v15 = *v7 - v11;
        double v16 = v14 - v10;
        double v17 = (v9 - v10) * (v14 - v10) + (v8 - v11) * v15;
        if (v17 <= 0.0)
        {
          double v22 = (v8 - v11) * (v8 - v11) + 0.0 + (v9 - v10) * (v9 - v10);
        }
        else
        {
          double v18 = v16 * v16 + v15 * v15;
          if (v18 <= v17)
          {
            double v20 = v9 - v14;
            double v21 = v8 - v13;
          }
          else
          {
            double v19 = v17 / v18;
            double v20 = v9 - (v10 + v16 * v19);
            double v21 = v8 - (v11 + v15 * v19);
          }
          double v22 = v21 * v21 + 0.0 + v20 * v20;
        }
        if (v22 < v12)
        {
          long long v34 = *((_OWORD *)v7 - 1);
          long long v35 = *(_OWORD *)v7;
          double v12 = v22;
        }
        v7 += 2;
        double v10 = v14;
        double v11 = v13;
      }
      while (v7 != v4);
    }
  }
  return trackrun::TrackRunEngineActiveObject::FindClosestPointOnLineSegment(a1, (double *)&v34, a3, a4, 0);
}

void trackrun::TrackRunEngineActiveObject::HandleEvent(trackrun::TrackRunEngineActiveObject *this, const trackrun::PositionEvent *a2, double *a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, int8x16_t a13)
{
  uint64_t v751 = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)this + 480))
  {
    LOWORD(v730) = 13;
    LOBYTE(__p[0].f64[0]) = 4;
    uint64_t v26 = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
    double v673 = v27 + (double)v26;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v730, (unsigned __int8 *)__p, "#tre_ao,Not Configured,HandleEvent,PositionEvent,time,%.3lf", v28, v29, v30, v31, v32, SLOBYTE(v673));
    return;
  }
  if (!*((unsigned char *)a2 + 105))
  {
    LOWORD(v730) = 13;
    LOBYTE(__p[0].f64[0]) = 4;
    uint64_t v33 = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
    double v674 = v34 + (double)v33;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v730, (unsigned __int8 *)__p, "#tre_ao,Invalid PositionEvent,latlon coordinates invalid,time,%.3lf", v35, v36, v37, v38, v39, SLOBYTE(v674));
    return;
  }
  unsigned int v15 = *((unsigned __int8 *)a2 + 104);
  if (v15 > 0xD) {
    goto LABEL_17;
  }
  if (((1 << v15) & 0x2E10) != 0)
  {
    int v721 = 0;
    if (*((unsigned char *)this + 1000))
    {
      *(_OWORD *)((char *)this + 792) = *(_OWORD *)((char *)a2 + 8);
      long long v17 = *(_OWORD *)((char *)a2 + 24);
      long long v18 = *(_OWORD *)((char *)a2 + 40);
      long long v19 = *(_OWORD *)((char *)a2 + 56);
      *(_OWORD *)((char *)this + 856) = *(_OWORD *)((char *)a2 + 72);
      *(_OWORD *)((char *)this + 840) = v19;
      *(_OWORD *)((char *)this + 824) = v18;
      *(_OWORD *)((char *)this + 808) = v17;
      long long v20 = *(_OWORD *)((char *)a2 + 88);
      long long v21 = *(_OWORD *)((char *)a2 + 104);
      long long v22 = *(_OWORD *)((char *)a2 + 120);
      *(_OWORD *)((char *)this + 920) = *(_OWORD *)((char *)a2 + 136);
      *(_OWORD *)((char *)this + 904) = v22;
      *(_OWORD *)((char *)this + 888) = v21;
      *(_OWORD *)((char *)this + 872) = v20;
      __n128 v23 = *(__n128 *)((char *)a2 + 152);
      long long v24 = *(_OWORD *)((char *)a2 + 168);
      long long v25 = *(_OWORD *)((char *)a2 + 184);
      *(_OWORD *)((char *)this + 984) = *(_OWORD *)((char *)a2 + 200);
      *(_OWORD *)((char *)this + 968) = v25;
      *(_OWORD *)((char *)this + 952) = v24;
      *(__n128 *)((char *)this + 936) = v23;
    }
    else
    {
      *((void *)this + 98) = &unk_1EDD19F38;
      *(_OWORD *)((char *)this + 792) = *(_OWORD *)((char *)a2 + 8);
      long long v49 = *(_OWORD *)((char *)a2 + 24);
      long long v50 = *(_OWORD *)((char *)a2 + 40);
      long long v51 = *(_OWORD *)((char *)a2 + 56);
      *(_OWORD *)((char *)this + 856) = *(_OWORD *)((char *)a2 + 72);
      *(_OWORD *)((char *)this + 840) = v51;
      *(_OWORD *)((char *)this + 824) = v50;
      *(_OWORD *)((char *)this + 808) = v49;
      long long v52 = *(_OWORD *)((char *)a2 + 88);
      long long v53 = *(_OWORD *)((char *)a2 + 104);
      long long v54 = *(_OWORD *)((char *)a2 + 120);
      *(_OWORD *)((char *)this + 920) = *(_OWORD *)((char *)a2 + 136);
      *(_OWORD *)((char *)this + 904) = v54;
      *(_OWORD *)((char *)this + 888) = v53;
      *(_OWORD *)((char *)this + 872) = v52;
      __n128 v23 = *(__n128 *)((char *)a2 + 152);
      long long v55 = *(_OWORD *)((char *)a2 + 168);
      long long v56 = *(_OWORD *)((char *)a2 + 184);
      *(_OWORD *)((char *)this + 984) = *(_OWORD *)((char *)a2 + 200);
      *(_OWORD *)((char *)this + 968) = v56;
      *(_OWORD *)((char *)this + 952) = v55;
      *(__n128 *)((char *)this + 936) = v23;
      *((unsigned char *)this + 1000) = 1;
    }
    goto LABEL_19;
  }
  if (((1 << v15) & 0x10C0) != 0)
  {
    if (*((unsigned char *)this + 1000))
    {
      *(_OWORD *)((char *)this + 792) = *(_OWORD *)((char *)a2 + 8);
      long long v40 = *(_OWORD *)((char *)a2 + 24);
      long long v41 = *(_OWORD *)((char *)a2 + 40);
      long long v42 = *(_OWORD *)((char *)a2 + 56);
      *(_OWORD *)((char *)this + 856) = *(_OWORD *)((char *)a2 + 72);
      *(_OWORD *)((char *)this + 840) = v42;
      *(_OWORD *)((char *)this + 824) = v41;
      *(_OWORD *)((char *)this + 808) = v40;
      long long v43 = *(_OWORD *)((char *)a2 + 88);
      long long v44 = *(_OWORD *)((char *)a2 + 104);
      long long v45 = *(_OWORD *)((char *)a2 + 120);
      *(_OWORD *)((char *)this + 920) = *(_OWORD *)((char *)a2 + 136);
      *(_OWORD *)((char *)this + 904) = v45;
      *(_OWORD *)((char *)this + 888) = v44;
      *(_OWORD *)((char *)this + 872) = v43;
      long long v46 = *(_OWORD *)((char *)a2 + 152);
      long long v47 = *(_OWORD *)((char *)a2 + 168);
      long long v48 = *(_OWORD *)((char *)a2 + 184);
      *(_OWORD *)((char *)this + 984) = *(_OWORD *)((char *)a2 + 200);
      *(_OWORD *)((char *)this + 968) = v48;
      *(_OWORD *)((char *)this + 952) = v47;
      *(_OWORD *)((char *)this + 936) = v46;
    }
    else
    {
      *((void *)this + 98) = &unk_1EDD19F38;
      *(_OWORD *)((char *)this + 792) = *(_OWORD *)((char *)a2 + 8);
      long long v65 = *(_OWORD *)((char *)a2 + 24);
      long long v66 = *(_OWORD *)((char *)a2 + 40);
      long long v67 = *(_OWORD *)((char *)a2 + 56);
      *(_OWORD *)((char *)this + 856) = *(_OWORD *)((char *)a2 + 72);
      *(_OWORD *)((char *)this + 840) = v67;
      *(_OWORD *)((char *)this + 824) = v66;
      *(_OWORD *)((char *)this + 808) = v65;
      long long v68 = *(_OWORD *)((char *)a2 + 88);
      long long v69 = *(_OWORD *)((char *)a2 + 104);
      long long v70 = *(_OWORD *)((char *)a2 + 120);
      *(_OWORD *)((char *)this + 920) = *(_OWORD *)((char *)a2 + 136);
      *(_OWORD *)((char *)this + 904) = v70;
      *(_OWORD *)((char *)this + 888) = v69;
      *(_OWORD *)((char *)this + 872) = v68;
      long long v71 = *(_OWORD *)((char *)a2 + 152);
      long long v72 = *(_OWORD *)((char *)a2 + 168);
      long long v73 = *(_OWORD *)((char *)a2 + 184);
      *(_OWORD *)((char *)this + 984) = *(_OWORD *)((char *)a2 + 200);
      *(_OWORD *)((char *)this + 968) = v73;
      *(_OWORD *)((char *)this + 952) = v72;
      *(_OWORD *)((char *)this + 936) = v71;
      *((unsigned char *)this + 1000) = 1;
    }
    return;
  }
  if (v15 != 1)
  {
LABEL_17:
    LOWORD(v730) = 13;
    LOBYTE(__p[0].f64[0]) = 4;
    uint64_t v74 = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
    double v675 = v75 + (double)v74;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v730, (unsigned __int8 *)__p, "#tre_ao,HandleEvent,PositionEvent,time,%.3lf,type unusable,%hhu", v76, v77, v78, v79, v80, SLOBYTE(v675));
    return;
  }
  if (*((unsigned char *)this + 1000))
  {
    *(_OWORD *)((char *)this + 792) = *(_OWORD *)((char *)a2 + 8);
    long long v57 = *(_OWORD *)((char *)a2 + 24);
    long long v58 = *(_OWORD *)((char *)a2 + 40);
    long long v59 = *(_OWORD *)((char *)a2 + 56);
    *(_OWORD *)((char *)this + 856) = *(_OWORD *)((char *)a2 + 72);
    *(_OWORD *)((char *)this + 840) = v59;
    *(_OWORD *)((char *)this + 824) = v58;
    *(_OWORD *)((char *)this + 808) = v57;
    long long v60 = *(_OWORD *)((char *)a2 + 88);
    long long v61 = *(_OWORD *)((char *)a2 + 104);
    long long v62 = *(_OWORD *)((char *)a2 + 120);
    *(_OWORD *)((char *)this + 920) = *(_OWORD *)((char *)a2 + 136);
    *(_OWORD *)((char *)this + 904) = v62;
    *(_OWORD *)((char *)this + 888) = v61;
    *(_OWORD *)((char *)this + 872) = v60;
    __n128 v23 = *(__n128 *)((char *)a2 + 152);
    long long v63 = *(_OWORD *)((char *)a2 + 168);
    long long v64 = *(_OWORD *)((char *)a2 + 184);
    *(_OWORD *)((char *)this + 984) = *(_OWORD *)((char *)a2 + 200);
    *(_OWORD *)((char *)this + 968) = v64;
    *(_OWORD *)((char *)this + 952) = v63;
    *(__n128 *)((char *)this + 936) = v23;
    int v721 = 1;
  }
  else
  {
    *((void *)this + 98) = &unk_1EDD19F38;
    *(_OWORD *)((char *)this + 792) = *(_OWORD *)((char *)a2 + 8);
    long long v81 = *(_OWORD *)((char *)a2 + 24);
    long long v82 = *(_OWORD *)((char *)a2 + 40);
    long long v83 = *(_OWORD *)((char *)a2 + 56);
    *(_OWORD *)((char *)this + 856) = *(_OWORD *)((char *)a2 + 72);
    *(_OWORD *)((char *)this + 840) = v83;
    *(_OWORD *)((char *)this + 824) = v82;
    *(_OWORD *)((char *)this + 808) = v81;
    long long v84 = *(_OWORD *)((char *)a2 + 88);
    long long v85 = *(_OWORD *)((char *)a2 + 104);
    long long v86 = *(_OWORD *)((char *)a2 + 120);
    *(_OWORD *)((char *)this + 920) = *(_OWORD *)((char *)a2 + 136);
    *(_OWORD *)((char *)this + 904) = v86;
    *(_OWORD *)((char *)this + 888) = v85;
    *(_OWORD *)((char *)this + 872) = v84;
    __n128 v23 = *(__n128 *)((char *)a2 + 152);
    long long v87 = *(_OWORD *)((char *)a2 + 168);
    long long v88 = *(_OWORD *)((char *)a2 + 184);
    *(_OWORD *)((char *)this + 984) = *(_OWORD *)((char *)a2 + 200);
    *(_OWORD *)((char *)this + 968) = v88;
    *(_OWORD *)((char *)this + 952) = v87;
    *(__n128 *)((char *)this + 936) = v23;
    int v721 = 1;
    *((unsigned char *)this + 1000) = 1;
  }
LABEL_19:
  if (*((unsigned char *)this + 672) || !*((unsigned char *)this + 2536))
  {
    if (!*((unsigned char *)this + 704) && *((unsigned char *)this + 2632)) {
      trackrun::TrackRunEngineActiveObject::HandleEvent((uint64_t)this, (trackrun::TrackRunEngineActiveObject *)((char *)this + 2544), a3, a4, a5, a6, a7, a8, v23);
    }
  }
  else
  {
    trackrun::TrackRunEngineActiveObject::HandleEvent((uint64_t)this, (trackrun::TrackRunEngineActiveObject *)((char *)this + 2448), a3, a4, a5, a6, a7, a8, v23);
    if (*((unsigned char *)this + 2536))
    {
      *((void *)this + 306) = &unk_1EDD1A160;
      v730 = (void **)((char *)this + 2456);
      sub_18E1BEB28(&v730);
      *((unsigned char *)this + 2536) = 0;
    }
  }
  v730 = (void **)&unk_1EDD1A0C0;
  BYTE8(v731[3]) = 0;
  LOBYTE(v731[9]) = 0;
  BYTE8(v731[9]) = 0;
  BYTE8(v731[11]) = 0;
  LOBYTE(v731[12]) = 0;
  LOBYTE(v731[22]) = 0;
  LODWORD(v731[3]) = 0;
  memset(__p, 0, 24);
  memset(v749, 0, 23);
  LOBYTE(v731[0]) = 0;
  *(float64_t *)((char *)&v731[1] + 1) = __p[1].f64[0];
  *(float64x2_t *)((char *)v731 + 1) = __p[0];
  *((void *)&v731[2] + 1) = 0;
  *(_OWORD *)((char *)&v731[1] + 9) = *(_OWORD *)v749;
  BYTE10(v731[22]) = 0;
  WORD4(v731[22]) = v721;
  int v89 = *((unsigned __int8 *)this + 672);
  if (!*((unsigned char *)this + 672) && !*((unsigned char *)this + 704))
  {
    strcpy((char *)__p, "\r");
    v749[0] = 2;
    uint64_t v152 = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
    double v677 = v153 + (double)v152;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, v749, "#tre_ao,HandleEvent,PositionEvent,time,%.3lf,no track data available; cannot perform proximity detection",
      v154,
      v155,
      v156,
      v157,
      v158,
      SLOBYTE(v677));
    LODWORD(v731[3]) = 0;
    BYTE10(v731[22]) = 1;
    if (*((unsigned char *)this + 2056))
    {
      memcpy((char *)this + 1688, v731, 0x16BuLL);
    }
    else
    {
      *((void *)this + 210) = &unk_1EDD1A0C0;
      memcpy((char *)this + 1688, v731, 0x16BuLL);
      *((unsigned char *)this + 2056) = 1;
    }
    return;
  }
  if (!*((unsigned char *)this + 624))
  {
    v728.i8[0] = 0;
    char v729 = 0;
    strcpy((char *)__p, "\r");
    v749[0] = 4;
    uint64_t v136 = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
    double v676 = v137 + (double)v136;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, v749, "#tre_ao,HandleEvent,PositionEvent,time,%.3lf,failed ConvertLatLonToEastNorth", v138, v139, v140, v141, v142, SLOBYTE(v676));
    return;
  }
  int8x16_t v90 = (int8x16_t)vmulq_f64(vsubq_f64(*((float64x2_t *)a2 + 7), *((float64x2_t *)this + 38)), *(float64x2_t *)((char *)this + 632));
  int8x16_t v728 = vextq_s8(v90, v90, 8uLL);
  char v729 = 1;
  if (!*((unsigned char *)this + 704)
    || (uint64_t v91 = *((void *)this + 86), v92 = *((void *)this + 85), v93 = v91 - v92, v91 == v92))
  {
    uint64_t v94 = 0;
    double v98 = INFINITY;
  }
  else
  {
    uint64_t v94 = 0;
    uint64_t v95 = 0;
    unint64_t v96 = v93 / 104;
    if (v96 <= 1) {
      unint64_t v96 = 1;
    }
    uint64_t v97 = (double *)(v92 + 32);
    double v98 = INFINITY;
    do
    {
      double v99 = (*(double *)&v90.i64[1] - *(v97 - 1)) * (*(double *)&v90.i64[1] - *(v97 - 1)) + 0.0;
      *(double *)a13.i64 = v99 + (*(double *)v90.i64 - *v97) * (*(double *)v90.i64 - *v97);
      if (*(double *)a13.i64 < v98)
      {
        uint64_t v94 = v95;
        double v98 = v99 + (*(double *)v90.i64 - *v97) * (*(double *)v90.i64 - *v97);
      }
      ++v95;
      v97 += 13;
    }
    while (v96 != v95);
  }
  double v100 = (uint64_t *)((char *)this + 648);
  if (!v89 || (uint64_t v101 = *((void *)this + 82), v102 = *((void *)this + 81), v103 = v101 - v102, v101 == v102))
  {
    uint64_t v104 = 0;
    double v108 = INFINITY;
  }
  else
  {
    uint64_t v104 = 0;
    uint64_t v105 = 0;
    unint64_t v106 = v103 / 104;
    if (v106 <= 1) {
      unint64_t v106 = 1;
    }
    uint64_t v107 = (double *)(v102 + 32);
    double v108 = INFINITY;
    a13.i64[0] = 0;
    do
    {
      double v109 = (*(double *)&v90.i64[1] - *(v107 - 1)) * (*(double *)&v90.i64[1] - *(v107 - 1)) + 0.0;
      if (v109 + (*(double *)v90.i64 - *v107) * (*(double *)v90.i64 - *v107) < v108)
      {
        uint64_t v104 = v105;
        double v108 = v109 + (*(double *)v90.i64 - *v107) * (*(double *)v90.i64 - *v107);
      }
      ++v105;
      v107 += 13;
    }
    while (v106 != v105);
  }
  BOOL v110 = v98 >= v108 || *((unsigned char *)this + 704) == 0;
  int v111 = !v110;
  int v717 = v111;
  if (v110)
  {
    uint64_t v143 = *v100;
    v720 = (trackrun::RunningTrackData::RunningTrack *)(*v100 + 104 * v104);
    if (*((void *)v720 + 12))
    {
      uint64_t v144 = v143 + 104 * v104;
      uint64_t v147 = *(void *)(v144 + 40);
      long long v146 = (uint64_t *)(v144 + 40);
      uint64_t v145 = v147;
      v716 = (char *)this + 648;
      if (!*(unsigned char *)(v147 + 40))
      {
        trackrun::RunningTrackData::RunningTrackLane::PopulateLaneLength(v145, *(double *)v90.i64, v98, v108);
        if (*(unsigned char *)(*((void *)this + 67) + 216))
        {
          uint64_t v185 = *v146;
          uint64_t v186 = *(void *)(v143 + 104 * v104 + 48);
          if (v185 != v186)
          {
            int v187 = 1;
            do
            {
              trackrun::RunningTrackData::RunningTrackLane::PopulateLaneLength(v185, v182, v183, v184);
              strcpy((char *)__p, "\r");
              v749[0] = 3;
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, v749, "#tre_ao,lane,%zu,length,%.2lf,width,%.2lf", v188, v189, v190, v191, v192, v187++);
              v185 += 72;
            }
            while (v185 != v186);
          }
        }
      }
      goto LABEL_104;
    }
    strcpy((char *)__p, "\r");
    v749[0] = 4;
    uint64_t v159 = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
    double v678 = v160 + (double)v159;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, v749, "#tre_ao,HandleEvent,PositionEvent,time,%.3lf,nearest_track has no lanes cached. Cannot proceed.", v161, v162, v163, v164, v165, SLOBYTE(v678));
    return;
  }
  v716 = (char *)this + 648;
  uint64_t v112 = *((void *)this + 85) + 104 * v94;
  uint64_t v113 = *(double **)v112;
  int v114 = *(double **)(v112 + 8);
  v720 = (trackrun::RunningTrackData::RunningTrack *)v112;
  if (*(double **)v112 == v114) {
    goto LABEL_676;
  }
  uint64_t v115 = *(double **)v112;
  do
  {
    BOOL v116 = (*(void *)v115 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
        && ((void)v115[1] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL;
    char v117 = !v116;
    if (!v116) {
      break;
    }
    v115 += 2;
  }
  while (v115 != v114);
  char v118 = (unint64_t)((char *)v114 - (char *)v113) < 0x40 ? 1 : v117;
  if (v118) {
    goto LABEL_676;
  }
  unint64_t v119 = 0;
  uint64_t v120 = v113;
  while (1)
  {
    unint64_t v121 = v119;
    if (v120 == v114) {
      break;
    }
    uint64_t v122 = v120;
    ++v119;
    double v123 = *v120;
    BOOL v124 = (*(void *)v120 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL;
    double v125 = fabs(*v120);
    while (1)
    {
      double v126 = *v120;
      if (*v120 != v123)
      {
        char v127 = (*(void *)&v126 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v124;
        if (v127) {
          break;
        }
        *(double *)a13.i64 = vabdd_f64(v126, v123);
        double v128 = fabs(v126);
        if (v128 < v125) {
          double v128 = v125;
        }
        double v129 = v128 >= 1.0 ? v128 * 2.22044605e-16 : 2.22044605e-16;
        if (*(double *)a13.i64 > v129) {
          break;
        }
      }
      double v130 = v120[1];
      a13.i64[0] = (uint64_t)v122[1];
      if (v130 != *(double *)a13.i64)
      {
        if ((*(void *)&v130 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || (a13.i64[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          break;
        }
        double v132 = vabdd_f64(v130, *(double *)a13.i64);
        double v133 = fabs(v130);
        double v134 = fabs(*(double *)a13.i64);
        if (v133 < v134) {
          double v133 = v134;
        }
        a13.i64[0] = 0x3CB0000000000000;
        double v135 = v133 >= 1.0 ? v133 * 2.22044605e-16 : 2.22044605e-16;
        if (v132 > v135) {
          break;
        }
      }
      v120 += 2;
      if (v120 == v114) {
        goto LABEL_112;
      }
    }
    if (v121 == 4) {
      goto LABEL_113;
    }
  }
LABEL_112:
  if (v121 < 3) {
    goto LABEL_676;
  }
LABEL_113:
  double v166 = *v113;
  double v167 = *(v114 - 2);
  if (*v113 != v167)
  {
    if ((*(void *)&v166 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v167 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_676;
    }
    double v283 = vabdd_f64(v166, v167);
    double v284 = fabs(v166);
    double v285 = fabs(v167);
    if (v284 >= v285) {
      double v285 = v284;
    }
    *(double *)a13.i64 = v285 * 2.22044605e-16;
    double v286 = v285 >= 1.0 ? v285 * 2.22044605e-16 : 2.22044605e-16;
    if (v283 > v286) {
      goto LABEL_676;
    }
  }
  double v168 = v113[1];
  double v169 = *(v114 - 1);
  if (v168 != v169)
  {
    if ((*(void *)&v168 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v169 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_676;
    }
    double v288 = vabdd_f64(v168, v169);
    double v289 = fabs(v168);
    double v290 = fabs(v169);
    if (v289 >= v290) {
      double v290 = v289;
    }
    a13.i64[0] = 0x3CB0000000000000;
    double v291 = v290 >= 1.0 ? v290 * 2.22044605e-16 : 2.22044605e-16;
    if (v288 > v291) {
      goto LABEL_676;
    }
  }
  double v170 = v113 + 2;
  if (v113 + 2 != v114)
  {
    double v171 = fabs(v166);
    *(double *)a13.i64 = fabs(v168);
    while (1)
    {
      double v172 = *v170;
      if (*v170 != v166)
      {
        if ((*(void *)&v172 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v166 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          break;
        }
        double v174 = vabdd_f64(v172, v166);
        double v175 = fabs(v172);
        if (v175 < v171) {
          double v175 = v171;
        }
        double v176 = v175 >= 1.0 ? v175 * 2.22044605e-16 : 2.22044605e-16;
        if (v174 > v176) {
          break;
        }
      }
      double v177 = v170[1];
      if (v177 != v168)
      {
        if ((*(void *)&v177 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v168 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          break;
        }
        double v179 = vabdd_f64(v177, v168);
        double v180 = fabs(v177);
        if (v180 < *(double *)a13.i64) {
          double v180 = *(double *)a13.i64;
        }
        double v181 = v180 >= 1.0 ? v180 * 2.22044605e-16 : 2.22044605e-16;
        if (v179 > v181) {
          break;
        }
      }
      v170 += 2;
      if (v170 == v114) {
        goto LABEL_499;
      }
    }
    if (v170 != v114)
    {
      uint64_t v301 = v170 + 2;
      if (v170 + 2 != v114)
      {
        double v302 = fabs(v172);
        while (1)
        {
          double v303 = *v301;
          if (*v301 != v172)
          {
            if ((*(void *)&v303 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
              || (*(void *)&v172 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              break;
            }
            *(double *)a13.i64 = vabdd_f64(v303, v172);
            double v305 = fabs(v303);
            if (v305 < v302) {
              double v305 = v302;
            }
            double v306 = v305 >= 1.0 ? v305 * 2.22044605e-16 : 2.22044605e-16;
            if (*(double *)a13.i64 > v306) {
              break;
            }
          }
          double v307 = v301[1];
          a13.i64[0] = (uint64_t)v170[1];
          if (v307 != *(double *)a13.i64)
          {
            if ((*(void *)&v307 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
              || (a13.i64[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              break;
            }
            double v309 = vabdd_f64(v307, *(double *)a13.i64);
            double v310 = fabs(v307);
            double v311 = fabs(*(double *)a13.i64);
            if (v310 < v311) {
              double v310 = v311;
            }
            a13.i64[0] = 0x3CB0000000000000;
            double v312 = v310 >= 1.0 ? v310 * 2.22044605e-16 : 2.22044605e-16;
            if (v309 > v312) {
              break;
            }
          }
          v301 += 2;
          if (v301 == v114) {
            goto LABEL_499;
          }
        }
        if (v301 != v114)
        {
          double v13 = 1.0;
          char v365 = v113;
          do
          {
            char v366 = v170;
            double v170 = v301;
            __p[0].f64[0] = 1.0;
            uint64_t v367 = v365;
            double v368 = sub_18E12FB7C(v301, v366, v365, __p[0].f64);
            if (v368 == 0.0
              || (*(void *)&v368 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
              && fabs(v368) <= __p[0].f64[0] * 2.22044605e-16)
            {
              double v369 = v366[1];
              double v370 = v170[1] - v369;
              double v371 = *v366 - *v170;
              double v372 = -v370;
              if (v371 == 0.0) {
                goto LABEL_433;
              }
              if (COERCE_UNSIGNED_INT64(fabs(*v366 - *v170)) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                double v375 = fabs(v371);
                double v376 = 2.22044605e-16;
                if (v375 >= 1.0) {
                  double v376 = v375 * 2.22044605e-16;
                }
                if (v375 <= v376)
                {
LABEL_433:
                  if (v370 == 0.0) {
                    goto LABEL_676;
                  }
                  if (COERCE_UNSIGNED_INT64(fabs(v170[1] - v369)) <= 0x7FEFFFFFFFFFFFFFLL)
                  {
                    double v373 = fabs(v372);
                    double v374 = 2.22044605e-16;
                    if (v373 >= 1.0) {
                      double v374 = v373 * 2.22044605e-16;
                    }
                    if (v373 <= v374) {
                      goto LABEL_676;
                    }
                  }
                }
              }
              double v377 = v369 * v370 - v371 * *v366;
              a13.i64[0] = (uint64_t)v367[1];
              if (v377 + *(double *)a13.i64 * v372 + v371 * *v367 <= 0.0) {
                goto LABEL_676;
              }
            }
            if (v170 == v114) {
              break;
            }
            uint64_t v301 = v170 + 2;
            if (v170 + 2 == v114) {
              break;
            }
            double v378 = *v170;
            double v379 = fabs(*v170);
            while (1)
            {
              double v380 = *v301;
              if (*v301 != v378)
              {
                if ((*(void *)&v380 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                  || (*(void *)v170 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                {
                  break;
                }
                double v382 = vabdd_f64(v380, v378);
                double v383 = fabs(v380);
                if (v383 < v379) {
                  double v383 = v379;
                }
                a13.i64[0] = 0x3CB0000000000000;
                double v384 = v383 >= 1.0 ? v383 * 2.22044605e-16 : 2.22044605e-16;
                if (v382 > v384) {
                  break;
                }
              }
              double v385 = v301[1];
              double v386 = v170[1];
              if (v385 != v386)
              {
                if ((*(void *)&v385 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                  || (*(void *)&v386 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                {
                  break;
                }
                *(double *)a13.i64 = vabdd_f64(v385, v386);
                double v388 = fabs(v385);
                double v389 = fabs(v386);
                if (v388 < v389) {
                  double v388 = v389;
                }
                double v390 = v388 >= 1.0 ? v388 * 2.22044605e-16 : 2.22044605e-16;
                if (*(double *)a13.i64 > v390) {
                  break;
                }
              }
              v301 += 2;
              if (v301 == v114) {
                goto LABEL_472;
              }
            }
            char v365 = v366;
          }
          while (v301 != v114);
LABEL_472:
          double v391 = *v113;
          double v392 = *(v114 - 2);
          if (*v113 == v392) {
            goto LABEL_474;
          }
          if ((*(void *)&v391 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
            && (*(void *)&v392 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            double v397 = vabdd_f64(v391, v392);
            double v398 = fabs(v391);
            double v399 = fabs(v392);
            if (v398 < v399) {
              double v398 = v399;
            }
            a13.i64[0] = 1.0;
            double v400 = v398 >= 1.0 ? v398 * 2.22044605e-16 : 2.22044605e-16;
            if (v397 <= v400)
            {
LABEL_474:
              double v393 = v113[1];
              double v394 = *(v114 - 1);
              if (v393 == v394) {
                goto LABEL_839;
              }
              if ((*(void *)&v393 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                && (*(void *)&v394 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                double v401 = vabdd_f64(v393, v394);
                double v402 = fabs(v393);
                double v403 = fabs(v394);
                if (v402 < v403) {
                  double v402 = v403;
                }
                a13.i64[0] = 1.0;
                double v404 = v402 >= 1.0 ? v402 * 2.22044605e-16 : 2.22044605e-16;
                if (v401 <= v404)
                {
LABEL_839:
                  if (sub_18E1CBBB4(v113, v114))
                  {
LABEL_676:
                    strcpy((char *)__p, "\r");
                    v749[0] = 4;
                    uint64_t v511 = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
                    double v682 = v512 + (double)v511;
                    cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, v749, "#tre_ao,HandleEvent,PositionEvent,time,%.3lf,nearest_track does not have a valid bounding box. Cannot proceed.", v513, v514, v515, v516, v517, SLOBYTE(v682));
                    return;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_499:
  v733 = 0;
  v732 = 0;
  uint64_t v734 = 0;
  uint64_t v406 = *(double **)v720;
  v405 = (double *)*((void *)v720 + 1);
  if (*(double **)v720 == v405)
  {
    double v412 = 0.0;
    v405 = *(double **)v720;
  }
  else
  {
    v407 = (float64x2_t *)(v406 + 2);
    float64x2_t v408 = *(float64x2_t *)v406;
    a13 = *(int8x16_t *)v406;
    while (v407 != (float64x2_t *)v405)
    {
      float64x2_t v409 = *v407++;
      a13 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)a13, v409), (int8x16_t)v409, a13);
      float64x2_t v408 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v409, v408), (int8x16_t)v409, (int8x16_t)v408);
    }
    float64x2_t v410 = vabdq_f64(v408, (float64x2_t)a13);
    double v411 = v410.f64[1];
    if (v410.f64[1] < v410.f64[0]) {
      double v411 = v410.f64[0];
    }
    double v13 = *(double *)&a13.i64[1];
    double v412 = 1.0;
    if (v411 != 0.0)
    {
      double v413 = 2.22044605e-16;
      if (v411 >= 1.0) {
        double v413 = v411 * 2.22044605e-16;
      }
      BOOL v414 = v411 <= v413 && *(void *)&v411 >> 52 < 0x7FFuLL;
      if (v411 < 10000000.0 && !v414 && *(void *)&v411 >> 52 < 0x7FFuLL)
      {
        unint64_t v713 = a13.i64[0];
        double v415 = 10000000.0 / v411 + 0.5;
        sub_18E1CBEE0(2 * (v415 >= 9.22337204e18));
        uint64_t v416 = vcvtmd_s64_f64(v415);
        if (v416 < 1)
        {
          v669 = "factor >= 1";
          int v670 = 86;
          v671 = "get_rescale_policy.hpp";
          v672 = "scale_box_to_integer_range";
LABEL_828:
          __assert_rtn(v672, v671, v670, v669);
        }
        double v412 = (double)v416;
        uint64_t v406 = *(double **)v720;
        v405 = (double *)*((void *)v720 + 1);
        a13.i64[0] = v713;
      }
    }
  }
  *(void *)v749 = a13.i64[0];
  *(double *)&v749[8] = v13;
  *(int64x2_t *)&v749[16] = vdupq_n_s64(0xFFFFFFFFFFB3B4C0);
  double v750 = v412;
  LOBYTE(v726) = 0;
  uint64_t v417 = (char *)v405 - (char *)v406;
  if ((unint64_t)((char *)v405 - (char *)v406) < 0x20 || (v735.i64[1] = -1, v735.i64[0] = -1, v405 == v406))
  {
    v492 = 0;
    v491 = 0;
    goto LABEL_626;
  }
  v688 = v405;
  __p[0].f64[1] = NAN;
  __p[0].f64[0] = NAN;
  double v418 = (v406[1] - v13) * v412 + -5000000.0;
  if (v418 >= 0.0) {
    double v419 = 0.5;
  }
  else {
    double v419 = -0.5;
  }
  double v420 = v418 + v419;
  v421 = v406;
  if (v418 + v419 <= -9.22337204e18) {
    uint64_t v422 = 1;
  }
  else {
    uint64_t v422 = 2 * (v418 + v419 >= 9.22337204e18);
  }
  sub_18E1CBEE0(v422);
  double v423 = (double)*(uint64_t *)&v749[16] + (*v421 - *(double *)v749) * v750;
  if (v423 >= 0.0) {
    double v424 = 0.5;
  }
  else {
    double v424 = -0.5;
  }
  double v425 = v423 + v424;
  if (v423 + v424 <= -9.22337204e18) {
    uint64_t v426 = 1;
  }
  else {
    uint64_t v426 = 2 * (v423 + v424 >= 9.22337204e18);
  }
  sub_18E1CBEE0(v426);
  v427 = v421 + 2;
  v428 = v688;
  if (v421 + 2 == v688)
  {
    v492 = 0;
    v491 = 0;
    unint64_t v490 = 0;
    goto LABEL_693;
  }
  v429 = v421;
  v704 = 0;
  v430 = 0;
  unint64_t v687 = 0;
  uint64_t v431 = 0;
  uint64_t v432 = 0;
  *((void *)&v707 + 1) = 0;
  DWORD1(v707) = 0;
  unint64_t v433 = 0;
  int v434 = 0;
  int v706 = 0;
  uint64_t v693 = v417 >> 4;
  unint64_t v694 = 0;
  double v435 = ceil(v425);
  double v436 = floor(v425);
  if (v425 >= 0.0) {
    double v435 = v436;
  }
  uint64_t v437 = (uint64_t)v435;
  double v438 = ceil(v420);
  double v439 = floor(v420);
  if (v420 >= 0.0) {
    double v438 = v439;
  }
  uint64_t v440 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v441 = 0x8000000000000000;
  int v705 = 1;
  uint64_t v697 = -1;
  uint64_t v698 = 0;
  uint64_t v442 = (uint64_t)v438;
  uint64_t v695 = -1;
  uint64_t v696 = -1;
  uint64_t v443 = -1;
  uint64_t v444 = 0x7FFFFFFFFFFFFFFFLL;
  int64_t v445 = 0x8000000000000000;
  do
  {
    uint64_t v699 = v443;
    uint64_t v700 = v444;
    uint64_t v702 = v440;
    uint64_t v712 = v442;
    uint64_t v714 = v437;
    int v710 = v434;
    unint64_t v446 = v433;
    uint64_t v708 = v431;
    uint64_t v709 = v432;
    v447 = v427;
    double v448 = (double)*(uint64_t *)&v749[24] + (v429[3] - *(double *)&v749[8]) * v750;
    if (v448 >= 0.0) {
      double v449 = 0.5;
    }
    else {
      double v449 = -0.5;
    }
    double v450 = v448 + v449;
    if (v448 + v449 <= -9.22337204e18) {
      uint64_t v451 = 1;
    }
    else {
      uint64_t v451 = 2 * (v448 + v449 >= 9.22337204e18);
    }
    sub_18E1CBEE0(v451);
    double v452 = ceil(v450);
    double v453 = floor(v450);
    if (v450 >= 0.0) {
      double v454 = v453;
    }
    else {
      double v454 = v452;
    }
    double v455 = (double)*(uint64_t *)&v749[16] + (*v447 - *(double *)v749) * v750;
    if (v455 >= 0.0) {
      double v456 = 0.5;
    }
    else {
      double v456 = -0.5;
    }
    double v457 = v455 + v456;
    if (v455 + v456 <= -9.22337204e18) {
      uint64_t v458 = 1;
    }
    else {
      uint64_t v458 = 2 * (v455 + v456 >= 9.22337204e18);
    }
    sub_18E1CBEE0(v458);
    uint64_t v442 = (uint64_t)v454;
    double v459 = ceil(v457);
    double v460 = floor(v457);
    if (v457 >= 0.0) {
      double v459 = v460;
    }
    uint64_t v437 = (uint64_t)v459;
    if (v714 <= (uint64_t)v459) {
      int v461 = 0;
    }
    else {
      int v461 = -1;
    }
    if (v714 < (uint64_t)v459) {
      unsigned int v462 = 1;
    }
    else {
      unsigned int v462 = v461;
    }
    if (v712 <= v442) {
      unsigned int v463 = 0;
    }
    else {
      unsigned int v463 = -1;
    }
    if (v712 < v442) {
      uint64_t v464 = 1;
    }
    else {
      uint64_t v464 = v463;
    }
    v429 = v447;
    uint64_t v465 = v708;
    int v434 = v710;
    unint64_t v466 = v446;
    if (v462)
    {
      LODWORD(v707) = 0;
      uint64_t v467 = v709;
    }
    else
    {
      BOOL v468 = v714 == v437 && v712 == v442;
      uint64_t v467 = v709;
      if (v468)
      {
        LODWORD(v707) = 1;
        uint64_t v464 = 4294967197;
        unsigned int v462 = -99;
      }
      else
      {
        unsigned int v462 = 0;
        LODWORD(v707) = 0;
      }
    }
    if (v446)
    {
      if (v462 == DWORD1(v707) && v464 == DWORD2(v707) && v446 < 0xB)
      {
        uint64_t v477 = v700;
        uint64_t v476 = v702;
        unsigned int v462 = DWORD1(v707);
        uint64_t v464 = *((void *)&v707 + 1);
        int v478 = v707;
        goto LABEL_609;
      }
      if (!(_BYTE)v710) {
        unint64_t v687 = 0xEEEEEEEEEEEEEEEFLL * ((v430 - v704) >> 3);
      }
      if ((unint64_t)v430 >= v694)
      {
        unsigned int v689 = v462;
        v690 = v429;
        uint64_t v691 = v464;
        unint64_t v473 = 0xEEEEEEEEEEEEEEEFLL * ((v430 - v704) >> 3) + 1;
        if (v473 > 0x222222222222222) {
          sub_18DEE1FC8();
        }
        if (0xDDDDDDDDDDDDDDDELL * ((uint64_t)(v694 - (void)v704) >> 3) > v473) {
          unint64_t v473 = 0xDDDDDDDDDDDDDDDELL * ((uint64_t)(v694 - (void)v704) >> 3);
        }
        if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v694 - (void)v704) >> 3) >= 0x111111111111111) {
          unint64_t v474 = 0x222222222222222;
        }
        else {
          unint64_t v474 = v473;
        }
        if (v474) {
          unint64_t v474 = (unint64_t)sub_18E1CC050(v474);
        }
        else {
          uint64_t v475 = 0;
        }
        v428 = v688;
        unint64_t v479 = v474 + 8 * ((v430 - v704) >> 3);
        *(void *)unint64_t v479 = v707 >> 32;
        *(void *)(v479 + 8) = v697;
        *(float64x2_t *)(v479 + 16) = __p[0];
        *(void *)(v479 + 32) = v702;
        *(void *)(v479 + 40) = v700;
        *(void *)(v479 + 48) = v445;
        *(void *)(v479 + 56) = v441;
        *(void *)(v479 + 64) = v695;
        *(void *)(v479 + 72) = v699;
        *(void *)(v479 + 80) = v446;
        *(void *)(v479 + 88) = v698;
        *(unsigned char *)(v479 + 96) = v710;
        *(void *)(v479 + 104) = v696;
        *(unsigned char *)(v479 + 112) = v706;
        *(unsigned char *)(v479 + 113) = 0;
        if (v430 == v704)
        {
          v488 = (char *)(v474 + 8 * ((v430 - v704) >> 3));
          v481 = v704;
          uint64_t v467 = v709;
          int v472 = v705;
        }
        else
        {
          unint64_t v480 = v474 + 8 * ((v430 - v704) >> 3);
          v481 = v704;
          uint64_t v467 = v709;
          int v472 = v705;
          do
          {
            long long v482 = *(_OWORD *)(v430 - 120);
            long long v483 = *(_OWORD *)(v430 - 104);
            long long v484 = *(_OWORD *)(v430 - 88);
            *(_OWORD *)(v480 - 72) = *(_OWORD *)(v430 - 72);
            *(_OWORD *)(v480 - 88) = v484;
            *(_OWORD *)(v480 - 104) = v483;
            *(_OWORD *)(v480 - 120) = v482;
            long long v485 = *(_OWORD *)(v430 - 56);
            long long v486 = *(_OWORD *)(v430 - 40);
            long long v487 = *(_OWORD *)(v430 - 24);
            v488 = (char *)(v480 - 120);
            *(_WORD *)(v480 - 8) = *((_WORD *)v430 - 4);
            *(_OWORD *)(v480 - 24) = v487;
            *(_OWORD *)(v480 - 40) = v486;
            *(_OWORD *)(v480 - 56) = v485;
            v430 -= 120;
            v480 -= 120;
          }
          while (v430 != v704);
        }
        unint64_t v694 = v474 + 120 * v475;
        v430 = (char *)(v479 + 120);
        if (v481) {
          operator delete(v481);
        }
        int v471 = 0;
        v704 = v488;
        v429 = v690;
        uint64_t v464 = v691;
        uint64_t v465 = v708;
        unsigned int v462 = v689;
        goto LABEL_606;
      }
      *(void *)v430 = v707 >> 32;
      *((void *)v430 + 1) = v697;
      *((float64x2_t *)v430 + 1) = __p[0];
      *((void *)v430 + 4) = v702;
      *((void *)v430 + 5) = v700;
      *((void *)v430 + 6) = v445;
      *((void *)v430 + 7) = v441;
      *((void *)v430 + 8) = v695;
      *((void *)v430 + 9) = v699;
      *((void *)v430 + 10) = v446;
      *((void *)v430 + 11) = v698;
      v430[96] = v710;
      *((void *)v430 + 13) = v696;
      v430[112] = v706;
      v430[113] = 0;
      v430 += 120;
      int v471 = 0;
    }
    else
    {
      int v471 = v706;
    }
    int v472 = v705;
LABEL_606:
    uint64_t v696 = v465;
    uint64_t v697 = 0;
    unint64_t v466 = 0;
    int v478 = v707;
    __p[0] = (float64x2_t)v735;
    if (!(v707 & 1 | ((v472 & 1) == 0))) {
      int v471 = 1;
    }
    int v706 = v471;
    int v705 = v472 & v707;
    uint64_t v477 = v712;
    uint64_t v476 = v714;
    int64_t v445 = v714;
    uint64_t v441 = v712;
    int v434 = v707;
    uint64_t v698 = v693;
    uint64_t v695 = v467;
    *((void *)&v707 + 1) = v464;
    DWORD1(v707) = v462;
LABEL_609:
    if (v476 >= v437) {
      uint64_t v440 = v437;
    }
    else {
      uint64_t v440 = v476;
    }
    if (v445 <= v437) {
      int64_t v445 = v437;
    }
    if (v477 >= v442) {
      uint64_t v444 = (uint64_t)v454;
    }
    else {
      uint64_t v444 = v477;
    }
    if (v441 <= v442) {
      uint64_t v441 = (uint64_t)v454;
    }
    uint64_t v432 = v467 + 1;
    unint64_t v433 = v466 + 1;
    uint64_t v431 = v465 + (v478 ^ 1u);
    v427 = v429 + 2;
    uint64_t v443 = v432;
  }
  while (v429 + 2 != v428);
  unint64_t v489 = 0xEEEEEEEEEEEEEEEFLL * ((v430 - v704) >> 3);
  if ((_BYTE)v434) {
    unint64_t v490 = v687;
  }
  else {
    unint64_t v490 = 0xEEEEEEEEEEEEEEEFLL * ((v430 - v704) >> 3);
  }
  if ((unint64_t)v430 >= v694)
  {
    uint64_t v701 = v444;
    uint64_t v703 = v440;
    uint64_t v692 = v464;
    unint64_t v715 = v433;
    char v711 = v434;
    unint64_t v518 = v489 + 1;
    if (v489 + 1 > 0x222222222222222) {
      sub_18DEE1FC8();
    }
    unsigned int v519 = v462;
    if (0xDDDDDDDDDDDDDDDELL * ((uint64_t)(v694 - (void)v704) >> 3) > v518) {
      unint64_t v518 = 0xDDDDDDDDDDDDDDDELL * ((uint64_t)(v694 - (void)v704) >> 3);
    }
    if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v694 - (void)v704) >> 3) >= 0x111111111111111) {
      unint64_t v520 = 0x222222222222222;
    }
    else {
      unint64_t v520 = v518;
    }
    if (v520) {
      unint64_t v520 = (unint64_t)sub_18E1CC050(v520);
    }
    unint64_t v521 = v520 + 8 * ((v430 - v704) >> 3);
    *(void *)unint64_t v521 = v519 | (unint64_t)(v692 << 32);
    *(void *)(v521 + 8) = v697;
    *(float64x2_t *)(v521 + 16) = __p[0];
    *(void *)(v521 + 32) = v703;
    *(void *)(v521 + 40) = v701;
    *(void *)(v521 + 48) = v445;
    *(void *)(v521 + 56) = v441;
    *(void *)(v521 + 64) = v695;
    *(void *)(v521 + 72) = v432;
    *(void *)(v521 + 80) = v715;
    *(void *)(v521 + 88) = v698;
    *(unsigned char *)(v521 + 96) = v711;
    *(void *)(v521 + 104) = v696;
    *(unsigned char *)(v521 + 112) = v706;
    *(unsigned char *)(v521 + 113) = 0;
    v491 = (uint64_t *)(v521 + 120);
    if (v430 == v704)
    {
      v492 = (char *)(v520 + 8 * ((v430 - v704) >> 3));
      v522 = v704;
    }
    else
    {
      v522 = v704;
      do
      {
        long long v523 = *(_OWORD *)(v430 - 120);
        long long v524 = *(_OWORD *)(v430 - 104);
        long long v525 = *(_OWORD *)(v430 - 88);
        *(_OWORD *)(v521 - 72) = *(_OWORD *)(v430 - 72);
        *(_OWORD *)(v521 - 88) = v525;
        *(_OWORD *)(v521 - 104) = v524;
        *(_OWORD *)(v521 - 120) = v523;
        long long v526 = *(_OWORD *)(v430 - 56);
        long long v527 = *(_OWORD *)(v430 - 40);
        long long v528 = *(_OWORD *)(v430 - 24);
        v492 = (char *)(v521 - 120);
        *(_WORD *)(v521 - 8) = *((_WORD *)v430 - 4);
        *(_OWORD *)(v521 - 24) = v528;
        *(_OWORD *)(v521 - 40) = v527;
        *(_OWORD *)(v521 - 56) = v526;
        v430 -= 120;
        v521 -= 120;
      }
      while (v430 != v704);
    }
    if (v522) {
      operator delete(v522);
    }
  }
  else
  {
    *(void *)v430 = v462 | (unint64_t)(v464 << 32);
    *((void *)v430 + 1) = v697;
    *((float64x2_t *)v430 + 1) = __p[0];
    *((void *)v430 + 4) = v440;
    *((void *)v430 + 5) = v444;
    *((void *)v430 + 6) = v445;
    *((void *)v430 + 7) = v441;
    *((void *)v430 + 8) = v695;
    *((void *)v430 + 9) = v432;
    *((void *)v430 + 10) = v433;
    *((void *)v430 + 11) = v698;
    v430[96] = v434;
    *((void *)v430 + 13) = v696;
    v430[112] = v706;
    v430[113] = 0;
    v491 = (uint64_t *)(v430 + 120);
    v492 = v704;
  }
LABEL_693:
  if (v490 < 0xEEEEEEEEEEEEEEEFLL * (((char *)v491 - v492) >> 3) && !v492[120 * v490 + 96]) {
    v492[120 * v490 + 113] = 1;
  }
LABEL_626:
  *(void *)&__p[0].f64[0] = v720;
  *(void *)&__p[0].f64[1] = &v724;
  *(void *)&__p[1].f64[0] = v749;
  *(void *)&__p[1].f64[1] = &v732;
  *(void *)&__p[2].f64[0] = &v726;
  LODWORD(__p[2].f64[1]) = 0;
  BYTE4(__p[2].f64[1]) = 1;
  if (0xEEEEEEEEEEEEEEEFLL * (((char *)v491 - v492) >> 3) <= 0x10)
  {
    if (v492 != (char *)v491)
    {
      v504 = (uint64_t *)v492;
      while (1)
      {
        v505 = v504;
        v504 += 15;
        if (v504 != v491) {
          break;
        }
LABEL_667:
        if (v504 == v491) {
          goto LABEL_668;
        }
      }
      v506 = v504;
      while (1)
      {
        if (v505[6] >= v506[4] && v505[4] <= v506[6])
        {
          BOOL v507 = v505[7] >= v506[5] && v505[5] <= v506[7];
          BOOL v508 = v507 && *((unsigned char *)v505 + 96) == 0;
          BOOL v509 = v508 && *((unsigned char *)v506 + 96) == 0;
          if (v509
            && !sub_18E1CE310(SLODWORD(__p[2].f64[1]), **(double ***)&__p[0].f64[0], *(double **)(*(void *)&__p[0].f64[0] + 8), (int *)v505, SLODWORD(__p[2].f64[1]), **(double ***)&__p[0].f64[0], *(double **)(*(void *)&__p[0].f64[0] + 8), (int *)v506, SBYTE4(__p[2].f64[1]), *(uint64_t *)&__p[0].f64[1], *(uint64_t **)&__p[1].f64[0], *(uint64_t **)&__p[1].f64[1], *(BOOL **)&__p[2].f64[0]))
          {
            break;
          }
        }
        v506 += 15;
        if (v506 == v491) {
          goto LABEL_667;
        }
      }
    }
  }
  else
  {
    memset(v737, 0, 24);
    int64x2_t v735 = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
    int64x2_t v736 = vdupq_n_s64(0x8000000000000000);
    if (v492 != (char *)v491)
    {
      v493 = 0;
      v494 = (uint64_t *)v492;
      do
      {
        sub_18E1CC524(v735.i64, v494 + 4);
        if (v493 >= v737[2])
        {
          v496 = (char *)v737[0];
          uint64_t v497 = (v493 - (char *)v737[0]) >> 3;
          unint64_t v498 = v497 + 1;
          if ((unint64_t)(v497 + 1) >> 61) {
            sub_18DEE1FC8();
          }
          int64_t v499 = (char *)v737[2] - (char *)v737[0];
          if (((char *)v737[2] - (char *)v737[0]) >> 2 > v498) {
            unint64_t v498 = v499 >> 2;
          }
          if ((unint64_t)v499 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v500 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v500 = v498;
          }
          if (v500) {
            unint64_t v500 = (unint64_t)sub_18DEE2FBC(v500);
          }
          else {
            uint64_t v501 = 0;
          }
          v502 = (uint64_t **)(v500 + 8 * v497);
          *v502 = v494;
          v495 = v502 + 1;
          if (v493 != v496)
          {
            do
            {
              v503 = (uint64_t *)*((void *)v493 - 1);
              v493 -= 8;
              *--v502 = v503;
            }
            while (v493 != v496);
            v493 = (char *)v737[0];
          }
          v737[0] = v502;
          v737[2] = (void *)(v500 + 8 * v501);
          if (v493) {
            operator delete(v493);
          }
        }
        else
        {
          *(void *)v493 = v494;
          v495 = v493 + 8;
        }
        v737[1] = v495;
        v494 += 15;
        v493 = (char *)v495;
      }
      while (v494 != v491);
    }
    sub_18E1CC098(&v735, (uint64_t *)v737, 0, (uint64_t)__p);
    if (v737[0]) {
      operator delete(v737[0]);
    }
  }
LABEL_668:
  if (v492) {
    operator delete(v492);
  }
  int v510 = v726;
  if ((_BYTE)v726 && v732 == v733)
  {
    v669 = "! boost::empty(turns)";
    int v670 = 94;
    v671 = "has_valid_self_turns.hpp";
    v672 = "apply";
    goto LABEL_828;
  }
  if (v732)
  {
    v733 = v732;
    operator delete(v732);
  }
  if (v510 || !sub_18E1CBB54(*(double **)v720, *((void *)v720 + 1))) {
    goto LABEL_676;
  }
LABEL_104:
  std::mutex::lock((std::mutex *)((char *)this + 544));
  int v150 = *((unsigned __int8 *)this + 2056);
  if (*((unsigned char *)this + 2056))
  {
    int v151 = *((unsigned __int8 *)this + 2440);
    if (!*((unsigned char *)this + 2440) || *((unsigned char *)this + 2048))
    {
LABEL_107:
      if (v151 == v150)
      {
        memcpy((char *)this + 2072, (char *)this + 1688, 0x16BuLL);
      }
      else if (v151)
      {
        *((unsigned char *)this + 2440) = 0;
      }
      else
      {
        *((void *)this + 258) = &unk_1EDD1A0C0;
        memcpy((char *)this + 2072, (char *)this + 1688, 0x16BuLL);
        *((unsigned char *)this + 2440) = 1;
      }
      goto LABEL_158;
    }
    uint64_t v193 = CNTimeSpan::operator-((uint64_t)this + 1696, (void *)this + 260, v148, v149);
    *(void *)&__p[0].f64[0] = v193;
    __p[0].f64[1] = v194;
    if (v193 < 0 || (*(double *)v195.i64 = v194, v194 < 0.0))
    {
      uint64_t v193 = CNTimeSpan::operator-(__p[0].f64, v195, v196);
      v195.i64[0] = v197;
    }
    if (v193 == 2)
    {
LABEL_155:
      if (*(double *)v195.i64 > 0.0) {
        goto LABEL_107;
      }
    }
    else
    {
      if (!v193)
      {
        if ((v195.i64[0] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL) {
          goto LABEL_158;
        }
        goto LABEL_155;
      }
      if (v193 > 2) {
        goto LABEL_107;
      }
    }
LABEL_158:
    *((unsigned char *)this + 2056) = 0;
  }
  if (v717)
  {
    uint64_t v199 = *(double **)v720;
    uint64_t v198 = (double *)*((void *)v720 + 1);
    if ((unint64_t)v198 - *(void *)v720 >= 0x40)
    {
      LODWORD(__p[0].f64[0]) = 0;
      BYTE4(__p[0].f64[0]) = 0;
      uint64_t v200 = v198 - 4;
      do
      {
        if (v200 + 2 == v199) {
          break;
        }
        BOOL v201 = sub_18E12F8BC((double *)v728.i64, v200 + 2, v200, (uint64_t)__p);
        v200 -= 2;
      }
      while (v201);
      double v202 = 0.0;
      if (BYTE4(__p[0].f64[0])) {
        BOOL v203 = 1;
      }
      else {
        BOOL v203 = LODWORD(__p[0].f64[0]) == 0;
      }
      if (!v203) {
        goto LABEL_185;
      }
      uint64_t v199 = *(double **)v720;
      uint64_t v198 = (double *)*((void *)v720 + 1);
    }
    if (v198 != v199)
    {
LABEL_183:
      v735.i64[0] = 0;
      *(void *)v749 = 0;
      sub_18E1D38D8((double *)v728.i64, v199, v198, (double **)__p, (double **)v749, (double *)v735.i64);
      double v202 = *(double *)v735.i64;
      goto LABEL_185;
    }
LABEL_184:
    double v202 = 0.0;
    goto LABEL_185;
  }
  uint64_t v204 = *((void *)v720 + 6);
  uint64_t v199 = *(double **)(v204 - 72);
  uint64_t v198 = *(double **)(v204 - 64);
  if ((unint64_t)((char *)v198 - (char *)v199) < 0x40)
  {
LABEL_182:
    if (v198 != v199) {
      goto LABEL_183;
    }
    goto LABEL_184;
  }
  LODWORD(__p[0].f64[0]) = 0;
  BYTE4(__p[0].f64[0]) = 0;
  unint64_t v205 = v198 - 4;
  do
  {
    if (v205 + 2 == v199) {
      break;
    }
    BOOL v206 = sub_18E12F8BC((double *)v728.i64, v205 + 2, v205, (uint64_t)__p);
    v205 -= 2;
  }
  while (v206);
  double v202 = 0.0;
  if (BYTE4(__p[0].f64[0])) {
    BOOL v207 = 1;
  }
  else {
    BOOL v207 = LODWORD(__p[0].f64[0]) == 0;
  }
  if (v207)
  {
    uint64_t v199 = *(double **)(v204 - 72);
    uint64_t v198 = *(double **)(v204 - 64);
    goto LABEL_182;
  }
LABEL_185:
  long long v208 = (float64_t *)((char *)a2 + 136);
  if (*((unsigned char *)a2 + 105)) {
    double v209 = *((double *)a2 + 17) * *((double *)a2 + 17);
  }
  else {
    double v209 = 0.0;
  }
  LODWORD(v731[3]) = 0;
  uint64_t v210 = *((void *)this + 67) + 72;
  LODWORD(__p[0].f64[0]) = 4;
  double v211 = *((double *)sub_18E1CB940(v210, 4, __p) + 3);
  uint64_t v212 = *((void *)this + 67) + 72;
  LODWORD(__p[0].f64[0]) = 2;
  double v213 = *((double *)sub_18E1CB940(v212, 2, __p) + 3);
  uint64_t v214 = *((void *)this + 67) + 72;
  LODWORD(__p[0].f64[0]) = 3;
  unint64_t v215 = (double *)sub_18E1CB940(v214, 3, __p);
  double v216 = v209 + v211;
  if (v202 < v216) {
    int v217 = v721;
  }
  else {
    int v217 = 0;
  }
  if (v217 != 1)
  {
    if (v202 >= v209 + v215[3]) {
      char v220 = 1;
    }
    else {
      char v220 = v721;
    }
    if (v220)
    {
      if (v202 < v209 + v213)
      {
LABEL_206:
        LODWORD(v731[3]) = 2;
        goto LABEL_222;
      }
      LODWORD(v731[3]) = 1;
      if (v721 && *((unsigned char *)this + 2440) && *((_DWORD *)this + 530) != 1) {
        trackrun::TrackRunEngineActiveObject::ResetTrackStateWhenLeaveTrackOrSessionEnds(this);
      }
    }
    else
    {
      LODWORD(v731[3]) = 3;
      if (*((unsigned char *)this + 1360)
        && *((unsigned char *)this + 1304) == 1
        && *((unsigned char *)this + 1136)
        && sub_18DEE8C5C((double *)this + 143, (double *)a2 + 2)
        && (!*((unsigned char *)this + 1184) || sub_18DEE4D28((double *)this + 149, (double *)a2 + 2)))
      {
        __p[0] = *((float64x2_t *)this + 80);
        trackrun::TrackRunEngineActiveObject::ConvertPointLatLonToEastNorth((uint64_t)this, __p, v221, v222, v223, v224, v225, v226);
        if (v227)
        {
          uint64_t v228 = (double **)v720;
          if ((v717 & 1) == 0) {
            uint64_t v228 = (double **)(*((void *)v720 + 6) - 72);
          }
          if (sub_18E1C9244(__p[0].f64, v228) <= *(double *)(*((void *)this + 67) + 248)
                                                * *((double *)this + 162)
                                                * (*(double *)(*((void *)this + 67) + 248)
                                                 * *((double *)this + 162)))
            goto LABEL_206;
        }
      }
    }
LABEL_222:
    if (!v717 || (LODWORD(v731[3]) - 3) > 1) {
      goto LABEL_225;
    }
    goto LABEL_224;
  }
  LODWORD(v731[3]) = 3;
  if (v717)
  {
LABEL_224:
    BYTE9(v731[22]) = 1;
    goto LABEL_225;
  }
  if (*((void *)v720 + 12))
  {
    trackrun::TrackRunEngineActiveObject::FindClosestPointOnRing((double *)v728.i64, *((double ***)v720 + 5), 1, 0);
    if (v218 < 0.0 || v218 * v218 < v216)
    {
      if (!*((unsigned char *)this + 1672)
        || (unsigned int v219 = *((unsigned __int8 *)this + 1497), v219 > 5)
        || ((1 << v219) & 0x34) == 0
        || *((unsigned char *)this + 1072)
        || !*((unsigned char *)this + 2440)
        || *((_DWORD *)this + 530) == 4
        || v202 <= *(double *)(*((void *)v720 + 6) - 8) * *(double *)(*((void *)v720 + 6) - 8))
      {
        LODWORD(v731[3]) = 4;
      }
    }
  }
LABEL_225:
  memset(&v731[4], 0, 80);
  LOBYTE(v731[9]) = 1;
  *((void *)&v731[3] + 1) = sqrt(v202);
  *((void *)&v731[8] + 1) = *((void *)v720 + 8);
  LOBYTE(v731[4]) = *((void *)v720 + 12);
  long long v229 = *(_OWORD *)((char *)a2 + 24);
  v731[0] = *(_OWORD *)((char *)a2 + 8);
  v731[1] = v229;
  v731[2] = *(_OWORD *)((char *)a2 + 40);
  BYTE10(v731[22]) = 1;
  if (*((unsigned char *)this + 2056))
  {
    memcpy((char *)this + 1688, v731, 0x16BuLL);
  }
  else
  {
    *((void *)this + 210) = &unk_1EDD1A0C0;
    memcpy((char *)this + 1688, v731, 0x16BuLL);
    *((unsigned char *)this + 2056) = 1;
  }
  trackrun::TrackRunEngineActiveObject::TrackCoordinateTransform::ConvertEastNorthToLatLon((uint64_t)this + 608, (float64x2_t *)((char *)v720 + 24), v230, v231, v232, v233, v234, (uint64_t)&v732);
  v735.i16[0] = 13;
  LOBYTE(v737[0]) = 3;
  unint64_t v235 = *((char *)a2 + 104);
  if (v235 > 9) {
    uint64_t v236 = "Other";
  }
  else {
    uint64_t v236 = off_1E55B9F08[v235];
  }
  char v237 = *((unsigned char *)this + 2640);
  sub_18DEDE7B0(__p, v236);
  (*(void (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
  trackrun::TrackRunEngineActiveObject::ConvertIosTimeToGregorianString((uint64_t)this, *((void *)a2 + 5), *((void *)a2 + 6), v749);
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v735, (unsigned __int8 *)v737, "TrackRun-Raw-%u-%s,viewType,SingleArrowCoordinate,iOSTime,%.1lf,mcTime,%.1lf,gregTime,%s,latitude,%.7lf,longitude,%.7lf,course,%.2lf,courseUnc,%.2lf,speed,%.2lf,speedUnc,%.2lf,hunc,%.1lf,type,%d,track_prox,%d,dist_to_outer,%.1lf,track_lat,%.7lf,track_lon,%.7lf,num_lanes,%d,odo_valid,%d,odo,%.1lf,odo_dd,%.1lf,odo_dd_unc,%.1lf", v238, v239, v240, v241, v242, v237);
  if ((v749[23] & 0x80000000) != 0) {
    operator delete(*(void **)v749);
  }
  if (SHIBYTE(__p[1].f64[0]) < 0) {
    operator delete(*(void **)&__p[0].f64[0]);
  }
  double v244 = (long long *)((char *)a2 + 8);
  if (*((unsigned char *)this + 1072) && *((unsigned char *)this + 4602) || !*(unsigned char *)(*((void *)this + 67) + 68))
  {
LABEL_261:
    if (*((unsigned char *)this + 1672))
    {
      unsigned int v261 = *((unsigned __int8 *)this + 1497);
      if (v261 <= 5 && ((1 << v261) & 0x34) != 0)
      {
        char v262 = v717;
        if (!*((unsigned char *)this + 672)) {
          char v262 = 1;
        }
        if ((v262 & 1) == 0 && LODWORD(v731[3]) == 4)
        {
          *((void *)this + 230) = 0;
          *(int64x2_t *)((char *)this + 1848) = vdupq_n_s64(0x7FF8000000000000uLL);
          *((void *)this + 233) = 0x7FF8000000000000;
          *((unsigned char *)this + 1872) = 1;
          double v263 = *((double *)a2 + 24);
          if (!*((unsigned char *)a2 + 184)) {
            double v263 = 0.0;
          }
          *((double *)this + 231) = v263;
          *((unsigned char *)this + 1840) = 0;
          double v264 = *((double *)a2 + 25);
          double v265 = *((double *)a2 + 21);
          if (v264 > 0.0 && v265 > 0.0 && ((v721 ^ 1) & 1) == 0)
          {
            trackrun::TrackRunEngineActiveObject::ComputeAcrossTrackDistanceInformation((uint64_t)this, (uint64_t)a2, (uint64_t)v720, (double *)v728.i64, (long long *)__p);
            sub_18E1C9604((void *)this + 382, (uint64_t)__p);
            trackrun::TrackRunEngineActiveObject::PruneAcrossTrackDistanceDeque(this);
            double v264 = *((double *)a2 + 25);
            double v265 = *((double *)a2 + 21);
          }
          if (*((void *)this + 387) && v264 > 0.0 && v265 > 0.0)
          {
            trackrun::TrackRunEngineActiveObject::ComputeAcrossTrackDistanceEvidence(this, a2, v720, (uint64_t)v749);
            if (!*((unsigned char *)this + 4602))
            {
              __p[0].f64[0] = 0.0;
              __p[0].f64[1] = NAN;
              LOBYTE(__p[1].f64[0]) = 0;
              LOBYTE(__p[1].f64[1]) = 0;
              BYTE8(v742) = 0;
              *(void *)&__p[0].f64[0] = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
              __p[0].f64[1] = v313;
              LOBYTE(__p[1].f64[0]) = *((void *)v720 + 12);
              if (*((unsigned char *)this + 1072))
              {
                if (BYTE8(v742) == *((unsigned __int8 *)this + 1072))
                {
                  LOBYTE(v742) = *((unsigned char *)this + 1064);
                  float64x2_t v314 = *(float64x2_t *)((char *)this + 1032);
                  __p[2] = *(float64x2_t *)((char *)this + 1016);
                  __p[3] = v314;
                  long long v741 = *(_OWORD *)((char *)this + 1048);
                }
                else if (BYTE8(v742))
                {
                  BYTE8(v742) = 0;
                }
                else
                {
                  *(void *)&__p[1].f64[1] = &unk_1EDD19FC8;
                  LOBYTE(v742) = *((unsigned char *)this + 1064);
                  float64x2_t v395 = *(float64x2_t *)((char *)this + 1032);
                  __p[2] = *(float64x2_t *)((char *)this + 1016);
                  __p[3] = v395;
                  long long v741 = *(_OWORD *)((char *)this + 1048);
                  BYTE8(v742) = 1;
                }
              }
              if (trackrun::TrackRunLaneEstimator::Initialize((uint64_t)this + 3104))
              {
                v735.i16[0] = 13;
                LOBYTE(v737[0]) = 4;
                cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v735, (unsigned __int8 *)v737, "#tre_ao,TrackRunLaneEstimator is not initialized. Cannot continue.", v267, v268, v269, v270, v271, v679);
                goto LABEL_807;
              }
            }
            trackrun::TrackRunLaneEstimator::HandleEvidence((trackrun::TrackRunEngineActiveObject *)((char *)this + 3104), (double *)v749, v266, v267, v268, v269, v270, v271);
          }
          if (*((unsigned char *)this + 4602) && *((unsigned __int16 *)this + 1552) >= 0x100u)
          {
            uint64_t v272 = *((_WORD *)this + 1552);
          }
          else if (!*((unsigned char *)this + 1072) || (uint64_t v272 = *((unsigned __int8 *)this + 1064), !*((unsigned char *)this + 1064)))
          {
            uint64_t v273 = *((void *)this + 387);
            if (v273)
            {
              unint64_t v274 = *(void *)(*((void *)this + 383) + 8 * ((v273 + *((void *)this + 386) - 1) / 0x33uLL))
                   + 80 * ((v273 + *((void *)this + 386) - 1) % 0x33uLL);
              __p[1] = *(float64x2_t *)(v274 + 16);
              __p[2] = *(float64x2_t *)(v274 + 32);
              __p[3] = *(float64x2_t *)(v274 + 48);
              long long v741 = *(_OWORD *)(v274 + 64);
              __p[0] = *(float64x2_t *)v274;
              char v275 = v720;
            }
            else
            {
              char v275 = v720;
              trackrun::TrackRunEngineActiveObject::ComputeAcrossTrackDistanceInformation((uint64_t)this, (uint64_t)a2, (uint64_t)v720, (double *)v728.i64, (long long *)__p);
            }
            double v315 = 1.0;
            if (*((unsigned char *)v275 + 88)
              && (double v316 = *((double *)v275 + 10), v316 > 0.0)
              && (double v315 = round(-round(__p[1].f64[1] / v316)), v315 < 1.0))
            {
              uint64_t v293 = 0;
            }
            else
            {
              unint64_t v317 = *((void *)v720 + 12);
              if (v315 <= (double)v317) {
                uint64_t v293 = (unint64_t)(v315 + -1.0);
              }
              else {
                uint64_t v293 = v317 - 1;
              }
            }
LABEL_368:
            if (*((unsigned char *)this + 4704))
            {
              uint64_t v318 = *((void *)this + 67);
              if (*(unsigned char *)(v318 + 217))
              {
                uint64_t v319 = *((void *)this + 587);
                if (*((unsigned char *)this + 1072)) {
                  goto LABEL_376;
                }
              }
              else
              {
                uint64_t v319 = *((void *)this + 587);
              }
              uint64_t v320 = v293 + 1;
              if (v319 == v293 + 1 || *(void *)(v318 + 184) > (unint64_t)*((unsigned __int16 *)this + 2344))
              {
LABEL_376:
                unint64_t v321 = v319 - 1;
                long long v322 = v720;
                if (v321 >= *((void *)v720 + 12) - 1) {
                  uint64_t v293 = *((void *)v720 + 12) - 1;
                }
                else {
                  uint64_t v293 = v321;
                }
                __int16 v323 = *((_WORD *)this + 2344);
                goto LABEL_381;
              }
            }
            else
            {
              uint64_t v320 = v293 + 1;
            }
            __int16 v323 = 0;
            *((void *)this + 587) = v320;
            *((unsigned char *)this + 4704) = 1;
            *((_WORD *)this + 2344) = 0;
            long long v322 = v720;
LABEL_381:
            *((_WORD *)this + 2344) = v323 + 1;
            double ClosestPointOnRing = trackrun::TrackRunEngineActiveObject::FindClosestPointOnRing((double *)v728.i64, (double **)(*((void *)v322 + 5) + 72 * v293), 0, 1);
            double v326 = v325;
            double v328 = v327;
            *(double *)v749 = ClosestPointOnRing;
            *(double *)&v749[8] = v325;
            *(double *)&v749[16] = v327;
            *(void *)&v749[24] = v329;
            trackrun::TrackRunEngineActiveObject::TrackCoordinateTransform::ConvertEastNorthToLatLon((uint64_t)this + 608, (float64x2_t *)v749, v330, v331, v332, v333, v334, (uint64_t)&v726);
            if (!v727)
            {
              strcpy((char *)__p, "\r");
              v735.i8[0] = 4;
              uint64_t v352 = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
              double v681 = v353 + (double)v352;
              cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v735, "#tre_ao,Warning,MatchedPosition,time,%.3lf,current_position,latlng,%.7lf,%.7lf,lane_matched_point has no value", v354, v355, v356, v357, v358, SLOBYTE(v681));
LABEL_795:
              if (*((unsigned __int16 *)this + 1552) >= 0x100u)
              {
                *((_WORD *)this + 908) = *((_WORD *)this + 1552) | 0x100;
              }
              else if (*((unsigned char *)this + 1072))
              {
                *((_WORD *)this + 908) = *((unsigned __int8 *)this + 1064) | 0x100;
              }
              else
              {
                if (!*((unsigned char *)this + 1817)) {
                  *((unsigned char *)this + 1817) = 1;
                }
                *((unsigned char *)this + 1816) = 1;
              }
              if (*((unsigned char *)this + 1776))
              {
                v735.i16[0] = 13;
                LOBYTE(v737[0]) = 3;
                char v640 = *((unsigned char *)this + 2640);
                (*(void (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
                trackrun::TrackRunEngineActiveObject::ConvertIosTimeToGregorianString((uint64_t)this, *((void *)a2 + 5), *((void *)a2 + 6), __p);
                cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v735, (unsigned __int8 *)v737, "TrackRun-Mat-%u,viewType,SingleArrowCoordinate,iOSTime,%.1lf,mcTime,%.1lf,gregTime,%s,latitude,%.7lf,longitude,%.7lf,course,%.2lf,courseUnc,%.2lf,speed,%.2lf,speedUnc,%.2lf,hunc,%.1lf,altitude,%.1lf,vunc,%.1lf,type,%d,track_prox,%d,dist_to_lane_,%.1lf,matched_lane_num,%d,lane_est,%d,lane_count,%hhu,lane_width,%.2lf,odo_valid,%d,odo,%.1lf,odo_dd,%.1lf,odo_dd_unc,%.1lf,odo_diff,%.1lf,odo_dd_diff,%.1lf,current_lap_distance,%.1lf", v641, v642, v643, v644, v645, v640);
                if (SHIBYTE(__p[1].f64[0]) < 0) {
                  operator delete(*(void **)&__p[0].f64[0]);
                }
              }
              else
              {
                strcpy((char *)__p, "\r");
                v735.i8[0] = 4;
                uint64_t v646 = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
                double v686 = v647 + (double)v646;
                cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v735, "#tre_ao,Warning,MatchedPosition,time,%.3lf,current_position_east_north_m,latlng,%.8lf,%.8lf,track_position_ has no value.", v648, v649, v650, v651, v652, SLOBYTE(v686));
              }
              goto LABEL_807;
            }
            long long v345 = v726;
            int v346 = *((unsigned __int8 *)this + 1776);
            *((_OWORD *)this + 110) = v726;
            if (!v346) {
              *((unsigned char *)this + 1776) = 1;
            }
            v343.i64[0] = *((void *)a2 + 19);
            if (*(double *)v343.i64 >= 0.0)
            {
              double v347 = *((double *)a2 + 20);
              if (v347 >= 0.0)
              {
                double v348 = *((double *)a2 + 21);
                if (v348 > 0.0)
                {
                  v344.f64[0] = *((float64_t *)a2 + 22);
                  if (v344.f64[0] >= 0.0
                    && (v343.i64[0] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                    && (*(void *)&v347 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                    && (*(void *)&v348 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                    && (*(void *)&v344.f64[0] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                  {
                    double v718 = *((double *)a2 + 19);
                    *(double *)v343.i64 = fmod(*(double *)v343.i64 - v328, 180.0);
                    v344.f64[0] = fabs(*(double *)v343.i64);
                    if (v344.f64[0] > 90.0)
                    {
                      double v349 = 1.0;
                      if (*(double *)v343.i64 <= 0.0)
                      {
                        double v349 = 0.0;
                        if (*(double *)v343.i64 < 0.0) {
                          double v349 = -1.0;
                        }
                      }
                      *(double *)v343.i64 = *(double *)v343.i64 + v349 * -180.0;
                      v344.f64[0] = fabs(*(double *)v343.i64);
                    }
                    uint64_t v350 = *((void *)this + 67);
                    BOOL v116 = v344.f64[0] > *(double *)(v350 + 192);
                    v344.f64[0] = v718;
                    if (!v116 && !*(unsigned char *)(v350 + 200))
                    {
                      *(double *)v343.i64 = v718 - *(double *)v343.i64;
                      if (*(double *)v343.i64 < 0.0 || (v344.f64[0] = 360.0, *(double *)v343.i64 >= 360.0))
                      {
                        v344.f64[0] = 1.0;
                        if (*(double *)v343.i64 <= 0.0)
                        {
                          v344.f64[0] = 0.0;
                          if (*(double *)v343.i64 < 0.0) {
                            v344.f64[0] = -1.0;
                          }
                        }
                        *(double *)v343.i64 = *(double *)v343.i64 + v344.f64[0] * -360.0;
                      }
                      *((void *)this + 223) = v343.i64[0];
                      *((unsigned char *)this + 1792) = 1;
                      if (*((unsigned char *)this + 1808))
                      {
                        v343.i64[0] = *((void *)this + 225);
                        v344.f64[0] = *(float64_t *)(v350 + 240);
                        if (*(double *)v343.i64 == v344.f64[0]) {
                          char v351 = 0;
                        }
                        else {
                          char v351 = -127;
                        }
                        if (*(double *)v343.i64 > v344.f64[0]) {
                          char v351 = 1;
                        }
                        if (*(double *)v343.i64 < v344.f64[0]) {
                          char v351 = -1;
                        }
                      }
                      else
                      {
                        char v351 = -1;
                      }
                      if (v351 != 129 && v351 <= 0)
                      {
                        v343.i64[0] = *(void *)(v350 + 232);
                        v344.f64[0] = *v208;
                        if (*(double *)v343.i64 >= *v208) {
                          v343.i64[0] = *(uint64_t *)v208;
                        }
                        *((void *)this + 225) = v343.i64[0];
                        *((unsigned char *)this + 1808) = 1;
                      }
                    }
                  }
                }
              }
            }
            if (!*((unsigned char *)this + 1819)) {
              *((unsigned char *)this + 1819) = 1;
            }
            *((unsigned char *)this + 1818) = v293 + 1;
            if (!*((unsigned char *)this + 2440)) {
              goto LABEL_727;
            }
            uint64_t v335 = CNTimeSpan::operator-((uint64_t)a2 + 16, (void *)this + 260, v343, (int8x16_t)v344);
            *(void *)&__p[0].f64[0] = v335;
            __p[0].f64[1] = v336;
            if (v335 < 0 || (*(double *)v343.i64 = v336, v336 < 0.0))
            {
              uint64_t v335 = CNTimeSpan::operator-(__p[0].f64, v343, (int8x16_t)v344);
              *(double *)v343.i64 = v336;
            }
            if (v335 == 2) {
              goto LABEL_711;
            }
            if (v335)
            {
              if (v335 > 1) {
                goto LABEL_727;
              }
              goto LABEL_714;
            }
            if ((v343.i64[0] & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
            {
LABEL_711:
              if (*(double *)v343.i64 > 0.0) {
                goto LABEL_727;
              }
            }
LABEL_714:
            if (*((_DWORD *)this + 530) == 4
              && *((unsigned char *)this + 2256)
              && *((unsigned char *)this + 2224)
              && *((unsigned char *)this + 2216)
              && *((unsigned char *)this + 2160)
              && *((unsigned char *)this + 2201))
            {
              if (!*((unsigned char *)this + 624)) {
                sub_18DFF28FC();
              }
              double v529 = (*((double *)this + 268) - *((double *)this + 76)) * *((double *)this + 79) - v326;
              double v530 = (*((double *)this + 269) - *((double *)this + 77)) * *((double *)this + 80) - ClosestPointOnRing;
              *(double *)v343.i64 = sqrt(v530 * v530 + 0.0 + v529 * v529);
              v344.f64[0] = 11.0;
              if (*(double *)v343.i64 < 11.0)
              {
                *((void *)this + 232) = v343.i64[0];
                if (!(_BYTE)v293)
                {
                  uint64_t v667 = *((void *)v720 + 5);
                  if (*(unsigned char *)(v667 + 40))
                  {
                    double v668 = *(double *)(v667 + 32);
                    if (v668 >= 392.0 && v668 <= 408.0)
                    {
                      if (!*(unsigned char *)(v667 + 56))
                      {
                        *(double *)(v667 + 48) = 400.0 / v668;
                        *(unsigned char *)(v667 + 56) = 1;
                        uint64_t v667 = *((void *)v720 + 5);
                        if (!*(unsigned char *)(v667 + 56)) {
                          sub_18DFF28FC();
                        }
                        v343.i64[0] = *((void *)this + 232);
                      }
                      *(double *)v343.i64 = *(double *)(v667 + 48) * *(double *)v343.i64;
                      *((void *)this + 232) = v343.i64[0];
                    }
                  }
                }
                v344.f64[0] = *(double *)v343.i64 + *((double *)this + 279);
                *((void *)this + 231) = *(void *)&v344.f64[0];
                *((void *)this + 233) = 0x3FD0000000000000;
                *((_WORD *)this + 920) = 257;
                if (!*((unsigned char *)this + 2992))
                {
                  char v531 = 1;
                  goto LABEL_735;
                }
                if (!*((unsigned char *)this + 1672) || *((unsigned char *)this + 1497) != 4)
                {
                  *((double *)this + 362) = *((double *)this + 361) + *((double *)this + 362);
                  *((void *)this + 361) = 0;
                  *((double *)this + 363) = *(double *)v343.i64 + *((double *)this + 363);
                  v344.f64[0] = *((float64_t *)this + 372);
                  *(double *)v343.i64 = *(double *)v343.i64 + v344.f64[0];
                  *((void *)this + 372) = v343.i64[0];
                  char v531 = *((unsigned char *)a2 + 184);
                  if (v531)
                  {
                    char v531 = 0;
                    double v666 = *((double *)a2 + 25);
                    *((double *)this + 364) = v666 + *((double *)this + 364);
                    v344.f64[0] = *((float64_t *)this + 373);
                    *(double *)v343.i64 = v666 + v344.f64[0];
                    *((void *)this + 373) = v343.i64[0];
                  }
LABEL_735:
                  if (*((unsigned char *)this + 3048))
                  {
                    if ((v531 & 1) == 0)
                    {
                      *(double *)v533.i64 = (double)CNTimeSpan::operator-((uint64_t)a2 + 16, (void *)this + 376, v343, (int8x16_t)v344);
                      *(double *)v535.i64 = v534 + *(double *)v533.i64;
                      *((double *)this + 371) = v534 + *(double *)v533.i64;
                      uint64_t v335 = CNTimeSpan::operator-((uint64_t)a2 + 16, (void *)this + 355, v535, v533);
                      double v536 = v336 + (double)v335 - *((double *)this + 361) - *((double *)this + 362);
                      *((double *)this + 360) = v536;
                      if (v536 < 0.0)
                      {
                        strcpy((char *)__p, "\r");
                        v735.i8[0] = 3;
                        uint64_t v537 = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
                        double v683 = v538 + (double)v537;
                        cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v735, "#tre_ao,%.1lf,Warning:current lap duration is less than 0,limiting to 0,current_lap_duration,%.1lf,current_pause_duration,%.1lf,previous_pauses_duration,%.1lf", v539, v540, v541, v542, v543, SLOBYTE(v683));
                        *((double *)this + 360) = fmax(*((double *)this + 360), 0.0);
                      }
                    }
                  }
                  int v544 = v721;
                  if (LODWORD(v731[3]) != 4) {
                    int v544 = 0;
                  }
                  if (v544 == 1)
                  {
                    if (!*((unsigned char *)this + 2824))
                    {
LABEL_748:
                      long long v746 = 0u;
                      long long v747 = 0u;
                      long long v744 = 0u;
                      long long v745 = 0u;
                      long long v742 = 0u;
                      long long v743 = 0u;
                      long long v741 = 0u;
                      memset(__p, 0, sizeof(__p));
                      char v748 = 1;
                      sub_18E1CB5B8((uint64_t)this + 2648, (uint64_t)__p);
                      __p[0].f64[0] = trackrun::TrackRunEngineActiveObject::FindClosestPointOnRing((double *)v728.i64, *((double ***)v720 + 5), 0, 0);
                      __p[0].f64[1] = v546;
                      __p[1].f64[0] = v547;
                      __p[1].f64[1] = v548;
                      trackrun::TrackRunEngineActiveObject::TrackCoordinateTransform::ConvertEastNorthToLatLon((uint64_t)this + 608, __p, v549, v550, v551, v552, v553, (uint64_t)&v724);
                      v735.i64[0] = trackrun::TrackRunEngineActiveObject::FindClosestPointOnRing((double *)v728.i64, (double **)(*((void *)v720 + 5) + 72 * *((void *)v720 + 12) - 72), 0, 0);
                      *(float64_t *)&v735.i64[1] = v554;
                      v736.i64[0] = v555;
                      v736.i64[1] = v556;
                      trackrun::TrackRunEngineActiveObject::TrackCoordinateTransform::ConvertEastNorthToLatLon((uint64_t)this + 608, (float64x2_t *)&v735, v557, v558, v559, v560, v561, (uint64_t)&v722);
                      if (!v725 || !v723)
                      {
                        LOWORD(v737[0]) = 13;
                        v739[0] = 4;
                        uint64_t v583 = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
                        double v685 = v584 + (double)v583;
                        cnprint::CNPrinter::Print((cnprint::CNPrinter *)v737, v739, "#tre_ao,coordinate conversion issue, could not start line,%.1lf", v585, v586, v587, v588, v589, SLOBYTE(v685));
                        goto LABEL_807;
                      }
                      *(float64x2_t *)((char *)this + 2648) = v724;
                      *(_OWORD *)((char *)this + 2664) = v722;
                      *((unsigned char *)this + 2713) = *v208 <= *(double *)(*((void *)this + 67) + 240);
                      trackrun::TrackRunEngineActiveObject::PopulateAllStartingLineFields(this, v562, v563, v564, v565, v566, v567, v568);
                      if (cnprint::CNPrinter::GetLogLevel(v569) <= 1)
                      {
                        LOWORD(v737[0]) = 13;
                        v739[0] = 1;
                        uint64_t v570 = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
                        double v684 = v571 + (double)v570;
                        cnprint::CNPrinter::Print((cnprint::CNPrinter *)v737, v739, "#tre_ao,successfully set the start line,%.1lf", v572, v573, v574, v575, v576, SLOBYTE(v684));
                      }
                      if (*((unsigned char *)this + 2992))
                      {
                        uint64_t v577 = *((void *)this + 371);
                        uint64_t v578 = *((void *)this + 363);
                        uint64_t v579 = *((void *)this + 373);
                        memset(v739, 0, sizeof(v739));
                        memset(&v738, 0, 23);
                        memset(v737, 0, 30);
                        *((unsigned char *)this + 2832) = 0;
                        long long v580 = *(_OWORD *)v739;
                        *(void *)((char *)this + 2849) = *(void *)&v739[16];
                        *(_OWORD *)((char *)this + 2833) = v580;
                        long long v581 = v738;
                        *((void *)this + 359) = 0;
                        *(_OWORD *)((char *)this + 2857) = v581;
                        *((_OWORD *)this + 183) = 0u;
                        *((_OWORD *)this + 182) = 0u;
                        *((_OWORD *)this + 181) = 0u;
                        *((_OWORD *)this + 180) = 0u;
                        *((int64x2_t *)this + 184) = vdupq_n_s64(0x7FF8000000000000uLL);
                        *((_WORD *)this + 1480) = 0;
                        int v582 = (int)v737[0];
                        *((_WORD *)this + 1483) = WORD2(v737[0]);
                        *(_DWORD *)((char *)this + 2962) = v582;
                        *((unsigned char *)this + 2992) = 1;
                        *((void *)this + 371) = v577;
                        *((void *)this + 372) = v578;
                        *((void *)this + 373) = v579;
                        *((unsigned char *)this + 4602) = 0;
                        *((unsigned char *)this + 4600) = 0;
                        if (*((unsigned char *)this + 3105)) {
                          *((unsigned char *)this + 3105) = 0;
                        }
                        if (*((unsigned char *)this + 4680)) {
                          *((unsigned char *)this + 4680) = 0;
                        }
                        sub_18E1CA020((void *)this + 382);
                      }
                      else
                      {
                        memset(v739, 0, sizeof(v739));
                        memset(&v738, 0, 23);
                        memset(v737, 0, 30);
                        *((unsigned char *)this + 2832) = 0;
                        long long v631 = *(_OWORD *)v739;
                        *(void *)((char *)this + 2849) = *(void *)&v739[16];
                        *(_OWORD *)((char *)this + 2833) = v631;
                        long long v632 = v738;
                        *((void *)this + 359) = 0;
                        *(_OWORD *)((char *)this + 2857) = v632;
                        *((_OWORD *)this + 183) = 0u;
                        *((_OWORD *)this + 182) = 0u;
                        *((_OWORD *)this + 181) = 0u;
                        *((_OWORD *)this + 180) = 0u;
                        *((int64x2_t *)this + 184) = vdupq_n_s64(0x7FF8000000000000uLL);
                        *((_WORD *)this + 1480) = 0;
                        long long v633 = *(_OWORD *)v737;
                        *((_OWORD *)this + 186) = *(_OWORD *)((char *)&v737[1] + 6);
                        *(_OWORD *)((char *)this + 2962) = v633;
                        *((unsigned char *)this + 2992) = 1;
                      }
                      long long v634 = *v244;
                      long long v635 = *(_OWORD *)((char *)a2 + 40);
                      *((_OWORD *)this + 178) = *(_OWORD *)((char *)a2 + 24);
                      *((_OWORD *)this + 179) = v635;
                      *((_OWORD *)this + 177) = v634;
                      *((_OWORD *)this + 184) = v345;
                      *(_OWORD *)((char *)this + 2792) = v726;
                      *((unsigned char *)this + 2808) = 0;
                      *((unsigned char *)this + 2816) = 1;
                      goto LABEL_792;
                    }
                    v545 = (char *)this + 2824;
                    if (*((unsigned char *)this + 2712))
                    {
LABEL_765:
                      if ((!*((unsigned char *)this + 2768) || !*((unsigned char *)this + 2784) || !*((unsigned char *)this + 2752))
                        && ((trackrun::TrackRunEngineActiveObject::PopulateAllStartingLineFields(this, *(uint64_t *)&v336, v337, v338, v339, v340, v341, v342), !*((unsigned char *)this + 2752))|| !*((unsigned char *)this + 2784))|| !*((unsigned char *)this + 2768))
                      {
                        sub_18DFF28FC();
                      }
                      double v595 = *((double *)this + 340);
                      double v596 = *((double *)this + 341);
                      double v597 = *((double *)this + 347);
                      double v598 = *((double *)this + 345);
                      v735.i64[0] = trackrun::TrackRunEngineActiveObject::FindClosestPointOnLineSegment((double *)v749, (double *)this + 335, 0, 0, 0);
                      *(float64_t *)&v735.i64[1] = v599;
                      v736.i64[0] = v600;
                      v736.i64[1] = v601;
                      double v608 = (ClosestPointOnRing - v595) * v597 - (v326 - v596) * v598;
                      if (cnprint::CNPrinter::GetLogLevel(v602) <= 1)
                      {
                        strcpy((char *)__p, "\r");
                        LOBYTE(v737[0]) = 1;
                        cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)v737, "#tre_ao,signed dist to inifinite start line,%.1lf", v603, v604, v605, v606, v607, SLOBYTE(v608));
                      }
                      uint64_t v609 = *((void *)v720 + 5);
                      if (*(unsigned char *)(v609 + 40)) {
                        double v610 = *(double *)(v609 + 32);
                      }
                      else {
                        double v610 = 100.0;
                      }
                      if (!*v545) {
                        goto LABEL_792;
                      }
                      if (!*((unsigned char *)this + 2816)) {
                        goto LABEL_792;
                      }
                      int v616 = v608 > 0.0;
                      if (*((unsigned __int8 *)this + 2808) == v616
                        || !*((unsigned char *)this + 2992)
                        || *((double *)this + 363) <= v610 * 0.4)
                      {
                        goto LABEL_792;
                      }
                      strcpy((char *)__p, "\r");
                      LOBYTE(v737[0]) = 3;
                      uint64_t v617 = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
                      double v619 = v618 + (double)v617;
                      cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)v737, "#tre_ao,infinite starting line has been crossed,time,%.1lf,workout_number,%d,distance_to_start,%.1lf,current_lap_distance,%.1lf,lap_distance_thresh,%.1lf,lat,lon,%.7lf,%.7lf", v620, v621, v622, v623, v624, SLOBYTE(v619));
                      *(_OWORD *)((char *)this + 2792) = v726;
                      *((unsigned char *)this + 2808) = v616;
                      *((unsigned char *)this + 2816) = 1;
                      if (!*((unsigned char *)this + 2752)) {
                        sub_18DFF28FC();
                      }
                      trackrun::TrackRunEngineActiveObject::FindClosestPointOnLineSegment((double *)v749, (double *)this + 340, 1, 0, 0);
                      if (fabs(v626) >= 10.0) {
                        goto LABEL_792;
                      }
                      ++*((_WORD *)this + 1480);
                      *(double *)v625.i64 = fabs(v608);
                      float64x2_t v627 = *(float64x2_t *)((char *)this + 2904);
                      int8x16_t v628 = (int8x16_t)vsubq_f64(v627, (float64x2_t)vdupq_lane_s64(v625.i64[0], 0));
                      *((int8x16_t *)this + 183) = v628;
                      *((void *)this + 363) = v625.i64[0];
                      *((void *)this + 364) = v625.i64[0];
                      float64x2_t v724 = 0uLL;
                      v628.i64[0] = *((void *)a2 + 21);
                      if (fabs(*(double *)v628.i64) < 2.22044605e-16
                        || (v628.i64[0] & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
                      {
                        v627.f64[0] = 0.0;
                        *(double *)v628.i64 = fmax(*((double *)this + 360), 0.0);
                        *((void *)this + 365) = v628.i64[0];
                      }
                      else
                      {
                        __p[0] = 0uLL;
                        *(double *)v628.i64 = *(double *)v625.i64 / *(double *)v628.i64;
                        CNTimeSpan::SetTimeSpan((uint64_t *)__p, 0, v628, v625);
                        v628.i64[1] = *(void *)&__p[0].f64[1];
                        float64x2_t v724 = __p[0];
                        uint64_t v629 = *(void *)&__p[0].f64[0];
                        v627.f64[0] = 0.0;
                        *(double *)v628.i64 = fmax(*((double *)this + 360), 0.0);
                        *((void *)this + 365) = v628.i64[0];
                        if (v629)
                        {
                          if (v629 < 1)
                          {
                            uint64_t v653 = 0;
                            goto LABEL_811;
                          }
                          float64_t v630 = v724.f64[1];
                          goto LABEL_810;
                        }
                      }
                      uint64_t v629 = 0;
                      uint64_t v653 = 0;
                      float64_t v630 = v724.f64[1];
                      if (v724.f64[1] <= 0.0)
                      {
LABEL_811:
                        *(void *)&v724.f64[0] = v653;
                        v724.f64[1] = v627.f64[0];
                        v627.f64[0] = v627.f64[0] + (double)v653;
                        *(double *)v628.i64 = *(double *)v628.i64 - v627.f64[0];
                        *((void *)this + 365) = v628.i64[0];
                        sub_18E1CA240((uint64_t)__p, (uint64_t)a2 + 8, &v724, v628, (int8x16_t)v627);
                        float64x2_t v654 = __p[1];
                        *((float64x2_t *)this + 177) = __p[0];
                        *((float64x2_t *)this + 178) = v654;
                        *((float64x2_t *)this + 179) = __p[2];
                        *((void *)this + 362) = 0;
                        *((void *)this + 361) = 0;
                        trackrun::TrackRunEngineActiveObject::TrackCoordinateTransform::ConvertEastNorthToLatLon((uint64_t)this + 608, (float64x2_t *)&v735, v655, v656, v657, v658, v659, (uint64_t)__p);
                        if (LOBYTE(__p[1].f64[0])) {
                          *((float64x2_t *)this + 184) = __p[0];
                        }
                        LOWORD(v722) = 13;
                        v739[0] = 3;
                        char v660 = *((unsigned char *)this + 2640);
                        trackrun::TrackRunEngineActiveObject::ConvertIosTimeToGregorianString((uint64_t)this, *((void *)this + 358), *((void *)this + 359), v737);
                        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v722, v739, "TrackRun-Lap-%u,viewType,SingleArrowCoordinate,iOSTime,%.1lf,mcTime,%.1lf,gregTime,%s,latitude,%.7lf,longitude,%.7lf,course,%.2lf,cur_dist_past_lap_m,%.1lf,lap_count,%d,last_lap_dist,%.2lf,raw_last_lap_dist,%.2lf,last_lap_split_s,%.1lf,workout_duration,%.1lf,workout_dist,%.1lf,raw_workout_dist,%.1lf,current_lane,%lu,last_lap_start_time,%.1lf", v661, v662, v663, v664, v665, v660);
                        if (SHIBYTE(v737[2]) < 0) {
                          operator delete(v737[0]);
                        }
LABEL_792:
                        if (*((unsigned char *)this + 2992))
                        {
                          int v636 = *((unsigned __int8 *)this + 2040);
                          *(_OWORD *)((char *)this + 1912) = *((_OWORD *)this + 179);
                          *(_OWORD *)((char *)this + 1928) = *((_OWORD *)this + 180);
                          *(_OWORD *)((char *)this + 1880) = *((_OWORD *)this + 177);
                          *(_OWORD *)((char *)this + 1896) = *((_OWORD *)this + 178);
                          long long v637 = *((_OWORD *)this + 184);
                          *(_OWORD *)((char *)this + 1976) = *((_OWORD *)this + 183);
                          *(_OWORD *)((char *)this + 1992) = v637;
                          long long v638 = *((_OWORD *)this + 186);
                          *(_OWORD *)((char *)this + 2008) = *((_OWORD *)this + 185);
                          *(_OWORD *)((char *)this + 2024) = v638;
                          long long v639 = *((_OWORD *)this + 182);
                          *(_OWORD *)((char *)this + 1944) = *((_OWORD *)this + 181);
                          *(_OWORD *)((char *)this + 1960) = v639;
                          if (!v636) {
                            *((unsigned char *)this + 2040) = 1;
                          }
                        }
                        goto LABEL_795;
                      }
LABEL_810:
                      uint64_t v653 = v629;
                      v627.f64[0] = v630;
                      goto LABEL_811;
                    }
                    if (!*((unsigned char *)this + 2713)
                      || *((double *)a2 + 21) < 0.05
                      && (!*((unsigned char *)this + 776) || *((unsigned __int8 *)this + 768) - 1 <= 1))
                    {
                      goto LABEL_748;
                    }
                  }
                  else
                  {
                    if (!*((unsigned char *)this + 2824)) {
                      goto LABEL_775;
                    }
                    v545 = (char *)this + 2824;
                    if (*((unsigned char *)this + 2712)) {
                      goto LABEL_765;
                    }
                  }
                  *((unsigned char *)this + 2712) = 1;
                  v735.i16[0] = 13;
                  LOBYTE(v737[0]) = 3;
                  char v719 = *((unsigned char *)this + 2640);
                  trackrun::TrackRunEngineActiveObject::ConvertIosTimeToGregorianString((uint64_t)this, *((void *)this + 358), *((void *)this + 359), __p);
                  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v735, (unsigned __int8 *)v737, "TrackRun-Start-%u hint:%d,viewType,MultiCoordinatePolyline,iOSTime,%.1lf,mcTime,%.1lf,gregTime,%s,latitude,%.7lf,longitude,%.7lf,latitude1,%.7lf,longitude1,%.7lf,lane_hint,%d", v590, v591, v592, v593, v594, v719);
                  if (SHIBYTE(__p[1].f64[0]) < 0) {
                    operator delete(*(void **)&__p[0].f64[0]);
                  }
                  if (*v545) {
                    goto LABEL_765;
                  }
LABEL_775:
                  if (cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v335) <= 1)
                  {
                    strcpy((char *)__p, "\r");
                    v735.i8[0] = 1;
                    cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v735, "#tre_ao,starting line not populated. Cannot proceed", v611, v612, v613, v614, v615, v679);
                  }
                  goto LABEL_807;
                }
LABEL_732:
                uint64_t v335 = CNTimeSpan::operator-((uint64_t)a2 + 16, (void *)this + 204, v343, (int8x16_t)v344);
                char v531 = 0;
                v344.f64[0] = (double)v335;
                *(double *)v343.i64 = v336 + (double)v335;
                *((void *)this + 361) = v343.i64[0];
                goto LABEL_735;
              }
            }
LABEL_727:
            if (*((unsigned char *)a2 + 184))
            {
              int8x16_t v343 = *((int8x16_t *)a2 + 12);
              *(int8x16_t *)((char *)this + 1848) = v343;
              v343.i64[0] = *((void *)a2 + 26);
              *((void *)this + 233) = v343.i64[0];
              *((_WORD *)this + 920) = 1;
            }
            if (!*((unsigned char *)this + 2992))
            {
              char v531 = 1;
              goto LABEL_735;
            }
            if (!*((unsigned char *)this + 1672) || *((unsigned char *)this + 1497) != 4)
            {
              char v531 = 0;
              *((double *)this + 362) = *((double *)this + 361) + *((double *)this + 362);
              *((void *)this + 361) = 0;
              float64x2_t v532 = (float64x2_t)vdupq_lane_s64(*((void *)a2 + 25), 0);
              *(float64x2_t *)((char *)this + 2904) = vaddq_f64(v532, *(float64x2_t *)((char *)this + 2904));
              float64x2_t v344 = *((float64x2_t *)this + 186);
              int8x16_t v343 = (int8x16_t)vaddq_f64(v532, v344);
              *((int8x16_t *)this + 186) = v343;
              goto LABEL_735;
            }
            goto LABEL_732;
          }
          unint64_t v292 = v272 - 1;
          if (v292 >= *((void *)v720 + 12) - 1) {
            uint64_t v293 = *((void *)v720 + 12) - 1;
          }
          else {
            uint64_t v293 = v292;
          }
          goto LABEL_368;
        }
      }
    }
    if (!v721) {
      goto LABEL_807;
    }
    if (*((double *)&v731[3] + 1) < 50.0)
    {
      strcpy(v749, "\r");
      v735.i8[0] = 3;
      char v276 = *((unsigned char *)this + 2640);
      (*(void (**)(const trackrun::PositionEvent *, double))(*(void *)a2 + 16))(a2, *((double *)&v731[3] + 1));
      trackrun::TrackRunEngineActiveObject::ConvertIosTimeToGregorianString((uint64_t)this, *((void *)a2 + 5), *((void *)a2 + 6), __p);
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)v749, (unsigned __int8 *)&v735, "TrackRun-Mat-%u,viewType,SingleArrowCoordinate,iOSTime,%.1lf,mcTime,%.1lf,gregTime,%s,latitude,%.7lf,longitude,%.7lf,course,%.2lf,courseUnc,%.2lf,speed,%.2lf,speedUnc,%.2lf,hunc,%.1lf,altitude,%.1lf,vunc,%.1lf,type,%d,track_prox,%d,dist_to_outer_lane_,%.1lf,lane_est,%d,lane_count,%hhu,current_lap_distance,%.1lf,in_a_workout,%d,use_sparse_data,%d", v277, v278, v279, v280, v281, v276);
      if (SHIBYTE(__p[1].f64[0]) < 0) {
        operator delete(*(void **)&__p[0].f64[0]);
      }
    }
    if (v202 <= *(double *)(*((void *)this + 67) + 112)) {
      goto LABEL_807;
    }
    if (*((unsigned char *)this + 672))
    {
      *(void *)&__p[0].f64[0] = v716;
      sub_18E1BEB28((void ***)__p);
      *((unsigned char *)this + 672) = 0;
      if (!*((unsigned char *)this + 2536)) {
        goto LABEL_326;
      }
    }
    else if (!*((unsigned char *)this + 2536))
    {
      goto LABEL_807;
    }
    *((void *)this + 306) = &unk_1EDD1A160;
    *(void *)&__p[0].f64[0] = (char *)this + 2456;
    sub_18E1BEB28((void ***)__p);
    *((unsigned char *)this + 2536) = 0;
LABEL_326:
    strcpy((char *)__p, "\r");
    v749[0] = 3;
    uint64_t v294 = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
    double v680 = v295 + (double)v294;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, v749, "#tre_ao,time,%.3lf,user is no longer near any track, clearing non-sparse track data.", v296, v297, v298, v299, v300, SLOBYTE(v680));
    goto LABEL_807;
  }
  if (cnprint::CNPrinter::GetLogLevel(v243) <= 1)
  {
    strcpy((char *)__p, "\r");
    v749[0] = 1;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, v749, "#tre_ao,DEBUG FORCING TO LANE %d", v245, v246, v247, v248, v249, *(unsigned char *)(*((void *)this + 67) + 69));
  }
  memset(&__p[0].f64[1], 0, 56);
  *(void *)&__p[0].f64[0] = &unk_1EDD19FC8;
  __p[1].f64[1] = 0.0;
  LOBYTE(__p[2].f64[0]) = 0;
  long long v250 = *(long long *)((char *)&__p[1] + 8);
  if (*((unsigned char *)this + 1072))
  {
    *(float64x2_t *)((char *)this + 1016) = *(float64x2_t *)((char *)__p + 8);
    *(_OWORD *)((char *)this + 1032) = v250;
    *(float64x2_t *)((char *)this + 1048) = *(float64x2_t *)((char *)&__p[2] + 8);
    *((unsigned char *)this + 1064) = LOBYTE(__p[3].f64[1]);
  }
  else
  {
    *(float64x2_t *)((char *)this + 1016) = *(float64x2_t *)((char *)__p + 8);
    *((void *)this + 126) = &unk_1EDD19FC8;
    *(_OWORD *)((char *)this + 1032) = v250;
    *(float64x2_t *)((char *)this + 1048) = *(float64x2_t *)((char *)&__p[2] + 8);
    *((unsigned char *)this + 1064) = LOBYTE(__p[3].f64[1]);
    *((unsigned char *)this + 1072) = 1;
  }
  *((unsigned char *)this + 1064) = *(unsigned char *)(*((void *)this + 67) + 69);
  uint64_t v251 = (_OWORD *)((char *)this + 1016);
  long long v253 = *v244;
  long long v252 = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 1048) = *(_OWORD *)((char *)a2 + 40);
  *(_OWORD *)((char *)this + 1016) = v253;
  *(_OWORD *)((char *)this + 1032) = v252;
  if (*((unsigned char *)this + 4602))
  {
LABEL_244:
    if (*((unsigned char *)this + 4680))
    {
      *((unsigned char *)this + 4672) = *((unsigned char *)this + 1064);
      long long v254 = *(_OWORD *)((char *)this + 1032);
      *((_OWORD *)this + 289) = *v251;
      *((_OWORD *)this + 290) = v254;
      *((_OWORD *)this + 291) = *(_OWORD *)((char *)this + 1048);
    }
    else
    {
      long long v257 = *(_OWORD *)((char *)this + 1032);
      *((_OWORD *)this + 289) = *v251;
      *((unsigned char *)this + 4672) = *((unsigned char *)this + 1064);
      *((void *)this + 577) = &unk_1EDD19FC8;
      *((_OWORD *)this + 290) = v257;
      *((_OWORD *)this + 291) = *(_OWORD *)((char *)this + 1048);
      *((unsigned char *)this + 4680) = 1;
    }
    unsigned int v258 = *((unsigned __int8 *)this + 1064);
    if (v258 <= 1) {
      unsigned int v259 = 1;
    }
    else {
      unsigned int v259 = *((unsigned __int8 *)this + 1064);
    }
    if (v258 > *((unsigned __int8 *)v720 + 96)) {
      unsigned int v259 = *((unsigned __int8 *)v720 + 96);
    }
    if (*((unsigned char *)v720 + 96)) {
      uint64_t v260 = v259;
    }
    else {
      uint64_t v260 = *((unsigned __int8 *)this + 1064);
    }
    if (!*((unsigned char *)this + 4704)) {
      *((unsigned char *)this + 4704) = 1;
    }
    *((void *)this + 587) = v260;
    *((_WORD *)this + 2344) = 0;
    goto LABEL_261;
  }
  __p[0].f64[0] = 0.0;
  __p[0].f64[1] = NAN;
  LOBYTE(__p[1].f64[0]) = 0;
  LOBYTE(__p[1].f64[1]) = 0;
  BYTE8(v742) = 0;
  *(void *)&__p[0].f64[0] = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
  __p[0].f64[1] = v255;
  LOBYTE(__p[1].f64[0]) = v731[4];
  if (BYTE8(v742) == *((unsigned __int8 *)this + 1072))
  {
    if (BYTE8(v742))
    {
      float64x2_t v256 = *(float64x2_t *)((char *)this + 1032);
      __p[2] = *(float64x2_t *)v251;
      __p[3] = v256;
      long long v741 = *(_OWORD *)((char *)this + 1048);
      LOBYTE(v742) = *((unsigned char *)this + 1064);
    }
  }
  else if (BYTE8(v742))
  {
    BYTE8(v742) = 0;
  }
  else
  {
    *(void *)&__p[1].f64[1] = &unk_1EDD19FC8;
    float64x2_t v359 = *(float64x2_t *)((char *)this + 1032);
    __p[2] = *(float64x2_t *)v251;
    __p[3] = v359;
    long long v741 = *(_OWORD *)((char *)this + 1048);
    LOBYTE(v742) = *((unsigned char *)this + 1064);
    BYTE8(v742) = 1;
  }
  if (!trackrun::TrackRunLaneEstimator::Initialize((uint64_t)this + 3104))
  {
    if (!*((unsigned char *)this + 1072)) {
      sub_18DFF28FC();
    }
    goto LABEL_244;
  }
  strcpy(v749, "\r");
  v735.i8[0] = 4;
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)v749, (unsigned __int8 *)&v735, "#tre_ao,lane estimator could not be initialized.", v360, v361, v362, v363, v364, v679);
LABEL_807:
  std::mutex::unlock((std::mutex *)((char *)this + 544));
}

void sub_18E1C90B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,std::mutex *a59)
{
}

double sub_18E1C9244(double *a1, double **a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if ((unint64_t)((char *)v3 - (char *)*a2) < 0x40) {
    goto LABEL_11;
  }
  LODWORD(v12) = 0;
  BYTE4(v12) = 0;
  long long v6 = v3 - 4;
  do
  {
    if (v6 + 2 == v4) {
      break;
    }
    BOOL v7 = sub_18E12F8BC(a1, v6 + 2, v6, (uint64_t)&v12);
    v6 -= 2;
  }
  while (v7);
  double result = 0.0;
  if (BYTE4(v12)) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = v12 == 0;
  }
  if (v9)
  {
    uint64_t v4 = *a2;
    uint64_t v3 = a2[1];
LABEL_11:
    if (v3 == v4)
    {
      return 0.0;
    }
    else
    {
      double v10 = 0.0;
      double v11 = 0;
      sub_18E1D38D8(a1, v4, v3, &v12, &v11, &v10);
      return v10;
    }
  }
  return result;
}

void trackrun::TrackRunEngineActiveObject::ComputeAcrossTrackDistanceInformation(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, double *a4@<X3>, long long *a5@<X8>)
{
  *((_WORD *)a5 + 32) = 0;
  a5[2] = 0u;
  a5[3] = 0u;
  *a5 = 0u;
  a5[1] = 0u;
  *((void *)a5 + 9) = 0x3FF0000000000000;
  if (*(void *)(a3 + 96))
  {
    trackrun::TrackRunEngineActiveObject::FindClosestPointOnRing(a4, *(double ***)(a3 + 40), 1, 0);
    double v11 = v10;
    *((double *)a5 + 3) = v10;
  }
  else
  {
    double v11 = 0.0;
  }
  if (*(unsigned char *)(a1 + 1432))
  {
    int v12 = *(unsigned __int8 *)(a1 + 1425);
    if (v12 == 2)
    {
      double v13 = 0.1863;
    }
    else
    {
      if (v12 != 1) {
        goto LABEL_10;
      }
      double v13 = -0.1863;
    }
    double v11 = v11 + v13;
    *((double *)a5 + 3) = v11;
  }
LABEL_10:
  *a5 = *(_OWORD *)a4;
  double v14 = *(double *)(a2 + 200);
  if (v14 > 20.0)
  {
    LOWORD(v46) = 13;
    LOBYTE(v45) = 3;
    sub_18DEDE7B0(v47, "TrackRunEngineActiveObject");
    if (v48 >= 0) {
      long long v20 = v47;
    }
    else {
      LOBYTE(v20) = v47[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v46, (unsigned __int8 *)&v45, "Warning %s, delta_distance for current epoch is very large,%.1lf", v15, v16, v17, v18, v19, (char)v20);
    if (v48 < 0) {
      operator delete(v47[0]);
    }
    double v14 = 20.0;
  }
  *((double *)a5 + 2) = v14;
  long long v21 = *(double ***)(a3 + 40);
  long long v22 = &v21[9 * *(void *)(a3 + 96) - 9];
  double ClosestPointOnRing = trackrun::TrackRunEngineActiveObject::FindClosestPointOnRing(a4, v21, 0, 0);
  uint64_t v25 = v24;
  double v26 = trackrun::TrackRunEngineActiveObject::FindClosestPointOnRing(a4, v22, 0, 0);
  *((double *)a5 + 4) = ClosestPointOnRing;
  *((void *)a5 + 5) = v25;
  *((double *)a5 + 6) = v26;
  *((void *)a5 + 7) = v27;
  if (*(unsigned char *)(a1 + 2992)) {
    *((_WORD *)a5 + 32) = *(_WORD *)(a1 + 2960);
  }
  if (!*(unsigned char *)(a3 + 88)) {
    sub_18DFF28FC();
  }
  double v28 = *(double *)(a3 + 80);
  double v29 = v11 + (double)*(unint64_t *)(a3 + 96) * v28;
  double v30 = v11 - v28;
  if (v29 < 0.0 || v30 > 0.0)
  {
    if (v29 >= 0.0) {
      double v31 = v30;
    }
    else {
      double v31 = -v29;
    }
    *((long double *)a5 + 9) = exp(-(*(double *)(*(void *)(a1 + 536) + 224) * v31));
    long long v46 = *a5;
    trackrun::TrackRunEngineActiveObject::ConvertPointEastNorthToLatLon(a1, (uint64_t)&v46, v32, v33, v34, v35, v36, v37);
    __int16 v45 = 13;
    unsigned __int8 v44 = 3;
    char v38 = *(unsigned char *)(a1 + 2640);
    (*(void (**)(uint64_t))(*(void *)a2 + 16))(a2);
    trackrun::TrackRunEngineActiveObject::ConvertIosTimeToGregorianString(a1, *(void *)(a2 + 40), *(void *)(a2 + 48), v47);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v45, &v44, "TrackRun-OUT-%u,viewType,SingleArrowCoordinate,iOSTime,%.1lf,mcTime,%.1lf,gregTime,%s,latitude,%.7lf,longitude,%.7lf,course,%.2lf,speed,%.2lf,type,%d,distance,%.1lf,weight_factor,%.1lf", v39, v40, v41, v42, v43, v38);
    if (v48 < 0) {
      operator delete(v47[0]);
    }
  }
}

void sub_18E1C95E4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 81) < 0) {
    operator delete(*(void **)(v1 - 104));
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_18E1C9604(void *a1, uint64_t a2)
{
  uint64_t v4 = (char *)a1[1];
  uint64_t v5 = (char *)a1[2];
  unint64_t v6 = (v5 - v4) >> 3;
  if (v5 == v4) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = 51 * v6 - 1;
  }
  unint64_t v8 = a1[4];
  unint64_t v9 = a1[5] + v8;
  if (v7 == v9)
  {
    if (v8 < 0x33)
    {
      __n128 v23 = (char *)a1[3];
      uint64_t v24 = (char *)*a1;
      uint64_t v25 = (uint64_t)&v23[-*a1];
      if (v6 >= v25 >> 3)
      {
        uint64_t v28 = v25 >> 2;
        if (v23 == v24) {
          unint64_t v29 = 1;
        }
        else {
          unint64_t v29 = v28;
        }
        double v30 = (char *)sub_18DEE2FBC(v29);
        uint64_t v32 = v31;
        uint64_t v33 = operator new(0xFF0uLL);
        uint64_t v34 = &v30[8 * v6];
        uint64_t v35 = &v30[8 * v32];
        if (v6 == v32)
        {
          uint64_t v36 = 8 * v6;
          if (v5 - v4 < 1)
          {
            double v75 = v33;
            uint64_t v76 = v36 >> 2;
            if (v5 == v4) {
              unint64_t v77 = 1;
            }
            else {
              unint64_t v77 = v76;
            }
            uint64_t v78 = (char *)sub_18DEE2FBC(v77);
            uint64_t v34 = &v78[8 * (v77 >> 2)];
            uint64_t v35 = &v78[8 * v79];
            if (v30) {
              operator delete(v30);
            }
            double v30 = v78;
            uint64_t v33 = v75;
          }
          else
          {
            uint64_t v37 = v36 >> 3;
            if (v37 >= -1) {
              unint64_t v38 = v37 + 1;
            }
            else {
              unint64_t v38 = v37 + 2;
            }
            v34 -= 8 * (v38 >> 1);
          }
        }
        *(void *)uint64_t v34 = v33;
        uint64_t v80 = v34 + 8;
        for (uint64_t i = a1[2]; i != a1[1]; i -= 8)
        {
          if (v34 == v30)
          {
            if (v80 >= v35)
            {
              if (v35 == v30) {
                unint64_t v86 = 1;
              }
              else {
                unint64_t v86 = (v35 - v30) >> 2;
              }
              long long v87 = (char *)sub_18DEE2FBC(v86);
              int v89 = v87;
              uint64_t v34 = &v87[(2 * v86 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v91 = v80 - v30;
              BOOL v90 = v80 == v30;
              uint64_t v80 = v34;
              if (!v90)
              {
                uint64_t v80 = &v34[v91 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v92 = 8 * (v91 >> 3);
                uint64_t v93 = v34;
                uint64_t v94 = (uint64_t *)v30;
                do
                {
                  uint64_t v95 = *v94++;
                  *(void *)uint64_t v93 = v95;
                  v93 += 8;
                  v92 -= 8;
                }
                while (v92);
              }
              uint64_t v35 = &v87[8 * v88];
              if (v30) {
                operator delete(v30);
              }
              double v30 = v89;
            }
            else
            {
              uint64_t v82 = (v35 - v80) >> 3;
              if (v82 >= -1) {
                uint64_t v83 = v82 + 1;
              }
              else {
                uint64_t v83 = v82 + 2;
              }
              uint64_t v84 = v83 >> 1;
              uint64_t v34 = &v30[8 * (v83 >> 1)];
              long long v85 = v30;
              if (v80 != v30)
              {
                memmove(v34, v30, v80 - v30);
                long long v85 = v80;
              }
              uint64_t v80 = &v85[8 * v84];
            }
          }
          uint64_t v96 = *(void *)(i - 8);
          *((void *)v34 - 1) = v96;
          v34 -= 8;
        }
        uint64_t v97 = (char *)*a1;
        *a1 = v30;
        a1[1] = v34;
        a1[2] = v80;
        a1[3] = v35;
        if (v97) {
          operator delete(v97);
        }
        goto LABEL_36;
      }
      double v26 = operator new(0xFF0uLL);
      uint64_t v27 = v26;
      if (v23 == v5)
      {
        if (v4 == v24)
        {
          if (v5 == v4) {
            unint64_t v53 = 1;
          }
          else {
            unint64_t v53 = (v23 - v4) >> 2;
          }
          uint64_t v54 = 2 * v53;
          long long v55 = (char *)sub_18DEE2FBC(v53);
          uint64_t v4 = &v55[(v54 + 6) & 0xFFFFFFFFFFFFFFF8];
          long long v57 = (uint64_t *)a1[1];
          long long v58 = v4;
          uint64_t v59 = a1[2] - (void)v57;
          if (v59)
          {
            long long v58 = &v4[v59 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v60 = 8 * (v59 >> 3);
            long long v61 = &v55[(v54 + 6) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              uint64_t v62 = *v57++;
              *(void *)long long v61 = v62;
              v61 += 8;
              v60 -= 8;
            }
            while (v60);
          }
          long long v63 = (char *)*a1;
          *a1 = v55;
          a1[1] = v4;
          a1[2] = v58;
          a1[3] = &v55[8 * v56];
          if (v63)
          {
            operator delete(v63);
            uint64_t v4 = (char *)a1[1];
          }
        }
        *((void *)v4 - 1) = v27;
        long long v64 = (char *)a1[1];
        long long v65 = (char *)a1[2];
        a1[1] = v64 - 8;
        uint64_t v66 = *((void *)v64 - 1);
        a1[1] = v64;
        if (v65 == (char *)a1[3])
        {
          uint64_t v67 = (uint64_t)&v64[-*a1];
          if ((unint64_t)v64 <= *a1)
          {
            if (v65 == (char *)*a1) {
              unint64_t v98 = 1;
            }
            else {
              unint64_t v98 = (uint64_t)&v65[-*a1] >> 2;
            }
            double v99 = (char *)sub_18DEE2FBC(v98);
            uint64_t v101 = &v99[8 * (v98 >> 2)];
            uint64_t v102 = (uint64_t *)a1[1];
            long long v65 = v101;
            uint64_t v103 = a1[2] - (void)v102;
            if (v103)
            {
              long long v65 = &v101[v103 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v104 = 8 * (v103 >> 3);
              uint64_t v105 = &v99[8 * (v98 >> 2)];
              do
              {
                uint64_t v106 = *v102++;
                *(void *)uint64_t v105 = v106;
                v105 += 8;
                v104 -= 8;
              }
              while (v104);
            }
            uint64_t v107 = (char *)*a1;
            *a1 = v99;
            a1[1] = v101;
            a1[2] = v65;
            a1[3] = &v99[8 * v100];
            if (v107)
            {
              operator delete(v107);
              long long v65 = (char *)a1[2];
            }
          }
          else
          {
            uint64_t v68 = v67 >> 3;
            BOOL v15 = v67 >> 3 < -1;
            uint64_t v69 = (v67 >> 3) + 2;
            if (v15) {
              uint64_t v70 = v69;
            }
            else {
              uint64_t v70 = v68 + 1;
            }
            uint64_t v71 = -(v70 >> 1);
            uint64_t v72 = v70 >> 1;
            long long v73 = &v64[-8 * v72];
            int64_t v74 = v65 - v64;
            if (v65 != v64)
            {
              memmove(&v64[-8 * v72], v64, v65 - v64);
              long long v64 = (char *)a1[1];
            }
            long long v65 = &v73[v74];
            a1[1] = &v64[8 * v71];
            a1[2] = &v73[v74];
          }
        }
        *(void *)long long v65 = v66;
      }
      else
      {
        *(void *)uint64_t v5 = v26;
      }
    }
    else
    {
      a1[4] = v8 - 51;
      uint64_t v12 = *(void *)v4;
      double v10 = v4 + 8;
      uint64_t v11 = v12;
      a1[1] = v10;
      if (v5 == (char *)a1[3])
      {
        uint64_t v13 = (uint64_t)&v10[-*a1];
        if ((unint64_t)v10 <= *a1)
        {
          if (v5 == (char *)*a1) {
            unint64_t v39 = 1;
          }
          else {
            unint64_t v39 = (uint64_t)&v5[-*a1] >> 2;
          }
          uint64_t v40 = (char *)sub_18DEE2FBC(v39);
          uint64_t v42 = &v40[8 * (v39 >> 2)];
          uint64_t v43 = (uint64_t *)a1[1];
          uint64_t v5 = v42;
          uint64_t v44 = a1[2] - (void)v43;
          if (v44)
          {
            uint64_t v5 = &v42[v44 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v45 = 8 * (v44 >> 3);
            long long v46 = &v40[8 * (v39 >> 2)];
            do
            {
              uint64_t v47 = *v43++;
              *(void *)long long v46 = v47;
              v46 += 8;
              v45 -= 8;
            }
            while (v45);
          }
          char v48 = (char *)*a1;
          *a1 = v40;
          a1[1] = v42;
          a1[2] = v5;
          a1[3] = &v40[8 * v41];
          if (v48)
          {
            operator delete(v48);
            uint64_t v5 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v14 = v13 >> 3;
          BOOL v15 = v13 >> 3 < -1;
          uint64_t v16 = (v13 >> 3) + 2;
          if (v15) {
            uint64_t v17 = v16;
          }
          else {
            uint64_t v17 = v14 + 1;
          }
          uint64_t v18 = -(v17 >> 1);
          uint64_t v19 = v17 >> 1;
          long long v20 = &v10[-8 * v19];
          int64_t v21 = v5 - v10;
          if (v5 != v10)
          {
            memmove(&v10[-8 * v19], v10, v5 - v10);
            uint64_t v5 = (char *)a1[1];
          }
          long long v22 = &v5[8 * v18];
          uint64_t v5 = &v20[v21];
          a1[1] = v22;
          a1[2] = &v20[v21];
        }
      }
      *(void *)uint64_t v5 = v11;
    }
    a1[2] += 8;
LABEL_36:
    uint64_t v4 = (char *)a1[1];
    unint64_t v9 = a1[5] + a1[4];
  }
  unint64_t v49 = *(void *)&v4[8 * (v9 / 0x33)] + 80 * (v9 % 0x33);
  *(_OWORD *)unint64_t v49 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  long long v51 = *(_OWORD *)(a2 + 32);
  long long v52 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v49 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v49 + 64) = v52;
  *(__n128 *)(v49 + 16) = result;
  *(_OWORD *)(v49 + 32) = v51;
  ++a1[5];
  return result;
}

void sub_18E1C9AFC(_Unwind_Exception *a1)
{
  operator delete(v2);
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

void trackrun::TrackRunEngineActiveObject::PruneAcrossTrackDistanceDeque(trackrun::TrackRunEngineActiveObject *this)
{
  unint64_t v1 = *((void *)this + 387);
  if (v1 >= 2)
  {
    unint64_t v3 = *((void *)this + 386);
    do
    {
      unint64_t v4 = v3 + v1;
      uint64_t v5 = *((void *)this + 383);
      unint64_t v6 = (void *)(v5 + 8 * (v4 / 0x33));
      uint64_t v7 = *v6 + 80 * (v4 % 0x33);
      if (*((void *)this + 384) == v5) {
        uint64_t v7 = 0;
      }
      if (*v6 == v7) {
        uint64_t v7 = *(v6 - 1) + 4080;
      }
      trackrun::TrackRunEngineActiveObject::FindClosestPointOnLineSegment((double *)(v7 - 80), (double *)(*(void *)(v5 + 8 * (v3 / 0x33)) + 80 * (v3 % 0x33) + 32), 1, 0, 0);
      double v10 = v9;
      unint64_t v11 = *((void *)this + 386);
      unint64_t v12 = v11 + *((void *)this + 387);
      uint64_t v13 = *((void *)this + 383);
      uint64_t v14 = (void *)(v13 + 8 * (v12 / 0x33));
      uint64_t v15 = *v14 + 80 * (v12 % 0x33);
      if (*((void *)this + 384) == v13) {
        uint64_t v15 = 0;
      }
      if (*v14 == v15) {
        uint64_t v15 = *(v14 - 1) + 4080;
      }
      unsigned int v16 = *(unsigned __int16 *)(v15 - 16);
      unsigned int v17 = *(unsigned __int16 *)(*(void *)(v13 + 8 * (v11 / 0x33)) + 80 * (v11 % 0x33) + 64);
      unsigned int LogLevel = (cnprint::CNPrinter *)cnprint::CNPrinter::GetLogLevel(v8);
      if (!LogLevel)
      {
        __int16 v33 = 13;
        unsigned __int8 v32 = 0;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v33, &v32, "#tre_ao,lap_count,first,%d,last,%d,signed_last,%.1lf", v19, v20, v21, v22, v23, v17);
      }
      if (v10 <= 0.0 || v16 <= v17 && *((double *)this + 363) <= 250.0) {
        break;
      }
      if (cnprint::CNPrinter::GetLogLevel(LogLevel) <= 1)
      {
        __int16 v31 = 13;
        unsigned __int8 v30 = 1;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v31, &v30, "#tre_ao,dist_to_first_point is positive,discarding,%.1lf,size,%lu", v24, v25, v26, v27, v28, SLOBYTE(v10));
      }
      uint64_t v29 = *((void *)this + 386);
      unint64_t v1 = *((void *)this + 387) - 1;
      *((void *)this + 387) = v1;
      unint64_t v3 = v29 + 1;
      *((void *)this + 386) = v3;
      if (v3 >= 0x66)
      {
        operator delete(**((void ***)this + 383));
        *((void *)this + 383) += 8;
        unint64_t v3 = *((void *)this + 386) - 51;
        *((void *)this + 386) = v3;
        unint64_t v1 = *((void *)this + 387);
      }
    }
    while (v1 > 1);
  }
}

void trackrun::TrackRunEngineActiveObject::ComputeAcrossTrackDistanceEvidence(trackrun::TrackRunEngineActiveObject *this@<X0>, const trackrun::PositionEvent *a2@<X1>, const trackrun::RunningTrackData::RunningTrack *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v4 = this;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(void *)(a4 + 32) = 0x7FF8000000000000;
  uint64_t v5 = *((void *)a3 + 12);
  if (!*(unsigned char *)(*((void *)this + 67) + 66)) {
    uint64_t v5 = 1;
  }
  uint64_t v28 = v5;
  if (!v5)
  {
    unint64_t v8 = 0;
    if (!*(unsigned char *)(*((void *)this + 67) + 66)) {
      return;
    }
    goto LABEL_26;
  }
  unint64_t v8 = 0;
  unint64_t v9 = 0;
  double v10 = INFINITY;
  do
  {
    v31[0] = 0;
    long long v32 = 0u;
    memset(v33, 0, sizeof(v33));
    if (*((void *)v4 + 387))
    {
      unint64_t v11 = 0;
      do
      {
        double v30 = 0.0;
        if (!*((unsigned char *)a3 + 88)) {
          goto LABEL_30;
        }
        unint64_t v12 = (double *)(*(void *)(*((void *)v4 + 383) + 8 * ((v11 + *((void *)v4 + 386)) / 0x33))
                       + 80 * ((v11 + *((void *)v4 + 386)) % 0x33));
        double v30 = v12[3] + *((double *)a3 + 10) * (double)v9;
        this = (trackrun::TrackRunEngineActiveObject *)sub_18DFF11E4((uint64_t)v31, &v30, v12[9] * v12[2]);
        ++v11;
        unint64_t v13 = *((void *)v4 + 387);
      }
      while (v11 < v13);
      double v14 = *(double *)&v33[1];
      double v15 = sqrt(*(double *)&v33[5]);
      if (v13 <= 4) {
        double v16 = 10.0;
      }
      else {
        double v16 = v15;
      }
    }
    else
    {
      double v14 = 0.0;
      double v16 = 10.0;
    }
    double v17 = fabs(v14);
    if (v17 < v10)
    {
      double v10 = v17;
      unint64_t v8 = v9;
    }
    if (*(unsigned char *)(*((void *)v4 + 67) + 66))
    {
      this = (trackrun::TrackRunEngineActiveObject *)cnprint::CNPrinter::GetLogLevel(this);
      if (this <= 1)
      {
        LOWORD(v30) = 13;
        unsigned __int8 v29 = 1;
        uint64_t v18 = (*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
        if (!*((unsigned char *)a3 + 88)) {
          goto LABEL_30;
        }
        double v25 = v19 + (double)v18;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v30, &v29, "#tre_ao,time,%.3lf,laneidx,%lu,weighted_across_track_distance_sum,%.2lf,delta_distance_sum,%.1lf,lane_width,%.1lf,win_count,%u,standard_deviation,%.1lf,source,%hhu,delta_dist,%.3lf,speed,%.1lf", v20, v21, v22, v23, v24, SLOBYTE(v25));
      }
    }
    if (!v9)
    {
      this = (trackrun::TrackRunEngineActiveObject *)(*(uint64_t (**)(const trackrun::PositionEvent *))(*(void *)a2 + 16))(a2);
      *(void *)(a4 + 24) = this;
      *(void *)(a4 + 32) = v26;
      *(double *)a4 = v14;
      if (!*((unsigned char *)a3 + 88)) {
LABEL_30:
      }
        sub_18DFF28FC();
      *(void *)(a4 + 8) = *((void *)a3 + 10);
      *(double *)(a4 + 16) = v16;
    }
    ++v9;
  }
  while (v9 != v28);
  if (*(unsigned char *)(*((void *)v4 + 67) + 66))
  {
LABEL_26:
    if (*((unsigned char *)v4 + 2992))
    {
      if (*((_WORD *)v4 + 1480)) {
        ++*((_DWORD *)v4 + v8 + 1178);
      }
    }
  }
}

void sub_18E1CA020(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = a1[2];
  a1[5] = 0;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = v5 - (void)v2;
    }
    while (v4 > 0x10);
  }
  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 25;
  }
  else
  {
    if (v4 >> 3 != 2) {
      return;
    }
    uint64_t v6 = 51;
  }
  a1[4] = v6;
}

double trackrun::TrackRunEngineActiveObject::FindClosestPointOnLineSegment(double *a1, double *a2, int a3, int a4, int a5)
{
  double v6 = a1[1];
  double v7 = a2[1];
  double v8 = a2[2];
  double v9 = a2[3];
  double v10 = *a1 - *a2;
  double v11 = v6 - v7;
  double v12 = v8 - *a2;
  double v13 = v9 - v7;
  double v14 = v13 * v13 + v12 * v12;
  double v15 = -1.0;
  if (fabs(v14) >= 2.22044605e-16) {
    double v15 = (v11 * v13 + v10 * v12) / v14;
  }
  if (v15 < 0.0 && a5 == 0)
  {
    double v8 = *a2;
    double v9 = a2[1];
    if (a3) {
      goto LABEL_13;
    }
LABEL_22:
    if (!a4) {
      return v8;
    }
    goto LABEL_23;
  }
  if (v15 <= 1.0 || a5 != 0)
  {
    double v8 = *a2 + v15 * v12;
    double v9 = v7 + v15 * v13;
  }
  if (!a3) {
    goto LABEL_22;
  }
LABEL_13:
  double v18 = sqrt((v6 - v9) * (v6 - v9) + (*a1 - v8) * (*a1 - v8));
  double v19 = v12 * v11 - v13 * v10;
  double v20 = 1.0;
  double v21 = 0.0;
  if (v19 < 0.0) {
    double v21 = -1.0;
  }
  if (v19 <= 0.0) {
    double v20 = v21;
  }
  double v22 = v18 * v20;
  if (!cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)a1))
  {
    __int16 v30 = 13;
    unsigned __int8 v29 = 0;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v30, &v29, "#tre_ao,signed_distance_to_closest_point_m,%.1lf", v23, v24, v25, v26, v27, SLOBYTE(v22));
  }
  if (a4)
  {
LABEL_23:
    if (fabs(v12) > 0.000000015 || fabs(v13) > 0.000000015) {
      atan2(v12, v13);
    }
  }
  return v8;
}

uint64_t sub_18E1CA240(uint64_t a1, uint64_t a2, void *a3, int8x16_t a4, int8x16_t a5)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t result = CNTimeSpan::operator-(a2 + 8, a3, a4, a5);
  *(void *)(a1 + 8) = result;
  *(void *)(a1 + 16) = v11;
  if (*(unsigned char *)(a2 + 24))
  {
    uint64_t result = CNTimeSpan::operator-(a2 + 32, a3, v9, v10);
    *(void *)(a1 + 32) = result;
    *(void *)(a1 + 40) = v12;
  }
  return result;
}

void trackrun::TrackRunEngineActiveObject::HandleEvent(trackrun::TrackRunEngineActiveObject *this, const trackrun::TrackRunHintEvent *a2)
{
  if (cnprint::CNPrinter::GetLogLevel(this) <= 1)
  {
    LOWORD(__p[0]) = 13;
    LOBYTE(v43) = 1;
    uint64_t v4 = (*(uint64_t (**)(const trackrun::TrackRunHintEvent *))(*(void *)a2 + 16))(a2);
    double v38 = v5 + (double)v4;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v43, "#tre_ao,received track run hint event,time,%.1lf,lane_number,%hhu", v6, v7, v8, v9, v10, SLOBYTE(v38));
  }
  __int16 v43 = 13;
  unsigned __int8 v42 = 3;
  char v11 = *((unsigned char *)this + 2640);
  if (*((unsigned char *)this + 1000) && ((*(void (**)(void))(*((void *)this + 98) + 16))(), *((unsigned char *)this + 1000)))
  {
    uint64_t v12 = *((void *)this + 103);
    uint64_t v13 = *((void *)this + 104);
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
  }
  trackrun::TrackRunEngineActiveObject::ConvertIosTimeToGregorianString((uint64_t)this, v12, v13, __p);
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v43, &v42, "TrackRun-Hint-%u hint:%d,viewType,SingleArrowCoordinate,time,%.1lf,iOSTime,%.1lf,gregTime,%s,latitude,%.7lf,longitude,%.7lf,lane_hint,%d", v14, v15, v16, v17, v18, v11);
  if (v41 < 0) {
    operator delete(__p[0]);
  }
  if (!*(unsigned char *)(*((void *)this + 67) + 201))
  {
    if (*((unsigned char *)this + 4680))
    {
      long long v20 = *(_OWORD *)((char *)a2 + 8);
      long long v21 = *(_OWORD *)((char *)a2 + 24);
      long long v22 = *(_OWORD *)((char *)a2 + 40);
      *((unsigned char *)this + 4672) = *((unsigned char *)a2 + 56);
      *((_OWORD *)this + 291) = v22;
      *((_OWORD *)this + 290) = v21;
      *((_OWORD *)this + 289) = v20;
    }
    else
    {
      *((void *)this + 577) = &unk_1EDD19FC8;
      long long v23 = *(_OWORD *)((char *)a2 + 8);
      long long v24 = *(_OWORD *)((char *)a2 + 24);
      long long v25 = *(_OWORD *)((char *)a2 + 40);
      *((unsigned char *)this + 4672) = *((unsigned char *)a2 + 56);
      *((_OWORD *)this + 291) = v25;
      *((_OWORD *)this + 290) = v24;
      *((_OWORD *)this + 289) = v23;
      *((unsigned char *)this + 4680) = 1;
    }
    if (*((unsigned char *)this + 1072)) {
      goto LABEL_19;
    }
    if (*((unsigned char *)this + 2824)) {
      *((unsigned char *)this + 2824) = 0;
    }
    if (cnprint::CNPrinter::GetLogLevel(v19) <= 1)
    {
      LOWORD(__p[0]) = 13;
      LOBYTE(v43) = 1;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)__p, (unsigned __int8 *)&v43, "#tre_ao,received first lane hint of the workout, resetting start line.", v26, v27, v28, v29, v30, v39);
    }
    if (*((unsigned char *)this + 1072))
    {
LABEL_19:
      long long v31 = *(_OWORD *)((char *)a2 + 8);
      long long v32 = *(_OWORD *)((char *)a2 + 24);
      long long v33 = *(_OWORD *)((char *)a2 + 40);
      *((unsigned char *)this + 1064) = *((unsigned char *)a2 + 56);
      *(_OWORD *)((char *)this + 1048) = v33;
      *(_OWORD *)((char *)this + 1032) = v32;
      *(_OWORD *)((char *)this + 1016) = v31;
    }
    else
    {
      *((void *)this + 126) = &unk_1EDD19FC8;
      long long v35 = *(_OWORD *)((char *)a2 + 8);
      long long v36 = *(_OWORD *)((char *)a2 + 24);
      long long v37 = *(_OWORD *)((char *)a2 + 40);
      *((unsigned char *)this + 1064) = *((unsigned char *)a2 + 56);
      *(_OWORD *)((char *)this + 1048) = v37;
      *(_OWORD *)((char *)this + 1032) = v36;
      *(_OWORD *)((char *)this + 1016) = v35;
      *((unsigned char *)this + 1072) = 1;
    }
    uint64_t v34 = *((unsigned __int8 *)this + 1064);
    if (!*((unsigned char *)this + 4704)) {
      *((unsigned char *)this + 4704) = 1;
    }
    *((void *)this + 587) = v34;
  }
}

void sub_18E1CA5D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void trackrun::TrackRunEngineActiveObject::Reset(trackrun::TrackRunEngineActiveObject *this)
{
  if (*((unsigned char *)this + 480))
  {
    __int16 v11 = 13;
    unsigned __int8 v10 = 2;
    sub_18DEDE7B0(__p, "TrackRunEngineActiveObject");
    if (v9 >= 0) {
      uint64_t v7 = __p;
    }
    else {
      LOBYTE(v7) = __p[0];
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v11, &v10, "Resetting %s", v2, v3, v4, v5, v6, (char)v7);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
    trackrun::TrackRunEngineActiveObject::ResetTrackStateWhenLeaveTrackOrSessionEnds(this);
    if (*((unsigned char *)this + 1000)) {
      *((unsigned char *)this + 1000) = 0;
    }
    std::mutex::lock((std::mutex *)((char *)this + 544));
    if (*((unsigned char *)this + 2056)) {
      *((unsigned char *)this + 2056) = 0;
    }
    if (*((unsigned char *)this + 2440)) {
      *((unsigned char *)this + 2440) = 0;
    }
    if (*((unsigned char *)this + 672))
    {
      __p[0] = (char *)this + 648;
      sub_18E1BEB28((void ***)__p);
      *((unsigned char *)this + 672) = 0;
    }
    *((void *)this + 78) = 0;
    *((_OWORD *)this + 38) = 0u;
    *((void *)this + 79) = 0x7FF8000000000000;
    *((void *)this + 80) = 0x7FF8000000000000;
    std::mutex::unlock((std::mutex *)((char *)this + 544));
  }
  cnframework::ActiveObjectBase::ResetCurrentTime(this);
  cnframework::ActiveObjectBase::ResetEventQueue(this);
}

void sub_18E1CA6FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL trackrun::TrackRunEngineActiveObject::ConvertPointEastNorthToLatLon(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  trackrun::TrackRunEngineActiveObject::TrackCoordinateTransform::ConvertEastNorthToLatLon(a1 + 608, (float64x2_t *)a2, a4, a5, a6, a7, a8, (uint64_t)&v19);
  int v14 = v20;
  if (v20)
  {
    *(_OWORD *)a2 = v19;
  }
  else
  {
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v18, &v17, "#tre_ao,point coordinate conversion from east north to lat lon could not be completed", v9, v10, v11, v12, v13, v16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  return v14 != 0;
}

void sub_18E1CA794(uint64_t a1)
{
  sub_18E1CB6A8(a1);

  JUMPOUT(0x192FA6240);
}

void *sub_18E1CA7CC(void *result)
{
  *uint64_t result = &unk_1EDD0A448;
  result[18] = &unk_1EDD17478;
  result[1] = &unk_1EDD17478;
  return result;
}

void sub_18E1CA82C(void *a1)
{
  *a1 = &unk_1EDD0A448;
  a1[18] = &unk_1EDD17478;
  a1[1] = &unk_1EDD17478;
  JUMPOUT(0x192FA6240);
}

double sub_18E1CA89C@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 24) = 0x10000000CLL;
  *(void *)a2 = &unk_1EDD17808;
  *(_OWORD *)(a2 + 8) = xmmword_18E1FD010;
  *(void *)(a2 + 32) = a2 + 40;
  if (*(_DWORD *)(a1 + 280)) {
    uint64_t v2 = a1 + 144;
  }
  else {
    uint64_t v2 = a1 + 8;
  }
  *(void *)&double result = sub_18DFE2F24(a2, v2).n128_u64[0];
  return result;
}

uint64_t sub_18E1CA8F4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1EDD19F08;
  long long v4 = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v4;
  long long v5 = *(_OWORD *)(a2 + 40);
  long long v6 = *(_OWORD *)(a2 + 56);
  long long v7 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v7;
  *(_OWORD *)(a1 + 56) = v6;
  *(_OWORD *)(a1 + 40) = v5;
  long long v8 = *(_OWORD *)(a2 + 104);
  long long v9 = *(_OWORD *)(a2 + 120);
  long long v10 = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
  *(_OWORD *)(a1 + 136) = v10;
  *(_OWORD *)(a1 + 120) = v9;
  *(_OWORD *)(a1 + 104) = v8;
  long long v11 = *(_OWORD *)(a2 + 168);
  long long v12 = *(_OWORD *)(a2 + 184);
  long long v13 = *(_OWORD *)(a2 + 200);
  *(_OWORD *)(a1 + 210) = *(_OWORD *)(a2 + 210);
  *(_OWORD *)(a1 + 200) = v13;
  *(_OWORD *)(a1 + 184) = v12;
  *(_OWORD *)(a1 + 168) = v11;
  if (*(char *)(a2 + 255) < 0)
  {
    sub_18DEDE668((unsigned char *)(a1 + 232), *(void **)(a2 + 232), *(void *)(a2 + 240));
  }
  else
  {
    long long v14 = *(_OWORD *)(a2 + 232);
    *(void *)(a1 + 248) = *(void *)(a2 + 248);
    *(_OWORD *)(a1 + 232) = v14;
  }
  uint64_t v15 = (unsigned char *)(a1 + 256);
  if (*(char *)(a2 + 279) < 0)
  {
    sub_18DEDE668(v15, *(void **)(a2 + 256), *(void *)(a2 + 264));
  }
  else
  {
    long long v16 = *(_OWORD *)(a2 + 256);
    *(void *)(a1 + 272) = *(void *)(a2 + 272);
    *(_OWORD *)uint64_t v15 = v16;
  }
  return a1;
}

void sub_18E1CAA0C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 255) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void *sub_18E1CAA28(void *a1, char a2)
{
  return sub_18DEDE7B0(a1, off_1E55B9F58[a2]);
}

void *sub_18E1CAA3C(void *a1, char a2)
{
  return sub_18DEDE7B0(a1, off_1E55B9F98[a2]);
}

void sub_18E1CAA50(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    long long v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 104;
        sub_18E1BDAAC(v3);
      }
      while ((void *)v3 != v1);
      long long v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *sub_18E1CAAB8(void *a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277) {
    sub_18DEE1FC8();
  }
  double result = (char *)sub_18E1BDB6C((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[104 * v4];
  return result;
}

uint64_t sub_18E1CAB10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_18E1CAB94(a4 + v7, a2 + v7);
      v7 += 104;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_18E1CAB70(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 104;
    do
    {
      sub_18E1BDAAC(v4 + v2);
      v2 -= 104;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E1CAB94(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_18E1CB374((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  long long v4 = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = v4;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  sub_18E1CAC3C((void *)(a1 + 40), *(void *)(a2 + 40), *(void *)(a2 + 48), 0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3));
  long long v5 = *(_OWORD *)(a2 + 64);
  long long v6 = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(_OWORD *)(a1 + 64) = v5;
  *(_OWORD *)(a1 + 80) = v6;
  return a1;
}

void sub_18E1CAC20(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_18E1CAC3C(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_18E1CACC4(result, a4);
    double result = (void *)sub_18E1CAD1C((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_18E1CACA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_18E1BDF18(&a9);
  _Unwind_Resume(a1);
}

char *sub_18E1CACC4(void *a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL) {
    sub_18DEE1FC8();
  }
  double result = (char *)sub_18E1BDD00((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[72 * v4];
  return result;
}

uint64_t sub_18E1CAD1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v12 = a4;
  uint64_t v13 = a4;
  v10[0] = a1;
  v10[1] = &v12;
  void v10[2] = &v13;
  char v11 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *(void *)uint64_t v4 = 0;
      *(void *)(v4 + 8) = 0;
      *(void *)(v4 + 16) = 0;
      sub_18E1CB374((void *)v4, *(const void **)v6, *(void *)(v6 + 8), (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 4);
      long long v7 = *(_OWORD *)(v6 + 24);
      long long v8 = *(_OWORD *)(v6 + 40);
      *(_OWORD *)(v4 + 56) = *(_OWORD *)(v6 + 56);
      *(_OWORD *)(v4 + 40) = v8;
      *(_OWORD *)(v4 + 24) = v7;
      uint64_t v4 = v13 + 72;
      v13 += 72;
      v6 += 72;
    }
    while (v6 != a3);
  }
  char v11 = 1;
  sub_18E1CADE8((uint64_t)v10);
  return v4;
}

void sub_18E1CADD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_18E1CADE8(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_18E1CAE20(a1);
  }
  return a1;
}

void sub_18E1CAE20(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  if (v1 != v2)
  {
    uint64_t v3 = **(void **)(a1 + 16);
    do
    {
      long long v5 = *(void **)(v3 - 72);
      v3 -= 72;
      uint64_t v4 = v5;
      if (v5)
      {
        *(void *)(v1 - 64) = v4;
        operator delete(v4);
      }
      uint64_t v1 = v3;
    }
    while (v3 != v2);
  }
}

uint64_t sub_18E1CAE70(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    for (uint64_t i = a1; i != a2; i += 104)
    {
      if (a3 != i)
      {
        sub_18E1CB078((char *)a3, *(char **)i, *(void *)(i + 8), (uint64_t)(*(void *)(i + 8) - *(void *)i) >> 4);
        long long v7 = (void **)(a3 + 40);
        uint64_t v6 = *(void *)(a3 + 40);
        *(_OWORD *)(a3 + 24) = *(_OWORD *)(i + 24);
        uint64_t v9 = *(void *)(i + 40);
        uint64_t v8 = *(void *)(i + 48);
        unint64_t v10 = 0x8E38E38E38E38E39 * ((v8 - v9) >> 3);
        uint64_t v11 = *(void *)(a3 + 56);
        if (0x8E38E38E38E38E39 * ((v11 - v6) >> 3) >= v10)
        {
          if (0x8E38E38E38E38E39 * ((*(void *)(a3 + 48) - v6) >> 3) >= v10)
          {
            uint64_t v17 = sub_18E1CB1C8(*(void *)(i + 40), *(void *)(i + 48), v6);
            uint64_t v18 = *(void *)(a3 + 48);
            if (v18 != v17)
            {
              uint64_t v19 = *(void *)(a3 + 48);
              do
              {
                long long v21 = *(void **)(v19 - 72);
                v19 -= 72;
                unsigned __int8 v20 = v21;
                if (v21)
                {
                  *(void *)(v18 - 64) = v20;
                  operator delete(v20);
                }
                uint64_t v18 = v19;
              }
              while (v19 != v17);
            }
            *(void *)(a3 + 48) = v17;
            goto LABEL_23;
          }
          uint64_t v16 = v9 + 8 * ((*(void *)(a3 + 48) - v6) >> 3);
          sub_18E1CB1C8(*(void *)(i + 40), v16, v6);
          uint64_t v15 = sub_18E1CAD1C(a3 + 56, v16, v8, *(void *)(a3 + 48));
        }
        else
        {
          if (v6)
          {
            sub_18E1BDF6C((uint64_t *)(a3 + 40));
            operator delete(*v7);
            uint64_t v11 = 0;
            double *v7 = 0;
            *(void *)(a3 + 48) = 0;
            *(void *)(a3 + 56) = 0;
          }
          if (v10 > 0x38E38E38E38E38ELL) {
            sub_18DEE1FC8();
          }
          unint64_t v12 = 0x8E38E38E38E38E39 * (v11 >> 3);
          uint64_t v13 = 2 * v12;
          if (2 * v12 <= v10) {
            uint64_t v13 = 0x8E38E38E38E38E39 * ((v8 - v9) >> 3);
          }
          if (v12 >= 0x1C71C71C71C71C7) {
            unint64_t v14 = 0x38E38E38E38E38ELL;
          }
          else {
            unint64_t v14 = v13;
          }
          sub_18E1CACC4((void *)(a3 + 40), v14);
          uint64_t v15 = sub_18E1CAD1C(a3 + 56, v9, v8, *(void *)(a3 + 48));
        }
        *(void *)(a3 + 48) = v15;
      }
LABEL_23:
      long long v22 = *(_OWORD *)(i + 64);
      long long v23 = *(_OWORD *)(i + 80);
      *(void *)(a3 + 96) = *(void *)(i + 96);
      *(_OWORD *)(a3 + 64) = v22;
      *(_OWORD *)(a3 + 80) = v23;
      a3 += 104;
    }
  }
  return a3;
}

void sub_18E1CB068(_Unwind_Exception *a1)
{
  *(void *)(v1 + 48) = v2;
  _Unwind_Resume(a1);
}

void sub_18E1CB070(_Unwind_Exception *a1)
{
  *(void *)(v1 + 48) = v2;
  _Unwind_Resume(a1);
}

char *sub_18E1CB078(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  long long v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60) {
      sub_18DEE1FC8();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    double result = sub_18E1CB184(v7, v11);
    uint64_t v13 = (char *)v7[1];
    unint64_t v12 = (void **)(v7 + 1);
    uint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  unint64_t v12 = (void **)(result + 8);
  unint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    double result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    double result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *unint64_t v12 = &v9[v17];
  return result;
}

char *sub_18E1CB184(void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    sub_18DEE1FC8();
  }
  double result = (char *)sub_18DFF7B64((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

uint64_t sub_18E1CB1C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      if (v5 != a3) {
        sub_18E1CB078((char *)a3, *(char **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 4);
      }
      long long v6 = *(_OWORD *)(v5 + 24);
      long long v7 = *(_OWORD *)(v5 + 40);
      *(_OWORD *)(a3 + 56) = *(_OWORD *)(v5 + 56);
      *(_OWORD *)(a3 + 40) = v7;
      *(_OWORD *)(a3 + 24) = v6;
      v5 += 72;
      a3 += 72;
    }
    while (v5 != a2);
  }
  return a3;
}

void *sub_18E1CB248(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_18E1CAAB8(result, a4);
    double result = (void *)sub_18E1CAB10((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_18E1CB2B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_18E1BEB28(&a9);
  _Unwind_Resume(a1);
}

__n128 sub_18E1CB2D0(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(unsigned char *)(a1 + 24))
    {
      sub_18E1CAA50((void **)a1);
      __n128 result = *a2;
      *(__n128 *)a1 = *a2;
      *(void *)(a1 + 16) = a2[1].n128_u64[0];
      a2->n128_u64[0] = 0;
      a2->n128_u64[1] = 0;
      a2[1].n128_u64[0] = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v5 = (void **)a1;
    sub_18E1BEB28(&v5);
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    __n128 result = *a2;
    *(__n128 *)a1 = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return result;
}

void *sub_18E1CB374(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    __n128 result = sub_18E1CB184(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_18E1CB3D4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E1CB3F0(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x4EC4EC4EC4EC4EC5 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x276276276276276) {
    sub_18DEE1FC8();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x4EC4EC4EC4EC4EC5 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x13B13B13B13B13BLL) {
    unint64_t v9 = 0x276276276276276;
  }
  else {
    unint64_t v9 = v5;
  }
  size_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_18E1BDB6C(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v13 = v10;
  unint64_t v14 = &v10[104 * v4];
  uint64_t v16 = &v10[104 * v9];
  sub_18E1CB510((uint64_t)v14, a2);
  unint64_t v15 = v14 + 104;
  sub_18E1BDAF4(a1, &v13);
  uint64_t v11 = a1[1];
  sub_18E1BDC38((uint64_t)&v13);
  return v11;
}

void sub_18E1CB4FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_18E1BDC38((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_18E1CB510(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_18E1CB374((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  long long v4 = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = v4;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  sub_18E1CAC3C((void *)(a1 + 40), *(void *)(a2 + 40), *(void *)(a2 + 48), 0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3));
  long long v5 = *(_OWORD *)(a2 + 64);
  long long v6 = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(_OWORD *)(a1 + 64) = v5;
  *(_OWORD *)(a1 + 80) = v6;
  return a1;
}

void sub_18E1CB59C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_18E1CB5B8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 176) == *(unsigned __int8 *)(a2 + 176))
  {
    if (*(unsigned char *)(a1 + 176))
    {
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
      *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
      *(_WORD *)(a1 + 64) = *(_WORD *)(a2 + 64);
      uint64_t v2 = (_OWORD *)(a1 + 72);
      uint64_t v3 = (_OWORD *)(a2 + 72);
      if (*(unsigned __int8 *)(a1 + 104) == *(unsigned __int8 *)(a2 + 104))
      {
        if (*(unsigned char *)(a1 + 104))
        {
          *uint64_t v2 = *v3;
          *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
        }
      }
      else if (*(unsigned char *)(a1 + 104))
      {
        *(unsigned char *)(a1 + 104) = 0;
      }
      else
      {
        long long v6 = *(_OWORD *)(a2 + 88);
        *uint64_t v2 = *v3;
        *(_OWORD *)(a1 + 88) = v6;
        *(unsigned char *)(a1 + 104) = 1;
      }
      __n128 result = *(__n128 *)(a2 + 112);
      long long v7 = *(_OWORD *)(a2 + 128);
      long long v8 = *(_OWORD *)(a2 + 144);
      *(_OWORD *)(a1 + 153) = *(_OWORD *)(a2 + 153);
      *(_OWORD *)(a1 + 128) = v7;
      *(_OWORD *)(a1 + 144) = v8;
      *(__n128 *)(a1 + 112) = result;
    }
  }
  else if (*(unsigned char *)(a1 + 176))
  {
    *(unsigned char *)(a1 + 176) = 0;
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 16) = v4;
    *(unsigned char *)(a1 + 72) = 0;
    *(unsigned char *)(a1 + 104) = 0;
    *(unsigned char *)(a1 + 112) = 0;
    *(unsigned char *)(a1 + 120) = 0;
    *(unsigned char *)(a1 + 128) = 0;
    *(unsigned char *)(a1 + 136) = 0;
    *(unsigned char *)(a1 + 144) = 0;
    *(unsigned char *)(a1 + 168) = 0;
    result.n128_u64[0] = 0;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_WORD *)(a1 + 64) = 0;
    *(unsigned char *)(a1 + 176) = 1;
  }
  return result;
}

void sub_18E1CB6A8(uint64_t a1)
{
  *(void *)a1 = &unk_1EDD1A0F0;
  *(void *)(a1 + 4304) = &unk_1EDD0A448;
  *(void *)(a1 + 4448) = &unk_1EDD17478;
  *(void *)(a1 + 4312) = &unk_1EDD17478;
  *(void *)(a1 + 3112) = &unk_1EDD17478;
  sub_18E1CB898((void *)(a1 + 3056));
  if (*(unsigned char *)(a1 + 2632))
  {
    *(void *)(a1 + 2544) = &unk_1EDD1A160;
    uint64_t v2 = (void **)(a1 + 2552);
    sub_18E1BEB28(&v2);
  }
  if (*(unsigned char *)(a1 + 2536))
  {
    *(void *)(a1 + 2448) = &unk_1EDD1A160;
    uint64_t v2 = (void **)(a1 + 2456);
    sub_18E1BEB28(&v2);
  }
  if (*(unsigned char *)(a1 + 1672))
  {
    *(void *)(a1 + 1440) = &unk_1EDD1A090;
    if (*(char *)(a1 + 1527) < 0) {
      operator delete(*(void **)(a1 + 1504));
    }
  }
  if (*(unsigned char *)(a1 + 1360)) {
    trackrun::VisitEvent::~VisitEvent((void **)(a1 + 1080));
  }
  if (*(unsigned char *)(a1 + 704))
  {
    uint64_t v2 = (void **)(a1 + 680);
    sub_18E1BEB28(&v2);
  }
  if (*(unsigned char *)(a1 + 672))
  {
    uint64_t v2 = (void **)(a1 + 648);
    sub_18E1BEB28(&v2);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 544));
  if (*(char *)(a1 + 535) < 0) {
    operator delete(*(void **)(a1 + 512));
  }
  if (*(char *)(a1 + 511) < 0) {
    operator delete(*(void **)(a1 + 488));
  }
  cnframework::ActiveObjectBase::~ActiveObjectBase((cnframework::ActiveObjectBase *)a1);
}

uint64_t sub_18E1CB898(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 25;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 51;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    long long v7 = *v2++;
    operator delete(v7);
  }

  return sub_18DEE1F78((uint64_t)a1);
}

void *sub_18E1CB940(uint64_t a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v10 = operator new(0x20uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  void v10[3] = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_18DFF4F38(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_18E1CBB40(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

BOOL sub_18E1CBB54(double *a1, uint64_t a2)
{
  uint64_t v2 = (double *)(a2 - 16);
  if ((unint64_t)(a2 - (void)a1) < 0x40 || v2 == a1) {
    return 0;
  }
  double v4 = 0.0;
  unint64_t v5 = (double *)(a2 - 16);
  do
  {
    double v6 = *(v5 - 2);
    v5 -= 2;
    double v4 = v4 + (*v2 + v6) * (v2[1] - *(v2 - 1));
    uint64_t v2 = v5;
  }
  while (v5 != a1);
  return v4 * 0.5 > 0.0;
}

BOOL sub_18E1CBBB4(double *a1, double *a2)
{
  uint64_t v2 = a2;
  if (a2 == a1)
  {
    unint64_t v5 = a2;
  }
  else
  {
    double v4 = a2 - 2;
    unint64_t v5 = a1;
    if (a2 - 2 != a1)
    {
      double v6 = *(a2 - 2);
      double v7 = fabs(v6);
      unint64_t v5 = a2 - 2;
      while (1)
      {
        double v8 = *(v4 - 2);
        v4 -= 2;
        double v9 = v8;
        if (v8 != v6)
        {
          if ((*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
            || (*(void *)(a2 - 2) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            break;
          }
          double v11 = vabdd_f64(v9, v6);
          double v12 = fabs(v9);
          if (v12 < v7) {
            double v12 = v7;
          }
          double v13 = v12 >= 1.0 ? v12 * 2.22044605e-16 : 2.22044605e-16;
          if (v11 > v13) {
            break;
          }
        }
        double v14 = *(v5 - 1);
        double v15 = *(a2 - 1);
        if (v14 != v15)
        {
          if ((*(void *)&v14 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
            || (*(void *)&v15 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            break;
          }
          double v17 = vabdd_f64(v14, v15);
          double v18 = fabs(v14);
          double v19 = fabs(v15);
          if (v18 < v19) {
            double v18 = v19;
          }
          double v20 = v18 >= 1.0 ? v18 * 2.22044605e-16 : 2.22044605e-16;
          if (v17 > v20) {
            break;
          }
        }
        unint64_t v5 = v4;
        if (v4 == a1)
        {
          unint64_t v5 = a1;
          break;
        }
      }
    }
    long long v21 = a1 + 2;
    if (a1 + 2 != a2)
    {
      double v22 = *a1;
      double v23 = fabs(*a1);
      while (1)
      {
        double v24 = *v21;
        if (*v21 != v22)
        {
          if ((*(void *)&v24 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
            || (*(void *)a1 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            break;
          }
          double v26 = vabdd_f64(v24, v22);
          double v27 = fabs(v24);
          if (v27 < v23) {
            double v27 = v23;
          }
          double v28 = v27 >= 1.0 ? v27 * 2.22044605e-16 : 2.22044605e-16;
          if (v26 > v28) {
            break;
          }
        }
        double v29 = v21[1];
        double v30 = a1[1];
        if (v29 != v30)
        {
          if ((*(void *)&v29 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
            || (*(void *)&v30 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            break;
          }
          double v32 = vabdd_f64(v29, v30);
          double v33 = fabs(v29);
          double v34 = fabs(v30);
          if (v33 < v34) {
            double v33 = v34;
          }
          double v35 = v33 >= 1.0 ? v33 * 2.22044605e-16 : 2.22044605e-16;
          if (v32 > v35) {
            break;
          }
        }
        v21 += 2;
        if (v21 == a2) {
          goto LABEL_58;
        }
      }
      uint64_t v2 = v21;
    }
  }
LABEL_58:
  double v46 = 1.0;
  double v36 = sub_18E12FB7C(v2, a1, v5 - 2, &v46);
  if (v36 != 0.0
    && ((*(void *)&v36 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || fabs(v36) > v46 * 2.22044605e-16))
  {
    return 0;
  }
  double v37 = a1[1];
  double v38 = v2[1] - v37;
  double v39 = *a1 - *v2;
  double v40 = -v38;
  if (v39 == 0.0) {
    goto LABEL_64;
  }
  if (COERCE_UNSIGNED_INT64(fabs(*a1 - *v2)) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v43 = fabs(v39);
    double v44 = 2.22044605e-16;
    if (v43 >= 1.0) {
      double v44 = v43 * 2.22044605e-16;
    }
    if (v43 <= v44)
    {
LABEL_64:
      if (v38 == 0.0) {
        return 1;
      }
      if (COERCE_UNSIGNED_INT64(fabs(v2[1] - v37)) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v41 = fabs(v40);
        double v42 = 2.22044605e-16;
        if (v41 >= 1.0) {
          double v42 = v41 * 2.22044605e-16;
        }
        if (v41 <= v42) {
          return 1;
        }
      }
    }
  }
  return v37 * v38 - v39 * *a1 + *(v5 - 1) * v40 + v39 * *(v5 - 2) <= 0.0;
}

uint64_t sub_18E1CBEE0(uint64_t result)
{
  if (result == 2)
  {
    exceptiouint64_t n = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    exception->__vftable = 0;
    uint64_t v2 = sub_18E1CBF90(exception);
    unint64_t v3 = (struct type_info *)&unk_1EDD04F40;
    double v4 = std::exception::~exception;
    goto LABEL_6;
  }
  if (result == 1)
  {
    unint64_t v5 = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v5->__vftable = 0;
    uint64_t v2 = sub_18E1CBF58(v5);
    unint64_t v3 = (struct type_info *)&unk_1EDD04F28;
    double v4 = std::exception::~exception;
LABEL_6:
    __cxa_throw(v2, v3, (void (*)(void *))v4);
  }
  return result;
}

std::bad_cast *sub_18E1CBF58(std::bad_cast *a1)
{
  __n128 result = std::bad_cast::bad_cast(a1);
  result->__vftable = (std::bad_cast_vtbl *)&unk_1EDD13668;
  return result;
}

std::bad_cast *sub_18E1CBF90(std::bad_cast *a1)
{
  __n128 result = std::bad_cast::bad_cast(a1);
  result->__vftable = (std::bad_cast_vtbl *)&unk_1EDD13690;
  return result;
}

void sub_18E1CBFC8(std::exception *a1)
{
  std::exception::~exception(a1);

  JUMPOUT(0x192FA6240);
}

const char *sub_18E1CC000()
{
  return "bad numeric conversion: negative overflow";
}

void sub_18E1CC00C(std::exception *a1)
{
  std::exception::~exception(a1);

  JUMPOUT(0x192FA6240);
}

const char *sub_18E1CC044()
{
  return "bad numeric conversion: positive overflow";
}

void *sub_18E1CC050(unint64_t a1)
{
  if (a1 >= 0x222222222222223) {
    sub_18DEDF7D4();
  }
  return operator new(120 * a1);
}

uint64_t sub_18E1CC098(void *a1, uint64_t *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *a1;
  uint64_t v7 = a1[2];
  if ((uint64_t)*a1 >= 0) {
    uint64_t v8 = *a1;
  }
  else {
    uint64_t v8 = v6 + 1;
  }
  if (v7 >= 0) {
    uint64_t v9 = a1[2];
  }
  else {
    uint64_t v9 = v7 + 1;
  }
  uint64_t v10 = v9 >> 1;
  long long v11 = *((_OWORD *)a1 + 1);
  int v12 = v7 - 2 * v10 + v6 - 2 * (v8 >> 1);
  long long v56 = *(_OWORD *)a1;
  uint64_t v58 = *((void *)&v11 + 1);
  *((void *)&v55[0] + 1) = *((void *)&v56 + 1);
  v55[1] = v11;
  uint64_t v57 = v10 + (v8 >> 1) + ((v12 + ((v12 & 0x80) >> 7)) << 24 >> 25);
  *(void *)&v55[0] = v57;
  long long v52 = 0;
  unint64_t v53 = 0;
  uint64_t v54 = 0;
  long long __p = 0;
  long long v50 = 0;
  uint64_t v51 = 0;
  double v46 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  sub_18E1CC5B8(&v56, v55, a2, &v52, &__p, (void **)&v46);
  double v13 = v46;
  double v14 = v47;
  if (v46 != v47)
  {
    v45[0] = (__int128)vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
    v45[1] = (__int128)vdupq_n_s64(0x8000000000000000);
    double v15 = v46;
    do
    {
      uint64_t v16 = *(void *)v15;
      v15 += 8;
      sub_18E1CC524((uint64_t *)v45, (uint64_t *)(v16 + 32));
    }
    while (v15 != v14);
    double v17 = v13;
    if (a3 > 0x63 || (double v17 = v13, (unint64_t)(v14 - v13) < 0x79))
    {
LABEL_31:
      double v24 = v17 + 8;
      if (v17 + 8 != v14)
      {
        double v18 = v17 + 8;
        while (1)
        {
          uint64_t v19 = *(void *)v17;
          uint64_t v20 = *v18;
          if (*(void *)(*(void *)v17 + 48) >= *(void *)(*v18 + 32)
            && *(void *)(v19 + 32) <= *(void *)(v20 + 48))
          {
            BOOL v21 = *(void *)(v19 + 56) >= *(void *)(v20 + 40) && *(void *)(v19 + 40) <= *(void *)(v20 + 56);
            BOOL v22 = v21 && *(unsigned char *)(v19 + 96) == 0;
            BOOL v23 = v22 && *(unsigned char *)(v20 + 96) == 0;
            if (v23
              && !sub_18E1CE310(*(_DWORD *)(a4 + 40), **(double ***)a4, *(double **)(*(void *)a4 + 8), (int *)v19, *(_DWORD *)(a4 + 40), **(double ***)a4, *(double **)(*(void *)a4 + 8), (int *)v20, *(unsigned char *)(a4 + 44), *(void *)(a4 + 8), *(uint64_t **)(a4 + 16), *(uint64_t **)(a4 + 24), *(BOOL **)(a4 + 32)))
            {
              goto LABEL_37;
            }
          }
          if (++v18 == (void *)v14)
          {
            v17 += 8;
            if (v24 == v14) {
              break;
            }
            goto LABEL_31;
          }
        }
      }
    }
    else if (!sub_18E1CCA20(v45, (uint64_t *)&v46, a3 + 1, a4))
    {
      goto LABEL_37;
    }
    if (!sub_18E1CC8B0(v45, (uint64_t *)&v46, (uint64_t *)&v52, a3, a4)
      || (sub_18E1CC8B0(v45, (uint64_t *)&v46, (uint64_t *)&__p, a3, a4) & 1) == 0)
    {
      goto LABEL_37;
    }
  }
  double v26 = (char *)v52;
  long long v25 = v53;
  if (a3 > 0x63 || (unint64_t)(v53 - (unsigned char *)v52) < 0x79)
  {
    if (v52 != v53)
    {
LABEL_46:
      double v29 = v26 + 8;
      if (v26 + 8 != v25)
      {
        double v30 = v26 + 8;
        while (1)
        {
          uint64_t v31 = *(void *)v26;
          uint64_t v32 = *(void *)v30;
          if (*(void *)(*(void *)v26 + 48) >= *(void *)(*(void *)v30 + 32)
            && *(void *)(v31 + 32) <= *(void *)(v32 + 48))
          {
            BOOL v33 = *(void *)(v31 + 56) >= *(void *)(v32 + 40) && *(void *)(v31 + 40) <= *(void *)(v32 + 56);
            BOOL v34 = v33 && *(unsigned char *)(v31 + 96) == 0;
            BOOL v35 = v34 && *(unsigned char *)(v32 + 96) == 0;
            if (v35
              && !sub_18E1CE310(*(_DWORD *)(a4 + 40), **(double ***)a4, *(double **)(*(void *)a4 + 8), (int *)v31, *(_DWORD *)(a4 + 40), **(double ***)a4, *(double **)(*(void *)a4 + 8), (int *)v32, *(unsigned char *)(a4 + 44), *(void *)(a4 + 8), *(uint64_t **)(a4 + 16), *(uint64_t **)(a4 + 24), *(BOOL **)(a4 + 32)))
            {
              goto LABEL_37;
            }
          }
          v30 += 8;
          if (v30 == v25)
          {
            v26 += 8;
            if (v29 != v25) {
              goto LABEL_46;
            }
            break;
          }
        }
      }
    }
  }
  else if (!sub_18E1CCA20(&v56, (uint64_t *)&v52, a3 + 1, a4))
  {
LABEL_37:
    uint64_t v27 = 0;
    goto LABEL_38;
  }
  double v37 = (char *)__p;
  double v36 = v50;
  if (a3 > 0x63 || (unint64_t)(v50 - (unsigned char *)__p) < 0x79)
  {
    if (__p != v50)
    {
LABEL_68:
      double v38 = v37 + 8;
      if (v37 + 8 != v36)
      {
        double v39 = v37 + 8;
        while (1)
        {
          uint64_t v40 = *(void *)v37;
          uint64_t v41 = *(void *)v39;
          if (*(void *)(*(void *)v37 + 48) >= *(void *)(*(void *)v39 + 32)
            && *(void *)(v40 + 32) <= *(void *)(v41 + 48))
          {
            BOOL v42 = *(void *)(v40 + 56) >= *(void *)(v41 + 40) && *(void *)(v40 + 40) <= *(void *)(v41 + 56);
            BOOL v43 = v42 && *(unsigned char *)(v40 + 96) == 0;
            BOOL v44 = v43 && *(unsigned char *)(v41 + 96) == 0;
            if (v44
              && !sub_18E1CE310(*(_DWORD *)(a4 + 40), **(double ***)a4, *(double **)(*(void *)a4 + 8), (int *)v40, *(_DWORD *)(a4 + 40), **(double ***)a4, *(double **)(*(void *)a4 + 8), (int *)v41, *(unsigned char *)(a4 + 44), *(void *)(a4 + 8), *(uint64_t **)(a4 + 16), *(uint64_t **)(a4 + 24), *(BOOL **)(a4 + 32)))
            {
              goto LABEL_37;
            }
          }
          v39 += 8;
          if (v39 == v36)
          {
            uint64_t v27 = 1;
            v37 += 8;
            if (v38 != v36) {
              goto LABEL_68;
            }
            goto LABEL_38;
          }
        }
      }
    }
    uint64_t v27 = 1;
  }
  else
  {
    uint64_t v27 = sub_18E1CCA20(v55, (uint64_t *)&__p, a3 + 1, a4);
  }
LABEL_38:
  if (v13) {
    operator delete(v13);
  }
  if (__p) {
    operator delete(__p);
  }
  if (v52) {
    operator delete(v52);
  }
  return v27;
}

void sub_18E1CC4DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,uint64_t a25,void *a26)
{
  if (v26) {
    operator delete(v26);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a26) {
    operator delete(a26);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_18E1CC524(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *result;
  if (*a2 < *result)
  {
    *__n128 result = v2;
    uint64_t v3 = v2;
  }
  uint64_t v4 = result[2];
  if (v2 > v4)
  {
    result[2] = v2;
    uint64_t v4 = v2;
  }
  uint64_t v5 = a2[1];
  uint64_t v6 = result[1];
  if (v5 < v6)
  {
    result[1] = v5;
    uint64_t v6 = v5;
  }
  uint64_t v7 = result[3];
  if (v5 > v7)
  {
    result[3] = v5;
    uint64_t v7 = v5;
  }
  uint64_t v8 = a2[2];
  if (v8 < v3) {
    *__n128 result = v8;
  }
  if (v8 > v4) {
    result[2] = v8;
  }
  uint64_t v9 = a2[3];
  if (v9 < v6) {
    result[1] = v9;
  }
  if (v9 > v7) {
    result[3] = v9;
  }
  return result;
}

void sub_18E1CC5B8(void *a1, void *a2, uint64_t *a3, void **a4, void **a5, void **a6)
{
  uint64_t v6 = *a3;
  if (*a3 != a3[1])
  {
    while (1)
    {
      double v13 = *(void **)v6;
      uint64_t v14 = *(void *)(*(void *)v6 + 32);
      if (a1[2] >= v14 && *a1 <= v13[6])
      {
        BOOL v16 = a1[3] >= v13[5] && a1[1] <= v13[7];
        BOOL v15 = v16;
      }
      else
      {
        BOOL v15 = 0;
      }
      if (a2[2] >= v14 && *a2 <= v13[6]) {
        break;
      }
      if (v15) {
        goto LABEL_14;
      }
LABEL_75:
      v6 += 8;
      if (v6 == a3[1]) {
        return;
      }
    }
    BOOL v21 = a2[3] < v13[5] || a2[1] > v13[7];
    if (v15 && !v21)
    {
      BOOL v23 = a6[1];
      unint64_t v22 = (unint64_t)a6[2];
      if ((unint64_t)v23 >= v22)
      {
        uint64_t v37 = ((char *)v23 - (unsigned char *)*a6) >> 3;
        if ((unint64_t)(v37 + 1) >> 61) {
          goto LABEL_77;
        }
        uint64_t v38 = v22 - (void)*a6;
        uint64_t v39 = v38 >> 2;
        if (v38 >> 2 <= (unint64_t)(v37 + 1)) {
          uint64_t v39 = v37 + 1;
        }
        if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v40 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v40 = v39;
        }
        if (v40)
        {
          unint64_t v40 = (unint64_t)sub_18DEE2FBC(v40);
          double v13 = *(void **)v6;
        }
        else
        {
          uint64_t v41 = 0;
        }
        BOOL v42 = (void *)(v40 + 8 * v37);
        void *v42 = v13;
        double v24 = v42 + 1;
        BOOL v44 = (char *)*a6;
        BOOL v43 = (char *)a6[1];
        if (v43 != *a6)
        {
          do
          {
            uint64_t v45 = *((void *)v43 - 1);
            v43 -= 8;
            *--BOOL v42 = v45;
          }
          while (v43 != v44);
          BOOL v43 = (char *)*a6;
        }
        *a6 = v42;
        a6[1] = v24;
        a6[2] = (void *)(v40 + 8 * v41);
        if (v43) {
          operator delete(v43);
        }
      }
      else
      {
        *BOOL v23 = v13;
        double v24 = v23 + 1;
      }
      a6[1] = v24;
      goto LABEL_75;
    }
    if (!v15)
    {
      if (!v21)
      {
        uint64_t v31 = a5[1];
        unint64_t v30 = (unint64_t)a5[2];
        if ((unint64_t)v31 >= v30)
        {
          uint64_t v46 = ((char *)v31 - (unsigned char *)*a5) >> 3;
          if ((unint64_t)(v46 + 1) >> 61) {
LABEL_77:
          }
            sub_18DEE1FC8();
          uint64_t v47 = v30 - (void)*a5;
          uint64_t v48 = v47 >> 2;
          if (v47 >> 2 <= (unint64_t)(v46 + 1)) {
            uint64_t v48 = v46 + 1;
          }
          if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v49 = v48;
          }
          if (v49)
          {
            unint64_t v49 = (unint64_t)sub_18DEE2FBC(v49);
            double v13 = *(void **)v6;
          }
          else
          {
            uint64_t v50 = 0;
          }
          uint64_t v51 = (void *)(v49 + 8 * v46);
          void *v51 = v13;
          uint64_t v32 = v51 + 1;
          unint64_t v53 = (char *)*a5;
          long long v52 = (char *)a5[1];
          if (v52 != *a5)
          {
            do
            {
              uint64_t v54 = *((void *)v52 - 1);
              v52 -= 8;
              *--uint64_t v51 = v54;
            }
            while (v52 != v53);
            long long v52 = (char *)*a5;
          }
          *a5 = v51;
          a5[1] = v32;
          a5[2] = (void *)(v49 + 8 * v50);
          if (v52) {
            operator delete(v52);
          }
        }
        else
        {
          *uint64_t v31 = v13;
          uint64_t v32 = v31 + 1;
        }
        a5[1] = v32;
      }
      goto LABEL_75;
    }
LABEL_14:
    double v18 = a4[1];
    unint64_t v17 = (unint64_t)a4[2];
    if ((unint64_t)v18 >= v17)
    {
      uint64_t v25 = ((char *)v18 - (unsigned char *)*a4) >> 3;
      if ((unint64_t)(v25 + 1) >> 61) {
        goto LABEL_77;
      }
      uint64_t v26 = v17 - (void)*a4;
      uint64_t v27 = v26 >> 2;
      if (v26 >> 2 <= (unint64_t)(v25 + 1)) {
        uint64_t v27 = v25 + 1;
      }
      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v28 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v28 = v27;
      }
      if (v28)
      {
        unint64_t v28 = (unint64_t)sub_18DEE2FBC(v28);
        double v13 = *(void **)v6;
      }
      else
      {
        uint64_t v29 = 0;
      }
      BOOL v33 = (void *)(v28 + 8 * v25);
      *BOOL v33 = v13;
      uint64_t v19 = v33 + 1;
      BOOL v35 = (char *)*a4;
      BOOL v34 = (char *)a4[1];
      if (v34 != *a4)
      {
        do
        {
          uint64_t v36 = *((void *)v34 - 1);
          v34 -= 8;
          *--BOOL v33 = v36;
        }
        while (v34 != v35);
        BOOL v34 = (char *)*a4;
      }
      *a4 = v33;
      a4[1] = v19;
      a4[2] = (void *)(v28 + 8 * v29);
      if (v34) {
        operator delete(v34);
      }
    }
    else
    {
      *double v18 = v13;
      uint64_t v19 = v18 + 1;
    }
    a4[1] = v19;
    goto LABEL_75;
  }
}

uint64_t sub_18E1CC8B0(long long *a1, uint64_t *a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v9 = *a2;
  uint64_t v8 = a2[1];
  if ((unint64_t)(v8 - *a2) < 0x80 || a4 > 0x63 || (unint64_t)(a3[1] - *a3) < 0x79)
  {
    if (v9 != v8)
    {
      uint64_t v12 = a3[1];
      if (*a3 != v12)
      {
        do
        {
          uint64_t v13 = *a3;
          if (*a3 != v12)
          {
            do
            {
              uint64_t v14 = *(void *)v9;
              uint64_t v15 = *(void *)v13;
              if (*(void *)(*(void *)v9 + 48) >= *(void *)(*(void *)v13 + 32)
                && *(void *)(v14 + 32) <= *(void *)(v15 + 48))
              {
                BOOL v16 = *(void *)(v14 + 56) >= *(void *)(v15 + 40) && *(void *)(v14 + 40) <= *(void *)(v15 + 56);
                BOOL v17 = v16 && *(unsigned char *)(v14 + 96) == 0;
                if (v17 && *(unsigned char *)(v15 + 96) == 0)
                {
                  uint64_t result = sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v14, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v15, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32));
                  if (!result) {
                    return result;
                  }
                  uint64_t v12 = a3[1];
                }
              }
              v13 += 8;
            }
            while (v13 != v12);
            uint64_t v8 = a2[1];
          }
          v9 += 8;
        }
        while (v9 != v8);
      }
    }
    return 1;
  }
  else
  {
    unint64_t v10 = a4 + 1;
    return sub_18E1CD994(a1, a2, a3, v10, a5);
  }
}

uint64_t sub_18E1CCA20(long long *a1, uint64_t *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7 = *((void *)a1 + 2);
  uint64_t v6 = *((void *)a1 + 3);
  uint64_t v8 = *((void *)a1 + 1);
  if (v8 >= 0) {
    uint64_t v9 = *((void *)a1 + 1);
  }
  else {
    uint64_t v9 = v8 + 1;
  }
  int v10 = v8 - 2 * (v9 >> 1);
  if (v6 >= 0) {
    uint64_t v11 = *((void *)a1 + 3);
  }
  else {
    uint64_t v11 = v6 + 1;
  }
  long long v12 = *a1;
  long long v56 = a1[1];
  long long v57 = v12;
  v55[0] = v12;
  uint64_t v58 = v7;
  uint64_t v59 = (v11 >> 1)
      + (v9 >> 1)
      + ((int)((v6
              - 2 * (v11 >> 1)
              + v10
              + (((v6 - 2 * (v11 >> 1) + v10) & 0x80) >> 7)) << 24) >> 25);
  v55[1] = v59;
  long long v52 = 0;
  unint64_t v53 = 0;
  uint64_t v54 = 0;
  long long __p = 0;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  sub_18E1CC5B8(&v57, v55, a2, &v52, &__p, (void **)&v46);
  uint64_t v13 = v46;
  uint64_t v14 = v47;
  if (v46 != v47)
  {
    v45[0] = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
    v45[1] = vdupq_n_s64(0x8000000000000000);
    uint64_t v15 = v46;
    do
    {
      uint64_t v16 = *(void *)v15;
      v15 += 8;
      sub_18E1CC524((uint64_t *)v45, (uint64_t *)(v16 + 32));
    }
    while (v15 != v14);
    BOOL v17 = v13;
    if (a3 > 0x63 || (BOOL v17 = v13, (unint64_t)(v14 - v13) < 0x79))
    {
LABEL_31:
      double v24 = v17 + 8;
      if (v17 + 8 != v14)
      {
        double v18 = v17 + 8;
        while (1)
        {
          uint64_t v19 = *(void *)v17;
          uint64_t v20 = *v18;
          if (*(void *)(*(void *)v17 + 48) >= *(void *)(*v18 + 32)
            && *(void *)(v19 + 32) <= *(void *)(v20 + 48))
          {
            BOOL v21 = *(void *)(v19 + 56) >= *(void *)(v20 + 40) && *(void *)(v19 + 40) <= *(void *)(v20 + 56);
            BOOL v22 = v21 && *(unsigned char *)(v19 + 96) == 0;
            BOOL v23 = v22 && *(unsigned char *)(v20 + 96) == 0;
            if (v23
              && !sub_18E1CE310(*(_DWORD *)(a4 + 40), **(double ***)a4, *(double **)(*(void *)a4 + 8), (int *)v19, *(_DWORD *)(a4 + 40), **(double ***)a4, *(double **)(*(void *)a4 + 8), (int *)v20, *(unsigned char *)(a4 + 44), *(void *)(a4 + 8), *(uint64_t **)(a4 + 16), *(uint64_t **)(a4 + 24), *(BOOL **)(a4 + 32)))
            {
              goto LABEL_37;
            }
          }
          if (++v18 == (void *)v14)
          {
            v17 += 8;
            if (v24 == v14) {
              break;
            }
            goto LABEL_31;
          }
        }
      }
    }
    else if (!sub_18E1CC098(v45, &v46, a3 + 1, a4))
    {
      goto LABEL_37;
    }
    if (!sub_18E1CCEAC((uint64_t *)v45, (uint64_t *)&v46, (uint64_t *)&v52, a3, a4)
      || (sub_18E1CCEAC((uint64_t *)v45, (uint64_t *)&v46, (uint64_t *)&__p, a3, a4) & 1) == 0)
    {
      goto LABEL_37;
    }
  }
  uint64_t v26 = (char *)v52;
  uint64_t v25 = v53;
  if (a3 > 0x63 || (unint64_t)(v53 - (unsigned char *)v52) < 0x79)
  {
    if (v52 != v53)
    {
LABEL_46:
      uint64_t v29 = v26 + 8;
      if (v26 + 8 != v25)
      {
        unint64_t v30 = v26 + 8;
        while (1)
        {
          uint64_t v31 = *(void *)v26;
          uint64_t v32 = *(void *)v30;
          if (*(void *)(*(void *)v26 + 48) >= *(void *)(*(void *)v30 + 32)
            && *(void *)(v31 + 32) <= *(void *)(v32 + 48))
          {
            BOOL v33 = *(void *)(v31 + 56) >= *(void *)(v32 + 40) && *(void *)(v31 + 40) <= *(void *)(v32 + 56);
            BOOL v34 = v33 && *(unsigned char *)(v31 + 96) == 0;
            BOOL v35 = v34 && *(unsigned char *)(v32 + 96) == 0;
            if (v35
              && !sub_18E1CE310(*(_DWORD *)(a4 + 40), **(double ***)a4, *(double **)(*(void *)a4 + 8), (int *)v31, *(_DWORD *)(a4 + 40), **(double ***)a4, *(double **)(*(void *)a4 + 8), (int *)v32, *(unsigned char *)(a4 + 44), *(void *)(a4 + 8), *(uint64_t **)(a4 + 16), *(uint64_t **)(a4 + 24), *(BOOL **)(a4 + 32)))
            {
              goto LABEL_37;
            }
          }
          v30 += 8;
          if (v30 == v25)
          {
            v26 += 8;
            if (v29 != v25) {
              goto LABEL_46;
            }
            break;
          }
        }
      }
    }
  }
  else if (!sub_18E1CC098(&v57, &v52, a3 + 1, a4))
  {
LABEL_37:
    uint64_t v27 = 0;
    goto LABEL_38;
  }
  uint64_t v37 = (char *)__p;
  uint64_t v36 = v50;
  if (a3 > 0x63 || (unint64_t)(v50 - (unsigned char *)__p) < 0x79)
  {
    if (__p != v50)
    {
LABEL_68:
      uint64_t v38 = v37 + 8;
      if (v37 + 8 != v36)
      {
        uint64_t v39 = v37 + 8;
        while (1)
        {
          uint64_t v40 = *(void *)v37;
          uint64_t v41 = *(void *)v39;
          if (*(void *)(*(void *)v37 + 48) >= *(void *)(*(void *)v39 + 32)
            && *(void *)(v40 + 32) <= *(void *)(v41 + 48))
          {
            BOOL v42 = *(void *)(v40 + 56) >= *(void *)(v41 + 40) && *(void *)(v40 + 40) <= *(void *)(v41 + 56);
            BOOL v43 = v42 && *(unsigned char *)(v40 + 96) == 0;
            BOOL v44 = v43 && *(unsigned char *)(v41 + 96) == 0;
            if (v44
              && !sub_18E1CE310(*(_DWORD *)(a4 + 40), **(double ***)a4, *(double **)(*(void *)a4 + 8), (int *)v40, *(_DWORD *)(a4 + 40), **(double ***)a4, *(double **)(*(void *)a4 + 8), (int *)v41, *(unsigned char *)(a4 + 44), *(void *)(a4 + 8), *(uint64_t **)(a4 + 16), *(uint64_t **)(a4 + 24), *(BOOL **)(a4 + 32)))
            {
              goto LABEL_37;
            }
          }
          v39 += 8;
          if (v39 == v36)
          {
            uint64_t v27 = 1;
            v37 += 8;
            if (v38 != v36) {
              goto LABEL_68;
            }
            goto LABEL_38;
          }
        }
      }
    }
    uint64_t v27 = 1;
  }
  else
  {
    uint64_t v27 = sub_18E1CC098(v55, &__p, a3 + 1, a4);
  }
LABEL_38:
  if (v13) {
    operator delete(v13);
  }
  if (__p) {
    operator delete(__p);
  }
  if (v52) {
    operator delete(v52);
  }
  return v27;
}

void sub_18E1CCE64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,uint64_t a25,void *a26)
{
  if (v26) {
    operator delete(v26);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a26) {
    operator delete(a26);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E1CCEAC(uint64_t *a1, uint64_t *a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v9 = *a2;
  uint64_t v8 = a2[1];
  if ((unint64_t)(v8 - *a2) < 0x80 || a4 > 0x63 || (unint64_t)(a3[1] - *a3) < 0x79)
  {
    if (v9 != v8)
    {
      uint64_t v12 = a3[1];
      if (*a3 != v12)
      {
        do
        {
          uint64_t v13 = *a3;
          if (*a3 != v12)
          {
            do
            {
              uint64_t v14 = *(void *)v9;
              uint64_t v15 = *(void *)v13;
              if (*(void *)(*(void *)v9 + 48) >= *(void *)(*(void *)v13 + 32)
                && *(void *)(v14 + 32) <= *(void *)(v15 + 48))
              {
                BOOL v16 = *(void *)(v14 + 56) >= *(void *)(v15 + 40) && *(void *)(v14 + 40) <= *(void *)(v15 + 56);
                BOOL v17 = v16 && *(unsigned char *)(v14 + 96) == 0;
                if (v17 && *(unsigned char *)(v15 + 96) == 0)
                {
                  uint64_t result = sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v14, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v15, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32));
                  if (!result) {
                    return result;
                  }
                  uint64_t v12 = a3[1];
                }
              }
              v13 += 8;
            }
            while (v13 != v12);
            uint64_t v8 = a2[1];
          }
          v9 += 8;
        }
        while (v9 != v8);
      }
    }
    return 1;
  }
  else
  {
    unint64_t v10 = a4 + 1;
    return sub_18E1CD01C(a1, a2, a3, v10, a5);
  }
}

uint64_t sub_18E1CD01C(uint64_t *a1, uint64_t *a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v8 = *a1;
  uint64_t v9 = a1[2];
  if (*a1 >= 0) {
    uint64_t v10 = *a1;
  }
  else {
    uint64_t v10 = v8 + 1;
  }
  long long v12 = *(_OWORD *)a1;
  long long v11 = *((_OWORD *)a1 + 1);
  if (v9 >= 0) {
    uint64_t v13 = a1[2];
  }
  else {
    uint64_t v13 = v9 + 1;
  }
  uint64_t v14 = v13 >> 1;
  long long v115 = *(_OWORD *)a1;
  uint64_t v117 = *((void *)&v11 + 1);
  v113[1] = *((void *)&v12 + 1);
  long long v114 = v11;
  int v15 = v9 - 2 * v14 + v8 - 2 * (v10 >> 1);
  uint64_t v116 = v14 + (v10 >> 1) + ((v15 + ((v15 & 0x80) >> 7)) << 24 >> 25);
  uint64_t v112 = 0;
  v113[0] = v116;
  BOOL v110 = 0;
  int v111 = 0;
  uint64_t v107 = 0;
  double v108 = 0;
  uint64_t v109 = 0;
  uint64_t v104 = 0;
  uint64_t v105 = 0;
  uint64_t v106 = 0;
  uint64_t v101 = 0;
  uint64_t v102 = 0;
  uint64_t v103 = 0;
  long long __p = 0;
  double v99 = 0;
  uint64_t v100 = 0;
  uint64_t v95 = 0;
  uint64_t v96 = 0;
  uint64_t v97 = 0;
  sub_18E1CC5B8(&v115, v113, a2, (void **)&v110, &v107, (void **)&v104);
  sub_18E1CC5B8(&v115, v113, a3, &v101, &__p, (void **)&v95);
  BOOL v16 = v104;
  BOOL v17 = v105;
  double v18 = v95;
  if (v104 == v105)
  {
    unint64_t v92 = a4;
    uint64_t v20 = v96;
  }
  else
  {
    unint64_t v19 = v105 - v104;
    uint64_t v20 = v96;
    if ((unint64_t)(v105 - v104) < 0x80 || a4 > 0x63 || (unint64_t)(v96 - v95) < 0x79)
    {
      if (v95 != v96)
      {
        uint64_t v25 = v104;
LABEL_20:
        uint64_t v26 = v18;
        while (1)
        {
          uint64_t v27 = *(void *)v25;
          uint64_t v28 = *(void *)v26;
          if (*(void *)(*(void *)v25 + 48) >= *(void *)(*(void *)v26 + 32)
            && *(void *)(v27 + 32) <= *(void *)(v28 + 48))
          {
            BOOL v29 = *(void *)(v27 + 56) >= *(void *)(v28 + 40) && *(void *)(v27 + 40) <= *(void *)(v28 + 56);
            BOOL v30 = v29 && *(unsigned char *)(v27 + 96) == 0;
            BOOL v31 = v30 && *(unsigned char *)(v28 + 96) == 0;
            if (v31
              && !sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v27, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v28, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32)))
            {
              goto LABEL_183;
            }
          }
          v26 += 8;
          if (v26 == v20)
          {
            v25 += 8;
            if (v25 != v17) {
              goto LABEL_20;
            }
            break;
          }
        }
      }
    }
    else
    {
      int64x2_t v93 = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
      int64x2_t v94 = vdupq_n_s64(0x8000000000000000);
      BOOL v21 = (uint64_t *)v104;
      do
      {
        uint64_t v22 = *v21++;
        sub_18E1CC524(v93.i64, (uint64_t *)(v22 + 32));
      }
      while (v21 != (uint64_t *)v17);
      if (v18 != v20)
      {
        BOOL v23 = v18;
        do
        {
          uint64_t v24 = *(void *)v23;
          v23 += 8;
          sub_18E1CC524(v93.i64, (uint64_t *)(v24 + 32));
        }
        while (v23 != v20);
      }
      if ((sub_18E1CD994(&v93, &v104, &v95, a4 + 1, a5) & 1) == 0) {
        goto LABEL_183;
      }
    }
    BOOL v33 = (char *)v101;
    uint64_t v32 = v102;
    unint64_t v92 = a4;
    if ((unint64_t)(v102 - (unsigned char *)v101) < 0x80
      || (unint64_t)(v99 - (unsigned char *)__p) < 0x80
      || a4 > 0x63
      || v19 < 0x79)
    {
      if (v101 != v102)
      {
        unint64_t v49 = v16;
LABEL_79:
        uint64_t v50 = v33;
        while (1)
        {
          uint64_t v51 = *v49;
          uint64_t v52 = *(void *)v50;
          if (*(void *)(*v49 + 48) >= *(void *)(*(void *)v50 + 32)
            && *(void *)(v51 + 32) <= *(void *)(v52 + 48))
          {
            BOOL v53 = *(void *)(v51 + 56) >= *(void *)(v52 + 40) && *(void *)(v51 + 40) <= *(void *)(v52 + 56);
            BOOL v54 = v53 && *(unsigned char *)(v51 + 96) == 0;
            BOOL v55 = v54 && *(unsigned char *)(v52 + 96) == 0;
            if (v55
              && !sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v51, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v52, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32)))
            {
              goto LABEL_183;
            }
          }
          v50 += 8;
          if (v50 == v32)
          {
            if (++v49 != (void *)v17) {
              goto LABEL_79;
            }
            break;
          }
        }
      }
      long long v56 = (char *)__p;
      long long v57 = v99;
      if (__p != v99)
      {
        uint64_t v58 = v16;
LABEL_98:
        uint64_t v59 = v56;
        while (1)
        {
          uint64_t v60 = *v58;
          uint64_t v61 = *(void *)v59;
          if (*(void *)(*v58 + 48) >= *(void *)(*(void *)v59 + 32)
            && *(void *)(v60 + 32) <= *(void *)(v61 + 48))
          {
            BOOL v62 = *(void *)(v60 + 56) >= *(void *)(v61 + 40) && *(void *)(v60 + 40) <= *(void *)(v61 + 56);
            BOOL v63 = v62 && *(unsigned char *)(v60 + 96) == 0;
            BOOL v64 = v63 && *(unsigned char *)(v61 + 96) == 0;
            if (v64
              && !sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v60, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v61, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32)))
            {
              goto LABEL_183;
            }
          }
          v59 += 8;
          if (v59 == v57)
          {
            if (++v58 != (void *)v17) {
              goto LABEL_98;
            }
            break;
          }
        }
      }
    }
    else
    {
      int64x2_t v93 = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
      int64x2_t v94 = vdupq_n_s64(0x8000000000000000);
      BOOL v34 = v16;
      do
      {
        uint64_t v35 = *v34++;
        sub_18E1CC524(v93.i64, (uint64_t *)(v35 + 32));
      }
      while (v34 != (uint64_t *)v17);
      if (!sub_18E1CD994(&v93, &v104, &v101, a4 + 1, a5)
        || (sub_18E1CD994(&v93, &v104, &__p, a4 + 1, a5) & 1) == 0)
      {
        goto LABEL_183;
      }
    }
  }
  uint64_t v37 = v110;
  uint64_t v36 = v111;
  unint64_t v38 = v111 - v110;
  if (v18 != v20)
  {
    if (v38 < 0x80
      || (unint64_t)(v108 - (unsigned char *)v107) < 0x80
      || v92 > 0x63
      || (unint64_t)(v20 - v18) < 0x79)
    {
      if (v110 != v111)
      {
        long long v65 = v110;
LABEL_118:
        uint64_t v66 = v18;
        while (1)
        {
          uint64_t v67 = *(void *)v65;
          uint64_t v68 = *(void *)v66;
          if (*(void *)(*(void *)v65 + 48) >= *(void *)(*(void *)v66 + 32)
            && *(void *)(v67 + 32) <= *(void *)(v68 + 48))
          {
            BOOL v69 = *(void *)(v67 + 56) >= *(void *)(v68 + 40) && *(void *)(v67 + 40) <= *(void *)(v68 + 56);
            BOOL v70 = v69 && *(unsigned char *)(v67 + 96) == 0;
            BOOL v71 = v70 && *(unsigned char *)(v68 + 96) == 0;
            if (v71
              && !sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v67, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v68, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32)))
            {
              goto LABEL_183;
            }
          }
          v66 += 8;
          if (v66 == v20)
          {
            v65 += 8;
            if (v65 != v36) {
              goto LABEL_118;
            }
            break;
          }
        }
      }
      uint64_t v72 = (char *)v107;
      long long v73 = v108;
LABEL_136:
      if (v72 != v73)
      {
        int64_t v74 = v18;
        while (1)
        {
          uint64_t v75 = *(void *)v72;
          uint64_t v76 = *(void *)v74;
          if (*(void *)(*(void *)v72 + 48) >= *(void *)(*(void *)v74 + 32)
            && *(void *)(v75 + 32) <= *(void *)(v76 + 48))
          {
            BOOL v77 = *(void *)(v75 + 56) >= *(void *)(v76 + 40) && *(void *)(v75 + 40) <= *(void *)(v76 + 56);
            BOOL v78 = v77 && *(unsigned char *)(v75 + 96) == 0;
            BOOL v79 = v78 && *(unsigned char *)(v76 + 96) == 0;
            if (v79
              && !sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v75, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v76, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32)))
            {
              goto LABEL_183;
            }
          }
          v74 += 8;
          if (v74 == v20)
          {
            v72 += 8;
            goto LABEL_136;
          }
        }
      }
    }
    else
    {
      int64x2_t v93 = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
      int64x2_t v94 = vdupq_n_s64(0x8000000000000000);
      uint64_t v39 = v18;
      do
      {
        uint64_t v40 = *(void *)v39;
        v39 += 8;
        sub_18E1CC524(v93.i64, (uint64_t *)(v40 + 32));
      }
      while (v39 != v20);
      if (!sub_18E1CD994(&v93, &v110, &v95, v92 + 1, a5)
        || (sub_18E1CD994(&v93, &v107, &v95, v92 + 1, a5) & 1) == 0)
      {
        goto LABEL_183;
      }
    }
  }
  if (v38 < 0x80 || v92 > 0x63 || (unint64_t)(v102 - (unsigned char *)v101) < 0x79)
  {
    if (v37 != v36)
    {
      uint64_t v41 = (char *)v101;
      BOOL v42 = v102;
      if (v101 != v102)
      {
LABEL_59:
        BOOL v43 = v41;
        while (1)
        {
          uint64_t v44 = *(void *)v37;
          uint64_t v45 = *(void *)v43;
          if (*(void *)(*(void *)v37 + 48) >= *(void *)(*(void *)v43 + 32)
            && *(void *)(v44 + 32) <= *(void *)(v45 + 48))
          {
            BOOL v46 = *(void *)(v44 + 56) >= *(void *)(v45 + 40) && *(void *)(v44 + 40) <= *(void *)(v45 + 56);
            BOOL v47 = v46 && *(unsigned char *)(v44 + 96) == 0;
            BOOL v48 = v47 && *(unsigned char *)(v45 + 96) == 0;
            if (v48
              && !sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v44, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v45, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32)))
            {
              goto LABEL_183;
            }
          }
          v43 += 8;
          if (v43 == v42)
          {
            v37 += 8;
            if (v37 != v36) {
              goto LABEL_59;
            }
            break;
          }
        }
      }
    }
  }
  else if ((sub_18E1CD994(&v115, &v110, &v101, v92 + 1, a5) & 1) == 0)
  {
    goto LABEL_183;
  }
  long long v81 = (char *)v107;
  uint64_t v80 = v108;
  if ((unint64_t)(v108 - (unsigned char *)v107) < 0x80 || v92 > 0x63 || (unint64_t)(v99 - (unsigned char *)__p) < 0x79)
  {
    if (v107 == v108) {
      goto LABEL_181;
    }
    uint64_t v82 = (char *)__p;
    uint64_t v83 = v99;
    if (__p == v99) {
      goto LABEL_181;
    }
LABEL_160:
    uint64_t v84 = v82;
    while (1)
    {
      uint64_t v85 = *(void *)v81;
      uint64_t v86 = *(void *)v84;
      if (*(void *)(*(void *)v81 + 48) >= *(void *)(*(void *)v84 + 32)
        && *(void *)(v85 + 32) <= *(void *)(v86 + 48))
      {
        BOOL v87 = *(void *)(v85 + 56) >= *(void *)(v86 + 40) && *(void *)(v85 + 40) <= *(void *)(v86 + 56);
        BOOL v88 = v87 && *(unsigned char *)(v85 + 96) == 0;
        BOOL v89 = v88 && *(unsigned char *)(v86 + 96) == 0;
        if (v89
          && !sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v85, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v86, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32)))
        {
          break;
        }
      }
      v84 += 8;
      if (v84 == v83)
      {
        v81 += 8;
        if (v81 != v80) {
          goto LABEL_160;
        }
        goto LABEL_181;
      }
    }
LABEL_183:
    uint64_t v90 = 0;
    if (!v18) {
      goto LABEL_185;
    }
    goto LABEL_184;
  }
  if ((sub_18E1CD994(v113, &v107, &__p, v92 + 1, a5) & 1) == 0) {
    goto LABEL_183;
  }
LABEL_181:
  uint64_t v90 = 1;
  if (v18) {
LABEL_184:
  }
    operator delete(v18);
LABEL_185:
  if (__p) {
    operator delete(__p);
  }
  if (v101) {
    operator delete(v101);
  }
  if (v16) {
    operator delete(v16);
  }
  if (v107) {
    operator delete(v107);
  }
  if (v110) {
    operator delete(v110);
  }
  return v90;
}

void sub_18E1CD910(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31)
{
  if (v31) {
    operator delete(v31);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a25) {
    operator delete(a25);
  }
  if (a28) {
    operator delete(a28);
  }
  if (a31) {
    operator delete(a31);
  }
  BOOL v34 = *(void **)(v32 - 184);
  if (v34) {
    operator delete(v34);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E1CD994(long long *a1, uint64_t *a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v9 = *((void *)a1 + 2);
  uint64_t v8 = *((void *)a1 + 3);
  uint64_t v10 = *((void *)a1 + 1);
  if (v10 >= 0) {
    uint64_t v11 = *((void *)a1 + 1);
  }
  else {
    uint64_t v11 = v10 + 1;
  }
  long long v12 = *a1;
  if (v8 >= 0) {
    uint64_t v13 = *((void *)a1 + 3);
  }
  else {
    uint64_t v13 = v8 + 1;
  }
  uint64_t v14 = v13 >> 1;
  long long v114 = a1[1];
  long long v115 = v12;
  v113[0] = v12;
  int v15 = v8 - 2 * v14 + v10 - 2 * (v11 >> 1);
  uint64_t v116 = v9;
  uint64_t v117 = v14 + (v11 >> 1) + ((v15 + ((v15 & 0x80) >> 7)) << 24 >> 25);
  v113[1] = v117;
  BOOL v110 = 0;
  int v111 = 0;
  uint64_t v112 = 0;
  uint64_t v107 = 0;
  double v108 = 0;
  uint64_t v109 = 0;
  uint64_t v104 = 0;
  uint64_t v105 = 0;
  uint64_t v106 = 0;
  uint64_t v101 = 0;
  uint64_t v102 = 0;
  uint64_t v103 = 0;
  long long __p = 0;
  double v99 = 0;
  uint64_t v100 = 0;
  uint64_t v95 = 0;
  uint64_t v96 = 0;
  uint64_t v97 = 0;
  sub_18E1CC5B8(&v115, v113, a2, (void **)&v110, &v107, (void **)&v104);
  sub_18E1CC5B8(&v115, v113, a3, &v101, &__p, (void **)&v95);
  BOOL v16 = v104;
  BOOL v17 = v105;
  double v18 = v95;
  if (v104 == v105)
  {
    unint64_t v92 = a4;
    uint64_t v20 = v96;
  }
  else
  {
    unint64_t v19 = v105 - v104;
    uint64_t v20 = v96;
    if ((unint64_t)(v105 - v104) < 0x80 || a4 > 0x63 || (unint64_t)(v96 - v95) < 0x79)
    {
      if (v95 != v96)
      {
        uint64_t v25 = v104;
LABEL_20:
        uint64_t v26 = v18;
        while (1)
        {
          uint64_t v27 = *(void *)v25;
          uint64_t v28 = *(void *)v26;
          if (*(void *)(*(void *)v25 + 48) >= *(void *)(*(void *)v26 + 32)
            && *(void *)(v27 + 32) <= *(void *)(v28 + 48))
          {
            BOOL v29 = *(void *)(v27 + 56) >= *(void *)(v28 + 40) && *(void *)(v27 + 40) <= *(void *)(v28 + 56);
            BOOL v30 = v29 && *(unsigned char *)(v27 + 96) == 0;
            BOOL v31 = v30 && *(unsigned char *)(v28 + 96) == 0;
            if (v31
              && !sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v27, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v28, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32)))
            {
              goto LABEL_183;
            }
          }
          v26 += 8;
          if (v26 == v20)
          {
            v25 += 8;
            if (v25 != v17) {
              goto LABEL_20;
            }
            break;
          }
        }
      }
    }
    else
    {
      int64x2_t v93 = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
      int64x2_t v94 = vdupq_n_s64(0x8000000000000000);
      BOOL v21 = (uint64_t *)v104;
      do
      {
        uint64_t v22 = *v21++;
        sub_18E1CC524(v93.i64, (uint64_t *)(v22 + 32));
      }
      while (v21 != (uint64_t *)v17);
      if (v18 != v20)
      {
        BOOL v23 = v18;
        do
        {
          uint64_t v24 = *(void *)v23;
          v23 += 8;
          sub_18E1CC524(v93.i64, (uint64_t *)(v24 + 32));
        }
        while (v23 != v20);
      }
      if ((sub_18E1CD01C(v93.i64, (uint64_t *)&v104, (uint64_t *)&v95, a4 + 1, a5) & 1) == 0) {
        goto LABEL_183;
      }
    }
    BOOL v33 = (char *)v101;
    uint64_t v32 = v102;
    unint64_t v92 = a4;
    if ((unint64_t)(v102 - (unsigned char *)v101) < 0x80
      || (unint64_t)(v99 - (unsigned char *)__p) < 0x80
      || a4 > 0x63
      || v19 < 0x79)
    {
      if (v101 != v102)
      {
        unint64_t v49 = v16;
LABEL_79:
        uint64_t v50 = v33;
        while (1)
        {
          uint64_t v51 = *v49;
          uint64_t v52 = *(void *)v50;
          if (*(void *)(*v49 + 48) >= *(void *)(*(void *)v50 + 32)
            && *(void *)(v51 + 32) <= *(void *)(v52 + 48))
          {
            BOOL v53 = *(void *)(v51 + 56) >= *(void *)(v52 + 40) && *(void *)(v51 + 40) <= *(void *)(v52 + 56);
            BOOL v54 = v53 && *(unsigned char *)(v51 + 96) == 0;
            BOOL v55 = v54 && *(unsigned char *)(v52 + 96) == 0;
            if (v55
              && !sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v51, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v52, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32)))
            {
              goto LABEL_183;
            }
          }
          v50 += 8;
          if (v50 == v32)
          {
            if (++v49 != (void *)v17) {
              goto LABEL_79;
            }
            break;
          }
        }
      }
      long long v56 = (char *)__p;
      long long v57 = v99;
      if (__p != v99)
      {
        uint64_t v58 = v16;
LABEL_98:
        uint64_t v59 = v56;
        while (1)
        {
          uint64_t v60 = *v58;
          uint64_t v61 = *(void *)v59;
          if (*(void *)(*v58 + 48) >= *(void *)(*(void *)v59 + 32)
            && *(void *)(v60 + 32) <= *(void *)(v61 + 48))
          {
            BOOL v62 = *(void *)(v60 + 56) >= *(void *)(v61 + 40) && *(void *)(v60 + 40) <= *(void *)(v61 + 56);
            BOOL v63 = v62 && *(unsigned char *)(v60 + 96) == 0;
            BOOL v64 = v63 && *(unsigned char *)(v61 + 96) == 0;
            if (v64
              && !sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v60, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v61, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32)))
            {
              goto LABEL_183;
            }
          }
          v59 += 8;
          if (v59 == v57)
          {
            if (++v58 != (void *)v17) {
              goto LABEL_98;
            }
            break;
          }
        }
      }
    }
    else
    {
      int64x2_t v93 = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
      int64x2_t v94 = vdupq_n_s64(0x8000000000000000);
      BOOL v34 = v16;
      do
      {
        uint64_t v35 = *v34++;
        sub_18E1CC524(v93.i64, (uint64_t *)(v35 + 32));
      }
      while (v34 != (uint64_t *)v17);
      if (!sub_18E1CD01C(v93.i64, (uint64_t *)&v104, (uint64_t *)&v101, a4 + 1, a5)
        || (sub_18E1CD01C(v93.i64, (uint64_t *)&v104, (uint64_t *)&__p, a4 + 1, a5) & 1) == 0)
      {
        goto LABEL_183;
      }
    }
  }
  uint64_t v37 = v110;
  uint64_t v36 = v111;
  unint64_t v38 = v111 - v110;
  if (v18 != v20)
  {
    if (v38 < 0x80
      || (unint64_t)(v108 - (unsigned char *)v107) < 0x80
      || v92 > 0x63
      || (unint64_t)(v20 - v18) < 0x79)
    {
      if (v110 != v111)
      {
        long long v65 = v110;
LABEL_118:
        uint64_t v66 = v18;
        while (1)
        {
          uint64_t v67 = *(void *)v65;
          uint64_t v68 = *(void *)v66;
          if (*(void *)(*(void *)v65 + 48) >= *(void *)(*(void *)v66 + 32)
            && *(void *)(v67 + 32) <= *(void *)(v68 + 48))
          {
            BOOL v69 = *(void *)(v67 + 56) >= *(void *)(v68 + 40) && *(void *)(v67 + 40) <= *(void *)(v68 + 56);
            BOOL v70 = v69 && *(unsigned char *)(v67 + 96) == 0;
            BOOL v71 = v70 && *(unsigned char *)(v68 + 96) == 0;
            if (v71
              && !sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v67, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v68, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32)))
            {
              goto LABEL_183;
            }
          }
          v66 += 8;
          if (v66 == v20)
          {
            v65 += 8;
            if (v65 != v36) {
              goto LABEL_118;
            }
            break;
          }
        }
      }
      uint64_t v72 = (char *)v107;
      long long v73 = v108;
LABEL_136:
      if (v72 != v73)
      {
        int64_t v74 = v18;
        while (1)
        {
          uint64_t v75 = *(void *)v72;
          uint64_t v76 = *(void *)v74;
          if (*(void *)(*(void *)v72 + 48) >= *(void *)(*(void *)v74 + 32)
            && *(void *)(v75 + 32) <= *(void *)(v76 + 48))
          {
            BOOL v77 = *(void *)(v75 + 56) >= *(void *)(v76 + 40) && *(void *)(v75 + 40) <= *(void *)(v76 + 56);
            BOOL v78 = v77 && *(unsigned char *)(v75 + 96) == 0;
            BOOL v79 = v78 && *(unsigned char *)(v76 + 96) == 0;
            if (v79
              && !sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v75, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v76, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32)))
            {
              goto LABEL_183;
            }
          }
          v74 += 8;
          if (v74 == v20)
          {
            v72 += 8;
            goto LABEL_136;
          }
        }
      }
    }
    else
    {
      int64x2_t v93 = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
      int64x2_t v94 = vdupq_n_s64(0x8000000000000000);
      uint64_t v39 = v18;
      do
      {
        uint64_t v40 = *(void *)v39;
        v39 += 8;
        sub_18E1CC524(v93.i64, (uint64_t *)(v40 + 32));
      }
      while (v39 != v20);
      if (!sub_18E1CD01C(v93.i64, (uint64_t *)&v110, (uint64_t *)&v95, v92 + 1, a5)
        || (sub_18E1CD01C(v93.i64, (uint64_t *)&v107, (uint64_t *)&v95, v92 + 1, a5) & 1) == 0)
      {
        goto LABEL_183;
      }
    }
  }
  if (v38 < 0x80 || v92 > 0x63 || (unint64_t)(v102 - (unsigned char *)v101) < 0x79)
  {
    if (v37 != v36)
    {
      uint64_t v41 = (char *)v101;
      BOOL v42 = v102;
      if (v101 != v102)
      {
LABEL_59:
        BOOL v43 = v41;
        while (1)
        {
          uint64_t v44 = *(void *)v37;
          uint64_t v45 = *(void *)v43;
          if (*(void *)(*(void *)v37 + 48) >= *(void *)(*(void *)v43 + 32)
            && *(void *)(v44 + 32) <= *(void *)(v45 + 48))
          {
            BOOL v46 = *(void *)(v44 + 56) >= *(void *)(v45 + 40) && *(void *)(v44 + 40) <= *(void *)(v45 + 56);
            BOOL v47 = v46 && *(unsigned char *)(v44 + 96) == 0;
            BOOL v48 = v47 && *(unsigned char *)(v45 + 96) == 0;
            if (v48
              && !sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v44, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v45, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32)))
            {
              goto LABEL_183;
            }
          }
          v43 += 8;
          if (v43 == v42)
          {
            v37 += 8;
            if (v37 != v36) {
              goto LABEL_59;
            }
            break;
          }
        }
      }
    }
  }
  else if ((sub_18E1CD01C((uint64_t *)&v115, (uint64_t *)&v110, (uint64_t *)&v101, v92 + 1, a5) & 1) == 0)
  {
    goto LABEL_183;
  }
  long long v81 = (char *)v107;
  uint64_t v80 = v108;
  if ((unint64_t)(v108 - (unsigned char *)v107) < 0x80 || v92 > 0x63 || (unint64_t)(v99 - (unsigned char *)__p) < 0x79)
  {
    if (v107 == v108) {
      goto LABEL_181;
    }
    uint64_t v82 = (char *)__p;
    uint64_t v83 = v99;
    if (__p == v99) {
      goto LABEL_181;
    }
LABEL_160:
    uint64_t v84 = v82;
    while (1)
    {
      uint64_t v85 = *(void *)v81;
      uint64_t v86 = *(void *)v84;
      if (*(void *)(*(void *)v81 + 48) >= *(void *)(*(void *)v84 + 32)
        && *(void *)(v85 + 32) <= *(void *)(v86 + 48))
      {
        BOOL v87 = *(void *)(v85 + 56) >= *(void *)(v86 + 40) && *(void *)(v85 + 40) <= *(void *)(v86 + 56);
        BOOL v88 = v87 && *(unsigned char *)(v85 + 96) == 0;
        BOOL v89 = v88 && *(unsigned char *)(v86 + 96) == 0;
        if (v89
          && !sub_18E1CE310(*(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v85, *(_DWORD *)(a5 + 40), **(double ***)a5, *(double **)(*(void *)a5 + 8), (int *)v86, *(unsigned char *)(a5 + 44), *(void *)(a5 + 8), *(uint64_t **)(a5 + 16), *(uint64_t **)(a5 + 24), *(BOOL **)(a5 + 32)))
        {
          break;
        }
      }
      v84 += 8;
      if (v84 == v83)
      {
        v81 += 8;
        if (v81 != v80) {
          goto LABEL_160;
        }
        goto LABEL_181;
      }
    }
LABEL_183:
    uint64_t v90 = 0;
    if (!v18) {
      goto LABEL_185;
    }
    goto LABEL_184;
  }
  if ((sub_18E1CD01C(v113, (uint64_t *)&v107, (uint64_t *)&__p, v92 + 1, a5) & 1) == 0) {
    goto LABEL_183;
  }
LABEL_181:
  uint64_t v90 = 1;
  if (v18) {
LABEL_184:
  }
    operator delete(v18);
LABEL_185:
  if (__p) {
    operator delete(__p);
  }
  if (v101) {
    operator delete(v101);
  }
  if (v16) {
    operator delete(v16);
  }
  if (v107) {
    operator delete(v107);
  }
  if (v110) {
    operator delete(v110);
  }
  return v90;
}

void sub_18E1CE28C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31)
{
  if (v31) {
    operator delete(v31);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a25) {
    operator delete(a25);
  }
  if (a28) {
    operator delete(a28);
  }
  if (a31) {
    operator delete(a31);
  }
  BOOL v34 = *(void **)(v32 - 184);
  if (v34) {
    operator delete(v34);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E1CE310(int a1, double *a2, double *a3, int *a4, int a5, double *a6, double *a7, int *a8, char a9, uint64_t a10, uint64_t *a11, uint64_t *a12, BOOL *a13)
{
  uint64_t v13 = a6;
  uint64_t v14 = a4;
  int v15 = a3;
  BOOL v16 = a2;
  uint64_t v600 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)a4 + 96) && (unint64_t)(*((void *)a4 + 10) + 1) < *((void *)a4 + 11)
    || *((unsigned char *)a8 + 96) && (unint64_t)(*((void *)a8 + 10) + 1) < *((void *)a8 + 11))
  {
    return 1;
  }
  int v17 = *a4;
  int v18 = *a8;
  uint64_t v19 = *((void *)a4 + 13);
  uint64_t v21 = *((void *)a4 + 8);
  uint64_t v20 = *((void *)a4 + 9);
  uint64_t v22 = &a2[2 * v21];
  int v495 = *a8;
  if (v21 == v20) {
    goto LABEL_32;
  }
  BOOL v23 = a8;
  uint64_t v24 = 0;
  uint64_t v512 = *((void *)a4 + 9);
  BOOL v509 = &a2[2 * v21];
  uint64_t v490 = *((void *)a4 + 13);
  uint64_t v25 = v490;
  uint64_t v26 = *((void *)a4 + 8);
  uint64_t v27 = v509;
  uint64_t v500 = v26;
  uint64_t v28 = 16 * v20 - 16 * v26;
  BOOL v29 = v22;
  while (1)
  {
    uint64_t v22 = v29;
    double v30 = (double)a11[3] + (v29[3] - *((double *)a11 + 1)) * *((double *)a11 + 4);
    if (v30 >= 0.0) {
      double v31 = 0.5;
    }
    else {
      double v31 = -0.5;
    }
    double v32 = v30 + v31;
    if (v32 <= -9.22337204e18) {
      uint64_t v33 = 1;
    }
    else {
      uint64_t v33 = 2 * (v32 >= 9.22337204e18);
    }
    sub_18E1CBEE0(v33);
    double v34 = v27[2];
    v27 += 2;
    double v35 = (double)a11[2] + (v34 - *(double *)a11) * *((double *)a11 + 4);
    if (v35 >= 0.0) {
      double v36 = 0.5;
    }
    else {
      double v36 = -0.5;
    }
    double v37 = v35 + v36;
    if (v35 + v36 <= -9.22337204e18) {
      uint64_t v38 = 1;
    }
    else {
      uint64_t v38 = 2 * (v35 + v36 >= 9.22337204e18);
    }
    sub_18E1CBEE0(v38);
    double v39 = ceil(v37);
    double v40 = floor(v37);
    if (v37 >= 0.0) {
      double v39 = v40;
    }
    uint64_t v41 = (uint64_t)v39;
    if (v17 == 1) {
      break;
    }
    if (v17 != -1)
    {
      uint64_t v22 = v509;
      a8 = v23;
      uint64_t v13 = a6;
      uint64_t v21 = v500;
      uint64_t v14 = a4;
      BOOL v16 = a2;
      int v15 = a3;
      int v18 = v495;
      uint64_t v19 = v490;
      goto LABEL_31;
    }
    if (*((void *)v23 + 6) >= v41)
    {
      uint64_t v19 = v25;
      uint64_t v21 = v26;
      goto LABEL_30;
    }
LABEL_26:
    ++v26;
    ++v25;
    ++v24;
    BOOL v29 = v27;
    v28 -= 16;
    if (!v28) {
      return 1;
    }
  }
  if (*((void *)v23 + 4) > v41) {
    goto LABEL_26;
  }
  uint64_t v19 = v490 + v24;
  uint64_t v21 = v500 + v24;
LABEL_30:
  a8 = v23;
  uint64_t v13 = a6;
  uint64_t v14 = a4;
  BOOL v16 = a2;
  int v15 = a3;
  int v18 = v495;
LABEL_31:
  uint64_t v20 = v512;
LABEL_32:
  uint64_t v42 = 1;
  v481 = &v16[2 * v20];
  if (v22 != v481)
  {
    unint64_t v498 = a8;
    uint64_t v491 = v19;
    BOOL v43 = v22;
    uint64_t v44 = &v16[2 * (v22 != v16)];
    if (v22 + 2 != v15) {
      uint64_t v44 = v22 + 2;
    }
    uint64_t v45 = v44 + 2;
    BOOL v46 = &v16[2 * (v44 != v16)];
    if (v45 != v15) {
      BOOL v46 = v45;
    }
    v488 = v46;
    unint64_t v489 = v22 + 2;
    int v482 = -v17;
    int v492 = -v18;
    double v47 = 0.5;
    double v48 = -0.5;
    while (1)
    {
      double v49 = (double)a11[3] + (v43[1] - *((double *)a11 + 1)) * *((double *)a11 + 4);
      if (v49 >= 0.0) {
        double v50 = v47;
      }
      else {
        double v50 = v48;
      }
      double v51 = v49 + v50;
      if (v51 <= -9.22337204e18) {
        uint64_t v52 = 1;
      }
      else {
        uint64_t v52 = 2 * (v51 >= 9.22337204e18);
      }
      sub_18E1CBEE0(v52);
      long long v487 = v43;
      double v53 = (double)a11[2] + (*v43 - *(double *)a11) * *((double *)a11 + 4);
      if (v53 >= 0.0) {
        double v54 = v47;
      }
      else {
        double v54 = v48;
      }
      double v55 = v53 + v54;
      if (v53 + v54 <= -9.22337204e18) {
        uint64_t v56 = 1;
      }
      else {
        uint64_t v56 = 2 * (v53 + v54 >= 9.22337204e18);
      }
      sub_18E1CBEE0(v56);
      double v57 = ceil(v55);
      double v58 = floor(v55);
      if (v55 >= 0.0) {
        double v57 = v58;
      }
      uint64_t v59 = (uint64_t)v57;
      if (v482 == 1)
      {
        uint64_t v60 = v498;
        if (v498[4] > v59) {
          return 1;
        }
      }
      else
      {
        uint64_t v60 = v498;
        if (v482 == -1 && v498[6] < v59) {
          return 1;
        }
      }
      v536[0] = v14;
      uint64_t v501 = v21;
      v536[1] = v21;
      *(void *)&long long v537 = v43;
      *((void *)&v537 + 1) = v489;
      v538[0] = v488;
      v538[1] = v16;
      v538[2] = v15;
      char v539 = 1;
      char v541 = 0;
      long long v61 = *((_OWORD *)a11 + 1);
      long long v542 = *(_OWORD *)a11;
      long long v543 = v61;
      uint64_t v544 = a11[4];
      uint64_t v63 = v60[8];
      uint64_t v62 = v60[9];
      BOOL v64 = &v13[2 * v63];
      uint64_t v65 = v60[13];
      uint64_t v505 = v63;
      uint64_t v508 = v65;
      if (v63 == v62) {
        goto LABEL_84;
      }
      uint64_t v66 = 0;
      uint64_t v513 = v60[9];
      uint64_t v67 = 16 * v62 - 16 * v63;
      int v510 = v64;
      uint64_t v68 = v64;
      BOOL v69 = v64;
      while (1)
      {
        BOOL v70 = v68;
        double v71 = (double)a11[3] + (v68[3] - *((double *)a11 + 1)) * *((double *)a11 + 4);
        if (v71 >= 0.0) {
          double v72 = v47;
        }
        else {
          double v72 = v48;
        }
        double v73 = v71 + v72;
        if (v73 <= -9.22337204e18) {
          uint64_t v74 = 1;
        }
        else {
          uint64_t v74 = 2 * (v73 >= 9.22337204e18);
        }
        sub_18E1CBEE0(v74);
        double v75 = v69[2];
        v69 += 2;
        double v76 = (double)a11[2] + (v75 - *(double *)a11) * *((double *)a11 + 4);
        if (v76 >= 0.0) {
          double v77 = v47;
        }
        else {
          double v77 = v48;
        }
        double v78 = v76 + v77;
        if (v76 + v77 <= -9.22337204e18) {
          uint64_t v79 = 1;
        }
        else {
          uint64_t v79 = 2 * (v76 + v77 >= 9.22337204e18);
        }
        sub_18E1CBEE0(v79);
        double v80 = ceil(v78);
        double v81 = floor(v78);
        if (v78 >= 0.0) {
          double v80 = v81;
        }
        uint64_t v82 = (uint64_t)v80;
        if (v495 == 1) {
          break;
        }
        if (v495 != -1)
        {
          BOOL v64 = v510;
          uint64_t v13 = a6;
          goto LABEL_83;
        }
        if (*((void *)a4 + 6) >= v82)
        {
          uint64_t v508 = v65;
          uint64_t v505 = v63;
          goto LABEL_82;
        }
LABEL_78:
        ++v63;
        ++v65;
        ++v66;
        uint64_t v68 = v69;
        v67 -= 16;
        if (!v67) {
          goto LABEL_886;
        }
      }
      if (*((void *)a4 + 4) > v82) {
        goto LABEL_78;
      }
      v508 += v66;
      v505 += v66;
LABEL_82:
      uint64_t v13 = a6;
      BOOL v64 = v70;
LABEL_83:
      uint64_t v62 = v513;
LABEL_84:
      v494 = &v13[2 * v62];
      if (v64 != v494) {
        break;
      }
LABEL_886:
      ++v491;
      uint64_t v13 = a6;
      uint64_t v14 = a4;
LABEL_887:
      BOOL v43 = v487 + 2;
      int v472 = v489;
      uint64_t v21 = v501 + 1;
      unint64_t v473 = v488 + 2;
      BOOL v16 = a2;
      int v15 = a3;
      if (v488 + 2 == a3) {
        unint64_t v473 = &a2[2 * (v488 != a2)];
      }
      v488 = v473;
      v489 += 2;
      if (v472 == v481) {
        return 1;
      }
    }
    uint64_t v83 = v64 + 2;
    uint64_t v13 = a6;
    uint64_t v84 = &a6[2 * (v64 != a6)];
    uint64_t v85 = a7;
    if (v64 + 2 != a7) {
      uint64_t v84 = v64 + 2;
    }
    uint64_t v86 = v84 + 2;
    BOOL v87 = &a6[2 * (v84 != a6)];
    if (v86 != a7) {
      BOOL v87 = v86;
    }
    uint64_t v514 = v87;
    ++v491;
    uint64_t v88 = v505;
    uint64_t v14 = a4;
    int v89 = v492;
    while (1)
    {
      v504 = v83;
      double v90 = (double)a11[3] + (v64[1] - *((double *)a11 + 1)) * *((double *)a11 + 4);
      if (v90 >= 0.0) {
        double v91 = v47;
      }
      else {
        double v91 = v48;
      }
      double v92 = v90 + v91;
      if (v92 <= -9.22337204e18) {
        uint64_t v93 = 1;
      }
      else {
        uint64_t v93 = 2 * (v92 >= 9.22337204e18);
      }
      int64x2_t v94 = v64;
      sub_18E1CBEE0(v93);
      uint64_t v511 = v94;
      double v95 = (double)a11[2] + (*v94 - *(double *)a11) * *((double *)a11 + 4);
      if (v95 >= 0.0) {
        double v96 = v47;
      }
      else {
        double v96 = v48;
      }
      double v97 = v95 + v96;
      if (v95 + v96 <= -9.22337204e18) {
        uint64_t v98 = 1;
      }
      else {
        uint64_t v98 = 2 * (v95 + v96 >= 9.22337204e18);
      }
      sub_18E1CBEE0(v98);
      double v99 = ceil(v97);
      double v100 = floor(v97);
      if (v97 >= 0.0) {
        double v99 = v100;
      }
      uint64_t v101 = (uint64_t)v99;
      if (v89 == 1)
      {
        long long v102 = xmmword_18E22C210;
        if (v14[4] > v101) {
          goto LABEL_887;
        }
      }
      else
      {
        long long v102 = xmmword_18E22C210;
        if (v89 == -1 && v14[6] < v101) {
          goto LABEL_887;
        }
      }
      uint64_t v103 = v504;
      if (a1 == a5 && v14[2] == v498[2] && v14[3] == v498[3] && a9 && (v508 == v491 || !v501 && v14[11] - 2 <= v88)) {
        goto LABEL_241;
      }
      uint64_t v104 = 0;
      uint64_t v535 = a11[4];
      v526[0] = v498;
      v526[1] = v88;
      long long v527 = v511;
      long long v528 = v504;
      v529[0] = v514;
      v529[1] = v13;
      v529[2] = v85;
      char v530 = 0;
      char v532 = 0;
      long long v105 = *((_OWORD *)a11 + 1);
      long long v533 = *(_OWORD *)a11;
      long long v534 = v105;
      LODWORD(v516) = 0;
      BYTE4(v516) = 0;
      *((void *)&v516 + 1) = -1;
      LOWORD(v517) = 0;
      *(void *)&long long v106 = -1;
      *((void *)&v106 + 1) = -1;
      do
      {
        uint64_t v107 = (char *)&v515 + v104;
        *((_DWORD *)v107 + 10) = 0;
        *((_OWORD *)v107 + 3) = v106;
        *((_OWORD *)v107 + 4) = v106;
        *((void *)v107 + 10) = -1;
        *(_OWORD *)(v107 + 88) = v102;
        v104 += 80;
        *((void *)v107 + 13) = 0;
        *((void *)v107 + 14) = 0;
      }
      while (v104 != 160);
      *(void *)unint64_t v518 = a1;
      *(_OWORD *)&v518[8] = *((_OWORD *)v14 + 1);
      *(void *)&v518[24] = v501;
      *(void *)&long long v519 = -1;
      *(void *)v522 = a5;
      *(_OWORD *)&v522[8] = *((_OWORD *)v498 + 1);
      uint64_t v506 = v88;
      *(void *)&v522[24] = v88;
      *(void *)&long long v523 = -1;
      uint64_t v502 = *a12;
      uint64_t v503 = a12[1];
      v545 = v536;
      float64_t v546 = v526;
      uint64_t v555 = (long long *)a11;
      uint64_t v556 = v536;
      uint64_t v557 = v526;
      __int16 v558 = 0;
      double v108 = (double *)v537;
      double v109 = (double)a11[3] + (*(double *)(v537 + 8) - *((double *)a11 + 1)) * *((double *)a11 + 4);
      if (v109 >= 0.0) {
        double v110 = v47;
      }
      else {
        double v110 = v48;
      }
      double v111 = v109 + v110;
      if (v109 + v110 <= -9.22337204e18) {
        uint64_t v112 = 1;
      }
      else {
        uint64_t v112 = 2 * (v109 + v110 >= 9.22337204e18);
      }
      sub_18E1CBEE0(v112);
      double v113 = ceil(v111);
      double v114 = floor(v111);
      if (v111 >= 0.0) {
        double v113 = v114;
      }
      uint64_t v548 = (uint64_t)v113;
      double v115 = (double)a11[2] + (*v108 - *(double *)a11) * *((double *)a11 + 4);
      if (v115 >= 0.0) {
        double v116 = v47;
      }
      else {
        double v116 = v48;
      }
      double v117 = v115 + v116;
      if (v115 + v116 <= -9.22337204e18) {
        uint64_t v118 = 1;
      }
      else {
        uint64_t v118 = 2 * (v115 + v116 >= 9.22337204e18);
      }
      sub_18E1CBEE0(v118);
      double v119 = ceil(v117);
      double v120 = floor(v117);
      if (v117 >= 0.0) {
        double v119 = v120;
      }
      uint64_t v547 = (uint64_t)v119;
      unint64_t v121 = (double *)*((void *)&v537 + 1);
      double v122 = (double)a11[3] + (*(double *)(*((void *)&v537 + 1) + 8) - *((double *)a11 + 1)) * *((double *)a11 + 4);
      if (v122 >= 0.0) {
        double v123 = v47;
      }
      else {
        double v123 = v48;
      }
      double v124 = v122 + v123;
      if (v122 + v123 <= -9.22337204e18) {
        uint64_t v125 = 1;
      }
      else {
        uint64_t v125 = 2 * (v122 + v123 >= 9.22337204e18);
      }
      sub_18E1CBEE0(v125);
      double v126 = ceil(v124);
      double v127 = floor(v124);
      if (v124 >= 0.0) {
        double v126 = v127;
      }
      uint64_t v550 = (uint64_t)v126;
      double v128 = (double)a11[2] + (*v121 - *(double *)a11) * *((double *)a11 + 4);
      if (v128 >= 0.0) {
        double v129 = v47;
      }
      else {
        double v129 = v48;
      }
      double v130 = v128 + v129;
      if (v128 + v129 <= -9.22337204e18) {
        uint64_t v131 = 1;
      }
      else {
        uint64_t v131 = 2 * (v128 + v129 >= 9.22337204e18);
      }
      sub_18E1CBEE0(v131);
      double v132 = ceil(v130);
      double v133 = floor(v130);
      if (v130 >= 0.0) {
        double v132 = v133;
      }
      uint64_t v549 = (uint64_t)v132;
      double v134 = v527;
      double v135 = (double)a11[3] + (v527[1] - *((double *)a11 + 1)) * *((double *)a11 + 4);
      if (v135 >= 0.0) {
        double v136 = v47;
      }
      else {
        double v136 = v48;
      }
      double v137 = v135 + v136;
      if (v135 + v136 <= -9.22337204e18) {
        uint64_t v138 = 1;
      }
      else {
        uint64_t v138 = 2 * (v135 + v136 >= 9.22337204e18);
      }
      sub_18E1CBEE0(v138);
      double v139 = ceil(v137);
      double v140 = floor(v137);
      if (v137 >= 0.0) {
        double v139 = v140;
      }
      uint64_t v552 = (uint64_t)v139;
      double v141 = (double)a11[2] + (*v134 - *(double *)a11) * *((double *)a11 + 4);
      if (v141 >= 0.0) {
        double v142 = v47;
      }
      else {
        double v142 = v48;
      }
      double v143 = v141 + v142;
      if (v141 + v142 <= -9.22337204e18) {
        uint64_t v144 = 1;
      }
      else {
        uint64_t v144 = 2 * (v141 + v142 >= 9.22337204e18);
      }
      sub_18E1CBEE0(v144);
      double v145 = ceil(v143);
      double v146 = floor(v143);
      if (v143 >= 0.0) {
        double v145 = v146;
      }
      uint64_t v551 = (uint64_t)v145;
      uint64_t v147 = v528;
      double v148 = (double)a11[3] + (v528[1] - *((double *)a11 + 1)) * *((double *)a11 + 4);
      if (v148 >= 0.0) {
        double v149 = v47;
      }
      else {
        double v149 = v48;
      }
      double v150 = v148 + v149;
      if (v148 + v149 <= -9.22337204e18) {
        uint64_t v151 = 1;
      }
      else {
        uint64_t v151 = 2 * (v148 + v149 >= 9.22337204e18);
      }
      sub_18E1CBEE0(v151);
      double v152 = ceil(v150);
      double v153 = floor(v150);
      if (v150 >= 0.0) {
        double v152 = v153;
      }
      uint64_t v154 = (uint64_t)v152;
      uint64_t v554 = (uint64_t)v152;
      double v155 = (double)a11[2] + (*v147 - *(double *)a11) * *((double *)a11 + 4);
      if (v155 >= 0.0) {
        double v156 = v47;
      }
      else {
        double v156 = v48;
      }
      double v157 = v155 + v156;
      if (v155 + v156 <= -9.22337204e18) {
        uint64_t v158 = 1;
      }
      else {
        uint64_t v158 = 2 * (v155 + v156 >= 9.22337204e18);
      }
      sub_18E1CBEE0(v158);
      double v159 = ceil(v157);
      double v160 = floor(v157);
      if (v157 >= 0.0) {
        double v159 = v160;
      }
      uint64_t v161 = (uint64_t)v159;
      uint64_t v553 = (uint64_t)v159;
      v559[0] = v536;
      v559[1] = a11;
      v559[2] = &v547;
      v559[3] = &v549;
      char v560 = 0;
      v561[0] = v526;
      v561[1] = a11;
      v561[2] = &v551;
      v561[3] = &v553;
      char v562 = 0;
      uint64_t v564 = v559;
      uint64_t v565 = v561;
      uint64_t v566 = v561;
      uint64_t v567 = v559;
      uint64_t v162 = (double *)v537;
      uint64_t v163 = v527;
      long long v579 = v537;
      v578[0] = v527;
      v578[1] = v528;
      double v165 = **((double **)&v537 + 1);
      double v164 = *(double *)(*((void *)&v537 + 1) + 8);
      double v167 = *(double *)v537;
      double v166 = *(double *)(v537 + 8);
      double v168 = *v528;
      double v169 = v528[1];
      BOOL v170 = v547 == v549 && v548 == v550;
      int v171 = v170;
      BOOL v173 = v551 == v161 && v552 == v154;
      double v174 = *v527;
      double v175 = v527[1];
      if (v171 == 1 && v173)
      {
        if (v547 != v161 || v548 != v154)
        {
          *(void *)&long long v580 = 0;
          uint64_t v189 = 40;
          uint64_t v85 = a7;
          uint64_t v13 = a6;
          uint64_t v88 = v506;
          uint64_t v14 = a4;
          double v47 = 0.5;
          do
          {
            uint64_t v190 = (char *)&v580 + v189;
            *(_OWORD *)uint64_t v190 = xmmword_18E22C210;
            *((void *)v190 + 2) = 0;
            *((void *)v190 + 3) = 0;
            *((void *)v190 + 4) = 1;
            *((void *)v190 + 5) = 0;
            v190[48] = 0;
            v189 += 56;
          }
          while (v190 + 56 != (char *)&v588 + 8);
          memset(&v591[2], 0, 40);
          long long v571 = *(_OWORD *)&v585[16];
          *(_OWORD *)uint64_t v572 = v586;
          *(_OWORD *)&v572[16] = v587;
          uint64_t v573 = v588;
          *(_OWORD *)&v568[32] = v582;
          *(_OWORD *)&v568[48] = v583;
          long long v569 = v584;
          long long v570 = *(_OWORD *)v585;
          *(_OWORD *)uint64_t v568 = v580;
          *(_OWORD *)&v568[16] = v581;
          __int16 v574 = 100;
          *(_OWORD *)uint64_t v575 = *(_OWORD *)v591;
          *(_OWORD *)&v575[16] = *(_OWORD *)&v591[16];
          *(_OWORD *)&v575[26] = *(_OWORD *)&v591[26];
          int v89 = v492;
          goto LABEL_237;
        }
        uint64_t v176 = 40;
        uint64_t v85 = a7;
        uint64_t v13 = a6;
        uint64_t v88 = v506;
        uint64_t v14 = a4;
        double v47 = 0.5;
        do
        {
          double v177 = (char *)&v580 + v176;
          *(_OWORD *)double v177 = xmmword_18E22C210;
          *((void *)v177 + 2) = 0;
          *((void *)v177 + 3) = 0;
          *((void *)v177 + 4) = 1;
          *((void *)v177 + 5) = 0;
          v177[48] = 0;
          v176 += 56;
        }
        while (v177 + 56 != (char *)&v588 + 8);
        *(void *)&long long v580 = 1;
        *((double *)&v580 + 1) = v167;
        *(double *)&long long v581 = v166;
        memset(&v591[2], 0, 40);
        long long v571 = *(_OWORD *)&v585[16];
        *(_OWORD *)uint64_t v572 = v586;
        *(_OWORD *)&v572[16] = v587;
        uint64_t v573 = v588;
        *(_OWORD *)&v568[32] = v582;
        *(_OWORD *)&v568[48] = v583;
        long long v569 = v584;
        long long v570 = *(_OWORD *)v585;
        *(_OWORD *)uint64_t v568 = v580;
        *(_OWORD *)&v568[16] = v581;
        __int16 v574 = 48;
        *(_OWORD *)uint64_t v575 = *(_OWORD *)v591;
        *(_OWORD *)&v575[16] = *(_OWORD *)&v591[16];
        *(_OWORD *)&v575[26] = *(_OWORD *)&v591[26];
        uint64_t v576 = a10;
        int v89 = v492;
        double v48 = -0.5;
        goto LABEL_238;
      }
      if (v547 >= v549) {
        uint64_t v178 = v549;
      }
      else {
        uint64_t v178 = v547;
      }
      if (v547 <= v549) {
        uint64_t v179 = v549;
      }
      else {
        uint64_t v179 = v547;
      }
      if (v551 >= v161) {
        uint64_t v180 = (uint64_t)v159;
      }
      else {
        uint64_t v180 = v551;
      }
      if (v551 <= v161) {
        uint64_t v181 = (uint64_t)v159;
      }
      else {
        uint64_t v181 = v551;
      }
      if (v179 < v180
        || v181 < v178
        || (v548 >= v550 ? (uint64_t v182 = v550) : (uint64_t v182 = v548),
            v548 <= v550 ? (uint64_t v183 = v550) : (uint64_t v183 = v548),
            v552 >= v154 ? (uint64_t v184 = v154) : (uint64_t v184 = v552),
            v552 <= v154 ? (uint64_t v185 = v154) : (uint64_t v185 = v552),
            v183 < v184 || v185 < v182))
      {
        *(void *)&long long v580 = 0;
        uint64_t v187 = 40;
        do
        {
          uint64_t v188 = (char *)&v580 + v187;
          *(_OWORD *)uint64_t v188 = xmmword_18E22C210;
          *((void *)v188 + 2) = 0;
          *((void *)v188 + 3) = 0;
          *((void *)v188 + 4) = 1;
          *((void *)v188 + 5) = 0;
          v188[48] = 0;
          v187 += 56;
        }
        while (v188 + 56 != (char *)&v588 + 8);
LABEL_233:
        memset(&v591[2], 0, 40);
        long long v571 = *(_OWORD *)&v585[16];
        *(_OWORD *)uint64_t v572 = v586;
        *(_OWORD *)&v572[16] = v587;
        uint64_t v573 = v588;
        *(_OWORD *)&v568[32] = v582;
        *(_OWORD *)&v568[48] = v583;
        long long v569 = v584;
        long long v570 = *(_OWORD *)v585;
        *(_OWORD *)uint64_t v568 = v580;
        *(_OWORD *)&v568[16] = v581;
        __int16 v574 = 100;
        *(_OWORD *)uint64_t v575 = *(_OWORD *)v591;
        *(_OWORD *)&v575[16] = *(_OWORD *)&v591[16];
        *(_OWORD *)&v575[26] = *(_OWORD *)&v591[26];
        uint64_t v85 = a7;
        uint64_t v13 = a6;
        uint64_t v88 = v506;
        uint64_t v14 = a4;
        int v89 = v492;
        double v47 = 0.5;
LABEL_237:
        double v48 = -0.5;
        uint64_t v576 = a10;
        goto LABEL_238;
      }
      *(void *)&long long v580 = 0x3FF0000000000000;
      double v186 = sub_18E1D1B30(v551, v552, v161, v154, v547, v548, (double *)&v580);
      if (v186 == 0.0) {
        break;
      }
      if ((*(void *)&v186 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
      {
        if (v186 > 0.0) {
          int v196 = 1;
        }
        else {
          int v196 = -1;
        }
        int v485 = v196;
      }
      else
      {
        double v194 = fabs(v186);
        if (v186 > 0.0) {
          int v195 = 1;
        }
        else {
          int v195 = -1;
        }
        int v485 = v195;
        if (v194 <= *(double *)&v580 * 2.22044605e-16) {
          break;
        }
      }
LABEL_255:
      *(void *)&long long v580 = 0x3FF0000000000000;
      double v197 = sub_18E1D1B30(v551, v552, v553, v554, v549, v550, (double *)&v580);
      if (v197 == 0.0) {
        goto LABEL_256;
      }
      if ((*(void *)&v197 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
      {
        if (v197 > 0.0) {
          int v198 = 1;
        }
        else {
          int v198 = -1;
        }
      }
      else
      {
        double v199 = fabs(v197);
        if (v197 > 0.0) {
          int v198 = 1;
        }
        else {
          int v198 = -1;
        }
        if (v199 <= *(double *)&v580 * 2.22044605e-16) {
LABEL_256:
        }
          int v198 = 0;
      }
      if (v198 * v485 == 1)
      {
        *(void *)&long long v580 = 0;
        uint64_t v200 = 40;
        do
        {
          BOOL v201 = (char *)&v580 + v200;
          *(_OWORD *)BOOL v201 = xmmword_18E22C210;
          *((void *)v201 + 2) = 0;
          *((void *)v201 + 3) = 0;
          *((void *)v201 + 4) = 1;
          *((void *)v201 + 5) = 0;
          v201[48] = 0;
          v200 += 56;
        }
        while (v201 + 56 != (char *)&v588 + 8);
        goto LABEL_233;
      }
      int v479 = v198;
      *(void *)&long long v580 = 0x3FF0000000000000;
      double v202 = sub_18E1D1B30(v547, v548, v549, v550, v551, v552, (double *)&v580);
      if (v202 == 0.0)
      {
LABEL_271:
        int v203 = 0;
        goto LABEL_281;
      }
      if ((*(void *)&v202 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
      {
        if (v202 > 0.0) {
          int v203 = 1;
        }
        else {
          int v203 = -1;
        }
      }
      else
      {
        double v204 = fabs(v202);
        if (v202 > 0.0) {
          int v203 = 1;
        }
        else {
          int v203 = -1;
        }
        if (v204 <= *(double *)&v580 * 2.22044605e-16) {
          goto LABEL_271;
        }
      }
LABEL_281:
      *(void *)&long long v580 = 0x3FF0000000000000;
      double v205 = sub_18E1D1B30(v547, v548, v549, v550, v553, v554, (double *)&v580);
      if (v205 == 0.0) {
        goto LABEL_282;
      }
      if ((*(void *)&v205 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
      {
        if (v205 > 0.0) {
          int v206 = 1;
        }
        else {
          int v206 = -1;
        }
      }
      else
      {
        double v207 = fabs(v205);
        if (v205 > 0.0) {
          int v206 = 1;
        }
        else {
          int v206 = -1;
        }
        if (v207 <= *(double *)&v580 * 2.22044605e-16) {
LABEL_282:
        }
          int v206 = 0;
      }
      if (v206 * v203 == 1)
      {
        *(void *)&long long v580 = 0;
        uint64_t v208 = 40;
        do
        {
          double v209 = (char *)&v580 + v208;
          *(_OWORD *)double v209 = xmmword_18E22C210;
          *((void *)v209 + 2) = 0;
          *((void *)v209 + 3) = 0;
          *((void *)v209 + 4) = 1;
          *((void *)v209 + 5) = 0;
          v209[48] = 0;
          v208 += 56;
        }
        while (v209 + 56 != (char *)&v588 + 8);
        goto LABEL_233;
      }
      int v210 = v203;
      int v211 = v479;
      uint64_t v212 = v549;
      uint64_t v213 = v548;
      uint64_t v214 = v549 - v547;
      uint64_t v215 = v553;
      uint64_t v216 = v552;
      uint64_t v217 = v553 - v551;
      uint64_t v218 = v550 - v548;
      uint64_t v219 = v554 - v552;
      if (v479 | v485 | v210 | v206)
      {
        uint64_t v220 = v219 * v214 - v218 * v217;
        if (v219 * v214 != v218 * v217)
        {
          uint64_t v230 = v218 * v217 - v219 * v214;
          if (v220 >= 0) {
            uint64_t v224 = (v548 - v552) * v217 + v219 * (v551 - v547);
          }
          else {
            uint64_t v224 = -((v548 - v552) * v217 + v219 * (v551 - v547));
          }
          if (v220 >= 0) {
            uint64_t v227 = v220;
          }
          else {
            uint64_t v227 = -v220;
          }
          double v229 = (double)v224 * 1000000.0 / (double)v227;
          if (v230 >= 0) {
            uint64_t v228 = v230;
          }
          else {
            uint64_t v228 = -v230;
          }
          if (v230 >= 0) {
            uint64_t v225 = v218 * (v547 - v551) + (v552 - v548) * v214;
          }
          else {
            uint64_t v225 = -(v218 * (v547 - v551) + (v552 - v548) * v214);
          }
          double v226 = (double)v225 * 1000000.0 / (double)v228;
          goto LABEL_329;
        }
        int v485 = 0;
        int v211 = 0;
        int v210 = 0;
        int v206 = 0;
      }
      if (v214 < 0) {
        uint64_t v214 = v547 - v549;
      }
      if (v218 < 0) {
        uint64_t v218 = v548 - v550;
      }
      if (v217 < 0) {
        uint64_t v217 = v551 - v553;
      }
      if (v219 < 0) {
        uint64_t v219 = v552 - v554;
      }
      if (v171)
      {
        BOOL v221 = v217 >= (unint64_t)v219;
        goto LABEL_311;
      }
      if (v173)
      {
        BOOL v221 = v214 >= (unint64_t)v218;
LABEL_311:
        __int16 v222 = v221;
        goto LABEL_314;
      }
      if (v217 >= v214) {
        uint64_t v217 = v214;
      }
      if (v219 >= v218) {
        uint64_t v219 = v218;
      }
      if (v217 == v219)
      {
        if (v217) {
          __int16 v223 = 257;
        }
        else {
          __int16 v223 = 1;
        }
        if ((v223 & 0x100) != 0)
        {
LABEL_350:
          if (v223)
          {
            int v89 = v492;
            double v47 = 0.5;
            double v48 = -0.5;
            if (v171)
            {
              uint64_t v247 = v162;
              uint64_t v248 = v547;
              uint64_t v213 = v551;
              uint64_t v212 = v553;
LABEL_355:
              int v249 = 1;
            }
            else
            {
              if (!v173)
              {
                uint64_t v213 = v547;
                uint64_t v216 = v551;
                goto LABEL_405;
              }
              uint64_t v247 = v163;
              uint64_t v248 = v551;
              uint64_t v213 = v547;
LABEL_395:
              int v249 = 0;
            }
            sub_18E1D1C50((uint64_t)v568, v247, v248, v213, v212, v249);
          }
          else
          {
            int v89 = v492;
            double v47 = 0.5;
            double v48 = -0.5;
            if (v171)
            {
              uint64_t v247 = v162;
              uint64_t v248 = v548;
              uint64_t v213 = v552;
              uint64_t v212 = v554;
              goto LABEL_355;
            }
            if (v173)
            {
              uint64_t v247 = v163;
              uint64_t v248 = v552;
              uint64_t v212 = v550;
              goto LABEL_395;
            }
            uint64_t v212 = v550;
            uint64_t v215 = v554;
LABEL_405:
            sub_18E1D1F90((uint64_t)v568, (uint64_t)&v579, (uint64_t)v578, v213, v212, v216, v215);
          }
          uint64_t v85 = a7;
          uint64_t v13 = a6;
          uint64_t v88 = v506;
          uint64_t v14 = a4;
          long long v251 = xmmword_18E22C210;
          goto LABEL_418;
        }
        goto LABEL_315;
      }
      __int16 v222 = v217 > (unint64_t)v219;
LABEL_314:
      __int16 v223 = v222 | 0x100;
      if ((v223 & 0x100) != 0) {
        goto LABEL_350;
      }
LABEL_315:
      uint64_t v224 = 0;
      uint64_t v225 = 0;
      double v226 = 0.0;
      uint64_t v227 = 1;
      uint64_t v228 = 1;
      double v229 = 0.0;
LABEL_329:
      int v480 = v211;
      double v231 = v165 - v167;
      double v232 = v168 - v174;
      double v233 = v164 - v166;
      uint64_t v234 = 40;
      double v235 = v169 - v175;
      uint64_t v88 = v506;
      do
      {
        uint64_t v236 = (char *)&v580 + v234;
        *(_OWORD *)uint64_t v236 = xmmword_18E22C210;
        *((void *)v236 + 2) = 0;
        *((void *)v236 + 3) = 0;
        *((void *)v236 + 4) = 1;
        *((void *)v236 + 5) = 0;
        v236[48] = 0;
        v234 += 56;
      }
      while (v236 + 56 != (char *)&v588 + 8);
      int v477 = v210;
      int v478 = v206;
      *(void *)&long long v580 = 1;
      double v237 = v233 * v233 + v231 * v231;
      double v238 = v235 * v235 + v232 * v232;
      if (v237 >= v238) {
        double v239 = v233 * v233 + v231 * v231;
      }
      else {
        double v239 = v235 * v235 + v232 * v232;
      }
      double v47 = 0.5;
      double v48 = -0.5;
      uint64_t v475 = v228;
      uint64_t v476 = v225;
      if (v239 <= 0.0) {
        goto LABEL_340;
      }
      double v240 = vabdd_f64(0.5, v226 / 1000000.0);
      double v241 = v240 + v240;
      if (v241 > 1.0) {
        double v241 = 1.0;
      }
      double v242 = vabdd_f64(0.5, v229 / 1000000.0);
      double v243 = v242 + v242;
      if (v243 > 1.0) {
        double v243 = 1.0;
      }
      if (1.0 - v237 / v239 + v243 * 5.0 <= 1.0 - v238 / v239 + v241 * 5.0)
      {
        double v244 = v229;
        double v245 = v226;
        uint64_t v246 = v163;
        double v231 = v232;
        double v233 = v235;
      }
      else
      {
LABEL_340:
        double v244 = v229;
        double v245 = v226;
        uint64_t v246 = v162;
        uint64_t v225 = v224;
        uint64_t v228 = v227;
      }
      uint64_t v250 = v224;
      sub_18E1D37C8((double *)&v580 + 1, v246, v225, v228, v231, v233);
      uint64_t v13 = a6;
      uint64_t v14 = a4;
      v585[8] = 1;
      *((void *)&v582 + 1) = v250;
      *(void *)&long long v583 = v227;
      *((double *)&v583 + 1) = v244;
      *(void *)&long long v584 = v476;
      *((void *)&v584 + 1) = v475;
      *(double *)uint64_t v585 = v245;
      long long v251 = xmmword_18E22C210;
      if (!(v485 | v477))
      {
        int v253 = -1;
        if (v478 == 1) {
          int v254 = -1;
        }
        else {
          int v254 = 1;
        }
        if (v478 == 1) {
          int v255 = 1;
        }
        else {
          int v255 = -1;
        }
        unsigned __int8 v256 = 102;
        int v257 = -1;
        int v252 = v480;
        uint64_t v85 = a7;
        goto LABEL_417;
      }
      int v252 = v480;
      uint64_t v85 = a7;
      if (!(v480 | v478))
      {
        if (v477 == 1) {
          int v254 = -1;
        }
        else {
          int v254 = 1;
        }
        if (v477 == 1) {
          int v255 = 1;
        }
        else {
          int v255 = -1;
        }
        int v253 = 1;
        unsigned __int8 v256 = 116;
        int v257 = 1;
        goto LABEL_417;
      }
      if (!(v480 | v477))
      {
        if (v478 == 1) {
          int v254 = 1;
        }
        else {
          int v254 = -1;
        }
        int v257 = -1;
        int v253 = 1;
        goto LABEL_401;
      }
      if (!(v485 | v478))
      {
        if (v477 == 1) {
          int v254 = 1;
        }
        else {
          int v254 = -1;
        }
        int v257 = 1;
        int v253 = -1;
LABEL_401:
        unsigned __int8 v256 = 97;
        goto LABEL_402;
      }
      if (!v477)
      {
        int v253 = 0;
        BOOL v258 = v478 == 1;
        int v257 = -1;
        if (v478 == 1) {
          int v254 = -1;
        }
        else {
          int v254 = 1;
        }
LABEL_413:
        if (v258) {
          int v255 = v478;
        }
        else {
          int v255 = -1;
        }
        unsigned __int8 v256 = 115;
        goto LABEL_417;
      }
      if (!v485)
      {
        int v257 = 0;
        BOOL v258 = v478 == 1;
        int v253 = -1;
        if (v478 == 1) {
          int v254 = -1;
        }
        else {
          int v254 = 1;
        }
        goto LABEL_413;
      }
      if (v478)
      {
        if (v480)
        {
          int v253 = -1;
          if (v478 == 1) {
            int v254 = -1;
          }
          else {
            int v254 = 1;
          }
          if (v478 == 1) {
            int v255 = 1;
          }
          else {
            int v255 = -1;
          }
          unsigned __int8 v256 = 105;
          int v257 = -1;
          goto LABEL_417;
        }
        int v257 = 0;
        if (v478 == 1) {
          int v254 = 1;
        }
        else {
          int v254 = -1;
        }
        int v253 = 1;
      }
      else
      {
        int v253 = 0;
        if (v480 == 1) {
          int v254 = 1;
        }
        else {
          int v254 = -1;
        }
        int v257 = 1;
      }
      unsigned __int8 v256 = 109;
LABEL_402:
      int v255 = v254;
LABEL_417:
      long long v571 = *(_OWORD *)&v585[16];
      *(_OWORD *)uint64_t v572 = v586;
      *(_OWORD *)&v572[16] = v587;
      uint64_t v573 = v588;
      *(_OWORD *)&v568[32] = v582;
      *(_OWORD *)&v568[48] = v583;
      long long v569 = v584;
      long long v570 = *(_OWORD *)v585;
      *(_OWORD *)uint64_t v568 = v580;
      *(_OWORD *)&v568[16] = v581;
      __int16 v574 = v256;
      *(_DWORD *)&v575[2] = v253;
      *(_DWORD *)&v575[6] = v257;
      *(_DWORD *)&v575[10] = v254;
      *(_DWORD *)&v575[14] = v255;
      *(_DWORD *)&v575[18] = v485;
      *(_DWORD *)&v575[22] = v252;
      *(_DWORD *)&v575[26] = v477;
      *(_DWORD *)&v575[30] = v478;
      *(_DWORD *)&v575[34] = v253;
      *(_DWORD *)&v575[38] = v257;
      int v89 = v492;
LABEL_418:
      uint64_t v576 = a10;
      uint64_t v577 = (long long *)a11;
      if (v574 == 100) {
        goto LABEL_238;
      }
      *(_OWORD *)double v598 = v523;
      *(_OWORD *)&v598[16] = v524;
      double v599 = v525;
      *(_OWORD *)&v594[16] = v520;
      long long v595 = v521;
      long long v597 = *(_OWORD *)&v522[16];
      long long v596 = *(_OWORD *)v522;
      *(_OWORD *)&v591[32] = v517;
      long long v592 = *(_OWORD *)v518;
      *(_OWORD *)uint64_t v594 = v519;
      long long v593 = *(_OWORD *)&v518[16];
      *(_OWORD *)&v591[16] = v516;
      *(_OWORD *)uint64_t v591 = v515;
      if (v574 > 0x6Cu)
      {
        if (v574 == 116)
        {
          uint64_t v291 = 0;
          *(_DWORD *)&v591[16] = 3;
          *(_OWORD *)uint64_t v591 = *(_OWORD *)&v568[8];
          char v292 = 1;
          do
          {
            char v293 = v292;
            int v294 = *(_DWORD *)&v575[4 * v291 + 34];
            if (v294 == -1)
            {
              uint64_t v296 = &v591[80 * v291 + 40];
              *((_OWORD *)v296 + 3) = v251;
              *((void *)v296 + 8) = 0;
            }
            else if (v294 == 1)
            {
              double v295 = (int64x2_t *)&v591[80 * v291 + 40];
              v295[3] = vdupq_n_s64(1uLL);
              v295[4].i64[0] = 0x412E848000000000;
            }
            else
            {
              if (v293) {
                uint64_t v297 = (long long *)&v568[40];
              }
              else {
                uint64_t v297 = &v569;
              }
              uint64_t v298 = &v591[80 * v291 + 40];
              *((_OWORD *)v298 + 3) = *v297;
              *((void *)v298 + 8) = *((void *)v297 + 2);
            }
            char v292 = 0;
            uint64_t v291 = 1;
          }
          while ((v293 & 1) != 0);
          uint64_t v299 = (uint64_t *)v565[2];
          uint64_t v300 = (uint64_t *)v565[3];
          uint64_t v301 = (uint64_t *)sub_18E1D19E4((uint64_t)v564);
          *(void *)&long long v580 = 0x3FF0000000000000;
          double v302 = sub_18E1D1B30(*v299, v299[1], *v300, v300[1], *v301, v301[1], (double *)&v580);
          if (v302 == 0.0)
          {
LABEL_464:
            int v486 = 0;
          }
          else
          {
            if ((*(void *)&v302 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
            {
              if (v302 > 0.0) {
                int v305 = 1;
              }
              else {
                int v305 = -1;
              }
            }
            else
            {
              double v304 = fabs(v302);
              if (v302 > 0.0) {
                int v305 = 1;
              }
              else {
                int v305 = -1;
              }
              if (v304 <= *(double *)&v580 * 2.22044605e-16) {
                goto LABEL_464;
              }
            }
            int v486 = v305;
          }
          int v308 = *(_DWORD *)&v575[26];
          double v309 = (uint64_t *)v564[2];
          double v310 = (uint64_t *)v564[3];
          double v311 = (uint64_t *)sub_18E1D19E4((uint64_t)v565);
          *(void *)&long long v580 = 0x3FF0000000000000;
          double v312 = sub_18E1D1B30(*v309, v309[1], *v310, v310[1], *v311, v311[1], (double *)&v580);
          if (v312 == 0.0)
          {
LABEL_494:
            int v313 = 0;
          }
          else if ((*(void *)&v312 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
          {
            if (v312 > 0.0) {
              int v313 = 1;
            }
            else {
              int v313 = -1;
            }
          }
          else
          {
            double v314 = fabs(v312);
            if (v312 > 0.0) {
              int v313 = 1;
            }
            else {
              int v313 = -1;
            }
            if (v314 <= *(double *)&v580 * 2.22044605e-16) {
              goto LABEL_494;
            }
          }
          if (v313 * v308 != -1)
          {
            double v315 = (uint64_t *)v565[3];
            double v316 = (uint64_t *)sub_18E1D19E4((uint64_t)v565);
            unint64_t v317 = (uint64_t *)sub_18E1D19E4((uint64_t)v564);
            *(void *)&long long v580 = 0x3FF0000000000000;
            double v318 = sub_18E1D1B30(*v315, v315[1], *v316, v316[1], *v317, v317[1], (double *)&v580);
            if (v318 == 0.0) {
              goto LABEL_506;
            }
            if ((*(void *)&v318 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
            {
              if (v318 > 0.0) {
                int v319 = 1;
              }
              else {
                int v319 = -1;
              }
            }
            else
            {
              double v325 = fabs(v318);
              if (v318 > 0.0) {
                int v319 = 1;
              }
              else {
                int v319 = -1;
              }
              if (v325 <= *(double *)&v580 * 2.22044605e-16) {
LABEL_506:
              }
                int v319 = 0;
            }
            uint64_t v335 = (uint64_t *)v564[2];
            double v336 = (uint64_t *)v564[3];
            uint64_t v337 = (uint64_t *)sub_18E1D19E4((uint64_t)v564);
            *(void *)&long long v580 = 0x3FF0000000000000;
            double v338 = sub_18E1D1B30(*v335, v335[1], *v336, v336[1], *v337, v337[1], (double *)&v580);
            if (v338 == 0.0)
            {
LABEL_539:
              int v339 = 0;
            }
            else if ((*(void *)&v338 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
            {
              if (v338 > 0.0) {
                int v339 = 1;
              }
              else {
                int v339 = -1;
              }
            }
            else
            {
              double v340 = fabs(v338);
              if (v338 > 0.0) {
                int v339 = 1;
              }
              else {
                int v339 = -1;
              }
              if (v340 <= *(double *)&v580 * 2.22044605e-16) {
                goto LABEL_539;
              }
            }
            uint64_t v341 = (uint64_t *)v565[2];
            uint64_t v342 = (uint64_t *)v565[3];
            int8x16_t v343 = (uint64_t *)sub_18E1D19E4((uint64_t)v565);
            *(void *)&long long v580 = 0x3FF0000000000000;
            double v344 = sub_18E1D1B30(*v341, v341[1], *v342, v342[1], *v343, v343[1], (double *)&v580);
            uint64_t v14 = a4;
            uint64_t v103 = v504;
            if (v344 == 0.0)
            {
LABEL_550:
              int v345 = 0;
            }
            else if ((*(void *)&v344 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
            {
              if (v344 > 0.0) {
                int v345 = 1;
              }
              else {
                int v345 = -1;
              }
            }
            else
            {
              double v346 = fabs(v344);
              if (v344 > 0.0) {
                int v345 = 1;
              }
              else {
                int v345 = -1;
              }
              if (v346 <= *(double *)&v580 * 2.22044605e-16) {
                goto LABEL_550;
              }
            }
            if (v313) {
              BOOL v347 = 1;
            }
            else {
              BOOL v347 = v345 * v308 == 1;
            }
            int v348 = !v347;
            if (v339 != v308 && v339 != v313 && (v313 | v308 || v339 == -1))
            {
              if (v345 == 1) {
                int v354 = 2;
              }
              else {
                int v354 = 1;
              }
              if (v313 == 1 || v308 == 1) {
                int v356 = 1;
              }
              else {
                int v356 = 2;
              }
              if (v348) {
                int v356 = 3;
              }
              *(_DWORD *)&v591[40] = v354;
              DWORD2(v595) = v356;
              uint64_t v85 = a7;
              uint64_t v13 = a6;
              int v89 = v492;
              uint64_t v88 = v506;
              if (v348) {
                goto LABEL_885;
              }
            }
            else
            {
              if (v319) {
                char v349 = 1;
              }
              else {
                char v349 = v348;
              }
              if ((v349 & 1) == 0)
              {
                *(_DWORD *)&v591[40] = 4;
                DWORD2(v595) = 4;
                uint64_t v85 = a7;
                uint64_t v13 = a6;
                goto LABEL_720;
              }
              uint64_t v85 = a7;
              uint64_t v13 = a6;
              uint64_t v88 = v506;
              if (!v486)
              {
                if (v345 == 1) {
                  int v371 = 2;
                }
                else {
                  int v371 = 1;
                }
                if (v348) {
                  int v371 = 3;
                }
                *(_DWORD *)&v591[40] = 3;
                DWORD2(v595) = v371;
                goto LABEL_884;
              }
              if (v486 == v319 && v345 * v486 != -1)
              {
                BOOL v350 = v345 == 1;
                if (v345 == 1) {
                  int v351 = 1;
                }
                else {
                  int v351 = 2;
                }
                if (v350) {
                  int v352 = 2;
                }
                else {
                  int v352 = 1;
                }
                if (v348) {
                  int v353 = 3;
                }
                else {
                  int v353 = v352;
                }
                *(_DWORD *)&v591[40] = v351;
                DWORD2(v595) = v353;
                goto LABEL_884;
              }
              if (!(v319 + v345))
              {
                BOOL v373 = v345 == 1;
                if (v345 == 1) {
                  int v374 = 2;
                }
                else {
                  int v374 = 1;
                }
                if (v373) {
                  int v375 = 1;
                }
                else {
                  int v375 = 2;
                }
                *(_DWORD *)&v591[40] = v374;
                DWORD2(v595) = v375;
                v591[20] = 1;
                goto LABEL_884;
              }
              int v89 = v492;
              if (v486 != -v345) {
                goto LABEL_885;
              }
              if (v345 == 1) {
                int v435 = 2;
              }
              else {
                int v435 = 1;
              }
              *(_DWORD *)&v591[40] = v435;
              DWORD2(v595) = v435;
              if (v348)
              {
                DWORD2(v595) = 3;
                goto LABEL_885;
              }
            }
            v591[20] = 1;
            goto LABEL_885;
          }
          uint64_t v320 = (uint64_t *)v564[2];
          unint64_t v321 = (uint64_t *)v564[3];
          long long v322 = (uint64_t *)sub_18E1D19E4((uint64_t)v564);
          *(void *)&long long v580 = 0x3FF0000000000000;
          double v323 = sub_18E1D1B30(*v320, v320[1], *v321, v321[1], *v322, v322[1], (double *)&v580);
          int v89 = v492;
          uint64_t v103 = v504;
          if (v323 == 0.0)
          {
LABEL_508:
            int v324 = 0;
          }
          else if ((*(void *)&v323 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
          {
            if (v323 > 0.0) {
              int v324 = 1;
            }
            else {
              int v324 = -1;
            }
          }
          else
          {
            double v326 = fabs(v323);
            if (v323 > 0.0) {
              int v324 = 1;
            }
            else {
              int v324 = -1;
            }
            if (v326 <= *(double *)&v580 * 2.22044605e-16) {
              goto LABEL_508;
            }
          }
          BOOL v170 = v324 == v308;
          uint64_t v88 = v506;
          if (v170)
          {
            if (v486)
            {
              if (v486 != v313) {
                goto LABEL_664;
              }
              if (v313 == 1) {
                int v376 = 1;
              }
              else {
                int v376 = 2;
              }
              *(_DWORD *)&v591[40] = v376;
              DWORD2(v595) = v376;
LABEL_818:
              v591[20] = 1;
              goto LABEL_826;
            }
            if (v313 == 1) {
              int v385 = 1;
            }
            else {
              int v385 = 2;
            }
            *(_DWORD *)&v591[40] = 3;
          }
          else
          {
LABEL_664:
            if (v324 != v313) {
              goto LABEL_819;
            }
            double v377 = (uint64_t *)v565[3];
            double v378 = (uint64_t *)sub_18E1D19E4((uint64_t)v565);
            double v379 = (uint64_t *)sub_18E1D19E4((uint64_t)v564);
            *(void *)&long long v580 = 0x3FF0000000000000;
            uint64_t v381 = *v377;
            uint64_t v380 = v377[1];
            uint64_t v88 = v506;
            uint64_t v382 = *v378;
            uint64_t v383 = v378[1];
            int v89 = v492;
            double v384 = sub_18E1D1B30(v381, v380, v382, v383, *v379, v379[1], (double *)&v580);
            if (v384 == 0.0) {
              goto LABEL_666;
            }
            if ((*(void *)&v384 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
            {
              if (v384 > 0.0) {
                int v412 = 1;
              }
              else {
                int v412 = -1;
              }
              goto LABEL_810;
            }
            double v411 = fabs(v384);
            if (v384 > 0.0) {
              int v412 = 1;
            }
            else {
              int v412 = -1;
            }
            if (v411 > *(double *)&v580 * 2.22044605e-16)
            {
LABEL_810:
              if (v412 == v313)
              {
                if (v313 == 1) {
                  int v438 = 1;
                }
                else {
                  int v438 = 2;
                }
                if (v313 == 1) {
                  int v439 = 2;
                }
                else {
                  int v439 = 1;
                }
                *(_DWORD *)&v591[40] = v438;
                DWORD2(v595) = v439;
                goto LABEL_818;
              }
LABEL_819:
              if (v313 == 1) {
                int v440 = 2;
              }
              else {
                int v440 = 1;
              }
              if (v313 == 1) {
                int v441 = 1;
              }
              else {
                int v441 = 2;
              }
              *(_DWORD *)&v591[40] = v440;
              DWORD2(v595) = v441;
LABEL_826:
              uint64_t v13 = a6;
              goto LABEL_885;
            }
LABEL_666:
            int v385 = 4;
            *(_DWORD *)&v591[40] = 4;
          }
          DWORD2(v595) = v385;
          goto LABEL_826;
        }
        if (v574 == 109)
        {
          *(_DWORD *)&v591[16] = 4;
          *(_OWORD *)uint64_t v591 = *(_OWORD *)&v568[8];
          uint64_t v260 = 0;
          char v261 = 1;
          if (*(_DWORD *)&v575[38] == 1)
          {
            do
            {
              char v262 = v261;
              int v263 = *(_DWORD *)&v575[4 * v260 + 34];
              if (v263 == -1)
              {
                double v265 = &v591[80 * v260 + 40];
                *((_OWORD *)v265 + 3) = v251;
                *((void *)v265 + 8) = 0;
              }
              else if (v263 == 1)
              {
                double v264 = (int64x2_t *)&v591[80 * v260 + 40];
                v264[3] = vdupq_n_s64(1uLL);
                v264[4].i64[0] = 0x412E848000000000;
              }
              else
              {
                if (v262) {
                  uint64_t v266 = (long long *)&v568[40];
                }
                else {
                  uint64_t v266 = &v569;
                }
                uint64_t v267 = &v591[80 * v260 + 40];
                *((_OWORD *)v267 + 3) = *v266;
                *((void *)v267 + 8) = *((void *)v266 + 2);
              }
              char v261 = 0;
              uint64_t v260 = 1;
            }
            while ((v262 & 1) != 0);
            int v268 = *(_DWORD *)&v575[26];
            uint64_t v269 = (uint64_t *)v564[2];
            uint64_t v270 = (uint64_t *)v564[3];
            uint64_t v271 = (uint64_t *)sub_18E1D19E4((uint64_t)v565);
            *(void *)&long long v580 = 0x3FF0000000000000;
            double v272 = sub_18E1D1B30(*v269, v269[1], *v270, v270[1], *v271, v271[1], (double *)&v580);
            if (v272 == 0.0)
            {
LABEL_437:
              int v273 = 0;
            }
            else if ((*(void *)&v272 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
            {
              if (v272 > 0.0) {
                int v273 = 1;
              }
              else {
                int v273 = -1;
              }
            }
            else
            {
              double v306 = fabs(v272);
              if (v272 > 0.0) {
                int v273 = 1;
              }
              else {
                int v273 = -1;
              }
              if (v306 <= *(double *)&v580 * 2.22044605e-16) {
                goto LABEL_437;
              }
            }
            if (!(v268 + v273))
            {
              BOOL v357 = v273 == -1;
              BOOL v358 = v273 != -1;
LABEL_613:
              *(_DWORD *)&v591[80 * v358 + 40] = 1;
              *(_DWORD *)&v591[80 * v357 + 40] = 2;
              uint64_t v88 = v506;
              uint64_t v14 = a4;
              int v89 = v492;
              uint64_t v103 = v504;
              goto LABEL_885;
            }
            float64x2_t v359 = (uint64_t *)v565[2];
            uint64_t v360 = (uint64_t *)v565[3];
            uint64_t v361 = (uint64_t *)sub_18E1D19E4((uint64_t)v565);
            *(void *)&long long v580 = 0x3FF0000000000000;
            double v362 = sub_18E1D1B30(*v359, v359[1], *v360, v360[1], *v361, v361[1], (double *)&v580);
            if (v362 == 0.0)
            {
LABEL_607:
              int v363 = 0;
            }
            else if ((*(void *)&v362 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
            {
              if (v362 > 0.0) {
                int v363 = 1;
              }
              else {
                int v363 = -1;
              }
            }
            else
            {
              double v369 = fabs(v362);
              if (v362 > 0.0) {
                int v363 = 1;
              }
              else {
                int v363 = -1;
              }
              if (v369 <= *(double *)&v580 * 2.22044605e-16) {
                goto LABEL_607;
              }
            }
            double v386 = (uint64_t *)v565[3];
            unsigned int v387 = (uint64_t *)sub_18E1D19E4((uint64_t)v565);
            double v388 = (uint64_t *)v564[3];
            *(void *)&long long v580 = 0x3FF0000000000000;
            double v389 = sub_18E1D1B30(*v386, v386[1], *v387, v387[1], *v388, v388[1], (double *)&v580);
            uint64_t v103 = v504;
            if (v389 == 0.0)
            {
LABEL_676:
              int v390 = 0;
            }
            else if ((*(void *)&v389 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
            {
              if (v389 > 0.0) {
                int v390 = 1;
              }
              else {
                int v390 = -1;
              }
            }
            else
            {
              double v391 = fabs(v389);
              if (v389 > 0.0) {
                int v390 = 1;
              }
              else {
                int v390 = -1;
              }
              if (v391 <= *(double *)&v580 * 2.22044605e-16) {
                goto LABEL_676;
              }
            }
            if ((v273 & v268) != 0xFFFFFFFF || v363 != 1)
            {
              if (v268 == 1 && v273 == 1 && v363 == -1)
              {
                if (v390 == -1) {
                  int v397 = 1;
                }
                else {
                  int v397 = 3;
                }
                *(_DWORD *)&v591[40] = 1;
LABEL_717:
                DWORD2(v595) = v397;
LABEL_718:
                v591[20] = 1;
LABEL_719:
                uint64_t v13 = a6;
                uint64_t v14 = a4;
LABEL_720:
                int v89 = v492;
LABEL_721:
                uint64_t v88 = v506;
                goto LABEL_885;
              }
              if (v268 == v273 && v268 == v363)
              {
                int v398 = (v363 == 1) ^ (v390 == 0);
                if (v390 * v268 == -1)
                {
                  double v400 = (uint64_t *)v564[2];
                  double v399 = (uint64_t *)v564[3];
                  double v401 = (uint64_t *)v565[3];
                  uint64_t v402 = *v400;
                  uint64_t v403 = v400[1];
                  uint64_t v404 = *v399;
                  uint64_t v405 = v399[1];
                  uint64_t v406 = *v401;
                  uint64_t v407 = v401[1];
                  *(void *)&long long v580 = 0x3FF0000000000000;
                  double v408 = sub_18E1D1B30(v402, v403, v404, v405, v406, v407, (double *)&v580);
                  uint64_t v13 = a6;
                  if (v408 == 0.0) {
                    goto LABEL_710;
                  }
                  if ((*(void *)&v408 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
                  {
                    if (v408 > 0.0) {
                      int v409 = 1;
                    }
                    else {
                      int v409 = -1;
                    }
                  }
                  else
                  {
                    double v454 = fabs(v408);
                    if (v408 > 0.0) {
                      int v409 = 1;
                    }
                    else {
                      int v409 = -1;
                    }
                    if (v454 <= *(double *)&v580 * 2.22044605e-16) {
LABEL_710:
                    }
                      int v409 = 0;
                  }
                  double v456 = (uint64_t *)v564[3];
                  double v457 = (uint64_t *)sub_18E1D19E4((uint64_t)v564);
                  uint64_t v458 = (uint64_t *)v565[3];
                  *(void *)&long long v580 = 0x3FF0000000000000;
                  double v459 = sub_18E1D1B30(*v456, v456[1], *v457, v457[1], *v458, v458[1], (double *)&v580);
                  if (v459 == 0.0)
                  {
LABEL_853:
                    int v460 = 0;
                  }
                  else if ((*(void *)&v459 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
                  {
                    if (v459 > 0.0) {
                      int v460 = 1;
                    }
                    else {
                      int v460 = -1;
                    }
                  }
                  else
                  {
                    double v461 = fabs(v459);
                    if (v459 > 0.0) {
                      int v460 = 1;
                    }
                    else {
                      int v460 = -1;
                    }
                    if (v461 <= *(double *)&v580 * 2.22044605e-16) {
                      goto LABEL_853;
                    }
                  }
                  int v468 = v460 * v409;
                  uint64_t v103 = v504;
                  uint64_t v88 = v506;
                  if (v468 == 1)
                  {
                    uint64_t v469 = (uint64_t)v564;
                    uint64_t v470 = (uint64_t)v565;
LABEL_881:
                    if (sub_18E1D3830(**(void **)(v469 + 24), *(void *)(*(void *)(v469 + 24) + 8), **(void **)(v470 + 16), *(void *)(*(void *)(v470 + 16) + 8), **(void **)(v470 + 24), *(void *)(*(void *)(v470 + 24) + 8))* v390 == -1)v398 ^= 1u; {
                  }
                    }
                  goto LABEL_883;
                }
LABEL_732:
                uint64_t v13 = a6;
                uint64_t v88 = v506;
                goto LABEL_883;
              }
              if (!v273)
              {
                int v89 = v492;
                if (v268 != v363)
                {
                  if (v363 == 1) {
                    int v436 = 2;
                  }
                  else {
                    int v436 = 1;
                  }
                  *(_DWORD *)&v591[40] = v436;
                  int v437 = 3;
LABEL_831:
                  DWORD2(v595) = v437;
LABEL_836:
                  uint64_t v13 = a6;
                  uint64_t v14 = a4;
                  goto LABEL_721;
                }
                goto LABEL_830;
              }
              goto LABEL_806;
            }
LABEL_716:
            int v397 = 2;
            *(_DWORD *)&v591[40] = 2;
            goto LABEL_717;
          }
          do
          {
            char v274 = v261;
            int v275 = *(_DWORD *)&v575[4 * v260 + 34];
            if (v275 == -1)
            {
              uint64_t v277 = &v591[80 * v260 + 40];
              *((_OWORD *)v277 + 3) = v251;
              *((void *)v277 + 8) = 0;
            }
            else if (v275 == 1)
            {
              char v276 = (int64x2_t *)&v591[80 * v260 + 40];
              v276[3] = vdupq_n_s64(1uLL);
              v276[4].i64[0] = 0x412E848000000000;
            }
            else
            {
              if (v274) {
                uint64_t v278 = (long long *)&v568[40];
              }
              else {
                uint64_t v278 = &v569;
              }
              uint64_t v279 = &v591[80 * v260 + 40];
              *((_OWORD *)v279 + 3) = *v278;
              *((void *)v279 + 8) = *((void *)v278 + 2);
            }
            char v261 = 0;
            uint64_t v260 = 1;
          }
          while ((v274 & 1) != 0);
          int v280 = *(_DWORD *)&v575[18];
          uint64_t v281 = (uint64_t *)v566[2];
          char v282 = (uint64_t *)v566[3];
          double v283 = (uint64_t *)sub_18E1D19E4((uint64_t)v567);
          *(void *)&long long v580 = 0x3FF0000000000000;
          double v284 = sub_18E1D1B30(*v281, v281[1], *v282, v282[1], *v283, v283[1], (double *)&v580);
          if (v284 == 0.0)
          {
LABEL_448:
            int v285 = 0;
          }
          else if ((*(void *)&v284 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
          {
            if (v284 > 0.0) {
              int v285 = 1;
            }
            else {
              int v285 = -1;
            }
          }
          else
          {
            double v307 = fabs(v284);
            if (v284 > 0.0) {
              int v285 = 1;
            }
            else {
              int v285 = -1;
            }
            if (v307 <= *(double *)&v580 * 2.22044605e-16) {
              goto LABEL_448;
            }
          }
          if (!(v280 + v285))
          {
            BOOL v357 = v285 != -1;
            BOOL v358 = v285 == -1;
            goto LABEL_613;
          }
          uint64_t v364 = (uint64_t *)v567[2];
          char v365 = (uint64_t *)v567[3];
          char v366 = (uint64_t *)sub_18E1D19E4((uint64_t)v567);
          *(void *)&long long v580 = 0x3FF0000000000000;
          double v367 = sub_18E1D1B30(*v364, v364[1], *v365, v365[1], *v366, v366[1], (double *)&v580);
          if (v367 == 0.0)
          {
LABEL_615:
            int v368 = 0;
          }
          else if ((*(void *)&v367 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
          {
            if (v367 > 0.0) {
              int v368 = 1;
            }
            else {
              int v368 = -1;
            }
          }
          else
          {
            double v370 = fabs(v367);
            if (v367 > 0.0) {
              int v368 = 1;
            }
            else {
              int v368 = -1;
            }
            if (v370 <= *(double *)&v580 * 2.22044605e-16) {
              goto LABEL_615;
            }
          }
          double v392 = (uint64_t *)v567[3];
          double v393 = (uint64_t *)sub_18E1D19E4((uint64_t)v567);
          double v394 = (uint64_t *)v566[3];
          *(void *)&long long v580 = 0x3FF0000000000000;
          double v395 = sub_18E1D1B30(*v392, v392[1], *v393, v393[1], *v394, v394[1], (double *)&v580);
          uint64_t v103 = v504;
          if (v395 == 0.0)
          {
LABEL_687:
            int v390 = 0;
          }
          else if ((*(void *)&v395 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
          {
            if (v395 > 0.0) {
              int v390 = 1;
            }
            else {
              int v390 = -1;
            }
          }
          else
          {
            double v396 = fabs(v395);
            if (v395 > 0.0) {
              int v390 = 1;
            }
            else {
              int v390 = -1;
            }
            if (v396 <= *(double *)&v580 * 2.22044605e-16) {
              goto LABEL_687;
            }
          }
          if ((v285 & v280) == 0xFFFFFFFF && v368 == 1) {
            goto LABEL_716;
          }
          if (v280 == 1 && v285 == 1 && v368 == -1)
          {
            if (v390 == -1) {
              int v410 = 1;
            }
            else {
              int v410 = 3;
            }
            *(_DWORD *)&v591[40] = v410;
            DWORD2(v595) = 1;
            goto LABEL_718;
          }
          if (v280 != v285 || v280 != v368)
          {
            if (!v285)
            {
              int v89 = v492;
              if (v280 != v368)
              {
                if (v368 == 1) {
                  int v453 = 2;
                }
                else {
                  int v453 = 1;
                }
                DWORD2(v595) = v453;
                *(_DWORD *)&v591[40] = 3;
                goto LABEL_836;
              }
LABEL_830:
              int v437 = 4;
              *(_DWORD *)&v591[40] = 4;
              goto LABEL_831;
            }
LABEL_806:
            *(_DWORD *)&v591[16] = 8;
            goto LABEL_719;
          }
          int v398 = (v368 == 1) ^ (v390 != 0);
          if (v390 * v280 != -1) {
            goto LABEL_732;
          }
          uint64_t v443 = (uint64_t *)v566[2];
          uint64_t v442 = (uint64_t *)v566[3];
          uint64_t v444 = (uint64_t *)v567[3];
          uint64_t v445 = *v443;
          uint64_t v446 = v443[1];
          uint64_t v447 = *v442;
          uint64_t v448 = v442[1];
          uint64_t v449 = *v444;
          uint64_t v450 = v444[1];
          *(void *)&long long v580 = 0x3FF0000000000000;
          double v451 = sub_18E1D1B30(v445, v446, v447, v448, v449, v450, (double *)&v580);
          uint64_t v13 = a6;
          if (v451 == 0.0)
          {
LABEL_828:
            int v452 = 0;
          }
          else if ((*(void *)&v451 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
          {
            if (v451 > 0.0) {
              int v452 = 1;
            }
            else {
              int v452 = -1;
            }
          }
          else
          {
            double v455 = fabs(v451);
            if (v451 > 0.0) {
              int v452 = 1;
            }
            else {
              int v452 = -1;
            }
            if (v455 <= *(double *)&v580 * 2.22044605e-16) {
              goto LABEL_828;
            }
          }
          unsigned int v462 = (uint64_t *)v566[3];
          unsigned int v463 = (uint64_t *)sub_18E1D19E4((uint64_t)v566);
          uint64_t v464 = (uint64_t *)v567[3];
          *(void *)&long long v580 = 0x3FF0000000000000;
          double v465 = sub_18E1D1B30(*v462, v462[1], *v463, v463[1], *v464, v464[1], (double *)&v580);
          if (v465 == 0.0)
          {
LABEL_864:
            int v466 = 0;
          }
          else if ((*(void *)&v465 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
          {
            if (v465 > 0.0) {
              int v466 = 1;
            }
            else {
              int v466 = -1;
            }
          }
          else
          {
            double v467 = fabs(v465);
            if (v465 > 0.0) {
              int v466 = 1;
            }
            else {
              int v466 = -1;
            }
            if (v467 <= *(double *)&v580 * 2.22044605e-16) {
              goto LABEL_864;
            }
          }
          int v471 = v466 * v452;
          uint64_t v103 = v504;
          uint64_t v88 = v506;
          if (v471 == 1)
          {
            uint64_t v469 = (uint64_t)v566;
            uint64_t v470 = (uint64_t)v567;
            goto LABEL_881;
          }
LABEL_883:
          *(_DWORD *)&v591[80 * v398 + 40] = 1;
          *(_DWORD *)&v591[80 * (v398 ^ 1) + 40] = 2;
          v591[20] = 1;
          uint64_t v14 = a4;
LABEL_884:
          int v89 = v492;
          goto LABEL_885;
        }
        goto LABEL_465;
      }
      if (v574 != 99)
      {
        if (v574 == 105)
        {
          *(_DWORD *)&v591[16] = 2;
          if (!*(void *)v568) {
            goto LABEL_893;
          }
          *(_OWORD *)uint64_t v591 = *(_OWORD *)&v568[8];
          *(_OWORD *)&v594[8] = *(_OWORD *)&v568[40];
          *(void *)&v594[24] = *(void *)&v568[56];
          *(_OWORD *)&v598[8] = v569;
          *(void *)&v598[24] = v570;
          BOOL v259 = *(_DWORD *)&v575[26] == 1;
          *(_DWORD *)&v591[80 * (*(_DWORD *)&v575[26] != 1) + 40] = 1;
          *(_DWORD *)&v591[80 * v259 + 40] = 2;
          goto LABEL_885;
        }
LABEL_465:
        if (v574 == 101 && !HIBYTE(v574))
        {
          sub_18E1D140C((uint64_t)v591, (uint64_t)v568, (uint64_t)&v563);
LABEL_885:
          *(void *)&long long v580 = a12;
          sub_18E1D11F8((char ***)&v580, (long long *)v591);
          goto LABEL_238;
        }
        goto LABEL_238;
      }
      if (!HIBYTE(v574))
      {
        if (!*(_DWORD *)&v575[34])
        {
          sub_18E1D140C((uint64_t)v591, (uint64_t)v568, (uint64_t)&v563);
          *(_DWORD *)&v591[16] = 5;
          goto LABEL_885;
        }
        if (vabdd_f64(*(double *)&v570, *(double *)&v572[24]) >= 50.0)
        {
          unsigned int v303 = *(double *)&v570 < *(double *)&v572[24];
        }
        else
        {
          long long v580 = v569;
          sub_18E1D2DAC((int64_t *)&v580);
          long long v579 = *(_OWORD *)&v572[8];
          sub_18E1D2DAC((int64_t *)&v579);
          unsigned int v303 = sub_18E1D2CA0(v580, *((uint64_t *)&v580 + 1), v579, *((uint64_t *)&v579 + 1));
        }
        *(_DWORD *)&v591[16] = 5;
        if (*(void *)v568 <= (unint64_t)v303) {
LABEL_893:
        }
          __assert_rtn("assign_point", "get_turn_info.hpp", 164, "index < info.count");
        *(_OWORD *)uint64_t v591 = *(_OWORD *)&v568[16 * v303 + 8];
        double v328 = &v568[56 * v303];
        *(_OWORD *)&v594[8] = *(_OWORD *)(v328 + 40);
        *(void *)&v594[24] = *((void *)v328 + 7);
        *(_OWORD *)&v598[8] = *((_OWORD *)v328 + 4);
        *(void *)&v598[24] = *((void *)v328 + 10);
        int v329 = *(_DWORD *)&v575[34];
        if (!*(_DWORD *)&v575[34]) {
          __assert_rtn("apply", "get_turn_info.hpp", 1033, "arrival_p != 0");
        }
        uint64_t v330 = (uint64_t *)v564[2];
        uint64_t v331 = (uint64_t *)v564[3];
        uint64_t v332 = (uint64_t *)sub_18E1D19E4((uint64_t)v564);
        *(void *)&long long v580 = 0x3FF0000000000000;
        double v333 = sub_18E1D1B30(*v330, v330[1], *v331, v331[1], *v332, v332[1], (double *)&v580);
        if (v333 == 0.0)
        {
LABEL_534:
          int v334 = 0;
        }
        else if ((*(void *)&v333 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
        {
          if (v333 > 0.0) {
            int v334 = 1;
          }
          else {
            int v334 = -1;
          }
        }
        else
        {
          double v372 = fabs(v333);
          if (v333 > 0.0) {
            int v334 = 1;
          }
          else {
            int v334 = -1;
          }
          if (v372 <= *(double *)&v580 * 2.22044605e-16) {
            goto LABEL_534;
          }
        }
        double v418 = (uint64_t *)v565[2];
        double v419 = (uint64_t *)v565[3];
        double v420 = (uint64_t *)sub_18E1D19E4((uint64_t)v565);
        *(void *)&long long v580 = 0x3FF0000000000000;
        double v421 = sub_18E1D1B30(*v418, v418[1], *v419, v419[1], *v420, v420[1], (double *)&v580);
        uint64_t v14 = a4;
        if (v421 == 0.0)
        {
LABEL_757:
          int v422 = 0;
        }
        else if ((*(void *)&v421 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
        {
          if (v421 > 0.0) {
            int v422 = 1;
          }
          else {
            int v422 = -1;
          }
        }
        else
        {
          double v423 = fabs(v421);
          if (v421 > 0.0) {
            int v422 = 1;
          }
          else {
            int v422 = -1;
          }
          if (v423 <= *(double *)&v580 * 2.22044605e-16) {
            goto LABEL_757;
          }
        }
        if (v329 == 1) {
          int v424 = v334;
        }
        else {
          int v424 = v422;
        }
        if (v424 * v329 == 1) {
          int v425 = 1;
        }
        else {
          int v425 = 2;
        }
        if (v424 * v329 == 1) {
          int v426 = 2;
        }
        else {
          int v426 = 1;
        }
        BOOL v427 = v424 == 0;
        if (v424) {
          int v428 = v425;
        }
        else {
          int v428 = 4;
        }
        if (v427) {
          int v429 = 4;
        }
        else {
          int v429 = v426;
        }
        *(_DWORD *)&v591[40] = v428;
        DWORD2(v595) = v429;
        if (v334)
        {
          double v431 = *(double *)&v591[8];
          double v430 = *(double *)v591;
          double v432 = (*(double *)&v591[8] - *(double *)(*((void *)&v537 + 1) + 8))
               * (*(double *)&v591[8] - *(double *)(*((void *)&v537 + 1) + 8))
               + (*(double *)v591 - **((double **)&v537 + 1)) * (*(double *)v591 - **((double **)&v537 + 1));
          int v89 = v492;
          uint64_t v88 = v506;
        }
        else
        {
          uint64_t v88 = v506;
          if (!v541)
          {
            sub_18E1D16F4((uint64_t)v536, *((double **)&v537 + 1), (uint64_t)v538);
            long long v540 = *(_OWORD *)v538[0];
            char v541 = 1;
          }
          double v431 = *(double *)&v591[8];
          double v430 = *(double *)v591;
          double v432 = (*(double *)&v591[8] - *((double *)&v540 + 1)) * (*(double *)&v591[8] - *((double *)&v540 + 1))
               + (*(double *)v591 - *(double *)&v540) * (*(double *)v591 - *(double *)&v540);
          int v89 = v492;
        }
        *(double *)&long long v595 = v432;
        if (v422)
        {
          double v433 = *v528;
          double v434 = v528[1];
        }
        else
        {
          if (!v532)
          {
            sub_18E1D16F4((uint64_t)v526, v528, (uint64_t)v529);
            long long v531 = *(_OWORD *)v529[0];
            char v532 = 1;
            double v431 = *(double *)&v591[8];
            double v430 = *(double *)v591;
          }
          double v434 = *((double *)&v531 + 1);
          double v433 = *(double *)&v531;
        }
        uint64_t v103 = v504;
        double v599 = (v431 - v434) * (v431 - v434) + (v430 - v433) * (v430 - v433);
        goto LABEL_885;
      }
      *(_OWORD *)uint64_t v589 = v523;
      *(_OWORD *)&v589[16] = v524;
      double v590 = v525;
      *(_OWORD *)&v585[16] = v520;
      long long v586 = v521;
      long long v588 = *(_OWORD *)&v522[16];
      long long v587 = *(_OWORD *)v522;
      long long v582 = v517;
      long long v583 = *(_OWORD *)v518;
      *(_OWORD *)uint64_t v585 = v519;
      long long v584 = *(_OWORD *)&v518[16];
      long long v581 = v516;
      long long v580 = v515;
      int v286 = *(_DWORD *)&v575[38];
      if (*(_DWORD *)&v575[34] == 1)
      {
        std::string v287 = (uint64_t *)v564[2];
        double v288 = (uint64_t *)v564[3];
        double v289 = (uint64_t *)sub_18E1D19E4((uint64_t)v564);
        *(void *)&long long v579 = 0x3FF0000000000000;
        double v290 = sub_18E1D1B30(*v287, v287[1], *v288, v288[1], *v289, v289[1], (double *)&v579);
        if (v290 == 0.0
          || (*(void *)&v290 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
          && fabs(v290) <= *(double *)&v579 * 2.22044605e-16)
        {
          int v89 = v492;
          uint64_t v103 = v504;
        }
        else
        {
          if (v290 <= 0.0) {
            int v327 = 1;
          }
          else {
            int v327 = 2;
          }
          int v89 = v492;
          uint64_t v103 = v504;
          DWORD2(v586) = 3;
          DWORD2(v582) = v327;
          LODWORD(v581) = 5;
          if (*(void *)v568 <= 1uLL) {
            goto LABEL_893;
          }
          long long v580 = *(_OWORD *)&v568[24];
          *(_OWORD *)&v585[8] = v571;
          *(void *)&v585[24] = *(void *)v572;
          *(_OWORD *)&v589[8] = *(_OWORD *)&v572[8];
          *(void *)&v589[24] = *(void *)&v572[24];
          *(void *)&long long v579 = a12;
          sub_18E1D11F8((char ***)&v579, &v580);
        }
      }
      if (v286 == 1)
      {
        double v413 = (uint64_t *)v565[2];
        BOOL v414 = (uint64_t *)v565[3];
        double v415 = (uint64_t *)sub_18E1D19E4((uint64_t)v565);
        *(void *)&long long v579 = 0x3FF0000000000000;
        double v416 = sub_18E1D1B30(*v413, v413[1], *v414, v414[1], *v415, v415[1], (double *)&v579);
        if (v416 == 0.0
          || (*(void *)&v416 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
          && fabs(v416) <= *(double *)&v579 * 2.22044605e-16)
        {
          int v89 = v492;
        }
        else
        {
          if (v416 <= 0.0) {
            int v417 = 1;
          }
          else {
            int v417 = 2;
          }
          int v89 = v492;
          DWORD2(v586) = v417;
          DWORD2(v582) = 3;
          LODWORD(v581) = 5;
          if (!*(void *)v568) {
            goto LABEL_893;
          }
          long long v580 = *(_OWORD *)&v568[8];
          *(_OWORD *)&v585[8] = *(_OWORD *)&v568[40];
          *(void *)&v585[24] = *(void *)&v568[56];
          *(_OWORD *)&v589[8] = v569;
          *(void *)&v589[24] = v570;
          *(void *)&long long v579 = a12;
          sub_18E1D11F8((char ***)&v579, &v580);
        }
      }
      uint64_t v88 = v506;
LABEL_238:
      uint64_t v191 = a12[1];
      if (0x8F5C28F5C28F5C29 * ((v191 - *a12) >> 3) < 0x8F5C28F5C28F5C29 * ((v503 - v502) >> 3)) {
        __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
      }
      uint64_t v192 = *a12 + 8 * ((v503 - v502) >> 3);
      *a13 = v192 != v191;
      if (v192 != v191) {
        return 0;
      }
LABEL_241:
      BOOL v64 = v511 + 2;
      ++v88;
      uint64_t v193 = v514 + 2;
      if (v514 + 2 == v85) {
        uint64_t v193 = &v13[2 * (v514 != v13)];
      }
      uint64_t v514 = v193;
      ++v508;
      uint64_t v83 = v103 + 2;
      if (v103 == v494) {
        goto LABEL_887;
      }
    }
    int v485 = 0;
    goto LABEL_255;
  }
  return v42;
}

char ***sub_18E1D11F8(char ***a1, long long *a2)
{
  uint64_t v4 = *a1;
  uint64_t v6 = (*a1)[1];
  unint64_t v5 = (unint64_t)(*a1)[2];
  if ((unint64_t)v6 >= v5)
  {
    int v17 = *v4;
    unint64_t v18 = 0x8F5C28F5C28F5C29 * ((v6 - *v4) >> 3);
    unint64_t v19 = v18 + 1;
    if (v18 + 1 > 0x147AE147AE147AELL) {
      sub_18DEE1FC8();
    }
    unint64_t v20 = 0x8F5C28F5C28F5C29 * ((uint64_t)(v5 - (void)v17) >> 3);
    if (2 * v20 > v19) {
      unint64_t v19 = 2 * v20;
    }
    if (v20 >= 0xA3D70A3D70A3D7) {
      unint64_t v21 = 0x147AE147AE147AELL;
    }
    else {
      unint64_t v21 = v19;
    }
    if (v21)
    {
      if (v21 > 0x147AE147AE147AELL) {
        sub_18DEDF7D4();
      }
      uint64_t v22 = (char *)operator new(200 * v21);
    }
    else
    {
      uint64_t v22 = 0;
    }
    long long v23 = a2[11];
    uint64_t v24 = &v22[200 * v18];
    *((_OWORD *)v24 + 10) = a2[10];
    *((_OWORD *)v24 + 11) = v23;
    *((void *)v24 + 24) = *((void *)a2 + 24);
    long long v25 = a2[7];
    *((_OWORD *)v24 + 6) = a2[6];
    *((_OWORD *)v24 + 7) = v25;
    long long v26 = a2[9];
    *((_OWORD *)v24 + 8) = a2[8];
    *((_OWORD *)v24 + 9) = v26;
    long long v27 = a2[3];
    *((_OWORD *)v24 + 2) = a2[2];
    *((_OWORD *)v24 + 3) = v27;
    long long v28 = a2[5];
    *((_OWORD *)v24 + 4) = a2[4];
    *((_OWORD *)v24 + 5) = v28;
    long long v30 = *a2;
    long long v29 = a2[1];
    BOOL v16 = v24 + 200;
    *(_OWORD *)uint64_t v24 = v30;
    *((_OWORD *)v24 + 1) = v29;
    if (v6 != v17)
    {
      do
      {
        *(_OWORD *)(v24 - 200) = *(_OWORD *)(v6 - 200);
        long long v31 = *(_OWORD *)(v6 - 184);
        long long v32 = *(_OWORD *)(v6 - 168);
        long long v33 = *(_OWORD *)(v6 - 152);
        *(_OWORD *)(v24 - 136) = *(_OWORD *)(v6 - 136);
        *(_OWORD *)(v24 - 152) = v33;
        *(_OWORD *)(v24 - 168) = v32;
        *(_OWORD *)(v24 - 184) = v31;
        long long v34 = *(_OWORD *)(v6 - 120);
        long long v35 = *(_OWORD *)(v6 - 104);
        long long v36 = *(_OWORD *)(v6 - 88);
        *(_OWORD *)(v24 - 72) = *(_OWORD *)(v6 - 72);
        *(_OWORD *)(v24 - 88) = v36;
        *(_OWORD *)(v24 - 104) = v35;
        *(_OWORD *)(v24 - 120) = v34;
        long long v37 = *(_OWORD *)(v6 - 56);
        long long v38 = *(_OWORD *)(v6 - 40);
        long long v39 = *(_OWORD *)(v6 - 24);
        *((void *)v24 - 1) = *((void *)v6 - 1);
        *(_OWORD *)(v24 - 24) = v39;
        *(_OWORD *)(v24 - 40) = v38;
        *(_OWORD *)(v24 - 56) = v37;
        v24 -= 200;
        v6 -= 200;
      }
      while (v6 != v17);
      uint64_t v6 = *v4;
    }
    *uint64_t v4 = v24;
    v4[1] = v16;
    void v4[2] = &v22[200 * v21];
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *a2;
    long long v7 = a2[1];
    long long v8 = a2[2];
    long long v9 = a2[4];
    *((_OWORD *)v6 + 3) = a2[3];
    *((_OWORD *)v6 + 4) = v9;
    *((_OWORD *)v6 + 1) = v7;
    *((_OWORD *)v6 + 2) = v8;
    long long v10 = a2[5];
    long long v11 = a2[6];
    long long v12 = a2[8];
    *((_OWORD *)v6 + 7) = a2[7];
    *((_OWORD *)v6 + 8) = v12;
    *((_OWORD *)v6 + 5) = v10;
    *((_OWORD *)v6 + 6) = v11;
    long long v13 = a2[9];
    long long v14 = a2[10];
    long long v15 = a2[11];
    *((void *)v6 + 24) = *((void *)a2 + 24);
    *((_OWORD *)v6 + 10) = v14;
    *((_OWORD *)v6 + 11) = v15;
    *((_OWORD *)v6 + 9) = v13;
    BOOL v16 = v6 + 200;
  }
  v4[1] = v16;
  return a1;
}

void sub_18E1D140C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v6 = *(double *)(a2 + 80);
  double v7 = *(double *)(a2 + 136);
  if (vabdd_f64(v6, v7) >= 50.0)
  {
    unsigned int v8 = v6 < v7;
  }
  else
  {
    long long v38 = *(_OWORD *)(a2 + 64);
    sub_18E1D2DAC((int64_t *)&v38);
    long long v37 = *(_OWORD *)(a2 + 120);
    sub_18E1D2DAC((int64_t *)&v37);
    unsigned int v8 = sub_18E1D2CA0(v38, *((uint64_t *)&v38 + 1), v37, *((uint64_t *)&v37 + 1));
  }
  *(_DWORD *)(a1 + 16) = 6;
  if (*(void *)a2 <= (unint64_t)v8) {
    __assert_rtn("assign_point", "get_turn_info.hpp", 164, "index < info.count");
  }
  *(_OWORD *)a1 = *(_OWORD *)(a2 + 16 * v8 + 8);
  uint64_t v9 = a2 + 56 * v8;
  long long v10 = *(_OWORD *)(v9 + 40);
  *(void *)(a1 + 104) = *(void *)(v9 + 56);
  *(_OWORD *)(a1 + 88) = v10;
  long long v11 = *(_OWORD *)(v9 + 64);
  *(void *)(a1 + 184) = *(void *)(v9 + 80);
  *(_OWORD *)(a1 + 168) = v11;
  uint64_t v12 = *(void *)(a3 + 16);
  long long v13 = *(uint64_t **)(v12 + 24);
  long long v14 = (uint64_t *)sub_18E1D19E4(v12);
  long long v15 = (uint64_t *)sub_18E1D19E4(*(void *)(a3 + 8));
  *(void *)&long long v38 = 0x3FF0000000000000;
  double v16 = sub_18E1D1B30(*v13, v13[1], *v14, v14[1], *v15, v15[1], (double *)&v38);
  if (v16 == 0.0) {
    goto LABEL_6;
  }
  if ((*(void *)&v16 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    if (v16 > 0.0) {
      int v17 = 1;
    }
    else {
      int v17 = -1;
    }
  }
  else
  {
    double v18 = fabs(v16);
    if (v16 > 0.0) {
      int v17 = 1;
    }
    else {
      int v17 = -1;
    }
    if (v18 <= *(double *)&v38 * 2.22044605e-16) {
LABEL_6:
    }
      int v17 = 0;
  }
  uint64_t v19 = *(void *)(a3 + 8);
  unint64_t v20 = *(uint64_t **)(v19 + 16);
  unint64_t v21 = *(uint64_t **)(v19 + 24);
  uint64_t v22 = (uint64_t *)sub_18E1D19E4(v19);
  *(void *)&long long v38 = 0x3FF0000000000000;
  double v23 = sub_18E1D1B30(*v20, v20[1], *v21, v21[1], *v22, v22[1], (double *)&v38);
  if (v23 == 0.0)
  {
LABEL_17:
    int v24 = 0;
    goto LABEL_27;
  }
  if ((*(void *)&v23 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    if (v23 > 0.0) {
      int v24 = 1;
    }
    else {
      int v24 = -1;
    }
  }
  else
  {
    double v25 = fabs(v23);
    if (v23 > 0.0) {
      int v24 = 1;
    }
    else {
      int v24 = -1;
    }
    if (v25 <= *(double *)&v38 * 2.22044605e-16) {
      goto LABEL_17;
    }
  }
LABEL_27:
  uint64_t v27 = *(void *)(a3 + 8);
  uint64_t v26 = *(void *)(a3 + 16);
  long long v28 = *(uint64_t **)(v27 + 16);
  long long v29 = *(uint64_t **)(v27 + 24);
  long long v30 = (uint64_t *)sub_18E1D19E4(v26);
  *(void *)&long long v38 = 0x3FF0000000000000;
  double v31 = sub_18E1D1B30(*v28, v28[1], *v29, v29[1], *v30, v30[1], (double *)&v38);
  if (v31 == 0.0)
  {
LABEL_28:
    int v32 = 0;
    goto LABEL_38;
  }
  if ((*(void *)&v31 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
  {
    double v33 = fabs(v31);
    if (v31 > 0.0) {
      int v32 = 1;
    }
    else {
      int v32 = -1;
    }
    if (v33 > *(double *)&v38 * 2.22044605e-16) {
      goto LABEL_38;
    }
    goto LABEL_28;
  }
  if (v31 > 0.0) {
    int v32 = 1;
  }
  else {
    int v32 = -1;
  }
LABEL_38:
  if (v17 || v24 != v32)
  {
    if (v32 * v24 == -1) {
      BOOL v35 = v24 == -1;
    }
    else {
      BOOL v35 = v17 == -1;
    }
    if (v35) {
      int v36 = 2;
    }
    else {
      int v36 = 1;
    }
    *(_DWORD *)(a1 + 40) = v36;
    if (v35) {
      int v34 = 1;
    }
    else {
      int v34 = 2;
    }
  }
  else
  {
    int v34 = 4;
    *(_DWORD *)(a1 + 40) = 4;
  }
  *(_DWORD *)(a1 + 120) = v34;
}

uint64_t sub_18E1D16F4(uint64_t a1, double *a2, uint64_t a3)
{
  double v6 = (double)*(uint64_t *)(a1 + 112) + (a2[1] - *(double *)(a1 + 96)) * *(double *)(a1 + 120);
  if (v6 >= 0.0) {
    double v7 = 0.5;
  }
  else {
    double v7 = -0.5;
  }
  double v8 = v6 + v7;
  if (v6 + v7 <= -9.22337204e18) {
    uint64_t v9 = 1;
  }
  else {
    uint64_t v9 = 2 * (v6 + v7 >= 9.22337204e18);
  }
  sub_18E1CBEE0(v9);
  double v10 = ceil(v8);
  double v11 = floor(v8);
  if (v8 >= 0.0) {
    double v10 = v11;
  }
  uint64_t v12 = (uint64_t)v10;
  double v13 = (double)*(uint64_t *)(a1 + 104) + (*a2 - *(double *)(a1 + 88)) * *(double *)(a1 + 120);
  if (v13 >= 0.0) {
    double v14 = 0.5;
  }
  else {
    double v14 = -0.5;
  }
  double v15 = v13 + v14;
  if (v13 + v14 <= -9.22337204e18) {
    uint64_t v16 = 1;
  }
  else {
    uint64_t v16 = 2 * (v13 + v14 >= 9.22337204e18);
  }
  sub_18E1CBEE0(v16);
  double v17 = ceil(v15);
  double v18 = floor(v15);
  if (v15 >= 0.0) {
    double v17 = v18;
  }
  uint64_t v19 = (uint64_t)v17;
  unint64_t v20 = *(double **)a3;
  double v21 = (double)*(uint64_t *)(a1 + 112)
      + (*(double *)(*(void *)a3 + 8) - *(double *)(a1 + 96)) * *(double *)(a1 + 120);
  if (v21 >= 0.0) {
    double v22 = 0.5;
  }
  else {
    double v22 = -0.5;
  }
  double v23 = v21 + v22;
  if (v21 + v22 <= -9.22337204e18) {
    uint64_t v24 = 1;
  }
  else {
    uint64_t v24 = 2 * (v21 + v22 >= 9.22337204e18);
  }
  sub_18E1CBEE0(v24);
  double v25 = ceil(v23);
  double v26 = floor(v23);
  if (v23 >= 0.0) {
    double v27 = v26;
  }
  else {
    double v27 = v25;
  }
  double v28 = (double)*(uint64_t *)(a1 + 104) + (*v20 - *(double *)(a1 + 88)) * *(double *)(a1 + 120);
  if (v28 >= 0.0) {
    double v29 = 0.5;
  }
  else {
    double v29 = -0.5;
  }
  double v30 = v28 + v29;
  if (v28 + v29 <= -9.22337204e18) {
    uint64_t v31 = 1;
  }
  else {
    uint64_t v31 = 2 * (v28 + v29 >= 9.22337204e18);
  }
  uint64_t result = sub_18E1CBEE0(v31);
  double v33 = ceil(v30);
  double v34 = floor(v30);
  if (v30 >= 0.0) {
    double v33 = v34;
  }
  if (v19 == (uint64_t)v33 && v12 == (uint64_t)v27)
  {
    uint64_t v36 = -1;
    do
    {
      if ((unint64_t)++v36 >= *(void *)(*(void *)a1 + 88)) {
        break;
      }
      long long v37 = *(double **)a3;
      long long v38 = (double *)(*(void *)a3 + 16);
      *(void *)a3 = v38;
      if (v38 == *(double **)(a3 + 16))
      {
        double v53 = *(double **)(a3 + 8);
        *(void *)a3 = v53;
        if (*(unsigned char *)(a3 + 24))
        {
          long long v38 = v53 + 2;
          *(void *)a3 = v53 + 2;
          if (v37 == v53)
          {
            *(void *)a3 = v53;
            long long v38 = v37;
          }
        }
        else
        {
          long long v38 = v53;
        }
      }
      double v39 = (double)*(uint64_t *)(a1 + 112) + (v38[1] - *(double *)(a1 + 96)) * *(double *)(a1 + 120);
      if (v39 >= 0.0) {
        double v40 = 0.5;
      }
      else {
        double v40 = -0.5;
      }
      double v41 = v39 + v40;
      if (v39 + v40 <= -9.22337204e18) {
        uint64_t v42 = 1;
      }
      else {
        uint64_t v42 = 2 * (v39 + v40 >= 9.22337204e18);
      }
      sub_18E1CBEE0(v42);
      double v43 = ceil(v41);
      double v44 = floor(v41);
      if (v41 >= 0.0) {
        double v45 = v44;
      }
      else {
        double v45 = v43;
      }
      double v46 = (double)*(uint64_t *)(a1 + 104) + (*v38 - *(double *)(a1 + 88)) * *(double *)(a1 + 120);
      if (v46 >= 0.0) {
        double v47 = 0.5;
      }
      else {
        double v47 = -0.5;
      }
      double v48 = v46 + v47;
      if (v46 + v47 <= -9.22337204e18) {
        uint64_t v49 = 1;
      }
      else {
        uint64_t v49 = 2 * (v46 + v47 >= 9.22337204e18);
      }
      uint64_t result = sub_18E1CBEE0(v49);
      double v50 = ceil(v48);
      double v51 = floor(v48);
      if (v48 >= 0.0) {
        double v50 = v51;
      }
    }
    while (v19 == (uint64_t)v50 && v12 == (uint64_t)v45);
  }
  return result;
}

uint64_t sub_18E1D19E4(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 48))
  {
    uint64_t v2 = *(void *)a1;
    if (!*(unsigned char *)(*(void *)a1 + 80))
    {
      sub_18E1D16F4(*(void *)a1, *(double **)(v2 + 24), v2 + 32);
      *(_OWORD *)(v2 + 64) = *(_OWORD *)*(void *)(v2 + 32);
      *(unsigned char *)(v2 + 80) = 1;
    }
    uint64_t v3 = *(void *)(a1 + 8);
    double v4 = (double)*(uint64_t *)(v3 + 24) + (*(double *)(v2 + 72) - *(double *)(v3 + 8)) * *(double *)(v3 + 32);
    if (v4 >= 0.0) {
      double v5 = 0.5;
    }
    else {
      double v5 = -0.5;
    }
    double v6 = v4 + v5;
    if (v4 + v5 <= -9.22337204e18) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = 2 * (v4 + v5 >= 9.22337204e18);
    }
    sub_18E1CBEE0(v7);
    double v8 = ceil(v6);
    double v9 = floor(v6);
    if (v6 >= 0.0) {
      double v8 = v9;
    }
    *(void *)(a1 + 40) = (uint64_t)v8;
    double v10 = (double)*(uint64_t *)(v3 + 16) + (*(double *)(v2 + 64) - *(double *)v3) * *(double *)(v3 + 32);
    if (v10 >= 0.0) {
      double v11 = 0.5;
    }
    else {
      double v11 = -0.5;
    }
    double v12 = v10 + v11;
    if (v10 + v11 <= -9.22337204e18) {
      uint64_t v13 = 1;
    }
    else {
      uint64_t v13 = 2 * (v10 + v11 >= 9.22337204e18);
    }
    sub_18E1CBEE0(v13);
    double v14 = ceil(v12);
    double v15 = floor(v12);
    if (v12 >= 0.0) {
      double v14 = v15;
    }
    *(void *)(a1 + 32) = (uint64_t)v14;
    *(unsigned char *)(a1 + 48) = 1;
  }
  return a1 + 32;
}

double sub_18E1D1B30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, double *a7)
{
  v20[0] = (double)a1;
  v20[1] = (double)a2;
  v19[0] = (double)a3;
  v19[1] = (double)a4;
  v18[0] = (double)a5;
  v18[1] = (double)a6;
  double v7 = (double)a1 - (double)a5;
  v27[0] = v7;
  double v8 = (double)a4 - (double)a6;
  v26[0] = v8;
  double v9 = (double)a2 - (double)a6;
  v25[0] = v9;
  double v10 = (double)a3 - (double)a5;
  v24[0] = v10;
  double v11 = vabdd_f64((double)a1, (double)a5);
  double v12 = vabdd_f64((double)a4, (double)a6);
  double v13 = vabdd_f64((double)a2, (double)a6);
  double v14 = vabdd_f64((double)a3, (double)a5);
  if (v11 < v12) {
    double v11 = v12;
  }
  if (v11 < v13) {
    double v11 = v13;
  }
  if (v11 < v14) {
    double v11 = v14;
  }
  if (v11 < 1.0) {
    double v11 = 1.0;
  }
  *a7 = v11;
  double v15 = v7 * v8;
  v23[0] = v7 * v8;
  double v16 = v10 * v9;
  double result = v7 * v8 - v10 * v9;
  double v21 = fabs(v7 * v8) + fabs(v10 * v9);
  v22[0] = v10 * v9;
  if (vabdd_f64(v7 * v8, v10 * v9) < v21 * 3.33066907e-16 && (v15 <= 0.0 || v16 > 0.0) && (v15 >= 0.0 || v16 < 0.0)) {
    return sub_18E12FC90(v20, v19, v18, v27, v26, v25, v24, v23, v22, &v21);
  }
  return result;
}

__n128 sub_18E1D1C50(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a3 - a4;
  uint64_t v7 = a5 - a4;
  if (a5 - a4 < 0)
  {
    uint64_t v6 = a4 - a3;
    uint64_t v7 = a4 - a5;
    goto LABEL_5;
  }
  if (v7)
  {
LABEL_5:
    double v8 = (double)v6 * 1000000.0 / (double)v7;
    goto LABEL_6;
  }
  double v8 = 0.0;
LABEL_6:
  if (v6 < 0 || v6 > (unint64_t)v7)
  {
    *(void *)long long v38 = 0;
    uint64_t v13 = 40;
    do
    {
      double v14 = &v38[v13];
      *(_OWORD *)double v14 = xmmword_18E22C210;
      *((void *)v14 + 2) = 0;
      *((void *)v14 + 3) = 0;
      *((void *)v14 + 4) = 1;
      *((void *)v14 + 5) = 0;
      unsigned char v14[48] = 0;
      v13 += 56;
    }
    while (v14 + 56 != v46);
    memset(&v47[2], 0, 32);
    long long v15 = v43;
    *(_OWORD *)(a1 + 96) = v42;
    *(_OWORD *)(a1 + 112) = v15;
    *(_OWORD *)(a1 + 128) = v44;
    long long v16 = *(_OWORD *)&v39[16];
    *(_OWORD *)(a1 + 32) = *(_OWORD *)v39;
    *(_OWORD *)(a1 + 48) = v16;
    long long v17 = v41;
    *(_OWORD *)(a1 + 64) = v40;
    *(_OWORD *)(a1 + 80) = v17;
    long long v18 = *(_OWORD *)&v38[16];
    *(_OWORD *)a1 = *(_OWORD *)v38;
    *(_OWORD *)(a1 + 16) = v18;
    long long v19 = *(_OWORD *)&v47[16];
    *(_OWORD *)(a1 + 154) = *(_OWORD *)v47;
    *(void *)&v47[34] = 0;
    *(void *)(a1 + 144) = v45;
    __int16 v20 = 100;
  }
  else
  {
    double v9 = (long long *)&v39[8];
    uint64_t v10 = 40;
    do
    {
      double v11 = &v38[v10];
      *(_OWORD *)double v11 = xmmword_18E22C210;
      *((void *)v11 + 2) = 0;
      *((void *)v11 + 3) = 0;
      *((void *)v11 + 4) = 1;
      *((void *)v11 + 5) = 0;
      unsigned char v11[48] = 0;
      v10 += 56;
    }
    while (v11 + 56 != v46);
    *(void *)long long v38 = 1;
    *(_OWORD *)&void v38[8] = *a2;
    unsigned __int8 explicit = atomic_load_explicit((atomic_uchar *volatile)&qword_1EB4052C0, memory_order_acquire);
    if (a6)
    {
      if ((explicit & 1) == 0)
      {
        uint64_t v26 = a1;
        uint64_t v27 = v6;
        uint64_t v28 = v7;
        double v36 = v8;
        int v29 = __cxa_guard_acquire(&qword_1EB4052C0);
        double v8 = v36;
        uint64_t v7 = v28;
        uint64_t v6 = v27;
        int v30 = v29;
        a1 = v26;
        if (v30)
        {
          xmmword_1EB4052D0 = xmmword_18E22C210;
          qword_1EB4052E0 = 0;
          __cxa_guard_release(&qword_1EB4052C0);
          double v8 = v36;
          uint64_t v7 = v28;
          uint64_t v6 = v27;
          a1 = v26;
        }
      }
      *(_OWORD *)&v39[8] = xmmword_1EB4052D0;
      *(void *)&v39[24] = qword_1EB4052E0;
      BYTE8(v41) = 1;
      double v9 = &v40;
    }
    else
    {
      if ((explicit & 1) == 0)
      {
        uint64_t v31 = a1;
        uint64_t v32 = v6;
        uint64_t v33 = v7;
        double v37 = v8;
        int v34 = __cxa_guard_acquire(&qword_1EB4052C0);
        double v9 = (long long *)&v39[8];
        double v8 = v37;
        uint64_t v7 = v33;
        uint64_t v6 = v32;
        int v35 = v34;
        a1 = v31;
        if (v35)
        {
          xmmword_1EB4052D0 = xmmword_18E22C210;
          qword_1EB4052E0 = 0;
          __cxa_guard_release(&qword_1EB4052C0);
          double v9 = (long long *)&v39[8];
          double v8 = v37;
          uint64_t v7 = v33;
          uint64_t v6 = v32;
          a1 = v31;
        }
      }
      long long v40 = xmmword_1EB4052D0;
      *(void *)&long long v41 = qword_1EB4052E0;
      BYTE8(v41) = 1;
    }
    *(void *)double v9 = v6;
    *((void *)v9 + 1) = v7;
    *((double *)v9 + 2) = v8;
    memset(&v47[2], 0, 32);
    long long v21 = v43;
    *(_OWORD *)(a1 + 96) = v42;
    *(_OWORD *)(a1 + 112) = v21;
    *(_OWORD *)(a1 + 128) = v44;
    long long v22 = *(_OWORD *)&v39[16];
    *(_OWORD *)(a1 + 32) = *(_OWORD *)v39;
    *(_OWORD *)(a1 + 48) = v22;
    long long v23 = v41;
    *(_OWORD *)(a1 + 64) = v40;
    *(_OWORD *)(a1 + 80) = v23;
    long long v24 = *(_OWORD *)&v38[16];
    *(_OWORD *)a1 = *(_OWORD *)v38;
    *(_OWORD *)(a1 + 16) = v24;
    long long v19 = *(_OWORD *)&v47[16];
    *(_OWORD *)(a1 + 154) = *(_OWORD *)v47;
    *(void *)&v47[34] = 0;
    *(void *)(a1 + 144) = v45;
    __int16 v20 = 48;
  }
  *(_WORD *)(a1 + 152) = v20;
  *(_OWORD *)(a1 + 170) = v19;
  __n128 result = *(__n128 *)&v47[26];
  *(_OWORD *)(a1 + 180) = *(_OWORD *)&v47[26];
  return result;
}

void sub_18E1D1F90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v162 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = a5 - a4;
  uint64_t v9 = a7 - a6;
  uint64_t v10 = a4 - a6;
  if (a7 - a6 < 0)
  {
    uint64_t v10 = a6 - a4;
    uint64_t v14 = a6 - a7;
    double v11 = (double)(a6 - a7);
    double v12 = (double)(a6 - a4) * 1000000.0 / v11;
    uint64_t v13 = a6 - a5;
    goto LABEL_5;
  }
  if (v9)
  {
    double v11 = (double)v9;
    double v12 = (double)v10 * 1000000.0 / (double)v9;
    uint64_t v13 = a5 - a6;
    uint64_t v14 = a7 - a6;
LABEL_5:
    double v15 = (double)v13 * 1000000.0 / v11;
    goto LABEL_7;
  }
  uint64_t v14 = 0;
  uint64_t v13 = a5 - a6;
  double v12 = 0.0;
  double v15 = 0.0;
LABEL_7:
  uint64_t v16 = a6 - a4;
  uint64_t v153 = a5 - a4;
  if (v8 < 0)
  {
    uint64_t v16 = a4 - a6;
    uint64_t v17 = a4 - a5;
    uint64_t v153 = a4 - a5;
  }
  else
  {
    if (!v8)
    {
      uint64_t v151 = 0;
      double v152 = 0.0;
      uint64_t v18 = a7 - a4;
      double v20 = 0.0;
      goto LABEL_16;
    }
    uint64_t v17 = a5 - a4;
  }
  double v152 = (double)v16 * 1000000.0 / (double)v17;
  uint64_t v18 = a7 - a4;
  if (v8 >= 0)
  {
    uint64_t v19 = a5 - a4;
  }
  else
  {
    uint64_t v18 = a4 - a7;
    uint64_t v19 = a4 - a5;
  }
  uint64_t v151 = v19;
  double v20 = (double)v18 * 1000000.0 / (double)v19;
LABEL_16:
  double v150 = v20;
  if (a4 != a6)
  {
    if (a7 == a4)
    {
      unsigned int v21 = 3;
      goto LABEL_31;
    }
    if (a7 <= a6)
    {
      if (a4 <= a6)
      {
        if (a7 <= a4) {
          unsigned int v21 = 2;
        }
        else {
          unsigned int v21 = 4;
        }
LABEL_31:
        if (a5 == a6)
        {
          int v23 = 3;
          unsigned int v22 = 1;
          goto LABEL_57;
        }
        goto LABEL_33;
      }
    }
    else if (a4 >= a6)
    {
      if (a7 >= a4) {
        unsigned int v21 = 2;
      }
      else {
        unsigned int v21 = 4;
      }
      goto LABEL_31;
    }
    unsigned int v21 = 0;
    goto LABEL_31;
  }
  unsigned int v21 = 1;
  unsigned int v22 = 1;
  int v23 = 1;
  if (a5 == a4) {
    goto LABEL_57;
  }
LABEL_33:
  if (a5 == a7)
  {
    unsigned int v22 = 3;
    goto LABEL_45;
  }
  if (a7 > a6)
  {
    if (a5 >= a6)
    {
      if (a5 <= a7) {
        unsigned int v22 = 2;
      }
      else {
        unsigned int v22 = 4;
      }
      goto LABEL_45;
    }
LABEL_41:
    unsigned int v22 = 0;
    goto LABEL_45;
  }
  if (a5 > a6) {
    goto LABEL_41;
  }
  if (a5 >= a7) {
    unsigned int v22 = 2;
  }
  else {
    unsigned int v22 = 4;
  }
LABEL_45:
  if (a4 == a6)
  {
    int v23 = 1;
    goto LABEL_57;
  }
  if (a5 > a4)
  {
    if (a6 >= a4)
    {
      if (a5 >= a6) {
        int v23 = 2;
      }
      else {
        int v23 = 4;
      }
      goto LABEL_57;
    }
LABEL_53:
    int v23 = 0;
    goto LABEL_57;
  }
  if (a6 > a4) {
    goto LABEL_53;
  }
  if (a5 <= a6) {
    int v23 = 2;
  }
  else {
    int v23 = 4;
  }
LABEL_57:
  if (a7 == a4)
  {
    int v24 = 1;
    goto LABEL_71;
  }
  if (a7 == a5)
  {
    int v24 = 3;
    goto LABEL_71;
  }
  if (a5 > a4)
  {
    if (a7 >= a4)
    {
      if (a7 <= a5) {
        int v24 = 2;
      }
      else {
        int v24 = 4;
      }
      goto LABEL_71;
    }
LABEL_67:
    int v24 = 0;
    goto LABEL_71;
  }
  if (a7 > a4) {
    goto LABEL_67;
  }
  if (a7 >= a5) {
    int v24 = 2;
  }
  else {
    int v24 = 4;
  }
LABEL_71:
  if (v21 == 1)
  {
    uint64_t v10 = 0;
    uint64_t v16 = 0;
    double v25 = &v152;
    uint64_t v26 = &v153;
    double v12 = 0.0;
    goto LABEL_75;
  }
  if (v21 == 3)
  {
    uint64_t v18 = 0;
    double v25 = &v150;
    uint64_t v26 = &v151;
    uint64_t v10 = 1;
    double v12 = 1000000.0;
LABEL_75:
    uint64_t v27 = 1;
    *uint64_t v26 = 1;
    *double v25 = 0.0;
    goto LABEL_77;
  }
  uint64_t v27 = v14;
LABEL_77:
  unsigned int v28 = v22 - 1;
  if (v22 == 1)
  {
    uint64_t v13 = 0;
    int v29 = &v152;
    int v30 = &v153;
    double v15 = 0.0;
    uint64_t v16 = 1;
    goto LABEL_81;
  }
  if (v22 == 3)
  {
    int v29 = &v150;
    int v30 = &v151;
    uint64_t v13 = 1;
    double v15 = 1000000.0;
    uint64_t v18 = 1;
LABEL_81:
    uint64_t v14 = 1;
    *int v30 = 1;
    *int v29 = 1000000.0;
    goto LABEL_82;
  }
  if (!(v22 | v21) || v21 >= 4 && v22 >= 4)
  {
    *(void *)uint64_t v154 = 0;
    uint64_t v61 = 40;
    do
    {
      uint64_t v62 = &v154[v61];
      *(_OWORD *)uint64_t v62 = xmmword_18E22C210;
      *((void *)v62 + 2) = 0;
      *((void *)v62 + 3) = 0;
      *((void *)v62 + 4) = 1;
      *((void *)v62 + 5) = 0;
      v62[48] = 0;
      v61 += 56;
    }
    while (v62 + 56 != (unsigned char *)v159);
    memset(&v160[2], 0, 32);
    long long v63 = v156;
    *(_OWORD *)(a1 + 96) = v155;
    *(_OWORD *)(a1 + 112) = v63;
    *(_OWORD *)(a1 + 128) = v157;
    long long v64 = *(_OWORD *)&v154[48];
    *(_OWORD *)(a1 + 32) = *(_OWORD *)&v154[32];
    *(_OWORD *)(a1 + 48) = v64;
    long long v65 = *(_OWORD *)&v154[80];
    *(_OWORD *)(a1 + 64) = *(_OWORD *)&v154[64];
    *(_OWORD *)(a1 + 80) = v65;
    long long v66 = *(_OWORD *)&v154[16];
    *(_OWORD *)a1 = *(_OWORD *)v154;
    *(_OWORD *)(a1 + 16) = v66;
    long long v67 = *(_OWORD *)&v160[16];
    *(_OWORD *)(a1 + 154) = *(_OWORD *)v160;
    *(void *)&v160[34] = 0;
    *(void *)(a1 + 144) = v158;
    *(_WORD *)(a1 + 152) = 100;
    *(_OWORD *)(a1 + 170) = v67;
    *(_OWORD *)(a1 + 180) = *(_OWORD *)&v160[26];
    return;
  }
LABEL_82:
  if (v8) {
    int v31 = -1;
  }
  else {
    int v31 = 0;
  }
  BOOL v32 = v9 <= 0;
  if (v9) {
    int v33 = -1;
  }
  else {
    int v33 = 0;
  }
  if (v32) {
    int v34 = v33;
  }
  else {
    int v34 = 1;
  }
  *(void *)uint64_t v154 = 0;
  uint64_t v35 = 40;
  long long v36 = xmmword_18E22C210;
  do
  {
    double v37 = &v154[v35];
    *(_OWORD *)double v37 = xmmword_18E22C210;
    *((void *)v37 + 2) = 0;
    *((void *)v37 + 3) = 0;
    *((void *)v37 + 4) = 1;
    *((void *)v37 + 5) = 0;
    v37[48] = 0;
    v35 += 56;
  }
  while (v37 + 56 != (unsigned char *)v159);
  if (v8 > 0) {
    int v38 = 1;
  }
  else {
    int v38 = v31;
  }
  *(void *)&v160[16] = 0;
  *(void *)&v160[24] = 0;
  *(_OWORD *)&v160[32] = xmmword_18E22C220;
  *(_OWORD *)double v160 = xmmword_18E22C210;
  if (v21 - 1 > 2)
  {
    unsigned int v40 = 0;
  }
  else
  {
    double v39 = *(void **)a2;
    *(void *)&v154[8] = **(void **)a2;
    *(void *)&v154[16] = v39[1];
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB4052C0, memory_order_acquire) & 1) == 0)
    {
      uint64_t v95 = a3;
      uint64_t v96 = a2;
      uint64_t v125 = v18;
      uint64_t v128 = v14;
      uint64_t v97 = v13;
      double v131 = v15;
      uint64_t v122 = v16;
      uint64_t v114 = v10;
      double v117 = v12;
      int v135 = v23;
      int v139 = v38;
      int v98 = __cxa_guard_acquire(&qword_1EB4052C0);
      long long v36 = xmmword_18E22C210;
      int v38 = v139;
      unsigned int v28 = v22 - 1;
      int v23 = v135;
      double v12 = v117;
      uint64_t v10 = v114;
      uint64_t v16 = v122;
      uint64_t v18 = v125;
      double v15 = v131;
      uint64_t v14 = v128;
      uint64_t v13 = v97;
      a2 = v96;
      a3 = v95;
      if (v98)
      {
        xmmword_1EB4052D0 = xmmword_18E22C210;
        qword_1EB4052E0 = 0;
        __cxa_guard_release(&qword_1EB4052C0);
        long long v36 = xmmword_18E22C210;
        int v38 = v139;
        unsigned int v28 = v22 - 1;
        int v23 = v135;
        double v12 = v117;
        uint64_t v10 = v114;
        uint64_t v16 = v122;
        uint64_t v18 = v125;
        double v15 = v131;
        uint64_t v14 = v128;
        uint64_t v13 = v97;
        a2 = v96;
        a3 = v95;
      }
    }
    *(_OWORD *)&v154[40] = xmmword_1EB4052D0;
    *(void *)&v154[56] = qword_1EB4052E0;
    v154[88] = 1;
    *(void *)&v154[64] = v10;
    *(void *)&v154[72] = v27;
    *(double *)&v154[80] = v12;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB4052C0, memory_order_acquire) & 1) == 0)
    {
      uint64_t v99 = a3;
      uint64_t v100 = a2;
      uint64_t v101 = v18;
      uint64_t v102 = v13;
      uint64_t v103 = v14;
      double v132 = v15;
      uint64_t v123 = v16;
      int v136 = v23;
      int v140 = v38;
      unsigned int v145 = v28;
      long long v120 = v36;
      int v104 = __cxa_guard_acquire(&qword_1EB4052C0);
      long long v36 = v120;
      int v38 = v140;
      unsigned int v28 = v145;
      int v23 = v136;
      uint64_t v16 = v123;
      double v15 = v132;
      uint64_t v14 = v103;
      uint64_t v13 = v102;
      uint64_t v18 = v101;
      a2 = v100;
      a3 = v99;
      if (v104)
      {
        xmmword_1EB4052D0 = v120;
        qword_1EB4052E0 = 0;
        __cxa_guard_release(&qword_1EB4052C0);
        long long v36 = v120;
        int v38 = v140;
        unsigned int v28 = v145;
        int v23 = v136;
        uint64_t v16 = v123;
        double v15 = v132;
        uint64_t v14 = v103;
        uint64_t v13 = v102;
        uint64_t v18 = v101;
        a2 = v100;
        a3 = v99;
      }
    }
    *(_OWORD *)double v160 = xmmword_1EB4052D0;
    *(void *)&v160[16] = qword_1EB4052E0;
    unsigned int v40 = 1;
  }
  if (v23 == 2)
  {
    long long v41 = &v154[16 * v40];
    long long v42 = *(void **)a3;
    *((void *)v41 + 1) = **(void **)a3;
    *((void *)v41 + 2) = v42[1];
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB4052C0, memory_order_acquire) & 1) == 0)
    {
      uint64_t v115 = a3;
      uint64_t v118 = v13;
      uint64_t v105 = a2;
      uint64_t v126 = v18;
      uint64_t v129 = v14;
      double v133 = v15;
      uint64_t v124 = v16;
      int v141 = v38;
      unsigned int v146 = v28;
      long long v121 = v36;
      int v106 = __cxa_guard_acquire(&qword_1EB4052C0);
      int v38 = v141;
      unsigned int v28 = v146;
      int v23 = 2;
      uint64_t v16 = v124;
      uint64_t v18 = v126;
      double v15 = v133;
      uint64_t v14 = v129;
      a3 = v115;
      uint64_t v13 = v118;
      a2 = v105;
      if (v106)
      {
        xmmword_1EB4052D0 = v121;
        qword_1EB4052E0 = 0;
        __cxa_guard_release(&qword_1EB4052C0);
        int v38 = v141;
        unsigned int v28 = v146;
        int v23 = 2;
        uint64_t v16 = v124;
        uint64_t v18 = v126;
        double v15 = v133;
        uint64_t v14 = v129;
        a3 = v115;
        uint64_t v13 = v118;
        a2 = v105;
      }
    }
    long long v43 = &v154[56 * v40];
    v43[88] = 1;
    uint64_t v44 = v153;
    *((void *)v43 + 5) = v16;
    *((void *)v43 + 6) = v44;
    double v45 = v152;
    *((double *)v43 + 7) = v152;
    *((_OWORD *)v43 + 4) = xmmword_1EB4052D0;
    *((void *)v43 + 10) = qword_1EB4052E0;
    double v46 = (uint64_t *)&v160[24 * v40];
    uint64_t *v46 = v16;
    v46[1] = v44;
    *((double *)v46 + 2) = v45;
    ++v40;
  }
  if (v28 <= 2 && v40 <= 1)
  {
    double v47 = &v154[16 * v40];
    uint64_t v48 = *(void **)(a2 + 8);
    *((void *)v47 + 1) = *v48;
    *((void *)v47 + 2) = v48[1];
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB4052C8, memory_order_acquire) & 1) == 0)
    {
      uint64_t v116 = a3;
      uint64_t v119 = v13;
      uint64_t v127 = v18;
      uint64_t v130 = v14;
      double v134 = v15;
      int v137 = v23;
      int v142 = v38;
      unsigned int v147 = v28;
      int v107 = __cxa_guard_acquire(&qword_1EB4052C8);
      int v38 = v142;
      unsigned int v28 = v147;
      int v23 = v137;
      double v15 = v134;
      uint64_t v18 = v127;
      uint64_t v14 = v130;
      a3 = v116;
      uint64_t v13 = v119;
      if (v107)
      {
        xmmword_1EB4052F0 = (__int128)vdupq_n_s64(1uLL);
        qword_1EB405300 = 0x412E848000000000;
        __cxa_guard_release(&qword_1EB4052C8);
        int v38 = v142;
        unsigned int v28 = v147;
        int v23 = v137;
        double v15 = v134;
        uint64_t v18 = v127;
        uint64_t v14 = v130;
        a3 = v116;
        uint64_t v13 = v119;
      }
    }
    uint64_t v49 = &v154[56 * v40];
    v49[88] = 1;
    *(_OWORD *)(v49 + 40) = xmmword_1EB4052F0;
    *((void *)v49 + 7) = qword_1EB405300;
    *((void *)v49 + 8) = v13;
    *((void *)v49 + 9) = v14;
    *((double *)v49 + 10) = v15;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB4052C8, memory_order_acquire) & 1) == 0)
    {
      uint64_t v108 = a3;
      uint64_t v109 = v18;
      int v110 = v23;
      unsigned int v148 = v28;
      int v143 = v38;
      int v111 = __cxa_guard_acquire(&qword_1EB4052C8);
      int v38 = v143;
      unsigned int v28 = v148;
      int v23 = v110;
      uint64_t v18 = v109;
      a3 = v108;
      if (v111)
      {
        xmmword_1EB4052F0 = (__int128)vdupq_n_s64(1uLL);
        qword_1EB405300 = 0x412E848000000000;
        __cxa_guard_release(&qword_1EB4052C8);
        int v38 = v143;
        unsigned int v28 = v148;
        int v23 = v110;
        uint64_t v18 = v109;
        a3 = v108;
      }
    }
    double v50 = &v160[24 * v40];
    *(_OWORD *)double v50 = xmmword_1EB4052F0;
    *((void *)v50 + 2) = qword_1EB405300;
    ++v40;
  }
  if (v24 == 2 && v40 <= 1)
  {
    double v51 = &v154[16 * v40];
    uint64_t v52 = *(void **)(a3 + 8);
    *((void *)v51 + 1) = *v52;
    *((void *)v51 + 2) = v52[1];
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB4052C8, memory_order_acquire) & 1) == 0)
    {
      uint64_t v112 = v18;
      int v138 = v23;
      int v144 = v38;
      unsigned int v149 = v28;
      int v113 = __cxa_guard_acquire(&qword_1EB4052C8);
      int v38 = v144;
      unsigned int v28 = v149;
      int v23 = v138;
      uint64_t v18 = v112;
      if (v113)
      {
        xmmword_1EB4052F0 = (__int128)vdupq_n_s64(1uLL);
        qword_1EB405300 = 0x412E848000000000;
        __cxa_guard_release(&qword_1EB4052C8);
        int v38 = v144;
        unsigned int v28 = v149;
        int v23 = v138;
        uint64_t v18 = v112;
      }
    }
    double v53 = &v154[56 * v40];
    v53[88] = 1;
    uint64_t v54 = v151;
    *((void *)v53 + 5) = v18;
    *((void *)v53 + 6) = v54;
    double v55 = v150;
    *((double *)v53 + 7) = v150;
    *((_OWORD *)v53 + 4) = xmmword_1EB4052F0;
    *((void *)v53 + 10) = qword_1EB405300;
    uint64_t v56 = (uint64_t *)&v160[24 * v40];
    *uint64_t v56 = v18;
    v56[1] = v54;
    *((double *)v56 + 2) = v55;
    ++v40;
  }
  if (v40 != 2) {
    goto LABEL_125;
  }
  if (vabdd_f64(*(double *)&v160[40], *(double *)&v160[16]) < 50.0)
  {
    int v57 = v38;
    unsigned int v58 = v28;
    int v59 = v23;
    long long v161 = *(_OWORD *)&v160[24];
    sub_18E1D2DAC((int64_t *)&v161);
    *(_OWORD *)double v159 = *(_OWORD *)v160;
    sub_18E1D2DAC(v159);
    char v60 = sub_18E1D2CA0(v161, *((uint64_t *)&v161 + 1), v159[0], v159[1]);
    int v23 = v59;
    unsigned int v28 = v58;
    int v38 = v57;
    if ((v60 & 1) == 0) {
      goto LABEL_125;
    }
    goto LABEL_124;
  }
  if (*(double *)&v160[40] < *(double *)&v160[16])
  {
LABEL_124:
    char v68 = v154[88];
    long long v69 = *(_OWORD *)&v154[40];
    long long v70 = *(_OWORD *)&v154[56];
    long long v71 = *(_OWORD *)&v154[72];
    *(_OWORD *)&v154[40] = v155;
    *(_OWORD *)&v154[56] = v156;
    *(_OWORD *)&v154[72] = v157;
    v154[88] = v158;
    long long v157 = v71;
    long long v156 = v70;
    long long v155 = v69;
    LOBYTE(v158) = v68;
    long long v72 = *(_OWORD *)&v154[8];
    long long v161 = *(_OWORD *)&v154[8];
    *(_OWORD *)&v154[8] = *(_OWORD *)&v154[24];
    *(_OWORD *)&unsigned char v154[24] = v72;
  }
LABEL_125:
  if ((v22 & 0xFFFFFFFD) == 1) {
    int v73 = 0;
  }
  else {
    int v73 = -1;
  }
  int v74 = (v21 & 0xFFFFFFFD) != 1;
  BOOL v75 = (v21 & 0xFFFFFFFD) != 1 || v21 - 4 < 0xFFFFFFFD;
  if (v21 - 4 <= 0xFFFFFFFC) {
    int v74 = 0;
  }
  if (v22 == 2) {
    int v73 = 1;
  }
  else {
    int v74 = v21 - 4 < 0xFFFFFFFD;
  }
  int v76 = !v75;
  if ((v22 & 0xFFFFFFFD) == 1)
  {
    int v74 = !v75;
    BOOL v77 = v28 >= 3;
  }
  else
  {
    BOOL v77 = 1;
  }
  *(void *)uint64_t v154 = v40;
  memset(&v160[2], 0, 32);
  unsigned int v78 = v24 & 0xFFFFFFFD;
  if (!v77) {
    int v76 = v74 + 1;
  }
  BOOL v79 = (v23 & 0xFFFFFFFD) != 1;
  BOOL v80 = (v23 & 0xFFFFFFFD) != 1 || (v23 - 4) < 0xFFFFFFFD;
  if ((v23 - 4) <= 0xFFFFFFFC) {
    BOOL v79 = 0;
  }
  int v81 = !v80;
  if (v24 != 2) {
    BOOL v79 = (v23 - 4) < 0xFFFFFFFD;
  }
  unsigned int v82 = v24 - 1;
  if (v78 == 1) {
    int v83 = v81;
  }
  else {
    int v83 = v79;
  }
  if (v78 != 1 || v82 >= 3) {
    int v85 = v81;
  }
  else {
    int v85 = v83 + 1;
  }
  BOOL v86 = v74 == 0;
  if (v28 < 3) {
    BOOL v86 = v21 - 4 < 0xFFFFFFFD;
  }
  BOOL v87 = v83 == 0;
  if (v82 < 3) {
    BOOL v87 = (v23 - 4) < 0xFFFFFFFD;
  }
  if (v76 == 1 && v85 == 1 && v86 && v87)
  {
    if (v38 == v34)
    {
      char v88 = 97;
    }
    else if (v73)
    {
      char v88 = 102;
    }
    else
    {
      char v88 = 116;
    }
  }
  else
  {
    char v88 = 99;
    if (v76 == 2 && v85 == 2) {
      char v88 = 101;
    }
  }
  long long v89 = v156;
  *(_OWORD *)(a1 + 96) = v155;
  *(_OWORD *)(a1 + 112) = v89;
  *(_OWORD *)(a1 + 128) = v157;
  long long v90 = *(_OWORD *)&v154[48];
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v154[32];
  *(_OWORD *)(a1 + 48) = v90;
  long long v91 = *(_OWORD *)&v154[80];
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&v154[64];
  *(_OWORD *)(a1 + 80) = v91;
  long long v92 = *(_OWORD *)&v154[16];
  *(_OWORD *)a1 = *(_OWORD *)v154;
  *(_OWORD *)(a1 + 16) = v92;
  long long v93 = *(_OWORD *)&v160[16];
  *(_OWORD *)(a1 + 154) = *(_OWORD *)v160;
  if (v78 == 1) {
    int v94 = 0;
  }
  else {
    int v94 = -1;
  }
  if (v24 == 2) {
    int v94 = 1;
  }
  *(void *)(a1 + 144) = v158;
  *(unsigned char *)(a1 + 152) = v88;
  *(unsigned char *)(a1 + 153) = v38 != v34;
  *(_OWORD *)(a1 + 170) = v93;
  *(_WORD *)(a1 + 186) = *(_WORD *)&v160[32];
  *(_DWORD *)(a1 + 188) = v73;
  *(_DWORD *)(a1 + 192) = v94;
}

uint64_t sub_18E1D2CA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 <= 0) {
    __assert_rtn("operator<", "rational.hpp", 794, "this->den > zero");
  }
  if (a4 <= 0) {
    __assert_rtn("operator<", "rational.hpp", 795, "r.den > zero");
  }
  uint64_t v4 = a1 / a2;
  unint64_t v5 = a1 % a2;
  uint64_t v6 = a3 / a4;
  for (unint64_t i = a3 % a4; (v5 & 0x8000000000000000) != 0; --v4)
    v5 += a2;
  for (; (i & 0x8000000000000000) != 0; --v6)
    i += a4;
  if (v4 != v6) {
    return v4 < v6;
  }
  int v8 = 0;
  while (1)
  {
    unint64_t v9 = v5;
    unint64_t v10 = i;
    v8 ^= 1u;
    if (!v5 || !i) {
      break;
    }
    int64_t v11 = a2 / v5;
    unint64_t v5 = a2 % v5;
    int64_t v12 = a4 / i;
    unint64_t i = a4 % i;
    a4 = v10;
    a2 = v9;
    if (v11 != v12)
    {
      uint64_t result = v11 > v12;
      if (!v8) {
        return v11 < v12;
      }
      return result;
    }
  }
  unsigned int v14 = (v8 != 0) ^ (v5 != 0);
  if (v9 == i) {
    return 0;
  }
  else {
    return v14;
  }
}

int64_t *sub_18E1D2DAC(int64_t *result)
{
  uint64_t v1 = result + 1;
  int64_t v2 = result[1];
  if (!v2)
  {
    std::logic_error::logic_error(&v9, "bad rational: zero denominator");
    v9.__vftable = (std::logic_error_vtbl *)&unk_1EDD12A40;
    v7.i64[0] = (uint64_t)"/AppleInternal/Library/BuildRoots/cb09429a-9ee5-11ef-b491-ce2c30f2a3e7/Applications/Xcode.app/C"
                         "ontents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.2.Internal.sdk/usr/loca"
                         "l/include/boost/rational.hpp";
    v7.i64[1] = (uint64_t)"void boost::rational<long long>::normalize() [T = long long]";
    uint64_t v8 = 892;
    sub_18E1D2F44(&v9, &v7);
  }
  uint64_t v3 = result;
  int64_t v4 = *result;
  if (*result)
  {
    int64_t v5 = sub_18E1D2F90(result, result + 1);
    uint64_t v6 = v2 / v5;
    *uint64_t v3 = v4 / v5;
    v3[1] = v2 / v5;
    if (v2 / v5 == 0x8000000000000000)
    {
      std::logic_error::logic_error(&v9, "bad rational: non-zero singular denominator");
      v9.__vftable = (std::logic_error_vtbl *)&unk_1EDD12A40;
      v7.i64[0] = (uint64_t)"/AppleInternal/Library/BuildRoots/cb09429a-9ee5-11ef-b491-ce2c30f2a3e7/Applications/Xcode.app"
                           "/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.2.Internal.sdk/usr/"
                           "local/include/boost/rational.hpp";
      v7.i64[1] = (uint64_t)"void boost::rational<long long>::normalize() [T = long long]";
      uint64_t v8 = 906;
      sub_18E1D2F44(&v9, &v7);
    }
    if (v6 < 0)
    {
      *uint64_t v3 = -(v4 / v5);
      v3[1] = -v6;
    }
    else if (!v6)
    {
LABEL_10:
      __assert_rtn("normalize", "rational.hpp", 915, "this->test_invariant()");
    }
    uint64_t result = (int64_t *)sub_18E1D2F90(v3, v1);
    if (result != (int64_t *)1) {
      goto LABEL_10;
    }
  }
  else
  {
    *uint64_t v1 = 1;
  }
  return result;
}

void sub_18E1D2F2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::logic_error a13)
{
}

void sub_18E1D2F44(const std::logic_error *a1, int8x16_t *a2)
{
  exceptiouint64_t n = __cxa_allocate_exception(0x40uLL);
  int64_t v5 = (void *)sub_18E1D3094((uint64_t)exception, a1, a2);
  __cxa_throw(v5, (struct type_info *)&unk_1EDD04698, (void (*)(void *))sub_18E1D314C);
}

unint64_t sub_18E1D2F90(int64_t *a1, uint64_t *a2)
{
  int64_t v2 = *a1;
  if (*a1 == 0x8000000000000000)
  {
    uint64_t v12 = (uint64_t)0x8000000000000000 % *a2;
    a1 = &v12;
    return sub_18E1D2F90(a1, a2);
  }
  uint64_t v3 = *a2;
  if (*a2 == 0x8000000000000000)
  {
    uint64_t v12 = (uint64_t)0x8000000000000000 % v2;
    a2 = &v12;
    return sub_18E1D2F90(a1, a2);
  }
  if (v2 < 0) {
    int64_t v2 = -v2;
  }
  if (v3 >= 0) {
    int64_t v5 = *a2;
  }
  else {
    int64_t v5 = -v3;
  }
  if (v2 >= v5) {
    unint64_t result = v5;
  }
  else {
    unint64_t result = v2;
  }
  if (v2 <= v5) {
    int64_t v2 = v5;
  }
  if (v2)
  {
    if (result)
    {
      unsigned int v6 = __clz(__rbit64(v2));
      int64_t v7 = (unint64_t)v2 >> v6;
      unsigned int v8 = __clz(__rbit64(result));
      unint64_t v9 = result >> v8;
      if (v6 < v8) {
        LOBYTE(v8) = v6;
      }
      if (v9 < 2)
      {
LABEL_29:
        if (v9 == 1) {
          int64_t v7 = 1;
        }
      }
      else
      {
        while (1)
        {
          unint64_t v10 = v7 % v9;
          int64_t v7 = v9 - v7 % v9;
          if (!v10) {
            break;
          }
          int64_t v11 = v10 >> __clz(__rbit64(v10));
          v7 >>= __clz(__rbit64(v7));
          if (v11 >= v7) {
            unint64_t v9 = v7;
          }
          else {
            unint64_t v9 = v11;
          }
          if (v11 > v7) {
            int64_t v7 = v11;
          }
          if ((uint64_t)v9 <= 1) {
            goto LABEL_29;
          }
        }
      }
      return v7 << v8;
    }
    else
    {
      return v2;
    }
  }
  return result;
}

uint64_t sub_18E1D3094(uint64_t a1, const std::logic_error *a2, int8x16_t *a3)
{
  *(void *)a1 = &unk_1EDD12A90;
  std::logic_error::logic_error((std::logic_error *)(a1 + 8), a2);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_1EDD12658;
  *(void *)(a1 + 8) = &unk_1EDD12688;
  *(void *)(a1 + 24) = &unk_1EDD126B0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 56) = a3[1].i32[0];
  *(int8x16_t *)(a1 + 40) = vextq_s8(*a3, *a3, 8uLL);
  return a1;
}

uint64_t sub_18E1D314C(uint64_t a1)
{
  *(void *)(a1 + 24) = &unk_1EDD136E0;
  sub_18DFE4B84((uint64_t *)(a1 + 32));
  std::logic_error::~logic_error((std::logic_error *)(a1 + 8));
  return a1;
}

void sub_18E1D31A0()
{
}

void sub_18E1D336C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_18DFE4B84(&a9);
  sub_18DFE4B84(&a10);
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  _Unwind_Resume(a1);
}

void sub_18E1D33E4(uint64_t a1)
{
  exceptiouint64_t n = __cxa_allocate_exception(0x40uLL);
  sub_18E1D368C((uint64_t)exception, a1);
  __cxa_throw(exception, (struct type_info *)&unk_1EDD04698, (void (*)(void *))sub_18E1D314C);
}

void sub_18E1D342C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_18E1D3440(uint64_t a1)
{
  *(void *)(a1 + 24) = &unk_1EDD136E0;
  sub_18DFE4B84((uint64_t *)(a1 + 32));
  std::logic_error::~logic_error((std::logic_error *)(a1 + 8));

  JUMPOUT(0x192FA6240);
}

void sub_18E1D34B4(uint64_t a1)
{
  *(void *)(a1 + 16) = &unk_1EDD136E0;
  sub_18DFE4B84((uint64_t *)(a1 + 24));

  std::logic_error::~logic_error((std::logic_error *)a1);
}

void sub_18E1D3510(uint64_t a1)
{
  *(void *)(a1 + 16) = &unk_1EDD136E0;
  sub_18DFE4B84((uint64_t *)(a1 + 24));
  std::logic_error::~logic_error((std::logic_error *)a1);

  JUMPOUT(0x192FA6240);
}

void sub_18E1D3588(void *a1)
{
  *a1 = &unk_1EDD136E0;
  sub_18DFE4B84(a1 + 1);

  std::logic_error::~logic_error((std::logic_error *)a1 - 1);
}

void sub_18E1D35E0(void *a1)
{
  *a1 = &unk_1EDD136E0;
  sub_18DFE4B84(a1 + 1);
  std::logic_error::~logic_error((std::logic_error *)a1 - 1);

  JUMPOUT(0x192FA6240);
}

void sub_18E1D3654(std::logic_error *a1)
{
  std::logic_error::~logic_error(a1);

  JUMPOUT(0x192FA6240);
}

uint64_t sub_18E1D368C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1EDD12A90;
  std::logic_error::logic_error((std::logic_error *)(a1 + 8), (const std::logic_error *)(a2 + 8));
  *(void *)(a1 + 8) = &unk_1EDD12A40;
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = &unk_1EDD136E0;
  *(void *)(a1 + 32) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v5;
  *(void *)a1 = &unk_1EDD12658;
  *(void *)(a1 + 8) = &unk_1EDD12688;
  *(void *)(a1 + 24) = &unk_1EDD126B0;
  return a1;
}

void sub_18E1D37B4(_Unwind_Exception *a1)
{
  std::logic_error::~logic_error(v1);
  _Unwind_Resume(a1);
}

double sub_18E1D37C8(double *a1, double *a2, uint64_t a3, uint64_t a4, double a5, double a6)
{
  if (!a4) {
    __assert_rtn("assign", "intersection.hpp", 176, "ratio.denominator() != typename SegmentRatio::int_type(0)");
  }
  *a1 = (double)a3 * a5 / (double)a4 + *a2;
  double result = (double)a3 * a6 / (double)a4 + a2[1];
  a1[1] = result;
  return result;
}

uint64_t sub_18E1D3830(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  double v9 = 1.0;
  double v6 = sub_18E1D1B30(a3, a4, a5, a6, a1, a2, &v9);
  if (v6 == 0.0) {
    return 0;
  }
  if ((*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    if (v6 > 0.0) {
      return 1;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    double v8 = fabs(v6);
    if (v6 > 0.0) {
      uint64_t result = 1;
    }
    else {
      uint64_t result = 0xFFFFFFFFLL;
    }
    if (v8 <= v9 * 2.22044605e-16) {
      return 0;
    }
  }
  return result;
}

double *sub_18E1D38D8(double *result, double *a2, double *a3, double **a4, double **a5, double *a6)
{
  if (a2 == a3) {
    __assert_rtn("apply", "point_to_range.hpp", 55, "first != last");
  }
  if (a2 + 2 == a3)
  {
    *a5 = a2;
    *a4 = a2;
    double v18 = *a2;
    double v19 = a2[1];
    double v20 = result[1];
    double v21 = v18 - v18;
    double v22 = v19 - v19;
    double v23 = *result - *a2;
    double v24 = (v19 - v19) * (v20 - v19) + v23 * (v18 - v18);
    if (v24 <= 0.0 || (double v25 = v22 * v22 + v21 * v21, v25 <= v24))
    {
      double v27 = v23 * v23 + 0.0 + (v20 - v19) * (v20 - v19);
    }
    else
    {
      double v26 = *result - (v18 + v21 * (v24 / v25));
      double v27 = v26 * v26 + 0.0 + (v20 - (v19 + v22 * (v24 / v25))) * (v20 - (v19 + v22 * (v24 / v25)));
    }
    *a6 = v27;
  }
  else
  {
    double v6 = a2[2];
    double v7 = a2[3];
    double v8 = *result;
    double v9 = result[1];
    double v10 = a2[1];
    double v11 = v6 - *a2;
    double v12 = v7 - v10;
    double v13 = *result - *a2;
    double v14 = (v9 - v10) * (v7 - v10) + v13 * v11;
    if (v14 <= 0.0)
    {
      double v28 = v13 * v13 + 0.0 + (v9 - v10) * (v9 - v10);
    }
    else
    {
      double v15 = v12 * v12 + v11 * v11;
      if (v15 <= v14)
      {
        double v16 = v9 - v7;
        double v17 = v8 - v6;
      }
      else
      {
        double v16 = v9 - (v10 + v12 * (v14 / v15));
        double v17 = v8 - (*a2 + v11 * (v14 / v15));
      }
      double v28 = v17 * v17 + 0.0 + v16 * v16;
    }
    *a6 = v28;
    if (a2 + 4 == a3)
    {
LABEL_25:
      *a5 = a2;
      *a4 = a2;
      int v29 = *a5;
    }
    else
    {
      int v29 = a2 + 2;
      int v30 = a2 + 3;
      while (1)
      {
        double v31 = *(v30 - 1);
        double v33 = v30[1];
        double v32 = v30[2];
        double v34 = *result;
        double v35 = result[1];
        double v36 = v33 - v31;
        double v37 = v32 - *v30;
        double v38 = *result - v31;
        double v39 = v35 - *v30;
        double v40 = v39 * v37 + v38 * (v33 - v31);
        if (v40 <= 0.0)
        {
          double v43 = v38 * v38 + 0.0 + v39 * v39;
        }
        else
        {
          double v41 = v37 * v37 + v36 * v36;
          if (v41 <= v40)
          {
            double v43 = (v34 - v33) * (v34 - v33) + 0.0 + (v35 - v32) * (v35 - v32);
          }
          else
          {
            double v42 = v35 - (*v30 + v37 * (v40 / v41));
            double v43 = (v34 - (v31 + v36 * (v40 / v41))) * (v34 - (v31 + v36 * (v40 / v41))) + 0.0 + v42 * v42;
          }
        }
        if (v43 == 0.0) {
          break;
        }
        if (v43 < v28)
        {
          *a6 = v43;
          double v28 = v43;
          a2 = v30 - 1;
        }
        v29 += 2;
        uint64_t v44 = v30 + 3;
        v30 += 2;
        if (v44 == a3) {
          goto LABEL_25;
        }
      }
      *a6 = 0.0;
      *a4 = v29;
    }
    *a5 = v29 + 2;
  }
  return result;
}

uint64_t trackrun::TrackRunSupervisor::TrackRunSupervisor(trackrun::TrackRunSupervisor *this)
{
  char v2 = 1;
  return trackrun::TrackRunSupervisor::TrackRunSupervisor((uint64_t)this, &v2);
}

{
  char v2;

  char v2 = 1;
  return trackrun::TrackRunSupervisor::TrackRunSupervisor((uint64_t)this, &v2);
}

uint64_t trackrun::TrackRunSupervisor::TrackRunSupervisor(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = cnframework::Supervisor::Supervisor(a1, a2);
  *(void *)uint64_t v4 = &unk_1EDD19FF8;
  *(unsigned char *)(v4 + 817) = 0;
  sub_18E1D6EEC(v4 + 824);
  sub_18E1D6EEC(a1 + 1088);
  trackrun::TrackRunEngineActiveObject::TrackRunEngineActiveObject(a1 + 1352, a2);
  *(unsigned char *)(a1 + 6112) = *a2;
  return a1;
}

void sub_18E1D3BC4(_Unwind_Exception *a1)
{
  sub_18E1D3C28(v3);
  sub_18E1D3C28(v2);
  cnframework::Supervisor::~Supervisor(v1, v5, v6, v7, v8, v9, v10, v11);
  _Unwind_Resume(a1);
}

uint64_t sub_18E1D3C28(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void trackrun::TrackRunSupervisor::~TrackRunSupervisor(void **this)
{
  *this = &unk_1EDD19FF8;
  cnframework::Supervisor::TearDown((cnframework::Supervisor *)this);
  sub_18E1CB6A8((uint64_t)(this + 169));
  sub_18E011990((uint64_t)(this + 145));
  if (*((char *)this + 1151) < 0) {
    operator delete(this[141]);
  }
  if (*((char *)this + 1119) < 0) {
    operator delete(this[137]);
  }
  sub_18E011990((uint64_t)(this + 112));
  if (*((char *)this + 887) < 0) {
    operator delete(this[108]);
  }
  if (*((char *)this + 855) < 0) {
    operator delete(this[104]);
  }

  cnframework::Supervisor::~Supervisor((cnframework::Supervisor *)this, v2, v3, v4, v5, v6, v7, v8);
}

{
  uint64_t vars8;

  trackrun::TrackRunSupervisor::~TrackRunSupervisor(this);

  JUMPOUT(0x192FA6240);
}

uint64_t trackrun::TrackRunSupervisor::Configure(uint64_t a1, __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((unsigned char *)a2 + 256))
  {
    uint64_t v10 = (__int16 *)(a1 + 824);
    __int16 v11 = *a2;
    *(unsigned char *)(a1 + 826) = *((unsigned char *)a2 + 2);
    *(_WORD *)(a1 + 824) = v11;
    double v12 = (const std::string *)(a2 + 4);
    std::string::operator=((std::string *)(a1 + 832), (const std::string *)(a2 + 4));
    *(_WORD *)(a1 + 856) = a2[16];
    std::string::operator=((std::string *)(a1 + 864), (const std::string *)(a2 + 20));
    __int16 v13 = a2[34];
    *(_DWORD *)(a1 + 888) = *((_DWORD *)a2 + 16);
    *(_WORD *)(a1 + 892) = v13;
    if (v10 != a2)
    {
      *(_DWORD *)(a1 + 928) = *((_DWORD *)a2 + 26);
      sub_18E1D7088((void *)(a1 + 896), *((uint64_t **)a2 + 11));
    }
    long long v14 = *((_OWORD *)a2 + 8);
    *((_OWORD *)v10 + 7) = *((_OWORD *)a2 + 7);
    *((_OWORD *)v10 + 8) = v14;
    long long v15 = *((_OWORD *)a2 + 9);
    long long v16 = *((_OWORD *)a2 + 10);
    long long v17 = *((_OWORD *)a2 + 12);
    *((_OWORD *)v10 + 11) = *((_OWORD *)a2 + 11);
    *((_OWORD *)v10 + 12) = v17;
    *((_OWORD *)v10 + 9) = v15;
    *((_OWORD *)v10 + 10) = v16;
    long long v18 = *((_OWORD *)a2 + 13);
    long long v19 = *((_OWORD *)a2 + 14);
    long long v20 = *((_OWORD *)a2 + 15);
    *(unsigned char *)(a1 + 1080) = *((unsigned char *)a2 + 256);
    *((_OWORD *)v10 + 14) = v19;
    *((_OWORD *)v10 + 15) = v20;
    *((_OWORD *)v10 + 13) = v18;
    __int16 v21 = *a2;
    *(unsigned char *)(a1 + 1090) = *((unsigned char *)a2 + 2);
    *(_WORD *)(a1 + 1088) = v21;
    std::string::operator=((std::string *)(a1 + 1096), v12);
    *(_WORD *)(a1 + 1120) = a2[16];
    double v22 = std::string::operator=((std::string *)(a1 + 1128), (const std::string *)(a2 + 20));
    __int16 v28 = a2[34];
    *(_DWORD *)(a1 + 1152) = *((_DWORD *)a2 + 16);
    *(_WORD *)(a1 + 1156) = v28;
    if ((__int16 *)(a1 + 1088) != a2)
    {
      *(_DWORD *)(a1 + 1192) = *((_DWORD *)a2 + 26);
      sub_18E1D7088((void *)(a1 + 1160), *((uint64_t **)a2 + 11));
    }
    long long v29 = *((_OWORD *)a2 + 7);
    *(_OWORD *)(a1 + 1216) = *((_OWORD *)a2 + 8);
    *(_OWORD *)(a1 + 1200) = v29;
    long long v30 = *((_OWORD *)a2 + 9);
    long long v31 = *((_OWORD *)a2 + 10);
    long long v32 = *((_OWORD *)a2 + 11);
    *(_OWORD *)(a1 + 1280) = *((_OWORD *)a2 + 12);
    *(_OWORD *)(a1 + 1264) = v32;
    *(_OWORD *)(a1 + 1248) = v31;
    *(_OWORD *)(a1 + 1232) = v30;
    long long v33 = *((_OWORD *)a2 + 13);
    long long v34 = *((_OWORD *)a2 + 14);
    long long v35 = *((_OWORD *)a2 + 15);
    *(unsigned char *)(a1 + 1344) = *((unsigned char *)a2 + 256);
    *(_OWORD *)(a1 + 1328) = v35;
    *(_OWORD *)(a1 + 1312) = v34;
    *(_OWORD *)(a1 + 1296) = v33;
    if (*(unsigned char *)(a1 + 1120))
    {
      uint64_t v46 = 0;
      cnprint::CNPrinter::EnableLogStream((cnprint::CNPrinter *)&v46);
    }
    double v36 = (unsigned char *)(a1 + 1152);
    if (*(unsigned char *)(a1 + 1121))
    {
      cnprint::CNPrinter::SetFileLogStreamName((cnprint::CNPrinter *)(a1 + 1128));
      uint64_t v46 = 1;
      cnprint::CNPrinter::EnableLogStream((cnprint::CNPrinter *)&v46);
    }
    if (*v36)
    {
      uint64_t v46 = 2;
      cnprint::CNPrinter::EnableLogStream((cnprint::CNPrinter *)&v46);
    }
    if (*(unsigned char *)(a1 + 1120) || *(unsigned char *)(a1 + 1121) || *v36)
    {
      unsigned int v37 = *(unsigned __int8 *)(a1 + 1153);
      if (v37 < cnprint::CNPrinter::GetLogLevel((cnprint::CNPrinter *)v22)) {
        cnprint::CNPrinter::SetLogLevel((cnprint::CNPrinter *)(a1 + 1153));
      }
    }
    unsigned __int8 v47 = 2;
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v46, &v47, "TrackRunSupervisor configuration parameters set", v23, v24, v25, v26, v27, 13);
    if (*(unsigned char *)(a1 + 817))
    {
      unsigned __int8 v47 = 2;
      cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v46, &v47, "TrackRunSupervisor::Configure called after TrackRunSupervisor was already configured.", v39, v40, v41, v42, v43, 13);
    }
    cnframework::Supervisor::SetThreadingModel(a1, (unsigned __int8 *)(a1 + 1089), v38, v39, v40, v41, v42, v43);
    if (!*(unsigned char *)(a1 + 817)) {
      (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
    }
    LOWORD(v46) = 13;
    unsigned __int8 v47 = 2;
    uint64_t v44 = "TrackRunSupervisor successfully configured";
  }
  else
  {
    LOWORD(v46) = 13;
    unsigned __int8 v47 = 4;
    uint64_t v44 = "TrackRunSupervisor::Configure called with uninitialized parameters.";
  }
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v46, &v47, v44, a4, a5, a6, a7, a8, v46);
  return 0;
}

uint64_t trackrun::TrackRunSupervisor::IsConfigured(trackrun::TrackRunSupervisor *this)
{
  return *((unsigned __int8 *)this + 817);
}

void *trackrun::TrackRunSupervisor::GetSupervisorName@<X0>(void *a1@<X8>)
{
  return sub_18DEDE7B0(a1, "TrackRunSupervisor");
}

uint64_t trackrun::TrackRunSupervisor::GetMutableTrackRunParameters(trackrun::TrackRunSupervisor *this)
{
  return (uint64_t)this + 1088;
}

uint64_t trackrun::TrackRunSupervisor::GetTrackRunSolution(trackrun::TrackRunSupervisor *this, trackrun::TrackRunSolutionEvent *a2)
{
  return trackrun::TrackRunEngineActiveObject::GetTrackRunSolution((trackrun::TrackRunSupervisor *)((char *)this + 1352), a2);
}

BOOL trackrun::TrackRunSupervisor::Configure(cnframework::ActiveObjectBase ***this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v159 = *MEMORY[0x1E4F143B8];
  int v8 = *((unsigned __int8 *)this + 1344);
  if (*((unsigned char *)this + 1344))
  {
    double v152 = this + 136;
    uint64_t v10 = (cnframework::ActiveObjectBase *)(this + 169);
    trackrun::TrackRunEngineActiveObject::Configure((cnframework::ActiveObjectBase *)(this + 169), (uint64_t *)&v152);
    cnframework::Supervisor::RegisterActiveObject(this, v10);
    LOBYTE(v153) = 0;
    LOBYTE(v154) = 0;
    *((void *)&v154 + 1) = this + 2;
    __int16 v11 = this + 170;
    double v12 = this[170];
    __int16 v13 = this[171];
    if (v12 == v13)
    {
LABEL_6:
      long long v14 = this[172];
      if (v12 >= v14)
      {
        uint64_t v17 = ((char *)v12 - (char *)*v11) >> 5;
        if ((unint64_t)(v17 + 1) >> 59) {
          sub_18DEE1FC8();
        }
        uint64_t v18 = (char *)v14 - (char *)*v11;
        uint64_t v19 = v18 >> 4;
        if (v18 >> 4 <= (unint64_t)(v17 + 1)) {
          uint64_t v19 = v17 + 1;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v20 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v20 = v19;
        }
        if (v20) {
          __int16 v21 = (char *)sub_18E01ACC8((uint64_t)(this + 172), v20);
        }
        else {
          __int16 v21 = 0;
        }
        double v22 = &v21[32 * v17];
        uint64_t v23 = (cnframework::ActiveObjectBase **)&v21[32 * v20];
        long long v24 = v154;
        *(_OWORD *)double v22 = v153;
        *((_OWORD *)v22 + 1) = v24;
        long long v16 = (cnframework::ActiveObjectBase **)(v22 + 32);
        uint64_t v25 = this[171];
        uint64_t v26 = this[170];
        if (v25 != v26)
        {
          do
          {
            long long v27 = *((_OWORD *)v25 - 1);
            *((_OWORD *)v22 - 2) = *((_OWORD *)v25 - 2);
            *((_OWORD *)v22 - 1) = v27;
            v22 -= 32;
            v25 -= 4;
          }
          while (v25 != v26);
          uint64_t v25 = *v11;
        }
        this[170] = (cnframework::ActiveObjectBase **)v22;
        this[171] = v16;
        this[172] = v23;
        if (v25) {
          operator delete(v25);
        }
      }
      else
      {
        long long v15 = v154;
        *(_OWORD *)double v12 = v153;
        *((_OWORD *)v12 + 1) = v15;
        long long v16 = v12 + 4;
      }
      this[171] = v16;
      int v28 = *((unsigned __int8 *)this + 1520);
      if (*((unsigned char *)this + 1520))
      {
        long long v29 = 0;
      }
      else
      {
        long long v29 = (std::mutex *)(this + 178);
        std::mutex::lock((std::mutex *)(this + 178));
      }
      if (sub_18DEE511C(this + 173, (uint64_t *)&v155))
      {
        if (v28) {
          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v158 = v157;
        long long v156 = &v155;
        v157[0] = &unk_1EDD1E0A8;
        uint64_t v40 = sub_18E0BB7A0((uint64_t)(this + 173), (uint64_t *)&v155, (uint64_t)&std::piecewise_construct, &v156);
        sub_18E0BA000(v40 + 3, (uint64_t)v157);
        sub_18DEE52C8(v157);
        if (v28) {
          goto LABEL_28;
        }
      }
      std::mutex::unlock(v29);
    }
    else
    {
      while (!cnframework::EventSubscription::operator==((unsigned __int8 *)v12, (unsigned __int8 *)&v153))
      {
        v12 += 4;
        if (v12 == v13)
        {
          double v12 = this[171];
          goto LABEL_6;
        }
      }
    }
LABEL_28:
    LOBYTE(v153) = 0;
    LOBYTE(v154) = 0;
    *((void *)&v154 + 1) = this + 2;
    long long v30 = this[170];
    long long v31 = this[171];
    if (v30 == v31)
    {
LABEL_32:
      long long v32 = this[172];
      if (v30 >= v32)
      {
        uint64_t v35 = ((char *)v30 - (char *)*v11) >> 5;
        if ((unint64_t)(v35 + 1) >> 59) {
          sub_18DEE1FC8();
        }
        uint64_t v36 = (char *)v32 - (char *)*v11;
        uint64_t v37 = v36 >> 4;
        if (v36 >> 4 <= (unint64_t)(v35 + 1)) {
          uint64_t v37 = v35 + 1;
        }
        if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v38 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v38 = v37;
        }
        if (v38) {
          uint64_t v39 = (char *)sub_18E01ACC8((uint64_t)(this + 172), v38);
        }
        else {
          uint64_t v39 = 0;
        }
        uint64_t v41 = &v39[32 * v35];
        uint64_t v42 = (cnframework::ActiveObjectBase **)&v39[32 * v38];
        long long v43 = v154;
        *(_OWORD *)uint64_t v41 = v153;
        *((_OWORD *)v41 + 1) = v43;
        long long v34 = (cnframework::ActiveObjectBase **)(v41 + 32);
        uint64_t v44 = this[171];
        double v45 = this[170];
        if (v44 != v45)
        {
          do
          {
            long long v46 = *((_OWORD *)v44 - 1);
            *((_OWORD *)v41 - 2) = *((_OWORD *)v44 - 2);
            *((_OWORD *)v41 - 1) = v46;
            v41 -= 32;
            v44 -= 4;
          }
          while (v44 != v45);
          uint64_t v44 = *v11;
        }
        this[170] = (cnframework::ActiveObjectBase **)v41;
        this[171] = v34;
        this[172] = v42;
        if (v44) {
          operator delete(v44);
        }
      }
      else
      {
        long long v33 = v154;
        *(_OWORD *)long long v30 = v153;
        *((_OWORD *)v30 + 1) = v33;
        long long v34 = v30 + 4;
      }
      this[171] = v34;
      int v47 = *((unsigned __int8 *)this + 1520);
      if (*((unsigned char *)this + 1520))
      {
        uint64_t v48 = 0;
      }
      else
      {
        uint64_t v48 = (std::mutex *)(this + 178);
        std::mutex::lock((std::mutex *)(this + 178));
      }
      if (sub_18DEE511C(this + 173, (uint64_t *)&v155))
      {
        if (v47) {
          goto LABEL_55;
        }
      }
      else
      {
        uint64_t v158 = v157;
        long long v156 = &v155;
        v157[0] = &unk_1EDD1DFA0;
        int v59 = sub_18E0BB7A0((uint64_t)(this + 173), (uint64_t *)&v155, (uint64_t)&std::piecewise_construct, &v156);
        sub_18E0BA000(v59 + 3, (uint64_t)v157);
        sub_18DEE52C8(v157);
        if (v47) {
          goto LABEL_55;
        }
      }
      std::mutex::unlock(v48);
    }
    else
    {
      while (!cnframework::EventSubscription::operator==((unsigned __int8 *)v30, (unsigned __int8 *)&v153))
      {
        v30 += 4;
        if (v30 == v31)
        {
          long long v30 = this[171];
          goto LABEL_32;
        }
      }
    }
LABEL_55:
    LOBYTE(v153) = 0;
    LOBYTE(v154) = 0;
    *((void *)&v154 + 1) = this + 2;
    uint64_t v49 = this[170];
    double v50 = this[171];
    if (v49 == v50)
    {
LABEL_59:
      double v51 = this[172];
      if (v49 >= v51)
      {
        uint64_t v54 = ((char *)v49 - (char *)*v11) >> 5;
        if ((unint64_t)(v54 + 1) >> 59) {
          sub_18DEE1FC8();
        }
        uint64_t v55 = (char *)v51 - (char *)*v11;
        uint64_t v56 = v55 >> 4;
        if (v55 >> 4 <= (unint64_t)(v54 + 1)) {
          uint64_t v56 = v54 + 1;
        }
        if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v57 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v57 = v56;
        }
        if (v57) {
          unsigned int v58 = (char *)sub_18E01ACC8((uint64_t)(this + 172), v57);
        }
        else {
          unsigned int v58 = 0;
        }
        char v60 = &v58[32 * v54];
        uint64_t v61 = (cnframework::ActiveObjectBase **)&v58[32 * v57];
        long long v62 = v154;
        *(_OWORD *)char v60 = v153;
        *((_OWORD *)v60 + 1) = v62;
        double v53 = (cnframework::ActiveObjectBase **)(v60 + 32);
        long long v63 = this[171];
        long long v64 = this[170];
        if (v63 != v64)
        {
          do
          {
            long long v65 = *((_OWORD *)v63 - 1);
            *((_OWORD *)v60 - 2) = *((_OWORD *)v63 - 2);
            *((_OWORD *)v60 - 1) = v65;
            v60 -= 32;
            v63 -= 4;
          }
          while (v63 != v64);
          long long v63 = *v11;
        }
        this[170] = (cnframework::ActiveObjectBase **)v60;
        this[171] = v53;
        this[172] = v61;
        if (v63) {
          operator delete(v63);
        }
      }
      else
      {
        long long v52 = v154;
        *(_OWORD *)uint64_t v49 = v153;
        *((_OWORD *)v49 + 1) = v52;
        double v53 = v49 + 4;
      }
      this[171] = v53;
      int v66 = *((unsigned __int8 *)this + 1520);
      if (*((unsigned char *)this + 1520))
      {
        long long v67 = 0;
      }
      else
      {
        long long v67 = (std::mutex *)(this + 178);
        std::mutex::lock((std::mutex *)(this + 178));
      }
      if (sub_18DEE511C(this + 173, (uint64_t *)&v155))
      {
        if (v66) {
          goto LABEL_82;
        }
      }
      else
      {
        uint64_t v158 = v157;
        long long v156 = &v155;
        v157[0] = &unk_1EDD1DEF0;
        unsigned int v78 = sub_18E0BB7A0((uint64_t)(this + 173), (uint64_t *)&v155, (uint64_t)&std::piecewise_construct, &v156);
        sub_18E0BA000(v78 + 3, (uint64_t)v157);
        sub_18DEE52C8(v157);
        if (v66) {
          goto LABEL_82;
        }
      }
      std::mutex::unlock(v67);
    }
    else
    {
      while (!cnframework::EventSubscription::operator==((unsigned __int8 *)v49, (unsigned __int8 *)&v153))
      {
        v49 += 4;
        if (v49 == v50)
        {
          uint64_t v49 = this[171];
          goto LABEL_59;
        }
      }
    }
LABEL_82:
    LOBYTE(v153) = 0;
    LOBYTE(v154) = 0;
    *((void *)&v154 + 1) = this + 2;
    char v68 = this[170];
    long long v69 = this[171];
    if (v68 == v69)
    {
LABEL_86:
      long long v70 = this[172];
      if (v68 >= v70)
      {
        uint64_t v73 = ((char *)v68 - (char *)*v11) >> 5;
        if ((unint64_t)(v73 + 1) >> 59) {
          sub_18DEE1FC8();
        }
        uint64_t v74 = (char *)v70 - (char *)*v11;
        uint64_t v75 = v74 >> 4;
        if (v74 >> 4 <= (unint64_t)(v73 + 1)) {
          uint64_t v75 = v73 + 1;
        }
        if ((unint64_t)v74 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v76 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v76 = v75;
        }
        if (v76) {
          BOOL v77 = (char *)sub_18E01ACC8((uint64_t)(this + 172), v76);
        }
        else {
          BOOL v77 = 0;
        }
        BOOL v79 = &v77[32 * v73];
        BOOL v80 = (cnframework::ActiveObjectBase **)&v77[32 * v76];
        long long v81 = v154;
        *(_OWORD *)BOOL v79 = v153;
        *((_OWORD *)v79 + 1) = v81;
        long long v72 = (cnframework::ActiveObjectBase **)(v79 + 32);
        unsigned int v82 = this[171];
        int v83 = this[170];
        if (v82 != v83)
        {
          do
          {
            long long v84 = *((_OWORD *)v82 - 1);
            *((_OWORD *)v79 - 2) = *((_OWORD *)v82 - 2);
            *((_OWORD *)v79 - 1) = v84;
            v79 -= 32;
            v82 -= 4;
          }
          while (v82 != v83);
          unsigned int v82 = *v11;
        }
        this[170] = (cnframework::ActiveObjectBase **)v79;
        this[171] = v72;
        this[172] = v80;
        if (v82) {
          operator delete(v82);
        }
      }
      else
      {
        long long v71 = v154;
        *(_OWORD *)char v68 = v153;
        *((_OWORD *)v68 + 1) = v71;
        long long v72 = v68 + 4;
      }
      this[171] = v72;
      int v85 = *((unsigned __int8 *)this + 1520);
      if (*((unsigned char *)this + 1520))
      {
        BOOL v86 = 0;
      }
      else
      {
        BOOL v86 = (std::mutex *)(this + 178);
        std::mutex::lock((std::mutex *)(this + 178));
      }
      if (sub_18DEE511C(this + 173, (uint64_t *)&v155))
      {
        if (v85) {
          goto LABEL_109;
        }
      }
      else
      {
        uint64_t v158 = v157;
        long long v156 = &v155;
        v157[0] = &unk_1EDD1DFF8;
        uint64_t v97 = sub_18E0BB7A0((uint64_t)(this + 173), (uint64_t *)&v155, (uint64_t)&std::piecewise_construct, &v156);
        sub_18E0BA000(v97 + 3, (uint64_t)v157);
        sub_18DEE52C8(v157);
        if (v85) {
          goto LABEL_109;
        }
      }
      std::mutex::unlock(v86);
    }
    else
    {
      while (!cnframework::EventSubscription::operator==((unsigned __int8 *)v68, (unsigned __int8 *)&v153))
      {
        v68 += 4;
        if (v68 == v69)
        {
          char v68 = this[171];
          goto LABEL_86;
        }
      }
    }
LABEL_109:
    LOBYTE(v153) = 0;
    LOBYTE(v154) = 0;
    *((void *)&v154 + 1) = this + 2;
    BOOL v87 = this[170];
    char v88 = this[171];
    if (v87 == v88)
    {
LABEL_113:
      long long v89 = this[172];
      if (v87 >= v89)
      {
        uint64_t v92 = ((char *)v87 - (char *)*v11) >> 5;
        if ((unint64_t)(v92 + 1) >> 59) {
          sub_18DEE1FC8();
        }
        uint64_t v93 = (char *)v89 - (char *)*v11;
        uint64_t v94 = v93 >> 4;
        if (v93 >> 4 <= (unint64_t)(v92 + 1)) {
          uint64_t v94 = v92 + 1;
        }
        if ((unint64_t)v93 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v95 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v95 = v94;
        }
        if (v95) {
          uint64_t v96 = (char *)sub_18E01ACC8((uint64_t)(this + 172), v95);
        }
        else {
          uint64_t v96 = 0;
        }
        int v98 = &v96[32 * v92];
        uint64_t v99 = (cnframework::ActiveObjectBase **)&v96[32 * v95];
        long long v100 = v154;
        *(_OWORD *)int v98 = v153;
        *((_OWORD *)v98 + 1) = v100;
        long long v91 = (cnframework::ActiveObjectBase **)(v98 + 32);
        uint64_t v101 = this[171];
        uint64_t v102 = this[170];
        if (v101 != v102)
        {
          do
          {
            long long v103 = *((_OWORD *)v101 - 1);
            *((_OWORD *)v98 - 2) = *((_OWORD *)v101 - 2);
            *((_OWORD *)v98 - 1) = v103;
            v98 -= 32;
            v101 -= 4;
          }
          while (v101 != v102);
          uint64_t v101 = *v11;
        }
        this[170] = (cnframework::ActiveObjectBase **)v98;
        this[171] = v91;
        this[172] = v99;
        if (v101) {
          operator delete(v101);
        }
      }
      else
      {
        long long v90 = v154;
        *(_OWORD *)BOOL v87 = v153;
        *((_OWORD *)v87 + 1) = v90;
        long long v91 = v87 + 4;
      }
      this[171] = v91;
      int v104 = *((unsigned __int8 *)this + 1520);
      if (*((unsigned char *)this + 1520))
      {
        uint64_t v105 = 0;
      }
      else
      {
        uint64_t v105 = (std::mutex *)(this + 178);
        std::mutex::lock((std::mutex *)(this + 178));
      }
      if (sub_18DEE511C(this + 173, (uint64_t *)&v155))
      {
        if (v104) {
          goto LABEL_136;
        }
      }
      else
      {
        uint64_t v158 = v157;
        long long v156 = &v155;
        v157[0] = &unk_1EDD1DE98;
        uint64_t v116 = sub_18E0BB7A0((uint64_t)(this + 173), (uint64_t *)&v155, (uint64_t)&std::piecewise_construct, &v156);
        sub_18E0BA000(v116 + 3, (uint64_t)v157);
        sub_18DEE52C8(v157);
        if (v104) {
          goto LABEL_136;
        }
      }
      std::mutex::unlock(v105);
    }
    else
    {
      while (!cnframework::EventSubscription::operator==((unsigned __int8 *)v87, (unsigned __int8 *)&v153))
      {
        v87 += 4;
        if (v87 == v88)
        {
          BOOL v87 = this[171];
          goto LABEL_113;
        }
      }
    }
LABEL_136:
    LOBYTE(v153) = 0;
    LOBYTE(v154) = 0;
    *((void *)&v154 + 1) = this + 2;
    int v106 = this[170];
    int v107 = this[171];
    if (v106 == v107)
    {
LABEL_140:
      uint64_t v108 = this[172];
      if (v106 >= v108)
      {
        uint64_t v111 = ((char *)v106 - (char *)*v11) >> 5;
        if ((unint64_t)(v111 + 1) >> 59) {
          sub_18DEE1FC8();
        }
        uint64_t v112 = (char *)v108 - (char *)*v11;
        uint64_t v113 = v112 >> 4;
        if (v112 >> 4 <= (unint64_t)(v111 + 1)) {
          uint64_t v113 = v111 + 1;
        }
        if ((unint64_t)v112 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v114 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v114 = v113;
        }
        if (v114) {
          uint64_t v115 = (char *)sub_18E01ACC8((uint64_t)(this + 172), v114);
        }
        else {
          uint64_t v115 = 0;
        }
        double v117 = &v115[32 * v111];
        uint64_t v118 = (cnframework::ActiveObjectBase **)&v115[32 * v114];
        long long v119 = v154;
        *(_OWORD *)double v117 = v153;
        *((_OWORD *)v117 + 1) = v119;
        int v110 = (cnframework::ActiveObjectBase **)(v117 + 32);
        long long v120 = this[171];
        long long v121 = this[170];
        if (v120 != v121)
        {
          do
          {
            long long v122 = *((_OWORD *)v120 - 1);
            *((_OWORD *)v117 - 2) = *((_OWORD *)v120 - 2);
            *((_OWORD *)v117 - 1) = v122;
            v117 -= 32;
            v120 -= 4;
          }
          while (v120 != v121);
          long long v120 = *v11;
        }
        this[170] = (cnframework::ActiveObjectBase **)v117;
        this[171] = v110;
        this[172] = v118;
        if (v120) {
          operator delete(v120);
        }
      }
      else
      {
        long long v109 = v154;
        *(_OWORD *)int v106 = v153;
        *((_OWORD *)v106 + 1) = v109;
        int v110 = v106 + 4;
      }
      this[171] = v110;
      int v123 = *((unsigned __int8 *)this + 1520);
      if (*((unsigned char *)this + 1520))
      {
        uint64_t v124 = 0;
      }
      else
      {
        uint64_t v124 = (std::mutex *)(this + 178);
        std::mutex::lock((std::mutex *)(this + 178));
      }
      if (sub_18DEE511C(this + 173, (uint64_t *)&v155))
      {
        if (v123) {
          goto LABEL_163;
        }
      }
      else
      {
        uint64_t v158 = v157;
        long long v156 = &v155;
        v157[0] = &unk_1EDD1DF48;
        int v140 = sub_18E0BB7A0((uint64_t)(this + 173), (uint64_t *)&v155, (uint64_t)&std::piecewise_construct, &v156);
        sub_18E0BA000(v140 + 3, (uint64_t)v157);
        sub_18DEE52C8(v157);
        if (v123) {
          goto LABEL_163;
        }
      }
      std::mutex::unlock(v124);
    }
    else
    {
      while (!cnframework::EventSubscription::operator==((unsigned __int8 *)v106, (unsigned __int8 *)&v153))
      {
        v106 += 4;
        if (v106 == v107)
        {
          int v106 = this[171];
          goto LABEL_140;
        }
      }
    }
LABEL_163:
    LOBYTE(v153) = 0;
    LOBYTE(v154) = 0;
    *((void *)&v154 + 1) = this + 2;
    uint64_t v125 = this[170];
    uint64_t v126 = this[171];
    if (v125 != v126)
    {
      while (!cnframework::EventSubscription::operator==((unsigned __int8 *)v125, (unsigned __int8 *)&v153))
      {
        v125 += 4;
        if (v125 == v126)
        {
          uint64_t v125 = this[171];
          goto LABEL_167;
        }
      }
      goto LABEL_190;
    }
LABEL_167:
    double v132 = this[172];
    if (v125 >= v132)
    {
      uint64_t v135 = ((char *)v125 - (char *)*v11) >> 5;
      if ((unint64_t)(v135 + 1) >> 59) {
        sub_18DEE1FC8();
      }
      uint64_t v136 = (char *)v132 - (char *)*v11;
      uint64_t v137 = v136 >> 4;
      if (v136 >> 4 <= (unint64_t)(v135 + 1)) {
        uint64_t v137 = v135 + 1;
      }
      if ((unint64_t)v136 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v138 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v138 = v137;
      }
      if (v138) {
        int v139 = (char *)sub_18E01ACC8((uint64_t)(this + 172), v138);
      }
      else {
        int v139 = 0;
      }
      int v141 = &v139[32 * v135];
      int v142 = (cnframework::ActiveObjectBase **)&v139[32 * v138];
      long long v143 = v154;
      *(_OWORD *)int v141 = v153;
      *((_OWORD *)v141 + 1) = v143;
      double v134 = (cnframework::ActiveObjectBase **)(v141 + 32);
      int v144 = this[171];
      unsigned int v145 = this[170];
      if (v144 != v145)
      {
        do
        {
          long long v146 = *((_OWORD *)v144 - 1);
          *((_OWORD *)v141 - 2) = *((_OWORD *)v144 - 2);
          *((_OWORD *)v141 - 1) = v146;
          v141 -= 32;
          v144 -= 4;
        }
        while (v144 != v145);
        int v144 = *v11;
      }
      this[170] = (cnframework::ActiveObjectBase **)v141;
      this[171] = v134;
      this[172] = v142;
      if (v144) {
        operator delete(v144);
      }
    }
    else
    {
      long long v133 = v154;
      *(_OWORD *)uint64_t v125 = v153;
      *((_OWORD *)v125 + 1) = v133;
      double v134 = v125 + 4;
    }
    this[171] = v134;
    int v147 = *((unsigned __int8 *)this + 1520);
    if (*((unsigned char *)this + 1520))
    {
      unsigned int v148 = 0;
    }
    else
    {
      unsigned int v148 = (std::mutex *)(this + 178);
      std::mutex::lock((std::mutex *)(this + 178));
    }
    if (sub_18DEE511C(this + 173, (uint64_t *)&v155))
    {
      if (v147)
      {
LABEL_190:
        *((unsigned char *)this + 817) = 1;
        LOWORD(v157[0]) = 13;
        LOBYTE(v153) = 2;
        cnprint::CNPrinter::Print((cnprint::CNPrinter *)v157, (unsigned __int8 *)&v153, "TrackRunSupervisor configured successfully", v127, v128, v129, v130, v131, v151);
        return v8 != 0;
      }
    }
    else
    {
      uint64_t v158 = v157;
      long long v156 = &v155;
      v157[0] = &unk_1EDD1E050;
      double v150 = sub_18E0BB7A0((uint64_t)(this + 173), (uint64_t *)&v155, (uint64_t)&std::piecewise_construct, &v156);
      sub_18E0BA000(v150 + 3, (uint64_t)v157);
      sub_18DEE52C8(v157);
      if (v147) {
        goto LABEL_190;
      }
    }
    std::mutex::unlock(v148);
    goto LABEL_190;
  }
  LOWORD(v157[0]) = 13;
  LOBYTE(v153) = 5;
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)v157, (unsigned __int8 *)&v153, "TrackRunSupervisor::Configure() called with invalid configuration parameters.", a4, a5, a6, a7, a8, v151);
  return v8 != 0;
}

void sub_18E1D4D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_18DEE52C8((uint64_t *)va);
  if (!v11) {
    std::mutex::unlock(v10);
  }
  _Unwind_Resume(a1);
}

void trackrun::TrackRunSupervisor::RaiseEventsFrom(trackrun::TrackRunSupervisor *this, const CoreNavigation::CLP::LogEntry::Raven::RavenPlatformInfo *a2)
{
  if (!*((unsigned char *)this + 817))
  {
    sub_18E1D6EEC((uint64_t)&v47);
    CNPlatformInfo::CNPlatformInfo((CNPlatformInfo *)&v18, a2);
    trackrun::TrackRunParameters::TrackRunParameters((trackrun::TrackRunParameters *)&v23, (const trackrun::TrackRunPlatformInfo *)&v18);
    __int16 v47 = v23;
    char v48 = v24;
    if (SHIBYTE(v50) < 0) {
      operator delete((void *)__p);
    }
    long long __p = v25;
    uint64_t v50 = v26;
    HIBYTE(v26) = 0;
    LOBYTE(v25) = 0;
    __int16 v51 = v27;
    if (SHIBYTE(v53) < 0) {
      operator delete((void *)v52);
    }
    long long v52 = *(_OWORD *)v28;
    uint64_t v53 = v29;
    HIBYTE(v29) = 0;
    LOBYTE(v28[0]) = 0;
    int v54 = v30;
    __int16 v55 = v31;
    if (v59)
    {
      uint64_t v4 = v58;
      if (v58)
      {
        do
        {
          uint64_t v5 = (void *)*v4;
          operator delete(v4);
          uint64_t v4 = v5;
        }
        while (v5);
      }
      unsigned int v58 = 0;
      unint64_t v6 = v57;
      if (v57)
      {
        uint64_t v7 = 0;
        do
          *((void *)v56 + v7++) = 0;
        while (v6 != v7);
      }
      uint64_t v59 = 0;
    }
    int v8 = v32;
    long long v32 = 0;
    uint64_t v9 = v56;
    uint64_t v56 = v8;
    if (v9) {
      operator delete(v9);
    }
    unint64_t v10 = v33;
    unint64_t v33 = 0;
    unsigned int v58 = v34;
    uint64_t v59 = v35;
    int v60 = v36;
    unint64_t v57 = v10;
    if (v35)
    {
      unint64_t v11 = v34[1];
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v11 >= v10) {
          v11 %= v10;
        }
      }
      else
      {
        v11 &= v10 - 1;
      }
      *((void *)v56 + v11) = &v58;
      long long v34 = 0;
      uint64_t v35 = 0;
    }
    long long v67 = v43;
    long long v68 = v44;
    long long v69 = v45;
    char v70 = v46;
    long long v63 = v39;
    long long v64 = v40;
    long long v65 = v41;
    long long v66 = v42;
    long long v61 = v37;
    long long v62 = v38;
    sub_18E011990((uint64_t)&v32);
    if (SHIBYTE(v29) < 0) {
      operator delete(v28[0]);
    }
    if (SHIBYTE(v26) < 0) {
      operator delete((void *)v25);
    }
    if (v22 < 0) {
      operator delete(v21);
    }
    if (v20 < 0) {
      operator delete(v19);
    }
    trackrun::TrackRunSupervisor::Configure((uint64_t)this, &v47, v12, v13, v14, v15, v16, v17);
    sub_18E011990((uint64_t)&v56);
    if (SHIBYTE(v53) < 0) {
      operator delete((void *)v52);
    }
    if (SHIBYTE(v50) < 0) {
      operator delete((void *)__p);
    }
  }
}

void sub_18E1D5014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50)
{
}

uint64_t sub_18E1D503C(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void trackrun::TrackRunSupervisor::RaiseEventsFrom(trackrun::TrackRunSupervisor *this, const CoreNavigation::CLP::LogEntry::PrivateData::GEOMapTropicalSavannaData *a2, trackrun::GEOMapRunningTrackDataEvent *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  char v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v18 = &unk_1EDD1A160;
  memset(v19, 0, sizeof(v19));
  char v20 = 0;
  char v26 = 1;
  if (trackrun::ConvertProtobufToGEOMapRunningTrackDataEvent(a2, (const CoreNavigation::CLP::LogEntry::PrivateData::GEOMapTropicalSavannaData *)&v18, a3, a4, a5, a6, a7, a8, a9, a10))
  {
    uint64_t v15 = operator new(0x60uLL);
    v15[1] = 0;
    void v15[2] = 0;
    *uint64_t v15 = &unk_1EDD1E458;
    v15[3] = &unk_1EDD0A260;
    uint64_t v16 = MEMORY[0x1E4FBA3D8];
    *((unsigned char *)v15 + 32) = 0;
    v15[5] = 0;
    v15[6] = v16;
    v15[7] = 0;
    v15[8] = 0;
    sub_18DEDE7B0(v15 + 9, "");
    *((unsigned char *)v15 + 32) = 1;
    operator new();
  }
  LOWORD(v27) = 13;
  v28[0] = 2;
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v27, v28, "Warning:Unable to create GEOMapTrackRunDataEvent from protobuf", v10, v11, v12, v13, v14, v17);
  uint64_t v18 = &unk_1EDD1A160;
  *(void *)&long long v27 = v19;
  sub_18E1BEB28((void ***)&v27);
}

void sub_18E1D5380(_Unwind_Exception *a1)
{
  *(void *)(v2 - 72) = v1;
  sub_18E1BEB28((void ***)(v2 - 72));
  _Unwind_Resume(a1);
}

cnprint::CNPrinter *trackrun::TrackRunSupervisor::RaiseEventsFrom(trackrun::TrackRunSupervisor *this, const CoreNavigation::CLP::LogEntry::PrivateData::Location *a2, trackrun::PositionEvent *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, int8x16_t a10)
{
  uint64_t v13 = &unk_1EDD19F38;
  char v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  char v17 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  char v23 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  char v20 = 0;
  uint64_t v24 = 0;
  v25[0] = 0;
  *(_DWORD *)((char *)v25 + 7) = 0;
  int8x16_t v26 = (int8x16_t)vdupq_n_s64(0x7FF8000000000000uLL);
  int8x16_t v27 = v26;
  int8x16_t v28 = v26;
  int8x16_t v29 = v26;
  uint64_t v30 = 0x7FF8000000000000;
  __int16 v31 = 0;
  int8x16_t v32 = v26;
  uint64_t v33 = 0x7FF8000000000000;
  uint64_t result = trackrun::ConvertProtobufToPositionEvent(a2, (const CoreNavigation::CLP::LogEntry::PrivateData::Location *)&v13, a3, a4, a5, a6, a7, a8, v26, a10);
  if (result)
  {
    uint64_t v11 = operator new(0x60uLL);
    v11[1] = 0;
    void v11[2] = 0;
    void *v11 = &unk_1EDD1E458;
    v11[3] = &unk_1EDD0A260;
    uint64_t v12 = MEMORY[0x1E4FBA3D8];
    *((unsigned char *)v11 + 32) = 0;
    v11[5] = 0;
    v11[6] = v12;
    v11[7] = 0;
    v11[8] = 0;
    sub_18DEDE7B0(v11 + 9, "");
    *((unsigned char *)v11 + 32) = 1;
    operator new();
  }
  return result;
}

void sub_18E1D570C(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v2 - 64);
  if (v4) {
    sub_18DEE4E18(v4);
  }
  sub_18DEE4E18(v1);
  _Unwind_Resume(a1);
}

CoreNavigation::CLP::LogEntry::PrivateData *trackrun::TrackRunSupervisor::RaiseEventsFrom(trackrun::TrackRunSupervisor *this, const CoreNavigation::CLP::LogEntry::PrivateData::MotionState *a2, trackrun::MovingStateEvent *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  uint64_t v21 = &unk_1EDD19F98;
  char v22 = 0;
  uint64_t v23 = 0;
  double v24 = 0.0;
  char v25 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  char v28 = 0;
  uint64_t result = (CoreNavigation::CLP::LogEntry::PrivateData *)trackrun::ConvertProtobufToMovingStateEvent(a2, (const CoreNavigation::CLP::LogEntry::PrivateData::MotionState *)&v21, a3, a4, a5, a6, a7, a8, a9, a10);
  if (result)
  {
    LOWORD(v29) = 13;
    unsigned __int8 v20 = 2;
    double v17 = v24 + (double)v23;
    if (!*((void *)a2 + 2)) {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataShared_2eproto(result);
    }
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v29, &v20, "ExternalMovingState,t,%.3lf,moving_tate,%d,activityType,%d", v12, v13, v14, v15, v16, SLOBYTE(v17));
    uint64_t v18 = operator new(0x60uLL);
    v18[1] = 0;
    double v18[2] = 0;
    *uint64_t v18 = &unk_1EDD1E458;
    v18[3] = &unk_1EDD0A260;
    uint64_t v19 = MEMORY[0x1E4FBA3D8];
    *((unsigned char *)v18 + 32) = 0;
    v18[5] = 0;
    v18[6] = v19;
    v18[7] = 0;
    v18[8] = 0;
    sub_18DEDE7B0(v18 + 9, "");
    *((unsigned char *)v18 + 32) = 1;
    operator new();
  }
  return result;
}

void sub_18E1D5A70(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v2 - 80);
  if (v4) {
    sub_18DEE4E18(v4);
  }
  sub_18DEE4E18(v1);
  _Unwind_Resume(a1);
}

void trackrun::TrackRunSupervisor::RaiseEventsFrom(trackrun::TrackRunSupervisor *this, const CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator *a2)
{
  uint64_t v11 = &unk_1EDD1A090;
  char v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  char v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  __int16 v18 = 0;
  sub_18DEDE7B0(&__p, "");
  char v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  char v24 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  char v30 = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  char v36 = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  char v27 = 0;
  char v33 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  if (trackrun::ConvertProtobufToWorkoutSessionEvent(a2, (const CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator *)&v11, v3, v4, v5, v6, v7, v8, v9, v10))sub_18E1D5BEC(); {
  uint64_t v11 = &unk_1EDD1A090;
  }
  if (v20 < 0) {
    operator delete(__p);
  }
}

void sub_18E1D5BCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_18E1D5BEC()
{
  std::locale v0 = operator new(0x60uLL);
  v0[1] = 0;
  v0[2] = 0;
  void *v0 = &unk_1EDD1E458;
  v0[3] = &unk_1EDD0A260;
  uint64_t v1 = MEMORY[0x1E4FBA3D8];
  *((unsigned char *)v0 + 32) = 0;
  v0[5] = 0;
  v0[6] = v1;
  v0[7] = 0;
  v0[8] = 0;
  sub_18DEDE7B0(v0 + 9, "");
  *((unsigned char *)v0 + 32) = 1;
  operator new();
}

void sub_18E1D5DD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_18DEE4E18(a11);
  }
  sub_18DEE4E18(v11);
  _Unwind_Resume(a1);
}

void trackrun::TrackRunSupervisor::RaiseEventsFrom(trackrun::TrackRunSupervisor *this, const CoreNavigation::CLP::LogEntry::PrivateData::MotionStateObserver *a2)
{
  uint64_t v11 = &unk_1EDD1A090;
  char v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  char v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  __int16 v18 = 0;
  sub_18DEDE7B0(&__p, "");
  char v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  char v24 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  char v30 = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  char v36 = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  char v27 = 0;
  char v33 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  if (trackrun::ConvertProtobufToWorkoutSessionEvent(a2, (const CoreNavigation::CLP::LogEntry::PrivateData::MotionStateObserver *)&v11, v3, v4, v5, v6, v7, v8, v9, v10))sub_18E1D5BEC(); {
  uint64_t v11 = &unk_1EDD1A090;
  }
  if (v20 < 0) {
    operator delete(__p);
  }
}

void sub_18E1D5F50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void trackrun::TrackRunSupervisor::RaiseEventsFrom(trackrun::TrackRunSupervisor *this, const CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit *a2)
{
  uint64_t v13 = &unk_1EDD19F08;
  char v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  char v17 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  char v23 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  char v29 = 0;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  char v35 = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  char v20 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  char v26 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  char v32 = 0;
  int64x2_t v38 = vdupq_n_s64(0x7FF8000000000000uLL);
  unint64_t v39 = 0xBFF0000000000000;
  __int16 v40 = 0;
  sub_18DEDE7B0(v41, "");
  sub_18DEDE7B0(v42, "");
  if (trackrun::ConvertProtobufToVisitEvent(a2, (const CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit *)&v13, v3, v4, v5, v6, v7, v8, v9, v10))
  {
    uint64_t v11 = operator new(0x60uLL);
    v11[1] = 0;
    void v11[2] = 0;
    void *v11 = &unk_1EDD1E458;
    v11[3] = &unk_1EDD0A260;
    uint64_t v12 = MEMORY[0x1E4FBA3D8];
    *((unsigned char *)v11 + 32) = 0;
    v11[5] = 0;
    v11[6] = v12;
    v11[7] = 0;
    v11[8] = 0;
    sub_18DEDE7B0(v11 + 9, "");
    *((unsigned char *)v11 + 32) = 1;
    operator new();
  }
  trackrun::VisitEvent::~VisitEvent(&v13);
}

void sub_18E1D620C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  char v46 = *(std::__shared_weak_count **)(v44 - 64);
  if (v46) {
    sub_18DEE4E18(v46);
  }
  sub_18DEE4E18(v43);
  trackrun::VisitEvent::~VisitEvent((void **)&a9);
  _Unwind_Resume(a1);
}

void trackrun::TrackRunSupervisor::RaiseEventsFrom(trackrun::TrackRunSupervisor *this, const CoreNavigation::CLP::LogEntry::TropicalSavanna::TropicalSavannaHint *a2, trackrun::TrackRunHintEvent *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  uint64_t v19 = &unk_1EDD19FC8;
  char v20 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  char v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  char v26 = 0;
  if (trackrun::ConvertProtobufToTrackRunHintEvent(a2, (const CoreNavigation::CLP::LogEntry::TropicalSavanna::TropicalSavannaHint *)&v19, a3, a4, a5, a6, a7, a8, a9, a10))
  {
    uint64_t v15 = operator new(0x60uLL);
    v15[1] = 0;
    void v15[2] = 0;
    *uint64_t v15 = &unk_1EDD1E458;
    v15[3] = &unk_1EDD0A260;
    uint64_t v16 = MEMORY[0x1E4FBA3D8];
    *((unsigned char *)v15 + 32) = 0;
    v15[5] = 0;
    v15[6] = v16;
    v15[7] = 0;
    v15[8] = 0;
    sub_18DEDE7B0(v15 + 9, "");
    *((unsigned char *)v15 + 32) = 1;
    operator new();
  }
  LOWORD(v27) = 13;
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v27, &v18, "Warning:Unable to create TrackRunHintEvent from protobuf", v10, v11, v12, v13, v14, v17);
}

void sub_18E1D6584(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19) {
    sub_18DEE4E18(a19);
  }
  sub_18DEE4E18(v19);
  _Unwind_Resume(a1);
}

void trackrun::TrackRunSupervisor::RaiseEventsFrom(trackrun::TrackRunSupervisor *this, const CoreNavigation::CLP::LogEntry::PrivateData::WatchState *a2, trackrun::WatchStateEvent *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  uint64_t v19 = &unk_1EDD19F68;
  char v20 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  char v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  if (trackrun::ConvertProtobufToWatchStateEvent(a2, (const CoreNavigation::CLP::LogEntry::PrivateData::WatchState *)&v19, a3, a4, a5, a6, a7, a8, a9, a10))
  {
    uint64_t v15 = operator new(0x60uLL);
    v15[1] = 0;
    void v15[2] = 0;
    *uint64_t v15 = &unk_1EDD1E458;
    v15[3] = &unk_1EDD0A260;
    uint64_t v16 = MEMORY[0x1E4FBA3D8];
    *((unsigned char *)v15 + 32) = 0;
    v15[5] = 0;
    v15[6] = v16;
    v15[7] = 0;
    v15[8] = 0;
    sub_18DEDE7B0(v15 + 9, "");
    *((unsigned char *)v15 + 32) = 1;
    operator new();
  }
  LOWORD(v26) = 13;
  cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v26, &v18, "Warning:Unable to create WatchStateEvent from protobuf", v10, v11, v12, v13, v14, v17);
}

void sub_18E1D68A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19) {
    sub_18DEE4E18(a19);
  }
  sub_18DEE4E18(v19);
  _Unwind_Resume(a1);
}

uint64_t trackrun::TrackRunSupervisor::RaiseEventsFrom(trackrun::TrackRunSupervisor *this, const CoreNavigation::CLP::LogEntry::LogEntry *a2, trackrun::GEOMapRunningTrackDataEvent *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  uint64_t v11 = this;
  uint64_t v12 = *((void *)a2 + 5);
  uint64_t v13 = v12;
  if (!v12)
  {
    CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
    uint64_t v13 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    uint64_t v12 = *((void *)a2 + 5);
  }
  if ((*(unsigned char *)(v13 + 320) & 2) == 0) {
    goto LABEL_9;
  }
  if (!v12)
  {
    CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
    uint64_t v12 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
  }
  uint64_t v14 = *(void *)(v12 + 272);
  if (!v14)
  {
    CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataCapture_2eproto(this);
    uint64_t v14 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::PrivateDataCapture::default_instance_ + 272);
  }
  uint64_t v12 = *((void *)a2 + 5);
  if ((*(unsigned char *)(v14 + 28) & 2) != 0)
  {
    if (!v12)
    {
      CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
      uint64_t v12 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    }
    uint64_t v16 = *(void *)(v12 + 272);
    if (!v16)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataCapture_2eproto(this);
      uint64_t v16 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::PrivateDataCapture::default_instance_ + 272);
    }
    char v17 = *(const CoreNavigation::CLP::LogEntry::Raven::RavenPlatformInfo **)(v16 + 16);
    if (!v17)
    {
      CoreNavigation::CLP::LogEntry::Raven::protobuf_AddDesc_CoreNavigationCLPRavenLogEntry_2eproto(this);
      char v17 = *(const CoreNavigation::CLP::LogEntry::Raven::RavenPlatformInfo **)(CoreNavigation::CLP::LogEntry::Raven::LogEntry::default_instance_
                                                                              + 16);
    }
    trackrun::TrackRunSupervisor::RaiseEventsFrom(v11, v17);
    uint64_t v12 = *((void *)a2 + 5);
    uint64_t v15 = 1;
  }
  else
  {
LABEL_9:
    uint64_t v15 = 0;
  }
  uint64_t v18 = v12;
  if (!v12)
  {
    CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
    uint64_t v18 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    uint64_t v12 = *((void *)a2 + 5);
  }
  if ((*(unsigned char *)(v18 + 319) & 4) != 0)
  {
    if (!v12)
    {
      CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
      uint64_t v12 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    }
    uint64_t v19 = *(const CoreNavigation::CLP::LogEntry::PrivateData::GEOMapTropicalSavannaData **)(v12 + 216);
    if (!v19)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataCapture_2eproto(this);
      uint64_t v19 = *(const CoreNavigation::CLP::LogEntry::PrivateData::GEOMapTropicalSavannaData **)(CoreNavigation::CLP::LogEntry::PrivateData::PrivateDataCapture::default_instance_
                                                                                            + 216);
    }
    trackrun::TrackRunSupervisor::RaiseEventsFrom(v11, v19, a3, a4, a5, a6, a7, a8, a9, a10);
    uint64_t v12 = *((void *)a2 + 5);
    uint64_t v15 = 2;
  }
  uint64_t v20 = v12;
  if (!v12)
  {
    CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
    uint64_t v20 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    uint64_t v12 = *((void *)a2 + 5);
  }
  if ((*(unsigned char *)(v20 + 316) & 8) != 0)
  {
    if (!v12)
    {
      CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
      uint64_t v12 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    }
    uint64_t v21 = *(const CoreNavigation::CLP::LogEntry::PrivateData::Location **)(v12 + 32);
    if (!v21)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataCapture_2eproto(this);
      uint64_t v21 = *(const CoreNavigation::CLP::LogEntry::PrivateData::Location **)(CoreNavigation::CLP::LogEntry::PrivateData::PrivateDataCapture::default_instance_
                                                                           + 32);
    }
    this = trackrun::TrackRunSupervisor::RaiseEventsFrom(v11, v21, a3, a4, a5, a6, a7, a8, *(double *)a9.i64, a10);
    uint64_t v12 = *((void *)a2 + 5);
    uint64_t v15 = 3;
  }
  uint64_t v22 = v12;
  if (!v12)
  {
    CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
    uint64_t v22 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    uint64_t v12 = *((void *)a2 + 5);
  }
  if ((*(unsigned char *)(v22 + 316) & 0x10) != 0)
  {
    if (!v12)
    {
      CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
      uint64_t v12 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    }
    char v23 = *(const CoreNavigation::CLP::LogEntry::PrivateData::MotionState **)(v12 + 40);
    if (!v23)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataCapture_2eproto(this);
      char v23 = *(const CoreNavigation::CLP::LogEntry::PrivateData::MotionState **)(CoreNavigation::CLP::LogEntry::PrivateData::PrivateDataCapture::default_instance_
                                                                              + 40);
    }
    this = trackrun::TrackRunSupervisor::RaiseEventsFrom(v11, v23, a3, a4, a5, a6, a7, a8, a9, a10);
    uint64_t v12 = *((void *)a2 + 5);
    uint64_t v15 = 4;
  }
  uint64_t v24 = v12;
  if (!v12)
  {
    CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
    uint64_t v24 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    uint64_t v12 = *((void *)a2 + 5);
  }
  if ((*(unsigned char *)(v24 + 319) & 0x10) != 0)
  {
    if (!v12)
    {
      CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
      uint64_t v12 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    }
    uint64_t v25 = *(const CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator **)(v12 + 232);
    if (!v25)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataCapture_2eproto(this);
      uint64_t v25 = *(const CoreNavigation::CLP::LogEntry::PrivateData::MotionStateMediator **)(CoreNavigation::CLP::LogEntry::PrivateData::PrivateDataCapture::default_instance_
                                                                                      + 232);
    }
    trackrun::TrackRunSupervisor::RaiseEventsFrom(v11, v25);
    uint64_t v12 = *((void *)a2 + 5);
    uint64_t v15 = 5;
  }
  if (!v12)
  {
    CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
    uint64_t v12 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
  }
  if ((*(unsigned char *)(v12 + 317) & 8) != 0)
  {
    uint64_t v26 = *((void *)a2 + 5);
    if (!v26)
    {
      CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
      uint64_t v26 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    }
    if (!*(void *)(v26 + 96)) {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataCapture_2eproto(this);
    }
    uint64_t v15 = 8;
  }
  uint64_t v27 = *((void *)a2 + 5);
  if (!v27)
  {
    CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
    uint64_t v27 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
  }
  if ((*(unsigned char *)(v27 + 317) & 0x80) != 0)
  {
    uint64_t v28 = *((void *)a2 + 5);
    if (!v28)
    {
      CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
      uint64_t v28 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    }
    if (!*(void *)(v28 + 128)) {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataCapture_2eproto(this);
    }
    uint64_t v15 = 9;
  }
  uint64_t v29 = *((void *)a2 + 5);
  uint64_t v30 = v29;
  if (!v29)
  {
    CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
    uint64_t v30 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    uint64_t v29 = *((void *)a2 + 5);
  }
  if ((*(unsigned char *)(v30 + 320) & 8) != 0)
  {
    if (!v29)
    {
      CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
      uint64_t v29 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    }
    uint64_t v31 = *(void *)(v29 + 288);
    if (!v31)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataCapture_2eproto(this);
      uint64_t v31 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::PrivateDataCapture::default_instance_ + 288);
    }
    uint64_t v29 = *((void *)a2 + 5);
    if (*(unsigned char *)(v31 + 20))
    {
      if (!v29)
      {
        CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
        uint64_t v29 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
      }
      uint64_t v32 = *(void *)(v29 + 288);
      if (!v32)
      {
        CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataCapture_2eproto(this);
        uint64_t v32 = *(void *)(CoreNavigation::CLP::LogEntry::PrivateData::PrivateDataCapture::default_instance_ + 288);
      }
      uint64_t v33 = *(const CoreNavigation::CLP::LogEntry::TropicalSavanna::TropicalSavannaHint **)(v32 + 8);
      if (!v33)
      {
        CoreNavigation::CLP::LogEntry::TropicalSavanna::protobuf_AddDesc_CoreNavigationCLPTropicalSavannaLogEntry_2eproto(this);
        uint64_t v33 = *(const CoreNavigation::CLP::LogEntry::TropicalSavanna::TropicalSavannaHint **)(CoreNavigation::CLP::LogEntry::TropicalSavanna::LogEntry::default_instance_
                                                                                            + 8);
      }
      trackrun::TrackRunSupervisor::RaiseEventsFrom(v11, v33, a3, a4, a5, a6, a7, a8, a9, a10);
      uint64_t v29 = *((void *)a2 + 5);
      uint64_t v15 = 10;
    }
  }
  uint64_t v34 = v29;
  if (!v29)
  {
    CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
    uint64_t v34 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    uint64_t v29 = *((void *)a2 + 5);
  }
  if ((*(unsigned char *)(v34 + 319) & 0x20) != 0)
  {
    if (!v29)
    {
      CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
      uint64_t v29 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    }
    char v35 = *(const CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit **)(v29 + 240);
    if (!v35)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataCapture_2eproto(this);
      char v35 = *(const CoreNavigation::CLP::LogEntry::PrivateData::RoutineVisit **)(CoreNavigation::CLP::LogEntry::PrivateData::PrivateDataCapture::default_instance_
                                                                               + 240);
    }
    trackrun::TrackRunSupervisor::RaiseEventsFrom(v11, v35);
    uint64_t v29 = *((void *)a2 + 5);
    uint64_t v15 = 11;
  }
  uint64_t v36 = v29;
  if (!v29)
  {
    CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
    uint64_t v36 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    uint64_t v29 = *((void *)a2 + 5);
  }
  if ((*(unsigned char *)(v36 + 319) & 8) != 0)
  {
    if (!v29)
    {
      CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
      uint64_t v29 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
    }
    uint64_t v37 = *(const CoreNavigation::CLP::LogEntry::PrivateData::WatchState **)(v29 + 224);
    if (!v37)
    {
      CoreNavigation::CLP::LogEntry::PrivateData::protobuf_AddDesc_CoreNavigationCLPPrivateDataCapture_2eproto(this);
      uint64_t v37 = *(const CoreNavigation::CLP::LogEntry::PrivateData::WatchState **)(CoreNavigation::CLP::LogEntry::PrivateData::PrivateDataCapture::default_instance_
                                                                             + 224);
    }
    trackrun::TrackRunSupervisor::RaiseEventsFrom(v11, v37, a3, a4, a5, a6, a7, a8, a9, a10);
    uint64_t v29 = *((void *)a2 + 5);
    uint64_t v15 = 12;
  }
  if (!v29)
  {
    CoreNavigation::CLP::LogEntry::protobuf_AddDesc_CoreNavigationCLPLogEntry_2eproto(this);
    uint64_t v29 = *(void *)(CoreNavigation::CLP::LogEntry::LogEntry::default_instance_ + 40);
  }
  if ((*(unsigned char *)(v29 + 317) & 0x40) != 0)
  {
    cnframework::Supervisor::Reset(v11);
    return 7;
  }
  return v15;
}

uint64_t trackrun::TrackRunSupervisor::RaiseEventsFrom(trackrun::TrackRunSupervisor *a1)
{
  CoreNavigation::CLP::LogEntry::LogEntry::LogEntry((CoreNavigation::CLP::LogEntry::LogEntry *)v15);
  if (wireless_diagnostics::google::protobuf::MessageLite::ParseFromString())
  {
    uint64_t v10 = trackrun::TrackRunSupervisor::RaiseEventsFrom(a1, (const CoreNavigation::CLP::LogEntry::LogEntry *)v15, v2, v3, v4, v5, v6, v7, v8, v9);
  }
  else
  {
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v14, &v13, "Failed to parse incoming LogEntry", v3, v4, v5, v6, v7, v12);
    uint64_t v10 = 0;
  }
  CoreNavigation::CLP::LogEntry::LogEntry::~LogEntry((CoreNavigation::CLP::LogEntry::LogEntry *)v15);
  return v10;
}

void sub_18E1D6ED4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  CoreNavigation::CLP::LogEntry::LogEntry::~LogEntry((CoreNavigation::CLP::LogEntry::LogEntry *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_18E1D6EEC(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  *(_WORD *)a1 = 0;
  *(unsigned char *)(a1 + 2) = 0;
  sub_18DEDE7B0((void *)(a1 + 8), "trackrun_output.bin");
  *(_WORD *)(a1 + 32) = 1;
  sub_18DEDE7B0((void *)(a1 + 40), "trackrun_debug.txt");
  *(_DWORD *)(a1 + 64) = 256;
  *(_WORD *)(a1 + 68) = 256;
  int v3 = 2;
  uint64_t v4 = 0x40A3880000000000;
  int v5 = 3;
  uint64_t v6 = 0x40A3880000000000;
  int v7 = 4;
  uint64_t v8 = 0x4059000000000000;
  sub_18E1BEE04(a1 + 72, &v3, 3);
  *(void *)(a1 + 112) = 0x410E848000000000;
  *(unsigned char *)(a1 + 120) = 1;
  *(_OWORD *)(a1 + 128) = xmmword_18E22C040;
  *(_OWORD *)(a1 + 144) = xmmword_18E22C050;
  *(_OWORD *)(a1 + 160) = xmmword_18E22C060;
  *(void *)(a1 + 176) = 0x3F50624DD2F1A9FCLL;
  *(void *)(a1 + 184) = 5;
  *(void *)(a1 + 192) = 0x4052C00000000000;
  *(_WORD *)(a1 + 200) = 0;
  *(unsigned char *)(a1 + 202) = 0;
  *(void *)(a1 + 208) = 1;
  *(_WORD *)(a1 + 216) = 256;
  *(_OWORD *)(a1 + 224) = xmmword_18E1FC4D0;
  *(_OWORD *)(a1 + 240) = xmmword_18E22C070;
  *(unsigned char *)(a1 + 256) = 0;
  return a1;
}

void sub_18E1D7054(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_18E1D7088(void *a1, uint64_t *a2)
{
  uint64_t v4 = a1[1];
  if (!v4) {
    goto LABEL_9;
  }
  for (uint64_t i = 0; i != v4; *(void *)(*a1 + 8 * i++) = 0)
    ;
  uint64_t v6 = (uint64_t *)a1[2];
  a1[2] = 0;
  a1[3] = 0;
  if (v6)
  {
    while (a2)
    {
      unint64_t v7 = *((int *)a2 + 4);
      *((_DWORD *)v6 + 4) = v7;
      uint64_t v6[3] = a2[3];
      uint64_t v8 = (uint64_t *)*v6;
      v6[1] = v7;
      uint64_t v9 = sub_18E1D71C8((uint64_t)a1, v7, (_DWORD *)v6 + 4);
      sub_18E1D7518(a1, v6, v9);
      a2 = (uint64_t *)*a2;
      uint64_t v6 = v8;
      if (!v8) {
        goto LABEL_9;
      }
    }
    do
    {
      unsigned __int8 v13 = (uint64_t *)*v6;
      operator delete(v6);
      uint64_t v6 = v13;
    }
    while (v13);
  }
  else
  {
LABEL_9:
    while (a2)
    {
      uint64_t v10 = operator new(0x20uLL);
      *(void *)uint64_t v10 = 0;
      v10[1] = *((_OWORD *)a2 + 1);
      unint64_t v11 = *((int *)v10 + 4);
      *((void *)v10 + 1) = v11;
      char v12 = sub_18E1D71C8((uint64_t)a1, v11, (_DWORD *)v10 + 4);
      sub_18E1D7518(a1, v10, v12);
      a2 = (uint64_t *)*a2;
    }
  }
}

void sub_18E1D7184(void *a1)
{
  __cxa_begin_catch(a1);
  do
  {
    uint64_t v2 = (void *)*v1;
    operator delete(v1);
    uint64_t v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_18E1D71A4(_Unwind_Exception *a1)
{
}

uint64_t *sub_18E1D71C8(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v6 = *(void *)(a1 + 8);
  float v7 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v8 = *(float *)(a1 + 32);
  if (!v6 || (float)(v8 * (float)v6) < v7)
  {
    BOOL v9 = 1;
    if (v6 >= 3) {
      BOOL v9 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v10 = v9 | (2 * v6);
    unint64_t v11 = vcvtps_u32_f32(v7 / v8);
    if (v10 <= v11) {
      int8x8_t prime = (int8x8_t)v11;
    }
    else {
      int8x8_t prime = (int8x8_t)v10;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v6 = *(void *)(a1 + 8);
    }
    if (*(void *)&prime > v6) {
      goto LABEL_74;
    }
    if (*(void *)&prime >= v6) {
      goto LABEL_43;
    }
    unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v6 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
    {
      unint64_t v19 = std::__next_prime(v19);
    }
    else
    {
      uint64_t v21 = 1 << -(char)__clz(v19 - 1);
      if (v19 >= 2) {
        unint64_t v19 = v21;
      }
    }
    if (*(void *)&prime <= v19) {
      int8x8_t prime = (int8x8_t)v19;
    }
    if (*(void *)&prime >= v6)
    {
      unint64_t v6 = *(void *)(a1 + 8);
      goto LABEL_43;
    }
    if (prime)
    {
LABEL_74:
      if (*(void *)&prime >> 61) {
        sub_18DEDF7D4();
      }
      unsigned __int8 v13 = operator new(8 * *(void *)&prime);
      __int16 v14 = *(void **)a1;
      *(void *)a1 = v13;
      if (v14) {
        operator delete(v14);
      }
      uint64_t v15 = 0;
      *(int8x8_t *)(a1 + 8) = prime;
      do
        *(void *)(*(void *)a1 + 8 * v15++) = 0;
      while (*(void *)&prime != v15);
      uint64_t v16 = *(uint64_t ***)(a1 + 16);
      if (v16)
      {
        unint64_t v17 = (unint64_t)v16[1];
        uint8x8_t v18 = (uint8x8_t)vcnt_s8(prime);
        v18.i16[0] = vaddlv_u8(v18);
        if (v18.u32[0] > 1uLL)
        {
          if (v17 >= *(void *)&prime) {
            v17 %= *(void *)&prime;
          }
        }
        else
        {
          v17 &= *(void *)&prime - 1;
        }
        *(void *)(*(void *)a1 + 8 * v17) = a1 + 16;
        for (uint64_t i = *v16; *v16; uint64_t i = *v16)
        {
          unint64_t v23 = i[1];
          if (v18.u32[0] > 1uLL)
          {
            if (v23 >= *(void *)&prime) {
              v23 %= *(void *)&prime;
            }
          }
          else
          {
            v23 &= *(void *)&prime - 1;
          }
          if (v23 == v17)
          {
            uint64_t v16 = (uint64_t **)i;
          }
          else
          {
            uint64_t v24 = i;
            if (*(void *)(*(void *)a1 + 8 * v23))
            {
              do
              {
                uint64_t v25 = v24;
                uint64_t v24 = (uint64_t *)*v24;
              }
              while (v24 && *((_DWORD *)i + 4) == *((_DWORD *)v24 + 4));
              *uint64_t v16 = v24;
              *uint64_t v25 = **(void **)(*(void *)a1 + 8 * v23);
              **(void **)(*(void *)a1 + 8 * v23) = i;
            }
            else
            {
              *(void *)(*(void *)a1 + 8 * v23) = v16;
              uint64_t v16 = (uint64_t **)i;
              unint64_t v17 = v23;
            }
          }
        }
      }
      unint64_t v6 = (unint64_t)prime;
    }
    else
    {
      char v35 = *(void **)a1;
      *(void *)a1 = 0;
      if (v35) {
        operator delete(v35);
      }
      unint64_t v6 = 0;
      *(void *)(a1 + 8) = 0;
    }
  }
LABEL_43:
  uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v26.i16[0] = vaddlv_u8(v26);
  if (v26.u32[0] > 1uLL)
  {
    unint64_t v27 = a2;
    if (v6 <= a2) {
      unint64_t v27 = a2 % v6;
    }
  }
  else
  {
    unint64_t v27 = (v6 - 1) & a2;
  }
  uint64_t v28 = *(uint64_t **)(*(void *)a1 + 8 * v27);
  if (!v28) {
    return 0;
  }
  int v29 = 0;
  do
  {
    uint64_t result = v28;
    uint64_t v28 = (uint64_t *)*v28;
    if (!v28) {
      break;
    }
    unint64_t v31 = v28[1];
    if (v26.u32[0] > 1uLL)
    {
      unint64_t v32 = v28[1];
      if (v31 >= v6) {
        unint64_t v32 = v31 % v6;
      }
    }
    else
    {
      unint64_t v32 = v31 & (v6 - 1);
    }
    if (v32 != v27) {
      break;
    }
    BOOL v33 = v31 == a2 && *((_DWORD *)v28 + 4) == *a3;
    int v34 = v29 & !v33;
    v29 |= v33;
  }
  while (v34 != 1);
  return result;
}

void *sub_18E1D7518(void *result, void *a2, void *a3)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  if (!a3)
  {
    *a2 = result[2];
    result[2] = a2;
    *(void *)(*result + 8 * v4) = result + 2;
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v3) {
        v6 %= *(void *)&v3;
      }
    }
    else
    {
      v6 &= *(void *)&v3 - 1;
    }
LABEL_18:
    *(void *)(*result + 8 * v6) = a2;
    goto LABEL_19;
  }
  *a2 = *a3;
  *a3 = a2;
  if (*a2)
  {
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v3) {
        v6 %= *(void *)&v3;
      }
    }
    else
    {
      v6 &= *(void *)&v3 - 1;
    }
    if (v6 != v4) {
      goto LABEL_18;
    }
  }
LABEL_19:
  ++result[3];
  return result;
}

void sub_18E1D7604()
{
}

void *sub_18E1D7618()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EDD1E0A8;
  return result;
}

void sub_18E1D7650(uint64_t a1, void *a2)
{
  *a2 = &unk_1EDD1E0A8;
}

void sub_18E1D7678(int a1, uint64_t *a2, cnframework::GenericEvent *this, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a2;
  uint64_t EventType = cnframework::GenericEvent::GetEventType(this, (uint64_t)a2, (uint64_t)this, a4, a5, a6, a7, a8);
  {
    uint64_t v18 = *((void *)this + 2);
    if (v18) {
      uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18);
    }
    else {
      uint64_t v19 = MEMORY[0x1E4FBA3D8];
    }
    BOOL v33 = (const char *)(*(void *)(v19 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v33 != (const char *)((unint64_t)off_1EDD080E0 & 0x7FFFFFFFFFFFFFFFLL)
      && strcmp(v33, (const char *)((unint64_t)off_1EDD080E0 & 0x7FFFFFFFFFFFFFFFLL)))
    {
      v46.__vftable = 0;
      std::bad_cast::bad_cast(&v46);
      v46.__vftable = (std::bad_cast_vtbl *)&unk_1EDD12A18;
      sub_18E0BA8B8();
    }
    uint64_t v34 = *((void *)this + 2);
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    uint64_t v37 = &unk_1EDD1A160;
    uint64_t v38 = 0;
    sub_18E1CB248(&v38, *(void *)(v34 + 16), *(void *)(v34 + 24), 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(v34 + 24) - *(void *)(v34 + 16)) >> 3));
    __n128 v32 = *(__n128 *)(v34 + 40);
    long long v35 = *(_OWORD *)(v34 + 56);
    long long v36 = *(_OWORD *)(v34 + 72);
    LOBYTE(v44) = *(unsigned char *)(v34 + 88);
    long long v43 = v36;
    long long v42 = v35;
    __n128 v41 = v32;
  }
  else
  {
    LOWORD(v46.__vftable) = 3;
    unsigned __int8 v45 = 5;
    uint64_t v20 = cnframework::GenericEvent::GetEventType(this, v11, v12, v13, v14, v15, v16, v17);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v46, &v45, "Attempted to cast a GenericEvent of type %s to type %s.", v21, v22, v23, v24, v25, *(unsigned char *)(v20 + 8));
    __n128 v32 = 0uLL;
    __n128 v41 = 0uLL;
    long long v42 = 0uLL;
    long long v43 = 0uLL;
    uint64_t v37 = &unk_1EDD1A160;
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    uint64_t v44 = 1;
  }
  trackrun::TrackRunEngineActiveObject::HandleEvent(v9, (const trackrun::GEOMapRunningTrackDataEvent *)&v37, v26, v27, v28, v29, v30, v31, v32);
  uint64_t v37 = &unk_1EDD1A160;
  v46.__vftable = (std::bad_cast_vtbl *)&v38;
  sub_18E1BEB28((void ***)&v46);
}

void sub_18E1D7894(_Unwind_Exception *a1)
{
  std::exception::~exception((std::exception *)(v1 - 40));
  _Unwind_Resume(a1);
}

uint64_t sub_18E1D78DC(uint64_t a1, uint64_t a2)
{
  if (sub_18DEE4C68(a2, (uint64_t)&unk_1EDD0A160)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_18E1D791C()
{
  return &unk_1EDD0A160;
}

void sub_18E1D792C()
{
}

void *sub_18E1D7940()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EDD1DFA0;
  return result;
}

void sub_18E1D7978(uint64_t a1, void *a2)
{
  *a2 = &unk_1EDD1DFA0;
}

void sub_18E1D79A0(int a1, trackrun::TrackRunEngineActiveObject **a2, cnframework::GenericEvent *this, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a2;
  uint64_t EventType = cnframework::GenericEvent::GetEventType(this, (uint64_t)a2, (uint64_t)this, a4, a5, a6, a7, a8);
  {
    uint64_t v18 = *((void *)this + 2);
    if (v18) {
      uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18);
    }
    else {
      uint64_t v19 = MEMORY[0x1E4FBA3D8];
    }
    uint8x8_t v26 = (const char *)(*(void *)(v19 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v26 != (const char *)((unint64_t)off_1EDD08050 & 0x7FFFFFFFFFFFFFFFLL)
      && strcmp(v26, (const char *)((unint64_t)off_1EDD08050 & 0x7FFFFFFFFFFFFFFFLL)))
    {
      v31.__vftable = 0;
      std::bad_cast::bad_cast(&v31);
      v31.__vftable = (std::bad_cast_vtbl *)&unk_1EDD12A18;
      sub_18E0BA8B8();
    }
    uint64_t v27 = *((void *)this + 2);
    v31.__vftable = (std::bad_cast_vtbl *)&unk_1EDD19F98;
    long long v28 = *(_OWORD *)(v27 + 16);
    long long v29 = *(_OWORD *)(v27 + 32);
    long long v30 = *(_OWORD *)(v27 + 48);
    LOBYTE(v35) = *(unsigned char *)(v27 + 64);
    long long v33 = v29;
    long long v34 = v30;
    long long v32 = v28;
  }
  else
  {
    LOWORD(v31.__vftable) = 3;
    unsigned __int8 v36 = 5;
    uint64_t v20 = cnframework::GenericEvent::GetEventType(this, v11, v12, v13, v14, v15, v16, v17);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v31, &v36, "Attempted to cast a GenericEvent of type %s to type %s.", v21, v22, v23, v24, v25, *(unsigned char *)(v20 + 8));
    long long v32 = 0uLL;
    v31.__vftable = (std::bad_cast_vtbl *)&unk_1EDD19F98;
    long long v33 = 0uLL;
    long long v34 = 0uLL;
    uint64_t v35 = 0;
  }
  trackrun::TrackRunEngineActiveObject::HandleEvent(v9, (const trackrun::MovingStateEvent *)&v31);
}

void sub_18E1D7B4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12)
{
}

uint64_t sub_18E1D7B60(uint64_t a1, uint64_t a2)
{
  if (sub_18DEE4C68(a2, (uint64_t)&unk_1EDD0A130)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_18E1D7BA0()
{
  return &unk_1EDD0A130;
}

void sub_18E1D7BB0()
{
}

void *sub_18E1D7BC4()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EDD1DEF0;
  return result;
}

void sub_18E1D7BFC(uint64_t a1, void *a2)
{
  *a2 = &unk_1EDD1DEF0;
}

void sub_18E1D7C24(int a1, trackrun::TrackRunEngineActiveObject **a2, int64x2_t **this, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a2;
  uint64_t EventType = cnframework::GenericEvent::GetEventType((cnframework::GenericEvent *)this, (uint64_t)a2, (uint64_t)this, a4, a5, a6, a7, a8);
  {
    uint64_t v19 = this[2];
    if (v19) {
      uint64_t v20 = (*(uint64_t (**)(int64x2_t *))(v19->i64[0] + 16))(v19);
    }
    else {
      uint64_t v20 = MEMORY[0x1E4FBA3D8];
    }
    std::bad_cast v31 = (const char *)(*(void *)(v20 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v31 != (const char *)((unint64_t)off_1EDD08020 & 0x7FFFFFFFFFFFFFFFLL)
      && strcmp(v31, (const char *)((unint64_t)off_1EDD08020 & 0x7FFFFFFFFFFFFFFFLL)))
    {
      v39.__vftable = 0;
      std::bad_cast::bad_cast(&v39);
      v39.__vftable = (std::bad_cast_vtbl *)&unk_1EDD12A18;
      sub_18E0BA8B8();
    }
    long long v32 = this[2];
    v39.__vftable = (std::bad_cast_vtbl *)&unk_1EDD19F38;
    int64x2_t v40 = v32[1];
    int64x2_t v33 = v32[4];
    int64x2_t v34 = v32[5];
    int64x2_t v35 = v32[3];
    int64x2_t v41 = v32[2];
    int64x2_t v44 = v34;
    int64x2_t v43 = v33;
    int64x2_t v42 = v35;
    int64x2_t v36 = v32[8];
    int64x2_t v37 = v32[9];
    int64x2_t v38 = v32[7];
    *(int64x2_t *)unsigned __int8 v45 = v32[6];
    *(int64x2_t *)&v45[48] = v37;
    *(int64x2_t *)&v45[32] = v36;
    *(int64x2_t *)&v45[16] = v38;
    int64x2_t v30 = v32[12];
    int64x2_t v27 = v32[13];
    int64x2_t v29 = v32[10];
    int64x2_t v28 = v32[11];
    *(int64x2_t *)&v45[64] = v29;
    *(int64x2_t *)&v46[16] = v27;
    *(int64x2_t *)std::bad_cast v46 = v30;
    *(int64x2_t *)&v45[80] = v28;
  }
  else
  {
    LOWORD(v39.__vftable) = 3;
    unsigned __int8 v47 = 5;
    uint64_t v21 = cnframework::GenericEvent::GetEventType((cnframework::GenericEvent *)this, v11, (uint64_t)v12, (uint64_t)v13, v14, v15, v16, v17);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v39, &v47, "Attempted to cast a GenericEvent of type %s to type %s.", v22, v23, v24, v25, v26, *(unsigned char *)(v21 + 8));
    int64x2_t v40 = 0uLL;
    int64x2_t v43 = 0uLL;
    v39.__vftable = (std::bad_cast_vtbl *)&unk_1EDD19F38;
    int64x2_t v41 = 0uLL;
    int64x2_t v44 = 0uLL;
    int64x2_t v42 = 0uLL;
    memset(v45, 0, 24);
    int64x2_t v30 = vdupq_n_s64(0x7FF8000000000000uLL);
    *(int64x2_t *)&v45[24] = v30;
    *(int64x2_t *)&v45[40] = v30;
    *(int64x2_t *)&v45[56] = v30;
    *(int64x2_t *)&v45[72] = v30;
    *(void *)&v45[88] = 0x7FF8000000000000;
    *(void *)std::bad_cast v46 = 0;
    *(int64x2_t *)&v46[8] = v30;
    *(void *)&v46[24] = 0x7FF8000000000000;
  }
  trackrun::TrackRunEngineActiveObject::HandleEvent(v9, (const trackrun::PositionEvent *)&v39, v12, v13, v14, v15, v16, v17, *(double *)v30.i64, *(double *)v27.i64, *(double *)v28.i64, *(double *)v29.i64, v18);
}

void sub_18E1D7E60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::exception a11)
{
}

uint64_t sub_18E1D7E74(uint64_t a1, uint64_t a2)
{
  if (sub_18DEE4C68(a2, (uint64_t)&unk_1EDD0A110)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_18E1D7EB4()
{
  return &unk_1EDD0A110;
}

void sub_18E1D7EC4()
{
}

void *sub_18E1D7ED8()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EDD1DFF8;
  return result;
}

void sub_18E1D7F10(uint64_t a1, void *a2)
{
  *a2 = &unk_1EDD1DFF8;
}

void sub_18E1D7F38(int a1, trackrun::TrackRunEngineActiveObject **a2, cnframework::GenericEvent *this, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a2;
  uint64_t EventType = cnframework::GenericEvent::GetEventType(this, (uint64_t)a2, (uint64_t)this, a4, a5, a6, a7, a8);
  {
    uint64_t v18 = *((void *)this + 2);
    if (v18) {
      uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18);
    }
    else {
      uint64_t v19 = MEMORY[0x1E4FBA3D8];
    }
    uint64_t v26 = (const char *)(*(void *)(v19 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v26 != (const char *)((unint64_t)off_1EDD08068 & 0x7FFFFFFFFFFFFFFFLL)
      && strcmp(v26, (const char *)((unint64_t)off_1EDD08068 & 0x7FFFFFFFFFFFFFFFLL)))
    {
      v31.__vftable = 0;
      std::bad_cast::bad_cast(&v31);
      v31.__vftable = (std::bad_cast_vtbl *)&unk_1EDD12A18;
      sub_18E0BA8B8();
    }
    uint64_t v27 = *((void *)this + 2);
    v31.__vftable = (std::bad_cast_vtbl *)&unk_1EDD19FC8;
    long long v28 = *(_OWORD *)(v27 + 16);
    long long v29 = *(_OWORD *)(v27 + 32);
    long long v30 = *(_OWORD *)(v27 + 48);
    LOBYTE(v35) = *(unsigned char *)(v27 + 64);
    long long v33 = v29;
    long long v34 = v30;
    long long v32 = v28;
  }
  else
  {
    LOWORD(v31.__vftable) = 3;
    unsigned __int8 v36 = 5;
    uint64_t v20 = cnframework::GenericEvent::GetEventType(this, v11, v12, v13, v14, v15, v16, v17);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v31, &v36, "Attempted to cast a GenericEvent of type %s to type %s.", v21, v22, v23, v24, v25, *(unsigned char *)(v20 + 8));
    long long v32 = 0uLL;
    v31.__vftable = (std::bad_cast_vtbl *)&unk_1EDD19FC8;
    long long v33 = 0uLL;
    long long v34 = 0uLL;
    uint64_t v35 = 0;
  }
  trackrun::TrackRunEngineActiveObject::HandleEvent(v9, (const trackrun::TrackRunHintEvent *)&v31);
}

void sub_18E1D80E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12)
{
}

uint64_t sub_18E1D80F8(uint64_t a1, uint64_t a2)
{
  if (sub_18DEE4C68(a2, (uint64_t)&unk_1EDD0A140)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_18E1D8138()
{
  return &unk_1EDD0A140;
}

void sub_18E1D8148()
{
}

void *sub_18E1D815C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EDD1DE98;
  return result;
}

void sub_18E1D8194(uint64_t a1, void *a2)
{
  *a2 = &unk_1EDD1DE98;
}

void sub_18E1D81BC(int a1, trackrun::TrackRunEngineActiveObject **a2, cnframework::GenericEvent *this, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a2;
  uint64_t EventType = cnframework::GenericEvent::GetEventType(this, (uint64_t)a2, (uint64_t)this, a4, a5, a6, a7, a8);
  {
    uint64_t v18 = *((void *)this + 2);
    if (v18) {
      uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18);
    }
    else {
      uint64_t v19 = MEMORY[0x1E4FBA3D8];
    }
    uint64_t v26 = (const char *)(*(void *)(v19 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v26 != (const char *)((unint64_t)off_1EDD08008 & 0x7FFFFFFFFFFFFFFFLL)
      && strcmp(v26, (const char *)((unint64_t)off_1EDD08008 & 0x7FFFFFFFFFFFFFFFLL)))
    {
      v56.__vftable = 0;
      std::bad_cast::bad_cast(&v56);
      v56.__vftable = (std::bad_cast_vtbl *)&unk_1EDD12A18;
      sub_18E0BA8B8();
    }
    uint64_t v27 = *((void *)this + 2);
    int64x2_t v40 = &unk_1EDD19F08;
    long long v28 = *(_OWORD *)(v27 + 32);
    long long v41 = *(_OWORD *)(v27 + 16);
    long long v42 = v28;
    long long v29 = *(_OWORD *)(v27 + 80);
    long long v30 = *(_OWORD *)(v27 + 96);
    long long v31 = *(_OWORD *)(v27 + 64);
    long long v43 = *(_OWORD *)(v27 + 48);
    long long v44 = v31;
    long long v45 = v29;
    long long v46 = v30;
    long long v32 = *(_OWORD *)(v27 + 144);
    long long v33 = *(_OWORD *)(v27 + 160);
    long long v34 = *(_OWORD *)(v27 + 128);
    long long v47 = *(_OWORD *)(v27 + 112);
    long long v48 = v34;
    long long v50 = v33;
    long long v49 = v32;
    long long v36 = *(_OWORD *)(v27 + 192);
    long long v35 = *(_OWORD *)(v27 + 208);
    long long v37 = *(_OWORD *)(v27 + 218);
    long long v51 = *(_OWORD *)(v27 + 176);
    *(_OWORD *)&v53[10] = v37;
    *(_OWORD *)uint64_t v53 = v35;
    long long v52 = v36;
    if (*(char *)(v27 + 263) < 0)
    {
      sub_18DEDE668(v54, *(void **)(v27 + 240), *(void *)(v27 + 248));
    }
    else
    {
      long long v38 = *(_OWORD *)(v27 + 240);
      *(void *)&v54[1] = *(void *)(v27 + 256);
      v54[0] = v38;
    }
    if (*(char *)(v27 + 287) < 0)
    {
      sub_18DEDE668((unsigned char *)&v54[1] + 8, *(void **)(v27 + 264), *(void *)(v27 + 272));
    }
    else
    {
      long long v39 = *(_OWORD *)(v27 + 264);
      *((void *)&v54[2] + 1) = *(void *)(v27 + 280);
      *(_OWORD *)((char *)&v54[1] + 8) = v39;
    }
  }
  else
  {
    LOWORD(v56.__vftable) = 3;
    unsigned __int8 v55 = 5;
    uint64_t v20 = cnframework::GenericEvent::GetEventType(this, v11, v12, v13, v14, v15, v16, v17);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v56, &v55, "Attempted to cast a GenericEvent of type %s to type %s.", v21, v22, v23, v24, v25, *(unsigned char *)(v20 + 8));
    long long v41 = 0uLL;
    long long v44 = 0uLL;
    long long v47 = 0uLL;
    long long v50 = 0uLL;
    long long v51 = 0u;
    *(_OWORD *)&v53[16] = 0u;
    memset(v54, 0, sizeof(v54));
    long long v42 = 0uLL;
    int64x2_t v40 = &unk_1EDD19F08;
    long long v45 = 0uLL;
    long long v48 = 0uLL;
    *(void *)&long long v51 = 0;
    BYTE8(v51) = 0;
    long long v52 = 0uLL;
    long long v43 = 0uLL;
    long long v46 = 0uLL;
    long long v49 = 0uLL;
    *(int64x2_t *)uint64_t v53 = vdupq_n_s64(0x7FF8000000000000uLL);
    *(void *)&v53[16] = 0xBFF0000000000000;
    sub_18DEDE7B0(v54, "");
    sub_18DEDE7B0((void *)&v54[1] + 1, "");
  }
  trackrun::TrackRunEngineActiveObject::HandleEvent(v9, (const trackrun::VisitEvent *)&v40);
  trackrun::VisitEvent::~VisitEvent(&v40);
}

void sub_18E1D848C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a46 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E1D84CC(uint64_t a1, uint64_t a2)
{
  if (sub_18DEE4C68(a2, (uint64_t)&unk_1EDD0A100)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_18E1D850C()
{
  return &unk_1EDD0A100;
}

void sub_18E1D851C()
{
}

void *sub_18E1D8530()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EDD1DF48;
  return result;
}

void sub_18E1D8568(uint64_t a1, void *a2)
{
  *a2 = &unk_1EDD1DF48;
}

void sub_18E1D8590(int a1, trackrun::TrackRunEngineActiveObject **a2, cnframework::GenericEvent *this, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a2;
  uint64_t EventType = cnframework::GenericEvent::GetEventType(this, (uint64_t)a2, (uint64_t)this, a4, a5, a6, a7, a8);
  {
    uint64_t v18 = *((void *)this + 2);
    if (v18) {
      uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18);
    }
    else {
      uint64_t v19 = MEMORY[0x1E4FBA3D8];
    }
    uint64_t v26 = (const char *)(*(void *)(v19 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v26 != (const char *)((unint64_t)off_1EDD08038 & 0x7FFFFFFFFFFFFFFFLL)
      && strcmp(v26, (const char *)((unint64_t)off_1EDD08038 & 0x7FFFFFFFFFFFFFFFLL)))
    {
      v31.__vftable = 0;
      std::bad_cast::bad_cast(&v31);
      v31.__vftable = (std::bad_cast_vtbl *)&unk_1EDD12A18;
      sub_18E0BA8B8();
    }
    uint64_t v27 = *((void *)this + 2);
    v31.__vftable = (std::bad_cast_vtbl *)&unk_1EDD19F68;
    long long v28 = *(_OWORD *)(v27 + 16);
    long long v29 = *(_OWORD *)(v27 + 32);
    long long v30 = *(_OWORD *)(v27 + 48);
    LOWORD(v35) = *(_WORD *)(v27 + 64);
    long long v33 = v29;
    long long v34 = v30;
    long long v32 = v28;
  }
  else
  {
    LOWORD(v31.__vftable) = 3;
    unsigned __int8 v36 = 5;
    uint64_t v20 = cnframework::GenericEvent::GetEventType(this, v11, v12, v13, v14, v15, v16, v17);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v31, &v36, "Attempted to cast a GenericEvent of type %s to type %s.", v21, v22, v23, v24, v25, *(unsigned char *)(v20 + 8));
    long long v32 = 0uLL;
    uint64_t v35 = 0;
    v31.__vftable = (std::bad_cast_vtbl *)&unk_1EDD19F68;
    long long v33 = 0uLL;
    long long v34 = 0uLL;
  }
  trackrun::TrackRunEngineActiveObject::HandleEvent(v9, (const trackrun::WatchStateEvent *)&v31);
}

void sub_18E1D8738(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12)
{
}

uint64_t sub_18E1D874C(uint64_t a1, uint64_t a2)
{
  if (sub_18DEE4C68(a2, (uint64_t)&unk_1EDD0A120)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_18E1D878C()
{
  return &unk_1EDD0A120;
}

void sub_18E1D879C()
{
}

void *sub_18E1D87B0()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EDD1E050;
  return result;
}

void sub_18E1D87E8(uint64_t a1, void *a2)
{
  *a2 = &unk_1EDD1E050;
}

void sub_18E1D8810(int a1, trackrun::TrackRunEngineActiveObject **a2, cnframework::GenericEvent *this, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a2;
  uint64_t EventType = cnframework::GenericEvent::GetEventType(this, (uint64_t)a2, (uint64_t)this, a4, a5, a6, a7, a8);
  {
    uint64_t v18 = *((void *)this + 2);
    if (v18) {
      uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18);
    }
    else {
      uint64_t v19 = MEMORY[0x1E4FBA3D8];
    }
    uint64_t v26 = (const char *)(*(void *)(v19 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v26 != (const char *)((unint64_t)off_1EDD08098 & 0x7FFFFFFFFFFFFFFFLL)
      && strcmp(v26, (const char *)((unint64_t)off_1EDD08098 & 0x7FFFFFFFFFFFFFFFLL)))
    {
      v52.__vftable = 0;
      std::bad_cast::bad_cast(&v52);
      v52.__vftable = (std::bad_cast_vtbl *)&unk_1EDD12A18;
      sub_18E0BA8B8();
    }
    uint64_t v27 = *((void *)this + 2);
    long long v37 = &unk_1EDD1A090;
    long long v29 = *(_OWORD *)(v27 + 32);
    long long v28 = *(_OWORD *)(v27 + 48);
    long long v38 = *(_OWORD *)(v27 + 16);
    long long v39 = v29;
    long long v40 = v28;
    LOWORD(__p[0]) = *(_WORD *)(v27 + 64);
    if (*(char *)(v27 + 95) < 0)
    {
      sub_18DEDE668(&__p[1], *(void **)(v27 + 72), *(void *)(v27 + 80));
    }
    else
    {
      long long v30 = *(_OWORD *)(v27 + 72);
      __p[3] = *(void **)(v27 + 88);
      *(_OWORD *)&__p[1] = v30;
    }
    long long v42 = *(_OWORD *)(v27 + 96);
    long long v31 = *(_OWORD *)(v27 + 112);
    long long v32 = *(_OWORD *)(v27 + 128);
    long long v33 = *(_OWORD *)(v27 + 144);
    long long v46 = *(_OWORD *)(v27 + 160);
    long long v45 = v33;
    long long v43 = v31;
    long long v44 = v32;
    long long v34 = *(_OWORD *)(v27 + 176);
    long long v35 = *(_OWORD *)(v27 + 192);
    long long v36 = *(_OWORD *)(v27 + 208);
    long long v50 = *(_OWORD *)(v27 + 224);
    long long v49 = v36;
    long long v48 = v35;
    long long v47 = v34;
  }
  else
  {
    LOWORD(v52.__vftable) = 3;
    unsigned __int8 v51 = 5;
    uint64_t v20 = cnframework::GenericEvent::GetEventType(this, v11, v12, v13, v14, v15, v16, v17);
    cnprint::CNPrinter::Print((cnprint::CNPrinter *)&v52, &v51, "Attempted to cast a GenericEvent of type %s to type %s.", v21, v22, v23, v24, v25, *(unsigned char *)(v20 + 8));
    long long v38 = 0uLL;
    memset(__p, 0, sizeof(__p));
    long long v42 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v37 = &unk_1EDD1A090;
    long long v39 = 0uLL;
    long long v40 = 0uLL;
    LOWORD(__p[0]) = 0;
    sub_18DEDE7B0(&__p[1], "");
    LOBYTE(v42) = 0;
    *((void *)&v42 + 1) = 0;
    *(void *)&long long v43 = 0;
    BYTE8(v43) = 0;
    *((void *)&v45 + 1) = 0;
    *(void *)&long long v46 = 0;
    BYTE8(v46) = 0;
    *((void *)&v48 + 1) = 0;
    *(void *)&long long v49 = 0;
    BYTE8(v49) = 0;
    long long v50 = 0uLL;
    long long v44 = 0uLL;
    LOBYTE(v45) = 0;
    LOBYTE(v48) = 0;
    long long v47 = 0uLL;
  }
  trackrun::TrackRunEngineActiveObject::HandleEvent(v9, (const trackrun::WorkoutSessionEvent *)&v37);
  long long v37 = &unk_1EDD1A090;
  if (SHIBYTE(__p[3]) < 0) {
    operator delete(__p[1]);
  }
}

void sub_18E1D8AAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  std::exception::~exception((std::exception *)(v25 - 56));
  _Unwind_Resume(a1);
}

uint64_t sub_18E1D8AF4(uint64_t a1, uint64_t a2)
{
  if (sub_18DEE4C68(a2, (uint64_t)&unk_1EDD0A150)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_18E1D8B34()
{
  return &unk_1EDD0A150;
}

uint64_t sub_18E1D8B40(uint64_t a1)
{
  *(void *)(a1 + 8) = &unk_1EDD1A160;
  int8x8_t v3 = (void **)(a1 + 16);
  sub_18E1BEB28(&v3);
  return a1;
}

void sub_18E1D8B9C(uint64_t a1)
{
  *(void *)(a1 + 8) = &unk_1EDD1A160;
  uint64_t v1 = (void **)(a1 + 16);
  sub_18E1BEB28(&v1);

  JUMPOUT(0x192FA6240);
}

void *sub_18E1D8C18()
{
}

void sub_18E1D8C24()
{
}

void sub_18E1D8CEC(_Unwind_Exception *a1)
{
  MEMORY[0x192FA6240](v1, 0x10A1C40B05C3A1DLL);
  _Unwind_Resume(a1);
}

void sub_18E1D8D14()
{
}

void *sub_18E1D8D28()
{
}

void sub_18E1D8D34()
{
}

void sub_18E1D8DE4()
{
}

void *sub_18E1D8DF8()
{
}

void sub_18E1D8E04()
{
}

uint64_t sub_18E1D8E90(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1EDD13538;
  *(void *)(a1 + 8) = &unk_1EDD1A090;
  long long v4 = *(_OWORD *)(a2 + 8);
  long long v5 = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 48) = v5;
  *(_OWORD *)(a1 + 16) = v4;
  *(_WORD *)(a1 + 64) = *(_WORD *)(a2 + 56);
  uint64_t v6 = a1 + 72;
  if (*(char *)(a2 + 87) < 0)
  {
    sub_18DEDE668((unsigned char *)v6, *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 64);
    *(void *)(v6 + 16) = *(void *)(a2 + 80);
    *(_OWORD *)uint64_t v6 = v7;
  }
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 88);
  long long v8 = *(_OWORD *)(a2 + 104);
  long long v9 = *(_OWORD *)(a2 + 120);
  long long v10 = *(_OWORD *)(a2 + 152);
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 160) = v10;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 128) = v9;
  long long v11 = *(_OWORD *)(a2 + 168);
  long long v12 = *(_OWORD *)(a2 + 184);
  long long v13 = *(_OWORD *)(a2 + 216);
  *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 200);
  *(_OWORD *)(a1 + 224) = v13;
  *(_OWORD *)(a1 + 176) = v11;
  *(_OWORD *)(a1 + 192) = v12;
  return a1;
}

uint64_t sub_18E1D8F74(uint64_t a1)
{
  *(void *)(a1 + 8) = &unk_1EDD1A090;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  return a1;
}

void sub_18E1D8FC8(uint64_t a1)
{
  *(void *)(a1 + 8) = &unk_1EDD1A090;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }

  JUMPOUT(0x192FA6240);
}

void *sub_18E1D903C()
{
}

void sub_18E1D9048()
{
}

void sub_18E1D9090(_Unwind_Exception *a1)
{
  MEMORY[0x192FA6240](v1, 0x1093C40A5554E92);
  _Unwind_Resume(a1);
}

uint64_t sub_18E1D90B4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1EDD13448;
  *(void *)(a1 + 8) = &unk_1EDD19F08;
  long long v4 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 32) = v4;
  long long v5 = *(_OWORD *)(a2 + 40);
  long long v6 = *(_OWORD *)(a2 + 56);
  long long v7 = *(_OWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 96) = v7;
  *(_OWORD *)(a1 + 48) = v5;
  *(_OWORD *)(a1 + 64) = v6;
  long long v8 = *(_OWORD *)(a2 + 104);
  long long v9 = *(_OWORD *)(a2 + 120);
  long long v10 = *(_OWORD *)(a2 + 152);
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 160) = v10;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 128) = v9;
  long long v11 = *(_OWORD *)(a2 + 168);
  long long v12 = *(_OWORD *)(a2 + 184);
  long long v13 = *(_OWORD *)(a2 + 200);
  *(_OWORD *)(a1 + 218) = *(_OWORD *)(a2 + 210);
  *(_OWORD *)(a1 + 192) = v12;
  *(_OWORD *)(a1 + 208) = v13;
  *(_OWORD *)(a1 + 176) = v11;
  if (*(char *)(a2 + 255) < 0)
  {
    sub_18DEDE668((unsigned char *)(a1 + 240), *(void **)(a2 + 232), *(void *)(a2 + 240));
  }
  else
  {
    long long v14 = *(_OWORD *)(a2 + 232);
    *(void *)(a1 + 256) = *(void *)(a2 + 248);
    *(_OWORD *)(a1 + 240) = v14;
  }
  uint64_t v15 = (unsigned char *)(a1 + 264);
  if (*(char *)(a2 + 279) < 0)
  {
    sub_18DEDE668(v15, *(void **)(a2 + 256), *(void *)(a2 + 264));
  }
  else
  {
    long long v16 = *(_OWORD *)(a2 + 256);
    *(void *)(a1 + 280) = *(void *)(a2 + 272);
    *(_OWORD *)uint64_t v15 = v16;
  }
  return a1;
}

void sub_18E1D91D4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 263) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_18E1D91F0(uint64_t a1)
{
  return a1;
}

void sub_18E1D921C(uint64_t a1)
{
  trackrun::VisitEvent::~VisitEvent((void **)(a1 + 8));

  JUMPOUT(0x192FA6240);
}

void *sub_18E1D9268()
{
}

void sub_18E1D9274()
{
}

void sub_18E1D92BC(_Unwind_Exception *a1)
{
  MEMORY[0x192FA6240](v1, 0x1093C4054D318A0);
  _Unwind_Resume(a1);
}

void sub_18E1D92E4()
{
}

void *sub_18E1D92F8()
{
}

void sub_18E1D9304()
{
}

void sub_18E1D9394()
{
}

void *sub_18E1D93A8()
{
}

void sub_18E1D93B4()
{
}

uint64_t trackrun::RunningTrackData::RunningTrackLane::PopulateLaneLength(uint64_t this, double a2, double a3, double a4)
{
  long long v4 = *(double **)this;
  long long v5 = *(double **)(this + 8);
  if (*(double **)this != v5)
  {
    char v6 = 1;
    double v7 = 0.0;
    double v8 = 0.0;
    do
    {
      double v9 = *v4;
      if ((v6 & 1) == 0) {
        double v7 = v7 + sqrt((v8 - v9) * (v8 - v9) + 0.0 + (a4 - v4[1]) * (a4 - v4[1]));
      }
      a4 = v4[1];
      char v6 = 0;
      v4 += 2;
      double v8 = v9;
    }
    while (v4 != v5);
    if ((*(void *)&v7 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && v7 > 0.0)
    {
      *(double *)(this + 32) = v7;
      *(unsigned char *)(this + 40) = 1;
    }
  }
  return this;
}

void *trackrun::RunningTrackData::RunningTrack::PopulateLaneCountFromLaneGeometry(void *this)
{
  uint64_t v1 = this[6] - this[5];
  if (v1) {
    this[12] = 0x8E38E38E38E38E39 * (v1 >> 3);
  }
  return this;
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

uint64_t wireless_diagnostics::google::protobuf::MessageLite::ParseFromArray(wireless_diagnostics::google::protobuf::MessageLite *this, const void *a2)
{
  return MEMORY[0x1F4181C38](this, a2);
}

uint64_t wireless_diagnostics::google::protobuf::MessageLite::ParseFromString()
{
  return MEMORY[0x1F4181C40]();
}

void wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(wireless_diagnostics::google::protobuf::MessageLite *this)
{
}

uint64_t wireless_diagnostics::google::protobuf::GoogleOnceInitImpl()
{
  return MEMORY[0x1F4181C50]();
}

uint64_t wireless_diagnostics::google::protobuf::io::ArrayInputStream::ArrayInputStream(wireless_diagnostics::google::protobuf::io::ArrayInputStream *this, const void *a2)
{
  return MEMORY[0x1F4181C58](this, a2);
}

void wireless_diagnostics::google::protobuf::io::ArrayInputStream::~ArrayInputStream(wireless_diagnostics::google::protobuf::io::ArrayInputStream *this)
{
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(wireless_diagnostics::google::protobuf::io::CodedInputStream *this)
{
  return MEMORY[0x1F4181C68](this);
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, unsigned int *a2)
{
  return MEMORY[0x1F4181C70](this, a2);
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, unint64_t *a2)
{
  return MEMORY[0x1F4181C78](this, a2);
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, unsigned int *a2)
{
  return MEMORY[0x1F4181C80](this, a2);
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, unint64_t *a2)
{
  return MEMORY[0x1F4181C88](this, a2);
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip(wireless_diagnostics::google::protobuf::io::CodedInputStream *this)
{
  return MEMORY[0x1F4181C90](this);
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedInputStream::Refresh(wireless_diagnostics::google::protobuf::io::CodedInputStream *this)
{
  return MEMORY[0x1F4181C98](this);
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(wireless_diagnostics::google::protobuf::io::CodedInputStream *this)
{
  return MEMORY[0x1F4181CA0](this);
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(wireless_diagnostics::google::protobuf::io::CodedInputStream *this)
{
  return MEMORY[0x1F4181CA8](this);
}

void wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream(wireless_diagnostics::google::protobuf::io::CodedInputStream *this)
{
}

uint64_t wireless_diagnostics::google::protobuf::io::ArrayOutputStream::ArrayOutputStream(wireless_diagnostics::google::protobuf::io::ArrayOutputStream *this, void *a2)
{
  return MEMORY[0x1F4181CB8](this, a2);
}

void wireless_diagnostics::google::protobuf::io::ArrayOutputStream::~ArrayOutputStream(wireless_diagnostics::google::protobuf::io::ArrayOutputStream *this)
{
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(wireless_diagnostics::google::protobuf::io::CodedOutputStream *this)
{
  return MEMORY[0x1F4181CC8](this);
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(wireless_diagnostics::google::protobuf::io::CodedOutputStream *this)
{
  return MEMORY[0x1F4181CD0](this);
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(wireless_diagnostics::google::protobuf::io::CodedOutputStream *this)
{
  return MEMORY[0x1F4181CD8](this);
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(wireless_diagnostics::google::protobuf::io::CodedOutputStream *this)
{
  return MEMORY[0x1F4181CE0](this);
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(wireless_diagnostics::google::protobuf::io::CodedOutputStream *this)
{
  return MEMORY[0x1F4181CE8](this);
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedOutputStream::CodedOutputStream()
{
  return MEMORY[0x1F4181D00]();
}

void wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream(wireless_diagnostics::google::protobuf::io::CodedOutputStream *this)
{
}

uint64_t wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage()
{
  return MEMORY[0x1F4181D10]();
}

void wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage(wireless_diagnostics::google::protobuf::internal::LogMessage *this)
{
}

uint64_t wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<()
{
  return MEMORY[0x1F4181D20]();
}

uint64_t wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=()
{
  return MEMORY[0x1F4181D30]();
}

uint64_t wireless_diagnostics::google::protobuf::internal::ExtensionSet::ParseField(wireless_diagnostics::google::protobuf::internal::ExtensionSet *this, uint64_t a2, wireless_diagnostics::google::protobuf::io::CodedInputStream *a3, const wireless_diagnostics::google::protobuf::MessageLite *a4)
{
  return MEMORY[0x1F4181D38](this, a2, a3, a4);
}

uint64_t wireless_diagnostics::google::protobuf::internal::ExtensionSet::Swap(wireless_diagnostics::google::protobuf::internal::ExtensionSet *this, wireless_diagnostics::google::protobuf::internal::ExtensionSet *a2)
{
  return MEMORY[0x1F4181D40](this, a2);
}

uint64_t wireless_diagnostics::google::protobuf::internal::ExtensionSet::Clear(wireless_diagnostics::google::protobuf::internal::ExtensionSet *this)
{
  return MEMORY[0x1F4181D48](this);
}

uint64_t wireless_diagnostics::google::protobuf::internal::ExtensionSet::MergeFrom(wireless_diagnostics::google::protobuf::internal::ExtensionSet *this, const wireless_diagnostics::google::protobuf::internal::ExtensionSet *a2)
{
  return MEMORY[0x1F4181D50](this, a2);
}

uint64_t wireless_diagnostics::google::protobuf::internal::ExtensionSet::ExtensionSet(wireless_diagnostics::google::protobuf::internal::ExtensionSet *this)
{
  return MEMORY[0x1F4181D58](this);
}

void wireless_diagnostics::google::protobuf::internal::ExtensionSet::~ExtensionSet(wireless_diagnostics::google::protobuf::internal::ExtensionSet *this)
{
}

uint64_t wireless_diagnostics::google::protobuf::internal::VerifyVersion(wireless_diagnostics::google::protobuf::internal *this, uint64_t a2, uint64_t a3, const char *a4)
{
  return MEMORY[0x1F4181D68](this, a2, a3, a4);
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString()
{
  return MEMORY[0x1F4181D70]();
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes()
{
  return MEMORY[0x1F4181D78]();
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat(wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, uint64_t a2, float a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  return MEMORY[0x1F4181D80](this, a2, a4, a3);
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32(wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  return MEMORY[0x1F4181D88](this, a2, a3, a4);
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt64(wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  return MEMORY[0x1F4181D90](this, a2, a3, a4);
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble(wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, uint64_t a2, double a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  return MEMORY[0x1F4181D98](this, a2, a4, a3);
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteSInt32(wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  return MEMORY[0x1F4181DA0](this, a2, a3, a4);
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString()
{
  return MEMORY[0x1F4181DA8]();
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32(wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  return MEMORY[0x1F4181DB0](this, a2, a3, a4);
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64(wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  return MEMORY[0x1F4181DB8](this, a2, a3, a4);
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFixed64(wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  return MEMORY[0x1F4181DC8](this, a2, a3, a4);
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage(wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, uint64_t a2, const wireless_diagnostics::google::protobuf::MessageLite *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  return MEMORY[0x1F4181DD0](this, a2, a3, a4);
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes()
{
  return MEMORY[0x1F4181DE0]();
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  return MEMORY[0x1F4181DE8](this, a2);
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool(wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  return MEMORY[0x1F4181DF0](this, a2, a3, a4);
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum(wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  return MEMORY[0x1F4181DF8](this, a2, a3, a4);
}

void wireless_diagnostics::google::protobuf::internal::FunctionClosure0::~FunctionClosure0(wireless_diagnostics::google::protobuf::internal::FunctionClosure0 *this)
{
}

uint64_t wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Swap()
{
  return MEMORY[0x1F4181E08]();
}

uint64_t wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *this)
{
  return MEMORY[0x1F4181E10](this);
}

uint64_t wireless_diagnostics::google::protobuf::MessageLite::SerializeToString()
{
  return MEMORY[0x1F4181E30]();
}

uint64_t wireless_diagnostics::google::protobuf::MessageLite::SerializeToCodedStream(wireless_diagnostics::google::protobuf::MessageLite *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2)
{
  return MEMORY[0x1F4181E38](this, a2);
}

uint64_t wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(wireless_diagnostics::google::protobuf::io::CodedInputStream *this)
{
  return MEMORY[0x1F4181E40](this);
}

uint64_t wireless_diagnostics::google::protobuf::internal::ExtensionSet::SerializeWithCachedSizes(wireless_diagnostics::google::protobuf::internal::ExtensionSet *this, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  return MEMORY[0x1F4181E50](this, a2, a3, a4);
}

uint64_t wireless_diagnostics::google::protobuf::internal::ExtensionSet::ByteSize(wireless_diagnostics::google::protobuf::internal::ExtensionSet *this)
{
  return MEMORY[0x1F4181E58](this);
}

std::string::size_type std::string::find(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return MEMORY[0x1F417E380](this, __c, __pos);
}

std::string *__cdecl std::locale::name(std::string *__return_ptr retstr, const std::locale *this)
{
  return (std::string *)MEMORY[0x1F417E400](retstr, this);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1F417E408](this, a2);
}

BOOL std::locale::operator==(const std::locale *this, const std::locale *a2)
{
  return MEMORY[0x1F417E410](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1F417E418](this);
}

uint64_t std::time_put<char,std::ostreambuf_iterator<char>>::put()
{
  return MEMORY[0x1F417E428]();
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E448](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const std::string *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E450](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const std::logic_error *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E458](this, a2);
}

void std::logic_error::~logic_error(std::logic_error *this)
{
}

void std::domain_error::~domain_error(std::domain_error *this)
{
}

{
  MEMORY[0x1F417E478](this);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::string *a2)
{
  return (std::runtime_error *)MEMORY[0x1F417E4D8](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::runtime_error *a2)
{
  return (std::runtime_error *)MEMORY[0x1F417E4E0](this, a2);
}

void std::runtime_error::~runtime_error(std::runtime_error *this)
{
}

void std::overflow_error::~overflow_error(std::overflow_error *this)
{
}

{
  MEMORY[0x1F417E508](this);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1F417E530](this);
}

std::regex_error *__cdecl std::regex_error::regex_error(std::regex_error *this, std::regex_constants::error_type __ecode)
{
  return (std::regex_error *)MEMORY[0x1F417E550](this, *(void *)&__ecode);
}

void std::timed_mutex::unlock(std::timed_mutex *this)
{
}

std::timed_mutex *__cdecl std::timed_mutex::timed_mutex(std::timed_mutex *this)
{
  return (std::timed_mutex *)MEMORY[0x1F417E570](this);
}

void std::timed_mutex::~timed_mutex(std::timed_mutex *this)
{
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1F417E588](__n);
}

void std::string::__grow_by_and_replace(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add, const std::string::value_type *__p_new_stuff)
{
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E5C0](this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E608](this, __pos, __s, __n);
}

std::string *__cdecl std::string::replace(std::string *this, std::string::size_type __pos, std::string::size_type __n1, const std::string::value_type *__s, std::string::size_type __n2)
{
  return (std::string *)MEMORY[0x1F417E628](this, __pos, __n1, __s, __n2);
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x1F417E660](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1F417E670](this, __str);
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x1F417E728]();
}

uint64_t std::filebuf::close()
{
  return MEMORY[0x1F417E730]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x1F417E740]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x1F417E748]();
}

uint64_t std::istream::get()
{
  return MEMORY[0x1F417E758]();
}

uint64_t std::istream::sentry::sentry()
{
  return MEMORY[0x1F417E7A0]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x1F417E7B8]();
}

{
  return MEMORY[0x1F417E7C0]();
}

uint64_t std::istream::operator>>()
{
  return MEMORY[0x1F417E7D0]();
}

{
  return MEMORY[0x1F417E7D8]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x1F417E830]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x1F417E838]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1F417E848]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1F417E850]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1F417E860]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1F417E868]();
}

{
  return MEMORY[0x1F417E880]();
}

{
  return MEMORY[0x1F417E888]();
}

{
  return MEMORY[0x1F417E890]();
}

{
  return MEMORY[0x1F417E898]();
}

{
  return MEMORY[0x1F417E8A0]();
}

{
  return MEMORY[0x1F417E8B0]();
}

{
  return MEMORY[0x1F417E8B8]();
}

{
  return MEMORY[0x1F417E8C8]();
}

{
  return MEMORY[0x1F417E8D0]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1F417E940]();
}

uint64_t std::ofstream::open()
{
  return MEMORY[0x1F417E948]();
}

{
  return MEMORY[0x1F417E950]();
}

std::regex_traits<char>::char_class_type std::__get_classname(const char *__s, BOOL __icase)
{
  return MEMORY[0x1F417E960](__s, __icase);
}

std::__thread_struct *__cdecl std::__thread_struct::__thread_struct(std::__thread_struct *this)
{
  return (std::__thread_struct *)MEMORY[0x1F417E968](this);
}

void std::__thread_struct::~__thread_struct(std::__thread_struct *this)
{
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1F417E978]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1F417E980]();
}

void std::recursive_mutex::lock(std::recursive_mutex *this)
{
}

void std::recursive_mutex::unlock(std::recursive_mutex *this)
{
}

std::recursive_mutex *__cdecl std::recursive_mutex::recursive_mutex(std::recursive_mutex *this)
{
  return (std::recursive_mutex *)MEMORY[0x1F417E9D0](this);
}

void std::recursive_mutex::~recursive_mutex(std::recursive_mutex *this)
{
}

void std::condition_variable::notify_all(std::condition_variable *this)
{
}

void std::condition_variable::__do_timed_wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk, std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> a3)
{
}

void std::condition_variable::wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk)
{
}

void std::condition_variable::~condition_variable(std::condition_variable *this)
{
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

std::__thread_specific_ptr<std::__thread_struct> *std::__thread_local_data(void)
{
  return (std::__thread_specific_ptr<std::__thread_struct> *)MEMORY[0x1F417EAA0]();
}

std::string *__cdecl std::__get_collation_name(std::string *__return_ptr retstr, const char *__s)
{
  return (std::string *)MEMORY[0x1F417EAA8](retstr, __s);
}

void std::__throw_system_error(int __ev, const char *__what_arg)
{
}

double std::stod(const std::string *__str, size_t *__idx)
{
  MEMORY[0x1F417EBD0](__str, __idx);
  return result;
}

int std::stoi(const std::string *__str, size_t *__idx, int __base)
{
  return MEMORY[0x1F417EBE0](__str, __idx, *(void *)&__base);
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

BOOL std::mutex::try_lock(std::mutex *this)
{
  return MEMORY[0x1F417EC08](this);
}

void std::mutex::~mutex(std::mutex *this)
{
}

unint64_t std::stoul(const std::string *__str, size_t *__idx, int __base)
{
  return MEMORY[0x1F417EC20](__str, __idx, *(void *)&__base);
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x1F417EC90]();
}

std::chrono::system_clock::time_point std::chrono::system_clock::now(void)
{
  return (std::chrono::system_clock::time_point)MEMORY[0x1F417ECA0]();
}

const std::locale *std::locale::classic(void)
{
  return (const std::locale *)MEMORY[0x1F417ECD0]();
}

std::locale *__cdecl std::locale::locale(std::locale *this, const std::locale *a2)
{
  return (std::locale *)MEMORY[0x1F417ECE0](this, a2);
}

std::locale *__cdecl std::locale::locale(std::locale *this)
{
  return (std::locale *)MEMORY[0x1F417ECE8](this);
}

void std::locale::~locale(std::locale *this)
{
}

const std::locale *__cdecl std::locale::operator=(std::locale *this, const std::locale *a2)
{
  return (const std::locale *)MEMORY[0x1F417ECF8](this, a2);
}

void std::thread::join(std::thread *this)
{
}

void std::thread::~thread(std::thread *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

std::locale std::ios_base::imbue(std::ios_base *this, const std::locale *__loc)
{
  return (std::locale)MEMORY[0x1F417EDB8](this, __loc);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1F417EE40]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, double __val)
{
  return (std::string *)MEMORY[0x1F417EE58](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x1F417EE70](retstr, *(void *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x1F417EE78](retstr, *(void *)&__val);
}

uint64_t std::operator+<char>()
{
  return MEMORY[0x1F417EEA0]();
}

std::bad_cast *__cdecl std::bad_cast::bad_cast(std::bad_cast *this)
{
  return (std::bad_cast *)MEMORY[0x1F417EEB0](this);
}

void std::bad_cast::~bad_cast(std::bad_cast *this)
{
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void *__cdecl operator new[](size_t __sz, const std::nothrow_t *a2)
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1F417EF30](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x1F40C9B60](lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1F417EF48](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void *__cxa_get_exception_ptr(void *a1)
{
  return (void *)MEMORY[0x1F417EF70](a1);
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1F417EF80](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d)
{
  return (void *)MEMORY[0x1F417EFA8](lpsrc, lpstype, lpdtype, s2d);
}

double __exp10(double a1)
{
  MEMORY[0x1F40C9B90](a1);
  return result;
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1F40C9C18](*(void *)&a1, a2);
}

__double2 __sincos_stret(double a1)
{
  MEMORY[0x1F40C9C80](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1F40C9CF8](*(void *)&a1);
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

long double acos(long double __x)
{
  MEMORY[0x1F40CA330](__x);
  return result;
}

long double asin(long double __x)
{
  MEMORY[0x1F40CA3D0](__x);
  return result;
}

long double atan(long double __x)
{
  MEMORY[0x1F40CA450](__x);
  return result;
}

long double atan2(long double __y, long double __x)
{
  MEMORY[0x1F40CA460](__y, __x);
  return result;
}

double atof(const char *a1)
{
  MEMORY[0x1F40CA498](a1);
  return result;
}

int atoi(const char *a1)
{
  return MEMORY[0x1F40CA4A8](a1);
}

uint64_t atoll(const char *a1)
{
  return MEMORY[0x1F40CA4C8](a1);
}

void bzero(void *a1, size_t a2)
{
}

void cblas_dgemm(const CBLAS_ORDER __Order, const CBLAS_TRANSPOSE __TransA, const CBLAS_TRANSPOSE __TransB, const int __M, const int __N, const int __K, const double __alpha, const double *__A, const int __lda, const double *__B, const int __ldb, const double __beta, double *__C, const int __ldc)
{
}

int close(int a1)
{
  return MEMORY[0x1F40CB3F8](*(void *)&a1);
}

long double cos(long double __x)
{
  MEMORY[0x1F40CB8A8](__x);
  return result;
}

long double cosh(long double __x)
{
  MEMORY[0x1F40CB8B8](__x);
  return result;
}

int dgecon_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
{
  return MEMORY[0x1F40D16C0](__norm, __n, __a, __lda, __anorm, __rcond, __work, __iwork);
}

int dgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work,__CLPK_integer *__lwork,__CLPK_integer *__iwork,__CLPK_integer *__info)
{
  return MEMORY[0x1F40D16D8](__balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __wr);
}

int dgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
{
  return MEMORY[0x1F40D16F8](__m, __n, __a, __lda, __tau, __work, __lwork, __info);
}

int dgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
{
  return MEMORY[0x1F40D1730](__jobu, __jobvt, __m, __n, __a, __lda, __s, __u);
}

int dgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
{
  return MEMORY[0x1F40D1740](__m, __n, __a, __lda, __ipiv, __info);
}

int dgetri_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
{
  return MEMORY[0x1F40D1750](__n, __a, __lda, __ipiv, __work, __lwork, __info);
}

int dormqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
{
  return MEMORY[0x1F40D1778](__side, __trans, __m, __n, __k, __a, __lda, __tau);
}

int dpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
{
  return MEMORY[0x1F40D1788](__uplo, __n, __a, __lda, __info);
}

long double exp(long double __x)
{
  MEMORY[0x1F40CBFE0](__x);
  return result;
}

long double exp2(long double __x)
{
  MEMORY[0x1F40CBFE8](__x);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x1F40CC050](a1);
}

int feof(FILE *a1)
{
  return MEMORY[0x1F40CC098](a1);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1F40CC0C8](a1);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return (char *)MEMORY[0x1F40CC100](a1, *(void *)&a2, a3);
}

long double fmod(long double __x, long double __y)
{
  MEMORY[0x1F40CC1A0](__x, __y);
  return result;
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1F40CC1C0](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CC1D8](a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x1F40CC1F0](a1, a2);
}

void free(void *a1)
{
}

long double frexp(long double __x, int *__e)
{
  MEMORY[0x1F40CC248](__e, __x);
  return result;
}

int fscanf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CC280](a1, a2);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1F40CC2B8](*(void *)&a1, a2);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1F40CC3B0](a1);
}

pid_t getpid(void)
{
  return MEMORY[0x1F40CC4A0]();
}

passwd *__cdecl getpwuid(uid_t a1)
{
  return (passwd *)MEMORY[0x1F40CC4E8](*(void *)&a1);
}

uid_t getuid(void)
{
  return MEMORY[0x1F40CC570]();
}

long double hypot(long double __x, long double __y)
{
  MEMORY[0x1F40CC630](__x, __y);
  return result;
}

float hypotf(float a1, float a2)
{
  MEMORY[0x1F40CC640](a1, a2);
  return result;
}

int ioctl(int a1, unint64_t a2, ...)
{
  return MEMORY[0x1F40CC690](*(void *)&a1, a2);
}

long double ldexp(long double __x, int __e)
{
  MEMORY[0x1F40CC800](*(void *)&__e, __x);
  return result;
}

tm *__cdecl localtime(const time_t *a1)
{
  return (tm *)MEMORY[0x1F40CC868](a1);
}

long double log(long double __x)
{
  MEMORY[0x1F40CC878](__x);
  return result;
}

long double log1pl(long double a1)
{
  MEMORY[0x1F40CC8A0](a1);
  return result;
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCD8](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1F40CCE40](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

long double modf(long double __x, long double *__y)
{
  MEMORY[0x1F40CCE48](__y, __x);
  return result;
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1F40CCE88](a1, a2);
}

long double nextafter(long double __x, long double __y)
{
  MEMORY[0x1F40CCFF8](__x, __y);
  return result;
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CD0E0](a1, *(void *)&a2);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

long double pow(long double __x, long double __y)
{
  MEMORY[0x1F40CD818](__x, __y);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1F40CD838](a1);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1F40CD9B8](a1, a2, a3, a4);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1F40CDB30]();
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return MEMORY[0x1F40CDB70](a1, a2);
}

int puts(const char *a1)
{
  return MEMORY[0x1F40CDBB8](a1);
}

int rand(void)
{
  return MEMORY[0x1F40CDC08]();
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1F40CDC98](a1, a2);
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return MEMORY[0x1F40CDD10](__p, __ec);
}

long double sin(long double __x)
{
  MEMORY[0x1F40CE058](__x);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1F40CE080](__str, __size, __format);
}

int sprintf(char *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CE0A0](a1, a2);
}

void srand(unsigned int a1)
{
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CE0D0](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CE110](a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1F40CE178](__s1);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return MEMORY[0x1F40CE198](a1, a2, a3, a4);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1F40CE258](__s1, __s2);
}

char *__cdecl strtok(char *__str, const char *__sep)
{
  return (char *)MEMORY[0x1F40CE290](__str, __sep);
}

long double tan(long double __x)
{
  MEMORY[0x1F40CE420](__x);
  return result;
}

time_t time(time_t *a1)
{
  return MEMORY[0x1F40CE588](a1);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1F40CE790](__str, __size, __format, a4);
}