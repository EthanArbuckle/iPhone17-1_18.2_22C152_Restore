void sub_1000B6BA4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1000B6FD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1000B7280(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B72EC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 48), OS_LOG_TYPE_ERROR))
    {
      [*(id *)(a1 + 32) uuid];
      objc_claimAutoreleasedReturnValue();
      [v6 localizedDescription];
      objc_claimAutoreleasedReturnValue();
      sub_100148C7C();
    }
  }
  else
  {
    v7 = *(NSObject **)(qword_1001D8080 + 48);
    if (v5)
    {
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        [*(id *)(a1 + 32) uuid];
        objc_claimAutoreleasedReturnValue();
        sub_100148C38();
      }
      v8 = [*(id *)(a1 + 40) queue];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000B7504;
      block[3] = &unk_1001BACD8;
      block[4] = *(void *)(a1 + 40);
      id v10 = v5;
      id v11 = *(id *)(a1 + 32);
      char v13 = *(unsigned char *)(a1 + 56);
      id v12 = *(id *)(a1 + 48);
      dispatch_async(v8, block);
    }
    else if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      [*(id *)(a1 + 32) uuid];
      objc_claimAutoreleasedReturnValue();
      sub_100148BF4();
    }
  }
}

void sub_1000B74CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B7504(uint64_t a1)
{
  v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  id v18 = 0;
  v4 = [v2 extractCellInfo:v3 error:&v18];
  id v5 = v18;
  if (v5) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = v4 == 0;
  }
  if (v6)
  {
    v7 = v5;
    v8 = *(NSObject **)(qword_1001D8080 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = [*(id *)(a1 + 48) uuid];
      id v10 = [v7 localizedDescription];
      *(_DWORD *)buf = 138412546;
      v20 = v9;
      __int16 v21 = 2112;
      v22 = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "OOSRecoveryMetric:#N Error while extracting data from cell for context %@: %@", buf, 0x16u);
    }
    v4 = 0;
  }
  id v11 = [OOSRecoveryMetricState alloc];
  int v12 = *(unsigned __int8 *)(a1 + 64);
  char v13 = [*(id *)(a1 + 56) registrationDisplayStatus];
  v14 = [(OOSRecoveryMetricState *)v11 initWithIsDataContext:v12 != 0 registrationState:v13 cellInfo:v4];

  if (v14)
  {
    v15 = [*(id *)(a1 + 32) contextUUIDToStateMap];
    v16 = [*(id *)(a1 + 48) uuid];
    [v15 setObject:v14 forKey:v16];

    if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 48), OS_LOG_TYPE_DEBUG))
    {
      v17 = [*(id *)(a1 + 48) uuid];
      sub_100148D14(v17, (uint64_t)v14, (uint64_t)buf);
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 48), OS_LOG_TYPE_ERROR))
  {
    [*(id *)(a1 + 48) uuid];
    objc_claimAutoreleasedReturnValue();
    sub_100148CD0();
  }
}

void sub_1000B7728(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B7C7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B7EF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B7F2C(uint64_t a1, void *a2, void *a3)
{
  id v7 = a2;
  id v5 = a3;
  BOOL v6 = [*(id *)(a1 + 32) uuid];
  objc_msgSend(v5, "setIsDataContext:", objc_msgSend(v7, "isEqual:", v6));
}

void sub_1000B7FB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1000B8084(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B8094(id a1, NSUUID *a2, OOSRecoveryMetricState *a3, BOOL *a4)
{
}

void sub_1000B8954(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,_Unwind_Exception *exception_object,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54)
{
  _Unwind_Resume(a1);
}

id sub_1000B8D10(uint64_t a1)
{
  return *(id *)(a1 + 32);
}

void sub_1000B8DE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B9014(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1000B9108()
{
  return +[WISOOSRecoveryMetric getSharedInstance];
}

void sub_1000B9130(void *a1@<X0>, const char *a2@<X3>, uint8_t *a3@<X4>, NSObject *a4@<X8>)
{
  _os_log_debug_impl(a1, a4, OS_LOG_TYPE_DEBUG, a2, a3, 0x16u);
}

void sub_1000B9160(const __CFString *a1@<X0>, CFPropertyListRef *a2@<X8>)
{
}

void sub_1000B9170(const __CFString *a1@<X0>, const __CFString *a2@<X1>, CFPropertyListRef *a3@<X8>)
{
  ctu::cf::assign();
  *(_OWORD *)v42 = 0u;
  uint64_t v43 = 0;
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *(_OWORD *)__p = 0u;
  uint64_t v41 = 0;
  BOOL v6 = *(NSObject **)(qword_1001D8080 + 80);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = v42;
    if (v43 < 0) {
      id v7 = (void **)v42[0];
    }
    v8 = __p;
    if (v41 < 0) {
      v8 = (void **)__p[0];
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "prefs:#I Getting preference from domain:%s key:%s", buf, 0x16u);
  }
  CFPropertyListRef propertyList = 0;
  sub_100018888(&v38, "/Library/Managed Preferences/mobile/com.apple.wirelessinsightsd.plist");
  if (a1 == @"com.apple.wirelessinsightsd.private") {
    std::string::assign(&v38, "/Library/Managed Preferences/mobile/com.apple.wirelessinsightsd.private.plist");
  }
  v9 = *(NSObject **)(qword_1001D8080 + 80);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    id v10 = v42;
    if (v43 < 0) {
      id v10 = (void **)v42[0];
    }
    id v11 = __p;
    if (v41 < 0) {
      id v11 = (void **)__p[0];
    }
    int v12 = &v38;
    if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      int v12 = (std::string *)v38.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v11;
    *(_WORD *)&buf[22] = 2080;
    v45 = v12;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "prefs:#I Getting preference from domain:%s key:%s, path is %s", buf, 0x20u);
  }
  sub_1000B9828((uint64_t)&v38, &theDict);
  if (theDict) {
    char v13 = sub_1000A4CAC;
  }
  else {
    char v13 = 0;
  }
  if (!v13) {
    goto LABEL_43;
  }
  *(void *)buf = CFDictionaryGetValue(theDict, a2);
  sub_1000B9958(&propertyList, (CFTypeRef *)buf);
  v14 = *(NSObject **)(qword_1001D8080 + 80);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    v15 = v42;
    if (v43 < 0) {
      v15 = (void **)v42[0];
    }
    v16 = __p;
    if (v41 < 0) {
      v16 = (void **)__p[0];
    }
    if (propertyList) {
      v17 = sub_100057DD8;
    }
    else {
      v17 = 0;
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&buf[12] = 2080;
    if (v17) {
      id v18 = " NOT NULL";
    }
    else {
      id v18 = " NULL";
    }
    *(void *)&buf[14] = v16;
    *(_WORD *)&buf[22] = 2080;
    v45 = (std::string *)v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "prefs:#I Getting iOS profile preference from domain:%s key:%s, profile value is %s", buf, 0x20u);
  }
  if (propertyList ? sub_100057DD8 : 0)
  {
    *a3 = CFPropertyListCreateDeepCopy(0, propertyList, 0);
    v20 = *(NSObject **)(qword_1001D8080 + 80);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      __int16 v21 = v42;
      if (v43 < 0) {
        __int16 v21 = (void **)v42[0];
      }
      v22 = __p;
      if (v41 < 0) {
        v22 = (void **)__p[0];
      }
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = v21;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v22;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "prefs:#I Got iOS profile preference from domain:%s key:%s", buf, 0x16u);
    }
  }
  else
  {
LABEL_43:
    CFPreferencesAppSynchronize(a1);
    CFPropertyListRef v23 = CFPreferencesCopyAppValue(a2, a1);
    CFPropertyListRef v24 = propertyList;
    CFPropertyListRef propertyList = v23;
    *(void *)buf = v24;
    sub_10001570C((const void **)buf);
    v25 = *(NSObject **)(qword_1001D8080 + 80);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
    {
      v26 = v42;
      if (v43 < 0) {
        v26 = (void **)v42[0];
      }
      v27 = __p;
      if (v41 < 0) {
        v27 = (void **)__p[0];
      }
      if (propertyList) {
        v28 = sub_100057DD8;
      }
      else {
        v28 = 0;
      }
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = v26;
      *(_WORD *)&buf[12] = 2080;
      if (v28) {
        v29 = " NOT NULL";
      }
      else {
        v29 = " NULL";
      }
      *(void *)&buf[14] = v27;
      *(_WORD *)&buf[22] = 2080;
      v45 = (std::string *)v29;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_INFO, "prefs:#I Getting regular preference from domain:%s key:%s, profile value is %s", buf, 0x20u);
    }
    CFPropertyListRef v30 = propertyList;
    if (propertyList) {
      v31 = sub_100057DD8;
    }
    else {
      v31 = 0;
    }
    v32 = *(NSObject **)(qword_1001D8080 + 80);
    if (v31)
    {
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        v35 = v42;
        if (v43 < 0) {
          v35 = (void **)v42[0];
        }
        v36 = __p;
        if (v41 < 0) {
          v36 = (void **)__p[0];
        }
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = v35;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v36;
        _os_log_debug_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEBUG, "prefs:#D Got regular preference from domain:%s key:%s", buf, 0x16u);
        CFPropertyListRef v30 = propertyList;
      }
      *a3 = v30;
      CFPropertyListRef propertyList = 0;
    }
    else
    {
      if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
      {
        v33 = v42;
        if (v43 < 0) {
          v33 = (void **)v42[0];
        }
        v34 = __p;
        if (v41 < 0) {
          v34 = (void **)__p[0];
        }
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = v33;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v34;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "prefs:#I Unable to find preference from domain:%s key:%s", buf, 0x16u);
      }
      *a3 = 0;
    }
  }
  sub_1000A6140((const void **)&theDict);
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  sub_10001570C(&propertyList);
  if (SHIBYTE(v41) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v43) < 0) {
    operator delete(v42[0]);
  }
}

void sub_1000B9780(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, const void *a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10001570C(&a17);
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  _Unwind_Resume(a1);
}

void sub_1000B9818(const __CFString *a1@<X0>, CFPropertyListRef *a2@<X8>)
{
}

const void **sub_1000B9828@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  int v3 = *(char *)(a1 + 23);
  if (v3 >= 0) {
    uint64_t v4 = (const UInt8 *)a1;
  }
  else {
    uint64_t v4 = *(const UInt8 **)a1;
  }
  if (v3 >= 0) {
    CFIndex v5 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    CFIndex v5 = *(void *)(a1 + 8);
  }
  CFURLRef v6 = CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault, v4, v5, 0);
  CFURLRef v13 = v6;
  if (v6) {
    id v7 = sub_1000B99AC;
  }
  else {
    id v7 = 0;
  }
  if (v7)
  {
    CFDataRef data = 0;
    SInt32 errorCode = 0;
    resourceData[0] = 0;
    resourceData[1] = (CFDataRef)&data;
    int v8 = CFURLCreateDataAndPropertiesFromResource(kCFAllocatorDefault, v6, resourceData, 0, 0, &errorCode);
    sub_1000B99E8((const void **)resourceData);
    if (v8)
    {
      resourceData[0] = (CFDataRef)CFPropertyListCreateWithData(kCFAllocatorDefault, data, 2uLL, 0, 0);
      sub_1000A8338(a2, (CFTypeRef *)resourceData);
    }
    else
    {
      *a2 = 0;
    }
    sub_100058818((const void **)&data);
  }
  else
  {
    *a2 = 0;
  }
  return sub_1000B99B4((const void **)&v13);
}

void sub_1000B992C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  int v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  va_copy(va2, va1);
  id v7 = va_arg(va2, const void *);
  sub_1000B99E8((const void **)va);
  sub_100058818((const void **)va1);
  sub_1000B99B4((const void **)va2);
  _Unwind_Resume(a1);
}

const void **sub_1000B9958(const void **a1, CFTypeRef *a2)
{
  CFTypeRef v3 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  uint64_t v4 = *a1;
  *a1 = v3;
  uint64_t v6 = v4;
  sub_10001570C(&v6);
  return a1;
}

uint64_t sub_1000B99AC(uint64_t a1)
{
  return *(void *)a1;
}

const void **sub_1000B99B4(const void **a1)
{
  v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **sub_1000B99E8(const void **a1)
{
  v2 = (const void **)a1[1];
  if (*a1)
  {
    CFTypeRef v3 = *v2;
    const void *v2 = *a1;
    uint64_t v6 = v3;
  }
  else
  {
    uint64_t v4 = *v2;
    const void *v2 = 0;
    uint64_t v6 = v4;
  }
  sub_100058818(&v6);
  return a1;
}

uint64_t sub_1000B9A40(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 72);
  if ((v1 & 4) != 0) {
    return 7;
  }
  if ((v1 & 8) != 0) {
    return 4;
  }
  if (v1) {
    return 6;
  }
  if ((v1 & 2) != 0) {
    return 3;
  }
  if ((v1 & 0x40) != 0) {
    return 13;
  }
  if ((v1 & 0x20) != 0) {
    int v2 = 1;
  }
  else {
    int v2 = (v1 >> 3) & 2;
  }
  if ((v1 & 0x100) != 0) {
    unsigned int v3 = 14;
  }
  else {
    unsigned int v3 = v2;
  }
  if ((v1 & 0x80) != 0) {
    return 12;
  }
  else {
    return v3;
  }
}

void sub_1000B9AB0(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = a1;
  int v5 = *(_DWORD *)(a1 + 8);
  int v4 = *(_DWORD *)(a1 + 12);
  uint64_t v6 = *(void *)(a1 + 32);
  if (!v6)
  {
    a1 = awd::profile::Condition::default_instance((awd::profile::Condition *)a1);
    uint64_t v6 = *(void *)(a1 + 32);
  }
  uint64_t v7 = *(void *)(v2 + 40);
  if (!v7) {
    uint64_t v7 = *(void *)(awd::profile::Condition::default_instance((awd::profile::Condition *)a1) + 40);
  }
  int v8 = sub_1000B9A40(v6);
  int v9 = sub_1000B9A40(v7);
  if (v8 == v9)
  {
    switch(v8)
    {
      case 0:
        id v10 = *(NSObject **)(qword_1001D8080 + 88);
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_12;
        }
        int v13 = 67109888;
        int v14 = v5;
        __int16 v15 = 1024;
        int v16 = v4;
        __int16 v17 = 1024;
        int v18 = 0;
        __int16 v19 = 1024;
        int v20 = 0;
        id v11 = "rule:#E Range metric rule creation failed due to bad types (mid=0x%x, field=%d, lowerType=%u, upperType=%u)";
        break;
      case 3:
        operator new();
      case 4:
        operator new();
      case 6:
        operator new();
      case 7:
        operator new();
      default:
        id v10 = *(NSObject **)(qword_1001D8080 + 88);
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_12;
        }
        int v13 = 67109888;
        int v14 = v5;
        __int16 v15 = 1024;
        int v16 = v4;
        __int16 v17 = 1024;
        int v18 = v8;
        __int16 v19 = 1024;
        int v20 = v8;
        id v11 = "rule:#E Range metric rule creation failed due invalid type (mid=0x%x, field=%d, lowerType=%u, upperType=%u)";
        break;
    }
    goto LABEL_11;
  }
  int v12 = v9;
  id v10 = *(NSObject **)(qword_1001D8080 + 88);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 67109888;
    int v14 = v5;
    __int16 v15 = 1024;
    int v16 = v4;
    __int16 v17 = 1024;
    int v18 = v8;
    __int16 v19 = 1024;
    int v20 = v12;
    id v11 = "rule:#E Range metric rule creation failed due to type mismatch (mid=0x%x, field=%d, lowerType=%u, upperType=%u)";
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v13, 0x1Au);
  }
LABEL_12:
  *a2 = 0;
}

void sub_1000B9D9C()
{
}

void sub_1000B9DEC(uint64_t a1@<X0>, void *a2@<X8>)
{
  int v4 = *(_DWORD *)(a1 + 8);
  int v3 = *(_DWORD *)(a1 + 12);
  uint64_t v5 = *(void *)(a1 + 32);
  if (!v5) {
    uint64_t v5 = *(void *)(awd::profile::Condition::default_instance((awd::profile::Condition *)a1) + 32);
  }
  switch(sub_1000B9A40(v5))
  {
    case 3u:
      operator new();
    case 4u:
      operator new();
    case 6u:
      operator new();
    case 7u:
      operator new();
    default:
      uint64_t v6 = *(NSObject **)(qword_1001D8080 + 88);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7[0] = 67109632;
        v7[1] = v4;
        __int16 v8 = 1024;
        int v9 = v3;
        __int16 v10 = 1024;
        int v11 = sub_1000B9A40(v5);
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "rule:#E Min metric rule creation failed due invalid type (mid=0x%x, field=%d, lowerType=%u)", (uint8_t *)v7, 0x14u);
      }
      *a2 = 0;
      return;
  }
}

void sub_1000B9FD4()
{
}

void sub_1000BA018(uint64_t a1@<X0>, void *a2@<X8>)
{
  int v4 = *(_DWORD *)(a1 + 8);
  int v3 = *(_DWORD *)(a1 + 12);
  uint64_t v5 = *(void *)(a1 + 40);
  if (!v5) {
    uint64_t v5 = *(void *)(awd::profile::Condition::default_instance((awd::profile::Condition *)a1) + 40);
  }
  switch(sub_1000B9A40(v5))
  {
    case 3u:
      operator new();
    case 4u:
      operator new();
    case 6u:
      operator new();
    case 7u:
      operator new();
    default:
      uint64_t v6 = *(NSObject **)(qword_1001D8080 + 88);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7[0] = 67109632;
        v7[1] = v4;
        __int16 v8 = 1024;
        int v9 = v3;
        __int16 v10 = 1024;
        int v11 = sub_1000B9A40(v5);
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "rule:#E Max metric rule creation failed due invalid type (mid=0x%x, field=%d, upperType=%u)", (uint8_t *)v7, 0x14u);
      }
      *a2 = 0;
      return;
  }
}

void sub_1000BA200()
{
}

void sub_1000BA244(uint64_t a1@<X1>, uint64_t a2@<X2>, void *a3@<X8>)
{
  int v6 = sub_1000B9A40(a1);
  int v7 = sub_1000B9A40(a2);
  if (v6 == v7)
  {
    switch(v6)
    {
      case 0:
        __int16 v8 = *(NSObject **)(qword_1001D8080 + 88);
        if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_9;
        }
        int v15 = 67109376;
        int v16 = 0;
        __int16 v17 = 1024;
        int v18 = 0;
        int v9 = "rule:#E Random range metric rule creation failed due to bad types (lowerType=%u, upperType=%u)";
        __int16 v10 = v8;
        goto LABEL_8;
      case 3:
        unint64_t v13 = *(void *)(a1 + 8);
        unint64_t v14 = *(void *)(a2 + 8);
        break;
      case 4:
        unint64_t v13 = *(void *)(a1 + 24);
        unint64_t v14 = *(void *)(a2 + 24);
        break;
      case 6:
        unint64_t v13 = *(int *)(a1 + 16);
        unint64_t v14 = *(int *)(a2 + 16);
        break;
      case 7:
        unint64_t v13 = *(unsigned int *)(a1 + 20);
        unint64_t v14 = *(unsigned int *)(a2 + 20);
        break;
      default:
        int v12 = *(NSObject **)(qword_1001D8080 + 88);
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_9;
        }
        int v15 = 67109376;
        int v16 = v6;
        __int16 v17 = 1024;
        int v18 = v6;
        int v9 = "rule:#E Range metric rule creation failed due invalid type (lowerType=%u, upperType=%u)";
        goto LABEL_7;
    }
    sub_1000BA498(v13, v14, a3);
  }
  else
  {
    int v11 = v7;
    int v12 = *(NSObject **)(qword_1001D8080 + 88);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = 67109376;
      int v16 = v6;
      __int16 v17 = 1024;
      int v18 = v11;
      int v9 = "rule:#E Random range metric rule creation failed due to type mismatch (lowerType=%u, upperType=%u)";
LABEL_7:
      __int16 v10 = v12;
LABEL_8:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v15, 0xEu);
    }
LABEL_9:
    *a3 = 0;
  }
}

uint64_t sub_1000BA498@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (a1 <= 0x2710 && a2 < 0x2711) {
    operator new();
  }
  int v7 = *(NSObject **)(qword_1001D8080 + 88);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 134218240;
    unint64_t v10 = a1;
    __int16 v11 = 2048;
    unint64_t v12 = a2;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "rule:#E Random metric rule creation failed due to invalid random range (lowerValue=%llu, upperValue=%llu)", (uint8_t *)&v9, 0x16u);
  }
  uint64_t result = 0;
  *a3 = 0;
  return result;
}

uint64_t sub_1000BA5B8@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t result = sub_1000B9A40(a1);
  switch((int)result)
  {
    case 3:
      unint64_t v5 = *(void *)(a1 + 8);
      goto LABEL_7;
    case 4:
      unint64_t v5 = *(void *)(a1 + 24);
      goto LABEL_7;
    case 6:
      unint64_t v5 = *(int *)(a1 + 16);
      goto LABEL_7;
    case 7:
      unint64_t v5 = *(unsigned int *)(a1 + 20);
LABEL_7:
      uint64_t result = sub_1000BA498(v5, 0x2710uLL, a2);
      break;
    default:
      *a2 = 0;
      break;
  }
  return result;
}

uint64_t sub_1000BA668@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t result = sub_1000B9A40(a1);
  switch((int)result)
  {
    case 3:
      unint64_t v5 = *(void *)(a1 + 8);
      goto LABEL_7;
    case 4:
      unint64_t v5 = *(void *)(a1 + 24);
      goto LABEL_7;
    case 6:
      unint64_t v5 = *(int *)(a1 + 16);
      goto LABEL_7;
    case 7:
      unint64_t v5 = *(unsigned int *)(a1 + 20);
LABEL_7:
      uint64_t result = sub_1000BA498(0, v5, a2);
      break;
    default:
      *a2 = 0;
      break;
  }
  return result;
}

uint64_t sub_1000BA718(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1000BA76C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  operator delete();
}

BOOL sub_1000BA7E0(void *a1)
{
  uint64_t v2 = sub_100059984();
  uint64_t v3 = a1[3];
  if (v3) {
    LODWORD(v2) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 16))(v3, v2);
  }
  return a1[1] <= (unint64_t)v2 && a1[2] > (unint64_t)v2;
}

void *sub_1000BA860(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *a1 = off_1001BAE08;
  v9[0] = off_1001BAE78;
  v9[3] = v9;
  sub_1000599E4(a1, a2, (uint64_t)v9);
  sub_100059E54(v9);
  a1[6] = a3;
  a1[7] = a4;
  sub_100059BC4(a2, a1 + 8);
  *a1 = off_1001BAE08;
  return a1;
}

void sub_1000BA93C(_Unwind_Exception *a1)
{
  void *v1 = off_1001B7408;
  sub_100059E54(v1 + 2);
  _Unwind_Resume(a1);
}

void *sub_1000BA978(void *a1)
{
  uint64_t v2 = a1[8];
  a1[8] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);
  return a1;
}

void sub_1000BA9F0(void *a1)
{
  uint64_t v2 = a1[8];
  a1[8] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);

  operator delete();
}

void sub_1000BAA8C()
{
}

void *sub_1000BAAA0()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1001BAE78;
  return result;
}

void sub_1000BAAD8(uint64_t a1, void *a2)
{
  *a2 = off_1001BAE78;
}

BOOL sub_1000BAB00(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a2;
  int v6 = *(_DWORD *)(*a2 + 12);
  MetricFileMetadataHelper::MetricFileMetadataHelper();
  uint64_t v63 = v5;
  int v64 = v6;
  while (1)
  {
    int v8 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
    if (v8 < 1) {
      break;
    }
    int v9 = *(char **)(a4 + 8);
    if ((unint64_t)v9 >= *(void *)(a4 + 16) || *v9 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
      *(_DWORD *)(a4 + 32) = TagFallback;
      if (TagFallback) {
        goto LABEL_6;
      }
LABEL_12:
      sub_1000BB758(a4, 0);
    }
    else
    {
      unint64_t TagFallback = *v9;
      *(_DWORD *)(a4 + 32) = TagFallback;
      *(void *)(a4 + 8) = v9 + 1;
      if (!TagFallback) {
        goto LABEL_12;
      }
LABEL_6:
      unint64_t v11 = wis::reflect::decodeTag((wis::reflect *)TagFallback, v7);
      unint64_t v12 = HIDWORD(v11);
      uint64_t v71 = 0;
      uint64_t v72 = 0;
      uint64_t v73 = 0xFFFFFFFFLL;
      MetricFileMetadataHelper::getSubfieldType();
      long long v69 = v74;
      uint64_t v70 = v75;
      int BuiltinType = MetadataHelper::getBuiltinType();
      char v14 = v11;
      int DecodingType = wis::reflect::getDecodingType();
      switch(DecodingType)
      {
        case 0:
          switch(v14)
          {
            case 0:
              *(void *)v76 = 0;
              v36 = *(char **)(a4 + 8);
              if ((unint64_t)v36 < *(void *)(a4 + 16) && (*v36 & 0x80000000) == 0)
              {
                *(void *)(a4 + 8) = v36 + 1;
                continue;
              }
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v76);
LABEL_131:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_106;
              }
              continue;
            case 1:
              *(void *)v76 = 0;
              if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v76))goto LABEL_106; {
              continue;
              }
            case 2:
              LODWORD(__p) = 0;
              v56 = *(char **)(a4 + 8);
              if ((unint64_t)v56 < *(void *)(a4 + 16) && (*v56 & 0x80000000) == 0)
              {
                unsigned int v41 = *v56;
                LODWORD(__p) = v41;
                *(void *)(a4 + 8) = v56 + 1;
                goto LABEL_117;
              }
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_106; {
              unsigned int v41 = __p;
              }
              break;
            case 5:
              v76[0] = 0;
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v76);
              goto LABEL_131;
            default:
              goto LABEL_106;
          }
          goto LABEL_117;
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
          *(void *)v76 = 0;
          switch(v14)
          {
            case 0:
              int v16 = *(char **)(a4 + 8);
              if ((unint64_t)v16 < *(void *)(a4 + 16) && (*v16 & 0x80000000) == 0)
              {
                *(void *)v76 = *v16;
                *(void *)(a4 + 8) = v16 + 1;
LABEL_66:
                uint64_t v42 = *(void *)v76;
                switch(BuiltinType)
                {
                  case 1:
                  case 15:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
                    continue;
                  case 2:
                  case 16:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
                    continue;
                  case 3:
                  case 17:
                    if (v64 != v12) {
                      continue;
                    }
                    uint64_t v43 = v63;
                    uint64_t v44 = *(void *)(v63 + 64);
                    if (v44) {
                      goto LABEL_77;
                    }
                    goto LABEL_78;
                  case 4:
                  case 7:
                  case 9:
                  case 10:
                  case 12:
                  case 18:
                  case 21:
                  case 23:
                  case 24:
                  case 26:
                    continue;
                  case 5:
                  case 19:
                    uint64_t v42 = wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
                    if (v64 != v12) {
                      continue;
                    }
                    uint64_t v43 = v63;
                    uint64_t v44 = *(void *)(v63 + 64);
                    if (v44) {
                      goto LABEL_77;
                    }
                    goto LABEL_78;
                  case 6:
                  case 20:
                    if (v64 == v12)
                    {
                      uint64_t v45 = v63;
                      uint64_t v46 = *(void *)(v63 + 64);
                      if (v46) {
                        LODWORD(v42) = (*(uint64_t (**)(uint64_t, void))(*(void *)v46 + 32))(v46, *(void *)v76);
                      }
                      if (*(void *)(v63 + 48) <= (int)v42) {
                        goto LABEL_91;
                      }
                    }
                    continue;
                  case 8:
                  case 22:
                    uint64_t v42 = wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
                    if (v64 != v12) {
                      continue;
                    }
                    uint64_t v45 = v63;
                    uint64_t v47 = *(void *)(v63 + 64);
                    if (v47) {
                      LODWORD(v42) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v47 + 32))(v47, v42);
                    }
                    if (*(void *)(v63 + 48) > (int)v42) {
                      continue;
                    }
LABEL_91:
                    if (*(void *)(v45 + 56) > (int)v42) {
                      goto LABEL_133;
                    }
                    continue;
                  case 11:
                  case 25:
                    if (v64 != v12) {
                      continue;
                    }
                    uint64_t v43 = v63;
                    uint64_t v44 = *(void *)(v63 + 64);
                    if (v44) {
LABEL_77:
                    }
                      uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v44 + 40))(v44, v42);
LABEL_78:
                    if (*(void *)(v43 + 48) <= v42 && v42 < *(void *)(v43 + 56)) {
                      goto LABEL_133;
                    }
                    continue;
                  default:
                    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                    std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
                }
              }
              char LittleEndian64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v76);
LABEL_65:
              if (LittleEndian64Fallback) {
                goto LABEL_66;
              }
LABEL_106:
              sub_1000BB758(a4, v12);
              break;
            case 1:
              char LittleEndian64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v76);
              goto LABEL_65;
            case 2:
              goto LABEL_106;
            case 5:
              LODWORD(__p) = 0;
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_106; {
              *(void *)v76 = __p;
              }
              goto LABEL_66;
            default:
              goto LABEL_66;
          }
          break;
        case 13:
          LODWORD(__p) = 0;
          v37 = *(char **)(a4 + 8);
          if ((unint64_t)v37 >= *(void *)(a4 + 16) || *v37 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_106; {
          }
            }
          else
          {
            LODWORD(__p) = *v37;
            *(void *)(a4 + 8) = v37 + 1;
          }
          *(void *)v76 = 0;
          uint64_t v77 = 0;
          uint64_t v78 = 0;
          char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
          if ((SHIBYTE(v78) & 0x80000000) == 0) {
            goto LABEL_120;
          }
          v50 = *(void **)v76;
          goto LABEL_119;
        case 14:
          LODWORD(__p) = 0;
          v40 = *(char **)(a4 + 8);
          if ((unint64_t)v40 >= *(void *)(a4 + 16) || *v40 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_106; {
            unsigned int v41 = __p;
            }
          }
          else
          {
            unsigned int v41 = *v40;
            LODWORD(__p) = v41;
            *(void *)(a4 + 8) = v40 + 1;
          }
LABEL_117:
          sub_10003908C(v76, v41);
          char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, *(void **)v76, (int)__p);
          v50 = *(void **)v76;
          if (*(void *)v76)
          {
            uint64_t v77 = *(void *)v76;
LABEL_119:
            operator delete(v50);
          }
LABEL_120:
          if ((String & 1) == 0) {
            goto LABEL_106;
          }
          continue;
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
          unsigned int v68 = 0;
          __int16 v17 = *(char **)(a4 + 8);
          if ((unint64_t)v17 >= *(void *)(a4 + 16) || *v17 < 0)
          {
            if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, &v68) & 1) == 0)goto LABEL_106; {
          }
            }
          else
          {
            unsigned int v68 = *v17;
            *(void *)(a4 + 8) = v17 + 1;
          }
          wis::reflect::getUnpackedType();
          int WireTypeForType = wis::reflect::getWireTypeForType();
          int v19 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v68);
          __p = 0;
          v66 = 0;
          v67 = 0;
          while (1)
          {
            int v20 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
            if (v20 < 1) {
              break;
            }
            __int16 v21 = v66;
            if (v66 >= v67)
            {
              CFPropertyListRef v23 = (char *)__p;
              uint64_t v24 = (v66 - (unsigned char *)__p) >> 3;
              unint64_t v25 = v24 + 1;
              if ((unint64_t)(v24 + 1) >> 61) {
                sub_10002B5E0();
              }
              uint64_t v26 = v67 - (unsigned char *)__p;
              if ((v67 - (unsigned char *)__p) >> 2 > v25) {
                unint64_t v25 = v26 >> 2;
              }
              if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v27 = v25;
              }
              if (v27)
              {
                v28 = (char *)sub_100038500((uint64_t)&v67, v27);
                CFPropertyListRef v23 = (char *)__p;
                __int16 v21 = v66;
              }
              else
              {
                v28 = 0;
              }
              v29 = &v28[8 * v24];
              *(void *)v29 = 0;
              v22 = v29 + 8;
              while (v21 != v23)
              {
                uint64_t v30 = *((void *)v21 - 1);
                v21 -= 8;
                *((void *)v29 - 1) = v30;
                v29 -= 8;
              }
              __p = v29;
              v66 = v22;
              v67 = &v28[8 * v27];
              if (v23) {
                operator delete(v23);
              }
            }
            else
            {
              *(void *)v66 = 0;
              v22 = v21 + 8;
            }
            v66 = v22;
            switch(WireTypeForType)
            {
              case 0:
                v31 = (unint64_t *)(v22 - 8);
                v32 = *(char **)(a4 + 8);
                if ((unint64_t)v32 >= *(void *)(a4 + 16) || *v32 < 0)
                {
                  char v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v31);
LABEL_43:
                  if ((v33 & 1) == 0) {
                    goto LABEL_103;
                  }
                }
                else
                {
                  unint64_t *v31 = *v32;
                  *(void *)(a4 + 8) = v32 + 1;
                }
                break;
              case 1:
                char v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v22 - 1);
                goto LABEL_43;
              case 2:
                goto LABEL_103;
              case 5:
                v76[0] = 0;
                char LittleEndian32Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v76);
                *((void *)v66 - 1) = v76[0];
                if ((LittleEndian32Fallback & 1) == 0) {
                  goto LABEL_103;
                }
                continue;
              default:
                continue;
            }
          }
          switch(DecodingType)
          {
            case 15:
              sub_1000385BC((uint64_t *)&__p, v76);
              goto LABEL_100;
            case 16:
              sub_1000386C8((uint64_t *)&__p, v76);
              goto LABEL_100;
            case 17:
            case 18:
            case 24:
            case 25:
              sub_100038538((uint64_t *)&__p, v76);
              goto LABEL_100;
            case 19:
              sub_1000387D4((uint64_t *)&__p, v76);
              goto LABEL_100;
            case 20:
            case 21:
            case 23:
              sub_100038644((uint64_t *)&__p, v76);
              goto LABEL_100;
            case 22:
              sub_10003885C((uint64_t *)&__p, v76);
LABEL_100:
              v48 = *(void **)v76;
              if (!*(void *)v76) {
                break;
              }
              uint64_t v77 = *(void *)v76;
LABEL_102:
              operator delete(v48);
              break;
            case 26:
              sub_100038750((uint64_t)&__p, v76);
              v48 = *(void **)v76;
              if (!*(void *)v76) {
                break;
              }
              goto LABEL_102;
            default:
              v59 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v59, "This should never happen, no matter what the input!");
          }
LABEL_103:
          if (__p)
          {
            v66 = (char *)__p;
            operator delete(__p);
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v19);
          if (v20 > 0) {
            goto LABEL_106;
          }
          continue;
        case 27:
          v76[0] = 0;
          std::string v38 = *(char **)(a4 + 8);
          if ((unint64_t)v38 >= *(void *)(a4 + 16) || *v38 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v76))goto LABEL_106; {
            int v39 = v76[0];
            }
          }
          else
          {
            int v39 = *v38;
            v76[0] = v39;
            *(void *)(a4 + 8) = v38 + 1;
          }
          int v51 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v39);
          ++*(_DWORD *)(a4 + 56);
          int v52 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
          wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v52);
          int v53 = *(_DWORD *)(a4 + 56);
          BOOL v54 = __OFSUB__(v53, 1);
          int v55 = v53 - 1;
          if (v55 < 0 == v54) {
            *(_DWORD *)(a4 + 56) = v55;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v51);
          continue;
        default:
          goto LABEL_106;
      }
    }
  }
LABEL_133:
  sub_100038238((uint64_t)&v62);
  if (v61) {
    sub_10000B678(v61);
  }
  return v8 > 0;
}

void sub_1000BB4FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  if (a11) {
    sub_10000B678(a11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000BB70C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1000BB74C()
{
}

uint64_t sub_1000BB758(uint64_t result, int a2)
{
  if (a2 || !*(unsigned char *)(result + 36))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
  }
  return result;
}

void sub_1000BB7B8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1000BB7CC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *a1 = off_1001BAEF8;
  v9[0] = off_1001BAF58;
  v9[3] = v9;
  sub_1000599E4(a1, a2, (uint64_t)v9);
  sub_100059E54(v9);
  a1[6] = a3;
  a1[7] = a4;
  sub_100059BC4(a2, a1 + 8);
  *a1 = off_1001BAEF8;
  return a1;
}

void sub_1000BB8A8(_Unwind_Exception *a1)
{
  void *v1 = off_1001B7408;
  sub_100059E54(v1 + 2);
  _Unwind_Resume(a1);
}

void *sub_1000BB8E4(void *a1)
{
  uint64_t v2 = a1[8];
  a1[8] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);
  return a1;
}

void sub_1000BB95C(void *a1)
{
  uint64_t v2 = a1[8];
  a1[8] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);

  operator delete();
}

void sub_1000BB9F8()
{
}

void *sub_1000BBA0C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1001BAF58;
  return result;
}

void sub_1000BBA44(uint64_t a1, void *a2)
{
  *a2 = off_1001BAF58;
}

BOOL sub_1000BBA6C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a2;
  int v6 = *(_DWORD *)(*a2 + 12);
  MetricFileMetadataHelper::MetricFileMetadataHelper();
  uint64_t v62 = v5;
  int v63 = v6;
  while (1)
  {
    int v8 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
    if (v8 < 1) {
      break;
    }
    int v9 = *(char **)(a4 + 8);
    if ((unint64_t)v9 >= *(void *)(a4 + 16) || *v9 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
      *(_DWORD *)(a4 + 32) = TagFallback;
      if (TagFallback) {
        goto LABEL_6;
      }
LABEL_12:
      sub_1000BC674(a4, 0);
    }
    else
    {
      unint64_t TagFallback = *v9;
      *(_DWORD *)(a4 + 32) = TagFallback;
      *(void *)(a4 + 8) = v9 + 1;
      if (!TagFallback) {
        goto LABEL_12;
      }
LABEL_6:
      unint64_t v11 = wis::reflect::decodeTag((wis::reflect *)TagFallback, v7);
      unint64_t v12 = HIDWORD(v11);
      uint64_t v70 = 0;
      uint64_t v71 = 0;
      uint64_t v72 = 0xFFFFFFFFLL;
      MetricFileMetadataHelper::getSubfieldType();
      long long v68 = v73;
      uint64_t v69 = v74;
      int BuiltinType = MetadataHelper::getBuiltinType();
      char v14 = v11;
      int DecodingType = wis::reflect::getDecodingType();
      switch(DecodingType)
      {
        case 0:
          switch(v14)
          {
            case 0:
              *(void *)uint64_t v75 = 0;
              v36 = *(char **)(a4 + 8);
              if ((unint64_t)v36 < *(void *)(a4 + 16) && (*v36 & 0x80000000) == 0)
              {
                *(void *)(a4 + 8) = v36 + 1;
                continue;
              }
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v75);
LABEL_128:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_103;
              }
              continue;
            case 1:
              *(void *)uint64_t v75 = 0;
              if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v75))goto LABEL_103; {
              continue;
              }
            case 2:
              LODWORD(__p) = 0;
              int v55 = *(char **)(a4 + 8);
              if ((unint64_t)v55 < *(void *)(a4 + 16) && (*v55 & 0x80000000) == 0)
              {
                unsigned int v41 = *v55;
                LODWORD(__p) = v41;
                *(void *)(a4 + 8) = v55 + 1;
                goto LABEL_114;
              }
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_103; {
              unsigned int v41 = __p;
              }
              break;
            case 5:
              v75[0] = 0;
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v75);
              goto LABEL_128;
            default:
              goto LABEL_103;
          }
          goto LABEL_114;
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
          *(void *)uint64_t v75 = 0;
          switch(v14)
          {
            case 0:
              int v16 = *(char **)(a4 + 8);
              if ((unint64_t)v16 < *(void *)(a4 + 16) && (*v16 & 0x80000000) == 0)
              {
                *(void *)uint64_t v75 = *v16;
                *(void *)(a4 + 8) = v16 + 1;
LABEL_66:
                unint64_t v42 = *(void *)v75;
                switch(BuiltinType)
                {
                  case 1:
                  case 15:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
                    continue;
                  case 2:
                  case 16:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
                    continue;
                  case 3:
                  case 6:
                  case 11:
                  case 12:
                  case 17:
                  case 20:
                  case 25:
                  case 26:
                    continue;
                  case 4:
                  case 18:
                    if (v63 != v12) {
                      continue;
                    }
                    uint64_t v43 = v62;
                    uint64_t v44 = *(void *)(v62 + 64);
                    if (v44) {
                      goto LABEL_79;
                    }
                    goto LABEL_80;
                  case 5:
                  case 19:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
                    continue;
                  case 7:
                  case 21:
                    if (v63 != v12) {
                      continue;
                    }
                    uint64_t v45 = v62;
                    uint64_t v46 = *(void *)(v62 + 64);
                    if (v46) {
                      goto LABEL_85;
                    }
                    goto LABEL_86;
                  case 8:
                  case 22:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
                    continue;
                  case 9:
                  case 23:
                    if (v63 != v12) {
                      continue;
                    }
                    uint64_t v45 = v62;
                    uint64_t v46 = *(void *)(v62 + 64);
                    if (v46) {
LABEL_85:
                    }
                      LODWORD(v42) = (*(uint64_t (**)(uint64_t, void))(*(void *)v46 + 16))(v46, *(void *)v75);
LABEL_86:
                    if (*(void *)(v45 + 48) <= (unint64_t)v42
                      && *(void *)(v45 + 56) > (unint64_t)v42)
                    {
                      goto LABEL_130;
                    }
                    continue;
                  case 10:
                  case 24:
                    if (v63 != v12) {
                      continue;
                    }
                    uint64_t v43 = v62;
                    uint64_t v44 = *(void *)(v62 + 64);
                    if (v44) {
LABEL_79:
                    }
                      unint64_t v42 = (*(uint64_t (**)(uint64_t, void))(*(void *)v44 + 24))(v44, *(void *)v75);
LABEL_80:
                    if (*(void *)(v43 + 48) <= v42 && v42 < *(void *)(v43 + 56)) {
                      goto LABEL_130;
                    }
                    continue;
                  default:
                    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                    std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
                }
              }
              char LittleEndian64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v75);
LABEL_65:
              if (LittleEndian64Fallback) {
                goto LABEL_66;
              }
LABEL_103:
              sub_1000BC674(a4, v12);
              break;
            case 1:
              char LittleEndian64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v75);
              goto LABEL_65;
            case 2:
              goto LABEL_103;
            case 5:
              LODWORD(__p) = 0;
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_103; {
              *(void *)uint64_t v75 = __p;
              }
              goto LABEL_66;
            default:
              goto LABEL_66;
          }
          break;
        case 13:
          LODWORD(__p) = 0;
          v37 = *(char **)(a4 + 8);
          if ((unint64_t)v37 >= *(void *)(a4 + 16) || *v37 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_103; {
          }
            }
          else
          {
            LODWORD(__p) = *v37;
            *(void *)(a4 + 8) = v37 + 1;
          }
          *(void *)uint64_t v75 = 0;
          unint64_t v76 = 0;
          uint64_t v77 = 0;
          char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
          if ((SHIBYTE(v77) & 0x80000000) == 0) {
            goto LABEL_117;
          }
          v49 = *(void **)v75;
          goto LABEL_116;
        case 14:
          LODWORD(__p) = 0;
          v40 = *(char **)(a4 + 8);
          if ((unint64_t)v40 >= *(void *)(a4 + 16) || *v40 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_103; {
            unsigned int v41 = __p;
            }
          }
          else
          {
            unsigned int v41 = *v40;
            LODWORD(__p) = v41;
            *(void *)(a4 + 8) = v40 + 1;
          }
LABEL_114:
          sub_10003908C(v75, v41);
          char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, *(void **)v75, (int)__p);
          v49 = *(void **)v75;
          if (*(void *)v75)
          {
            unint64_t v76 = *(void *)v75;
LABEL_116:
            operator delete(v49);
          }
LABEL_117:
          if ((String & 1) == 0) {
            goto LABEL_103;
          }
          continue;
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
          unsigned int v67 = 0;
          __int16 v17 = *(char **)(a4 + 8);
          if ((unint64_t)v17 >= *(void *)(a4 + 16) || *v17 < 0)
          {
            if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, &v67) & 1) == 0)goto LABEL_103; {
          }
            }
          else
          {
            unsigned int v67 = *v17;
            *(void *)(a4 + 8) = v17 + 1;
          }
          wis::reflect::getUnpackedType();
          int WireTypeForType = wis::reflect::getWireTypeForType();
          int v19 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v67);
          __p = 0;
          v65 = 0;
          v66 = 0;
          while (1)
          {
            int v20 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
            if (v20 < 1) {
              break;
            }
            __int16 v21 = v65;
            if (v65 >= v66)
            {
              CFPropertyListRef v23 = (char *)__p;
              uint64_t v24 = (v65 - (unsigned char *)__p) >> 3;
              unint64_t v25 = v24 + 1;
              if ((unint64_t)(v24 + 1) >> 61) {
                sub_10002B5E0();
              }
              uint64_t v26 = v66 - (unsigned char *)__p;
              if ((v66 - (unsigned char *)__p) >> 2 > v25) {
                unint64_t v25 = v26 >> 2;
              }
              if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v27 = v25;
              }
              if (v27)
              {
                v28 = (char *)sub_100038500((uint64_t)&v66, v27);
                CFPropertyListRef v23 = (char *)__p;
                __int16 v21 = v65;
              }
              else
              {
                v28 = 0;
              }
              v29 = &v28[8 * v24];
              *(void *)v29 = 0;
              v22 = v29 + 8;
              while (v21 != v23)
              {
                uint64_t v30 = *((void *)v21 - 1);
                v21 -= 8;
                *((void *)v29 - 1) = v30;
                v29 -= 8;
              }
              __p = v29;
              v65 = v22;
              v66 = &v28[8 * v27];
              if (v23) {
                operator delete(v23);
              }
            }
            else
            {
              *(void *)v65 = 0;
              v22 = v21 + 8;
            }
            v65 = v22;
            switch(WireTypeForType)
            {
              case 0:
                v31 = (unint64_t *)(v22 - 8);
                v32 = *(char **)(a4 + 8);
                if ((unint64_t)v32 >= *(void *)(a4 + 16) || *v32 < 0)
                {
                  char v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v31);
LABEL_43:
                  if ((v33 & 1) == 0) {
                    goto LABEL_100;
                  }
                }
                else
                {
                  unint64_t *v31 = *v32;
                  *(void *)(a4 + 8) = v32 + 1;
                }
                break;
              case 1:
                char v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v22 - 1);
                goto LABEL_43;
              case 2:
                goto LABEL_100;
              case 5:
                v75[0] = 0;
                char LittleEndian32Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v75);
                *((void *)v65 - 1) = v75[0];
                if ((LittleEndian32Fallback & 1) == 0) {
                  goto LABEL_100;
                }
                continue;
              default:
                continue;
            }
          }
          switch(DecodingType)
          {
            case 15:
              sub_1000385BC((uint64_t *)&__p, v75);
              goto LABEL_97;
            case 16:
              sub_1000386C8((uint64_t *)&__p, v75);
              goto LABEL_97;
            case 17:
            case 18:
            case 24:
            case 25:
              sub_100038538((uint64_t *)&__p, v75);
              goto LABEL_97;
            case 19:
              sub_1000387D4((uint64_t *)&__p, v75);
              goto LABEL_97;
            case 20:
            case 21:
            case 23:
              sub_100038644((uint64_t *)&__p, v75);
              goto LABEL_97;
            case 22:
              sub_10003885C((uint64_t *)&__p, v75);
LABEL_97:
              uint64_t v47 = *(void **)v75;
              if (!*(void *)v75) {
                break;
              }
              unint64_t v76 = *(void *)v75;
LABEL_99:
              operator delete(v47);
              break;
            case 26:
              sub_100038750((uint64_t)&__p, v75);
              uint64_t v47 = *(void **)v75;
              if (!*(void *)v75) {
                break;
              }
              goto LABEL_99;
            default:
              v58 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v58, "This should never happen, no matter what the input!");
          }
LABEL_100:
          if (__p)
          {
            v65 = (char *)__p;
            operator delete(__p);
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v19);
          if (v20 > 0) {
            goto LABEL_103;
          }
          continue;
        case 27:
          v75[0] = 0;
          std::string v38 = *(char **)(a4 + 8);
          if ((unint64_t)v38 >= *(void *)(a4 + 16) || *v38 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v75))goto LABEL_103; {
            int v39 = v75[0];
            }
          }
          else
          {
            int v39 = *v38;
            v75[0] = v39;
            *(void *)(a4 + 8) = v38 + 1;
          }
          int v50 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v39);
          ++*(_DWORD *)(a4 + 56);
          int v51 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
          wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v51);
          int v52 = *(_DWORD *)(a4 + 56);
          BOOL v53 = __OFSUB__(v52, 1);
          int v54 = v52 - 1;
          if (v54 < 0 == v53) {
            *(_DWORD *)(a4 + 56) = v54;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v50);
          continue;
        default:
          goto LABEL_103;
      }
    }
  }
LABEL_130:
  sub_100038238((uint64_t)&v61);
  if (v60) {
    sub_10000B678(v60);
  }
  return v8 > 0;
}

void sub_1000BC418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  if (a11) {
    sub_10000B678(a11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000BC628(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1000BC668()
{
}

uint64_t sub_1000BC674(uint64_t result, int a2)
{
  if (a2 || !*(unsigned char *)(result + 36))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
  }
  return result;
}

void sub_1000BC6D4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1000BC6E8(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = off_1001BAFD8;
  v7[0] = off_1001BB048;
  v7[3] = v7;
  sub_1000599E4(a1, a2, (uint64_t)v7);
  sub_100059E54(v7);
  a1[6] = a3;
  sub_100059BC4(a2, a1 + 7);
  *a1 = off_1001BAFD8;
  return a1;
}

void sub_1000BC7B8(_Unwind_Exception *a1)
{
  void *v1 = off_1001B7408;
  sub_100059E54(v1 + 2);
  _Unwind_Resume(a1);
}

void *sub_1000BC7F4(void *a1)
{
  uint64_t v2 = a1[7];
  a1[7] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);
  return a1;
}

void sub_1000BC86C(void *a1)
{
  uint64_t v2 = a1[7];
  a1[7] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);

  operator delete();
}

void sub_1000BC908()
{
}

void *sub_1000BC91C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1001BB048;
  return result;
}

void sub_1000BC954(uint64_t a1, void *a2)
{
  *a2 = off_1001BB048;
}

BOOL sub_1000BC97C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a2;
  int v6 = *(_DWORD *)(*a2 + 12);
  MetricFileMetadataHelper::MetricFileMetadataHelper();
  uint64_t v63 = v5;
  int v64 = v6;
  while (1)
  {
    int v8 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
    if (v8 < 1) {
      break;
    }
    int v9 = *(char **)(a4 + 8);
    if ((unint64_t)v9 >= *(void *)(a4 + 16) || *v9 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
      *(_DWORD *)(a4 + 32) = TagFallback;
      if (TagFallback) {
        goto LABEL_6;
      }
LABEL_12:
      sub_1000BD5B8(a4, 0);
    }
    else
    {
      unint64_t TagFallback = *v9;
      *(_DWORD *)(a4 + 32) = TagFallback;
      *(void *)(a4 + 8) = v9 + 1;
      if (!TagFallback) {
        goto LABEL_12;
      }
LABEL_6:
      unint64_t v11 = wis::reflect::decodeTag((wis::reflect *)TagFallback, v7);
      unint64_t v12 = HIDWORD(v11);
      uint64_t v71 = 0;
      uint64_t v72 = 0;
      uint64_t v73 = 0xFFFFFFFFLL;
      MetricFileMetadataHelper::getSubfieldType();
      long long v69 = v74;
      uint64_t v70 = v75;
      int BuiltinType = MetadataHelper::getBuiltinType();
      char v14 = v11;
      int DecodingType = wis::reflect::getDecodingType();
      switch(DecodingType)
      {
        case 0:
          switch(v14)
          {
            case 0:
              *(void *)unint64_t v76 = 0;
              v36 = *(char **)(a4 + 8);
              if ((unint64_t)v36 < *(void *)(a4 + 16) && (*v36 & 0x80000000) == 0)
              {
                *(void *)(a4 + 8) = v36 + 1;
                continue;
              }
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v76);
LABEL_129:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_104;
              }
              continue;
            case 1:
              *(void *)unint64_t v76 = 0;
              if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v76))goto LABEL_104; {
              continue;
              }
            case 2:
              LODWORD(__p) = 0;
              v56 = *(char **)(a4 + 8);
              if ((unint64_t)v56 < *(void *)(a4 + 16) && (*v56 & 0x80000000) == 0)
              {
                unsigned int v41 = *v56;
                LODWORD(__p) = v41;
                *(void *)(a4 + 8) = v56 + 1;
                goto LABEL_115;
              }
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_104; {
              unsigned int v41 = __p;
              }
              break;
            case 5:
              v76[0] = 0;
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v76);
              goto LABEL_129;
            default:
              goto LABEL_104;
          }
          goto LABEL_115;
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
          *(void *)unint64_t v76 = 0;
          switch(v14)
          {
            case 0:
              int v16 = *(char **)(a4 + 8);
              if ((unint64_t)v16 < *(void *)(a4 + 16) && (*v16 & 0x80000000) == 0)
              {
                *(void *)unint64_t v76 = *v16;
                *(void *)(a4 + 8) = v16 + 1;
LABEL_66:
                uint64_t v42 = *(void *)v76;
                switch(BuiltinType)
                {
                  case 1:
                  case 15:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
                    continue;
                  case 2:
                  case 16:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
                    continue;
                  case 3:
                  case 17:
                    if (v64 != v12) {
                      continue;
                    }
                    uint64_t v43 = v63;
                    uint64_t v44 = *(void *)(v63 + 56);
                    if (v44) {
                      goto LABEL_77;
                    }
                    goto LABEL_78;
                  case 4:
                  case 7:
                  case 9:
                  case 10:
                  case 12:
                  case 18:
                  case 21:
                  case 23:
                  case 24:
                  case 26:
                    continue;
                  case 5:
                  case 19:
                    uint64_t v42 = wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
                    if (v64 != v12) {
                      continue;
                    }
                    uint64_t v43 = v63;
                    uint64_t v44 = *(void *)(v63 + 56);
                    if (v44) {
                      goto LABEL_77;
                    }
                    goto LABEL_78;
                  case 6:
                  case 20:
                    if (v64 == v12)
                    {
                      uint64_t v45 = *(void *)(v63 + 56);
                      if (v45) {
                        LODWORD(v42) = (*(uint64_t (**)(uint64_t, void))(*(void *)v45 + 32))(v45, *(void *)v76);
                      }
                      if (*(void *)(v63 + 48) <= (int)v42) {
                        goto LABEL_131;
                      }
                    }
                    continue;
                  case 8:
                  case 22:
                    uint64_t v46 = wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
                    if (v64 == v12)
                    {
                      uint64_t v47 = *(void *)(v63 + 56);
                      if (v47) {
                        LODWORD(v46) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v47 + 32))(v47, v46);
                      }
                      if (*(void *)(v63 + 48) <= (int)v46) {
                        goto LABEL_131;
                      }
                    }
                    continue;
                  case 11:
                  case 25:
                    if (v64 != v12) {
                      continue;
                    }
                    uint64_t v43 = v63;
                    uint64_t v44 = *(void *)(v63 + 56);
                    if (v44) {
LABEL_77:
                    }
                      uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v44 + 40))(v44, v42);
LABEL_78:
                    if (*(void *)(v43 + 48) <= v42) {
                      goto LABEL_131;
                    }
                    continue;
                  default:
                    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                    std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
                }
              }
              char LittleEndian64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v76);
LABEL_65:
              if (LittleEndian64Fallback) {
                goto LABEL_66;
              }
LABEL_104:
              sub_1000BD5B8(a4, v12);
              break;
            case 1:
              char LittleEndian64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v76);
              goto LABEL_65;
            case 2:
              goto LABEL_104;
            case 5:
              LODWORD(__p) = 0;
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_104; {
              *(void *)unint64_t v76 = __p;
              }
              goto LABEL_66;
            default:
              goto LABEL_66;
          }
          break;
        case 13:
          LODWORD(__p) = 0;
          v37 = *(char **)(a4 + 8);
          if ((unint64_t)v37 >= *(void *)(a4 + 16) || *v37 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_104; {
          }
            }
          else
          {
            LODWORD(__p) = *v37;
            *(void *)(a4 + 8) = v37 + 1;
          }
          *(void *)unint64_t v76 = 0;
          uint64_t v77 = 0;
          uint64_t v78 = 0;
          char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
          if ((SHIBYTE(v78) & 0x80000000) == 0) {
            goto LABEL_118;
          }
          int v50 = *(void **)v76;
          goto LABEL_117;
        case 14:
          LODWORD(__p) = 0;
          v40 = *(char **)(a4 + 8);
          if ((unint64_t)v40 >= *(void *)(a4 + 16) || *v40 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_104; {
            unsigned int v41 = __p;
            }
          }
          else
          {
            unsigned int v41 = *v40;
            LODWORD(__p) = v41;
            *(void *)(a4 + 8) = v40 + 1;
          }
LABEL_115:
          sub_10003908C(v76, v41);
          char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, *(void **)v76, (int)__p);
          int v50 = *(void **)v76;
          if (*(void *)v76)
          {
            uint64_t v77 = *(void *)v76;
LABEL_117:
            operator delete(v50);
          }
LABEL_118:
          if ((String & 1) == 0) {
            goto LABEL_104;
          }
          continue;
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
          unsigned int v68 = 0;
          __int16 v17 = *(char **)(a4 + 8);
          if ((unint64_t)v17 >= *(void *)(a4 + 16) || *v17 < 0)
          {
            if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, &v68) & 1) == 0)goto LABEL_104; {
          }
            }
          else
          {
            unsigned int v68 = *v17;
            *(void *)(a4 + 8) = v17 + 1;
          }
          wis::reflect::getUnpackedType();
          int WireTypeForType = wis::reflect::getWireTypeForType();
          int v19 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v68);
          __p = 0;
          v66 = 0;
          unsigned int v67 = 0;
          while (1)
          {
            int v20 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
            if (v20 < 1) {
              break;
            }
            __int16 v21 = v66;
            if (v66 >= v67)
            {
              CFPropertyListRef v23 = (char *)__p;
              uint64_t v24 = (v66 - (unsigned char *)__p) >> 3;
              unint64_t v25 = v24 + 1;
              if ((unint64_t)(v24 + 1) >> 61) {
                sub_10002B5E0();
              }
              uint64_t v26 = v67 - (unsigned char *)__p;
              if ((v67 - (unsigned char *)__p) >> 2 > v25) {
                unint64_t v25 = v26 >> 2;
              }
              if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v27 = v25;
              }
              if (v27)
              {
                v28 = (char *)sub_100038500((uint64_t)&v67, v27);
                CFPropertyListRef v23 = (char *)__p;
                __int16 v21 = v66;
              }
              else
              {
                v28 = 0;
              }
              v29 = &v28[8 * v24];
              *(void *)v29 = 0;
              v22 = v29 + 8;
              while (v21 != v23)
              {
                uint64_t v30 = *((void *)v21 - 1);
                v21 -= 8;
                *((void *)v29 - 1) = v30;
                v29 -= 8;
              }
              __p = v29;
              v66 = v22;
              unsigned int v67 = &v28[8 * v27];
              if (v23) {
                operator delete(v23);
              }
            }
            else
            {
              *(void *)v66 = 0;
              v22 = v21 + 8;
            }
            v66 = v22;
            switch(WireTypeForType)
            {
              case 0:
                v31 = (unint64_t *)(v22 - 8);
                v32 = *(char **)(a4 + 8);
                if ((unint64_t)v32 >= *(void *)(a4 + 16) || *v32 < 0)
                {
                  char v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v31);
LABEL_43:
                  if ((v33 & 1) == 0) {
                    goto LABEL_101;
                  }
                }
                else
                {
                  unint64_t *v31 = *v32;
                  *(void *)(a4 + 8) = v32 + 1;
                }
                break;
              case 1:
                char v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v22 - 1);
                goto LABEL_43;
              case 2:
                goto LABEL_101;
              case 5:
                v76[0] = 0;
                char LittleEndian32Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v76);
                *((void *)v66 - 1) = v76[0];
                if ((LittleEndian32Fallback & 1) == 0) {
                  goto LABEL_101;
                }
                continue;
              default:
                continue;
            }
          }
          switch(DecodingType)
          {
            case 15:
              sub_1000385BC((uint64_t *)&__p, v76);
              goto LABEL_98;
            case 16:
              sub_1000386C8((uint64_t *)&__p, v76);
              goto LABEL_98;
            case 17:
            case 18:
            case 24:
            case 25:
              sub_100038538((uint64_t *)&__p, v76);
              goto LABEL_98;
            case 19:
              sub_1000387D4((uint64_t *)&__p, v76);
              goto LABEL_98;
            case 20:
            case 21:
            case 23:
              sub_100038644((uint64_t *)&__p, v76);
              goto LABEL_98;
            case 22:
              sub_10003885C((uint64_t *)&__p, v76);
LABEL_98:
              v48 = *(void **)v76;
              if (!*(void *)v76) {
                break;
              }
              uint64_t v77 = *(void *)v76;
LABEL_100:
              operator delete(v48);
              break;
            case 26:
              sub_100038750((uint64_t)&__p, v76);
              v48 = *(void **)v76;
              if (!*(void *)v76) {
                break;
              }
              goto LABEL_100;
            default:
              v59 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v59, "This should never happen, no matter what the input!");
          }
LABEL_101:
          if (__p)
          {
            v66 = (char *)__p;
            operator delete(__p);
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v19);
          if (v20 > 0) {
            goto LABEL_104;
          }
          continue;
        case 27:
          v76[0] = 0;
          std::string v38 = *(char **)(a4 + 8);
          if ((unint64_t)v38 >= *(void *)(a4 + 16) || *v38 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v76))goto LABEL_104; {
            int v39 = v76[0];
            }
          }
          else
          {
            int v39 = *v38;
            v76[0] = v39;
            *(void *)(a4 + 8) = v38 + 1;
          }
          int v51 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v39);
          ++*(_DWORD *)(a4 + 56);
          int v52 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
          wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v52);
          int v53 = *(_DWORD *)(a4 + 56);
          BOOL v54 = __OFSUB__(v53, 1);
          int v55 = v53 - 1;
          if (v55 < 0 == v54) {
            *(_DWORD *)(a4 + 56) = v55;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v51);
          continue;
        default:
          goto LABEL_104;
      }
    }
  }
LABEL_131:
  sub_100038238((uint64_t)&v62);
  if (v61) {
    sub_10000B678(v61);
  }
  return v8 > 0;
}

void sub_1000BD35C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  if (a11) {
    sub_10000B678(a11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000BD56C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1000BD5AC()
{
}

uint64_t sub_1000BD5B8(uint64_t result, int a2)
{
  if (a2 || !*(unsigned char *)(result + 36))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
  }
  return result;
}

void sub_1000BD618(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1000BD62C(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = off_1001BB0C8;
  v7[0] = off_1001BB138;
  v7[3] = v7;
  sub_1000599E4(a1, a2, (uint64_t)v7);
  sub_100059E54(v7);
  a1[6] = a3;
  sub_100059BC4(a2, a1 + 7);
  *a1 = off_1001BB0C8;
  return a1;
}

void sub_1000BD6FC(_Unwind_Exception *a1)
{
  void *v1 = off_1001B7408;
  sub_100059E54(v1 + 2);
  _Unwind_Resume(a1);
}

void *sub_1000BD738(void *a1)
{
  uint64_t v2 = a1[7];
  a1[7] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);
  return a1;
}

void sub_1000BD7B0(void *a1)
{
  uint64_t v2 = a1[7];
  a1[7] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);

  operator delete();
}

void sub_1000BD84C()
{
}

void *sub_1000BD860()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1001BB138;
  return result;
}

void sub_1000BD898(uint64_t a1, void *a2)
{
  *a2 = off_1001BB138;
}

BOOL sub_1000BD8C0(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a2;
  int v6 = *(_DWORD *)(*a2 + 12);
  MetricFileMetadataHelper::MetricFileMetadataHelper();
  uint64_t v62 = v5;
  int v63 = v6;
  while (1)
  {
    int v8 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
    if (v8 < 1) {
      break;
    }
    int v9 = *(char **)(a4 + 8);
    if ((unint64_t)v9 >= *(void *)(a4 + 16) || *v9 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
      *(_DWORD *)(a4 + 32) = TagFallback;
      if (TagFallback) {
        goto LABEL_6;
      }
LABEL_12:
      sub_1000BE4AC(a4, 0);
    }
    else
    {
      unint64_t TagFallback = *v9;
      *(_DWORD *)(a4 + 32) = TagFallback;
      *(void *)(a4 + 8) = v9 + 1;
      if (!TagFallback) {
        goto LABEL_12;
      }
LABEL_6:
      unint64_t v11 = wis::reflect::decodeTag((wis::reflect *)TagFallback, v7);
      unint64_t v12 = HIDWORD(v11);
      uint64_t v70 = 0;
      uint64_t v71 = 0;
      uint64_t v72 = 0xFFFFFFFFLL;
      MetricFileMetadataHelper::getSubfieldType();
      long long v68 = v73;
      uint64_t v69 = v74;
      int BuiltinType = MetadataHelper::getBuiltinType();
      char v14 = v11;
      int DecodingType = wis::reflect::getDecodingType();
      switch(DecodingType)
      {
        case 0:
          switch(v14)
          {
            case 0:
              *(void *)uint64_t v75 = 0;
              v36 = *(char **)(a4 + 8);
              if ((unint64_t)v36 < *(void *)(a4 + 16) && (*v36 & 0x80000000) == 0)
              {
                *(void *)(a4 + 8) = v36 + 1;
                continue;
              }
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v75);
LABEL_126:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_101;
              }
              continue;
            case 1:
              *(void *)uint64_t v75 = 0;
              if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v75))goto LABEL_101; {
              continue;
              }
            case 2:
              LODWORD(__p) = 0;
              int v55 = *(char **)(a4 + 8);
              if ((unint64_t)v55 < *(void *)(a4 + 16) && (*v55 & 0x80000000) == 0)
              {
                unsigned int v41 = *v55;
                LODWORD(__p) = v41;
                *(void *)(a4 + 8) = v55 + 1;
                goto LABEL_112;
              }
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_101; {
              unsigned int v41 = __p;
              }
              break;
            case 5:
              v75[0] = 0;
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v75);
              goto LABEL_126;
            default:
              goto LABEL_101;
          }
          goto LABEL_112;
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
          *(void *)uint64_t v75 = 0;
          switch(v14)
          {
            case 0:
              int v16 = *(char **)(a4 + 8);
              if ((unint64_t)v16 < *(void *)(a4 + 16) && (*v16 & 0x80000000) == 0)
              {
                *(void *)uint64_t v75 = *v16;
                *(void *)(a4 + 8) = v16 + 1;
LABEL_66:
                unint64_t v42 = *(void *)v75;
                switch(BuiltinType)
                {
                  case 1:
                  case 15:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
                    continue;
                  case 2:
                  case 16:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
                    continue;
                  case 3:
                  case 6:
                  case 11:
                  case 12:
                  case 17:
                  case 20:
                  case 25:
                  case 26:
                    continue;
                  case 4:
                  case 18:
                    if (v63 != v12) {
                      continue;
                    }
                    uint64_t v43 = v62;
                    uint64_t v44 = *(void *)(v62 + 56);
                    if (v44) {
                      goto LABEL_79;
                    }
                    goto LABEL_80;
                  case 5:
                  case 19:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
                    continue;
                  case 7:
                  case 21:
                    if (v63 != v12) {
                      continue;
                    }
                    uint64_t v45 = v62;
                    uint64_t v46 = *(void *)(v62 + 56);
                    if (v46) {
                      goto LABEL_84;
                    }
                    goto LABEL_85;
                  case 8:
                  case 22:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
                    continue;
                  case 9:
                  case 23:
                    if (v63 != v12) {
                      continue;
                    }
                    uint64_t v45 = v62;
                    uint64_t v46 = *(void *)(v62 + 56);
                    if (v46) {
LABEL_84:
                    }
                      LODWORD(v42) = (*(uint64_t (**)(uint64_t, void))(*(void *)v46 + 16))(v46, *(void *)v75);
LABEL_85:
                    if (*(void *)(v45 + 48) <= (unint64_t)v42) {
                      goto LABEL_128;
                    }
                    continue;
                  case 10:
                  case 24:
                    if (v63 != v12) {
                      continue;
                    }
                    uint64_t v43 = v62;
                    uint64_t v44 = *(void *)(v62 + 56);
                    if (v44) {
LABEL_79:
                    }
                      unint64_t v42 = (*(uint64_t (**)(uint64_t, void))(*(void *)v44 + 24))(v44, *(void *)v75);
LABEL_80:
                    if (*(void *)(v43 + 48) <= v42) {
                      goto LABEL_128;
                    }
                    continue;
                  default:
                    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                    std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
                }
              }
              char LittleEndian64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v75);
LABEL_65:
              if (LittleEndian64Fallback) {
                goto LABEL_66;
              }
LABEL_101:
              sub_1000BE4AC(a4, v12);
              break;
            case 1:
              char LittleEndian64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v75);
              goto LABEL_65;
            case 2:
              goto LABEL_101;
            case 5:
              LODWORD(__p) = 0;
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_101; {
              *(void *)uint64_t v75 = __p;
              }
              goto LABEL_66;
            default:
              goto LABEL_66;
          }
          break;
        case 13:
          LODWORD(__p) = 0;
          v37 = *(char **)(a4 + 8);
          if ((unint64_t)v37 >= *(void *)(a4 + 16) || *v37 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_101; {
          }
            }
          else
          {
            LODWORD(__p) = *v37;
            *(void *)(a4 + 8) = v37 + 1;
          }
          *(void *)uint64_t v75 = 0;
          unint64_t v76 = 0;
          uint64_t v77 = 0;
          char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
          if ((SHIBYTE(v77) & 0x80000000) == 0) {
            goto LABEL_115;
          }
          v49 = *(void **)v75;
          goto LABEL_114;
        case 14:
          LODWORD(__p) = 0;
          v40 = *(char **)(a4 + 8);
          if ((unint64_t)v40 >= *(void *)(a4 + 16) || *v40 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_101; {
            unsigned int v41 = __p;
            }
          }
          else
          {
            unsigned int v41 = *v40;
            LODWORD(__p) = v41;
            *(void *)(a4 + 8) = v40 + 1;
          }
LABEL_112:
          sub_10003908C(v75, v41);
          char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, *(void **)v75, (int)__p);
          v49 = *(void **)v75;
          if (*(void *)v75)
          {
            unint64_t v76 = *(void *)v75;
LABEL_114:
            operator delete(v49);
          }
LABEL_115:
          if ((String & 1) == 0) {
            goto LABEL_101;
          }
          continue;
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
          unsigned int v67 = 0;
          __int16 v17 = *(char **)(a4 + 8);
          if ((unint64_t)v17 >= *(void *)(a4 + 16) || *v17 < 0)
          {
            if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, &v67) & 1) == 0)goto LABEL_101; {
          }
            }
          else
          {
            unsigned int v67 = *v17;
            *(void *)(a4 + 8) = v17 + 1;
          }
          wis::reflect::getUnpackedType();
          int WireTypeForType = wis::reflect::getWireTypeForType();
          int v19 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v67);
          __p = 0;
          v65 = 0;
          v66 = 0;
          while (1)
          {
            int v20 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
            if (v20 < 1) {
              break;
            }
            __int16 v21 = v65;
            if (v65 >= v66)
            {
              CFPropertyListRef v23 = (char *)__p;
              uint64_t v24 = (v65 - (unsigned char *)__p) >> 3;
              unint64_t v25 = v24 + 1;
              if ((unint64_t)(v24 + 1) >> 61) {
                sub_10002B5E0();
              }
              uint64_t v26 = v66 - (unsigned char *)__p;
              if ((v66 - (unsigned char *)__p) >> 2 > v25) {
                unint64_t v25 = v26 >> 2;
              }
              if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v27 = v25;
              }
              if (v27)
              {
                v28 = (char *)sub_100038500((uint64_t)&v66, v27);
                CFPropertyListRef v23 = (char *)__p;
                __int16 v21 = v65;
              }
              else
              {
                v28 = 0;
              }
              v29 = &v28[8 * v24];
              *(void *)v29 = 0;
              v22 = v29 + 8;
              while (v21 != v23)
              {
                uint64_t v30 = *((void *)v21 - 1);
                v21 -= 8;
                *((void *)v29 - 1) = v30;
                v29 -= 8;
              }
              __p = v29;
              v65 = v22;
              v66 = &v28[8 * v27];
              if (v23) {
                operator delete(v23);
              }
            }
            else
            {
              *(void *)v65 = 0;
              v22 = v21 + 8;
            }
            v65 = v22;
            switch(WireTypeForType)
            {
              case 0:
                v31 = (unint64_t *)(v22 - 8);
                v32 = *(char **)(a4 + 8);
                if ((unint64_t)v32 >= *(void *)(a4 + 16) || *v32 < 0)
                {
                  char v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v31);
LABEL_43:
                  if ((v33 & 1) == 0) {
                    goto LABEL_98;
                  }
                }
                else
                {
                  unint64_t *v31 = *v32;
                  *(void *)(a4 + 8) = v32 + 1;
                }
                break;
              case 1:
                char v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v22 - 1);
                goto LABEL_43;
              case 2:
                goto LABEL_98;
              case 5:
                v75[0] = 0;
                char LittleEndian32Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v75);
                *((void *)v65 - 1) = v75[0];
                if ((LittleEndian32Fallback & 1) == 0) {
                  goto LABEL_98;
                }
                continue;
              default:
                continue;
            }
          }
          switch(DecodingType)
          {
            case 15:
              sub_1000385BC((uint64_t *)&__p, v75);
              goto LABEL_95;
            case 16:
              sub_1000386C8((uint64_t *)&__p, v75);
              goto LABEL_95;
            case 17:
            case 18:
            case 24:
            case 25:
              sub_100038538((uint64_t *)&__p, v75);
              goto LABEL_95;
            case 19:
              sub_1000387D4((uint64_t *)&__p, v75);
              goto LABEL_95;
            case 20:
            case 21:
            case 23:
              sub_100038644((uint64_t *)&__p, v75);
              goto LABEL_95;
            case 22:
              sub_10003885C((uint64_t *)&__p, v75);
LABEL_95:
              uint64_t v47 = *(void **)v75;
              if (!*(void *)v75) {
                break;
              }
              unint64_t v76 = *(void *)v75;
LABEL_97:
              operator delete(v47);
              break;
            case 26:
              sub_100038750((uint64_t)&__p, v75);
              uint64_t v47 = *(void **)v75;
              if (!*(void *)v75) {
                break;
              }
              goto LABEL_97;
            default:
              v58 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v58, "This should never happen, no matter what the input!");
          }
LABEL_98:
          if (__p)
          {
            v65 = (char *)__p;
            operator delete(__p);
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v19);
          if (v20 > 0) {
            goto LABEL_101;
          }
          continue;
        case 27:
          v75[0] = 0;
          std::string v38 = *(char **)(a4 + 8);
          if ((unint64_t)v38 >= *(void *)(a4 + 16) || *v38 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v75))goto LABEL_101; {
            int v39 = v75[0];
            }
          }
          else
          {
            int v39 = *v38;
            v75[0] = v39;
            *(void *)(a4 + 8) = v38 + 1;
          }
          int v50 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v39);
          ++*(_DWORD *)(a4 + 56);
          int v51 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
          wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v51);
          int v52 = *(_DWORD *)(a4 + 56);
          BOOL v53 = __OFSUB__(v52, 1);
          int v54 = v52 - 1;
          if (v54 < 0 == v53) {
            *(_DWORD *)(a4 + 56) = v54;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v50);
          continue;
        default:
          goto LABEL_101;
      }
    }
  }
LABEL_128:
  sub_100038238((uint64_t)&v61);
  if (v60) {
    sub_10000B678(v60);
  }
  return v8 > 0;
}

void sub_1000BE250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  if (a11) {
    sub_10000B678(a11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000BE460(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1000BE4A0()
{
}

uint64_t sub_1000BE4AC(uint64_t result, int a2)
{
  if (a2 || !*(unsigned char *)(result + 36))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
  }
  return result;
}

void sub_1000BE50C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1000BE520(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = off_1001BB1B8;
  v7[0] = off_1001BB228;
  v7[3] = v7;
  sub_1000599E4(a1, a2, (uint64_t)v7);
  sub_100059E54(v7);
  a1[6] = a3;
  sub_100059BC4(a2, a1 + 7);
  *a1 = off_1001BB1B8;
  return a1;
}

void sub_1000BE5F0(_Unwind_Exception *a1)
{
  void *v1 = off_1001B7408;
  sub_100059E54(v1 + 2);
  _Unwind_Resume(a1);
}

void *sub_1000BE62C(void *a1)
{
  uint64_t v2 = a1[7];
  a1[7] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);
  return a1;
}

void sub_1000BE6A4(void *a1)
{
  uint64_t v2 = a1[7];
  a1[7] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);

  operator delete();
}

void sub_1000BE740()
{
}

void *sub_1000BE754()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1001BB228;
  return result;
}

void sub_1000BE78C(uint64_t a1, void *a2)
{
  *a2 = off_1001BB228;
}

BOOL sub_1000BE7B4(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a2;
  int v6 = *(_DWORD *)(*a2 + 12);
  MetricFileMetadataHelper::MetricFileMetadataHelper();
  uint64_t v63 = v5;
  int v64 = v6;
  while (1)
  {
    int v8 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
    if (v8 < 1) {
      break;
    }
    int v9 = *(char **)(a4 + 8);
    if ((unint64_t)v9 >= *(void *)(a4 + 16) || *v9 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
      *(_DWORD *)(a4 + 32) = TagFallback;
      if (TagFallback) {
        goto LABEL_6;
      }
LABEL_12:
      sub_1000BF3F0(a4, 0);
    }
    else
    {
      unint64_t TagFallback = *v9;
      *(_DWORD *)(a4 + 32) = TagFallback;
      *(void *)(a4 + 8) = v9 + 1;
      if (!TagFallback) {
        goto LABEL_12;
      }
LABEL_6:
      unint64_t v11 = wis::reflect::decodeTag((wis::reflect *)TagFallback, v7);
      unint64_t v12 = HIDWORD(v11);
      uint64_t v71 = 0;
      uint64_t v72 = 0;
      uint64_t v73 = 0xFFFFFFFFLL;
      MetricFileMetadataHelper::getSubfieldType();
      long long v69 = v74;
      uint64_t v70 = v75;
      int BuiltinType = MetadataHelper::getBuiltinType();
      char v14 = v11;
      int DecodingType = wis::reflect::getDecodingType();
      switch(DecodingType)
      {
        case 0:
          switch(v14)
          {
            case 0:
              *(void *)unint64_t v76 = 0;
              v36 = *(char **)(a4 + 8);
              if ((unint64_t)v36 < *(void *)(a4 + 16) && (*v36 & 0x80000000) == 0)
              {
                *(void *)(a4 + 8) = v36 + 1;
                continue;
              }
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v76);
LABEL_129:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_104;
              }
              continue;
            case 1:
              *(void *)unint64_t v76 = 0;
              if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v76))goto LABEL_104; {
              continue;
              }
            case 2:
              LODWORD(__p) = 0;
              v56 = *(char **)(a4 + 8);
              if ((unint64_t)v56 < *(void *)(a4 + 16) && (*v56 & 0x80000000) == 0)
              {
                unsigned int v41 = *v56;
                LODWORD(__p) = v41;
                *(void *)(a4 + 8) = v56 + 1;
                goto LABEL_115;
              }
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_104; {
              unsigned int v41 = __p;
              }
              break;
            case 5:
              v76[0] = 0;
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v76);
              goto LABEL_129;
            default:
              goto LABEL_104;
          }
          goto LABEL_115;
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
          *(void *)unint64_t v76 = 0;
          switch(v14)
          {
            case 0:
              int v16 = *(char **)(a4 + 8);
              if ((unint64_t)v16 < *(void *)(a4 + 16) && (*v16 & 0x80000000) == 0)
              {
                *(void *)unint64_t v76 = *v16;
                *(void *)(a4 + 8) = v16 + 1;
LABEL_66:
                uint64_t v42 = *(void *)v76;
                switch(BuiltinType)
                {
                  case 1:
                  case 15:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
                    continue;
                  case 2:
                  case 16:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
                    continue;
                  case 3:
                  case 17:
                    if (v64 != v12) {
                      continue;
                    }
                    uint64_t v43 = v63;
                    uint64_t v44 = *(void *)(v63 + 56);
                    if (v44) {
                      goto LABEL_77;
                    }
                    goto LABEL_78;
                  case 4:
                  case 7:
                  case 9:
                  case 10:
                  case 12:
                  case 18:
                  case 21:
                  case 23:
                  case 24:
                  case 26:
                    continue;
                  case 5:
                  case 19:
                    uint64_t v42 = wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
                    if (v64 != v12) {
                      continue;
                    }
                    uint64_t v43 = v63;
                    uint64_t v44 = *(void *)(v63 + 56);
                    if (v44) {
                      goto LABEL_77;
                    }
                    goto LABEL_78;
                  case 6:
                  case 20:
                    if (v64 == v12)
                    {
                      uint64_t v45 = *(void *)(v63 + 56);
                      if (v45) {
                        LODWORD(v42) = (*(uint64_t (**)(uint64_t, void))(*(void *)v45 + 32))(v45, *(void *)v76);
                      }
                      if (*(void *)(v63 + 48) > (int)v42) {
                        goto LABEL_131;
                      }
                    }
                    continue;
                  case 8:
                  case 22:
                    uint64_t v46 = wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
                    if (v64 == v12)
                    {
                      uint64_t v47 = *(void *)(v63 + 56);
                      if (v47) {
                        LODWORD(v46) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v47 + 32))(v47, v46);
                      }
                      if (*(void *)(v63 + 48) > (int)v46) {
                        goto LABEL_131;
                      }
                    }
                    continue;
                  case 11:
                  case 25:
                    if (v64 != v12) {
                      continue;
                    }
                    uint64_t v43 = v63;
                    uint64_t v44 = *(void *)(v63 + 56);
                    if (v44) {
LABEL_77:
                    }
                      uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v44 + 40))(v44, v42);
LABEL_78:
                    if (v42 < *(void *)(v43 + 48)) {
                      goto LABEL_131;
                    }
                    continue;
                  default:
                    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                    std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
                }
              }
              char LittleEndian64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v76);
LABEL_65:
              if (LittleEndian64Fallback) {
                goto LABEL_66;
              }
LABEL_104:
              sub_1000BF3F0(a4, v12);
              break;
            case 1:
              char LittleEndian64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v76);
              goto LABEL_65;
            case 2:
              goto LABEL_104;
            case 5:
              LODWORD(__p) = 0;
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_104; {
              *(void *)unint64_t v76 = __p;
              }
              goto LABEL_66;
            default:
              goto LABEL_66;
          }
          break;
        case 13:
          LODWORD(__p) = 0;
          v37 = *(char **)(a4 + 8);
          if ((unint64_t)v37 >= *(void *)(a4 + 16) || *v37 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_104; {
          }
            }
          else
          {
            LODWORD(__p) = *v37;
            *(void *)(a4 + 8) = v37 + 1;
          }
          *(void *)unint64_t v76 = 0;
          uint64_t v77 = 0;
          uint64_t v78 = 0;
          char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
          if ((SHIBYTE(v78) & 0x80000000) == 0) {
            goto LABEL_118;
          }
          int v50 = *(void **)v76;
          goto LABEL_117;
        case 14:
          LODWORD(__p) = 0;
          v40 = *(char **)(a4 + 8);
          if ((unint64_t)v40 >= *(void *)(a4 + 16) || *v40 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_104; {
            unsigned int v41 = __p;
            }
          }
          else
          {
            unsigned int v41 = *v40;
            LODWORD(__p) = v41;
            *(void *)(a4 + 8) = v40 + 1;
          }
LABEL_115:
          sub_10003908C(v76, v41);
          char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, *(void **)v76, (int)__p);
          int v50 = *(void **)v76;
          if (*(void *)v76)
          {
            uint64_t v77 = *(void *)v76;
LABEL_117:
            operator delete(v50);
          }
LABEL_118:
          if ((String & 1) == 0) {
            goto LABEL_104;
          }
          continue;
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
          unsigned int v68 = 0;
          __int16 v17 = *(char **)(a4 + 8);
          if ((unint64_t)v17 >= *(void *)(a4 + 16) || *v17 < 0)
          {
            if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, &v68) & 1) == 0)goto LABEL_104; {
          }
            }
          else
          {
            unsigned int v68 = *v17;
            *(void *)(a4 + 8) = v17 + 1;
          }
          wis::reflect::getUnpackedType();
          int WireTypeForType = wis::reflect::getWireTypeForType();
          int v19 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v68);
          __p = 0;
          v66 = 0;
          unsigned int v67 = 0;
          while (1)
          {
            int v20 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
            if (v20 < 1) {
              break;
            }
            __int16 v21 = v66;
            if (v66 >= v67)
            {
              CFPropertyListRef v23 = (char *)__p;
              uint64_t v24 = (v66 - (unsigned char *)__p) >> 3;
              unint64_t v25 = v24 + 1;
              if ((unint64_t)(v24 + 1) >> 61) {
                sub_10002B5E0();
              }
              uint64_t v26 = v67 - (unsigned char *)__p;
              if ((v67 - (unsigned char *)__p) >> 2 > v25) {
                unint64_t v25 = v26 >> 2;
              }
              if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v27 = v25;
              }
              if (v27)
              {
                v28 = (char *)sub_100038500((uint64_t)&v67, v27);
                CFPropertyListRef v23 = (char *)__p;
                __int16 v21 = v66;
              }
              else
              {
                v28 = 0;
              }
              v29 = &v28[8 * v24];
              *(void *)v29 = 0;
              v22 = v29 + 8;
              while (v21 != v23)
              {
                uint64_t v30 = *((void *)v21 - 1);
                v21 -= 8;
                *((void *)v29 - 1) = v30;
                v29 -= 8;
              }
              __p = v29;
              v66 = v22;
              unsigned int v67 = &v28[8 * v27];
              if (v23) {
                operator delete(v23);
              }
            }
            else
            {
              *(void *)v66 = 0;
              v22 = v21 + 8;
            }
            v66 = v22;
            switch(WireTypeForType)
            {
              case 0:
                v31 = (unint64_t *)(v22 - 8);
                v32 = *(char **)(a4 + 8);
                if ((unint64_t)v32 >= *(void *)(a4 + 16) || *v32 < 0)
                {
                  char v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v31);
LABEL_43:
                  if ((v33 & 1) == 0) {
                    goto LABEL_101;
                  }
                }
                else
                {
                  unint64_t *v31 = *v32;
                  *(void *)(a4 + 8) = v32 + 1;
                }
                break;
              case 1:
                char v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v22 - 1);
                goto LABEL_43;
              case 2:
                goto LABEL_101;
              case 5:
                v76[0] = 0;
                char LittleEndian32Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v76);
                *((void *)v66 - 1) = v76[0];
                if ((LittleEndian32Fallback & 1) == 0) {
                  goto LABEL_101;
                }
                continue;
              default:
                continue;
            }
          }
          switch(DecodingType)
          {
            case 15:
              sub_1000385BC((uint64_t *)&__p, v76);
              goto LABEL_98;
            case 16:
              sub_1000386C8((uint64_t *)&__p, v76);
              goto LABEL_98;
            case 17:
            case 18:
            case 24:
            case 25:
              sub_100038538((uint64_t *)&__p, v76);
              goto LABEL_98;
            case 19:
              sub_1000387D4((uint64_t *)&__p, v76);
              goto LABEL_98;
            case 20:
            case 21:
            case 23:
              sub_100038644((uint64_t *)&__p, v76);
              goto LABEL_98;
            case 22:
              sub_10003885C((uint64_t *)&__p, v76);
LABEL_98:
              v48 = *(void **)v76;
              if (!*(void *)v76) {
                break;
              }
              uint64_t v77 = *(void *)v76;
LABEL_100:
              operator delete(v48);
              break;
            case 26:
              sub_100038750((uint64_t)&__p, v76);
              v48 = *(void **)v76;
              if (!*(void *)v76) {
                break;
              }
              goto LABEL_100;
            default:
              v59 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v59, "This should never happen, no matter what the input!");
          }
LABEL_101:
          if (__p)
          {
            v66 = (char *)__p;
            operator delete(__p);
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v19);
          if (v20 > 0) {
            goto LABEL_104;
          }
          continue;
        case 27:
          v76[0] = 0;
          std::string v38 = *(char **)(a4 + 8);
          if ((unint64_t)v38 >= *(void *)(a4 + 16) || *v38 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v76))goto LABEL_104; {
            int v39 = v76[0];
            }
          }
          else
          {
            int v39 = *v38;
            v76[0] = v39;
            *(void *)(a4 + 8) = v38 + 1;
          }
          int v51 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v39);
          ++*(_DWORD *)(a4 + 56);
          int v52 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
          wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v52);
          int v53 = *(_DWORD *)(a4 + 56);
          BOOL v54 = __OFSUB__(v53, 1);
          int v55 = v53 - 1;
          if (v55 < 0 == v54) {
            *(_DWORD *)(a4 + 56) = v55;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v51);
          continue;
        default:
          goto LABEL_104;
      }
    }
  }
LABEL_131:
  sub_100038238((uint64_t)&v62);
  if (v61) {
    sub_10000B678(v61);
  }
  return v8 > 0;
}

void sub_1000BF194(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  if (a11) {
    sub_10000B678(a11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000BF3A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1000BF3E4()
{
}

uint64_t sub_1000BF3F0(uint64_t result, int a2)
{
  if (a2 || !*(unsigned char *)(result + 36))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
  }
  return result;
}

void sub_1000BF450(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1000BF464(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = off_1001BB2A8;
  v7[0] = off_1001BB318;
  v7[3] = v7;
  sub_1000599E4(a1, a2, (uint64_t)v7);
  sub_100059E54(v7);
  a1[6] = a3;
  sub_100059BC4(a2, a1 + 7);
  *a1 = off_1001BB2A8;
  return a1;
}

void sub_1000BF534(_Unwind_Exception *a1)
{
  void *v1 = off_1001B7408;
  sub_100059E54(v1 + 2);
  _Unwind_Resume(a1);
}

void *sub_1000BF570(void *a1)
{
  uint64_t v2 = a1[7];
  a1[7] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);
  return a1;
}

void sub_1000BF5E8(void *a1)
{
  uint64_t v2 = a1[7];
  a1[7] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);

  operator delete();
}

void sub_1000BF684()
{
}

void *sub_1000BF698()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1001BB318;
  return result;
}

void sub_1000BF6D0(uint64_t a1, void *a2)
{
  *a2 = off_1001BB318;
}

BOOL sub_1000BF6F8(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a2;
  int v6 = *(_DWORD *)(*a2 + 12);
  MetricFileMetadataHelper::MetricFileMetadataHelper();
  uint64_t v62 = v5;
  int v63 = v6;
  while (1)
  {
    int v8 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
    if (v8 < 1) {
      break;
    }
    int v9 = *(char **)(a4 + 8);
    if ((unint64_t)v9 >= *(void *)(a4 + 16) || *v9 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
      *(_DWORD *)(a4 + 32) = TagFallback;
      if (TagFallback) {
        goto LABEL_6;
      }
LABEL_12:
      sub_1000C02E4(a4, 0);
    }
    else
    {
      unint64_t TagFallback = *v9;
      *(_DWORD *)(a4 + 32) = TagFallback;
      *(void *)(a4 + 8) = v9 + 1;
      if (!TagFallback) {
        goto LABEL_12;
      }
LABEL_6:
      unint64_t v11 = wis::reflect::decodeTag((wis::reflect *)TagFallback, v7);
      unint64_t v12 = HIDWORD(v11);
      uint64_t v70 = 0;
      uint64_t v71 = 0;
      uint64_t v72 = 0xFFFFFFFFLL;
      MetricFileMetadataHelper::getSubfieldType();
      long long v68 = v73;
      uint64_t v69 = v74;
      int BuiltinType = MetadataHelper::getBuiltinType();
      char v14 = v11;
      int DecodingType = wis::reflect::getDecodingType();
      switch(DecodingType)
      {
        case 0:
          switch(v14)
          {
            case 0:
              *(void *)uint64_t v75 = 0;
              v36 = *(char **)(a4 + 8);
              if ((unint64_t)v36 < *(void *)(a4 + 16) && (*v36 & 0x80000000) == 0)
              {
                *(void *)(a4 + 8) = v36 + 1;
                continue;
              }
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v75);
LABEL_126:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_101;
              }
              continue;
            case 1:
              *(void *)uint64_t v75 = 0;
              if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v75))goto LABEL_101; {
              continue;
              }
            case 2:
              LODWORD(__p) = 0;
              int v55 = *(char **)(a4 + 8);
              if ((unint64_t)v55 < *(void *)(a4 + 16) && (*v55 & 0x80000000) == 0)
              {
                unsigned int v41 = *v55;
                LODWORD(__p) = v41;
                *(void *)(a4 + 8) = v55 + 1;
                goto LABEL_112;
              }
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_101; {
              unsigned int v41 = __p;
              }
              break;
            case 5:
              v75[0] = 0;
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v75);
              goto LABEL_126;
            default:
              goto LABEL_101;
          }
          goto LABEL_112;
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
          *(void *)uint64_t v75 = 0;
          switch(v14)
          {
            case 0:
              int v16 = *(char **)(a4 + 8);
              if ((unint64_t)v16 < *(void *)(a4 + 16) && (*v16 & 0x80000000) == 0)
              {
                *(void *)uint64_t v75 = *v16;
                *(void *)(a4 + 8) = v16 + 1;
LABEL_66:
                unint64_t v42 = *(void *)v75;
                switch(BuiltinType)
                {
                  case 1:
                  case 15:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
                    continue;
                  case 2:
                  case 16:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
                    continue;
                  case 3:
                  case 6:
                  case 11:
                  case 12:
                  case 17:
                  case 20:
                  case 25:
                  case 26:
                    continue;
                  case 4:
                  case 18:
                    if (v63 != v12) {
                      continue;
                    }
                    uint64_t v43 = v62;
                    uint64_t v44 = *(void *)(v62 + 56);
                    if (v44) {
                      goto LABEL_79;
                    }
                    goto LABEL_80;
                  case 5:
                  case 19:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
                    continue;
                  case 7:
                  case 21:
                    if (v63 != v12) {
                      continue;
                    }
                    uint64_t v45 = v62;
                    uint64_t v46 = *(void *)(v62 + 56);
                    if (v46) {
                      goto LABEL_84;
                    }
                    goto LABEL_85;
                  case 8:
                  case 22:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
                    continue;
                  case 9:
                  case 23:
                    if (v63 != v12) {
                      continue;
                    }
                    uint64_t v45 = v62;
                    uint64_t v46 = *(void *)(v62 + 56);
                    if (v46) {
LABEL_84:
                    }
                      LODWORD(v42) = (*(uint64_t (**)(uint64_t, void))(*(void *)v46 + 16))(v46, *(void *)v75);
LABEL_85:
                    if (*(void *)(v45 + 48) > (unint64_t)v42) {
                      goto LABEL_128;
                    }
                    continue;
                  case 10:
                  case 24:
                    if (v63 != v12) {
                      continue;
                    }
                    uint64_t v43 = v62;
                    uint64_t v44 = *(void *)(v62 + 56);
                    if (v44) {
LABEL_79:
                    }
                      unint64_t v42 = (*(uint64_t (**)(uint64_t, void))(*(void *)v44 + 24))(v44, *(void *)v75);
LABEL_80:
                    if (v42 < *(void *)(v43 + 48)) {
                      goto LABEL_128;
                    }
                    continue;
                  default:
                    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                    std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
                }
              }
              char LittleEndian64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v75);
LABEL_65:
              if (LittleEndian64Fallback) {
                goto LABEL_66;
              }
LABEL_101:
              sub_1000C02E4(a4, v12);
              break;
            case 1:
              char LittleEndian64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v75);
              goto LABEL_65;
            case 2:
              goto LABEL_101;
            case 5:
              LODWORD(__p) = 0;
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_101; {
              *(void *)uint64_t v75 = __p;
              }
              goto LABEL_66;
            default:
              goto LABEL_66;
          }
          break;
        case 13:
          LODWORD(__p) = 0;
          v37 = *(char **)(a4 + 8);
          if ((unint64_t)v37 >= *(void *)(a4 + 16) || *v37 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_101; {
          }
            }
          else
          {
            LODWORD(__p) = *v37;
            *(void *)(a4 + 8) = v37 + 1;
          }
          *(void *)uint64_t v75 = 0;
          unint64_t v76 = 0;
          uint64_t v77 = 0;
          char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
          if ((SHIBYTE(v77) & 0x80000000) == 0) {
            goto LABEL_115;
          }
          v49 = *(void **)v75;
          goto LABEL_114;
        case 14:
          LODWORD(__p) = 0;
          v40 = *(char **)(a4 + 8);
          if ((unint64_t)v40 >= *(void *)(a4 + 16) || *v40 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_101; {
            unsigned int v41 = __p;
            }
          }
          else
          {
            unsigned int v41 = *v40;
            LODWORD(__p) = v41;
            *(void *)(a4 + 8) = v40 + 1;
          }
LABEL_112:
          sub_10003908C(v75, v41);
          char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, *(void **)v75, (int)__p);
          v49 = *(void **)v75;
          if (*(void *)v75)
          {
            unint64_t v76 = *(void *)v75;
LABEL_114:
            operator delete(v49);
          }
LABEL_115:
          if ((String & 1) == 0) {
            goto LABEL_101;
          }
          continue;
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
          unsigned int v67 = 0;
          __int16 v17 = *(char **)(a4 + 8);
          if ((unint64_t)v17 >= *(void *)(a4 + 16) || *v17 < 0)
          {
            if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, &v67) & 1) == 0)goto LABEL_101; {
          }
            }
          else
          {
            unsigned int v67 = *v17;
            *(void *)(a4 + 8) = v17 + 1;
          }
          wis::reflect::getUnpackedType();
          int WireTypeForType = wis::reflect::getWireTypeForType();
          int v19 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v67);
          __p = 0;
          v65 = 0;
          v66 = 0;
          while (1)
          {
            int v20 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
            if (v20 < 1) {
              break;
            }
            __int16 v21 = v65;
            if (v65 >= v66)
            {
              CFPropertyListRef v23 = (char *)__p;
              uint64_t v24 = (v65 - (unsigned char *)__p) >> 3;
              unint64_t v25 = v24 + 1;
              if ((unint64_t)(v24 + 1) >> 61) {
                sub_10002B5E0();
              }
              uint64_t v26 = v66 - (unsigned char *)__p;
              if ((v66 - (unsigned char *)__p) >> 2 > v25) {
                unint64_t v25 = v26 >> 2;
              }
              if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v27 = v25;
              }
              if (v27)
              {
                v28 = (char *)sub_100038500((uint64_t)&v66, v27);
                CFPropertyListRef v23 = (char *)__p;
                __int16 v21 = v65;
              }
              else
              {
                v28 = 0;
              }
              v29 = &v28[8 * v24];
              *(void *)v29 = 0;
              v22 = v29 + 8;
              while (v21 != v23)
              {
                uint64_t v30 = *((void *)v21 - 1);
                v21 -= 8;
                *((void *)v29 - 1) = v30;
                v29 -= 8;
              }
              __p = v29;
              v65 = v22;
              v66 = &v28[8 * v27];
              if (v23) {
                operator delete(v23);
              }
            }
            else
            {
              *(void *)v65 = 0;
              v22 = v21 + 8;
            }
            v65 = v22;
            switch(WireTypeForType)
            {
              case 0:
                v31 = (unint64_t *)(v22 - 8);
                v32 = *(char **)(a4 + 8);
                if ((unint64_t)v32 >= *(void *)(a4 + 16) || *v32 < 0)
                {
                  char v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v31);
LABEL_43:
                  if ((v33 & 1) == 0) {
                    goto LABEL_98;
                  }
                }
                else
                {
                  unint64_t *v31 = *v32;
                  *(void *)(a4 + 8) = v32 + 1;
                }
                break;
              case 1:
                char v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v22 - 1);
                goto LABEL_43;
              case 2:
                goto LABEL_98;
              case 5:
                v75[0] = 0;
                char LittleEndian32Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v75);
                *((void *)v65 - 1) = v75[0];
                if ((LittleEndian32Fallback & 1) == 0) {
                  goto LABEL_98;
                }
                continue;
              default:
                continue;
            }
          }
          switch(DecodingType)
          {
            case 15:
              sub_1000385BC((uint64_t *)&__p, v75);
              goto LABEL_95;
            case 16:
              sub_1000386C8((uint64_t *)&__p, v75);
              goto LABEL_95;
            case 17:
            case 18:
            case 24:
            case 25:
              sub_100038538((uint64_t *)&__p, v75);
              goto LABEL_95;
            case 19:
              sub_1000387D4((uint64_t *)&__p, v75);
              goto LABEL_95;
            case 20:
            case 21:
            case 23:
              sub_100038644((uint64_t *)&__p, v75);
              goto LABEL_95;
            case 22:
              sub_10003885C((uint64_t *)&__p, v75);
LABEL_95:
              uint64_t v47 = *(void **)v75;
              if (!*(void *)v75) {
                break;
              }
              unint64_t v76 = *(void *)v75;
LABEL_97:
              operator delete(v47);
              break;
            case 26:
              sub_100038750((uint64_t)&__p, v75);
              uint64_t v47 = *(void **)v75;
              if (!*(void *)v75) {
                break;
              }
              goto LABEL_97;
            default:
              v58 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v58, "This should never happen, no matter what the input!");
          }
LABEL_98:
          if (__p)
          {
            v65 = (char *)__p;
            operator delete(__p);
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v19);
          if (v20 > 0) {
            goto LABEL_101;
          }
          continue;
        case 27:
          v75[0] = 0;
          std::string v38 = *(char **)(a4 + 8);
          if ((unint64_t)v38 >= *(void *)(a4 + 16) || *v38 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v75))goto LABEL_101; {
            int v39 = v75[0];
            }
          }
          else
          {
            int v39 = *v38;
            v75[0] = v39;
            *(void *)(a4 + 8) = v38 + 1;
          }
          int v50 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v39);
          ++*(_DWORD *)(a4 + 56);
          int v51 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
          wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v51);
          int v52 = *(_DWORD *)(a4 + 56);
          BOOL v53 = __OFSUB__(v52, 1);
          int v54 = v52 - 1;
          if (v54 < 0 == v53) {
            *(_DWORD *)(a4 + 56) = v54;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v50);
          continue;
        default:
          goto LABEL_101;
      }
    }
  }
LABEL_128:
  sub_100038238((uint64_t)&v61);
  if (v60) {
    sub_10000B678(v60);
  }
  return v8 > 0;
}

void sub_1000C0088(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  if (a11) {
    sub_10000B678(a11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000C0298(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1000C02D8()
{
}

uint64_t sub_1000C02E4(uint64_t result, int a2)
{
  if (a2 || !*(unsigned char *)(result + 36))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
  }
  return result;
}

void sub_1000C0344(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1000C035C()
{
}

void sub_1000C047C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_1001415F0(a10);
  }
  unint64_t v12 = *(std::__shared_weak_count **)(v10 + 8);
  if (v12) {
    sub_10000B678(v12);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000C04D8(void *a1, const char *a2, dispatch_qos_class_t a3, const ctu::OsLogLogger *a4)
{
  dispatch_object_t object = 0;
  sub_10002A670(a1, a2, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), a4);
  return a1;
}

void sub_1000C052C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  sub_100029804(v10);
  _Unwind_Resume(a1);
}

void *sub_1000C0554(uint64_t a1)
{
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  if (DarwinNotifyCenter) {
    CFNotificationCenterRemoveEveryObserver(DarwinNotifyCenter, (const void *)a1);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 96);
  if (v3) {
    sub_10000B678(v3);
  }
  uint64_t v5 = (void **)(a1 + 64);
  sub_100060BBC(&v5);
  uint64_t v5 = (void **)(a1 + 40);
  sub_100060BBC(&v5);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 32));
  return sub_100029804((void *)a1);
}

void sub_1000C05CC(uint64_t a1)
{
  *(unsigned char *)(a1 + 104) = sub_10009E7B8(0);
  uint64_t v2 = *(void **)(a1 + 64);
  uint64_t v3 = *(void **)(a1 + 72);
  while (v2 != v3)
  {
    int v4 = (std::__shared_weak_count *)v2[1];
    if (v4)
    {
      uint64_t v5 = std::__shared_weak_count::lock(v4);
      if (v5 && *v2)
      {
        (*(void (**)(void, void))(*(void *)*v2 + 16))(*v2, *(unsigned __int8 *)(a1 + 104));
LABEL_10:
        sub_10000B678(v5);
        goto LABEL_12;
      }
      int v6 = (std::__shared_weak_count *)v2[1];
      void *v2 = 0;
      v2[1] = 0;
      if (v6) {
        std::__shared_weak_count::__release_weak(v6);
      }
      if (v5) {
        goto LABEL_10;
      }
    }
    else
    {
      void *v2 = 0;
      v2[1] = 0;
    }
LABEL_12:
    v2 += 2;
  }
}

void sub_1000C0680(_Unwind_Exception *a1)
{
  sub_10000B678(v1);
  _Unwind_Resume(a1);
}

void sub_1000C0694(uint64_t a1)
{
  v16[0] = off_1001BB590;
  v16[3] = v16;
  sub_10006FB38((uint64_t)v16, v14);
  long long v2 = v14[0];
  v14[0] = 0uLL;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 96);
  *(_OWORD *)(a1 + 88) = v2;
  if (v3)
  {
    sub_10000B678(v3);
    if (*((void *)&v14[0] + 1)) {
      sub_10000B678(*((std::__shared_weak_count **)&v14[0] + 1));
    }
  }
  sub_10006FD58(v16);
  if (!*(void *)(a1 + 88))
  {
    int v4 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v14[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "config:#E Config callbacks were not set up!", (uint8_t *)v14, 2u);
    }
  }
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  int v6 = DarwinNotifyCenter;
  if (DarwinNotifyCenter)
  {
    CFNotificationCenterAddObserver(DarwinNotifyCenter, (const void *)a1, (CFNotificationCallback)sub_1000C0954, @"com.apple.Preferences.ResetPrivacyWarningsNotification", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
    CFNotificationCenterAddObserver(v6, (const void *)a1, (CFNotificationCallback)sub_1000C09CC, @"com.apple.purplebuddy.setupdone", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = sub_1000C0A44;
    handler[3] = &unk_1001BB388;
    handler[4] = a1;
    global_queue = dispatch_get_global_queue(0, 0);
    xpc_set_event_stream_handler("com.apple.notifyd.matching", global_queue, handler);
    int v8 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
      sub_1001491F8(v8);
    }
    sub_1000A0F2C((uint64_t)v14);
    int v9 = *(_OWORD **)&v14[0];
    if (*(_OWORD **)&v14[0] != (_OWORD *)((char *)v14 + 8))
    {
      do
      {
        if (*((_DWORD *)v9 + 8) == 1) {
          sub_10002FA28((std::string *)((char *)v9 + 40));
        }
        uint64_t v10 = (void *)*((void *)v9 + 1);
        if (v10)
        {
          do
          {
            unint64_t v11 = v10;
            uint64_t v10 = (void *)*v10;
          }
          while (v10);
        }
        else
        {
          do
          {
            unint64_t v11 = (_OWORD *)*((void *)v9 + 2);
            BOOL v12 = *(void *)v11 == (void)v9;
            int v9 = v11;
          }
          while (!v12);
        }
        int v9 = v11;
      }
      while (v11 != (_OWORD *)((char *)v14 + 8));
    }
    sub_100058A90((uint64_t)v14, *((char **)&v14[0] + 1));
  }
  else
  {
    unint64_t v13 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v14[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "config:#E Unable to get notification center for configuration reader.", (uint8_t *)v14, 2u);
    }
  }
}

void sub_1000C0924(_Unwind_Exception *a1)
{
  sub_10006FD58((void *)(v1 - 56));
  _Unwind_Resume(a1);
}

void sub_1000C0954()
{
  v0 = *(NSObject **)qword_1001D8080;
  if (os_log_type_enabled(*(os_log_t *)qword_1001D8080, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_INFO, "config:#I In privacy reset callback", v1, 2u);
  }
  sub_1000C0EB0();
}

void sub_1000C09CC()
{
  v0 = *(NSObject **)qword_1001D8080;
  if (os_log_type_enabled(*(os_log_t *)qword_1001D8080, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_INFO, "config:#I Purple buddy setup done callback", v1, 2u);
  }
  sub_1000C0C28();
}

void *sub_1000C0A44(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(NSObject **)(v3 + 32);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "config:#N Woken up by notifyd.", (uint8_t *)&v10, 2u);
  }
  uint64_t result = xpc_get_type(a2);
  if (result == &_xpc_type_dictionary && &_xpc_type_error != &_xpc_type_dictionary)
  {
    uint64_t result = xpc_dictionary_get_value(a2, _xpc_event_key_name);
    if (result)
    {
      unsigned int v7 = result;
      uint64_t result = xpc_get_type(result);
      if (result == &_xpc_type_string)
      {
        uint64_t result = (void *)xpc_string_get_string_ptr(v7);
        if (result)
        {
          int v8 = (const char *)result;
          int v9 = *(NSObject **)(v3 + 32);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            int v10 = 136315138;
            unint64_t v11 = v8;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "config:#N Woken up by notifyd, got event %s", (uint8_t *)&v10, 0xCu);
          }
          if (!strcmp(v8, "com.apple.wirelessinsightsd.ProfileChanged")
            || !strcmp(v8, "logging tasks have changed")
            || !strcmp(v8, "com.apple.wirelessinsightsd.AnonymityChangedCommandLine"))
          {
            sub_1000C0C28();
          }
          if (!strcmp(v8, "com.apple.wirelessinsightsd.SubmissionPreferenceChanged")
            || !strcmp(v8, "com.apple.wirelessinsightsd.UISubmissionPreferenceChanged"))
          {
            sub_1000C0D6C();
          }
          uint64_t result = (void *)strcmp(v8, "com.apple.wirelessinsightsd.ResetPrivacyWarningsNotification");
          if (!result) {
            sub_1000C0EB0();
          }
        }
      }
    }
  }
  return result;
}

void sub_1000C0C28()
{
  sub_100018888(&__p, "update-config");
  sub_1000035F0();
}

void sub_1000C0D4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000C0D6C()
{
  sub_100018888(&__p, "update-config");
  sub_1000035F0();
}

void sub_1000C0E90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000C0EB0()
{
  sub_100018888(&__p, "Reconfig-priv");
  sub_1000035F0();
}

void sub_1000C0FD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000C0FF4(void *a1, uint64_t a2, uint64_t a3)
{
  sub_10000BA54(&v7, a1);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_1000C1124;
  v6[3] = &unk_1001BB3A8;
  v6[4] = a1;
  uint64_t v5 = (NSObject **)(v7 + 16);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  v9[2] = sub_1000C302C;
  v9[3] = &unk_1001BB618;
  v9[5] = v7;
  int v10 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void v9[4] = v6;
  sub_100123D98(a3, v5, (uint64_t)v9);
  if (v10) {
    sub_10000B678(v10);
  }
  if (v8) {
    sub_10000B678(v8);
  }
}

void sub_1000C1100(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    sub_10000B678(a22);
  }
  if (a15) {
    sub_10000B678(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000C1124(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(void *)(v1 + 88))
  {
    sub_10006FC90((const void **)(v1 + 88));
    long long v2 = *(std::__shared_weak_count **)(v1 + 96);
    *(void *)(v1 + 88) = 0;
    *(void *)(v1 + 96) = 0;
    if (v2)
    {
      sub_10000B678(v2);
    }
  }
}

void sub_1000C117C(void *a1, int a2, uint64_t a3)
{
  if (a2 == 2)
  {
    sub_10000BA54(&v10, a1);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    v9[2] = sub_1000C1774;
    v9[3] = &unk_1001BB408;
    void v9[4] = a1;
    uint64_t v7 = (NSObject **)(v10 + 16);
    int v18 = _NSConcreteStackBlock;
    uint64_t v19 = 1174405120;
    int v20 = sub_1000C3068;
    __int16 v21 = &unk_1001BB650;
    uint64_t v23 = v10;
    uint64_t v24 = v11;
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v22 = v9;
    sub_100123EA0(a3, v7, (uint64_t)&v18);
    if (v24) {
      sub_10000B678(v24);
    }
    int v6 = v11;
    if (v11) {
      goto LABEL_15;
    }
  }
  else
  {
    if (a2 != 1)
    {
      if (a2) {
        return;
      }
      sub_10000BA54(&v16, a1);
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 0x40000000;
      v15[2] = sub_1000C14C0;
      v15[3] = &unk_1001BB3C8;
      v15[4] = a1;
      uint64_t v5 = (NSObject **)(v16 + 16);
      int v18 = _NSConcreteStackBlock;
      uint64_t v19 = 1174405120;
      int v20 = sub_1000C3068;
      __int16 v21 = &unk_1001BB650;
      uint64_t v23 = v16;
      uint64_t v24 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v22 = v15;
      sub_100123EA0(a3, v5, (uint64_t)&v18);
      if (v24) {
        sub_10000B678(v24);
      }
      int v6 = v17;
      if (!v17) {
        return;
      }
LABEL_15:
      sub_10000B678(v6);
      return;
    }
    sub_10000BA54(&v13, a1);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    v12[2] = sub_1000C14C8;
    v12[3] = &unk_1001BB3E8;
    v12[4] = a1;
    int v8 = (NSObject **)(v13 + 16);
    int v18 = _NSConcreteStackBlock;
    uint64_t v19 = 1174405120;
    int v20 = sub_1000C3068;
    __int16 v21 = &unk_1001BB650;
    uint64_t v23 = v13;
    uint64_t v24 = v14;
    if (v14) {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v22 = v12;
    sub_100123EA0(a3, v8, (uint64_t)&v18);
    if (v24) {
      sub_10000B678(v24);
    }
    int v6 = v14;
    if (v14) {
      goto LABEL_15;
    }
  }
}

void sub_1000C1464(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  uint64_t v24 = *(std::__shared_weak_count **)(v22 - 40);
  if (v24) {
    sub_10000B678(v24);
  }
  if (a22) {
    sub_10000B678(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000C14A4()
{
  uint64_t v1 = *(std::__shared_weak_count **)(v0 - 40);
  if (v1) {
    sub_10000B678(v1);
  }
  if (!*(void *)(v0 - 96)) {
    JUMPOUT(0x1000C149CLL);
  }
  JUMPOUT(0x1000C1498);
}

void sub_1000C14C0(uint64_t a1)
{
}

uint64_t sub_1000C14C8(uint64_t a1)
{
  return sub_1000C14D8(*(void *)(a1 + 32), 0, 0);
}

uint64_t sub_1000C14D8(uint64_t a1, int a2, int a3)
{
  pthread_mutex_lock(&stru_1001D69C0);
  if (!(void)xmmword_1001D6A00) {
    sub_1000781CC();
  }
  int v6 = (std::__shared_weak_count *)*((void *)&xmmword_1001D6A00 + 1);
  if (*((void *)&xmmword_1001D6A00 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6A00 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_1001D69C0);
  if (v6) {
    sub_10000B678(v6);
  }
  sub_1000C18A0(a1, a3);
  pthread_mutex_lock(&stru_1001D6E38);
  uint64_t v7 = xmmword_1001D6E78;
  if (!(void)xmmword_1001D6E78) {
    sub_100057048();
  }
  int v8 = (std::__shared_weak_count *)*((void *)&xmmword_1001D6E78 + 1);
  if (*((void *)&xmmword_1001D6E78 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6E78 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_1001D6E38);
  sub_100058384(v7, *(unsigned char *)(a1 + 104), &v12);
  if (v8) {
    sub_10000B678(v8);
  }
  if (!v12) {
    sub_1000E7DE8();
  }
  uint64_t v9 = sub_1000C1A84(a1, v12, a2);
  uint64_t v10 = v12;
  uint64_t v12 = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 16))(v10);
  }
  return v9;
}

void sub_1000C16E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 16))(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000C1774(uint64_t a1)
{
}

uint64_t sub_1000C177C(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_1000C32F4;
  v5[3] = &unk_1001BB680;
  v5[4] = a1;
  v5[5] = &v4;
  int v6 = v5;
  uint64_t v2 = a1 + 16;
  uint64_t v1 = *(NSObject **)(a1 + 16);
  if (*(void *)(v2 + 8))
  {
    unsigned __int8 v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_1000C3340;
    uint64_t v10 = &unk_1001BB6C0;
    unint64_t v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    unsigned __int8 v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_1000C3304;
    uint64_t v10 = &unk_1001BB6A0;
    unint64_t v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13;
}

uint64_t sub_1000C18A0(uint64_t a1, int a2)
{
  uint64_t result = sub_10009E7B8(a2);
  *(unsigned char *)(a1 + 104) = result;
  uint64_t v4 = *(void **)(a1 + 64);
  uint64_t v5 = *(void **)(a1 + 72);
  if (v4 != v5)
  {
    while (1)
    {
      int v6 = (std::__shared_weak_count *)v4[1];
      if (v6)
      {
        uint64_t v7 = std::__shared_weak_count::lock(v6);
        if (v7 && *v4)
        {
          (*(void (**)(void, void))(*(void *)*v4 + 24))(*v4, *(unsigned __int8 *)(a1 + 104));
        }
        else
        {
          uint64_t v8 = (std::__shared_weak_count *)v4[1];
          void *v4 = 0;
          v4[1] = 0;
          if (v8) {
            std::__shared_weak_count::__release_weak(v8);
          }
          if (!v7) {
            goto LABEL_11;
          }
        }
        sub_10000B678(v7);
      }
      else
      {
        void *v4 = 0;
        v4[1] = 0;
      }
LABEL_11:
      v4 += 2;
      if (v4 == v5)
      {
        uint64_t result = *(unsigned __int8 *)(a1 + 104);
        break;
      }
    }
  }
  if (!result)
  {
    uint64_t v9 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "config:#N Metric collection disabled.  Loading 'disabled' configuration.", v10, 2u);
    }
    sub_1000C19C0();
  }
  return result;
}

void sub_1000C19AC(_Unwind_Exception *a1)
{
  sub_10000B678(v1);
  _Unwind_Resume(a1);
}

void sub_1000C19C0()
{
}

void sub_1000C1A68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_100143724(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000C1A84(uint64_t a1, uint64_t a2, int a3)
{
  pthread_mutex_lock(&stru_1001D69C0);
  uint64_t v6 = xmmword_1001D6A00;
  if (!(void)xmmword_1001D6A00) {
    sub_1000781CC();
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)&xmmword_1001D6A00 + 1);
  if (*((void *)&xmmword_1001D6A00 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6A00 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_1001D69C0);
  sub_1000A51FC(v6, type);
  if (v7) {
    sub_10000B678(v7);
  }
  if (!*(void *)type)
  {
    uint64_t v8 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "config:#N Set Config: Device has no current config assigned; assuming we are starting from nothing.",
        buf,
        2u);
    }
    sub_1000E7DE8();
  }
  int v9 = sub_1000E8360(a2, *(uint64_t *)type);
  sub_1000B9818(@"Anonymous", (CFPropertyListRef *)buf);
  sub_100082794(&v31, (CFTypeRef *)buf);
  sub_10001570C((const void **)buf);
  buf[0] = 1;
  ctu::cf::assign((ctu::cf *)buf, v31, v10);
  int v11 = buf[0];
  pthread_mutex_lock(&stru_1001D69C0);
  uint64_t v12 = xmmword_1001D6A00;
  if (!(void)xmmword_1001D6A00) {
    sub_1000781CC();
  }
  unsigned __int8 v13 = (std::__shared_weak_count *)*((void *)&xmmword_1001D6A00 + 1);
  if (*((void *)&xmmword_1001D6A00 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6A00 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_1001D69C0);
  BOOL v14 = sub_1000A3C84(v12);
  if (v13) {
    sub_10000B678(v13);
  }
  int v15 = *(NSObject **)(a1 + 32);
  BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
  if ((v9 ^ 1 | (v11 != 0) ^ v14))
  {
    if (v9)
    {
      if (v16)
      {
        int v17 = sub_10006BFF4(a2);
        int v18 = sub_10000B7EC(a2);
        int v19 = sub_1000E8260(a2);
        *(_DWORD *)buf = 67110144;
        *(_DWORD *)&uint8_t buf[4] = v17;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v18;
        *(_WORD *)&buf[14] = 1024;
        int v34 = v19;
        __int16 v35 = 1024;
        BOOL v36 = v14;
        __int16 v37 = 1024;
        int v38 = v11;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "config:#N Set Config: == Anon Change! == Same config (dcid=%d, iid=%d, type=%d); anon change from %d to %d",
          buf,
          0x20u);
      }
    }
    else if (v16)
    {
      int v30 = sub_10006BFF4(a2);
      int v21 = sub_10000B7EC(a2);
      int v22 = sub_1000E8260(a2);
      int v23 = sub_10006BFF4(*(uint64_t *)type);
      int v24 = sub_10000B7EC(*(uint64_t *)type);
      int v25 = sub_1000E8260(*(uint64_t *)type);
      *(_DWORD *)buf = 67110656;
      *(_DWORD *)&uint8_t buf[4] = v30;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v21;
      *(_WORD *)&buf[14] = 1024;
      int v34 = v22;
      __int16 v35 = 1024;
      BOOL v36 = v23;
      __int16 v37 = 1024;
      int v38 = v24;
      __int16 v39 = 1024;
      int v40 = v25;
      __int16 v41 = 1024;
      BOOL v42 = v14;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "config:#N Set Config: == Config Change! == New config (dcid=%d, iid=%d, type=%d) Old config (dcid=%d, iid=%d, type=%d); anon=%d",
        buf,
        0x2Cu);
    }
    pthread_mutex_lock(&stru_1001D69C0);
    uint64_t v26 = xmmword_1001D6A00;
    if (!(void)xmmword_1001D6A00) {
      sub_1000781CC();
    }
    unint64_t v27 = (std::__shared_weak_count *)*((void *)&xmmword_1001D6A00 + 1);
    if (*((void *)&xmmword_1001D6A00 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6A00 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(&stru_1001D69C0);
    sub_1000A3BF8(v26, v11 != 0);
    if (v27) {
      sub_10000B678(v27);
    }
    sub_1000C23D4(a1, a2);
    sub_1000C25D8(a1, a2);
  }
  if (v16)
  {
    int v20 = sub_10006BFF4(a2);
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v20;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v14;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "config:#N Set Config: No change (config dcid=%d, anonymity=%d). Doing nothing.", buf, 0xEu);
  }
  if (!a3) {
    sub_1000C2508(a1, *(uint64_t *)type, 0);
  }
  sub_100081E20((const void **)&v31);
  uint64_t v28 = *(void *)type;
  *(void *)type = 0;
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 16))(v28);
  }
  return v9 ^ 1 | (v11 != 0) ^ v14;
}

void sub_1000C1FB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, uint64_t a12)
{
  pthread_mutex_unlock(&stru_1001D69C0);
  sub_100081E20(&a11);
  uint64_t v13 = a12;
  a12 = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 16))(v13);
  }
  _Unwind_Resume(a1);
}

void sub_1000C20C4(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = xpc_null_create();
  if (xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(*a2);
    if (reply || (xpc_object_t reply = xpc_null_create()) != 0)
    {
      if (xpc_get_type(reply) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(reply);
        xpc_object_t v4 = reply;
      }
      else
      {
        xpc_object_t v4 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
      xpc_object_t reply = 0;
    }
    xpc_object_t v6 = xpc_null_create();
    xpc_release(v3);
    xpc_release(v6);
    xpc_release(reply);
  }
  else
  {
    xpc_object_t v4 = v3;
  }
  long long v9 = 0uLL;
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary) {
    operator new();
  }
  long long v8 = v9;
  xpc_release(v4);
  sub_100018888(&__p, "Reconfig");
  sub_100060258(&__p, (xpc_object_t **)&v8);
}

void sub_1000C2390(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a19) {
    sub_10000B678(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000C23D4(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(sub_1000E82A8(a2) + 208) & 0x20) != 0)
  {
    xpc_object_t v4 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      uint64_t v5 = *(uint64_t **)(sub_1000E82A8(a2) + 64);
      if (*((char *)v5 + 23) < 0) {
        uint64_t v5 = (uint64_t *)*v5;
      }
      int v9 = 136315138;
      CFBooleanRef v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "config:#I Display message to UI: %s", (uint8_t *)&v9, 0xCu);
    }
    xpc_object_t v6 = *(const char **)(sub_1000E82A8(a2) + 64);
    if (v6[23] < 0) {
      xpc_object_t v6 = *(const char **)v6;
    }
    CFStringRef v7 = CFStringCreateWithCString(kCFAllocatorDefault, v6, 0x8000100u);
    if (v7)
    {
      CFStringRef v8 = v7;
      CFUserNotificationDisplayNotice(0.0, 0, 0, 0, 0, @"Diagnostics & Usage Message", v7, 0);
      CFRelease(v8);
    }
  }
}

void sub_1000C2508(uint64_t a1, uint64_t a2, uint64_t a3)
{
  xpc_object_t v3 = *(void **)(a1 + 40);
  for (i = *(void **)(a1 + 48); v3 != i; v3 += 2)
  {
    CFStringRef v7 = (std::__shared_weak_count *)v3[1];
    if (v7)
    {
      CFStringRef v8 = std::__shared_weak_count::lock(v7);
      if (v8 && *v3)
      {
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v3 + 16))(*v3, a2, a3);
      }
      else
      {
        int v9 = (std::__shared_weak_count *)v3[1];
        void *v3 = 0;
        v3[1] = 0;
        if (v9) {
          std::__shared_weak_count::__release_weak(v9);
        }
        if (!v8) {
          continue;
        }
      }
      sub_10000B678(v8);
    }
    else
    {
      void *v3 = 0;
      v3[1] = 0;
    }
  }
}

void sub_1000C25C4(_Unwind_Exception *a1)
{
  sub_10000B678(v1);
  _Unwind_Resume(a1);
}

void sub_1000C25D8(uint64_t a1, uint64_t a2)
{
  xpc_object_t v3 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(__p[0]) = 67109376;
    HIDWORD(__p[0]) = sub_10006BFF4(a2);
    LOWORD(__p[1]) = 1024;
    *(_DWORD *)((char *)&__p[1] + 2) = sub_10000B7EC(a2);
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "config:#N  ===== New DCID is %d with IID %d. Sending configuration. ====", (uint8_t *)__p, 0xEu);
  }
  uint64_t v4 = sub_1000E82A8(a2);
  sub_1000155F0(__p, (const void **)4);
  sub_1000E6E98(v4);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v5 = sub_1000E82A8(a2);
  sub_1000995D8(v5);
  uint64_t v6 = sub_1000E82A8(a2);
  sub_1000479C8(v6);
  pthread_mutex_lock(&stru_1001D6C28);
  if (!(void)xmmword_1001D6C68) {
    sub_10007F320();
  }
  if (*((void *)&xmmword_1001D6C68 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6C68 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_1001D6C28);
  sub_100081138();
}

void sub_1000C2814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_1000C2890(void *a1, void *a2)
{
  *a2 = 0;
  a2[1] = 0;
  sub_10000BA54(&v2, a1);
  operator new();
}

void sub_1000C297C(void *a1, void *a2)
{
  *a2 = 0;
  a2[1] = 0;
  sub_10000BA54(&v2, a1);
  operator new();
}

void sub_1000C2A68(uint64_t a1, uint64_t a2)
{
  sub_1000C2AB0(&v2, a2);
}

void sub_1000C2AB0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1000C2B28(void *a1)
{
  __cxa_begin_catch(a1);
  v1(v2);
  __cxa_rethrow();
}

void sub_1000C2B3C(_Unwind_Exception *a1)
{
}

void sub_1000C2B54(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1000C2B8C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24));
}

uint64_t sub_1000C2BAC(uint64_t a1, uint64_t a2)
{
  if (sub_1000233A4(a2, (uint64_t)&off_1001BB4A8)) {
    return a1 + 32;
  }
  else {
    return 0;
  }
}

void sub_1000C2BF0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1000C2C68(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[2], v1, (dispatch_function_t)sub_1000C2D40);
  __cxa_rethrow();
}

void sub_1000C2C90(_Unwind_Exception *a1)
{
}

void sub_1000C2CA8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1000C2CE0(uint64_t a1)
{
}

uint64_t sub_1000C2CFC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1000C2D40(uint64_t result)
{
  if (result)
  {
    sub_1000C0554(result);
    operator delete();
  }
  return result;
}

void *sub_1000C2D80(void *a1)
{
  *a1 = off_1001BB538;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10000B678(v2);
  }
  return a1;
}

void sub_1000C2DCC(void *a1)
{
  *a1 = off_1001BB538;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10000B678(v1);
  }

  operator delete();
}

void *sub_1000C2E38@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "ConfigurationReader");
}

unsigned char *sub_1000C2E48@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1000C2E84(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1000C2E90(uint64_t a1, int a2, uint64_t a3)
{
}

void sub_1000C2E9C()
{
}

void *sub_1000C2EB0()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1001BB590;
  return result;
}

void sub_1000C2EE8(uint64_t a1, void *a2)
{
  *a2 = off_1001BB590;
}

void sub_1000C2F10()
{
  uint64_t v0 = *(NSObject **)qword_1001D8080;
  if (os_log_type_enabled(*(os_log_t *)qword_1001D8080, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)xpc_object_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_INFO, "config:#I Config-Change notification received from system.", v3, 2u);
  }
  pthread_mutex_lock(&stru_1001D6A70);
  uint64_t v2 = qword_1001D6AB0;
  uint64_t v1 = (std::__shared_weak_count *)qword_1001D6AB8;
  if (qword_1001D6AB8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_1001D6AB8 + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_1001D6A70);
  if (v2) {
    sub_1000C0C28();
  }
  if (v1) {
    sub_10000B678(v1);
  }
}

void sub_1000C2FC4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10000B678(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000C2FE0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1000C3020()
{
}

uint64_t sub_1000C302C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000C303C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1000C3058(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10000B678(v1);
  }
}

void sub_1000C3068(uint64_t a1, NSObject **a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  group = *a2;
  *a2 = 0;
  (*(void (**)(void))(v2 + 16))();
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
}

void sub_1000C30C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1000C30E8(uint64_t **a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v3 = a1;
  uint64_t v4 = v1;
  sub_1000C14D8(*v1, 1, 0);
  sub_1000C3150((uint64_t *)&v4);
  return sub_10000BA00((uint64_t *)&v3);
}

void sub_1000C3134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1000C3150(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10000B678(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1000C31A4(uint64_t **a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v3 = a1;
  uint64_t v4 = v1;
  sub_1000C14D8(*v1, 1, 1);
  sub_1000C3150((uint64_t *)&v4);
  return sub_10000BA00((uint64_t *)&v3);
}

void sub_1000C31F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1000C320C(void **a1)
{
  uint64_t v1 = *a1;
  int v9 = a1;
  CFBooleanRef v10 = v1;
  uint64_t v2 = *v1;
  xpc_object_t v3 = *(void **)(v2 + 64);
  uint64_t v4 = *(void **)(v2 + 72);
  while (v3 != v4)
  {
    uint64_t v5 = (std::__shared_weak_count *)v3[1];
    if (v5)
    {
      uint64_t v6 = std::__shared_weak_count::lock(v5);
      if (v6 && *v3)
      {
        (*(void (**)(void))(*(void *)*v3 + 32))(*v3);
LABEL_10:
        sub_10000B678(v6);
        goto LABEL_12;
      }
      CFStringRef v7 = (std::__shared_weak_count *)v3[1];
      void *v3 = 0;
      v3[1] = 0;
      if (v7) {
        std::__shared_weak_count::__release_weak(v7);
      }
      if (v6) {
        goto LABEL_10;
      }
    }
    else
    {
      void *v3 = 0;
      v3[1] = 0;
    }
LABEL_12:
    v3 += 2;
  }
  sub_1000C3150((uint64_t *)&v10);
  return sub_10000BA00((uint64_t *)&v9);
}

void sub_1000C32D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10000B678(v10);
  sub_1000C3150(&a10);
  sub_10000BA00(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1000C32F4(uint64_t a1)
{
  return *(unsigned __int8 *)(**(void **)(a1 + 40) + 104);
}

uint64_t sub_1000C3304(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1000C3340(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t *sub_1000C337C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  int v19 = a1;
  int v20 = v1;
  uint64_t v2 = *v1;
  sub_1000C18A0(*v1, 0);
  if (*(unsigned char *)(v2 + 104) == 2)
  {
    xpc_object_t v3 = (void *)v1[1];
    xpc_object_t v26 = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t v26 = xpc_null_create();
    }
    sub_100089284((uint64_t *)object, (uint64_t)&v26);
    xpc_release(v26);
    xpc_object_t v26 = 0;
    sub_1000EFC00(object, (uint64_t)&v25);
    if (sub_1000EFBE8(object))
    {
      uint64_t v5 = sub_1000EFBF8((uint64_t)object);
      pthread_mutex_lock(&stru_1001D6E38);
      uint64_t v6 = xmmword_1001D6E78;
      if (!(void)xmmword_1001D6E78) {
        sub_100057048();
      }
      CFStringRef v7 = (std::__shared_weak_count *)*((void *)&xmmword_1001D6E78 + 1);
      if (*((void *)&xmmword_1001D6E78 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6E78 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      pthread_mutex_unlock(&stru_1001D6E38);
      BOOL v8 = sub_100058068(v6, v5);
      if (v7) {
        sub_10000B678(v7);
      }
      int v9 = *(NSObject **)(v2 + 32);
      BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
      if (v8)
      {
        if (v10)
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "config:#N Config saved; reselecting the best config",
            buf,
            2u);
        }
        if ((sub_1000C14D8(v2, 1, 0) & 1) == 0) {
          std::string::assign(&v25, "Saved (but is not different)");
        }
      }
      else
      {
        if (v10)
        {
          int v12 = sub_10006BFF4(v5);
          int v13 = sub_10000B7EC(v5);
          int v14 = sub_1000E8260(v5);
          *(_DWORD *)buf = 67109632;
          *(_DWORD *)&uint8_t buf[4] = v12;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v13;
          *(_WORD *)&buf[14] = 1024;
          int v29 = v14;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "config:#E Attempt to save config failed (dcid=%d, iid=%d, type=%d)", buf, 0x14u);
        }
        std::string::assign(&v25, "Config was not accepted");
      }
    }
    else
    {
      int v11 = *(NSObject **)(v2 + 32);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "config:#E Config was not parsable. Ignoring the update.", buf, 2u);
      }
    }
    int v15 = (xpc_object_t *)v1[2];
    if (!v15 || xpc_get_type(*v15) != (xpc_type_t)&_xpc_type_dictionary) {
      goto LABEL_39;
    }
    BOOL v16 = sub_1000EFBE8(object);
    xpc_object_t v23 = xpc_BOOL_create(v16);
    if (!v23) {
      xpc_object_t v23 = xpc_null_create();
    }
    *(void *)buf = v1[2];
    *(void *)&buf[8] = "Success";
    sub_100014D08((uint64_t)buf, &v23, &v24);
    xpc_release(v24);
    xpc_object_t v24 = 0;
    xpc_release(v23);
    xpc_object_t v23 = 0;
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
    {
      if (v25.__r_.__value_.__l.__size_)
      {
        int v17 = (std::string *)v25.__r_.__value_.__r.__words[0];
        goto LABEL_36;
      }
    }
    else if (*((unsigned char *)&v25.__r_.__value_.__s + 23))
    {
      int v17 = &v25;
LABEL_36:
      xpc_object_t v21 = xpc_string_create((const char *)v17);
      if (!v21) {
        xpc_object_t v21 = xpc_null_create();
      }
      *(void *)buf = v1[2];
      *(void *)&buf[8] = "Reason";
      sub_100014D08((uint64_t)buf, &v21, &v22);
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_release(v21);
      xpc_object_t v21 = 0;
    }
LABEL_39:
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v25.__r_.__value_.__l.__data_);
    }
    sub_1000EF9DC(object);
    goto LABEL_42;
  }
  uint64_t v4 = (xpc_object_t *)v1[2];
  if (v4 && xpc_get_type(*v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    object[0] = xpc_BOOL_create(1);
    if (!object[0]) {
      object[0] = xpc_null_create();
    }
    v25.__r_.__value_.__r.__words[0] = v1[2];
    v25.__r_.__value_.__l.__size_ = (std::string::size_type)"Success";
    sub_100014D08((uint64_t)&v25, object, (xpc_object_t *)buf);
    xpc_release(*(xpc_object_t *)buf);
    *(void *)buf = 0;
    xpc_release(object[0]);
  }
LABEL_42:
  sub_1000C3864((uint64_t *)&v20);
  return sub_10000BA00((uint64_t *)&v19);
}

void sub_1000C3784(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,xpc_object_t object,char a22)
{
  if (a2) {
    sub_10001F4A8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1000C3864(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 40);
    if (v2) {
      sub_10000B678(v2);
    }
    xpc_object_t v3 = *(std::__shared_weak_count **)(v1 + 24);
    if (v3) {
      sub_10000B678(v3);
    }
    xpc_release(*(xpc_object_t *)(v1 + 8));
    *(void *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

uint64_t *sub_1000C38D4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v3 = a1;
  uint64_t v4 = v1;
  sub_1000C3938((uint64_t *)(*(void *)v1 + 40), (long long *)(v1 + 8));
  sub_100072414(&v4);
  return sub_10000BA00((uint64_t *)&v3);
}

void sub_1000C391C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *sub_1000C3938(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = a1 + 2;
  unint64_t v5 = v6;
  CFStringRef v7 = (void *)*(v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_10002B5E0();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v19[4] = v4;
    int v14 = (char *)sub_10001E498((uint64_t)v4, v13);
    int v15 = &v14[16 * v10];
    v19[0] = v14;
    v19[1] = v15;
    v19[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)int v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 16), 1uLL, memory_order_relaxed);
    }
    v19[2] = v15 + 16;
    sub_1000C3A58(a1, v19);
    int v9 = (void *)a1[1];
    sub_100061150(v19);
  }
  else
  {
    void *v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 16), 1uLL, memory_order_relaxed);
    }
    int v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return v9 - 2;
}

void sub_1000C3A44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100061150((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1000C3A58(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000C3AD0((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1000C3AD0(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      _OWORD *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_1000C3B64((uint64_t)v12);
  return v10;
}

uint64_t sub_1000C3B64(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_10006110C(a1);
  }
  return a1;
}

uint64_t *sub_1000C3B9C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v3 = a1;
  uint64_t v4 = v1;
  sub_1000C3C00((uint64_t *)(*(void *)v1 + 64), (long long *)(v1 + 8));
  sub_100072414(&v4);
  return sub_10000BA00((uint64_t *)&v3);
}

void sub_1000C3BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *sub_1000C3C00(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = a1 + 2;
  unint64_t v5 = v6;
  uint64_t v7 = (void *)*(v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_10002B5E0();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v19[4] = v4;
    long long v14 = (char *)sub_10001E498((uint64_t)v4, v13);
    long long v15 = &v14[16 * v10];
    v19[0] = v14;
    v19[1] = v15;
    v19[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)long long v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 16), 1uLL, memory_order_relaxed);
    }
    v19[2] = v15 + 16;
    sub_1000C3D20(a1, v19);
    long long v9 = (void *)a1[1];
    sub_100061150(v19);
  }
  else
  {
    void *v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 16), 1uLL, memory_order_relaxed);
    }
    long long v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return v9 - 2;
}

void sub_1000C3D0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100061150((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1000C3D20(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000C3D98((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1000C3D98(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      _OWORD *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_1000C3E2C((uint64_t)v12);
  return v10;
}

uint64_t sub_1000C3E2C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_10006110C(a1);
  }
  return a1;
}

uint64_t sub_1000C3E64()
{
  if ((byte_1001D6AC0 & 1) == 0)
  {
    byte_1001D6AC0 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E64, &stru_1001D6A70, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000C3EA0()
{
  if ((byte_1001D6A10 & 1) == 0)
  {
    byte_1001D6A10 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E5C, &stru_1001D69C0, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000C3EDC()
{
  if ((byte_1001D6E88 & 1) == 0)
  {
    byte_1001D6E88 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E90, &stru_1001D6E38, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000C3F18()
{
  if ((byte_1001D6C78 & 1) == 0)
  {
    byte_1001D6C78 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E78, &stru_1001D6C28, (void *)&_mh_execute_header);
  }
  return result;
}

void sub_1000C4040(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000C4108(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)WISCLLocationManager;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1000C42FC(uint64_t a1)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [*(id *)(a1 + 32) shouldUpdateLocation:1];
}

void sub_1000C43FC(uint64_t a1)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [*(id *)(a1 + 32) shouldUpdateLocation:0];
}

void sub_1000C44FC(uint64_t a1)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = +[WISCLLocationManager sIsLocationAllowed:](WISCLLocationManager, "sIsLocationAllowed:", [*(id *)(*(void *)(a1 + 32) + 8) authorizationStatus]);
}

void sub_1000C4718(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10001F4A8(a1);
}

void sub_1000C48E8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10001F4A8(a1);
}

void sub_1000C4AAC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10001F4A8(a1);
}

void sub_1000C4C34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000C4D04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000C4DE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id **sub_1000C4E68(id **result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {

    operator delete();
  }
  return result;
}

id **sub_1000C4EB8(uint64_t a1)
{
  uint64_t v4 = (id *)a1;
  [*(id *)(*(void *)a1 + 8) setDesiredAccuracy:*(double *)(a1 + 8)];
  return sub_1000C4E68(&v4);
}

void sub_1000C4F0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C4E68((id **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1000C4F20(uint64_t a1, uint64_t a2)
{
  xpc_object_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    xpc_object_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_1000C4FA0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_10006D524((void *)(v1 + 8));

    operator delete();
  }
  return result;
}

uint64_t *sub_1000C4FF8(uint64_t a1)
{
  uint64_t v2 = a1;
  sub_1000C5034((void *)(*(void *)a1 + 24), a1 + 8);
  return sub_1000C4FA0(&v2);
}

void *sub_1000C5034(void *a1, uint64_t a2)
{
  sub_1000C50B8(a1);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      a1[3] = a1;
      (*(void (**)(void, void *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v4;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

void *sub_1000C50B8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

id **sub_1000C5140(id **result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {

    operator delete();
  }
  return result;
}

id **sub_1000C5190(uint64_t a1)
{
  uint64_t v4 = (id *)a1;
  if (*(void *)(*(void *)a1 + 48)) {
    sub_1000C5218(*(void *)a1 + 24, +[WISCLLocationManager sIsLocationAllowed:*(unsigned int *)(a1 + 8)]);
  }
  return sub_1000C5140(&v4);
}

void sub_1000C5204(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C5140((id **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1000C5218(uint64_t a1, char a2)
{
  char v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_100029F0C();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t sub_1000C526C(uint64_t a1, uint64_t a2)
{
  xpc_object_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    xpc_object_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_1000C52EC(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_10006DBA4((void *)(v1 + 8));

    operator delete();
  }
  return result;
}

uint64_t *sub_1000C5344(uint64_t a1)
{
  uint64_t v2 = a1;
  sub_1000C5380((void *)(*(void *)a1 + 56), a1 + 8);
  return sub_1000C52EC(&v2);
}

void *sub_1000C5380(void *a1, uint64_t a2)
{
  sub_1000C5404(a1);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      a1[3] = a1;
      (*(void (**)(void, void *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v4;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

void *sub_1000C5404(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

id **sub_1000C548C(id **result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {

    operator delete();
  }
  return result;
}

id **sub_1000C54E4(id *a1)
{
  uint64_t v4 = a1;
  if (*((void *)*a1 + 10)) {
    sub_1000C5554((uint64_t)*a1 + 56, a1[1]);
  }
  return sub_1000C548C(&v4);
}

void sub_1000C5540(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C548C((id **)va);
  _Unwind_Resume(a1);
}

void sub_1000C5554(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_100029F0C();
  }
  (*(void (**)(uint64_t, id *))(*(void *)v3 + 48))(v3, &v4);
}

void sub_1000C55C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1000C55D8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_1000C5658(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_10006FD58((void *)(v1 + 8));

    operator delete();
  }
  return result;
}

uint64_t *sub_1000C56B0(uint64_t a1)
{
  uint64_t v2 = a1;
  sub_10006FDDC((void *)(*(void *)a1 + 88), a1 + 8);
  return sub_1000C5658(&v2);
}

id **sub_1000C56EC(id **result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {

    operator delete();
  }
  return result;
}

id **sub_1000C573C(id *a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = *((void *)*a1 + 14);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 48))(v1);
  }
  return sub_1000C56EC(&v3);
}

void sub_1000C579C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C56EC((id **)va);
  _Unwind_Resume(a1);
}

void sub_1000C58C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000C5BA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000C5CB4()
{
}

void sub_1000C5FE4(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&stru_1001D6968);
  if (v1) {
    sub_10000B678(v1);
  }
  _Unwind_Resume(a1);
}

void sub_1000C60B8(uint64_t a1@<X0>, void *a2@<X8>)
{
  sub_10000BA54(&v4, (void *)(a1 + 8));
  uint64_t v3 = v5;
  *a2 = v4;
  a2[1] = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    if (v5) {
      sub_10000B678(v5);
    }
  }
}

uint64_t sub_1000C6110(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  sub_100018888(&__p, "com.apple.wirelessinsightsd.ConnectionManagerSerialQueue");
  xpc_object_t v13 = xpc_null_create();
  ctu::XpcServer::XpcServer();
  xpc_release(v13);
  if (v15 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 72) = off_1001B71D0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 80), (const ctu::OsLogLogger *)(qword_1001D8080 + 8));
  *(void *)a1 = off_1001BB740;
  *(void *)(a1 + 72) = off_1001BB780;
  *(_OWORD *)(a1 + 88) = *(_OWORD *)a2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_OWORD *)(a1 + 104) = *(_OWORD *)a3;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_OWORD *)(a1 + 120) = *(_OWORD *)a4;
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  *(_OWORD *)(a1 + 136) = *(_OWORD *)a5;
  *(void *)a5 = 0;
  *(void *)(a5 + 8) = 0;
  *(_OWORD *)(a1 + 152) = *(_OWORD *)a6;
  *(void *)a6 = 0;
  *(void *)(a6 + 8) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = a1 + 216;
  return a1;
}

void sub_1000C6284(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, xpc_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  nullsub_15(v18);
  ctu::XpcServer::~XpcServer(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_1000C62DC()
{
  uint64_t result = sub_10006FA24();
  if (!result) {
    return result;
  }
  sub_1000A23A4((uint64_t)v13);
  pthread_mutex_lock(&stru_1001D69C0);
  uint64_t v1 = xmmword_1001D6A00;
  if (!(void)xmmword_1001D6A00) {
    sub_1000781CC();
  }
  uint64_t v2 = (std::__shared_weak_count *)*((void *)&xmmword_1001D6A00 + 1);
  if (*((void *)&xmmword_1001D6A00 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6A00 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_1001D69C0);
  sub_1000A3164(v1);
  if (v2) {
    sub_10000B678(v2);
  }
  uint64_t v3 = sub_100004D64(v14, (uint64_t)"Current device configuration is ", 32);
  *(_DWORD *)((char *)v3 + *(void *)(*v3 - 24) + 8) = *(_DWORD *)((unsigned char *)v3 + *(void *)(*v3 - 24) + 8) & 0xFFFFFFB5 | 2;
  uint64_t v4 = (void *)std::ostream::operator<<();
  uint64_t v5 = sub_100004D64(v4, (uint64_t)" (hex 0x", 8);
  *(_DWORD *)((char *)v5 + *(void *)(*v5 - 24) + 8) = *(_DWORD *)((unsigned char *)v5 + *(void *)(*v5 - 24) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v6 = (void *)std::ostream::operator<<();
  sub_100004D64(v6, (uint64_t)").", 2);
  std::stringbuf::str();
  if (v12 >= 0) {
    uint64_t v7 = __p;
  }
  else {
    uint64_t v7 = (void **)__p[0];
  }
  CFStringRef v8 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v7, 0x8000100u);
  CFStringRef v9 = v8;
  if ((v12 & 0x80000000) == 0)
  {
    if (!v8) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  operator delete(__p[0]);
  if (v9)
  {
LABEL_15:
    CFUserNotificationDisplayNotice(0.0, 0, 0, 0, 0, @"Device Configuration", v9, 0);
    CFRelease(v9);
  }
LABEL_16:
  *(void *)((char *)v13
  v14[0] = v10;
  if (v15 < 0) {
    operator delete((void *)v14[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1000C65E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

void sub_1000C6654(dispatch_queue_t *a1)
{
  uint64_t v2 = a1[10];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "conn:#E Listener got xpc error. Not sure what to do bout that. Start again?", v3, 2u);
  }
  sub_1000C66C0(a1);
}

void sub_1000C66C0(dispatch_queue_t *a1)
{
  mach_service = xpc_connection_create_mach_service("com.apple.wirelessinsightsd", a1[3], 1uLL);
  if (!mach_service) {
    mach_service = xpc_null_create();
  }
  if (xpc_get_type(mach_service) == (xpc_type_t)&_xpc_type_connection)
  {
    xpc_object_t object = mach_service;
    if (mach_service) {
      xpc_retain(mach_service);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    ctu::XpcServer::setListener_sync();
    xpc_release(object);
    xpc_object_t object = 0;
    ctu::XpcServer::startListener_sync((ctu::XpcServer *)a1);
    CFStringRef v8 = a1[10];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      __int16 v9 = 0;
      uint64_t v4 = "conn:#I XPC listener started.";
      uint64_t v5 = (uint8_t *)&v9;
      uint64_t v6 = v8;
      os_log_type_t v7 = OS_LOG_TYPE_INFO;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v3 = a1[10];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v11 = 0;
      uint64_t v4 = "conn:#E Unable to create listener in ConnectionManager::init_sync.";
      uint64_t v5 = (uint8_t *)&v11;
      uint64_t v6 = v3;
      os_log_type_t v7 = OS_LOG_TYPE_DEFAULT;
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v6, v7, v4, v5, 2u);
    }
  }
  xpc_release(mach_service);
}

void sub_1000C67E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

void *sub_1000C681C@<X0>(uint64_t a1@<X0>, void **a2@<X1>, void *a3@<X8>)
{
  sub_1000C685C((uint64_t *)(a1 + 168), a2);
  uint64_t result = *(void **)(a1 + 192);
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  *a3 = result;
  return result;
}

uint64_t sub_1000C685C(uint64_t *a1, void **a2)
{
  uint64_t v5 = (uint64_t)(a1 + 2);
  unint64_t v4 = a1[2];
  uint64_t v6 = (void **)a1[1];
  if ((unint64_t)v6 >= v4)
  {
    uint64_t v9 = ((uint64_t)v6 - *a1) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      sub_10002B5E0();
    }
    uint64_t v10 = v4 - *a1;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t v18 = a1 + 2;
    if (v12) {
      xpc_object_t v13 = (char *)sub_100038500((uint64_t)(a1 + 2), v12);
    }
    else {
      xpc_object_t v13 = 0;
    }
    long long v14 = v13;
    char v15 = (void **)&v13[8 * v9];
    long long v17 = &v13[8 * v12];
    sub_1000C9184(v5, v15, a2);
    uint64_t v16 = v15 + 1;
    sub_1000C91C4(a1, &v14);
    CFStringRef v8 = (void **)a1[1];
    uint64_t result = sub_1000C9404((uint64_t)&v14);
  }
  else
  {
    uint64_t result = (uint64_t)sub_1000C9184((uint64_t)(a1 + 2), v6, a2);
    CFStringRef v8 = v6 + 1;
    a1[1] = (uint64_t)(v6 + 1);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_1000C695C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C9404((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1000C6970(uint64_t a1, xpc_object_t *a2, xpc_object_t *a3)
{
  if (xpc_get_type(*a3) == (xpc_type_t)&_xpc_type_null)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 80), OS_LOG_TYPE_ERROR)) {
      sub_10014923C();
    }
  }
  else if (xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_connection)
  {
    if (*a3 == &_xpc_error_connection_interrupted)
    {
      uint64_t v11 = *(NSObject **)(a1 + 80);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        xpc_object_t v12 = *a2;
        *(_DWORD *)buf = 134217984;
        xpc_object_t v22 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "conn:#I Got xpc error connection interrupted on connection 0x%p", buf, 0xCu);
      }
    }
    else if (*a3 == &_xpc_error_connection_invalid)
    {
      uint64_t v6 = *(NSObject **)(a1 + 80);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        xpc_object_t v7 = *a2;
        *(_DWORD *)buf = 134217984;
        xpc_object_t v22 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "conn:#I Got xpc error connection invalid on connection 0x%p", buf, 0xCu);
      }
      CFStringRef v8 = *(xpc_object_t **)(a1 + 168);
      uint64_t v9 = *(xpc_object_t **)(a1 + 176);
      if (v8 == v9)
      {
        uint64_t v10 = *(void ***)(a1 + 168);
      }
      else
      {
        do
        {
          if (xpc_equal(*v8, *a2)) {
            goto LABEL_15;
          }
          ++v8;
        }
        while (v8 != v9);
        CFStringRef v8 = v9;
LABEL_15:
        uint64_t v10 = v8;
        CFStringRef v8 = *(xpc_object_t **)(a1 + 176);
      }
      if (v10 != v8)
      {
        sub_1000C9494((uint64_t)buf, v10 + 1, v8, v10);
        sub_1000C8D84(a1 + 168, v13);
      }
      uint64_t v14 = *(void *)(a1 + 88);
      xpc_object_t v15 = *a2;
      xpc_object_t object = v15;
      if (v15) {
        xpc_retain(v15);
      }
      else {
        xpc_object_t object = xpc_null_create();
      }
      sub_1000B36C0(v14, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      uint64_t v16 = *(void **)(a1 + 136);
      xpc_object_t v17 = *a2;
      aBlock = 0;
      xpc_object_t v19 = xpc_null_create();
      sub_100054E70(v16, (uint64_t)v17, &v19, (const void **)&aBlock);
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 80), OS_LOG_TYPE_ERROR))
  {
    sub_100149270();
  }
}

void sub_1000C6BDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock, xpc_object_t object, xpc_object_t a12)
{
  if (a2) {
    sub_10001F4A8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void **sub_1000C6C40(void **a1, void **a2)
{
  uint64_t v3 = *a2;
  *a1 = *a2;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    *a1 = xpc_null_create();
  }
  return a1;
}

uint64_t sub_1000C6CD4()
{
  xpc_connection_get_audit_token();
  audit_token_t token = v11;
  uint64_t v0 = SecTaskCreateWithAuditToken(kCFAllocatorDefault, &token);
  if (v0)
  {
    uint64_t v1 = v0;
    CFTypeRef v2 = SecTaskCopyValueForEntitlement(v0, @"com.apple.wirelessinsightsd.manager-access", 0);
    if (v2 && (CFTypeID TypeID = CFBooleanGetTypeID(), TypeID == CFGetTypeID(v2)))
    {
      if (CFEqual(v2, kCFBooleanTrue))
      {
        uint64_t v4 = 1;
      }
      else
      {
        CFStringRef v8 = *(NSObject **)(qword_1001D8080 + 8);
        uint64_t v4 = 0;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v9 = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "conn:#E Entitlement exists, but check failed.", v9, 2u);
          uint64_t v4 = 0;
        }
      }
    }
    else
    {
      uint64_t v5 = *(NSObject **)(qword_1001D8080 + 8);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v9 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "conn:#E Entitlement couldnt be found", v9, 2u);
      }
      uint64_t v4 = 0;
      if (!v2) {
        goto LABEL_10;
      }
    }
    CFRelease(v2);
LABEL_10:
    CFRelease(v1);
    return v4;
  }
  uint64_t v6 = *(NSObject **)(qword_1001D8080 + 8);
  uint64_t v4 = 0;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v9 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "conn:#E Entitlement query did not succeed", v9, 2u);
    return 0;
  }
  return v4;
}

void **sub_1000C6E8C(void **a1, void **a2)
{
  uint64_t v3 = *a2;
  *a1 = *a2;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    *a1 = xpc_null_create();
  }
  return a1;
}

void sub_1000C6ED0(uint64_t a1)
{
  if (os_log_type_enabled(*(os_log_t *)(*(void *)(a1 + 32) + 80), OS_LOG_TYPE_DEBUG)) {
    sub_100149374();
  }
}

uint64_t sub_1000C6F10(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1000C6F2C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10000B678(v1);
  }
}

void sub_1000C6F3C(uint64_t a1, char a2, uint64_t a3)
{
  if ((a2 & 1) == 0)
  {
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v4 = (const char *)a3;
    }
    else {
      uint64_t v4 = *(const char **)a3;
    }
    xpc_object_t v6 = xpc_string_create(v4);
    if (!v6) {
      xpc_object_t v6 = xpc_null_create();
    }
    v5[0] = *(void *)(a1 + 32);
    v5[1] = "error";
    sub_100014D08((uint64_t)v5, &v6, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v6);
  }
}

uint64_t sub_1000C6FD0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1000C6FEC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10000B678(v1);
  }
}

void sub_1000C6FFC(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v4 = xpc_null_create();
  if (xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(*a2);
    if (reply || (xpc_object_t reply = xpc_null_create()) != 0)
    {
      if (xpc_get_type(reply) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(reply);
        xpc_object_t v5 = reply;
      }
      else
      {
        xpc_object_t v5 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t reply = 0;
    }
    xpc_object_t v7 = xpc_null_create();
    xpc_release(v4);
    xpc_release(v7);
    xpc_release(reply);
  }
  else
  {
    xpc_object_t v5 = v4;
  }
  memset(buf, 0, sizeof(buf));
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary) {
    operator new();
  }
  xpc_release(v5);
  if (os_log_type_enabled(*(os_log_t *)(a1 + 80), OS_LOG_TYPE_ERROR)) {
    sub_1001493B4();
  }
}

void sub_1000C7410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a9) {
    sub_10000B678(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1000C750C(void *a1, xpc_object_t *a2)
{
  unsigned int v30 = 0;
  *(void *)buf = a2;
  *(void *)&buf[8] = "cid";
  sub_10000B7A4((uint64_t)buf, &object);
  unsigned int v5 = xpc::dyn_cast_or_default((xpc *)&object, 0, v4);
  xpc_release(object);
  unsigned int v30 = v5;
  xpc_object_t v6 = xpc_null_create();
  if (xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(*a2);
    if (reply || (xpc_object_t reply = xpc_null_create()) != 0)
    {
      if (xpc_get_type(reply) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(reply);
        xpc_object_t v7 = reply;
      }
      else
      {
        xpc_object_t v7 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t reply = 0;
    }
    xpc_object_t v9 = xpc_null_create();
    xpc_release(v6);
    xpc_release(v9);
    xpc_release(reply);
  }
  else
  {
    xpc_object_t v7 = v6;
  }
  *(void *)buf = 0;
  *(void *)&buf[8] = 0;
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary) {
    operator new();
  }
  uint64_t v11 = *(void *)buf;
  uint64_t v10 = *(std::__shared_weak_count **)&buf[8];
  xpc_release(v7);
  xpc_object_t v27 = xpc_int64_create(12);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  *(void *)buf = v11;
  *(void *)&buf[8] = "WISMessageType";
  sub_100014D08((uint64_t)buf, &v27, &v28);
  xpc_release(v28);
  xpc_object_t v28 = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_object_t v12 = a1[10];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v30;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "conn:#I CoreAnalytics shim: Handling metadata request for 0x%x", buf, 8u);
  }
  if (xpc_dictionary_get_value(*a2, "needs_base"))
  {
    if (!a1[25])
    {
      strcpy((char *)buf, "/System/Library/PrivateFrameworks/WirelessInsights.framework/Support/AWDMetadata.bin");
      operator new();
    }
    readonly = (void *)xpc_shmem_create_readonly();
    xpc_object_t v14 = readonly;
    if (readonly)
    {
      xpc_object_t v25 = readonly;
    }
    else
    {
      xpc_object_t v14 = xpc_null_create();
      xpc_object_t v25 = v14;
      if (!v14)
      {
        xpc_object_t v14 = 0;
        xpc_object_t v25 = xpc_null_create();
        goto LABEL_23;
      }
    }
    xpc_retain(v14);
LABEL_23:
    *(void *)buf = v11;
    *(void *)&buf[8] = "base";
    sub_100014D08((uint64_t)buf, &v25, &v26);
    xpc_release(v26);
    xpc_object_t v26 = 0;
    xpc_release(v25);
    xpc_object_t v25 = 0;
    xpc_release(v14);
  }
  unsigned int v15 = v30;
  sub_1000C7A34((uint64_t)a1, v30);
  uint64_t v18 = a1[27];
  xpc_object_t v17 = (uint64_t **)(a1 + 27);
  uint64_t v16 = v18;
  if (v18)
  {
    xpc_object_t v19 = v17;
    do
    {
      unsigned int v20 = *(_DWORD *)(v16 + 32);
      BOOL v21 = v20 >= v15;
      if (v20 >= v15) {
        xpc_object_t v22 = (uint64_t *)v16;
      }
      else {
        xpc_object_t v22 = (uint64_t *)(v16 + 8);
      }
      if (v21) {
        xpc_object_t v19 = (uint64_t **)v16;
      }
      uint64_t v16 = *v22;
    }
    while (*v22);
    if (v19 != v17 && v15 >= *((_DWORD *)v19 + 8))
    {
      *(void *)buf = &v30;
      sub_1000C9AB4(v17 - 1, &v30, (uint64_t)&unk_1001793E0, (_DWORD **)buf);
      *(void *)buf = &v30;
      sub_1000C9AB4(v17 - 1, &v30, (uint64_t)&unk_1001793E0, (_DWORD **)buf);
      xpc_object_t v23 = (xpc_object_t)xpc_shmem_create_readonly();
      if (!v23) {
        xpc_object_t v23 = xpc_null_create();
      }
      *(void *)buf = v11;
      *(void *)&buf[8] = "component";
      sub_100014D08((uint64_t)buf, &v23, &v24);
      xpc_release(v24);
      xpc_object_t v24 = 0;
      xpc_release(v23);
      xpc_object_t v23 = 0;
    }
  }
  if (v10) {
    sub_10000B678(v10);
  }
}

void sub_1000C7964(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10001F4A8(exception_object);
}

void sub_1000C7A34(uint64_t a1, unsigned int a2)
{
  unsigned int v38 = a2;
  uint64_t v2 = *(uint64_t **)(a1 + 216);
  if (!v2)
  {
LABEL_6:
    strcpy(v39, "/System/Library/WirelessInsights/Metadata");
    sub_10004E5F8(&v34.__pn_, v39);
    std::__fs::filesystem::directory_iterator::directory_iterator((std::__fs::filesystem::directory_iterator *)&__dst, &v34, 0, none);
    size = (std::__shared_weak_count *)__dst.__pn_.__r_.__value_.__l.__size_;
    xpc_object_t v6 = (std::shared_ptr<std::__fs::filesystem::__dir_stream>::element_type *)__dst.__pn_.__r_.__value_.__r.__words[0];
    *(_OWORD *)&__dst.__pn_.__r_.__value_.__l.__data_ = 0uLL;
    if (SHIBYTE(v34.__pn_.__r_.__value_.__r.__words[2]) < 0)
    {
      xpc_object_t v7 = size;
      operator delete(v34.__pn_.__r_.__value_.__l.__data_);
      size = v7;
    }
    xpc_object_t v26 = size;
    if (size)
    {
      atomic_fetch_add_explicit(&size->__shared_owners_, 1uLL, memory_order_relaxed);
      v37.__imp_.__ptr_ = v6;
      v37.__imp_.__cntrl_ = size;
      atomic_fetch_add_explicit(&size->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10000B678(size);
    }
    else
    {
      v37.__imp_.__ptr_ = v6;
      v37.__imp_.__cntrl_ = 0;
    }
    while (1)
    {
      if (!v37.__imp_.__ptr_)
      {
        if (v37.__imp_.__cntrl_) {
          sub_10000B678(v37.__imp_.__cntrl_);
        }
        if (v26) {
          sub_10000B678(v26);
        }
        return;
      }
      CFStringRef v8 = std::__fs::filesystem::directory_iterator::__dereference(&v37);
      std::__fs::filesystem::__status(&v8->__p_, 0);
      if (v34.__pn_.__r_.__value_.__s.__data_[0] == 1) {
        break;
      }
LABEL_60:
      std::__fs::filesystem::directory_iterator::__increment(&v37, 0);
    }
    sub_100002260((uint64_t)&v34);
    xpc_object_t v9 = sub_100004D64(&v34, (uint64_t)"-0x", 3);
    *(_DWORD *)((char *)v9 + *(void *)(*v9 - 24) + 8) = *(_DWORD *)((unsigned char *)v9 + *(void *)(*v9 - 24) + 8) & 0xFFFFFFB5 | 8;
    uint64_t v10 = (void *)std::ostream::operator<<();
    sub_100004D64(v10, (uint64_t)"-", 1);
    if (SHIBYTE(v8->__p_.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      sub_1000173FC(&__dst, v8->__p_.__pn_.__r_.__value_.__l.__data_, v8->__p_.__pn_.__r_.__value_.__l.__size_);
    }
    else {
      std::__fs::filesystem::path __dst = v8->__p_;
    }
    sub_10004CD90(&__dst, (uint64_t)&__p);
    if (SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      sub_1000173FC(&v32, __p.__pn_.__r_.__value_.__l.__data_, __p.__pn_.__r_.__value_.__l.__size_);
    }
    else {
      std::__fs::filesystem::path v32 = __p;
    }
    std::stringbuf::str();
    int64_t v11 = HIBYTE(v32.__pn_.__r_.__value_.__r.__words[2]);
    char v12 = HIBYTE(v32.__pn_.__r_.__value_.__r.__words[2]);
    if ((v32.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v13 = &v32;
    }
    else {
      uint64_t v13 = (std::__fs::filesystem::path *)v32.__pn_.__r_.__value_.__r.__words[0];
    }
    int v14 = (char)v30;
    unsigned int v15 = (void *)v29[0];
    if ((v30 & 0x80u) == 0) {
      uint64_t v16 = (char *)v29;
    }
    else {
      uint64_t v16 = (char *)v29[0];
    }
    if ((v30 & 0x80u) == 0) {
      int64_t v17 = v30;
    }
    else {
      int64_t v17 = v29[1];
    }
    if (v17)
    {
      if ((v32.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        int64_t v11 = v32.__pn_.__r_.__value_.__l.__size_;
      }
      uint64_t v18 = (char *)v13 + v11;
      if (v11 >= v17)
      {
        int v21 = *v16;
        xpc_object_t v22 = v13;
        do
        {
          int64_t v23 = v11 - v17;
          if (v23 == -1) {
            break;
          }
          xpc_object_t v24 = (char *)memchr(v22, v21, v23 + 1);
          if (!v24) {
            break;
          }
          xpc_object_t v19 = v24;
          if (!memcmp(v24, v16, v17)) {
            goto LABEL_34;
          }
          xpc_object_t v22 = (std::__fs::filesystem::path *)(v19 + 1);
          int64_t v11 = v18 - (v19 + 1);
        }
        while (v11 >= v17);
      }
      xpc_object_t v19 = v18;
LABEL_34:
      if (v19 == v18) {
        uint64_t v20 = -1;
      }
      else {
        uint64_t v20 = v19 - (char *)v13;
      }
      if ((v14 & 0x80000000) == 0)
      {
LABEL_38:
        if ((v12 & 0x80) == 0)
        {
LABEL_39:
          if (SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__pn_.__r_.__value_.__l.__data_);
          }
          if (v20 != -1)
          {
            if (SHIBYTE(__dst.__pn_.__r_.__value_.__r.__words[2]) < 0) {
              sub_1000173FC(&v32, __dst.__pn_.__r_.__value_.__l.__data_, __dst.__pn_.__r_.__value_.__l.__size_);
            }
            else {
              std::__fs::filesystem::path v32 = __dst;
            }
            operator new();
          }
          if ((*((unsigned char *)&__dst.__pn_.__r_.__value_.__s + 23) & 0x80) != 0) {
            operator delete(__dst.__pn_.__r_.__value_.__l.__data_);
          }
          v34.__pn_.__r_.__value_.__r.__words[0] = v28;
          *(std::string::size_type *)((char *)v34.__pn_.__r_.__value_.__r.__words + *(void *)(v28 - 24)) = v27;
          if (v36 < 0) {
            operator delete(v35);
          }
          std::streambuf::~streambuf();
          std::ostream::~ostream();
          std::ios::~ios();
          goto LABEL_60;
        }
LABEL_46:
        operator delete(v32.__pn_.__r_.__value_.__l.__data_);
        goto LABEL_39;
      }
    }
    else
    {
      uint64_t v20 = 0;
      if (((char)v30 & 0x80000000) == 0) {
        goto LABEL_38;
      }
    }
    operator delete(v15);
    if ((*((unsigned char *)&v32.__pn_.__r_.__value_.__s + 23) & 0x80) == 0) {
      goto LABEL_39;
    }
    goto LABEL_46;
  }
  while (1)
  {
    unsigned int v4 = *((_DWORD *)v2 + 8);
    if (v4 <= a2) {
      break;
    }
LABEL_5:
    uint64_t v2 = (uint64_t *)*v2;
    if (!v2) {
      goto LABEL_6;
    }
  }
  if (v4 < a2)
  {
    ++v2;
    goto LABEL_5;
  }
  xpc_object_t v25 = *(NSObject **)(a1 + 80);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
    sub_100149464(a2, v25);
  }
}

void sub_1000C7F3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a43 < 0) {
    operator delete(__p);
  }
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    uint64_t v47 = *(NSObject **)(v43 + 80);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      sub_1001493E8((int *)(v44 - 152), v47);
    }
    __cxa_end_catch();
    JUMPOUT(0x1000C7EDCLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000C8078(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 136);
  sub_1000C60B8(a1, v3);
  if (v3[0]) {
    uint64_t v2 = v3[0] + 72;
  }
  else {
    uint64_t v2 = 0;
  }
  v4[0] = v2;
  v4[1] = v3[1];
  sub_100054624(v1, (uint64_t)v4);
}

void sub_1000C80D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10000B678(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000C80EC(uint64_t a1)
{
  sub_1000C60B8(a1, &v8);
  uint64_t v3 = v8;
  uint64_t v2 = v9;
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10000B678(v2);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 1174405120;
  aBlock[2] = sub_1000058EC;
  aBlock[3] = &unk_1001BB7F8;
  aBlock[4] = a1;
  aBlock[5] = v3;
  xpc_object_t v7 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v4 = _Block_copy(aBlock);
  unsigned int v5 = *(const void **)(a1 + 192);
  *(void *)(a1 + 192) = v4;
  if (v5) {
    _Block_release(v5);
  }
  sub_1000C66C0((dispatch_queue_t *)a1);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_1000C81DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000C8204(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1000C8220(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1000C8230(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 80);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "conn:#N Closing connection listener port", buf, 2u);
  }
  xpc_object_t object = xpc_null_create();
  ctu::XpcServer::setListener_sync();
  xpc_release(object);
}

void sub_1000C82B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

void sub_1000C82D0(uint64_t a1, uint64_t a2, NSObject **a3)
{
  sub_100123D48(a3, &object);
  sub_1000C60B8(a1, &v12);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  v9[2] = sub_1000C85CC;
  v9[3] = &unk_1001BB828;
  uint64_t v6 = v12;
  unsigned int v5 = v13;
  void v9[4] = a1;
  void v9[5] = v12;
  uint64_t v10 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_group_t group = object;
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(group);
  }
  sub_10000BA54(&v15, (void *)(a1 + 8));
  xpc_object_t v7 = *(NSObject **)(a1 + 24);
  block = _NSConcreteStackBlock;
  uint64_t v18 = 1174405120;
  xpc_object_t v19 = sub_1000C9B78;
  uint64_t v20 = &unk_1001BBA70;
  uint64_t v22 = v15;
  int64_t v23 = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v21 = v9;
  dispatch_async(v7, &block);
  if (v23) {
    sub_10000B678(v23);
  }
  if (v16) {
    sub_10000B678(v16);
  }
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_1000C86F8;
  v8[3] = &unk_1001BB888;
  v8[4] = a1;
  block = _NSConcreteStackBlock;
  uint64_t v18 = 1174405120;
  xpc_object_t v19 = sub_1000C9BB4;
  uint64_t v20 = &unk_1001BBAA8;
  uint64_t v22 = v6;
  int64_t v23 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v21 = v8;
  sub_100123EA0((uint64_t)a3, (NSObject **)(v6 + 24), (uint64_t)&block);
  if (v23) {
    sub_10000B678(v23);
  }
  if (v5) {
    sub_10000B678(v5);
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if (v10) {
    sub_10000B678(v10);
  }
  if (v5) {
    sub_10000B678(v5);
  }
  if (object)
  {
    dispatch_group_leave(object);
    if (object) {
      dispatch_release(object);
    }
  }
}

void sub_1000C8554(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,dispatch_group_t group,uint64_t a23,uint64_t a24,dispatch_group_t object)
{
  std::string::size_type v28 = *(std::__shared_weak_count **)(v26 - 72);
  if (v28) {
    sub_10000B678(v28);
  }
  if (v25) {
    sub_10000B678(v25);
  }
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  if (a21) {
    sub_10000B678(a21);
  }
  if (v25) {
    sub_10000B678(v25);
  }
  if (object)
  {
    dispatch_group_leave(object);
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000C85CC(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 32) + 80);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "conn:#N Flush of all incoming requests complete.", v2, 2u);
  }
}

void sub_1000C8630(void *a1, void *a2)
{
  uint64_t v3 = a2[6];
  a1[5] = a2[5];
  a1[6] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  unsigned int v4 = a2[7];
  a1[7] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    unsigned int v5 = a1[7];
    if (v5)
    {
      dispatch_group_enter(v5);
    }
  }
}

void sub_1000C869C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 56);
    if (v3) {
      dispatch_release(v3);
    }
  }
  unsigned int v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    sub_10000B678(v4);
  }
}

void sub_1000C86F8(uint64_t a1, NSObject **a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  sub_1000C8230(v3);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  v6[2] = sub_1000C8848;
  v6[3] = &unk_1001BB858;
  unsigned int v4 = *a2;
  v6[4] = v3;
  dispatch_group_t group = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(group);
  }
  sub_10000BA54(&v10, (void *)(v3 + 8));
  unsigned int v5 = *(NSObject **)(v3 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000C9B78;
  block[3] = &unk_1001BBA70;
  void block[5] = v10;
  xpc_object_t v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v9) {
    sub_10000B678(v9);
  }
  if (v11) {
    sub_10000B678(v11);
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
}

void sub_1000C8848(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 32) + 80);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "conn:#N ConnectionManager closed all XPC services", v2, 2u);
  }
}

void sub_1000C88AC(uint64_t a1, int a2, uint64_t a3)
{
  if (a2 == 2)
  {
    sub_1000C60B8(a1, &v8);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    _DWORD v7[2] = sub_1000C89DC;
    v7[3] = &unk_1001BB8A8;
    void v7[4] = a1;
    unsigned int v5 = v9;
    uint64_t v6 = (NSObject **)(v8 + 24);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 1174405120;
    v10[2] = sub_1000C9BB4;
    v10[3] = &unk_1001BBAA8;
    v10[5] = v8;
    int64_t v11 = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v10[4] = v7;
    sub_100123EA0(a3, v6, (uint64_t)v10);
    if (v11) {
      sub_10000B678(v11);
    }
    if (v5) {
      sub_10000B678(v5);
    }
  }
}

void sub_1000C89B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    sub_10000B678(a22);
  }
  if (v22) {
    sub_10000B678(v22);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000C89DC(uint64_t a1)
{
}

void sub_1000C89E4(uint64_t a1, uint64_t a2, xpc_object_t *a3)
{
  if (*a3) {
    xpc_retain(*a3);
  }
  else {
    xpc_null_create();
  }
  sub_10000BA54(&v4, (void *)(a1 + 8));
  operator new();
}

void sub_1000C8B04(uint64_t a1, uint64_t a2, xpc_object_t *a3)
{
}

void sub_1000C8B10(uint64_t a1)
{
  sub_1000C8BE0(a1);

  operator delete();
}

void sub_1000C8B48(uint64_t a1)
{
}

void sub_1000C8B50(uint64_t a1)
{
  sub_1000C8BE0(a1 - 72);

  operator delete();
}

void **sub_1000C8B90(void **a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  *a2 = xpc_null_create();
  uint64_t v4 = *a1;
  *a1 = v3;
  xpc_release(v4);
  return a1;
}

void sub_1000C8BE0(uint64_t a1)
{
  *(void *)a1 = off_1001BB740;
  uint64_t v2 = a1 + 72;
  *(void *)(a1 + 72) = off_1001BB780;
  sub_1000C8CD0(a1 + 208, *(void **)(a1 + 216));
  sub_1000C90E0((uint64_t *)(a1 + 200), 0);
  xpc_object_t v3 = *(const void **)(a1 + 192);
  if (v3) {
    _Block_release(v3);
  }
  xpc_object_t v9 = (void **)(a1 + 168);
  sub_1000C8D30(&v9);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 160);
  if (v4) {
    sub_10000B678(v4);
  }
  unsigned int v5 = *(std::__shared_weak_count **)(a1 + 144);
  if (v5) {
    sub_10000B678(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 128);
  if (v6) {
    sub_10000B678(v6);
  }
  xpc_object_t v7 = *(std::__shared_weak_count **)(a1 + 112);
  if (v7) {
    sub_10000B678(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 96);
  if (v8) {
    sub_10000B678(v8);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 80));
  nullsub_15(v2);
  ctu::XpcServer::~XpcServer((ctu::XpcServer *)a1);
}

void sub_1000C8CD0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1000C8CD0(a1, *a2);
    sub_1000C8CD0(a1, a2[1]);
    sub_1000C90E0(a2 + 5, 0);
    operator delete(a2);
  }
}

void sub_1000C8D30(void ***a1)
{
  uint64_t v2 = (uint64_t *)*a1;
  if (*v2)
  {
    sub_1000C8D84((uint64_t)v2, *v2);
    xpc_object_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_1000C8D84(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 != a2)
  {
    uint64_t v5 = *(void *)(a1 + 8);
    do
    {
      uint64_t v6 = *(void **)(v5 - 8);
      v5 -= 8;
      xpc_release(v6);
      *(void *)(v4 - 8) = 0;
      uint64_t v4 = v5;
    }
    while (v5 != a2);
  }
  *(void *)(a1 + 8) = a2;
}

void sub_1000C8DE0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1000C8E60(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1000C8F38);
  __cxa_rethrow();
}

void sub_1000C8E88(_Unwind_Exception *a1)
{
}

void sub_1000C8EA0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1000C8ED8(uint64_t a1)
{
}

uint64_t sub_1000C8EF4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1000C8F38(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

void sub_1000C8F64(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1;
  xpc_object_t v3 = v1;
  sub_1000C8078(*v1);
}

void sub_1000C8FA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *sub_1000C8FC4(void *a1)
{
  *a1 = off_1001BB990;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10000B678(v2);
  }
  return a1;
}

void sub_1000C9010(void *a1)
{
  *a1 = off_1001BB990;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10000B678(v1);
  }

  operator delete();
}

void *sub_1000C907C@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "ConnectionManager");
}

unsigned char *sub_1000C908C@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 1;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1000C90CC(uint64_t a1, uint64_t a2, NSObject **a3)
{
}

void sub_1000C90D8(uint64_t a1, int a2, uint64_t a3)
{
}

uint64_t sub_1000C90E0(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1000C9130(result);
    operator delete();
  }
  return result;
}

uint64_t sub_1000C9130(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2 != (void *)-1)
  {
    munmap(v2, *(void *)(a1 + 16));
    *(void *)(a1 + 8) = -1;
  }
  if (*(void *)a1)
  {
    fclose(*(FILE **)a1);
    *(void *)a1 = 0;
  }
  return a1;
}

xpc_object_t sub_1000C9184(uint64_t a1, void **a2, void **a3)
{
  xpc_object_t v3 = *a3;
  *a2 = *a3;
  if (v3) {
    return xpc_retain(v3);
  }
  xpc_object_t result = xpc_null_create();
  *a2 = result;
  return result;
}

uint64_t sub_1000C91C4(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000C923C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1000C923C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v17 = a6;
  *((void *)&v17 + 1) = a7;
  long long v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  _OWORD v14[2] = &v17;
  char v15 = 0;
  if (a3 == a5)
  {
    uint64_t v12 = a6;
  }
  else
  {
    uint64_t v9 = a3;
    uint64_t v10 = a3;
    do
    {
      uint64_t v11 = *(void *)(v10 - 8);
      v10 -= 8;
      *(void *)(v7 - 8) = v11;
      *(void *)(v9 - 8) = xpc_null_create();
      uint64_t v7 = *((void *)&v17 + 1) - 8;
      *((void *)&v17 + 1) -= 8;
      uint64_t v9 = v10;
    }
    while (v10 != a5);
    uint64_t v12 = v17;
  }
  char v15 = 1;
  sub_1000C92F0((uint64_t)v14);
  return v12;
}

uint64_t sub_1000C92F0(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1000C9328((uint64_t *)a1);
  }
  return a1;
}

void sub_1000C9328(uint64_t *a1)
{
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v14 = v3;
  uint64_t v15 = v2;
  uint64_t v16 = v3;
  uint64_t v17 = v2;
  uint64_t v4 = *a1;
  uint64_t v5 = (uint64_t *)a1[1];
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  uint64_t v9 = v7;
  uint64_t v10 = v6;
  uint64_t v11 = v7;
  uint64_t v12 = v6;
  sub_1000C93A0(v4, (uint64_t)v13, (uint64_t)v8);
}

void sub_1000C93A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (i = *(xpc_object_t **)(a2 + 32); i != *(xpc_object_t **)(a3 + 32); *(void *)(a2 + 32) = i)
  {
    xpc_release(*i);
    xpc_object_t *i = 0;
    i = (xpc_object_t *)(*(void *)(a2 + 32) + 8);
  }
}

uint64_t sub_1000C9404(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1000C943C(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 16); i != a2; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v6 = *(void **)(i - 8);
    uint64_t v5 = (void *)(i - 8);
    *(void *)(a1 + 16) = v5;
    xpc_release(v6);
    *uint64_t v5 = 0;
  }
}

xpc_object_t *sub_1000C9494(uint64_t a1, xpc_object_t *a2, xpc_object_t *a3, void **a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      xpc_object_t v7 = *v5;
      *uint64_t v5 = xpc_null_create();
      uint64_t v8 = *a4;
      *a4 = v7;
      xpc_release(v8);
      ++v5;
      ++a4;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

uint64_t sub_1000C9508(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2) {
    sub_10000B678(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10000B678(v3);
  }
  return a1;
}

void *sub_1000C9560(void *a1)
{
  *a1 = off_1001BB9E8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10000B678(v2);
  }
  return a1;
}

void sub_1000C95AC(void *a1)
{
  *a1 = off_1001BB9E8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10000B678(v1);
  }

  operator delete();
}

char *sub_1000C9618(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1001BB9E8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1000C967C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1001BB9E8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1000C96BC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10000B678(v1);
  }
}

void sub_1000C96CC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10000B678(v2);
  }

  operator delete(__p);
}

void sub_1000C970C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  uint64_t v9 = *(void *)a2;
  long long v8 = *(_OWORD *)(a2 + 8);
  long long v10 = v8;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  uint64_t v4 = *(NSObject **)(*(void *)(a1 + 8) + 80);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v8 - v3) >> 3);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "conn:#I ConsolidateDeviceDiagnostics: returning %zd files", (uint8_t *)&buf, 0xCu);
  }
  xpc_object_t v5 = xpc_array_create(0, 0);
  xpc_object_t v6 = v5;
  if (v5)
  {
    xpc_object_t object = v5;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t object = v6;
    if (!v6)
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_10;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_retain(v6);
    goto LABEL_11;
  }
  xpc_object_t v7 = xpc_null_create();
LABEL_10:
  xpc_object_t object = v7;
LABEL_11:
  xpc_release(v6);
  sub_1000C9978((uint64_t)&v12, v9, v10, &object);
  xpc_object_t v11 = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_object_t v11 = xpc_null_create();
  }
  *(void *)&long long buf = *(void *)(a1 + 16);
  *((void *)&buf + 1) = "files";
  sub_10007A1B0((uint64_t)&buf, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_release(object);
  *(void *)&long long buf = &v9;
  sub_10002F868((void ***)&buf);
}

void sub_1000C98D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object, uint64_t a17)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10001F4A8(exception_object);
}

uint64_t sub_1000C992C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1000C996C()
{
}

uint64_t sub_1000C9978(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      xpc_object_t v7 = (const char *)v5;
      if (*(char *)(v5 + 23) < 0) {
        xpc_object_t v7 = *(const char **)v5;
      }
      xpc_object_t v8 = xpc_string_create(v7);
      if (!v8) {
        xpc_object_t v8 = xpc_null_create();
      }
      xpc_array_append_value(*a4, v8);
      xpc_release(v8);
      v5 += 24;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void sub_1000C9A08(_Unwind_Exception *a1)
{
  xpc_release(v1);
  _Unwind_Resume(a1);
}

FILE **sub_1000C9A24(FILE **a1, char *__filename)
{
  *a1 = 0;
  a1[1] = (FILE *)-1;
  a1[2] = 0;
  uint64_t v3 = fopen(__filename, "rb");
  *a1 = v3;
  if (v3)
  {
    int v4 = fileno(v3);
    if ((v4 & 0x80000000) == 0)
    {
      int v5 = v4;
      if (!fstat(v4, &v8))
      {
        off_t st_size = v8.st_size;
        a1[2] = (FILE *)v8.st_size;
        a1[1] = (FILE *)mmap(0, st_size, 1, 1025, v5, 0);
      }
    }
  }
  return a1;
}

uint64_t **sub_1000C9AB4(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  xpc_object_t v7 = a1 + 1;
  xpc_object_t v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        xpc_object_t v6 = *v9;
        xpc_object_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      xpc_object_t v6 = v9[1];
      if (!v6)
      {
        xpc_object_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    xpc_object_t v11 = operator new(0x30uLL);
    v11[8] = **a4;
    *((void *)v11 + 5) = 0;
    sub_10001716C(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t sub_1000C9B78(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000C9B88(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1000C9BA4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10000B678(v1);
  }
}

void sub_1000C9BB4(uint64_t a1, NSObject **a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  dispatch_group_t group = *a2;
  *a2 = 0;
  (*(void (**)(void))(v2 + 16))();
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
}

void sub_1000C9C10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000C9C34(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1000C9C50(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10000B678(v1);
  }
}

uint64_t *sub_1000C9C60(void **a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v6 = a1;
  xpc_object_t v7 = v1;
  uint64_t v3 = *(xpc_connection_t **)(*v1 + 168);
  uint64_t v2 = *(xpc_connection_t **)(*v1 + 176);
  if (v3 != v2)
  {
    while (*v3 != (xpc_connection_t)v1[1])
    {
      if (++v3 == v2) {
        goto LABEL_9;
      }
    }
  }
  if (v3 != v2)
  {
    int v4 = *(NSObject **)(*v1 + 80);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      xpc::object::to_string(v8, (xpc::object *)(v1 + 2));
      sub_1001494DC((char *)v8, buf, v4);
    }
    xpc_connection_send_message(*v3, (xpc_object_t)v1[2]);
  }
LABEL_9:
  sub_1000C9D68((uint64_t *)&v7);
  return sub_10000BA00((uint64_t *)&v6);
}

void sub_1000C9D44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14)
{
}

uint64_t *sub_1000C9D68(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    xpc_release(*(xpc_object_t *)(v1 + 16));
    *(void *)(v1 + 16) = 0;
    operator delete();
  }
  return result;
}

uint64_t sub_1000C9DC0()
{
  if ((byte_1001D69B8 & 1) == 0)
  {
    byte_1001D69B8 = 1;
    return __cxa_atexit((void (*)(void *))sub_100029800, &stru_1001D6968, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000C9DFC()
{
  if ((byte_1001D6A10 & 1) == 0)
  {
    byte_1001D6A10 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E5C, &stru_1001D69C0, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000C9E38()
{
  if ((byte_1001D6AC0 & 1) == 0)
  {
    byte_1001D6AC0 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E64, &stru_1001D6A70, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000C9E74()
{
  if ((byte_1001D6C78 & 1) == 0)
  {
    byte_1001D6C78 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E78, &stru_1001D6C28, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000C9EB0()
{
  if ((byte_1001D6E88 & 1) == 0)
  {
    byte_1001D6E88 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E90, &stru_1001D6E38, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000C9EEC()
{
  if ((byte_1001D6CD0 & 1) == 0)
  {
    byte_1001D6CD0 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E7C, &stru_1001D6C80, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000C9F28()
{
  if ((byte_1001D74C0 & 1) == 0)
  {
    byte_1001D74C0 = 1;
    return __cxa_atexit((void (*)(void *))sub_1000C8B8C, &stru_1001D7470, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000C9F64(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (const void *)_CTServerConnectionCreate();
  uint64_t v3 = _CTServerConnectionCopyTraceProperty();
  if (v3)
  {
    int v4 = *(NSObject **)(qword_1001D8080 + 112);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109634;
      *(_DWORD *)unsigned int v8 = v3;
      *(_WORD *)&v8[4] = 1024;
      *(_DWORD *)&v8[6] = HIDWORD(v3);
      __int16 v9 = 2112;
      id v10 = v1;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "WISABC:_CTServerConnectionCopyTraceProperty failed %d:%d for CTProperty: %@", buf, 0x18u);
    }
  }
  else
  {
    xpc_object_t v6 = *(NSObject **)(qword_1001D8080 + 112);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)unsigned int v8 = v1;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "WISABC:#I Couldn't get the enablement value for CTProperty: %@", buf, 0xCu);
    }
  }
  if (v2) {
    CFRelease(v2);
  }

  return 0;
}

void sub_1000CA184(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000CA1B0(uint64_t *a1)
{
  id v1 = a1;
  int v2 = *((char *)a1 + 23);
  if (v2 < 0)
  {
    if (a1[1] != 8) {
      goto LABEL_7;
    }
    uint64_t v3 = (void *)*a1;
  }
  else
  {
    uint64_t v3 = a1;
    if (v2 != 8) {
      goto LABEL_7;
    }
  }
  if (*v3 == 0x72616C756C6C6543 && *((unsigned char *)a1 + 96) && (sub_1000C9F64(@"BasebandTrace") & 1) == 0)
  {
    if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 112), OS_LOG_TYPE_DEBUG)) {
      sub_100149710();
    }
    return;
  }
LABEL_7:
  if (!*((unsigned char *)v1 + 97) || (sub_1000C9F64(@"CoreDump") & 1) != 0)
  {
    int v4 = v1;
    if (*((char *)v1 + 23) < 0) {
      int v4 = (void *)*v1;
    }
    int v5 = +[NSString stringWithUTF8String:v4];
    xpc_object_t v6 = v1 + 3;
    if (*((char *)v1 + 47) < 0) {
      xpc_object_t v6 = (void *)*v6;
    }
    xpc_object_t v7 = +[NSString stringWithUTF8String:v6];
    unsigned int v8 = v1 + 6;
    if (*((char *)v1 + 71) < 0) {
      unsigned int v8 = (void *)*v8;
    }
    __int16 v9 = +[NSString stringWithUTF8String:v8];
    id v10 = v1 + 9;
    if (*((char *)v1 + 95) < 0) {
      id v10 = (void *)*v10;
    }
    xpc_object_t v11 = +[NSString stringWithUTF8String:v10];
    sub_1000155F0(&__s1, (const void **)1);
    if ((char)v57 < 0)
    {
      if (__n != 4) {
        goto LABEL_26;
      }
      p_s1 = __s1;
    }
    else
    {
      if (v57 != 4) {
        goto LABEL_26;
      }
      p_s1 = &__s1;
    }
    if (*p_s1 == 1635018050)
    {
      id v13 = [objc_alloc((Class)NSUserDefaults) initWithSuiteName:@"com.apple.symptomsd-diag"];
      uint64_t v14 = [v13 valueForKey:@"autoFeedbackAssistantEnable"];
      unsigned __int8 v15 = [v14 BOOLValue];

      if ((v15 & 1) == 0)
      {
        if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 112), OS_LOG_TYPE_DEBUG)) {
          sub_1001496A8();
        }
        goto LABEL_107;
      }
    }
LABEL_26:
    id v16 = objc_alloc_init((Class)NSMutableDictionary);
    [v16 setObject:&__kCFBooleanTrue forKey:kSymptomDiagnosticActionLogArchive];
    [v16 setObject:&__kCFBooleanTrue forKey:kSymptomDiagnosticActionGetNetworkInfo];
    [v16 setObject:&__kCFBooleanTrue forKey:kSymptomDiagnosticActionCrashAndSpinLogs];
    uint64_t v17 = kSymptomDiagnosticActionDiagnosticExtensions;
    [v16 setObject:&__kCFBooleanFalse forKey:kSymptomDiagnosticActionDiagnosticExtensions];
    if (*((char *)v1 + 23) < 0)
    {
      uint64_t v19 = v1[1];
      if (v19 != 8 || *(void *)*v1 != 0x72616C756C6C6543)
      {
        if (v19 != 9) {
          goto LABEL_101;
        }
        id v1 = (uint64_t *)*v1;
LABEL_34:
        if (*v1 != 0x6E6F6870656C6554 || *((unsigned char *)v1 + 8) != 121) {
          goto LABEL_101;
        }
        size_t v21 = v57;
        if ((v57 & 0x80u) != 0) {
          size_t v21 = __n;
        }
        if (!v21) {
          goto LABEL_101;
        }
        long long v58 = 0uLL;
        uint64_t v59 = 0;
        ctu::cf::assign();
        uint64_t v54 = v59;
        *(_OWORD *)BOOL v53 = v58;
        uint64_t v22 = v57;
        if ((v57 & 0x80u) == 0) {
          size_t v23 = v57;
        }
        else {
          size_t v23 = __n;
        }
        xpc_object_t v24 = (void *)HIBYTE(v54);
        int v25 = SHIBYTE(v54);
        if (v54 < 0) {
          xpc_object_t v24 = v53[1];
        }
        if ((void *)v23 == v24)
        {
          if (v54 >= 0) {
            uint64_t v26 = v53;
          }
          else {
            uint64_t v26 = (void **)v53[0];
          }
          if ((v57 & 0x80) != 0)
          {
            if (memcmp(__s1, v26, __n)) {
              goto LABEL_72;
            }
          }
          else if (v57)
          {
            std::string::size_type v27 = &__s1;
            while (*(unsigned __int8 *)v27 == *(unsigned __int8 *)v26)
            {
              std::string::size_type v27 = (void **)((char *)v27 + 1);
              uint64_t v26 = (void **)((char *)v26 + 1);
              if (!--v22) {
                goto LABEL_91;
              }
            }
            goto LABEL_72;
          }
LABEL_91:
          BOOL v45 = 1;
          if ((v25 & 0x80000000) == 0) {
            goto LABEL_97;
          }
          goto LABEL_100;
        }
LABEL_72:
        long long v58 = 0uLL;
        uint64_t v59 = 0;
        ctu::cf::assign();
        uint64_t v52 = v59;
        *(_OWORD *)std::__fs::filesystem::path __p = v58;
        if ((v57 & 0x80u) == 0) {
          size_t v33 = v57;
        }
        else {
          size_t v33 = __n;
        }
        std::__fs::filesystem::path v34 = (void *)HIBYTE(v52);
        int v35 = SHIBYTE(v52);
        if (v52 < 0) {
          std::__fs::filesystem::path v34 = __p[1];
        }
        if ((void *)v33 == v34)
        {
          if (v52 >= 0) {
            char v36 = __p;
          }
          else {
            char v36 = (void **)__p[0];
          }
          if ((v57 & 0x80) != 0)
          {
            BOOL v45 = memcmp(__s1, v36, __n) == 0;
          }
          else if (v57)
          {
            uint64_t v37 = v57 - 1;
            unsigned int v38 = &__s1;
            do
            {
              int v40 = *(unsigned __int8 *)v38;
              unsigned int v38 = (void **)((char *)v38 + 1);
              int v39 = v40;
              int v42 = *(unsigned __int8 *)v36;
              char v36 = (void **)((char *)v36 + 1);
              int v41 = v42;
              BOOL v44 = v37-- != 0;
              BOOL v45 = v39 == v41;
            }
            while (v39 == v41 && v44);
          }
          else
          {
            BOOL v45 = 1;
          }
        }
        else
        {
          BOOL v45 = 0;
        }
        if (v35 < 0)
        {
          operator delete(__p[0]);
          if ((v25 & 0x80000000) == 0)
          {
LABEL_97:
            if (v45)
            {
LABEL_98:
              uint64_t v46 = +[NSString stringWithFormat:@"AutoBugCapture - Type: %@, SubType: %@", v7, v9];
              [v16 setObject:&__kCFBooleanTrue forKey:v17];
              uint64_t v64 = kSymptomDiagnosticKeyPayloadDEParameters;
              v61[1] = v46;
              CFStringRef v62 = @"com.apple.DiagnosticExtensions.Cellular";
              v60[0] = @"CellularExtensionCommandKey";
              v60[1] = @"CellularExtensionDumpReasonKey";
              v61[0] = @"dump_attach";
              uint64_t v47 = +[NSDictionary dictionaryWithObjects:v61 forKeys:v60 count:2];
              int v63 = v47;
              v48 = +[NSDictionary dictionaryWithObjects:&v63 forKeys:&v62 count:1];
              v65 = v48;
              std::__fs::filesystem::path v32 = +[NSDictionary dictionaryWithObjects:&v65 forKeys:&v64 count:1];

              goto LABEL_104;
            }
LABEL_101:
            if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 112), OS_LOG_TYPE_DEBUG)) {
              sub_100149674();
            }
            std::__fs::filesystem::path v32 = 0;
            goto LABEL_104;
          }
        }
        else if ((v25 & 0x80000000) == 0)
        {
          goto LABEL_97;
        }
LABEL_100:
        operator delete(v53[0]);
        if (v45) {
          goto LABEL_98;
        }
        goto LABEL_101;
      }
    }
    else
    {
      int v18 = *((unsigned __int8 *)v1 + 23);
      if (v18 != 8)
      {
        if (v18 != 9) {
          goto LABEL_101;
        }
        goto LABEL_34;
      }
      if (*v1 != 0x72616C756C6C6543) {
        goto LABEL_101;
      }
    }
    std::string::size_type v28 = +[NSString stringWithFormat:@"AutoBugCapture - Type: %@, SubType: %@", v7, v9];
    [v16 setObject:&__kCFBooleanTrue forKey:v17];
    if (*((unsigned char *)v1 + 99))
    {
      uint64_t v82 = kSymptomDiagnosticKeyPayloadDEParameters;
      v79[1] = v28;
      CFStringRef v80 = @"com.apple.DiagnosticExtensions.Cellular";
      v78[0] = @"CellularExtensionCommandKey";
      v78[1] = @"CellularExtensionDumpReasonKey";
      v79[0] = @"dumpWithBasebandReset";
      int v29 = +[NSDictionary dictionaryWithObjects:v79 forKeys:v78 count:2];
      v81 = v29;
      unsigned __int8 v30 = +[NSDictionary dictionaryWithObjects:&v81 forKeys:&v80 count:1];
      v83 = v30;
      uint64_t v31 = +[NSDictionary dictionaryWithObjects:&v83 forKeys:&v82 count:1];
    }
    else
    {
      if (*((unsigned char *)v1 + 98))
      {
        uint64_t v76 = kSymptomDiagnosticKeyPayloadDEParameters;
        v73[1] = v28;
        CFStringRef v74 = @"com.apple.DiagnosticExtensions.Cellular";
        v72[0] = @"CellularExtensionCommandKey";
        v72[1] = @"CellularExtensionDumpReasonKey";
        v73[0] = @"dump_attach";
        int v29 = +[NSDictionary dictionaryWithObjects:v73 forKeys:v72 count:2];
        uint64_t v75 = v29;
        unsigned __int8 v30 = +[NSDictionary dictionaryWithObjects:&v75 forKeys:&v74 count:1];
        uint64_t v77 = v30;
        +[NSDictionary dictionaryWithObjects:&v77 forKeys:&v76 count:1];
      }
      else
      {
        uint64_t v70 = kSymptomDiagnosticKeyPayloadDEParameters;
        v67[1] = v28;
        CFStringRef v68 = @"com.apple.DiagnosticExtensions.Cellular";
        v66[0] = @"CellularExtensionCommandKey";
        v66[1] = @"CellularExtensionDumpReasonKey";
        v67[0] = @"attach";
        int v29 = +[NSDictionary dictionaryWithObjects:v67 forKeys:v66 count:2];
        uint64_t v69 = v29;
        unsigned __int8 v30 = +[NSDictionary dictionaryWithObjects:&v69 forKeys:&v68 count:1];
        uint64_t v71 = v30;
        +[NSDictionary dictionaryWithObjects:&v71 forKeys:&v70 count:1];
      uint64_t v31 = };
    }
    std::__fs::filesystem::path v32 = (void *)v31;

LABEL_104:
    id v49 = objc_alloc_init((Class)SDRDiagnosticReporter);
    int v50 = [v49 signatureWithDomain:v5 type:v7 subType:v9 subtypeContext:v11 detectedProcess:@"wirelessinsightsd" triggerThresholdValues:0];
    if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 112), OS_LOG_TYPE_DEBUG)) {
      sub_100149640();
    }
    [v49 snapshotWithSignature:v50 delay:0 events:v32 payload:v16 actions:&stru_1001BBAF8 reply:600.0];

LABEL_107:
    if ((char)v57 < 0) {
      operator delete(__s1);
    }

    return;
  }
  if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 112), OS_LOG_TYPE_DEBUG)) {
    sub_1001496DC();
  }
}

void sub_1000CAAC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  unsigned int v38 = v35;

  if (a24 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1000CAC40(id a1, NSDictionary *a2)
{
  int v2 = a2;
  uint64_t v3 = [(NSDictionary *)v2 objectForKeyedSubscript:kSymptomDiagnosticReplySuccess];
  unsigned int v4 = [v3 BOOLValue];

  int v5 = *(NSObject **)(qword_1001D8080 + 112);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_INFO);
  if (v4)
  {
    if (v6)
    {
      LOWORD(v8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "WISABC:#I ABC case is submitted and accepted successfully", (uint8_t *)&v8, 2u);
    }
  }
  else if (v6)
  {
    xpc_object_t v7 = [(NSDictionary *)v2 objectForKey:kSymptomDiagnosticReplyReason];
    int v8 = 138412290;
    __int16 v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "WISABC:#I ABC case is rejected/dampened, SInt32 errorCode = %@", (uint8_t *)&v8, 0xCu);
  }
}

void sub_1000CAD70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000CAD98()
{
}

void sub_1000CB008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  pthread_mutex_unlock(&stru_1001D6968);
  if (a14) {
    sub_10000B678(a14);
  }
  id v16 = *(std::__shared_weak_count **)(v14 + 8);
  if (v16) {
    sub_10000B678(v16);
  }
  _Unwind_Resume(a1);
}

uint64_t **sub_1000CB0A4(uint64_t a1)
{
  return sub_1000CB0AC(*(void *)(a1 + 32));
}

uint64_t **sub_1000CB0AC(uint64_t a1)
{
  id v1 = (uint64_t **)(a1 + 48);
  unsigned int v7 = 458760;
  int v8 = &v7;
  int v2 = sub_1000CD448((uint64_t **)(a1 + 48), &v7, (uint64_t)&unk_1001793E0, &v8);
  v2[5] = (uint64_t *)sub_1000CB40C;
  v2[6] = 0;
  unsigned int v7 = 458759;
  int v8 = &v7;
  uint64_t v3 = sub_1000CD448(v1, &v7, (uint64_t)&unk_1001793E0, &v8);
  v3[5] = (uint64_t *)sub_1000CB520;
  v3[6] = 0;
  unsigned int v7 = 458768;
  int v8 = &v7;
  unsigned int v4 = sub_1000CD448(v1, &v7, (uint64_t)&unk_1001793E0, &v8);
  v4[5] = (uint64_t *)sub_1000CB634;
  v4[6] = 0;
  unsigned int v7 = 458758;
  int v8 = &v7;
  int v5 = sub_1000CD448(v1, &v7, (uint64_t)&unk_1001793E0, &v8);
  v5[5] = (uint64_t *)sub_1000CB754;
  void v5[6] = 0;
  int v8 = &dword_100179160;
  uint64_t result = sub_1000CD448(v1, &dword_100179160, (uint64_t)&unk_1001793E0, &v8);
  result[5] = (uint64_t *)sub_1000CB8FC;
  result[6] = 0;
  return result;
}

uint64_t sub_1000CB200(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1000CB21C(uint64_t a1)
{
  id v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10000B678(v1);
  }
}

void *sub_1000CB22C(void *a1)
{
  sub_1000CB2BC(a1 + 1, "TriggerMap", QOS_CLASS_DEFAULT, "trig");
  *a1 = &off_1001BBB58;
  a1[7] = 0;
  a1[6] = a1 + 7;
  a1[11] = 0;
  a1[10] = 0;
  a1[8] = 0;
  a1[9] = a1 + 10;
  dispatch_queue_t v2 = dispatch_queue_create("fQueriableMetricQueue", 0);
  a1[13] = 0;
  a1[14] = 0;
  a1[12] = v2;
  return a1;
}

void *sub_1000CB2BC(void *a1, const char *a2, dispatch_qos_class_t a3, const char *a4)
{
  dispatch_object_t object = 0;
  sub_10002A670(a1, a2, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), "com.apple.wis.wirelessinsightsd", a4);
  return a1;
}

void sub_1000CB31C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  sub_100029804(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_1000CB344(uint64_t a1)
{
  *(void *)a1 = &off_1001BBB58;
  dispatch_queue_t v2 = *(std::__shared_weak_count **)(a1 + 112);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(NSObject **)(a1 + 96);
  if (v3) {
    dispatch_release(v3);
  }
  sub_1000CD384(a1 + 72, *(void **)(a1 + 80));
  sub_10004B7F8(a1 + 48, *(void **)(a1 + 56));
  nullsub_15(a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100029804((void *)(a1 + 8));
  return a1;
}

void sub_1000CB3D4(uint64_t a1)
{
  sub_1000CB344(a1);

  operator delete();
}

void sub_1000CB40C(void *a1, uint64_t a2, unsigned int a3, const wireless_diagnostics::google::protobuf::MessageLite *a4, uint64_t a5)
{
  id v10 = a1[5];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 67109120;
    int v15 = HIDWORD(a2);
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "trig:#I Submit startup metric for trigger 0x%x", buf, 8u);
  }
  xpc_object_t v11 = (std::__shared_weak_count *)a1[14];
  uint64_t v12 = a1[13];
  id v13 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10005F6C8(&v12, a2, a3, a4, a5);
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
}

void sub_1000CB508(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000CB520(void *a1, uint64_t a2, unsigned int a3, const wireless_diagnostics::google::protobuf::MessageLite *a4, uint64_t a5)
{
  id v10 = a1[5];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 67109120;
    int v15 = HIDWORD(a2);
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "trig:#I Submit shutdown metric for trigger 0x%x", buf, 8u);
  }
  xpc_object_t v11 = (std::__shared_weak_count *)a1[14];
  uint64_t v12 = a1[13];
  id v13 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10005F874(&v12, a2, a3, a4, a5);
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
}

void sub_1000CB61C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000CB634(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v5 = HIDWORD(a2);
  unsigned int v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 67109376;
    int v11 = a4;
    __int16 v12 = 1024;
    int v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "trig:#I Submit battery level change metric for metric 0x%x triggered because of trigger 0x%x", buf, 0xEu);
  }
  int v8 = *(std::__shared_weak_count **)(a1 + 112);
  __int16 v9 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10009ED60();
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
}

void sub_1000CB73C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000CB754(uint64_t a1, uint64_t a2, unsigned int a3, const wireless_diagnostics::google::protobuf::MessageLite *a4, uint64_t a5)
{
  __int16 v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    v12[0] = 67109376;
    v12[1] = (int)a4;
    __int16 v13 = 1024;
    int v14 = HIDWORD(a2);
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "trig:#I Submit location's diagnostics allowed (0x%x) triggered because of trigger 0x%x", (uint8_t *)v12, 0xEu);
  }
  pthread_mutex_lock(&stru_1001D6C80);
  uint64_t v10 = xmmword_1001D6CC0;
  if (!(void)xmmword_1001D6CC0) {
    sub_1000B14D8();
  }
  int v11 = (std::__shared_weak_count *)*((void *)&xmmword_1001D6CC0 + 1);
  if (*((void *)&xmmword_1001D6CC0 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6CC0 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_1001D6C80);
  sub_1000B271C(v10, a2, a3, a4, a5);
  if (v11) {
    sub_10000B678(v11);
  }
}

void sub_1000CB8B4(_Unwind_Exception *a1)
{
}

void sub_1000CB8FC(void *a1, uint64_t a2, unsigned int a3, const PB::Base *a4, uint64_t a5)
{
  uint64_t v10 = a1[5];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = a4;
    LOWORD(v38) = 1024;
    *(_DWORD *)((char *)&v38 + 2) = HIDWORD(a2);
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "trig:#I Query aggregation (0x%x) for trigger 0x%x", buf, 0xEu);
  }
  int v11 = (std::__shared_weak_count *)a1[14];
  if (v11)
  {
    __int16 v12 = std::__shared_weak_count::lock(v11);
    if (v12)
    {
      __int16 v13 = v12;
      uint64_t v14 = a1[13];
      if (v14)
      {
        int v15 = (wis *)sub_10005E9D4((uint64_t)buf);
        WISTimestamp = (std::string *)wis::getWISTimestamp(v15);
        v44 |= 0x40u;
        v41[3] = WISTimestamp;
        pthread_mutex_lock(&stru_1001D69C0);
        uint64_t v17 = xmmword_1001D6A00;
        if (!(void)xmmword_1001D6A00) {
          sub_1000781CC();
        }
        int v18 = (std::__shared_weak_count *)*((void *)&xmmword_1001D6A00 + 1);
        if (*((void *)&xmmword_1001D6A00 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6A00 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        pthread_mutex_unlock(&stru_1001D69C0);
        sub_1000A5E40(v17, (int)a4, &__str);
        if (v18) {
          sub_10000B678(v18);
        }
        sub_1000CD03C((uint64_t)buf);
        std::string::operator=(v41[0], &__str);
        __int16 v20 = v44;
        v44 |= 3u;
        uint64_t v38 = v30;
        uint64_t v39 = v34;
        if (v30)
        {
          if (v35)
          {
            __int16 v21 = v20 | 0x83;
            char v42 = 1;
          }
          else
          {
            __int16 v21 = v20 | 0x13;
            v41[1] = v31;
          }
          if (v36)
          {
            __int16 v22 = v21 | 0x100;
            char v43 = 1;
          }
          else
          {
            __int16 v22 = v21 | 0x20;
            v41[2] = v32;
          }
          __int16 v44 = v22 | 0xC;
          int8x16_t v40 = vextq_s8(v33, v33, 8uLL);
        }
        wis::serializeMetric((uint64_t *)&v27, (wis *)buf, a4, v19);
        size_t v23 = (char *)operator new(0x30uLL);
        *((void *)v23 + 1) = 0;
        *((void *)v23 + 2) = 0;
        *(_OWORD *)(v23 + 24) = v27;
        *(void *)size_t v23 = off_1001B6FF8;
        *((void *)v23 + 5) = v28;
        int v25 = v23 + 24;
        uint64_t v26 = (std::__shared_weak_count *)v23;
        atomic_fetch_add_explicit((atomic_ullong *volatile)v23 + 1, 1uLL, memory_order_relaxed);
        (*(void (**)(uint64_t, const PB::Base *, uint64_t, uint64_t, void, uint64_t, char **))(*(void *)v14 + 24))(v14, a4, a5, a2, a3, 7, &v25);
        if (v26) {
          sub_10000B678(v26);
        }
        sub_10000B678((std::__shared_weak_count *)v23);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        xpc_object_t v24 = v41[0];
        *(void *)long long buf = off_1001B7688;
        v41[0] = 0;
        if (v24) {
          sub_10005F658((uint64_t)v41, (uint64_t)v24);
        }
        PB::Base::~Base((PB::Base *)buf);
      }
      sub_10000B678(v13);
    }
  }
}

void sub_1000CBC48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  pthread_mutex_unlock(&stru_1001D69C0);
  sub_10005F584((PB::Base *)&a28);
  sub_10000B678(v28);
  _Unwind_Resume(a1);
}

void sub_1000CBCFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_10000BA54(&v5, (void *)(a1 + 8));
  unsigned int v4 = (NSObject **)(v5 + 24);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 1174405120;
  _DWORD v7[2] = sub_1000CD50C;
  v7[3] = &unk_1001BBDA0;
  void v7[5] = v5;
  int v8 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void v7[4] = &stru_1001BBB90;
  sub_100123D98(a3, v4, (uint64_t)v7);
  if (v8) {
    sub_10000B678(v8);
  }
  if (v6) {
    sub_10000B678(v6);
  }
}

void sub_1000CBDC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10000B678(a18);
  }
  if (a11) {
    sub_10000B678(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000CBDEC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  sub_10000BA54(&v3, (void *)(a1 + 8));
  operator new();
}

void sub_1000CBF04(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    int v6 = *(_DWORD *)(a2 + 16);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "trig:#I TriggerMap::setConfiguration: parsing %d profiles", buf, 8u);
  }
  uint64_t v7 = *(int *)(a2 + 16);
  if (v7)
  {
    int v8 = *(uint64_t **)(a2 + 8);
    __int16 v9 = &v8[v7];
    int v50 = v9;
    do
    {
      uint64_t v10 = *v8;
      int v11 = *(_DWORD *)(*v8 + 132);
      if (v11)
      {
        int v16 = *(_DWORD *)(v10 + 8);
        if ((v11 & 8) != 0)
        {
          uint64_t v52 = v8;
          uint64_t v18 = *(int *)(v10 + 64);
          unsigned int v55 = *(_DWORD *)(v10 + 32);
          uint64_t v19 = *(int *)(v10 + 48);
          if (!v19)
          {
LABEL_60:
            if (a3) {
              sub_1000CC374();
            }
            int v8 = v52;
            __int16 v9 = v50;
            goto LABEL_63;
          }
          __int16 v20 = *(uint64_t **)(v10 + 40);
          BOOL v53 = &v20[v19];
          while (2)
          {
            uint64_t v21 = *v20;
            if (v18 <= *(int *)(*v20 + 36)) {
              uint64_t v18 = *(int *)(*v20 + 36);
            }
            if ((*(unsigned char *)(v21 + 132) & 1) == 0)
            {
              __int16 v22 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "trig:#E Got metric definition with no id", buf, 2u);
              }
              goto LABEL_59;
            }
            unsigned int v54 = *(_DWORD *)(v21 + 8);
            *(void *)long long buf = &v55;
            size_t v23 = sub_1000CD5C8((uint64_t **)(a1 + 72), &v55, (uint64_t)&unk_1001793E0, (_DWORD **)buf);
            *(void *)long long buf = &v54;
            xpc_object_t v24 = sub_1000CD698(v23 + 5, &v54, (uint64_t)&unk_1001793E0, (_DWORD **)buf);
            int v25 = v24;
            uint64_t v26 = (char *)v24[6];
            uint64_t v27 = (uint64_t)(v24 + 7);
            uint64_t v28 = v24[7];
            if (v26 >= (char *)v28)
            {
              xpc_object_t v24 = (uint64_t **)v24[5];
              uint64_t v30 = (v26 - (char *)v24) >> 2;
              if ((unint64_t)(v30 + 1) >> 62) {
                sub_10002B5E0();
              }
              unint64_t v31 = (char *)v28 - (char *)v24;
              unint64_t v32 = ((char *)v28 - (char *)v24) >> 1;
              if (v32 <= v30 + 1) {
                unint64_t v32 = v30 + 1;
              }
              if (v31 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v33 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v33 = v32;
              }
              if (v33)
              {
                uint64_t v34 = (char *)sub_10001E460(v27, v33);
                xpc_object_t v24 = (uint64_t **)v25[5];
                uint64_t v26 = (char *)v25[6];
              }
              else
              {
                uint64_t v34 = 0;
              }
              char v35 = &v34[4 * v30];
              *(_DWORD *)char v35 = v16;
              int v29 = (uint64_t *)(v35 + 4);
              while (v26 != (char *)v24)
              {
                int v36 = *((_DWORD *)v26 - 1);
                v26 -= 4;
                *((_DWORD *)v35 - 1) = v36;
                v35 -= 4;
              }
              v25[5] = (uint64_t *)v35;
              v25[6] = v29;
              v25[7] = (uint64_t *)&v34[4 * v33];
              if (v24) {
                operator delete(v24);
              }
            }
            else
            {
              *(_DWORD *)uint64_t v26 = v16;
              int v29 = (uint64_t *)(v26 + 4);
            }
            v25[6] = v29;
            uint64_t v37 = *(int *)(v21 + 104);
            if (!v37)
            {
LABEL_59:
              if (++v20 == v53) {
                goto LABEL_60;
              }
              continue;
            }
            break;
          }
          uint64_t v38 = *(uint64_t **)(v21 + 96);
          uint64_t v39 = 8 * v37;
          while (2)
          {
            uint64_t v40 = *v38;
            int v41 = *(uint64_t ***)(*v38 + 8);
            int v42 = *((char *)v41 + 23);
            if (v42 < 0)
            {
              if (v41[1] == (uint64_t *)5)
              {
                int v41 = (uint64_t **)*v41;
                goto LABEL_42;
              }
            }
            else
            {
              if (v42 != 5) {
                goto LABEL_54;
              }
LABEL_42:
              int v43 = *(_DWORD *)v41;
              int v44 = *((unsigned __int8 *)v41 + 4);
              if (v43 == 1634036835 && v44 == 114)
              {
                uint64_t v46 = *(uint64_t **)(v40 + 16);
                if (!v46)
                {
                  xpc_object_t v24 = (uint64_t **)awd::profile::ConfigurationParameter::default_instance((awd::profile::ConfigurationParameter *)v24);
                  uint64_t v46 = v24[2];
                }
                if ((v46[9] & 0x80) != 0)
                {
                  uint64_t v47 = *(uint64_t **)(v40 + 16);
                  if (!v47)
                  {
                    xpc_object_t v24 = (uint64_t **)awd::profile::ConfigurationParameter::default_instance((awd::profile::ConfigurationParameter *)v24);
                    uint64_t v47 = v24[2];
                  }
                  if (*((unsigned char *)v47 + 44))
                  {
                    *((unsigned char *)v25 + 64) = 1;
                    goto LABEL_58;
                  }
                }
              }
            }
LABEL_54:
            v48 = *(NSObject **)(a1 + 40);
            xpc_object_t v24 = (uint64_t **)os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT);
            if (v24)
            {
              id v49 = *(uint64_t ***)(v40 + 8);
              if (*((char *)v49 + 23) < 0) {
                id v49 = (uint64_t **)*v49;
              }
              *(_DWORD *)long long buf = 136315650;
              *(void *)&uint8_t buf[4] = v49;
              __int16 v57 = 1024;
              unsigned int v58 = v54;
              __int16 v59 = 1024;
              int v60 = v16;
              _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "trig:#E Unrecognized parameter '%s' for metric 0x%x in profile 0x%x", buf, 0x18u);
            }
LABEL_58:
            ++v38;
            v39 -= 8;
            if (!v39) {
              goto LABEL_59;
            }
            continue;
          }
        }
        uint64_t v17 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v16;
          __int16 v13 = v17;
          uint64_t v14 = "trig:#E Got profile 0x%x with no trigger id";
          uint32_t v15 = 8;
          goto LABEL_11;
        }
      }
      else
      {
        __int16 v12 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          __int16 v13 = v12;
          uint64_t v14 = "trig:#E Got profile with no profile id";
          uint32_t v15 = 2;
LABEL_11:
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v14, buf, v15);
        }
      }
LABEL_63:
      ++v8;
    }
    while (v8 != v9);
  }
}

void sub_1000CC374()
{
  if (!(void)xmmword_1001D6A00) {
    sub_1000781CC();
  }
  if (*((void *)&xmmword_1001D6A00 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6A00 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_1001D69C0);
  sub_1000A27B4();
}

void sub_1000CC478(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, int a10, uint64_t a11)
{
  pthread_mutex_unlock(&stru_1001D69C0);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    int v16 = *(NSObject **)(v13 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      a9 = 67109376;
      a10 = v12;
      LOWORD(a11) = 1024;
      *(_DWORD *)((char *)&a11 + 2) = v11;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "trig:#E Unable to register trigger 0x%x for component 0x%x", (uint8_t *)&a9, 0xEu);
    }
    __cxa_end_catch();
    JUMPOUT(0x1000CC444);
  }
  _Unwind_Resume(a1);
}

void sub_1000CC538()
{
}

void sub_1000CC540(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = (const awd::profile::DeviceConfiguration *)sub_1000E82A8(a2);
  awd::profile::DeviceConfiguration::DeviceConfiguration((awd::profile::DeviceConfiguration *)&v4, v3);
  sub_10000BA54(&v5, v2);
  operator new();
}

void sub_1000CC668(uint64_t a1)
{
  sub_10000BA54(&v1, (void *)(a1 + 8));
  operator new();
}

void sub_1000CC75C(uint64_t a1)
{
  sub_10000BA54(&v1, (void *)(a1 + 8));
  operator new();
}

void sub_1000CC840(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v10 = a2;
  int v11 = a3;
  uint64_t v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 67109632;
    *(_DWORD *)&uint8_t buf[4] = a2;
    __int16 v13 = 1024;
    int v14 = HIDWORD(a2);
    __int16 v15 = 1024;
    LODWORD(v16) = a3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "trig:#I AWD Component is going to handle Trigger(cid=0x%x, trid=0x%x, sid=%u) it just got.", buf, 0x14u);
  }
  wis::asString();
  if (v9 >= 0) {
    int v6 = (char *)&v8;
  }
  else {
    int v6 = (char *)v8;
  }
  sub_100018888(&__p, v6);
  sub_1000035F0();
}

void sub_1000CCDEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,std::__shared_weak_count *a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (v42) {
    dispatch_release(v42);
  }
  if (a36) {
    sub_10000B678(a36);
  }
  if (a42 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000CCEA4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (*(void *)(a1 + 40))
      {
        uint64_t v5 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
          sub_100149744((_DWORD *)a1, v5);
        }
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  int v6 = *(std::__shared_weak_count **)(a1 + 80);
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      int v8 = v7;
      uint64_t v9 = *(void *)(a1 + 72);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, void, void))(*(void *)v9 + 40))(v9, 7, *(void *)(a1 + 88), *(unsigned int *)(a1 + 96));
      }
      sub_10000B678(v8);
    }
  }
  if (v4) {
    sub_10000B678(v4);
  }
}

void sub_1000CCF74(_Unwind_Exception *a1)
{
  sub_10000B678(v2);
  if (v1) {
    sub_10000B678(v1);
  }
  _Unwind_Resume(a1);
}

void *sub_1000CCF94(void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[8];
  result[7] = a2[7];
  result[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[10];
  result[9] = a2[9];
  result[10] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1000CCFE0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    sub_10000B678(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

uint64_t sub_1000CD03C(uint64_t result)
{
  if (!*(void *)(result + 40)) {
    operator new();
  }
  return result;
}

void sub_1000CD0B0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1000CD130(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1000CD208);
  __cxa_rethrow();
}

void sub_1000CD158(_Unwind_Exception *a1)
{
}

void sub_1000CD170(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1000CD1A8(uint64_t a1)
{
}

uint64_t sub_1000CD1C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1000CD208(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1000CD234(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000CD244(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1000CD260(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10000B678(v1);
  }
}

void *sub_1000CD270(void *a1)
{
  *a1 = off_1001BBD50;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10000B678(v2);
  }
  return a1;
}

void sub_1000CD2BC(void *a1)
{
  *a1 = off_1001BBD50;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10000B678(v1);
  }

  operator delete();
}

void *sub_1000CD328@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "TriggerMap");
}

unsigned char *sub_1000CD338@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1000CD374(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1000CD384(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1000CD384(a1, *a2);
    sub_1000CD384(a1, a2[1]);
    sub_1000CD3E4((uint64_t)(a2 + 5), (void *)a2[6]);
    operator delete(a2);
  }
}

void sub_1000CD3E4(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1000CD3E4(a1, *a2);
    sub_1000CD3E4(a1, a2[1]);
    uint64_t v4 = (void *)a2[5];
    if (v4)
    {
      a2[6] = v4;
      operator delete(v4);
    }
    operator delete(a2);
  }
}

uint64_t **sub_1000CD448(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  int v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        int v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      int v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    int v11 = operator new(0x38uLL);
    v11[8] = **a4;
    *((void *)v11 + 5) = 0;
    *((void *)v11 + 6) = 0;
    sub_10001716C(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t sub_1000CD50C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000CD51C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1000CD538(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10000B678(v1);
  }
}

void sub_1000CD548(uint64_t **a1)
{
  uint64_t v7 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = (*a1)[1];
  uint64_t v4 = (*a1)[2];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 112);
  *(void *)(v2 + 104) = v3;
  *(void *)(v2 + 112) = v4;
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  int v6 = (std::__shared_weak_count *)v1[2];
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  operator delete();
}

uint64_t **sub_1000CD5C8(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  int v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        int v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      int v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    int v11 = operator new(0x40uLL);
    v11[8] = **a4;
    *((void *)v11 + 7) = 0;
    *((void *)v11 + 6) = 0;
    *((void *)v11 + 5) = v11 + 12;
    sub_10001716C(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t **sub_1000CD698(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  int v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        int v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      int v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    int v11 = (char *)operator new(0x48uLL);
    *((_DWORD *)v11 + 8) = **a4;
    *(_OWORD *)(v11 + 56) = 0u;
    *(_OWORD *)(v11 + 40) = 0u;
    sub_10001716C(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t *sub_1000CD764(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void **)v1;
  uint64_t v3 = (void **)(*(void *)v1 + 80);
  sub_1000CD384(*(void *)v1 + 72, *v3);
  v2[9] = v3;
  v2[11] = 0;
  std::__shared_weak_count *v3 = 0;
  uint64_t v4 = *(int *)(v1 + 32);
  if (v4)
  {
    uint64_t v5 = 8 * v4;
    int v6 = *(uint64_t **)(v1 + 24);
    while (*(_DWORD *)(*v6 + 56) != 7)
    {
      ++v6;
      v5 -= 8;
      if (!v5) {
        goto LABEL_9;
      }
    }
  }
  else
  {
    int v6 = *(uint64_t **)(v1 + 24);
  }
  if (v6 == (uint64_t *)(*(void *)(v1 + 24) + 8 * v4))
  {
LABEL_9:
    uint64_t v7 = v2[5];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "trig:#I TriggerMap::setConfiguration: no configuration for wirelessinsightsd", buf, 2u);
    }
  }
  else
  {
    sub_1000CBF04((uint64_t)v2, *v6, *(unsigned char *)(v1 + 8));
  }
  sub_1000CD878(&v10);
  return sub_10000BA00((uint64_t *)&v9);
}

void sub_1000CD85C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1000CD878(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    awd::profile::DeviceConfiguration::~DeviceConfiguration((awd::profile::DeviceConfiguration *)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_1000CD8C8(uint64_t a1)
{
  uint64_t v1 = a1;
  sub_1000CC374();
}

void sub_1000CD924()
{
}

void sub_1000CD950(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_1000CC840(**a1, (*a1)[1], *((_DWORD *)*a1 + 4));
}

void sub_1000CD9A8()
{
}

void *sub_1000CD9D4(void *result)
{
  uint64_t v1 = (void *)*result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = (void *)v1[8];
    if (v2)
    {
      v1[9] = v2;
      operator delete(v2);
    }
    uint64_t v3 = v1[5];
    if (v3)
    {
      dispatch_group_leave(v3);
      uint64_t v4 = v1[5];
      if (v4) {
        dispatch_release(v4);
      }
    }
    uint64_t v5 = (std::__shared_weak_count *)v1[2];
    if (v5) {
      std::__shared_weak_count::__release_weak(v5);
    }
    operator delete();
  }
  return result;
}

void *sub_1000CDA50(uint64_t a1)
{
  uint64_t v14 = a1;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)a1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 8))
      {
        int v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
          sub_1001497D8(a1, v6);
        }
        uint64_t v7 = *(void (**)(void *, void, void, void, uint64_t, uint64_t))(a1 + 24);
        uint64_t v8 = *(void *)(a1 + 32);
        uint64_t v9 = (void *)(v3 + (v8 >> 1));
        if (v8) {
          uint64_t v7 = *(void (**)(void *, void, void, void, uint64_t, uint64_t))(*v9 + v7);
        }
        v7(v9, *(void *)(a1 + 48), *(unsigned int *)(a1 + 56), *(unsigned int *)(a1 + 60), a1 + 64, a1 + 40);
        if (*(unsigned char *)(a1 + 88))
        {
          uint64_t v10 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
          {
            int v11 = *(_DWORD *)(a1 + 60);
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v11;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "trig:#I  -- trigger to reset aggregation: 0x%x", buf, 8u);
          }
          pthread_mutex_lock(&stru_1001D69C0);
          int v12 = (void *)xmmword_1001D6A00;
          if (!(void)xmmword_1001D6A00) {
            sub_1000781CC();
          }
          if (*((void *)&xmmword_1001D6A00 + 1)) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6A00 + 1) + 8), 1uLL, memory_order_relaxed);
          }
          pthread_mutex_unlock(&stru_1001D69C0);
          sub_1000A6060(v12);
        }
      }
      sub_10000B678(v5);
    }
  }
  return sub_1000CD9D4(&v14);
}

void sub_1000CDC34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  pthread_mutex_unlock(&stru_1001D69C0);
  sub_10000B678(v2);
  sub_1000CD9D4((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1000CDC98()
{
  if ((byte_1001D69B8 & 1) == 0)
  {
    byte_1001D69B8 = 1;
    return __cxa_atexit((void (*)(void *))sub_100029800, &stru_1001D6968, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000CDCD4()
{
  if ((byte_1001D6A10 & 1) == 0)
  {
    byte_1001D6A10 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E5C, &stru_1001D69C0, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000CDD10()
{
  if ((byte_1001D6CD0 & 1) == 0)
  {
    byte_1001D6CD0 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E7C, &stru_1001D6C80, (void *)&_mh_execute_header);
  }
  return result;
}

void sub_1000CDD4C(xpc_object_t *a1, xpc_object_t *a2)
{
  if (xpc_get_type(*a1) == (xpc_type_t)&_xpc_type_connection && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v3 = xpc_null_create();
    if (xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t reply = xpc_dictionary_create_reply(*a2);
      if (reply || (xpc_object_t reply = xpc_null_create()) != 0)
      {
        if (xpc_get_type(reply) == (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_retain(reply);
          xpc_object_t v4 = reply;
        }
        else
        {
          xpc_object_t v4 = xpc_null_create();
        }
      }
      else
      {
        xpc_object_t v4 = xpc_null_create();
        xpc_object_t reply = 0;
      }
      xpc_object_t v6 = xpc_null_create();
      xpc_release(v3);
      xpc_release(v6);
      xpc_release(reply);
    }
    else
    {
      xpc_object_t v4 = v3;
    }
    __p[0] = 0;
    __p[1] = 0;
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary) {
      operator new();
    }
    xpc_release(v4);
  }
}

void sub_1000CE3C4(_Unwind_Exception *exception_object)
{
  if (v3) {
    sub_10000B678(v3);
  }
  if (v2) {
    sub_10000B678(v2);
  }
  if (v1) {
    sub_10000B678(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000CE4DC(xpc_object_t *a1, xpc_object_t *a2)
{
  if (xpc_get_type(*a1) == (xpc_type_t)&_xpc_type_connection && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v3 = xpc_null_create();
    if (xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t reply = xpc_dictionary_create_reply(*a2);
      if (reply || (xpc_object_t reply = xpc_null_create()) != 0)
      {
        if (xpc_get_type(reply) == (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_retain(reply);
          xpc_object_t v4 = reply;
        }
        else
        {
          xpc_object_t v4 = xpc_null_create();
        }
      }
      else
      {
        xpc_object_t v4 = xpc_null_create();
        xpc_object_t reply = 0;
      }
      xpc_object_t v6 = xpc_null_create();
      xpc_release(v3);
      xpc_release(v6);
      xpc_release(reply);
    }
    else
    {
      xpc_object_t v4 = v3;
    }
    __p[0] = 0;
    __p[1] = 0;
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary) {
      operator new();
    }
    xpc_release(v4);
  }
}

void sub_1000CE7A0(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&stru_1001D69C0);
  if (v1) {
    sub_10000B678(v1);
  }
  _Unwind_Resume(a1);
}

void sub_1000CE83C(xpc_object_t *a1, xpc_object_t *a2)
{
  if (xpc_get_type(*a1) != (xpc_type_t)&_xpc_type_connection || xpc_get_type(*a2) != (xpc_type_t)&_xpc_type_dictionary) {
    return;
  }
  xpc_object_t reply = xpc_dictionary_create_reply(*a2);
  if (reply)
  {
    xpc_object_t v5 = reply;
    xpc_object_t v48 = reply;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v48 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_10;
    }
  }
  if (xpc_get_type(v5) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = xpc_null_create();
LABEL_10:
    xpc_object_t v48 = v6;
    goto LABEL_11;
  }
  xpc_retain(v5);
LABEL_11:
  xpc_release(v5);
  if (xpc_get_type(v48) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v7 = xpc_array_create(0, 0);
    if (v7 || (xpc_object_t v7 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_array)
      {
        xpc_retain(v7);
        xpc_object_t v8 = v7;
      }
      else
      {
        xpc_object_t v8 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v7 = 0;
    }
    xpc_release(v7);
    sub_1000A0F2C((uint64_t)&v45);
    uint64_t v9 = (char *)v45;
    if (v45 != &v46)
    {
      do
      {
        sub_10004EDE4(&v44.__pn_, v9 + 40);
        std::__fs::filesystem::__status(&v44, 0);
        if (LOBYTE(__p[0]))
        {
          if (LOBYTE(__p[0]) != 255)
          {
            std::__fs::filesystem::__status(&v44, 0);
            if (LOBYTE(__p[0]) == 2)
            {
              std::__fs::filesystem::directory_iterator::directory_iterator(&v43, &v44, 0, none);
              ptr = v43.__imp_.__ptr_;
              cntrl = v43.__imp_.__cntrl_;
              if (v43.__imp_.__cntrl_)
              {
                atomic_fetch_add_explicit(&v43.__imp_.__cntrl_->__shared_owners_, 1uLL, memory_order_relaxed);
                int v12 = v43.__imp_.__cntrl_;
                v42.__imp_.__ptr_ = ptr;
                v42.__imp_.__cntrl_ = cntrl;
                if (v43.__imp_.__cntrl_)
                {
                  atomic_fetch_add_explicit(&v43.__imp_.__cntrl_->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10000B678(v12);
                }
              }
              else
              {
                v42.__imp_.__ptr_ = v43.__imp_.__ptr_;
                v42.__imp_.__cntrl_ = 0;
              }
              while (v42.__imp_.__ptr_)
              {
                __int16 v13 = std::__fs::filesystem::directory_iterator::__dereference(&v42);
                std::__fs::filesystem::__status(&v13->__p_, 0);
                if (LOBYTE(__p[0]) == 1)
                {
                  if (SHIBYTE(v13->__p_.__pn_.__r_.__value_.__r.__words[2]) < 0)
                  {
                    sub_1000173FC(__p, v13->__p_.__pn_.__r_.__value_.__l.__data_, v13->__p_.__pn_.__r_.__value_.__l.__size_);
                  }
                  else
                  {
                    *(_OWORD *)std::__fs::filesystem::path __p = *(_OWORD *)&v13->__p_.__pn_.__r_.__value_.__l.__data_;
                    std::string::size_type v40 = v13->__p_.__pn_.__r_.__value_.__r.__words[2];
                  }
                  sub_1000E7FA0(4, (uint64_t)__p, &v41);
                  if (SHIBYTE(v40) < 0) {
                    operator delete(__p[0]);
                  }
                  uint64_t v14 = v41;
                  if (v41)
                  {
                    sub_10004CD90(&v13->__p_, (uint64_t)v36);
                    if (SHIBYTE(v37) < 0)
                    {
                      sub_1000173FC(__p, v36[0], (unint64_t)v36[1]);
                    }
                    else
                    {
                      *(_OWORD *)std::__fs::filesystem::path __p = *(_OWORD *)v36;
                      std::string::size_type v40 = v37;
                    }
                    sub_1000CF1B8(v14, (uint64_t)__p, &object);
                    if (SHIBYTE(v40) < 0) {
                      operator delete(__p[0]);
                    }
                    if (SHIBYTE(v37) < 0) {
                      operator delete(v36[0]);
                    }
                    if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary) {
                      xpc_array_append_value(v8, object);
                    }
                    xpc_release(object);
                    uint64_t v15 = v41;
                    uint64_t v41 = 0;
                    if (v15) {
                      (*(void (**)(uint64_t))(*(void *)v15 + 16))(v15);
                    }
                  }
                }
                std::__fs::filesystem::directory_iterator::__increment(&v42, 0);
              }
              if (v42.__imp_.__cntrl_) {
                sub_10000B678(v42.__imp_.__cntrl_);
              }
              if (v43.__imp_.__cntrl_) {
                sub_10000B678(v43.__imp_.__cntrl_);
              }
            }
          }
        }
        if (SHIBYTE(v44.__pn_.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v44.__pn_.__r_.__value_.__l.__data_);
        }
        uint64_t v16 = (char *)*((void *)v9 + 1);
        if (v16)
        {
          do
          {
            uint64_t v17 = (char **)v16;
            uint64_t v16 = *(char **)v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            uint64_t v17 = (char **)*((void *)v9 + 2);
            BOOL v18 = *v17 == v9;
            uint64_t v9 = (char *)v17;
          }
          while (!v18);
        }
        uint64_t v9 = (char *)v17;
      }
      while (v17 != &v46);
    }
    sub_100058A90((uint64_t)&v45, v46);
    xpc_object_t v34 = v8;
    if (v8) {
      xpc_retain(v8);
    }
    else {
      xpc_object_t v34 = xpc_null_create();
    }
    BOOL v45 = (char **)&v48;
    uint64_t v46 = "configs";
    sub_10007A1B0((uint64_t)&v45, &v34, &v35);
    xpc_release(v35);
    xpc_object_t v35 = 0;
    xpc_release(v34);
    xpc_object_t v34 = 0;
    pthread_mutex_lock(&stru_1001D6E38);
    uint64_t v19 = xmmword_1001D6E78;
    if (!(void)xmmword_1001D6E78) {
      sub_100057048();
    }
    __int16 v20 = (std::__shared_weak_count *)*((void *)&xmmword_1001D6E78 + 1);
    if (*((void *)&xmmword_1001D6E78 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6E78 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(&stru_1001D6E38);
    sub_1000575A4(v19, __p);
    if (v20) {
      sub_10000B678(v20);
    }
    uint64_t v21 = __p[0];
    if (__p[0])
    {
      sub_100018888(&v45, "default");
      sub_1000CF1B8((uint64_t)v21, (uint64_t)&v45, &v32);
      v44.__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)&v48;
      v44.__pn_.__r_.__value_.__l.__size_ = (std::string::size_type)"default";
      sub_10009D480((uint64_t)&v44, &v32, &v33);
      xpc_release(v33);
      xpc_object_t v33 = 0;
      xpc_release(v32);
      xpc_object_t v32 = 0;
      if (v47 < 0) {
        operator delete(v45);
      }
    }
    xpc_object_t v22 = xpc_array_create(0, 0);
    if (v22 || (xpc_object_t v22 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v22) == (xpc_type_t)&_xpc_type_array)
      {
        xpc_retain(v22);
        xpc_object_t v23 = v22;
      }
      else
      {
        xpc_object_t v23 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v23 = xpc_null_create();
      xpc_object_t v22 = 0;
    }
    xpc_release(v22);
    pthread_mutex_lock(&stru_1001D6E38);
    uint64_t v24 = xmmword_1001D6E78;
    if (!(void)xmmword_1001D6E78) {
      sub_100057048();
    }
    int v25 = (std::__shared_weak_count *)*((void *)&xmmword_1001D6E78 + 1);
    if (*((void *)&xmmword_1001D6E78 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6E78 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(&stru_1001D6E38);
    sub_100057DE0(v24, &v45);
    if (v25) {
      sub_10000B678(v25);
    }
    uint64_t v26 = v45;
    if (v45 != &v46)
    {
      do
      {
        sub_1000CF1B8((uint64_t)v26[7], (uint64_t)(v26 + 4), &v44);
        xpc_array_append_value(v23, v44.__pn_.__r_.__value_.__l.__data_);
        xpc_release(v44.__pn_.__r_.__value_.__l.__data_);
        uint64_t v27 = v26[1];
        if (v27)
        {
          do
          {
            uint64_t v28 = (char **)v27;
            uint64_t v27 = *(char **)v27;
          }
          while (v27);
        }
        else
        {
          do
          {
            uint64_t v28 = (char **)v26[2];
            BOOL v18 = *v28 == (char *)v26;
            uint64_t v26 = v28;
          }
          while (!v18);
        }
        uint64_t v26 = v28;
      }
      while (v28 != &v46);
    }
    sub_1000D01CC((uint64_t)&v45, v46);
    xpc_object_t v30 = v23;
    if (v23) {
      xpc_retain(v23);
    }
    else {
      xpc_object_t v30 = xpc_null_create();
    }
    BOOL v45 = (char **)&v48;
    uint64_t v46 = "fixed";
    sub_10007A1B0((uint64_t)&v45, &v30, &v31);
    xpc_release(v31);
    xpc_object_t v31 = 0;
    xpc_release(v30);
    xpc_object_t v30 = 0;
    xpc_connection_send_message((xpc_connection_t)*a1, v48);
    xpc_release(v23);
    int v29 = __p[0];
    __p[0] = 0;
    if (v29) {
      (*(void (**)(void *))(*(void *)v29 + 16))(v29);
    }
    xpc_release(v8);
  }
  xpc_release(v48);
}

void sub_1000CEF4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,xpc_object_t object,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  pthread_mutex_unlock(&stru_1001D6E38);
  xpc_release(v39);
  if (a22) {
    (*(void (**)(void *))(*(void *)a22 + 16))(a22);
  }
  xpc_release(v38);
  xpc_release(*(xpc_object_t *)(v40 - 88));
  _Unwind_Resume(a1);
}

void sub_1000CF1B8(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v7 = v6;
  if (v6)
  {
    *a3 = v6;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    *a3 = v7;
    if (!v7)
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v7 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v7);
    goto LABEL_9;
  }
  xpc_object_t v8 = xpc_null_create();
LABEL_8:
  *a3 = v8;
LABEL_9:
  xpc_release(v7);
  unsigned int v9 = sub_10006BFF4(a1);
  xpc_object_t object = xpc_int64_create(v9);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  uint64_t v16 = a3;
  uint64_t v17 = "dcid";
  sub_100014D08((uint64_t)&v16, &object, &v19);
  xpc_release(v19);
  xpc_object_t v19 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v10 = (const char *)a2;
  }
  else {
    uint64_t v10 = *(const char **)a2;
  }
  xpc_object_t v14 = xpc_string_create(v10);
  if (!v14) {
    xpc_object_t v14 = xpc_null_create();
  }
  uint64_t v16 = a3;
  uint64_t v17 = "title";
  sub_100014D08((uint64_t)&v16, &v14, &v15);
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_release(v14);
  xpc_object_t v14 = 0;
  if (*(char *)(a2 + 23) >= 0) {
    int v11 = (const char *)a2;
  }
  else {
    int v11 = *(const char **)a2;
  }
  xpc_object_t v12 = xpc_string_create(v11);
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  uint64_t v16 = a3;
  uint64_t v17 = "handle";
  sub_100014D08((uint64_t)&v16, &v12, &v13);
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_release(v12);
}

void sub_1000CF394(_Unwind_Exception *a1)
{
  sub_1000551DC(v1);
  _Unwind_Resume(a1);
}

void sub_1000CF3B4(xpc_object_t *a1, xpc_object_t *a2)
{
  if (xpc_get_type(*a1) == (xpc_type_t)&_xpc_type_connection && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v3 = xpc_null_create();
    if (xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t reply = xpc_dictionary_create_reply(*a2);
      if (reply || (xpc_object_t reply = xpc_null_create()) != 0)
      {
        if (xpc_get_type(reply) == (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_retain(reply);
          xpc_object_t v4 = reply;
        }
        else
        {
          xpc_object_t v4 = xpc_null_create();
        }
      }
      else
      {
        xpc_object_t v4 = xpc_null_create();
        xpc_object_t reply = 0;
      }
      xpc_object_t v6 = xpc_null_create();
      xpc_release(v3);
      xpc_release(v6);
      xpc_release(reply);
    }
    else
    {
      xpc_object_t v4 = v3;
    }
    long long v54 = 0uLL;
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary) {
      operator new();
    }
    long long v7 = v54;
    xpc_release(v4);
    if (!(void)v54 || xpc_get_type(*(xpc_object_t *)v54) != (xpc_type_t)&_xpc_type_dictionary) {
      goto LABEL_124;
    }
    *(void *)&long long v54 = a2;
    *((void *)&v54 + 1) = "InvestigationId";
    sub_10000B7A4((uint64_t)&v54, &object);
    int v9 = xpc::dyn_cast_or_default((xpc *)&object, 0, v8);
    xpc_release(object.__r_.__value_.__l.__data_);
    object.__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
    object.__r_.__value_.__l.__size_ = (std::string::size_type)"config";
    sub_10000B7A4((uint64_t)&object, &__p);
    long long v54 = 0uLL;
    uint64_t v55 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v55) < 0) {
      operator delete((void *)v54);
    }
    xpc_release(__p.__r_.__value_.__l.__data_);
    if (v50 < 0)
    {
      if (v49 != 7
        || (*(_DWORD *)v48 == 1634100580 ? (BOOL v11 = *(_DWORD *)((char *)v48 + 3) == 1953264993) : (BOOL v11 = 0), !v11))
      {
        if (v49 == 12)
        {
          if (*(void *)v48 == 0x2D6469692D746573 && *((_DWORD *)v48 + 2) == 2037149295) {
            goto LABEL_38;
          }
LABEL_63:
          pthread_mutex_lock(&stru_1001D6E38);
          uint64_t v24 = xmmword_1001D6E78;
          if (!(void)xmmword_1001D6E78) {
            sub_100057048();
          }
          int v25 = (std::__shared_weak_count *)*((void *)&xmmword_1001D6E78 + 1);
          if (*((void *)&xmmword_1001D6E78 + 1)) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6E78 + 1) + 8), 1uLL, memory_order_relaxed);
          }
          pthread_mutex_unlock(&stru_1001D6E38);
          sub_100057E74(v24, (uint64_t)&v48, &v56);
          if (v25) {
            sub_10000B678(v25);
          }
          if (v56)
          {
            uint64_t v47 = v56;
          }
          else
          {
            sub_1000A0F2C((uint64_t)&v54);
            uint64_t v26 = (char *)v54;
            if ((long long *)v54 == (long long *)((char *)&v54 + 8))
            {
LABEL_89:
              sub_100058A90((uint64_t)&v54, *((char **)&v54 + 1));
              uint64_t v47 = 0;
            }
            else
            {
              while (1)
              {
                sub_10004EDE4(&object, v26 + 40);
                uint64_t v27 = sub_10004EE4C(&object, (uint64_t)&v48);
                wis::getWISTimestamp((wis *)v27);
                if (SHIBYTE(object.__r_.__value_.__r.__words[2]) < 0) {
                  sub_1000173FC(&__p, object.__r_.__value_.__l.__data_, object.__r_.__value_.__l.__size_);
                }
                else {
                  std::string __p = object;
                }
                sub_1000E7FA0(4, (uint64_t)&__p, &v52);
                uint64_t v28 = v52;
                uint64_t v52 = 0;
                uint64_t v29 = v56;
                uint64_t v56 = v28;
                if (v29)
                {
                  (*(void (**)(uint64_t))(*(void *)v29 + 16))(v29);
                  uint64_t v30 = v52;
                  uint64_t v52 = 0;
                  if (v30) {
                    (*(void (**)(uint64_t))(*(void *)v30 + 16))(v30);
                  }
                }
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p.__r_.__value_.__l.__data_);
                }
                uint64_t v31 = v56;
                if (v56) {
                  break;
                }
                if (SHIBYTE(object.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(object.__r_.__value_.__l.__data_);
                }
                xpc_object_t v32 = (char *)*((void *)v26 + 1);
                if (v32)
                {
                  do
                  {
                    xpc_object_t v33 = v32;
                    xpc_object_t v32 = *(char **)v32;
                  }
                  while (v32);
                }
                else
                {
                  do
                  {
                    xpc_object_t v33 = (char *)*((void *)v26 + 2);
                    BOOL v10 = *(void *)v33 == (void)v26;
                    uint64_t v26 = v33;
                  }
                  while (!v10);
                }
                uint64_t v26 = v33;
                if (v33 == (char *)&v54 + 8) {
                  goto LABEL_89;
                }
              }
              uint64_t v56 = 0;
              uint64_t v47 = v31;
              if (SHIBYTE(object.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(object.__r_.__value_.__l.__data_);
              }
              sub_100058A90((uint64_t)&v54, *((char **)&v54 + 1));
            }
            uint64_t v34 = v56;
            uint64_t v56 = 0;
            if (v34) {
              (*(void (**)(uint64_t))(*(void *)v34 + 16))(v34);
            }
          }
          uint64_t v18 = v47;
          if (v47)
          {
            sub_1000E82A0(v47, v9);
            sub_1000E8268(v47, 4);
LABEL_102:
            pthread_mutex_lock(&stru_1001D6E38);
            uint64_t v35 = xmmword_1001D6E78;
            if (!(void)xmmword_1001D6E78) {
              sub_100057048();
            }
            int v36 = (std::__shared_weak_count *)*((void *)&xmmword_1001D6E78 + 1);
            if (*((void *)&xmmword_1001D6E78 + 1)) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6E78 + 1) + 8), 1uLL, memory_order_relaxed);
            }
            pthread_mutex_unlock(&stru_1001D6E38);
            sub_100058068(v35, v18);
            if (v36) {
              sub_10000B678(v36);
            }
            pthread_mutex_lock(&stru_1001D6A70);
            uint64_t v37 = qword_1001D6AB0;
            uint64_t v38 = (std::__shared_weak_count *)qword_1001D6AB8;
            if (qword_1001D6AB8) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_1001D6AB8 + 8), 1uLL, memory_order_relaxed);
            }
            pthread_mutex_unlock(&stru_1001D6A70);
            if (v37) {
              sub_1000C0C28();
            }
            unsigned int v39 = sub_10006BFF4(v18);
            xpc_object_t v45 = xpc_int64_create(v39);
            if (!v45) {
              xpc_object_t v45 = xpc_null_create();
            }
            *(void *)&long long v54 = v7;
            *((void *)&v54 + 1) = "dcid";
            sub_100014D08((uint64_t)&v54, &v45, &v46);
            xpc_release(v46);
            xpc_object_t v46 = 0;
            xpc_release(v45);
            xpc_object_t v45 = 0;
            unsigned int v40 = sub_10000B7EC(v18);
            xpc_object_t v43 = xpc_int64_create(v40);
            if (!v43) {
              xpc_object_t v43 = xpc_null_create();
            }
            *(void *)&long long v54 = v7;
            *((void *)&v54 + 1) = "InvestigationId";
            sub_100014D08((uint64_t)&v54, &v43, &v44);
            xpc_release(v44);
            xpc_object_t v44 = 0;
            xpc_release(v43);
            xpc_object_t v43 = 0;
            if (v38) {
              sub_10000B678(v38);
            }
            (*(void (**)(uint64_t))(*(void *)v18 + 16))(v18);
LABEL_122:
            if (v50 < 0) {
              operator delete(v48);
            }
LABEL_124:
            if (*((void *)&v7 + 1)) {
              sub_10000B678(*((std::__shared_weak_count **)&v7 + 1));
            }
            return;
          }
LABEL_119:
          xpc_object_t v41 = xpc_string_create("No configuration found");
          if (!v41) {
            xpc_object_t v41 = xpc_null_create();
          }
          *(void *)&long long v54 = v7;
          *((void *)&v54 + 1) = "error";
          sub_100014D08((uint64_t)&v54, &v41, &v42);
          xpc_release(v42);
          xpc_object_t v42 = 0;
          xpc_release(v41);
          xpc_object_t v41 = 0;
          goto LABEL_122;
        }
        if (v49 != 5) {
          goto LABEL_63;
        }
        __int16 v20 = (unsigned __int8 *)v48;
LABEL_59:
        int v21 = *(_DWORD *)v20;
        int v22 = v20[4];
        if (v21 == 1851878498 && v22 == 107) {
          sub_1000E7DE8();
        }
        goto LABEL_63;
      }
    }
    else
    {
      if (v50 != 7)
      {
        if (v50 == 12)
        {
          BOOL v10 = v48 == (void *)0x2D6469692D746573 && v49 == 2037149295;
          if (!v10) {
            goto LABEL_63;
          }
LABEL_38:
          pthread_mutex_lock(&stru_1001D6A70);
          uint64_t v14 = qword_1001D6AB0;
          xpc_object_t v13 = (std::__shared_weak_count *)qword_1001D6AB8;
          if (qword_1001D6AB8) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_1001D6AB8 + 8), 1uLL, memory_order_relaxed);
          }
          pthread_mutex_unlock(&stru_1001D6A70);
          if (v14)
          {
            char v15 = sub_1000C177C(v14);
            pthread_mutex_lock(&stru_1001D6E38);
            uint64_t v16 = xmmword_1001D6E78;
            if (!(void)xmmword_1001D6E78) {
              sub_100057048();
            }
            uint64_t v17 = (std::__shared_weak_count *)*((void *)&xmmword_1001D6E78 + 1);
            if (*((void *)&xmmword_1001D6E78 + 1)) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6E78 + 1) + 8), 1uLL, memory_order_relaxed);
            }
            pthread_mutex_unlock(&stru_1001D6E38);
            sub_100058384(v16, v15, &object);
            uint64_t v18 = object.__r_.__value_.__r.__words[0];
            object.__r_.__value_.__r.__words[0] = 0;
            if (v17) {
              sub_10000B678(v17);
            }
            if (v18)
            {
              sub_1000E8268(v18, 4);
              sub_1000E82A0(v18, v9);
            }
          }
          else
          {
            uint64_t v18 = 0;
          }
          if (v13) {
            sub_10000B678(v13);
          }
          if (v18) {
            goto LABEL_102;
          }
          goto LABEL_119;
        }
        if (v50 != 5) {
          goto LABEL_63;
        }
        __int16 v20 = (unsigned __int8 *)&v48;
        goto LABEL_59;
      }
      if (v48 != 1634100580 || *(_DWORD *)((char *)&v48 + 3) != 1953264993) {
        goto LABEL_63;
      }
    }
    sub_1000E7E90();
  }
}

void sub_1000CFC78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,xpc_object_t object,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,xpc_object_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  pthread_mutex_unlock(&stru_1001D6E38);
  if (v36) {
    sub_10000B678(v36);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  if (v35) {
    sub_10000B678(v35);
  }
  _Unwind_Resume(a1);
}

void sub_1000CFEC4(xpc_connection_t *a1, xpc_object_t *a2)
{
  if (xpc_get_type(*a1) == (xpc_type_t)&_xpc_type_connection && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(*a2);
    if (reply || (xpc_object_t reply = xpc_null_create()) != 0)
    {
      if (xpc_get_type(reply) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(reply);
        xpc_object_t v5 = reply;
      }
      else
      {
        xpc_object_t v5 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t reply = 0;
    }
    xpc_release(reply);
    if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
    {
      if (!xpc_dictionary_get_value(*a2, "enabled") && xpc_dictionary_get_value(*a2, "analyticsShim"))
      {
        v10[0] = a2;
        v10[1] = "analyticsShim";
        sub_10000B7A4((uint64_t)v10, &object);
        char v7 = xpc::dyn_cast_or_default((xpc *)&object, 0, v6);
        xpc_release(object);
        pthread_mutex_lock(&stru_1001D69C0);
        uint64_t v8 = xmmword_1001D6A00;
        if (!(void)xmmword_1001D6A00) {
          sub_1000781CC();
        }
        if (*((void *)&xmmword_1001D6A00 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6A00 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        pthread_mutex_unlock(&stru_1001D69C0);
        sub_1000A2E14(v8, v7);
      }
      xpc_connection_send_message(*a1, v5);
    }
    xpc_release(v5);
  }
}

void sub_1000D011C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  pthread_mutex_unlock(&stru_1001D6C80);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

void sub_1000D01CC(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1000D01CC(a1, *a2);
    sub_1000D01CC(a1, a2[1]);
    sub_100058CF4((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

uint64_t sub_1000D0228()
{
  if ((byte_1001D6AC0 & 1) == 0)
  {
    byte_1001D6AC0 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E64, &stru_1001D6A70, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000D0264()
{
  if ((byte_1001D6A10 & 1) == 0)
  {
    byte_1001D6A10 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E5C, &stru_1001D69C0, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000D02A0()
{
  if ((byte_1001D6E88 & 1) == 0)
  {
    byte_1001D6E88 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E90, &stru_1001D6E38, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000D02DC()
{
  if ((byte_1001D6CD0 & 1) == 0)
  {
    byte_1001D6CD0 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E7C, &stru_1001D6C80, (void *)&_mh_execute_header);
  }
  return result;
}

void sub_1000D046C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1000D04A4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000D04B4(uint64_t a1)
{
}

void sub_1000D055C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000D05CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000D06B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1000D06E8()
{
  if (qword_1001D8088) {
    (*(void (**)(uint64_t))(*(void *)qword_1001D8088 + 8))(qword_1001D8088);
  }
  if (qword_1001D8090) {
    (*(void (**)(uint64_t))(*(void *)qword_1001D8090 + 8))(qword_1001D8090);
  }
  uint64_t result = qword_1001D8098;
  if (qword_1001D8098)
  {
    uint64_t v1 = *(uint64_t (**)(void))(*(void *)qword_1001D8098 + 8);
    return v1();
  }
  return result;
}

void sub_1000D07A0(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
}

uint64_t sub_1000D08F0(uint64_t result)
{
  *(void *)uint64_t result = off_1001BBE18;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(_DWORD *)(result + 32) = 0;
  return result;
}

double sub_1000D0918(uint64_t a1)
{
  *(void *)a1 = off_1001BBE90;
  double result = 0.0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return result;
}

double sub_1000D0958(uint64_t a1)
{
  *(void *)a1 = off_1001BBF08;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

void sub_1000D0988()
{
  uint64_t v0 = qword_1001D80A0;
  __dmb(0xBu);
  if (v0 != 2)
  {
    v1[1] = sub_1000D07A0;
    char v2 = 0;
    wireless_diagnostics::google::protobuf::GoogleOnceInitImpl();
    wireless_diagnostics::google::protobuf::internal::FunctionClosure0::~FunctionClosure0((wireless_diagnostics::google::protobuf::internal::FunctionClosure0 *)v1);
  }
}

void sub_1000D0A0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  wireless_diagnostics::google::protobuf::internal::FunctionClosure0::~FunctionClosure0((wireless_diagnostics::google::protobuf::internal::FunctionClosure0 *)va);
  _Unwind_Resume(a1);
}

void sub_1000D0A20(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 32);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 32))
    {
      uint64_t v6 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 32) |= 1u;
      *(void *)(a1 + 8) = v6;
      int v4 = *(_DWORD *)(a2 + 32);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_12;
      }
    }
    else if ((*(unsigned char *)(a2 + 32) & 2) == 0)
    {
      goto LABEL_6;
    }
    int v7 = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 32) |= 2u;
    *(_DWORD *)(a1 + 16) = v7;
    int v4 = *(_DWORD *)(a2 + 32);
    if ((v4 & 4) == 0)
    {
LABEL_7:
      if ((v4 & 8) == 0) {
        return;
      }
      goto LABEL_8;
    }
LABEL_12:
    int v8 = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a1 + 32) |= 4u;
    *(_DWORD *)(a1 + 20) = v8;
    if ((*(_DWORD *)(a2 + 32) & 8) == 0) {
      return;
    }
LABEL_8:
    int v5 = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(a1 + 32) |= 8u;
    *(_DWORD *)(a1 + 24) = v5;
  }
}

void sub_1000D0B14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1000D0B2C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1001BBE18;
  sub_1000D0988();

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1000D0B88(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_1000D0B2C(a1);

  operator delete();
}

void sub_1000D0BC0()
{
}

uint64_t sub_1000D0C10(uint64_t result)
{
  if (*(unsigned char *)(result + 32))
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(_DWORD *)(result + 24) = 0;
  }
  *(_DWORD *)(result + 32) = 0;
  return result;
}

uint64_t sub_1000D0C28(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = (unint64_t *)(a1 + 8);
  uint64_t v6 = (unsigned int *)(a1 + 16);
  int v7 = (unsigned int *)(a1 + 20);
  int v8 = (unsigned int *)(a1 + 24);
  while (2)
  {
    int v9 = (char *)*((void *)this + 1);
    if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v9;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v9 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        xpc_object_t v13 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        if ((unint64_t)v13 < v12 && (*v13 & 0x80000000) == 0)
        {
          *int v5 = *v13;
          uint64_t v14 = v13 + 1;
          *((void *)this + 1) = v14;
LABEL_24:
          *(_DWORD *)(a1 + 32) |= 1u;
          if ((unint64_t)v14 < v12 && *v14 == 16)
          {
            char v15 = v14 + 1;
            *((void *)this + 1) = v15;
            goto LABEL_27;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
        if (result)
        {
          uint64_t v14 = (unsigned char *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
          goto LABEL_24;
        }
        break;
      case 2u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        char v15 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
LABEL_27:
        if ((unint64_t)v15 >= v12 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!result) {
            return result;
          }
          uint64_t v18 = (unsigned char *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          *uint64_t v6 = *v15;
          uint64_t v18 = v15 + 1;
          *((void *)this + 1) = v18;
        }
        *(_DWORD *)(a1 + 32) |= 2u;
        if ((unint64_t)v18 >= v12 || *v18 != 24) {
          continue;
        }
        uint64_t v16 = v18 + 1;
        *((void *)this + 1) = v16;
LABEL_35:
        if ((unint64_t)v16 >= v12 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!result) {
            return result;
          }
          xpc_object_t v19 = (unsigned char *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v7 = *v16;
          xpc_object_t v19 = v16 + 1;
          *((void *)this + 1) = v19;
        }
        *(_DWORD *)(a1 + 32) |= 4u;
        if ((unint64_t)v19 >= v12 || *v19 != 32) {
          continue;
        }
        uint64_t v17 = v19 + 1;
        *((void *)this + 1) = v17;
LABEL_43:
        if ((unint64_t)v17 >= v12 || *v17 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v8);
          if (!result) {
            return result;
          }
          __int16 v20 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v8 = *v17;
          __int16 v20 = (unsigned __int8 *)(v17 + 1);
          *((void *)this + 1) = v20;
        }
        *(_DWORD *)(a1 + 32) |= 8u;
        if (v20 != (unsigned __int8 *)v12 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10)) {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      case 3u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        uint64_t v16 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_35;
      case 4u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        uint64_t v17 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_43;
      default:
        int v11 = TagFallback & 7;
LABEL_18:
        if (v11 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t sub_1000D0EE8(uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  unsigned int v4 = a2;
  int v5 = (int *)result;
  int v6 = *(_DWORD *)(result + 32);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(result + 8), a2, a4);
    int v6 = v5[8];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v5[5], v4, a4);
      if ((v5[8] & 8) == 0) {
        return result;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v5[4], v4, a4);
  int v6 = v5[8];
  if ((v6 & 4) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((v6 & 8) == 0) {
    return result;
  }
LABEL_9:
  int v7 = v5[6];

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, v4, a4);
}

uint64_t sub_1000D0F90(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 32);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_22;
  }
  if (*(unsigned char *)(a1 + 32))
  {
    uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
    int v3 = *(_DWORD *)(a1 + 32);
    if ((v3 & 2) == 0) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 32) & 2) == 0) {
      goto LABEL_11;
    }
  }
  int v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
  if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 32);
  }
  else
  {
    int v6 = 2;
  }
  uint64_t v4 = (v6 + v4);
LABEL_11:
  if ((v3 & 4) == 0)
  {
    if ((v3 & 8) == 0) {
      goto LABEL_22;
    }
    goto LABEL_18;
  }
  int v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 20);
  if (v7 >= 0x80)
  {
    int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 32);
  }
  else
  {
    int v8 = 2;
  }
  uint64_t v4 = (v8 + v4);
  if ((v3 & 8) != 0)
  {
LABEL_18:
    int v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 24);
    if (v9 >= 0x80) {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, a2) + 1;
    }
    else {
      int v10 = 2;
    }
    uint64_t v4 = (v10 + v4);
  }
LABEL_22:
  *(_DWORD *)(a1 + 28) = v4;
  return v4;
}

uint64_t sub_1000D1068()
{
  return 1;
}

void *sub_1000D1070@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.InsightTypeTestOne");
}

void sub_1000D1080(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v17);
  }
  int v4 = *(_DWORD *)(a2 + 60);
  if (!(_BYTE)v4) {
    goto LABEL_13;
  }
  if (v4)
  {
    int v7 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 60) |= 1u;
    *(_DWORD *)(a1 + 8) = v7;
    int v4 = *(_DWORD *)(a2 + 60);
    if ((v4 & 2) == 0)
    {
LABEL_6:
      if ((v4 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_21;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_6;
  }
  int v8 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 60) |= 2u;
  *(_DWORD *)(a1 + 12) = v8;
  int v4 = *(_DWORD *)(a2 + 60);
  if ((v4 & 4) == 0)
  {
LABEL_7:
    if ((v4 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_24;
  }
LABEL_21:
  int v9 = *(const std::string **)(a2 + 16);
  *(_DWORD *)(a1 + 60) |= 4u;
  int v10 = *(std::string **)(a1 + 16);
  if (v10 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v10, v9);
  int v4 = *(_DWORD *)(a2 + 60);
  if ((v4 & 8) == 0)
  {
LABEL_8:
    if ((v4 & 0x10) == 0) {
      goto LABEL_9;
    }
    goto LABEL_25;
  }
LABEL_24:
  int v11 = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 60) |= 8u;
  *(_DWORD *)(a1 + 24) = v11;
  int v4 = *(_DWORD *)(a2 + 60);
  if ((v4 & 0x10) == 0)
  {
LABEL_9:
    if ((v4 & 0x20) == 0) {
      goto LABEL_10;
    }
LABEL_26:
    int v13 = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 60) |= 0x20u;
    *(_DWORD *)(a1 + 32) = v13;
    int v4 = *(_DWORD *)(a2 + 60);
    if ((v4 & 0x40) == 0)
    {
LABEL_11:
      if ((v4 & 0x80) == 0) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
    goto LABEL_27;
  }
LABEL_25:
  int v12 = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a1 + 60) |= 0x10u;
  *(_DWORD *)(a1 + 28) = v12;
  int v4 = *(_DWORD *)(a2 + 60);
  if ((v4 & 0x20) != 0) {
    goto LABEL_26;
  }
LABEL_10:
  if ((v4 & 0x40) == 0) {
    goto LABEL_11;
  }
LABEL_27:
  int v14 = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 60) |= 0x40u;
  *(_DWORD *)(a1 + 36) = v14;
  int v4 = *(_DWORD *)(a2 + 60);
  if ((v4 & 0x80) != 0)
  {
LABEL_12:
    int v5 = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(a1 + 60) |= 0x80u;
    *(_DWORD *)(a1 + 40) = v5;
    int v4 = *(_DWORD *)(a2 + 60);
  }
LABEL_13:
  if ((v4 & 0xFF00) == 0) {
    return;
  }
  if ((v4 & 0x100) != 0)
  {
    int v15 = *(_DWORD *)(a2 + 44);
    *(_DWORD *)(a1 + 60) |= 0x100u;
    *(_DWORD *)(a1 + 44) = v15;
    int v4 = *(_DWORD *)(a2 + 60);
    if ((v4 & 0x200) == 0)
    {
LABEL_16:
      if ((v4 & 0x400) == 0) {
        return;
      }
      goto LABEL_17;
    }
  }
  else if ((v4 & 0x200) == 0)
  {
    goto LABEL_16;
  }
  int v16 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 60) |= 0x200u;
  *(_DWORD *)(a1 + 48) = v16;
  if ((*(_DWORD *)(a2 + 60) & 0x400) == 0) {
    return;
  }
LABEL_17:
  int v6 = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a1 + 60) |= 0x400u;
  *(_DWORD *)(a1 + 52) = v6;
}

void sub_1000D12A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1000D12BC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1001BBE90;
  sub_1000D1314((uint64_t)a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1000D1314(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }

  sub_1000D0988();
}

void sub_1000D1384(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_1000D12BC(a1);

  operator delete();
}

void sub_1000D13BC()
{
}

uint64_t sub_1000D1424(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 60);
  if ((_BYTE)v1)
  {
    *(void *)(result + 8) = 0;
    if ((v1 & 4) != 0)
    {
      uint64_t v2 = *(void *)(result + 16);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
    *(void *)(result + 24) = 0;
    *(void *)(result + 32) = 0;
    *(_DWORD *)(result + 40) = 0;
    int v1 = *(_DWORD *)(result + 60);
  }
  if ((v1 & 0xFF00) != 0)
  {
    *(void *)(result + 48) = 0;
    *(_DWORD *)(result + 44) = 0;
  }
  *(_DWORD *)(result + 60) = 0;
  return result;
}

uint64_t sub_1000D1490(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = (unsigned int *)(a1 + 8);
  int v6 = (unsigned int *)(a1 + 24);
  int v7 = (unsigned int *)(a1 + 28);
  int v8 = (unsigned int *)(a1 + 32);
  int v9 = (unsigned int *)(a1 + 36);
  int v10 = (unsigned int *)(a1 + 44);
  int v11 = (unsigned int *)(a1 + 48);
  int v12 = (unsigned int *)(a1 + 52);
  while (2)
  {
    int v13 = (char *)*((void *)this + 1);
    if ((unint64_t)v13 >= *((void *)this + 2) || *v13 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v13;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v13 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        uint64_t v17 = (char *)*((void *)this + 1);
        unint64_t v16 = *((void *)this + 2);
        if ((unint64_t)v17 < v16 && (*v17 & 0x80000000) == 0)
        {
          *int v5 = *v17;
          uint64_t v18 = v17 + 1;
          *((void *)this + 1) = v18;
LABEL_38:
          *(_DWORD *)(a1 + 60) |= 1u;
          if ((unint64_t)v18 < v16 && *v18 == 16)
          {
            xpc_object_t v19 = v18 + 1;
            *((void *)this + 1) = v19;
            goto LABEL_41;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
        if (result)
        {
          uint64_t v18 = (unsigned char *)*((void *)this + 1);
          unint64_t v16 = *((void *)this + 2);
          goto LABEL_38;
        }
        break;
      case 2u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        xpc_object_t v19 = (char *)*((void *)this + 1);
        unint64_t v16 = *((void *)this + 2);
LABEL_41:
        unsigned int v44 = 0;
        if ((unint64_t)v19 >= v16 || *v19 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v44);
          if (!result) {
            return result;
          }
          unsigned int v30 = v44;
        }
        else
        {
          unsigned int v30 = *v19;
          *((void *)this + 1) = v19 + 1;
        }
        if (v30 <= 8)
        {
          *(_DWORD *)(a1 + 60) |= 2u;
          *(_DWORD *)(a1 + 12) = v30;
        }
        uint64_t v31 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v31 >= *((void *)this + 2) || *v31 != 26) {
          continue;
        }
        *((void *)this + 1) = v31 + 1;
LABEL_51:
        *(_DWORD *)(a1 + 60) |= 4u;
        if (*(_UNKNOWN **)(a1 + 16) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        xpc_object_t v32 = (unsigned char *)*((void *)this + 1);
        unint64_t v20 = *((void *)this + 2);
        if ((unint64_t)v32 >= v20 || *v32 != 32) {
          continue;
        }
        int v21 = v32 + 1;
        *((void *)this + 1) = v21;
LABEL_57:
        if ((unint64_t)v21 >= v20 || *v21 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!result) {
            return result;
          }
          xpc_object_t v33 = (unsigned char *)*((void *)this + 1);
          unint64_t v20 = *((void *)this + 2);
        }
        else
        {
          *int v6 = *v21;
          xpc_object_t v33 = v21 + 1;
          *((void *)this + 1) = v33;
        }
        *(_DWORD *)(a1 + 60) |= 8u;
        if ((unint64_t)v33 >= v20 || *v33 != 40) {
          continue;
        }
        int v22 = v33 + 1;
        *((void *)this + 1) = v22;
LABEL_65:
        if ((unint64_t)v22 >= v20 || *v22 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!result) {
            return result;
          }
          uint64_t v34 = (unsigned char *)*((void *)this + 1);
          unint64_t v20 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v7 = *v22;
          uint64_t v34 = v22 + 1;
          *((void *)this + 1) = v34;
        }
        *(_DWORD *)(a1 + 60) |= 0x10u;
        if ((unint64_t)v34 >= v20 || *v34 != 48) {
          continue;
        }
        xpc_object_t v23 = v34 + 1;
        *((void *)this + 1) = v23;
LABEL_73:
        if ((unint64_t)v23 >= v20 || *v23 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v8);
          if (!result) {
            return result;
          }
          uint64_t v35 = (unsigned char *)*((void *)this + 1);
          unint64_t v20 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v8 = *v23;
          uint64_t v35 = v23 + 1;
          *((void *)this + 1) = v35;
        }
        *(_DWORD *)(a1 + 60) |= 0x20u;
        if ((unint64_t)v35 >= v20 || *v35 != 56) {
          continue;
        }
        uint64_t v24 = v35 + 1;
        *((void *)this + 1) = v24;
LABEL_81:
        if ((unint64_t)v24 >= v20 || *v24 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v9);
          if (!result) {
            return result;
          }
          int v36 = (unsigned char *)*((void *)this + 1);
          unint64_t v20 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v9 = *v24;
          int v36 = v24 + 1;
          *((void *)this + 1) = v36;
        }
        *(_DWORD *)(a1 + 60) |= 0x40u;
        if ((unint64_t)v36 >= v20 || *v36 != 64) {
          continue;
        }
        int v25 = v36 + 1;
        *((void *)this + 1) = v25;
LABEL_89:
        unsigned int v43 = 0;
        if ((unint64_t)v25 >= v20 || *v25 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
          if (!result) {
            return result;
          }
          unsigned int v37 = v43;
        }
        else
        {
          unsigned int v37 = *v25;
          *((void *)this + 1) = v25 + 1;
        }
        if (v37 <= 2)
        {
          *(_DWORD *)(a1 + 60) |= 0x80u;
          *(_DWORD *)(a1 + 40) = v37;
        }
        uint64_t v38 = (unsigned char *)*((void *)this + 1);
        unint64_t v26 = *((void *)this + 2);
        if ((unint64_t)v38 >= v26 || *v38 != 72) {
          continue;
        }
        uint64_t v27 = v38 + 1;
        *((void *)this + 1) = v27;
LABEL_99:
        if ((unint64_t)v27 >= v26 || *v27 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v10);
          if (!result) {
            return result;
          }
          unsigned int v39 = (unsigned char *)*((void *)this + 1);
          unint64_t v26 = *((void *)this + 2);
        }
        else
        {
          *int v10 = *v27;
          unsigned int v39 = v27 + 1;
          *((void *)this + 1) = v39;
        }
        *(_DWORD *)(a1 + 60) |= 0x100u;
        if ((unint64_t)v39 >= v26 || *v39 != 80) {
          continue;
        }
        uint64_t v28 = v39 + 1;
        *((void *)this + 1) = v28;
LABEL_107:
        if ((unint64_t)v28 >= v26 || *v28 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v11);
          if (!result) {
            return result;
          }
          unsigned int v40 = (unsigned char *)*((void *)this + 1);
          unint64_t v26 = *((void *)this + 2);
        }
        else
        {
          *int v11 = *v28;
          unsigned int v40 = v28 + 1;
          *((void *)this + 1) = v40;
        }
        *(_DWORD *)(a1 + 60) |= 0x200u;
        if ((unint64_t)v40 >= v26 || *v40 != 88) {
          continue;
        }
        uint64_t v29 = v40 + 1;
        *((void *)this + 1) = v29;
LABEL_115:
        if ((unint64_t)v29 >= v26 || *v29 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v12);
          if (!result) {
            return result;
          }
          xpc_object_t v41 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v26 = *((void *)this + 2);
        }
        else
        {
          *int v12 = *v29;
          xpc_object_t v41 = (unsigned __int8 *)(v29 + 1);
          *((void *)this + 1) = v41;
        }
        *(_DWORD *)(a1 + 60) |= 0x400u;
        if (v41 != (unsigned __int8 *)v26 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10)) {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      case 3u:
        int v15 = TagFallback & 7;
        if (v15 == 2) {
          goto LABEL_51;
        }
        goto LABEL_32;
      case 4u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        int v21 = (char *)*((void *)this + 1);
        unint64_t v20 = *((void *)this + 2);
        goto LABEL_57;
      case 5u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        int v22 = (char *)*((void *)this + 1);
        unint64_t v20 = *((void *)this + 2);
        goto LABEL_65;
      case 6u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        xpc_object_t v23 = (char *)*((void *)this + 1);
        unint64_t v20 = *((void *)this + 2);
        goto LABEL_73;
      case 7u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        uint64_t v24 = (char *)*((void *)this + 1);
        unint64_t v20 = *((void *)this + 2);
        goto LABEL_81;
      case 8u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        int v25 = (char *)*((void *)this + 1);
        unint64_t v20 = *((void *)this + 2);
        goto LABEL_89;
      case 9u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        uint64_t v27 = (char *)*((void *)this + 1);
        unint64_t v26 = *((void *)this + 2);
        goto LABEL_99;
      case 0xAu:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        uint64_t v28 = (char *)*((void *)this + 1);
        unint64_t v26 = *((void *)this + 2);
        goto LABEL_107;
      case 0xBu:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        uint64_t v29 = (char *)*((void *)this + 1);
        unint64_t v26 = *((void *)this + 2);
        goto LABEL_115;
      default:
        int v15 = TagFallback & 7;
LABEL_32:
        if (v15 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

int *sub_1000D1AD8(int *result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v5 = result;
  int v6 = result[15];
  if (v6)
  {
    uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, result[2], a2, a4);
    int v6 = v5[15];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_15;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v5[3], a2, a4);
  int v6 = v5[15];
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_16;
  }
LABEL_15:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = v5[15];
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_17;
  }
LABEL_16:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v5[6], a2, a4);
  int v6 = v5[15];
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_18;
  }
LABEL_17:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v5[7], a2, a4);
  int v6 = v5[15];
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_19;
  }
LABEL_18:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v5[8], a2, a4);
  int v6 = v5[15];
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_20;
  }
LABEL_19:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, v5[9], a2, a4);
  int v6 = v5[15];
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_21;
  }
LABEL_20:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8, v5[10], a2, a4);
  int v6 = v5[15];
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0) {
      goto LABEL_11;
    }
LABEL_22:
    uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, v5[12], a2, a4);
    if ((v5[15] & 0x400) == 0) {
      return result;
    }
    goto LABEL_23;
  }
LABEL_21:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, v5[11], a2, a4);
  int v6 = v5[15];
  if ((v6 & 0x200) != 0) {
    goto LABEL_22;
  }
LABEL_11:
  if ((v6 & 0x400) == 0) {
    return result;
  }
LABEL_23:
  int v7 = v5[13];

  return (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, v7, a2, a4);
}

uint64_t sub_1000D1C44(uint64_t a1, unsigned int a2)
{
  int v3 = *(_DWORD *)(a1 + 60);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_54;
  }
  if ((v3 & 1) == 0)
  {
    uint64_t v4 = 0;
    if ((v3 & 2) == 0) {
      goto LABEL_16;
    }
    goto LABEL_10;
  }
  int v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
  if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
    int v3 = *(_DWORD *)(a1 + 60);
  }
  else
  {
    int v6 = 1;
  }
  uint64_t v4 = (v6 + 1);
  if ((v3 & 2) != 0)
  {
LABEL_10:
    int v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
    if ((v7 & 0x80000000) != 0)
    {
      int v8 = 10;
    }
    else if (v7 >= 0x80)
    {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2);
      int v3 = *(_DWORD *)(a1 + 60);
    }
    else
    {
      int v8 = 1;
    }
    uint64_t v4 = (v4 + v8 + 1);
  }
LABEL_16:
  if ((v3 & 4) != 0)
  {
    uint64_t v9 = *(void *)(a1 + 16);
    int v10 = *(unsigned __int8 *)(v9 + 23);
    char v11 = v10;
    uint64_t v12 = *(void *)(v9 + 8);
    if ((v10 & 0x80u) == 0) {
      unint64_t v13 = *(unsigned __int8 *)(v9 + 23);
    }
    else {
      unint64_t v13 = v12;
    }
    if (v13 >= 0x80)
    {
      int v14 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v13, a2);
      int v10 = *(unsigned __int8 *)(v9 + 23);
      uint64_t v12 = *(void *)(v9 + 8);
      int v3 = *(_DWORD *)(a1 + 60);
      char v11 = *(unsigned char *)(v9 + 23);
    }
    else
    {
      int v14 = 1;
    }
    if (v11 < 0) {
      int v10 = v12;
    }
    uint64_t v4 = (v4 + v14 + v10 + 1);
    if ((v3 & 8) == 0)
    {
LABEL_18:
      if ((v3 & 0x10) == 0) {
        goto LABEL_19;
      }
      goto LABEL_36;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_18;
  }
  int v15 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 24);
  if (v15 >= 0x80)
  {
    int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v15, a2);
    int v3 = *(_DWORD *)(a1 + 60);
  }
  else
  {
    int v16 = 1;
  }
  uint64_t v4 = (v4 + v16 + 1);
  if ((v3 & 0x10) == 0)
  {
LABEL_19:
    if ((v3 & 0x20) == 0) {
      goto LABEL_20;
    }
    goto LABEL_40;
  }
LABEL_36:
  uint64_t v17 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 28);
  if (v17 >= 0x80)
  {
    int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v17, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 60);
  }
  else
  {
    int v18 = 2;
  }
  uint64_t v4 = (v18 + v4);
  if ((v3 & 0x20) == 0)
  {
LABEL_20:
    if ((v3 & 0x40) == 0) {
      goto LABEL_21;
    }
    goto LABEL_44;
  }
LABEL_40:
  xpc_object_t v19 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 32);
  if (v19 >= 0x80)
  {
    int v20 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v19, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 60);
  }
  else
  {
    int v20 = 2;
  }
  uint64_t v4 = (v20 + v4);
  if ((v3 & 0x40) == 0)
  {
LABEL_21:
    if ((v3 & 0x80) == 0) {
      goto LABEL_54;
    }
    goto LABEL_48;
  }
LABEL_44:
  int v21 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 36);
  if (v21 >= 0x80)
  {
    int v22 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v21, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 60);
  }
  else
  {
    int v22 = 2;
  }
  uint64_t v4 = (v22 + v4);
  if ((v3 & 0x80) != 0)
  {
LABEL_48:
    xpc_object_t v23 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 40);
    if ((v23 & 0x80000000) != 0)
    {
      int v24 = 11;
    }
    else if (v23 >= 0x80)
    {
      int v24 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v23, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 60);
    }
    else
    {
      int v24 = 2;
    }
    uint64_t v4 = (v24 + v4);
  }
LABEL_54:
  if ((v3 & 0xFF00) == 0) {
    goto LABEL_71;
  }
  if ((v3 & 0x100) != 0)
  {
    int v25 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 44);
    if (v25 >= 0x80)
    {
      int v26 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v25, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 60);
    }
    else
    {
      int v26 = 2;
    }
    uint64_t v4 = (v26 + v4);
    if ((v3 & 0x200) == 0)
    {
LABEL_57:
      if ((v3 & 0x400) == 0) {
        goto LABEL_71;
      }
      goto LABEL_67;
    }
  }
  else if ((v3 & 0x200) == 0)
  {
    goto LABEL_57;
  }
  uint64_t v27 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 48);
  if (v27 >= 0x80)
  {
    int v28 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v27, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 60);
  }
  else
  {
    int v28 = 2;
  }
  uint64_t v4 = (v28 + v4);
  if ((v3 & 0x400) != 0)
  {
LABEL_67:
    uint64_t v29 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 52);
    if (v29 >= 0x80) {
      int v30 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v29, a2) + 1;
    }
    else {
      int v30 = 2;
    }
    uint64_t v4 = (v30 + v4);
  }
LABEL_71:
  *(_DWORD *)(a1 + 56) = v4;
  return v4;
}

uint64_t sub_1000D1EBC()
{
  return 1;
}

void *sub_1000D1EC4@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.InsightTypeOutOfService");
}

void sub_1000D1ED4(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v11);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 40);
  if (!(_BYTE)v4) {
    return;
  }
  if ((*(unsigned char *)(a2 + 40) & 1) == 0)
  {
    if ((*(unsigned char *)(a2 + 40) & 2) == 0) {
      goto LABEL_6;
    }
LABEL_10:
    int v6 = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 40) |= 2u;
    *(_DWORD *)(a1 + 32) = v6;
    int v4 = *(_DWORD *)(a2 + 40);
    if ((v4 & 4) == 0)
    {
LABEL_7:
      if ((v4 & 8) == 0) {
        return;
      }
      goto LABEL_16;
    }
    goto LABEL_11;
  }
  uint64_t v5 = *(void *)(a2 + 8);
  *(_DWORD *)(a1 + 40) |= 1u;
  *(void *)(a1 + 8) = v5;
  int v4 = *(_DWORD *)(a2 + 40);
  if ((v4 & 2) != 0) {
    goto LABEL_10;
  }
LABEL_6:
  if ((v4 & 4) == 0) {
    goto LABEL_7;
  }
LABEL_11:
  *(_DWORD *)(a1 + 40) |= 4u;
  uint64_t v7 = *(void *)(a1 + 16);
  if (!v7) {
    operator new();
  }
  uint64_t v8 = *(void *)(a2 + 16);
  if (!v8)
  {
    sub_1000D0988();
    uint64_t v8 = *(void *)(qword_1001D8098 + 16);
  }
  sub_1000D0A20(v7, v8);
  if ((*(_DWORD *)(a2 + 40) & 8) != 0)
  {
LABEL_16:
    *(_DWORD *)(a1 + 40) |= 8u;
    uint64_t v9 = *(void *)(a1 + 24);
    if (!v9) {
      operator new();
    }
    uint64_t v10 = *(void *)(a2 + 24);
    if (!v10)
    {
      sub_1000D0988();
      uint64_t v10 = *(void *)(qword_1001D8098 + 24);
    }
    sub_1000D1080(v9, v10);
  }
}

void sub_1000D20B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1000D20C8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1001BBF08;
  sub_1000D2120((uint64_t)a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1000D2120(uint64_t a1)
{
  sub_1000D0988();
  if (qword_1001D8098 != a1)
  {
    uint64_t v2 = *(void *)(a1 + 16);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3)
    {
      int v4 = *(void (**)(void))(*(void *)v3 + 8);
      v4();
    }
  }
}

void sub_1000D21C8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_1000D20C8(a1);

  operator delete();
}

void sub_1000D2200()
{
}

uint64_t sub_1000D2258(uint64_t result)
{
  uint64_t v1 = result;
  LOBYTE(v2) = *(unsigned char *)(result + 40);
  if ((_BYTE)v2)
  {
    *(void *)(result + 8) = 0;
    *(_DWORD *)(result + 32) = 0;
    if ((v2 & 4) != 0)
    {
      uint64_t v3 = *(void *)(result + 16);
      if (v3)
      {
        if (*(unsigned char *)(v3 + 32))
        {
          *(void *)(v3 + 8) = 0;
          *(void *)(v3 + 16) = 0;
          *(_DWORD *)(v3 + 24) = 0;
        }
        *(_DWORD *)(v3 + 32) = 0;
        int v2 = *(_DWORD *)(result + 40);
      }
    }
    if ((v2 & 8) != 0)
    {
      uint64_t result = *(void *)(result + 24);
      if (result) {
        uint64_t result = sub_1000D1424(result);
      }
    }
  }
  *(_DWORD *)(v1 + 40) = 0;
  return result;
}

uint64_t sub_1000D22C0(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  int v6 = (unsigned int *)(a1 + 32);
  while (2)
  {
    uint64_t v7 = (char *)*((void *)this + 1);
    if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v7;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v7 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v9 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        char v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
          if (!result) {
            return result;
          }
          uint64_t v12 = (unsigned char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          *uint64_t v5 = *v11;
          uint64_t v12 = v11 + 1;
          *((void *)this + 1) = v12;
        }
        *(_DWORD *)(a1 + 40) |= 1u;
        if ((unint64_t)v12 < v10 && *v12 == 16)
        {
          unint64_t v13 = v12 + 1;
          *((void *)this + 1) = v13;
          goto LABEL_26;
        }
        continue;
      case 2u:
        int v9 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        unint64_t v13 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
LABEL_26:
        if ((unint64_t)v13 >= v10 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!result) {
            return result;
          }
          int v16 = (unsigned char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          *int v6 = *v13;
          int v16 = v13 + 1;
          *((void *)this + 1) = v16;
        }
        int v14 = *(_DWORD *)(a1 + 40) | 2;
        *(_DWORD *)(a1 + 40) = v14;
        if ((unint64_t)v16 >= v10 || *v16 != 26) {
          continue;
        }
        *((void *)this + 1) = v16 + 1;
LABEL_34:
        *(_DWORD *)(a1 + 40) = v14 | 4;
        uint64_t v17 = *(void *)(a1 + 16);
        if (!v17) {
          operator new();
        }
        unsigned int v35 = 0;
        int v18 = (char *)*((void *)this + 1);
        if ((unint64_t)v18 >= *((void *)this + 2) || *v18 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v35))return 0; {
        }
          }
        else
        {
          unsigned int v35 = *v18;
          *((void *)this + 1) = v18 + 1;
        }
        int v19 = *((_DWORD *)this + 14);
        int v20 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v19 + 1;
        if (v19 >= v20) {
          return 0;
        }
        int v21 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v35);
        if (!sub_1000D0C28(v17, this, v22) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v21);
        int v23 = *((_DWORD *)this + 14);
        BOOL v24 = __OFSUB__(v23, 1);
        int v25 = v23 - 1;
        if (v25 < 0 == v24) {
          *((_DWORD *)this + 14) = v25;
        }
        int v26 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v26 >= *((void *)this + 2) || *v26 != 34) {
          continue;
        }
        *((void *)this + 1) = v26 + 1;
LABEL_48:
        *(_DWORD *)(a1 + 40) |= 8u;
        uint64_t v27 = *(void *)(a1 + 24);
        if (!v27) {
          operator new();
        }
        unsigned int v36 = 0;
        int v28 = (char *)*((void *)this + 1);
        if ((unint64_t)v28 >= *((void *)this + 2) || *v28 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v36))return 0; {
        }
          }
        else
        {
          unsigned int v36 = *v28;
          *((void *)this + 1) = v28 + 1;
        }
        int v29 = *((_DWORD *)this + 14);
        int v30 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v29 + 1;
        if (v29 < v30)
        {
          int v31 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v36);
          if (sub_1000D1490(v27, this, v32))
          {
            if (*((unsigned char *)this + 36))
            {
              wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v31);
              int v33 = *((_DWORD *)this + 14);
              BOOL v24 = __OFSUB__(v33, 1);
              int v34 = v33 - 1;
              if (v34 < 0 == v24) {
                *((_DWORD *)this + 14) = v34;
              }
              if (*((void *)this + 1) == *((void *)this + 2)
                && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
              {
                *((_DWORD *)this + 8) = 0;
                uint64_t result = 1;
                *((unsigned char *)this + 36) = 1;
                return result;
              }
              continue;
            }
          }
        }
        return 0;
      case 3u:
        int v9 = TagFallback & 7;
        if (v9 != 2) {
          goto LABEL_18;
        }
        int v14 = *(_DWORD *)(a1 + 40);
        goto LABEL_34;
      case 4u:
        int v9 = TagFallback & 7;
        if (v9 != 2) {
          goto LABEL_18;
        }
        goto LABEL_48;
      default:
        int v9 = TagFallback & 7;
LABEL_18:
        if (v9 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

uint64_t sub_1000D26F4(uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 40);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(result + 8), (unint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 40);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_DWORD *)(v5 + 32), a2, a4);
  int v6 = *(_DWORD *)(v5 + 40);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      return result;
    }
    goto LABEL_11;
  }
LABEL_8:
  uint64_t v7 = *(void *)(v5 + 16);
  if (!v7)
  {
    sub_1000D0988();
    uint64_t v7 = *(void *)(qword_1001D8098 + 16);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v7, a2, a4);
  if ((*(_DWORD *)(v5 + 40) & 8) != 0)
  {
LABEL_11:
    uint64_t v8 = *(void *)(v5 + 24);
    if (!v8)
    {
      sub_1000D0988();
      uint64_t v8 = *(void *)(qword_1001D8098 + 24);
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v8, a2, a4);
  }
  return result;
}

uint64_t sub_1000D27C4(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 40);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_26;
  }
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
    int v3 = *(_DWORD *)(a1 + 40);
    if ((v3 & 2) == 0) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 40) & 2) == 0) {
      goto LABEL_11;
    }
  }
  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 32);
  if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 40);
  }
  else
  {
    int v6 = 2;
  }
  uint64_t v4 = (v6 + v4);
LABEL_11:
  if ((v3 & 4) == 0)
  {
    if ((v3 & 8) == 0) {
      goto LABEL_26;
    }
    goto LABEL_20;
  }
  uint64_t v7 = *(void *)(a1 + 16);
  if (!v7)
  {
    sub_1000D0988();
    uint64_t v7 = *(void *)(qword_1001D8098 + 16);
  }
  uint64_t v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1000D0F90(v7, a2);
  int v9 = (int)v8;
  if (v8 >= 0x80) {
    int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2);
  }
  else {
    int v10 = 1;
  }
  uint64_t v4 = (v4 + v9 + v10 + 1);
  if ((*(_DWORD *)(a1 + 40) & 8) != 0)
  {
LABEL_20:
    uint64_t v11 = *(void *)(a1 + 24);
    if (!v11)
    {
      sub_1000D0988();
      uint64_t v11 = *(void *)(qword_1001D8098 + 24);
    }
    uint64_t v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1000D1C44(v11, a2);
    int v14 = (int)v12;
    if (v12 >= 0x80) {
      int v15 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v12, v13);
    }
    else {
      int v15 = 1;
    }
    uint64_t v4 = (v4 + v14 + v15 + 1);
  }
LABEL_26:
  *(_DWORD *)(a1 + 36) = v4;
  return v4;
}

uint64_t sub_1000D28EC()
{
  return 1;
}

void *sub_1000D28F4@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.InsightsConfiguration");
}

uint64_t sub_1000D2904(uint64_t a1)
{
  return *(unsigned int *)(a1 + 28);
}

uint64_t sub_1000D290C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t sub_1000D2914(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

void sub_1000D291C()
{
}

void sub_1000D29F8(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100059E54((uint64_t *)va);
  operator delete();
}

void *sub_1000D2A24(void *a1)
{
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);
  return a1;
}

void sub_1000D2A68(void *a1)
{
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);

  operator delete();
}

void sub_1000D2AD0()
{
}

unsigned char *sub_1000D2AE4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = off_1001BC008;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t sub_1000D2B30(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1001BC008;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

BOOL sub_1000D2B60(uint64_t a1, uint64_t a2, int a3, wireless_diagnostics::google::protobuf::io::CodedInputStream *this)
{
  int v6 = *(_DWORD *)(*(void *)a2 + 12);
  if ((int)wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this) >= 1)
  {
    do
    {
      uint64_t v8 = (char *)*((void *)this + 1);
      if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
        if (!TagFallback) {
          continue;
        }
      }
      else
      {
        unint64_t TagFallback = *v8;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v8 + 1;
        if (!TagFallback) {
          continue;
        }
      }
      unint64_t v10 = wis::reflect::decodeTag((wis::reflect *)TagFallback, v7);
      unint64_t v11 = HIDWORD(v10);
      switch((char)v10)
      {
        case 0:
          *(void *)unsigned int v22 = 0;
          uint64_t v12 = (char *)*((void *)this + 1);
          if ((unint64_t)v12 >= *((void *)this + 2) || *v12 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, (unint64_t *)v22))break; {
          }
            }
          else
          {
            *((void *)this + 1) = v12 + 1;
          }
          goto LABEL_25;
        case 1:
          *(void *)unsigned int v22 = 0;
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v22))break; {
          goto LABEL_25;
          }
        case 2:
          v22[0] = 0;
          unsigned int v13 = (char *)*((void *)this + 1);
          if ((unint64_t)v13 >= *((void *)this + 2) || *v13 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v22))break; {
            int v14 = v22[0];
            }
          }
          else
          {
            int v14 = *v13;
            v22[0] = v14;
            *((void *)this + 1) = v13 + 1;
          }
          int v15 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v14);
          ++*((_DWORD *)this + 14);
          int v16 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
          wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip(this, v16);
          int v17 = *((_DWORD *)this + 14);
          BOOL v18 = __OFSUB__(v17, 1);
          int v19 = v17 - 1;
          if (v19 < 0 == v18) {
            *((_DWORD *)this + 14) = v19;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v15);
LABEL_25:
          if (v6 == v11)
          {
            int v20 = 1;
            return *(unsigned __int8 *)(a1 + 8) == v20;
          }
          break;
        case 5:
          v22[0] = 0;
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v22))break; {
          goto LABEL_25;
          }
        default:
          break;
      }
    }
    while ((int)wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this) > 0);
  }
  int v20 = 0;
  return *(unsigned __int8 *)(a1 + 8) == v20;
}

uint64_t sub_1000D2D68(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1000D2DA8()
{
}

void sub_1000D2E4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double sub_1000D2E5C(uint64_t a1, __n128 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    operator new();
  }

  *(void *)&double result = sub_10001E1D4(v2, a2).n128_u64[0];
  return result;
}

double sub_1000D2F04(void *a1)
{
  uint64_t v1 = (__n128 *)a1[1];
  if (v1) {
    *(void *)&double result = sub_10001E1D4(*(void *)(*a1 + 8), v1).n128_u64[0];
  }
  return result;
}

char *sub_1000D2F1C@<X0>(char *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2)
  {
    long long v5 = 0uLL;
    uint64_t v6 = 0;
    sub_10001E158(&v5, *(const void **)result, *((void *)result + 1), (uint64_t)(*((void *)result + 1) - *(void *)result) >> 2);
    uint64_t v7 = a2;
    *(void *)(a3 + 24) = 0;
    double result = (char *)operator new(0x28uLL);
    *(void *)double result = off_1001BC088;
    *(_OWORD *)(result + 8) = v5;
    *((void *)result + 3) = v6;
    *((void *)result + 4) = a2;
    *(void *)(a3 + 24) = result;
  }
  else
  {
    *(void *)(a3 + 24) = 0;
  }
  return result;
}

void sub_1000D2FB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1000D2FCC@<X0>(char *result@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  if (a2)
  {
    long long v5 = 0uLL;
    uint64_t v6 = 0;
    sub_10001E158(&v5, *(const void **)result, *((void *)result + 1), (uint64_t)(*((void *)result + 1) - *(void *)result) >> 2);
    int v7 = a2;
    *(void *)(a3 + 24) = 0;
    double result = (char *)operator new(0x28uLL);
    *(void *)double result = off_1001BC118;
    *(_OWORD *)(result + 8) = v5;
    *((void *)result + 3) = v6;
    *((_DWORD *)result + 8) = a2;
    *(void *)(a3 + 24) = result;
  }
  else
  {
    *(void *)(a3 + 24) = 0;
  }
  return result;
}

void sub_1000D3064(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000D3080@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  long long v7 = 0uLL;
  uint64_t v8 = 0;
  sub_10001E158(&v7, *(const void **)a1, *(void *)(a1 + 8), (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2);
  double v9 = a3;
  *(void *)(a2 + 24) = 0;
  long long v5 = (char *)operator new(0x28uLL);
  *(void *)long long v5 = off_1001BC198;
  double result = *(double *)&v7;
  *(_OWORD *)(v5 + 8) = v7;
  *((void *)v5 + 3) = v8;
  *((double *)v5 + 4) = a3;
  *(void *)(a2 + 24) = v5;
  return result;
}

void sub_1000D3114(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1000D3130@<X0>(char *result@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  if (a2)
  {
    long long v4 = 0uLL;
    uint64_t v5 = 0;
    sub_10001E158(&v4, *(const void **)result, *((void *)result + 1), (uint64_t)(*((void *)result + 1) - *(void *)result) >> 2);
    *(void *)(a3 + 24) = 0;
    double result = (char *)operator new(0x20uLL);
    *(void *)double result = off_1001BC218;
    *(_OWORD *)(result + 8) = v4;
    *((void *)result + 3) = v5;
    *(void *)(a3 + 24) = result;
  }
  else
  {
    *(void *)(a3 + 24) = 0;
  }
  return result;
}

void sub_1000D31BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000D31D8@<D0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  if ((a2 - 458752) > 0xFFFEFFFF)
  {
    long long v7 = 0uLL;
    uint64_t v8 = 0;
    sub_10001E158(&v7, *(const void **)a1, *(void *)(a1 + 8), (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2);
    int v9 = a2;
    *(void *)(a3 + 24) = 0;
    uint64_t v5 = (char *)operator new(0x28uLL);
    *(void *)uint64_t v5 = off_1001BC298;
    double result = *(double *)&v7;
    *(_OWORD *)(v5 + 8) = v7;
    *((void *)v5 + 3) = v8;
    *((_DWORD *)v5 + 8) = a2;
    *(void *)(a3 + 24) = v5;
  }
  else
  {
    *(void *)(a3 + 24) = 0;
  }
  return result;
}

void sub_1000D327C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000D3298(void *a1)
{
  *a1 = off_1001BC088;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1000D32E8(void *a1)
{
  *a1 = off_1001BC088;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }

  operator delete();
}

void *sub_1000D3358(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_1001BC088;
  v2[2] = 0;
  v2[3] = 0;
  v2[1] = 0;
  sub_10001E158(v2 + 1, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2);
  v2[4] = *(void *)(a1 + 32);
  return v2;
}

void sub_1000D33C4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000D33D8(uint64_t a1, void *a2)
{
  *a2 = off_1001BC088;
  a2[2] = 0;
  a2[3] = 0;
  a2[1] = 0;
  double result = sub_10001E158(a2 + 1, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2);
  a2[4] = *(void *)(a1 + 32);
  return result;
}

void sub_1000D343C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void sub_1000D3454(void *__p)
{
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

uint64_t sub_1000D3498(uint64_t a1, void *a2)
{
  __n128 v25 = 0uLL;
  uint64_t v26 = 0;
  int v3 = (uint64_t *)a2[1];
  if (!v3) {
    int v3 = *(uint64_t **)(*a2 + 8);
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1] - *v3;
  v16[0] = 0;
  v16[1] = v4;
  v16[2] = v4 + (int)v5;
  int v17 = v5;
  uint64_t v18 = 0;
  __int16 v19 = 0;
  long long v21 = xmmword_100174830;
  int v20 = v5;
  int v22 = wireless_diagnostics::google::protobuf::io::CodedInputStream::default_recursion_limit_;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v6 = *(void *)(a1 + 32);
  sub_1000D4084((uint64_t)v11, (uint64_t)(a2 + 2), (uint64_t)&v25, a1 + 8);
  uint64_t v15 = v6;
  v10[0] = 0;
  v10[1] = 0;
  void v10[2] = 0xFFFFFFFFLL;
  if (sub_1000D36C4((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v16, (uint64_t)v10, (uint64_t)v11))
  {
    int v7 = v14[64];
    sub_100038238((uint64_t)v14);
    if (v13) {
      sub_10000B678(v13);
    }
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v12);
    wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v11);
    wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v16);
    if (v7)
    {
      sub_1000D2E5C((uint64_t)a2, &v25);
      uint64_t v8 = 1;
      goto LABEL_12;
    }
  }
  else
  {
    sub_100038238((uint64_t)v14);
    if (v13) {
      sub_10000B678(v13);
    }
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v12);
    wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v11);
    wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v16);
  }
  uint64_t v8 = 0;
LABEL_12:
  if (v25.n128_u64[0])
  {
    v25.n128_u64[1] = v25.n128_u64[0];
    operator delete((void *)v25.n128_u64[0]);
  }
  return v8;
}

void sub_1000D35FC(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)(v1 - 56);
  if (v3)
  {
    *(void *)(v1 - 48) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D3618(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  sub_100038238(v20 + 96);
  if (a20) {
    sub_10000B678(a20);
  }
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)&a14);
  wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)&a12);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream((wireless_diagnostics::google::protobuf::io::CodedInputStream *)(v21 - 136));
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1000D35D0);
  }
  JUMPOUT(0x1000D3600);
}

uint64_t sub_1000D3678(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1000D36B8()
{
}

uint64_t sub_1000D36C4(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a2, uint64_t a3)
{
  int v7 = (unsigned __int8 *)*((void *)this + 1);
  if ((unint64_t)v7 >= *((void *)this + 2) || (char)*v7 < 0)
  {
    unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = TagFallback;
    if (TagFallback) {
      goto LABEL_4;
    }
LABEL_10:
    if (*((unsigned char *)this + 36))
    {
LABEL_49:
      char v3 = 1;
      return v3 & 1;
    }
LABEL_11:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
LABEL_111:
  }
  unint64_t TagFallback = *v7;
  *((_DWORD *)this + 8) = TagFallback;
  *((void *)this + 1) = v7 + 1;
  if (!TagFallback) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v9 = wis::reflect::decodeTag((wis::reflect *)TagFallback, a2);
  char v10 = v9;
  v80[0] = HIDWORD(v9);
  long long v76 = *(_OWORD *)a2;
  uint64_t v77 = *(void *)(a2 + 16);
  MetricFileMetadataHelper::getSubfieldType();
  long long v73 = v78;
  uint64_t v74 = v79;
  int BuiltinType = MetadataHelper::getBuiltinType();
  int v75 = BuiltinType;
  int DecodingType = wis::reflect::getDecodingType();
  switch(DecodingType)
  {
    case 0:
      switch(v10)
      {
        case 0:
          *(void *)v66 = 0;
          if (!sub_100038330(this, (unint64_t *)v66)) {
            goto LABEL_47;
          }
          unint64_t v32 = *(void *)v66;
          long long v55 = *(_OWORD *)a2;
          uint64_t v56 = *(void *)(a2 + 16);
          uint64_t v33 = v80[0];
          int v34 = &v55;
          uint64_t v35 = a3;
          unsigned int v36 = 0;
          goto LABEL_108;
        case 1:
          *(void *)v66 = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v66))goto LABEL_47; {
          unint64_t v32 = *(void *)v66;
          }
          long long v51 = *(_OWORD *)a2;
          uint64_t v52 = *(void *)(a2 + 16);
          uint64_t v33 = v80[0];
          int v34 = &v51;
          uint64_t v35 = a3;
          unsigned int v36 = 1;
          goto LABEL_108;
        case 2:
          v69[0] = 0;
          if ((sub_100038360(this, v69) & 1) == 0) {
            goto LABEL_47;
          }
          sub_10003908C(v66, v69[0]);
          char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v66, v69[0]);
          if ((Raw & 1) == 0) {
            goto LABEL_96;
          }
          char v48 = sub_1000D5040(a3, *(const void **)v66, (unint64_t)&v67[-*(void *)v66]);
          goto LABEL_95;
        case 5:
          v66[0] = 0;
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v66))goto LABEL_47; {
          unint64_t v32 = v66[0];
          }
          long long v53 = *(_OWORD *)a2;
          uint64_t v54 = *(void *)(a2 + 16);
          uint64_t v33 = v80[0];
          int v34 = &v53;
          uint64_t v35 = a3;
          unsigned int v36 = 5;
LABEL_108:
          char v42 = sub_1000D4F1C(v35, v32, (uint64_t)v34, v33, v36);
          goto LABEL_77;
        default:
          goto LABEL_47;
      }
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      *(void *)v66 = 0;
      switch(v10)
      {
        case 0:
          unsigned int v13 = (char *)*((void *)this + 1);
          if ((unint64_t)v13 < *((void *)this + 2) && (*v13 & 0x80000000) == 0)
          {
            *(void *)v66 = *v13;
            *((void *)this + 1) = v13 + 1;
            goto LABEL_76;
          }
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, (unint64_t *)v66))goto LABEL_76; {
          if (!v80[0] && *((unsigned char *)this + 36))
          }
            goto LABEL_49;
LABEL_57:
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        case 1:
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v66))goto LABEL_76; {
          if (v80[0] || !*((unsigned char *)this + 36))
          }
            goto LABEL_57;
          goto LABEL_49;
        case 2:
          if (v80[0] || !*((unsigned char *)this + 36)) {
            goto LABEL_11;
          }
          goto LABEL_49;
        case 5:
          v69[0] = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v69))
          {
            *(void *)v66 = v69[0];
LABEL_76:
            char v42 = sub_1000D410C(BuiltinType, *(uint64_t *)v66, a3, (long long *)a2, v80, &v75);
LABEL_77:
            char v3 = v42;
            return v3 & 1;
          }
          if (!v80[0] && *((unsigned char *)this + 36)) {
            goto LABEL_49;
          }
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        default:
          goto LABEL_76;
      }
      goto LABEL_111;
    case 13:
      v69[0] = 0;
      unsigned int v37 = (char *)*((void *)this + 1);
      if ((unint64_t)v37 >= *((void *)this + 2) || *v37 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v69))goto LABEL_47; {
      }
        }
      else
      {
        v69[0] = *v37;
        *((void *)this + 1) = v37 + 1;
      }
      *(void *)v66 = 0;
      unsigned int v67 = 0;
      CFStringRef v68 = 0;
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
      if (Raw)
      {
        long long v63 = *(_OWORD *)a2;
        uint64_t v64 = *(void *)(a2 + 16);
        char v3 = sub_1000D4C0C(a3, v66);
      }
      if ((SHIBYTE(v68) & 0x80000000) == 0) {
        goto LABEL_99;
      }
      unsigned int v44 = *(void **)v66;
      goto LABEL_98;
    case 14:
      v69[0] = 0;
      unsigned int v40 = (char *)*((void *)this + 1);
      if ((unint64_t)v40 >= *((void *)this + 2) || *v40 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v69))goto LABEL_47; {
        unsigned int v41 = v69[0];
        }
      }
      else
      {
        unsigned int v41 = *v40;
        v69[0] = v41;
        *((void *)this + 1) = v40 + 1;
      }
      sub_10003908C(v66, v41);
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v66, v69[0]);
      if (Raw)
      {
        long long v61 = *(_OWORD *)a2;
        uint64_t v62 = *(void *)(a2 + 16);
        char v48 = sub_1000D4C90(a3, (uint64_t)v66);
LABEL_95:
        char v3 = v48;
      }
LABEL_96:
      unsigned int v44 = *(void **)v66;
      if (*(void *)v66)
      {
        unsigned int v67 = *(char **)v66;
LABEL_98:
        operator delete(v44);
      }
LABEL_99:
      if (Raw) {
        return v3 & 1;
      }
      goto LABEL_47;
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      unsigned int v72 = 0;
      uint64_t v15 = (unsigned __int8 *)*((void *)this + 1);
      if ((unint64_t)v15 >= *((void *)this + 2) || (char)*v15 < 0)
      {
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v72)) {
          goto LABEL_16;
        }
LABEL_47:
        if (!v80[0] && *((unsigned char *)this + 36)) {
          goto LABEL_49;
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Parsing failed in metric");
        goto LABEL_111;
      }
      unsigned int v72 = *v15;
      *((void *)this + 1) = v15 + 1;
LABEL_16:
      uint64_t v49 = a2;
      uint64_t v50 = a3;
      int UnpackedType = wis::reflect::getUnpackedType();
      int WireTypeForType = wis::reflect::getWireTypeForType();
      *(void *)uint64_t v69 = this;
      int v70 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v72);
      *(void *)v66 = 0;
      unsigned int v67 = 0;
      CFStringRef v68 = 0;
      while (1)
      {
        int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
        if (v17 < 1) {
          break;
        }
        uint64_t v18 = v67;
        if (v67 >= v68)
        {
          uint64_t v20 = *(char **)v66;
          uint64_t v21 = (uint64_t)&v67[-*(void *)v66] >> 3;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 61) {
            sub_10002B5E0();
          }
          uint64_t v23 = (uint64_t)&v68[-*(void *)v66];
          if ((uint64_t)&v68[-*(void *)v66] >> 2 > v22) {
            unint64_t v22 = v23 >> 2;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24)
          {
            __n128 v25 = (char *)sub_100038500((uint64_t)&v68, v24);
            uint64_t v20 = *(char **)v66;
            uint64_t v18 = v67;
          }
          else
          {
            __n128 v25 = 0;
          }
          uint64_t v26 = &v25[8 * v21];
          *(void *)uint64_t v26 = 0;
          __int16 v19 = v26 + 8;
          while (v18 != v20)
          {
            uint64_t v27 = *((void *)v18 - 1);
            v18 -= 8;
            *((void *)v26 - 1) = v27;
            v26 -= 8;
          }
          *(void *)v66 = v26;
          unsigned int v67 = v19;
          CFStringRef v68 = &v25[8 * v24];
          if (v20) {
            operator delete(v20);
          }
        }
        else
        {
          *(void *)unsigned int v67 = 0;
          __int16 v19 = v18 + 8;
        }
        unsigned int v67 = v19;
        switch(WireTypeForType)
        {
          case 0:
            int v28 = (unint64_t *)(v19 - 8);
            int v29 = (char *)*((void *)this + 1);
            if ((unint64_t)v29 >= *((void *)this + 2) || *v29 < 0)
            {
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v28);
LABEL_41:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_44;
              }
            }
            else
            {
              unint64_t *v28 = *v29;
              *((void *)this + 1) = v29 + 1;
            }
            break;
          case 1:
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v19 - 1);
            goto LABEL_41;
          case 2:
            goto LABEL_44;
          case 5:
            unsigned int v65 = 0;
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v65);
            *((void *)v67 - 1) = v65;
            goto LABEL_41;
          default:
            continue;
        }
      }
      char v3 = sub_1000D44EC(DecodingType, (uint64_t *)v66, v50, v49, v80, &UnpackedType);
LABEL_44:
      if (*(void *)v66)
      {
        unsigned int v67 = *(char **)v66;
        operator delete(*(void **)v66);
      }
      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(*(wireless_diagnostics::google::protobuf::io::CodedInputStream **)v69, v70);
      if (v17 > 0) {
        goto LABEL_47;
      }
      return v3 & 1;
    case 27:
      unsigned int v72 = 0;
      uint64_t v38 = (char *)*((void *)this + 1);
      if ((unint64_t)v38 >= *((void *)this + 2) || *v38 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v72))goto LABEL_47; {
        unsigned int v39 = v72;
        }
      }
      else
      {
        unsigned int v39 = *v38;
        unsigned int v72 = v39;
        *((void *)this + 1) = v38 + 1;
      }
      *(void *)v66 = this;
      LODWORD(v67) = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v39);
      ++*((_DWORD *)this + 14);
      *(void *)uint64_t v69 = this;
      long long v59 = *(_OWORD *)a2;
      uint64_t v60 = *(void *)(a2 + 16);
      long long v57 = v78;
      uint64_t v58 = v79;
      char v3 = sub_1000D4D04(a3, this, (uint64_t)&v59, v80[0], &v57);
      sub_1000D6D64((wireless_diagnostics::google::protobuf::io::CodedInputStream **)v69);
      int v45 = *((_DWORD *)this + 14);
      BOOL v46 = __OFSUB__(v45, 1);
      int v47 = v45 - 1;
      if (v47 < 0 == v46) {
        *((_DWORD *)this + 14) = v47;
      }
      sub_100039058((uint64_t)v66);
      return v3 & 1;
    default:
      goto LABEL_47;
  }
}

void sub_1000D3F1C(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 - 224);
  if (v3)
  {
    *(void *)(v1 - 216) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D4084(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)(sub_100009298((void *)a1, a3) + 2);
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::CodedOutputStream(v6, (wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)a1);
  *(void *)(a1 + 48) = v6;
  MetricFileMetadataHelper::MetricFileMetadataHelper();
  *(unsigned char *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = a4;
  return a1;
}

void sub_1000D40E8(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream(v2);
  wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D410C(int a1, uint64_t a2, uint64_t a3, long long *a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 1:
    case 15:
      wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
      char v10 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v11 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v10, v11);
      uint64_t v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      uint64_t v13 = wis::protobuf::NumberConverter<(wis::reflect::Type)1>::encode();
      goto LABEL_4;
    case 2:
    case 16:
      wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
      int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v15 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v14, v15);
      uint64_t v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      uint64_t v13 = wis::protobuf::NumberConverter<(wis::reflect::Type)2>::encode();
LABEL_4:
      uint64_t v16 = v13;
      goto LABEL_19;
    case 3:
    case 17:
      uint64_t v54 = a2;
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v17 = *a5;
      int v18 = *a6;
      __int16 v19 = &v48;
      goto LABEL_17;
    case 4:
    case 18:
      uint64_t v54 = a2;
      long long v44 = *a4;
      uint64_t v45 = *((void *)a4 + 2);
      int v20 = *a5;
      int v21 = *a6;
      unint64_t v22 = &v44;
      goto LABEL_15;
    case 5:
    case 19:
      uint64_t v54 = wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
      long long v46 = *a4;
      uint64_t v47 = *((void *)a4 + 2);
      int v17 = *a5;
      int v18 = *a6;
      __int16 v19 = &v46;
      goto LABEL_17;
    case 6:
    case 20:
      LODWORD(v54) = a2;
      long long v42 = *a4;
      uint64_t v43 = *((void *)a4 + 2);
      int v23 = *a5;
      int v24 = *a6;
      __n128 v25 = &v42;
      goto LABEL_11;
    case 7:
    case 21:
      LODWORD(v54) = a2;
      long long v38 = *a4;
      uint64_t v39 = *((void *)a4 + 2);
      int v26 = *a5;
      int v27 = *a6;
      int v28 = &v38;
      goto LABEL_13;
    case 8:
    case 22:
      LODWORD(v54) = wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
      long long v40 = *a4;
      uint64_t v41 = *((void *)a4 + 2);
      int v23 = *a5;
      int v24 = *a6;
      __n128 v25 = &v40;
LABEL_11:
      uint64_t result = sub_1000D53A0(a3, (unsigned int *)&v54, v25, v23, v24);
      break;
    case 9:
    case 23:
      LODWORD(v54) = a2;
      long long v50 = *a4;
      uint64_t v51 = *((void *)a4 + 2);
      int v26 = *a5;
      int v27 = *a6;
      int v28 = &v50;
LABEL_13:
      uint64_t result = sub_1000D51B0(a3, (unsigned int *)&v54, (uint64_t)v28, v26, v27);
      break;
    case 10:
    case 24:
      long long v52 = *a4;
      uint64_t v53 = *((void *)a4 + 2);
      uint64_t v54 = a2;
      int v20 = *a5;
      int v21 = *a6;
      unint64_t v22 = &v52;
LABEL_15:
      uint64_t result = sub_1000D50B0(a3, &v54, (uint64_t)v22, v20, v21);
      break;
    case 11:
    case 25:
      uint64_t v54 = a2;
      long long v36 = *a4;
      uint64_t v37 = *((void *)a4 + 2);
      int v17 = *a5;
      int v18 = *a6;
      __int16 v19 = &v36;
LABEL_17:
      uint64_t result = sub_1000D52B0(a3, (unint64_t *)&v54, v19, v17, v18);
      break;
    case 12:
    case 26:
      unsigned int v30 = a2 != 0;
      int v31 = *a6;
      unint64_t v32 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v33 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v32, v33);
      uint64_t v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      uint64_t v16 = sub_10003B49C(v31, v30);
LABEL_19:
      int WireTypeForType = wis::reflect::getWireTypeForType();
      switch(WireTypeForType)
      {
        case 5:
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v12, v16);
          break;
        case 1:
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v12, v16);
          break;
        case 0:
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v12, v16);
          break;
      }
      uint64_t result = 1;
      break;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
  return result;
}

void sub_1000D4470(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D44EC(int a1, uint64_t *a2, uint64_t a3, uint64_t a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 15:
      sub_1000385BC(a2, __p);
      int v10 = *a6;
      uint64_t v11 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v11 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v11 - 4) == *a5)
      {
        uint64_t v12 = __p[1];
        if (__p[0] == __p[1]) {
          goto LABEL_11;
        }
      }
      uint64_t v13 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v14 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v13, v14);
      sub_10003C2D0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v10, (uint64_t *)__p);
      goto LABEL_10;
    case 16:
      sub_1000386C8(a2, __p);
      int v15 = *a6;
      uint64_t v16 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v16 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v16 - 4) == *a5)
      {
        uint64_t v12 = __p[1];
        if (__p[0] == __p[1]) {
          goto LABEL_11;
        }
      }
      int v17 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v18 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v17, v18);
      sub_10003D7B4(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v15, (uint64_t *)__p);
LABEL_10:
      uint64_t v12 = __p[0];
LABEL_11:
      if (v12)
      {
        __p[1] = v12;
        operator delete(v12);
      }
      return 1;
    case 17:
      sub_100038538(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v20 = *a6;
      int v21 = sub_1000D5714(a3, (unint64_t **)v48, (uint64_t)__p, *a5);
      if (v21 == 3) {
        goto LABEL_42;
      }
      if (!v21) {
        goto LABEL_40;
      }
      goto LABEL_41;
    case 18:
      sub_100038538(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v22 = *a6;
      int v23 = sub_1000D5590(a3, (uint64_t)v48, (uint64_t)__p, *a5);
      if (v23 == 3) {
        goto LABEL_42;
      }
      if (!v23) {
        goto LABEL_19;
      }
      goto LABEL_41;
    case 19:
      sub_1000387D4(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v20 = *a6;
      int v26 = sub_1000D5714(a3, (unint64_t **)v48, (uint64_t)__p, *a5);
      if (v26 == 3) {
        goto LABEL_42;
      }
      if (!v26) {
        goto LABEL_40;
      }
      goto LABEL_41;
    case 20:
      sub_100038644(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v27 = *a6;
      int v28 = sub_1000D57C0(a3, (unsigned int **)v48, (uint64_t)__p, *a5);
      if (v28 == 3) {
        goto LABEL_42;
      }
      if (!v28) {
        goto LABEL_25;
      }
      goto LABEL_41;
    case 21:
      sub_100038644(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v31 = *a6;
      int v32 = sub_1000D5604(a3, (uint64_t)v48, (uint64_t)__p, *a5);
      if (v32 == 3) {
        goto LABEL_42;
      }
      if (!v32) {
        goto LABEL_28;
      }
      goto LABEL_41;
    case 22:
      sub_10003885C(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v27 = *a6;
      int v35 = sub_1000D57C0(a3, (unsigned int **)v48, (uint64_t)__p, *a5);
      if (v35 == 3) {
        goto LABEL_42;
      }
      if (!v35)
      {
LABEL_25:
        int v29 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v30 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v29, v30);
        sub_10003F9B0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v27, (uint64_t *)v48);
      }
      goto LABEL_41;
    case 23:
      sub_100038644(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v31 = *a6;
      int v36 = sub_1000D5604(a3, (uint64_t)v48, (uint64_t)__p, *a5);
      if (v36 == 3) {
        goto LABEL_42;
      }
      if (!v36)
      {
LABEL_28:
        unsigned int v33 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v34 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v33, v34);
        sub_10003CD54(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v31, (uint64_t *)v48);
      }
      goto LABEL_41;
    case 24:
      sub_100038538(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v22 = *a6;
      int v37 = sub_1000D5590(a3, (uint64_t)v48, (uint64_t)__p, *a5);
      if (v37 == 3) {
        goto LABEL_42;
      }
      if (!v37)
      {
LABEL_19:
        int v24 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v25 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v24, v25);
        sub_10003B870(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v22, (uint64_t *)v48);
      }
      goto LABEL_41;
    case 25:
      sub_100038538(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v20 = *a6;
      int v38 = sub_1000D5714(a3, (unint64_t **)v48, (uint64_t)__p, *a5);
      if (v38 == 3)
      {
LABEL_42:
        uint64_t v19 = 0;
      }
      else
      {
        if (!v38)
        {
LABEL_40:
          uint64_t v39 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v40 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v39, v40);
          sub_10003EF50(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v20, (uint64_t *)v48);
        }
LABEL_41:
        uint64_t v19 = 1;
      }
      uint64_t v41 = v48[0];
      if (v48[0])
      {
        v48[1] = v48[0];
LABEL_45:
        operator delete(v41);
      }
      return v19;
    case 26:
      sub_100038750((uint64_t)a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v43 = *a6;
      int v44 = sub_1000D5678(a3, (uint64_t **)v48, (uint64_t)__p, *a5);
      if (v44 == 3)
      {
        uint64_t v19 = 0;
      }
      else
      {
        if (!v44)
        {
          uint64_t v45 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v46 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v45, v46);
          sub_10003E238(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v43, (uint64_t *)v48);
        }
        uint64_t v19 = 1;
      }
      uint64_t v41 = v48[0];
      if (!v48[0]) {
        return v19;
      }
      goto LABEL_45;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
}

void sub_1000D4B68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D4C0C(uint64_t a1, void *a2)
{
  uint64_t v4 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  unsigned int v5 = wis::reflect::encodeTag();
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v4, v5);
  uint64_t v6 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  unint64_t v7 = a2[1];
  if (*((char *)a2 + 23) >= 0)
  {
    unint64_t v8 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = (void *)*a2;
    unint64_t v8 = v7;
  }
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v6, v8);
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v6, a2, v8);
  return 1;
}

uint64_t sub_1000D4C90(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  unsigned int v5 = wis::reflect::encodeTag();
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v4, v5);
  uint64_t v6 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  unint64_t v7 = *(const void **)a2;
  unint64_t v8 = *(void *)(a2 + 8) - *(void *)a2;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v6, v8);
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v6, v7, v8);
  return 1;
}

BOOL sub_1000D4D04(uint64_t a1, wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a3, int a4, long long *a5)
{
  unint64_t v7 = *(void *)(a1 + 168);
  uint64_t v8 = **(void **)(a1 + 176);
  if (v7 < (*(void *)(*(void *)(a1 + 176) + 8) - v8) >> 2 && *(_DWORD *)(v8 + 4 * v7) == a4)
  {
    *(void *)(a1 + 168) = v7 + 1;
    std::string __p = 0;
    int v27 = 0;
    uint64_t v28 = 0;
    sub_100009298(v25, (uint64_t)&__p);
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v24, (wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v25);
    uint64_t v10 = *(void *)(a1 + 48);
    *(void *)(a1 + 48) = v24;
    while (1)
    {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
      BOOL v12 = v11 < 1;
      if (v11 < 1) {
        break;
      }
      long long v22 = *a5;
      uint64_t v23 = *((void *)a5 + 2);
      if ((sub_1000D586C(this, (uint64_t)&v22, a1) & 1) == 0) {
        goto LABEL_12;
      }
    }
    --*(void *)(a1 + 168);
    *(void *)(a1 + 48) = v10;
LABEL_12:
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v24);
    wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v25);
    if (v11 <= 0)
    {
      unsigned int v18 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      unsigned int v19 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v18, v19);
      int v20 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      int v21 = __p;
      LODWORD(v18) = v27 - __p;
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v20, v27 - (unsigned char *)__p);
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v20, v21, (int)v18);
    }
    if (__p)
    {
      int v27 = __p;
      operator delete(__p);
    }
  }
  else
  {
    v24[0] = 0;
    LODWORD(__p) = 0;
    wireless_diagnostics::google::protobuf::io::CodedInputStream::GetDirectBufferPointer(this, (const void **)v24, (int *)&__p);
    LODWORD(__p) = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
    if ((__p & 0x80000000) == 0)
    {
      uint64_t v13 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      unsigned int v14 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v13, v14);
      int v15 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      uint64_t v16 = v24[0];
      LODWORD(v13) = __p;
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v15, (int)__p);
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v15, v16, (int)v13);
    }
    return 1;
  }
  return v12;
}

void sub_1000D4ED8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000D4F1C(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  if (a5 != 5)
  {
    if (a5 > 1) {
      return 1;
    }
    BOOL v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    unsigned int v13 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v12, v13);
    unsigned int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    if (WireTypeForType != 5)
    {
      if (WireTypeForType != 1)
      {
        if (!WireTypeForType)
        {
          int v11 = v14;
          unint64_t v10 = a2;
          goto LABEL_12;
        }
        return 1;
      }
      uint64_t v16 = v14;
      unint64_t v10 = a2;
LABEL_16:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v16, v10);
      return 1;
    }
LABEL_13:
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v14, a2);
    return 1;
  }
  unint64_t v7 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  unsigned int v8 = wis::reflect::encodeTag();
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v7, v8);
  unsigned int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  int v9 = wis::reflect::getWireTypeForType();
  if (v9 == 5) {
    goto LABEL_13;
  }
  unint64_t v10 = a2;
  if (v9 == 1)
  {
    uint64_t v16 = v14;
    goto LABEL_16;
  }
  if (!v9)
  {
    int v11 = v14;
LABEL_12:
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v10);
  }
  return 1;
}

uint64_t sub_1000D5040(uint64_t a1, const void *a2, unint64_t a3)
{
  uint64_t v6 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  unsigned int v7 = wis::reflect::encodeTag();
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v6, v7);
  unsigned int v8 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v8, a3);
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v8, a2, a3);
  return 1;
}

uint64_t sub_1000D50B0(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v8 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v8 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
    *a2 = (unint64_t)*a2 / *(void *)(a1 + 184) * *(void *)(a1 + 184);
  }
  int v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  wis::reflect::getWireTypeForType();
  unsigned int v10 = wis::reflect::encodeTag();
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
  int v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  uint64_t v12 = sub_10003B200(a5, *a2);
  int WireTypeForType = wis::reflect::getWireTypeForType();
  switch(WireTypeForType)
  {
    case 5:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v11, v12);
      break;
    case 1:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v11, v12);
      break;
    case 0:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v12);
      break;
  }
  return 1;
}

uint64_t sub_1000D51B0(uint64_t a1, unsigned int *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v8 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v8 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
    *a2 = (unint64_t)*a2 / *(void *)(a1 + 184) * *(void *)(a1 + 184);
  }
  int v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  wis::reflect::getWireTypeForType();
  unsigned int v10 = wis::reflect::encodeTag();
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
  int v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  uint64_t v12 = sub_10003B350(a5, *a2);
  int WireTypeForType = wis::reflect::getWireTypeForType();
  switch(WireTypeForType)
  {
    case 5:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v11, v12);
      break;
    case 1:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v11, v12);
      break;
    case 0:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v12);
      break;
  }
  return 1;
}

uint64_t sub_1000D52B0(uint64_t a1, unint64_t *a2, long long *a3, int a4, int a5)
{
  long long v15 = *a3;
  uint64_t v16 = *((void *)a3 + 2);
  int v8 = sub_1000D5490(a1, a2, (uint64_t)&v15, a4);
  if (v8 == 3) {
    return 0;
  }
  if (!v8)
  {
    int v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v10 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
    int v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v12 = sub_10003B5D4(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v11, v12);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v11, v12);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v12);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000D53A0(uint64_t a1, unsigned int *a2, long long *a3, int a4, int a5)
{
  long long v15 = *a3;
  uint64_t v16 = *((void *)a3 + 2);
  int v8 = sub_1000D5510(a1, a2, (uint64_t)&v15, a4);
  if (v8 == 3) {
    return 0;
  }
  if (!v8)
  {
    int v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v10 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
    int v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v12 = sub_10003B724(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v11, v12);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v11, v12);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v12);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000D5490(uint64_t a1, unint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v4 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v4 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
    unint64_t v5 = *a2;
    unint64_t v6 = *(void *)(a1 + 184);
    if ((*a2 & 0x8000000000000000) != 0)
    {
      unint64_t v8 = 0x8000000000000000;
      if (v5 == 0x8000000000000000 || (uint64_t)0x8000000000000000 / (uint64_t)v6 * v6 > v5) {
        goto LABEL_8;
      }
      unint64_t v7 = ~(-(uint64_t)v5 / v6);
    }
    else
    {
      unint64_t v7 = v5 / v6;
    }
    unint64_t v8 = v7 * v6;
LABEL_8:
    *a2 = v8;
  }
  return 0;
}

uint64_t sub_1000D5510(uint64_t a1, unsigned int *a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v4 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v4 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
    unint64_t v5 = *a2;
    unint64_t v6 = *(void *)(a1 + 184);
    if ((v5 & 0x80000000) != 0)
    {
      unsigned int v8 = 0x80000000;
      if (v5 == 0x80000000 || (int)0x80000000 / (int)v6 * (int)v6 > v5) {
        goto LABEL_8;
      }
      unint64_t v7 = ~(-(int)v5 / v6);
    }
    else
    {
      unint64_t v7 = v5 / v6;
    }
    unsigned int v8 = v7 * v6;
LABEL_8:
    *a2 = v8;
  }
  return 0;
}

uint64_t sub_1000D5590(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) != ((v4 - **(void **)(a1 + 176)) >> 2) - 1 || *(_DWORD *)(v4 - 4) != a4) {
    return 0;
  }
  unint64_t v5 = *(void **)a2;
  unint64_t v6 = *(void **)(a2 + 8);
  if (*(void **)a2 == v6) {
    return 1;
  }
  do
  {
    *unint64_t v5 = *v5 / *(void *)(a1 + 184) * *(void *)(a1 + 184);
    ++v5;
  }
  while (v5 != v6);
  uint64_t v7 = 0;
  *(unsigned char *)(a1 + 160) = 1;
  return v7;
}

uint64_t sub_1000D5604(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) != ((v4 - **(void **)(a1 + 176)) >> 2) - 1 || *(_DWORD *)(v4 - 4) != a4) {
    return 0;
  }
  unint64_t v5 = *(_DWORD **)a2;
  unint64_t v6 = *(_DWORD **)(a2 + 8);
  if (*(_DWORD **)a2 == v6) {
    return 1;
  }
  unint64_t v7 = *(void *)(a1 + 184);
  do
  {
    *unint64_t v5 = *v5 / v7 * v7;
    ++v5;
  }
  while (v5 != v6);
  uint64_t v8 = 0;
  *(unsigned char *)(a1 + 160) = 1;
  return v8;
}

BOOL sub_1000D5678(uint64_t a1, uint64_t **a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) != ((v4 - **(void **)(a1 + 176)) >> 2) - 1 || *(_DWORD *)(v4 - 4) != a4) {
    return 0;
  }
  if (!a2[1]) {
    return 1;
  }
  int v5 = 0;
  unint64_t v6 = *a2;
  unint64_t v7 = *a2;
  do
  {
    if ((*v7 & (1 << v5)) != 0) {
      uint64_t v8 = *v7 | (1 << v5);
    }
    else {
      uint64_t v8 = *v7 & ~(1 << v5);
    }
    uint64_t *v7 = v8;
    v7 += v5 == 63;
    if (v5 == 63) {
      int v5 = 0;
    }
    else {
      ++v5;
    }
    unint64_t v9 = (unint64_t)a2[1];
  }
  while (v7 != &v6[v9 >> 6] || v5 != (v9 & 0x3F));
  return !v9;
}

uint64_t sub_1000D5714(uint64_t a1, unint64_t **a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) != ((v4 - **(void **)(a1 + 176)) >> 2) - 1 || *(_DWORD *)(v4 - 4) != a4) {
    return 0;
  }
  int v5 = *a2;
  unint64_t v6 = a2[1];
  if (*a2 == v6) {
    return 1;
  }
  do
  {
    unint64_t v7 = *v5;
    unint64_t v8 = *(void *)(a1 + 184);
    if ((*v5 & 0x8000000000000000) == 0)
    {
      unint64_t v9 = v7 / v8;
LABEL_6:
      unint64_t v10 = v9 * v8;
      goto LABEL_9;
    }
    unint64_t v10 = 0x8000000000000000;
    if (v7 != 0x8000000000000000 && (uint64_t)0x8000000000000000 / (uint64_t)v8 * v8 <= v7)
    {
      unint64_t v9 = ~(-(uint64_t)v7 / v8);
      goto LABEL_6;
    }
LABEL_9:
    *v5++ = v10;
  }
  while (v5 != v6);
  uint64_t v12 = 0;
  *(unsigned char *)(a1 + 160) = 1;
  return v12;
}

uint64_t sub_1000D57C0(uint64_t a1, unsigned int **a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) != ((v4 - **(void **)(a1 + 176)) >> 2) - 1 || *(_DWORD *)(v4 - 4) != a4) {
    return 0;
  }
  int v5 = *a2;
  unint64_t v6 = a2[1];
  if (*a2 == v6) {
    return 1;
  }
  unint64_t v7 = *(void *)(a1 + 184);
  do
  {
    unint64_t v8 = *v5;
    if ((v8 & 0x80000000) == 0)
    {
      unint64_t v9 = v8 / v7;
LABEL_7:
      unsigned int v10 = v9 * v7;
      goto LABEL_10;
    }
    unsigned int v10 = 0x80000000;
    if (v8 != 0x80000000 && (int)0x80000000 / (int)v7 * (int)v7 <= v8)
    {
      unint64_t v9 = ~(-(int)v8 / v7);
      goto LABEL_7;
    }
LABEL_10:
    *v5++ = v10;
  }
  while (v5 != v6);
  uint64_t v12 = 0;
  *(unsigned char *)(a1 + 160) = 1;
  return v12;
}

uint64_t sub_1000D586C(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a2, uint64_t a3)
{
  unint64_t v7 = (unsigned __int8 *)*((void *)this + 1);
  if ((unint64_t)v7 >= *((void *)this + 2) || (char)*v7 < 0)
  {
    unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = TagFallback;
    if (TagFallback) {
      goto LABEL_4;
    }
LABEL_10:
    if (*((unsigned char *)this + 36))
    {
LABEL_49:
      char v3 = 1;
      return v3 & 1;
    }
LABEL_11:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
LABEL_111:
  }
  unint64_t TagFallback = *v7;
  *((_DWORD *)this + 8) = TagFallback;
  *((void *)this + 1) = v7 + 1;
  if (!TagFallback) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v9 = wis::reflect::decodeTag((wis::reflect *)TagFallback, a2);
  char v10 = v9;
  unsigned int v73 = HIDWORD(v9);
  MetricFileMetadataHelper::getSubfieldType();
  *(_OWORD *)uint64_t v74 = v71;
  int v75 = v72;
  int BuiltinType = MetadataHelper::getBuiltinType();
  int v70 = BuiltinType;
  int DecodingType = wis::reflect::getDecodingType();
  switch(DecodingType)
  {
    case 0:
      switch(v10)
      {
        case 0:
          *(void *)uint64_t v74 = 0;
          if (!sub_100038330(this, (unint64_t *)v74)) {
            goto LABEL_47;
          }
          unint64_t v32 = *(void *)v74;
          long long v55 = *(_OWORD *)a2;
          uint64_t v56 = *(void *)(a2 + 16);
          uint64_t v33 = v73;
          unsigned int v34 = &v55;
          uint64_t v35 = a3;
          unsigned int v36 = 0;
          goto LABEL_108;
        case 1:
          *(void *)uint64_t v74 = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v74))goto LABEL_47; {
          unint64_t v32 = *(void *)v74;
          }
          long long v51 = *(_OWORD *)a2;
          uint64_t v52 = *(void *)(a2 + 16);
          uint64_t v33 = v73;
          unsigned int v34 = &v51;
          uint64_t v35 = a3;
          unsigned int v36 = 1;
          goto LABEL_108;
        case 2:
          v66[0] = 0;
          if ((sub_100038360(this, v66) & 1) == 0) {
            goto LABEL_47;
          }
          sub_10003908C(v74, v66[0]);
          char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v74, v66[0]);
          if ((Raw & 1) == 0) {
            goto LABEL_96;
          }
          char v48 = sub_1000D5040(a3, *(const void **)v74, *(void *)&v74[2] - *(void *)v74);
          goto LABEL_95;
        case 5:
          v74[0] = 0;
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v74))goto LABEL_47; {
          uint64_t v33 = v73;
          }
          unint64_t v32 = v74[0];
          long long v53 = *(_OWORD *)a2;
          uint64_t v54 = *(void *)(a2 + 16);
          unsigned int v34 = &v53;
          uint64_t v35 = a3;
          unsigned int v36 = 5;
LABEL_108:
          char v42 = sub_1000D4F1C(v35, v32, (uint64_t)v34, v33, v36);
          goto LABEL_77;
        default:
          goto LABEL_47;
      }
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      *(void *)uint64_t v74 = 0;
      switch(v10)
      {
        case 0:
          unsigned int v13 = (char *)*((void *)this + 1);
          if ((unint64_t)v13 < *((void *)this + 2) && (*v13 & 0x80000000) == 0)
          {
            *(void *)uint64_t v74 = *v13;
            *((void *)this + 1) = v13 + 1;
            goto LABEL_76;
          }
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, (unint64_t *)v74))goto LABEL_76; {
          if (!v73 && *((unsigned char *)this + 36))
          }
            goto LABEL_49;
LABEL_57:
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        case 1:
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v74))goto LABEL_76; {
          if (v73 || !*((unsigned char *)this + 36))
          }
            goto LABEL_57;
          goto LABEL_49;
        case 2:
          if (v73 || !*((unsigned char *)this + 36)) {
            goto LABEL_11;
          }
          goto LABEL_49;
        case 5:
          v66[0] = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v66))
          {
            *(void *)uint64_t v74 = v66[0];
LABEL_76:
            char v42 = sub_1000D6228(BuiltinType, *(uint64_t *)v74, a3, (long long *)a2, (int *)&v73, &v70);
LABEL_77:
            char v3 = v42;
            return v3 & 1;
          }
          if (!v73 && *((unsigned char *)this + 36)) {
            goto LABEL_49;
          }
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        default:
          goto LABEL_76;
      }
      goto LABEL_111;
    case 13:
      v66[0] = 0;
      int v37 = (char *)*((void *)this + 1);
      if ((unint64_t)v37 >= *((void *)this + 2) || *v37 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v66))goto LABEL_47; {
      }
        }
      else
      {
        v66[0] = *v37;
        *((void *)this + 1) = v37 + 1;
      }
      memset(v74, 0, sizeof(v74));
      int v75 = 0;
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
      if (Raw)
      {
        long long v63 = *(_OWORD *)a2;
        uint64_t v64 = *(void *)(a2 + 16);
        char v3 = sub_1000D4C0C(a3, v74);
      }
      if ((SHIBYTE(v75) & 0x80000000) == 0) {
        goto LABEL_99;
      }
      int v44 = *(void **)v74;
      goto LABEL_98;
    case 14:
      v66[0] = 0;
      unsigned int v40 = (char *)*((void *)this + 1);
      if ((unint64_t)v40 >= *((void *)this + 2) || *v40 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v66))goto LABEL_47; {
        unsigned int v41 = v66[0];
        }
      }
      else
      {
        unsigned int v41 = *v40;
        v66[0] = v41;
        *((void *)this + 1) = v40 + 1;
      }
      sub_10003908C(v74, v41);
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v74, v66[0]);
      if (Raw)
      {
        long long v61 = *(_OWORD *)a2;
        uint64_t v62 = *(void *)(a2 + 16);
        char v48 = sub_1000D4C90(a3, (uint64_t)v74);
LABEL_95:
        char v3 = v48;
      }
LABEL_96:
      int v44 = *(void **)v74;
      if (*(void *)v74)
      {
        *(void *)&v74[2] = *(void *)v74;
LABEL_98:
        operator delete(v44);
      }
LABEL_99:
      if (Raw) {
        return v3 & 1;
      }
      goto LABEL_47;
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      unsigned int v69 = 0;
      long long v15 = (unsigned __int8 *)*((void *)this + 1);
      if ((unint64_t)v15 >= *((void *)this + 2) || (char)*v15 < 0)
      {
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v69)) {
          goto LABEL_16;
        }
LABEL_47:
        if (!v73 && *((unsigned char *)this + 36)) {
          goto LABEL_49;
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Parsing failed in metric");
        goto LABEL_111;
      }
      unsigned int v69 = *v15;
      *((void *)this + 1) = v15 + 1;
LABEL_16:
      uint64_t v49 = a2;
      uint64_t v50 = a3;
      int UnpackedType = wis::reflect::getUnpackedType();
      int WireTypeForType = wis::reflect::getWireTypeForType();
      *(void *)v66 = this;
      int v67 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v69);
      memset(v74, 0, sizeof(v74));
      int v75 = 0;
      while (1)
      {
        int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
        if (v17 < 1) {
          break;
        }
        unsigned int v18 = *(char **)&v74[2];
        if (*(void *)&v74[2] >= (unint64_t)v75)
        {
          int v20 = *(char **)v74;
          uint64_t v21 = (uint64_t)(*(void *)&v74[2] - *(void *)v74) >> 3;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 61) {
            sub_10002B5E0();
          }
          uint64_t v23 = (uint64_t)&v75[-*(void *)v74];
          if ((uint64_t)&v75[-*(void *)v74] >> 2 > v22) {
            unint64_t v22 = v23 >> 2;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24)
          {
            unsigned int v25 = (char *)sub_100038500((uint64_t)&v75, v24);
            int v20 = *(char **)v74;
            unsigned int v18 = *(char **)&v74[2];
          }
          else
          {
            unsigned int v25 = 0;
          }
          int v26 = &v25[8 * v21];
          *(void *)int v26 = 0;
          unsigned int v19 = v26 + 8;
          while (v18 != v20)
          {
            uint64_t v27 = *((void *)v18 - 1);
            v18 -= 8;
            *((void *)v26 - 1) = v27;
            v26 -= 8;
          }
          *(void *)uint64_t v74 = v26;
          *(void *)&v74[2] = v19;
          int v75 = &v25[8 * v24];
          if (v20) {
            operator delete(v20);
          }
        }
        else
        {
          **(void **)&v74[2] = 0;
          unsigned int v19 = v18 + 8;
        }
        *(void *)&v74[2] = v19;
        switch(WireTypeForType)
        {
          case 0:
            uint64_t v28 = v19 - 1;
            int v29 = (char *)*((void *)this + 1);
            if ((unint64_t)v29 >= *((void *)this + 2) || *v29 < 0)
            {
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v28);
LABEL_41:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_44;
              }
            }
            else
            {
              unint64_t *v28 = *v29;
              *((void *)this + 1) = v29 + 1;
            }
            break;
          case 1:
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, v19 - 1);
            goto LABEL_41;
          case 2:
            goto LABEL_44;
          case 5:
            unsigned int v65 = 0;
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v65);
            *(void *)(*(void *)&v74[2] - 8) = v65;
            goto LABEL_41;
          default:
            continue;
        }
      }
      char v3 = sub_1000D6608(DecodingType, (uint64_t *)v74, v50, v49, (int *)&v73, &UnpackedType);
LABEL_44:
      if (*(void *)v74)
      {
        *(void *)&v74[2] = *(void *)v74;
        operator delete(*(void **)v74);
      }
      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(*(wireless_diagnostics::google::protobuf::io::CodedInputStream **)v66, v67);
      if (v17 > 0) {
        goto LABEL_47;
      }
      return v3 & 1;
    case 27:
      unsigned int v69 = 0;
      int v38 = (char *)*((void *)this + 1);
      if ((unint64_t)v38 >= *((void *)this + 2) || *v38 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v69))goto LABEL_47; {
        unsigned int v39 = v69;
        }
      }
      else
      {
        unsigned int v39 = *v38;
        unsigned int v69 = v39;
        *((void *)this + 1) = v38 + 1;
      }
      *(void *)uint64_t v74 = this;
      v74[2] = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v39);
      ++*((_DWORD *)this + 14);
      *(void *)v66 = this;
      long long v59 = *(_OWORD *)a2;
      uint64_t v60 = *(void *)(a2 + 16);
      long long v57 = v71;
      uint64_t v58 = v72;
      char v3 = sub_1000D4D04(a3, this);
      sub_1000D6D28((wireless_diagnostics::google::protobuf::io::CodedInputStream **)v66);
      int v45 = *((_DWORD *)this + 14);
      BOOL v46 = __OFSUB__(v45, 1);
      int v47 = v45 - 1;
      if (v47 < 0 == v46) {
        *((_DWORD *)this + 14) = v47;
      }
      sub_100039058((uint64_t)v74);
      return v3 & 1;
    default:
      goto LABEL_47;
  }
}

void sub_1000D60C0(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 - 112);
  if (v3)
  {
    *(void *)(v1 - 104) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D6228(int a1, uint64_t a2, uint64_t a3, long long *a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 1:
    case 15:
      wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
      char v10 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v11 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v10, v11);
      uint64_t v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      uint64_t v13 = wis::protobuf::NumberConverter<(wis::reflect::Type)1>::encode();
      goto LABEL_4;
    case 2:
    case 16:
      wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
      unsigned int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v15 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v14, v15);
      uint64_t v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      uint64_t v13 = wis::protobuf::NumberConverter<(wis::reflect::Type)2>::encode();
LABEL_4:
      uint64_t v16 = v13;
      goto LABEL_19;
    case 3:
    case 17:
      uint64_t v54 = a2;
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v17 = *a5;
      int v18 = *a6;
      unsigned int v19 = &v48;
      goto LABEL_17;
    case 4:
    case 18:
      uint64_t v54 = a2;
      long long v44 = *a4;
      uint64_t v45 = *((void *)a4 + 2);
      int v20 = *a5;
      int v21 = *a6;
      unint64_t v22 = &v44;
      goto LABEL_15;
    case 5:
    case 19:
      uint64_t v54 = wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
      long long v46 = *a4;
      uint64_t v47 = *((void *)a4 + 2);
      int v17 = *a5;
      int v18 = *a6;
      unsigned int v19 = &v46;
      goto LABEL_17;
    case 6:
    case 20:
      LODWORD(v54) = a2;
      long long v42 = *a4;
      uint64_t v43 = *((void *)a4 + 2);
      int v23 = *a5;
      int v24 = *a6;
      unsigned int v25 = &v42;
      goto LABEL_11;
    case 7:
    case 21:
      LODWORD(v54) = a2;
      long long v38 = *a4;
      uint64_t v39 = *((void *)a4 + 2);
      int v26 = *a5;
      int v27 = *a6;
      uint64_t v28 = &v38;
      goto LABEL_13;
    case 8:
    case 22:
      LODWORD(v54) = wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
      long long v40 = *a4;
      uint64_t v41 = *((void *)a4 + 2);
      int v23 = *a5;
      int v24 = *a6;
      unsigned int v25 = &v40;
LABEL_11:
      uint64_t result = sub_1000D53A0(a3, (unsigned int *)&v54, v25, v23, v24);
      break;
    case 9:
    case 23:
      LODWORD(v54) = a2;
      long long v50 = *a4;
      uint64_t v51 = *((void *)a4 + 2);
      int v26 = *a5;
      int v27 = *a6;
      uint64_t v28 = &v50;
LABEL_13:
      uint64_t result = sub_1000D51B0(a3, (unsigned int *)&v54, (uint64_t)v28, v26, v27);
      break;
    case 10:
    case 24:
      long long v52 = *a4;
      uint64_t v53 = *((void *)a4 + 2);
      uint64_t v54 = a2;
      int v20 = *a5;
      int v21 = *a6;
      unint64_t v22 = &v52;
LABEL_15:
      uint64_t result = sub_1000D50B0(a3, &v54, (uint64_t)v22, v20, v21);
      break;
    case 11:
    case 25:
      uint64_t v54 = a2;
      long long v36 = *a4;
      uint64_t v37 = *((void *)a4 + 2);
      int v17 = *a5;
      int v18 = *a6;
      unsigned int v19 = &v36;
LABEL_17:
      uint64_t result = sub_1000D52B0(a3, (unint64_t *)&v54, v19, v17, v18);
      break;
    case 12:
    case 26:
      unsigned int v30 = a2 != 0;
      int v31 = *a6;
      unint64_t v32 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v33 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v32, v33);
      uint64_t v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      uint64_t v16 = sub_10003B49C(v31, v30);
LABEL_19:
      int WireTypeForType = wis::reflect::getWireTypeForType();
      switch(WireTypeForType)
      {
        case 5:
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v12, v16);
          break;
        case 1:
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v12, v16);
          break;
        case 0:
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v12, v16);
          break;
      }
      uint64_t result = 1;
      break;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
  return result;
}

void sub_1000D658C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D6608(int a1, uint64_t *a2, uint64_t a3, uint64_t a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 15:
      sub_1000385BC(a2, __p);
      int v10 = *a6;
      uint64_t v11 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v11 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v11 - 4) == *a5)
      {
        uint64_t v12 = __p[1];
        if (__p[0] == __p[1]) {
          goto LABEL_11;
        }
      }
      uint64_t v13 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v14 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v13, v14);
      sub_10003C2D0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v10, (uint64_t *)__p);
      goto LABEL_10;
    case 16:
      sub_1000386C8(a2, __p);
      int v15 = *a6;
      uint64_t v16 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v16 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v16 - 4) == *a5)
      {
        uint64_t v12 = __p[1];
        if (__p[0] == __p[1]) {
          goto LABEL_11;
        }
      }
      int v17 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v18 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v17, v18);
      sub_10003D7B4(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v15, (uint64_t *)__p);
LABEL_10:
      uint64_t v12 = __p[0];
LABEL_11:
      if (v12)
      {
        __p[1] = v12;
        operator delete(v12);
      }
      return 1;
    case 17:
      sub_100038538(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v20 = *a6;
      int v21 = sub_1000D5714(a3, (unint64_t **)v48, (uint64_t)__p, *a5);
      if (v21 == 3) {
        goto LABEL_42;
      }
      if (!v21) {
        goto LABEL_40;
      }
      goto LABEL_41;
    case 18:
      sub_100038538(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v22 = *a6;
      int v23 = sub_1000D5590(a3, (uint64_t)v48, (uint64_t)__p, *a5);
      if (v23 == 3) {
        goto LABEL_42;
      }
      if (!v23) {
        goto LABEL_19;
      }
      goto LABEL_41;
    case 19:
      sub_1000387D4(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v20 = *a6;
      int v26 = sub_1000D5714(a3, (unint64_t **)v48, (uint64_t)__p, *a5);
      if (v26 == 3) {
        goto LABEL_42;
      }
      if (!v26) {
        goto LABEL_40;
      }
      goto LABEL_41;
    case 20:
      sub_100038644(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v27 = *a6;
      int v28 = sub_1000D57C0(a3, (unsigned int **)v48, (uint64_t)__p, *a5);
      if (v28 == 3) {
        goto LABEL_42;
      }
      if (!v28) {
        goto LABEL_25;
      }
      goto LABEL_41;
    case 21:
      sub_100038644(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v31 = *a6;
      int v32 = sub_1000D5604(a3, (uint64_t)v48, (uint64_t)__p, *a5);
      if (v32 == 3) {
        goto LABEL_42;
      }
      if (!v32) {
        goto LABEL_28;
      }
      goto LABEL_41;
    case 22:
      sub_10003885C(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v27 = *a6;
      int v35 = sub_1000D57C0(a3, (unsigned int **)v48, (uint64_t)__p, *a5);
      if (v35 == 3) {
        goto LABEL_42;
      }
      if (!v35)
      {
LABEL_25:
        int v29 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v30 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v29, v30);
        sub_10003F9B0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v27, (uint64_t *)v48);
      }
      goto LABEL_41;
    case 23:
      sub_100038644(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v31 = *a6;
      int v36 = sub_1000D5604(a3, (uint64_t)v48, (uint64_t)__p, *a5);
      if (v36 == 3) {
        goto LABEL_42;
      }
      if (!v36)
      {
LABEL_28:
        unsigned int v33 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v34 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v33, v34);
        sub_10003CD54(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v31, (uint64_t *)v48);
      }
      goto LABEL_41;
    case 24:
      sub_100038538(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v22 = *a6;
      int v37 = sub_1000D5590(a3, (uint64_t)v48, (uint64_t)__p, *a5);
      if (v37 == 3) {
        goto LABEL_42;
      }
      if (!v37)
      {
LABEL_19:
        int v24 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v25 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v24, v25);
        sub_10003B870(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v22, (uint64_t *)v48);
      }
      goto LABEL_41;
    case 25:
      sub_100038538(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v20 = *a6;
      int v38 = sub_1000D5714(a3, (unint64_t **)v48, (uint64_t)__p, *a5);
      if (v38 == 3)
      {
LABEL_42:
        uint64_t v19 = 0;
      }
      else
      {
        if (!v38)
        {
LABEL_40:
          uint64_t v39 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v40 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v39, v40);
          sub_10003EF50(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v20, (uint64_t *)v48);
        }
LABEL_41:
        uint64_t v19 = 1;
      }
      uint64_t v41 = v48[0];
      if (v48[0])
      {
        v48[1] = v48[0];
LABEL_45:
        operator delete(v41);
      }
      return v19;
    case 26:
      sub_100038750((uint64_t)a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v43 = *a6;
      int v44 = sub_1000D5678(a3, (uint64_t **)v48, (uint64_t)__p, *a5);
      if (v44 == 3)
      {
        uint64_t v19 = 0;
      }
      else
      {
        if (!v44)
        {
          uint64_t v45 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v46 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v45, v46);
          sub_10003E238(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v43, (uint64_t *)v48);
        }
        uint64_t v19 = 1;
      }
      uint64_t v41 = v48[0];
      if (!v48[0]) {
        return v19;
      }
      goto LABEL_45;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
}

void sub_1000D6C84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

wireless_diagnostics::google::protobuf::io::CodedInputStream **sub_1000D6D28(wireless_diagnostics::google::protobuf::io::CodedInputStream **a1)
{
  int v2 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(*a1);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip(*a1, v2);
  return a1;
}

wireless_diagnostics::google::protobuf::io::CodedInputStream **sub_1000D6D64(wireless_diagnostics::google::protobuf::io::CodedInputStream **a1)
{
  int v2 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(*a1);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip(*a1, v2);
  return a1;
}

void *sub_1000D6DA0(void *a1)
{
  *a1 = off_1001BC118;
  int v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1000D6DF0(void *a1)
{
  *a1 = off_1001BC118;
  int v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }

  operator delete();
}

void *sub_1000D6E60(uint64_t a1)
{
  int v2 = operator new(0x28uLL);
  void *v2 = off_1001BC118;
  v2[2] = 0;
  v2[3] = 0;
  v2[1] = 0;
  sub_10001E158(v2 + 1, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2);
  *((_DWORD *)v2 + 8) = *(_DWORD *)(a1 + 32);
  return v2;
}

void sub_1000D6ECC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000D6EE0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1001BC118;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t result = sub_10001E158((void *)(a2 + 8), *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 32);
  return result;
}

void sub_1000D6F44(uint64_t a1)
{
  int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void sub_1000D6F5C(void *__p)
{
  int v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

uint64_t sub_1000D6FA0(uint64_t a1, void *a2)
{
  __n128 v25 = 0uLL;
  uint64_t v26 = 0;
  char v3 = (uint64_t *)a2[1];
  if (!v3) {
    char v3 = *(uint64_t **)(*a2 + 8);
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1] - *v3;
  v16[0] = 0;
  v16[1] = v4;
  v16[2] = v4 + (int)v5;
  int v17 = v5;
  uint64_t v18 = 0;
  __int16 v19 = 0;
  long long v21 = xmmword_100174830;
  int v20 = v5;
  int v22 = wireless_diagnostics::google::protobuf::io::CodedInputStream::default_recursion_limit_;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  int v6 = *(_DWORD *)(a1 + 32);
  sub_1000D7B8C((uint64_t)v11, (uint64_t)(a2 + 2), (uint64_t)&v25, a1 + 8);
  int v15 = v6;
  v10[0] = 0;
  v10[1] = 0;
  void v10[2] = 0xFFFFFFFFLL;
  if (sub_1000D71CC((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v16, (uint64_t)v10, v11))
  {
    int v7 = v14[64];
    sub_100038238((uint64_t)v14);
    if (v13) {
      sub_10000B678(v13);
    }
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v12);
    wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v11);
    wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v16);
    if (v7)
    {
      sub_1000D2E5C((uint64_t)a2, &v25);
      uint64_t v8 = 1;
      goto LABEL_12;
    }
  }
  else
  {
    sub_100038238((uint64_t)v14);
    if (v13) {
      sub_10000B678(v13);
    }
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v12);
    wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v11);
    wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v16);
  }
  uint64_t v8 = 0;
LABEL_12:
  if (v25.n128_u64[0])
  {
    v25.n128_u64[1] = v25.n128_u64[0];
    operator delete((void *)v25.n128_u64[0]);
  }
  return v8;
}

void sub_1000D7104(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 - 56);
  if (v3)
  {
    *(void *)(v1 - 48) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D7120(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  sub_100038238(v20 + 96);
  if (a20) {
    sub_10000B678(a20);
  }
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)&a14);
  wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)&a12);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream((wireless_diagnostics::google::protobuf::io::CodedInputStream *)(v21 - 136));
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1000D70D8);
  }
  JUMPOUT(0x1000D7108);
}

uint64_t sub_1000D7180(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1000D71C0()
{
}

uint64_t sub_1000D71CC(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a2, void *a3)
{
  int v7 = (unsigned __int8 *)*((void *)this + 1);
  if ((unint64_t)v7 >= *((void *)this + 2) || (char)*v7 < 0)
  {
    unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = TagFallback;
    if (TagFallback) {
      goto LABEL_4;
    }
LABEL_10:
    if (*((unsigned char *)this + 36))
    {
LABEL_49:
      char v3 = 1;
      return v3 & 1;
    }
LABEL_11:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
LABEL_111:
  }
  unint64_t TagFallback = *v7;
  *((_DWORD *)this + 8) = TagFallback;
  *((void *)this + 1) = v7 + 1;
  if (!TagFallback) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v9 = wis::reflect::decodeTag((wis::reflect *)TagFallback, a2);
  char v10 = v9;
  v80[0] = HIDWORD(v9);
  long long v76 = *(_OWORD *)a2;
  uint64_t v77 = *(void *)(a2 + 16);
  MetricFileMetadataHelper::getSubfieldType();
  long long v73 = v78;
  uint64_t v74 = v79;
  int BuiltinType = MetadataHelper::getBuiltinType();
  int v75 = BuiltinType;
  int DecodingType = wis::reflect::getDecodingType();
  switch(DecodingType)
  {
    case 0:
      switch(v10)
      {
        case 0:
          *(void *)v66 = 0;
          if (!sub_100038330(this, (unint64_t *)v66)) {
            goto LABEL_47;
          }
          unint64_t v32 = *(void *)v66;
          long long v55 = *(_OWORD *)a2;
          uint64_t v56 = *(void *)(a2 + 16);
          uint64_t v33 = v80[0];
          unsigned int v34 = &v55;
          uint64_t v35 = (uint64_t)a3;
          unsigned int v36 = 0;
          goto LABEL_108;
        case 1:
          *(void *)v66 = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v66))goto LABEL_47; {
          unint64_t v32 = *(void *)v66;
          }
          long long v51 = *(_OWORD *)a2;
          uint64_t v52 = *(void *)(a2 + 16);
          uint64_t v33 = v80[0];
          unsigned int v34 = &v51;
          uint64_t v35 = (uint64_t)a3;
          unsigned int v36 = 1;
          goto LABEL_108;
        case 2:
          v69[0] = 0;
          if ((sub_100038360(this, v69) & 1) == 0) {
            goto LABEL_47;
          }
          sub_10003908C(v66, v69[0]);
          char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v66, v69[0]);
          if ((Raw & 1) == 0) {
            goto LABEL_96;
          }
          char v48 = sub_1000D5040((uint64_t)a3, *(const void **)v66, (unint64_t)&v67[-*(void *)v66]);
          goto LABEL_95;
        case 5:
          v66[0] = 0;
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v66))goto LABEL_47; {
          unint64_t v32 = v66[0];
          }
          long long v53 = *(_OWORD *)a2;
          uint64_t v54 = *(void *)(a2 + 16);
          uint64_t v33 = v80[0];
          unsigned int v34 = &v53;
          uint64_t v35 = (uint64_t)a3;
          unsigned int v36 = 5;
LABEL_108:
          char v42 = sub_1000D4F1C(v35, v32, (uint64_t)v34, v33, v36);
          goto LABEL_77;
        default:
          goto LABEL_47;
      }
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      *(void *)v66 = 0;
      switch(v10)
      {
        case 0:
          uint64_t v13 = (char *)*((void *)this + 1);
          if ((unint64_t)v13 < *((void *)this + 2) && (*v13 & 0x80000000) == 0)
          {
            *(void *)v66 = *v13;
            *((void *)this + 1) = v13 + 1;
            goto LABEL_76;
          }
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, (unint64_t *)v66))goto LABEL_76; {
          if (!v80[0] && *((unsigned char *)this + 36))
          }
            goto LABEL_49;
LABEL_57:
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        case 1:
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v66))goto LABEL_76; {
          if (v80[0] || !*((unsigned char *)this + 36))
          }
            goto LABEL_57;
          goto LABEL_49;
        case 2:
          if (v80[0] || !*((unsigned char *)this + 36)) {
            goto LABEL_11;
          }
          goto LABEL_49;
        case 5:
          v69[0] = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v69))
          {
            *(void *)v66 = v69[0];
LABEL_76:
            char v42 = sub_1000D7C14(BuiltinType, *(uint64_t *)v66, a3, (long long *)a2, v80, &v75);
LABEL_77:
            char v3 = v42;
            return v3 & 1;
          }
          if (!v80[0] && *((unsigned char *)this + 36)) {
            goto LABEL_49;
          }
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        default:
          goto LABEL_76;
      }
      goto LABEL_111;
    case 13:
      v69[0] = 0;
      int v37 = (char *)*((void *)this + 1);
      if ((unint64_t)v37 >= *((void *)this + 2) || *v37 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v69))goto LABEL_47; {
      }
        }
      else
      {
        v69[0] = *v37;
        *((void *)this + 1) = v37 + 1;
      }
      *(void *)v66 = 0;
      int v67 = 0;
      CFStringRef v68 = 0;
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
      if (Raw)
      {
        long long v63 = *(_OWORD *)a2;
        uint64_t v64 = *(void *)(a2 + 16);
        char v3 = sub_1000D4C0C((uint64_t)a3, v66);
      }
      if ((SHIBYTE(v68) & 0x80000000) == 0) {
        goto LABEL_99;
      }
      int v44 = *(void **)v66;
      goto LABEL_98;
    case 14:
      v69[0] = 0;
      unsigned int v40 = (char *)*((void *)this + 1);
      if ((unint64_t)v40 >= *((void *)this + 2) || *v40 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v69))goto LABEL_47; {
        unsigned int v41 = v69[0];
        }
      }
      else
      {
        unsigned int v41 = *v40;
        v69[0] = v41;
        *((void *)this + 1) = v40 + 1;
      }
      sub_10003908C(v66, v41);
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v66, v69[0]);
      if (Raw)
      {
        long long v61 = *(_OWORD *)a2;
        uint64_t v62 = *(void *)(a2 + 16);
        char v48 = sub_1000D4C90((uint64_t)a3, (uint64_t)v66);
LABEL_95:
        char v3 = v48;
      }
LABEL_96:
      int v44 = *(void **)v66;
      if (*(void *)v66)
      {
        int v67 = *(char **)v66;
LABEL_98:
        operator delete(v44);
      }
LABEL_99:
      if (Raw) {
        return v3 & 1;
      }
      goto LABEL_47;
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      unsigned int v72 = 0;
      int v15 = (unsigned __int8 *)*((void *)this + 1);
      if ((unint64_t)v15 >= *((void *)this + 2) || (char)*v15 < 0)
      {
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v72)) {
          goto LABEL_16;
        }
LABEL_47:
        if (!v80[0] && *((unsigned char *)this + 36)) {
          goto LABEL_49;
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Parsing failed in metric");
        goto LABEL_111;
      }
      unsigned int v72 = *v15;
      *((void *)this + 1) = v15 + 1;
LABEL_16:
      uint64_t v49 = (long long *)a2;
      uint64_t v50 = (uint64_t)a3;
      int UnpackedType = wis::reflect::getUnpackedType();
      int WireTypeForType = wis::reflect::getWireTypeForType();
      *(void *)unsigned int v69 = this;
      int v70 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v72);
      *(void *)v66 = 0;
      int v67 = 0;
      CFStringRef v68 = 0;
      while (1)
      {
        int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
        if (v17 < 1) {
          break;
        }
        uint64_t v18 = v67;
        if (v67 >= v68)
        {
          uint64_t v20 = *(char **)v66;
          uint64_t v21 = (uint64_t)&v67[-*(void *)v66] >> 3;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 61) {
            sub_10002B5E0();
          }
          uint64_t v23 = (uint64_t)&v68[-*(void *)v66];
          if ((uint64_t)&v68[-*(void *)v66] >> 2 > v22) {
            unint64_t v22 = v23 >> 2;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24)
          {
            __n128 v25 = (char *)sub_100038500((uint64_t)&v68, v24);
            uint64_t v20 = *(char **)v66;
            uint64_t v18 = v67;
          }
          else
          {
            __n128 v25 = 0;
          }
          uint64_t v26 = &v25[8 * v21];
          *(void *)uint64_t v26 = 0;
          __int16 v19 = v26 + 8;
          while (v18 != v20)
          {
            uint64_t v27 = *((void *)v18 - 1);
            v18 -= 8;
            *((void *)v26 - 1) = v27;
            v26 -= 8;
          }
          *(void *)v66 = v26;
          int v67 = v19;
          CFStringRef v68 = &v25[8 * v24];
          if (v20) {
            operator delete(v20);
          }
        }
        else
        {
          *(void *)int v67 = 0;
          __int16 v19 = v18 + 8;
        }
        int v67 = v19;
        switch(WireTypeForType)
        {
          case 0:
            int v28 = (unint64_t *)(v19 - 8);
            int v29 = (char *)*((void *)this + 1);
            if ((unint64_t)v29 >= *((void *)this + 2) || *v29 < 0)
            {
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v28);
LABEL_41:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_44;
              }
            }
            else
            {
              unint64_t *v28 = *v29;
              *((void *)this + 1) = v29 + 1;
            }
            break;
          case 1:
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v19 - 1);
            goto LABEL_41;
          case 2:
            goto LABEL_44;
          case 5:
            unsigned int v65 = 0;
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v65);
            *((void *)v67 - 1) = v65;
            goto LABEL_41;
          default:
            continue;
        }
      }
      char v3 = sub_1000D7FCC(DecodingType, (uint64_t *)v66, v50, v49, v80, &UnpackedType);
LABEL_44:
      if (*(void *)v66)
      {
        int v67 = *(char **)v66;
        operator delete(*(void **)v66);
      }
      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(*(wireless_diagnostics::google::protobuf::io::CodedInputStream **)v69, v70);
      if (v17 > 0) {
        goto LABEL_47;
      }
      return v3 & 1;
    case 27:
      unsigned int v72 = 0;
      int v38 = (char *)*((void *)this + 1);
      if ((unint64_t)v38 >= *((void *)this + 2) || *v38 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v72))goto LABEL_47; {
        unsigned int v39 = v72;
        }
      }
      else
      {
        unsigned int v39 = *v38;
        unsigned int v72 = v39;
        *((void *)this + 1) = v38 + 1;
      }
      *(void *)v66 = this;
      LODWORD(v67) = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v39);
      ++*((_DWORD *)this + 14);
      *(void *)unsigned int v69 = this;
      long long v59 = *(_OWORD *)a2;
      uint64_t v60 = *(void *)(a2 + 16);
      long long v57 = v78;
      uint64_t v58 = v79;
      char v3 = sub_1000D86D0((uint64_t)a3, this, (uint64_t)&v59, v80[0], &v57);
      sub_1000DAD30((wireless_diagnostics::google::protobuf::io::CodedInputStream **)v69);
      int v45 = *((_DWORD *)this + 14);
      BOOL v46 = __OFSUB__(v45, 1);
      int v47 = v45 - 1;
      if (v47 < 0 == v46) {
        *((_DWORD *)this + 14) = v47;
      }
      sub_100039058((uint64_t)v66);
      return v3 & 1;
    default:
      goto LABEL_47;
  }
}

void sub_1000D7A24(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 - 224);
  if (v3)
  {
    *(void *)(v1 - 216) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D7B8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)(sub_100009298((void *)a1, a3) + 2);
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::CodedOutputStream(v6, (wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)a1);
  *(void *)(a1 + 48) = v6;
  MetricFileMetadataHelper::MetricFileMetadataHelper();
  *(unsigned char *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = a4;
  return a1;
}

void sub_1000D7BF0(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream(v2);
  wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D7C14(int a1, uint64_t a2, void *a3, long long *a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 1:
    case 15:
      wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
      uint64_t v55 = v10;
      long long v51 = *a4;
      uint64_t v52 = *((void *)a4 + 2);
      return sub_1000D89EC(a3, (double *)&v55, (uint64_t)&v51, *a5);
    case 2:
    case 16:
      wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
      LODWORD(v55) = v12;
      long long v47 = *a4;
      uint64_t v48 = *((void *)a4 + 2);
      return sub_1000D8BF0(a3, (float *)&v55, (uint64_t)&v47, *a5);
    case 3:
    case 17:
      uint64_t v55 = a2;
      long long v45 = *a4;
      uint64_t v46 = *((void *)a4 + 2);
      int v13 = *a5;
      int v14 = *a6;
      int v15 = &v45;
      goto LABEL_16;
    case 4:
    case 18:
      uint64_t v55 = a2;
      long long v41 = *a4;
      uint64_t v42 = *((void *)a4 + 2);
      int v16 = *a5;
      int v17 = *a6;
      uint64_t v18 = &v41;
      goto LABEL_14;
    case 5:
    case 19:
      uint64_t v55 = wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
      long long v43 = *a4;
      uint64_t v44 = *((void *)a4 + 2);
      int v13 = *a5;
      int v14 = *a6;
      int v15 = &v43;
      goto LABEL_16;
    case 6:
    case 20:
      LODWORD(v55) = a2;
      long long v39 = *a4;
      uint64_t v40 = *((void *)a4 + 2);
      int v19 = *a5;
      int v20 = *a6;
      uint64_t v21 = &v39;
      goto LABEL_10;
    case 7:
    case 21:
      LODWORD(v55) = a2;
      long long v35 = *a4;
      uint64_t v36 = *((void *)a4 + 2);
      int v22 = *a5;
      int v23 = *a6;
      unint64_t v24 = &v35;
      goto LABEL_12;
    case 8:
    case 22:
      LODWORD(v55) = wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
      long long v37 = *a4;
      uint64_t v38 = *((void *)a4 + 2);
      int v19 = *a5;
      int v20 = *a6;
      uint64_t v21 = &v37;
LABEL_10:
      uint64_t result = sub_1000D8DF4(a3, (unsigned int *)&v55, (uint64_t)v21, v19, v20);
      break;
    case 9:
    case 23:
      LODWORD(v55) = a2;
      long long v49 = *a4;
      uint64_t v50 = *((void *)a4 + 2);
      int v22 = *a5;
      int v23 = *a6;
      unint64_t v24 = &v49;
LABEL_12:
      uint64_t result = sub_1000D8AEC(a3, (unsigned int *)&v55, (uint64_t)v24, v22, v23);
      break;
    case 10:
    case 24:
      long long v53 = *a4;
      uint64_t v54 = *((void *)a4 + 2);
      uint64_t v55 = a2;
      int v16 = *a5;
      int v17 = *a6;
      uint64_t v18 = &v53;
LABEL_14:
      uint64_t result = sub_1000D88E8(a3, (unint64_t *)&v55, (uint64_t)v18, v16, v17);
      break;
    case 11:
    case 25:
      uint64_t v55 = a2;
      long long v33 = *a4;
      uint64_t v34 = *((void *)a4 + 2);
      int v13 = *a5;
      int v14 = *a6;
      int v15 = &v33;
LABEL_16:
      uint64_t result = sub_1000D8CF0(a3, &v55, (uint64_t)v15, v13, v14);
      break;
    case 12:
    case 26:
      unsigned int v25 = a2 != 0;
      int v26 = *a6;
      uint64_t v27 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a3[6];
      wis::reflect::getWireTypeForType();
      unsigned int v28 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v27, v28);
      int v29 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a3[6];
      uint64_t v30 = sub_10003B49C(v26, v25);
      int WireTypeForType = wis::reflect::getWireTypeForType();
      switch(WireTypeForType)
      {
        case 5:
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v29, v30);
          break;
        case 1:
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v29, v30);
          break;
        case 0:
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v29, v30);
          break;
      }
      uint64_t result = 1;
      break;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
  return result;
}

void sub_1000D7F50(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D7FCC(int a1, uint64_t *a2, uint64_t a3, long long *a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 15:
      sub_1000385BC(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v10 = *a6;
      int v11 = sub_1000D93E0(a3, (char **)__p, (uint64_t)&v48, *a5);
      if (v11 == 3) {
        goto LABEL_36;
      }
      if (!v11)
      {
        int v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v13 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v12, v13);
        sub_10003C2D0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v10, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 16:
      sub_1000386C8(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v14 = *a6;
      int v15 = sub_1000D95B8(a3, (char **)__p, (uint64_t)&v48, *a5);
      if (v15 == 3) {
        goto LABEL_36;
      }
      if (!v15)
      {
        int v16 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v17 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v16, v17);
        sub_10003D7B4(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v14, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 17:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v18 = *a6;
      int v19 = sub_1000D96A4(a3, (uint64_t **)__p, (uint64_t)&v48, *a5);
      if (v19 == 3) {
        goto LABEL_36;
      }
      if (!v19) {
        goto LABEL_34;
      }
      goto LABEL_35;
    case 18:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v20 = *a6;
      int v21 = sub_1000D92F4(a3, (unint64_t **)__p, (uint64_t)&v48, *a5);
      if (v21 == 3) {
        goto LABEL_36;
      }
      if (!v21) {
        goto LABEL_13;
      }
      goto LABEL_35;
    case 19:
      sub_1000387D4(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v18 = *a6;
      int v24 = sub_1000D96A4(a3, (uint64_t **)__p, (uint64_t)&v48, *a5);
      if (v24 == 3) {
        goto LABEL_36;
      }
      if (!v24) {
        goto LABEL_34;
      }
      goto LABEL_35;
    case 20:
      sub_100038644(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v25 = *a6;
      int v26 = sub_1000D9790(a3, (unsigned int **)__p, (uint64_t)&v48, *a5);
      if (v26 == 3) {
        goto LABEL_36;
      }
      if (!v26) {
        goto LABEL_19;
      }
      goto LABEL_35;
    case 21:
      sub_100038644(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v29 = *a6;
      int v30 = sub_1000D94CC(a3, (unsigned int **)__p, (uint64_t)&v48, *a5);
      if (v30 == 3) {
        goto LABEL_36;
      }
      if (!v30) {
        goto LABEL_22;
      }
      goto LABEL_35;
    case 22:
      sub_10003885C(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v25 = *a6;
      int v33 = sub_1000D9790(a3, (unsigned int **)__p, (uint64_t)&v48, *a5);
      if (v33 == 3) {
        goto LABEL_36;
      }
      if (!v33)
      {
LABEL_19:
        uint64_t v27 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v28 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v27, v28);
        sub_10003F9B0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v25, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 23:
      sub_100038644(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v29 = *a6;
      int v34 = sub_1000D94CC(a3, (unsigned int **)__p, (uint64_t)&v48, *a5);
      if (v34 == 3) {
        goto LABEL_36;
      }
      if (!v34)
      {
LABEL_22:
        int v31 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v32 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v31, v32);
        sub_10003CD54(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v29, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 24:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v20 = *a6;
      int v35 = sub_1000D92F4(a3, (unint64_t **)__p, (uint64_t)&v48, *a5);
      if (v35 == 3) {
        goto LABEL_36;
      }
      if (!v35)
      {
LABEL_13:
        int v22 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v23 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v22, v23);
        sub_10003B870(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v20, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 25:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v18 = *a6;
      int v36 = sub_1000D96A4(a3, (uint64_t **)__p, (uint64_t)&v48, *a5);
      if (v36 == 3)
      {
LABEL_36:
        uint64_t v39 = 0;
      }
      else
      {
        if (!v36)
        {
LABEL_34:
          long long v37 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v38 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v37, v38);
          sub_10003EF50(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v18, (uint64_t *)__p);
        }
LABEL_35:
        uint64_t v39 = 1;
      }
      uint64_t v40 = __p[0];
      if (__p[0])
      {
        __p[1] = __p[0];
LABEL_39:
        operator delete(v40);
      }
      return v39;
    case 26:
      sub_100038750((uint64_t)a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v42 = *a6;
      int v43 = sub_1000D5678(a3, (uint64_t **)__p, (uint64_t)&v48, *a5);
      if (v43 == 3)
      {
        uint64_t v39 = 0;
      }
      else
      {
        if (!v43)
        {
          uint64_t v44 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v45 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v44, v45);
          sub_10003E238(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v42, (uint64_t *)__p);
        }
        uint64_t v39 = 1;
      }
      uint64_t v40 = __p[0];
      if (!__p[0]) {
        return v39;
      }
      goto LABEL_39;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
}

void sub_1000D863C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  __cxa_free_exception(v11);
  _Unwind_Resume(a1);
}

BOOL sub_1000D86D0(uint64_t a1, wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a3, int a4, long long *a5)
{
  unint64_t v7 = *(void *)(a1 + 168);
  uint64_t v8 = **(void **)(a1 + 176);
  if (v7 < (*(void *)(*(void *)(a1 + 176) + 8) - v8) >> 2 && *(_DWORD *)(v8 + 4 * v7) == a4)
  {
    *(void *)(a1 + 168) = v7 + 1;
    std::string __p = 0;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    sub_100009298(v25, (uint64_t)&__p);
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v24, (wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v25);
    uint64_t v10 = *(void *)(a1 + 48);
    *(void *)(a1 + 48) = v24;
    while (1)
    {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
      BOOL v12 = v11 < 1;
      if (v11 < 1) {
        break;
      }
      long long v22 = *a5;
      uint64_t v23 = *((void *)a5 + 2);
      if ((sub_1000D987C(this, (uint64_t)&v22, (void *)a1) & 1) == 0) {
        goto LABEL_12;
      }
    }
    --*(void *)(a1 + 168);
    *(void *)(a1 + 48) = v10;
LABEL_12:
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v24);
    wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v25);
    if (v11 <= 0)
    {
      int v18 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      unsigned int v19 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v18, v19);
      int v20 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      int v21 = __p;
      LODWORD(v18) = v27 - __p;
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v20, v27 - (unsigned char *)__p);
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v20, v21, (int)v18);
    }
    if (__p)
    {
      uint64_t v27 = __p;
      operator delete(__p);
    }
  }
  else
  {
    v24[0] = 0;
    LODWORD(__p) = 0;
    wireless_diagnostics::google::protobuf::io::CodedInputStream::GetDirectBufferPointer(this, (const void **)v24, (int *)&__p);
    LODWORD(__p) = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
    if ((__p & 0x80000000) == 0)
    {
      unsigned int v13 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      unsigned int v14 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v13, v14);
      int v15 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      int v16 = v24[0];
      LODWORD(v13) = __p;
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v15, (int)__p);
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v15, v16, (int)v13);
    }
    return 1;
  }
  return v12;
}

void sub_1000D88A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000D88E8(void *a1, unint64_t *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v8 = *(void *)(a1[22] + 8);
  if (a1[21] != ((v8 - *(void *)a1[22]) >> 2) - 1 || *(_DWORD *)(v8 - 4) != a4) {
    goto LABEL_5;
  }
  int v9 = sub_1000D8EF8((uint64_t)a1, a2);
  if (v9 != 3)
  {
    if (v9) {
      return 1;
    }
LABEL_5:
    uint64_t v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[6];
    wis::reflect::getWireTypeForType();
    unsigned int v11 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v10, v11);
    BOOL v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[6];
    uint64_t v13 = sub_10003B200(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v12, v13);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v12, v13);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v12, v13);
        break;
    }
    return 1;
  }
  return 0;
}

uint64_t sub_1000D89EC(void *a1, double *a2, uint64_t a3, int a4)
{
  uint64_t v5 = *(void *)(a1[22] + 8);
  if (a1[21] != ((v5 - *(void *)a1[22]) >> 2) - 1 || *(_DWORD *)(v5 - 4) != a4) {
    goto LABEL_5;
  }
  int v6 = sub_1000D8F70((uint64_t)a1, a2);
  if (v6 != 3)
  {
    if (v6) {
      return 1;
    }
LABEL_5:
    unint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[6];
    wis::reflect::getWireTypeForType();
    unsigned int v8 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v7, v8);
    int v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[6];
    uint64_t v10 = wis::protobuf::NumberConverter<(wis::reflect::Type)1>::encode();
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v9, v10);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v9, v10);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v9, v10);
        break;
    }
    return 1;
  }
  return 0;
}

uint64_t sub_1000D8AEC(void *a1, unsigned int *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v8 = *(void *)(a1[22] + 8);
  if (a1[21] != ((v8 - *(void *)a1[22]) >> 2) - 1 || *(_DWORD *)(v8 - 4) != a4) {
    goto LABEL_5;
  }
  int v9 = sub_1000D9014((uint64_t)a1, a2);
  if (v9 != 3)
  {
    if (v9) {
      return 1;
    }
LABEL_5:
    uint64_t v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[6];
    wis::reflect::getWireTypeForType();
    unsigned int v11 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v10, v11);
    BOOL v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[6];
    uint64_t v13 = sub_10003B350(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v12, v13);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v12, v13);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v12, v13);
        break;
    }
    return 1;
  }
  return 0;
}

uint64_t sub_1000D8BF0(void *a1, float *a2, uint64_t a3, int a4)
{
  uint64_t v5 = *(void *)(a1[22] + 8);
  if (a1[21] != ((v5 - *(void *)a1[22]) >> 2) - 1 || *(_DWORD *)(v5 - 4) != a4) {
    goto LABEL_5;
  }
  int v6 = sub_1000D908C((uint64_t)a1, a2);
  if (v6 != 3)
  {
    if (v6) {
      return 1;
    }
LABEL_5:
    unint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[6];
    wis::reflect::getWireTypeForType();
    unsigned int v8 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v7, v8);
    int v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[6];
    uint64_t v10 = wis::protobuf::NumberConverter<(wis::reflect::Type)2>::encode();
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v9, v10);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v9, v10);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v9, v10);
        break;
    }
    return 1;
  }
  return 0;
}

uint64_t sub_1000D8CF0(void *a1, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v8 = *(void *)(a1[22] + 8);
  if (a1[21] != ((v8 - *(void *)a1[22]) >> 2) - 1 || *(_DWORD *)(v8 - 4) != a4) {
    goto LABEL_5;
  }
  int v9 = sub_1000D913C((uint64_t)a1, a2);
  if (v9 != 3)
  {
    if (v9) {
      return 1;
    }
LABEL_5:
    uint64_t v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[6];
    wis::reflect::getWireTypeForType();
    unsigned int v11 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v10, v11);
    BOOL v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[6];
    uint64_t v13 = sub_10003B5D4(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v12, v13);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v12, v13);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v12, v13);
        break;
    }
    return 1;
  }
  return 0;
}

uint64_t sub_1000D8DF4(void *a1, unsigned int *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v8 = *(void *)(a1[22] + 8);
  if (a1[21] != ((v8 - *(void *)a1[22]) >> 2) - 1 || *(_DWORD *)(v8 - 4) != a4) {
    goto LABEL_5;
  }
  int v9 = sub_1000D9218((uint64_t)a1, a2);
  if (v9 != 3)
  {
    if (v9) {
      return 1;
    }
LABEL_5:
    uint64_t v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[6];
    wis::reflect::getWireTypeForType();
    unsigned int v11 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v10, v11);
    BOOL v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[6];
    uint64_t v13 = sub_10003B724(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v12, v13);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v12, v13);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v12, v13);
        break;
    }
    return 1;
  }
  return 0;
}

uint64_t sub_1000D8EF8(uint64_t a1, unint64_t *a2)
{
  *(unsigned char *)(a1 + 160) = 1;
  unint64_t v3 = *a2;
  unint64_t v4 = *a2;
  unsigned int v5 = *(_DWORD *)(a1 + 184);
  if (*a2) {
    BOOL v6 = v5 > 0x13;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    unsigned int v7 = vcvtpd_u64_f64(log10((double)v3));
    BOOL v8 = v7 >= v5;
    unsigned int v9 = v7 - v5;
    if (v9 != 0 && v8) {
      unint64_t v4 = (unint64_t)__exp10((double)v9);
    }
    v4 *= v3 / v4;
  }
  *a2 = v4;
  return 0;
}

uint64_t sub_1000D8F70(uint64_t a1, double *a2)
{
  *(unsigned char *)(a1 + 160) = 1;
  long double v3 = *a2;
  unsigned int v4 = *(_DWORD *)(a1 + 184);
  if (*a2 != 0.0 && v4 <= 0xF)
  {
    if (v3 <= 0.0) {
      long double v6 = -nextafter(-v3, 1.79769313e308);
    }
    else {
      long double v6 = nextafter(v3, 1.79769313e308);
    }
    double v7 = log10(fabs(v6));
    double v8 = __exp10((double)(int)(vcvtpd_s64_f64(v7) - v4));
    long double v3 = v6 - fmod(v6, v8);
  }
  *a2 = v3;
  return 0;
}

uint64_t sub_1000D9014(uint64_t a1, unsigned int *a2)
{
  *(unsigned char *)(a1 + 160) = 1;
  unsigned int v3 = *a2;
  unsigned int v4 = *a2;
  unsigned int v5 = *(_DWORD *)(a1 + 184);
  if (*a2) {
    BOOL v6 = v5 > 9;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    unsigned int v7 = vcvtpd_u64_f64(log10((double)v3));
    BOOL v8 = v7 >= v5;
    unsigned int v9 = v7 - v5;
    if (v9 != 0 && v8) {
      unsigned int v4 = __exp10((double)v9);
    }
    v4 *= v3 / v4;
  }
  *a2 = v4;
  return 0;
}

uint64_t sub_1000D908C(uint64_t a1, float *a2)
{
  *(unsigned char *)(a1 + 160) = 1;
  float v3 = *a2;
  unsigned int v4 = *(_DWORD *)(a1 + 184);
  if (*a2 != 0.0 && v4 <= 6)
  {
    if (v3 <= 0.0) {
      float v6 = -nextafterf(-v3, 3.4028e38);
    }
    else {
      float v6 = nextafterf(v3, 3.4028e38);
    }
    float v7 = log10f(fabsf(v6));
    float v8 = __exp10((double)(int)(vcvtps_s32_f32(v7) - v4));
    float v3 = v6 - fmod(v6, v8);
  }
  *a2 = v3;
  return 0;
}

uint64_t sub_1000D913C(uint64_t a1, uint64_t *a2)
{
  *(unsigned char *)(a1 + 160) = 1;
  uint64_t v3 = *a2;
  unint64_t v4 = *a2;
  unsigned int v5 = *(_DWORD *)(a1 + 184);
  if (*a2) {
    BOOL v6 = v5 > 0x12;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    if (v3 < 1)
    {
      unint64_t v4 = 0x8000000000000000;
      if (v3 != 0x8000000000000000)
      {
        unsigned int v10 = vcvtpd_u64_f64(log10((double)(unint64_t)-v3));
        unint64_t v11 = -v3;
        BOOL v8 = v10 >= v5;
        unsigned int v12 = v10 - v5;
        if (v12 != 0 && v8) {
          unint64_t v11 = (unint64_t)__exp10((double)v12);
        }
        if ((uint64_t)0x8000000000000000 / (uint64_t)v11 * v11 <= v3) {
          unint64_t v4 = v11 * ~(-v3 / v11);
        }
      }
    }
    else
    {
      unsigned int v7 = vcvtpd_u64_f64(log10((double)(unint64_t)v3));
      BOOL v8 = v7 >= v5;
      unsigned int v9 = v7 - v5;
      if (v9 != 0 && v8) {
        unint64_t v4 = (unint64_t)__exp10((double)v9);
      }
      v4 *= v3 / v4;
    }
  }
  *a2 = v4;
  return 0;
}

uint64_t sub_1000D9218(uint64_t a1, unsigned int *a2)
{
  *(unsigned char *)(a1 + 160) = 1;
  unsigned int v3 = *a2;
  unsigned int v4 = *a2;
  unsigned int v5 = *(_DWORD *)(a1 + 184);
  if (*a2) {
    BOOL v6 = v5 > 9;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    if ((int)v3 < 1)
    {
      unsigned int v4 = 0x80000000;
      if (v3 != 0x80000000)
      {
        unsigned int v10 = vcvtpd_u64_f64(log10((double)-v3));
        int v11 = -v3;
        BOOL v8 = v10 >= v5;
        unsigned int v12 = v10 - v5;
        if (v12 != 0 && v8) {
          int v11 = __exp10((double)v12);
        }
        if ((int)0x80000000 / v11 * v11 <= v3) {
          unsigned int v4 = v11 * ~(-v3 / v11);
        }
      }
    }
    else
    {
      unsigned int v7 = vcvtpd_u64_f64(log10((double)v3));
      BOOL v8 = v7 >= v5;
      unsigned int v9 = v7 - v5;
      if (v9 != 0 && v8) {
        unsigned int v4 = __exp10((double)v9);
      }
      v4 *= v3 / v4;
    }
  }
  *a2 = v4;
  return 0;
}

uint64_t sub_1000D92F4(uint64_t a1, unint64_t **a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) != ((v4 - **(void **)(a1 + 176)) >> 2) - 1 || *(_DWORD *)(v4 - 4) != a4) {
    return 0;
  }
  BOOL v6 = *a2;
  if (*a2 == a2[1]) {
    return 1;
  }
  do
  {
    unint64_t v11 = 0;
    unint64_t v11 = *v6;
    uint64_t result = sub_1000D8EF8(a1, &v11);
    if (result)
    {
      if (result == 1)
      {
        unsigned int v9 = a2[1];
        int64_t v10 = (char *)v9 - (char *)(v6 + 1);
        if (v9 != v6 + 1) {
          memmove(v6, v6 + 1, (char *)v9 - (char *)(v6 + 1));
        }
        a2[1] = (unint64_t *)((char *)v6 + v10);
      }
      else if (result == 3)
      {
        return result;
      }
    }
    else
    {
      *v6++ = v11;
    }
  }
  while (v6 != a2[1]);
  return *a2 == v6;
}

uint64_t sub_1000D93E0(uint64_t a1, char **a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) != ((v4 - **(void **)(a1 + 176)) >> 2) - 1 || *(_DWORD *)(v4 - 4) != a4) {
    return 0;
  }
  BOOL v6 = *a2;
  if (*a2 == a2[1]) {
    return 1;
  }
  do
  {
    uint64_t v11 = 0;
    uint64_t v11 = *(void *)v6;
    uint64_t result = sub_1000D8F70(a1, (double *)&v11);
    if (result)
    {
      if (result == 1)
      {
        unsigned int v9 = a2[1];
        int64_t v10 = v9 - (v6 + 8);
        if (v9 != v6 + 8) {
          memmove(v6, v6 + 8, v9 - (v6 + 8));
        }
        a2[1] = &v6[v10];
      }
      else if (result == 3)
      {
        return result;
      }
    }
    else
    {
      *(void *)BOOL v6 = v11;
      v6 += 8;
    }
  }
  while (v6 != a2[1]);
  return *a2 == v6;
}

uint64_t sub_1000D94CC(uint64_t a1, unsigned int **a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) != ((v4 - **(void **)(a1 + 176)) >> 2) - 1 || *(_DWORD *)(v4 - 4) != a4) {
    return 0;
  }
  BOOL v6 = *a2;
  if (*a2 == a2[1]) {
    return 1;
  }
  do
  {
    unsigned int v11 = 0;
    unsigned int v11 = *v6;
    uint64_t result = sub_1000D9014(a1, &v11);
    if (result)
    {
      if (result == 1)
      {
        unsigned int v9 = a2[1];
        int64_t v10 = (char *)v9 - (char *)(v6 + 1);
        if (v9 != v6 + 1) {
          memmove(v6, v6 + 1, (char *)v9 - (char *)(v6 + 1));
        }
        a2[1] = (unsigned int *)((char *)v6 + v10);
      }
      else if (result == 3)
      {
        return result;
      }
    }
    else
    {
      *v6++ = v11;
    }
  }
  while (v6 != a2[1]);
  return *a2 == v6;
}

uint64_t sub_1000D95B8(uint64_t a1, char **a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) != ((v4 - **(void **)(a1 + 176)) >> 2) - 1 || *(_DWORD *)(v4 - 4) != a4) {
    return 0;
  }
  BOOL v6 = *a2;
  if (*a2 == a2[1]) {
    return 1;
  }
  do
  {
    int v11 = 0;
    int v11 = *(_DWORD *)v6;
    uint64_t result = sub_1000D908C(a1, (float *)&v11);
    if (result)
    {
      if (result == 1)
      {
        unsigned int v9 = a2[1];
        int64_t v10 = v9 - (v6 + 4);
        if (v9 != v6 + 4) {
          memmove(v6, v6 + 4, v9 - (v6 + 4));
        }
        a2[1] = &v6[v10];
      }
      else if (result == 3)
      {
        return result;
      }
    }
    else
    {
      *(_DWORD *)BOOL v6 = v11;
      v6 += 4;
    }
  }
  while (v6 != a2[1]);
  return *a2 == v6;
}

uint64_t sub_1000D96A4(uint64_t a1, uint64_t **a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) != ((v4 - **(void **)(a1 + 176)) >> 2) - 1 || *(_DWORD *)(v4 - 4) != a4) {
    return 0;
  }
  BOOL v6 = *a2;
  if (*a2 == a2[1]) {
    return 1;
  }
  do
  {
    uint64_t v11 = 0;
    uint64_t v11 = *v6;
    uint64_t result = sub_1000D913C(a1, &v11);
    if (result)
    {
      if (result == 1)
      {
        unsigned int v9 = a2[1];
        int64_t v10 = (char *)v9 - (char *)(v6 + 1);
        if (v9 != v6 + 1) {
          memmove(v6, v6 + 1, (char *)v9 - (char *)(v6 + 1));
        }
        a2[1] = (uint64_t *)((char *)v6 + v10);
      }
      else if (result == 3)
      {
        return result;
      }
    }
    else
    {
      *v6++ = v11;
    }
  }
  while (v6 != a2[1]);
  return *a2 == v6;
}

uint64_t sub_1000D9790(uint64_t a1, unsigned int **a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) != ((v4 - **(void **)(a1 + 176)) >> 2) - 1 || *(_DWORD *)(v4 - 4) != a4) {
    return 0;
  }
  BOOL v6 = *a2;
  if (*a2 == a2[1]) {
    return 1;
  }
  do
  {
    unsigned int v11 = 0;
    unsigned int v11 = *v6;
    uint64_t result = sub_1000D9218(a1, &v11);
    if (result)
    {
      if (result == 1)
      {
        unsigned int v9 = a2[1];
        int64_t v10 = (char *)v9 - (char *)(v6 + 1);
        if (v9 != v6 + 1) {
          memmove(v6, v6 + 1, (char *)v9 - (char *)(v6 + 1));
        }
        a2[1] = (unsigned int *)((char *)v6 + v10);
      }
      else if (result == 3)
      {
        return result;
      }
    }
    else
    {
      *v6++ = v11;
    }
  }
  while (v6 != a2[1]);
  return *a2 == v6;
}

uint64_t sub_1000D987C(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a2, void *a3)
{
  unsigned int v7 = (unsigned __int8 *)*((void *)this + 1);
  if ((unint64_t)v7 >= *((void *)this + 2) || (char)*v7 < 0)
  {
    unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = TagFallback;
    if (TagFallback) {
      goto LABEL_4;
    }
LABEL_10:
    if (*((unsigned char *)this + 36))
    {
LABEL_49:
      char v3 = 1;
      return v3 & 1;
    }
LABEL_11:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
LABEL_111:
  }
  unint64_t TagFallback = *v7;
  *((_DWORD *)this + 8) = TagFallback;
  *((void *)this + 1) = v7 + 1;
  if (!TagFallback) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v9 = wis::reflect::decodeTag((wis::reflect *)TagFallback, a2);
  char v10 = v9;
  unsigned int v73 = HIDWORD(v9);
  MetricFileMetadataHelper::getSubfieldType();
  *(_OWORD *)uint64_t v74 = v71;
  int v75 = v72;
  int BuiltinType = MetadataHelper::getBuiltinType();
  int v70 = BuiltinType;
  int DecodingType = wis::reflect::getDecodingType();
  switch(DecodingType)
  {
    case 0:
      switch(v10)
      {
        case 0:
          *(void *)uint64_t v74 = 0;
          if (!sub_100038330(this, (unint64_t *)v74)) {
            goto LABEL_47;
          }
          unint64_t v32 = *(void *)v74;
          long long v55 = *(_OWORD *)a2;
          uint64_t v56 = *(void *)(a2 + 16);
          uint64_t v33 = v73;
          int v34 = &v55;
          uint64_t v35 = (uint64_t)a3;
          unsigned int v36 = 0;
          goto LABEL_108;
        case 1:
          *(void *)uint64_t v74 = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v74))goto LABEL_47; {
          unint64_t v32 = *(void *)v74;
          }
          long long v51 = *(_OWORD *)a2;
          uint64_t v52 = *(void *)(a2 + 16);
          uint64_t v33 = v73;
          int v34 = &v51;
          uint64_t v35 = (uint64_t)a3;
          unsigned int v36 = 1;
          goto LABEL_108;
        case 2:
          v66[0] = 0;
          if ((sub_100038360(this, v66) & 1) == 0) {
            goto LABEL_47;
          }
          sub_10003908C(v74, v66[0]);
          char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v74, v66[0]);
          if ((Raw & 1) == 0) {
            goto LABEL_96;
          }
          char v48 = sub_1000D5040((uint64_t)a3, *(const void **)v74, *(void *)&v74[2] - *(void *)v74);
          goto LABEL_95;
        case 5:
          v74[0] = 0;
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v74))goto LABEL_47; {
          uint64_t v33 = v73;
          }
          unint64_t v32 = v74[0];
          long long v53 = *(_OWORD *)a2;
          uint64_t v54 = *(void *)(a2 + 16);
          int v34 = &v53;
          uint64_t v35 = (uint64_t)a3;
          unsigned int v36 = 5;
LABEL_108:
          char v42 = sub_1000D4F1C(v35, v32, (uint64_t)v34, v33, v36);
          goto LABEL_77;
        default:
          goto LABEL_47;
      }
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      *(void *)uint64_t v74 = 0;
      switch(v10)
      {
        case 0:
          uint64_t v13 = (char *)*((void *)this + 1);
          if ((unint64_t)v13 < *((void *)this + 2) && (*v13 & 0x80000000) == 0)
          {
            *(void *)uint64_t v74 = *v13;
            *((void *)this + 1) = v13 + 1;
            goto LABEL_76;
          }
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, (unint64_t *)v74))goto LABEL_76; {
          if (!v73 && *((unsigned char *)this + 36))
          }
            goto LABEL_49;
LABEL_57:
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        case 1:
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v74))goto LABEL_76; {
          if (v73 || !*((unsigned char *)this + 36))
          }
            goto LABEL_57;
          goto LABEL_49;
        case 2:
          if (v73 || !*((unsigned char *)this + 36)) {
            goto LABEL_11;
          }
          goto LABEL_49;
        case 5:
          v66[0] = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v66))
          {
            *(void *)uint64_t v74 = v66[0];
LABEL_76:
            char v42 = sub_1000DA238(BuiltinType, *(uint64_t *)v74, a3, (long long *)a2, (int *)&v73, &v70);
LABEL_77:
            char v3 = v42;
            return v3 & 1;
          }
          if (!v73 && *((unsigned char *)this + 36)) {
            goto LABEL_49;
          }
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        default:
          goto LABEL_76;
      }
      goto LABEL_111;
    case 13:
      v66[0] = 0;
      long long v37 = (char *)*((void *)this + 1);
      if ((unint64_t)v37 >= *((void *)this + 2) || *v37 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v66))goto LABEL_47; {
      }
        }
      else
      {
        v66[0] = *v37;
        *((void *)this + 1) = v37 + 1;
      }
      memset(v74, 0, sizeof(v74));
      int v75 = 0;
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
      if (Raw)
      {
        long long v63 = *(_OWORD *)a2;
        uint64_t v64 = *(void *)(a2 + 16);
        char v3 = sub_1000D4C0C((uint64_t)a3, v74);
      }
      if ((SHIBYTE(v75) & 0x80000000) == 0) {
        goto LABEL_99;
      }
      uint64_t v44 = *(void **)v74;
      goto LABEL_98;
    case 14:
      v66[0] = 0;
      uint64_t v40 = (char *)*((void *)this + 1);
      if ((unint64_t)v40 >= *((void *)this + 2) || *v40 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v66))goto LABEL_47; {
        unsigned int v41 = v66[0];
        }
      }
      else
      {
        unsigned int v41 = *v40;
        v66[0] = v41;
        *((void *)this + 1) = v40 + 1;
      }
      sub_10003908C(v74, v41);
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v74, v66[0]);
      if (Raw)
      {
        long long v61 = *(_OWORD *)a2;
        uint64_t v62 = *(void *)(a2 + 16);
        char v48 = sub_1000D4C90((uint64_t)a3, (uint64_t)v74);
LABEL_95:
        char v3 = v48;
      }
LABEL_96:
      uint64_t v44 = *(void **)v74;
      if (*(void *)v74)
      {
        *(void *)&v74[2] = *(void *)v74;
LABEL_98:
        operator delete(v44);
      }
LABEL_99:
      if (Raw) {
        return v3 & 1;
      }
      goto LABEL_47;
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      unsigned int v69 = 0;
      int v15 = (unsigned __int8 *)*((void *)this + 1);
      if ((unint64_t)v15 >= *((void *)this + 2) || (char)*v15 < 0)
      {
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v69)) {
          goto LABEL_16;
        }
LABEL_47:
        if (!v73 && *((unsigned char *)this + 36)) {
          goto LABEL_49;
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Parsing failed in metric");
        goto LABEL_111;
      }
      unsigned int v69 = *v15;
      *((void *)this + 1) = v15 + 1;
LABEL_16:
      uint64_t v49 = (long long *)a2;
      uint64_t v50 = (uint64_t)a3;
      int UnpackedType = wis::reflect::getUnpackedType();
      int WireTypeForType = wis::reflect::getWireTypeForType();
      *(void *)v66 = this;
      int v67 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v69);
      memset(v74, 0, sizeof(v74));
      int v75 = 0;
      while (1)
      {
        int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
        if (v17 < 1) {
          break;
        }
        int v18 = *(char **)&v74[2];
        if (*(void *)&v74[2] >= (unint64_t)v75)
        {
          int v20 = *(char **)v74;
          uint64_t v21 = (uint64_t)(*(void *)&v74[2] - *(void *)v74) >> 3;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 61) {
            sub_10002B5E0();
          }
          uint64_t v23 = (uint64_t)&v75[-*(void *)v74];
          if ((uint64_t)&v75[-*(void *)v74] >> 2 > v22) {
            unint64_t v22 = v23 >> 2;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24)
          {
            int v25 = (char *)sub_100038500((uint64_t)&v75, v24);
            int v20 = *(char **)v74;
            int v18 = *(char **)&v74[2];
          }
          else
          {
            int v25 = 0;
          }
          int v26 = &v25[8 * v21];
          *(void *)int v26 = 0;
          unsigned int v19 = v26 + 8;
          while (v18 != v20)
          {
            uint64_t v27 = *((void *)v18 - 1);
            v18 -= 8;
            *((void *)v26 - 1) = v27;
            v26 -= 8;
          }
          *(void *)uint64_t v74 = v26;
          *(void *)&v74[2] = v19;
          int v75 = &v25[8 * v24];
          if (v20) {
            operator delete(v20);
          }
        }
        else
        {
          **(void **)&v74[2] = 0;
          unsigned int v19 = v18 + 8;
        }
        *(void *)&v74[2] = v19;
        switch(WireTypeForType)
        {
          case 0:
            uint64_t v28 = v19 - 1;
            int v29 = (char *)*((void *)this + 1);
            if ((unint64_t)v29 >= *((void *)this + 2) || *v29 < 0)
            {
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v28);
LABEL_41:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_44;
              }
            }
            else
            {
              unint64_t *v28 = *v29;
              *((void *)this + 1) = v29 + 1;
            }
            break;
          case 1:
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, v19 - 1);
            goto LABEL_41;
          case 2:
            goto LABEL_44;
          case 5:
            unsigned int v65 = 0;
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v65);
            *(void *)(*(void *)&v74[2] - 8) = v65;
            goto LABEL_41;
          default:
            continue;
        }
      }
      char v3 = sub_1000DA5F0(DecodingType, (uint64_t *)v74, v50, v49, (int *)&v73, &UnpackedType);
LABEL_44:
      if (*(void *)v74)
      {
        *(void *)&v74[2] = *(void *)v74;
        operator delete(*(void **)v74);
      }
      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(*(wireless_diagnostics::google::protobuf::io::CodedInputStream **)v66, v67);
      if (v17 > 0) {
        goto LABEL_47;
      }
      return v3 & 1;
    case 27:
      unsigned int v69 = 0;
      unsigned int v38 = (char *)*((void *)this + 1);
      if ((unint64_t)v38 >= *((void *)this + 2) || *v38 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v69))goto LABEL_47; {
        unsigned int v39 = v69;
        }
      }
      else
      {
        unsigned int v39 = *v38;
        unsigned int v69 = v39;
        *((void *)this + 1) = v38 + 1;
      }
      *(void *)uint64_t v74 = this;
      v74[2] = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v39);
      ++*((_DWORD *)this + 14);
      *(void *)v66 = this;
      long long v59 = *(_OWORD *)a2;
      uint64_t v60 = *(void *)(a2 + 16);
      long long v57 = v71;
      uint64_t v58 = v72;
      char v3 = sub_1000D86D0((int)a3, this);
      sub_1000DACF4((wireless_diagnostics::google::protobuf::io::CodedInputStream **)v66);
      int v45 = *((_DWORD *)this + 14);
      BOOL v46 = __OFSUB__(v45, 1);
      int v47 = v45 - 1;
      if (v47 < 0 == v46) {
        *((_DWORD *)this + 14) = v47;
      }
      sub_100039058((uint64_t)v74);
      return v3 & 1;
    default:
      goto LABEL_47;
  }
}

void sub_1000DA0D0(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 - 112);
  if (v3)
  {
    *(void *)(v1 - 104) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DA238(int a1, uint64_t a2, void *a3, long long *a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 1:
    case 15:
      wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
      uint64_t v55 = v10;
      long long v51 = *a4;
      uint64_t v52 = *((void *)a4 + 2);
      return sub_1000D89EC(a3, (double *)&v55, (uint64_t)&v51, *a5);
    case 2:
    case 16:
      wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
      LODWORD(v55) = v12;
      long long v47 = *a4;
      uint64_t v48 = *((void *)a4 + 2);
      return sub_1000D8BF0(a3, (float *)&v55, (uint64_t)&v47, *a5);
    case 3:
    case 17:
      uint64_t v55 = a2;
      long long v45 = *a4;
      uint64_t v46 = *((void *)a4 + 2);
      int v13 = *a5;
      int v14 = *a6;
      int v15 = &v45;
      goto LABEL_16;
    case 4:
    case 18:
      uint64_t v55 = a2;
      long long v41 = *a4;
      uint64_t v42 = *((void *)a4 + 2);
      int v16 = *a5;
      int v17 = *a6;
      int v18 = &v41;
      goto LABEL_14;
    case 5:
    case 19:
      uint64_t v55 = wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
      long long v43 = *a4;
      uint64_t v44 = *((void *)a4 + 2);
      int v13 = *a5;
      int v14 = *a6;
      int v15 = &v43;
      goto LABEL_16;
    case 6:
    case 20:
      LODWORD(v55) = a2;
      long long v39 = *a4;
      uint64_t v40 = *((void *)a4 + 2);
      int v19 = *a5;
      int v20 = *a6;
      uint64_t v21 = &v39;
      goto LABEL_10;
    case 7:
    case 21:
      LODWORD(v55) = a2;
      long long v35 = *a4;
      uint64_t v36 = *((void *)a4 + 2);
      int v22 = *a5;
      int v23 = *a6;
      unint64_t v24 = &v35;
      goto LABEL_12;
    case 8:
    case 22:
      LODWORD(v55) = wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
      long long v37 = *a4;
      uint64_t v38 = *((void *)a4 + 2);
      int v19 = *a5;
      int v20 = *a6;
      uint64_t v21 = &v37;
LABEL_10:
      uint64_t result = sub_1000D8DF4(a3, (unsigned int *)&v55, (uint64_t)v21, v19, v20);
      break;
    case 9:
    case 23:
      LODWORD(v55) = a2;
      long long v49 = *a4;
      uint64_t v50 = *((void *)a4 + 2);
      int v22 = *a5;
      int v23 = *a6;
      unint64_t v24 = &v49;
LABEL_12:
      uint64_t result = sub_1000D8AEC(a3, (unsigned int *)&v55, (uint64_t)v24, v22, v23);
      break;
    case 10:
    case 24:
      long long v53 = *a4;
      uint64_t v54 = *((void *)a4 + 2);
      uint64_t v55 = a2;
      int v16 = *a5;
      int v17 = *a6;
      int v18 = &v53;
LABEL_14:
      uint64_t result = sub_1000D88E8(a3, (unint64_t *)&v55, (uint64_t)v18, v16, v17);
      break;
    case 11:
    case 25:
      uint64_t v55 = a2;
      long long v33 = *a4;
      uint64_t v34 = *((void *)a4 + 2);
      int v13 = *a5;
      int v14 = *a6;
      int v15 = &v33;
LABEL_16:
      uint64_t result = sub_1000D8CF0(a3, &v55, (uint64_t)v15, v13, v14);
      break;
    case 12:
    case 26:
      unsigned int v25 = a2 != 0;
      int v26 = *a6;
      uint64_t v27 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a3[6];
      wis::reflect::getWireTypeForType();
      unsigned int v28 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v27, v28);
      int v29 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a3[6];
      uint64_t v30 = sub_10003B49C(v26, v25);
      int WireTypeForType = wis::reflect::getWireTypeForType();
      switch(WireTypeForType)
      {
        case 5:
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v29, v30);
          break;
        case 1:
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v29, v30);
          break;
        case 0:
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v29, v30);
          break;
      }
      uint64_t result = 1;
      break;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
  return result;
}

void sub_1000DA574(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DA5F0(int a1, uint64_t *a2, uint64_t a3, long long *a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 15:
      sub_1000385BC(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v10 = *a6;
      int v11 = sub_1000D93E0(a3, (char **)__p, (uint64_t)&v48, *a5);
      if (v11 == 3) {
        goto LABEL_36;
      }
      if (!v11)
      {
        int v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v13 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v12, v13);
        sub_10003C2D0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v10, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 16:
      sub_1000386C8(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v14 = *a6;
      int v15 = sub_1000D95B8(a3, (char **)__p, (uint64_t)&v48, *a5);
      if (v15 == 3) {
        goto LABEL_36;
      }
      if (!v15)
      {
        int v16 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v17 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v16, v17);
        sub_10003D7B4(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v14, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 17:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v18 = *a6;
      int v19 = sub_1000D96A4(a3, (uint64_t **)__p, (uint64_t)&v48, *a5);
      if (v19 == 3) {
        goto LABEL_36;
      }
      if (!v19) {
        goto LABEL_34;
      }
      goto LABEL_35;
    case 18:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v20 = *a6;
      int v21 = sub_1000D92F4(a3, (unint64_t **)__p, (uint64_t)&v48, *a5);
      if (v21 == 3) {
        goto LABEL_36;
      }
      if (!v21) {
        goto LABEL_13;
      }
      goto LABEL_35;
    case 19:
      sub_1000387D4(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v18 = *a6;
      int v24 = sub_1000D96A4(a3, (uint64_t **)__p, (uint64_t)&v48, *a5);
      if (v24 == 3) {
        goto LABEL_36;
      }
      if (!v24) {
        goto LABEL_34;
      }
      goto LABEL_35;
    case 20:
      sub_100038644(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v25 = *a6;
      int v26 = sub_1000D9790(a3, (unsigned int **)__p, (uint64_t)&v48, *a5);
      if (v26 == 3) {
        goto LABEL_36;
      }
      if (!v26) {
        goto LABEL_19;
      }
      goto LABEL_35;
    case 21:
      sub_100038644(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v29 = *a6;
      int v30 = sub_1000D94CC(a3, (unsigned int **)__p, (uint64_t)&v48, *a5);
      if (v30 == 3) {
        goto LABEL_36;
      }
      if (!v30) {
        goto LABEL_22;
      }
      goto LABEL_35;
    case 22:
      sub_10003885C(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v25 = *a6;
      int v33 = sub_1000D9790(a3, (unsigned int **)__p, (uint64_t)&v48, *a5);
      if (v33 == 3) {
        goto LABEL_36;
      }
      if (!v33)
      {
LABEL_19:
        uint64_t v27 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v28 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v27, v28);
        sub_10003F9B0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v25, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 23:
      sub_100038644(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v29 = *a6;
      int v34 = sub_1000D94CC(a3, (unsigned int **)__p, (uint64_t)&v48, *a5);
      if (v34 == 3) {
        goto LABEL_36;
      }
      if (!v34)
      {
LABEL_22:
        int v31 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v32 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v31, v32);
        sub_10003CD54(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v29, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 24:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v20 = *a6;
      int v35 = sub_1000D92F4(a3, (unint64_t **)__p, (uint64_t)&v48, *a5);
      if (v35 == 3) {
        goto LABEL_36;
      }
      if (!v35)
      {
LABEL_13:
        int v22 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v23 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v22, v23);
        sub_10003B870(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v20, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 25:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v18 = *a6;
      int v36 = sub_1000D96A4(a3, (uint64_t **)__p, (uint64_t)&v48, *a5);
      if (v36 == 3)
      {
LABEL_36:
        uint64_t v39 = 0;
      }
      else
      {
        if (!v36)
        {
LABEL_34:
          long long v37 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v38 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v37, v38);
          sub_10003EF50(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v18, (uint64_t *)__p);
        }
LABEL_35:
        uint64_t v39 = 1;
      }
      uint64_t v40 = __p[0];
      if (__p[0])
      {
        __p[1] = __p[0];
LABEL_39:
        operator delete(v40);
      }
      return v39;
    case 26:
      sub_100038750((uint64_t)a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v42 = *a6;
      int v43 = sub_1000D5678(a3, (uint64_t **)__p, (uint64_t)&v48, *a5);
      if (v43 == 3)
      {
        uint64_t v39 = 0;
      }
      else
      {
        if (!v43)
        {
          uint64_t v44 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v45 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v44, v45);
          sub_10003E238(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v42, (uint64_t *)__p);
        }
        uint64_t v39 = 1;
      }
      uint64_t v40 = __p[0];
      if (!__p[0]) {
        return v39;
      }
      goto LABEL_39;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
}

void sub_1000DAC60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  __cxa_free_exception(v11);
  _Unwind_Resume(a1);
}

wireless_diagnostics::google::protobuf::io::CodedInputStream **sub_1000DACF4(wireless_diagnostics::google::protobuf::io::CodedInputStream **a1)
{
  int v2 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(*a1);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip(*a1, v2);
  return a1;
}

wireless_diagnostics::google::protobuf::io::CodedInputStream **sub_1000DAD30(wireless_diagnostics::google::protobuf::io::CodedInputStream **a1)
{
  int v2 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(*a1);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip(*a1, v2);
  return a1;
}

void *sub_1000DAD6C(void *a1)
{
  *a1 = off_1001BC198;
  int v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1000DADBC(void *a1)
{
  *a1 = off_1001BC198;
  int v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }

  operator delete();
}

void *sub_1000DAE2C(uint64_t a1)
{
  int v2 = operator new(0x28uLL);
  void *v2 = off_1001BC198;
  v2[2] = 0;
  v2[3] = 0;
  v2[1] = 0;
  sub_10001E158(v2 + 1, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2);
  v2[4] = *(void *)(a1 + 32);
  return v2;
}

void sub_1000DAE98(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

double sub_1000DAEAC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1001BC198;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  sub_10001E158((void *)(a2 + 8), *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2);
  double result = *(double *)(a1 + 32);
  *(double *)(a2 + 32) = result;
  return result;
}

void sub_1000DAF10(uint64_t a1)
{
  int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void sub_1000DAF28(void *__p)
{
  int v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

uint64_t sub_1000DAF6C(uint64_t a1, void *a2)
{
  __n128 v25 = 0uLL;
  uint64_t v26 = 0;
  char v3 = (uint64_t *)a2[1];
  if (!v3) {
    char v3 = *(uint64_t **)(*a2 + 8);
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1] - *v3;
  v16[0] = 0;
  v16[1] = v4;
  v16[2] = v4 + (int)v5;
  int v17 = v5;
  uint64_t v18 = 0;
  __int16 v19 = 0;
  long long v21 = xmmword_100174830;
  int v20 = v5;
  int v22 = wireless_diagnostics::google::protobuf::io::CodedInputStream::default_recursion_limit_;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v6 = *(void *)(a1 + 32);
  sub_1000DBB60((uint64_t)v11, (uint64_t)(a2 + 2), (uint64_t)&v25, a1 + 8);
  uint64_t v15 = v6;
  v10[0] = 0;
  v10[1] = 0;
  void v10[2] = 0xFFFFFFFFLL;
  if (sub_1000DB1A0((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v16, (uint64_t)v10, (uint64_t)v11))
  {
    int v7 = v14[64];
    sub_100038238((uint64_t)v14);
    if (v13) {
      sub_10000B678(v13);
    }
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v12);
    wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v11);
    wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v16);
    if (v7)
    {
      sub_1000D2E5C((uint64_t)a2, &v25);
      uint64_t v8 = 1;
      goto LABEL_12;
    }
  }
  else
  {
    sub_100038238((uint64_t)v14);
    if (v13) {
      sub_10000B678(v13);
    }
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v12);
    wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v11);
    wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v16);
  }
  uint64_t v8 = 0;
LABEL_12:
  if (v25.n128_u64[0])
  {
    v25.n128_u64[1] = v25.n128_u64[0];
    operator delete((void *)v25.n128_u64[0]);
  }
  return v8;
}

void sub_1000DB0D8(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 - 72);
  if (v3)
  {
    *(void *)(v1 - 64) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000DB0F4(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  sub_100038238(v20 + 96);
  if (a20) {
    sub_10000B678(a20);
  }
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)&a14);
  wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)&a12);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream((wireless_diagnostics::google::protobuf::io::CodedInputStream *)(v21 - 152));
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1000DB0A8);
  }
  JUMPOUT(0x1000DB0DCLL);
}

uint64_t sub_1000DB154(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1000DB194()
{
}

uint64_t sub_1000DB1A0(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a2, uint64_t a3)
{
  int v7 = (unsigned __int8 *)*((void *)this + 1);
  if ((unint64_t)v7 >= *((void *)this + 2) || (char)*v7 < 0)
  {
    unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = TagFallback;
    if (TagFallback) {
      goto LABEL_4;
    }
LABEL_10:
    if (*((unsigned char *)this + 36))
    {
LABEL_49:
      char v3 = 1;
      return v3 & 1;
    }
LABEL_11:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
LABEL_111:
  }
  unint64_t TagFallback = *v7;
  *((_DWORD *)this + 8) = TagFallback;
  *((void *)this + 1) = v7 + 1;
  if (!TagFallback) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v9 = wis::reflect::decodeTag((wis::reflect *)TagFallback, a2);
  char v10 = v9;
  v80[0] = HIDWORD(v9);
  long long v76 = *(_OWORD *)a2;
  uint64_t v77 = *(void *)(a2 + 16);
  MetricFileMetadataHelper::getSubfieldType();
  long long v73 = v78;
  uint64_t v74 = v79;
  int BuiltinType = MetadataHelper::getBuiltinType();
  int v75 = BuiltinType;
  int DecodingType = wis::reflect::getDecodingType();
  switch(DecodingType)
  {
    case 0:
      switch(v10)
      {
        case 0:
          *(void *)v66 = 0;
          if (!sub_100038330(this, (unint64_t *)v66)) {
            goto LABEL_47;
          }
          unint64_t v32 = *(void *)v66;
          long long v55 = *(_OWORD *)a2;
          uint64_t v56 = *(void *)(a2 + 16);
          uint64_t v33 = v80[0];
          int v34 = &v55;
          uint64_t v35 = a3;
          unsigned int v36 = 0;
          goto LABEL_108;
        case 1:
          *(void *)v66 = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v66))goto LABEL_47; {
          unint64_t v32 = *(void *)v66;
          }
          long long v51 = *(_OWORD *)a2;
          uint64_t v52 = *(void *)(a2 + 16);
          uint64_t v33 = v80[0];
          int v34 = &v51;
          uint64_t v35 = a3;
          unsigned int v36 = 1;
          goto LABEL_108;
        case 2:
          v69[0] = 0;
          if ((sub_100038360(this, v69) & 1) == 0) {
            goto LABEL_47;
          }
          sub_10003908C(v66, v69[0]);
          char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v66, v69[0]);
          if ((Raw & 1) == 0) {
            goto LABEL_96;
          }
          char v48 = sub_1000D5040(a3, *(const void **)v66, (unint64_t)&v67[-*(void *)v66]);
          goto LABEL_95;
        case 5:
          v66[0] = 0;
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v66))goto LABEL_47; {
          unint64_t v32 = v66[0];
          }
          long long v53 = *(_OWORD *)a2;
          uint64_t v54 = *(void *)(a2 + 16);
          uint64_t v33 = v80[0];
          int v34 = &v53;
          uint64_t v35 = a3;
          unsigned int v36 = 5;
LABEL_108:
          char v42 = sub_1000D4F1C(v35, v32, (uint64_t)v34, v33, v36);
          goto LABEL_77;
        default:
          goto LABEL_47;
      }
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      *(void *)v66 = 0;
      switch(v10)
      {
        case 0:
          unsigned int v13 = (char *)*((void *)this + 1);
          if ((unint64_t)v13 < *((void *)this + 2) && (*v13 & 0x80000000) == 0)
          {
            *(void *)v66 = *v13;
            *((void *)this + 1) = v13 + 1;
            goto LABEL_76;
          }
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, (unint64_t *)v66))goto LABEL_76; {
          if (!v80[0] && *((unsigned char *)this + 36))
          }
            goto LABEL_49;
LABEL_57:
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        case 1:
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v66))goto LABEL_76; {
          if (v80[0] || !*((unsigned char *)this + 36))
          }
            goto LABEL_57;
          goto LABEL_49;
        case 2:
          if (v80[0] || !*((unsigned char *)this + 36)) {
            goto LABEL_11;
          }
          goto LABEL_49;
        case 5:
          v69[0] = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v69))
          {
            *(void *)v66 = v69[0];
LABEL_76:
            char v42 = sub_1000DBBE8(BuiltinType, *(uint64_t *)v66, a3, (long long *)a2, v80, &v75);
LABEL_77:
            char v3 = v42;
            return v3 & 1;
          }
          if (!v80[0] && *((unsigned char *)this + 36)) {
            goto LABEL_49;
          }
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        default:
          goto LABEL_76;
      }
      goto LABEL_111;
    case 13:
      v69[0] = 0;
      long long v37 = (char *)*((void *)this + 1);
      if ((unint64_t)v37 >= *((void *)this + 2) || *v37 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v69))goto LABEL_47; {
      }
        }
      else
      {
        v69[0] = *v37;
        *((void *)this + 1) = v37 + 1;
      }
      *(void *)v66 = 0;
      int v67 = 0;
      CFStringRef v68 = 0;
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
      if (Raw)
      {
        long long v63 = *(_OWORD *)a2;
        uint64_t v64 = *(void *)(a2 + 16);
        char v3 = sub_1000D4C0C(a3, v66);
      }
      if ((SHIBYTE(v68) & 0x80000000) == 0) {
        goto LABEL_99;
      }
      uint64_t v44 = *(void **)v66;
      goto LABEL_98;
    case 14:
      v69[0] = 0;
      uint64_t v40 = (char *)*((void *)this + 1);
      if ((unint64_t)v40 >= *((void *)this + 2) || *v40 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v69))goto LABEL_47; {
        unsigned int v41 = v69[0];
        }
      }
      else
      {
        unsigned int v41 = *v40;
        v69[0] = v41;
        *((void *)this + 1) = v40 + 1;
      }
      sub_10003908C(v66, v41);
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v66, v69[0]);
      if (Raw)
      {
        long long v61 = *(_OWORD *)a2;
        uint64_t v62 = *(void *)(a2 + 16);
        char v48 = sub_1000D4C90(a3, (uint64_t)v66);
LABEL_95:
        char v3 = v48;
      }
LABEL_96:
      uint64_t v44 = *(void **)v66;
      if (*(void *)v66)
      {
        int v67 = *(char **)v66;
LABEL_98:
        operator delete(v44);
      }
LABEL_99:
      if (Raw) {
        return v3 & 1;
      }
      goto LABEL_47;
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      unsigned int v72 = 0;
      uint64_t v15 = (unsigned __int8 *)*((void *)this + 1);
      if ((unint64_t)v15 >= *((void *)this + 2) || (char)*v15 < 0)
      {
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v72)) {
          goto LABEL_16;
        }
LABEL_47:
        if (!v80[0] && *((unsigned char *)this + 36)) {
          goto LABEL_49;
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Parsing failed in metric");
        goto LABEL_111;
      }
      unsigned int v72 = *v15;
      *((void *)this + 1) = v15 + 1;
LABEL_16:
      uint64_t v49 = a2;
      uint64_t v50 = a3;
      int UnpackedType = wis::reflect::getUnpackedType();
      int WireTypeForType = wis::reflect::getWireTypeForType();
      *(void *)unsigned int v69 = this;
      int v70 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v72);
      *(void *)v66 = 0;
      int v67 = 0;
      CFStringRef v68 = 0;
      while (1)
      {
        int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
        if (v17 < 1) {
          break;
        }
        uint64_t v18 = v67;
        if (v67 >= v68)
        {
          uint64_t v20 = *(char **)v66;
          uint64_t v21 = (uint64_t)&v67[-*(void *)v66] >> 3;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 61) {
            sub_10002B5E0();
          }
          uint64_t v23 = (uint64_t)&v68[-*(void *)v66];
          if ((uint64_t)&v68[-*(void *)v66] >> 2 > v22) {
            unint64_t v22 = v23 >> 2;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24)
          {
            __n128 v25 = (char *)sub_100038500((uint64_t)&v68, v24);
            uint64_t v20 = *(char **)v66;
            uint64_t v18 = v67;
          }
          else
          {
            __n128 v25 = 0;
          }
          uint64_t v26 = &v25[8 * v21];
          *(void *)uint64_t v26 = 0;
          __int16 v19 = v26 + 8;
          while (v18 != v20)
          {
            uint64_t v27 = *((void *)v18 - 1);
            v18 -= 8;
            *((void *)v26 - 1) = v27;
            v26 -= 8;
          }
          *(void *)v66 = v26;
          int v67 = v19;
          CFStringRef v68 = &v25[8 * v24];
          if (v20) {
            operator delete(v20);
          }
        }
        else
        {
          *(void *)int v67 = 0;
          __int16 v19 = v18 + 8;
        }
        int v67 = v19;
        switch(WireTypeForType)
        {
          case 0:
            unsigned int v28 = (unint64_t *)(v19 - 8);
            int v29 = (char *)*((void *)this + 1);
            if ((unint64_t)v29 >= *((void *)this + 2) || *v29 < 0)
            {
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v28);
LABEL_41:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_44;
              }
            }
            else
            {
              unint64_t *v28 = *v29;
              *((void *)this + 1) = v29 + 1;
            }
            break;
          case 1:
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v19 - 1);
            goto LABEL_41;
          case 2:
            goto LABEL_44;
          case 5:
            unsigned int v65 = 0;
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v65);
            *((void *)v67 - 1) = v65;
            goto LABEL_41;
          default:
            continue;
        }
      }
      char v3 = sub_1000DBF50(DecodingType, (uint64_t *)v66, v50, v49, v80, &UnpackedType);
LABEL_44:
      if (*(void *)v66)
      {
        int v67 = *(char **)v66;
        operator delete(*(void **)v66);
      }
      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(*(wireless_diagnostics::google::protobuf::io::CodedInputStream **)v69, v70);
      if (v17 > 0) {
        goto LABEL_47;
      }
      return v3 & 1;
    case 27:
      unsigned int v72 = 0;
      unsigned int v38 = (char *)*((void *)this + 1);
      if ((unint64_t)v38 >= *((void *)this + 2) || *v38 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v72))goto LABEL_47; {
        unsigned int v39 = v72;
        }
      }
      else
      {
        unsigned int v39 = *v38;
        unsigned int v72 = v39;
        *((void *)this + 1) = v38 + 1;
      }
      *(void *)v66 = this;
      LODWORD(v67) = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v39);
      ++*((_DWORD *)this + 14);
      *(void *)unsigned int v69 = this;
      long long v59 = *(_OWORD *)a2;
      uint64_t v60 = *(void *)(a2 + 16);
      long long v57 = v78;
      uint64_t v58 = v79;
      char v3 = sub_1000DC654(a3, this, (uint64_t)&v59, v80[0], &v57);
      sub_1000DE034((wireless_diagnostics::google::protobuf::io::CodedInputStream **)v69);
      int v45 = *((_DWORD *)this + 14);
      BOOL v46 = __OFSUB__(v45, 1);
      int v47 = v45 - 1;
      if (v47 < 0 == v46) {
        *((_DWORD *)this + 14) = v47;
      }
      sub_100039058((uint64_t)v66);
      return v3 & 1;
    default:
      goto LABEL_47;
  }
}

void sub_1000DB9F8(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 - 224);
  if (v3)
  {
    *(void *)(v1 - 216) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DBB60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)(sub_100009298((void *)a1, a3) + 2);
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::CodedOutputStream(v6, (wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)a1);
  *(void *)(a1 + 48) = v6;
  MetricFileMetadataHelper::MetricFileMetadataHelper();
  *(unsigned char *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = a4;
  return a1;
}

void sub_1000DBBC4(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream(v2);
  wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DBBE8(int a1, uint64_t a2, uint64_t a3, long long *a4, int *a5, int *a6)
{
  uint64_t v10 = a2;
  switch(a1)
  {
    case 1:
    case 15:
      wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
      uint64_t v45 = v19;
      long long v43 = *a4;
      uint64_t v44 = *((void *)a4 + 2);
      return sub_1000DC86C(a3, (long double *)&v45, (uint64_t)&v43, *a5);
    case 2:
    case 16:
      wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
      LODWORD(v45) = v21;
      long long v41 = *a4;
      uint64_t v42 = *((void *)a4 + 2);
      return sub_1000DC974(a3, (float *)&v45, (uint64_t)&v41, *a5);
    case 3:
    case 11:
    case 17:
    case 25:
      goto LABEL_7;
    case 4:
    case 10:
    case 18:
    case 24:
      int v16 = *a6;
      int v17 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v18 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v17, v18);
      int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      uint64_t v15 = sub_10003B200(v16, v10);
      break;
    case 5:
    case 19:
      uint64_t v10 = wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
LABEL_7:
      int v22 = *a6;
      uint64_t v23 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v24 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v23, v24);
      int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      uint64_t v15 = sub_10003B5D4(v22, v10);
      break;
    case 6:
    case 20:
      int v25 = *a6;
      uint64_t v26 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v27 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v26, v27);
      int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      int v28 = v25;
      unsigned int v29 = v10;
      goto LABEL_10;
    case 7:
    case 9:
    case 21:
    case 23:
      int v11 = *a6;
      int v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v13 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v12, v13);
      int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      uint64_t v15 = sub_10003B350(v11, v10);
      break;
    case 8:
    case 22:
      unsigned int v30 = wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
      int v31 = *a6;
      unint64_t v32 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v33 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v32, v33);
      int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      int v28 = v31;
      unsigned int v29 = v30;
LABEL_10:
      uint64_t v15 = sub_10003B724(v28, v29);
      break;
    case 12:
    case 26:
      unsigned int v34 = a2 != 0;
      int v35 = *a6;
      unsigned int v36 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v37 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v36, v37);
      int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      uint64_t v15 = sub_10003B49C(v35, v34);
      break;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
  unint64_t v38 = v15;
  int WireTypeForType = wis::reflect::getWireTypeForType();
  switch(WireTypeForType)
  {
    case 5:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v14, v38);
      break;
    case 1:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v14, v38);
      break;
    case 0:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v14, v38);
      break;
  }
  return 1;
}

void sub_1000DBED4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DBF50(int a1, uint64_t *a2, uint64_t a3, uint64_t a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 15:
      sub_1000385BC(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v10 = *a6;
      int v11 = sub_1000DCA84(a3, (long double **)v48, (uint64_t)__p, *a5);
      if (v11 == 3) {
        goto LABEL_54;
      }
      if (!v11)
      {
        int v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v13 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v12, v13);
        sub_10003C2D0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v10, (uint64_t *)v48);
      }
      goto LABEL_8;
    case 16:
      sub_1000386C8(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v14 = *a6;
      int v15 = sub_1000DCB24(a3, (float **)v48, (uint64_t)__p, *a5);
      if (v15 == 3)
      {
LABEL_54:
        uint64_t v18 = 0;
      }
      else
      {
        if (!v15)
        {
          int v16 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v17 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v16, v17);
          sub_10003D7B4(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v14, (uint64_t *)v48);
        }
LABEL_8:
        uint64_t v18 = 1;
      }
      BOOL v46 = v48[0];
      if (!v48[0]) {
        return v18;
      }
      v48[1] = v48[0];
LABEL_59:
      operator delete(v46);
      return v18;
    case 17:
      sub_100038538(a2, __p);
      int v19 = *a6;
      uint64_t v20 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v20 - **(void **)(a3 + 176)) >> 2) - 1) {
        goto LABEL_44;
      }
      if (*(_DWORD *)(v20 - 4) != *a5) {
        goto LABEL_44;
      }
      int v21 = __p[1];
      if (__p[0] != __p[1]) {
        goto LABEL_44;
      }
      goto LABEL_46;
    case 18:
      sub_100038538(a2, __p);
      int v22 = *a6;
      uint64_t v23 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v23 - **(void **)(a3 + 176)) >> 2) - 1) {
        goto LABEL_16;
      }
      if (*(_DWORD *)(v23 - 4) != *a5) {
        goto LABEL_16;
      }
      int v21 = __p[1];
      if (__p[0] != __p[1]) {
        goto LABEL_16;
      }
      goto LABEL_46;
    case 19:
      sub_1000387D4(a2, __p);
      int v19 = *a6;
      uint64_t v26 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v26 - **(void **)(a3 + 176)) >> 2) - 1) {
        goto LABEL_44;
      }
      if (*(_DWORD *)(v26 - 4) != *a5) {
        goto LABEL_44;
      }
      int v21 = __p[1];
      if (__p[0] != __p[1]) {
        goto LABEL_44;
      }
      goto LABEL_46;
    case 20:
      sub_100038644(a2, __p);
      int v27 = *a6;
      uint64_t v28 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v28 - **(void **)(a3 + 176)) >> 2) - 1) {
        goto LABEL_24;
      }
      if (*(_DWORD *)(v28 - 4) != *a5) {
        goto LABEL_24;
      }
      int v21 = __p[1];
      if (__p[0] != __p[1]) {
        goto LABEL_24;
      }
      goto LABEL_46;
    case 21:
      sub_100038644(a2, __p);
      int v31 = *a6;
      uint64_t v32 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v32 - **(void **)(a3 + 176)) >> 2) - 1) {
        goto LABEL_28;
      }
      if (*(_DWORD *)(v32 - 4) != *a5) {
        goto LABEL_28;
      }
      int v21 = __p[1];
      if (__p[0] != __p[1]) {
        goto LABEL_28;
      }
      goto LABEL_46;
    case 22:
      sub_10003885C(a2, __p);
      int v27 = *a6;
      uint64_t v35 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v35 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v35 - 4) == *a5)
      {
        int v21 = __p[1];
        if (__p[0] == __p[1]) {
          goto LABEL_46;
        }
      }
LABEL_24:
      unsigned int v29 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v30 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v29, v30);
      sub_10003F9B0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v27, (uint64_t *)__p);
      goto LABEL_45;
    case 23:
      sub_100038644(a2, __p);
      int v31 = *a6;
      uint64_t v36 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v36 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v36 - 4) == *a5)
      {
        int v21 = __p[1];
        if (__p[0] == __p[1]) {
          goto LABEL_46;
        }
      }
LABEL_28:
      unsigned int v33 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v34 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v33, v34);
      sub_10003CD54(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v31, (uint64_t *)__p);
      goto LABEL_45;
    case 24:
      sub_100038538(a2, __p);
      int v22 = *a6;
      uint64_t v37 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v37 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v37 - 4) == *a5)
      {
        int v21 = __p[1];
        if (__p[0] == __p[1]) {
          goto LABEL_46;
        }
      }
LABEL_16:
      unsigned int v24 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v25 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v24, v25);
      sub_10003B870(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v22, (uint64_t *)__p);
      goto LABEL_45;
    case 25:
      sub_100038538(a2, __p);
      int v19 = *a6;
      uint64_t v38 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v38 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v38 - 4) == *a5)
      {
        int v21 = __p[1];
        if (__p[0] == __p[1]) {
          goto LABEL_46;
        }
      }
LABEL_44:
      unsigned int v39 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v40 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v39, v40);
      sub_10003EF50(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v19, (uint64_t *)__p);
LABEL_45:
      int v21 = __p[0];
LABEL_46:
      if (v21)
      {
        __p[1] = v21;
        operator delete(v21);
      }
      return 1;
    case 26:
      sub_100038750((uint64_t)a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v42 = *a6;
      int v43 = sub_1000D5678(a3, (uint64_t **)v48, (uint64_t)__p, *a5);
      if (v43 == 3)
      {
        uint64_t v18 = 0;
      }
      else
      {
        if (!v43)
        {
          uint64_t v44 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v45 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v44, v45);
          sub_10003E238(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v42, (uint64_t *)v48);
        }
        uint64_t v18 = 1;
      }
      BOOL v46 = v48[0];
      if (v48[0]) {
        goto LABEL_59;
      }
      return v18;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
}

void sub_1000DC5B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

BOOL sub_1000DC654(uint64_t a1, wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a3, int a4, long long *a5)
{
  unint64_t v7 = *(void *)(a1 + 168);
  uint64_t v8 = **(void **)(a1 + 176);
  if (v7 < (*(void *)(*(void *)(a1 + 176) + 8) - v8) >> 2 && *(_DWORD *)(v8 + 4 * v7) == a4)
  {
    *(void *)(a1 + 168) = v7 + 1;
    std::string __p = 0;
    int v27 = 0;
    uint64_t v28 = 0;
    sub_100009298(v25, (uint64_t)&__p);
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v24, (wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v25);
    uint64_t v10 = *(void *)(a1 + 48);
    *(void *)(a1 + 48) = v24;
    while (1)
    {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
      BOOL v12 = v11 < 1;
      if (v11 < 1) {
        break;
      }
      long long v22 = *a5;
      uint64_t v23 = *((void *)a5 + 2);
      if ((sub_1000DCBD0(this, (uint64_t)&v22, a1) & 1) == 0) {
        goto LABEL_12;
      }
    }
    --*(void *)(a1 + 168);
    *(void *)(a1 + 48) = v10;
LABEL_12:
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v24);
    wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v25);
    if (v11 <= 0)
    {
      uint64_t v18 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      unsigned int v19 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v18, v19);
      uint64_t v20 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      int v21 = __p;
      LODWORD(v18) = v27 - __p;
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v20, v27 - (unsigned char *)__p);
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v20, v21, (int)v18);
    }
    if (__p)
    {
      int v27 = __p;
      operator delete(__p);
    }
  }
  else
  {
    v24[0] = 0;
    LODWORD(__p) = 0;
    wireless_diagnostics::google::protobuf::io::CodedInputStream::GetDirectBufferPointer(this, (const void **)v24, (int *)&__p);
    LODWORD(__p) = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
    if ((__p & 0x80000000) == 0)
    {
      unsigned int v13 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      unsigned int v14 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v13, v14);
      int v15 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      int v16 = v24[0];
      LODWORD(v13) = __p;
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v15, (int)__p);
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v15, v16, (int)v13);
    }
    return 1;
  }
  return v12;
}

void sub_1000DC828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000DC86C(uint64_t a1, long double *a2, uint64_t a3, int a4)
{
  uint64_t v5 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v5 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v5 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
    double v6 = *a2;
    *a2 = v6 - fmod(*a2, *(long double *)(a1 + 184));
  }
  unint64_t v7 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  wis::reflect::getWireTypeForType();
  unsigned int v8 = wis::reflect::encodeTag();
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v7, v8);
  uint64_t v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  uint64_t v10 = wis::protobuf::NumberConverter<(wis::reflect::Type)1>::encode();
  int WireTypeForType = wis::reflect::getWireTypeForType();
  switch(WireTypeForType)
  {
    case 5:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v9, v10);
      break;
    case 1:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v9, v10);
      break;
    case 0:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v9, v10);
      break;
  }
  return 1;
}

uint64_t sub_1000DC974(uint64_t a1, float *a2, uint64_t a3, int a4)
{
  uint64_t v6 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v6 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v6 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
    long double v7 = *a2;
    float v8 = v7 - fmod(v7, *(long double *)(a1 + 184));
    *a2 = v8;
  }
  uint64_t v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  wis::reflect::getWireTypeForType();
  unsigned int v10 = wis::reflect::encodeTag();
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
  int v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
  uint64_t v12 = wis::protobuf::NumberConverter<(wis::reflect::Type)2>::encode();
  int WireTypeForType = wis::reflect::getWireTypeForType();
  switch(WireTypeForType)
  {
    case 5:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v11, v12);
      break;
    case 1:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v11, v12);
      break;
    case 0:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v12);
      break;
  }
  return 1;
}

uint64_t sub_1000DCA84(uint64_t a1, long double **a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) != ((v4 - **(void **)(a1 + 176)) >> 2) - 1 || *(_DWORD *)(v4 - 4) != a4) {
    return 0;
  }
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  if (*a2 == v6) {
    return 1;
  }
  do
  {
    double v8 = *v5;
    *uint64_t v5 = v8 - fmod(*v5, *(long double *)(a1 + 184));
    ++v5;
  }
  while (v5 != v6);
  uint64_t result = 0;
  *(unsigned char *)(a1 + 160) = 1;
  return result;
}

uint64_t sub_1000DCB24(uint64_t a1, float **a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) != ((v4 - **(void **)(a1 + 176)) >> 2) - 1 || *(_DWORD *)(v4 - 4) != a4) {
    return 0;
  }
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  if (*a2 == v6) {
    return 1;
  }
  long double v8 = *(double *)(a1 + 184);
  do
  {
    long double v9 = *v5;
    float v10 = v9 - fmod(v9, v8);
    *v5++ = v10;
  }
  while (v5 != v6);
  uint64_t result = 0;
  *(unsigned char *)(a1 + 160) = 1;
  return result;
}

uint64_t sub_1000DCBD0(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a2, uint64_t a3)
{
  long double v7 = (unsigned __int8 *)*((void *)this + 1);
  if ((unint64_t)v7 >= *((void *)this + 2) || (char)*v7 < 0)
  {
    unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = TagFallback;
    if (TagFallback) {
      goto LABEL_4;
    }
LABEL_10:
    if (*((unsigned char *)this + 36))
    {
LABEL_49:
      char v3 = 1;
      return v3 & 1;
    }
LABEL_11:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
LABEL_111:
  }
  unint64_t TagFallback = *v7;
  *((_DWORD *)this + 8) = TagFallback;
  *((void *)this + 1) = v7 + 1;
  if (!TagFallback) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v9 = wis::reflect::decodeTag((wis::reflect *)TagFallback, a2);
  char v10 = v9;
  unsigned int v73 = HIDWORD(v9);
  MetricFileMetadataHelper::getSubfieldType();
  *(_OWORD *)uint64_t v74 = v71;
  int v75 = v72;
  int BuiltinType = MetadataHelper::getBuiltinType();
  int v70 = BuiltinType;
  int DecodingType = wis::reflect::getDecodingType();
  switch(DecodingType)
  {
    case 0:
      switch(v10)
      {
        case 0:
          *(void *)uint64_t v74 = 0;
          if (!sub_100038330(this, (unint64_t *)v74)) {
            goto LABEL_47;
          }
          unint64_t v32 = *(void *)v74;
          long long v55 = *(_OWORD *)a2;
          uint64_t v56 = *(void *)(a2 + 16);
          uint64_t v33 = v73;
          unsigned int v34 = &v55;
          uint64_t v35 = a3;
          unsigned int v36 = 0;
          goto LABEL_108;
        case 1:
          *(void *)uint64_t v74 = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v74))goto LABEL_47; {
          unint64_t v32 = *(void *)v74;
          }
          long long v51 = *(_OWORD *)a2;
          uint64_t v52 = *(void *)(a2 + 16);
          uint64_t v33 = v73;
          unsigned int v34 = &v51;
          uint64_t v35 = a3;
          unsigned int v36 = 1;
          goto LABEL_108;
        case 2:
          v66[0] = 0;
          if ((sub_100038360(this, v66) & 1) == 0) {
            goto LABEL_47;
          }
          sub_10003908C(v74, v66[0]);
          char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v74, v66[0]);
          if ((Raw & 1) == 0) {
            goto LABEL_96;
          }
          char v48 = sub_1000D5040(a3, *(const void **)v74, *(void *)&v74[2] - *(void *)v74);
          goto LABEL_95;
        case 5:
          v74[0] = 0;
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v74))goto LABEL_47; {
          uint64_t v33 = v73;
          }
          unint64_t v32 = v74[0];
          long long v53 = *(_OWORD *)a2;
          uint64_t v54 = *(void *)(a2 + 16);
          unsigned int v34 = &v53;
          uint64_t v35 = a3;
          unsigned int v36 = 5;
LABEL_108:
          char v42 = sub_1000D4F1C(v35, v32, (uint64_t)v34, v33, v36);
          goto LABEL_77;
        default:
          goto LABEL_47;
      }
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      *(void *)uint64_t v74 = 0;
      switch(v10)
      {
        case 0:
          unsigned int v13 = (char *)*((void *)this + 1);
          if ((unint64_t)v13 < *((void *)this + 2) && (*v13 & 0x80000000) == 0)
          {
            *(void *)uint64_t v74 = *v13;
            *((void *)this + 1) = v13 + 1;
            goto LABEL_76;
          }
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, (unint64_t *)v74))goto LABEL_76; {
          if (!v73 && *((unsigned char *)this + 36))
          }
            goto LABEL_49;
LABEL_57:
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        case 1:
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v74))goto LABEL_76; {
          if (v73 || !*((unsigned char *)this + 36))
          }
            goto LABEL_57;
          goto LABEL_49;
        case 2:
          if (v73 || !*((unsigned char *)this + 36)) {
            goto LABEL_11;
          }
          goto LABEL_49;
        case 5:
          v66[0] = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v66))
          {
            *(void *)uint64_t v74 = v66[0];
LABEL_76:
            char v42 = sub_1000DD58C(BuiltinType, *(uint64_t *)v74, a3, (long long *)a2, (int *)&v73, &v70);
LABEL_77:
            char v3 = v42;
            return v3 & 1;
          }
          if (!v73 && *((unsigned char *)this + 36)) {
            goto LABEL_49;
          }
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        default:
          goto LABEL_76;
      }
      goto LABEL_111;
    case 13:
      v66[0] = 0;
      uint64_t v37 = (char *)*((void *)this + 1);
      if ((unint64_t)v37 >= *((void *)this + 2) || *v37 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v66))goto LABEL_47; {
      }
        }
      else
      {
        v66[0] = *v37;
        *((void *)this + 1) = v37 + 1;
      }
      memset(v74, 0, sizeof(v74));
      int v75 = 0;
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
      if (Raw)
      {
        long long v63 = *(_OWORD *)a2;
        uint64_t v64 = *(void *)(a2 + 16);
        char v3 = sub_1000D4C0C(a3, v74);
      }
      if ((SHIBYTE(v75) & 0x80000000) == 0) {
        goto LABEL_99;
      }
      uint64_t v44 = *(void **)v74;
      goto LABEL_98;
    case 14:
      v66[0] = 0;
      unsigned int v40 = (char *)*((void *)this + 1);
      if ((unint64_t)v40 >= *((void *)this + 2) || *v40 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v66))goto LABEL_47; {
        unsigned int v41 = v66[0];
        }
      }
      else
      {
        unsigned int v41 = *v40;
        v66[0] = v41;
        *((void *)this + 1) = v40 + 1;
      }
      sub_10003908C(v74, v41);
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v74, v66[0]);
      if (Raw)
      {
        long long v61 = *(_OWORD *)a2;
        uint64_t v62 = *(void *)(a2 + 16);
        char v48 = sub_1000D4C90(a3, (uint64_t)v74);
LABEL_95:
        char v3 = v48;
      }
LABEL_96:
      uint64_t v44 = *(void **)v74;
      if (*(void *)v74)
      {
        *(void *)&v74[2] = *(void *)v74;
LABEL_98:
        operator delete(v44);
      }
LABEL_99:
      if (Raw) {
        return v3 & 1;
      }
      goto LABEL_47;
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      unsigned int v69 = 0;
      int v15 = (unsigned __int8 *)*((void *)this + 1);
      if ((unint64_t)v15 >= *((void *)this + 2) || (char)*v15 < 0)
      {
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v69)) {
          goto LABEL_16;
        }
LABEL_47:
        if (!v73 && *((unsigned char *)this + 36)) {
          goto LABEL_49;
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Parsing failed in metric");
        goto LABEL_111;
      }
      unsigned int v69 = *v15;
      *((void *)this + 1) = v15 + 1;
LABEL_16:
      uint64_t v49 = a2;
      uint64_t v50 = a3;
      int UnpackedType = wis::reflect::getUnpackedType();
      int WireTypeForType = wis::reflect::getWireTypeForType();
      *(void *)v66 = this;
      int v67 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v69);
      memset(v74, 0, sizeof(v74));
      int v75 = 0;
      while (1)
      {
        int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
        if (v17 < 1) {
          break;
        }
        uint64_t v18 = *(char **)&v74[2];
        if (*(void *)&v74[2] >= (unint64_t)v75)
        {
          uint64_t v20 = *(char **)v74;
          uint64_t v21 = (uint64_t)(*(void *)&v74[2] - *(void *)v74) >> 3;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 61) {
            sub_10002B5E0();
          }
          uint64_t v23 = (uint64_t)&v75[-*(void *)v74];
          if ((uint64_t)&v75[-*(void *)v74] >> 2 > v22) {
            unint64_t v22 = v23 >> 2;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24)
          {
            unsigned int v25 = (char *)sub_100038500((uint64_t)&v75, v24);
            uint64_t v20 = *(char **)v74;
            uint64_t v18 = *(char **)&v74[2];
          }
          else
          {
            unsigned int v25 = 0;
          }
          uint64_t v26 = &v25[8 * v21];
          *(void *)uint64_t v26 = 0;
          unsigned int v19 = v26 + 8;
          while (v18 != v20)
          {
            uint64_t v27 = *((void *)v18 - 1);
            v18 -= 8;
            *((void *)v26 - 1) = v27;
            v26 -= 8;
          }
          *(void *)uint64_t v74 = v26;
          *(void *)&v74[2] = v19;
          int v75 = &v25[8 * v24];
          if (v20) {
            operator delete(v20);
          }
        }
        else
        {
          **(void **)&v74[2] = 0;
          unsigned int v19 = v18 + 8;
        }
        *(void *)&v74[2] = v19;
        switch(WireTypeForType)
        {
          case 0:
            uint64_t v28 = v19 - 1;
            unsigned int v29 = (char *)*((void *)this + 1);
            if ((unint64_t)v29 >= *((void *)this + 2) || *v29 < 0)
            {
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v28);
LABEL_41:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_44;
              }
            }
            else
            {
              unint64_t *v28 = *v29;
              *((void *)this + 1) = v29 + 1;
            }
            break;
          case 1:
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, v19 - 1);
            goto LABEL_41;
          case 2:
            goto LABEL_44;
          case 5:
            unsigned int v65 = 0;
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v65);
            *(void *)(*(void *)&v74[2] - 8) = v65;
            goto LABEL_41;
          default:
            continue;
        }
      }
      char v3 = sub_1000DD8F4(DecodingType, (uint64_t *)v74, v50, v49, (int *)&v73, &UnpackedType);
LABEL_44:
      if (*(void *)v74)
      {
        *(void *)&v74[2] = *(void *)v74;
        operator delete(*(void **)v74);
      }
      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(*(wireless_diagnostics::google::protobuf::io::CodedInputStream **)v66, v67);
      if (v17 > 0) {
        goto LABEL_47;
      }
      return v3 & 1;
    case 27:
      unsigned int v69 = 0;
      uint64_t v38 = (char *)*((void *)this + 1);
      if ((unint64_t)v38 >= *((void *)this + 2) || *v38 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v69))goto LABEL_47; {
        unsigned int v39 = v69;
        }
      }
      else
      {
        unsigned int v39 = *v38;
        unsigned int v69 = v39;
        *((void *)this + 1) = v38 + 1;
      }
      *(void *)uint64_t v74 = this;
      v74[2] = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v39);
      ++*((_DWORD *)this + 14);
      *(void *)v66 = this;
      long long v59 = *(_OWORD *)a2;
      uint64_t v60 = *(void *)(a2 + 16);
      long long v57 = v71;
      uint64_t v58 = v72;
      char v3 = sub_1000DC654(a3, this);
      sub_1000DDFF8((wireless_diagnostics::google::protobuf::io::CodedInputStream **)v66);
      int v45 = *((_DWORD *)this + 14);
      BOOL v46 = __OFSUB__(v45, 1);
      int v47 = v45 - 1;
      if (v47 < 0 == v46) {
        *((_DWORD *)this + 14) = v47;
      }
      sub_100039058((uint64_t)v74);
      return v3 & 1;
    default:
      goto LABEL_47;
  }
}

void sub_1000DD424(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 - 112);
  if (v3)
  {
    *(void *)(v1 - 104) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DD58C(int a1, uint64_t a2, uint64_t a3, long long *a4, int *a5, int *a6)
{
  uint64_t v10 = a2;
  switch(a1)
  {
    case 1:
    case 15:
      wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
      uint64_t v45 = v19;
      long long v43 = *a4;
      uint64_t v44 = *((void *)a4 + 2);
      return sub_1000DC86C(a3, (long double *)&v45, (uint64_t)&v43, *a5);
    case 2:
    case 16:
      wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
      LODWORD(v45) = v21;
      long long v41 = *a4;
      uint64_t v42 = *((void *)a4 + 2);
      return sub_1000DC974(a3, (float *)&v45, (uint64_t)&v41, *a5);
    case 3:
    case 11:
    case 17:
    case 25:
      goto LABEL_7;
    case 4:
    case 10:
    case 18:
    case 24:
      int v16 = *a6;
      int v17 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v18 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v17, v18);
      unsigned int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      uint64_t v15 = sub_10003B200(v16, v10);
      break;
    case 5:
    case 19:
      uint64_t v10 = wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
LABEL_7:
      int v22 = *a6;
      uint64_t v23 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v24 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v23, v24);
      unsigned int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      uint64_t v15 = sub_10003B5D4(v22, v10);
      break;
    case 6:
    case 20:
      int v25 = *a6;
      uint64_t v26 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v27 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v26, v27);
      unsigned int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      int v28 = v25;
      unsigned int v29 = v10;
      goto LABEL_10;
    case 7:
    case 9:
    case 21:
    case 23:
      int v11 = *a6;
      uint64_t v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v13 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v12, v13);
      unsigned int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      uint64_t v15 = sub_10003B350(v11, v10);
      break;
    case 8:
    case 22:
      unsigned int v30 = wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
      int v31 = *a6;
      unint64_t v32 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v33 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v32, v33);
      unsigned int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      int v28 = v31;
      unsigned int v29 = v30;
LABEL_10:
      uint64_t v15 = sub_10003B724(v28, v29);
      break;
    case 12:
    case 26:
      unsigned int v34 = a2 != 0;
      int v35 = *a6;
      unsigned int v36 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      wis::reflect::getWireTypeForType();
      unsigned int v37 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v36, v37);
      unsigned int v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      uint64_t v15 = sub_10003B49C(v35, v34);
      break;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
  unint64_t v38 = v15;
  int WireTypeForType = wis::reflect::getWireTypeForType();
  switch(WireTypeForType)
  {
    case 5:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v14, v38);
      break;
    case 1:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v14, v38);
      break;
    case 0:
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v14, v38);
      break;
  }
  return 1;
}

void sub_1000DD878(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DD8F4(int a1, uint64_t *a2, uint64_t a3, uint64_t a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 15:
      sub_1000385BC(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v10 = *a6;
      int v11 = sub_1000DCA84(a3, (long double **)v48, (uint64_t)__p, *a5);
      if (v11 == 3) {
        goto LABEL_54;
      }
      if (!v11)
      {
        uint64_t v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v13 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v12, v13);
        sub_10003C2D0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v10, (uint64_t *)v48);
      }
      goto LABEL_8;
    case 16:
      sub_1000386C8(a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v14 = *a6;
      int v15 = sub_1000DCB24(a3, (float **)v48, (uint64_t)__p, *a5);
      if (v15 == 3)
      {
LABEL_54:
        uint64_t v18 = 0;
      }
      else
      {
        if (!v15)
        {
          int v16 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v17 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v16, v17);
          sub_10003D7B4(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v14, (uint64_t *)v48);
        }
LABEL_8:
        uint64_t v18 = 1;
      }
      BOOL v46 = v48[0];
      if (!v48[0]) {
        return v18;
      }
      v48[1] = v48[0];
LABEL_59:
      operator delete(v46);
      return v18;
    case 17:
      sub_100038538(a2, __p);
      int v19 = *a6;
      uint64_t v20 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v20 - **(void **)(a3 + 176)) >> 2) - 1) {
        goto LABEL_44;
      }
      if (*(_DWORD *)(v20 - 4) != *a5) {
        goto LABEL_44;
      }
      int v21 = __p[1];
      if (__p[0] != __p[1]) {
        goto LABEL_44;
      }
      goto LABEL_46;
    case 18:
      sub_100038538(a2, __p);
      int v22 = *a6;
      uint64_t v23 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v23 - **(void **)(a3 + 176)) >> 2) - 1) {
        goto LABEL_16;
      }
      if (*(_DWORD *)(v23 - 4) != *a5) {
        goto LABEL_16;
      }
      int v21 = __p[1];
      if (__p[0] != __p[1]) {
        goto LABEL_16;
      }
      goto LABEL_46;
    case 19:
      sub_1000387D4(a2, __p);
      int v19 = *a6;
      uint64_t v26 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v26 - **(void **)(a3 + 176)) >> 2) - 1) {
        goto LABEL_44;
      }
      if (*(_DWORD *)(v26 - 4) != *a5) {
        goto LABEL_44;
      }
      int v21 = __p[1];
      if (__p[0] != __p[1]) {
        goto LABEL_44;
      }
      goto LABEL_46;
    case 20:
      sub_100038644(a2, __p);
      int v27 = *a6;
      uint64_t v28 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v28 - **(void **)(a3 + 176)) >> 2) - 1) {
        goto LABEL_24;
      }
      if (*(_DWORD *)(v28 - 4) != *a5) {
        goto LABEL_24;
      }
      int v21 = __p[1];
      if (__p[0] != __p[1]) {
        goto LABEL_24;
      }
      goto LABEL_46;
    case 21:
      sub_100038644(a2, __p);
      int v31 = *a6;
      uint64_t v32 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v32 - **(void **)(a3 + 176)) >> 2) - 1) {
        goto LABEL_28;
      }
      if (*(_DWORD *)(v32 - 4) != *a5) {
        goto LABEL_28;
      }
      int v21 = __p[1];
      if (__p[0] != __p[1]) {
        goto LABEL_28;
      }
      goto LABEL_46;
    case 22:
      sub_10003885C(a2, __p);
      int v27 = *a6;
      uint64_t v35 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v35 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v35 - 4) == *a5)
      {
        int v21 = __p[1];
        if (__p[0] == __p[1]) {
          goto LABEL_46;
        }
      }
LABEL_24:
      unsigned int v29 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v30 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v29, v30);
      sub_10003F9B0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v27, (uint64_t *)__p);
      goto LABEL_45;
    case 23:
      sub_100038644(a2, __p);
      int v31 = *a6;
      uint64_t v36 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v36 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v36 - 4) == *a5)
      {
        int v21 = __p[1];
        if (__p[0] == __p[1]) {
          goto LABEL_46;
        }
      }
LABEL_28:
      unsigned int v33 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v34 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v33, v34);
      sub_10003CD54(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v31, (uint64_t *)__p);
      goto LABEL_45;
    case 24:
      sub_100038538(a2, __p);
      int v22 = *a6;
      uint64_t v37 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v37 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v37 - 4) == *a5)
      {
        int v21 = __p[1];
        if (__p[0] == __p[1]) {
          goto LABEL_46;
        }
      }
LABEL_16:
      unsigned int v24 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v25 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v24, v25);
      sub_10003B870(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v22, (uint64_t *)__p);
      goto LABEL_45;
    case 25:
      sub_100038538(a2, __p);
      int v19 = *a6;
      uint64_t v38 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v38 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v38 - 4) == *a5)
      {
        int v21 = __p[1];
        if (__p[0] == __p[1]) {
          goto LABEL_46;
        }
      }
LABEL_44:
      unsigned int v39 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v40 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v39, v40);
      sub_10003EF50(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v19, (uint64_t *)__p);
LABEL_45:
      int v21 = __p[0];
LABEL_46:
      if (v21)
      {
        __p[1] = v21;
        operator delete(v21);
      }
      return 1;
    case 26:
      sub_100038750((uint64_t)a2, v48);
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v50 = *(void *)(a4 + 16);
      int v42 = *a6;
      int v43 = sub_1000D5678(a3, (uint64_t **)v48, (uint64_t)__p, *a5);
      if (v43 == 3)
      {
        uint64_t v18 = 0;
      }
      else
      {
        if (!v43)
        {
          uint64_t v44 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v45 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v44, v45);
          sub_10003E238(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v42, (uint64_t *)v48);
        }
        uint64_t v18 = 1;
      }
      BOOL v46 = v48[0];
      if (v48[0]) {
        goto LABEL_59;
      }
      return v18;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
}

void sub_1000DDF54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

wireless_diagnostics::google::protobuf::io::CodedInputStream **sub_1000DDFF8(wireless_diagnostics::google::protobuf::io::CodedInputStream **a1)
{
  int v2 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(*a1);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip(*a1, v2);
  return a1;
}

wireless_diagnostics::google::protobuf::io::CodedInputStream **sub_1000DE034(wireless_diagnostics::google::protobuf::io::CodedInputStream **a1)
{
  int v2 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(*a1);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip(*a1, v2);
  return a1;
}

void *sub_1000DE070(void *a1)
{
  *a1 = off_1001BC218;
  int v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1000DE0C0(void *a1)
{
  *a1 = off_1001BC218;
  int v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }

  operator delete();
}

void *sub_1000DE130(uint64_t a1)
{
  int v2 = operator new(0x20uLL);
  void *v2 = off_1001BC218;
  v2[2] = 0;
  v2[3] = 0;
  v2[1] = 0;
  sub_10001E158(v2 + 1, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2);
  return v2;
}

void sub_1000DE194(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000DE1A8(uint64_t a1, void *a2)
{
  *a2 = off_1001BC218;
  a2[2] = 0;
  a2[3] = 0;
  a2[1] = 0;
  return sub_10001E158(a2 + 1, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2);
}

void sub_1000DE1E4(uint64_t a1)
{
  int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void sub_1000DE1FC(void *__p)
{
  int v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

uint64_t sub_1000DE240(uint64_t a1, void *a2)
{
  __n128 v23 = 0uLL;
  uint64_t v24 = 0;
  char v3 = (uint64_t *)a2[1];
  if (!v3) {
    char v3 = *(uint64_t **)(*a2 + 8);
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1] - *v3;
  v14[0] = 0;
  v14[1] = v4;
  _OWORD v14[2] = v4 + (int)v5;
  int v15 = v5;
  uint64_t v16 = 0;
  __int16 v17 = 0;
  long long v19 = xmmword_100174830;
  int v18 = v5;
  int v20 = wireless_diagnostics::google::protobuf::io::CodedInputStream::default_recursion_limit_;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  sub_1000DEE24((uint64_t)v10, (uint64_t)(a2 + 2), (uint64_t)&v23, a1 + 8);
  v9[0] = 0;
  v9[1] = 0;
  v9[2] = 0xFFFFFFFFLL;
  if (sub_1000DE464((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v14, (uint64_t)v9, (uint64_t)v10))
  {
    int v6 = v13[64];
    sub_100038238((uint64_t)v13);
    if (v12) {
      sub_10000B678(v12);
    }
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v11);
    wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v10);
    wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v14);
    if (v6)
    {
      sub_1000D2E5C((uint64_t)a2, &v23);
      uint64_t v7 = 1;
      goto LABEL_12;
    }
  }
  else
  {
    sub_100038238((uint64_t)v13);
    if (v12) {
      sub_10000B678(v12);
    }
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v11);
    wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v10);
    wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v14);
  }
  uint64_t v7 = 0;
LABEL_12:
  if (v23.n128_u64[0])
  {
    v23.n128_u64[1] = v23.n128_u64[0];
    operator delete((void *)v23.n128_u64[0]);
  }
  return v7;
}

void sub_1000DE39C(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 - 56);
  if (v3)
  {
    *(void *)(v1 - 48) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000DE3B8(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  sub_100038238(v21 + 96);
  if (a21) {
    sub_10000B678(a21);
  }
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)&a15);
  wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)&a13);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream((wireless_diagnostics::google::protobuf::io::CodedInputStream *)(v22 - 136));
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1000DE370);
  }
  JUMPOUT(0x1000DE3A0);
}

uint64_t sub_1000DE418(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1000DE458()
{
}

uint64_t sub_1000DE464(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = (unsigned __int8 *)*((void *)this + 1);
  if ((unint64_t)v7 >= *((void *)this + 2) || (char)*v7 < 0)
  {
    unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = TagFallback;
    if (TagFallback) {
      goto LABEL_4;
    }
LABEL_10:
    if (*((unsigned char *)this + 36))
    {
LABEL_49:
      char v3 = 1;
      return v3 & 1;
    }
LABEL_11:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
LABEL_111:
  }
  unint64_t TagFallback = *v7;
  *((_DWORD *)this + 8) = TagFallback;
  *((void *)this + 1) = v7 + 1;
  if (!TagFallback) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v9 = wis::reflect::decodeTag((wis::reflect *)TagFallback, a2);
  char v10 = v9;
  v82[0] = HIDWORD(v9);
  long long v78 = *(_OWORD *)a2;
  uint64_t v79 = *(void *)(a2 + 16);
  MetricFileMetadataHelper::getSubfieldType();
  long long v75 = v80;
  uint64_t v76 = v81;
  int BuiltinType = MetadataHelper::getBuiltinType();
  int v77 = BuiltinType;
  int DecodingType = wis::reflect::getDecodingType();
  switch(DecodingType)
  {
    case 0:
      switch(v10)
      {
        case 0:
          *(void *)CFStringRef v68 = 0;
          if (!sub_100038330(this, (unint64_t *)v68)) {
            goto LABEL_47;
          }
          unint64_t v32 = *(void *)v68;
          long long v57 = *(_OWORD *)a2;
          uint64_t v58 = *(void *)(a2 + 16);
          int v33 = v82[0];
          unsigned int v34 = &v57;
          uint64_t v35 = a3;
          unsigned int v36 = 0;
          goto LABEL_108;
        case 1:
          *(void *)CFStringRef v68 = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v68))goto LABEL_47; {
          unint64_t v32 = *(void *)v68;
          }
          long long v53 = *(_OWORD *)a2;
          uint64_t v54 = *(void *)(a2 + 16);
          int v33 = v82[0];
          unsigned int v34 = &v53;
          uint64_t v35 = a3;
          unsigned int v36 = 1;
          goto LABEL_108;
        case 2:
          v71[0] = 0;
          if ((sub_100038360(this, v71) & 1) == 0) {
            goto LABEL_47;
          }
          sub_10003908C(v68, v71[0]);
          char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v68, v71[0]);
          if ((Raw & 1) == 0) {
            goto LABEL_96;
          }
          long long v51 = *(_OWORD *)a2;
          uint64_t v52 = *(void *)(a2 + 16);
          char v48 = sub_1000DFD58(a3, *(const void **)v68, (unint64_t)&v69[-*(void *)v68], (uint64_t)&v51, v82[0]);
          goto LABEL_95;
        case 5:
          v68[0] = 0;
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v68))goto LABEL_47; {
          unint64_t v32 = v68[0];
          }
          long long v55 = *(_OWORD *)a2;
          uint64_t v56 = *(void *)(a2 + 16);
          int v33 = v82[0];
          unsigned int v34 = &v55;
          uint64_t v35 = a3;
          unsigned int v36 = 5;
LABEL_108:
          char v42 = sub_1000DFC00(v35, v32, (uint64_t)v34, v33, v36);
          goto LABEL_77;
        default:
          goto LABEL_47;
      }
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      *(void *)CFStringRef v68 = 0;
      switch(v10)
      {
        case 0:
          unsigned int v13 = (char *)*((void *)this + 1);
          if ((unint64_t)v13 < *((void *)this + 2) && (*v13 & 0x80000000) == 0)
          {
            *(void *)CFStringRef v68 = *v13;
            *((void *)this + 1) = v13 + 1;
            goto LABEL_76;
          }
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, (unint64_t *)v68))goto LABEL_76; {
          if (!v82[0] && *((unsigned char *)this + 36))
          }
            goto LABEL_49;
LABEL_57:
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        case 1:
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v68))goto LABEL_76; {
          if (v82[0] || !*((unsigned char *)this + 36))
          }
            goto LABEL_57;
          goto LABEL_49;
        case 2:
          if (v82[0] || !*((unsigned char *)this + 36)) {
            goto LABEL_11;
          }
          goto LABEL_49;
        case 5:
          v71[0] = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v71))
          {
            *(void *)CFStringRef v68 = v71[0];
LABEL_76:
            char v42 = sub_1000DEEAC(BuiltinType, *(uint64_t *)v68, a3, (long long *)a2, v82, &v77);
LABEL_77:
            char v3 = v42;
            return v3 & 1;
          }
          if (!v82[0] && *((unsigned char *)this + 36)) {
            goto LABEL_49;
          }
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        default:
          goto LABEL_76;
      }
      goto LABEL_111;
    case 13:
      v71[0] = 0;
      uint64_t v37 = (char *)*((void *)this + 1);
      if ((unint64_t)v37 >= *((void *)this + 2) || *v37 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v71))goto LABEL_47; {
      }
        }
      else
      {
        v71[0] = *v37;
        *((void *)this + 1) = v37 + 1;
      }
      *(void *)CFStringRef v68 = 0;
      unsigned int v69 = 0;
      int v70 = 0;
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
      if (Raw)
      {
        long long v65 = *(_OWORD *)a2;
        uint64_t v66 = *(void *)(a2 + 16);
        char v3 = sub_1000DF848(a3, v68, (uint64_t)&v65, v82[0]);
      }
      if ((SHIBYTE(v70) & 0x80000000) == 0) {
        goto LABEL_99;
      }
      uint64_t v44 = *(void **)v68;
      goto LABEL_98;
    case 14:
      v71[0] = 0;
      unsigned int v40 = (char *)*((void *)this + 1);
      if ((unint64_t)v40 >= *((void *)this + 2) || *v40 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v71))goto LABEL_47; {
        unsigned int v41 = v71[0];
        }
      }
      else
      {
        unsigned int v41 = *v40;
        v71[0] = v41;
        *((void *)this + 1) = v40 + 1;
      }
      sub_10003908C(v68, v41);
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v68, v71[0]);
      if (Raw)
      {
        long long v63 = *(_OWORD *)a2;
        uint64_t v64 = *(void *)(a2 + 16);
        char v48 = sub_1000DF900(a3, (uint64_t)v68, (uint64_t)&v63, v82[0]);
LABEL_95:
        char v3 = v48;
      }
LABEL_96:
      uint64_t v44 = *(void **)v68;
      if (*(void *)v68)
      {
        unsigned int v69 = *(char **)v68;
LABEL_98:
        operator delete(v44);
      }
LABEL_99:
      if (Raw) {
        return v3 & 1;
      }
      goto LABEL_47;
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      unsigned int v74 = 0;
      int v15 = (unsigned __int8 *)*((void *)this + 1);
      if ((unint64_t)v15 >= *((void *)this + 2) || (char)*v15 < 0)
      {
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v74)) {
          goto LABEL_16;
        }
LABEL_47:
        if (!v82[0] && *((unsigned char *)this + 36)) {
          goto LABEL_49;
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Parsing failed in metric");
        goto LABEL_111;
      }
      unsigned int v74 = *v15;
      *((void *)this + 1) = v15 + 1;
LABEL_16:
      uint64_t v49 = a2;
      uint64_t v50 = a3;
      int UnpackedType = wis::reflect::getUnpackedType();
      int WireTypeForType = wis::reflect::getWireTypeForType();
      *(void *)long long v71 = this;
      int v72 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v74);
      *(void *)CFStringRef v68 = 0;
      unsigned int v69 = 0;
      int v70 = 0;
      while (1)
      {
        int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
        if (v17 < 1) {
          break;
        }
        int v18 = v69;
        if (v69 >= v70)
        {
          int v20 = *(char **)v68;
          uint64_t v21 = (uint64_t)&v69[-*(void *)v68] >> 3;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 61) {
            sub_10002B5E0();
          }
          uint64_t v23 = (uint64_t)&v70[-*(void *)v68];
          if ((uint64_t)&v70[-*(void *)v68] >> 2 > v22) {
            unint64_t v22 = v23 >> 2;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24)
          {
            unsigned int v25 = (char *)sub_100038500((uint64_t)&v70, v24);
            int v20 = *(char **)v68;
            int v18 = v69;
          }
          else
          {
            unsigned int v25 = 0;
          }
          uint64_t v26 = &v25[8 * v21];
          *(void *)uint64_t v26 = 0;
          long long v19 = v26 + 8;
          while (v18 != v20)
          {
            uint64_t v27 = *((void *)v18 - 1);
            v18 -= 8;
            *((void *)v26 - 1) = v27;
            v26 -= 8;
          }
          *(void *)CFStringRef v68 = v26;
          unsigned int v69 = v19;
          int v70 = &v25[8 * v24];
          if (v20) {
            operator delete(v20);
          }
        }
        else
        {
          *(void *)unsigned int v69 = 0;
          long long v19 = v18 + 8;
        }
        unsigned int v69 = v19;
        switch(WireTypeForType)
        {
          case 0:
            uint64_t v28 = (unint64_t *)(v19 - 8);
            unsigned int v29 = (char *)*((void *)this + 1);
            if ((unint64_t)v29 >= *((void *)this + 2) || *v29 < 0)
            {
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v28);
LABEL_41:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_44;
              }
            }
            else
            {
              unint64_t *v28 = *v29;
              *((void *)this + 1) = v29 + 1;
            }
            break;
          case 1:
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v19 - 1);
            goto LABEL_41;
          case 2:
            goto LABEL_44;
          case 5:
            unsigned int v67 = 0;
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v67);
            *((void *)v69 - 1) = v67;
            goto LABEL_41;
          default:
            continue;
        }
      }
      char v3 = sub_1000DF208(DecodingType, (uint64_t *)v68, v50, v49, v82, &UnpackedType);
LABEL_44:
      if (*(void *)v68)
      {
        unsigned int v69 = *(char **)v68;
        operator delete(*(void **)v68);
      }
      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(*(wireless_diagnostics::google::protobuf::io::CodedInputStream **)v71, v72);
      if (v17 > 0) {
        goto LABEL_47;
      }
      return v3 & 1;
    case 27:
      unsigned int v74 = 0;
      uint64_t v38 = (char *)*((void *)this + 1);
      if ((unint64_t)v38 >= *((void *)this + 2) || *v38 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v74))goto LABEL_47; {
        unsigned int v39 = v74;
        }
      }
      else
      {
        unsigned int v39 = *v38;
        unsigned int v74 = v39;
        *((void *)this + 1) = v38 + 1;
      }
      *(void *)CFStringRef v68 = this;
      LODWORD(v69) = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v39);
      ++*((_DWORD *)this + 14);
      *(void *)long long v71 = this;
      long long v61 = *(_OWORD *)a2;
      uint64_t v62 = *(void *)(a2 + 16);
      long long v59 = v80;
      uint64_t v60 = v81;
      char v3 = sub_1000DF9A8(a3, this, &v61, v82[0], &v59);
      sub_1000E187C((wireless_diagnostics::google::protobuf::io::CodedInputStream **)v71);
      int v45 = *((_DWORD *)this + 14);
      BOOL v46 = __OFSUB__(v45, 1);
      int v47 = v45 - 1;
      if (v47 < 0 == v46) {
        *((_DWORD *)this + 14) = v47;
      }
      sub_100039058((uint64_t)v68);
      return v3 & 1;
    default:
      goto LABEL_47;
  }
}

void sub_1000DECBC(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 - 224);
  if (v3)
  {
    *(void *)(v1 - 216) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DEE24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)(sub_100009298((void *)a1, a3) + 2);
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::CodedOutputStream(v6, (wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)a1);
  *(void *)(a1 + 48) = v6;
  MetricFileMetadataHelper::MetricFileMetadataHelper();
  *(unsigned char *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = a4;
  return a1;
}

void sub_1000DEE88(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream(v2);
  wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DEEAC(int a1, uint64_t a2, uint64_t a3, long long *a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 1:
    case 15:
      wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
      uint64_t v50 = v10;
      long long v46 = *a4;
      uint64_t v47 = *((void *)a4 + 2);
      return sub_1000DFEEC(a3, (uint64_t)&v50, (uint64_t)&v46, *a5);
    case 2:
    case 16:
      wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
      LODWORD(v50) = v12;
      long long v42 = *a4;
      uint64_t v43 = *((void *)a4 + 2);
      return sub_1000E00C8(a3, (uint64_t)&v50, (uint64_t)&v42, *a5);
    case 3:
    case 17:
      uint64_t v50 = a2;
      long long v38 = *a4;
      uint64_t v39 = *((void *)a4 + 2);
      int v13 = *a5;
      int v14 = *a6;
      int v15 = &v38;
      goto LABEL_16;
    case 4:
    case 18:
      uint64_t v50 = a2;
      long long v34 = *a4;
      uint64_t v35 = *((void *)a4 + 2);
      int v16 = *a5;
      int v17 = *a6;
      int v18 = &v34;
      goto LABEL_14;
    case 5:
    case 19:
      uint64_t v50 = wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
      long long v36 = *a4;
      uint64_t v37 = *((void *)a4 + 2);
      int v13 = *a5;
      int v14 = *a6;
      int v15 = &v36;
      goto LABEL_16;
    case 6:
    case 20:
      LODWORD(v50) = a2;
      long long v32 = *a4;
      uint64_t v33 = *((void *)a4 + 2);
      int v19 = *a5;
      int v20 = *a6;
      uint64_t v21 = &v32;
      goto LABEL_10;
    case 7:
    case 21:
      LODWORD(v50) = a2;
      long long v28 = *a4;
      uint64_t v29 = *((void *)a4 + 2);
      int v22 = *a5;
      int v23 = *a6;
      unint64_t v24 = &v28;
      goto LABEL_12;
    case 8:
    case 22:
      LODWORD(v50) = wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
      long long v30 = *a4;
      uint64_t v31 = *((void *)a4 + 2);
      int v19 = *a5;
      int v20 = *a6;
      uint64_t v21 = &v30;
LABEL_10:
      uint64_t result = sub_1000E0394(a3, (unsigned int *)&v50, (uint64_t)v21, v19, v20);
      break;
    case 9:
    case 23:
      LODWORD(v50) = a2;
      long long v44 = *a4;
      uint64_t v45 = *((void *)a4 + 2);
      int v22 = *a5;
      int v23 = *a6;
      unint64_t v24 = &v44;
LABEL_12:
      uint64_t result = sub_1000DFFD8(a3, (unsigned int *)&v50, (uint64_t)v24, v22, v23);
      break;
    case 10:
    case 24:
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      uint64_t v50 = a2;
      int v16 = *a5;
      int v17 = *a6;
      int v18 = &v48;
LABEL_14:
      uint64_t result = sub_1000DFDFC(a3, &v50, (uint64_t)v18, v16, v17);
      break;
    case 11:
    case 25:
      uint64_t v50 = a2;
      long long v26 = *a4;
      uint64_t v27 = *((void *)a4 + 2);
      int v13 = *a5;
      int v14 = *a6;
      int v15 = &v26;
LABEL_16:
      uint64_t result = sub_1000E02A4(a3, &v50, (uint64_t)v15, v13, v14);
      break;
    case 12:
    case 26:
      LOBYTE(v50) = a2 != 0;
      long long v40 = *a4;
      uint64_t v41 = *((void *)a4 + 2);
      uint64_t result = sub_1000E01B4(a3, (unsigned __int8 *)&v50, (uint64_t)&v40, *a5, *a6);
      break;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
  return result;
}

void sub_1000DF18C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DF208(int a1, uint64_t *a2, uint64_t a3, uint64_t a4, _DWORD *a5, int *a6)
{
  switch(a1)
  {
    case 15:
      sub_1000385BC(a2, __p);
      int v9 = *a6;
      uint64_t v10 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v10 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v10 - 4) == *a5) {
        goto LABEL_34;
      }
      int v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v12 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v11, v12);
      sub_10003C2D0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v9, (uint64_t *)__p);
      goto LABEL_39;
    case 16:
      sub_1000386C8(a2, __p);
      int v13 = *a6;
      uint64_t v14 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v14 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v14 - 4) == *a5) {
        goto LABEL_34;
      }
      int v15 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v16 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v15, v16);
      sub_10003D7B4(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v13, (uint64_t *)__p);
      goto LABEL_39;
    case 17:
      sub_100038538(a2, __p);
      int v17 = *a6;
      uint64_t v18 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v18 - **(void **)(a3 + 176)) >> 2) - 1 || *(_DWORD *)(v18 - 4) != *a5) {
        goto LABEL_38;
      }
      goto LABEL_34;
    case 18:
      sub_100038538(a2, __p);
      int v19 = *a6;
      uint64_t v20 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v20 - **(void **)(a3 + 176)) >> 2) - 1 || *(_DWORD *)(v20 - 4) != *a5) {
        goto LABEL_13;
      }
      goto LABEL_34;
    case 19:
      sub_1000387D4(a2, __p);
      int v17 = *a6;
      uint64_t v23 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v23 - **(void **)(a3 + 176)) >> 2) - 1 || *(_DWORD *)(v23 - 4) != *a5) {
        goto LABEL_38;
      }
      goto LABEL_34;
    case 20:
      sub_100038644(a2, __p);
      int v24 = *a6;
      uint64_t v25 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v25 - **(void **)(a3 + 176)) >> 2) - 1 || *(_DWORD *)(v25 - 4) != *a5) {
        goto LABEL_19;
      }
      goto LABEL_34;
    case 21:
      sub_100038644(a2, __p);
      int v28 = *a6;
      uint64_t v29 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v29 - **(void **)(a3 + 176)) >> 2) - 1 || *(_DWORD *)(v29 - 4) != *a5) {
        goto LABEL_22;
      }
      goto LABEL_34;
    case 22:
      sub_10003885C(a2, __p);
      int v24 = *a6;
      uint64_t v32 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v32 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v32 - 4) == *a5) {
        goto LABEL_34;
      }
LABEL_19:
      long long v26 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v27 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v26, v27);
      sub_10003F9B0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v24, (uint64_t *)__p);
      goto LABEL_39;
    case 23:
      sub_100038644(a2, __p);
      int v28 = *a6;
      uint64_t v33 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v33 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v33 - 4) == *a5) {
        goto LABEL_34;
      }
LABEL_22:
      long long v30 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v31 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v30, v31);
      sub_10003CD54(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v28, (uint64_t *)__p);
      goto LABEL_39;
    case 24:
      sub_100038538(a2, __p);
      int v19 = *a6;
      uint64_t v34 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v34 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v34 - 4) == *a5) {
        goto LABEL_34;
      }
LABEL_13:
      uint64_t v21 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v22 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v21, v22);
      sub_10003B870(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v19, (uint64_t *)__p);
      goto LABEL_39;
    case 25:
      sub_100038538(a2, __p);
      int v17 = *a6;
      uint64_t v35 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v35 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v35 - 4) == *a5)
      {
LABEL_34:
        *(unsigned char *)(a3 + 160) = 1;
      }
      else
      {
LABEL_38:
        long long v38 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v39 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v38, v39);
        sub_10003EF50(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v17, (uint64_t *)__p);
      }
LABEL_39:
      long long v40 = __p[0];
      if (!__p[0]) {
        return 1;
      }
      __p[1] = __p[0];
LABEL_41:
      operator delete(v40);
      return 1;
    case 26:
      sub_100038750((uint64_t)a2, __p);
      int v36 = *a6;
      uint64_t v37 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v37 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v37 - 4) == *a5)
      {
        *(unsigned char *)(a3 + 160) = 1;
      }
      else
      {
        long long v42 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v43 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v42, v43);
        sub_10003E238(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v36, (uint64_t *)__p);
      }
      long long v40 = __p[0];
      if (!__p[0]) {
        return 1;
      }
      goto LABEL_41;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
}

void sub_1000DF7B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  __cxa_free_exception(v11);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DF848(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  uint64_t v6 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v6 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v6 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
  }
  else
  {
    uint64_t v7 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    unsigned int v8 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v7, v8);
    int v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    unint64_t v10 = a2[1];
    if (*((char *)a2 + 23) >= 0)
    {
      unint64_t v11 = *((unsigned __int8 *)a2 + 23);
    }
    else
    {
      a2 = (void *)*a2;
      unint64_t v11 = v10;
    }
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v9, v11);
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v9, a2, v11);
  }
  return 1;
}

uint64_t sub_1000DF900(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v6 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v6 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
  }
  else
  {
    uint64_t v7 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    unsigned int v8 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v7, v8);
    int v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    unint64_t v10 = *(const void **)a2;
    unint64_t v11 = *(void *)(a2 + 8) - *(void *)a2;
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v9, v11);
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v9, v10, v11);
  }
  return 1;
}

uint64_t sub_1000DF9A8(uint64_t a1, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, long long *a3, int a4, long long *a5)
{
  long long v31 = *a3;
  uint64_t v32 = *((void *)a3 + 2);
  long long v29 = *a5;
  uint64_t v30 = *((void *)a5 + 2);
  int v8 = sub_1000E0484(a1, (uint64_t)&v31, a4);
  if (!v8)
  {
    v24[0] = 0;
    LODWORD(__p) = 0;
    wireless_diagnostics::google::protobuf::io::CodedInputStream::GetDirectBufferPointer(a2, (const void **)v24, (int *)&__p);
    LODWORD(__p) = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(a2);
    if ((__p & 0x80000000) == 0)
    {
      unsigned int v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      unsigned int v13 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v12, v13);
      uint64_t v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      int v15 = v24[0];
      LODWORD(v12) = __p;
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v14, (int)__p);
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v14, v15, (int)v12);
    }
    return 1;
  }
  int v9 = v8;
  if (v8 == 3) {
    return 0;
  }
  if (v8 == 1) {
    return 1;
  }
  std::string __p = 0;
  unsigned int v27 = 0;
  uint64_t v28 = 0;
  sub_100009298(v25, (uint64_t)&__p);
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v24, (wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v25);
  uint64_t v10 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = v24;
  while (1)
  {
    int v11 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(a2);
    if (v11 < 1) {
      break;
    }
    long long v22 = *a5;
    uint64_t v23 = *((void *)a5 + 2);
    if ((sub_1000E04E8(a2, (uint64_t)&v22, a1) & 1) == 0) {
      goto LABEL_13;
    }
  }
  int v9 = 0;
  --*(void *)(a1 + 168);
  *(void *)(a1 + 48) = v10;
LABEL_13:
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v24);
  wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v25);
  if (v11 > 0 || v9 == 3)
  {
    uint64_t v16 = 0;
  }
  else
  {
    if (!v9)
    {
      int v17 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      unsigned int v18 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v17, v18);
      int v19 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      uint64_t v20 = __p;
      LODWORD(v17) = v27 - __p;
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v19, v27 - (unsigned char *)__p);
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v19, v20, (int)v17);
    }
    uint64_t v16 = 1;
  }
  if (__p)
  {
    unsigned int v27 = __p;
    operator delete(__p);
  }
  return v16;
}

void sub_1000DFBBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DFC00(uint64_t a1, unint64_t a2, uint64_t a3, int a4, unsigned int a5)
{
  uint64_t v7 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) != ((v7 - **(void **)(a1 + 176)) >> 2) - 1 || *(_DWORD *)(v7 - 4) != a4)
  {
    if (a5 == 5)
    {
      int v8 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      unsigned int v9 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v8, v9);
      int v15 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      int WireTypeForType = wis::reflect::getWireTypeForType();
      if (WireTypeForType != 5)
      {
        unint64_t v11 = a2;
        if (WireTypeForType != 1)
        {
          if (WireTypeForType) {
            return 1;
          }
          unsigned int v12 = v15;
LABEL_15:
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v12, v11);
          return 1;
        }
        int v17 = v15;
LABEL_19:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v17, v11);
        return 1;
      }
    }
    else
    {
      if (a5 > 1) {
        return 1;
      }
      unsigned int v13 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      unsigned int v14 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v13, v14);
      int v15 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      int v16 = wis::reflect::getWireTypeForType();
      if (v16 != 5)
      {
        if (v16 != 1)
        {
          if (v16) {
            return 1;
          }
          unsigned int v12 = v15;
          unint64_t v11 = a2;
          goto LABEL_15;
        }
        int v17 = v15;
        unint64_t v11 = a2;
        goto LABEL_19;
      }
    }
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v15, a2);
    return 1;
  }
  *(unsigned char *)(a1 + 160) = 1;
  return 1;
}

uint64_t sub_1000DFD58(uint64_t a1, const void *a2, unint64_t a3, uint64_t a4, int a5)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v8 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v8 - 4) == a5)
  {
    *(unsigned char *)(a1 + 160) = 1;
  }
  else
  {
    unsigned int v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    unsigned int v10 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
    unint64_t v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, a3);
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v11, a2, a3);
  }
  return 1;
}

uint64_t sub_1000DFDFC(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v8 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v8 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
  }
  else
  {
    unsigned int v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v10 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
    unint64_t v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v12 = sub_10003B200(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v11, v12);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v11, v12);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v12);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000DFEEC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v5 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v5 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
  }
  else
  {
    uint64_t v6 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v7 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v6, v7);
    uint64_t v8 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v9 = wis::protobuf::NumberConverter<(wis::reflect::Type)1>::encode();
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v8, v9);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v8, v9);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v8, v9);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000DFFD8(uint64_t a1, unsigned int *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v8 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v8 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
  }
  else
  {
    uint64_t v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v10 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
    unint64_t v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v12 = sub_10003B350(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v11, v12);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v11, v12);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v12);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000E00C8(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v5 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v5 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
  }
  else
  {
    uint64_t v6 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v7 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v6, v7);
    uint64_t v8 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v9 = wis::protobuf::NumberConverter<(wis::reflect::Type)2>::encode();
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v8, v9);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v8, v9);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v8, v9);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000E01B4(uint64_t a1, unsigned __int8 *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v8 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v8 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
  }
  else
  {
    uint64_t v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v10 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
    unint64_t v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v12 = sub_10003B49C(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v11, v12);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v11, v12);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v12);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000E02A4(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v8 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v8 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
  }
  else
  {
    uint64_t v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v10 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
    unint64_t v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v12 = sub_10003B5D4(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v11, v12);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v11, v12);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v12);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000E0394(uint64_t a1, unsigned int *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v8 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v8 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
  }
  else
  {
    uint64_t v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v10 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
    unint64_t v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v12 = sub_10003B724(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v11, v12);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v11, v12);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v12);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000E0484(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v3 = *(void *)(a1 + 168);
  uint64_t v4 = **(void **)(a1 + 176);
  uint64_t v5 = *(void *)(*(void *)(a1 + 176) + 8);
  unint64_t v6 = (v5 - v4) >> 2;
  if (v3 == v6 - 1 && *(_DWORD *)(v5 - 4) == a3)
  {
    uint64_t v7 = 1;
    *(unsigned char *)(a1 + 160) = 1;
  }
  else if (v3 < v6 && *(_DWORD *)(v4 + 4 * v3) == a3)
  {
    *(void *)(a1 + 168) = v3 + 1;
    return 2;
  }
  else
  {
    return 0;
  }
  return v7;
}

uint64_t sub_1000E04E8(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = (unsigned __int8 *)*((void *)this + 1);
  if ((unint64_t)v7 >= *((void *)this + 2) || (char)*v7 < 0)
  {
    unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = TagFallback;
    if (TagFallback) {
      goto LABEL_4;
    }
LABEL_10:
    if (*((unsigned char *)this + 36))
    {
LABEL_49:
      char v3 = 1;
      return v3 & 1;
    }
LABEL_11:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
LABEL_111:
  }
  unint64_t TagFallback = *v7;
  *((_DWORD *)this + 8) = TagFallback;
  *((void *)this + 1) = v7 + 1;
  if (!TagFallback) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v9 = wis::reflect::decodeTag((wis::reflect *)TagFallback, a2);
  char v10 = v9;
  unsigned int v75 = HIDWORD(v9);
  MetricFileMetadataHelper::getSubfieldType();
  *(_OWORD *)uint64_t v76 = v73;
  int v77 = v74;
  int BuiltinType = MetadataHelper::getBuiltinType();
  int v72 = BuiltinType;
  int DecodingType = wis::reflect::getDecodingType();
  switch(DecodingType)
  {
    case 0:
      switch(v10)
      {
        case 0:
          *(void *)uint64_t v76 = 0;
          if (!sub_100038330(this, (unint64_t *)v76)) {
            goto LABEL_47;
          }
          unint64_t v32 = *(void *)v76;
          long long v57 = *(_OWORD *)a2;
          uint64_t v58 = *(void *)(a2 + 16);
          int v33 = v75;
          uint64_t v34 = &v57;
          uint64_t v35 = a3;
          unsigned int v36 = 0;
          goto LABEL_108;
        case 1:
          *(void *)uint64_t v76 = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v76))goto LABEL_47; {
          unint64_t v32 = *(void *)v76;
          }
          long long v53 = *(_OWORD *)a2;
          uint64_t v54 = *(void *)(a2 + 16);
          int v33 = v75;
          uint64_t v34 = &v53;
          uint64_t v35 = a3;
          unsigned int v36 = 1;
          goto LABEL_108;
        case 2:
          v68[0] = 0;
          if ((sub_100038360(this, v68) & 1) == 0) {
            goto LABEL_47;
          }
          sub_10003908C(v76, v68[0]);
          char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v76, v68[0]);
          if ((Raw & 1) == 0) {
            goto LABEL_96;
          }
          long long v51 = *(_OWORD *)a2;
          uint64_t v52 = *(void *)(a2 + 16);
          char v48 = sub_1000DFD58(a3, *(const void **)v76, *(void *)&v76[2] - *(void *)v76, (uint64_t)&v51, v75);
          goto LABEL_95;
        case 5:
          v76[0] = 0;
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v76))goto LABEL_47; {
          int v33 = v75;
          }
          unint64_t v32 = v76[0];
          long long v55 = *(_OWORD *)a2;
          uint64_t v56 = *(void *)(a2 + 16);
          uint64_t v34 = &v55;
          uint64_t v35 = a3;
          unsigned int v36 = 5;
LABEL_108:
          char v42 = sub_1000DFC00(v35, v32, (uint64_t)v34, v33, v36);
          goto LABEL_77;
        default:
          goto LABEL_47;
      }
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      *(void *)uint64_t v76 = 0;
      switch(v10)
      {
        case 0:
          unsigned int v13 = (char *)*((void *)this + 1);
          if ((unint64_t)v13 < *((void *)this + 2) && (*v13 & 0x80000000) == 0)
          {
            *(void *)uint64_t v76 = *v13;
            *((void *)this + 1) = v13 + 1;
            goto LABEL_76;
          }
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, (unint64_t *)v76))goto LABEL_76; {
          if (!v75 && *((unsigned char *)this + 36))
          }
            goto LABEL_49;
LABEL_57:
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        case 1:
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v76))goto LABEL_76; {
          if (v75 || !*((unsigned char *)this + 36))
          }
            goto LABEL_57;
          goto LABEL_49;
        case 2:
          if (v75 || !*((unsigned char *)this + 36)) {
            goto LABEL_11;
          }
          goto LABEL_49;
        case 5:
          v68[0] = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v68))
          {
            *(void *)uint64_t v76 = v68[0];
LABEL_76:
            char v42 = sub_1000E0EA4(BuiltinType, *(uint64_t *)v76, a3, (long long *)a2, (int *)&v75, &v72);
LABEL_77:
            char v3 = v42;
            return v3 & 1;
          }
          if (!v75 && *((unsigned char *)this + 36)) {
            goto LABEL_49;
          }
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        default:
          goto LABEL_76;
      }
      goto LABEL_111;
    case 13:
      v68[0] = 0;
      uint64_t v37 = (char *)*((void *)this + 1);
      if ((unint64_t)v37 >= *((void *)this + 2) || *v37 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v68))goto LABEL_47; {
      }
        }
      else
      {
        v68[0] = *v37;
        *((void *)this + 1) = v37 + 1;
      }
      memset(v76, 0, sizeof(v76));
      int v77 = 0;
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
      if (Raw)
      {
        long long v65 = *(_OWORD *)a2;
        uint64_t v66 = *(void *)(a2 + 16);
        char v3 = sub_1000DF848(a3, v76, (uint64_t)&v65, v75);
      }
      if ((SHIBYTE(v77) & 0x80000000) == 0) {
        goto LABEL_99;
      }
      long long v44 = *(void **)v76;
      goto LABEL_98;
    case 14:
      v68[0] = 0;
      long long v40 = (char *)*((void *)this + 1);
      if ((unint64_t)v40 >= *((void *)this + 2) || *v40 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v68))goto LABEL_47; {
        unsigned int v41 = v68[0];
        }
      }
      else
      {
        unsigned int v41 = *v40;
        v68[0] = v41;
        *((void *)this + 1) = v40 + 1;
      }
      sub_10003908C(v76, v41);
      char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v76, v68[0]);
      if (Raw)
      {
        long long v63 = *(_OWORD *)a2;
        uint64_t v64 = *(void *)(a2 + 16);
        char v48 = sub_1000DF900(a3, (uint64_t)v76, (uint64_t)&v63, v75);
LABEL_95:
        char v3 = v48;
      }
LABEL_96:
      long long v44 = *(void **)v76;
      if (*(void *)v76)
      {
        *(void *)&unsigned int v76[2] = *(void *)v76;
LABEL_98:
        operator delete(v44);
      }
LABEL_99:
      if (Raw) {
        return v3 & 1;
      }
      goto LABEL_47;
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      unsigned int v71 = 0;
      int v15 = (unsigned __int8 *)*((void *)this + 1);
      if ((unint64_t)v15 >= *((void *)this + 2) || (char)*v15 < 0)
      {
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v71)) {
          goto LABEL_16;
        }
LABEL_47:
        if (!v75 && *((unsigned char *)this + 36)) {
          goto LABEL_49;
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Parsing failed in metric");
        goto LABEL_111;
      }
      unsigned int v71 = *v15;
      *((void *)this + 1) = v15 + 1;
LABEL_16:
      uint64_t v49 = a2;
      uint64_t v50 = a3;
      int UnpackedType = wis::reflect::getUnpackedType();
      int WireTypeForType = wis::reflect::getWireTypeForType();
      *(void *)CFStringRef v68 = this;
      int v69 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v71);
      memset(v76, 0, sizeof(v76));
      int v77 = 0;
      while (1)
      {
        int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
        if (v17 < 1) {
          break;
        }
        unsigned int v18 = *(char **)&v76[2];
        if (*(void *)&v76[2] >= (unint64_t)v77)
        {
          uint64_t v20 = *(char **)v76;
          uint64_t v21 = (uint64_t)(*(void *)&v76[2] - *(void *)v76) >> 3;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 61) {
            sub_10002B5E0();
          }
          uint64_t v23 = (uint64_t)&v77[-*(void *)v76];
          if ((uint64_t)&v77[-*(void *)v76] >> 2 > v22) {
            unint64_t v22 = v23 >> 2;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24)
          {
            uint64_t v25 = (char *)sub_100038500((uint64_t)&v77, v24);
            uint64_t v20 = *(char **)v76;
            unsigned int v18 = *(char **)&v76[2];
          }
          else
          {
            uint64_t v25 = 0;
          }
          long long v26 = &v25[8 * v21];
          *(void *)long long v26 = 0;
          int v19 = v26 + 8;
          while (v18 != v20)
          {
            uint64_t v27 = *((void *)v18 - 1);
            v18 -= 8;
            *((void *)v26 - 1) = v27;
            v26 -= 8;
          }
          *(void *)uint64_t v76 = v26;
          *(void *)&unsigned int v76[2] = v19;
          int v77 = &v25[8 * v24];
          if (v20) {
            operator delete(v20);
          }
        }
        else
        {
          **(void **)&unsigned int v76[2] = 0;
          int v19 = v18 + 8;
        }
        *(void *)&unsigned int v76[2] = v19;
        switch(WireTypeForType)
        {
          case 0:
            uint64_t v28 = v19 - 1;
            long long v29 = (char *)*((void *)this + 1);
            if ((unint64_t)v29 >= *((void *)this + 2) || *v29 < 0)
            {
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v28);
LABEL_41:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_44;
              }
            }
            else
            {
              unint64_t *v28 = *v29;
              *((void *)this + 1) = v29 + 1;
            }
            break;
          case 1:
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, v19 - 1);
            goto LABEL_41;
          case 2:
            goto LABEL_44;
          case 5:
            unsigned int v67 = 0;
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v67);
            *(void *)(*(void *)&v76[2] - 8) = v67;
            goto LABEL_41;
          default:
            continue;
        }
      }
      char v3 = sub_1000E1200(DecodingType, (uint64_t *)v76, v50, v49, &v75, &UnpackedType);
LABEL_44:
      if (*(void *)v76)
      {
        *(void *)&unsigned int v76[2] = *(void *)v76;
        operator delete(*(void **)v76);
      }
      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(*(wireless_diagnostics::google::protobuf::io::CodedInputStream **)v68, v69);
      if (v17 > 0) {
        goto LABEL_47;
      }
      return v3 & 1;
    case 27:
      unsigned int v71 = 0;
      long long v38 = (char *)*((void *)this + 1);
      if ((unint64_t)v38 >= *((void *)this + 2) || *v38 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v71))goto LABEL_47; {
        unsigned int v39 = v71;
        }
      }
      else
      {
        unsigned int v39 = *v38;
        unsigned int v71 = v39;
        *((void *)this + 1) = v38 + 1;
      }
      *(void *)uint64_t v76 = this;
      unsigned int v76[2] = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v39);
      ++*((_DWORD *)this + 14);
      *(void *)CFStringRef v68 = this;
      long long v61 = *(_OWORD *)a2;
      uint64_t v62 = *(void *)(a2 + 16);
      long long v59 = v73;
      uint64_t v60 = v74;
      char v3 = sub_1000DF9A8(a3, this, &v61, v75, &v59);
      sub_1000E1840((wireless_diagnostics::google::protobuf::io::CodedInputStream **)v68);
      int v45 = *((_DWORD *)this + 14);
      BOOL v46 = __OFSUB__(v45, 1);
      int v47 = v45 - 1;
      if (v47 < 0 == v46) {
        *((_DWORD *)this + 14) = v47;
      }
      sub_100039058((uint64_t)v76);
      return v3 & 1;
    default:
      goto LABEL_47;
  }
}

void sub_1000E0D3C(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 - 112);
  if (v3)
  {
    *(void *)(v1 - 104) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E0EA4(int a1, uint64_t a2, uint64_t a3, long long *a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 1:
    case 15:
      wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
      uint64_t v50 = v10;
      long long v46 = *a4;
      uint64_t v47 = *((void *)a4 + 2);
      return sub_1000DFEEC(a3, (uint64_t)&v50, (uint64_t)&v46, *a5);
    case 2:
    case 16:
      wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
      LODWORD(v50) = v12;
      long long v42 = *a4;
      uint64_t v43 = *((void *)a4 + 2);
      return sub_1000E00C8(a3, (uint64_t)&v50, (uint64_t)&v42, *a5);
    case 3:
    case 17:
      uint64_t v50 = a2;
      long long v38 = *a4;
      uint64_t v39 = *((void *)a4 + 2);
      int v13 = *a5;
      int v14 = *a6;
      int v15 = &v38;
      goto LABEL_16;
    case 4:
    case 18:
      uint64_t v50 = a2;
      long long v34 = *a4;
      uint64_t v35 = *((void *)a4 + 2);
      int v16 = *a5;
      int v17 = *a6;
      unsigned int v18 = &v34;
      goto LABEL_14;
    case 5:
    case 19:
      uint64_t v50 = wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
      long long v36 = *a4;
      uint64_t v37 = *((void *)a4 + 2);
      int v13 = *a5;
      int v14 = *a6;
      int v15 = &v36;
      goto LABEL_16;
    case 6:
    case 20:
      LODWORD(v50) = a2;
      long long v32 = *a4;
      uint64_t v33 = *((void *)a4 + 2);
      int v19 = *a5;
      int v20 = *a6;
      uint64_t v21 = &v32;
      goto LABEL_10;
    case 7:
    case 21:
      LODWORD(v50) = a2;
      long long v28 = *a4;
      uint64_t v29 = *((void *)a4 + 2);
      int v22 = *a5;
      int v23 = *a6;
      unint64_t v24 = &v28;
      goto LABEL_12;
    case 8:
    case 22:
      LODWORD(v50) = wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
      long long v30 = *a4;
      uint64_t v31 = *((void *)a4 + 2);
      int v19 = *a5;
      int v20 = *a6;
      uint64_t v21 = &v30;
LABEL_10:
      uint64_t result = sub_1000E0394(a3, (unsigned int *)&v50, (uint64_t)v21, v19, v20);
      break;
    case 9:
    case 23:
      LODWORD(v50) = a2;
      long long v44 = *a4;
      uint64_t v45 = *((void *)a4 + 2);
      int v22 = *a5;
      int v23 = *a6;
      unint64_t v24 = &v44;
LABEL_12:
      uint64_t result = sub_1000DFFD8(a3, (unsigned int *)&v50, (uint64_t)v24, v22, v23);
      break;
    case 10:
    case 24:
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      uint64_t v50 = a2;
      int v16 = *a5;
      int v17 = *a6;
      unsigned int v18 = &v48;
LABEL_14:
      uint64_t result = sub_1000DFDFC(a3, &v50, (uint64_t)v18, v16, v17);
      break;
    case 11:
    case 25:
      uint64_t v50 = a2;
      long long v26 = *a4;
      uint64_t v27 = *((void *)a4 + 2);
      int v13 = *a5;
      int v14 = *a6;
      int v15 = &v26;
LABEL_16:
      uint64_t result = sub_1000E02A4(a3, &v50, (uint64_t)v15, v13, v14);
      break;
    case 12:
    case 26:
      LOBYTE(v50) = a2 != 0;
      long long v40 = *a4;
      uint64_t v41 = *((void *)a4 + 2);
      uint64_t result = sub_1000E01B4(a3, (unsigned __int8 *)&v50, (uint64_t)&v40, *a5, *a6);
      break;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
  return result;
}

void sub_1000E1184(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E1200(int a1, uint64_t *a2, uint64_t a3, uint64_t a4, _DWORD *a5, int *a6)
{
  switch(a1)
  {
    case 15:
      sub_1000385BC(a2, __p);
      int v9 = *a6;
      uint64_t v10 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v10 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v10 - 4) == *a5) {
        goto LABEL_34;
      }
      unint64_t v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v12 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v11, v12);
      sub_10003C2D0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v9, (uint64_t *)__p);
      goto LABEL_39;
    case 16:
      sub_1000386C8(a2, __p);
      int v13 = *a6;
      uint64_t v14 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v14 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v14 - 4) == *a5) {
        goto LABEL_34;
      }
      int v15 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v16 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v15, v16);
      sub_10003D7B4(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v13, (uint64_t *)__p);
      goto LABEL_39;
    case 17:
      sub_100038538(a2, __p);
      int v17 = *a6;
      uint64_t v18 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v18 - **(void **)(a3 + 176)) >> 2) - 1 || *(_DWORD *)(v18 - 4) != *a5) {
        goto LABEL_38;
      }
      goto LABEL_34;
    case 18:
      sub_100038538(a2, __p);
      int v19 = *a6;
      uint64_t v20 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v20 - **(void **)(a3 + 176)) >> 2) - 1 || *(_DWORD *)(v20 - 4) != *a5) {
        goto LABEL_13;
      }
      goto LABEL_34;
    case 19:
      sub_1000387D4(a2, __p);
      int v17 = *a6;
      uint64_t v23 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v23 - **(void **)(a3 + 176)) >> 2) - 1 || *(_DWORD *)(v23 - 4) != *a5) {
        goto LABEL_38;
      }
      goto LABEL_34;
    case 20:
      sub_100038644(a2, __p);
      int v24 = *a6;
      uint64_t v25 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v25 - **(void **)(a3 + 176)) >> 2) - 1 || *(_DWORD *)(v25 - 4) != *a5) {
        goto LABEL_19;
      }
      goto LABEL_34;
    case 21:
      sub_100038644(a2, __p);
      int v28 = *a6;
      uint64_t v29 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) != ((v29 - **(void **)(a3 + 176)) >> 2) - 1 || *(_DWORD *)(v29 - 4) != *a5) {
        goto LABEL_22;
      }
      goto LABEL_34;
    case 22:
      sub_10003885C(a2, __p);
      int v24 = *a6;
      uint64_t v32 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v32 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v32 - 4) == *a5) {
        goto LABEL_34;
      }
LABEL_19:
      long long v26 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v27 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v26, v27);
      sub_10003F9B0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v24, (uint64_t *)__p);
      goto LABEL_39;
    case 23:
      sub_100038644(a2, __p);
      int v28 = *a6;
      uint64_t v33 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v33 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v33 - 4) == *a5) {
        goto LABEL_34;
      }
LABEL_22:
      long long v30 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v31 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v30, v31);
      sub_10003CD54(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v28, (uint64_t *)__p);
      goto LABEL_39;
    case 24:
      sub_100038538(a2, __p);
      int v19 = *a6;
      uint64_t v34 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v34 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v34 - 4) == *a5) {
        goto LABEL_34;
      }
LABEL_13:
      uint64_t v21 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
      unsigned int v22 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v21, v22);
      sub_10003B870(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v19, (uint64_t *)__p);
      goto LABEL_39;
    case 25:
      sub_100038538(a2, __p);
      int v17 = *a6;
      uint64_t v35 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v35 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v35 - 4) == *a5)
      {
LABEL_34:
        *(unsigned char *)(a3 + 160) = 1;
      }
      else
      {
LABEL_38:
        long long v38 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v39 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v38, v39);
        sub_10003EF50(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v17, (uint64_t *)__p);
      }
LABEL_39:
      long long v40 = __p[0];
      if (!__p[0]) {
        return 1;
      }
      __p[1] = __p[0];
LABEL_41:
      operator delete(v40);
      return 1;
    case 26:
      sub_100038750((uint64_t)a2, __p);
      int v36 = *a6;
      uint64_t v37 = *(void *)(*(void *)(a3 + 176) + 8);
      if (*(void *)(a3 + 168) == ((v37 - **(void **)(a3 + 176)) >> 2) - 1 && *(_DWORD *)(v37 - 4) == *a5)
      {
        *(unsigned char *)(a3 + 160) = 1;
      }
      else
      {
        long long v42 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v43 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v42, v43);
        sub_10003E238(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v36, (uint64_t *)__p);
      }
      long long v40 = __p[0];
      if (!__p[0]) {
        return 1;
      }
      goto LABEL_41;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
}

void sub_1000E17AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  __cxa_free_exception(v11);
  _Unwind_Resume(a1);
}

wireless_diagnostics::google::protobuf::io::CodedInputStream **sub_1000E1840(wireless_diagnostics::google::protobuf::io::CodedInputStream **a1)
{
  int v2 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(*a1);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip(*a1, v2);
  return a1;
}

wireless_diagnostics::google::protobuf::io::CodedInputStream **sub_1000E187C(wireless_diagnostics::google::protobuf::io::CodedInputStream **a1)
{
  int v2 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(*a1);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip(*a1, v2);
  return a1;
}

void *sub_1000E18B8(void *a1)
{
  *a1 = off_1001BC298;
  int v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1000E1908(void *a1)
{
  *a1 = off_1001BC298;
  int v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }

  operator delete();
}

void *sub_1000E1978(uint64_t a1)
{
  int v2 = operator new(0x28uLL);
  void *v2 = off_1001BC298;
  v2[2] = 0;
  v2[3] = 0;
  v2[1] = 0;
  sub_10001E158(v2 + 1, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2);
  *((_DWORD *)v2 + 8) = *(_DWORD *)(a1 + 32);
  return v2;
}

void sub_1000E19E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000E19F8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1001BC298;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t result = sub_10001E158((void *)(a2 + 8), *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 32);
  return result;
}

void sub_1000E1A5C(uint64_t a1)
{
  int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void sub_1000E1A74(void *__p)
{
  int v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

uint64_t sub_1000E1AB8(uint64_t a1, void *a2)
{
  uint64_t v23 = 0;
  int v24 = 0;
  uint64_t v25 = 0;
  int v2 = (uint64_t *)a2[1];
  if (!v2) {
    int v2 = *(uint64_t **)(*a2 + 8);
  }
  uint64_t v3 = *v2;
  uint64_t v4 = v2[1] - *v2;
  v14[0] = 0;
  v14[1] = v3;
  _OWORD v14[2] = v3 + (int)v4;
  int v15 = v4;
  uint64_t v16 = 0;
  __int16 v17 = 0;
  long long v19 = xmmword_100174830;
  int v18 = v4;
  int v20 = wireless_diagnostics::google::protobuf::io::CodedInputStream::default_recursion_limit_;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  int v5 = *(_DWORD *)(a1 + 32);
  sub_1000E25CC((uint64_t)v9, (uint64_t)(a2 + 2), (uint64_t)&v23, a1 + 8);
  int v13 = v5;
  v8[0] = 0;
  v8[1] = 0;
  v8[2] = 0xFFFFFFFFLL;
  sub_1000E1C94((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v14, (uint64_t)v8, (uint64_t)v9);
  uint64_t v6 = v12[64];
  sub_100038238((uint64_t)v12);
  if (v11) {
    sub_10000B678(v11);
  }
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)&v10);
  wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v9);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v14);
  if (v23)
  {
    int v24 = v23;
    operator delete(v23);
  }
  return v6;
}

void sub_1000E1BC8(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  uint64_t v18 = va_arg(va2, void);
  long long v19 = va_arg(va2, std::__shared_weak_count *);
  uint64_t v20 = va_arg(va2, void);
  uint64_t v21 = va_arg(va2, void);
  uint64_t v22 = va_arg(va2, void);
  sub_100038238((uint64_t)va2);
  if (v19) {
    sub_10000B678(v19);
  }
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)va1);
  wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)va);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream((wireless_diagnostics::google::protobuf::io::CodedInputStream *)(v5 - 136));
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1000E1BA0);
  }
  uint64_t v8 = *(void **)(v5 - 56);
  if (v8)
  {
    *(void *)(v5 - 48) = v8;
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000E1C48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1000E1C88()
{
}

uint64_t sub_1000E1C94(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = (unsigned __int8 *)*((void *)this + 1);
  if ((unint64_t)v7 >= *((void *)this + 2) || (char)*v7 < 0)
  {
    unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = TagFallback;
    if (TagFallback) {
      goto LABEL_4;
    }
LABEL_10:
    if (*((unsigned char *)this + 36))
    {
LABEL_49:
      char v3 = 1;
      return v3 & 1;
    }
LABEL_11:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
LABEL_110:
  }
  unint64_t TagFallback = *v7;
  *((_DWORD *)this + 8) = TagFallback;
  *((void *)this + 1) = v7 + 1;
  if (!TagFallback) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v9 = wis::reflect::decodeTag((wis::reflect *)TagFallback, a2);
  char v10 = v9;
  v68[0] = HIDWORD(v9);
  long long v64 = *(_OWORD *)a2;
  uint64_t v65 = *(void *)(a2 + 16);
  MetricFileMetadataHelper::getSubfieldType();
  long long v61 = v66;
  uint64_t v62 = v67;
  int BuiltinType = MetadataHelper::getBuiltinType();
  int v63 = BuiltinType;
  int DecodingType = wis::reflect::getDecodingType();
  switch(DecodingType)
  {
    case 0:
      switch(v10)
      {
        case 0:
          std::string __p = 0;
          if (sub_100038330(this, (unint64_t *)&__p)) {
            goto LABEL_49;
          }
          goto LABEL_47;
        case 1:
          std::string __p = 0;
          if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)&__p) & 1) == 0)goto LABEL_49; {
          goto LABEL_47;
          }
        case 2:
          LODWORD(v57) = 0;
          if (sub_100038360(this, (unsigned int *)&v57))
          {
            sub_10003908C(&__p, v57);
            char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, __p, (int)v57);
            if (__p)
            {
              long long v55 = (char *)__p;
              operator delete(__p);
            }
            if (Raw) {
              goto LABEL_49;
            }
          }
          goto LABEL_47;
        case 5:
          LODWORD(__p) = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, (unsigned int *)&__p))goto LABEL_49; {
          goto LABEL_47;
          }
        default:
          goto LABEL_47;
      }
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      std::string __p = 0;
      switch(v10)
      {
        case 0:
          int v13 = (char *)*((void *)this + 1);
          if ((unint64_t)v13 < *((void *)this + 2) && (*v13 & 0x80000000) == 0)
          {
            std::string __p = (void *)*v13;
            *((void *)this + 1) = v13 + 1;
LABEL_76:
            char v3 = sub_1000E2654(BuiltinType, (uint64_t)__p, a3, a2, v68, &v63);
            return v3 & 1;
          }
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, (unint64_t *)&__p))goto LABEL_76; {
          if (!v68[0] && *((unsigned char *)this + 36))
          }
            goto LABEL_49;
LABEL_57:
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        case 1:
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)&__p))goto LABEL_76; {
          if (v68[0] || !*((unsigned char *)this + 36))
          }
            goto LABEL_57;
          goto LABEL_49;
        case 2:
          if (v68[0] || !*((unsigned char *)this + 36)) {
            goto LABEL_11;
          }
          goto LABEL_49;
        case 5:
          LODWORD(v57) = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, (unsigned int *)&v57))
          {
            std::string __p = (void *)v57;
            goto LABEL_76;
          }
          if (!v68[0] && *((unsigned char *)this + 36)) {
            goto LABEL_49;
          }
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        default:
          goto LABEL_76;
      }
      goto LABEL_110;
    case 13:
      LODWORD(v57) = 0;
      uint64_t v32 = (char *)*((void *)this + 1);
      if ((unint64_t)v32 >= *((void *)this + 2) || *v32 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, (unsigned int *)&v57))goto LABEL_47; {
      }
        }
      else
      {
        LODWORD(v57) = *v32;
        *((void *)this + 1) = v32 + 1;
      }
      std::string __p = 0;
      long long v55 = 0;
      uint64_t v56 = 0;
      char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
      if (String)
      {
        long long v51 = *(_OWORD *)a2;
        uint64_t v52 = *(void *)(a2 + 16);
        char v3 = sub_1000E30B4(a3, (uint64_t)&__p, &v51, v68[0]);
      }
      if ((SHIBYTE(v56) & 0x80000000) == 0) {
        goto LABEL_97;
      }
      long long v38 = __p;
      goto LABEL_96;
    case 14:
      LODWORD(v57) = 0;
      uint64_t v35 = (char *)*((void *)this + 1);
      if ((unint64_t)v35 >= *((void *)this + 2) || *v35 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, (unsigned int *)&v57))goto LABEL_47; {
        unsigned int v36 = v57;
        }
      }
      else
      {
        unsigned int v36 = *v35;
        LODWORD(v57) = v36;
        *((void *)this + 1) = v35 + 1;
      }
      sub_10003908C(&__p, v36);
      char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, __p, (int)v57);
      if (String)
      {
        long long v49 = *(_OWORD *)a2;
        uint64_t v50 = *(void *)(a2 + 16);
        char v3 = sub_1000E3170(a3, (const void **)&__p, &v49, v68[0]);
      }
      long long v38 = __p;
      if (__p)
      {
        long long v55 = (char *)__p;
LABEL_96:
        operator delete(v38);
      }
LABEL_97:
      if (String) {
        return v3 & 1;
      }
      goto LABEL_47;
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      unsigned int v60 = 0;
      uint64_t v15 = (unsigned __int8 *)*((void *)this + 1);
      if ((unint64_t)v15 >= *((void *)this + 2) || (char)*v15 < 0)
      {
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v60)) {
          goto LABEL_16;
        }
LABEL_47:
        if (!v68[0] && *((unsigned char *)this + 36)) {
          goto LABEL_49;
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Parsing failed in metric");
        goto LABEL_110;
      }
      unsigned int v60 = *v15;
      *((void *)this + 1) = v15 + 1;
LABEL_16:
      unsigned int v43 = (long long *)a2;
      uint64_t v44 = a3;
      int UnpackedType = wis::reflect::getUnpackedType();
      int WireTypeForType = wis::reflect::getWireTypeForType();
      long long v57 = this;
      int v58 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v60);
      std::string __p = 0;
      long long v55 = 0;
      uint64_t v56 = 0;
      while (1)
      {
        int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
        if (v17 < 1) {
          break;
        }
        uint64_t v18 = v55;
        if (v55 >= v56)
        {
          uint64_t v20 = (char *)__p;
          uint64_t v21 = (v55 - (unsigned char *)__p) >> 3;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 61) {
            sub_10002B5E0();
          }
          uint64_t v23 = v56 - (unsigned char *)__p;
          if ((v56 - (unsigned char *)__p) >> 2 > v22) {
            unint64_t v22 = v23 >> 2;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24)
          {
            uint64_t v25 = (char *)sub_100038500((uint64_t)&v56, v24);
            uint64_t v20 = (char *)__p;
            uint64_t v18 = v55;
          }
          else
          {
            uint64_t v25 = 0;
          }
          long long v26 = &v25[8 * v21];
          *(void *)long long v26 = 0;
          long long v19 = v26 + 8;
          while (v18 != v20)
          {
            uint64_t v27 = *((void *)v18 - 1);
            v18 -= 8;
            *((void *)v26 - 1) = v27;
            v26 -= 8;
          }
          std::string __p = v26;
          long long v55 = v19;
          uint64_t v56 = &v25[8 * v24];
          if (v20) {
            operator delete(v20);
          }
        }
        else
        {
          *(void *)long long v55 = 0;
          long long v19 = v18 + 8;
        }
        long long v55 = v19;
        switch(WireTypeForType)
        {
          case 0:
            int v28 = (unint64_t *)(v19 - 8);
            uint64_t v29 = (char *)*((void *)this + 1);
            if ((unint64_t)v29 >= *((void *)this + 2) || *v29 < 0)
            {
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v28);
LABEL_41:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_44;
              }
            }
            else
            {
              unint64_t *v28 = *v29;
              *((void *)this + 1) = v29 + 1;
            }
            break;
          case 1:
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v19 - 1);
            goto LABEL_41;
          case 2:
            goto LABEL_44;
          case 5:
            unsigned int v53 = 0;
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v53);
            *((void *)v55 - 1) = v53;
            goto LABEL_41;
          default:
            continue;
        }
      }
      char v3 = sub_1000E29B0(DecodingType, (uint64_t *)&__p, v44, v43, v68, &UnpackedType);
LABEL_44:
      if (__p)
      {
        long long v55 = (char *)__p;
        operator delete(__p);
      }
      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(v57, v58);
      if (v17 > 0) {
        goto LABEL_47;
      }
      return v3 & 1;
    case 27:
      unsigned int v60 = 0;
      uint64_t v33 = (char *)*((void *)this + 1);
      if ((unint64_t)v33 >= *((void *)this + 2) || *v33 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v60))goto LABEL_47; {
        unsigned int v34 = v60;
        }
      }
      else
      {
        unsigned int v34 = *v33;
        unsigned int v60 = v34;
        *((void *)this + 1) = v33 + 1;
      }
      std::string __p = this;
      LODWORD(v55) = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v34);
      ++*((_DWORD *)this + 14);
      long long v57 = this;
      long long v47 = *(_OWORD *)a2;
      uint64_t v48 = *(void *)(a2 + 16);
      long long v45 = v66;
      uint64_t v46 = v67;
      char v3 = sub_1000E321C(a3, this, &v47, v68[0], &v45);
      sub_1000E555C(&v57);
      int v39 = *((_DWORD *)this + 14);
      BOOL v40 = __OFSUB__(v39, 1);
      int v41 = v39 - 1;
      if (v41 < 0 == v40) {
        *((_DWORD *)this + 14) = v41;
      }
      sub_100039058((uint64_t)&__p);
      return v3 & 1;
    default:
      goto LABEL_47;
  }
}

void sub_1000E2464(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E25CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)(sub_100009298((void *)a1, a3) + 2);
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::CodedOutputStream(v6, (wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)a1);
  *(void *)(a1 + 48) = v6;
  MetricFileMetadataHelper::MetricFileMetadataHelper();
  *(unsigned char *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = a4;
  return a1;
}

void sub_1000E2630(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream(v2);
  wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E2654(int a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 1:
    case 15:
      wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
      uint64_t v50 = v10;
      long long v46 = *(_OWORD *)a4;
      uint64_t v47 = *(void *)(a4 + 16);
      return sub_1000E3564(a3, (uint64_t)&v50, &v46, *a5);
    case 2:
    case 16:
      wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
      LODWORD(v50) = v12;
      long long v42 = *(_OWORD *)a4;
      uint64_t v43 = *(void *)(a4 + 16);
      return sub_1000E3740(a3, (uint64_t)&v50, &v42, *a5);
    case 3:
    case 17:
      uint64_t v50 = a2;
      long long v38 = *(_OWORD *)a4;
      uint64_t v39 = *(void *)(a4 + 16);
      int v13 = *a5;
      int v14 = *a6;
      uint64_t v15 = &v38;
      goto LABEL_16;
    case 4:
    case 18:
      uint64_t v50 = a2;
      long long v34 = *(_OWORD *)a4;
      uint64_t v35 = *(void *)(a4 + 16);
      int v16 = *a5;
      int v17 = *a6;
      uint64_t v18 = &v34;
      goto LABEL_14;
    case 5:
    case 19:
      uint64_t v50 = wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
      long long v36 = *(_OWORD *)a4;
      uint64_t v37 = *(void *)(a4 + 16);
      int v13 = *a5;
      int v14 = *a6;
      uint64_t v15 = &v36;
      goto LABEL_16;
    case 6:
    case 20:
      LODWORD(v50) = a2;
      long long v32 = *(_OWORD *)a4;
      uint64_t v33 = *(void *)(a4 + 16);
      int v19 = *a5;
      int v20 = *a6;
      uint64_t v21 = &v32;
      goto LABEL_10;
    case 7:
    case 21:
      LODWORD(v50) = a2;
      long long v28 = *(_OWORD *)a4;
      uint64_t v29 = *(void *)(a4 + 16);
      int v22 = *a5;
      int v23 = *a6;
      unint64_t v24 = &v28;
      goto LABEL_12;
    case 8:
    case 22:
      LODWORD(v50) = wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
      long long v30 = *(_OWORD *)a4;
      uint64_t v31 = *(void *)(a4 + 16);
      int v19 = *a5;
      int v20 = *a6;
      uint64_t v21 = &v30;
LABEL_10:
      uint64_t result = sub_1000E3A0C(a3, (unsigned int *)&v50, v21, v19, v20);
      break;
    case 9:
    case 23:
      LODWORD(v50) = a2;
      long long v44 = *(_OWORD *)a4;
      uint64_t v45 = *(void *)(a4 + 16);
      int v22 = *a5;
      int v23 = *a6;
      unint64_t v24 = &v44;
LABEL_12:
      uint64_t result = sub_1000E3650(a3, (unsigned int *)&v50, v24, v22, v23);
      break;
    case 10:
    case 24:
      long long v48 = *(_OWORD *)a4;
      uint64_t v49 = *(void *)(a4 + 16);
      uint64_t v50 = a2;
      int v16 = *a5;
      int v17 = *a6;
      uint64_t v18 = &v48;
LABEL_14:
      uint64_t result = sub_1000E3474(a3, &v50, v18, v16, v17);
      break;
    case 11:
    case 25:
      uint64_t v50 = a2;
      long long v26 = *(_OWORD *)a4;
      uint64_t v27 = *(void *)(a4 + 16);
      int v13 = *a5;
      int v14 = *a6;
      uint64_t v15 = &v26;
LABEL_16:
      uint64_t result = sub_1000E391C(a3, &v50, v15, v13, v14);
      break;
    case 12:
    case 26:
      LOBYTE(v50) = a2 != 0;
      long long v40 = *(_OWORD *)a4;
      uint64_t v41 = *(void *)(a4 + 16);
      uint64_t result = sub_1000E382C(a3, (unsigned __int8 *)&v50, &v40, *a5, *a6);
      break;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
  return result;
}

void sub_1000E2934(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E29B0(int a1, uint64_t *a2, uint64_t a3, long long *a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 15:
      sub_1000385BC(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v10 = *a6;
      int v11 = sub_1000E3E00(a3, __p, (uint64_t)&v48, *a5);
      if (v11 == 3) {
        goto LABEL_36;
      }
      if (!v11)
      {
        int v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v13 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v12, v13);
        sub_10003C2D0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v10, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 16:
      sub_1000386C8(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v14 = *a6;
      int v15 = sub_1000E3EF4(a3, __p, (uint64_t)&v48, *a5);
      if (v15 == 3) {
        goto LABEL_36;
      }
      if (!v15)
      {
        int v16 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v17 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v16, v17);
        sub_10003D7B4(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v14, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 17:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v18 = *a6;
      int v19 = sub_1000E3D88(a3, __p, (uint64_t)&v48, *a5);
      if (v19 == 3) {
        goto LABEL_36;
      }
      if (!v19) {
        goto LABEL_34;
      }
      goto LABEL_35;
    case 18:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v20 = *a6;
      int v21 = sub_1000E3D88(a3, __p, (uint64_t)&v48, *a5);
      if (v21 == 3) {
        goto LABEL_36;
      }
      if (!v21) {
        goto LABEL_13;
      }
      goto LABEL_35;
    case 19:
      sub_1000387D4(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v18 = *a6;
      int v24 = sub_1000E3D88(a3, __p, (uint64_t)&v48, *a5);
      if (v24 == 3) {
        goto LABEL_36;
      }
      if (!v24) {
        goto LABEL_34;
      }
      goto LABEL_35;
    case 20:
      sub_100038644(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v25 = *a6;
      int v26 = sub_1000E4028(a3, __p, (uint64_t)&v48, *a5);
      if (v26 == 3) {
        goto LABEL_36;
      }
      if (!v26) {
        goto LABEL_19;
      }
      goto LABEL_35;
    case 21:
      sub_100038644(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v29 = *a6;
      int v30 = sub_1000E3E7C(a3, __p, (uint64_t)&v48, *a5);
      if (v30 == 3) {
        goto LABEL_36;
      }
      if (!v30) {
        goto LABEL_22;
      }
      goto LABEL_35;
    case 22:
      sub_10003885C(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v25 = *a6;
      int v33 = sub_1000E4028(a3, __p, (uint64_t)&v48, *a5);
      if (v33 == 3) {
        goto LABEL_36;
      }
      if (!v33)
      {
LABEL_19:
        uint64_t v27 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v28 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v27, v28);
        sub_10003F9B0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v25, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 23:
      sub_100038644(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v29 = *a6;
      int v34 = sub_1000E3E7C(a3, __p, (uint64_t)&v48, *a5);
      if (v34 == 3) {
        goto LABEL_36;
      }
      if (!v34)
      {
LABEL_22:
        uint64_t v31 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v32 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v31, v32);
        sub_10003CD54(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v29, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 24:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v20 = *a6;
      int v35 = sub_1000E3D88(a3, __p, (uint64_t)&v48, *a5);
      if (v35 == 3) {
        goto LABEL_36;
      }
      if (!v35)
      {
LABEL_13:
        int v22 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v23 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v22, v23);
        sub_10003B870(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v20, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 25:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v18 = *a6;
      int v36 = sub_1000E3D88(a3, __p, (uint64_t)&v48, *a5);
      if (v36 == 3)
      {
LABEL_36:
        uint64_t v39 = 0;
      }
      else
      {
        if (!v36)
        {
LABEL_34:
          uint64_t v37 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v38 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v37, v38);
          sub_10003EF50(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v18, (uint64_t *)__p);
        }
LABEL_35:
        uint64_t v39 = 1;
      }
      long long v40 = __p[0];
      if (__p[0])
      {
        __p[1] = __p[0];
LABEL_39:
        operator delete(v40);
      }
      return v39;
    case 26:
      sub_100038750((uint64_t)a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v42 = *a6;
      int v43 = sub_1000E3F70(a3, (uint64_t)__p, (uint64_t)&v48, *a5);
      if (v43 == 3)
      {
        uint64_t v39 = 0;
      }
      else
      {
        if (!v43)
        {
          long long v44 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v45 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v44, v45);
          sub_10003E238(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v42, (uint64_t *)__p);
        }
        uint64_t v39 = 1;
      }
      long long v40 = __p[0];
      if (!__p[0]) {
        return v39;
      }
      goto LABEL_39;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
}

void sub_1000E3020(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  __cxa_free_exception(v11);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E30B4(uint64_t a1, uint64_t a2, long long *a3, int a4)
{
  uint64_t v4 = (void *)a2;
  long long v13 = *a3;
  uint64_t v14 = *((void *)a3 + 2);
  int v6 = sub_1000E40A0(a1, a2, (uint64_t)&v13, a4);
  if (v6 == 3) {
    return 0;
  }
  if (!v6)
  {
    uint64_t v7 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    unsigned int v8 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v7, v8);
    uint64_t v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    unint64_t v10 = v4[1];
    if (*((char *)v4 + 23) >= 0)
    {
      unint64_t v11 = *((unsigned __int8 *)v4 + 23);
    }
    else
    {
      uint64_t v4 = (void *)*v4;
      unint64_t v11 = v10;
    }
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v9, v11);
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v9, v4, v11);
  }
  return 1;
}

uint64_t sub_1000E3170(uint64_t a1, const void **a2, long long *a3, int a4)
{
  long long v13 = *a3;
  uint64_t v14 = *((void *)a3 + 2);
  int v6 = sub_1000E40A0(a1, (uint64_t)a2, (uint64_t)&v13, a4);
  if (v6 == 3) {
    return 0;
  }
  if (!v6)
  {
    uint64_t v7 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    unsigned int v8 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v7, v8);
    uint64_t v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    unint64_t v10 = *a2;
    unint64_t v11 = (unsigned char *)a2[1] - (unsigned char *)*a2;
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v9, v11);
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v9, v10, v11);
  }
  return 1;
}

uint64_t sub_1000E321C(uint64_t a1, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, long long *a3, int a4, long long *a5)
{
  long long v31 = *a3;
  uint64_t v32 = *((void *)a3 + 2);
  long long v29 = *a5;
  uint64_t v30 = *((void *)a5 + 2);
  int v8 = sub_1000E40FC(a1, (uint64_t)&v31, a4);
  if (!v8)
  {
    v24[0] = 0;
    LODWORD(__p) = 0;
    wireless_diagnostics::google::protobuf::io::CodedInputStream::GetDirectBufferPointer(a2, (const void **)v24, (int *)&__p);
    LODWORD(__p) = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(a2);
    if ((__p & 0x80000000) == 0)
    {
      int v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      unsigned int v13 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v12, v13);
      uint64_t v14 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      int v15 = v24[0];
      LODWORD(v12) = __p;
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v14, (int)__p);
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v14, v15, (int)v12);
    }
    return 1;
  }
  int v9 = v8;
  if (v8 == 3) {
    return 0;
  }
  if (v8 == 1) {
    return 1;
  }
  std::string __p = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  sub_100009298(v25, (uint64_t)&__p);
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v24, (wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v25);
  uint64_t v10 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = v24;
  while (1)
  {
    int v11 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(a2);
    if (v11 < 1) {
      break;
    }
    long long v22 = *a5;
    uint64_t v23 = *((void *)a5 + 2);
    if ((sub_1000E4188(a2, (uint64_t)&v22, a1) & 1) == 0) {
      goto LABEL_13;
    }
  }
  int v9 = 0;
  --*(void *)(a1 + 168);
  *(void *)(a1 + 48) = v10;
LABEL_13:
  wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v24);
  wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream((wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *)v25);
  if (v11 > 0 || v9 == 3)
  {
    uint64_t v16 = 0;
  }
  else
  {
    if (!v9)
    {
      unsigned int v17 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      unsigned int v18 = wis::reflect::encodeTag();
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v17, v18);
      int v19 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
      int v20 = __p;
      LODWORD(v17) = v27 - __p;
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v19, v27 - (unsigned char *)__p);
      wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw(v19, v20, (int)v17);
    }
    uint64_t v16 = 1;
  }
  if (__p)
  {
    uint64_t v27 = __p;
    operator delete(__p);
  }
  return v16;
}

void sub_1000E3430(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E3474(uint64_t a1, uint64_t *a2, long long *a3, int a4, int a5)
{
  long long v15 = *a3;
  uint64_t v16 = *((void *)a3 + 2);
  int v8 = sub_1000E3AFC(a1, (uint64_t)a2, (uint64_t)&v15, a4);
  if (v8 == 3) {
    return 0;
  }
  if (!v8)
  {
    int v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v10 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
    int v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v12 = sub_10003B200(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v11, v12);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v11, v12);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v12);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000E3564(uint64_t a1, uint64_t a2, long long *a3, int a4)
{
  long long v12 = *a3;
  uint64_t v13 = *((void *)a3 + 2);
  int v5 = sub_1000E3C48(a1, a2, (uint64_t)&v12, a4);
  if (v5 == 3) {
    return 0;
  }
  if (!v5)
  {
    int v6 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v7 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v6, v7);
    int v8 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v9 = wis::protobuf::NumberConverter<(wis::reflect::Type)1>::encode();
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v8, v9);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v8, v9);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v8, v9);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000E3650(uint64_t a1, unsigned int *a2, long long *a3, int a4, int a5)
{
  long long v15 = *a3;
  uint64_t v16 = *((void *)a3 + 2);
  int v8 = sub_1000E3C98(a1, (uint64_t)a2, (uint64_t)&v15, a4);
  if (v8 == 3) {
    return 0;
  }
  if (!v8)
  {
    uint64_t v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v10 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
    int v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v12 = sub_10003B350(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v11, v12);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v11, v12);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v12);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000E3740(uint64_t a1, uint64_t a2, long long *a3, int a4)
{
  long long v12 = *a3;
  uint64_t v13 = *((void *)a3 + 2);
  int v5 = sub_1000E3C48(a1, a2, (uint64_t)&v12, a4);
  if (v5 == 3) {
    return 0;
  }
  if (!v5)
  {
    int v6 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v7 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v6, v7);
    int v8 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v9 = wis::protobuf::NumberConverter<(wis::reflect::Type)2>::encode();
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v8, v9);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v8, v9);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v8, v9);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000E382C(uint64_t a1, unsigned __int8 *a2, long long *a3, int a4, int a5)
{
  long long v15 = *a3;
  uint64_t v16 = *((void *)a3 + 2);
  int v8 = sub_1000E3CE8(a1, (uint64_t)a2, (uint64_t)&v15, a4);
  if (v8 == 3) {
    return 0;
  }
  if (!v8)
  {
    uint64_t v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v10 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
    int v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v12 = sub_10003B49C(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v11, v12);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v11, v12);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v12);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000E391C(uint64_t a1, uint64_t *a2, long long *a3, int a4, int a5)
{
  long long v15 = *a3;
  uint64_t v16 = *((void *)a3 + 2);
  int v8 = sub_1000E3AFC(a1, (uint64_t)a2, (uint64_t)&v15, a4);
  if (v8 == 3) {
    return 0;
  }
  if (!v8)
  {
    uint64_t v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v10 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
    int v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v12 = sub_10003B5D4(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v11, v12);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v11, v12);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v12);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000E3A0C(uint64_t a1, unsigned int *a2, long long *a3, int a4, int a5)
{
  long long v15 = *a3;
  uint64_t v16 = *((void *)a3 + 2);
  int v8 = sub_1000E3D38(a1, (uint64_t)a2, (uint64_t)&v15, a4);
  if (v8 == 3) {
    return 0;
  }
  if (!v8)
  {
    uint64_t v9 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    wis::reflect::getWireTypeForType();
    unsigned int v10 = wis::reflect::encodeTag();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v9, v10);
    int v11 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 48);
    uint64_t v12 = sub_10003B724(a5, *a2);
    int WireTypeForType = wis::reflect::getWireTypeForType();
    switch(WireTypeForType)
    {
      case 5:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32(v11, v12);
        break;
      case 1:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian64(v11, v12);
        break;
      case 0:
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64(v11, v12);
        break;
    }
  }
  return 1;
}

uint64_t sub_1000E3AFC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v4 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v4 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
    sub_1000E3B4C();
  }
  return 1;
}

void sub_1000E3B4C()
{
  pthread_mutex_lock(&stru_1001D69C0);
  uint64_t v0 = (void *)xmmword_1001D6A00;
  if (!(void)xmmword_1001D6A00) {
    sub_1000781CC();
  }
  if (*((void *)&xmmword_1001D6A00 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6A00 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_1001D69C0);
  sub_1000A5F78(v0);
}

void sub_1000E3C14(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E3C48(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v4 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v4 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
    sub_1000E3B4C();
  }
  return 1;
}

uint64_t sub_1000E3C98(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v4 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v4 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
    sub_1000E3B4C();
  }
  return 1;
}

uint64_t sub_1000E3CE8(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v4 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v4 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
    sub_1000E3B4C();
  }
  return 1;
}

uint64_t sub_1000E3D38(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v4 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v4 - 4) == a4)
  {
    *(unsigned char *)(a1 + 160) = 1;
    sub_1000E3B4C();
  }
  return 1;
}

uint64_t sub_1000E3D88(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v4 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v4 - 4) == a4)
  {
    if (*a2 != a2[1]) {
      sub_1000E3B4C();
    }
    *(unsigned char *)(a1 + 160) = 1;
  }
  return 1;
}

uint64_t sub_1000E3E00(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v4 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v4 - 4) == a4)
  {
    if (*a2 != a2[1]) {
      sub_1000E3B4C();
    }
    *(unsigned char *)(a1 + 160) = 1;
  }
  return 1;
}

uint64_t sub_1000E3E7C(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v4 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v4 - 4) == a4)
  {
    if (*a2 != a2[1]) {
      sub_1000E3B4C();
    }
    *(unsigned char *)(a1 + 160) = 1;
  }
  return 1;
}

uint64_t sub_1000E3EF4(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v4 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v4 - 4) == a4)
  {
    if (*a2 != a2[1]) {
      sub_1000E3B4C();
    }
    *(unsigned char *)(a1 + 160) = 1;
  }
  return 1;
}

uint64_t sub_1000E3F70(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v4 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v4 - 4) == a4)
  {
    if (*(void *)(a2 + 8) > 0x3FuLL || (*(_DWORD *)(a2 + 8) & 0x3F) != 0) {
      sub_1000E3B4C();
    }
    *(unsigned char *)(a1 + 160) = 1;
  }
  return 1;
}

uint64_t sub_1000E4028(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v4 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v4 - 4) == a4)
  {
    if (*a2 != a2[1]) {
      sub_1000E3B4C();
    }
    *(unsigned char *)(a1 + 160) = 1;
  }
  return 1;
}

uint64_t sub_1000E40A0(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 176) + 8);
  if (*(void *)(a1 + 168) == ((v4 - **(void **)(a1 + 176)) >> 2) - 1 && *(_DWORD *)(v4 - 4) == a4) {
    sub_1000E3B4C();
  }
  return 1;
}

uint64_t sub_1000E40FC(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v3 = *(void *)(a1 + 168);
  uint64_t v4 = **(void **)(a1 + 176);
  uint64_t v5 = *(void *)(*(void *)(a1 + 176) + 8);
  unint64_t v6 = (v5 - v4) >> 2;
  if (v3 == v6 - 1 && *(_DWORD *)(v5 - 4) == a3) {
    sub_1000E3B4C();
  }
  if (v3 >= v6 || *(_DWORD *)(v4 + 4 * v3) != a3) {
    return 0;
  }
  *(void *)(a1 + 168) = v3 + 1;
  return 2;
}

uint64_t sub_1000E4188(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a2, uint64_t a3)
{
  unsigned int v7 = (unsigned __int8 *)*((void *)this + 1);
  if ((unint64_t)v7 >= *((void *)this + 2) || (char)*v7 < 0)
  {
    unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = TagFallback;
    if (TagFallback) {
      goto LABEL_4;
    }
LABEL_10:
    if (*((unsigned char *)this + 36))
    {
LABEL_49:
      char v3 = 1;
      return v3 & 1;
    }
LABEL_11:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
LABEL_110:
  }
  unint64_t TagFallback = *v7;
  *((_DWORD *)this + 8) = TagFallback;
  *((void *)this + 1) = v7 + 1;
  if (!TagFallback) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v9 = wis::reflect::decodeTag((wis::reflect *)TagFallback, a2);
  char v10 = v9;
  unsigned int v61 = HIDWORD(v9);
  MetricFileMetadataHelper::getSubfieldType();
  *(_OWORD *)uint64_t v62 = v59;
  int v63 = v60;
  int BuiltinType = MetadataHelper::getBuiltinType();
  int v58 = BuiltinType;
  int DecodingType = wis::reflect::getDecodingType();
  switch(DecodingType)
  {
    case 0:
      switch(v10)
      {
        case 0:
          *(void *)uint64_t v62 = 0;
          if (sub_100038330(this, (unint64_t *)v62)) {
            goto LABEL_49;
          }
          goto LABEL_47;
        case 1:
          *(void *)uint64_t v62 = 0;
          if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v62) & 1) == 0)goto LABEL_49; {
          goto LABEL_47;
          }
        case 2:
          LODWORD(v54) = 0;
          if (sub_100038360(this, (unsigned int *)&v54))
          {
            sub_10003908C(v62, v54);
            char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v62, (int)v54);
            if (*(void *)v62)
            {
              *(void *)&v62[2] = *(void *)v62;
              operator delete(*(void **)v62);
            }
            if (Raw) {
              goto LABEL_49;
            }
          }
          goto LABEL_47;
        case 5:
          v62[0] = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v62)) {
            goto LABEL_49;
          }
          goto LABEL_47;
        default:
          goto LABEL_47;
      }
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      *(void *)uint64_t v62 = 0;
      switch(v10)
      {
        case 0:
          uint64_t v13 = (char *)*((void *)this + 1);
          if ((unint64_t)v13 < *((void *)this + 2) && (*v13 & 0x80000000) == 0)
          {
            *(void *)uint64_t v62 = *v13;
            *((void *)this + 1) = v13 + 1;
LABEL_76:
            char v3 = sub_1000E4AC0(BuiltinType, *(uint64_t *)v62, a3, a2, (int *)&v61, &v58);
            return v3 & 1;
          }
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, (unint64_t *)v62))goto LABEL_76; {
          if (!v61 && *((unsigned char *)this + 36))
          }
            goto LABEL_49;
LABEL_57:
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        case 1:
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v62))goto LABEL_76; {
          if (v61 || !*((unsigned char *)this + 36))
          }
            goto LABEL_57;
          goto LABEL_49;
        case 2:
          if (v61 || !*((unsigned char *)this + 36)) {
            goto LABEL_11;
          }
          goto LABEL_49;
        case 5:
          LODWORD(v54) = 0;
          if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, (unsigned int *)&v54))
          {
            *(void *)uint64_t v62 = v54;
            goto LABEL_76;
          }
          if (!v61 && *((unsigned char *)this + 36)) {
            goto LABEL_49;
          }
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Parsing failed in metric");
          break;
        default:
          goto LABEL_76;
      }
      goto LABEL_110;
    case 13:
      LODWORD(v54) = 0;
      uint64_t v32 = (char *)*((void *)this + 1);
      if ((unint64_t)v32 >= *((void *)this + 2) || *v32 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, (unsigned int *)&v54))goto LABEL_47; {
      }
        }
      else
      {
        LODWORD(v54) = *v32;
        *((void *)this + 1) = v32 + 1;
      }
      memset(v62, 0, sizeof(v62));
      int v63 = 0;
      char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
      if (String)
      {
        long long v51 = *(_OWORD *)a2;
        uint64_t v52 = *(void *)(a2 + 16);
        char v3 = sub_1000E30B4(a3, (uint64_t)v62, &v51, v61);
      }
      if ((SHIBYTE(v63) & 0x80000000) == 0) {
        goto LABEL_97;
      }
      unsigned int v38 = *(void **)v62;
      goto LABEL_96;
    case 14:
      LODWORD(v54) = 0;
      int v35 = (char *)*((void *)this + 1);
      if ((unint64_t)v35 >= *((void *)this + 2) || *v35 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, (unsigned int *)&v54))goto LABEL_47; {
        unsigned int v36 = v54;
        }
      }
      else
      {
        unsigned int v36 = *v35;
        LODWORD(v54) = v36;
        *((void *)this + 1) = v35 + 1;
      }
      sub_10003908C(v62, v36);
      char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw(this, *(void **)v62, (int)v54);
      if (String)
      {
        long long v49 = *(_OWORD *)a2;
        uint64_t v50 = *(void *)(a2 + 16);
        char v3 = sub_1000E3170(a3, (const void **)v62, &v49, v61);
      }
      unsigned int v38 = *(void **)v62;
      if (*(void *)v62)
      {
        *(void *)&v62[2] = *(void *)v62;
LABEL_96:
        operator delete(v38);
      }
LABEL_97:
      if (String) {
        return v3 & 1;
      }
      goto LABEL_47;
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      unsigned int v57 = 0;
      long long v15 = (unsigned __int8 *)*((void *)this + 1);
      if ((unint64_t)v15 >= *((void *)this + 2) || (char)*v15 < 0)
      {
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v57)) {
          goto LABEL_16;
        }
LABEL_47:
        if (!v61 && *((unsigned char *)this + 36)) {
          goto LABEL_49;
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Parsing failed in metric");
        goto LABEL_110;
      }
      unsigned int v57 = *v15;
      *((void *)this + 1) = v15 + 1;
LABEL_16:
      int v43 = (long long *)a2;
      uint64_t v44 = a3;
      int UnpackedType = wis::reflect::getUnpackedType();
      int WireTypeForType = wis::reflect::getWireTypeForType();
      uint64_t v54 = this;
      int v55 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v57);
      memset(v62, 0, sizeof(v62));
      int v63 = 0;
      while (1)
      {
        int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this);
        if (v17 < 1) {
          break;
        }
        unsigned int v18 = *(char **)&v62[2];
        if (*(void *)&v62[2] >= (unint64_t)v63)
        {
          int v20 = *(char **)v62;
          uint64_t v21 = (uint64_t)(*(void *)&v62[2] - *(void *)v62) >> 3;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 61) {
            sub_10002B5E0();
          }
          uint64_t v23 = (uint64_t)&v63[-*(void *)v62];
          if ((uint64_t)&v63[-*(void *)v62] >> 2 > v22) {
            unint64_t v22 = v23 >> 2;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24)
          {
            int v25 = (char *)sub_100038500((uint64_t)&v63, v24);
            int v20 = *(char **)v62;
            unsigned int v18 = *(char **)&v62[2];
          }
          else
          {
            int v25 = 0;
          }
          int v26 = &v25[8 * v21];
          *(void *)int v26 = 0;
          int v19 = v26 + 8;
          while (v18 != v20)
          {
            uint64_t v27 = *((void *)v18 - 1);
            v18 -= 8;
            *((void *)v26 - 1) = v27;
            v26 -= 8;
          }
          *(void *)uint64_t v62 = v26;
          *(void *)&v62[2] = v19;
          int v63 = &v25[8 * v24];
          if (v20) {
            operator delete(v20);
          }
        }
        else
        {
          **(void **)&v62[2] = 0;
          int v19 = v18 + 8;
        }
        *(void *)&v62[2] = v19;
        switch(WireTypeForType)
        {
          case 0:
            uint64_t v28 = v19 - 1;
            long long v29 = (char *)*((void *)this + 1);
            if ((unint64_t)v29 >= *((void *)this + 2) || *v29 < 0)
            {
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v28);
LABEL_41:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_44;
              }
            }
            else
            {
              unint64_t *v28 = *v29;
              *((void *)this + 1) = v29 + 1;
            }
            break;
          case 1:
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, v19 - 1);
            goto LABEL_41;
          case 2:
            goto LABEL_44;
          case 5:
            unsigned int v53 = 0;
            char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v53);
            *(void *)(*(void *)&v62[2] - 8) = v53;
            goto LABEL_41;
          default:
            continue;
        }
      }
      char v3 = sub_1000E4E1C(DecodingType, (uint64_t *)v62, v44, v43, (int *)&v61, &UnpackedType);
LABEL_44:
      if (*(void *)v62)
      {
        *(void *)&v62[2] = *(void *)v62;
        operator delete(*(void **)v62);
      }
      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(v54, v55);
      if (v17 > 0) {
        goto LABEL_47;
      }
      return v3 & 1;
    case 27:
      unsigned int v57 = 0;
      int v33 = (char *)*((void *)this + 1);
      if ((unint64_t)v33 >= *((void *)this + 2) || *v33 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v57))goto LABEL_47; {
        unsigned int v34 = v57;
        }
      }
      else
      {
        unsigned int v34 = *v33;
        unsigned int v57 = v34;
        *((void *)this + 1) = v33 + 1;
      }
      *(void *)uint64_t v62 = this;
      v62[2] = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v34);
      ++*((_DWORD *)this + 14);
      uint64_t v54 = this;
      long long v47 = *(_OWORD *)a2;
      uint64_t v48 = *(void *)(a2 + 16);
      long long v45 = v59;
      long long v46 = v60;
      char v3 = sub_1000E321C(a3, this, &v47, v61, &v45);
      sub_1000E5520(&v54);
      int v39 = *((_DWORD *)this + 14);
      BOOL v40 = __OFSUB__(v39, 1);
      int v41 = v39 - 1;
      if (v41 < 0 == v40) {
        *((_DWORD *)this + 14) = v41;
      }
      sub_100039058((uint64_t)v62);
      return v3 & 1;
    default:
      goto LABEL_47;
  }
}

void sub_1000E4958(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  long long v29 = *(void **)(v27 - 112);
  if (v29)
  {
    *(void *)(v27 - 104) = v29;
    operator delete(v29);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E4AC0(int a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 1:
    case 15:
      wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
      uint64_t v50 = v10;
      long long v46 = *(_OWORD *)a4;
      uint64_t v47 = *(void *)(a4 + 16);
      return sub_1000E3564(a3, (uint64_t)&v50, &v46, *a5);
    case 2:
    case 16:
      wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
      LODWORD(v50) = v12;
      long long v42 = *(_OWORD *)a4;
      uint64_t v43 = *(void *)(a4 + 16);
      return sub_1000E3740(a3, (uint64_t)&v50, &v42, *a5);
    case 3:
    case 17:
      uint64_t v50 = a2;
      long long v38 = *(_OWORD *)a4;
      uint64_t v39 = *(void *)(a4 + 16);
      int v13 = *a5;
      int v14 = *a6;
      long long v15 = &v38;
      goto LABEL_16;
    case 4:
    case 18:
      uint64_t v50 = a2;
      long long v34 = *(_OWORD *)a4;
      uint64_t v35 = *(void *)(a4 + 16);
      int v16 = *a5;
      int v17 = *a6;
      unsigned int v18 = &v34;
      goto LABEL_14;
    case 5:
    case 19:
      uint64_t v50 = wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
      long long v36 = *(_OWORD *)a4;
      uint64_t v37 = *(void *)(a4 + 16);
      int v13 = *a5;
      int v14 = *a6;
      long long v15 = &v36;
      goto LABEL_16;
    case 6:
    case 20:
      LODWORD(v50) = a2;
      long long v32 = *(_OWORD *)a4;
      uint64_t v33 = *(void *)(a4 + 16);
      int v19 = *a5;
      int v20 = *a6;
      uint64_t v21 = &v32;
      goto LABEL_10;
    case 7:
    case 21:
      LODWORD(v50) = a2;
      long long v28 = *(_OWORD *)a4;
      uint64_t v29 = *(void *)(a4 + 16);
      int v22 = *a5;
      int v23 = *a6;
      unint64_t v24 = &v28;
      goto LABEL_12;
    case 8:
    case 22:
      LODWORD(v50) = wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
      long long v30 = *(_OWORD *)a4;
      uint64_t v31 = *(void *)(a4 + 16);
      int v19 = *a5;
      int v20 = *a6;
      uint64_t v21 = &v30;
LABEL_10:
      uint64_t result = sub_1000E3A0C(a3, (unsigned int *)&v50, v21, v19, v20);
      break;
    case 9:
    case 23:
      LODWORD(v50) = a2;
      long long v44 = *(_OWORD *)a4;
      uint64_t v45 = *(void *)(a4 + 16);
      int v22 = *a5;
      int v23 = *a6;
      unint64_t v24 = &v44;
LABEL_12:
      uint64_t result = sub_1000E3650(a3, (unsigned int *)&v50, v24, v22, v23);
      break;
    case 10:
    case 24:
      long long v48 = *(_OWORD *)a4;
      uint64_t v49 = *(void *)(a4 + 16);
      uint64_t v50 = a2;
      int v16 = *a5;
      int v17 = *a6;
      unsigned int v18 = &v48;
LABEL_14:
      uint64_t result = sub_1000E3474(a3, &v50, v18, v16, v17);
      break;
    case 11:
    case 25:
      uint64_t v50 = a2;
      long long v26 = *(_OWORD *)a4;
      uint64_t v27 = *(void *)(a4 + 16);
      int v13 = *a5;
      int v14 = *a6;
      long long v15 = &v26;
LABEL_16:
      uint64_t result = sub_1000E391C(a3, &v50, v15, v13, v14);
      break;
    case 12:
    case 26:
      LOBYTE(v50) = a2 != 0;
      long long v40 = *(_OWORD *)a4;
      uint64_t v41 = *(void *)(a4 + 16);
      uint64_t result = sub_1000E382C(a3, (unsigned __int8 *)&v50, &v40, *a5, *a6);
      break;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
  return result;
}

void sub_1000E4DA0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E4E1C(int a1, uint64_t *a2, uint64_t a3, long long *a4, int *a5, int *a6)
{
  switch(a1)
  {
    case 15:
      sub_1000385BC(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v10 = *a6;
      int v11 = sub_1000E3E00(a3, __p, (uint64_t)&v48, *a5);
      if (v11 == 3) {
        goto LABEL_36;
      }
      if (!v11)
      {
        int v12 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v13 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v12, v13);
        sub_10003C2D0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v10, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 16:
      sub_1000386C8(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v14 = *a6;
      int v15 = sub_1000E3EF4(a3, __p, (uint64_t)&v48, *a5);
      if (v15 == 3) {
        goto LABEL_36;
      }
      if (!v15)
      {
        int v16 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v17 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v16, v17);
        sub_10003D7B4(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v14, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 17:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v18 = *a6;
      int v19 = sub_1000E3D88(a3, __p, (uint64_t)&v48, *a5);
      if (v19 == 3) {
        goto LABEL_36;
      }
      if (!v19) {
        goto LABEL_34;
      }
      goto LABEL_35;
    case 18:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v20 = *a6;
      int v21 = sub_1000E3D88(a3, __p, (uint64_t)&v48, *a5);
      if (v21 == 3) {
        goto LABEL_36;
      }
      if (!v21) {
        goto LABEL_13;
      }
      goto LABEL_35;
    case 19:
      sub_1000387D4(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v18 = *a6;
      int v24 = sub_1000E3D88(a3, __p, (uint64_t)&v48, *a5);
      if (v24 == 3) {
        goto LABEL_36;
      }
      if (!v24) {
        goto LABEL_34;
      }
      goto LABEL_35;
    case 20:
      sub_100038644(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v25 = *a6;
      int v26 = sub_1000E4028(a3, __p, (uint64_t)&v48, *a5);
      if (v26 == 3) {
        goto LABEL_36;
      }
      if (!v26) {
        goto LABEL_19;
      }
      goto LABEL_35;
    case 21:
      sub_100038644(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v29 = *a6;
      int v30 = sub_1000E3E7C(a3, __p, (uint64_t)&v48, *a5);
      if (v30 == 3) {
        goto LABEL_36;
      }
      if (!v30) {
        goto LABEL_22;
      }
      goto LABEL_35;
    case 22:
      sub_10003885C(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v25 = *a6;
      int v33 = sub_1000E4028(a3, __p, (uint64_t)&v48, *a5);
      if (v33 == 3) {
        goto LABEL_36;
      }
      if (!v33)
      {
LABEL_19:
        uint64_t v27 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v28 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v27, v28);
        sub_10003F9B0(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v25, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 23:
      sub_100038644(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v29 = *a6;
      int v34 = sub_1000E3E7C(a3, __p, (uint64_t)&v48, *a5);
      if (v34 == 3) {
        goto LABEL_36;
      }
      if (!v34)
      {
LABEL_22:
        uint64_t v31 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v32 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v31, v32);
        sub_10003CD54(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v29, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 24:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v20 = *a6;
      int v35 = sub_1000E3D88(a3, __p, (uint64_t)&v48, *a5);
      if (v35 == 3) {
        goto LABEL_36;
      }
      if (!v35)
      {
LABEL_13:
        int v22 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
        unsigned int v23 = wis::reflect::encodeTag();
        wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v22, v23);
        sub_10003B870(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v20, (uint64_t *)__p);
      }
      goto LABEL_35;
    case 25:
      sub_100038538(a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v18 = *a6;
      int v36 = sub_1000E3D88(a3, __p, (uint64_t)&v48, *a5);
      if (v36 == 3)
      {
LABEL_36:
        uint64_t v39 = 0;
      }
      else
      {
        if (!v36)
        {
LABEL_34:
          uint64_t v37 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v38 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v37, v38);
          sub_10003EF50(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v18, (uint64_t *)__p);
        }
LABEL_35:
        uint64_t v39 = 1;
      }
      long long v40 = __p[0];
      if (__p[0])
      {
        __p[1] = __p[0];
LABEL_39:
        operator delete(v40);
      }
      return v39;
    case 26:
      sub_100038750((uint64_t)a2, __p);
      long long v48 = *a4;
      uint64_t v49 = *((void *)a4 + 2);
      int v42 = *a6;
      int v43 = sub_1000E3F70(a3, (uint64_t)__p, (uint64_t)&v48, *a5);
      if (v43 == 3)
      {
        uint64_t v39 = 0;
      }
      else
      {
        if (!v43)
        {
          long long v44 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48);
          unsigned int v45 = wis::reflect::encodeTag();
          wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(v44, v45);
          sub_10003E238(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a3 + 48), v42, (uint64_t *)__p);
        }
        uint64_t v39 = 1;
      }
      long long v40 = __p[0];
      if (!__p[0]) {
        return v39;
      }
      goto LABEL_39;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
  }
}

void sub_1000E548C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  __cxa_free_exception(v11);
  _Unwind_Resume(a1);
}

wireless_diagnostics::google::protobuf::io::CodedInputStream **sub_1000E5520(wireless_diagnostics::google::protobuf::io::CodedInputStream **a1)
{
  int v2 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(*a1);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip(*a1, v2);
  return a1;
}

wireless_diagnostics::google::protobuf::io::CodedInputStream **sub_1000E555C(wireless_diagnostics::google::protobuf::io::CodedInputStream **a1)
{
  int v2 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(*a1);
  wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip(*a1, v2);
  return a1;
}

uint64_t sub_1000E5598()
{
  if ((byte_1001D6A10 & 1) == 0)
  {
    byte_1001D6A10 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E5C, &stru_1001D69C0, (void *)&_mh_execute_header);
  }
  return result;
}

void sub_1000E55D4(wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream *a1)
{
  wireless_diagnostics::google::protobuf::io::ZeroCopyOutputStream::~ZeroCopyOutputStream(a1);

  operator delete();
}

uint64_t sub_1000E560C(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 8) - **(void **)(a1 + 8);
}

void sub_1000E57B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000E5910(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000E5A00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000E5A40(xpc_object_t *a1, xpc_object_t *a2)
{
  uint64_t v4 = *(NSObject **)(qword_1001D8080 + 128);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "insight_config:#I Running SendTestInsightsNow.", buf, 2u);
  }
  if (xpc_get_type(*a1) == (xpc_type_t)&_xpc_type_connection && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(*a2);
    if (reply || (xpc_object_t reply = xpc_null_create()) != 0)
    {
      if (xpc_get_type(reply) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(reply);
        xpc_object_t v6 = reply;
      }
      else
      {
        xpc_object_t v6 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t reply = 0;
    }
    xpc_release(reply);
    xpc_type_t type = xpc_get_type(v6);
    int v8 = *(NSObject **)(qword_1001D8080 + 128);
    if (type == (xpc_type_t)&_xpc_type_dictionary)
    {
      if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 128), OS_LOG_TYPE_INFO))
      {
        xpc::object::to_string((uint64_t *)buf, (xpc::object *)a2);
        uint64_t v9 = v12 >= 0 ? buf : *(uint8_t **)buf;
        *(_DWORD *)unsigned int v13 = 136315138;
        *(void *)&v13[4] = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "insight_config:#I Received insight = %s", v13, 0xCu);
        if (v12 < 0) {
          operator delete(*(void **)buf);
        }
      }
      int int64 = xpc_dictionary_get_int64(*a2, "InsightId");
      if (int64 == 4353) {
        operator new();
      }
      if (int64 == 4097) {
        operator new();
      }
      if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 128), OS_LOG_TYPE_ERROR)) {
        sub_100149854();
      }
    }
    else if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 128), OS_LOG_TYPE_ERROR))
    {
      sub_100149888();
    }
    xpc_release(v6);
  }
}

void sub_1000E5E40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, void);
  pthread_mutex_unlock(&stru_1001D6BD0);
  sub_100077FDC((uint64_t *)va, 0);
  sub_100077F8C((uint64_t *)va1, 0);
  xpc_release(v3);
  _Unwind_Resume(a1);
}

void sub_1000E5F8C(xpc_object_t *a1, xpc_object_t *a2)
{
  uint64_t v4 = *(NSObject **)(qword_1001D8080 + 128);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "insight_config:#I Received SendMockCellInfo.", buf, 2u);
  }
  if (xpc_get_type(*a1) == (xpc_type_t)&_xpc_type_connection && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(*a2);
    if (reply || (xpc_object_t reply = xpc_null_create()) != 0)
    {
      if (xpc_get_type(reply) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(reply);
        xpc_object_t v6 = reply;
      }
      else
      {
        xpc_object_t v6 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t reply = 0;
    }
    xpc_release(reply);
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
    {
      size_t length = 0;
      xpc_dictionary_get_data(*a2, "Payload", &length);
      operator new();
    }
    if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 128), OS_LOG_TYPE_ERROR)) {
      sub_1001498BC();
    }
    xpc_release(v6);
  }
}

void sub_1000E61F0(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&stru_1001D67F0);
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

void sub_1000E62BC(xpc_object_t *a1, xpc_object_t *a2)
{
  uint64_t v4 = *(NSObject **)(qword_1001D8080 + 128);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "insight_config:#I Received GetConfigurationForLocation.", buf, 2u);
  }
  if (xpc_get_type(*a1) == (xpc_type_t)&_xpc_type_connection && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(*a2);
    xpc_object_t v6 = reply;
    if (reply)
    {
      xpc_object_t object = reply;
    }
    else
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t object = v6;
      if (!v6)
      {
        xpc_object_t v7 = xpc_null_create();
        xpc_object_t v6 = 0;
        goto LABEL_12;
      }
    }
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v6);
LABEL_13:
      xpc_release(v6);
      if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
      {
        pthread_mutex_lock(&stru_1001D67F0);
        int v8 = (void *)xmmword_1001D6830;
        if (!(void)xmmword_1001D6830) {
          sub_100027A48();
        }
        if (*((void *)&xmmword_1001D6830 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6830 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        pthread_mutex_unlock(&stru_1001D67F0);
        double v9 = xpc_dictionary_get_double(*a2, "latitude");
        double v10 = xpc_dictionary_get_double(*a2, "longitude");
        int v11 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
        char v12 = dispatch_queue_create("com.apple.wirelessinsightsd.insightshelpers", v11);
        unsigned int v13 = dispatch_semaphore_create(0);
        if (v12) {
          dispatch_retain(v12);
        }
        if (object)
        {
          xpc_retain(object);
          xpc_object_t v14 = object;
        }
        else
        {
          xpc_object_t v14 = xpc_null_create();
        }
        if (v13) {
          dispatch_retain(v13);
        }
        int v19 = 0;
        int v15 = operator new(0x20uLL);
        void *v15 = off_1001BC368;
        v15[1] = v12;
        v15[2] = v14;
        xpc_null_create();
        v15[3] = v13;
        int v19 = v15;
        sub_100028A48(v8, 1, (uint64_t)v18, v9, v10);
      }
      if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 128), OS_LOG_TYPE_ERROR)) {
        sub_1001498F0();
      }
      xpc_release(object);
      return;
    }
    xpc_object_t v7 = xpc_null_create();
LABEL_12:
    xpc_object_t object = v7;
    goto LABEL_13;
  }
}

void sub_1000E6688(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, xpc_object_t object, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a2) {
    sub_10001F4A8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E6768(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 16);
  if (v2) {
    dispatch_release(v2);
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  if (*(void *)a1) {
    dispatch_release(*(dispatch_object_t *)a1);
  }
  return a1;
}

uint64_t sub_1000E67B4(uint64_t a1)
{
  *(void *)a1 = off_1001BC368;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (v2) {
    dispatch_release(v2);
  }
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  char v3 = *(NSObject **)(a1 + 8);
  if (v3) {
    dispatch_release(v3);
  }
  return a1;
}

void sub_1000E681C(uint64_t a1)
{
  *(void *)a1 = off_1001BC368;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (v2) {
    dispatch_release(v2);
  }
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  char v3 = *(NSObject **)(a1 + 8);
  if (v3) {
    dispatch_release(v3);
  }

  operator delete();
}

void *sub_1000E68A4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = off_1001BC368;
  sub_1000E6AB8(v2 + 1, v1);
  return v2;
}

void *sub_1000E68F8(uint64_t a1, void *a2)
{
  *a2 = off_1001BC368;
  return sub_1000E6AB8(a2 + 1, a1 + 8);
}

void sub_1000E6924(uint64_t a1)
{
}

void sub_1000E692C(void *a1)
{
  sub_1000E6B20((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1000E6968(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t v5 = a1[1];
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 1174405120;
  v8[2] = sub_1000E6B80;
  void v8[3] = &unk_1001BC3C8;
  v8[4] = v3;
  double v9 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  xpc_object_t v6 = (void *)a1[2];
  xpc_object_t v10 = v6;
  if (v6) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t v10 = xpc_null_create();
  }
  xpc_object_t v7 = a1[3];
  dispatch_object_t object = v7;
  if (v7) {
    dispatch_retain(v7);
  }
  dispatch_async(v5, v8);
  if (object) {
    dispatch_release(object);
  }
  xpc_release(v10);
  xpc_object_t v10 = 0;
  if (v9) {
    sub_10000B678(v9);
  }
  if (v4) {
    sub_10000B678(v4);
  }
}

uint64_t sub_1000E6A6C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1000E6AAC()
{
}

void *sub_1000E6AB8(void *a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)a2;
  *a1 = *(void *)a2;
  if (v4) {
    dispatch_retain(v4);
  }
  uint64_t v5 = *(void **)(a2 + 8);
  a1[1] = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    a1[1] = xpc_null_create();
  }
  xpc_object_t v6 = *(NSObject **)(a2 + 16);
  a1[2] = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  return a1;
}

void sub_1000E6B20(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 16);
  if (v2) {
    dispatch_release(v2);
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = *(NSObject **)a1;
  if (*(void *)a1)
  {
    dispatch_release(v3);
  }
}

intptr_t sub_1000E6B80(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(qword_1001D8080 + 128);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "insight_config:#I Received config.", buf, 2u);
  }
  uint64_t v3 = *(unsigned int **)(a1 + 32);
  if (v3)
  {
    sub_10009DC94(v3, &v13);
    xpc_object_t v11 = v13;
    if (v13) {
      xpc_retain(v13);
    }
    else {
      xpc_object_t v11 = xpc_null_create();
    }
    *(void *)long long buf = a1 + 48;
    xpc_object_t v10 = "CellularCoverageConfig";
    sub_10009D480((uint64_t)buf, &v11, &v12);
    xpc_release(v12);
    xpc_object_t v12 = 0;
    xpc_release(v11);
    xpc_object_t v11 = 0;
    xpc_object_t v7 = xpc_string_create("Request Succeeded");
    if (!v7) {
      xpc_object_t v7 = xpc_null_create();
    }
    *(void *)long long buf = a1 + 48;
    xpc_object_t v10 = "Status";
    sub_100014D08((uint64_t)buf, &v7, &v8);
    xpc_release(v8);
    xpc_object_t v8 = 0;
    xpc_release(v7);
    xpc_object_t v7 = 0;
    xpc_release(v13);
  }
  else
  {
    xpc_object_t v5 = xpc_string_create("Request Failed, cellCoverageTile is nil");
    if (!v5) {
      xpc_object_t v5 = xpc_null_create();
    }
    *(void *)long long buf = a1 + 48;
    xpc_object_t v10 = "Status";
    sub_100014D08((uint64_t)buf, &v5, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v5);
    xpc_object_t v5 = 0;
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 56));
}

void sub_1000E6D3C(void *a1, void *a2)
{
  uint64_t v4 = a2[5];
  a1[4] = a2[4];
  a1[5] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  xpc_object_t v5 = (void *)a2[6];
  a1[6] = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    a1[6] = xpc_null_create();
  }
  xpc_object_t v6 = a2[7];
  a1[7] = v6;
  if (v6)
  {
    dispatch_retain(v6);
  }
}

void sub_1000E6DC0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (v2) {
    dispatch_release(v2);
  }
  xpc_release(*(xpc_object_t *)(a1 + 48));
  *(void *)(a1 + 48) = 0;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    sub_10000B678(v3);
  }
}

uint64_t sub_1000E6E20()
{
  if ((byte_1001D6C20 & 1) == 0)
  {
    byte_1001D6C20 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E74, &stru_1001D6BD0, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1000E6E5C()
{
  if ((byte_1001D6840 & 1) == 0)
  {
    byte_1001D6840 = 1;
    return __cxa_atexit((void (*)(void *))sub_100022F54, &stru_1001D67F0, (void *)&_mh_execute_header);
  }
  return result;
}

void sub_1000E6E98(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 16);
  uint64_t v2 = 0;
  if (v1)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 8);
    xpc_object_t v13 = &v3[v1];
    do
    {
      uint64_t v4 = *v3;
      uint64_t v5 = *(int *)(*v3 + 16);
      if (v5)
      {
        xpc_object_t v6 = *(uint64_t **)(v4 + 8);
        uint64_t v7 = 8 * v5;
        do
        {
          uint64_t v8 = *v6;
          if (*(int *)(*v6 + 96) >= 1)
          {
            double v9 = *(NSObject **)qword_1001D8080;
            if (os_log_type_enabled(*(os_log_t *)qword_1001D8080, OS_LOG_TYPE_INFO))
            {
              int v10 = *(_DWORD *)(v8 + 8);
              int v11 = *(_DWORD *)(v4 + 56);
              *(_DWORD *)long long buf = 67109376;
              LODWORD(v15[0]) = v10;
              WORD2(v15[0]) = 1024;
              *(_DWORD *)((char *)v15 + 6) = v11;
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "config:#I Found profile 0x%x with HW model spec in cid 0x%x", buf, 0xEu);
            }
          }
          sub_1000E702C(v8 + 88);
          ++v6;
          v7 -= 8;
        }
        while (v7);
      }
      v2 += v5;
      ++v3;
    }
    while (v3 != v13);
  }
  xpc_object_t v12 = *(NSObject **)qword_1001D8080;
  if (os_log_type_enabled(*(os_log_t *)qword_1001D8080, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 134217984;
    v15[0] = v2;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "config:#I HW model filter complete: no profiles removed; %zd total profiles",
      buf,
      0xCu);
  }
}

uint64_t sub_1000E702C(uint64_t result)
{
  if (*(int *)(result + 8) >= 1)
  {
    uint64_t v1 = 0;
    do
    {
      uint64_t v2 = *(void *)(*(void *)result + 8 * v1);
      if (*(char *)(v2 + 23) < 0)
      {
        **(unsigned char **)uint64_t v2 = 0;
        *(void *)(v2 + 8) = 0;
      }
      else
      {
        *(unsigned char *)uint64_t v2 = 0;
        *(unsigned char *)(v2 + 23) = 0;
      }
      ++v1;
    }
    while (v1 < *(int *)(result + 8));
  }
  *(_DWORD *)(result + 8) = 0;
  return result;
}

void sub_1000E707C(void *a1)
{
}

void sub_1000E7124(_Unwind_Exception *a1)
{
  sub_100043DE4(v3, 0);
  sub_100099F34(v2, 0);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 4));
  sub_100029804(v1);
  _Unwind_Resume(a1);
}

void *sub_1000E7168(void *a1, const char *a2, dispatch_qos_class_t a3, const char *a4)
{
  dispatch_object_t object = 0;
  sub_10002A670(a1, a2, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), "com.apple.wis.wirelessinsightsd", a4);
  return a1;
}

void sub_1000E71C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  sub_100029804(v10);
  _Unwind_Resume(a1);
}

void *sub_1000E71F4(uint64_t *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10000B678(v2);
  }
  sub_1000AB324(a1 + 7, 0);
  sub_100043DE4(a1 + 6, 0);
  sub_100099F34(a1 + 5, 0);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 4));

  return sub_100029804(a1);
}

uint64_t sub_1000E7264(void *a1, uint64_t a2, unint64_t a3, int a4, uint64_t a5, uint64_t **a6)
{
  unint64_t v11 = HIDWORD(a3);
  sub_1000E7610((uint64_t)a1, a2, HIDWORD(a3), (uint64_t)a6);
  xpc_object_t v12 = *a6;
  xpc_object_t v13 = a6[1];
  if (*a6 == v13)
  {
    uint64_t v14 = 0;
  }
  else
  {
    uint64_t v14 = 0;
    int v15 = *a6;
    do
    {
      uint64_t v14 = v14 + *(void *)(v15[1] + 8) - *(void *)v15[1];
      v15 += 3;
    }
    while (v15 != v13);
  }
  int v16 = a1[4];
  if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 67110144;
    *(_DWORD *)&uint8_t buf[4] = a3;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v11;
    *(_WORD *)&buf[14] = 1024;
    LODWORD(v34) = a4;
    WORD2(v34) = 2048;
    *(void *)((char *)&v34 + 6) = 0xAAAAAAAAAAAAAAABLL * (v13 - v12);
    HIWORD(v34) = 2048;
    uint64_t v35 = v14;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "submit.proc:#I Trigger(cid=0x%x, trid=0x%x, sid=%u): Processing %zd metrics with %zd bytes", buf, 0x28u);
  }
  uint64_t v17 = a1[8];
  if (v17) {
    sub_100055210(v17, a3, a4, a5, (uint64_t)a6);
  }
  *(_OWORD *)long long buf = 0u;
  long long v34 = 0u;
  LODWORD(v35) = 1065353216;
  int v19 = *a6;
  int v18 = a6[1];
  if (*a6 != v18)
  {
    do
    {
      unint64_t v32 = sub_1000AAF70(a1[7], v19);
      if ((v32 & 0xFF00000000) != 0)
      {
        *(void *)int v36 = &v32;
        int v20 = sub_1000E79A8((uint64_t)buf, (unsigned int *)&v32, (uint64_t)&unk_1001793E0, (_DWORD **)v36);
        sub_100008940(v20 + 3, (uint64_t)v19);
      }
      v19 += 3;
    }
    while (v19 != v18);
    for (uint64_t i = (uint64_t *)v34; i; uint64_t i = (uint64_t *)*i)
    {
      uint64_t v22 = *((unsigned int *)i + 4);
      if (sub_1000E77A8((uint64_t)a1, v11, *((_DWORD *)i + 4), (uint64_t)(i + 3)))
      {
        char v23 = sub_1000E7810((uint64_t)a1, v11, v22, (uint64_t)(i + 3));
        sub_1000E7878((uint64_t)a1, (int **)i + 3);
        if (v23)
        {
          (*(void (**)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 24))(a2, v11, a5, v22, i + 3);
        }
        else
        {
          unsigned int v28 = a1[4];
          if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
          {
            unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((i[4] - i[3]) >> 3);
            *(_DWORD *)int v36 = 67110144;
            *(_DWORD *)&v36[4] = a3;
            __int16 v37 = 1024;
            int v38 = v11;
            __int16 v39 = 1024;
            int v40 = a4;
            __int16 v41 = 1024;
            int v42 = v22;
            __int16 v43 = 2048;
            unint64_t v44 = v29;
            int v26 = v28;
            uint64_t v27 = "submit.proc:#I Trigger(cid=0x%x, trid=0x%x, sid=%u): [file %d] Skipping save of %zd metrics due to should-save rule";
            goto LABEL_22;
          }
        }
      }
      else
      {
        int v24 = a1[4];
        if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
        {
          unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((i[4] - i[3]) >> 3);
          *(_DWORD *)int v36 = 67110144;
          *(_DWORD *)&v36[4] = a3;
          __int16 v37 = 1024;
          int v38 = v11;
          __int16 v39 = 1024;
          int v40 = a4;
          __int16 v41 = 1024;
          int v42 = v22;
          __int16 v43 = 2048;
          unint64_t v44 = v25;
          int v26 = v24;
          uint64_t v27 = "submit.proc:#I Trigger(cid=0x%x, trid=0x%x, sid=%u): [file %d] Skipping processing of %zd metrics due to"
                " should-process rule";
LABEL_22:
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_INFO, v27, v36, 0x24u);
        }
      }
    }
  }
  return sub_1000E7C4C((uint64_t)buf);
}

void sub_1000E75F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void sub_1000E7610(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5)
  {
    sub_10009A174(v5, a3, a4, &v12);
    uint64_t v8 = v12;
    double v9 = v13;
    if (v12 != v13)
    {
      do
      {
        uint64_t v10 = *(unsigned int *)v8;
        unint64_t v11 = *(NSObject **)(a1 + 32);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 67109376;
          unsigned int v15 = a3;
          __int16 v16 = 1024;
          int v17 = v10;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "submit.proc:#I Trigger 0x%x conditions evaluated, generated trigger 0x%x", buf, 0xEu);
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, v10);
        v8 += 4;
      }
      while (v8 != v9);
      uint64_t v8 = v12;
    }
    if (v8)
    {
      xpc_object_t v13 = v8;
      operator delete(v8);
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 32), OS_LOG_TYPE_DEBUG))
  {
    sub_100149924();
  }
}

void sub_1000E7784(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t sub_1000E77A8(uint64_t a1, unsigned int a2, __int32 a3, uint64_t a4)
{
  if (*(void *)(a1 + 48))
  {
    uint64_t v4 = *(void *)(a1 + 48);
    return sub_1000441C4(v4, a2, a3, a4);
  }
  else
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 32), OS_LOG_TYPE_DEBUG)) {
      sub_100149958();
    }
    return 1;
  }
}

uint64_t sub_1000E7810(uint64_t a1, unsigned int a2, __int32 a3, uint64_t a4)
{
  if (*(void *)(a1 + 48))
  {
    uint64_t v4 = *(void *)(a1 + 48);
    return sub_100043FBC(v4, a2, a3, a4);
  }
  else
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 32), OS_LOG_TYPE_DEBUG)) {
      sub_10014998C();
    }
    return 1;
  }
}

void sub_1000E7878(uint64_t a1, int **a2)
{
  if (*(void *)(a1 + 56))
  {
    uint64_t v4 = *a2;
    uint64_t v5 = a2[1];
    if (*a2 == v5)
    {
      uint64_t v6 = 0;
    }
    else
    {
      uint64_t v6 = 0;
      do
      {
        v6 += sub_1000AAFE8(*(uint64_t **)(a1 + 56), v4);
        v4 += 6;
      }
      while (v4 != v5);
    }
    uint64_t v7 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 3);
      int v9 = 134218240;
      uint64_t v10 = v6;
      __int16 v11 = 2048;
      unint64_t v12 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "submit.proc:#I Metric processing rules applied rules to %zu of %zu metrics", (uint8_t *)&v9, 0x16u);
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 32), OS_LOG_TYPE_DEBUG))
  {
    sub_1001499C0();
  }
}

void *sub_1000E79A8(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      __int16 v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          __int16 v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  xpc_object_t v13 = (void *)(a1 + 16);
  __int16 v11 = operator new(0x30uLL);
  *__int16 v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  v11[4] = 0;
  v11[5] = 0;
  v11[3] = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    sub_10002D4B4(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v20 = *(void *)a1;
  int v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    *__int16 v11 = *v21;
LABEL_38:
    *int v21 = v11;
    goto LABEL_39;
  }
  *__int16 v11 = *v13;
  *xpc_object_t v13 = v11;
  *(void *)(v20 + 8 * v4) = v13;
  if (*v11)
  {
    unint64_t v22 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }
    else
    {
      v22 &= v8 - 1;
    }
    int v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_1000E7BE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  sub_1000E7C00(v11, v10);
  _Unwind_Resume(a1);
}

void sub_1000E7C00(uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v3 = __p + 3;
    sub_10000B6EC(&v3);
  }
  if (__p) {
    operator delete(__p);
  }
}

uint64_t sub_1000E7C4C(uint64_t a1)
{
  sub_1000E7C88(a1, *(char **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_1000E7C88(uint64_t a1, char *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = *(char **)v2;
      unint64_t v4 = (void **)(v2 + 24);
      sub_10000B6EC(&v4);
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void sub_1000E7CDC(const void *a1@<X2>, int a2@<W3>, std::__shared_weak_count **a3@<X8>)
{
  if (a1)
  {
    sub_1000E8778(&v7);
    if ((wireless_diagnostics::google::protobuf::MessageLite::ParseFromArray(v7, a1, a2) & 1) == 0)
    {
      uint64_t v6 = v8;
      unint64_t v7 = 0;
      unint64_t v8 = 0;
      if (!v6) {
        goto LABEL_9;
      }
      sub_10000B678(v6);
    }
    if (v7) {
      operator new();
    }
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    unint64_t v8 = 0;
  }
LABEL_9:
  *a3 = v6;
  if (v8) {
    sub_10000B678(v8);
  }
}

void sub_1000E7DAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10000B678(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000E7DE8()
{
  sub_1000E8778(&v2);
  uint64_t v0 = v2;
  int v1 = *(_DWORD *)(v2 + 208);
  *(_DWORD *)(v2 + 32) = 1;
  *(_DWORD *)(v0 + 208) = v1 | 0x11;
  *(_DWORD *)(v0 + 200) = 2;
  operator new();
}

void sub_1000E7E78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10000B678(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000E7E90()
{
}

void sub_1000E7EF8()
{
  sub_1000E8778(&v2);
  uint64_t v0 = v2;
  int v1 = *(_DWORD *)(v2 + 208);
  *(_DWORD *)(v2 + 32) = -1;
  *(_DWORD *)(v0 + 208) = v1 | 0x11;
  *(_DWORD *)(v0 + 200) = 2;
  operator new();
}

void sub_1000E7F88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10000B678(a11);
  }
  _Unwind_Resume(exception_object);
}

FILE *sub_1000E7FA0@<X0>(int a1@<W0>, uint64_t a2@<X3>, void *a3@<X8>)
{
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v5 = (const char *)a2;
  }
  else {
    uint64_t v5 = *(const char **)a2;
  }
  uint64_t result = fopen(v5, "rb");
  if (result)
  {
    unint64_t v7 = result;
    int v8 = fileno(result);
    if (v8 < 0)
    {
      unint64_t v12 = 0;
      xpc_object_t v13 = 0;
    }
    else
    {
      wireless_diagnostics::google::protobuf::io::FileInputStream::FileInputStream((wireless_diagnostics::google::protobuf::io::FileInputStream *)v21, v8, -1);
      v14[0] = v21;
      v14[1] = 0;
      _OWORD v14[2] = 0;
      v15[0] = 0;
      *(void *)((char *)v15 + 6) = 0;
      long long v16 = xmmword_100179C80;
      int v17 = 0;
      int v18 = wireless_diagnostics::google::protobuf::io::CodedInputStream::default_recursion_limit_;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      wireless_diagnostics::google::protobuf::io::CodedInputStream::Refresh((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v14);
      sub_1000E8778(&v12);
      if ((wireless_diagnostics::google::protobuf::MessageLite::MergeFromCodedStream(v12, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)v14) & 1) == 0|| (*((unsigned char *)v12 + 208) & 1) == 0)
      {
        uint8x8_t v9 = v13;
        unint64_t v12 = 0;
        xpc_object_t v13 = 0;
        if (v9) {
          sub_10000B678(v9);
        }
      }
      wireless_diagnostics::google::protobuf::io::CodedInputStream::~CodedInputStream((wireless_diagnostics::google::protobuf::io::CodedInputStream *)v14);
      wireless_diagnostics::google::protobuf::io::FileInputStream::~FileInputStream((wireless_diagnostics::google::protobuf::io::FileInputStream *)v21);
      uint64_t v10 = v12;
      if (v12)
      {
        if ((a1 - 1) <= 3)
        {
          int v11 = dword_100179C90[a1 - 1];
          *((_DWORD *)v12 + 52) |= 0x10u;
          *((_DWORD *)v10 + 50) = v11;
        }
        operator new();
      }
    }
    *a3 = 0;
    if (v13) {
      sub_10000B678(v13);
    }
    return (FILE *)fclose(v7);
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

void sub_1000E8134(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (a10) {
    sub_10000B678(a10);
  }
  fclose(v21);
  _Unwind_Resume(a1);
}

void *sub_1000E8190(void *a1)
{
  *a1 = off_1001BC428;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10000B678(v2);
  }
  return a1;
}

void sub_1000E81DC(void *a1)
{
  *a1 = off_1001BC428;
  int v1 = (std::__shared_weak_count *)a1[5];
  if (v1) {
    sub_10000B678(v1);
  }

  operator delete();
}

BOOL sub_1000E8248(uint64_t a1)
{
  return *(void *)(a1 + 32) != 0;
}

uint64_t sub_1000E8258()
{
  return 0;
}

uint64_t sub_1000E8260(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1000E8268(uint64_t result, int a2)
{
  *(_DWORD *)(result + 24) = a2;
  uint64_t v2 = *(void *)(result + 32);
  if (v2)
  {
    if ((a2 - 1) <= 3)
    {
      int v3 = dword_100179C90[a2 - 1];
      *(_DWORD *)(v2 + 208) |= 0x10u;
      *(_DWORD *)(v2 + 200) = v3;
    }
  }
  return result;
}

uint64_t sub_1000E82A0(uint64_t result, int a2)
{
  *(_DWORD *)(result + 8) = a2;
  return result;
}

uint64_t sub_1000E82A8(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t sub_1000E82B0@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    int v5 = (*(uint64_t (**)(uint64_t))(*(void *)result + 72))(result);
    if (v5)
    {
      sub_10000712C(a2, v5);
      uint64_t v6 = (void *)*a2;
    }
    else
    {
      uint64_t v6 = 0;
    }
    uint64_t result = wireless_diagnostics::google::protobuf::MessageLite::SerializeToArray(*(wireless_diagnostics::google::protobuf::MessageLite **)(a1 + 32), v6);
    if ((result & 1) == 0) {
      a2[1] = *a2;
    }
  }
  return result;
}

void sub_1000E8340(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E8360(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24))
  {
    return 0;
  }
  uint64_t v2 = *(void *)(a2 + 32);
  BOOL v3 = v2 == 0;
  BOOL v4 = v2 != 0;
  unsigned int v5 = v3;
  if (*(void *)(a1 + 32)) {
    return v4;
  }
  else {
    return v5;
  }
}

void sub_1000E83B8(uint64_t a1@<X0>, xpc_object_t *a2@<X8>)
{
  *a2 = xpc_null_create();
  sub_1000E82B0(a1, (unint64_t *)&v16);
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  xpc_object_t v6 = xpc_null_create();
  xpc_object_t v7 = *a2;
  *a2 = v5;
  xpc_release(v7);
  xpc_release(v6);
  xpc_object_t v14 = xpc_data_create(v16, v17 - (unsigned char *)v16);
  if (!v14) {
    xpc_object_t v14 = xpc_null_create();
  }
  unint64_t v12 = a2;
  xpc_object_t v13 = "bin";
  sub_100014D08((uint64_t)&v12, &v14, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_object_t v10 = xpc_int64_create(*(unsigned int *)(a1 + 8));
  if (!v10) {
    xpc_object_t v10 = xpc_null_create();
  }
  unint64_t v12 = a2;
  xpc_object_t v13 = "iid";
  sub_100014D08((uint64_t)&v12, &v10, &v11);
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_release(v10);
  xpc_object_t v10 = 0;
  xpc_object_t v8 = xpc_int64_create(*(void *)(a1 + 16));
  if (!v8) {
    xpc_object_t v8 = xpc_null_create();
  }
  unint64_t v12 = a2;
  xpc_object_t v13 = "task_date";
  sub_100014D08((uint64_t)&v12, &v8, &v9);
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_release(v8);
  xpc_object_t v8 = 0;
  if (v16)
  {
    int v17 = v16;
    operator delete(v16);
  }
}

void sub_1000E85C8(_Unwind_Exception *a1)
{
  sub_1000551DC(v1);
  _Unwind_Resume(a1);
}

void sub_1000E85E4(xpc_object_t *a1@<X0>, std::__shared_weak_count **a2@<X8>)
{
  if (xpc_get_type(*a1) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v10 = a1;
    xpc_object_t v11 = "bin";
    sub_10000B7A4((uint64_t)&v10, &object);
    xpc_object_t v10 = a1;
    xpc_object_t v11 = "iid";
    sub_10000B7A4((uint64_t)&v10, &v9);
    xpc_object_t v10 = a1;
    xpc_object_t v11 = "task_date";
    sub_10000B7A4((uint64_t)&v10, &v8);
    if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_data
      || xpc_get_type(v9) == (xpc_type_t)&_xpc_type_null
      || xpc_get_type(v8) == (xpc_type_t)&_xpc_type_null)
    {
      *a2 = 0;
    }
    else
    {
      xpc::dyn_cast_or_default((xpc *)&v9, 0, v4);
      xpc::dyn_cast_or_default((xpc *)&v8, 0, v5);
      bytes_ptr = xpc_data_get_bytes_ptr(object);
      int length = xpc_data_get_length(object);
      sub_1000E7CDC(bytes_ptr, length, a2);
    }
    xpc_release(v8);
    xpc_release(v9);
    xpc_release(object);
  }
  else
  {
    *a2 = 0;
  }
}

void sub_1000E8738(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, uint64_t a12, uint64_t a13, xpc_object_t a14)
{
}

void *sub_1000E8778@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0xF0uLL);
  uint64_t result = sub_1000E87C4(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000E87B0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000E87C4(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1001BC460;
  awd::profile::DeviceConfiguration::DeviceConfiguration((uint64_t)(a1 + 3));
  return a1;
}

void sub_1000E880C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000E8820(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1001BC460;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000E8840(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1001BC460;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1000E8894(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_1000E88BC(uint64_t a1, int a2, uint64_t a3, long long *a4)
{
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = 0;
  *(void *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  unint64_t v5 = (_OWORD *)(a1 + 32);
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = off_1001BC4B0;
  long long v6 = *a4;
  *(void *)a4 = 0;
  *((void *)a4 + 1) = 0;
  xpc_object_t v7 = *(std::__shared_weak_count **)(a1 + 40);
  *unint64_t v5 = v6;
  if (v7)
  {
    sub_10000B678(v7);
    xpc_object_t v8 = *(_DWORD **)v5;
    if (!*(void *)v5) {
      return a1;
    }
  }
  else
  {
    xpc_object_t v8 = (_DWORD *)v6;
    if (!(void)v6) {
      return a1;
    }
  }
  int v9 = v8[52];
  if ((v9 & 0x10) != 0)
  {
    uint64_t v10 = (int)v8[50];
    if (v10 <= 3) {
      *(_DWORD *)(a1 + 24) = dword_100179CA0[v10];
    }
  }
  if (v9) {
    *(_DWORD *)(a1 + 12) = v8[8];
  }
  return a1;
}

void *sub_1000E8970(void *a1)
{
  *a1 = off_1001BC428;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10000B678(v2);
  }
  return a1;
}

void sub_1000E89BC(void *a1)
{
  *a1 = off_1001BC428;
  uint64_t v1 = (std::__shared_weak_count *)a1[5];
  if (v1) {
    sub_10000B678(v1);
  }

  operator delete();
}

uint64_t sub_1000E8A28()
{
  return 1;
}

void *sub_1000E8A30(void *a1)
{
  *a1 = off_1001BC428;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10000B678(v2);
  }
  return a1;
}

void sub_1000E8A7C(void *a1)
{
  *a1 = off_1001BC428;
  uint64_t v1 = (std::__shared_weak_count *)a1[5];
  if (v1) {
    sub_10000B678(v1);
  }

  operator delete();
}

void sub_1000E8C10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000E8C5C()
{
}

void sub_1000E8C64()
{
}

void sub_1000E8C6C()
{
}

void sub_1000E8D84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1000E8DA8()
{
  sub_1000155F0(v40, 0);
  pthread_mutex_lock(&stru_1001D69C0);
  uint64_t v0 = xmmword_1001D6A00;
  if (!(void)xmmword_1001D6A00) {
    sub_1000781CC();
  }
  uint64_t v1 = (std::__shared_weak_count *)*((void *)&xmmword_1001D6A00 + 1);
  if (*((void *)&xmmword_1001D6A00 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1001D6A00 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_1001D69C0);
  sub_1000A3AD8(v0, &__s1);
  if (v1) {
    sub_10000B678(v1);
  }
  uint64_t v2 = v39;
  if ((v39 & 0x80u) == 0) {
    size_t v3 = v39;
  }
  else {
    size_t v3 = __n;
  }
  if (v3)
  {
    unint64_t v4 = v41;
    if ((v41 & 0x80u) != 0) {
      unint64_t v4 = (unint64_t)v40[1];
    }
    if (v4)
    {
      if (v3 != v4) {
        goto LABEL_32;
      }
      if ((v41 & 0x80u) == 0) {
        unint64_t v5 = v40;
      }
      else {
        unint64_t v5 = (void **)v40[0];
      }
      if ((v39 & 0x80) != 0)
      {
        if (memcmp(__s1, v5, __n)) {
          goto LABEL_32;
        }
      }
      else if (v39)
      {
        p_s1 = &__s1;
        xpc_object_t v7 = v5;
        while (*(unsigned __int8 *)p_s1 == *(unsigned __int8 *)v7)
        {
          p_s1 = (void **)((char *)p_s1 + 1);
          xpc_object_t v7 = (void **)((char *)v7 + 1);
          if (!--v2) {
            goto LABEL_47;
          }
        }
LABEL_32:
        sub_1000E93C0((uint64_t)&__s1, (uint64_t)buf);
        sub_1000E93C0((uint64_t)v40, (uint64_t)v33);
        uint64_t v12 = v47;
        if ((v47 & 0x80u) == 0) {
          unint64_t v13 = v47;
        }
        else {
          unint64_t v13 = *(void *)&buf[8];
        }
        unint64_t v14 = v34;
        if ((v34 & 0x80u) != 0) {
          unint64_t v14 = (unint64_t)v33[1];
        }
        if (v13 == v14)
        {
          if ((v34 & 0x80u) == 0) {
            float v15 = v33;
          }
          else {
            float v15 = (void **)v33[0];
          }
          if ((v47 & 0x80) == 0)
          {
            if (v47)
            {
              long long v16 = buf;
              while (*v16 == *(unsigned __int8 *)v15)
              {
                ++v16;
                float v15 = (void **)((char *)v15 + 1);
                if (!--v12) {
                  goto LABEL_58;
                }
              }
              goto LABEL_51;
            }
LABEL_58:
            uint64_t v21 = v50;
            if ((v50 & 0x80u) == 0) {
              size_t v22 = v50;
            }
            else {
              size_t v22 = v49;
            }
            unint64_t v23 = v36;
            if ((v36 & 0x80u) != 0) {
              unint64_t v23 = (unint64_t)__p[1];
            }
            if (v22 == v23)
            {
              if ((v36 & 0x80u) == 0) {
                int v24 = __p;
              }
              else {
                int v24 = (void **)__p[0];
              }
              if ((v50 & 0x80) == 0)
              {
                if (v50)
                {
                  unint64_t v25 = &v48;
                  while (*(unsigned __int8 *)v25 == *(unsigned __int8 *)v24)
                  {
                    unint64_t v25 = (void **)((char *)v25 + 1);
                    int v24 = (void **)((char *)v24 + 1);
                    if (!--v21) {
                      goto LABEL_81;
                    }
                  }
                  goto LABEL_74;
                }
LABEL_81:
                unint64_t v29 = *(NSObject **)(qword_1001D8080 + 48);
                if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
                {
                  int v30 = &__s1;
                  if ((v39 & 0x80u) != 0) {
                    int v30 = __s1;
                  }
                  uint64_t v31 = v40;
                  if ((v41 & 0x80u) != 0) {
                    uint64_t v31 = (void **)v40[0];
                  }
                  *(_DWORD *)int v42 = 136446466;
                  __int16 v43 = v30;
                  __int16 v44 = 2082;
                  unsigned int v45 = v31;
                  _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#N Patch build update from %{public}s to %{public}s", v42, 0x16u);
                }
                uint64_t v10 = 1;
LABEL_88:
                if ((char)v36 < 0) {
                  operator delete(__p[0]);
                }
                if ((char)v34 < 0) {
                  operator delete(v33[0]);
                }
                if ((char)v50 < 0) {
                  operator delete(v48);
                }
                if ((char)v47 < 0) {
                  operator delete(*(void **)buf);
                }
                goto LABEL_96;
              }
              if (!memcmp(v48, v24, v49)) {
                goto LABEL_81;
              }
            }
LABEL_74:
            int v26 = *(NSObject **)(qword_1001D8080 + 48);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v27 = &__s1;
              if ((v39 & 0x80u) != 0) {
                uint64_t v27 = __s1;
              }
              unsigned int v28 = v40;
              if ((v41 & 0x80u) != 0) {
                unsigned int v28 = (void **)v40[0];
              }
              *(_DWORD *)int v42 = 136446466;
              __int16 v43 = v27;
              __int16 v44 = 2082;
              unsigned int v45 = v28;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#N Minor build update from %{public}s to %{public}s", v42, 0x16u);
            }
            uint64_t v10 = 2;
            goto LABEL_88;
          }
          if (!memcmp(*(const void **)buf, v15, *(size_t *)&buf[8])) {
            goto LABEL_58;
          }
        }
LABEL_51:
        int v18 = *(NSObject **)(qword_1001D8080 + 48);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v19 = &__s1;
          if ((v39 & 0x80u) != 0) {
            uint64_t v19 = __s1;
          }
          uint64_t v20 = v40;
          if ((v41 & 0x80u) != 0) {
            uint64_t v20 = (void **)v40[0];
          }
          *(_DWORD *)int v42 = 136446466;
          __int16 v43 = v19;
          __int16 v44 = 2082;
          unsigned int v45 = v20;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#N Major build update from %{public}s to %{public}s", v42, 0x16u);
        }
        uint64_t v10 = 3;
        goto LABEL_88;
      }
LABEL_47:
      int v17 = *(NSObject **)(qword_1001D8080 + 48);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
        sub_100149A28((uint64_t)v5, v17);
      }
    }
    else
    {
      xpc_object_t v11 = *(NSObject **)(qword_1001D8080 + 48);
      uint64_t v10 = 0;
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_96;
      }
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N No build information available; weird.",
        buf,
        2u);
    }
    uint64_t v10 = 0;
    goto LABEL_96;
  }
  xpc_object_t v8 = *(NSObject **)(qword_1001D8080 + 48);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = v40;
    if ((v41 & 0x80u) != 0) {
      int v9 = (void **)v40[0];
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N No old build information available; new build is %{public}s",
      buf,
      0xCu);
  }
  uint64_t v10 = 3;
LABEL_96:
  if ((char)v39 < 0) {
    operator delete(__s1);
  }
  if ((char)v41 < 0) {
    operator delete(v40[0]);
  }
  return v10;
}

void sub_1000E9338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  sub_1000E94C0(v26 - 80);
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(a1);
}

void sub_1000E93C0(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  int v3 = *(char *)(a1 + 23);
  if (v3 >= 0) {
    unint64_t v4 = (std::string::value_type *)a1;
  }
  else {
    unint64_t v4 = *(std::string::value_type **)a1;
  }
  if (v3 >= 0) {
    uint64_t v5 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  long long v6 = &v4[v5];
  xpc_object_t v7 = v4;
  if (v5)
  {
    xpc_object_t v7 = v4;
    while ((*v7 & 0x80000000) == 0 && (_DefaultRuneLocale.__runetype[*v7] & 0x400) != 0)
    {
      ++v7;
      if (!--v5)
      {
        xpc_object_t v7 = v6;
        goto LABEL_20;
      }
    }
  }
  if (v7 != v6)
  {
    xpc_object_t v8 = v7;
    while (*v8 < 0 || (_DefaultRuneLocale.__runetype[*v8] & 0x400) == 0)
    {
      if (++v8 == v6) {
        goto LABEL_20;
      }
    }
    long long v6 = v8;
  }
LABEL_20:
  sub_1000E9504((std::string *)a2, v4, v7, v7 - v4);
  sub_1000E9504((std::string *)(a2 + 24), v7, v6, v6 - v7);
}

void sub_1000E94AC(_Unwind_Exception *a1)
{
  sub_1000E94C0(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E94C0(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1000E9504(std::string *this, std::string::value_type *a2, std::string::value_type *a3, std::string::size_type a4)
{
  if ((SHIBYTE(this->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    xpc_object_t v8 = this;
    if (a4 <= 0x16) {
      goto LABEL_11;
    }
    std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    std::string::size_type v10 = 22;
    goto LABEL_6;
  }
  unint64_t v11 = this->__r_.__value_.__r.__words[2];
  std::string::size_type v10 = (v11 & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v10 < a4)
  {
    std::string::size_type size = this->__r_.__value_.__l.__size_;
LABEL_6:
    std::string::__grow_by(this, v10, a4 - v10, size, 0, size, 0);
    this->__r_.__value_.__l.__size_ = 0;
    LOBYTE(v12) = *((unsigned char *)&this->__r_.__value_.__s + 23);
    goto LABEL_8;
  }
  unint64_t v12 = HIBYTE(v11);
LABEL_8:
  xpc_object_t v8 = this;
  if ((v12 & 0x80) != 0) {
    xpc_object_t v8 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
LABEL_11:
  while (a2 != a3)
  {
    std::string::value_type v13 = *a2++;
    v8->__r_.__value_.__s.__data_[0] = v13;
    xpc_object_t v8 = (std::string *)((char *)v8 + 1);
  }
  v8->__r_.__value_.__s.__data_[0] = 0;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
    this->__r_.__value_.__l.__size_ = a4;
  }
  else {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = a4 & 0x7F;
  }
}

uint64_t sub_1000E95D4()
{
  if ((byte_1001D6A10 & 1) == 0)
  {
    byte_1001D6A10 = 1;
    return __cxa_atexit((void (*)(void *))sub_100042E5C, &stru_1001D69C0, (void *)&_mh_execute_header);
  }
  return result;
}

void sub_1000E9610()
{
}

void sub_1000E9780(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&stru_1001D6968);
  int v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10000B678(v3);
  }
  _Unwind_Resume(a1);
}

void sub_1000E980C(void *a1)
{
}

void sub_1000E9868(_Unwind_Exception *a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 4));
  sub_100029804(v1);
  _Unwind_Resume(a1);
}

void *sub_1000E9884(void *a1, const char *a2, dispatch_qos_class_t a3, const char *a4)
{
  dispatch_object_t object = 0;
  sub_10002A670(a1, a2, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), "com.apple.wis.wirelessinsightsd", a4);
  return a1;
}

void sub_1000E98E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  sub_100029804(v10);
  _Unwind_Resume(a1);
}

void *sub_1000E990C(uint64_t a1)
{
  unint64_t v4 = (void **)(a1 + 112);
  sub_1000EA8D0(&v4);
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  unint64_t v4 = (void **)(a1 + 64);
  sub_1000EA848(&v4);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10000B678(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 32));
  return sub_100029804((void *)a1);
}

void sub_1000E9980(void *a1, unsigned char *a2, uint64_t a3)
{
  if (!*a2)
  {
    sub_10000BA54(&v7, a1);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = sub_1000E9AB8;
    v6[3] = &unk_1001BC520;
    v6[4] = a1;
    uint64_t v5 = (NSObject **)(v7 + 16);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 1174405120;
    v9[2] = sub_1000EA954;
    void v9[3] = &unk_1001BC600;
    void v9[5] = v7;
    std::string::size_type v10 = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    void v9[4] = v6;
    sub_100123EA0(a3, v5, (uint64_t)v9);
    if (v10) {
      sub_10000B678(v10);
    }
    if (v8) {
      sub_10000B678(v8);
    }
  }
}

void sub_1000E9A94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    sub_10000B678(a22);
  }
  if (a15) {
    sub_10000B678(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000E9AB8(uint64_t a1)
{
}

void sub_1000E9AC0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "#I Init WISBasebandManager", (uint8_t *)&__p, 2u);
  }
  uint64_t v3 = *(void *)(a1 + 40);
  unint64_t v4 = (char *)abm::kEventBasebandBootStateChange;
  uint64_t v5 = *(NSObject **)(a1 + 16);
  dispatch_object_t v12 = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  v18[0] = off_1001BC640;
  v18[1] = a1;
  v18[3] = v18;
  sub_10009FFA4(v3, v4, &v12, (uint64_t)v18, &object);
  if (object) {
    dispatch_release(object);
  }
  sub_1000A0A98(v18);
  if (v12) {
    dispatch_release(v12);
  }
  sub_10009FED4(*(void *)(a1 + 40));
  memset(&__p, 0, sizeof(__p));
  if (sub_1000A07D4(*(void *)(a1 + 40)))
  {
    long long v6 = std::string::operator=((std::string *)(a1 + 88), &__p);
    *(unsigned char *)(a1 + 56) = sub_1000E9DF8((uint64_t)v6, (void *)(a1 + 88));
  }
  uint64_t v7 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    xpc_object_t v8 = (void *)(a1 + 88);
    if (*(char *)(a1 + 111) < 0) {
      xpc_object_t v8 = (void *)*v8;
    }
    unint64_t v9 = *(char *)(a1 + 56);
    if (v9 > 2) {
      std::string::size_type v10 = "???";
    }
    else {
      std::string::size_type v10 = off_1001BC750[v9];
    }
    *(_DWORD *)long long buf = 136315394;
    float v15 = v8;
    __int16 v16 = 2080;
    int v17 = v10;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "#I After init baseBandBootState = %s, insightsState = %s", buf, 0x16u);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1000E9CAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, dispatch_object_t object, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
}

void sub_1000E9CEC(void *a1, uint64_t a2, NSObject **a3)
{
  sub_100123D48(a3, &group[1]);
  sub_10000BA54(&v5, a1);
  operator new();
}

uint64_t sub_1000E9DF8(uint64_t a1, void *a2)
{
  size_t v3 = strlen(abm::kBasebandBootStateIsReady);
  size_t v4 = v3;
  size_t v5 = *((unsigned __int8 *)a2 + 23);
  if (*((char *)a2 + 23) < 0)
  {
    if (v3 != a2[1])
    {
      uint64_t v7 = (const void *)abm::kBasebandBootStateDead;
      size_t v8 = strlen(abm::kBasebandBootStateDead);
      size_t v5 = a2[1];
LABEL_15:
      if (v8 == v5)
      {
        if (v5 == -1) {
          sub_1000983B4();
        }
        a2 = (void *)*a2;
        return memcmp(a2, v7, v5) != 0;
      }
      return 1;
    }
    if (v3 == -1) {
      goto LABEL_21;
    }
    long long v6 = (void *)*a2;
  }
  else
  {
    if (v3 != v5)
    {
      uint64_t v7 = (const void *)abm::kBasebandBootStateDead;
      size_t v8 = strlen(abm::kBasebandBootStateDead);
      goto LABEL_12;
    }
    long long v6 = a2;
    if (v4 == -1) {
LABEL_21:
    }
      sub_1000983B4();
  }
  if (memcmp(v6, abm::kBasebandBootStateIsReady, v4))
  {
    uint64_t v7 = (const void *)abm::kBasebandBootStateDead;
    size_t v8 = strlen(abm::kBasebandBootStateDead);
    if ((v5 & 0x80) != 0)
    {
      size_t v5 = a2[1];
      goto LABEL_15;
    }
LABEL_12:
    if (v8 == v5) {
      return memcmp(a2, v7, v5) != 0;
    }
    return 1;
  }
  return 2;
}

void sub_1000E9F34(void *a1, void *a2)
{
  *a2 = 0;
  sub_10000BA54(&v2, a1);
  operator new();
}

void sub_1000EA014(void *a1, uint64_t *a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v33 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v33 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v33 = v6;
LABEL_9:
  xpc_release(v5);
  if (xpc_get_type(v33) != (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v7 = a1[4];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_100149AA0(v7, v8, v9, v10, v11, v12, v13, v14);
    }
    goto LABEL_29;
  }
  xpc_object_t object = xpc_int64_create(4);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  std::string __p = &v33;
  uint64_t v27 = (unsigned char *)abm::kKeyAppID;
  sub_100014D08((uint64_t)&__p, &object, &v32);
  xpc_release(v32);
  xpc_object_t v32 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_object_t v29 = xpc_int64_create(0);
  if (!v29) {
    xpc_object_t v29 = xpc_null_create();
  }
  std::string __p = &v33;
  uint64_t v27 = (unsigned char *)abm::kKeyPayloadType;
  sub_100014D08((uint64_t)&__p, &v29, &v30);
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
  uint64_t v15 = sub_1000B0210(*a2);
  std::string __p = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  sub_1000148E0(&__p, *(const void **)v15, *(void *)(v15 + 8), *(void *)(v15 + 8) - *(void *)v15);
  xpc_object_t v16 = xpc_data_create(__p, v27 - (unsigned char *)__p);
  xpc_object_t v17 = v16;
  if (v16)
  {
    xpc_object_t v24 = v16;
  }
  else
  {
    xpc_object_t v17 = xpc_null_create();
    xpc_object_t v24 = v17;
    if (!v17)
    {
      xpc_object_t v17 = 0;
      xpc_object_t v24 = xpc_null_create();
      goto LABEL_20;
    }
  }
  xpc_retain(v17);
LABEL_20:
  v23[0] = &v33;
  v23[1] = abm::kKeyPayload;
  sub_100014D08((uint64_t)v23, &v24, &v25);
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_release(v24);
  xpc_object_t v24 = 0;
  uint64_t v18 = a1[5];
  xpc_object_t v22 = v33;
  if (v33) {
    xpc_retain(v33);
  }
  else {
    xpc_object_t v22 = xpc_null_create();
  }
  uint64_t v19 = (char *)abm::kCommandAddConfiguration;
  uint64_t v20 = a1[2];
  dispatch_object_t v21 = v20;
  if (v20) {
    dispatch_retain(v20);
  }
  v34[0] = off_1001BC6D0;
  v34[1] = a1;
  v34[3] = v34;
  sub_1000A03D8(v18, v19, (uint64_t)&v22, &v21, (uint64_t)v34);
  sub_1000A0D18(v34);
  if (v21) {
    dispatch_release(v21);
  }
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v17);
  if (__p)
  {
    uint64_t v27 = __p;
    operator delete(__p);
  }
LABEL_29:
  xpc_release(v33);
}

void sub_1000EA314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, xpc_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10001F4A8(exception_object);
}

void sub_1000EA3E4(void *a1, xpc_object_t *a2)
{
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_null_create();
  }
  sub_10000BA54(&v3, a1);
  operator new();
}

void *sub_1000EA4FC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1000EA580(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1000EA5F8(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[2], v1, (dispatch_function_t)sub_1000EA6D0);
  __cxa_rethrow();
}

void sub_1000EA620(_Unwind_Exception *a1)
{
}

void sub_1000EA638(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1000EA670(uint64_t a1)
{
}

uint64_t sub_1000EA68C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1000EA6D0(uint64_t result)
{
  if (result)
  {
    sub_1000E990C(result);
    operator delete();
  }
  return result;
}

void *sub_1000EA710(void *a1)
{
  *a1 = off_1001BC5B0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10000B678(v2);
  }
  return a1;
}

void sub_1000EA75C(void *a1)
{
  *a1 = off_1001BC5B0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10000B678(v1);
  }

  operator delete();
}

void *sub_1000EA7C8@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "WISBasebandManager");
}

unsigned char *sub_1000EA7D8@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1000EA814(uint64_t a1, uint64_t a2, NSObject **a3)
{
}

void sub_1000EA81C(uint64_t a1, char a2, uint64_t a3)
{
  char v3 = a2;
  sub_1000E9980(*(void **)(a1 + 8), &v3, a3);
}

void sub_1000EA848(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (uint64_t *)**a1;
  if (v2)
  {
    xpc_object_t v4 = (uint64_t *)v1[1];
    xpc_object_t v5 = **a1;
    if (v4 != v2)
    {
      do
        sub_100077FDC(--v4, 0);
      while (v4 != v2);
      xpc_object_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1000EA8D0(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    xpc_object_t v4 = v1[1];
    xpc_object_t v5 = v2;
    if (v4 != v2)
    {
      do
        xpc_object_t v4 = sub_1000EA4FC(v4 - 4);
      while (v4 != v2);
      xpc_object_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1000EA954(uint64_t a1, NSObject **a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  dispatch_group_t group = *a2;
  *a2 = 0;
  (*(void (**)(void))(v2 + 16))();
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
}

void sub_1000EA9B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000EA9D4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1000EA9F0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10000B678(v1);
  }
}

uint64_t *sub_1000EAA00(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *v1;
  char v3 = *(NSObject **)(*v1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "#I Shutting down WISBasebandManager", buf, 2u);
  }
  uint64_t v4 = *(void *)(v2 + 40);
  xpc_object_t v5 = v1[1];
  *(void *)long long buf = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  sub_10009FF3C(v4);
  if (*(void *)buf)
  {
    dispatch_group_leave(*(dispatch_group_t *)buf);
    if (*(void *)buf) {
      dispatch_release(*(dispatch_object_t *)buf);
    }
  }
  sub_1000EAAFC((uint64_t *)&v8);
  return sub_10000BA00((uint64_t *)&v7);
}

void sub_1000EAAC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_1000EAAFC(&a10);
  sub_10000BA00(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1000EAAFC(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(NSObject **)(v1 + 8);
    if (v2)
    {
      dispatch_group_leave(v2);
      char v3 = *(NSObject **)(v1 + 8);
      if (v3) {
        dispatch_release(v3);
      }
    }
    operator delete();
  }
  return result;
}

void sub_1000EAB60()
{
}

void *sub_1000EAB74(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1001BC640;
  result[1] = v3;
  return result;
}

uint64_t sub_1000EABBC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1001BC640;
  a2[1] = v2;
  return result;
}

void sub_1000EABE8(uint64_t a1, void **a2, void *a3)
{
  xpc_object_t v5 = *a2;
  *a2 = xpc_null_create();
  *a3 = 0;
  xpc_object_t v6 = *(void **)(a1 + 8);
  uint64_t v7 = v6[4];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)uint64_t v9 = 136315138;
    *(void *)&void v9[4] = abm::kEventBasebandBootStateChange;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "#I Received event %s", v9, 0xCu);
  }
  if (v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    *(void *)uint64_t v9 = v5;
    xpc_object_t v8 = v5;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    *(void *)uint64_t v9 = v8;
    if (!v8)
    {
      *(void *)uint64_t v9 = xpc_null_create();
      goto LABEL_9;
    }
  }
  xpc_retain(v8);
LABEL_9:
  sub_1000EA3E4(v6, (xpc_object_t *)v9);
}

void sub_1000EAD50(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10001F4A8(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000EAD80(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1000EADC0()
{
}

uint64_t *sub_1000EADCC(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v27 = a1;
  uint64_t v28 = v1;
  uint64_t v2 = (int64x2_t *)*v1;
  int v3 = *(unsigned __int8 *)(*v1 + 56);
  if (v3 == 2)
  {
    xpc_object_t v8 = v2[2].i64[0];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "#I Pumping the insight to Baseband", buf, 2u);
    }
    uint64_t v9 = v1[1];
    v1[1] = 0;
    *(void *)long long buf = v9;
    sub_1000EA014(v2, (uint64_t *)buf);
    if (v9)
    {
      sub_1000AFEE0(v9);
      operator delete();
    }
  }
  else if (v3 == 1)
  {
    unint64_t v4 = v2[5].u64[0];
    xpc_object_t v5 = (void *)v2[4].i64[1];
    if ((unint64_t)v5 >= v4)
    {
      uint64_t v12 = v2[4].i64[0];
      uint64_t v13 = ((uint64_t)v5 - v12) >> 3;
      if ((unint64_t)(v13 + 1) >> 61) {
        sub_10002B5E0();
      }
      uint64_t v14 = v4 - v12;
      uint64_t v15 = v14 >> 2;
      if (v14 >> 2 <= (unint64_t)(v13 + 1)) {
        uint64_t v15 = v13 + 1;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v15;
      }
      xpc_object_t v32 = v2 + 5;
      if (v16) {
        xpc_object_t v17 = (char *)sub_100038500((uint64_t)v2[5].i64, v16);
      }
      else {
        xpc_object_t v17 = 0;
      }
      uint64_t v18 = &v17[8 * v13];
      uint64_t v19 = &v17[8 * v16];
      uint64_t v31 = v19;
      uint64_t v20 = v1[1];
      v1[1] = 0;
      *(void *)uint64_t v18 = v20;
      uint64_t v7 = v18 + 8;
      v30.i64[1] = (uint64_t)(v18 + 8);
      xpc_object_t v22 = (void *)v2[4].i64[0];
      dispatch_object_t v21 = (void *)v2[4].i64[1];
      if (v21 == v22)
      {
        int64x2_t v24 = vdupq_n_s64((unint64_t)v21);
      }
      else
      {
        do
        {
          uint64_t v23 = *--v21;
          *dispatch_object_t v21 = 0;
          *((void *)v18 - 1) = v23;
          v18 -= 8;
        }
        while (v21 != v22);
        int64x2_t v24 = v2[4];
        uint64_t v7 = (void *)v30.i64[1];
        uint64_t v19 = v31;
      }
      v2[4].i64[0] = (uint64_t)v18;
      v2[4].i64[1] = (uint64_t)v7;
      int64x2_t v30 = v24;
      uint64_t v25 = v2[5].i64[0];
      v2[5].i64[0] = (uint64_t)v19;
      uint64_t v31 = (char *)v25;
      *(void *)long long buf = v24.i64[0];
      sub_1000EB080((uint64_t)buf);
    }
    else
    {
      uint64_t v6 = v1[1];
      v1[1] = 0;
      *xpc_object_t v5 = v6;
      uint64_t v7 = v5 + 1;
    }
    v2[4].i64[1] = (uint64_t)v7;
    uint64_t v10 = v2[2].i64[0];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v11 = "#I Queued the insight";
      goto LABEL_27;
    }
  }
  else
  {
    uint64_t v10 = v2[2].i64[0];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v11 = "#I Baseband is in Error state, dropping the insight";
LABEL_27:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, v11, buf, 2u);
    }
  }
  sub_1000EB02C((uint64_t *)&v28);
  return sub_10000BA00((uint64_t *)&v27);
}

void sub_1000EAFFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1000EB02C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100077FDC((uint64_t *)(v1 + 8), 0);
    operator delete();
  }
  return result;
}

uint64_t sub_1000EB080(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_100077FDC((uint64_t *)(i - 8), 0);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1000EB0D8()
{
}

void *sub_1000EB0EC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1001BC6D0;
  result[1] = v3;
  return result;
}

uint64_t sub_1000EB134(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1001BC6D0;
  a2[1] = v2;
  return result;
}

void sub_1000EB160(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  xpc_object_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  *a3 = xpc_null_create();
  xpc_object_t v8 = *(NSObject **)(*(void *)(a1 + 8) + 32);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    v9[0] = 67109120;
    v9[1] = v4 == 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "#I Pumping Insight to Baseband result=%{BOOL}d", (uint8_t *)v9, 8u);
  }
  xpc_release(v7);
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_1000EB250(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10001F4A8(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000EB260(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1000EB2A0()
{
}

uint64_t sub_1000EB2AC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t *sub_1000EB344(void **a1)
{
  uint64_t v1 = *a1;
  int64x2_t v30 = a1;
  uint64_t v31 = v1;
  uint64_t v2 = *v1;
  int v4 = (void *)v1[1];
  uint64_t v3 = (uint64_t)(v1 + 1);
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v32[0] = v3;
    v32[1] = abm::kKeyBasebandBootState;
    sub_10000B7A4((uint64_t)v32, &object);
    long long __p = 0uLL;
    uint64_t v37 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v37) < 0) {
      operator delete((void *)__p);
    }
    uint64_t v13 = (void **)(v2 + 88);
    if (*(char *)(v2 + 111) < 0) {
      operator delete(*v13);
    }
    *(_OWORD *)uint64_t v13 = *(_OWORD *)__dst;
    *(void *)(v2 + 104) = v35;
    HIBYTE(v35) = 0;
    LOBYTE(__dst[0]) = 0;
    xpc_release(object);
    uint64_t v14 = *(NSObject **)(v2 + 32);
    uint64_t v15 = os_log_type_enabled(v14, OS_LOG_TYPE_INFO);
    if (v15)
    {
      unint64_t v16 = (void *)(v2 + 88);
      if (*(char *)(v2 + 111) < 0) {
        unint64_t v16 = *v13;
      }
      LODWORD(__p) = 136315138;
      *(void *)((char *)&__p + 4) = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "#I Baseband boot state = %s", (uint8_t *)&__p, 0xCu);
    }
    uint64_t v17 = *(void *)(v2 + 112);
    uint64_t v18 = *(void *)(v2 + 120);
    while (v17 != v18)
    {
      sub_1000EB2AC((uint64_t)&__p, v17);
      if (*(char *)(v2 + 111) < 0)
      {
        sub_1000173FC(__dst, *(void **)(v2 + 88), *(void *)(v2 + 96));
      }
      else
      {
        *(_OWORD *)std::__fs::filesystem::path __dst = *(_OWORD *)v13;
        uint64_t v35 = *(void *)(v2 + 104);
      }
      if (!v38) {
        sub_100029F0C();
      }
      (*(void (**)(uint64_t, void **))(*(void *)v38 + 48))(v38, __dst);
      if (SHIBYTE(v35) < 0) {
        operator delete(__dst[0]);
      }
      uint64_t v15 = (uint64_t)sub_1000EA4FC(&__p);
      v17 += 32;
    }
    int v19 = sub_1000E9DF8(v15, (void *)(v2 + 88));
    *(unsigned char *)(v2 + 56) = v19;
    if (v19)
    {
      if (v19 == 2)
      {
        dispatch_object_t v21 = *(uint64_t **)(v2 + 64);
        uint64_t v20 = *(uint64_t **)(v2 + 72);
        if (v20 != v21)
        {
          xpc_object_t v22 = *(NSObject **)(v2 + 32);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
          {
            LODWORD(__p) = 134217984;
            *(void *)((char *)&__p + 4) = v20 - v21;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "#I Found %zu configs in the queue", (uint8_t *)&__p, 0xCu);
            dispatch_object_t v21 = *(uint64_t **)(v2 + 64);
            uint64_t v20 = *(uint64_t **)(v2 + 72);
          }
          if (v21 != v20)
          {
            int v23 = 1;
            do
            {
              int64x2_t v24 = *(NSObject **)(v2 + 32);
              if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
              {
                LODWORD(__p) = 67109120;
                DWORD1(__p) = v23;
                _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "#I Popping insight %u from the queue", (uint8_t *)&__p, 8u);
              }
              uint64_t v25 = *v21;
              *dispatch_object_t v21 = 0;
              v32[0] = v25;
              sub_1000EA014((void *)v2, v32);
              v32[0] = 0;
              if (v25)
              {
                sub_1000AFEE0(v25);
                operator delete();
              }
              ++v21;
              ++v23;
            }
            while (v21 != v20);
            uint64_t v26 = *(uint64_t **)(v2 + 64);
            uint64_t v20 = *(uint64_t **)(v2 + 72);
            if (v20 != v26)
            {
              do
                sub_100077FDC(--v20, 0);
              while (v20 != v26);
              uint64_t v20 = v26;
            }
          }
          *(void *)(v2 + 72) = v20;
        }
      }
    }
    else
    {
      uint64_t v28 = *(uint64_t **)(v2 + 64);
      for (uint64_t i = *(uint64_t **)(v2 + 72); i != v28; sub_100077FDC(i, 0))
        --i;
      *(void *)(v2 + 72) = v28;
    }
  }
  else
  {
    xpc_object_t v5 = *(NSObject **)(v2 + 32);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      sub_100149AF4(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
  sub_1000EB77C((uint64_t *)&v31);
  return sub_10000BA00((uint64_t *)&v30);
}

void sub_1000EB6E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, xpc_object_t object, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a2) {
    sub_10001F4A8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1000EB77C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    xpc_release(*(xpc_object_t *)(v1 + 8));
    *(void *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

void sub_1000EB7D4()
{
  operator delete();
}

uint64_t sub_1000EB7F4()
{
  if ((byte_1001D69B8 & 1) == 0)
  {
    byte_1001D69B8 = 1;
    return __cxa_atexit((void (*)(void *))sub_100029800, &stru_1001D6968, (void *)&_mh_execute_header);
  }
  return result;
}

void sub_1000EB958(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000EB9A4()
{
}

void sub_1000EB9AC()
{
}

void sub_1000EB9B4()
{
}

void sub_1000EBC24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1000EBEA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,void *a26)
{
  _Unwind_Resume(a1);
}

void sub_1000EC11C(uint64_t a1)
{
  id v1 = objc_alloc_init(*(Class *)(a1 + 32));
  uint64_t v2 = (void *)qword_1001D7E78;
  qword_1001D7E78 = (uint64_t)v1;
}

void sub_1000EC26C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1000EC28C(uint64_t a1)
{
  [*(id *)(a1 + 32) setIsDataInitSuccess:0];
  uint64_t v2 = +[TelephonyStateRelay sharedInstance];
  [*(id *)(a1 + 32) setCtRelay:v2];

  uint64_t v3 = [*(id *)(a1 + 32) ctRelay];
  int v4 = [v3 coreTelephonyClient];

  if (!v4 && os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 48), OS_LOG_TYPE_ERROR)) {
    sub_100149B2C();
  }
  xpc_object_t v5 = [*(id *)(a1 + 32) ctRelay];
  objc_msgSend(v5, "addTelephonyStateDelegate:withQueue:", *(void *)(a1 + 32), objc_msgSend(*(id *)(a1 + 32), "queue"));

  uint64_t v6 = [*(id *)(a1 + 32) ctRelay];
  [v6 getAirplaneModeStatus:*(void *)(a1 + 32)];

  [*(id *)(a1 + 32) setAirplaneModeActive:0];
  uint64_t v7 = [*(id *)(a1 + 32) ctRelay];
  [v7 getRadioStateForDelegate:*(void *)(a1 + 32)];

  [*(id *)(a1 + 32) setRadioState:&off_1001C3BE0];
  uint64_t v8 = [*(id *)(a1 + 32) ctRelay];
  uint64_t v9 = [v8 getStewieState];
  [*(id *)(a1 + 32) setStewieState:v9];

  return [*(id *)(a1 + 32) populateSubscriptionContextsInUse];
}

void sub_1000EC3F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000EC84C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1000ECA5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1000ECA90(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if ([v4 dataPreferred])
  {
    xpc_object_t v5 = *(void **)(a1 + 32);
    uint64_t v6 = [v4 rat];
    uint64_t v7 = *(void *)(a1 + 40);
    id v8 = [v4 isSatelliteSystem];
    id v9 = [*(id *)(a1 + 32) airplaneModeActive];
    uint64_t v10 = [v4 displayStatus];
    uint64_t v11 = [v5 deriveRAT:v6 stewieState:v7 isSatelliteSystem:v8 airplaneModeActive:v9 displayStatus:v10];

    uint64_t v12 = objc_msgSend(*(id *)(a1 + 32), "deriveDataIcon:stewieState:", objc_msgSend(v4, "dataConnectionType"), *(void *)(a1 + 40));
    uint64_t v13 = *(void **)(a1 + 32);
    uint64_t v14 = *(void *)(a1 + 48);
    uint64_t v15 = [v13 getNSString:"new_radio_access_technology"];
    v18[0] = v15;
    v19[0] = v11;
    unint64_t v16 = [*(id *)(a1 + 32) getNSString:"new_cellular_icon"];
    v18[1] = v16;
    v19[1] = v12;
    uint64_t v17 = +[NSDictionary dictionaryWithObjects:v19 forKeys:v18 count:2];
    [v13 buildAndSubmitCAPayload:v4 currentTime:v14 changedFields:v17];
  }
  [v4 setStartTime:*(void *)(a1 + 48)];
}

void sub_1000ECC44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000ECDB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1000ECDEC(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if ([v4 dataPreferred])
  {
    xpc_object_t v5 = *(void **)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v7 = [v5 getNSString:"new_baseband_operating_mode"];
    uint64_t v10 = v7;
    id v8 = [*(id *)(a1 + 32) getRadioStateString:*(void *)(a1 + 40)];
    uint64_t v11 = v8;
    id v9 = +[NSDictionary dictionaryWithObjects:&v11 forKeys:&v10 count:1];
    [v5 buildAndSubmitCAPayload:v4 currentTime:v6 changedFields:v9];
  }
  [v4 setStartTime:*(void *)(a1 + 48)];
}

void sub_1000ECEF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000ED034(_Unwind_Exception *exception_object)
{
}

void sub_1000ED04C(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if ([v4 dataPreferred])
  {
    xpc_object_t v5 = *(void **)(a1 + 32);
    uint64_t v6 = [v4 displayStatus];
    uint64_t v7 = [v5 deriveRegistrationStatus:v6 airplaneModeActive:*(unsigned __int8 *)(a1 + 48)];

    id v8 = *(void **)(a1 + 32);
    id v9 = [v4 rat];
    uint64_t v10 = [*(id *)(a1 + 32) stewieState];
    id v11 = [v4 isSatelliteSystem];
    int v12 = *(unsigned __int8 *)(a1 + 48);
    uint64_t v13 = [v4 displayStatus];
    uint64_t v14 = [v8 deriveRAT:v9 stewieState:v10 isSatelliteSystem:v11 airplaneModeActive:v12 != 0 displayStatus:v13];

    unint64_t v16 = *(void **)(a1 + 32);
    uint64_t v15 = *(void *)(a1 + 40);
    uint64_t v17 = [v16 getNSString:"new_registration_state"];
    v20[0] = v17;
    v21[0] = v7;
    uint64_t v18 = [*(id *)(a1 + 32) getNSString:"new_radio_access_technology"];
    v20[1] = v18;
    v21[1] = v14;
    int v19 = +[NSDictionary dictionaryWithObjects:v21 forKeys:v20 count:2];
    [v16 buildAndSubmitCAPayload:v4 currentTime:v15 changedFields:v19];
  }
  [v4 setStartTime:*(void *)(a1 + 40)];
}

void sub_1000ED214(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000ED498(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000ED4D0(uint64_t a1, void *a2, void *a3)
{
  id v7 = a2;
  id v5 = a3;
  if ([v5 dataPreferred]) {
    [*(id *)(a1 + 32) buildAndSubmitCAPayload:v5 currentTime:*(void *)(a1 + 48) changedFields:&__NSDictionary0__struct];
  }
  [v5 setStartTime:*(void *)(a1 + 48)];
  uint64_t v6 = [*(id *)(a1 + 40) uuid];
  objc_msgSend(v5, "setDataPreferred:", objc_msgSend(v7, "isEqual:", v6));
}

void sub_1000ED584(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1000EDAD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000EDF44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1000EE2F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1000EE5BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000EE950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1000EEA20(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 48), OS_LOG_TYPE_ERROR))
    {
      [*(id *)(a1 + 32) uuid];
      objc_claimAutoreleasedReturnValue();
      [v6 localizedDescription];
      objc_claimAutoreleasedReturnValue();
      sub_10014A6A8();
    }
  }
  else
  {
    id v7 = *(NSObject **)(qword_1001D8080 + 48);
    if (v5)
    {
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        [*(id *)(a1 + 32) uuid];
        objc_claimAutoreleasedReturnValue();
        sub_10014A664();
      }
      id v8 = [*(id *)(a1 + 40) queue];
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472;
      _OWORD v14[2] = sub_1000EEC5C;
      void v14[3] = &unk_1001BC7E8;
      v14[4] = *(void *)(a1 + 40);
      id v15 = v5;
      id v16 = *(id *)(a1 + 32);
      id v9 = *(id *)(a1 + 48);
      id v11 = *(void **)(a1 + 56);
      uint64_t v10 = *(void *)(a1 + 64);
      id v17 = v9;
      uint64_t v19 = v10;
      id v12 = v11;
      __int16 v21 = *(_WORD *)(a1 + 80);
      uint64_t v13 = *(void *)(a1 + 72);
      id v18 = v12;
      uint64_t v20 = v13;
      dispatch_async(v8, v14);
    }
    else if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      [*(id *)(a1 + 32) uuid];
      objc_claimAutoreleasedReturnValue();
      sub_10014A620();
    }
  }
}

void sub_1000EEC24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000EEC5C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  id v37 = 0;
  id v4 = [v2 extractCellInfo:v3 error:&v37];
  id v5 = v37;
  if (v5) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = v4 == 0;
  }
  if (v6)
  {
    id v7 = v5;
    id v8 = *(NSObject **)(qword_1001D8080 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = [*(id *)(a1 + 48) uuid];
      uint64_t v10 = [v7 localizedDescription];
      *(_DWORD *)long long buf = 138412546;
      unsigned __int8 v39 = v9;
      __int16 v40 = 2112;
      unsigned __int8 v41 = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "RatRetentionMetric:#N Error while extracting data from cell for context %@: %@", buf, 0x16u);
    }
    id v11 = [ExtractedCellInfo alloc];
    id v12 = [*(id *)(a1 + 32) getNSString:"Unknown"];
    uint64_t v13 = [*(id *)(a1 + 32) getNSString:"Unknown"];
    uint64_t v14 = [*(id *)(a1 + 32) getNSString:"Unknown"];
    id v15 = [(ExtractedCellInfo *)v11 init:v12 band:&off_1001C3BF8 frequencyRange:v13 nrnsaFrequencyRange:v14 bandwidth:&off_1001C3BF8 nrnsaBandwidth:&off_1001C3BF8 arfcn:&off_1001C3BF8 nrnsaArfcn:&off_1001C3BF8 gci:0];

    id v4 = v15;
  }
  unsigned __int8 v36 = objc_msgSend(*(id *)(a1 + 32), "CTCellularDataTechnologyToString:", objc_msgSend(*(id *)(a1 + 56), "dataBearerTechnology"));
  if (v36)
  {
    id v16 = [v4 gci];
    if (v16) {
      [v4 gci];
    }
    else {
    xpc_object_t v32 = [*(id *)(a1 + 32) getNSString:"unknown"];
    }

    id v17 = [RatRetentionState alloc];
    uint64_t v18 = *(void *)(a1 + 72);
    uint64_t v31 = [*(id *)(a1 + 64) registrationDisplayStatus];
    uint64_t v35 = [v4 rat];
    xpc_object_t v33 = [v4 band];
    unsigned __int8 v34 = [v4 arfcn];
    uint64_t v19 = [v4 nrnsaArfcn];
    uint64_t v20 = [v4 bandwidth];
    __int16 v21 = [v4 nrnsaBandwidth];
    xpc_object_t v22 = [v4 frequencyRange];
    int v23 = [v4 nrnsaFrequencyRange];
    int64x2_t v24 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [*(id *)(a1 + 48) slotID]);
    BYTE1(v30) = *(unsigned char *)(a1 + 89);
    LOBYTE(v30) = 0;
    LOBYTE(v29) = *(unsigned char *)(a1 + 88);
    id v25 = -[RatRetentionState init:displayStatus:rat:dataBearerTechnology:band:arfcn:nrnsaArfcn:bandwidth:nrnsaBandwidth:frequencyRange:nrnsaFrequencyRange:subsId:dataPreferred:lastKnownGci:isSatelliteSystem:isSatelliteProvisioned:dataConnectionType:](v17, "init:displayStatus:rat:dataBearerTechnology:band:arfcn:nrnsaArfcn:bandwidth:nrnsaBandwidth:frequencyRange:nrnsaFrequencyRange:subsId:dataPreferred:lastKnownGci:isSatelliteSystem:isSatelliteProvisioned:dataConnectionType:", v18, v31, v35, v36, v33, v34, v19, v20, v21, v22, v23, v24, v29, v32, v30, *(void *)(a1 + 80));

    uint64_t v26 = [*(id *)(a1 + 32) ctRelay];
    [v26 getSatelliteRegistrationStatus:*(void *)(a1 + 48) delegate:*(void *)(a1 + 32)];

    if (v25)
    {
      uint64_t v27 = [*(id *)(a1 + 32) contextUUIDToStateMap];
      uint64_t v28 = [*(id *)(a1 + 48) uuid];
      [v27 setObject:v25 forKey:v28];

      if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 48), OS_LOG_TYPE_DEBUG))
      {
        [*(id *)(a1 + 48) uuid];
        objc_claimAutoreleasedReturnValue();
        sub_10014A794();
      }
    }
    else if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 48), OS_LOG_TYPE_ERROR))
    {
      [*(id *)(a1 + 48) uuid];
      objc_claimAutoreleasedReturnValue();
      sub_10014A750();
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 48), OS_LOG_TYPE_ERROR))
  {
    [*(id *)(a1 + 56) dataBearerTechnology];
    [*(id *)(a1 + 48) uuid];
    objc_claimAutoreleasedReturnValue();
    sub_10014A6FC();
  }
}

void sub_1000EF118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25)
{
  _Unwind_Resume(a1);
}

void sub_1000EF364(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000EF578(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000EF6A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1000EF7E4(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&stru_1001D6738);

  _Unwind_Resume(a1);
}

id sub_1000EF8EC()
{
  return +[WISRatRetentionMetric getSharedInstance];
}

uint64_t sub_1000EF924(uint64_t result, uint64_t a2, int a3, float a4)
{
  *(float *)a2 = a4;
  *(_DWORD *)(a2 + 4) = a3;
  *(_WORD *)(a2 + 8) = 2112;
  *(void *)(a2 + 10) = result;
  return result;
}

uint64_t sub_1000EF93C()
{
  if ((byte_1001D6788 & 1) == 0)
  {
    byte_1001D6788 = 1;
    return __cxa_atexit((void (*)(void *))sub_100021D7C, &stru_1001D6738, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t *sub_1000EF978(uint64_t *a1)
{
  uint64_t v4 = a1[1];
  uint64_t v2 = a1 + 1;
  uint64_t v3 = v4;
  void *v2 = 0;
  if (v4) {
    sub_10005F658((uint64_t)v2, v3);
  }
  uint64_t v5 = *a1;
  *a1 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
  }
  return a1;
}

uint64_t sub_1000EF9E0(uint64_t *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  sub_1000E7CDC(a2, a3, (std::__shared_weak_count **)v15);
  uint64_t v9 = *(void *)v15;
  *(void *)id v15 = 0;
  uint64_t v10 = *a1;
  *a1 = v9;
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)v10 + 16))(v10);
    uint64_t v11 = *(void *)v15;
    *(void *)id v15 = 0;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 16))(v11);
    }
    uint64_t v9 = *a1;
  }
  id v12 = *(NSObject **)qword_1001D8080;
  BOOL v13 = os_log_type_enabled(*(os_log_t *)qword_1001D8080, OS_LOG_TYPE_DEFAULT);
  if (!v9)
  {
    if (v13)
    {
      *(_DWORD *)id v15 = 134217984;
      *(void *)&v15[4] = a3;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "config:#E Configuration did not parse correctly (%zd bytes)", v15, 0xCu);
    }
    operator new();
  }
  if (v13)
  {
    *(_DWORD *)id v15 = 134218240;
    *(void *)&v15[4] = a3;
    __int16 v16 = 1024;
    int v17 = a6;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "config:#N Config parsed (%zd bytes, type=%d)", v15, 0x12u);
    uint64_t v9 = *a1;
  }
  return sub_1000E8268(v9, a6);
}

void sub_1000EFBBC()
{
}

BOOL sub_1000EFBE8(void *a1)
{
  return *a1 != 0;
}

uint64_t sub_1000EFBF8(uint64_t a1)
{
  return *(void *)a1;
}

void *sub_1000EFC00@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (long long *)result[1];
  if (v2)
  {
    if (*((char *)v2 + 23) < 0)
    {
      return sub_1000173FC((unsigned char *)a2, *(void **)v2, *((void *)v2 + 1));
    }
    else
    {
      long long v3 = *v2;
      *(void *)(a2 + 16) = *((void *)v2 + 2);
      *(_OWORD *)a2 = v3;
    }
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  return result;
}

void sub_1000EFCE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000EFD94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000EFE14(_OWORD *a1@<X8>)
{
  ctu::DispatchTimerService::create();
  *a1 = v2;
}

void sub_1000EFE64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10000B678(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000EFE7C(void *a1, void *a2)
{
  *a1 = off_1001BC8A8;
  a1[1] = 0;
  long long v3 = (id *)(a1 + 1);
  id v4 = a2;
  objc_storeWeak(v3, v4);

  return a1;
}

void *sub_1000EFEE4(void *a1, void *a2)
{
  objc_initWeak(&location, a2);
  sub_1000EFE7C(a1, location);
  objc_destroyWeak(&location);
  return a1;
}

void sub_1000EFF2C(uint64_t a1, const void **a2, void **a3)
{
  int v6 = *((char *)a2 + 23);
  if (v6 < 0)
  {
    if (a2[1] != (const void *)59) {
      return;
    }
    id v7 = *a2;
  }
  else
  {
    id v7 = a2;
    if (v6 != 59) {
      return;
    }
  }
  if (!memcmp(v7, "com.apple.Baseband.cellularPowerLogBasebandPowerConsumption", 0x3BuLL))
  {
    id v8 = *(NSObject **)(qword_1001D8080 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
      sub_10014A8B8(a2, (v6 & 0x80) != 0, v8);
    }
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 8));
    if (WeakRetained)
    {
      uint64_t v10 = *a3;
      xpc_object_t object = v10;
      if (v10) {
        xpc_retain(v10);
      }
      else {
        xpc_object_t object = xpc_null_create();
      }
      id v22 = 0;
      uint64_t v11 = +[WISXPCUtils dictionaryFromPrimitivesXPCDict:&object error:&v22];
      id v12 = v22;
      xpc_release(object);
      xpc_object_t object = 0;
      if (v12 || !v11)
      {
        int v17 = *(NSObject **)(qword_1001D8080 + 48);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_10014A840((uint64_t)v12, v17);
        }
      }
      else
      {
        BOOL v13 = [v11 valueForKey:@"power_stats_component"];
        unsigned __int8 v14 = [v13 isEqualToString:@"OVERALL"];

        if (v14)
        {
          id v15 = [v11 valueForKey:@"duration_ms"];
          uint64_t v16 = (uint64_t)[v15 longLongValue];

          if (v16 < 21600001)
          {
            uint64_t v18 = [WeakRetained queue];
            v19[0] = _NSConcreteStackBlock;
            v19[1] = 3221225472;
            void v19[2] = sub_1000F01C8;
            v19[3] = &unk_1001B7948;
            id v20 = WeakRetained;
            id v21 = v11;
            dispatch_async(v18, v19);
          }
          else if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 48), OS_LOG_TYPE_DEBUG))
          {
            sub_10014A80C();
          }
        }
      }
    }
  }
}

void sub_1000F0184(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object)
{
  _Unwind_Resume(a1);
}

void sub_1000F01C8(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  id v2 = [*(id *)(a1 + 40) copy];
  objc_msgSend(v1, "handleBasebandPowerMetricWithPayload:");
}

void sub_1000F0218(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1000F05E4(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&stru_1001D66E0);
  objc_destroyWeak(v2);
  objc_destroyWeak((id *)(v3 - 112));

  _Unwind_Resume(a1);
}

void sub_1000F0680(uint64_t a1)
{
  if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 48), OS_LOG_TYPE_DEBUG)) {
    sub_10014A9B4();
  }
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v3 = WeakRetained;
  if (WeakRetained) {
    [WeakRetained handleChargingStateUpdate];
  }
}

void sub_1000F06E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1000F06F8(uint64_t a1)
{
  return [*(id *)(a1 + 32) handleChargingStateUpdate];
}

void sub_1000F07A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)WISPowerUsageMetricController;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1000F12F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,void *a27,void *a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34)
{
  _Unwind_Resume(a1);
}

id sub_1000F154C(uint64_t a1)
{
  return *(id *)(a1 + 32);
}

void sub_1000F16B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_1000F16EC(void *result, void *a2)
{
  uint64_t v2 = a2[1];
  *uint64_t result = *a2;
  result[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1000F1724(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  id v4 = (std::__shared_weak_count *)a1[1];
  *a1 = v3;
  a1[1] = v2;
  if (v4) {
    sub_10000B678(v4);
  }
}

WISPowerUsageMetricController **sub_1000F1844(WISPowerUsageMetricController **a1)
{
  *a1 = 0;
  uint64_t v2 = objc_alloc_init(WISPowerUsageMetricController);
  uint64_t v3 = *a1;
  *a1 = v2;

  return a1;
}

void sub_1000F1884(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *sub_1000F189C(id *a1)
{
  id v2 = *a1;
  *a1 = 0;

  return a1;
}

uint64_t sub_1000F18D4(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 8));

  return nullsub_15(a1);
}

void sub_1000F1910(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 8));
  nullsub_15(a1);

  operator delete();
}

void *sub_1000F1960@<X0>(id *a1@<X1>, void *a2@<X8>)
{
  id v4 = operator new(0x28uLL);
  uint64_t result = sub_1000F19BC(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000F19A8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F19BC(void *a1, id *location)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1001BC8E8;
  uint64_t v3 = a1 + 3;
  id WeakRetained = objc_loadWeakRetained(location);
  sub_1000EFEE4(v3, WeakRetained);

  return a1;
}

void sub_1000F1A28(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1001BC8E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000F1A48(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1001BC8E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1000F1A9C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_1000F1AC4()
{
  if ((byte_1001D6730 & 1) == 0)
  {
    byte_1001D6730 = 1;
    return __cxa_atexit((void (*)(void *))sub_10001F66C, &stru_1001D66E0, (void *)&_mh_execute_header);
  }
  return result;
}

void sub_1000F1D68(_Unwind_Exception *a1)
{
  int v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1000F2118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1000F227C(_Unwind_Exception *a1)
{
  uint64_t v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1000F24DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1000F26DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000F2920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1000F2AF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000F37D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27)
{
  _Unwind_Resume(a1);
}

id sub_1000F3AFC(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) isFMCongestionCell:*(void *)(a1 + 40) equalToCongestionCell:a2];
}

id sub_1000F3B0C(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) isFMCongestionCell:*(void *)(a1 + 40) equalToCongestionCell:a2];
}

id sub_1000F3B1C(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) isFMCongestionCell:*(void *)(a1 + 40) equalToCongestionCell:a2];
}

id sub_1000F3B2C(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) isFMCongestionCell:*(void *)(a1 + 40) equalToCongestionCell:a2];
}

void sub_1000F3D30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

BOOL sub_1000F3D84(uint64_t a1, void *a2)
{
  uint64_t v3 = [a2 objectID];
  id v4 = [*(id *)(a1 + 32) objectID];
  BOOL v5 = v3 == v4;

  return v5;
}

void sub_1000F3DD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000F4184(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000F464C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_1000F48A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000F4BFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_1000F4F20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000F5270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1000F55E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1000F5968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1000F5B88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1000F5C58()
{
  if (qword_1001D80A8) {
    (*(void (**)(uint64_t))(*(void *)qword_1001D80A8 + 8))(qword_1001D80A8);
  }
  if (qword_1001D80B0) {
    (*(void (**)(uint64_t))(*(void *)qword_1001D80B0 + 8))(qword_1001D80B0);
  }
  if (qword_1001D80B8) {
    (*(void (**)(uint64_t))(*(void *)qword_1001D80B8 + 8))(qword_1001D80B8);
  }
  if (qword_1001D80C0) {
    (*(void (**)(uint64_t))(*(void *)qword_1001D80C0 + 8))(qword_1001D80C0);
  }
  if (qword_1001D80C8) {
    (*(void (**)(uint64_t))(*(void *)qword_1001D80C8 + 8))(qword_1001D80C8);
  }
  if (qword_1001D80D0) {
    (*(void (**)(uint64_t))(*(void *)qword_1001D80D0 + 8))(qword_1001D80D0);
  }
  if (qword_1001D80D8) {
    (*(void (**)(uint64_t))(*(void *)qword_1001D80D8 + 8))(qword_1001D80D8);
  }
  if (qword_1001D80E0) {
    (*(void (**)(uint64_t))(*(void *)qword_1001D80E0 + 8))(qword_1001D80E0);
  }
  uint64_t result = qword_1001D80E8;
  if (qword_1001D80E8)
  {
    id v1 = *(uint64_t (**)(void))(*(void *)qword_1001D80E8 + 8);
    return v1();
  }
  return result;
}

void sub_1000F5E30(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
}

uint64_t sub_1000F6140(uint64_t result)
{
  *(void *)(result + 40) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(void *)uint64_t result = off_1001BCD48;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(_DWORD *)(result + 32) = 0;
  return result;
}

void sub_1000F6170()
{
  uint64_t v0 = qword_1001D80F0;
  __dmb(0xBu);
  if (v0 != 2)
  {
    v1[1] = sub_1000F5E30;
    char v2 = 0;
    wireless_diagnostics::google::protobuf::GoogleOnceInitImpl();
    wireless_diagnostics::google::protobuf::internal::FunctionClosure0::~FunctionClosure0((wireless_diagnostics::google::protobuf::internal::FunctionClosure0 *)v1);
  }
}

void sub_1000F61F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  wireless_diagnostics::google::protobuf::internal::FunctionClosure0::~FunctionClosure0((wireless_diagnostics::google::protobuf::internal::FunctionClosure0 *)va);
  _Unwind_Resume(a1);
}

void sub_1000F6208(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v14);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), *(_DWORD *)(a2 + 16) + a1[4]);
  if (*(int *)(a2 + 16) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*(void *)(a2 + 8) + 8 * v4);
      int v6 = a1[5];
      uint64_t v7 = (int)a1[4];
      if ((int)v7 >= v6)
      {
        if (v6 == a1[6])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), v6 + 1);
          int v6 = a1[5];
        }
        a1[5] = v6 + 1;
        operator new();
      }
      uint64_t v8 = *((void *)a1 + 1);
      a1[4] = v7 + 1;
      sub_1000F6B20(*(void *)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 16));
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 8), *(_DWORD *)(a2 + 40) + a1[10]);
  if (*(int *)(a2 + 40) >= 1)
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = *(void *)(*(void *)(a2 + 32) + 8 * v9);
      int v11 = a1[11];
      uint64_t v12 = (int)a1[10];
      if ((int)v12 >= v11)
      {
        if (v11 == a1[12])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 8), v11 + 1);
          int v11 = a1[11];
        }
        a1[11] = v11 + 1;
        operator new();
      }
      uint64_t v13 = *((void *)a1 + 4);
      a1[10] = v12 + 1;
      sub_1000F6B20(*(void *)(v13 + 8 * v12), v10);
      ++v9;
    }
    while (v9 < *(int *)(a2 + 40));
  }
}

void sub_1000F6468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1000F6480(uint64_t *a1)
{
  *a1 = (uint64_t)off_1001BC988;
  sub_1000F6170();
  sub_1000FB750(a1 + 4);
  sub_1000FB750(a1 + 1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite((wireless_diagnostics::google::protobuf::MessageLite *)a1);
}

void sub_1000F64F4(uint64_t *a1)
{
  sub_1000F6480(a1);

  operator delete();
}

void sub_1000F652C()
{
}

uint64_t sub_1000F6588(uint64_t a1)
{
  sub_1000FB6E0(a1 + 8);
  uint64_t result = sub_1000FB6E0(a1 + 32);
  *(_DWORD *)(a1 + 60) = 0;
  return result;
}

uint64_t sub_1000F65BC(int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2);
  int v6 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 8);
  while (1)
  {
    while (1)
    {
      while (1)
      {
LABEL_2:
        uint64_t v7 = (char *)*((void *)this + 1);
        if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
        {
          unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          unint64_t TagFallback = *v7;
          *((_DWORD *)this + 8) = TagFallback;
          *((void *)this + 1) = v7 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v9 = TagFallback & 7;
        if (v9 != 2) {
          goto LABEL_30;
        }
        while (1)
        {
          int v10 = a1[5];
          uint64_t v11 = a1[4];
          if ((int)v11 >= v10)
          {
            if (v10 == a1[6])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v10 + 1);
              int v10 = a1[5];
            }
            a1[5] = v10 + 1;
            operator new();
          }
          uint64_t v12 = *((void *)a1 + 1);
          a1[4] = v11 + 1;
          uint64_t v13 = *(void *)(v12 + 8 * v11);
          unsigned int v37 = 0;
          unsigned __int8 v14 = (char *)*((void *)this + 1);
          if ((unint64_t)v14 >= *((void *)this + 2) || *v14 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v37))return 0; {
          }
            }
          else
          {
            unsigned int v37 = *v14;
            *((void *)this + 1) = v14 + 1;
          }
          int v15 = *((_DWORD *)this + 14);
          int v16 = *((_DWORD *)this + 15);
          *((_DWORD *)this + 14) = v15 + 1;
          if (v15 >= v16) {
            return 0;
          }
          int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v37);
          if (!sub_1000F6F90(v13, this, v18) || !*((unsigned char *)this + 36)) {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v17);
          int v19 = *((_DWORD *)this + 14);
          BOOL v20 = __OFSUB__(v19, 1);
          int v21 = v19 - 1;
          if (v21 < 0 == v20) {
            *((_DWORD *)this + 14) = v21;
          }
          id v22 = (unsigned char *)*((void *)this + 1);
          if ((unint64_t)v22 >= *((void *)this + 2)) {
            break;
          }
          int v23 = *v22;
          if (v23 != 10)
          {
            if (v23 != 18) {
              goto LABEL_2;
            }
            goto LABEL_34;
          }
          *((void *)this + 1) = v22 + 1;
        }
      }
      if (TagFallback >> 3 != 2) {
        break;
      }
      int v9 = TagFallback & 7;
      if (v9 != 2) {
        goto LABEL_30;
      }
      while (1)
      {
        int v24 = a1[11];
        uint64_t v25 = a1[10];
        if ((int)v25 >= v24)
        {
          if (v24 == a1[12])
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v6, v24 + 1);
            int v24 = a1[11];
          }
          a1[11] = v24 + 1;
          operator new();
        }
        uint64_t v26 = *((void *)a1 + 4);
        a1[10] = v25 + 1;
        uint64_t v27 = *(void *)(v26 + 8 * v25);
        unsigned int v38 = 0;
        uint64_t v28 = (char *)*((void *)this + 1);
        if ((unint64_t)v28 >= *((void *)this + 2) || *v28 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v38))return 0; {
        }
          }
        else
        {
          unsigned int v38 = *v28;
          *((void *)this + 1) = v28 + 1;
        }
        int v29 = *((_DWORD *)this + 14);
        int v30 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v29 + 1;
        if (v29 >= v30) {
          return 0;
        }
        int v31 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v38);
        if (!sub_1000F6F90(v27, this, v32) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v31);
        int v33 = *((_DWORD *)this + 14);
        BOOL v20 = __OFSUB__(v33, 1);
        int v34 = v33 - 1;
        if (v34 < 0 == v20) {
          *((_DWORD *)this + 14) = v34;
        }
        id v22 = (unsigned char *)*((void *)this + 1);
        uint64_t v35 = (unsigned char *)*((void *)this + 2);
        if (v22 >= v35 || *v22 != 18) {
          break;
        }
LABEL_34:
        *((void *)this + 1) = v22 + 1;
      }
      if (v22 == v35 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    int v9 = TagFallback & 7;
LABEL_30:
    if (v9 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_1000F699C(uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v6 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(*(void *)(v5 + 8) + 8 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  if (*(int *)(v5 + 40) >= 1)
  {
    uint64_t v7 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(void *)(*(void *)(v5 + 32) + 8 * v7++), a2, a4);
    while (v7 < *(int *)(v5 + 40));
  }
  return result;
}

uint64_t sub_1000F6A30(uint64_t a1, unsigned int a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (v3 >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1000F7924(*(void *)(*(void *)(a1 + 8) + 8 * v4), a2);
      int v6 = (int)v5;
      if (v5 >= 0x80) {
        int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
      }
      else {
        int v7 = 1;
      }
      v3 += v6 + v7;
      ++v4;
    }
    while (v4 < *(int *)(a1 + 16));
  }
  int v8 = *(_DWORD *)(a1 + 40);
  uint64_t v9 = (v8 + v3);
  if (v8 >= 1)
  {
    uint64_t v10 = 0;
    do
    {
      uint64_t v11 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1000F7924(*(void *)(*(void *)(a1 + 32) + 8 * v10), a2);
      int v12 = (int)v11;
      if (v11 >= 0x80) {
        int v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11, a2);
      }
      else {
        int v13 = 1;
      }
      uint64_t v9 = (v12 + v9 + v13);
      ++v10;
    }
    while (v10 < *(int *)(a1 + 40));
  }
  *(_DWORD *)(a1 + 56) = v9;
  return v9;
}

uint64_t sub_1000F6B08()
{
  return 1;
}

void *sub_1000F6B10@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.CellPerformanceTile");
}

void sub_1000F6B20(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v20);
  }
  int v4 = *(_DWORD *)(a2 + 72);
  if (!(_BYTE)v4) {
    goto LABEL_13;
  }
  if (v4)
  {
    int v7 = *(const std::string **)(a2 + 8);
    *(_DWORD *)(a1 + 72) |= 1u;
    int v8 = *(std::string **)(a1 + 8);
    if (v8 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v8, v7);
    int v4 = *(_DWORD *)(a2 + 72);
    if ((v4 & 2) == 0)
    {
LABEL_6:
      if ((v4 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_26;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_6;
  }
  int v9 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 72) |= 2u;
  *(_DWORD *)(a1 + 16) = v9;
  int v4 = *(_DWORD *)(a2 + 72);
  if ((v4 & 4) == 0)
  {
LABEL_7:
    if ((v4 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_27;
  }
LABEL_26:
  int v10 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 72) |= 4u;
  *(_DWORD *)(a1 + 20) = v10;
  int v4 = *(_DWORD *)(a2 + 72);
  if ((v4 & 8) == 0)
  {
LABEL_8:
    if ((v4 & 0x10) == 0) {
      goto LABEL_9;
    }
    goto LABEL_28;
  }
LABEL_27:
  int v11 = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 72) |= 8u;
  *(_DWORD *)(a1 + 24) = v11;
  int v4 = *(_DWORD *)(a2 + 72);
  if ((v4 & 0x10) == 0)
  {
LABEL_9:
    if ((v4 & 0x20) == 0) {
      goto LABEL_10;
    }
LABEL_29:
    int v13 = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 72) |= 0x20u;
    *(_DWORD *)(a1 + 32) = v13;
    int v4 = *(_DWORD *)(a2 + 72);
    if ((v4 & 0x40) == 0)
    {
LABEL_11:
      if ((v4 & 0x80) == 0) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
    goto LABEL_30;
  }
LABEL_28:
  int v12 = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a1 + 72) |= 0x10u;
  *(_DWORD *)(a1 + 28) = v12;
  int v4 = *(_DWORD *)(a2 + 72);
  if ((v4 & 0x20) != 0) {
    goto LABEL_29;
  }
LABEL_10:
  if ((v4 & 0x40) == 0) {
    goto LABEL_11;
  }
LABEL_30:
  int v14 = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 72) |= 0x40u;
  *(_DWORD *)(a1 + 36) = v14;
  int v4 = *(_DWORD *)(a2 + 72);
  if ((v4 & 0x80) != 0)
  {
LABEL_12:
    int v5 = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(a1 + 72) |= 0x80u;
    *(_DWORD *)(a1 + 40) = v5;
    int v4 = *(_DWORD *)(a2 + 72);
  }
LABEL_13:
  if ((v4 & 0xFF00) == 0) {
    return;
  }
  if ((v4 & 0x100) != 0)
  {
    int v15 = *(_DWORD *)(a2 + 44);
    *(_DWORD *)(a1 + 72) |= 0x100u;
    *(_DWORD *)(a1 + 44) = v15;
    int v4 = *(_DWORD *)(a2 + 72);
    if ((v4 & 0x200) == 0)
    {
LABEL_16:
      if ((v4 & 0x400) == 0) {
        goto LABEL_17;
      }
      goto LABEL_34;
    }
  }
  else if ((v4 & 0x200) == 0)
  {
    goto LABEL_16;
  }
  int v16 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 72) |= 0x200u;
  *(_DWORD *)(a1 + 48) = v16;
  int v4 = *(_DWORD *)(a2 + 72);
  if ((v4 & 0x400) == 0)
  {
LABEL_17:
    if ((v4 & 0x800) == 0) {
      goto LABEL_18;
    }
    goto LABEL_35;
  }
LABEL_34:
  int v17 = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a1 + 72) |= 0x400u;
  *(_DWORD *)(a1 + 52) = v17;
  int v4 = *(_DWORD *)(a2 + 72);
  if ((v4 & 0x800) == 0)
  {
LABEL_18:
    if ((v4 & 0x1000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_36;
  }
LABEL_35:
  int v18 = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 72) |= 0x800u;
  *(_DWORD *)(a1 + 56) = v18;
  int v4 = *(_DWORD *)(a2 + 72);
  if ((v4 & 0x1000) == 0)
  {
LABEL_19:
    if ((v4 & 0x2000) == 0) {
      return;
    }
    goto LABEL_20;
  }
LABEL_36:
  int v19 = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a1 + 72) |= 0x1000u;
  *(_DWORD *)(a1 + 60) = v19;
  if ((*(_DWORD *)(a2 + 72) & 0x2000) == 0) {
    return;
  }
LABEL_20:
  int v6 = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 72) |= 0x2000u;
  *(_DWORD *)(a1 + 64) = v6;
}

void sub_1000F6DA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1000F6DBC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1001BCA00;
  sub_1000F6E14((uint64_t)a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1000F6E14(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }

  sub_1000F6170();
}

void sub_1000F6E84(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_1000F6DBC(a1);

  operator delete();
}

void sub_1000F6EBC()
{
}

uint64_t sub_1000F6F20(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 72);
  if ((_BYTE)v1)
  {
    if (v1)
    {
      uint64_t v2 = *(void *)(result + 8);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(_DWORD *)(result + 40) = 0;
    *(void *)(result + 32) = 0;
    int v1 = *(_DWORD *)(result + 72);
  }
  if ((v1 & 0xFF00) != 0)
  {
    *(void *)(result + 52) = 0;
    *(void *)(result + 44) = 0;
    *(void *)(result + 60) = 0;
  }
  *(_DWORD *)(result + 72) = 0;
  return result;
}

uint64_t sub_1000F6F90(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  size_t v49 = (unsigned int *)(a1 + 16);
  int v5 = (unsigned int *)(a1 + 20);
  int v6 = (unsigned int *)(a1 + 24);
  int v7 = (unsigned int *)(a1 + 36);
  int v8 = (unsigned int *)(a1 + 40);
  int v9 = (unsigned int *)(a1 + 44);
  int v10 = (unsigned int *)(a1 + 48);
  int v11 = (unsigned int *)(a1 + 52);
  int v12 = (unsigned int *)(a1 + 64);
  while (2)
  {
    int v13 = (char *)*((void *)this + 1);
    if ((unint64_t)v13 >= *((void *)this + 2) || *v13 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v13;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v13 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v15 = TagFallback & 7;
        if (v15 != 2) {
          goto LABEL_44;
        }
        *(_DWORD *)(a1 + 72) |= 1u;
        if (*(_UNKNOWN **)(a1 + 8) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (result)
        {
          int v18 = (unsigned char *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
          if ((unint64_t)v18 < v17 && *v18 == 16)
          {
            int v19 = v18 + 1;
            *((void *)this + 1) = v19;
            goto LABEL_18;
          }
          continue;
        }
        return result;
      case 2u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        int v19 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
LABEL_18:
        if ((unint64_t)v19 < v17 && (*v19 & 0x80000000) == 0)
        {
          unsigned int *v49 = *v19;
          BOOL v20 = v19 + 1;
          *((void *)this + 1) = v20;
LABEL_50:
          *(_DWORD *)(a1 + 72) |= 2u;
          if ((unint64_t)v20 < v17 && *v20 == 24)
          {
            int v21 = v20 + 1;
            *((void *)this + 1) = v21;
            goto LABEL_53;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v49);
        if (result)
        {
          BOOL v20 = (unsigned char *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
          goto LABEL_50;
        }
        break;
      case 3u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        int v21 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
LABEL_53:
        if ((unint64_t)v21 >= v17 || *v21 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
          if (!result) {
            return result;
          }
          int v33 = (unsigned char *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
        }
        else
        {
          *int v5 = *v21;
          int v33 = v21 + 1;
          *((void *)this + 1) = v33;
        }
        *(_DWORD *)(a1 + 72) |= 4u;
        if ((unint64_t)v33 >= v17 || *v33 != 32) {
          continue;
        }
        id v22 = v33 + 1;
        *((void *)this + 1) = v22;
LABEL_61:
        if ((unint64_t)v22 >= v17 || *v22 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!result) {
            return result;
          }
          int v34 = (unsigned char *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
        }
        else
        {
          *int v6 = *v22;
          int v34 = v22 + 1;
          *((void *)this + 1) = v34;
        }
        *(_DWORD *)(a1 + 72) |= 8u;
        if ((unint64_t)v34 >= v17 || *v34 != 40) {
          continue;
        }
        int v23 = v34 + 1;
        *((void *)this + 1) = v23;
LABEL_69:
        unsigned int v50 = 0;
        if ((unint64_t)v23 >= v17 || *v23 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v50);
          if (!result) {
            return result;
          }
          unsigned int v35 = v50;
          unsigned __int8 v36 = (unsigned char *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
        }
        else
        {
          unsigned int v35 = *v23;
          unsigned __int8 v36 = v23 + 1;
          *((void *)this + 1) = v36;
        }
        *(_DWORD *)(a1 + 28) = -(v35 & 1) ^ (v35 >> 1);
        *(_DWORD *)(a1 + 72) |= 0x10u;
        if ((unint64_t)v36 >= v17 || *v36 != 48) {
          continue;
        }
        int v24 = v36 + 1;
        *((void *)this + 1) = v24;
LABEL_77:
        unsigned int v50 = 0;
        if ((unint64_t)v24 >= v17 || *v24 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v50);
          if (!result) {
            return result;
          }
          unsigned int v37 = v50;
          unsigned int v38 = (unsigned char *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
        }
        else
        {
          unsigned int v37 = *v24;
          unsigned int v38 = v24 + 1;
          *((void *)this + 1) = v38;
        }
        *(_DWORD *)(a1 + 32) = v37;
        *(_DWORD *)(a1 + 72) |= 0x20u;
        if ((unint64_t)v38 >= v17 || *v38 != 56) {
          continue;
        }
        uint64_t v25 = v38 + 1;
        *((void *)this + 1) = v25;
LABEL_85:
        if ((unint64_t)v25 >= v17 || *v25 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!result) {
            return result;
          }
          unsigned __int8 v39 = (unsigned char *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v7 = *v25;
          unsigned __int8 v39 = v25 + 1;
          *((void *)this + 1) = v39;
        }
        *(_DWORD *)(a1 + 72) |= 0x40u;
        if ((unint64_t)v39 >= v17 || *v39 != 64) {
          continue;
        }
        uint64_t v26 = v39 + 1;
        *((void *)this + 1) = v26;
LABEL_93:
        if ((unint64_t)v26 >= v17 || *v26 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v8);
          if (!result) {
            return result;
          }
          __int16 v40 = (unsigned char *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v8 = *v26;
          __int16 v40 = v26 + 1;
          *((void *)this + 1) = v40;
        }
        *(_DWORD *)(a1 + 72) |= 0x80u;
        if ((unint64_t)v40 >= v17 || *v40 != 72) {
          continue;
        }
        uint64_t v27 = v40 + 1;
        *((void *)this + 1) = v27;
LABEL_101:
        if ((unint64_t)v27 >= v17 || *v27 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v9);
          if (!result) {
            return result;
          }
          unsigned __int8 v41 = (unsigned char *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v9 = *v27;
          unsigned __int8 v41 = v27 + 1;
          *((void *)this + 1) = v41;
        }
        *(_DWORD *)(a1 + 72) |= 0x100u;
        if ((unint64_t)v41 >= v17 || *v41 != 80) {
          continue;
        }
        uint64_t v28 = v41 + 1;
        *((void *)this + 1) = v28;
LABEL_109:
        if ((unint64_t)v28 >= v17 || *v28 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v10);
          if (!result) {
            return result;
          }
          int v42 = (unsigned char *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
        }
        else
        {
          *int v10 = *v28;
          int v42 = v28 + 1;
          *((void *)this + 1) = v42;
        }
        *(_DWORD *)(a1 + 72) |= 0x200u;
        if ((unint64_t)v42 >= v17 || *v42 != 88) {
          continue;
        }
        int v29 = v42 + 1;
        *((void *)this + 1) = v29;
LABEL_117:
        if ((unint64_t)v29 >= v17 || *v29 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v11);
          if (!result) {
            return result;
          }
          __int16 v43 = (unsigned char *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
        }
        else
        {
          *int v11 = *v29;
          __int16 v43 = v29 + 1;
          *((void *)this + 1) = v43;
        }
        *(_DWORD *)(a1 + 72) |= 0x400u;
        if ((unint64_t)v43 >= v17 || *v43 != 96) {
          continue;
        }
        int v30 = v43 + 1;
        *((void *)this + 1) = v30;
LABEL_125:
        unsigned int v50 = 0;
        if ((unint64_t)v30 >= v17 || *v30 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v50);
          if (!result) {
            return result;
          }
          unsigned int v44 = v50;
          unsigned int v45 = (unsigned char *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
        }
        else
        {
          unsigned int v44 = *v30;
          unsigned int v45 = v30 + 1;
          *((void *)this + 1) = v45;
        }
        *(_DWORD *)(a1 + 56) = -(v44 & 1) ^ (v44 >> 1);
        *(_DWORD *)(a1 + 72) |= 0x800u;
        if ((unint64_t)v45 >= v17 || *v45 != 104) {
          continue;
        }
        int v31 = v45 + 1;
        *((void *)this + 1) = v31;
LABEL_133:
        unsigned int v50 = 0;
        if ((unint64_t)v31 >= v17 || *v31 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v50);
          if (!result) {
            return result;
          }
          unsigned int v46 = v50;
          unsigned __int8 v47 = (unsigned char *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
        }
        else
        {
          unsigned int v46 = *v31;
          unsigned __int8 v47 = v31 + 1;
          *((void *)this + 1) = v47;
        }
        *(_DWORD *)(a1 + 60) = -(v46 & 1) ^ (v46 >> 1);
        *(_DWORD *)(a1 + 72) |= 0x1000u;
        if ((unint64_t)v47 >= v17 || *v47 != 112) {
          continue;
        }
        unsigned int v32 = v47 + 1;
        *((void *)this + 1) = v32;
LABEL_141:
        if ((unint64_t)v32 >= v17 || *v32 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v12);
          if (!result) {
            return result;
          }
          long long v48 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
        }
        else
        {
          *int v12 = *v32;
          long long v48 = (unsigned __int8 *)(v32 + 1);
          *((void *)this + 1) = v48;
        }
        *(_DWORD *)(a1 + 72) |= 0x2000u;
        if (v48 != (unsigned __int8 *)v17 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10)) {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      case 4u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        id v22 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        goto LABEL_61;
      case 5u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        int v23 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        goto LABEL_69;
      case 6u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        int v24 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        goto LABEL_77;
      case 7u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        uint64_t v25 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        goto LABEL_85;
      case 8u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        uint64_t v26 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        goto LABEL_93;
      case 9u:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        uint64_t v27 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        goto LABEL_101;
      case 0xAu:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        uint64_t v28 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        goto LABEL_109;
      case 0xBu:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        int v29 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        goto LABEL_117;
      case 0xCu:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        int v30 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        goto LABEL_125;
      case 0xDu:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        int v31 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        goto LABEL_133;
      case 0xEu:
        int v15 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        unsigned int v32 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        goto LABEL_141;
      default:
        int v15 = TagFallback & 7;
LABEL_44:
        if (v15 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

int *sub_1000F7764(int *result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v5 = result;
  int v6 = result[18];
  if (v6)
  {
    uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
    int v6 = v5[18];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_18;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v5[4], a2, a4);
  int v6 = v5[18];
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_19;
  }
LABEL_18:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v5[5], a2, a4);
  int v6 = v5[18];
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_20;
  }
LABEL_19:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v5[6], a2, a4);
  int v6 = v5[18];
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_21;
  }
LABEL_20:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteSInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v5[7], a2, a4);
  int v6 = v5[18];
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_22;
  }
LABEL_21:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v5[8], a2, a4);
  int v6 = v5[18];
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_23;
  }
LABEL_22:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, v5[9], a2, a4);
  int v6 = v5[18];
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_24;
  }
LABEL_23:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8, v5[10], a2, a4);
  int v6 = v5[18];
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0) {
      goto LABEL_11;
    }
    goto LABEL_25;
  }
LABEL_24:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, v5[11], a2, a4);
  int v6 = v5[18];
  if ((v6 & 0x200) == 0)
  {
LABEL_11:
    if ((v6 & 0x400) == 0) {
      goto LABEL_12;
    }
    goto LABEL_26;
  }
LABEL_25:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, v5[12], a2, a4);
  int v6 = v5[18];
  if ((v6 & 0x400) == 0)
  {
LABEL_12:
    if ((v6 & 0x800) == 0) {
      goto LABEL_13;
    }
    goto LABEL_27;
  }
LABEL_26:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, v5[13], a2, a4);
  int v6 = v5[18];
  if ((v6 & 0x800) == 0)
  {
LABEL_13:
    if ((v6 & 0x1000) == 0) {
      goto LABEL_14;
    }
LABEL_28:
    uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteSInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xD, v5[15], a2, a4);
    if ((v5[18] & 0x2000) == 0) {
      return result;
    }
    goto LABEL_29;
  }
LABEL_27:
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteSInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xC, v5[14], a2, a4);
  int v6 = v5[18];
  if ((v6 & 0x1000) != 0) {
    goto LABEL_28;
  }
LABEL_14:
  if ((v6 & 0x2000) == 0) {
    return result;
  }
LABEL_29:
  int v7 = v5[16];

  return (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xE, v7, a2, a4);
}

uint64_t sub_1000F7924(uint64_t a1, unsigned int a2)
{
  int v3 = *(_DWORD *)(a1 + 72);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_52;
  }
  if ((v3 & 1) == 0)
  {
    uint64_t v4 = 0;
    if ((v3 & 2) == 0) {
      goto LABEL_19;
    }
    goto LABEL_15;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  int v6 = *(unsigned __int8 *)(v5 + 23);
  char v7 = v6;
  uint64_t v8 = *(void *)(v5 + 8);
  if ((v6 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 >= 0x80)
  {
    int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9, a2);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v8 = *(void *)(v5 + 8);
    int v3 = *(_DWORD *)(a1 + 72);
    char v7 = *(unsigned char *)(v5 + 23);
  }
  else
  {
    int v10 = 1;
  }
  if (v7 < 0) {
    int v6 = v8;
  }
  uint64_t v4 = (v10 + v6 + 1);
  if ((v3 & 2) != 0)
  {
LABEL_15:
    int v11 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if (v11 >= 0x80)
    {
      int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11, a2);
      int v3 = *(_DWORD *)(a1 + 72);
    }
    else
    {
      int v12 = 1;
    }
    uint64_t v4 = (v4 + v12 + 1);
  }
LABEL_19:
  if ((v3 & 4) != 0)
  {
    int v13 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 20);
    if (v13 >= 0x80)
    {
      int v14 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v13, a2);
      int v3 = *(_DWORD *)(a1 + 72);
    }
    else
    {
      int v14 = 1;
    }
    uint64_t v4 = (v4 + v14 + 1);
    if ((v3 & 8) == 0)
    {
LABEL_21:
      if ((v3 & 0x10) == 0) {
        goto LABEL_22;
      }
      goto LABEL_34;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_21;
  }
  int v15 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 24);
  if (v15 >= 0x80)
  {
    int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v15, a2);
    int v3 = *(_DWORD *)(a1 + 72);
  }
  else
  {
    int v16 = 1;
  }
  uint64_t v4 = (v4 + v16 + 1);
  if ((v3 & 0x10) == 0)
  {
LABEL_22:
    if ((v3 & 0x20) == 0) {
      goto LABEL_23;
    }
    goto LABEL_38;
  }
LABEL_34:
  unint64_t v17 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)((2 * *(_DWORD *)(a1 + 28)) ^ (*(int *)(a1 + 28) >> 31));
  if (v17 >= 0x80)
  {
    int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v17, a2);
    int v3 = *(_DWORD *)(a1 + 72);
  }
  else
  {
    int v18 = 1;
  }
  uint64_t v4 = (v4 + v18 + 1);
  if ((v3 & 0x20) == 0)
  {
LABEL_23:
    if ((v3 & 0x40) == 0) {
      goto LABEL_24;
    }
    goto LABEL_44;
  }
LABEL_38:
  int v19 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 32);
  if ((v19 & 0x80000000) != 0)
  {
    int v20 = 10;
  }
  else if (v19 >= 0x80)
  {
    int v20 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v19, a2);
    int v3 = *(_DWORD *)(a1 + 72);
  }
  else
  {
    int v20 = 1;
  }
  uint64_t v4 = (v4 + v20 + 1);
  if ((v3 & 0x40) == 0)
  {
LABEL_24:
    if ((v3 & 0x80) == 0) {
      goto LABEL_52;
    }
    goto LABEL_48;
  }
LABEL_44:
  int v21 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 36);
  if (v21 >= 0x80)
  {
    int v22 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v21, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 72);
  }
  else
  {
    int v22 = 2;
  }
  uint64_t v4 = (v22 + v4);
  if ((v3 & 0x80) != 0)
  {
LABEL_48:
    int v23 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 40);
    if (v23 >= 0x80)
    {
      int v24 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v23, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 72);
    }
    else
    {
      int v24 = 2;
    }
    uint64_t v4 = (v24 + v4);
  }
LABEL_52:
  if ((v3 & 0xFF00) == 0) {
    goto LABEL_84;
  }
  if ((v3 & 0x100) != 0)
  {
    uint64_t v25 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 44);
    if (v25 >= 0x80)
    {
      int v26 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v25, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 72);
    }
    else
    {
      int v26 = 2;
    }
    uint64_t v4 = (v26 + v4);
    if ((v3 & 0x200) == 0)
    {
LABEL_55:
      if ((v3 & 0x400) == 0) {
        goto LABEL_56;
      }
      goto LABEL_68;
    }
  }
  else if ((v3 & 0x200) == 0)
  {
    goto LABEL_55;
  }
  uint64_t v27 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 48);
  if (v27 >= 0x80)
  {
    int v28 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v27, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 72);
  }
  else
  {
    int v28 = 2;
  }
  uint64_t v4 = (v28 + v4);
  if ((v3 & 0x400) == 0)
  {
LABEL_56:
    if ((v3 & 0x800) == 0) {
      goto LABEL_57;
    }
    goto LABEL_72;
  }
LABEL_68:
  int v29 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 52);
  if (v29 >= 0x80)
  {
    int v30 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v29, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 72);
  }
  else
  {
    int v30 = 2;
  }
  uint64_t v4 = (v30 + v4);
  if ((v3 & 0x800) == 0)
  {
LABEL_57:
    if ((v3 & 0x1000) == 0) {
      goto LABEL_58;
    }
    goto LABEL_76;
  }
LABEL_72:
  int v31 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)((2 * *(_DWORD *)(a1 + 56)) ^ (*(int *)(a1 + 56) >> 31));
  if (v31 >= 0x80)
  {
    int v32 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v31, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 72);
  }
  else
  {
    int v32 = 2;
  }
  uint64_t v4 = (v32 + v4);
  if ((v3 & 0x1000) == 0)
  {
LABEL_58:
    if ((v3 & 0x2000) == 0) {
      goto LABEL_84;
    }
    goto LABEL_80;
  }
LABEL_76:
  int v33 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)((2 * *(_DWORD *)(a1 + 60)) ^ (*(int *)(a1 + 60) >> 31));
  if (v33 >= 0x80)
  {
    int v34 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v33, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 72);
  }
  else
  {
    int v34 = 2;
  }
  uint64_t v4 = (v34 + v4);
  if ((v3 & 0x2000) != 0)
  {
LABEL_80:
    unsigned int v35 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 64);
    if (v35 >= 0x80) {
      int v36 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v35, a2) + 1;
    }
    else {
      int v36 = 2;
    }
    uint64_t v4 = (v36 + v4);
  }
LABEL_84:
  *(_DWORD *)(a1 + 68) = v4;
  return v4;
}

uint64_t sub_1000F7C24()
{
  return 1;
}

void *sub_1000F7C2C@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.CellPerformanceMetrics");
}

void sub_1000F7C3C(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 24);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 24))
    {
      int v6 = *(_DWORD *)(a2 + 8);
      a1[6] |= 1u;
      a1[2] = v6;
      int v4 = *(_DWORD *)(a2 + 24);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          return;
        }
        goto LABEL_7;
      }
    }
    else if ((*(unsigned char *)(a2 + 24) & 2) == 0)
    {
      goto LABEL_6;
    }
    int v7 = *(_DWORD *)(a2 + 12);
    a1[6] |= 2u;
    a1[3] = v7;
    if ((*(_DWORD *)(a2 + 24) & 4) == 0) {
      return;
    }
LABEL_7:
    int v5 = *(_DWORD *)(a2 + 16);
    a1[6] |= 4u;
    a1[4] = v5;
  }
}

void sub_1000F7D10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1000F7D28(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1001BCA78;
  sub_1000F6170();

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1000F7D84(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_1000F7D28(a1);

  operator delete();
}

void sub_1000F7DBC()
{
}

uint64_t sub_1000F7E0C(uint64_t result)
{
  if (*(unsigned char *)(result + 24))
  {
    *(void *)(result + 8) = 0;
    *(_DWORD *)(result + 16) = 0;
  }
  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_1000F7E24(unsigned int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = a1 + 2;
  int v6 = a1 + 3;
  int v7 = a1 + 4;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (char *)*((void *)this + 1);
        if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
        {
          unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          unint64_t TagFallback = *v8;
          *((_DWORD *)this + 8) = TagFallback;
          *((void *)this + 1) = v8 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        unsigned int v10 = TagFallback >> 3;
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        int v14 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        if ((unint64_t)v14 >= v12 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
          if (!result) {
            return result;
          }
          int v15 = (unsigned char *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          *int v5 = *v14;
          int v15 = v14 + 1;
          *((void *)this + 1) = v15;
        }
        a1[6] |= 1u;
        if ((unint64_t)v15 < v12 && *v15 == 16)
        {
          int v16 = v15 + 1;
          *((void *)this + 1) = v16;
          goto LABEL_27;
        }
      }
      if (v10 != 2) {
        break;
      }
      int v11 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_19;
      }
      int v16 = (char *)*((void *)this + 1);
      unint64_t v12 = *((void *)this + 2);
LABEL_27:
      if ((unint64_t)v16 >= v12 || *v16 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
        if (!result) {
          return result;
        }
        unint64_t v17 = (unsigned char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
      }
      else
      {
        *int v6 = *v16;
        unint64_t v17 = v16 + 1;
        *((void *)this + 1) = v17;
      }
      a1[6] |= 2u;
      if ((unint64_t)v17 < v12 && *v17 == 24)
      {
        int v13 = v17 + 1;
        *((void *)this + 1) = v13;
LABEL_35:
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!result) {
            return result;
          }
          int v18 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v7 = *v13;
          int v18 = (unsigned __int8 *)(v13 + 1);
          *((void *)this + 1) = v18;
        }
        a1[6] |= 4u;
        if (v18 == (unsigned __int8 *)v12
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (v10 == 3)
    {
      int v11 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v13 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_35;
      }
    }
    else
    {
      int v11 = TagFallback & 7;
    }
LABEL_19:
    if (v11 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

int *sub_1000F8048(int *result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v5 = result;
  int v6 = result[6];
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v5[3], a2, a4);
    if ((v5[6] & 4) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, result[2], a2, a4);
  int v6 = v5[6];
  if ((v6 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v6 & 4) == 0) {
    return result;
  }
LABEL_7:
  int v7 = v5[4];

  return (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v7, a2, a4);
}

uint64_t sub_1000F80D4(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 24);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_19;
  }
  if (*(unsigned char *)(a1 + 24))
  {
    int v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if (v5 >= 0x80)
    {
      uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 24);
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 24) & 2) == 0) {
      goto LABEL_14;
    }
  }
  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
  if (v6 >= 0x80)
  {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 24);
  }
  else
  {
    int v7 = 2;
  }
  uint64_t v4 = (v7 + v4);
LABEL_14:
  if ((v3 & 4) != 0)
  {
    uint64_t v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if (v8 >= 0x80) {
      int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2) + 1;
    }
    else {
      int v9 = 2;
    }
    uint64_t v4 = (v9 + v4);
  }
LABEL_19:
  *(_DWORD *)(a1 + 20) = v4;
  return v4;
}

uint64_t sub_1000F8190()
{
  return 1;
}

void *sub_1000F8198@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.GsmCellTower");
}

void sub_1000F81A8(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 28);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 28))
    {
      int v6 = *(_DWORD *)(a2 + 8);
      a1[7] |= 1u;
      a1[2] = v6;
      int v4 = *(_DWORD *)(a2 + 28);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_12;
      }
    }
    else if ((*(unsigned char *)(a2 + 28) & 2) == 0)
    {
      goto LABEL_6;
    }
    int v7 = *(_DWORD *)(a2 + 12);
    a1[7] |= 2u;
    a1[3] = v7;
    int v4 = *(_DWORD *)(a2 + 28);
    if ((v4 & 4) == 0)
    {
LABEL_7:
      if ((v4 & 8) == 0) {
        return;
      }
      goto LABEL_8;
    }
LABEL_12:
    int v8 = *(_DWORD *)(a2 + 16);
    a1[7] |= 4u;
    a1[4] = v8;
    if ((*(_DWORD *)(a2 + 28) & 8) == 0) {
      return;
    }
LABEL_8:
    int v5 = *(_DWORD *)(a2 + 20);
    a1[7] |= 8u;
    a1[5] = v5;
  }
}

void sub_1000F829C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1000F82B4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1001BCAF0;
  sub_1000F6170();

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1000F8310(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_1000F82B4(a1);

  operator delete();
}

void sub_1000F8348()
{
}

uint64_t sub_1000F8394(uint64_t result)
{
  if (*(unsigned char *)(result + 28))
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
  }
  *(_DWORD *)(result + 28) = 0;
  return result;
}

uint64_t sub_1000F83A8(unsigned int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = a1 + 2;
  int v6 = a1 + 3;
  int v7 = a1 + 4;
  while (2)
  {
    int v8 = (char *)*((void *)this + 1);
    if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v8;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v8 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        unint64_t v12 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        if ((unint64_t)v12 < v11 && (*v12 & 0x80000000) == 0)
        {
          *int v5 = *v12;
          int v13 = v12 + 1;
          *((void *)this + 1) = v13;
LABEL_24:
          a1[7] |= 1u;
          if ((unint64_t)v13 < v11 && *v13 == 16)
          {
            int v14 = v13 + 1;
            *((void *)this + 1) = v14;
            goto LABEL_27;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
        if (result)
        {
          int v13 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
          goto LABEL_24;
        }
        break;
      case 2u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        int v14 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
LABEL_27:
        if ((unint64_t)v14 >= v11 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!result) {
            return result;
          }
          unint64_t v17 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          *int v6 = *v14;
          unint64_t v17 = v14 + 1;
          *((void *)this + 1) = v17;
        }
        a1[7] |= 2u;
        if ((unint64_t)v17 >= v11 || *v17 != 24) {
          continue;
        }
        int v15 = v17 + 1;
        *((void *)this + 1) = v15;
LABEL_35:
        if ((unint64_t)v15 >= v11 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!result) {
            return result;
          }
          int v18 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v7 = *v15;
          int v18 = v15 + 1;
          *((void *)this + 1) = v18;
        }
        a1[7] |= 4u;
        if ((unint64_t)v18 >= v11 || *v18 != 32) {
          continue;
        }
        int v16 = v18 + 1;
        *((void *)this + 1) = v16;
LABEL_43:
        unsigned int v22 = 0;
        if ((unint64_t)v16 >= v11 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
          if (!result) {
            return result;
          }
          unsigned int v19 = v22;
          int v20 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int v19 = *v16;
          int v20 = (unsigned __int8 *)(v16 + 1);
          *((void *)this + 1) = v20;
        }
        a1[5] = -(v19 & 1) ^ (v19 >> 1);
        a1[7] |= 8u;
        if (v20 != (unsigned __int8 *)v11 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10)) {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      case 3u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        int v15 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_35;
      case 4u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        int v16 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_43;
      default:
        int v10 = TagFallback & 7;
LABEL_18:
        if (v10 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

int *sub_1000F8680(int *result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v5 = result;
  int v6 = result[7];
  if (v6)
  {
    uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, result[2], a2, a4);
    int v6 = v5[7];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v5[4], a2, a4);
      if ((v5[7] & 8) == 0) {
        return result;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v5[3], a2, a4);
  int v6 = v5[7];
  if ((v6 & 4) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((v6 & 8) == 0) {
    return result;
  }
LABEL_9:
  int v7 = v5[5];

  return (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteSInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, a2, a4);
}

uint64_t sub_1000F8728(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 28);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_25;
  }
  if (*(unsigned char *)(a1 + 28))
  {
    int v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if (v5 >= 0x80)
    {
      uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 28);
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 28) & 2) == 0) {
      goto LABEL_14;
    }
  }
  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
  if (v6 >= 0x80)
  {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 28);
  }
  else
  {
    int v7 = 2;
  }
  uint64_t v4 = (v7 + v4);
LABEL_14:
  if ((v3 & 4) == 0)
  {
    if ((v3 & 8) == 0) {
      goto LABEL_25;
    }
    goto LABEL_21;
  }
  int v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
  if (v8 >= 0x80)
  {
    int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 28);
  }
  else
  {
    int v9 = 2;
  }
  uint64_t v4 = (v9 + v4);
  if ((v3 & 8) != 0)
  {
LABEL_21:
    int v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)((2 * *(_DWORD *)(a1 + 20)) ^ (*(int *)(a1 + 20) >> 31));
    if (v10 >= 0x80) {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v10, a2) + 1;
    }
    else {
      int v11 = 2;
    }
    uint64_t v4 = (v11 + v4);
  }
LABEL_25:
  *(_DWORD *)(a1 + 24) = v4;
  return v4;
}

uint64_t sub_1000F881C()
{
  return 1;
}

void *sub_1000F8824@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.NrCellTower");
}

void sub_1000F8834(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 28);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 28))
    {
      int v6 = *(_DWORD *)(a2 + 8);
      a1[7] |= 1u;
      a1[2] = v6;
      int v4 = *(_DWORD *)(a2 + 28);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_12;
      }
    }
    else if ((*(unsigned char *)(a2 + 28) & 2) == 0)
    {
      goto LABEL_6;
    }
    int v7 = *(_DWORD *)(a2 + 12);
    a1[7] |= 2u;
    a1[3] = v7;
    int v4 = *(_DWORD *)(a2 + 28);
    if ((v4 & 4) == 0)
    {
LABEL_7:
      if ((v4 & 8) == 0) {
        return;
      }
      goto LABEL_8;
    }
LABEL_12:
    int v8 = *(_DWORD *)(a2 + 16);
    a1[7] |= 4u;
    a1[4] = v8;
    if ((*(_DWORD *)(a2 + 28) & 8) == 0) {
      return;
    }
LABEL_8:
    int v5 = *(_DWORD *)(a2 + 20);
    a1[7] |= 8u;
    a1[5] = v5;
  }
}

void sub_1000F8928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1000F8940(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1001BCB68;
  sub_1000F6170();

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1000F899C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_1000F8940(a1);

  operator delete();
}

void sub_1000F89D4()
{
}

uint64_t sub_1000F8A20(uint64_t result)
{
  if (*(unsigned char *)(result + 28))
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
  }
  *(_DWORD *)(result + 28) = 0;
  return result;
}

uint64_t sub_1000F8A34(unsigned int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = a1 + 2;
  int v6 = a1 + 3;
  int v7 = a1 + 4;
  while (2)
  {
    int v8 = (char *)*((void *)this + 1);
    if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v8;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v8 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        unint64_t v12 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        if ((unint64_t)v12 < v11 && (*v12 & 0x80000000) == 0)
        {
          *int v5 = *v12;
          int v13 = v12 + 1;
          *((void *)this + 1) = v13;
LABEL_24:
          a1[7] |= 1u;
          if ((unint64_t)v13 < v11 && *v13 == 16)
          {
            int v14 = v13 + 1;
            *((void *)this + 1) = v14;
            goto LABEL_27;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
        if (result)
        {
          int v13 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
          goto LABEL_24;
        }
        break;
      case 2u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        int v14 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
LABEL_27:
        if ((unint64_t)v14 >= v11 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!result) {
            return result;
          }
          unint64_t v17 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          *int v6 = *v14;
          unint64_t v17 = v14 + 1;
          *((void *)this + 1) = v17;
        }
        a1[7] |= 2u;
        if ((unint64_t)v17 >= v11 || *v17 != 24) {
          continue;
        }
        int v15 = v17 + 1;
        *((void *)this + 1) = v15;
LABEL_35:
        if ((unint64_t)v15 >= v11 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!result) {
            return result;
          }
          int v18 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v7 = *v15;
          int v18 = v15 + 1;
          *((void *)this + 1) = v18;
        }
        a1[7] |= 4u;
        if ((unint64_t)v18 >= v11 || *v18 != 32) {
          continue;
        }
        int v16 = v18 + 1;
        *((void *)this + 1) = v16;
LABEL_43:
        unsigned int v22 = 0;
        if ((unint64_t)v16 >= v11 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
          if (!result) {
            return result;
          }
          unsigned int v19 = v22;
          int v20 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int v19 = *v16;
          int v20 = (unsigned __int8 *)(v16 + 1);
          *((void *)this + 1) = v20;
        }
        a1[5] = -(v19 & 1) ^ (v19 >> 1);
        a1[7] |= 8u;
        if (v20 != (unsigned __int8 *)v11 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10)) {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      case 3u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        int v15 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_35;
      case 4u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        int v16 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_43;
      default:
        int v10 = TagFallback & 7;
LABEL_18:
        if (v10 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

int *sub_1000F8D0C(int *result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v5 = result;
  int v6 = result[7];
  if (v6)
  {
    uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, result[2], a2, a4);
    int v6 = v5[7];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v5[4], a2, a4);
      if ((v5[7] & 8) == 0) {
        return result;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v5[3], a2, a4);
  int v6 = v5[7];
  if ((v6 & 4) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((v6 & 8) == 0) {
    return result;
  }
LABEL_9:
  int v7 = v5[5];

  return (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteSInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, a2, a4);
}

uint64_t sub_1000F8DB4(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 28);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_25;
  }
  if (*(unsigned char *)(a1 + 28))
  {
    int v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if (v5 >= 0x80)
    {
      uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 28);
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 28) & 2) == 0) {
      goto LABEL_14;
    }
  }
  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
  if (v6 >= 0x80)
  {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 28);
  }
  else
  {
    int v7 = 2;
  }
  uint64_t v4 = (v7 + v4);
LABEL_14:
  if ((v3 & 4) == 0)
  {
    if ((v3 & 8) == 0) {
      goto LABEL_25;
    }
    goto LABEL_21;
  }
  int v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
  if (v8 >= 0x80)
  {
    int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 28);
  }
  else
  {
    int v9 = 2;
  }
  uint64_t v4 = (v9 + v4);
  if ((v3 & 8) != 0)
  {
LABEL_21:
    int v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)((2 * *(_DWORD *)(a1 + 20)) ^ (*(int *)(a1 + 20) >> 31));
    if (v10 >= 0x80) {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v10, a2) + 1;
    }
    else {
      int v11 = 2;
    }
    uint64_t v4 = (v11 + v4);
  }
LABEL_25:
  *(_DWORD *)(a1 + 24) = v4;
  return v4;
}

uint64_t sub_1000F8EA8()
{
  return 1;
}

void *sub_1000F8EB0@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.LteCellTower");
}

void sub_1000F8EC0(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 28);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 28))
    {
      int v6 = *(_DWORD *)(a2 + 8);
      a1[7] |= 1u;
      a1[2] = v6;
      int v4 = *(_DWORD *)(a2 + 28);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_12;
      }
    }
    else if ((*(unsigned char *)(a2 + 28) & 2) == 0)
    {
      goto LABEL_6;
    }
    int v7 = *(_DWORD *)(a2 + 12);
    a1[7] |= 2u;
    a1[3] = v7;
    int v4 = *(_DWORD *)(a2 + 28);
    if ((v4 & 4) == 0)
    {
LABEL_7:
      if ((v4 & 8) == 0) {
        return;
      }
      goto LABEL_8;
    }
LABEL_12:
    int v8 = *(_DWORD *)(a2 + 16);
    a1[7] |= 4u;
    a1[4] = v8;
    if ((*(_DWORD *)(a2 + 28) & 8) == 0) {
      return;
    }
LABEL_8:
    int v5 = *(_DWORD *)(a2 + 20);
    a1[7] |= 8u;
    a1[5] = v5;
  }
}

void sub_1000F8FB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1000F8FCC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1001BCBE0;
  sub_1000F6170();

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1000F9028(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_1000F8FCC(a1);

  operator delete();
}

void sub_1000F9060()
{
}

uint64_t sub_1000F90AC(uint64_t result)
{
  if (*(unsigned char *)(result + 28))
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
  }
  *(_DWORD *)(result + 28) = 0;
  return result;
}

uint64_t sub_1000F90C0(unsigned int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = a1 + 2;
  int v6 = a1 + 3;
  int v7 = a1 + 4;
  while (2)
  {
    int v8 = (char *)*((void *)this + 1);
    if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v8;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v8 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        unint64_t v12 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        if ((unint64_t)v12 < v11 && (*v12 & 0x80000000) == 0)
        {
          *int v5 = *v12;
          int v13 = v12 + 1;
          *((void *)this + 1) = v13;
LABEL_24:
          a1[7] |= 1u;
          if ((unint64_t)v13 < v11 && *v13 == 16)
          {
            int v14 = v13 + 1;
            *((void *)this + 1) = v14;
            goto LABEL_27;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
        if (result)
        {
          int v13 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
          goto LABEL_24;
        }
        break;
      case 2u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        int v14 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
LABEL_27:
        if ((unint64_t)v14 >= v11 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!result) {
            return result;
          }
          unint64_t v17 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          *int v6 = *v14;
          unint64_t v17 = v14 + 1;
          *((void *)this + 1) = v17;
        }
        a1[7] |= 2u;
        if ((unint64_t)v17 >= v11 || *v17 != 24) {
          continue;
        }
        int v15 = v17 + 1;
        *((void *)this + 1) = v15;
LABEL_35:
        if ((unint64_t)v15 >= v11 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!result) {
            return result;
          }
          int v18 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v7 = *v15;
          int v18 = v15 + 1;
          *((void *)this + 1) = v18;
        }
        a1[7] |= 4u;
        if ((unint64_t)v18 >= v11 || *v18 != 32) {
          continue;
        }
        int v16 = v18 + 1;
        *((void *)this + 1) = v16;
LABEL_43:
        unsigned int v22 = 0;
        if ((unint64_t)v16 >= v11 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
          if (!result) {
            return result;
          }
          unsigned int v19 = v22;
          int v20 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int v19 = *v16;
          int v20 = (unsigned __int8 *)(v16 + 1);
          *((void *)this + 1) = v20;
        }
        a1[5] = -(v19 & 1) ^ (v19 >> 1);
        a1[7] |= 8u;
        if (v20 != (unsigned __int8 *)v11 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10)) {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      case 3u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        int v15 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_35;
      case 4u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        int v16 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_43;
      default:
        int v10 = TagFallback & 7;
LABEL_18:
        if (v10 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

int *sub_1000F9398(int *result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v5 = result;
  int v6 = result[7];
  if (v6)
  {
    uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, result[2], a2, a4);
    int v6 = v5[7];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v5[4], a2, a4);
      if ((v5[7] & 8) == 0) {
        return result;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v5[3], a2, a4);
  int v6 = v5[7];
  if ((v6 & 4) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((v6 & 8) == 0) {
    return result;
  }
LABEL_9:
  int v7 = v5[5];

  return (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteSInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, a2, a4);
}

uint64_t sub_1000F9440(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 28);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_25;
  }
  if (*(unsigned char *)(a1 + 28))
  {
    int v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if (v5 >= 0x80)
    {
      uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 28);
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 28) & 2) == 0) {
      goto LABEL_14;
    }
  }
  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
  if (v6 >= 0x80)
  {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 28);
  }
  else
  {
    int v7 = 2;
  }
  uint64_t v4 = (v7 + v4);
LABEL_14:
  if ((v3 & 4) == 0)
  {
    if ((v3 & 8) == 0) {
      goto LABEL_25;
    }
    goto LABEL_21;
  }
  int v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
  if (v8 >= 0x80)
  {
    int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 28);
  }
  else
  {
    int v9 = 2;
  }
  uint64_t v4 = (v9 + v4);
  if ((v3 & 8) != 0)
  {
LABEL_21:
    int v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)((2 * *(_DWORD *)(a1 + 20)) ^ (*(int *)(a1 + 20) >> 31));
    if (v10 >= 0x80) {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v10, a2) + 1;
    }
    else {
      int v11 = 2;
    }
    uint64_t v4 = (v11 + v4);
  }
LABEL_25:
  *(_DWORD *)(a1 + 24) = v4;
  return v4;
}

uint64_t sub_1000F9534()
{
  return 1;
}

void *sub_1000F953C@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.UmtsCellTower");
}

void sub_1000F954C(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v24);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), *(_DWORD *)(a2 + 16) + a1[4]);
  if (*(int *)(a2 + 16) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*(void *)(a2 + 8) + 8 * v4);
      int v6 = a1[5];
      uint64_t v7 = (int)a1[4];
      if ((int)v7 >= v6)
      {
        if (v6 == a1[6])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), v6 + 1);
          int v6 = a1[5];
        }
        a1[5] = v6 + 1;
        operator new();
      }
      uint64_t v8 = *((void *)a1 + 1);
      a1[4] = v7 + 1;
      sub_1000F7C3C(*(_DWORD **)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 16));
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 8), *(_DWORD *)(a2 + 40) + a1[10]);
  if (*(int *)(a2 + 40) >= 1)
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = *(void *)(*(void *)(a2 + 32) + 8 * v9);
      int v11 = a1[11];
      uint64_t v12 = (int)a1[10];
      if ((int)v12 >= v11)
      {
        if (v11 == a1[12])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 8), v11 + 1);
          int v11 = a1[11];
        }
        a1[11] = v11 + 1;
        operator new();
      }
      uint64_t v13 = *((void *)a1 + 4);
      a1[10] = v12 + 1;
      sub_1000F8EC0(*(_DWORD **)(v13 + 8 * v12), v10);
      ++v9;
    }
    while (v9 < *(int *)(a2 + 40));
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 14), *(_DWORD *)(a2 + 64) + a1[16]);
  if (*(int *)(a2 + 64) >= 1)
  {
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = *(void *)(*(void *)(a2 + 56) + 8 * v14);
      int v16 = a1[17];
      uint64_t v17 = (int)a1[16];
      if ((int)v17 >= v16)
      {
        if (v16 == a1[18])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 14), v16 + 1);
          int v16 = a1[17];
        }
        a1[17] = v16 + 1;
        operator new();
      }
      uint64_t v18 = *((void *)a1 + 7);
      a1[16] = v17 + 1;
      sub_1000F8834(*(_DWORD **)(v18 + 8 * v17), v15);
      ++v14;
    }
    while (v14 < *(int *)(a2 + 64));
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 20), *(_DWORD *)(a2 + 88) + a1[22]);
  if (*(int *)(a2 + 88) >= 1)
  {
    uint64_t v19 = 0;
    do
    {
      uint64_t v20 = *(void *)(*(void *)(a2 + 80) + 8 * v19);
      int v21 = a1[23];
      uint64_t v22 = (int)a1[22];
      if ((int)v22 >= v21)
      {
        if (v21 == a1[24])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 20), v21 + 1);
          int v21 = a1[23];
        }
        a1[23] = v21 + 1;
        operator new();
      }
      uint64_t v23 = *((void *)a1 + 10);
      a1[22] = v22 + 1;
      sub_1000F81A8(*(_DWORD **)(v23 + 8 * v22), v20);
      ++v19;
    }
    while (v19 < *(int *)(a2 + 88));
  }
}

void sub_1000F9940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1000F9958(uint64_t *a1)
{
  *a1 = (uint64_t)off_1001BCC58;
  sub_1000F6170();
  sub_1000FB750(a1 + 10);
  sub_1000FB750(a1 + 7);
  sub_1000FB750(a1 + 4);
  sub_1000FB750(a1 + 1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite((wireless_diagnostics::google::protobuf::MessageLite *)a1);
}

void sub_1000F99E4(uint64_t *a1)
{
  sub_1000F9958(a1);

  operator delete();
}

void sub_1000F9A1C()
{
}

uint64_t sub_1000F9A88(uint64_t a1)
{
  sub_1000FB6E0(a1 + 8);
  sub_1000FB6E0(a1 + 32);
  sub_1000FB6E0(a1 + 56);
  uint64_t result = sub_1000FB6E0(a1 + 80);
  *(_DWORD *)(a1 + 108) = 0;
  return result;
}

uint64_t sub_1000F9ACC(int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2);
  int v6 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 8);
  uint64_t v7 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 14);
  uint64_t v8 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 20);
LABEL_2:
  while (2)
  {
    uint64_t v9 = (char *)*((void *)this + 1);
    if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v9;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v9 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v11 = TagFallback & 7;
        if (v11 != 2) {
          goto LABEL_32;
        }
        while (1)
        {
          int v12 = a1[5];
          uint64_t v13 = a1[4];
          if ((int)v13 >= v12)
          {
            if (v12 == a1[6])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v12 + 1);
              int v12 = a1[5];
            }
            a1[5] = v12 + 1;
            operator new();
          }
          uint64_t v14 = *((void *)a1 + 1);
          a1[4] = v13 + 1;
          uint64_t v15 = *(unsigned int **)(v14 + 8 * v13);
          unsigned int v63 = 0;
          int v16 = (char *)*((void *)this + 1);
          if ((unint64_t)v16 >= *((void *)this + 2) || *v16 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v63))return 0; {
          }
            }
          else
          {
            unsigned int v63 = *v16;
            *((void *)this + 1) = v16 + 1;
          }
          int v17 = *((_DWORD *)this + 14);
          int v18 = *((_DWORD *)this + 15);
          *((_DWORD *)this + 14) = v17 + 1;
          if (v17 >= v18) {
            return 0;
          }
          int v19 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v63);
          if (!sub_1000F7E24(v15, this, v20) || !*((unsigned char *)this + 36)) {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v19);
          int v21 = *((_DWORD *)this + 14);
          BOOL v22 = __OFSUB__(v21, 1);
          int v23 = v21 - 1;
          if (v23 < 0 == v22) {
            *((_DWORD *)this + 14) = v23;
          }
          int v24 = (unsigned char *)*((void *)this + 1);
          if ((unint64_t)v24 >= *((void *)this + 2)) {
            goto LABEL_2;
          }
          int v25 = *v24;
          if (v25 != 10) {
            break;
          }
          *((void *)this + 1) = v24 + 1;
        }
        if (v25 != 18) {
          continue;
        }
        goto LABEL_36;
      case 2u:
        int v11 = TagFallback & 7;
        if (v11 != 2) {
          goto LABEL_32;
        }
        break;
      case 3u:
        int v11 = TagFallback & 7;
        if (v11 == 2) {
          goto LABEL_55;
        }
        goto LABEL_32;
      case 4u:
        int v11 = TagFallback & 7;
        if (v11 != 2) {
          goto LABEL_32;
        }
        goto LABEL_73;
      default:
        int v11 = TagFallback & 7;
LABEL_32:
        if (v11 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
        continue;
        }
    }
    break;
  }
  while (1)
  {
    int v26 = a1[11];
    uint64_t v27 = a1[10];
    if ((int)v27 >= v26)
    {
      if (v26 == a1[12])
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v6, v26 + 1);
        int v26 = a1[11];
      }
      a1[11] = v26 + 1;
      operator new();
    }
    uint64_t v28 = *((void *)a1 + 4);
    a1[10] = v27 + 1;
    int v29 = *(unsigned int **)(v28 + 8 * v27);
    unsigned int v63 = 0;
    int v30 = (char *)*((void *)this + 1);
    if ((unint64_t)v30 >= *((void *)this + 2) || *v30 < 0)
    {
      if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v63)) {
        return 0;
      }
    }
    else
    {
      unsigned int v63 = *v30;
      *((void *)this + 1) = v30 + 1;
    }
    int v31 = *((_DWORD *)this + 14);
    int v32 = *((_DWORD *)this + 15);
    *((_DWORD *)this + 14) = v31 + 1;
    if (v31 >= v32) {
      return 0;
    }
    int v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v63);
    if (!sub_1000F90C0(v29, this, v34) || !*((unsigned char *)this + 36)) {
      return 0;
    }
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v33);
    int v35 = *((_DWORD *)this + 14);
    BOOL v22 = __OFSUB__(v35, 1);
    int v36 = v35 - 1;
    if (v36 < 0 == v22) {
      *((_DWORD *)this + 14) = v36;
    }
    int v24 = (unsigned char *)*((void *)this + 1);
    if ((unint64_t)v24 >= *((void *)this + 2)) {
      goto LABEL_2;
    }
    int v37 = *v24;
    if (v37 != 18)
    {
      if (v37 != 26) {
        goto LABEL_2;
      }
      while (1)
      {
        *((void *)this + 1) = v24 + 1;
LABEL_55:
        int v38 = a1[17];
        uint64_t v39 = a1[16];
        if ((int)v39 >= v38)
        {
          if (v38 == a1[18])
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v7, v38 + 1);
            int v38 = a1[17];
          }
          a1[17] = v38 + 1;
          operator new();
        }
        uint64_t v40 = *((void *)a1 + 7);
        a1[16] = v39 + 1;
        unsigned __int8 v41 = *(unsigned int **)(v40 + 8 * v39);
        unsigned int v63 = 0;
        int v42 = (char *)*((void *)this + 1);
        if ((unint64_t)v42 >= *((void *)this + 2) || *v42 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v63))return 0; {
        }
          }
        else
        {
          unsigned int v63 = *v42;
          *((void *)this + 1) = v42 + 1;
        }
        int v43 = *((_DWORD *)this + 14);
        int v44 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v43 + 1;
        if (v43 >= v44) {
          return 0;
        }
        int v45 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v63);
        if (!sub_1000F8A34(v41, this, v46) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v45);
        int v47 = *((_DWORD *)this + 14);
        BOOL v22 = __OFSUB__(v47, 1);
        int v48 = v47 - 1;
        if (v48 < 0 == v22) {
          *((_DWORD *)this + 14) = v48;
        }
        int v24 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v24 >= *((void *)this + 2)) {
          goto LABEL_2;
        }
        int v49 = *v24;
        if (v49 != 26)
        {
          if (v49 != 34) {
            goto LABEL_2;
          }
          while (1)
          {
            *((void *)this + 1) = v24 + 1;
LABEL_73:
            int v50 = a1[23];
            uint64_t v51 = a1[22];
            if ((int)v51 >= v50)
            {
              if (v50 == a1[24])
              {
                wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v8, v50 + 1);
                int v50 = a1[23];
              }
              a1[23] = v50 + 1;
              operator new();
            }
            uint64_t v52 = *((void *)a1 + 10);
            a1[22] = v51 + 1;
            unsigned int v53 = *(unsigned int **)(v52 + 8 * v51);
            unsigned int v63 = 0;
            uint64_t v54 = (char *)*((void *)this + 1);
            if ((unint64_t)v54 >= *((void *)this + 2) || *v54 < 0)
            {
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v63))return 0; {
            }
              }
            else
            {
              unsigned int v63 = *v54;
              *((void *)this + 1) = v54 + 1;
            }
            int v55 = *((_DWORD *)this + 14);
            int v56 = *((_DWORD *)this + 15);
            *((_DWORD *)this + 14) = v55 + 1;
            if (v55 >= v56) {
              return 0;
            }
            int v57 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v63);
            if (!sub_1000F83A8(v53, this, v58) || !*((unsigned char *)this + 36)) {
              return 0;
            }
            wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v57);
            int v59 = *((_DWORD *)this + 14);
            BOOL v22 = __OFSUB__(v59, 1);
            int v60 = v59 - 1;
            if (v60 < 0 == v22) {
              *((_DWORD *)this + 14) = v60;
            }
            int v24 = (unsigned char *)*((void *)this + 1);
            unsigned int v61 = (unsigned char *)*((void *)this + 2);
            if (v24 >= v61 || *v24 != 34)
            {
              if (v24 == v61 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
              {
                *((_DWORD *)this + 8) = 0;
                uint64_t result = 1;
                *((unsigned char *)this + 36) = 1;
                return result;
              }
              goto LABEL_2;
            }
          }
        }
      }
    }
LABEL_36:
    *((void *)this + 1) = v24 + 1;
  }
}

uint64_t sub_1000FA184(uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v6 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(*(void *)(v5 + 8) + 8 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  if (*(int *)(v5 + 40) >= 1)
  {
    uint64_t v7 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(void *)(*(void *)(v5 + 32) + 8 * v7++), a2, a4);
    while (v7 < *(int *)(v5 + 40));
  }
  if (*(int *)(v5 + 64) >= 1)
  {
    uint64_t v8 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(void *)(*(void *)(v5 + 56) + 8 * v8++), a2, a4);
    while (v8 < *(int *)(v5 + 64));
  }
  if (*(int *)(v5 + 88) >= 1)
  {
    uint64_t v9 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(void *)(*(void *)(v5 + 80) + 8 * v9++), a2, a4);
    while (v9 < *(int *)(v5 + 88));
  }
  return result;
}

uint64_t sub_1000FA280(uint64_t a1, unsigned int a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (v3 >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1000F80D4(*(void *)(*(void *)(a1 + 8) + 8 * v4), a2);
      int v6 = (int)v5;
      if (v5 >= 0x80) {
        int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
      }
      else {
        int v7 = 1;
      }
      v3 += v6 + v7;
      ++v4;
    }
    while (v4 < *(int *)(a1 + 16));
  }
  int v8 = *(_DWORD *)(a1 + 40);
  int v9 = v8 + v3;
  if (v8 >= 1)
  {
    uint64_t v10 = 0;
    do
    {
      int v11 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1000F9440(*(void *)(*(void *)(a1 + 32) + 8 * v10), a2);
      int v12 = (int)v11;
      if (v11 >= 0x80) {
        int v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11, a2);
      }
      else {
        int v13 = 1;
      }
      v9 += v12 + v13;
      ++v10;
    }
    while (v10 < *(int *)(a1 + 40));
  }
  int v14 = *(_DWORD *)(a1 + 64);
  int v15 = v14 + v9;
  if (v14 >= 1)
  {
    uint64_t v16 = 0;
    do
    {
      int v17 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1000F8DB4(*(void *)(*(void *)(a1 + 56) + 8 * v16), a2);
      int v18 = (int)v17;
      if (v17 >= 0x80) {
        int v19 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v17, a2);
      }
      else {
        int v19 = 1;
      }
      v15 += v18 + v19;
      ++v16;
    }
    while (v16 < *(int *)(a1 + 64));
  }
  int v20 = *(_DWORD *)(a1 + 88);
  uint64_t v21 = (v20 + v15);
  if (v20 >= 1)
  {
    uint64_t v22 = 0;
    do
    {
      int v23 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1000F8728(*(void *)(*(void *)(a1 + 80) + 8 * v22), a2);
      int v24 = (int)v23;
      if (v23 >= 0x80) {
        int v25 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v23, a2);
      }
      else {
        int v25 = 1;
      }
      uint64_t v21 = (v24 + v21 + v25);
      ++v22;
    }
    while (v22 < *(int *)(a1 + 88));
  }
  *(_DWORD *)(a1 + 104) = v21;
  return v21;
}

uint64_t sub_1000FA400()
{
  return 1;
}

void *sub_1000FA408@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.CellTower");
}

void sub_1000FA418(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v11);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 36);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 36))
    {
      int v5 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a1 + 36) |= 1u;
      *(_DWORD *)(a1 + 8) = v5;
      int v4 = *(_DWORD *)(a2 + 36);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_12;
      }
    }
    else if ((*(unsigned char *)(a2 + 36) & 2) == 0)
    {
      goto LABEL_6;
    }
    int v6 = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a1 + 36) |= 2u;
    *(_DWORD *)(a1 + 12) = v6;
    int v4 = *(_DWORD *)(a2 + 36);
    if ((v4 & 4) == 0)
    {
LABEL_7:
      if ((v4 & 8) == 0) {
        goto LABEL_8;
      }
      goto LABEL_13;
    }
LABEL_12:
    int v7 = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 36) |= 4u;
    *(_DWORD *)(a1 + 16) = v7;
    int v4 = *(_DWORD *)(a2 + 36);
    if ((v4 & 8) == 0)
    {
LABEL_8:
      if ((v4 & 0x10) == 0) {
        return;
      }
      goto LABEL_14;
    }
LABEL_13:
    int v8 = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a1 + 36) |= 8u;
    *(_DWORD *)(a1 + 20) = v8;
    if ((*(_DWORD *)(a2 + 36) & 0x10) == 0) {
      return;
    }
LABEL_14:
    *(_DWORD *)(a1 + 36) |= 0x10u;
    int v9 = *(_DWORD **)(a1 + 24);
    if (!v9) {
      operator new();
    }
    uint64_t v10 = *(void *)(a2 + 24);
    if (!v10)
    {
      sub_1000F6170();
      uint64_t v10 = *(void *)(qword_1001D80E0 + 24);
    }
    sub_1000F954C(v9, v10);
  }
}

void sub_1000FA5B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1000FA5CC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1001BCCD0;
  sub_1000FA624((uint64_t)a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1000FA624(uint64_t a1)
{
  sub_1000F6170();
  if (qword_1001D80E0 != a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2)
    {
      int v3 = *(void (**)(void))(*(void *)v2 + 8);
      v3();
    }
  }
}

void sub_1000FA6A0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_1000FA5CC(a1);

  operator delete();
}

uint64_t sub_1000FA6D8()
{
  return qword_1001D80E0;
}

void sub_1000FA6F8()
{
}

uint64_t sub_1000FA74C(uint64_t result)
{
  uint64_t v1 = result;
  char v2 = *(unsigned char *)(result + 36);
  if (v2)
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    if ((v2 & 0x10) != 0)
    {
      uint64_t result = *(void *)(result + 24);
      if (result) {
        uint64_t result = sub_1000F9A88(result);
      }
    }
  }
  *(_DWORD *)(v1 + 36) = 0;
  return result;
}

uint64_t sub_1000FA78C(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = (unsigned int *)(a1 + 8);
  int v6 = (unsigned int *)(a1 + 12);
  int v7 = (unsigned int *)(a1 + 16);
  int v8 = (unsigned int *)(a1 + 20);
  while (2)
  {
    int v9 = (char *)*((void *)this + 1);
    if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v9;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v9 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_21;
        }
        int v13 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
          if (!result) {
            return result;
          }
          int v14 = (unsigned char *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          *int v5 = *v13;
          int v14 = v13 + 1;
          *((void *)this + 1) = v14;
        }
        *(_DWORD *)(a1 + 36) |= 1u;
        if ((unint64_t)v14 < v12 && *v14 == 16)
        {
          int v15 = v14 + 1;
          *((void *)this + 1) = v15;
          goto LABEL_29;
        }
        continue;
      case 2u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_21;
        }
        int v15 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
LABEL_29:
        if ((unint64_t)v15 >= v12 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!result) {
            return result;
          }
          int v20 = (unsigned char *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          *int v6 = *v15;
          int v20 = v15 + 1;
          *((void *)this + 1) = v20;
        }
        *(_DWORD *)(a1 + 36) |= 2u;
        if ((unint64_t)v20 >= v12 || *v20 != 24) {
          continue;
        }
        uint64_t v16 = v20 + 1;
        *((void *)this + 1) = v16;
LABEL_37:
        if ((unint64_t)v16 >= v12 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!result) {
            return result;
          }
          uint64_t v21 = (unsigned char *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v7 = *v16;
          uint64_t v21 = v16 + 1;
          *((void *)this + 1) = v21;
        }
        *(_DWORD *)(a1 + 36) |= 4u;
        if ((unint64_t)v21 >= v12 || *v21 != 32) {
          continue;
        }
        int v17 = v21 + 1;
        *((void *)this + 1) = v17;
LABEL_45:
        if ((unint64_t)v17 >= v12 || *v17 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v8);
          if (!result) {
            return result;
          }
          uint64_t v22 = (unsigned char *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v8 = *v17;
          uint64_t v22 = v17 + 1;
          *((void *)this + 1) = v22;
        }
        int v18 = *(_DWORD *)(a1 + 36) | 8;
        *(_DWORD *)(a1 + 36) = v18;
        if ((unint64_t)v22 >= v12 || *v22 != 42) {
          continue;
        }
        *((void *)this + 1) = v22 + 1;
LABEL_53:
        *(_DWORD *)(a1 + 36) = v18 | 0x10;
        int v23 = *(int **)(a1 + 24);
        if (!v23) {
          operator new();
        }
        unsigned int v32 = 0;
        int v24 = (char *)*((void *)this + 1);
        if ((unint64_t)v24 >= *((void *)this + 2) || *v24 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v32))return 0; {
        }
          }
        else
        {
          unsigned int v32 = *v24;
          *((void *)this + 1) = v24 + 1;
        }
        int v25 = *((_DWORD *)this + 14);
        int v26 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v25 + 1;
        if (v25 < v26)
        {
          int v27 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v32);
          if (sub_1000F9ACC(v23, this, v28))
          {
            if (*((unsigned char *)this + 36))
            {
              wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v27);
              int v29 = *((_DWORD *)this + 14);
              BOOL v30 = __OFSUB__(v29, 1);
              int v31 = v29 - 1;
              if (v31 < 0 == v30) {
                *((_DWORD *)this + 14) = v31;
              }
              if (*((void *)this + 1) == *((void *)this + 2)
                && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
              {
                *((_DWORD *)this + 8) = 0;
                uint64_t result = 1;
                *((unsigned char *)this + 36) = 1;
                return result;
              }
              continue;
            }
          }
        }
        return 0;
      case 3u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_21;
        }
        uint64_t v16 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_37;
      case 4u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_21;
        }
        int v17 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_45;
      case 5u:
        int v11 = TagFallback & 7;
        if (v11 != 2) {
          goto LABEL_21;
        }
        int v18 = *(_DWORD *)(a1 + 36);
        goto LABEL_53;
      default:
        int v11 = TagFallback & 7;
LABEL_21:
        if (v11 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

uint64_t sub_1000FAB98(uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 36);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 36);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_DWORD *)(v5 + 12), a2, a4);
  int v6 = *(_DWORD *)(v5 + 36);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
LABEL_10:
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(_DWORD *)(v5 + 20), a2, a4);
    if ((*(_DWORD *)(v5 + 36) & 0x10) == 0) {
      return result;
    }
    goto LABEL_11;
  }
LABEL_9:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(_DWORD *)(v5 + 16), a2, a4);
  int v6 = *(_DWORD *)(v5 + 36);
  if ((v6 & 8) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if ((v6 & 0x10) == 0) {
    return result;
  }
LABEL_11:
  uint64_t v7 = *(void *)(v5 + 24);
  if (!v7)
  {
    sub_1000F6170();
    uint64_t v7 = *(void *)(qword_1001D80E0 + 24);
  }

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v7, a2, a4);
}

uint64_t sub_1000FAC70(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 36);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_32;
  }
  if (*(unsigned char *)(a1 + 36))
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if (v5 >= 0x80)
    {
      uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 36);
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 36) & 2) == 0) {
      goto LABEL_14;
    }
  }
  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
  if (v6 >= 0x80)
  {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 36);
  }
  else
  {
    int v7 = 2;
  }
  uint64_t v4 = (v7 + v4);
LABEL_14:
  if ((v3 & 4) == 0)
  {
    if ((v3 & 8) == 0) {
      goto LABEL_16;
    }
LABEL_22:
    uint64_t v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 20);
    if (v10 >= 0x80)
    {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v10, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 36);
    }
    else
    {
      int v11 = 2;
    }
    uint64_t v4 = (v11 + v4);
    if ((v3 & 0x10) == 0) {
      goto LABEL_32;
    }
    goto LABEL_26;
  }
  int v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
  if (v8 >= 0x80)
  {
    int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 36);
  }
  else
  {
    int v9 = 2;
  }
  uint64_t v4 = (v9 + v4);
  if ((v3 & 8) != 0) {
    goto LABEL_22;
  }
LABEL_16:
  if ((v3 & 0x10) == 0) {
    goto LABEL_32;
  }
LABEL_26:
  uint64_t v12 = *(void *)(a1 + 24);
  if (!v12)
  {
    sub_1000F6170();
    uint64_t v12 = *(void *)(qword_1001D80E0 + 24);
  }
  int v13 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1000FA280(v12, a2);
  int v15 = (int)v13;
  if (v13 >= 0x80) {
    int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v13, v14);
  }
  else {
    int v16 = 1;
  }
  uint64_t v4 = (v4 + v15 + v16 + 1);
LABEL_32:
  *(_DWORD *)(a1 + 32) = v4;
  return v4;
}

uint64_t sub_1000FADB4()
{
  return 1;
}

void *sub_1000FADBC@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.Plmn");
}

void sub_1000FADCC(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v13);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 4), *(_DWORD *)(a2 + 24) + a1[6]);
  if (*(int *)(a2 + 24) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*(void *)(a2 + 16) + 8 * v4);
      int v6 = a1[7];
      uint64_t v7 = (int)a1[6];
      if ((int)v7 >= v6)
      {
        if (v6 == a1[8])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 4), v6 + 1);
          int v6 = a1[7];
        }
        a1[7] = v6 + 1;
        operator new();
      }
      uint64_t v8 = *((void *)a1 + 2);
      a1[6] = v7 + 1;
      sub_1000FA418(*(void *)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 24));
  }
  LOBYTE(v9) = *(unsigned char *)(a2 + 48);
  if ((_BYTE)v9)
  {
    if (*(unsigned char *)(a2 + 48))
    {
      int v11 = *(_DWORD *)(a2 + 8);
      a1[12] |= 1u;
      a1[2] = v11;
      int v9 = *(_DWORD *)(a2 + 48);
      if ((v9 & 2) == 0)
      {
LABEL_14:
        if ((v9 & 4) == 0) {
          return;
        }
        goto LABEL_15;
      }
    }
    else if ((*(unsigned char *)(a2 + 48) & 2) == 0)
    {
      goto LABEL_14;
    }
    int v12 = *(_DWORD *)(a2 + 12);
    a1[12] |= 2u;
    a1[3] = v12;
    if ((*(_DWORD *)(a2 + 48) & 4) == 0) {
      return;
    }
LABEL_15:
    int v10 = *(_DWORD *)(a2 + 40);
    a1[12] |= 4u;
    a1[10] = v10;
  }
}

void sub_1000FAF94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1000FAFAC(uint64_t *a1)
{
  *a1 = (uint64_t)off_1001BCD48;
  sub_1000F6170();
  sub_1000FB750(a1 + 2);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite((wireless_diagnostics::google::protobuf::MessageLite *)a1);
}

void sub_1000FB014(uint64_t *a1)
{
  sub_1000FAFAC(a1);

  operator delete();
}

void sub_1000FB04C()
{
}

uint64_t sub_1000FB0A4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    *(void *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 40) = 0;
  }
  uint64_t result = sub_1000FB6E0(a1 + 16);
  *(_DWORD *)(a1 + 48) = 0;
  return result;
}

uint64_t sub_1000FB0E0(_DWORD *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = a1 + 2;
  int v6 = a1 + 3;
  uint64_t v7 = a1 + 10;
  uint64_t v8 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 4);
  while (1)
  {
    int v9 = (unsigned __int8 *)*((void *)this + 1);
    if ((unint64_t)v9 >= *((void *)this + 2) || (char)*v9 < 0) {
      break;
    }
    unint64_t TagFallback = *v9;
    *((_DWORD *)this + 8) = TagFallback;
    *((void *)this + 1) = v9 + 1;
    if (!TagFallback) {
      return 1;
    }
LABEL_7:
    switch(TagFallback >> 3)
    {
      case 1u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        int v13 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
          if (!result) {
            return result;
          }
          unsigned int v14 = (unsigned char *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          *uint64_t v5 = *v13;
          unsigned int v14 = v13 + 1;
          *((void *)this + 1) = v14;
        }
        a1[12] |= 1u;
        if ((unint64_t)v14 < v12 && *v14 == 16)
        {
          int v15 = v14 + 1;
          *((void *)this + 1) = v15;
          goto LABEL_26;
        }
        continue;
      case 2u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        int v15 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
LABEL_26:
        if ((unint64_t)v15 >= v12 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!result) {
            return result;
          }
          int v18 = (unsigned char *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          *int v6 = *v15;
          int v18 = v15 + 1;
          *((void *)this + 1) = v18;
        }
        a1[12] |= 2u;
        if ((unint64_t)v18 >= v12 || *v18 != 24) {
          continue;
        }
        int v16 = v18 + 1;
        *((void *)this + 1) = v16;
LABEL_34:
        if ((unint64_t)v16 >= v12 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!result) {
            return result;
          }
          int v19 = (unsigned char *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v7 = *v16;
          int v19 = v16 + 1;
          *((void *)this + 1) = v19;
        }
        a1[12] |= 4u;
        if ((unint64_t)v19 >= v12 || *v19 != 34) {
          continue;
        }
        break;
      case 3u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        int v16 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_34;
      case 4u:
        int v11 = TagFallback & 7;
        if (v11 != 2) {
          goto LABEL_18;
        }
        goto LABEL_42;
      default:
        int v11 = TagFallback & 7;
LABEL_18:
        if (v11 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
        continue;
        }
    }
    do
    {
      *((void *)this + 1) = v19 + 1;
LABEL_42:
      int v20 = a1[7];
      uint64_t v21 = (int)a1[6];
      if ((int)v21 >= v20)
      {
        if (v20 == a1[8])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v8, v20 + 1);
          int v20 = a1[7];
        }
        a1[7] = v20 + 1;
        operator new();
      }
      uint64_t v22 = *((void *)a1 + 2);
      a1[6] = v21 + 1;
      uint64_t v23 = *(void *)(v22 + 8 * v21);
      unsigned int v33 = 0;
      int v24 = (char *)*((void *)this + 1);
      if ((unint64_t)v24 >= *((void *)this + 2) || *v24 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v33))return 0; {
      }
        }
      else
      {
        unsigned int v33 = *v24;
        *((void *)this + 1) = v24 + 1;
      }
      int v25 = *((_DWORD *)this + 14);
      int v26 = *((_DWORD *)this + 15);
      *((_DWORD *)this + 14) = v25 + 1;
      if (v25 >= v26) {
        return 0;
      }
      int v27 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v33);
      if (!sub_1000FA78C(v23, this, v28) || !*((unsigned char *)this + 36)) {
        return 0;
      }
      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v27);
      int v29 = *((_DWORD *)this + 14);
      BOOL v30 = __OFSUB__(v29, 1);
      int v31 = v29 - 1;
      if (v31 < 0 == v30) {
        *((_DWORD *)this + 14) = v31;
      }
      int v19 = (unsigned char *)*((void *)this + 1);
      unsigned int v32 = (unsigned char *)*((void *)this + 2);
    }
    while (v19 < v32 && *v19 == 34);
    if (v19 == v32 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
    {
      *((_DWORD *)this + 8) = 0;
      uint64_t result = 1;
      *((unsigned char *)this + 36) = 1;
      return result;
    }
  }
  unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
  *((_DWORD *)this + 8) = TagFallback;
  if (TagFallback) {
    goto LABEL_7;
  }
  return 1;
}

uint64_t sub_1000FB4B4(uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 48);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 48);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_DWORD *)(v5 + 12), a2, a4);
  if ((*(_DWORD *)(v5 + 48) & 4) != 0) {
LABEL_4:
  }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(_DWORD *)(v5 + 40), a2, a4);
LABEL_5:
  if (*(int *)(v5 + 24) >= 1)
  {
    uint64_t v7 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(void *)(*(void *)(v5 + 16) + 8 * v7++), a2, a4);
    while (v7 < *(int *)(v5 + 24));
  }
  return result;
}

uint64_t sub_1000FB568(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 48);
  if (!(_BYTE)v3)
  {
    int v4 = 0;
    goto LABEL_19;
  }
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if (v5 >= 0x80)
    {
      int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 48);
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
    else
    {
      int v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
  }
  else
  {
    int v4 = 0;
    if ((*(unsigned char *)(a1 + 48) & 2) == 0) {
      goto LABEL_14;
    }
  }
  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
  if (v6 >= 0x80)
  {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 48);
  }
  else
  {
    int v7 = 2;
  }
  v4 += v7;
LABEL_14:
  if ((v3 & 4) != 0)
  {
    uint64_t v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 40);
    if (v8 >= 0x80) {
      int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2) + 1;
    }
    else {
      int v9 = 2;
    }
    v4 += v9;
  }
LABEL_19:
  int v10 = *(_DWORD *)(a1 + 24);
  uint64_t v11 = (v10 + v4);
  if (v10 >= 1)
  {
    uint64_t v12 = 0;
    do
    {
      int v13 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1000FAC70(*(void *)(*(void *)(a1 + 16) + 8 * v12), a2);
      int v14 = (int)v13;
      if (v13 >= 0x80) {
        int v15 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v13, a2);
      }
      else {
        int v15 = 1;
      }
      uint64_t v11 = (v14 + v11 + v15);
      ++v12;
    }
    while (v12 < *(int *)(a1 + 24));
  }
  *(_DWORD *)(a1 + 44) = v11;
  return v11;
}

uint64_t sub_1000FB680()
{
  return 1;
}

void *sub_1000FB688@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.CellularCoverageTile");
}

uint64_t sub_1000FB698(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t sub_1000FB6A0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 68);
}

uint64_t sub_1000FB6A8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t sub_1000FB6B0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1000FB6B8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1000FB6C0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1000FB6C8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 104);
}

uint64_t sub_1000FB6D0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t sub_1000FB6D8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 44);
}

uint64_t sub_1000FB6E0(uint64_t result)
{
  uint64_t v1 = result;
  if (*(int *)(result + 8) >= 1)
  {
    uint64_t v2 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(*(void *)v1 + 8 * v2) + 32))(*(void *)(*(void *)v1 + 8 * v2));
      ++v2;
    }
    while (v2 < *(int *)(v1 + 8));
  }
  *(_DWORD *)(v1 + 8) = 0;
  return result;
}

uint64_t sub_1000FB750(uint64_t *a1)
{
  int v2 = *((_DWORD *)a1 + 3);
  if (v2 >= 1)
  {
    for (uint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(void *)(*a1 + 8 * i);
      if (v4)
      {
        (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
        int v2 = *((_DWORD *)a1 + 3);
      }
    }
  }
  uint64_t result = *a1;
  if (*a1)
  {
    operator delete[]();
  }
  return result;
}

void sub_1000FB7F4()
{
}

void sub_1000FB84C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  uint64_t *v1 = 0;
  if (v3) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

id **sub_1000FB87C(id **a1)
{
  if (*a1)
  {

    int v2 = *a1;
    *a1 = 0;
    if (v2) {
      operator delete();
    }
  }
  else
  {
    *a1 = 0;
  }
  return a1;
}

id sub_1000FB8E0(id **a1)
{
  if (*a1) {
    return [**a1 improveSafetyAllowed];
  }
  else {
    return 0;
  }
}

void sub_1000FBAF4()
{
}

void sub_1000FBBF8()
{
  void *v0 = off_1001B7408;
  sub_100059E54(v0 + 2);
  operator delete();
}

void *sub_1000FBCE0(void *a1)
{
  *a1 = off_1001BCEB0;
  int v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10000B678(v2);
  }
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);
  return a1;
}

void sub_1000FBD50(void *a1)
{
  *a1 = off_1001BCEB0;
  int v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10000B678(v2);
  }
  *a1 = off_1001B7408;
  sub_100059E54(a1 + 2);

  operator delete();
}

void sub_1000FBDE4()
{
}

void *sub_1000FBDF8()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1001BCEF0;
  return result;
}

void sub_1000FBE30(uint64_t a1, void *a2)
{
  *a2 = off_1001BCEF0;
}

BOOL sub_1000FBE58(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a2;
  int v6 = *(_DWORD *)(*a2 + 12);
  MetricFileMetadataHelper::MetricFileMetadataHelper();
  uint64_t v61 = v5;
  int v62 = v6;
  while (1)
  {
    int v8 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
    if (v8 < 1) {
      break;
    }
    int v9 = *(char **)(a4 + 8);
    if ((unint64_t)v9 >= *(void *)(a4 + 16) || *v9 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
      *(_DWORD *)(a4 + 32) = TagFallback;
      if (TagFallback) {
        goto LABEL_6;
      }
LABEL_12:
      sub_1000FC9A4(a4, 0);
    }
    else
    {
      unint64_t TagFallback = *v9;
      *(_DWORD *)(a4 + 32) = TagFallback;
      *(void *)(a4 + 8) = v9 + 1;
      if (!TagFallback) {
        goto LABEL_12;
      }
LABEL_6:
      unint64_t v11 = wis::reflect::decodeTag((wis::reflect *)TagFallback, v7);
      unint64_t v12 = HIDWORD(v11);
      uint64_t v69 = 0;
      uint64_t v70 = 0;
      uint64_t v71 = 0xFFFFFFFFLL;
      MetricFileMetadataHelper::getSubfieldType();
      long long v67 = v72;
      uint64_t v68 = v73;
      int BuiltinType = MetadataHelper::getBuiltinType();
      char v14 = v11;
      int DecodingType = wis::reflect::getDecodingType();
      switch(DecodingType)
      {
        case 0:
          switch(v14)
          {
            case 0:
              *(void *)unsigned int v74 = 0;
              int v36 = *(char **)(a4 + 8);
              if ((unint64_t)v36 < *(void *)(a4 + 16) && (*v36 & 0x80000000) == 0)
              {
                *(void *)(a4 + 8) = v36 + 1;
                continue;
              }
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v74);
LABEL_128:
              if ((Varint64Fallback & 1) == 0) {
                goto LABEL_85;
              }
              continue;
            case 1:
              *(void *)unsigned int v74 = 0;
              if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v74))goto LABEL_85; {
              continue;
              }
            case 2:
              LODWORD(__p) = 0;
              uint64_t v52 = *(char **)(a4 + 8);
              if ((unint64_t)v52 >= *(void *)(a4 + 16) || *v52 < 0)
              {
                if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_85; {
                unsigned int v53 = __p;
                }
              }
              else
              {
                unsigned int v53 = *v52;
                LODWORD(__p) = v53;
                *(void *)(a4 + 8) = v52 + 1;
              }
              sub_10003908C(v74, v53);
              char Raw = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, *(void **)v74, (int)__p);
              if (*(void *)v74)
              {
                unsigned int v75 = *(void **)v74;
                operator delete(*(void **)v74);
              }
              if ((Raw & 1) == 0) {
                goto LABEL_85;
              }
              continue;
            case 5:
              v74[0] = 0;
              char Varint64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v74);
              goto LABEL_128;
            default:
              goto LABEL_85;
          }
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
          *(void *)unsigned int v74 = 0;
          switch(v14)
          {
            case 0:
              int v16 = *(char **)(a4 + 8);
              if ((unint64_t)v16 < *(void *)(a4 + 16) && (*v16 & 0x80000000) == 0)
              {
                *(void *)unsigned int v74 = *v16;
                *(void *)(a4 + 8) = v16 + 1;
LABEL_66:
                switch(BuiltinType)
                {
                  case 1:
                  case 15:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)1>::decode();
                    break;
                  case 2:
                  case 16:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)2>::decode();
                    break;
                  case 3:
                  case 4:
                  case 6:
                  case 7:
                  case 9:
                  case 10:
                  case 11:
                  case 12:
                  case 17:
                  case 18:
                  case 20:
                  case 21:
                  case 23:
                  case 24:
                  case 25:
                  case 26:
                    continue;
                  case 5:
                  case 19:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)5>::decode();
                    break;
                  case 8:
                  case 22:
                    wis::protobuf::NumberConverter<(wis::reflect::Type)8>::decode();
                    break;
                  default:
                    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                    std::runtime_error::runtime_error(exception, "This should never happen, no matter what the input!");
                }
                continue;
              }
              char LittleEndian64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v74);
LABEL_65:
              if (LittleEndian64Fallback) {
                goto LABEL_66;
              }
LABEL_85:
              sub_1000FC9A4(a4, v12);
              break;
            case 1:
              char LittleEndian64Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v74);
              goto LABEL_65;
            case 2:
              goto LABEL_85;
            case 5:
              LODWORD(__p) = 0;
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_85; {
              *(void *)unsigned int v74 = __p;
              }
              goto LABEL_66;
            default:
              goto LABEL_66;
          }
          break;
        case 13:
          LODWORD(__p) = 0;
          int v37 = *(char **)(a4 + 8);
          if ((unint64_t)v37 >= *(void *)(a4 + 16) || *v37 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_85; {
          }
            }
          else
          {
            LODWORD(__p) = *v37;
            *(void *)(a4 + 8) = v37 + 1;
          }
          *(void *)unsigned int v74 = 0;
          unsigned int v75 = 0;
          uint64_t v76 = 0;
          char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadString();
          if (String)
          {
            if (v62 == v12)
            {
              int64_t v44 = HIBYTE(v76);
              if (v76 >= 0) {
                int v45 = v74;
              }
              else {
                int v45 = *(unsigned int **)v74;
              }
              if (v76 < 0) {
                int64_t v44 = (int64_t)v75;
              }
              LOBYTE(DecodingType) = sub_1000FCA18((uint64_t)v45, (uint64_t)v45 + v44, v61 + 48, 0);
            }
            else
            {
              LOBYTE(DecodingType) = 0;
            }
          }
          if ((SHIBYTE(v76) & 0x80000000) == 0) {
            goto LABEL_112;
          }
          uint64_t v51 = *(void **)v74;
          goto LABEL_111;
        case 14:
          LODWORD(__p) = 0;
          uint64_t v40 = *(char **)(a4 + 8);
          if ((unint64_t)v40 >= *(void *)(a4 + 16) || *v40 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unsigned int *)&__p))goto LABEL_85; {
            unsigned int v41 = __p;
            }
          }
          else
          {
            unsigned int v41 = *v40;
            LODWORD(__p) = v41;
            *(void *)(a4 + 8) = v40 + 1;
          }
          sub_10003908C(v74, v41);
          char String = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadRaw((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, *(void **)v74, (int)__p);
          if (String)
          {
            if (v62 == v12) {
              LOBYTE(DecodingType) = sub_100104044(*(uint64_t *)v74, (uint64_t)v75, v61 + 48, 0);
            }
            else {
              LOBYTE(DecodingType) = 0;
            }
          }
          uint64_t v51 = *(void **)v74;
          if (*(void *)v74)
          {
            unsigned int v75 = *(void **)v74;
LABEL_111:
            operator delete(v51);
          }
LABEL_112:
          if ((String & 1) == 0) {
            goto LABEL_85;
          }
          if (DecodingType) {
            goto LABEL_130;
          }
          continue;
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
          unsigned int v66 = 0;
          int v17 = *(char **)(a4 + 8);
          if ((unint64_t)v17 >= *(void *)(a4 + 16) || *v17 < 0)
          {
            if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, &v66) & 1) == 0)goto LABEL_85; {
          }
            }
          else
          {
            unsigned int v66 = *v17;
            *(void *)(a4 + 8) = v17 + 1;
          }
          wis::reflect::getUnpackedType();
          int WireTypeForType = wis::reflect::getWireTypeForType();
          int v19 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v66);
          long long __p = 0;
          long long v64 = 0;
          uint64_t v65 = 0;
          while (1)
          {
            int v20 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
            if (v20 < 1) {
              break;
            }
            uint64_t v21 = v64;
            if (v64 >= v65)
            {
              uint64_t v23 = (char *)__p;
              uint64_t v24 = (v64 - (unsigned char *)__p) >> 3;
              unint64_t v25 = v24 + 1;
              if ((unint64_t)(v24 + 1) >> 61) {
                sub_10002B5E0();
              }
              uint64_t v26 = v65 - (unsigned char *)__p;
              if ((v65 - (unsigned char *)__p) >> 2 > v25) {
                unint64_t v25 = v26 >> 2;
              }
              if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v27 = v25;
              }
              if (v27)
              {
                unsigned int v28 = (char *)sub_100038500((uint64_t)&v65, v27);
                uint64_t v23 = (char *)__p;
                uint64_t v21 = v64;
              }
              else
              {
                unsigned int v28 = 0;
              }
              int v29 = &v28[8 * v24];
              *(void *)int v29 = 0;
              uint64_t v22 = v29 + 8;
              while (v21 != v23)
              {
                uint64_t v30 = *((void *)v21 - 1);
                v21 -= 8;
                *((void *)v29 - 1) = v30;
                v29 -= 8;
              }
              long long __p = v29;
              long long v64 = v22;
              uint64_t v65 = &v28[8 * v27];
              if (v23) {
                operator delete(v23);
              }
            }
            else
            {
              *(void *)long long v64 = 0;
              uint64_t v22 = v21 + 8;
            }
            long long v64 = v22;
            switch(WireTypeForType)
            {
              case 0:
                int v31 = (unint64_t *)(v22 - 8);
                unsigned int v32 = *(char **)(a4 + 8);
                if ((unint64_t)v32 >= *(void *)(a4 + 16) || *v32 < 0)
                {
                  char v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v31);
LABEL_43:
                  if ((v33 & 1) == 0) {
                    goto LABEL_82;
                  }
                }
                else
                {
                  unint64_t *v31 = *v32;
                  *(void *)(a4 + 8) = v32 + 1;
                }
                break;
              case 1:
                char v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, (unint64_t *)v22 - 1);
                goto LABEL_43;
              case 2:
                goto LABEL_82;
              case 5:
                v74[0] = 0;
                char LittleEndian32Fallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v74);
                *((void *)v64 - 1) = v74[0];
                if ((LittleEndian32Fallback & 1) == 0) {
                  goto LABEL_82;
                }
                continue;
              default:
                continue;
            }
          }
          switch(DecodingType)
          {
            case 15:
              sub_1000385BC((uint64_t *)&__p, v74);
              goto LABEL_79;
            case 16:
              sub_1000386C8((uint64_t *)&__p, v74);
              goto LABEL_79;
            case 17:
            case 18:
            case 24:
            case 25:
              sub_100038538((uint64_t *)&__p, v74);
              goto LABEL_79;
            case 19:
              sub_1000387D4((uint64_t *)&__p, v74);
              goto LABEL_79;
            case 20:
            case 21:
            case 23:
              sub_100038644((uint64_t *)&__p, v74);
              goto LABEL_79;
            case 22:
              sub_10003885C((uint64_t *)&__p, v74);
LABEL_79:
              int v42 = *(void **)v74;
              if (!*(void *)v74) {
                break;
              }
              unsigned int v75 = *(void **)v74;
LABEL_81:
              operator delete(v42);
              break;
            case 26:
              sub_100038750((uint64_t)&__p, v74);
              int v42 = *(void **)v74;
              if (!*(void *)v74) {
                break;
              }
              goto LABEL_81;
            default:
              int v57 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v57, "This should never happen, no matter what the input!");
          }
LABEL_82:
          if (__p)
          {
            long long v64 = (char *)__p;
            operator delete(__p);
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v19);
          if (v20 > 0) {
            goto LABEL_85;
          }
          continue;
        case 27:
          v74[0] = 0;
          int v38 = *(char **)(a4 + 8);
          if ((unint64_t)v38 >= *(void *)(a4 + 16) || *v38 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v74))goto LABEL_85; {
            int v39 = v74[0];
            }
          }
          else
          {
            int v39 = *v38;
            v74[0] = v39;
            *(void *)(a4 + 8) = v38 + 1;
          }
          int v46 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v39);
          ++*(_DWORD *)(a4 + 56);
          int v47 = wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4);
          wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v47);
          int v48 = *(_DWORD *)(a4 + 56);
          BOOL v49 = __OFSUB__(v48, 1);
          int v50 = v48 - 1;
          if (v50 < 0 == v49) {
            *(_DWORD *)(a4 + 56) = v50;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit((wireless_diagnostics::google::protobuf::io::CodedInputStream *)a4, v46);
          continue;
        default:
          goto LABEL_85;
      }
    }
  }
LABEL_130:
  sub_100038238((uint64_t)&v60);
  if (v59) {
    sub_10000B678(v59);
  }
  return v8 > 0;
}

void sub_1000FC748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  if (a11) {
    sub_10000B678(a11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000FC958(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1000FC998()
{
}

uint64_t sub_1000FC9A4(uint64_t result, int a2)
{
  if (a2 || !*(unsigned char *)(result + 36))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parsing failed in metric");
  }
  return result;
}

void sub_1000FCA04(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000FCA18(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (*(void *)a3 && (*(unsigned char *)(*(void *)a3 + 42) & 8) != 0) {
    return 0;
  }
  char v13 = 0;
  memset(v12, 0, sizeof(v12));
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  int v16 = 0;
  char v17 = 1;
  sub_1000FCB78((uint64_t)&v7, a1, a2, (uint64_t)v12, a3, a4 | 0x400, a1);
  uint64_t v4 = sub_1000FD7B4((uint64_t)&v7);
  int v18 = (void **)&v11;
  sub_1000FD72C(&v18);
  if (v10) {
    void *v9 = v10;
  }
  uint64_t v5 = v8;
  uint64_t v8 = 0;
  if (v5)
  {
    sub_100104004(v5);
    operator delete();
  }
  sub_100104004((uint64_t)v12);
  return v4;
}

void sub_1000FCAFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000FCB20((uint64_t)&a9);
  sub_100104004(v9 - 128);
  _Unwind_Resume(a1);
}

uint64_t sub_1000FCB20(uint64_t a1)
{
  uint64_t v4 = (void **)(a1 + 184);
  sub_1000FD72C(&v4);
  uint64_t v2 = *(void *)(a1 + 144);
  if (v2) {
    **(void **)(a1 + 136) = v2;
  }
  sub_1000FCEF8((uint64_t *)(a1 + 8), 0);
  return a1;
}

uint64_t sub_1000FCB78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  *(void *)a1 = a4;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = a2;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = a7;
  *(void *)(a1 + 72) = a5;
  *(void *)(a1 + 80) = *(void *)(*(void *)a5 + 24);
  *(unsigned char *)(a1 + 123) = 0;
  *(void *)(a1 + 128) = a1 + 136;
  *(void *)(a1 + 136) = a1 + 128;
  *(void *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 152) = -1;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 232) = 0;
  sub_1000FCC48(a1, a5, a6);
  return a1;
}

void sub_1000FCC10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v14 = v12;
  a10 = v14;
  sub_1000FD72C(&a10);
  uint64_t v16 = *(void *)(v11 + 144);
  if (v16) {
    **char v13 = v16;
  }
  sub_1000FCEF8(v10, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1000FCC48(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(void *)a2 || *(_DWORD *)(*(void *)a2 + 44))
  {
    std::logic_error::logic_error(&v14, "Invalid regular expression object");
    sub_1000FCDEC(&v14);
  }
  char v3 = a3;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = a3;
  uint64_t result = sub_1000FCE48(a1);
  uint64_t v7 = *(void *)(a1 + 72);
  if (*(void *)v7) {
    int v8 = *(_DWORD *)(*(void *)v7 + 40);
  }
  else {
    int v8 = 0;
  }
  *(unsigned char *)(a1 + 120) = (v8 & 0x100000) != 0;
  int v9 = *(_DWORD *)(a1 + 96);
  if ((v9 & 0x30000) == 0)
  {
    if ((v8 & 3) == 2 || (v8 & 0x1003) == 4097 || (v8 & 0x203) == 0) {
      int v12 = 0x10000;
    }
    else {
      int v12 = 0x20000;
    }
    v9 |= v12;
    *(_DWORD *)(a1 + 96) = v9;
  }
  if ((v9 & 0x20000) != 0) {
    operator new();
  }
  *(void *)(a1 + 16) = *(void *)a1;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 176) = *(_DWORD *)(*(void *)v7 + 368);
  if ((v3 & 0x40) != 0) {
    char v13 = 2;
  }
  else {
    char v13 = 3;
  }
  *(unsigned char *)(a1 + 180) = v13;
  if (*(unsigned char *)(*(void *)a2 + 401)) {
    *(_DWORD *)(a1 + 96) &= 0x3FFFFBFFu;
  }
  return result;
}

void sub_1000FCDD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::invalid_argument a9)
{
}

void sub_1000FCDEC(const std::logic_error *a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  sub_1000FCF48((uint64_t)exception, a1);
}

void sub_1000FCE34(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000FCE48(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32) - *(void *)(result + 24);
  if ((unint64_t)v1 <= 1) {
    uint64_t v1 = 1;
  }
  uint64_t v2 = **(void **)(result + 72);
  if (v2) {
    uint64_t v2 = *(void *)(v2 + 56);
  }
  if ((unint64_t)v2 <= 1) {
    uint64_t v2 = 1;
  }
  if (0x7FFFFFFFFFFFFFFFLL / v2 < v2
    || (uint64_t v3 = v2 * v2, 0x7FFFFFFFFFFFFFFFLL / v1 < v3)
    || (uint64_t v4 = v3 * v1, v4 > 0x7FFFFFFFFFFE795FLL)
    || (*(void *)(result + 112) = v4 + 100000, 0x7FFFFFFFFFFFFFFFLL / v1 < v1)
    || (unint64_t v5 = v1 * v1, v5 > 0x7FFFFFFFFFFE795FLL))
  {
    uint64_t v6 = 100000000;
LABEL_13:
    *(void *)(result + 112) = v6;
    return result;
  }
  if (v5 >= 0x5F45A60) {
    unint64_t v5 = 99900000;
  }
  if ((uint64_t)v5 > v4)
  {
    uint64_t v6 = v5 + 100000;
    goto LABEL_13;
  }
  return result;
}

uint64_t sub_1000FCEF8(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_100104004(result);
    operator delete();
  }
  return result;
}

uint64_t sub_1000FCF48(uint64_t a1, const std::logic_error *a2)
{
  *(void *)a1 = &off_1001BD040;
  std::logic_error::logic_error((std::logic_error *)(a1 + 8), a2);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = -1;
  *(void *)a1 = &off_1001BCFC8;
  *(void *)(a1 + 8) = off_1001BCFF8;
  *(void *)(a1 + 24) = off_1001BD020;
  return a1;
}

uint64_t sub_1000FCFF4(uint64_t a1)
{
  *(void *)(a1 + 24) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 32));
  std::invalid_argument::~invalid_argument((std::invalid_argument *)(a1 + 8));
  return a1;
}

void sub_1000FD048()
{
}

void sub_1000FD214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_1000FD4FC(&a9);
  sub_1000FD4FC(&a10);
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  _Unwind_Resume(a1);
}

void sub_1000FD28C(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  sub_1000FD558((uint64_t)exception, a1);
}

void sub_1000FD2D4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1000FD2E8(uint64_t a1)
{
  *(void *)(a1 + 24) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 32));
  std::invalid_argument::~invalid_argument((std::invalid_argument *)(a1 + 8));

  operator delete();
}

void sub_1000FD35C(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 24));

  std::invalid_argument::~invalid_argument((std::invalid_argument *)a1);
}

void sub_1000FD3B8(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 24));
  std::invalid_argument::~invalid_argument((std::invalid_argument *)a1);

  operator delete();
}

void sub_1000FD430(void *a1)
{
  *a1 = &off_1001BD070;
  sub_1000FD4FC(a1 + 1);

  std::invalid_argument::~invalid_argument((std::invalid_argument *)a1 - 1);
}

void sub_1000FD488(void *a1)
{
  *a1 = &off_1001BD070;
  sub_1000FD4FC(a1 + 1);
  std::invalid_argument::~invalid_argument((std::invalid_argument *)a1 - 1);

  operator delete();
}

uint64_t *sub_1000FD4FC(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2)) {
    *a1 = 0;
  }
  return a1;
}

uint64_t sub_1000FD558(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_1001BD040;
  std::logic_error::logic_error((std::logic_error *)(a1 + 8), (const std::logic_error *)(a2 + 8));
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = &off_1001BD070;
  *(void *)(a1 + 32) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v5;
  *(void *)a1 = &off_1001BCFC8;
  *(void *)(a1 + 8) = off_1001BCFF8;
  *(void *)(a1 + 24) = off_1001BD020;
  return a1;
}

void sub_1000FD680(_Unwind_Exception *a1)
{
  std::invalid_argument::~invalid_argument(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000FD694(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 32))(result);
  }
  *a1 = a2;
  if (a2)
  {
    long long v5 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 24);
    return v5(a2);
  }
  return result;
}

void sub_1000FD72C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    long long v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 112;
        sub_100104004((uint64_t)(v4 - 96));
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1000FD7B4(uint64_t a1)
{
  sub_100102E08(&v22, (void *)(a1 + 208), (void *)(a1 + 216));
  *(_DWORD *)(a1 + 224) = 1024;
  *(void *)(a1 + 104) = 0;
  int v2 = *(_DWORD *)(a1 + 96);
  if ((v2 & 0x200) == 0)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 16);
    uint64_t v4 = *(void *)(a1 + 24);
    *(void *)(a1 + 40) = v4;
    *(void *)(a1 + 56) = v4;
    uint64_t v5 = **(void **)(a1 + 72);
    *(void *)(a1 + 88) = *(void *)(v5 + 72);
    if ((v2 & 0x40000) != 0) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = *(void *)(v5 + 64);
    }
    sub_1000FDE00(v3, v6, v4, *(void *)(a1 + 32));
    *(void *)(*(void *)(a1 + 16) + 24) = *(void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 16);
    char v13 = *(uint64_t **)(a1 + 72);
    uint64_t v14 = *v13;
    uint64_t v15 = (std::__shared_weak_count *)v13[1];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v16 = *(std::__shared_weak_count **)(v12 + 64);
    *(void *)(v12 + 56) = v14;
    *(void *)(v12 + 64) = v15;
    if (v16) {
      sub_10000B678(v16);
    }
    if (v15) {
      sub_10000B678(v15);
    }
    int v11 = *(_DWORD *)(a1 + 96) | 0x200;
    *(_DWORD *)(a1 + 96) = v11;
    if ((v11 & 0x20000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_22;
  }
  uint64_t v7 = sub_1000FDF10(*(uint64_t **)a1, 0)[1];
  *(void *)(a1 + 40) = v7;
  *(void *)(a1 + 56) = v7;
  if ((*(unsigned char *)(a1 + 97) & 8) == 0 && !sub_1000FDF8C(*(uint64_t **)a1, 0))
  {
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8 == *(void *)(a1 + 32))
    {
      uint64_t v20 = 0;
      goto LABEL_31;
    }
    *(void *)(a1 + 40) = v8 + 1;
  }
  if ((*(unsigned char *)(a1 + 98) & 4) != 0 || (uint64_t v9 = **(void **)(a1 + 72)) == 0) {
    uint64_t v10 = 1;
  }
  else {
    uint64_t v10 = *(void *)(v9 + 64);
  }
  sub_1000FDE00(*(uint64_t **)(a1 + 16), v10, *(void *)(a1 + 56), *(void *)(a1 + 32));
  int v11 = *(_DWORD *)(a1 + 96);
  if ((v11 & 0x20000) != 0)
  {
LABEL_22:
    uint64_t v17 = **(void **)(a1 + 72);
    if (v17) {
      uint64_t v18 = *(void *)(v17 + 64);
    }
    else {
      uint64_t v18 = 1;
    }
    sub_1000FDE00(*(uint64_t **)a1, v18, *(void *)(a1 + 24), *(void *)(a1 + 32));
    *(void *)(*(void *)a1 + 24) = *(void *)(a1 + 24);
    int v11 = *(_DWORD *)(a1 + 96);
  }
LABEL_26:
  if ((~v11 & 0xA0000) == 0)
  {
    std::logic_error::logic_error(&v23, "Usage Error: Can't mix regular expression captures with POSIX matching rules");
    sub_1001026F4(&v23);
  }
  if ((v11 & 0x1000) != 0) {
    uint64_t v19 = 4;
  }
  else {
    uint64_t v19 = *(unsigned int *)(**(void **)(a1 + 72) + 80);
  }
  uint64_t v20 = ((uint64_t (*)(uint64_t))*(&off_1001BD080 + 2 * v19))(a1);
LABEL_31:
  sub_100103F9C(&v22);
  return v20;
}

void sub_1000FD9B4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::logic_error a11)
{
}

void sub_1000FDA20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  __cxa_end_catch();
  sub_100103F9C((void ***)va);
  _Unwind_Resume(a1);
}

BOOL sub_1000FDA40(uint64_t a1)
{
  uint64_t v2 = **(void **)(a1 + 72) + 84;
  uint64_t v3 = *(unsigned __int8 **)(a1 + 32);
  for (uint64_t i = *(unsigned __int8 **)(a1 + 40); ; *(void *)(a1 + 40) = i)
  {
    if (i != v3)
    {
      while ((*(unsigned char *)(v2 + *i) & 3) == 0)
      {
        *(void *)(a1 + 40) = ++i;
        if (i == v3) {
          goto LABEL_10;
        }
      }
    }
    if (i == v3) {
      break;
    }
    BOOL result = sub_1000FDD0C(a1);
    if (result) {
      return result;
    }
    uint64_t v3 = *(unsigned __int8 **)(a1 + 32);
    uint64_t v6 = *(unsigned __int8 **)(a1 + 40);
    if (v6 == v3) {
      return result;
    }
    uint64_t i = v6 + 1;
  }
LABEL_10:
  if (!*(_DWORD *)(**(void **)(a1 + 72) + 340)) {
    return 0;
  }

  return sub_1000FDD0C(a1);
}

uint64_t sub_1000FDAFC(uint64_t a1)
{
  uint64_t v2 = **(void **)(a1 + 72);
  if (*(unsigned char *)(a1 + 97))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    goto LABEL_6;
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3 != *(void *)(a1 + 24))
  {
LABEL_6:
    uint64_t v5 = (char *)(v3 - 1);
    *(void *)(a1 + 40) = v5;
    goto LABEL_7;
  }
  if (sub_1000FDD0C(a1)) {
    return 1;
  }
  uint64_t v5 = *(char **)(a1 + 40);
LABEL_7:
  uint64_t v6 = v2 + 84;
  uint64_t v7 = *(char **)(a1 + 32);
LABEL_8:
  while (v5 != v7)
  {
    BOOL v8 = sub_1000FE014(*(void *)(a1 + 80), *v5, *(_DWORD *)(a1 + 176));
    uint64_t v7 = *(char **)(a1 + 32);
    uint64_t v9 = *(char **)(a1 + 40);
    if (!v8)
    {
      while (v9 != v7)
      {
        BOOL v10 = sub_1000FE014(*(void *)(a1 + 80), *v9, *(_DWORD *)(a1 + 176));
        uint64_t v7 = *(char **)(a1 + 32);
        uint64_t v5 = *(char **)(a1 + 40);
        if (v10)
        {
          if (v5 == v7) {
            return 0;
          }
          if ((*(unsigned char *)(v6 + *v5) & 3) != 0)
          {
            if (sub_1000FDD0C(a1)) {
              return 1;
            }
            uint64_t v7 = *(char **)(a1 + 32);
            uint64_t v5 = *(char **)(a1 + 40);
          }
          if (v5 != v7) {
            goto LABEL_8;
          }
          return 0;
        }
        uint64_t v9 = v5 + 1;
        *(void *)(a1 + 40) = v9;
      }
      return 0;
    }
    uint64_t v5 = v9 + 1;
    *(void *)(a1 + 40) = v5;
  }
  return 0;
}

BOOL sub_1000FDBF4(uint64_t a1)
{
  uint64_t v2 = **(void **)(a1 + 72);
  uint64_t v3 = 1;
  if (!sub_1000FDD0C(a1))
  {
    uint64_t v4 = v2 + 84;
    uint64_t v6 = *(unsigned __int8 **)(a1 + 32);
    uint64_t v5 = *(unsigned __int8 **)(a1 + 40);
    do
    {
      if (v5 == v6) {
        break;
      }
      ++v5;
      while (1)
      {
        unsigned int v7 = *(v5 - 1);
        BOOL v8 = v7 > 0xD;
        int v9 = (1 << v7) & 0x3400;
        BOOL v10 = v8 || v9 == 0;
        if (!v10) {
          break;
        }
        *(void *)(a1 + 40) = v5;
        BOOL v10 = v5++ == v6;
        if (v10) {
          return 0;
        }
      }
      if (v5 - 1 == v6) {
        break;
      }
      *(void *)(a1 + 40) = v5;
      if (v5 == v6) {
        return *(_DWORD *)(**(void **)(a1 + 72) + 340) && sub_1000FDD0C(a1);
      }
      if ((*(unsigned char *)(v4 + *v5) & 3) != 0)
      {
        if (sub_1000FDD0C(a1)) {
          return 1;
        }
        uint64_t v6 = *(unsigned __int8 **)(a1 + 32);
        uint64_t v5 = *(unsigned __int8 **)(a1 + 40);
      }
    }
    while (v5 != v6);
    return 0;
  }
  return v3;
}

BOOL sub_1000FDCE8(uint64_t a1)
{
  return *(void *)(a1 + 40) == *(void *)(a1 + 24) && (*(unsigned char *)(a1 + 96) & 4) == 0 && sub_1000FDD0C(a1);
}

BOOL sub_1000FDD0C(uint64_t a1)
{
  *(_WORD *)(a1 + 121) = 0;
  *(void *)(a1 + 88) = *(void *)(**(void **)(a1 + 72) + 72);
  sub_1000FE0DC(*(void **)(a1 + 16), *(void *)(a1 + 40));
  *(void *)(a1 + 48) = *(void *)(a1 + 40);
  sub_1000FE168(a1, v2);
  if (*(unsigned char *)(a1 + 122))
  {
    int v3 = 1;
  }
  else
  {
    if (!*(unsigned char *)(a1 + 121)) {
      goto LABEL_5;
    }
    int v4 = *(_DWORD *)(a1 + 96);
    if ((v4 & 0x2000) == 0) {
      goto LABEL_5;
    }
    int v3 = 1;
    *(unsigned char *)(a1 + 122) = 1;
    uint64_t v6 = *(uint64_t **)(a1 + 16);
    uint64_t v7 = *(void *)(a1 + 32);
    *(void *)(*v6 + 56) = v7;
    uint64_t v8 = *v6;
    *(unsigned char *)(v8 + 64) = 0;
    *(void *)uint64_t v8 = v7;
    *(unsigned char *)(*v6 + 16) = *(void *)*v6 != *(void *)(*v6 + 8);
    v6[4] = v7;
    void v6[5] = v7;
    *((unsigned char *)v6 + 48) = 0;
    *((unsigned char *)v6 + 76) = 0;
    *(void *)(a1 + 40) = *(void *)(a1 + 32);
    if ((v4 & 0x20000) != 0)
    {
      sub_1000FE37C(*(void *)a1, *(void **)(a1 + 16));
      int v3 = *(unsigned __int8 *)(a1 + 122);
      if (!*(unsigned char *)(a1 + 122))
      {
LABEL_5:
        int v3 = 0;
        *(void *)(a1 + 40) = *(void *)(a1 + 48);
      }
    }
  }
  return v3 != 0;
}

uint64_t sub_1000FDDF8()
{
  return 0;
}

uint64_t *sub_1000FDE00(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = result;
  v16[0] = a4;
  v16[1] = a4;
  char v17 = 0;
  uint64_t v8 = *result;
  uint64_t v7 = result[1];
  uint64_t v9 = v7 - *result;
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v9 >> 3);
  uint64_t v11 = a2 + 2;
  if (a2 + 2 >= v10)
  {
    if (v9 >= 1)
    {
      unint64_t v15 = v9 / 0x18uLL + 1;
      do
      {
        *(void *)uint64_t v8 = a4;
        *(void *)(v8 + 8) = a4;
        *(unsigned char *)(v8 + 16) = 0;
        --v15;
        v8 += 24;
      }
      while (v15 > 1);
    }
    if (v11 != v10) {
      BOOL result = (uint64_t *)sub_100102EF8(result, result[1], v11 - v10, (unint64_t)v16);
    }
  }
  else
  {
    BOOL result = (uint64_t *)sub_100102E8C((uint64_t)result, v8 + 24 * a2 + 48, v7);
    uint64_t v12 = *v6;
    uint64_t v13 = v6[1] - *v6;
    if (v13 >= 1)
    {
      unint64_t v14 = v13 / 0x18uLL + 1;
      do
      {
        *(void *)uint64_t v12 = a4;
        *(void *)(v12 + 8) = a4;
        *(unsigned char *)(v12 + 16) = 0;
        --v14;
        v12 += 24;
      }
      while (v14 > 1);
    }
  }
  *(void *)(*v6 + 24) = a3;
  *((_DWORD *)v6 + 18) = 0;
  return result;
}

uint64_t *sub_1000FDF10(uint64_t *a1, int a2)
{
  uint64_t v2 = *a1;
  if (*((unsigned char *)a1 + 76) && v2 == a1[1]) {
    sub_1001026B0();
  }
  BOOL v3 = a2 + 2 >= (int)(-1431655765 * ((unint64_t)(a1[1] - v2) >> 3)) || a2 <= -3;
  uint64_t v4 = v2 + 24 * (a2 + 2);
  if (v3) {
    return a1 + 4;
  }
  else {
    return (uint64_t *)v4;
  }
}

uint64_t sub_1000FDF8C(uint64_t *a1, int a2)
{
  if (*((unsigned char *)a1 + 76)) {
    sub_1001026B0();
  }
  uint64_t result = 0;
  if (a2 >= -1)
  {
    unsigned int v4 = a2 + 2;
    uint64_t v5 = *a1;
    if (a2 + 2 < (int)(-1431655765 * ((unint64_t)(a1[1] - *a1) >> 3)))
    {
      if (*(unsigned char *)(v5 + 24 * v4 + 16)) {
        return *(void *)(v5 + 24 * v4 + 8) - *(void *)(v5 + 24 * v4);
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

BOOL sub_1000FE014(uint64_t a1, int a2, int a3)
{
  if ((a2 & 0x80000000) == 0
    && (a3 & 0x5F700) != 0
    && (*(_DWORD *)(*(void *)(*(void *)(*(void *)a1 + 8) + 16) + 4 * a2) & a3 & 0x5F700) != 0
    || a2 == 95 && (a3 & 0x2000000) != 0)
  {
    return 1;
  }
  if ((a2 & 0x80) != 0
    || (a3 & 0x1000000) == 0
    || (*(_DWORD *)(*(void *)(*(void *)(*(void *)a1 + 8) + 16) + 4 * a2) & 0x4000) == 0
    || (uint64_t v3 = 1, a2 <= 0xDu) && ((1 << a2) & 0x3400) != 0)
  {
    if (a2 - 10 <= 3 && (a3 & 0x10000000) != 0) {
      return 1;
    }
    uint64_t v3 = 0;
    if ((a2 & 0x80) == 0 && (a3 & 0x8000000) != 0) {
      return (*(_DWORD *)(*(void *)(*(void *)(*(void *)a1 + 8) + 16) + 4 * a2) & 0x4000) != 0
    }
          && a2 - 14 < 0xFFFFFFFC;
  }
  return v3;
}

void *sub_1000FE0DC(void *result, uint64_t a2)
{
  *(void *)(*result + 32) = a2;
  uint64_t v2 = *result;
  *(unsigned char *)(v2 + 40) = *(void *)(*result + 24) != a2;
  *(void *)(v2 + 48) = a2;
  uint64_t v3 = *result;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(result[1] - *result) >> 3) >= 4)
  {
    uint64_t v4 = 0;
    unint64_t v5 = 3;
    do
    {
      uint64_t v6 = v3 + v4;
      uint64_t v7 = *(void *)(v3 + 8);
      *(void *)(v6 + 80) = v7;
      *(void *)(*result + v4 + 72) = v7;
      uint64_t v3 = *result;
      uint64_t v8 = result[1];
      *(unsigned char *)(*result + v4 + 88) = 0;
      ++v5;
      v4 += 24;
    }
    while (v5 < 0xAAAAAAAAAAAAAAABLL * ((v8 - v3) >> 3));
  }
  return result;
}

uint64_t sub_1000FE168(uint64_t a1, __n128 a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 232) + 1;
  *(_DWORD *)(a1 + 232) = v3;
  if (v3 >= 0x51) {
    sub_1001003E4(*(void ***)(a1 + 80), 18);
  }
  uint64_t v4 = (_DWORD *)(*(void *)(a1 + 216) - 8);
  if ((unint64_t)v4 < *(void *)(a1 + 208))
  {
    a2 = sub_1001004C4((__n128 *)a1);
    uint64_t v4 = (_DWORD *)(*(void *)(a1 + 216) - 8);
  }
  _DWORD *v4 = 2;
  *(void *)(a1 + 216) = v4;
  unint64_t v5 = *(unsigned int **)(a1 + 88);
  do
  {
    while (v5)
    {
      uint64_t v6 = (unsigned int (*)(uint64_t, __n128))*(&off_1001BD0F0 + 2 * *v5);
      ++*(void *)(a1 + 104);
      if (v6(a1, a2))
      {
        unint64_t v5 = *(unsigned int **)(a1 + 88);
      }
      else
      {
        if (*(void *)(a1 + 104) > *(void *)(a1 + 112)) {
          sub_1001003E4(*(void ***)(a1 + 80), 18);
        }
        if ((*(unsigned char *)(a1 + 97) & 0x20) != 0)
        {
          uint64_t v7 = *(void *)(a1 + 40);
          if (v7 == *(void *)(a1 + 32) && v7 != *(void *)(a1 + 56)) {
            *(unsigned char *)(a1 + 121) = 1;
          }
        }
        *(_WORD *)(a1 + 228) = 0;
        *(unsigned char *)(a1 + 230) = 0;
        while ((((uint64_t (*)(uint64_t, void))off_1001BD568[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228)) & 1) != 0);
        if ((*(unsigned char *)(a1 + 97) & 0x20) != 0)
        {
          uint64_t v8 = *(void *)(a1 + 40);
          if (v8 == *(void *)(a1 + 32) && v8 != *(void *)(a1 + 56)) {
            *(unsigned char *)(a1 + 121) = 1;
          }
        }
        unint64_t v5 = *(unsigned int **)(a1 + 88);
        if (!v5) {
          goto LABEL_26;
        }
      }
    }
    *(_WORD *)(a1 + 228) = 1;
    *(unsigned char *)(a1 + 230) = 0;
    while ((((uint64_t (*)(uint64_t, void, __n128))off_1001BD568[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228), a2) & 1) != 0);
    unint64_t v5 = *(unsigned int **)(a1 + 88);
  }
  while (v5);
LABEL_26:
  uint64_t result = *(unsigned __int8 *)(a1 + 228);
  --*(_DWORD *)(a1 + 232);
  return result;
}

void sub_1000FE304(_Unwind_Exception *a1)
{
  --*(_DWORD *)(v1 + 232);
  _Unwind_Resume(a1);
}

_DWORD *sub_1000FE320(_DWORD *result, uint64_t a2, uint64_t a3, char a4, char a5)
{
  if (a3) {
    result[18] = a3;
  }
  uint64_t v5 = 24 * a3 + 48;
  *(void *)(*(void *)result + v5 + 8) = a2;
  uint64_t v6 = *(void **)result;
  *(unsigned char *)(*(void *)result + v5 + 16) = a4;
  if (!a3 && (a5 & 1) == 0)
  {
    *uint64_t v6 = a2;
    *(unsigned char *)(*(void *)result + 16) = **(void **)result != *(void *)(*(void *)result + 8);
    *((void *)result + 4) = a2;
    *((void *)result + 5) = a2;
    *((unsigned char *)result + 48) = 0;
    *((unsigned char *)result + 76) = 0;
  }
  return result;
}

uint64_t sub_1000FE37C(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 76)) {
    goto LABEL_2;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3) <= 2) {
    uint64_t v5 = *(void **)(a1 + 8);
  }
  else {
    uint64_t v5 = (void *)(*(void *)a1 + 48);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2[1] - *a2) >> 3) <= 2) {
    uint64_t v6 = a2[1];
  }
  else {
    uint64_t v6 = *a2 + 48;
  }
  uint64_t v7 = sub_100102628(a1)[1];
  if (*v5 == v7) {
    uint64_t result = (uint64_t)sub_10010266C(a1);
  }
  else {
    uint64_t result = (uint64_t)sub_1000FDF10((uint64_t *)a1, 0);
  }
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  if (v8 >= 2) {
    unint64_t v9 = v8 - 2;
  }
  else {
    unint64_t v9 = 0;
  }
  if (v8 >= 3)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    uint64_t v15 = *(void *)result;
    uint64_t v16 = v5 + 2;
    char v17 = (unsigned char *)(v6 + 16);
    do
    {
      uint64_t result = *((void *)v16 - 2);
      uint64_t v18 = *((void *)v17 - 2);
      if (result == v7)
      {
        if (v18 != v7) {
          goto LABEL_2;
        }
        uint64_t result = *v16;
        int v19 = *v17;
        if (*v16) {
          goto LABEL_29;
        }
      }
      else
      {
        if (v18 == v7) {
          return result;
        }
        uint64_t v12 = result - v15;
        uint64_t v13 = v18 - v15;
        if (result - v15 < v18 - v15) {
          return result;
        }
        if (v13 < v12 || (uint64_t v10 = *((void *)v16 - 1) - result, v11 = *((void *)v17 - 1) - v18, v10 != v11))
        {
LABEL_35:
          if (v9 == v14 || v13 >= v12 && v11 <= v10 && (*v16 || !*v17)) {
            return result;
          }
LABEL_2:
          return sub_100100624(a1, (uint64_t)a2);
        }
        int v19 = *v17;
        if (*v16)
        {
          uint64_t v11 = *((void *)v16 - 1) - result;
LABEL_29:
          if (!v19) {
            return result;
          }
          goto LABEL_33;
        }
        uint64_t v11 = *((void *)v16 - 1) - result;
      }
      if (v19) {
        goto LABEL_35;
      }
LABEL_33:
      ++v14;
      v16 += 24;
      v17 += 24;
    }
    while (v14 < v9);
  }
  return result;
}

uint64_t sub_1000FE55C(uint64_t a1, __n128 a2)
{
  uint64_t v3 = *(void *)(a1 + 88);
  int v4 = *(_DWORD *)(v3 + 16);
  *(unsigned char *)(a1 + 120) = *(unsigned char *)(v3 + 20);
  switch(v4)
  {
    case -5:
      unint64_t v14 = sub_1000FDF10(*(uint64_t **)(a1 + 16), 0);
      unint64_t v15 = *(void *)(a1 + 216) - 40;
      if (v15 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v15 = *(void *)(a1 + 216) - 40;
      }
      uint64_t result = 1;
      *(_DWORD *)unint64_t v15 = 1;
      *(_DWORD *)(v15 + 8) = 0;
      *(_OWORD *)(v15 + 16) = *(_OWORD *)v14;
      *(unsigned char *)(v15 + 32) = *((unsigned char *)v14 + 16);
      *(void *)(a1 + 216) = v15;
      uint64_t v16 = *(void *)(a1 + 16);
      uint64_t v17 = *(void *)(a1 + 40);
      *(void *)(*(void *)v16 + 48) = v17;
      *(void *)(*(void *)v16 + 32) = v17;
      *(unsigned char *)(*(void *)v16 + 40) = *(void *)(*(void *)v16 + 24) != *(void *)(*(void *)v16 + 32);
      *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
      return result;
    case -4:
      uint64_t v8 = *(void *)(v3 + 8);
      uint64_t v9 = *(void *)(v8 + 8);
      *(void *)(a1 + 88) = v9;
      if (*(_DWORD *)v9 != 27)
      {
        int v20 = *(_DWORD *)(v9 + 16);
        uint64_t v21 = *(void *)(a1 + 40);
        uint64_t v22 = *(void *)(*(void *)(*(void *)(v9 + 8) + 16) + 8);
        *(void *)(a1 + 88) = *(void *)(*(void *)(v9 + 8) + 8);
        int v23 = sub_1000FE168(a1, a2);
        *(void *)(a1 + 40) = v21;
        if ((((v20 == -2) ^ v23) & 1) == 0) {
          uint64_t v22 = *(void *)(v8 + 16);
        }
        *(void *)(a1 + 88) = v22;
        return 1;
      }
      if (sub_1000FFF00(a1)) {
        return 1;
      }
      uint64_t v10 = *(void *)(v8 + 16);
      goto LABEL_20;
    case -3:
      char v11 = *(unsigned char *)(a1 + 123);
      *(unsigned char *)(a1 + 123) = 1;
      uint64_t v12 = *(void *)(*(void *)(*(void *)(v3 + 8) + 16) + 8);
      *(void *)(a1 + 88) = *(void *)(*(void *)(v3 + 8) + 8);
      uint64_t result = sub_1000FE168(a1, a2);
      if ((result & 1) != 0 || *(unsigned char *)(a1 + 123))
      {
        *(void *)(a1 + 88) = v12;
        *(unsigned char *)(a1 + 123) = v11;
      }
      else if (**(_DWORD **)(a1 + 216))
      {
        do
        {
          *(_WORD *)(a1 + 228) = 0;
          *(unsigned char *)(a1 + 230) = 0;
          while ((((uint64_t (*)(uint64_t, void))off_1001BD568[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228)) & 1) != 0);
          uint64_t result = 0;
        }
        while (**(_DWORD **)(a1 + 216));
      }
      else
      {
        return 0;
      }
      return result;
    case -2:
    case -1:
      uint64_t v5 = *(void *)(*(void *)(*(void *)(v3 + 8) + 16) + 8);
      *(void *)(a1 + 88) = *(void *)(*(void *)(v3 + 8) + 8);
      unint64_t v6 = *(void *)(a1 + 216) - 32;
      if (v6 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v6 = *(void *)(a1 + 216) - 32;
      }
      uint64_t v7 = *(void *)(a1 + 40);
      *(_DWORD *)unint64_t v6 = 3;
      *(void *)(v6 + 8) = v5;
      *(void *)(v6 + 16) = v7;
      *(unsigned char *)(v6 + 24) = v4 == -1;
      *(void *)(a1 + 216) = v6;
      return 1;
    case 0:
      goto LABEL_19;
    default:
      if ((*(unsigned char *)(a1 + 98) & 4) == 0)
      {
        uint64_t v18 = sub_1000FDF10(*(uint64_t **)(a1 + 16), v4);
        unint64_t v19 = *(void *)(a1 + 216) - 40;
        if (v19 < *(void *)(a1 + 208))
        {
          sub_1001004C4((__n128 *)a1);
          unint64_t v19 = *(void *)(a1 + 216) - 40;
        }
        *(_DWORD *)unint64_t v19 = 1;
        *(_DWORD *)(v19 + 8) = v4;
        *(_OWORD *)(v19 + 16) = *(_OWORD *)v18;
        *(unsigned char *)(v19 + 32) = *((unsigned char *)v18 + 16);
        *(void *)(a1 + 216) = v19;
        *(void *)(**(void **)(a1 + 16) + 24 * v4 + 48) = *(void *)(a1 + 40);
      }
      uint64_t v3 = *(void *)(a1 + 88);
LABEL_19:
      uint64_t v10 = *(void *)(v3 + 8);
LABEL_20:
      *(void *)(a1 + 88) = v10;
      return 1;
  }
}

void sub_1000FE830(void *a1)
{
  __cxa_begin_catch(a1);
  *(void *)(v1 + 88) = v2;
  while (1)
  {
    *(_WORD *)(v1 + 228) = 1;
    *(unsigned char *)(v1 + 230) = 0;
    while ((((uint64_t (*)(uint64_t, void))off_1001BD568[2 * **(unsigned int **)(v1 + 216)])(v1, *(unsigned __int8 *)(v1 + 228)) & 1) != 0);
    if (!*(void *)(v1 + 88)) {
      __cxa_rethrow();
    }
  }
}

void sub_1000FE87C()
{
}

void sub_1000FE8E4()
{
}

uint64_t sub_1000FE914(__n128 *a1)
{
  unint64_t v2 = a1[5].n128_u64[1];
  uint64_t v3 = *(unsigned int *)(v2 + 16);
  a1[7].n128_u8[8] = *(unsigned char *)(v2 + 20);
  if ((int)v3 >= 1)
  {
    if ((a1[6].n128_u8[2] & 4) == 0) {
      sub_1000FE320((_DWORD *)a1[1].n128_u64[0], a1[2].n128_i64[1], v3, 1, 0);
    }
    unint64_t v4 = a1[12].n128_u64[0];
    if (a1[11].n128_u64[1] != v4 && v3 == *(_DWORD *)(v4 - 112))
    {
      a1[5].n128_u64[1] = *(void *)(v4 - 104);
      sub_100100624(a1[1].n128_i64[0], v4 - 96);
      unint64_t v5 = a1[12].n128_u64[0];
      int v6 = *(_DWORD *)(v5 - 112);
      uint64_t v7 = *(void *)(v5 - 104);
      uint64_t v8 = a1[1].n128_i64[0];
      uint64_t v9 = v5 - 96;
      unint64_t v10 = a1[13].n128_u64[1] - 184;
      if (v10 < a1[13].n128_u64[0])
      {
        sub_1001004C4(a1);
        unint64_t v10 = a1[13].n128_u64[1] - 184;
      }
      a1[13].n128_u64[1] = sub_10010089C(v10, v6, v7, v8, v9);
      unint64_t v11 = a1[12].n128_u64[0];
      unint64_t v12 = v11 - 112;
      sub_100104004(v11 - 96);
      a1[12].n128_u64[0] = v12;
      int v13 = -2 - v3;
      unint64_t v14 = (_DWORD *)(a1[13].n128_u64[1] - 48);
      if ((unint64_t)v14 < a1[13].n128_u64[0])
      {
        sub_1001004C4(a1);
        unint64_t v14 = (_DWORD *)(a1[13].n128_u64[1] - 48);
        unint64_t v12 = a1[12].n128_u64[0];
      }
      uint64_t v15 = a1[2].n128_i64[1];
      if (a1[11].n128_u64[1] == v12) {
        int v16 = -2147483645;
      }
      else {
        int v16 = *(_DWORD *)(v12 - 112);
      }
      _DWORD *v14 = 5;
      sub_100100A38((uint64_t)(v14 + 2), v13, (uint64_t *)&a1[8], v15, v16);
      a1[13].n128_u64[1] = (unint64_t)v14;
    }
    goto LABEL_19;
  }
  if (v3) {
    BOOL v17 = v3 == -4;
  }
  else {
    BOOL v17 = 1;
  }
  if (v17)
  {
LABEL_19:
    unint64_t v18 = *(void *)(a1[5].n128_u64[1] + 8);
    goto LABEL_20;
  }
  unint64_t v18 = 0;
LABEL_20:
  a1[5].n128_u64[1] = v18;
  return 1;
}

BOOL sub_1000FEA94(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 88);
  unint64_t v3 = *(unsigned int *)(v2 + 16);
  if (v3)
  {
    unint64_t v4 = *(unsigned __int8 **)(a1 + 40);
    if (v4 == *(unsigned __int8 **)(a1 + 32))
    {
      return 0;
    }
    else
    {
      BOOL v5 = 0;
      uint64_t v6 = 0;
      uint64_t v7 = v2 + 24;
      do
      {
        unsigned __int8 v8 = *v4;
        if (*(unsigned char *)(a1 + 120)) {
          unsigned __int8 v8 = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), (char)v8);
        }
        if (*(unsigned __int8 *)(v7 + v6) != v8) {
          break;
        }
        unint64_t v4 = (unsigned __int8 *)(*(void *)(a1 + 40) + 1);
        *(void *)(a1 + 40) = v4;
        if (v3 - 1 == v6)
        {
          uint64_t v2 = *(void *)(a1 + 88);
          goto LABEL_12;
        }
        BOOL v5 = ++v6 >= v3;
      }
      while (v4 != *(unsigned __int8 **)(a1 + 32));
    }
  }
  else
  {
LABEL_12:
    *(void *)(a1 + 88) = *(void *)(v2 + 8);
    return 1;
  }
  return v5;
}

uint64_t sub_1000FEB88(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)(a1 + 40);
  int v2 = *(_DWORD *)(a1 + 96);
  if (v1 != *(unsigned char **)(a1 + 64))
  {
    if ((v2 & 0x100000) != 0) {
      return 0;
    }
    goto LABEL_7;
  }
  if ((v2 & 0x100) != 0)
  {
LABEL_7:
    unsigned int v3 = *(v1 - 1);
    if (*(unsigned char **)(a1 + 32) == v1)
    {
      if (v3 > 0xD || ((1 << v3) & 0x3400) == 0) {
        return 0;
      }
    }
    else
    {
      BOOL v4 = v3 == 10 || v3 == 12;
      if (!v4 && (v3 != 13 || *v1 == 10)) {
        return 0;
      }
    }
    goto LABEL_19;
  }
  if (v2) {
    return 0;
  }
LABEL_19:
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return 1;
}

uint64_t sub_1000FEC18(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 40);
  int v2 = *(_DWORD *)(a1 + 96);
  if (v1 != *(unsigned __int8 **)(a1 + 32))
  {
    if ((v2 & 0x100000) == 0)
    {
      unsigned int v3 = *v1;
      if (v3 <= 0xD && ((1 << v3) & 0x3400) != 0)
      {
        if ((v2 & 0x100) == 0 && v1 == *(unsigned __int8 **)(a1 + 64)) {
          goto LABEL_16;
        }
        if (*(v1 - 1) != 13 || v3 != 10) {
          goto LABEL_16;
        }
      }
    }
    return 0;
  }
  if ((v2 & 2) != 0) {
    return 0;
  }
LABEL_16:
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return 1;
}

uint64_t sub_1000FEC8C(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)(a1 + 40);
  if (v1 == *(unsigned char **)(a1 + 32)) {
    return 0;
  }
  int v2 = *v1;
  if ((v2 - 12) >= 2)
  {
    if (!*v1)
    {
      if ((*(unsigned char *)(a1 + 96) & 0x80) == 0) {
        goto LABEL_6;
      }
      return 0;
    }
    if (v2 != 10)
    {
LABEL_6:
      *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
      *(void *)(a1 + 40) = v1 + 1;
      return 1;
    }
  }
  if ((*(unsigned char *)(*(void *)(a1 + 88) + 16) & *(unsigned char *)(a1 + 180)) != 0) {
    goto LABEL_6;
  }
  return 0;
}

BOOL sub_1000FECF4(__n128 *a1)
{
  unint64_t v2 = a1[12].n128_u64[0];
  if (a1[11].n128_u64[1] != v2)
  {
    uint64_t v3 = *(void *)(v2 - 104);
    a1[5].n128_u64[1] = v3;
    int v4 = *(_DWORD *)(v2 - 112);
    uint64_t v5 = a1[1].n128_i64[0];
    uint64_t v6 = v2 - 96;
    unint64_t v7 = a1[13].n128_u64[0];
    unint64_t v8 = a1[13].n128_u64[1] - 184;
    if (v8 < v7)
    {
      sub_1001004C4(a1);
      unint64_t v8 = a1[13].n128_u64[1] - 184;
    }
    a1[13].n128_u64[1] = sub_10010089C(v8, v4, v3, v5, v6);
    sub_100100624(a1[1].n128_i64[0], a1[12].n128_u64[0] - 96);
    unint64_t v9 = a1[12].n128_u64[0];
    unint64_t v10 = v9 - 112;
    sub_100104004(v9 - 96);
    a1[12].n128_u64[0] = v10;
    return 1;
  }
  unsigned __int32 v12 = a1[6].n128_u32[0];
  if ((v12 & 0x800) != 0)
  {
    if (a1[2].n128_u64[1] == *sub_1000FDF10((uint64_t *)a1[1].n128_u64[0], 0)) {
      return 0;
    }
    unsigned __int32 v12 = a1[6].n128_u32[0];
  }
  if ((v12 & 0x8000) != 0 && a1[2].n128_u64[1] != a1[2].n128_u64[0]) {
    return 0;
  }
  if ((v12 & 0x4000) != 0)
  {
    unint64_t v13 = a1[2].n128_u64[1];
    if (v13 == a1[3].n128_u64[1]) {
      return 0;
    }
  }
  else
  {
    unint64_t v13 = a1[2].n128_u64[1];
  }
  unint64_t v14 = a1[1].n128_u64[0];
  *(void *)(*(void *)v14 + 56) = v13;
  uint64_t v15 = *(void *)v14;
  *(unsigned char *)(v15 + 64) = 1;
  *(void *)uint64_t v15 = v13;
  *(unsigned char *)(*(void *)v14 + 16) = **(void **)v14 != *(void *)(*(void *)v14 + 8);
  *(void *)(v14 + 32) = v13;
  *(void *)(v14 + 40) = v13;
  *(unsigned char *)(v14 + 48) = 0;
  *(unsigned char *)(v14 + 76) = 0;
  a1[5].n128_u64[1] = 0;
  a1[7].n128_u8[10] = 1;
  if ((v12 & 0x20000) == 0) {
    return 1;
  }
  sub_1000FE37C(a1->n128_u64[0], (void *)a1[1].n128_u64[0]);
  return (a1[6].n128_u8[1] & 4) != 0;
}

uint64_t sub_1000FEE5C(uint64_t a1)
{
  unint64_t v2 = *(char **)(a1 + 40);
  if (v2 == *(char **)(a1 + 32))
  {
    int v3 = 0;
    uint64_t result = 0;
    if ((*(unsigned char *)(a1 + 96) & 0x20) != 0) {
      return result;
    }
  }
  else
  {
    int v3 = sub_1000FE014(*(void *)(a1 + 80), *v2, *(_DWORD *)(a1 + 176));
    unint64_t v2 = *(char **)(a1 + 40);
  }
  if (v2 != *(char **)(a1 + 64) || (int v5 = *(_DWORD *)(a1 + 96), (v5 & 0x100) != 0))
  {
    *(void *)(a1 + 40) = v2 - 1;
    int v7 = sub_1000FE014(*(void *)(a1 + 80), *(v2 - 1), *(_DWORD *)(a1 + 176));
    ++*(void *)(a1 + 40);
    if (v3 == v7) {
      return 0;
    }
  }
  else
  {
    if ((v5 & 0x10) != 0) {
      char v6 = 0;
    }
    else {
      char v6 = v3;
    }
    if ((v6 & 1) == 0) {
      return 0;
    }
  }
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return 1;
}

uint64_t sub_1000FEF18(uint64_t a1)
{
  int v2 = sub_1000FEE5C(a1);
  if ((v2 & 1) == 0) {
    *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  }
  return v2 ^ 1u;
}

BOOL sub_1000FEF50(uint64_t a1)
{
  uint64_t v1 = *(char **)(a1 + 40);
  if (v1 == *(char **)(a1 + 32)) {
    return 0;
  }
  BOOL result = sub_1000FE014(*(void *)(a1 + 80), *v1, *(_DWORD *)(a1 + 176));
  if (!result) {
    return result;
  }
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4 != *(void *)(a1 + 64) || (int v5 = *(_DWORD *)(a1 + 96), (v5 & 0x100) != 0))
  {
    if (sub_1000FE014(*(void *)(a1 + 80), *(char *)(v4 - 1), *(_DWORD *)(a1 + 176))) {
      return 0;
    }
  }
  else if ((v5 & 0x10) != 0)
  {
    return 0;
  }
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return 1;
}

BOOL sub_1000FEFD8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2 == *(void *)(a1 + 64) && (*(unsigned char *)(a1 + 97) & 1) == 0) {
    return 0;
  }
  BOOL result = sub_1000FE014(*(void *)(a1 + 80), *(char *)(v2 - 1), *(_DWORD *)(a1 + 176));
  if (!result) {
    return result;
  }
  uint64_t v4 = *(char **)(a1 + 40);
  if (v4 == *(char **)(a1 + 32))
  {
    if ((*(unsigned char *)(a1 + 96) & 0x20) != 0) {
      return 0;
    }
  }
  else if (sub_1000FE014(*(void *)(a1 + 80), *v4, *(_DWORD *)(a1 + 176)))
  {
    return 0;
  }
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return 1;
}

uint64_t sub_1000FF064(uint64_t a1)
{
  if (*(void *)(a1 + 40) != *(void *)(a1 + 64) || (*(unsigned char *)(a1 + 96) & 4) != 0) {
    return 0;
  }
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return 1;
}

uint64_t sub_1000FF098(uint64_t a1)
{
  if (*(void *)(a1 + 40) != *(void *)(a1 + 32) || (*(unsigned char *)(a1 + 96) & 8) != 0) {
    return 0;
  }
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return 1;
}

uint64_t sub_1000FF0C8(uint64_t a1)
{
  int v2 = *(_DWORD *)(*(void *)(a1 + 88) + 16);
  if (v2 >= 0x40000000)
  {
    int v3 = **(uint64_t ***)(a1 + 72);
    v16[0] = 0;
    v16[1] = v2;
    uint64_t v4 = sub_100100B38(*v3, v3[1], (uint64_t)v16);
    uint64_t v6 = v5;
    uint64_t v7 = v4 + 8;
    do
    {
      int v2 = *(_DWORD *)(v7 - 8);
      if (v7 == v6) {
        break;
      }
      unint64_t v8 = sub_1000FDF10(*(uint64_t **)(a1 + 16), *(_DWORD *)(v7 - 8));
      v7 += 8;
    }
    while (!*((unsigned char *)v8 + 16));
  }
  if ((*(unsigned char *)(a1 + 98) & 1) == 0 || *((unsigned char *)sub_1000FDF10(*(uint64_t **)(a1 + 16), v2) + 16))
  {
    unint64_t v9 = (char *)*sub_1000FDF10(*(uint64_t **)(a1 + 16), v2);
    uint64_t v10 = sub_1000FDF10(*(uint64_t **)(a1 + 16), v2)[1];
    if (v9 == (char *)v10)
    {
LABEL_16:
      *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
      return 1;
    }
    unint64_t v11 = *(char **)(a1 + 40);
    while (v11 != *(char **)(a1 + 32))
    {
      char v12 = *v11;
      if (*(unsigned char *)(a1 + 120))
      {
        uint64_t v13 = *(void *)(**(void **)(a1 + 80) + 8);
        char v12 = (*(uint64_t (**)(uint64_t, void))(*(void *)v13 + 40))(v13, v12);
        char v14 = *v9;
        if (*(unsigned char *)(a1 + 120)) {
          char v14 = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), v14);
        }
      }
      else
      {
        char v14 = *v9;
      }
      if (v12 != v14) {
        break;
      }
      ++v9;
      unint64_t v11 = (char *)(*(void *)(a1 + 40) + 1);
      *(void *)(a1 + 40) = v11;
      if (v9 == (char *)v10) {
        goto LABEL_16;
      }
    }
  }
  return 0;
}

uint64_t sub_1000FF278(uint64_t a1)
{
  int v2 = *(std::string::value_type **)(a1 + 40);
  int v3 = *(std::string::value_type **)(a1 + 32);
  if (v2 == v3) {
    return 0;
  }
  uint64_t v4 = sub_100100C00(v2, v3, *(void *)(a1 + 88), **(void **)(a1 + 72), *(unsigned __int8 *)(a1 + 120));
  if (*(std::string::value_type **)(a1 + 40) == v4) {
    return 0;
  }
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  *(void *)(a1 + 40) = v4;
  return 1;
}

uint64_t sub_1000FF2E4(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 40);
  if (v1 == *(unsigned __int8 **)(a1 + 32)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 88);
  unsigned __int8 v4 = *v1;
  if (*(unsigned char *)(a1 + 120)) {
    unsigned __int8 v4 = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), (char)v4);
  }
  if (!*(unsigned char *)(v3 + v4 + 16)) {
    return 0;
  }
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  ++*(void *)(a1 + 40);
  return 1;
}

uint64_t sub_1000FF388(uint64_t a1)
{
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 16);
  return 1;
}

uint64_t sub_1000FF39C(__n128 *a1)
{
  unint64_t v2 = a1[5].n128_u64[1];
  uint64_t v3 = (unsigned __int8 *)a1[2].n128_u64[1];
  if (v3 == (unsigned __int8 *)a1[2].n128_u64[0]) {
    unsigned int v4 = *(_DWORD *)(v2 + 280);
  }
  else {
    unsigned int v4 = *(unsigned __int8 *)(v2 + *v3 + 24);
  }
  int v5 = (v4 >> 1) & 1;
  if (v4)
  {
    if (v5)
    {
      uint64_t v7 = *(void *)(v2 + 16);
      unint64_t v8 = a1[13].n128_u64[1] - 24;
      if (v8 < a1[13].n128_u64[0])
      {
        sub_1001004C4(a1);
        unint64_t v8 = a1[13].n128_u64[1] - 24;
        uint64_t v3 = (unsigned __int8 *)a1[2].n128_u64[1];
      }
      *(_DWORD *)unint64_t v8 = 4;
      *(void *)(v8 + 8) = v7;
      *(void *)(v8 + 16) = v3;
      a1[13].n128_u64[1] = v8;
      unint64_t v2 = a1[5].n128_u64[1];
    }
    uint64_t v6 = (unint64_t *)(v2 + 8);
    goto LABEL_12;
  }
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v2 + 16);
LABEL_12:
    a1[5].n128_u64[1] = *v6;
    return 1;
  }
  return 0;
}

uint64_t sub_1000FF44C(__n128 *a1)
{
  unint64_t v2 = a1[5].n128_u64[1];
  uint64_t v3 = (unsigned __int8 *)a1[2].n128_u64[1];
  if (v3 == (unsigned __int8 *)a1[2].n128_u64[0]) {
    unsigned int v4 = *(_DWORD *)(v2 + 280);
  }
  else {
    unsigned int v4 = *(unsigned __int8 *)(v2 + *v3 + 24);
  }
  int v5 = v4 & 1;
  int v6 = (v4 >> 1) & 1;
  uint64_t v7 = (_DWORD *)a1[13].n128_u64[1];
  if (*v7 == 5)
  {
    int v8 = v7[6];
    int v9 = *(_DWORD *)(v2 + 304);
    if (v8 == v9)
    {
      unint64_t v10 = a1[8].n128_u64[0];
      int v9 = v7[6];
      if (*(_DWORD *)(v10 + 16) == v8) {
        goto LABEL_15;
      }
    }
  }
  else
  {
    int v9 = *(_DWORD *)(v2 + 304);
  }
  unint64_t v11 = v7 - 12;
  if ((unint64_t)(v7 - 12) < a1[13].n128_u64[0])
  {
    sub_1001004C4(a1);
    unint64_t v11 = (_DWORD *)(a1[13].n128_u64[1] - 48);
    uint64_t v3 = (unsigned __int8 *)a1[2].n128_u64[1];
  }
  unint64_t v12 = a1[12].n128_u64[0];
  if (a1[11].n128_u64[1] == v12) {
    int v13 = -2147483645;
  }
  else {
    int v13 = *(_DWORD *)(v12 - 112);
  }
  *unint64_t v11 = 5;
  sub_100100A38((uint64_t)(v11 + 2), v9, (uint64_t *)&a1[8], (uint64_t)v3, v13);
  a1[13].n128_u64[1] = (unint64_t)v11;
  unint64_t v10 = a1[8].n128_u64[0];
LABEL_15:
  unint64_t v14 = *(void *)(v2 + 296);
  if (*(void *)(v10 + 24))
  {
    unint64_t v15 = a1[2].n128_u64[1];
    if (v15 == *(void *)(v10 + 32))
    {
      *(void *)(v10 + 24) = v14;
      unint64_t v16 = v14;
      goto LABEL_20;
    }
  }
  else
  {
    unint64_t v15 = a1[2].n128_u64[1];
  }
  *(void *)(v10 + 32) = v15;
  unint64_t v10 = a1[8].n128_u64[0];
  unint64_t v16 = *(void *)(v10 + 24);
LABEL_20:
  if (v16 >= *(void *)(v2 + 288))
  {
    if (*(unsigned char *)(v2 + 309) && ((a1[6].n128_u8[1] & 4) == 0 || a1[7].n128_u8[11]))
    {
      if (v16 < v14) {
        int v18 = v5;
      }
      else {
        int v18 = 0;
      }
      if (v18 == 1)
      {
        if (v6)
        {
          uint64_t v19 = *(void *)(v2 + 16);
          unint64_t v20 = a1[13].n128_u64[1] - 24;
          if (v20 < a1[13].n128_u64[0])
          {
            sub_1001004C4(a1);
            unint64_t v20 = a1[13].n128_u64[1] - 24;
          }
          unint64_t v21 = a1[2].n128_u64[1];
          *(_DWORD *)unint64_t v20 = 4;
          *(void *)(v20 + 8) = v19;
          *(void *)(v20 + 16) = v21;
          a1[13].n128_u64[1] = v20;
          unint64_t v10 = a1[8].n128_u64[0];
          unint64_t v16 = *(void *)(v10 + 24);
        }
        goto LABEL_22;
      }
      if (!v6) {
        return 0;
      }
    }
    else
    {
      if (v16 < v14) {
        int v22 = v5;
      }
      else {
        int v22 = 0;
      }
      if (!v6)
      {
        if (v22) {
          goto LABEL_22;
        }
        return 0;
      }
      if (v22)
      {
        uint64_t v23 = *(void *)(v2 + 8);
        unint64_t v24 = a1[13].n128_u64[1] - 24;
        if (v24 < a1[13].n128_u64[0])
        {
          sub_1001004C4(a1);
          unint64_t v24 = a1[13].n128_u64[1] - 24;
        }
        unint64_t v25 = a1[2].n128_u64[1];
        *(_DWORD *)unint64_t v24 = 13;
        *(void *)(v24 + 8) = v23;
        *(void *)(v24 + 16) = v25;
        a1[13].n128_u64[1] = v24;
      }
    }
    BOOL v17 = (unint64_t *)(v2 + 16);
    goto LABEL_44;
  }
  if (v5)
  {
LABEL_22:
    *(void *)(v10 + 24) = v16 + 1;
    BOOL v17 = (unint64_t *)(v2 + 8);
LABEL_44:
    a1[5].n128_u64[1] = *v17;
    return 1;
  }
  return 0;
}

BOOL sub_1000FF680(uint64_t a1)
{
  unint64_t v2 = *(char **)(a1 + 32);
  uint64_t v1 = *(char **)(a1 + 40);
  if (v1 != v2)
  {
    if (*(unsigned char *)(a1 + 120))
    {
      uint64_t v4 = *(void *)(**(void **)(a1 + 80) + 8);
      (*(void (**)(uint64_t, void))(*(void *)v4 + 40))(v4, *v1);
      int v5 = *(char **)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 40);
    }
    else
    {
      int v5 = *(char **)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 40);
    }
    uint64_t v7 = (char *)(v6 + 1);
    *(void *)(a1 + 40) = v7;
    if (v7 != v5 && *(unsigned char *)(a1 + 120))
    {
      uint64_t v8 = *(void *)(**(void **)(a1 + 80) + 8);
      (*(void (**)(uint64_t, void))(*(void *)v8 + 40))(v8, *v7);
    }
    *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  }
  return v1 != v2;
}

uint64_t sub_1000FF760(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 96) & 8) != 0) {
    return 0;
  }
  unint64_t v2 = *(unsigned __int8 **)(a1 + 40);
  if (*(unsigned __int8 **)(a1 + 32) != v2)
  {
    while (1)
    {
      unsigned __int8 v3 = *v2;
      if (*(unsigned char *)(a1 + 120)) {
        unsigned __int8 v3 = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), (char)v3);
      }
      if (v3 > 0xDu || ((1 << v3) & 0x3400) == 0) {
        break;
      }
      if (++v2 == *(unsigned __int8 **)(a1 + 32)) {
        goto LABEL_10;
      }
    }
    if (v2 != *(unsigned __int8 **)(a1 + 32)) {
      return 0;
    }
  }
LABEL_10:
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return 1;
}

BOOL sub_1000FF834(void *a1)
{
  uint64_t v1 = a1[5];
  uint64_t v2 = a1[7];
  if (v1 == v2) {
    a1[11] = *(void *)(a1[11] + 8);
  }
  return v1 == v2;
}

uint64_t sub_1000FF860(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 88);
  if (*(unsigned char *)(v2 + 309))
  {
    if ((*(unsigned char *)(a1 + 97) & 4) == 0)
    {
      unsigned __int8 v3 = (unint64_t *)(v2 + 296);
      uint64_t v4 = (unint64_t *)(v2 + 288);
LABEL_6:
      int v5 = 1;
      uint64_t v6 = v3;
      goto LABEL_9;
    }
    unsigned __int8 v3 = (unint64_t *)(v2 + 296);
    uint64_t v4 = (unint64_t *)(v2 + 288);
    if (*(unsigned char *)(a1 + 123)) {
      goto LABEL_6;
    }
    int v5 = 0;
  }
  else
  {
    int v5 = 0;
    unsigned __int8 v3 = (unint64_t *)(v2 + 296);
    uint64_t v4 = (unint64_t *)(v2 + 288);
  }
  uint64_t v6 = v4;
LABEL_9:
  unint64_t v7 = *v6;
  uint64_t v8 = *(unsigned __int8 **)(a1 + 40);
  if (v7 == -1)
  {
    int v9 = *(unsigned __int8 **)(a1 + 32);
  }
  else if (v7 >= *(void *)(a1 + 32) - (void)v8)
  {
    int v9 = *(unsigned __int8 **)(a1 + 32);
  }
  else
  {
    int v9 = &v8[v7];
  }
  if (v9 == v8)
  {
    unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
  }
  else
  {
    int v10 = *(unsigned __int8 *)(*(void *)(v2 + 8) + 24);
    unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
    while (1)
    {
      unsigned __int8 v12 = *v11;
      if (*(unsigned char *)(a1 + 120))
      {
        unsigned __int8 v12 = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), (char)v12);
        unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
      }
      if (v10 != v12) {
        break;
      }
      *(void *)(a1 + 40) = ++v11;
      if (v11 == v9)
      {
        unint64_t v11 = v9;
        break;
      }
    }
  }
  unint64_t v13 = (v11 - v8);
  unint64_t v14 = *v4;
  if (v13 < *v4) {
    return 0;
  }
  if (v5)
  {
    if (*(unsigned char *)(v2 + 308) && v13 < *v3) {
      *(void *)(a1 + 48) = v11;
    }
    if (v13 != v14)
    {
      unint64_t v16 = *(void *)(a1 + 216) - 32;
      if (v16 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v16 = *(void *)(a1 + 216) - 32;
      }
      *(_DWORD *)unint64_t v16 = 7;
      *(void *)(v16 + 8) = v13;
      *(void *)(v16 + 16) = v2;
      *(void *)(v16 + 24) = v11;
      *(void *)(a1 + 216) = v16;
    }
    *(void *)(a1 + 88) = *(void *)(v2 + 16);
    return 1;
  }
  else
  {
    if (v13 < *v3)
    {
      unint64_t v17 = *(void *)(a1 + 216) - 32;
      if (v17 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v17 = *(void *)(a1 + 216) - 32;
      }
      *(_DWORD *)unint64_t v17 = 10;
      *(void *)(v17 + 8) = v13;
      *(void *)(v17 + 16) = v2;
      *(void *)(v17 + 24) = v11;
      *(void *)(a1 + 216) = v17;
      unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
    }
    *(void *)(a1 + 88) = *(void *)(v2 + 16);
    if (v11 == *(unsigned __int8 **)(a1 + 32)) {
      unsigned int v18 = *(unsigned __int8 *)(v2 + 280);
    }
    else {
      unsigned int v18 = *(unsigned __int8 *)(v2 + *v11 + 24);
    }
    return (v18 >> 1) & 1;
  }
}

uint64_t sub_1000FFA90(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 88);
  if (*(unsigned char *)(v2 + 309))
  {
    if ((*(unsigned char *)(a1 + 97) & 4) == 0)
    {
      unsigned __int8 v3 = (unint64_t *)(v2 + 296);
      uint64_t v4 = (unint64_t *)(v2 + 288);
LABEL_6:
      int v5 = 1;
      uint64_t v6 = v3;
      goto LABEL_9;
    }
    unsigned __int8 v3 = (unint64_t *)(v2 + 296);
    uint64_t v4 = (unint64_t *)(v2 + 288);
    if (*(unsigned char *)(a1 + 123)) {
      goto LABEL_6;
    }
    int v5 = 0;
  }
  else
  {
    int v5 = 0;
    unsigned __int8 v3 = (unint64_t *)(v2 + 296);
    uint64_t v4 = (unint64_t *)(v2 + 288);
  }
  uint64_t v6 = v4;
LABEL_9:
  unint64_t v7 = *v6;
  uint64_t v8 = *(unsigned __int8 **)(a1 + 40);
  if (v7 == -1)
  {
    int v9 = *(unsigned __int8 **)(a1 + 32);
  }
  else if (v7 >= *(void *)(a1 + 32) - (void)v8)
  {
    int v9 = *(unsigned __int8 **)(a1 + 32);
  }
  else
  {
    int v9 = &v8[v7];
  }
  if (v9 == v8)
  {
    unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
  }
  else
  {
    uint64_t v10 = *(void *)(v2 + 8) + 16;
    unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
    while (1)
    {
      unsigned __int8 v12 = *v11;
      if (*(unsigned char *)(a1 + 120))
      {
        unsigned __int8 v12 = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), (char)v12);
        unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
      }
      if (!*(unsigned char *)(v10 + v12)) {
        break;
      }
      *(void *)(a1 + 40) = ++v11;
      if (v11 == v9)
      {
        unint64_t v11 = v9;
        break;
      }
    }
  }
  unint64_t v13 = (v11 - v8);
  unint64_t v14 = *v4;
  if (v13 < *v4) {
    return 0;
  }
  if (v5)
  {
    if (*(unsigned char *)(v2 + 308) && v13 < *v3) {
      *(void *)(a1 + 48) = v11;
    }
    if (v13 != v14)
    {
      unint64_t v16 = *(void *)(a1 + 216) - 32;
      if (v16 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v16 = *(void *)(a1 + 216) - 32;
      }
      *(_DWORD *)unint64_t v16 = 7;
      *(void *)(v16 + 8) = v13;
      *(void *)(v16 + 16) = v2;
      *(void *)(v16 + 24) = v11;
      *(void *)(a1 + 216) = v16;
    }
    *(void *)(a1 + 88) = *(void *)(v2 + 16);
    return 1;
  }
  else
  {
    if (v13 < *v3)
    {
      unint64_t v17 = *(void *)(a1 + 216) - 32;
      if (v17 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v17 = *(void *)(a1 + 216) - 32;
      }
      *(_DWORD *)unint64_t v17 = 11;
      *(void *)(v17 + 8) = v13;
      *(void *)(v17 + 16) = v2;
      *(void *)(v17 + 24) = v11;
      *(void *)(a1 + 216) = v17;
      unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
    }
    *(void *)(a1 + 88) = *(void *)(v2 + 16);
    if (v11 == *(unsigned __int8 **)(a1 + 32)) {
      unsigned int v18 = *(unsigned __int8 *)(v2 + 280);
    }
    else {
      unsigned int v18 = *(unsigned __int8 *)(v2 + *v11 + 24);
    }
    return (v18 >> 1) & 1;
  }
}

uint64_t sub_1000FFCC4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 88);
  if (*(unsigned char *)(v2 + 309))
  {
    if ((*(unsigned char *)(a1 + 97) & 4) == 0)
    {
      unsigned __int8 v3 = (unint64_t *)(v2 + 296);
      uint64_t v4 = (unint64_t *)(v2 + 288);
LABEL_6:
      int v5 = 1;
      uint64_t v6 = v3;
      goto LABEL_9;
    }
    unsigned __int8 v3 = (unint64_t *)(v2 + 296);
    uint64_t v4 = (unint64_t *)(v2 + 288);
    if (*(unsigned char *)(a1 + 123)) {
      goto LABEL_6;
    }
    int v5 = 0;
  }
  else
  {
    int v5 = 0;
    unsigned __int8 v3 = (unint64_t *)(v2 + 296);
    uint64_t v4 = (unint64_t *)(v2 + 288);
  }
  uint64_t v6 = v4;
LABEL_9:
  unint64_t v7 = *v6;
  uint64_t v8 = *(unsigned __int8 **)(a1 + 40);
  if (v7 == -1)
  {
    int v9 = *(unsigned __int8 **)(a1 + 32);
  }
  else if (v7 >= *(void *)(a1 + 32) - (void)v8)
  {
    int v9 = *(unsigned __int8 **)(a1 + 32);
  }
  else
  {
    int v9 = &v8[v7];
  }
  if (v9 == v8)
  {
    unint64_t v11 = *(std::string::value_type **)(a1 + 40);
    int v9 = *(unsigned __int8 **)(a1 + 40);
  }
  else
  {
    uint64_t v10 = *(void *)(v2 + 8);
    unint64_t v11 = *(std::string::value_type **)(a1 + 40);
    while (1)
    {
      unsigned __int8 v12 = sub_100100C00(v11, *(std::string::value_type **)(a1 + 32), v10, **(void **)(a1 + 72), *(unsigned __int8 *)(a1 + 120));
      unint64_t v11 = *(std::string::value_type **)(a1 + 40);
      if (v11 == v12) {
        break;
      }
      *(void *)(a1 + 40) = ++v11;
      if (v11 == (std::string::value_type *)v9) {
        goto LABEL_21;
      }
    }
    int v9 = (unsigned __int8 *)v12;
  }
LABEL_21:
  unint64_t v13 = (v9 - v8);
  unint64_t v14 = *v4;
  if (v13 < *v4) {
    return 0;
  }
  if (v5)
  {
    if (*(unsigned char *)(v2 + 308) && v13 < *v3) {
      *(void *)(a1 + 48) = v11;
    }
    if (v13 != v14)
    {
      unint64_t v16 = *(void *)(a1 + 216) - 32;
      if (v16 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v16 = *(void *)(a1 + 216) - 32;
      }
      *(_DWORD *)unint64_t v16 = 7;
      *(void *)(v16 + 8) = v13;
      *(void *)(v16 + 16) = v2;
      *(void *)(v16 + 24) = v9;
      *(void *)(a1 + 216) = v16;
    }
    *(void *)(a1 + 88) = *(void *)(v2 + 16);
    return 1;
  }
  else
  {
    if (v13 < *v3)
    {
      unint64_t v17 = *(void *)(a1 + 216) - 32;
      if (v17 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v17 = *(void *)(a1 + 216) - 32;
      }
      *(_DWORD *)unint64_t v17 = 12;
      *(void *)(v17 + 8) = v13;
      *(void *)(v17 + 16) = v2;
      *(void *)(v17 + 24) = v9;
      *(void *)(a1 + 216) = v17;
      int v9 = *(unsigned __int8 **)(a1 + 40);
    }
    *(void *)(a1 + 88) = *(void *)(v2 + 16);
    if (v9 == *(unsigned __int8 **)(a1 + 32)) {
      unsigned int v18 = *(unsigned __int8 *)(v2 + 280);
    }
    else {
      unsigned int v18 = *(unsigned __int8 *)(v2 + *v9 + 24);
    }
    return (v18 >> 1) & 1;
  }
}

BOOL sub_1000FFEC8(void *a1)
{
  uint64_t v1 = a1[5];
  uint64_t v2 = v1 - a1[8];
  uint64_t v3 = a1[11];
  uint64_t v4 = *(int *)(v3 + 16);
  if (v2 >= v4)
  {
    a1[5] = v1 - v4;
    a1[11] = *(void *)(v3 + 8);
  }
  return v2 >= v4;
}

BOOL sub_1000FFF00(uint64_t a1)
{
  int v1 = *(_DWORD *)(*(void *)(a1 + 88) + 16);
  if (v1 == 9999) {
    return 0;
  }
  if (v1 < 1)
  {
    if (v1 > -1073741825)
    {
      uint64_t v17 = *(void *)(a1 + 192);
      if (*(void *)(a1 + 184) != v17)
      {
        int v18 = *(_DWORD *)(v17 - 112);
        if (v1) {
          BOOL v19 = v18 == ~v1;
        }
        else {
          BOOL v19 = 1;
        }
        BOOL result = v19;
        goto LABEL_34;
      }
    }
    else
    {
      unsigned __int8 v12 = **(uint64_t ***)(a1 + 72);
      int v23 = 0;
      int v24 = ~v1;
      uint64_t v13 = sub_100100B38(*v12, v12[1], (uint64_t)&v23);
      uint64_t v15 = *(void *)(a1 + 192);
      if (*(void *)(a1 + 184) == v15) {
        int v16 = -1;
      }
      else {
        int v16 = *(_DWORD *)(v15 - 112);
      }
      if (v13 != v14)
      {
        uint64_t v20 = v13 + 8;
        do
        {
          int v21 = *(_DWORD *)(v20 - 8);
          BOOL result = v16 == v21;
          BOOL v22 = v16 == v21 || v20 == v14;
          v20 += 8;
        }
        while (!v22);
        goto LABEL_34;
      }
    }
    goto LABEL_33;
  }
  if (v1 >> 30)
  {
    uint64_t v4 = **(uint64_t ***)(a1 + 72);
    int v23 = 0;
    int v24 = v1;
    uint64_t v5 = sub_100100B38(*v4, v4[1], (uint64_t)&v23);
    if (v5 != v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = v5 + 8;
      do
      {
        int v9 = sub_1000FDF10(*(uint64_t **)(a1 + 16), *(_DWORD *)(v8 - 8));
        int v10 = *((unsigned __int8 *)v9 + 16);
        BOOL result = *((unsigned char *)v9 + 16) != 0;
        if (v10) {
          BOOL v11 = 1;
        }
        else {
          BOOL v11 = v8 == v7;
        }
        v8 += 8;
      }
      while (!v11);
      goto LABEL_34;
    }
LABEL_33:
    BOOL result = 0;
    goto LABEL_34;
  }
  BOOL result = *((unsigned char *)sub_1000FDF10(*(uint64_t **)(a1 + 16), v1) + 16) != 0;
LABEL_34:
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return result;
}

uint64_t sub_10010006C(__n128 *a1)
{
  unsigned __int8 v2 = a1[7].n128_u8[8];
  unint64_t v3 = a1[13].n128_u64[1] - 16;
  if (v3 < a1[13].n128_u64[0])
  {
    sub_1001004C4(a1);
    unint64_t v3 = a1[13].n128_u64[1] - 16;
  }
  *(_DWORD *)unint64_t v3 = 18;
  *(unsigned char *)(v3 + 8) = v2;
  a1[13].n128_u64[1] = v3;
  unint64_t v4 = a1[5].n128_u64[1];
  a1[7].n128_u8[8] = *(unsigned char *)(v4 + 16);
  a1[5].n128_u64[1] = *(void *)(v4 + 8);
  return 1;
}

uint64_t sub_1001000D8(__n128 *a1)
{
  unint64_t v2 = a1[12].n128_u64[0];
  unint64_t v3 = &a1[11].n128_i64[1];
  while (v2 != a1[11].n128_u64[1])
  {
    int v4 = *(_DWORD *)(v2 - 112);
    v2 -= 112;
    if (v4 == *(_DWORD *)(*(void *)(a1[5].n128_u64[1] + 16) + 16))
    {
      if (*(void *)(v2 + 104) == a1[2].n128_u64[1]) {
        return 0;
      }
      break;
    }
  }
  uint64_t v5 = (_DWORD *)(a1[13].n128_u64[1] - 8);
  if ((unint64_t)v5 < a1[13].n128_u64[0])
  {
    sub_1001004C4(a1);
    uint64_t v5 = (_DWORD *)(a1[13].n128_u64[1] - 8);
  }
  *uint64_t v5 = 15;
  a1[13].n128_u64[1] = (unint64_t)v5;
  unint64_t v6 = a1[12].n128_u64[1];
  if (v6 == a1[11].n128_u64[1])
  {
    sub_1001018E4(v3, 0x32uLL);
    unint64_t v6 = a1[12].n128_u64[1];
  }
  long long v21 = 0uLL;
  long long v20 = 0u;
  long long v18 = 0u;
  memset(v19, 0, sizeof(v19));
  BYTE12(v20) = 1;
  unint64_t v7 = a1[12].n128_u64[0];
  if (v7 >= v6)
  {
    uint64_t v8 = sub_100101B70(v3, &v18);
  }
  else
  {
    *(void *)unint64_t v7 = 0;
    *(void *)(v7 + 8) = 0;
    sub_10010090C(v7 + 16, (uint64_t)v19);
    *(_OWORD *)(v7 + 96) = v21;
    uint64_t v8 = v7 + 112;
    a1[12].n128_u64[0] = v7 + 112;
  }
  a1[12].n128_u64[0] = v8;
  sub_100104004((uint64_t)v19);
  unint64_t v9 = a1[12].n128_u64[0];
  *(void *)(v9 - 104) = *(void *)(a1[5].n128_u64[1] + 8);
  sub_100100624(v9 - 96, a1[1].n128_i64[0]);
  unint64_t v10 = *(void *)(a1[5].n128_u64[1] + 16);
  a1[5].n128_u64[1] = v10;
  unint64_t v11 = a1[12].n128_u64[0];
  *(_DWORD *)(v11 - 112) = *(_DWORD *)(v10 + 16);
  *(void *)(v11 - 8) = a1[2].n128_u64[1];
  int v12 = -2 - *(_DWORD *)(a1[5].n128_u64[1] + 16);
  uint64_t v13 = (_DWORD *)(a1[13].n128_u64[1] - 48);
  if ((unint64_t)v13 < a1[13].n128_u64[0])
  {
    sub_1001004C4(a1);
    uint64_t v13 = (_DWORD *)(a1[13].n128_u64[1] - 48);
  }
  uint64_t v14 = a1[2].n128_i64[1];
  unint64_t v15 = a1[12].n128_u64[0];
  if (a1[11].n128_u64[1] == v15) {
    int v16 = -2147483645;
  }
  else {
    int v16 = *(_DWORD *)(v15 - 112);
  }
  *uint64_t v13 = 5;
  sub_100100A38((uint64_t)(v13 + 2), v12, (uint64_t *)&a1[8], v14, v16);
  a1[13].n128_u64[1] = (unint64_t)v13;
  return 1;
}

void sub_1001002AC(_Unwind_Exception *a1)
{
  sub_100104004(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001002CC()
{
  return 0;
}

uint64_t sub_1001002D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 192);
  if (*(void *)(a1 + 184) == v1) {
    int v2 = 0x7FFFFFFF;
  }
  else {
    int v2 = *(_DWORD *)(v1 - 112);
  }
  return sub_100101CAC(a1, v2, 1);
}

uint64_t sub_1001002F4(__n128 *a1)
{
  int v2 = *(_DWORD *)(a1[5].n128_u64[1] + 16);
  if (v2 == 1)
  {
    unint64_t v4 = a1[2].n128_u64[1];
    if (a1[1].n128_u64[1] == v4) {
      goto LABEL_7;
    }
    unint64_t v3 = v4 - 1;
  }
  else
  {
    if (v2 != 2) {
      goto LABEL_7;
    }
    unint64_t v3 = a1[2].n128_u64[0];
  }
  a1[3].n128_u64[0] = v3;
LABEL_7:
  uint64_t v5 = (_DWORD *)(a1[13].n128_u64[1] - 8);
  if ((unint64_t)v5 < a1[13].n128_u64[0])
  {
    sub_1001004C4(a1);
    uint64_t v5 = (_DWORD *)(a1[13].n128_u64[1] - 8);
  }
  *uint64_t v5 = 16;
  a1[13].n128_u64[1] = (unint64_t)v5;
  a1[5].n128_u64[1] = *(void *)(a1[5].n128_u64[1] + 8);
  return 1;
}

uint64_t sub_100100388(__n128 *a1)
{
  int v2 = (_DWORD *)(a1[13].n128_u64[1] - 8);
  if ((unint64_t)v2 < a1[13].n128_u64[0])
  {
    sub_1001004C4(a1);
    int v2 = (_DWORD *)(a1[13].n128_u64[1] - 8);
  }
  _DWORD *v2 = 17;
  a1[13].n128_u64[1] = (unint64_t)v2;
  a1[5].n128_u64[1] = *(void *)(a1[5].n128_u64[1] + 8);
  return 1;
}

void sub_1001003E4(void **a1, int a2)
{
  sub_100101DD4(*a1, a2, (uint64_t)&v3);
  std::runtime_error::runtime_error(&v4, &v3);
  v4.__vftable = (std::runtime_error_vtbl *)&off_1001BD3D0;
  int v5 = a2;
  uint64_t v6 = 0;
  if (SHIBYTE(v3.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v3.__r_.__value_.__l.__data_);
  }
  sub_100101EA4((uint64_t)&v4);
}

void sub_100100458(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::runtime_error a16)
{
}

void *sub_100100484(void *result, uint64_t a2, uint64_t a3, int a4)
{
  if (!a3 && !a4) {
    return sub_1000FE0DC(result, a2);
  }
  *(void *)(*result + 24 * a3 + 48) = a2;
  if (a4)
  {
    *(void *)(*result + 32) = a2;
    *(unsigned char *)(*result + 40) = *(void *)(*result + 24) != *(void *)(*result + 32);
  }
  return result;
}

__n128 sub_1001004C4(__n128 *a1)
{
  unsigned __int32 v2 = a1[14].n128_u32[0];
  if (!v2)
  {
    uint64_t v8 = (void **)a1[5].n128_u64[0];
    sub_1001003E4(v8, 19);
  }
  a1[14].n128_u32[0] = v2 - 1;
  std::string v3 = (char *)sub_10010056C();
  uint64_t v4 = 0;
  while (1)
  {
    int v5 = (__n128 *)atomic_load((unint64_t *)&v3[v4]);
    if (v5)
    {
      uint64_t v6 = v5;
      atomic_compare_exchange_strong((atomic_ullong *volatile)&v3[v4], (unint64_t *)&v6, 0);
      if (v6 == v5) {
        break;
      }
    }
    v4 += 8;
    if (v4 == 128)
    {
      int v5 = (__n128 *)operator new(0x1000uLL);
      break;
    }
  }
  __n128 result = a1[13];
  v5[254].n128_u32[2] = 6;
  v5[255] = result;
  a1[13].n128_u64[0] = (unint64_t)v5;
  a1[13].n128_u64[1] = (unint64_t)&v5[254].n128_u64[1];
  return result;
}

void *sub_10010056C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1001D75A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1001D75A8))
  {
    __cxa_atexit((void (*)(void *))sub_1001005DC, &unk_1001D7528, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1001D75A8);
  }
  return &unk_1001D7528;
}

uint64_t sub_1001005DC(uint64_t a1)
{
  for (uint64_t i = 0; i != 128; i += 8)
  {
    if (atomic_load((unint64_t *)(a1 + i)))
    {
      uint64_t v4 = (void *)atomic_load((unint64_t *)(a1 + i));
      operator delete(v4);
    }
  }
  return a1;
}

uint64_t sub_100100624(uint64_t a1, uint64_t a2)
{
  if (a1 != a2) {
    sub_1001006CC((void *)a1, *(void *)a2, *(void *)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
  }
  uint64_t v5 = *(void *)(a2 + 56);
  uint64_t v4 = *(void *)(a2 + 64);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 64);
  *(void *)(a1 + 56) = v5;
  *(void *)(a1 + 64) = v4;
  if (v6) {
    sub_10000B678(v6);
  }
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  int v7 = *(unsigned __int8 *)(a2 + 76);
  *(unsigned char *)(a1 + 76) = v7;
  if (!v7)
  {
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
  }
  return a1;
}

void *sub_1001006CC(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = a1[2];
  __n128 result = (void *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - (uint64_t)result) >> 3) < a4)
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      sub_10002B5E0();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v11;
    }
    sub_100082C04(a1, v12);
    uint64_t v14 = (void *)a1[1];
    uint64_t v13 = (void **)(a1 + 1);
    __n128 result = v14;
    unint64_t v15 = v14;
    if (v6 != a3)
    {
      unint64_t v15 = result;
      do
      {
        *(_OWORD *)unint64_t v15 = *(_OWORD *)v6;
        *((unsigned char *)v15 + 16) = *(unsigned char *)(v6 + 16);
        v15 += 3;
        v6 += 24;
      }
      while (v6 != a3);
    }
LABEL_25:
    int64_t v22 = (char *)v15 - (char *)result;
    goto LABEL_26;
  }
  uint64_t v17 = (void *)a1[1];
  uint64_t v13 = (void **)(a1 + 1);
  int v16 = v17;
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * (v17 - result);
  if (v18 >= a4)
  {
    unint64_t v15 = result;
    if (a2 != a3)
    {
      int v23 = result;
      do
      {
        *int v23 = *(void *)v6;
        v23[1] = *(void *)(v6 + 8);
        *((unsigned char *)v23 + 16) = *(unsigned char *)(v6 + 16);
        v15 += 3;
        v6 += 24;
        v23 += 3;
      }
      while (v6 != a3);
    }
    goto LABEL_25;
  }
  uint64_t v19 = a2 + 24 * v18;
  if (v16 != result)
  {
    do
    {
      *__n128 result = *(void *)v6;
      result[1] = *(void *)(v6 + 8);
      *((unsigned char *)result + 16) = *(unsigned char *)(v6 + 16);
      v6 += 24;
      result += 3;
    }
    while (v6 != v19);
    __n128 result = *v13;
  }
  long long v20 = (char *)result;
  if (v19 != a3)
  {
    long long v20 = (char *)result;
    long long v21 = result;
    do
    {
      *(_OWORD *)long long v21 = *(_OWORD *)v19;
      *((unsigned char *)v21 + 16) = *(unsigned char *)(v19 + 16);
      v20 += 24;
      v19 += 24;
      v21 += 3;
    }
    while (v19 != a3);
  }
  int64_t v22 = v20 - (char *)result;
LABEL_26:
  *uint64_t v13 = (void *)((char *)result + v22);
  return result;
}

uint64_t sub_10010089C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_DWORD *)a1 = 14;
  *(_DWORD *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a3;
  sub_10010090C(a1 + 24, a4);
  sub_10010090C(a1 + 104, a5);
  return a1;
}

void sub_1001008F8(_Unwind_Exception *a1)
{
  sub_100104004(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10010090C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_1001009B4((char *)a1, *(void *)a2, *(void *)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v4 = *(void *)(a2 + 64);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  int v5 = *(unsigned __int8 *)(a2 + 76);
  *(unsigned char *)(a1 + 76) = v5;
  if (!v5)
  {
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
  }
  return a1;
}

char *sub_1001009B4(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = sub_100082C04(result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
      *(unsigned char *)(v7 + 16) = *(unsigned char *)(a2 + 16);
      v7 += 24;
      a2 += 24;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_100100A1C(_Unwind_Exception *exception_object)
{
  std::string v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100100A38(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, int a5)
{
  *(void *)(a1 + 32) = a4;
  *(_DWORD *)(a1 + 16) = a2;
  *(void *)a1 = a3;
  *(void *)(a1 + 8) = *a3;
  *a3 = a1;
  uint64_t v6 = *(void *)(a1 + 8);
  int v7 = *(_DWORD *)(v6 + 16);
  if ((v7 >= a2 || v7 < 0) && (uint64_t v8 = sub_100100AA8(a1, a2, v6, a5)) != 0) {
    *(_OWORD *)(a1 + 24) = *(_OWORD *)(v8 + 24);
  }
  else {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100100AA8(uint64_t a1, int a2, uint64_t a3, int a4)
{
  if (a3)
  {
    int v6 = -2 - a4;
    while (1)
    {
      int v7 = *(_DWORD *)(a3 + 16);
      if (v7 == a2) {
        break;
      }
      if (v6 == v7) {
        return 0;
      }
      a3 = *(void *)(a3 + 8);
      if (!a3) {
        return a3;
      }
      if ((*(_DWORD *)(a3 + 16) & 0x80000000) != 0)
      {
        uint64_t v8 = sub_100100AA8(a1);
        if (!v8) {
          return 0;
        }
        a3 = *(void *)(v8 + 8);
        if (!a3) {
          return a3;
        }
      }
    }
  }
  return a3;
}

uint64_t sub_100100B38(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 == result) {
    return result;
  }
  unint64_t v3 = (a2 - result) >> 3;
  int v4 = *(_DWORD *)(a3 + 4);
  while (1)
  {
    unint64_t v5 = v3 >> 1;
    uint64_t v6 = result + 8 * (v3 >> 1);
    int v7 = *(_DWORD *)(v6 + 4);
    if (v7 >= v4) {
      break;
    }
    __n128 result = v6 + 8;
    unint64_t v5 = v3 + ~v5;
LABEL_7:
    unint64_t v3 = v5;
    if (!v5) {
      return result;
    }
  }
  if (v4 < v7)
  {
    a2 = result + 8 * (v3 >> 1);
    goto LABEL_7;
  }
  if (v3 >= 2)
  {
    do
    {
      unint64_t v8 = v5 >> 1;
      uint64_t v9 = result + 8 * (v5 >> 1);
      int v10 = *(_DWORD *)(v9 + 4);
      uint64_t v11 = v9 + 8;
      v5 += ~(v5 >> 1);
      if (v10 < v4) {
        __n128 result = v11;
      }
      else {
        unint64_t v5 = v8;
      }
    }
    while (v5);
  }
  uint64_t v12 = v6 + 8;
  uint64_t v13 = a2 - (v6 + 8);
  if (v13)
  {
    unint64_t v14 = v13 >> 3;
    do
    {
      unint64_t v15 = v14 >> 1;
      uint64_t v16 = v12 + 8 * (v14 >> 1);
      int v17 = *(_DWORD *)(v16 + 4);
      uint64_t v18 = v16 + 8;
      v14 += ~(v14 >> 1);
      if (v4 < v17) {
        unint64_t v14 = v15;
      }
      else {
        uint64_t v12 = v18;
      }
    }
    while (v14);
  }
  return result;
}

std::string::value_type *sub_100100C00(std::string::value_type *a1, std::string::value_type *a2, uint64_t a3, uint64_t a4, int a5)
{
  unint64_t v5 = a1;
  if (a1 == a2) {
    return v5;
  }
  uint64_t v9 = (const std::string::value_type *)(a3 + 40);
  int v10 = *(uint64_t **)(a4 + 24);
  if (*(_DWORD *)(a3 + 16))
  {
    unsigned int v12 = 0;
    do
    {
      LOBYTE(v13) = *v9;
      if (*v9)
      {
        uint64_t v14 = 0;
        do
        {
          std::string::value_type v15 = v5[v14];
          if (a5)
          {
            std::string::value_type v15 = (*(uint64_t (**)(void, void))(**(void **)(*v10 + 8) + 40))(*(void *)(*v10 + 8), v15);
            LOBYTE(v13) = v9[v14];
          }
          if (v15 != v13) {
            break;
          }
          uint64_t v16 = &v9[v14++];
          int v13 = *((unsigned __int8 *)v16 + 1);
        }
        while (v13 && &v5[v14] != a2);
        v9 += v14;
        uint64_t v18 = &v5[v14];
        if (!(_BYTE)v13)
        {
          if (v18 == v5) {
            uint64_t v18 = v5 + 1;
          }
          if (!*(unsigned char *)(a3 + 36)) {
            return v18;
          }
          return v5;
        }
        while (*(unsigned __int8 *)v9++)
          ;
      }
      else
      {
        std::string::value_type v20 = *v5;
        if (a5) {
          std::string::value_type v20 = (*(uint64_t (**)(void, void))(**(void **)(*v10 + 8) + 40))(*(void *)(*v10 + 8), v20);
        }
        if (!v20) {
          goto LABEL_94;
        }
        ++v9;
      }
      ++v12;
    }
    while (v12 < *(_DWORD *)(a3 + 16));
  }
  std::string::value_type v21 = *v5;
  if (a5) {
    std::string::value_type v21 = (*(uint64_t (**)(void, void))(**(void **)(*v10 + 8) + 40))(*(void *)(*v10 + 8), v21);
  }
  if (!*(_DWORD *)(a3 + 20))
  {
    if (!*(_DWORD *)(a3 + 24)) {
      goto LABEL_90;
    }
    memset(&v40, 0, sizeof(v40));
    goto LABEL_64;
  }
  memset(&v40, 0, sizeof(v40));
  if ((*(unsigned char *)(a4 + 42) & 0x20) != 0)
  {
    std::string::value_type v38 = v21;
    std::string::value_type v39 = 0;
    sub_10010108C(*v10, &v37);
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v40.__r_.__value_.__l.__data_);
    }
    std::string v40 = v37;
  }
  else
  {
    std::string::assign(&v40, 1uLL, v21);
  }
  if (!*(_DWORD *)(a3 + 20))
  {
LABEL_64:
    if (!*(_DWORD *)(a3 + 24)) {
      goto LABEL_83;
    }
    std::string::value_type v38 = v21;
    std::string::value_type v39 = 0;
    sub_100101264(*v10, &v38, &v39, (uint64_t *)&v37);
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v40.__r_.__value_.__l.__data_);
    }
    std::string v40 = v37;
    if (!*(_DWORD *)(a3 + 24))
    {
LABEL_83:
      char v34 = 1;
      goto LABEL_86;
    }
    int v30 = 0;
    while (1)
    {
      if (!*v9)
      {
        if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          int v31 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
          if (HIBYTE(v40.__r_.__value_.__r.__words[2]) == 1)
          {
            unsigned int v32 = &v40;
            goto LABEL_77;
          }
          goto LABEL_78;
        }
        if (v40.__r_.__value_.__l.__size_ == 1)
        {
          unsigned int v32 = (std::string *)v40.__r_.__value_.__r.__words[0];
LABEL_77:
          int v31 = v32->__r_.__value_.__s.__data_[0];
LABEL_78:
          if (!v31) {
            goto LABEL_84;
          }
          goto LABEL_79;
        }
        if (!v40.__r_.__value_.__l.__size_) {
          goto LABEL_84;
        }
      }
LABEL_79:
      if (!std::string::compare(&v40, v9)) {
        goto LABEL_84;
      }
      ++v9;
      while (*(unsigned __int8 *)v9++)
        ;
      if (++v30 >= *(_DWORD *)(a3 + 24)) {
        goto LABEL_83;
      }
    }
  }
  int v22 = 0;
  while (1)
  {
    if (!*v9)
    {
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
      {
        if (!v40.__r_.__value_.__l.__size_) {
          goto LABEL_36;
        }
        if (v40.__r_.__value_.__l.__size_ != 1) {
          goto LABEL_35;
        }
        unint64_t v27 = (std::string *)v40.__r_.__value_.__r.__words[0];
        goto LABEL_52;
      }
      if (!*((unsigned char *)&v40.__r_.__value_.__s + 23)) {
        goto LABEL_36;
      }
      if (HIBYTE(v40.__r_.__value_.__r.__words[2]) == 1)
      {
        unint64_t v27 = &v40;
LABEL_52:
        if (!v27->__r_.__value_.__s.__data_[0]) {
          goto LABEL_36;
        }
      }
    }
LABEL_35:
    if (std::string::compare(&v40, v9) < 0)
    {
      int v23 = v9 + 1;
      while (*(unsigned __int8 *)v23++)
        ;
      goto LABEL_61;
    }
LABEL_36:
    int v23 = v9 + 1;
    while (*(unsigned __int8 *)v23++)
      ;
    if (*v23) {
      goto LABEL_60;
    }
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
    {
      if (v40.__r_.__value_.__l.__size_ != 1)
      {
        if (!v40.__r_.__value_.__l.__size_) {
          break;
        }
        goto LABEL_60;
      }
      uint64_t v26 = (std::string *)v40.__r_.__value_.__r.__words[0];
    }
    else
    {
      int v25 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
      if (HIBYTE(v40.__r_.__value_.__r.__words[2]) != 1) {
        goto LABEL_59;
      }
      uint64_t v26 = &v40;
    }
    int v25 = v26->__r_.__value_.__s.__data_[0];
LABEL_59:
    if (!v25) {
      break;
    }
LABEL_60:
    if (std::string::compare(&v40, v23) <= 0) {
      break;
    }
LABEL_61:
    uint64_t v9 = v23 + 1;
    while (*(unsigned __int8 *)v9++)
      ;
    if (++v22 >= *(_DWORD *)(a3 + 20)) {
      goto LABEL_64;
    }
  }
LABEL_84:
  char v34 = 0;
  if (!*(unsigned char *)(a3 + 36)) {
    ++v5;
  }
LABEL_86:
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v40.__r_.__value_.__l.__data_);
    if (v34) {
      goto LABEL_90;
    }
  }
  else
  {
    if ((v34 & 1) == 0) {
      return v5;
    }
LABEL_90:
    if (!sub_1000FE014((uint64_t)v10, v21, *(_DWORD *)(a3 + 28)))
    {
      int v35 = *(_DWORD *)(a3 + 32);
      if (!v35 || sub_1000FE014((uint64_t)v10, v21, v35))
      {
        v5 += *(unsigned __int8 *)(a3 + 36);
        return v5;
      }
    }
LABEL_94:
    if (!*(unsigned char *)(a3 + 36)) {
      ++v5;
    }
  }
  return v5;
}

void sub_100101068(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10010108C(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  memset(&i, 0, sizeof(i));
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 24) + 32))(&v15);
  for (std::string i = v15; SHIBYTE(i.__r_.__value_.__r.__words[2]) < 0; std::string::erase(&i, size - 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    std::string::size_type size = i.__r_.__value_.__l.__size_;
    if (!i.__r_.__value_.__l.__size_ || *(unsigned char *)(i.__r_.__value_.__r.__words[0] + i.__r_.__value_.__l.__size_ - 1)) {
      goto LABEL_10;
    }
LABEL_8:
    ;
  }
  std::string::size_type size = HIBYTE(i.__r_.__value_.__r.__words[2]);
  if (*((unsigned char *)&i.__r_.__value_.__s + 23))
  {
    if (*((unsigned char *)&v15.__r_.__value_.__r.__words[2] + HIBYTE(i.__r_.__value_.__r.__words[2]) + 7)) {
      goto LABEL_10;
    }
    goto LABEL_8;
  }
  std::string::size_type size = 0;
LABEL_10:
  std::string::reserve(a2, 2 * size + 2);
  char v4 = HIBYTE(i.__r_.__value_.__r.__words[2]);
  std::string::size_type v5 = i.__r_.__value_.__l.__size_;
  if ((i.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v5 = HIBYTE(i.__r_.__value_.__r.__words[2]);
  }
  if (v5)
  {
    uint64_t v6 = 0;
    unsigned int v7 = SHIBYTE(i.__r_.__value_.__r.__words[2]) >> 31;
    unsigned int v8 = 1;
    do
    {
      if (v7) {
        p_std::string i = (std::string *)i.__r_.__value_.__r.__words[0];
      }
      else {
        p_std::string i = &i;
      }
      int v10 = p_i->__r_.__value_.__s.__data_[v6];
      if (v10 == 255)
      {
        uint64_t v11 = std::string::append(a2, 1uLL, -1);
        std::string::value_type v12 = 98;
      }
      else
      {
        uint64_t v11 = std::string::append(a2, 1uLL, v10 + 1);
        std::string::value_type v12 = 97;
      }
      std::string::append(v11, 1uLL, v12);
      uint64_t v6 = v8;
      unsigned int v7 = SHIBYTE(i.__r_.__value_.__r.__words[2]) >> 31;
      std::string::size_type v13 = i.__r_.__value_.__l.__size_;
      if ((i.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v13 = HIBYTE(i.__r_.__value_.__r.__words[2]);
      }
    }
    while (v13 > v8++);
    char v4 = HIBYTE(i.__r_.__value_.__r.__words[2]);
  }
  if (v4 < 0) {
    operator delete(i.__r_.__value_.__l.__data_);
  }
}

void sub_100101220(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    JUMPOUT(0x100101204);
  }
  JUMPOUT(0x10010120CLL);
}

void sub_100101240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  if (*(char *)(v5 + 23) < 0) {
    operator delete(*(void **)v5);
  }
  sub_100141970((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100101264(uint64_t a1@<X0>, std::string::value_type *a2@<X1>, std::string::value_type *a3@<X2>, uint64_t *a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  switch(*(_DWORD *)(a1 + 360))
  {
    case 0:
    case 3:
      sub_1000E9504((std::string *)a4, a2, a3, a3 - a2);
      uint64_t v6 = *((unsigned __int8 *)a4 + 23);
      if ((v6 & 0x80u) == 0) {
        unsigned int v7 = a4;
      }
      else {
        unsigned int v7 = (uint64_t *)*a4;
      }
      if ((v6 & 0x80u) != 0) {
        uint64_t v6 = a4[1];
      }
      (*(void (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), v7, (uint64_t)v7 + v6);
      (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 24) + 32))(&v15);
      if (*((char *)a4 + 23) < 0) {
        operator delete((void *)*a4);
      }
      *(_OWORD *)a4 = v15;
      a4[2] = v16;
      break;
    case 1:
      (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 24) + 32))(&v15);
      if (*((char *)a4 + 23) < 0) {
        operator delete((void *)*a4);
      }
      *(_OWORD *)a4 = v15;
      a4[2] = v16;
      std::string::erase((std::string *)a4, *(char *)(a1 + 364), 0xFFFFFFFFFFFFFFFFLL);
      break;
    case 2:
      (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 24) + 32))(&v15);
      if (*((char *)a4 + 23) < 0) {
        operator delete((void *)*a4);
      }
      *(_OWORD *)a4 = v15;
      unint64_t v8 = v16;
      a4[2] = v16;
      std::string::size_type v9 = HIBYTE(v8);
      int v10 = (char)v9;
      std::string::size_type v11 = 0;
      if ((v9 & 0x80u) != 0) {
        std::string::size_type v9 = a4[1];
      }
      if (v9)
      {
        if (v10 >= 0) {
          std::string::value_type v12 = a4;
        }
        else {
          std::string::value_type v12 = (uint64_t *)*a4;
        }
        while (*((unsigned __int8 *)v12 + v11) != *(unsigned __int8 *)(a1 + 364))
        {
          if (v9 == ++v11)
          {
            std::string::size_type v11 = v9;
            break;
          }
        }
      }
      std::string::erase((std::string *)a4, v11, 0xFFFFFFFFFFFFFFFFLL);
      break;
    default:
      break;
  }
  std::string::size_type v13 = a4 + 1;
  while ((*((char *)a4 + 23) & 0x80000000) == 0)
  {
    uint64_t v14 = *((unsigned __int8 *)a4 + 23);
    if (!*((unsigned char *)a4 + 23)) {
      goto LABEL_34;
    }
    if (*((unsigned char *)a4 + v14 - 1)) {
      return;
    }
LABEL_32:
    std::string::erase((std::string *)a4, v14 - 1, 0xFFFFFFFFFFFFFFFFLL);
  }
  uint64_t v14 = *v13;
  if (*v13)
  {
    if (*(unsigned char *)(*a4 + v14 - 1)) {
      return;
    }
    goto LABEL_32;
  }
  operator delete((void *)*a4);
LABEL_34:
  *a4 = 0;
  *std::string::size_type v13 = v15;
  *(uint64_t *)((char *)a4 + 15) = *(void *)((char *)&v15 + 7);
  *((unsigned char *)a4 + 23) = 1;
}

void sub_100101528(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x100101484);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100101584(__n128 *a1)
{
  unsigned __int32 v2 = a1[6].n128_u32[0];
  if ((v2 & 0x80) != 0 || (unint64_t v3 = a1[5].n128_u64[1], (a1[11].n128_u8[4] & *(unsigned char *)(*(void *)(v3 + 8) + 16)) == 0))
  {
    return sub_100101768(a1);
  }
  if (!*(unsigned char *)(v3 + 309))
  {
    char v4 = &a1[2].n128_u64[1];
    unint64_t v5 = a1[2].n128_u64[1];
    uint64_t v6 = (unsigned __int8 *)a1[2].n128_u64[0];
    unint64_t v11 = *(void *)(v3 + 288);
    if (v11 <= (unint64_t)&v6[-v5])
    {
      unint64_t v8 = (unsigned __int8 **)(v3 + 296);
      goto LABEL_26;
    }
LABEL_16:
    uint64_t result = 0;
    unint64_t *v4 = (unint64_t)v6;
    return result;
  }
  if ((v2 & 0x400) != 0)
  {
    char v4 = &a1[2].n128_u64[1];
    unint64_t v5 = a1[2].n128_u64[1];
    uint64_t v6 = (unsigned __int8 *)a1[2].n128_u64[0];
    unsigned int v7 = &v6[-v5];
    unint64_t v8 = (unsigned __int8 **)(v3 + 296);
    std::string::size_type v9 = (unint64_t *)(v3 + 288);
    if (a1[7].n128_u8[11]) {
      goto LABEL_12;
    }
    unint64_t v11 = *v9;
    if (*v9 <= (unint64_t)v7)
    {
LABEL_26:
      unint64_t v16 = (unsigned __int8 *)(v5 + v11);
      unint64_t *v4 = v5 + v11;
      if (v11 < (unint64_t)*v8)
      {
        unint64_t v17 = a1[13].n128_u64[1] - 32;
        if (v17 < a1[13].n128_u64[0])
        {
          sub_1001004C4(a1);
          unint64_t v17 = a1[13].n128_u64[1] - 32;
        }
        *(_DWORD *)unint64_t v17 = 9;
        *(void *)(v17 + 8) = v11;
        *(void *)(v17 + 16) = v3;
        *(void *)(v17 + 24) = v16;
        a1[13].n128_u64[1] = v17;
        uint64_t v6 = (unsigned __int8 *)a1[2].n128_u64[0];
        unint64_t v16 = (unsigned __int8 *)a1[2].n128_u64[1];
      }
      a1[5].n128_u64[1] = *(void *)(v3 + 16);
      if (v16 == v6) {
        unsigned int v18 = *(unsigned __int8 *)(v3 + 280);
      }
      else {
        unsigned int v18 = *(unsigned __int8 *)(v3 + *v16 + 24);
      }
      return (v18 >> 1) & 1;
    }
    goto LABEL_16;
  }
  char v4 = &a1[2].n128_u64[1];
  unint64_t v5 = a1[2].n128_u64[1];
  uint64_t v6 = (unsigned __int8 *)a1[2].n128_u64[0];
  unsigned int v7 = &v6[-v5];
  unint64_t v8 = (unsigned __int8 **)(v3 + 296);
  std::string::size_type v9 = (unint64_t *)(v3 + 288);
LABEL_12:
  if (*v8 >= v7) {
    std::string::value_type v12 = v7;
  }
  else {
    std::string::value_type v12 = *v8;
  }
  unint64_t v13 = *v9;
  if (*v9 > (unint64_t)v12) {
    goto LABEL_16;
  }
  unint64_t v14 = (unint64_t)&v12[v5];
  unint64_t *v4 = (unint64_t)&v12[v5];
  if (*(unsigned char *)(v3 + 308) && v12 < *v8) {
    a1[3].n128_u64[0] = v14;
  }
  if (v12 != (unsigned __int8 *)v13)
  {
    unint64_t v15 = a1[13].n128_u64[1] - 32;
    if (v15 < a1[13].n128_u64[0])
    {
      sub_1001004C4(a1);
      unint64_t v15 = a1[13].n128_u64[1] - 32;
    }
    *(_DWORD *)unint64_t v15 = 7;
    *(void *)(v15 + 8) = v12;
    *(void *)(v15 + 16) = v3;
    *(void *)(v15 + 24) = v14;
    a1[13].n128_u64[1] = v15;
  }
  a1[5].n128_u64[1] = *(void *)(v3 + 16);
  return 1;
}

uint64_t sub_100101768(__n128 *a1)
{
  unint64_t v2 = a1[5].n128_u64[1];
  unint64_t v3 = *(void *)(v2 + 8);
  if (*(void *)(v2 + 288))
  {
    unint64_t v4 = 0;
    while (1)
    {
      a1[5].n128_u64[1] = v3;
      uint64_t result = sub_1000FEC8C((uint64_t)a1);
      if (!result) {
        break;
      }
      if (++v4 >= *(void *)(v2 + 288)) {
        goto LABEL_7;
      }
    }
  }
  else
  {
    unint64_t v4 = 0;
LABEL_7:
    if (*(unsigned char *)(v2 + 309) && ((a1[6].n128_u8[1] & 4) == 0 || a1[7].n128_u8[11]))
    {
      while (v4 < *(void *)(v2 + 296))
      {
        a1[5].n128_u64[1] = v3;
        if (!sub_1000FEC8C((uint64_t)a1)) {
          break;
        }
        ++v4;
      }
      if (*(unsigned char *)(v2 + 308) && v4 < *(void *)(v2 + 296)) {
        a1[3].n128_u64[0] = a1[2].n128_u64[1];
      }
      if (v4 != *(void *)(v2 + 288))
      {
        unint64_t v10 = a1[2].n128_u64[1];
        unint64_t v11 = a1[13].n128_u64[1] - 32;
        if (v11 < a1[13].n128_u64[0])
        {
          sub_1001004C4(a1);
          unint64_t v11 = a1[13].n128_u64[1] - 32;
        }
        *(_DWORD *)unint64_t v11 = 7;
        *(void *)(v11 + 8) = v4;
        *(void *)(v11 + 16) = v2;
        *(void *)(v11 + 24) = v10;
        a1[13].n128_u64[1] = v11;
      }
      a1[5].n128_u64[1] = *(void *)(v2 + 16);
      return 1;
    }
    else
    {
      if (v4 < *(void *)(v2 + 296))
      {
        unint64_t v6 = a1[2].n128_u64[1];
        unint64_t v7 = a1[13].n128_u64[1] - 32;
        if (v7 < a1[13].n128_u64[0])
        {
          sub_1001004C4(a1);
          unint64_t v7 = a1[13].n128_u64[1] - 32;
        }
        *(_DWORD *)unint64_t v7 = 8;
        *(void *)(v7 + 8) = v4;
        *(void *)(v7 + 16) = v2;
        *(void *)(v7 + 24) = v6;
        a1[13].n128_u64[1] = v7;
      }
      a1[5].n128_u64[1] = *(void *)(v2 + 16);
      unint64_t v8 = (unsigned __int8 *)a1[2].n128_u64[1];
      if (v8 == (unsigned __int8 *)a1[2].n128_u64[0]) {
        unsigned int v9 = *(unsigned __int8 *)(v2 + 280);
      }
      else {
        unsigned int v9 = *(unsigned __int8 *)(v2 + *v8 + 24);
      }
      return (v9 >> 1) & 1;
    }
  }
  return result;
}

uint64_t sub_1001018E4(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0x6DB6DB6DB6DB6DB7 * ((v4 - *a1) >> 4) < a2)
  {
    if (a2 >= 0x24924924924924ALL) {
      sub_10002B5E0();
    }
    uint64_t v5 = a1[1] - *a1;
    void v7[4] = result;
    v7[0] = sub_100101A1C(result, a2);
    v7[1] = v7[0] + v5;
    _DWORD v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 112 * v6;
    sub_1001019A4(a1, v7);
    return sub_100101B1C((uint64_t)v7);
  }
  return result;
}

void sub_100101990(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100101B1C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1001019A4(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100101A68((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_100101A1C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x24924924924924ALL) {
    sub_10002A63C();
  }
  return operator new(112 * a2);
}

uint64_t sub_100101A68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0;
    do
    {
      *(_OWORD *)(a7 + v11 - 112) = *(_OWORD *)(a3 + v11 - 112);
      sub_10010090C(a7 + v11 - 96, a3 + v11 - 96);
      *(_OWORD *)(a7 + v11 - 16) = *(_OWORD *)(a3 + v11 - 16);
      v11 -= 112;
    }
    while (a3 + v11 != a5);
  }
  return a6;
}

void sub_100101AF8(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 + 16;
    do
    {
      sub_100104004(v4 + v2);
      v2 += 112;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100101B1C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 112;
    sub_100104004(i - 96);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100101B70(uint64_t *a1, _OWORD *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x249249249249249) {
    sub_10002B5E0();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x124924924924924) {
    unint64_t v9 = 0x249249249249249;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = sub_100101A1C(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  uint64_t v11 = &v10[7 * v4];
  v14[0] = v10;
  v14[1] = v11;
  unint64_t v15 = v11;
  unint64_t v16 = (char *)&v10[7 * v9];
  *uint64_t v11 = *a2;
  sub_10010090C((uint64_t)(v11 + 1), (uint64_t)(a2 + 1));
  v10[7 * v4 + 6] = a2[6];
  v15 += 7;
  sub_1001019A4(a1, v14);
  uint64_t v12 = a1[1];
  sub_100101B1C((uint64_t)v14);
  return v12;
}

void sub_100101C98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100101B1C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100101CAC(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(int **)(a1 + 88);
  if (!v3) {
    return 1;
  }
  while (1)
  {
    int v7 = *v3;
    if (!*v3)
    {
      uint64_t v9 = v3[4];
      *(void *)(a1 + 88) = *((void *)v3 + 1);
      sub_100101CAC(a1, v9, 0);
      unint64_t v8 = *(int **)(a1 + 88);
      goto LABEL_12;
    }
    if (v7 == 1) {
      break;
    }
    if (v7 == 6) {
      return 1;
    }
LABEL_5:
    unint64_t v8 = (int *)*((void *)v3 + 1);
    *(void *)(a1 + 88) = v8;
LABEL_12:
    uint64_t v3 = v8;
    if (!v8) {
      return 1;
    }
  }
  if (v3[4] != a2)
  {
    sub_1000FE914((__n128 *)a1);
    unint64_t v8 = *(int **)(a1 + 88);
    if (v8) {
      goto LABEL_12;
    }
    *(_WORD *)(a1 + 228) = 1;
    *(unsigned char *)(a1 + 230) = 0;
    while ((((uint64_t (*)(uint64_t, void))off_1001BD568[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228)) & 1) != 0);
    unint64_t v8 = *(int **)(a1 + 88);
    if (v8) {
      goto LABEL_12;
    }
    goto LABEL_5;
  }
  if (!a3)
  {
    *(void *)(a1 + 88) = *((void *)v3 + 1);
    return 1;
  }

  return sub_1000FE914((__n128 *)a1);
}

void *sub_100101DD4@<X0>(void *result@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  if (!result[38]) {
    goto LABEL_12;
  }
  uint64_t v3 = result[37];
  if (!v3) {
    goto LABEL_12;
  }
  uint64_t v4 = result + 37;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a2;
    if (v5 >= a2) {
      int v7 = (uint64_t *)v3;
    }
    else {
      int v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = (void *)v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 != result + 37 && *((_DWORD *)v4 + 8) <= a2)
  {
    if (*((char *)v4 + 63) < 0)
    {
      return sub_1000173FC((unsigned char *)a3, (void *)v4[5], v4[6]);
    }
    else
    {
      long long v9 = *(_OWORD *)(v4 + 5);
      *(void *)(a3 + 16) = v4[7];
      *(_OWORD *)a3 = v9;
    }
  }
  else
  {
LABEL_12:
    if (a2 <= 21) {
      unint64_t v8 = off_1001BD310[a2];
    }
    else {
      unint64_t v8 = "Unknown error.";
    }
    return sub_100018888((void *)a3, v8);
  }
  return result;
}

void sub_100101E6C(std::runtime_error *a1)
{
  std::runtime_error::~runtime_error(a1);

  operator delete();
}

void sub_100101EA4(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x50uLL);
  sub_100101F00(exception, a1);
}

void sub_100101EEC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100101F04(uint64_t a1)
{
  *(void *)(a1 + 40) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 48));
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));
  return a1;
}

uint64_t sub_100101F58(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_1001BD040;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), (const std::runtime_error *)a2);
  *(void *)(a1 + 8) = &off_1001BD3D0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = -1;
  *(void *)a1 = &off_1001BD440;
  *(void *)(a1 + 8) = off_1001BD470;
  *(void *)(a1 + 40) = off_1001BD498;
  *(void *)(a1 + 48) = 0;
  return a1;
}

void sub_100102028()
{
}

void sub_1001021FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_1000FD4FC(&a9);
  sub_1000FD4FC(&a10);
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  _Unwind_Resume(a1);
}

void sub_100102274(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x50uLL);
  sub_1001024E4((uint64_t)exception, a1);
}

void sub_1001022BC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1001022D0(uint64_t a1)
{
  *(void *)(a1 + 40) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 48));
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));

  operator delete();
}

void sub_100102344(uint64_t a1)
{
  *(void *)(a1 + 32) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 40));

  std::runtime_error::~runtime_error((std::runtime_error *)a1);
}

void sub_1001023A0(uint64_t a1)
{
  *(void *)(a1 + 32) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 40));
  std::runtime_error::~runtime_error((std::runtime_error *)a1);

  operator delete();
}

void sub_100102418(void *a1)
{
  *a1 = &off_1001BD070;
  sub_1000FD4FC(a1 + 1);

  std::runtime_error::~runtime_error((std::runtime_error *)a1 - 2);
}

void sub_100102470(void *a1)
{
  *a1 = &off_1001BD070;
  sub_1000FD4FC(a1 + 1);
  std::runtime_error::~runtime_error((std::runtime_error *)a1 - 2);

  operator delete();
}

uint64_t sub_1001024E4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_1001BD040;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), (const std::runtime_error *)(a2 + 8));
  *(void *)(a1 + 8) = &off_1001BD3D0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = &off_1001BD070;
  *(void *)(a1 + 48) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v5;
  *(void *)a1 = &off_1001BD440;
  *(void *)(a1 + 8) = off_1001BD470;
  *(void *)(a1 + 40) = off_1001BD498;
  return a1;
}

void sub_100102614(_Unwind_Exception *a1)
{
  std::runtime_error::~runtime_error(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100102628(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 76)) {
    sub_1001026B0();
  }

  return sub_1000FDF10((uint64_t *)a1, -2);
}

uint64_t *sub_10010266C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 76)) {
    sub_1001026B0();
  }

  return sub_1000FDF10((uint64_t *)a1, -1);
}

void sub_1001026B0()
{
  std::logic_error::logic_error(&v0, "Attempt to access an uninitialized boost::match_results<> class.");
  sub_1001026F4(&v0);
}

void sub_1001026E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::logic_error a9)
{
}

void sub_1001026F4(const std::logic_error *a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  sub_100102750((uint64_t)exception, a1);
}

void sub_10010273C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100102750(uint64_t a1, const std::logic_error *a2)
{
  *(void *)a1 = &off_1001BD040;
  std::logic_error::logic_error((std::logic_error *)(a1 + 8), a2);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = -1;
  *(void *)a1 = &off_1001BD500;
  *(void *)(a1 + 8) = off_1001BD530;
  *(void *)(a1 + 24) = off_1001BD558;
  return a1;
}

uint64_t sub_1001027FC(uint64_t a1)
{
  *(void *)(a1 + 24) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 32));
  std::logic_error::~logic_error((std::logic_error *)(a1 + 8));
  return a1;
}

void sub_100102850()
{
}

void sub_100102A00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_1000FD4FC(&a9);
  sub_1000FD4FC(&a10);
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  _Unwind_Resume(a1);
}

void sub_100102A78(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  sub_100102CE8((uint64_t)exception, a1);
}

void sub_100102AC0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_100102AD4(uint64_t a1)
{
  *(void *)(a1 + 24) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 32));
  std::logic_error::~logic_error((std::logic_error *)(a1 + 8));

  operator delete();
}

void sub_100102B48(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 24));

  std::logic_error::~logic_error((std::logic_error *)a1);
}

void sub_100102BA4(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 24));
  std::logic_error::~logic_error((std::logic_error *)a1);

  operator delete();
}

void sub_100102C1C(void *a1)
{
  *a1 = &off_1001BD070;
  sub_1000FD4FC(a1 + 1);

  std::logic_error::~logic_error((std::logic_error *)a1 - 1);
}

void sub_100102C74(void *a1)
{
  *a1 = &off_1001BD070;
  sub_1000FD4FC(a1 + 1);
  std::logic_error::~logic_error((std::logic_error *)a1 - 1);

  operator delete();
}

uint64_t sub_100102CE8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_1001BD040;
  std::logic_error::logic_error((std::logic_error *)(a1 + 8), (const std::logic_error *)(a2 + 8));
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = &off_1001BD070;
  *(void *)(a1 + 32) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v5;
  *(void *)a1 = &off_1001BD500;
  *(void *)(a1 + 8) = off_1001BD530;
  *(void *)(a1 + 24) = off_1001BD558;
  return a1;
}

void sub_100102DF4(_Unwind_Exception *a1)
{
  std::logic_error::~logic_error(v1);
  _Unwind_Resume(a1);
}

void *sub_100102E08(void *a1, void *a2, void *a3)
{
  *a1 = a2;
  BOOL v6 = (char *)sub_10010056C();
  uint64_t v7 = 0;
  while (1)
  {
    unint64_t v8 = (_DWORD *)atomic_load((unint64_t *)&v6[v7]);
    if (v8)
    {
      long long v9 = v8;
      atomic_compare_exchange_strong((atomic_ullong *volatile)&v6[v7], (unint64_t *)&v9, 0);
      if (v9 == v8) {
        break;
      }
    }
    v7 += 8;
    if (v7 == 128)
    {
      unint64_t v8 = operator new(0x1000uLL);
      break;
    }
  }
  *a2 = v8;
  *a3 = v8 + 1022;
  v8[1022] = 0;
  return a1;
}

uint64_t sub_100102E8C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v4 = a2;
    if (a3 != v3)
    {
      uint64_t v5 = 8 * ((a3 - a2) >> 3);
      uint64_t v4 = a2;
      do
      {
        uint64_t v6 = *(void *)(v4 + v5 + 8);
        *(void *)uint64_t v4 = *(void *)(v4 + v5);
        *(void *)(v4 + 8) = v6;
        *(unsigned char *)(v4 + 16) = *(unsigned char *)(v4 + v5 + 16);
        v4 += 24;
      }
      while (v4 + v5 != v3);
    }
    *(void *)(a1 + 8) = v4;
  }
  return a2;
}

unint64_t sub_100102EF8(uint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = a2;
  if (a3)
  {
    unint64_t v5 = a4;
    uint64_t v10 = a1[2];
    uint64_t v8 = (uint64_t)(a1 + 2);
    uint64_t v9 = v10;
    unint64_t v11 = *(void *)(v8 - 8);
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v11) >> 3) >= a3)
    {
      unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - a2) >> 3);
      unint64_t v20 = a3;
      if (a3 <= v19) {
        goto LABEL_15;
      }
      unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - a2) >> 3);
      unint64_t v21 = v11 + 24 * (a3 - v19);
      uint64_t v22 = *(void *)(v8 - 8);
      do
      {
        *(_OWORD *)uint64_t v22 = *(_OWORD *)a4;
        *(unsigned char *)(v22 + 16) = *(unsigned char *)(a4 + 16);
        v22 += 24;
      }
      while (v22 != v21);
      a1[1] = v21;
      if (v11 != a2)
      {
LABEL_15:
        sub_10010316C((uint64_t)a1, a2, v11, a2 + 24 * a3);
        if (v4 <= v5)
        {
          if (a1[1] <= v5) {
            unint64_t v23 = 0;
          }
          else {
            unint64_t v23 = a3;
          }
          v5 += 24 * v23;
        }
        unint64_t v24 = v4;
        do
        {
          *(void *)unint64_t v24 = *(void *)v5;
          *(void *)(v24 + 8) = *(void *)(v5 + 8);
          *(unsigned char *)(v24 + 16) = *(unsigned char *)(v5 + 16);
          v24 += 24;
          --v20;
        }
        while (v20);
      }
    }
    else
    {
      uint64_t v12 = *a1;
      unint64_t v13 = a3 - 0x5555555555555555 * ((uint64_t)(v11 - *a1) >> 3);
      if (v13 > 0xAAAAAAAAAAAAAAALL) {
        sub_10002B5E0();
      }
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v12) >> 3);
      unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v9 - v12) >> 3);
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v13) {
        uint64_t v16 = a3 - 0x5555555555555555 * ((uint64_t)(v11 - *a1) >> 3);
      }
      if (v15 >= 0x555555555555555) {
        unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v17 = v16;
      }
      uint64_t v32 = v8;
      if (v17) {
        unsigned int v18 = (char *)sub_100009078(v8, v17);
      }
      else {
        unsigned int v18 = 0;
      }
      int v25 = &v18[24 * v14];
      long long __p = v18;
      int v29 = v25;
      int v31 = &v18[24 * v17];
      uint64_t v26 = &v25[24 * a3];
      do
      {
        *(_OWORD *)int v25 = *(_OWORD *)v5;
        v25[16] = *(unsigned char *)(v5 + 16);
        v25 += 24;
      }
      while (v25 != v26);
      int v30 = v26;
      unint64_t v4 = sub_1001031F0(a1, &__p, v4);
      if (v30 != v29) {
        int v30 = &v29[(v30 - v29 - 24) % 0x18uLL];
      }
      if (__p) {
        operator delete(__p);
      }
    }
  }
  return v4;
}

void sub_100103120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010316C(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(result + 8);
  uint64_t v5 = v4 - a4;
  unint64_t v6 = a2 + v4 - a4;
  uint64_t v7 = v4;
  while (v6 < a3)
  {
    *(_OWORD *)uint64_t v7 = *(_OWORD *)v6;
    *(unsigned char *)(v7 + 16) = *(unsigned char *)(v6 + 16);
    v7 += 24;
    v6 += 24;
  }
  *(void *)(result + 8) = v7;
  if (v4 != a4)
  {
    uint64_t v8 = (unsigned char *)(v4 - 8);
    uint64_t v9 = 8 * (v5 >> 3);
    do
    {
      *((void *)v8 - 2) = *(void *)(a2 + v9 - 24);
      *((void *)v8 - 1) = *(void *)(a2 + v9 - 16);
      unsigned char *v8 = *(unsigned char *)(a2 + v9 - 8);
      v8 -= 24;
      v9 -= 24;
    }
    while (v9);
  }
  return result;
}

uint64_t sub_1001031F0(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t result = a2[1];
  uint64_t v5 = *a1;
  uint64_t v6 = result;
  if (*a1 != a3)
  {
    uint64_t v7 = a3;
    uint64_t v8 = a2[1];
    do
    {
      uint64_t v6 = v8 - 24;
      *(_OWORD *)(v8 - 24) = *(_OWORD *)(v7 - 24);
      *(unsigned char *)(v8 - 8) = *(unsigned char *)(v7 - 8);
      v7 -= 24;
      v8 -= 24;
    }
    while (v7 != v5);
  }
  a2[1] = v6;
  uint64_t v9 = a1[1];
  uint64_t v10 = a2[2];
  if (v9 != a3)
  {
    do
    {
      *(_OWORD *)uint64_t v10 = *(_OWORD *)a3;
      *(unsigned char *)(v10 + 16) = *(unsigned char *)(a3 + 16);
      v10 += 24;
      a3 += 24;
    }
    while (a3 != v9);
    uint64_t v6 = a2[1];
  }
  a2[2] = v10;
  uint64_t v11 = *a1;
  *a1 = v6;
  a2[1] = v11;
  uint64_t v12 = a1[1];
  a1[1] = a2[2];
  a2[2] = v12;
  uint64_t v13 = a1[2];
  a1[2] = a2[3];
  a2[3] = v13;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1001032AC(uint64_t a1)
{
  *(void *)(a1 + 88) = 0;
  return 0;
}

uint64_t sub_1001032B8(uint64_t a1, char a2)
{
  uint64_t v3 = *(void *)(a1 + 216);
  if ((a2 & 1) == 0)
  {
    sub_100100484(*(void **)(a1 + 16), *(void *)(v3 + 16), *(int *)(v3 + 8), *(_DWORD *)(v3 + 8) == 0);
    sub_1000FE320(*(_DWORD **)(a1 + 16), *(void *)(v3 + 24), *(int *)(v3 + 8), *(unsigned char *)(v3 + 32), *(_DWORD *)(v3 + 8) == 0);
  }
  *(void *)(a1 + 216) = v3 + 40;
  return 1;
}

uint64_t sub_100103320(uint64_t a1)
{
  *(void *)(a1 + 216) += 8;
  *(void *)(a1 + 88) = 0;
  return 0;
}

BOOL sub_100103338(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 216);
  *(void *)(a1 + 88) = *(void *)(v2 + 8);
  *(void *)(a1 + 40) = *(void *)(v2 + 16);
  BOOL v3 = *(unsigned __int8 *)(v2 + 24) != a2;
  *(unsigned char *)(a1 + 228) = (*(unsigned char *)(v2 + 24) == 0) ^ a2;
  *(void *)(a1 + 216) = v2 + 32;
  *(unsigned char *)(a1 + 229) = 1;
  return v3;
}

uint64_t sub_100103380(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 216);
  if ((a2 & 1) == 0)
  {
    *(void *)(a1 + 88) = *(void *)(v2 + 8);
    *(void *)(a1 + 40) = *(void *)(v2 + 16);
  }
  *(void *)(a1 + 216) = v2 + 24;
  *(unsigned char *)(a1 + 230) = a2 ^ 1;
  return a2;
}

uint64_t sub_1001033B0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 216);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    **(void **)(v1 + 8) = v2;
  }
  *(void *)(a1 + 216) = v1 + 48;
  return 1;
}

uint64_t sub_1001033D4(uint64_t a1)
{
  ++*(_DWORD *)(a1 + 224);
  uint64_t v1 = *(void **)(a1 + 208);
  *(_OWORD *)(a1 + 208) = *(_OWORD *)(*(void *)(a1 + 216) + 8);
  uint64_t v2 = (char *)sub_10010056C();
  uint64_t v3 = 0;
  while (1)
  {
    unint64_t v4 = atomic_load((unint64_t *)&v2[v3]);
    if (!v4)
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)&v2[v3], &v4, (unint64_t)v1);
      if (!v4) {
        break;
      }
    }
    v3 += 8;
    if (v3 == 128)
    {
      operator delete(v1);
      return 1;
    }
  }
  return 1;
}

uint64_t sub_100103440(uint64_t a1, int a2)
{
  uint64_t v2 = *(void **)(a1 + 216);
  if (a2)
  {
    *(void *)(a1 + 216) = v2 + 4;
    return 1;
  }
  else
  {
    uint64_t v5 = v2[1];
    uint64_t v4 = v2[2];
    uint64_t v6 = *(void *)(v4 + 288);
    if ((*(unsigned char *)(a1 + 97) & 0x20) != 0 && *(void *)(a1 + 40) == *(void *)(a1 + 32)) {
      *(unsigned char *)(a1 + 121) = 1;
    }
    uint64_t v7 = v2[3];
    uint64_t v8 = v4 + 24;
    uint64_t v9 = *(void *)(a1 + 104) + 1;
    uint64_t v10 = (unsigned __int8 *)(v7 - 1);
    uint64_t v11 = v6 + 1;
    while (1)
    {
      *(void *)(a1 + 40) = v10;
      *(void *)(a1 + 104) = v9;
      if (v11 == v5) {
        break;
      }
      unsigned int v12 = *v10--;
      ++v9;
      --v7;
      --v5;
      if ((*(unsigned char *)(v8 + v12) & 2) != 0)
      {
        v2[1] = v5;
        v2[3] = v7;
        goto LABEL_12;
      }
    }
    *(void *)(a1 + 216) = v2 + 4;
    if ((*(unsigned char *)(v8 + *v10) & 2) == 0) {
      return 1;
    }
LABEL_12:
    uint64_t v3 = 0;
    *(void *)(a1 + 88) = *(void *)(v4 + 16);
  }
  return v3;
}

uint64_t sub_1001034F0(uint64_t a1, int a2)
{
  uint64_t v3 = *(void **)(a1 + 216);
  if (a2)
  {
    uint64_t v4 = (uint64_t)(v3 + 4);
LABEL_3:
    *(void *)(a1 + 216) = v4;
    return 1;
  }
  uint64_t v6 = v3[1];
  uint64_t v7 = v3[2];
  *(void *)(a1 + 88) = *(void *)(v7 + 8);
  uint64_t v8 = (unsigned __int8 *)v3[3];
  *(void *)(a1 + 40) = v8;
  if (*(unsigned __int8 **)(a1 + 32) == v8)
  {
LABEL_17:
    *(void *)(a1 + 216) += 32;
    if ((*(unsigned char *)(a1 + 97) & 0x20) != 0 && v8 != *(unsigned __int8 **)(a1 + 56)) {
      *(unsigned char *)(a1 + 121) = 1;
    }
    if ((*(unsigned char *)(v7 + 280) & 2) == 0) {
      return 1;
    }
  }
  else
  {
    uint64_t v9 = v7 + 24;
    unint64_t v10 = v6 + 1;
    do
    {
      unint64_t v11 = v10;
      if ((sub_1000FEC8C(a1) & 1) == 0)
      {
        uint64_t v4 = *(void *)(a1 + 216) + 32;
        goto LABEL_3;
      }
      ++*(void *)(a1 + 104);
      *(void *)(a1 + 88) = *(void *)(v7 + 8);
      uint64_t v8 = *(unsigned __int8 **)(a1 + 32);
      unsigned int v12 = *(unsigned __int8 **)(a1 + 40);
      if (v11 >= *(void *)(v7 + 296) || v12 == v8) {
        break;
      }
      unint64_t v10 = v11 + 1;
    }
    while ((*(unsigned char *)(v9 + *v12) & 2) == 0);
    if (v12 == v8) {
      goto LABEL_17;
    }
    if (*(void *)(v7 + 296) == v11)
    {
      *(void *)(a1 + 216) += 32;
      if ((*(unsigned char *)(v9 + *v12) & 2) == 0) {
        return 1;
      }
    }
    else
    {
      v3[1] = v11;
      v3[3] = v12;
    }
  }
  uint64_t result = 0;
  *(void *)(a1 + 88) = *(void *)(v7 + 16);
  return result;
}

uint64_t sub_10010362C(uint64_t a1, int a2)
{
  uint64_t v2 = *(void **)(a1 + 216);
  if (!a2)
  {
    unint64_t v5 = v2[1];
    uint64_t v4 = v2[2];
    uint64_t v6 = (unsigned __int8 *)v2[3];
    *(void *)(a1 + 40) = v6;
    uint64_t v7 = *(unsigned __int8 **)(a1 + 32);
    if (v7 == v6)
    {
      uint64_t v13 = v6;
    }
    else
    {
      unint64_t v8 = *(void *)(v4 + 296);
      uint64_t v9 = *(void *)(a1 + 104) + 1;
      unint64_t v10 = v6 + 1;
      unint64_t v11 = v5 + 1;
      unsigned int v12 = v6 + 1;
      do
      {
        uint64_t v6 = v12;
        uint64_t v13 = v10;
        unint64_t v5 = v11;
        *(void *)(a1 + 40) = v10;
        *(void *)(a1 + 104) = v9;
        if (v11 >= v8) {
          break;
        }
        if (v10 == v7) {
          break;
        }
        ++v10;
        ++v9;
        ++v12;
        ++v11;
      }
      while ((*(unsigned char *)(v4 + 24 + *v13) & 2) == 0);
    }
    if (*(unsigned char *)(v4 + 308) && v5 < *(void *)(v4 + 296)) {
      *(void *)(a1 + 48) = v6;
    }
    if (v13 == v7)
    {
      *(void *)(a1 + 216) = v2 + 4;
      if ((*(unsigned char *)(a1 + 97) & 0x20) != 0 && v7 != *(unsigned __int8 **)(a1 + 56)) {
        *(unsigned char *)(a1 + 121) = 1;
      }
      if ((*(unsigned char *)(v4 + 280) & 2) == 0) {
        return 1;
      }
    }
    else if (v5 == *(void *)(v4 + 296))
    {
      *(void *)(a1 + 216) = v2 + 4;
      if ((*(unsigned char *)(v4 + *v13 + 24) & 2) == 0) {
        return 1;
      }
    }
    else
    {
      v2[1] = v5;
      v2[3] = v6;
    }
    uint64_t v3 = 0;
    *(void *)(a1 + 88) = *(void *)(v4 + 16);
    return v3;
  }
  *(void *)(a1 + 216) = v2 + 4;
  return 1;
}

uint64_t sub_100103754(uint64_t a1, int a2)
{
  uint64_t v3 = *(void **)(a1 + 216);
  if (a2)
  {
    uint64_t v4 = (uint64_t)(v3 + 4);
LABEL_3:
    *(void *)(a1 + 216) = v4;
    return 1;
  }
  unint64_t v7 = v3[1];
  uint64_t v6 = v3[2];
  uint64_t v8 = *(void *)(v6 + 8);
  *(void *)(a1 + 88) = v8;
  int v9 = *(unsigned __int8 *)(v8 + 24);
  unint64_t v10 = (unsigned char *)v3[3];
  *(void *)(a1 + 40) = v10;
  if (*(unsigned char **)(a1 + 32) != v10)
  {
    LOBYTE(v11) = *v10;
    unint64_t v12 = v7 + 1;
    while (1)
    {
      unint64_t v7 = v12;
      if (*(unsigned char *)(a1 + 120)) {
        LOBYTE(v11) = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), (char)v11);
      }
      if (v9 != v11) {
        break;
      }
      unint64_t v10 = (unsigned char *)(*(void *)(a1 + 40) + 1);
      *(void *)(a1 + 40) = v10;
      ++*(void *)(a1 + 104);
      *(void *)(a1 + 88) = *(void *)(v6 + 8);
      if (v7 < *(void *)(v6 + 296) && v10 != *(unsigned char **)(a1 + 32))
      {
        uint64_t v11 = *v10;
        unint64_t v12 = v7 + 1;
        if ((*(unsigned char *)(v6 + 24 + v11) & 2) == 0) {
          continue;
        }
      }
      goto LABEL_13;
    }
    uint64_t v4 = *(void *)(a1 + 216) + 32;
    goto LABEL_3;
  }
LABEL_13:
  if (*(unsigned char *)(v6 + 308) && v7 < *(void *)(v6 + 296)) {
    *(void *)(a1 + 48) = v10;
  }
  if (v10 == *(unsigned char **)(a1 + 32))
  {
    *(void *)(a1 + 216) += 32;
    if ((*(unsigned char *)(a1 + 97) & 0x20) != 0 && v10 != *(unsigned char **)(a1 + 56)) {
      *(unsigned char *)(a1 + 121) = 1;
    }
    if ((*(unsigned char *)(v6 + 280) & 2) == 0) {
      return 1;
    }
  }
  else if (v7 == *(void *)(v6 + 296))
  {
    *(void *)(a1 + 216) += 32;
    if ((*(unsigned char *)(v6 + *v10 + 24) & 2) == 0) {
      return 1;
    }
  }
  else
  {
    v3[1] = v7;
    v3[3] = v10;
  }
  uint64_t result = 0;
  *(void *)(a1 + 88) = *(void *)(v6 + 16);
  return result;
}

uint64_t sub_100103904(uint64_t a1, int a2)
{
  uint64_t v3 = *(void **)(a1 + 216);
  if (a2)
  {
    uint64_t v4 = (uint64_t)(v3 + 4);
LABEL_3:
    *(void *)(a1 + 216) = v4;
    return 1;
  }
  unint64_t v7 = v3[1];
  uint64_t v6 = v3[2];
  *(void *)(a1 + 88) = *(void *)(v6 + 8);
  uint64_t v8 = *(void *)(v6 + 8);
  int v9 = (unsigned char *)v3[3];
  *(void *)(a1 + 40) = v9;
  if (*(unsigned char **)(a1 + 32) != v9)
  {
    uint64_t v10 = v8 + 16;
    LOBYTE(v11) = *v9;
    unint64_t v12 = v7 + 1;
    while (1)
    {
      unint64_t v7 = v12;
      if (*(unsigned char *)(a1 + 120)) {
        LOBYTE(v11) = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), (char)v11);
      }
      if (!*(unsigned char *)(v10 + v11)) {
        break;
      }
      int v9 = (unsigned char *)(*(void *)(a1 + 40) + 1);
      *(void *)(a1 + 40) = v9;
      ++*(void *)(a1 + 104);
      *(void *)(a1 + 88) = *(void *)(v6 + 8);
      if (v7 < *(void *)(v6 + 296) && v9 != *(unsigned char **)(a1 + 32))
      {
        uint64_t v11 = *v9;
        unint64_t v12 = v7 + 1;
        if ((*(unsigned char *)(v6 + 24 + v11) & 2) == 0) {
          continue;
        }
      }
      goto LABEL_13;
    }
    uint64_t v4 = *(void *)(a1 + 216) + 32;
    goto LABEL_3;
  }
LABEL_13:
  if (*(unsigned char *)(v6 + 308) && v7 < *(void *)(v6 + 296)) {
    *(void *)(a1 + 48) = v9;
  }
  if (v9 == *(unsigned char **)(a1 + 32))
  {
    *(void *)(a1 + 216) += 32;
    if ((*(unsigned char *)(a1 + 97) & 0x20) != 0 && v9 != *(unsigned char **)(a1 + 56)) {
      *(unsigned char *)(a1 + 121) = 1;
    }
    if ((*(unsigned char *)(v6 + 280) & 2) == 0) {
      return 1;
    }
  }
  else if (v7 == *(void *)(v6 + 296))
  {
    *(void *)(a1 + 216) += 32;
    if ((*(unsigned char *)(v6 + *v9 + 24) & 2) == 0) {
      return 1;
    }
  }
  else
  {
    v3[1] = v7;
    v3[3] = v9;
  }
  uint64_t result = 0;
  *(void *)(a1 + 88) = *(void *)(v6 + 16);
  return result;
}

uint64_t sub_100103ABC(uint64_t a1, int a2)
{
  uint64_t v3 = *(void **)(a1 + 216);
  if (a2)
  {
    uint64_t v4 = (uint64_t)(v3 + 4);
LABEL_3:
    *(void *)(a1 + 216) = v4;
    return 1;
  }
  unint64_t v7 = v3[1];
  uint64_t v6 = v3[2];
  uint64_t v8 = *(void *)(v6 + 8);
  *(void *)(a1 + 88) = v8;
  int v9 = (std::string::value_type *)v3[3];
  *(void *)(a1 + 40) = v9;
  uint64_t v10 = *(std::string::value_type **)(a1 + 32);
  if (v10 != v9)
  {
    unint64_t v11 = v7 + 1;
    while (1)
    {
      unint64_t v7 = v11;
      unint64_t v12 = sub_100100C00(v9, v10, v8, **(void **)(a1 + 72), *(unsigned __int8 *)(a1 + 120));
      uint64_t v13 = *(std::string::value_type **)(a1 + 40);
      if (v13 == v12) {
        break;
      }
      int v9 = v13 + 1;
      *(void *)(a1 + 40) = v13 + 1;
      ++*(void *)(a1 + 104);
      *(void *)(a1 + 88) = *(void *)(v6 + 8);
      if (v7 < *(void *)(v6 + 296))
      {
        uint64_t v10 = *(std::string::value_type **)(a1 + 32);
        if (v9 != v10)
        {
          unint64_t v11 = v7 + 1;
          if ((*(unsigned char *)(v6 + 24 + *v9) & 2) == 0) {
            continue;
          }
        }
      }
      goto LABEL_11;
    }
    uint64_t v4 = *(void *)(a1 + 216) + 32;
    goto LABEL_3;
  }
LABEL_11:
  if (*(unsigned char *)(v6 + 308) && v7 < *(void *)(v6 + 296)) {
    *(void *)(a1 + 48) = v9;
  }
  if (v9 == *(std::string::value_type **)(a1 + 32))
  {
    *(void *)(a1 + 216) += 32;
    if ((*(unsigned char *)(a1 + 97) & 0x20) != 0 && v9 != *(std::string::value_type **)(a1 + 56)) {
      *(unsigned char *)(a1 + 121) = 1;
    }
    if ((*(unsigned char *)(v6 + 280) & 2) == 0) {
      return 1;
    }
  }
  else if (v7 == *(void *)(v6 + 296))
  {
    *(void *)(a1 + 216) += 32;
    if ((*(unsigned char *)(v6 + *v9 + 24) & 2) == 0) {
      return 1;
    }
  }
  else
  {
    v3[1] = v7;
    v3[3] = v9;
  }
  uint64_t result = 0;
  *(void *)(a1 + 88) = *(void *)(v6 + 16);
  return result;
}

uint64_t sub_100103C38(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[27];
  if ((a2 & 1) == 0)
  {
    a1[5] = *(void *)(v2 + 16);
    a1[11] = *(void *)(v2 + 8);
    ++*(void *)(a1[16] + 24);
  }
  a1[27] = v2 + 24;
  return a2;
}

uint64_t sub_100103C70(uint64_t *a1, char a2)
{
  uint64_t v3 = a1[27];
  if ((a2 & 1) == 0)
  {
    long long v11 = 0uLL;
    long long v10 = 0u;
    long long v8 = 0u;
    memset(v9, 0, sizeof(v9));
    BYTE12(v10) = 1;
    unint64_t v4 = a1[24];
    if (v4 >= a1[25])
    {
      uint64_t v5 = sub_100101B70(a1 + 23, &v8);
    }
    else
    {
      *(void *)unint64_t v4 = 0;
      *(void *)(v4 + 8) = 0;
      sub_10010090C(v4 + 16, (uint64_t)v9);
      *(_OWORD *)(v4 + 96) = v11;
      uint64_t v5 = v4 + 112;
      a1[24] = v4 + 112;
    }
    a1[24] = v5;
    sub_100104004((uint64_t)v9);
    uint64_t v6 = a1[24];
    *(_DWORD *)(v6 - 112) = *(_DWORD *)(v3 + 8);
    *(void *)(v6 - 104) = *(void *)(v3 + 16);
    sub_100100624(v6 - 96, v3 + 104);
    *(void *)(a1[24] - 8) = a1[5];
    sub_100100624(a1[2], v3 + 24);
  }
  sub_100104004(v3 + 104);
  sub_100104004(v3 + 24);
  a1[27] = v3 + 184;
  return 1;
}

void sub_100103D68(_Unwind_Exception *a1)
{
  sub_100104004(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100103D88(uint64_t *a1, char a2)
{
  uint64_t v3 = a1[27];
  if ((a2 & 1) == 0)
  {
    uint64_t v4 = a1[24];
    if (a1[23] != v4)
    {
      sub_100100624(a1[2], v4 - 96);
      uint64_t v5 = a1[24];
      uint64_t v6 = v5 - 112;
      a1[5] = *(void *)(v5 - 8);
      sub_100104004(v5 - 96);
      a1[24] = v6;
    }
  }
  a1[27] = v3 + 8;
  return 1;
}

uint64_t sub_100103DF8(uint64_t a1, char a2)
{
  *(void *)(a1 + 216) += 8;
  while (1)
  {
    *(unsigned char *)(a1 + 228) = a2;
    *(_WORD *)(a1 + 229) = 0;
    while ((((uint64_t (*)(uint64_t, void))off_1001BD568[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228)) & 1) != 0);
    if (!*(void *)(a1 + 88)) {
      break;
    }
    if (*(unsigned char *)(a1 + 229))
    {
      *(unsigned char *)(a1 + 229) = 0;
      uint64_t v4 = (_DWORD *)(*(void *)(a1 + 216) - 8);
      if ((unint64_t)v4 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        uint64_t v4 = (_DWORD *)(*(void *)(a1 + 216) - 8);
      }
      _DWORD *v4 = 16;
      *(void *)(a1 + 216) = v4;
      break;
    }
  }
  *(unsigned char *)(a1 + 123) = 0;
  return 0;
}

uint64_t sub_100103EAC(uint64_t a1, char a2)
{
  *(void *)(a1 + 216) += 8;
  *(unsigned char *)(a1 + 228) = a2;
  *(_WORD *)(a1 + 229) = 0;
  while ((((uint64_t (*)(uint64_t, void))off_1001BD568[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228)) & 1) != 0);
  while (*(void *)(a1 + 88))
  {
    int v4 = *(unsigned __int8 *)(a1 + 230);
    *(unsigned char *)(a1 + 228) = a2;
    *(_WORD *)(a1 + 229) = 0;
    if (v4)
    {
      while ((((uint64_t (*)(uint64_t, void))off_1001BD568[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228)) & 1) != 0);
      return 0;
    }
    while ((((uint64_t (*)(uint64_t, void))off_1001BD568[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228)) & 1) != 0);
  }
  return 0;
}

uint64_t sub_100103F80(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 216);
  *(unsigned char *)(a1 + 120) = *(unsigned char *)(v1 + 8);
  *(void *)(a1 + 216) = v1 + 16;
  return 1;
}

void ***sub_100103F9C(void ***a1)
{
  uint64_t v2 = **a1;
  uint64_t v3 = (char *)sub_10010056C();
  uint64_t v4 = 0;
  while (1)
  {
    unint64_t v5 = atomic_load((unint64_t *)&v3[v4]);
    if (!v5)
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)&v3[v4], &v5, (unint64_t)v2);
      if (!v5) {
        break;
      }
    }
    v4 += 8;
    if (v4 == 128)
    {
      operator delete(v2);
      break;
    }
  }
  **a1 = 0;
  return a1;
}

uint64_t sub_100104004(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10000B678(v2);
  }
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t sub_100104044(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (*(void *)a3 && (*(unsigned char *)(*(void *)a3 + 42) & 8) != 0) {
    return 0;
  }
  char v13 = 0;
  memset(v12, 0, sizeof(v12));
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  int v16 = 0;
  char v17 = 1;
  sub_10010414C((uint64_t)&v7, a1, a2, (uint64_t)v12, a3, a4 | 0x400, a1);
  uint64_t v4 = sub_1001043C0((uint64_t)&v7);
  unsigned int v18 = (void **)&v11;
  sub_1000FD72C(&v18);
  if (v10) {
    void *v9 = v10;
  }
  uint64_t v5 = v8;
  uint64_t v8 = 0;
  if (v5)
  {
    sub_100104004(v5);
    operator delete();
  }
  sub_100104004((uint64_t)v12);
  return v4;
}

void sub_100104128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000FCB20((uint64_t)&a9);
  sub_100104004(v9 - 128);
  _Unwind_Resume(a1);
}

uint64_t sub_10010414C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  *(void *)a1 = a4;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = a2;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = a7;
  *(void *)(a1 + 72) = a5;
  *(void *)(a1 + 80) = *(void *)(*(void *)a5 + 24);
  *(unsigned char *)(a1 + 123) = 0;
  *(void *)(a1 + 128) = a1 + 136;
  *(void *)(a1 + 136) = a1 + 128;
  *(void *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 152) = -1;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 232) = 0;
  sub_10010421C(a1, a5, a6);
  return a1;
}

void sub_1001041E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v14 = v12;
  a10 = v14;
  sub_1000FD72C(&a10);
  uint64_t v16 = *(void *)(v11 + 144);
  if (v16) {
    **char v13 = v16;
  }
  sub_1000FCEF8(v10, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_10010421C(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(void *)a2 || *(_DWORD *)(*(void *)a2 + 44))
  {
    std::logic_error::logic_error(&v14, "Invalid regular expression object");
    sub_1000FCDEC(&v14);
  }
  char v3 = a3;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = a3;
  uint64_t result = sub_1000FCE48(a1);
  uint64_t v7 = *(void *)(a1 + 72);
  if (*(void *)v7) {
    int v8 = *(_DWORD *)(*(void *)v7 + 40);
  }
  else {
    int v8 = 0;
  }
  *(unsigned char *)(a1 + 120) = (v8 & 0x100000) != 0;
  int v9 = *(_DWORD *)(a1 + 96);
  if ((v9 & 0x30000) == 0)
  {
    if ((v8 & 3) == 2 || (v8 & 0x1003) == 4097 || (v8 & 0x203) == 0) {
      int v12 = 0x10000;
    }
    else {
      int v12 = 0x20000;
    }
    v9 |= v12;
    *(_DWORD *)(a1 + 96) = v9;
  }
  if ((v9 & 0x20000) != 0) {
    operator new();
  }
  *(void *)(a1 + 16) = *(void *)a1;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 176) = *(_DWORD *)(*(void *)v7 + 368);
  if ((v3 & 0x40) != 0) {
    char v13 = 2;
  }
  else {
    char v13 = 3;
  }
  *(unsigned char *)(a1 + 180) = v13;
  if (*(unsigned char *)(*(void *)a2 + 401)) {
    *(_DWORD *)(a1 + 96) &= 0x3FFFFBFFu;
  }
  return result;
}

void sub_1001043AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::invalid_argument a9)
{
}

uint64_t sub_1001043C0(uint64_t a1)
{
  sub_100102E08(&v22, (void *)(a1 + 208), (void *)(a1 + 216));
  *(_DWORD *)(a1 + 224) = 1024;
  *(void *)(a1 + 104) = 0;
  int v2 = *(_DWORD *)(a1 + 96);
  if ((v2 & 0x200) == 0)
  {
    char v3 = *(uint64_t **)(a1 + 16);
    uint64_t v4 = *(void *)(a1 + 24);
    *(void *)(a1 + 40) = v4;
    *(void *)(a1 + 56) = v4;
    uint64_t v5 = **(void **)(a1 + 72);
    *(void *)(a1 + 88) = *(void *)(v5 + 72);
    if ((v2 & 0x40000) != 0) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = *(void *)(v5 + 64);
    }
    sub_100104A14(v3, v6, v4, *(void *)(a1 + 32));
    *(void *)(*(void *)(a1 + 16) + 24) = *(void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 16);
    char v13 = *(uint64_t **)(a1 + 72);
    uint64_t v14 = *v13;
    uint64_t v15 = (std::__shared_weak_count *)v13[1];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v16 = *(std::__shared_weak_count **)(v12 + 64);
    *(void *)(v12 + 56) = v14;
    *(void *)(v12 + 64) = v15;
    if (v16) {
      sub_10000B678(v16);
    }
    if (v15) {
      sub_10000B678(v15);
    }
    int v11 = *(_DWORD *)(a1 + 96) | 0x200;
    *(_DWORD *)(a1 + 96) = v11;
    if ((v11 & 0x20000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_22;
  }
  uint64_t v7 = sub_100104B24(*(uint64_t **)a1, 0)[1];
  *(void *)(a1 + 40) = v7;
  *(void *)(a1 + 56) = v7;
  if ((*(unsigned char *)(a1 + 97) & 8) == 0 && !sub_100104BA0(*(uint64_t **)a1, 0))
  {
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8 == *(void *)(a1 + 32))
    {
      uint64_t v20 = 0;
      goto LABEL_31;
    }
    *(void *)(a1 + 40) = v8 + 1;
  }
  if ((*(unsigned char *)(a1 + 98) & 4) != 0 || (uint64_t v9 = **(void **)(a1 + 72)) == 0) {
    uint64_t v10 = 1;
  }
  else {
    uint64_t v10 = *(void *)(v9 + 64);
  }
  sub_100104A14(*(uint64_t **)(a1 + 16), v10, *(void *)(a1 + 56), *(void *)(a1 + 32));
  int v11 = *(_DWORD *)(a1 + 96);
  if ((v11 & 0x20000) != 0)
  {
LABEL_22:
    uint64_t v17 = **(void **)(a1 + 72);
    if (v17) {
      uint64_t v18 = *(void *)(v17 + 64);
    }
    else {
      uint64_t v18 = 1;
    }
    sub_100104A14(*(uint64_t **)a1, v18, *(void *)(a1 + 24), *(void *)(a1 + 32));
    *(void *)(*(void *)a1 + 24) = *(void *)(a1 + 24);
    int v11 = *(_DWORD *)(a1 + 96);
  }
LABEL_26:
  if ((~v11 & 0xA0000) == 0)
  {
    std::logic_error::logic_error(&v23, "Usage Error: Can't mix regular expression captures with POSIX matching rules");
    sub_1001026F4(&v23);
  }
  if ((v11 & 0x1000) != 0) {
    uint64_t v19 = 4;
  }
  else {
    uint64_t v19 = *(unsigned int *)(**(void **)(a1 + 72) + 80);
  }
  uint64_t v20 = ((uint64_t (*)(uint64_t))off_1001BD698[2 * v19])(a1);
LABEL_31:
  sub_100103F9C(&v22);
  return v20;
}

void sub_1001045C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::logic_error a11)
{
}

void sub_10010462C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  __cxa_end_catch();
  sub_100103F9C((void ***)va);
  _Unwind_Resume(a1);
}

BOOL sub_10010464C(uint64_t a1)
{
  uint64_t v2 = **(void **)(a1 + 72) + 84;
  char v3 = *(unsigned __int8 **)(a1 + 32);
  for (uint64_t i = *(unsigned __int8 **)(a1 + 40); ; *(void *)(a1 + 40) = i)
  {
    if (i != v3)
    {
      while ((*(unsigned char *)(v2 + *i) & 3) == 0)
      {
        *(void *)(a1 + 40) = ++i;
        if (i == v3) {
          goto LABEL_10;
        }
      }
    }
    if (i == v3) {
      break;
    }
    BOOL result = sub_100104920(a1);
    if (result) {
      return result;
    }
    char v3 = *(unsigned __int8 **)(a1 + 32);
    uint64_t v6 = *(unsigned __int8 **)(a1 + 40);
    if (v6 == v3) {
      return result;
    }
    uint64_t i = v6 + 1;
  }
LABEL_10:
  if (!*(_DWORD *)(**(void **)(a1 + 72) + 340)) {
    return 0;
  }

  return sub_100104920(a1);
}

uint64_t sub_100104708(uint64_t a1)
{
  uint64_t v2 = **(void **)(a1 + 72);
  if (*(unsigned char *)(a1 + 97))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    goto LABEL_6;
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3 != *(void *)(a1 + 24))
  {
LABEL_6:
    uint64_t v5 = (char *)(v3 - 1);
    *(void *)(a1 + 40) = v5;
    goto LABEL_7;
  }
  if (sub_100104920(a1)) {
    return 1;
  }
  uint64_t v5 = *(char **)(a1 + 40);
LABEL_7:
  uint64_t v6 = v2 + 84;
  uint64_t v7 = *(char **)(a1 + 32);
LABEL_8:
  while (v5 != v7)
  {
    BOOL v8 = sub_1000FE014(*(void *)(a1 + 80), *v5, *(_DWORD *)(a1 + 176));
    uint64_t v7 = *(char **)(a1 + 32);
    uint64_t v9 = *(char **)(a1 + 40);
    if (!v8)
    {
      while (v9 != v7)
      {
        BOOL v10 = sub_1000FE014(*(void *)(a1 + 80), *v9, *(_DWORD *)(a1 + 176));
        uint64_t v7 = *(char **)(a1 + 32);
        uint64_t v5 = *(char **)(a1 + 40);
        if (v10)
        {
          if (v5 == v7) {
            return 0;
          }
          if ((*(unsigned char *)(v6 + *v5) & 3) != 0)
          {
            if (sub_100104920(a1)) {
              return 1;
            }
            uint64_t v7 = *(char **)(a1 + 32);
            uint64_t v5 = *(char **)(a1 + 40);
          }
          if (v5 != v7) {
            goto LABEL_8;
          }
          return 0;
        }
        uint64_t v9 = v5 + 1;
        *(void *)(a1 + 40) = v9;
      }
      return 0;
    }
    uint64_t v5 = v9 + 1;
    *(void *)(a1 + 40) = v5;
  }
  return 0;
}

BOOL sub_100104800(uint64_t a1)
{
  uint64_t v2 = **(void **)(a1 + 72);
  uint64_t v3 = 1;
  if (!sub_100104920(a1))
  {
    uint64_t v4 = v2 + 84;
    uint64_t v6 = *(unsigned __int8 **)(a1 + 32);
    uint64_t v5 = *(unsigned __int8 **)(a1 + 40);
    do
    {
      if (v5 == v6) {
        break;
      }
      ++v5;
      while (1)
      {
        unsigned int v7 = *(v5 - 1);
        BOOL v8 = v7 > 0xD || ((1 << v7) & 0x3400) == 0;
        if (!v8 || v7 == 133) {
          break;
        }
        *(void *)(a1 + 40) = v5;
        BOOL v8 = v5++ == v6;
        if (v8) {
          return 0;
        }
      }
      if (v5 - 1 == v6) {
        break;
      }
      *(void *)(a1 + 40) = v5;
      if (v5 == v6) {
        return *(_DWORD *)(**(void **)(a1 + 72) + 340) && sub_100104920(a1);
      }
      if ((*(unsigned char *)(v4 + *v5) & 3) != 0)
      {
        if (sub_100104920(a1)) {
          return 1;
        }
        uint64_t v6 = *(unsigned __int8 **)(a1 + 32);
        uint64_t v5 = *(unsigned __int8 **)(a1 + 40);
      }
    }
    while (v5 != v6);
    return 0;
  }
  return v3;
}

BOOL sub_1001048FC(uint64_t a1)
{
  return *(void *)(a1 + 40) == *(void *)(a1 + 24) && (*(unsigned char *)(a1 + 96) & 4) == 0 && sub_100104920(a1);
}

BOOL sub_100104920(uint64_t a1)
{
  *(_WORD *)(a1 + 121) = 0;
  *(void *)(a1 + 88) = *(void *)(**(void **)(a1 + 72) + 72);
  sub_1000FE0DC(*(void **)(a1 + 16), *(void *)(a1 + 40));
  *(void *)(a1 + 48) = *(void *)(a1 + 40);
  sub_100104C28(a1, v2);
  if (*(unsigned char *)(a1 + 122))
  {
    int v3 = 1;
  }
  else
  {
    if (!*(unsigned char *)(a1 + 121)) {
      goto LABEL_5;
    }
    int v4 = *(_DWORD *)(a1 + 96);
    if ((v4 & 0x2000) == 0) {
      goto LABEL_5;
    }
    int v3 = 1;
    *(unsigned char *)(a1 + 122) = 1;
    uint64_t v6 = *(uint64_t **)(a1 + 16);
    uint64_t v7 = *(void *)(a1 + 32);
    *(void *)(*v6 + 56) = v7;
    uint64_t v8 = *v6;
    *(unsigned char *)(v8 + 64) = 0;
    *(void *)uint64_t v8 = v7;
    *(unsigned char *)(*v6 + 16) = *(void *)*v6 != *(void *)(*v6 + 8);
    v6[4] = v7;
    void v6[5] = v7;
    *((unsigned char *)v6 + 48) = 0;
    *((unsigned char *)v6 + 76) = 0;
    *(void *)(a1 + 40) = *(void *)(a1 + 32);
    if ((v4 & 0x20000) != 0)
    {
      sub_100104DE0(*(void *)a1, *(void **)(a1 + 16));
      int v3 = *(unsigned __int8 *)(a1 + 122);
      if (!*(unsigned char *)(a1 + 122))
      {
LABEL_5:
        int v3 = 0;
        *(void *)(a1 + 40) = *(void *)(a1 + 48);
      }
    }
  }
  return v3 != 0;
}

uint64_t sub_100104A0C()
{
  return 0;
}

uint64_t *sub_100104A14(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = result;
  v16[0] = a4;
  v16[1] = a4;
  char v17 = 0;
  uint64_t v8 = *result;
  uint64_t v7 = result[1];
  uint64_t v9 = v7 - *result;
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v9 >> 3);
  uint64_t v11 = a2 + 2;
  if (a2 + 2 >= v10)
  {
    if (v9 >= 1)
    {
      unint64_t v15 = v9 / 0x18uLL + 1;
      do
      {
        *(void *)uint64_t v8 = a4;
        *(void *)(v8 + 8) = a4;
        *(unsigned char *)(v8 + 16) = 0;
        --v15;
        v8 += 24;
      }
      while (v15 > 1);
    }
    if (v11 != v10) {
      BOOL result = (uint64_t *)sub_100107D2C(result, result[1], v11 - v10, (unint64_t)v16);
    }
  }
  else
  {
    BOOL result = (uint64_t *)sub_100102E8C((uint64_t)result, v8 + 24 * a2 + 48, v7);
    uint64_t v12 = *v6;
    uint64_t v13 = v6[1] - *v6;
    if (v13 >= 1)
    {
      unint64_t v14 = v13 / 0x18uLL + 1;
      do
      {
        *(void *)uint64_t v12 = a4;
        *(void *)(v12 + 8) = a4;
        *(unsigned char *)(v12 + 16) = 0;
        --v14;
        v12 += 24;
      }
      while (v14 > 1);
    }
  }
  *(void *)(*v6 + 24) = a3;
  *((_DWORD *)v6 + 18) = 0;
  return result;
}

uint64_t *sub_100104B24(uint64_t *a1, int a2)
{
  uint64_t v2 = *a1;
  if (*((unsigned char *)a1 + 76) && v2 == a1[1]) {
    sub_100107CE8();
  }
  BOOL v3 = a2 + 2 >= (int)(-1431655765 * ((unint64_t)(a1[1] - v2) >> 3)) || a2 <= -3;
  uint64_t v4 = v2 + 24 * (a2 + 2);
  if (v3) {
    return a1 + 4;
  }
  else {
    return (uint64_t *)v4;
  }
}

uint64_t sub_100104BA0(uint64_t *a1, int a2)
{
  if (*((unsigned char *)a1 + 76)) {
    sub_100107CE8();
  }
  uint64_t result = 0;
  if (a2 >= -1)
  {
    unsigned int v4 = a2 + 2;
    uint64_t v5 = *a1;
    if (a2 + 2 < (int)(-1431655765 * ((unint64_t)(a1[1] - *a1) >> 3)))
    {
      if (*(unsigned char *)(v5 + 24 * v4 + 16)) {
        return *(void *)(v5 + 24 * v4 + 8) - *(void *)(v5 + 24 * v4);
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_100104C28(uint64_t a1, __n128 a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 232) + 1;
  *(_DWORD *)(a1 + 232) = v3;
  if (v3 >= 0x51) {
    sub_1001003E4(*(void ***)(a1 + 80), 18);
  }
  unsigned int v4 = (_DWORD *)(*(void *)(a1 + 216) - 8);
  if ((unint64_t)v4 < *(void *)(a1 + 208))
  {
    a2 = sub_1001004C4((__n128 *)a1);
    unsigned int v4 = (_DWORD *)(*(void *)(a1 + 216) - 8);
  }
  _DWORD *v4 = 2;
  *(void *)(a1 + 216) = v4;
  uint64_t v5 = *(unsigned int **)(a1 + 88);
  do
  {
    while (v5)
    {
      uint64_t v6 = off_1001BD708[2 * *v5];
      ++*(void *)(a1 + 104);
      if (((unsigned int (*)(uint64_t, __n128))v6)(a1, a2))
      {
        uint64_t v5 = *(unsigned int **)(a1 + 88);
      }
      else
      {
        if (*(void *)(a1 + 104) > *(void *)(a1 + 112)) {
          sub_1001003E4(*(void ***)(a1 + 80), 18);
        }
        if ((*(unsigned char *)(a1 + 97) & 0x20) != 0)
        {
          uint64_t v7 = *(void *)(a1 + 40);
          if (v7 == *(void *)(a1 + 32) && v7 != *(void *)(a1 + 56)) {
            *(unsigned char *)(a1 + 121) = 1;
          }
        }
        *(_WORD *)(a1 + 228) = 0;
        *(unsigned char *)(a1 + 230) = 0;
        while ((((uint64_t (*)(uint64_t, void))off_1001BD928[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228)) & 1) != 0);
        if ((*(unsigned char *)(a1 + 97) & 0x20) != 0)
        {
          uint64_t v8 = *(void *)(a1 + 40);
          if (v8 == *(void *)(a1 + 32) && v8 != *(void *)(a1 + 56)) {
            *(unsigned char *)(a1 + 121) = 1;
          }
        }
        uint64_t v5 = *(unsigned int **)(a1 + 88);
        if (!v5) {
          goto LABEL_26;
        }
      }
    }
    *(_WORD *)(a1 + 228) = 1;
    *(unsigned char *)(a1 + 230) = 0;
    while ((((uint64_t (*)(uint64_t, void, __n128))off_1001BD928[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228), a2) & 1) != 0);
    uint64_t v5 = *(unsigned int **)(a1 + 88);
  }
  while (v5);
LABEL_26:
  uint64_t result = *(unsigned __int8 *)(a1 + 228);
  --*(_DWORD *)(a1 + 232);
  return result;
}

void sub_100104DC4(_Unwind_Exception *a1)
{
  --*(_DWORD *)(v1 + 232);
  _Unwind_Resume(a1);
}

uint64_t sub_100104DE0(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 76)) {
    goto LABEL_2;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3) <= 2) {
    uint64_t v5 = *(void **)(a1 + 8);
  }
  else {
    uint64_t v5 = (void *)(*(void *)a1 + 48);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2[1] - *a2) >> 3) <= 2) {
    uint64_t v6 = a2[1];
  }
  else {
    uint64_t v6 = *a2 + 48;
  }
  uint64_t v7 = sub_100107C60(a1)[1];
  if (*v5 == v7) {
    uint64_t result = (uint64_t)sub_100107CA4(a1);
  }
  else {
    uint64_t result = (uint64_t)sub_100104B24((uint64_t *)a1, 0);
  }
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  if (v8 >= 2) {
    unint64_t v9 = v8 - 2;
  }
  else {
    unint64_t v9 = 0;
  }
  if (v8 >= 3)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    uint64_t v15 = *(void *)result;
    uint64_t v16 = v5 + 2;
    char v17 = (unsigned char *)(v6 + 16);
    do
    {
      uint64_t result = *((void *)v16 - 2);
      uint64_t v18 = *((void *)v17 - 2);
      if (result == v7)
      {
        if (v18 != v7) {
          goto LABEL_2;
        }
        uint64_t result = *v16;
        int v19 = *v17;
        if (*v16) {
          goto LABEL_29;
        }
      }
      else
      {
        if (v18 == v7) {
          return result;
        }
        uint64_t v12 = result - v15;
        uint64_t v13 = v18 - v15;
        if (result - v15 < v18 - v15) {
          return result;
        }
        if (v13 < v12 || (uint64_t v10 = *((void *)v16 - 1) - result, v11 = *((void *)v17 - 1) - v18, v10 != v11))
        {
LABEL_35:
          if (v9 == v14 || v13 >= v12 && v11 <= v10 && (*v16 || !*v17)) {
            return result;
          }
LABEL_2:
          return sub_100100624(a1, (uint64_t)a2);
        }
        int v19 = *v17;
        if (*v16)
        {
          uint64_t v11 = *((void *)v16 - 1) - result;
LABEL_29:
          if (!v19) {
            return result;
          }
          goto LABEL_33;
        }
        uint64_t v11 = *((void *)v16 - 1) - result;
      }
      if (v19) {
        goto LABEL_35;
      }
LABEL_33:
      ++v14;
      v16 += 24;
      v17 += 24;
    }
    while (v14 < v9);
  }
  return result;
}

uint64_t sub_100104FC0(uint64_t a1, __n128 a2)
{
  uint64_t v3 = *(void *)(a1 + 88);
  int v4 = *(_DWORD *)(v3 + 16);
  *(unsigned char *)(a1 + 120) = *(unsigned char *)(v3 + 20);
  switch(v4)
  {
    case -5:
      unint64_t v14 = sub_100104B24(*(uint64_t **)(a1 + 16), 0);
      unint64_t v15 = *(void *)(a1 + 216) - 40;
      if (v15 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v15 = *(void *)(a1 + 216) - 40;
      }
      uint64_t result = 1;
      *(_DWORD *)unint64_t v15 = 1;
      *(_DWORD *)(v15 + 8) = 0;
      *(_OWORD *)(v15 + 16) = *(_OWORD *)v14;
      *(unsigned char *)(v15 + 32) = *((unsigned char *)v14 + 16);
      *(void *)(a1 + 216) = v15;
      uint64_t v16 = *(void *)(a1 + 16);
      uint64_t v17 = *(void *)(a1 + 40);
      *(void *)(*(void *)v16 + 48) = v17;
      *(void *)(*(void *)v16 + 32) = v17;
      *(unsigned char *)(*(void *)v16 + 40) = *(void *)(*(void *)v16 + 24) != *(void *)(*(void *)v16 + 32);
      *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
      return result;
    case -4:
      uint64_t v8 = *(void *)(v3 + 8);
      uint64_t v9 = *(void *)(v8 + 8);
      *(void *)(a1 + 88) = v9;
      if (*(_DWORD *)v9 != 27)
      {
        int v20 = *(_DWORD *)(v9 + 16);
        uint64_t v21 = *(void *)(a1 + 40);
        uint64_t v22 = *(void *)(*(void *)(*(void *)(v9 + 8) + 16) + 8);
        *(void *)(a1 + 88) = *(void *)(*(void *)(v9 + 8) + 8);
        int v23 = sub_100104C28(a1, a2);
        *(void *)(a1 + 40) = v21;
        if ((((v20 == -2) ^ v23) & 1) == 0) {
          uint64_t v22 = *(void *)(v8 + 16);
        }
        *(void *)(a1 + 88) = v22;
        return 1;
      }
      if (sub_1001069A8(a1)) {
        return 1;
      }
      uint64_t v10 = *(void *)(v8 + 16);
      goto LABEL_20;
    case -3:
      char v11 = *(unsigned char *)(a1 + 123);
      *(unsigned char *)(a1 + 123) = 1;
      uint64_t v12 = *(void *)(*(void *)(*(void *)(v3 + 8) + 16) + 8);
      *(void *)(a1 + 88) = *(void *)(*(void *)(v3 + 8) + 8);
      uint64_t result = sub_100104C28(a1, a2);
      if ((result & 1) != 0 || *(unsigned char *)(a1 + 123))
      {
        *(void *)(a1 + 88) = v12;
        *(unsigned char *)(a1 + 123) = v11;
      }
      else if (**(_DWORD **)(a1 + 216))
      {
        do
        {
          *(_WORD *)(a1 + 228) = 0;
          *(unsigned char *)(a1 + 230) = 0;
          while ((((uint64_t (*)(uint64_t, void))off_1001BD928[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228)) & 1) != 0);
          uint64_t result = 0;
        }
        while (**(_DWORD **)(a1 + 216));
      }
      else
      {
        return 0;
      }
      return result;
    case -2:
    case -1:
      uint64_t v5 = *(void *)(*(void *)(*(void *)(v3 + 8) + 16) + 8);
      *(void *)(a1 + 88) = *(void *)(*(void *)(v3 + 8) + 8);
      unint64_t v6 = *(void *)(a1 + 216) - 32;
      if (v6 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v6 = *(void *)(a1 + 216) - 32;
      }
      uint64_t v7 = *(void *)(a1 + 40);
      *(_DWORD *)unint64_t v6 = 3;
      *(void *)(v6 + 8) = v5;
      *(void *)(v6 + 16) = v7;
      *(unsigned char *)(v6 + 24) = v4 == -1;
      *(void *)(a1 + 216) = v6;
      return 1;
    case 0:
      goto LABEL_19;
    default:
      if ((*(unsigned char *)(a1 + 98) & 4) == 0)
      {
        uint64_t v18 = sub_100104B24(*(uint64_t **)(a1 + 16), v4);
        unint64_t v19 = *(void *)(a1 + 216) - 40;
        if (v19 < *(void *)(a1 + 208))
        {
          sub_1001004C4((__n128 *)a1);
          unint64_t v19 = *(void *)(a1 + 216) - 40;
        }
        *(_DWORD *)unint64_t v19 = 1;
        *(_DWORD *)(v19 + 8) = v4;
        *(_OWORD *)(v19 + 16) = *(_OWORD *)v18;
        *(unsigned char *)(v19 + 32) = *((unsigned char *)v18 + 16);
        *(void *)(a1 + 216) = v19;
        *(void *)(**(void **)(a1 + 16) + 24 * v4 + 48) = *(void *)(a1 + 40);
      }
      uint64_t v3 = *(void *)(a1 + 88);
LABEL_19:
      uint64_t v10 = *(void *)(v3 + 8);
LABEL_20:
      *(void *)(a1 + 88) = v10;
      return 1;
  }
}

void sub_100105294(void *a1)
{
  __cxa_begin_catch(a1);
  *(void *)(v1 + 88) = v2;
  while (1)
  {
    *(_WORD *)(v1 + 228) = 1;
    *(unsigned char *)(v1 + 230) = 0;
    while ((((uint64_t (*)(uint64_t, void))off_1001BD928[2 * **(unsigned int **)(v1 + 216)])(v1, *(unsigned __int8 *)(v1 + 228)) & 1) != 0);
    if (!*(void *)(v1 + 88)) {
      __cxa_rethrow();
    }
  }
}

void sub_1001052E0()
{
}

void sub_100105348()
{
}

uint64_t sub_100105378(__n128 *a1)
{
  unint64_t v2 = a1[5].n128_u64[1];
  uint64_t v3 = *(unsigned int *)(v2 + 16);
  a1[7].n128_u8[8] = *(unsigned char *)(v2 + 20);
  if ((int)v3 >= 1)
  {
    if ((a1[6].n128_u8[2] & 4) == 0) {
      sub_1000FE320((_DWORD *)a1[1].n128_u64[0], a1[2].n128_i64[1], v3, 1, 0);
    }
    unint64_t v4 = a1[12].n128_u64[0];
    if (a1[11].n128_u64[1] != v4 && v3 == *(_DWORD *)(v4 - 112))
    {
      a1[5].n128_u64[1] = *(void *)(v4 - 104);
      sub_100100624(a1[1].n128_i64[0], v4 - 96);
      unint64_t v5 = a1[12].n128_u64[0];
      int v6 = *(_DWORD *)(v5 - 112);
      uint64_t v7 = *(void *)(v5 - 104);
      uint64_t v8 = a1[1].n128_i64[0];
      uint64_t v9 = v5 - 96;
      unint64_t v10 = a1[13].n128_u64[1] - 184;
      if (v10 < a1[13].n128_u64[0])
      {
        sub_1001004C4(a1);
        unint64_t v10 = a1[13].n128_u64[1] - 184;
      }
      a1[13].n128_u64[1] = sub_100106E8C(v10, v6, v7, v8, v9);
      unint64_t v11 = a1[12].n128_u64[0];
      unint64_t v12 = v11 - 112;
      sub_100104004(v11 - 96);
      a1[12].n128_u64[0] = v12;
      int v13 = -2 - v3;
      unint64_t v14 = (_DWORD *)(a1[13].n128_u64[1] - 48);
      if ((unint64_t)v14 < a1[13].n128_u64[0])
      {
        sub_1001004C4(a1);
        unint64_t v14 = (_DWORD *)(a1[13].n128_u64[1] - 48);
        unint64_t v12 = a1[12].n128_u64[0];
      }
      uint64_t v15 = a1[2].n128_i64[1];
      if (a1[11].n128_u64[1] == v12) {
        int v16 = -2147483645;
      }
      else {
        int v16 = *(_DWORD *)(v12 - 112);
      }
      _DWORD *v14 = 5;
      sub_100100A38((uint64_t)(v14 + 2), v13, (uint64_t *)&a1[8], v15, v16);
      a1[13].n128_u64[1] = (unint64_t)v14;
    }
    goto LABEL_19;
  }
  if (v3) {
    BOOL v17 = v3 == -4;
  }
  else {
    BOOL v17 = 1;
  }
  if (v17)
  {
LABEL_19:
    unint64_t v18 = *(void *)(a1[5].n128_u64[1] + 8);
    goto LABEL_20;
  }
  unint64_t v18 = 0;
LABEL_20:
  a1[5].n128_u64[1] = v18;
  return 1;
}

BOOL sub_1001054F8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 88);
  unint64_t v3 = *(unsigned int *)(v2 + 16);
  if (v3)
  {
    unint64_t v4 = *(unsigned __int8 **)(a1 + 40);
    if (v4 == *(unsigned __int8 **)(a1 + 32))
    {
      return 0;
    }
    else
    {
      BOOL v5 = 0;
      uint64_t v6 = 0;
      uint64_t v7 = v2 + 24;
      do
      {
        unsigned __int8 v8 = *v4;
        if (*(unsigned char *)(a1 + 120)) {
          unsigned __int8 v8 = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), (char)v8);
        }
        if (*(unsigned __int8 *)(v7 + v6) != v8) {
          break;
        }
        unint64_t v4 = (unsigned __int8 *)(*(void *)(a1 + 40) + 1);
        *(void *)(a1 + 40) = v4;
        if (v3 - 1 == v6)
        {
          uint64_t v2 = *(void *)(a1 + 88);
          goto LABEL_12;
        }
        BOOL v5 = ++v6 >= v3;
      }
      while (v4 != *(unsigned __int8 **)(a1 + 32));
    }
  }
  else
  {
LABEL_12:
    *(void *)(a1 + 88) = *(void *)(v2 + 8);
    return 1;
  }
  return v5;
}

uint64_t sub_1001055EC(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)(a1 + 40);
  int v2 = *(_DWORD *)(a1 + 96);
  if (v1 == *(unsigned char **)(a1 + 64))
  {
    if ((v2 & 0x100) == 0)
    {
      if (v2) {
        return 0;
      }
      goto LABEL_25;
    }
  }
  else if ((v2 & 0x100000) != 0)
  {
    return 0;
  }
  unsigned int v3 = *(v1 - 1);
  if (*(unsigned char **)(a1 + 32) == v1)
  {
    BOOL v6 = v3 > 0xD || ((1 << v3) & 0x3400) == 0;
    if (v6 && v3 != 133) {
      return 0;
    }
    goto LABEL_25;
  }
  uint64_t v4 = 0;
  if (*(v1 - 1) > 0xCu)
  {
    if (v3 != 133)
    {
      if (v3 != 13) {
        return v4;
      }
      if (*v1 == 10) {
        return 0;
      }
    }
LABEL_25:
    *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
    return 1;
  }
  if (v3 == 10 || v3 == 12) {
    goto LABEL_25;
  }
  return v4;
}

uint64_t sub_1001056A4(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 40);
  int v2 = *(_DWORD *)(a1 + 96);
  if (v1 != *(unsigned __int8 **)(a1 + 32))
  {
    if ((v2 & 0x100000) == 0)
    {
      unsigned int v3 = *v1;
      BOOL v4 = v3 > 0xD || ((1 << v3) & 0x3400) == 0;
      if (!v4 || v3 == 133)
      {
        if ((v2 & 0x100) == 0 && v1 == *(unsigned __int8 **)(a1 + 64)) {
          goto LABEL_18;
        }
        if (*(v1 - 1) != 13 || v3 != 10) {
          goto LABEL_18;
        }
      }
    }
    return 0;
  }
  if ((v2 & 2) != 0) {
    return 0;
  }
LABEL_18:
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return 1;
}

uint64_t sub_100105720(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)(a1 + 40);
  if (v1 == *(unsigned char **)(a1 + 32)) {
    return 0;
  }
  unsigned int v2 = *v1;
  if (v2 <= 0xB)
  {
    if (!*v1)
    {
      if ((*(unsigned char *)(a1 + 96) & 0x80) == 0) {
        goto LABEL_9;
      }
      return 0;
    }
    if (v2 != 10)
    {
LABEL_9:
      *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
      *(void *)(a1 + 40) = v1 + 1;
      return 1;
    }
  }
  else if (v2 - 12 >= 2 && v2 != 133)
  {
    goto LABEL_9;
  }
  if ((*(unsigned char *)(*(void *)(a1 + 88) + 16) & *(unsigned char *)(a1 + 180)) != 0) {
    goto LABEL_9;
  }
  return 0;
}

BOOL sub_10010579C(__n128 *a1)
{
  unint64_t v2 = a1[12].n128_u64[0];
  if (a1[11].n128_u64[1] != v2)
  {
    uint64_t v3 = *(void *)(v2 - 104);
    a1[5].n128_u64[1] = v3;
    int v4 = *(_DWORD *)(v2 - 112);
    uint64_t v5 = a1[1].n128_i64[0];
    uint64_t v6 = v2 - 96;
    unint64_t v7 = a1[13].n128_u64[0];
    unint64_t v8 = a1[13].n128_u64[1] - 184;
    if (v8 < v7)
    {
      sub_1001004C4(a1);
      unint64_t v8 = a1[13].n128_u64[1] - 184;
    }
    a1[13].n128_u64[1] = sub_100106E8C(v8, v4, v3, v5, v6);
    sub_100100624(a1[1].n128_i64[0], a1[12].n128_u64[0] - 96);
    unint64_t v9 = a1[12].n128_u64[0];
    unint64_t v10 = v9 - 112;
    sub_100104004(v9 - 96);
    a1[12].n128_u64[0] = v10;
    return 1;
  }
  unsigned __int32 v12 = a1[6].n128_u32[0];
  if ((v12 & 0x800) != 0)
  {
    if (a1[2].n128_u64[1] == *sub_100104B24((uint64_t *)a1[1].n128_u64[0], 0)) {
      return 0;
    }
    unsigned __int32 v12 = a1[6].n128_u32[0];
  }
  if ((v12 & 0x8000) != 0 && a1[2].n128_u64[1] != a1[2].n128_u64[0]) {
    return 0;
  }
  if ((v12 & 0x4000) != 0)
  {
    unint64_t v13 = a1[2].n128_u64[1];
    if (v13 == a1[3].n128_u64[1]) {
      return 0;
    }
  }
  else
  {
    unint64_t v13 = a1[2].n128_u64[1];
  }
  unint64_t v14 = a1[1].n128_u64[0];
  *(void *)(*(void *)v14 + 56) = v13;
  uint64_t v15 = *(void *)v14;
  *(unsigned char *)(v15 + 64) = 1;
  *(void *)uint64_t v15 = v13;
  *(unsigned char *)(*(void *)v14 + 16) = **(void **)v14 != *(void *)(*(void *)v14 + 8);
  *(void *)(v14 + 32) = v13;
  *(void *)(v14 + 40) = v13;
  *(unsigned char *)(v14 + 48) = 0;
  *(unsigned char *)(v14 + 76) = 0;
  a1[5].n128_u64[1] = 0;
  a1[7].n128_u8[10] = 1;
  if ((v12 & 0x20000) == 0) {
    return 1;
  }
  sub_100104DE0(a1->n128_u64[0], (void *)a1[1].n128_u64[0]);
  return (a1[6].n128_u8[1] & 4) != 0;
}

uint64_t sub_100105904(uint64_t a1)
{
  unint64_t v2 = *(char **)(a1 + 40);
  if (v2 == *(char **)(a1 + 32))
  {
    int v3 = 0;
    uint64_t result = 0;
    if ((*(unsigned char *)(a1 + 96) & 0x20) != 0) {
      return result;
    }
  }
  else
  {
    int v3 = sub_1000FE014(*(void *)(a1 + 80), *v2, *(_DWORD *)(a1 + 176));
    unint64_t v2 = *(char **)(a1 + 40);
  }
  if (v2 != *(char **)(a1 + 64) || (int v5 = *(_DWORD *)(a1 + 96), (v5 & 0x100) != 0))
  {
    *(void *)(a1 + 40) = v2 - 1;
    int v7 = sub_1000FE014(*(void *)(a1 + 80), *(v2 - 1), *(_DWORD *)(a1 + 176));
    ++*(void *)(a1 + 40);
    if (v3 == v7) {
      return 0;
    }
  }
  else
  {
    if ((v5 & 0x10) != 0) {
      char v6 = 0;
    }
    else {
      char v6 = v3;
    }
    if ((v6 & 1) == 0) {
      return 0;
    }
  }
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return 1;
}

uint64_t sub_1001059C0(uint64_t a1)
{
  int v2 = sub_100105904(a1);
  if ((v2 & 1) == 0) {
    *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  }
  return v2 ^ 1u;
}

BOOL sub_1001059F8(uint64_t a1)
{
  uint64_t v1 = *(char **)(a1 + 40);
  if (v1 == *(char **)(a1 + 32)) {
    return 0;
  }
  BOOL result = sub_1000FE014(*(void *)(a1 + 80), *v1, *(_DWORD *)(a1 + 176));
  if (!result) {
    return result;
  }
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4 != *(void *)(a1 + 64) || (int v5 = *(_DWORD *)(a1 + 96), (v5 & 0x100) != 0))
  {
    if (sub_1000FE014(*(void *)(a1 + 80), *(char *)(v4 - 1), *(_DWORD *)(a1 + 176))) {
      return 0;
    }
  }
  else if ((v5 & 0x10) != 0)
  {
    return 0;
  }
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return 1;
}

BOOL sub_100105A80(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2 == *(void *)(a1 + 64) && (*(unsigned char *)(a1 + 97) & 1) == 0) {
    return 0;
  }
  BOOL result = sub_1000FE014(*(void *)(a1 + 80), *(char *)(v2 - 1), *(_DWORD *)(a1 + 176));
  if (!result) {
    return result;
  }
  uint64_t v4 = *(char **)(a1 + 40);
  if (v4 == *(char **)(a1 + 32))
  {
    if ((*(unsigned char *)(a1 + 96) & 0x20) != 0) {
      return 0;
    }
  }
  else if (sub_1000FE014(*(void *)(a1 + 80), *v4, *(_DWORD *)(a1 + 176)))
  {
    return 0;
  }
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return 1;
}

uint64_t sub_100105B0C(uint64_t a1)
{
  if (*(void *)(a1 + 40) != *(void *)(a1 + 64) || (*(unsigned char *)(a1 + 96) & 4) != 0) {
    return 0;
  }
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return 1;
}

uint64_t sub_100105B40(uint64_t a1)
{
  if (*(void *)(a1 + 40) != *(void *)(a1 + 32) || (*(unsigned char *)(a1 + 96) & 8) != 0) {
    return 0;
  }
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return 1;
}

uint64_t sub_100105B70(uint64_t a1)
{
  int v2 = *(_DWORD *)(*(void *)(a1 + 88) + 16);
  if (v2 >= 0x40000000)
  {
    int v3 = **(uint64_t ***)(a1 + 72);
    v16[0] = 0;
    v16[1] = v2;
    uint64_t v4 = sub_100100B38(*v3, v3[1], (uint64_t)v16);
    uint64_t v6 = v5;
    uint64_t v7 = v4 + 8;
    do
    {
      int v2 = *(_DWORD *)(v7 - 8);
      if (v7 == v6) {
        break;
      }
      unint64_t v8 = sub_100104B24(*(uint64_t **)(a1 + 16), *(_DWORD *)(v7 - 8));
      v7 += 8;
    }
    while (!*((unsigned char *)v8 + 16));
  }
  if ((*(unsigned char *)(a1 + 98) & 1) == 0 || *((unsigned char *)sub_100104B24(*(uint64_t **)(a1 + 16), v2) + 16))
  {
    unint64_t v9 = (char *)*sub_100104B24(*(uint64_t **)(a1 + 16), v2);
    uint64_t v10 = sub_100104B24(*(uint64_t **)(a1 + 16), v2)[1];
    if (v9 == (char *)v10)
    {
LABEL_16:
      *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
      return 1;
    }
    unint64_t v11 = *(char **)(a1 + 40);
    while (v11 != *(char **)(a1 + 32))
    {
      char v12 = *v11;
      if (*(unsigned char *)(a1 + 120))
      {
        uint64_t v13 = *(void *)(**(void **)(a1 + 80) + 8);
        char v12 = (*(uint64_t (**)(uint64_t, void))(*(void *)v13 + 40))(v13, v12);
        char v14 = *v9;
        if (*(unsigned char *)(a1 + 120)) {
          char v14 = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), v14);
        }
      }
      else
      {
        char v14 = *v9;
      }
      if (v12 != v14) {
        break;
      }
      ++v9;
      unint64_t v11 = (char *)(*(void *)(a1 + 40) + 1);
      *(void *)(a1 + 40) = v11;
      if (v9 == (char *)v10) {
        goto LABEL_16;
      }
    }
  }
  return 0;
}

uint64_t sub_100105D20(uint64_t a1)
{
  int v2 = *(std::string::value_type **)(a1 + 40);
  int v3 = *(std::string::value_type **)(a1 + 32);
  if (v2 == v3) {
    return 0;
  }
  uint64_t v4 = sub_100107028(v2, v3, *(void *)(a1 + 88), **(void **)(a1 + 72), *(unsigned __int8 *)(a1 + 120));
  if (*(std::string::value_type **)(a1 + 40) == v4) {
    return 0;
  }
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  *(void *)(a1 + 40) = v4;
  return 1;
}

uint64_t sub_100105D8C(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 40);
  if (v1 == *(unsigned __int8 **)(a1 + 32)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 88);
  unsigned __int8 v4 = *v1;
  if (*(unsigned char *)(a1 + 120)) {
    unsigned __int8 v4 = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), (char)v4);
  }
  if (!*(unsigned char *)(v3 + v4 + 16)) {
    return 0;
  }
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  ++*(void *)(a1 + 40);
  return 1;
}

uint64_t sub_100105E30(uint64_t a1)
{
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 16);
  return 1;
}

uint64_t sub_100105E44(__n128 *a1)
{
  unint64_t v2 = a1[5].n128_u64[1];
  uint64_t v3 = (unsigned __int8 *)a1[2].n128_u64[1];
  if (v3 == (unsigned __int8 *)a1[2].n128_u64[0]) {
    unsigned int v4 = *(_DWORD *)(v2 + 280);
  }
  else {
    unsigned int v4 = *(unsigned __int8 *)(v2 + *v3 + 24);
  }
  int v5 = (v4 >> 1) & 1;
  if (v4)
  {
    if (v5)
    {
      uint64_t v7 = *(void *)(v2 + 16);
      unint64_t v8 = a1[13].n128_u64[1] - 24;
      if (v8 < a1[13].n128_u64[0])
      {
        sub_1001004C4(a1);
        unint64_t v8 = a1[13].n128_u64[1] - 24;
        uint64_t v3 = (unsigned __int8 *)a1[2].n128_u64[1];
      }
      *(_DWORD *)unint64_t v8 = 4;
      *(void *)(v8 + 8) = v7;
      *(void *)(v8 + 16) = v3;
      a1[13].n128_u64[1] = v8;
      unint64_t v2 = a1[5].n128_u64[1];
    }
    uint64_t v6 = (unint64_t *)(v2 + 8);
    goto LABEL_12;
  }
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v2 + 16);
LABEL_12:
    a1[5].n128_u64[1] = *v6;
    return 1;
  }
  return 0;
}

uint64_t sub_100105EF4(__n128 *a1)
{
  unint64_t v2 = a1[5].n128_u64[1];
  uint64_t v3 = (unsigned __int8 *)a1[2].n128_u64[1];
  if (v3 == (unsigned __int8 *)a1[2].n128_u64[0]) {
    unsigned int v4 = *(_DWORD *)(v2 + 280);
  }
  else {
    unsigned int v4 = *(unsigned __int8 *)(v2 + *v3 + 24);
  }
  int v5 = v4 & 1;
  int v6 = (v4 >> 1) & 1;
  uint64_t v7 = (_DWORD *)a1[13].n128_u64[1];
  if (*v7 == 5)
  {
    int v8 = v7[6];
    int v9 = *(_DWORD *)(v2 + 304);
    if (v8 == v9)
    {
      unint64_t v10 = a1[8].n128_u64[0];
      int v9 = v7[6];
      if (*(_DWORD *)(v10 + 16) == v8) {
        goto LABEL_15;
      }
    }
  }
  else
  {
    int v9 = *(_DWORD *)(v2 + 304);
  }
  unint64_t v11 = v7 - 12;
  if ((unint64_t)(v7 - 12) < a1[13].n128_u64[0])
  {
    sub_1001004C4(a1);
    unint64_t v11 = (_DWORD *)(a1[13].n128_u64[1] - 48);
    uint64_t v3 = (unsigned __int8 *)a1[2].n128_u64[1];
  }
  unint64_t v12 = a1[12].n128_u64[0];
  if (a1[11].n128_u64[1] == v12) {
    int v13 = -2147483645;
  }
  else {
    int v13 = *(_DWORD *)(v12 - 112);
  }
  *unint64_t v11 = 5;
  sub_100100A38((uint64_t)(v11 + 2), v9, (uint64_t *)&a1[8], (uint64_t)v3, v13);
  a1[13].n128_u64[1] = (unint64_t)v11;
  unint64_t v10 = a1[8].n128_u64[0];
LABEL_15:
  unint64_t v14 = *(void *)(v2 + 296);
  if (*(void *)(v10 + 24))
  {
    unint64_t v15 = a1[2].n128_u64[1];
    if (v15 == *(void *)(v10 + 32))
    {
      *(void *)(v10 + 24) = v14;
      unint64_t v16 = v14;
      goto LABEL_20;
    }
  }
  else
  {
    unint64_t v15 = a1[2].n128_u64[1];
  }
  *(void *)(v10 + 32) = v15;
  unint64_t v10 = a1[8].n128_u64[0];
  unint64_t v16 = *(void *)(v10 + 24);
LABEL_20:
  if (v16 >= *(void *)(v2 + 288))
  {
    if (*(unsigned char *)(v2 + 309) && ((a1[6].n128_u8[1] & 4) == 0 || a1[7].n128_u8[11]))
    {
      if (v16 < v14) {
        int v18 = v5;
      }
      else {
        int v18 = 0;
      }
      if (v18 == 1)
      {
        if (v6)
        {
          uint64_t v19 = *(void *)(v2 + 16);
          unint64_t v20 = a1[13].n128_u64[1] - 24;
          if (v20 < a1[13].n128_u64[0])
          {
            sub_1001004C4(a1);
            unint64_t v20 = a1[13].n128_u64[1] - 24;
          }
          unint64_t v21 = a1[2].n128_u64[1];
          *(_DWORD *)unint64_t v20 = 4;
          *(void *)(v20 + 8) = v19;
          *(void *)(v20 + 16) = v21;
          a1[13].n128_u64[1] = v20;
          unint64_t v10 = a1[8].n128_u64[0];
          unint64_t v16 = *(void *)(v10 + 24);
        }
        goto LABEL_22;
      }
      if (!v6) {
        return 0;
      }
    }
    else
    {
      if (v16 < v14) {
        int v22 = v5;
      }
      else {
        int v22 = 0;
      }
      if (!v6)
      {
        if (v22) {
          goto LABEL_22;
        }
        return 0;
      }
      if (v22)
      {
        uint64_t v23 = *(void *)(v2 + 8);
        unint64_t v24 = a1[13].n128_u64[1] - 24;
        if (v24 < a1[13].n128_u64[0])
        {
          sub_1001004C4(a1);
          unint64_t v24 = a1[13].n128_u64[1] - 24;
        }
        unint64_t v25 = a1[2].n128_u64[1];
        *(_DWORD *)unint64_t v24 = 13;
        *(void *)(v24 + 8) = v23;
        *(void *)(v24 + 16) = v25;
        a1[13].n128_u64[1] = v24;
      }
    }
    BOOL v17 = (unint64_t *)(v2 + 16);
    goto LABEL_44;
  }
  if (v5)
  {
LABEL_22:
    *(void *)(v10 + 24) = v16 + 1;
    BOOL v17 = (unint64_t *)(v2 + 8);
LABEL_44:
    a1[5].n128_u64[1] = *v17;
    return 1;
  }
  return 0;
}

BOOL sub_100106128(uint64_t a1)
{
  unint64_t v2 = *(char **)(a1 + 32);
  uint64_t v1 = *(char **)(a1 + 40);
  if (v1 != v2)
  {
    if (*(unsigned char *)(a1 + 120))
    {
      uint64_t v4 = *(void *)(**(void **)(a1 + 80) + 8);
      (*(void (**)(uint64_t, void))(*(void *)v4 + 40))(v4, *v1);
      int v5 = *(char **)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 40);
    }
    else
    {
      int v5 = *(char **)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 40);
    }
    uint64_t v7 = (char *)(v6 + 1);
    *(void *)(a1 + 40) = v7;
    if (v7 != v5 && *(unsigned char *)(a1 + 120))
    {
      uint64_t v8 = *(void *)(**(void **)(a1 + 80) + 8);
      (*(void (**)(uint64_t, void))(*(void *)v8 + 40))(v8, *v7);
    }
    *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  }
  return v1 != v2;
}

uint64_t sub_100106208(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 96) & 8) != 0) {
    return 0;
  }
  unint64_t v2 = *(unsigned __int8 **)(a1 + 40);
  if (*(unsigned __int8 **)(a1 + 32) != v2)
  {
    while (1)
    {
      unsigned __int8 v3 = *v2;
      if (*(unsigned char *)(a1 + 120)) {
        unsigned __int8 v3 = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), (char)v3);
      }
      if (v3 > 0xDu || ((1 << v3) & 0x3400) == 0) {
        break;
      }
      if (++v2 == *(unsigned __int8 **)(a1 + 32)) {
        goto LABEL_10;
      }
    }
    if (v2 != *(unsigned __int8 **)(a1 + 32)) {
      return 0;
    }
  }
LABEL_10:
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return 1;
}

BOOL sub_1001062DC(void *a1)
{
  uint64_t v1 = a1[5];
  uint64_t v2 = a1[7];
  if (v1 == v2) {
    a1[11] = *(void *)(a1[11] + 8);
  }
  return v1 == v2;
}

uint64_t sub_100106308(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 88);
  if (*(unsigned char *)(v2 + 309))
  {
    if ((*(unsigned char *)(a1 + 97) & 4) == 0)
    {
      unsigned __int8 v3 = (unint64_t *)(v2 + 296);
      uint64_t v4 = (unint64_t *)(v2 + 288);
LABEL_6:
      int v5 = 1;
      uint64_t v6 = v3;
      goto LABEL_9;
    }
    unsigned __int8 v3 = (unint64_t *)(v2 + 296);
    uint64_t v4 = (unint64_t *)(v2 + 288);
    if (*(unsigned char *)(a1 + 123)) {
      goto LABEL_6;
    }
    int v5 = 0;
  }
  else
  {
    int v5 = 0;
    unsigned __int8 v3 = (unint64_t *)(v2 + 296);
    uint64_t v4 = (unint64_t *)(v2 + 288);
  }
  uint64_t v6 = v4;
LABEL_9:
  unint64_t v7 = *v6;
  uint64_t v8 = *(unsigned __int8 **)(a1 + 40);
  if (v7 == -1)
  {
    int v9 = *(unsigned __int8 **)(a1 + 32);
  }
  else if (v7 >= *(void *)(a1 + 32) - (void)v8)
  {
    int v9 = *(unsigned __int8 **)(a1 + 32);
  }
  else
  {
    int v9 = &v8[v7];
  }
  if (v9 == v8)
  {
    unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
  }
  else
  {
    int v10 = *(unsigned __int8 *)(*(void *)(v2 + 8) + 24);
    unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
    while (1)
    {
      unsigned __int8 v12 = *v11;
      if (*(unsigned char *)(a1 + 120))
      {
        unsigned __int8 v12 = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), (char)v12);
        unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
      }
      if (v10 != v12) {
        break;
      }
      *(void *)(a1 + 40) = ++v11;
      if (v11 == v9)
      {
        unint64_t v11 = v9;
        break;
      }
    }
  }
  unint64_t v13 = (v11 - v8);
  unint64_t v14 = *v4;
  if (v13 < *v4) {
    return 0;
  }
  if (v5)
  {
    if (*(unsigned char *)(v2 + 308) && v13 < *v3) {
      *(void *)(a1 + 48) = v11;
    }
    if (v13 != v14)
    {
      unint64_t v16 = *(void *)(a1 + 216) - 32;
      if (v16 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v16 = *(void *)(a1 + 216) - 32;
      }
      *(_DWORD *)unint64_t v16 = 7;
      *(void *)(v16 + 8) = v13;
      *(void *)(v16 + 16) = v2;
      *(void *)(v16 + 24) = v11;
      *(void *)(a1 + 216) = v16;
    }
    *(void *)(a1 + 88) = *(void *)(v2 + 16);
    return 1;
  }
  else
  {
    if (v13 < *v3)
    {
      unint64_t v17 = *(void *)(a1 + 216) - 32;
      if (v17 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v17 = *(void *)(a1 + 216) - 32;
      }
      *(_DWORD *)unint64_t v17 = 10;
      *(void *)(v17 + 8) = v13;
      *(void *)(v17 + 16) = v2;
      *(void *)(v17 + 24) = v11;
      *(void *)(a1 + 216) = v17;
      unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
    }
    *(void *)(a1 + 88) = *(void *)(v2 + 16);
    if (v11 == *(unsigned __int8 **)(a1 + 32)) {
      unsigned int v18 = *(unsigned __int8 *)(v2 + 280);
    }
    else {
      unsigned int v18 = *(unsigned __int8 *)(v2 + *v11 + 24);
    }
    return (v18 >> 1) & 1;
  }
}

uint64_t sub_100106538(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 88);
  if (*(unsigned char *)(v2 + 309))
  {
    if ((*(unsigned char *)(a1 + 97) & 4) == 0)
    {
      unsigned __int8 v3 = (unint64_t *)(v2 + 296);
      uint64_t v4 = (unint64_t *)(v2 + 288);
LABEL_6:
      int v5 = 1;
      uint64_t v6 = v3;
      goto LABEL_9;
    }
    unsigned __int8 v3 = (unint64_t *)(v2 + 296);
    uint64_t v4 = (unint64_t *)(v2 + 288);
    if (*(unsigned char *)(a1 + 123)) {
      goto LABEL_6;
    }
    int v5 = 0;
  }
  else
  {
    int v5 = 0;
    unsigned __int8 v3 = (unint64_t *)(v2 + 296);
    uint64_t v4 = (unint64_t *)(v2 + 288);
  }
  uint64_t v6 = v4;
LABEL_9:
  unint64_t v7 = *v6;
  uint64_t v8 = *(unsigned __int8 **)(a1 + 40);
  if (v7 == -1)
  {
    int v9 = *(unsigned __int8 **)(a1 + 32);
  }
  else if (v7 >= *(void *)(a1 + 32) - (void)v8)
  {
    int v9 = *(unsigned __int8 **)(a1 + 32);
  }
  else
  {
    int v9 = &v8[v7];
  }
  if (v9 == v8)
  {
    unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
  }
  else
  {
    uint64_t v10 = *(void *)(v2 + 8) + 16;
    unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
    while (1)
    {
      unsigned __int8 v12 = *v11;
      if (*(unsigned char *)(a1 + 120))
      {
        unsigned __int8 v12 = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), (char)v12);
        unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
      }
      if (!*(unsigned char *)(v10 + v12)) {
        break;
      }
      *(void *)(a1 + 40) = ++v11;
      if (v11 == v9)
      {
        unint64_t v11 = v9;
        break;
      }
    }
  }
  unint64_t v13 = (v11 - v8);
  unint64_t v14 = *v4;
  if (v13 < *v4) {
    return 0;
  }
  if (v5)
  {
    if (*(unsigned char *)(v2 + 308) && v13 < *v3) {
      *(void *)(a1 + 48) = v11;
    }
    if (v13 != v14)
    {
      unint64_t v16 = *(void *)(a1 + 216) - 32;
      if (v16 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v16 = *(void *)(a1 + 216) - 32;
      }
      *(_DWORD *)unint64_t v16 = 7;
      *(void *)(v16 + 8) = v13;
      *(void *)(v16 + 16) = v2;
      *(void *)(v16 + 24) = v11;
      *(void *)(a1 + 216) = v16;
    }
    *(void *)(a1 + 88) = *(void *)(v2 + 16);
    return 1;
  }
  else
  {
    if (v13 < *v3)
    {
      unint64_t v17 = *(void *)(a1 + 216) - 32;
      if (v17 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v17 = *(void *)(a1 + 216) - 32;
      }
      *(_DWORD *)unint64_t v17 = 11;
      *(void *)(v17 + 8) = v13;
      *(void *)(v17 + 16) = v2;
      *(void *)(v17 + 24) = v11;
      *(void *)(a1 + 216) = v17;
      unint64_t v11 = *(unsigned __int8 **)(a1 + 40);
    }
    *(void *)(a1 + 88) = *(void *)(v2 + 16);
    if (v11 == *(unsigned __int8 **)(a1 + 32)) {
      unsigned int v18 = *(unsigned __int8 *)(v2 + 280);
    }
    else {
      unsigned int v18 = *(unsigned __int8 *)(v2 + *v11 + 24);
    }
    return (v18 >> 1) & 1;
  }
}

uint64_t sub_10010676C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 88);
  if (*(unsigned char *)(v2 + 309))
  {
    if ((*(unsigned char *)(a1 + 97) & 4) == 0)
    {
      unsigned __int8 v3 = (unint64_t *)(v2 + 296);
      uint64_t v4 = (unint64_t *)(v2 + 288);
LABEL_6:
      int v5 = 1;
      uint64_t v6 = v3;
      goto LABEL_9;
    }
    unsigned __int8 v3 = (unint64_t *)(v2 + 296);
    uint64_t v4 = (unint64_t *)(v2 + 288);
    if (*(unsigned char *)(a1 + 123)) {
      goto LABEL_6;
    }
    int v5 = 0;
  }
  else
  {
    int v5 = 0;
    unsigned __int8 v3 = (unint64_t *)(v2 + 296);
    uint64_t v4 = (unint64_t *)(v2 + 288);
  }
  uint64_t v6 = v4;
LABEL_9:
  unint64_t v7 = *v6;
  uint64_t v8 = *(unsigned __int8 **)(a1 + 40);
  if (v7 == -1)
  {
    int v9 = *(unsigned __int8 **)(a1 + 32);
  }
  else if (v7 >= *(void *)(a1 + 32) - (void)v8)
  {
    int v9 = *(unsigned __int8 **)(a1 + 32);
  }
  else
  {
    int v9 = &v8[v7];
  }
  if (v9 == v8)
  {
    unint64_t v11 = *(std::string::value_type **)(a1 + 40);
    int v9 = *(unsigned __int8 **)(a1 + 40);
  }
  else
  {
    uint64_t v10 = *(void *)(v2 + 8);
    unint64_t v11 = *(std::string::value_type **)(a1 + 40);
    while (1)
    {
      unsigned __int8 v12 = sub_100107028(v11, *(std::string::value_type **)(a1 + 32), v10, **(void **)(a1 + 72), *(unsigned __int8 *)(a1 + 120));
      unint64_t v11 = *(std::string::value_type **)(a1 + 40);
      if (v11 == v12) {
        break;
      }
      *(void *)(a1 + 40) = ++v11;
      if (v11 == (std::string::value_type *)v9) {
        goto LABEL_21;
      }
    }
    int v9 = (unsigned __int8 *)v12;
  }
LABEL_21:
  unint64_t v13 = (v9 - v8);
  unint64_t v14 = *v4;
  if (v13 < *v4) {
    return 0;
  }
  if (v5)
  {
    if (*(unsigned char *)(v2 + 308) && v13 < *v3) {
      *(void *)(a1 + 48) = v11;
    }
    if (v13 != v14)
    {
      unint64_t v16 = *(void *)(a1 + 216) - 32;
      if (v16 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v16 = *(void *)(a1 + 216) - 32;
      }
      *(_DWORD *)unint64_t v16 = 7;
      *(void *)(v16 + 8) = v13;
      *(void *)(v16 + 16) = v2;
      *(void *)(v16 + 24) = v9;
      *(void *)(a1 + 216) = v16;
    }
    *(void *)(a1 + 88) = *(void *)(v2 + 16);
    return 1;
  }
  else
  {
    if (v13 < *v3)
    {
      unint64_t v17 = *(void *)(a1 + 216) - 32;
      if (v17 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        unint64_t v17 = *(void *)(a1 + 216) - 32;
      }
      *(_DWORD *)unint64_t v17 = 12;
      *(void *)(v17 + 8) = v13;
      *(void *)(v17 + 16) = v2;
      *(void *)(v17 + 24) = v9;
      *(void *)(a1 + 216) = v17;
      int v9 = *(unsigned __int8 **)(a1 + 40);
    }
    *(void *)(a1 + 88) = *(void *)(v2 + 16);
    if (v9 == *(unsigned __int8 **)(a1 + 32)) {
      unsigned int v18 = *(unsigned __int8 *)(v2 + 280);
    }
    else {
      unsigned int v18 = *(unsigned __int8 *)(v2 + *v9 + 24);
    }
    return (v18 >> 1) & 1;
  }
}

BOOL sub_100106970(void *a1)
{
  uint64_t v1 = a1[5];
  uint64_t v2 = v1 - a1[8];
  uint64_t v3 = a1[11];
  uint64_t v4 = *(int *)(v3 + 16);
  if (v2 >= v4)
  {
    a1[5] = v1 - v4;
    a1[11] = *(void *)(v3 + 8);
  }
  return v2 >= v4;
}

BOOL sub_1001069A8(uint64_t a1)
{
  int v1 = *(_DWORD *)(*(void *)(a1 + 88) + 16);
  if (v1 == 9999) {
    return 0;
  }
  if (v1 < 1)
  {
    if (v1 > -1073741825)
    {
      uint64_t v17 = *(void *)(a1 + 192);
      if (*(void *)(a1 + 184) != v17)
      {
        int v18 = *(_DWORD *)(v17 - 112);
        if (v1) {
          BOOL v19 = v18 == ~v1;
        }
        else {
          BOOL v19 = 1;
        }
        BOOL result = v19;
        goto LABEL_34;
      }
    }
    else
    {
      unsigned __int8 v12 = **(uint64_t ***)(a1 + 72);
      int v23 = 0;
      int v24 = ~v1;
      uint64_t v13 = sub_100100B38(*v12, v12[1], (uint64_t)&v23);
      uint64_t v15 = *(void *)(a1 + 192);
      if (*(void *)(a1 + 184) == v15) {
        int v16 = -1;
      }
      else {
        int v16 = *(_DWORD *)(v15 - 112);
      }
      if (v13 != v14)
      {
        uint64_t v20 = v13 + 8;
        do
        {
          int v21 = *(_DWORD *)(v20 - 8);
          BOOL result = v16 == v21;
          BOOL v22 = v16 == v21 || v20 == v14;
          v20 += 8;
        }
        while (!v22);
        goto LABEL_34;
      }
    }
    goto LABEL_33;
  }
  if (v1 >> 30)
  {
    uint64_t v4 = **(uint64_t ***)(a1 + 72);
    int v23 = 0;
    int v24 = v1;
    uint64_t v5 = sub_100100B38(*v4, v4[1], (uint64_t)&v23);
    if (v5 != v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = v5 + 8;
      do
      {
        int v9 = sub_100104B24(*(uint64_t **)(a1 + 16), *(_DWORD *)(v8 - 8));
        int v10 = *((unsigned __int8 *)v9 + 16);
        BOOL result = *((unsigned char *)v9 + 16) != 0;
        if (v10) {
          BOOL v11 = 1;
        }
        else {
          BOOL v11 = v8 == v7;
        }
        v8 += 8;
      }
      while (!v11);
      goto LABEL_34;
    }
LABEL_33:
    BOOL result = 0;
    goto LABEL_34;
  }
  BOOL result = *((unsigned char *)sub_100104B24(*(uint64_t **)(a1 + 16), v1) + 16) != 0;
LABEL_34:
  *(void *)(a1 + 88) = *(void *)(*(void *)(a1 + 88) + 8);
  return result;
}

uint64_t sub_100106B14(__n128 *a1)
{
  unsigned __int8 v2 = a1[7].n128_u8[8];
  unint64_t v3 = a1[13].n128_u64[1] - 16;
  if (v3 < a1[13].n128_u64[0])
  {
    sub_1001004C4(a1);
    unint64_t v3 = a1[13].n128_u64[1] - 16;
  }
  *(_DWORD *)unint64_t v3 = 18;
  *(unsigned char *)(v3 + 8) = v2;
  a1[13].n128_u64[1] = v3;
  unint64_t v4 = a1[5].n128_u64[1];
  a1[7].n128_u8[8] = *(unsigned char *)(v4 + 16);
  a1[5].n128_u64[1] = *(void *)(v4 + 8);
  return 1;
}

uint64_t sub_100106B80(__n128 *a1)
{
  unint64_t v2 = a1[12].n128_u64[0];
  unint64_t v3 = &a1[11].n128_i64[1];
  while (v2 != a1[11].n128_u64[1])
  {
    int v4 = *(_DWORD *)(v2 - 112);
    v2 -= 112;
    if (v4 == *(_DWORD *)(*(void *)(a1[5].n128_u64[1] + 16) + 16))
    {
      if (*(void *)(v2 + 104) == a1[2].n128_u64[1]) {
        return 0;
      }
      break;
    }
  }
  uint64_t v5 = (_DWORD *)(a1[13].n128_u64[1] - 8);
  if ((unint64_t)v5 < a1[13].n128_u64[0])
  {
    sub_1001004C4(a1);
    uint64_t v5 = (_DWORD *)(a1[13].n128_u64[1] - 8);
  }
  *uint64_t v5 = 15;
  a1[13].n128_u64[1] = (unint64_t)v5;
  unint64_t v6 = a1[12].n128_u64[1];
  if (v6 == a1[11].n128_u64[1])
  {
    sub_100107814(v3, 0x32uLL);
    unint64_t v6 = a1[12].n128_u64[1];
  }
  long long v21 = 0uLL;
  long long v20 = 0u;
  long long v18 = 0u;
  memset(v19, 0, sizeof(v19));
  BYTE12(v20) = 1;
  unint64_t v7 = a1[12].n128_u64[0];
  if (v7 >= v6)
  {
    uint64_t v8 = sub_100107A00(v3, &v18);
  }
  else
  {
    *(void *)unint64_t v7 = 0;
    *(void *)(v7 + 8) = 0;
    sub_100106EFC(v7 + 16, (uint64_t)v19);
    *(_OWORD *)(v7 + 96) = v21;
    uint64_t v8 = v7 + 112;
    a1[12].n128_u64[0] = v7 + 112;
  }
  a1[12].n128_u64[0] = v8;
  sub_100104004((uint64_t)v19);
  unint64_t v9 = a1[12].n128_u64[0];
  *(void *)(v9 - 104) = *(void *)(a1[5].n128_u64[1] + 8);
  sub_100100624(v9 - 96, a1[1].n128_i64[0]);
  unint64_t v10 = *(void *)(a1[5].n128_u64[1] + 16);
  a1[5].n128_u64[1] = v10;
  unint64_t v11 = a1[12].n128_u64[0];
  *(_DWORD *)(v11 - 112) = *(_DWORD *)(v10 + 16);
  *(void *)(v11 - 8) = a1[2].n128_u64[1];
  int v12 = -2 - *(_DWORD *)(a1[5].n128_u64[1] + 16);
  uint64_t v13 = (_DWORD *)(a1[13].n128_u64[1] - 48);
  if ((unint64_t)v13 < a1[13].n128_u64[0])
  {
    sub_1001004C4(a1);
    uint64_t v13 = (_DWORD *)(a1[13].n128_u64[1] - 48);
  }
  uint64_t v14 = a1[2].n128_i64[1];
  unint64_t v15 = a1[12].n128_u64[0];
  if (a1[11].n128_u64[1] == v15) {
    int v16 = -2147483645;
  }
  else {
    int v16 = *(_DWORD *)(v15 - 112);
  }
  *uint64_t v13 = 5;
  sub_100100A38((uint64_t)(v13 + 2), v12, (uint64_t *)&a1[8], v14, v16);
  a1[13].n128_u64[1] = (unint64_t)v13;
  return 1;
}

void sub_100106D54(_Unwind_Exception *a1)
{
  sub_100104004(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100106D74()
{
  return 0;
}

uint64_t sub_100106D7C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 192);
  if (*(void *)(a1 + 184) == v1) {
    int v2 = 0x7FFFFFFF;
  }
  else {
    int v2 = *(_DWORD *)(v1 - 112);
  }
  return sub_100107B3C(a1, v2, 1);
}

uint64_t sub_100106D9C(__n128 *a1)
{
  int v2 = *(_DWORD *)(a1[5].n128_u64[1] + 16);
  if (v2 == 1)
  {
    unint64_t v4 = a1[2].n128_u64[1];
    if (a1[1].n128_u64[1] == v4) {
      goto LABEL_7;
    }
    unint64_t v3 = v4 - 1;
  }
  else
  {
    if (v2 != 2) {
      goto LABEL_7;
    }
    unint64_t v3 = a1[2].n128_u64[0];
  }
  a1[3].n128_u64[0] = v3;
LABEL_7:
  uint64_t v5 = (_DWORD *)(a1[13].n128_u64[1] - 8);
  if ((unint64_t)v5 < a1[13].n128_u64[0])
  {
    sub_1001004C4(a1);
    uint64_t v5 = (_DWORD *)(a1[13].n128_u64[1] - 8);
  }
  *uint64_t v5 = 16;
  a1[13].n128_u64[1] = (unint64_t)v5;
  a1[5].n128_u64[1] = *(void *)(a1[5].n128_u64[1] + 8);
  return 1;
}

uint64_t sub_100106E30(__n128 *a1)
{
  int v2 = (_DWORD *)(a1[13].n128_u64[1] - 8);
  if ((unint64_t)v2 < a1[13].n128_u64[0])
  {
    sub_1001004C4(a1);
    int v2 = (_DWORD *)(a1[13].n128_u64[1] - 8);
  }
  _DWORD *v2 = 17;
  a1[13].n128_u64[1] = (unint64_t)v2;
  a1[5].n128_u64[1] = *(void *)(a1[5].n128_u64[1] + 8);
  return 1;
}

uint64_t sub_100106E8C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_DWORD *)a1 = 14;
  *(_DWORD *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a3;
  sub_100106EFC(a1 + 24, a4);
  sub_100106EFC(a1 + 104, a5);
  return a1;
}

void sub_100106EE8(_Unwind_Exception *a1)
{
  sub_100104004(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100106EFC(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_100106FA4((char *)a1, *(void *)a2, *(void *)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v4 = *(void *)(a2 + 64);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  int v5 = *(unsigned __int8 *)(a2 + 76);
  *(unsigned char *)(a1 + 76) = v5;
  if (!v5)
  {
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
  }
  return a1;
}

char *sub_100106FA4(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    BOOL result = sub_100082C04(result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
      *(unsigned char *)(v7 + 16) = *(unsigned char *)(a2 + 16);
      v7 += 24;
      a2 += 24;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_10010700C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

std::string::value_type *sub_100107028(std::string::value_type *a1, std::string::value_type *a2, uint64_t a3, uint64_t a4, int a5)
{
  int v5 = a1;
  if (a1 == a2) {
    return v5;
  }
  unint64_t v9 = (const std::string::value_type *)(a3 + 40);
  unint64_t v10 = *(uint64_t **)(a4 + 24);
  if (*(_DWORD *)(a3 + 16))
  {
    unsigned int v12 = 0;
    do
    {
      LOBYTE(v13) = *v9;
      if (*v9)
      {
        uint64_t v14 = 0;
        do
        {
          std::string::value_type v15 = v5[v14];
          if (a5)
          {
            std::string::value_type v15 = (*(uint64_t (**)(void, void))(**(void **)(*v10 + 8) + 40))(*(void *)(*v10 + 8), v15);
            LOBYTE(v13) = v9[v14];
          }
          if (v15 != v13) {
            break;
          }
          int v16 = &v9[v14++];
          int v13 = *((unsigned __int8 *)v16 + 1);
        }
        while (v13 && &v5[v14] != a2);
        v9 += v14;
        long long v18 = &v5[v14];
        if (!(_BYTE)v13)
        {
          if (v18 == v5) {
            long long v18 = v5 + 1;
          }
          if (!*(unsigned char *)(a3 + 36)) {
            return v18;
          }
          return v5;
        }
        while (*(unsigned __int8 *)v9++)
          ;
      }
      else
      {
        std::string::value_type v20 = *v5;
        if (a5) {
          std::string::value_type v20 = (*(uint64_t (**)(void, void))(**(void **)(*v10 + 8) + 40))(*(void *)(*v10 + 8), v20);
        }
        if (!v20) {
          goto LABEL_94;
        }
        ++v9;
      }
      ++v12;
    }
    while (v12 < *(_DWORD *)(a3 + 16));
  }
  std::string::value_type v21 = *v5;
  if (a5) {
    std::string::value_type v21 = (*(uint64_t (**)(void, void))(**(void **)(*v10 + 8) + 40))(*(void *)(*v10 + 8), v21);
  }
  if (!*(_DWORD *)(a3 + 20))
  {
    if (!*(_DWORD *)(a3 + 24)) {
      goto LABEL_90;
    }
    memset(&v40, 0, sizeof(v40));
    goto LABEL_64;
  }
  memset(&v40, 0, sizeof(v40));
  if ((*(unsigned char *)(a4 + 42) & 0x20) != 0)
  {
    std::string::value_type v38 = v21;
    std::string::value_type v39 = 0;
    sub_10010108C(*v10, &v37);
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v40.__r_.__value_.__l.__data_);
    }
    std::string v40 = v37;
  }
  else
  {
    std::string::assign(&v40, 1uLL, v21);
  }
  if (!*(_DWORD *)(a3 + 20))
  {
LABEL_64:
    if (!*(_DWORD *)(a3 + 24)) {
      goto LABEL_83;
    }
    std::string::value_type v38 = v21;
    std::string::value_type v39 = 0;
    sub_100101264(*v10, &v38, &v39, (uint64_t *)&v37);
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v40.__r_.__value_.__l.__data_);
    }
    std::string v40 = v37;
    if (!*(_DWORD *)(a3 + 24))
    {
LABEL_83:
      char v34 = 1;
      goto LABEL_86;
    }
    int v30 = 0;
    while (1)
    {
      if (!*v9)
      {
        if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          int v31 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
          if (HIBYTE(v40.__r_.__value_.__r.__words[2]) == 1)
          {
            uint64_t v32 = &v40;
            goto LABEL_77;
          }
          goto LABEL_78;
        }
        if (v40.__r_.__value_.__l.__size_ == 1)
        {
          uint64_t v32 = (std::string *)v40.__r_.__value_.__r.__words[0];
LABEL_77:
          int v31 = v32->__r_.__value_.__s.__data_[0];
LABEL_78:
          if (!v31) {
            goto LABEL_84;
          }
          goto LABEL_79;
        }
        if (!v40.__r_.__value_.__l.__size_) {
          goto LABEL_84;
        }
      }
LABEL_79:
      if (!std::string::compare(&v40, v9)) {
        goto LABEL_84;
      }
      ++v9;
      while (*(unsigned __int8 *)v9++)
        ;
      if (++v30 >= *(_DWORD *)(a3 + 24)) {
        goto LABEL_83;
      }
    }
  }
  int v22 = 0;
  while (1)
  {
    if (!*v9)
    {
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
      {
        if (!v40.__r_.__value_.__l.__size_) {
          goto LABEL_36;
        }
        if (v40.__r_.__value_.__l.__size_ != 1) {
          goto LABEL_35;
        }
        unint64_t v27 = (std::string *)v40.__r_.__value_.__r.__words[0];
        goto LABEL_52;
      }
      if (!*((unsigned char *)&v40.__r_.__value_.__s + 23)) {
        goto LABEL_36;
      }
      if (HIBYTE(v40.__r_.__value_.__r.__words[2]) == 1)
      {
        unint64_t v27 = &v40;
LABEL_52:
        if (!v27->__r_.__value_.__s.__data_[0]) {
          goto LABEL_36;
        }
      }
    }
LABEL_35:
    if (std::string::compare(&v40, v9) < 0)
    {
      int v23 = v9 + 1;
      while (*(unsigned __int8 *)v23++)
        ;
      goto LABEL_61;
    }
LABEL_36:
    int v23 = v9 + 1;
    while (*(unsigned __int8 *)v23++)
      ;
    if (*v23) {
      goto LABEL_60;
    }
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
    {
      if (v40.__r_.__value_.__l.__size_ != 1)
      {
        if (!v40.__r_.__value_.__l.__size_) {
          break;
        }
        goto LABEL_60;
      }
      uint64_t v26 = (std::string *)v40.__r_.__value_.__r.__words[0];
    }
    else
    {
      int v25 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
      if (HIBYTE(v40.__r_.__value_.__r.__words[2]) != 1) {
        goto LABEL_59;
      }
      uint64_t v26 = &v40;
    }
    int v25 = v26->__r_.__value_.__s.__data_[0];
LABEL_59:
    if (!v25) {
      break;
    }
LABEL_60:
    if (std::string::compare(&v40, v23) <= 0) {
      break;
    }
LABEL_61:
    unint64_t v9 = v23 + 1;
    while (*(unsigned __int8 *)v9++)
      ;
    if (++v22 >= *(_DWORD *)(a3 + 20)) {
      goto LABEL_64;
    }
  }
LABEL_84:
  char v34 = 0;
  if (!*(unsigned char *)(a3 + 36)) {
    ++v5;
  }
LABEL_86:
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v40.__r_.__value_.__l.__data_);
    if (v34) {
      goto LABEL_90;
    }
  }
  else
  {
    if ((v34 & 1) == 0) {
      return v5;
    }
LABEL_90:
    if (!sub_1000FE014((uint64_t)v10, v21, *(_DWORD *)(a3 + 28)))
    {
      int v35 = *(_DWORD *)(a3 + 32);
      if (!v35 || sub_1000FE014((uint64_t)v10, v21, v35))
      {
        v5 += *(unsigned __int8 *)(a3 + 36);
        return v5;
      }
    }
LABEL_94:
    if (!*(unsigned char *)(a3 + 36)) {
      ++v5;
    }
  }
  return v5;
}

void sub_100107490(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001074B4(__n128 *a1)
{
  unsigned __int32 v2 = a1[6].n128_u32[0];
  if ((v2 & 0x80) != 0 || (unint64_t v3 = a1[5].n128_u64[1], (a1[11].n128_u8[4] & *(unsigned char *)(*(void *)(v3 + 8) + 16)) == 0))
  {
    return sub_100107698(a1);
  }
  if (!*(unsigned char *)(v3 + 309))
  {
    uint64_t v4 = &a1[2].n128_u64[1];
    unint64_t v5 = a1[2].n128_u64[1];
    unint64_t v6 = (unsigned __int8 *)a1[2].n128_u64[0];
    unint64_t v11 = *(void *)(v3 + 288);
    if (v11 <= (unint64_t)&v6[-v5])
    {
      uint64_t v8 = (unsigned __int8 **)(v3 + 296);
      goto LABEL_26;
    }
LABEL_16:
    uint64_t result = 0;
    unint64_t *v4 = (unint64_t)v6;
    return result;
  }
  if ((v2 & 0x400) != 0)
  {
    uint64_t v4 = &a1[2].n128_u64[1];
    unint64_t v5 = a1[2].n128_u64[1];
    unint64_t v6 = (unsigned __int8 *)a1[2].n128_u64[0];
    uint64_t v7 = &v6[-v5];
    uint64_t v8 = (unsigned __int8 **)(v3 + 296);
    unint64_t v9 = (unint64_t *)(v3 + 288);
    if (a1[7].n128_u8[11]) {
      goto LABEL_12;
    }
    unint64_t v11 = *v9;
    if (*v9 <= (unint64_t)v7)
    {
LABEL_26:
      int v16 = (unsigned __int8 *)(v5 + v11);
      unint64_t *v4 = v5 + v11;
      if (v11 < (unint64_t)*v8)
      {
        unint64_t v17 = a1[13].n128_u64[1] - 32;
        if (v17 < a1[13].n128_u64[0])
        {
          sub_1001004C4(a1);
          unint64_t v17 = a1[13].n128_u64[1] - 32;
        }
        *(_DWORD *)unint64_t v17 = 9;
        *(void *)(v17 + 8) = v11;
        *(void *)(v17 + 16) = v3;
        *(void *)(v17 + 24) = v16;
        a1[13].n128_u64[1] = v17;
        unint64_t v6 = (unsigned __int8 *)a1[2].n128_u64[0];
        int v16 = (unsigned __int8 *)a1[2].n128_u64[1];
      }
      a1[5].n128_u64[1] = *(void *)(v3 + 16);
      if (v16 == v6) {
        unsigned int v18 = *(unsigned __int8 *)(v3 + 280);
      }
      else {
        unsigned int v18 = *(unsigned __int8 *)(v3 + *v16 + 24);
      }
      return (v18 >> 1) & 1;
    }
    goto LABEL_16;
  }
  uint64_t v4 = &a1[2].n128_u64[1];
  unint64_t v5 = a1[2].n128_u64[1];
  unint64_t v6 = (unsigned __int8 *)a1[2].n128_u64[0];
  uint64_t v7 = &v6[-v5];
  uint64_t v8 = (unsigned __int8 **)(v3 + 296);
  unint64_t v9 = (unint64_t *)(v3 + 288);
LABEL_12:
  if (*v8 >= v7) {
    unsigned int v12 = v7;
  }
  else {
    unsigned int v12 = *v8;
  }
  unint64_t v13 = *v9;
  if (*v9 > (unint64_t)v12) {
    goto LABEL_16;
  }
  unint64_t v14 = (unint64_t)&v12[v5];
  unint64_t *v4 = (unint64_t)&v12[v5];
  if (*(unsigned char *)(v3 + 308) && v12 < *v8) {
    a1[3].n128_u64[0] = v14;
  }
  if (v12 != (unsigned __int8 *)v13)
  {
    unint64_t v15 = a1[13].n128_u64[1] - 32;
    if (v15 < a1[13].n128_u64[0])
    {
      sub_1001004C4(a1);
      unint64_t v15 = a1[13].n128_u64[1] - 32;
    }
    *(_DWORD *)unint64_t v15 = 7;
    *(void *)(v15 + 8) = v12;
    *(void *)(v15 + 16) = v3;
    *(void *)(v15 + 24) = v14;
    a1[13].n128_u64[1] = v15;
  }
  a1[5].n128_u64[1] = *(void *)(v3 + 16);
  return 1;
}

uint64_t sub_100107698(__n128 *a1)
{
  unint64_t v2 = a1[5].n128_u64[1];
  unint64_t v3 = *(void *)(v2 + 8);
  if (*(void *)(v2 + 288))
  {
    unint64_t v4 = 0;
    while (1)
    {
      a1[5].n128_u64[1] = v3;
      uint64_t result = sub_100105720((uint64_t)a1);
      if (!result) {
        break;
      }
      if (++v4 >= *(void *)(v2 + 288)) {
        goto LABEL_7;
      }
    }
  }
  else
  {
    unint64_t v4 = 0;
LABEL_7:
    if (*(unsigned char *)(v2 + 309) && ((a1[6].n128_u8[1] & 4) == 0 || a1[7].n128_u8[11]))
    {
      while (v4 < *(void *)(v2 + 296))
      {
        a1[5].n128_u64[1] = v3;
        if (!sub_100105720((uint64_t)a1)) {
          break;
        }
        ++v4;
      }
      if (*(unsigned char *)(v2 + 308) && v4 < *(void *)(v2 + 296)) {
        a1[3].n128_u64[0] = a1[2].n128_u64[1];
      }
      if (v4 != *(void *)(v2 + 288))
      {
        unint64_t v10 = a1[2].n128_u64[1];
        unint64_t v11 = a1[13].n128_u64[1] - 32;
        if (v11 < a1[13].n128_u64[0])
        {
          sub_1001004C4(a1);
          unint64_t v11 = a1[13].n128_u64[1] - 32;
        }
        *(_DWORD *)unint64_t v11 = 7;
        *(void *)(v11 + 8) = v4;
        *(void *)(v11 + 16) = v2;
        *(void *)(v11 + 24) = v10;
        a1[13].n128_u64[1] = v11;
      }
      a1[5].n128_u64[1] = *(void *)(v2 + 16);
      return 1;
    }
    else
    {
      if (v4 < *(void *)(v2 + 296))
      {
        unint64_t v6 = a1[2].n128_u64[1];
        unint64_t v7 = a1[13].n128_u64[1] - 32;
        if (v7 < a1[13].n128_u64[0])
        {
          sub_1001004C4(a1);
          unint64_t v7 = a1[13].n128_u64[1] - 32;
        }
        *(_DWORD *)unint64_t v7 = 8;
        *(void *)(v7 + 8) = v4;
        *(void *)(v7 + 16) = v2;
        *(void *)(v7 + 24) = v6;
        a1[13].n128_u64[1] = v7;
      }
      a1[5].n128_u64[1] = *(void *)(v2 + 16);
      uint64_t v8 = (unsigned __int8 *)a1[2].n128_u64[1];
      if (v8 == (unsigned __int8 *)a1[2].n128_u64[0]) {
        unsigned int v9 = *(unsigned __int8 *)(v2 + 280);
      }
      else {
        unsigned int v9 = *(unsigned __int8 *)(v2 + *v8 + 24);
      }
      return (v9 >> 1) & 1;
    }
  }
  return result;
}

uint64_t sub_100107814(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0x6DB6DB6DB6DB6DB7 * ((v4 - *a1) >> 4) < a2)
  {
    if (a2 >= 0x24924924924924ALL) {
      sub_10002B5E0();
    }
    uint64_t v5 = a1[1] - *a1;
    void v7[4] = result;
    v7[0] = sub_100101A1C(result, a2);
    v7[1] = v7[0] + v5;
    _DWORD v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 112 * v6;
    sub_1001078D4(a1, v7);
    return sub_100101B1C((uint64_t)v7);
  }
  return result;
}

void sub_1001078C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100101B1C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1001078D4(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10010794C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10010794C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0;
    do
    {
      *(_OWORD *)(a7 + v11 - 112) = *(_OWORD *)(a3 + v11 - 112);
      sub_100106EFC(a7 + v11 - 96, a3 + v11 - 96);
      *(_OWORD *)(a7 + v11 - 16) = *(_OWORD *)(a3 + v11 - 16);
      v11 -= 112;
    }
    while (a3 + v11 != a5);
  }
  return a6;
}

void sub_1001079DC(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 + 16;
    do
    {
      sub_100104004(v4 + v2);
      v2 += 112;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100107A00(uint64_t *a1, _OWORD *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x249249249249249) {
    sub_10002B5E0();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x124924924924924) {
    unint64_t v9 = 0x249249249249249;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = sub_100101A1C(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  uint64_t v11 = &v10[7 * v4];
  v14[0] = v10;
  v14[1] = v11;
  unint64_t v15 = v11;
  int v16 = (char *)&v10[7 * v9];
  *uint64_t v11 = *a2;
  sub_100106EFC((uint64_t)(v11 + 1), (uint64_t)(a2 + 1));
  v10[7 * v4 + 6] = a2[6];
  v15 += 7;
  sub_1001078D4(a1, v14);
  uint64_t v12 = a1[1];
  sub_100101B1C((uint64_t)v14);
  return v12;
}

void sub_100107B28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100101B1C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100107B3C(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(int **)(a1 + 88);
  if (!v3) {
    return 1;
  }
  while (1)
  {
    int v7 = *v3;
    if (!*v3)
    {
      uint64_t v9 = v3[4];
      *(void *)(a1 + 88) = *((void *)v3 + 1);
      sub_100107B3C(a1, v9, 0);
      unint64_t v8 = *(int **)(a1 + 88);
      goto LABEL_12;
    }
    if (v7 == 1) {
      break;
    }
    if (v7 == 6) {
      return 1;
    }
LABEL_5:
    unint64_t v8 = (int *)*((void *)v3 + 1);
    *(void *)(a1 + 88) = v8;
LABEL_12:
    uint64_t v3 = v8;
    if (!v8) {
      return 1;
    }
  }
  if (v3[4] != a2)
  {
    sub_100105378((__n128 *)a1);
    unint64_t v8 = *(int **)(a1 + 88);
    if (v8) {
      goto LABEL_12;
    }
    *(_WORD *)(a1 + 228) = 1;
    *(unsigned char *)(a1 + 230) = 0;
    while ((((uint64_t (*)(uint64_t, void))off_1001BD928[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228)) & 1) != 0);
    unint64_t v8 = *(int **)(a1 + 88);
    if (v8) {
      goto LABEL_12;
    }
    goto LABEL_5;
  }
  if (!a3)
  {
    *(void *)(a1 + 88) = *((void *)v3 + 1);
    return 1;
  }

  return sub_100105378((__n128 *)a1);
}

uint64_t *sub_100107C60(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 76)) {
    sub_100107CE8();
  }

  return sub_100104B24((uint64_t *)a1, -2);
}

uint64_t *sub_100107CA4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 76)) {
    sub_100107CE8();
  }

  return sub_100104B24((uint64_t *)a1, -1);
}

void sub_100107CE8()
{
  std::logic_error::logic_error(&v0, "Attempt to access an uninitialized boost::match_results<> class.");
  sub_1001026F4(&v0);
}

void sub_100107D18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::logic_error a9)
{
}

unint64_t sub_100107D2C(uint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = a2;
  if (a3)
  {
    unint64_t v5 = a4;
    uint64_t v10 = a1[2];
    uint64_t v8 = (uint64_t)(a1 + 2);
    uint64_t v9 = v10;
    unint64_t v11 = *(void *)(v8 - 8);
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v11) >> 3) >= a3)
    {
      unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - a2) >> 3);
      unint64_t v20 = a3;
      if (a3 <= v19) {
        goto LABEL_15;
      }
      unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - a2) >> 3);
      unint64_t v21 = v11 + 24 * (a3 - v19);
      uint64_t v22 = *(void *)(v8 - 8);
      do
      {
        *(_OWORD *)uint64_t v22 = *(_OWORD *)a4;
        *(unsigned char *)(v22 + 16) = *(unsigned char *)(a4 + 16);
        v22 += 24;
      }
      while (v22 != v21);
      a1[1] = v21;
      if (v11 != a2)
      {
LABEL_15:
        sub_10010316C((uint64_t)a1, a2, v11, a2 + 24 * a3);
        if (v4 <= v5)
        {
          if (a1[1] <= v5) {
            unint64_t v23 = 0;
          }
          else {
            unint64_t v23 = a3;
          }
          v5 += 24 * v23;
        }
        unint64_t v24 = v4;
        do
        {
          *(void *)unint64_t v24 = *(void *)v5;
          *(void *)(v24 + 8) = *(void *)(v5 + 8);
          *(unsigned char *)(v24 + 16) = *(unsigned char *)(v5 + 16);
          v24 += 24;
          --v20;
        }
        while (v20);
      }
    }
    else
    {
      uint64_t v12 = *a1;
      unint64_t v13 = a3 - 0x5555555555555555 * ((uint64_t)(v11 - *a1) >> 3);
      if (v13 > 0xAAAAAAAAAAAAAAALL) {
        sub_10002B5E0();
      }
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v12) >> 3);
      unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v9 - v12) >> 3);
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v13) {
        uint64_t v16 = a3 - 0x5555555555555555 * ((uint64_t)(v11 - *a1) >> 3);
      }
      if (v15 >= 0x555555555555555) {
        unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v17 = v16;
      }
      uint64_t v32 = v8;
      if (v17) {
        unsigned int v18 = (char *)sub_100009078(v8, v17);
      }
      else {
        unsigned int v18 = 0;
      }
      int v25 = &v18[24 * v14];
      long long __p = v18;
      int v29 = v25;
      int v31 = &v18[24 * v17];
      uint64_t v26 = &v25[24 * a3];
      do
      {
        *(_OWORD *)int v25 = *(_OWORD *)v5;
        v25[16] = *(unsigned char *)(v5 + 16);
        v25 += 24;
      }
      while (v25 != v26);
      int v30 = v26;
      unint64_t v4 = sub_1001031F0(a1, &__p, v4);
      if (v30 != v29) {
        int v30 = &v29[(v30 - v29 - 24) % 0x18uLL];
      }
      if (__p) {
        operator delete(__p);
      }
    }
  }
  return v4;
}

void sub_100107F54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100107FA0(uint64_t a1)
{
  *(void *)(a1 + 88) = 0;
  return 0;
}

uint64_t sub_100107FAC(uint64_t a1, char a2)
{
  uint64_t v3 = *(void *)(a1 + 216);
  if ((a2 & 1) == 0)
  {
    sub_100100484(*(void **)(a1 + 16), *(void *)(v3 + 16), *(int *)(v3 + 8), *(_DWORD *)(v3 + 8) == 0);
    sub_1000FE320(*(_DWORD **)(a1 + 16), *(void *)(v3 + 24), *(int *)(v3 + 8), *(unsigned char *)(v3 + 32), *(_DWORD *)(v3 + 8) == 0);
  }
  *(void *)(a1 + 216) = v3 + 40;
  return 1;
}

uint64_t sub_100108014(uint64_t a1)
{
  *(void *)(a1 + 216) += 8;
  *(void *)(a1 + 88) = 0;
  return 0;
}

BOOL sub_10010802C(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 216);
  *(void *)(a1 + 88) = *(void *)(v2 + 8);
  *(void *)(a1 + 40) = *(void *)(v2 + 16);
  BOOL v3 = *(unsigned __int8 *)(v2 + 24) != a2;
  *(unsigned char *)(a1 + 228) = (*(unsigned char *)(v2 + 24) == 0) ^ a2;
  *(void *)(a1 + 216) = v2 + 32;
  *(unsigned char *)(a1 + 229) = 1;
  return v3;
}

uint64_t sub_100108074(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 216);
  if ((a2 & 1) == 0)
  {
    *(void *)(a1 + 88) = *(void *)(v2 + 8);
    *(void *)(a1 + 40) = *(void *)(v2 + 16);
  }
  *(void *)(a1 + 216) = v2 + 24;
  *(unsigned char *)(a1 + 230) = a2 ^ 1;
  return a2;
}

uint64_t sub_1001080A4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 216);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    **(void **)(v1 + 8) = v2;
  }
  *(void *)(a1 + 216) = v1 + 48;
  return 1;
}

uint64_t sub_1001080C8(uint64_t a1)
{
  ++*(_DWORD *)(a1 + 224);
  uint64_t v1 = *(void **)(a1 + 208);
  *(_OWORD *)(a1 + 208) = *(_OWORD *)(*(void *)(a1 + 216) + 8);
  uint64_t v2 = (char *)sub_10010056C();
  uint64_t v3 = 0;
  while (1)
  {
    unint64_t v4 = atomic_load((unint64_t *)&v2[v3]);
    if (!v4)
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)&v2[v3], &v4, (unint64_t)v1);
      if (!v4) {
        break;
      }
    }
    v3 += 8;
    if (v3 == 128)
    {
      operator delete(v1);
      return 1;
    }
  }
  return 1;
}

uint64_t sub_100108134(uint64_t a1, int a2)
{
  uint64_t v2 = *(void **)(a1 + 216);
  if (a2)
  {
    *(void *)(a1 + 216) = v2 + 4;
    return 1;
  }
  else
  {
    uint64_t v5 = v2[1];
    uint64_t v4 = v2[2];
    uint64_t v6 = *(void *)(v4 + 288);
    if ((*(unsigned char *)(a1 + 97) & 0x20) != 0 && *(void *)(a1 + 40) == *(void *)(a1 + 32)) {
      *(unsigned char *)(a1 + 121) = 1;
    }
    uint64_t v7 = v2[3];
    uint64_t v8 = v4 + 24;
    uint64_t v9 = *(void *)(a1 + 104) + 1;
    uint64_t v10 = (unsigned __int8 *)(v7 - 1);
    uint64_t v11 = v6 + 1;
    while (1)
    {
      *(void *)(a1 + 40) = v10;
      *(void *)(a1 + 104) = v9;
      if (v11 == v5) {
        break;
      }
      unsigned int v12 = *v10--;
      ++v9;
      --v7;
      --v5;
      if ((*(unsigned char *)(v8 + v12) & 2) != 0)
      {
        v2[1] = v5;
        v2[3] = v7;
        goto LABEL_12;
      }
    }
    *(void *)(a1 + 216) = v2 + 4;
    if ((*(unsigned char *)(v8 + *v10) & 2) == 0) {
      return 1;
    }
LABEL_12:
    uint64_t v3 = 0;
    *(void *)(a1 + 88) = *(void *)(v4 + 16);
  }
  return v3;
}

uint64_t sub_1001081E4(uint64_t a1, int a2)
{
  uint64_t v3 = *(void **)(a1 + 216);
  if (a2)
  {
    uint64_t v4 = (uint64_t)(v3 + 4);
LABEL_3:
    *(void *)(a1 + 216) = v4;
    return 1;
  }
  uint64_t v6 = v3[1];
  uint64_t v7 = v3[2];
  *(void *)(a1 + 88) = *(void *)(v7 + 8);
  uint64_t v8 = (unsigned __int8 *)v3[3];
  *(void *)(a1 + 40) = v8;
  if (*(unsigned __int8 **)(a1 + 32) == v8)
  {
LABEL_17:
    *(void *)(a1 + 216) += 32;
    if ((*(unsigned char *)(a1 + 97) & 0x20) != 0 && v8 != *(unsigned __int8 **)(a1 + 56)) {
      *(unsigned char *)(a1 + 121) = 1;
    }
    if ((*(unsigned char *)(v7 + 280) & 2) == 0) {
      return 1;
    }
  }
  else
  {
    uint64_t v9 = v7 + 24;
    unint64_t v10 = v6 + 1;
    do
    {
      unint64_t v11 = v10;
      if ((sub_100105720(a1) & 1) == 0)
      {
        uint64_t v4 = *(void *)(a1 + 216) + 32;
        goto LABEL_3;
      }
      ++*(void *)(a1 + 104);
      *(void *)(a1 + 88) = *(void *)(v7 + 8);
      uint64_t v8 = *(unsigned __int8 **)(a1 + 32);
      unsigned int v12 = *(unsigned __int8 **)(a1 + 40);
      if (v11 >= *(void *)(v7 + 296) || v12 == v8) {
        break;
      }
      unint64_t v10 = v11 + 1;
    }
    while ((*(unsigned char *)(v9 + *v12) & 2) == 0);
    if (v12 == v8) {
      goto LABEL_17;
    }
    if (*(void *)(v7 + 296) == v11)
    {
      *(void *)(a1 + 216) += 32;
      if ((*(unsigned char *)(v9 + *v12) & 2) == 0) {
        return 1;
      }
    }
    else
    {
      v3[1] = v11;
      v3[3] = v12;
    }
  }
  uint64_t result = 0;
  *(void *)(a1 + 88) = *(void *)(v7 + 16);
  return result;
}

uint64_t sub_100108320(uint64_t a1, int a2)
{
  uint64_t v2 = *(void **)(a1 + 216);
  if (!a2)
  {
    unint64_t v5 = v2[1];
    uint64_t v4 = v2[2];
    uint64_t v6 = (unsigned __int8 *)v2[3];
    *(void *)(a1 + 40) = v6;
    uint64_t v7 = *(unsigned __int8 **)(a1 + 32);
    if (v7 == v6)
    {
      unint64_t v13 = v6;
    }
    else
    {
      unint64_t v8 = *(void *)(v4 + 296);
      uint64_t v9 = *(void *)(a1 + 104) + 1;
      unint64_t v10 = v6 + 1;
      unint64_t v11 = v5 + 1;
      unsigned int v12 = v6 + 1;
      do
      {
        uint64_t v6 = v12;
        unint64_t v13 = v10;
        unint64_t v5 = v11;
        *(void *)(a1 + 40) = v10;
        *(void *)(a1 + 104) = v9;
        if (v11 >= v8) {
          break;
        }
        if (v10 == v7) {
          break;
        }
        ++v10;
        ++v9;
        ++v12;
        ++v11;
      }
      while ((*(unsigned char *)(v4 + 24 + *v13) & 2) == 0);
    }
    if (*(unsigned char *)(v4 + 308) && v5 < *(void *)(v4 + 296)) {
      *(void *)(a1 + 48) = v6;
    }
    if (v13 == v7)
    {
      *(void *)(a1 + 216) = v2 + 4;
      if ((*(unsigned char *)(a1 + 97) & 0x20) != 0 && v7 != *(unsigned __int8 **)(a1 + 56)) {
        *(unsigned char *)(a1 + 121) = 1;
      }
      if ((*(unsigned char *)(v4 + 280) & 2) == 0) {
        return 1;
      }
    }
    else if (v5 == *(void *)(v4 + 296))
    {
      *(void *)(a1 + 216) = v2 + 4;
      if ((*(unsigned char *)(v4 + *v13 + 24) & 2) == 0) {
        return 1;
      }
    }
    else
    {
      v2[1] = v5;
      v2[3] = v6;
    }
    uint64_t v3 = 0;
    *(void *)(a1 + 88) = *(void *)(v4 + 16);
    return v3;
  }
  *(void *)(a1 + 216) = v2 + 4;
  return 1;
}

uint64_t sub_100108448(uint64_t a1, int a2)
{
  uint64_t v3 = *(void **)(a1 + 216);
  if (a2)
  {
    uint64_t v4 = (uint64_t)(v3 + 4);
LABEL_3:
    *(void *)(a1 + 216) = v4;
    return 1;
  }
  unint64_t v7 = v3[1];
  uint64_t v6 = v3[2];
  uint64_t v8 = *(void *)(v6 + 8);
  *(void *)(a1 + 88) = v8;
  int v9 = *(unsigned __int8 *)(v8 + 24);
  unint64_t v10 = (unsigned char *)v3[3];
  *(void *)(a1 + 40) = v10;
  if (*(unsigned char **)(a1 + 32) != v10)
  {
    LOBYTE(v11) = *v10;
    unint64_t v12 = v7 + 1;
    while (1)
    {
      unint64_t v7 = v12;
      if (*(unsigned char *)(a1 + 120)) {
        LOBYTE(v11) = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), (char)v11);
      }
      if (v9 != v11) {
        break;
      }
      unint64_t v10 = (unsigned char *)(*(void *)(a1 + 40) + 1);
      *(void *)(a1 + 40) = v10;
      ++*(void *)(a1 + 104);
      *(void *)(a1 + 88) = *(void *)(v6 + 8);
      if (v7 < *(void *)(v6 + 296) && v10 != *(unsigned char **)(a1 + 32))
      {
        uint64_t v11 = *v10;
        unint64_t v12 = v7 + 1;
        if ((*(unsigned char *)(v6 + 24 + v11) & 2) == 0) {
          continue;
        }
      }
      goto LABEL_13;
    }
    uint64_t v4 = *(void *)(a1 + 216) + 32;
    goto LABEL_3;
  }
LABEL_13:
  if (*(unsigned char *)(v6 + 308) && v7 < *(void *)(v6 + 296)) {
    *(void *)(a1 + 48) = v10;
  }
  if (v10 == *(unsigned char **)(a1 + 32))
  {
    *(void *)(a1 + 216) += 32;
    if ((*(unsigned char *)(a1 + 97) & 0x20) != 0 && v10 != *(unsigned char **)(a1 + 56)) {
      *(unsigned char *)(a1 + 121) = 1;
    }
    if ((*(unsigned char *)(v6 + 280) & 2) == 0) {
      return 1;
    }
  }
  else if (v7 == *(void *)(v6 + 296))
  {
    *(void *)(a1 + 216) += 32;
    if ((*(unsigned char *)(v6 + *v10 + 24) & 2) == 0) {
      return 1;
    }
  }
  else
  {
    v3[1] = v7;
    v3[3] = v10;
  }
  uint64_t result = 0;
  *(void *)(a1 + 88) = *(void *)(v6 + 16);
  return result;
}

uint64_t sub_1001085F8(uint64_t a1, int a2)
{
  uint64_t v3 = *(void **)(a1 + 216);
  if (a2)
  {
    uint64_t v4 = (uint64_t)(v3 + 4);
LABEL_3:
    *(void *)(a1 + 216) = v4;
    return 1;
  }
  unint64_t v7 = v3[1];
  uint64_t v6 = v3[2];
  *(void *)(a1 + 88) = *(void *)(v6 + 8);
  uint64_t v8 = *(void *)(v6 + 8);
  int v9 = (unsigned char *)v3[3];
  *(void *)(a1 + 40) = v9;
  if (*(unsigned char **)(a1 + 32) != v9)
  {
    uint64_t v10 = v8 + 16;
    LOBYTE(v11) = *v9;
    unint64_t v12 = v7 + 1;
    while (1)
    {
      unint64_t v7 = v12;
      if (*(unsigned char *)(a1 + 120)) {
        LOBYTE(v11) = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 80) + 8) + 40))(*(void *)(**(void **)(a1 + 80) + 8), (char)v11);
      }
      if (!*(unsigned char *)(v10 + v11)) {
        break;
      }
      int v9 = (unsigned char *)(*(void *)(a1 + 40) + 1);
      *(void *)(a1 + 40) = v9;
      ++*(void *)(a1 + 104);
      *(void *)(a1 + 88) = *(void *)(v6 + 8);
      if (v7 < *(void *)(v6 + 296) && v9 != *(unsigned char **)(a1 + 32))
      {
        uint64_t v11 = *v9;
        unint64_t v12 = v7 + 1;
        if ((*(unsigned char *)(v6 + 24 + v11) & 2) == 0) {
          continue;
        }
      }
      goto LABEL_13;
    }
    uint64_t v4 = *(void *)(a1 + 216) + 32;
    goto LABEL_3;
  }
LABEL_13:
  if (*(unsigned char *)(v6 + 308) && v7 < *(void *)(v6 + 296)) {
    *(void *)(a1 + 48) = v9;
  }
  if (v9 == *(unsigned char **)(a1 + 32))
  {
    *(void *)(a1 + 216) += 32;
    if ((*(unsigned char *)(a1 + 97) & 0x20) != 0 && v9 != *(unsigned char **)(a1 + 56)) {
      *(unsigned char *)(a1 + 121) = 1;
    }
    if ((*(unsigned char *)(v6 + 280) & 2) == 0) {
      return 1;
    }
  }
  else if (v7 == *(void *)(v6 + 296))
  {
    *(void *)(a1 + 216) += 32;
    if ((*(unsigned char *)(v6 + *v9 + 24) & 2) == 0) {
      return 1;
    }
  }
  else
  {
    v3[1] = v7;
    v3[3] = v9;
  }
  uint64_t result = 0;
  *(void *)(a1 + 88) = *(void *)(v6 + 16);
  return result;
}

uint64_t sub_1001087B0(uint64_t a1, int a2)
{
  uint64_t v3 = *(void **)(a1 + 216);
  if (a2)
  {
    uint64_t v4 = (uint64_t)(v3 + 4);
LABEL_3:
    *(void *)(a1 + 216) = v4;
    return 1;
  }
  unint64_t v7 = v3[1];
  uint64_t v6 = v3[2];
  uint64_t v8 = *(void *)(v6 + 8);
  *(void *)(a1 + 88) = v8;
  int v9 = (std::string::value_type *)v3[3];
  *(void *)(a1 + 40) = v9;
  uint64_t v10 = *(std::string::value_type **)(a1 + 32);
  if (v10 != v9)
  {
    unint64_t v11 = v7 + 1;
    while (1)
    {
      unint64_t v7 = v11;
      unint64_t v12 = sub_100107028(v9, v10, v8, **(void **)(a1 + 72), *(unsigned __int8 *)(a1 + 120));
      unint64_t v13 = *(std::string::value_type **)(a1 + 40);
      if (v13 == v12) {
        break;
      }
      int v9 = v13 + 1;
      *(void *)(a1 + 40) = v13 + 1;
      ++*(void *)(a1 + 104);
      *(void *)(a1 + 88) = *(void *)(v6 + 8);
      if (v7 < *(void *)(v6 + 296))
      {
        uint64_t v10 = *(std::string::value_type **)(a1 + 32);
        if (v9 != v10)
        {
          unint64_t v11 = v7 + 1;
          if ((*(unsigned char *)(v6 + 24 + *v9) & 2) == 0) {
            continue;
          }
        }
      }
      goto LABEL_11;
    }
    uint64_t v4 = *(void *)(a1 + 216) + 32;
    goto LABEL_3;
  }
LABEL_11:
  if (*(unsigned char *)(v6 + 308) && v7 < *(void *)(v6 + 296)) {
    *(void *)(a1 + 48) = v9;
  }
  if (v9 == *(std::string::value_type **)(a1 + 32))
  {
    *(void *)(a1 + 216) += 32;
    if ((*(unsigned char *)(a1 + 97) & 0x20) != 0 && v9 != *(std::string::value_type **)(a1 + 56)) {
      *(unsigned char *)(a1 + 121) = 1;
    }
    if ((*(unsigned char *)(v6 + 280) & 2) == 0) {
      return 1;
    }
  }
  else if (v7 == *(void *)(v6 + 296))
  {
    *(void *)(a1 + 216) += 32;
    if ((*(unsigned char *)(v6 + *v9 + 24) & 2) == 0) {
      return 1;
    }
  }
  else
  {
    v3[1] = v7;
    v3[3] = v9;
  }
  uint64_t result = 0;
  *(void *)(a1 + 88) = *(void *)(v6 + 16);
  return result;
}

uint64_t sub_10010892C(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[27];
  if ((a2 & 1) == 0)
  {
    a1[5] = *(void *)(v2 + 16);
    a1[11] = *(void *)(v2 + 8);
    ++*(void *)(a1[16] + 24);
  }
  a1[27] = v2 + 24;
  return a2;
}

uint64_t sub_100108964(uint64_t *a1, char a2)
{
  uint64_t v3 = a1[27];
  if ((a2 & 1) == 0)
  {
    long long v11 = 0uLL;
    long long v10 = 0u;
    long long v8 = 0u;
    memset(v9, 0, sizeof(v9));
    BYTE12(v10) = 1;
    unint64_t v4 = a1[24];
    if (v4 >= a1[25])
    {
      uint64_t v5 = sub_100107A00(a1 + 23, &v8);
    }
    else
    {
      *(void *)unint64_t v4 = 0;
      *(void *)(v4 + 8) = 0;
      sub_100106EFC(v4 + 16, (uint64_t)v9);
      *(_OWORD *)(v4 + 96) = v11;
      uint64_t v5 = v4 + 112;
      a1[24] = v4 + 112;
    }
    a1[24] = v5;
    sub_100104004((uint64_t)v9);
    uint64_t v6 = a1[24];
    *(_DWORD *)(v6 - 112) = *(_DWORD *)(v3 + 8);
    *(void *)(v6 - 104) = *(void *)(v3 + 16);
    sub_100100624(v6 - 96, v3 + 104);
    *(void *)(a1[24] - 8) = a1[5];
    sub_100100624(a1[2], v3 + 24);
  }
  sub_100104004(v3 + 104);
  sub_100104004(v3 + 24);
  a1[27] = v3 + 184;
  return 1;
}

void sub_100108A5C(_Unwind_Exception *a1)
{
  sub_100104004(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100108A7C(uint64_t *a1, char a2)
{
  uint64_t v3 = a1[27];
  if ((a2 & 1) == 0)
  {
    uint64_t v4 = a1[24];
    if (a1[23] != v4)
    {
      sub_100100624(a1[2], v4 - 96);
      uint64_t v5 = a1[24];
      uint64_t v6 = v5 - 112;
      a1[5] = *(void *)(v5 - 8);
      sub_100104004(v5 - 96);
      a1[24] = v6;
    }
  }
  a1[27] = v3 + 8;
  return 1;
}

uint64_t sub_100108AEC(uint64_t a1, char a2)
{
  *(void *)(a1 + 216) += 8;
  while (1)
  {
    *(unsigned char *)(a1 + 228) = a2;
    *(_WORD *)(a1 + 229) = 0;
    while ((((uint64_t (*)(uint64_t, void))off_1001BD928[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228)) & 1) != 0);
    if (!*(void *)(a1 + 88)) {
      break;
    }
    if (*(unsigned char *)(a1 + 229))
    {
      *(unsigned char *)(a1 + 229) = 0;
      uint64_t v4 = (_DWORD *)(*(void *)(a1 + 216) - 8);
      if ((unint64_t)v4 < *(void *)(a1 + 208))
      {
        sub_1001004C4((__n128 *)a1);
        uint64_t v4 = (_DWORD *)(*(void *)(a1 + 216) - 8);
      }
      _DWORD *v4 = 16;
      *(void *)(a1 + 216) = v4;
      break;
    }
  }
  *(unsigned char *)(a1 + 123) = 0;
  return 0;
}

uint64_t sub_100108BA0(uint64_t a1, char a2)
{
  *(void *)(a1 + 216) += 8;
  *(unsigned char *)(a1 + 228) = a2;
  *(_WORD *)(a1 + 229) = 0;
  while ((((uint64_t (*)(uint64_t, void))off_1001BD928[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228)) & 1) != 0);
  while (*(void *)(a1 + 88))
  {
    int v4 = *(unsigned __int8 *)(a1 + 230);
    *(unsigned char *)(a1 + 228) = a2;
    *(_WORD *)(a1 + 229) = 0;
    if (v4)
    {
      while ((((uint64_t (*)(uint64_t, void))off_1001BD928[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228)) & 1) != 0);
      return 0;
    }
    while ((((uint64_t (*)(uint64_t, void))off_1001BD928[2 * **(unsigned int **)(a1 + 216)])(a1, *(unsigned __int8 *)(a1 + 228)) & 1) != 0);
  }
  return 0;
}

uint64_t sub_100108C74(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 216);
  *(unsigned char *)(a1 + 120) = *(unsigned char *)(v1 + 8);
  *(void *)(a1 + 216) = v1 + 16;
  return 1;
}

void sub_100108C90(void *a1)
{
  *a1 = 0;
  a1[1] = 0;
  sub_100108CF4(a1);
}

void sub_100108CDC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10000B678(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100108CF4(void *a1)
{
  if (*a1) {
    operator new();
  }
  operator new();
}

void sub_100108E4C()
{
}

void sub_100108E8C(uint64_t a1, const void *a2, uint64_t a3, unsigned int a4)
{
  sub_10010B818((uint64_t)v7, a1);
  long long v10 = 0u;
  memset(v11, 0, sizeof(v11));
  uint64_t v12 = 0xFFFFFFFFLL;
  int v16 = 0;
  int v17 = 0;
  unint64_t v19 = 0;
  uint64_t v20 = 0;
  long long __p = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  char v15 = 0;
  sub_10010B580((uint64_t)v7, a2, a3, a4);
  if (__p)
  {
    unint64_t v19 = __p;
    operator delete(__p);
  }
  if (v8)
  {
    int v9 = v8;
    operator delete(v8);
  }
}

void sub_100108F38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10010B7D4((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100108F4C(void *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  operator new();
}

void sub_100109004()
{
}

void *sub_100109044(void *a1)
{
  std::locale::locale(&v3);
  sub_100109198(&v4, &v3);
  sub_1001090C8(&v4, a1);
  std::locale::~locale(&v4);
  std::locale::~locale(&v3);
  return a1;
}

void sub_1001090A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, std::locale a11)
{
}

void sub_1001090C8(void *a1@<X0>, void *a2@<X8>)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1001D75F0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1001D75F0))
  {
    __cxa_atexit((void (*)(void *))&std::mutex::~mutex, &stru_1001D75B0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1001D75F0);
  }
  std::mutex::lock(&stru_1001D75B0);
  sub_1001092AC(a1, a2);

  std::mutex::unlock(&stru_1001D75B0);
}

void sub_100109180(_Unwind_Exception *a1)
{
}

std::locale *sub_100109198(std::locale *a1, const std::locale *a2)
{
  std::locale v4 = std::locale::locale(a1);
  sub_1001091F4(v4, a2, &v6);
  std::locale::~locale(&v6);
  return a1;
}

void sub_1001091E0(_Unwind_Exception *a1)
{
  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

std::locale::__imp *sub_1001091F4@<X0>(std::locale *a1@<X0>, const std::locale *a2@<X1>, std::locale *a3@<X8>)
{
  std::locale::locale(a3, a1);
  std::locale::operator=(a1, a2);
  a1[1].__locale_ = (std::locale::__imp *)std::locale::use_facet(a2, &std::ctype<char>::id);
  if (std::locale::has_facet(a2, &std::messages<char>::id)) {
    uint64_t v5 = (std::locale::__imp *)std::locale::use_facet(a2, &std::messages<char>::id);
  }
  else {
    uint64_t v5 = 0;
  }
  a1[2].__locale_ = v5;
  uint64_t result = (std::locale::__imp *)std::locale::use_facet(a2, &std::collate<char>::id);
  a1[3].__locale_ = result;
  return result;
}

void sub_100109298(_Unwind_Exception *a1)
{
  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

void sub_1001092AC(void *a1@<X0>, void *a2@<X8>)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1001D7628, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1001D7628))
  {
    off_1001D75F8 = &off_1001D75F8;
    off_1001D7600 = &off_1001D75F8;
    qword_1001D7620 = 0;
    qword_1001D7618 = 0;
    qword_1001D7608 = 0;
    qword_1001D7610 = &qword_1001D7618;
    __cxa_atexit((void (*)(void *))sub_100109610, &off_1001D75F8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1001D7628);
  }
  std::locale v4 = sub_1001096F8((uint64_t)&qword_1001D7610, a1);
  if (v4 == &qword_1001D7618) {
    operator new();
  }
  uint64_t v5 = off_1001D75F8;
  std::locale v6 = (std::locale *)v4[8];
  if (off_1001D75F8 != (_UNKNOWN *)v6)
  {
    unint64_t v7 = &v16;
    v16.__locale_ = (std::locale::__imp *)&v16;
    long long v17 = (unint64_t)&v16;
    if (&v16 == v6 || (long long v8 = (std::locale *)v6[1].__locale_, v8 == &v16))
    {
      uint64_t v11 = -1;
    }
    else
    {
      locale = v6->__locale_;
      *((void *)locale + 1) = v8;
      *(void *)v6[1].__locale_ = locale;
      long long v10 = v16.__locale_;
      *((void *)v16.__locale_ + 1) = v6;
      v6->__locale_ = v10;
      v6[1].__locale_ = (std::locale::__imp *)&v16;
      --qword_1001D7608;
      v16.__locale_ = (std::locale::__imp *)v6;
      *((void *)&v17 + 1) = 1;
      unint64_t v7 = (std::locale *)v17;
      if ((_UNKNOWN **)v17 == &off_1001D75F8)
      {
LABEL_12:
        v4[8] = (uint64_t)off_1001D75F8;
        sub_1001097BC((uint64_t *)&v16);
        uint64_t v5 = off_1001D75F8;
        goto LABEL_13;
      }
      uint64_t v11 = 0;
    }
    uint64_t v12 = v7[1].__locale_;
    if (v12 != (std::locale::__imp *)&off_1001D75F8)
    {
      uint64_t v13 = v7->__locale_;
      *((void *)v13 + 1) = v12;
      *(void *)v7[1].__locale_ = v13;
      uint64_t v14 = (std::locale::__imp *)off_1001D75F8;
      *((void *)off_1001D75F8 + 1) = v7;
      v7->__locale_ = v14;
      v7[1].__locale_ = (std::locale::__imp *)&off_1001D75F8;
      off_1001D75F8 = v7;
      *((void *)&v17 + 1) = v11;
      ++qword_1001D7608;
    }
    goto LABEL_12;
  }
LABEL_13:
  *a2 = v5[2];
  uint64_t v15 = v5[3];
  a2[1] = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_1001095B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  uint64_t v12 = *(std::__shared_weak_count **)(v10 + 8);
  if (v12) {
    sub_10000B678(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100109610(uint64_t a1)
{
  return a1;
}

uint64_t sub_100109648(uint64_t a1, uint64_t *__p)
{
  uint64_t v3 = *__p;
  uint64_t v4 = __p[1];
  *(void *)(v3 + 8) = v4;
  *(void *)__p[1] = v3;
  --*(void *)(a1 + 16);
  uint64_t v5 = (std::__shared_weak_count *)__p[3];
  if (v5) {
    sub_10000B678(v5);
  }
  operator delete(__p);
  return v4;
}

void sub_10010969C(uint64_t a1, std::locale *a2)
{
  if (a2)
  {
    sub_10010969C(a1, a2->__locale_);
    sub_10010969C(a1, a2[1].__locale_);
    std::locale::~locale(a2 + 4);
    operator delete(a2);
  }
}

void *sub_1001096F8(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)(a1 + 8);
  uint64_t result = sub_10010976C(a1, a2, *(void **)(a1 + 8), (void *)(a1 + 8));
  if (v3 != result)
  {
    unint64_t v5 = a2[1];
    unint64_t v6 = result[5];
    BOOL v7 = v5 >= v6;
    if (v5 == v6 && (v8 = a2[2], v9 = result[6], BOOL v7 = v8 >= v9, v8 == v9))
    {
      if (a2[3] >= result[7]) {
        return result;
      }
    }
    else if (v7)
    {
      return result;
    }
  }
  return v3;
}

void *sub_10010976C(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t result = a4;
  if (a3)
  {
    unint64_t v5 = a2[1];
    unint64_t v6 = a2[2];
    do
    {
      unint64_t v7 = a3[5];
      BOOL v8 = v7 >= v5;
      if (v7 == v5)
      {
        unint64_t v9 = a3[6];
        BOOL v8 = v9 >= v6;
        if (v9 == v6) {
          BOOL v8 = a3[7] >= a2[3];
        }
      }
      int v10 = !v8;
      BOOL v11 = v10 == 0;
      if (v10) {
        uint64_t v12 = a3 + 1;
      }
      else {
        uint64_t v12 = a3;
      }
      if (v11) {
        uint64_t result = a3;
      }
      a3 = (void *)*v12;
    }
    while (*v12);
  }
  return result;
}

void sub_1001097BC(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        unint64_t v5 = (uint64_t *)v3[1];
        unint64_t v6 = (std::__shared_weak_count *)v3[3];
        if (v6) {
          sub_10000B678(v6);
        }
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

std::locale *sub_100109834(std::locale *a1, uint64_t a2)
{
  uint64_t v3 = sub_1001098D4(a1, a2);
  v3[36].__locale_ = (std::locale::__imp *)&v3[37];
  v3[37].__locale_ = 0;
  v3[40].__locale_ = 0;
  v3[41].__locale_ = 0;
  v3[38].__locale_ = 0;
  v3[39].__locale_ = (std::locale::__imp *)&v3[40];
  v3[43].__locale_ = 0;
  v3[44].__locale_ = 0;
  v3[42].__locale_ = (std::locale::__imp *)&v3[43];
  sub_100109928((uint64_t)v3);
  return a1;
}

void sub_10010989C(_Unwind_Exception *a1)
{
  sub_100013D8C(v4, *(void **)(v1 + 344));
  sub_100013D28(v3, *(char **)(v1 + 320));
  sub_100058A90(v2, *(char **)(v1 + 296));
  std::locale::~locale((std::locale *)v1);
  _Unwind_Resume(a1);
}

std::locale *sub_1001098D4(std::locale *a1, uint64_t a2)
{
  uint64_t v4 = std::locale::locale(a1, (const std::locale *)a2);
  long long v5 = *(_OWORD *)(a2 + 8);
  v4[3].__locale_ = *(std::locale::__imp **)(a2 + 24);
  *(_OWORD *)&v4[1].__locale_ = v5;
  sub_100109D8C((uint64_t)v4);
  return a1;
}

void sub_100109914(_Unwind_Exception *a1)
{
  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

void sub_100109928(uint64_t a1)
{
  sub_10010A0E0((uint64_t)v25);
  unint64_t v2 = v26;
  if ((v26 & 0x80u) != 0) {
    unint64_t v2 = (unint64_t)v25[1];
  }
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (((*(uint64_t (**)(uint64_t, void **, uint64_t))(*(void *)v3 + 24))(v3, v25, a1) & 0x80000000) != 0)
      {
        sub_100018888(&v24, "Unable to open message catalog: ");
        sub_1000133D8((const void **)&v24.__r_.__value_.__l.__data_, (const void **)v25, (uint64_t)&__p);
        std::runtime_error::runtime_error((std::runtime_error *)&__str, &__p);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        sub_10010A248((const std::runtime_error *)&__str);
      }
      for (uint64_t i = 0; i != 22; ++i)
      {
        long long v5 = off_1001BD310[i];
        memset(&v24, 0, sizeof(v24));
        char v6 = *v5;
        if (*v5)
        {
          unint64_t v7 = (unsigned __int8 *)(v5 + 1);
          do
          {
            std::string::value_type v8 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8), v6);
            std::string::append(&v24, 1uLL, v8);
            int v9 = *v7++;
            char v6 = v9;
          }
          while (v9);
        }
        (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 16) + 32))(&__p);
        memset(&__str, 0, sizeof(__str));
        BOOL v10 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0;
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type size = __p.__r_.__value_.__l.__size_;
        }
        if (size)
        {
          std::string::size_type v12 = 0;
          do
          {
            if (v10) {
              p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            else {
              p_p = &__p;
            }
            std::string::value_type v14 = (*(uint64_t (**)(void, void, void))(**(void **)(a1 + 8) + 72))(*(void *)(a1 + 8), p_p->__r_.__value_.__s.__data_[v12], 0);
            std::string::append(&__str, 1uLL, v14);
            ++v12;
            BOOL v10 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0;
            std::string::size_type v15 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v15 = __p.__r_.__value_.__l.__size_;
            }
          }
          while (v12 < v15);
        }
        int v21 = i;
        unint64_t v27 = &v21;
        std::locale v16 = sub_10010ACE4((uint64_t **)(a1 + 288), &v21, (uint64_t)&unk_1001793E0, &v27);
        std::string::operator=((std::string *)(v16 + 5), &__str);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v24.__r_.__value_.__l.__data_);
        }
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1001D76B0, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1001D76B0))
      {
        qword_1001D7698 = 0;
        unk_1001D76A0 = 0;
        qword_1001D76A8 = 0;
        __cxa_atexit((void (*)(void *))&std::string::~string, &qword_1001D7698, (void *)&_mh_execute_header);
        __cxa_guard_release(&qword_1001D76B0);
      }
      for (uint64_t j = 0; j != 14; ++j)
      {
        (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 16) + 32))(&v24);
        std::string::size_type v18 = HIBYTE(v24.__r_.__value_.__r.__words[2]);
        char v19 = HIBYTE(v24.__r_.__value_.__r.__words[2]);
        if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v18 = v24.__r_.__value_.__l.__size_;
        }
        if (v18)
        {
          int v20 = dword_10017A680[j];
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v24;
          *((_DWORD *)sub_10010ADAC((uint64_t **)(a1 + 312), (const void **)&v24.__r_.__value_.__l.__data_, (uint64_t)&unk_1001793E0, (long long **)&__p)+ 14) = v20;
          char v19 = HIBYTE(v24.__r_.__value_.__r.__words[2]);
        }
        if (v19 < 0) {
          operator delete(v24.__r_.__value_.__l.__data_);
        }
      }
    }
  }
  *(_DWORD *)(a1 + 360) = sub_10010A95C(a1, (unsigned char *)(a1 + 364));
  if ((char)v26 < 0) {
    operator delete(v25[0]);
  }
}

void sub_100109D00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::runtime_error a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(a1);
}

void sub_100109D8C(uint64_t a1)
{
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  sub_10010A0E0((uint64_t)v26);
  unint64_t v2 = v27;
  if ((v27 & 0x80u) != 0) {
    unint64_t v2 = (unint64_t)v26[1];
  }
  if (v2 && (uint64_t v3 = *(void *)(a1 + 16)) != 0)
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t, void **, uint64_t))(*(void *)v3 + 24))(v3, v26, a1);
    if ((v4 & 0x80000000) != 0)
    {
      sub_100018888(v24, "Unable to open message catalog: ");
      sub_1000133D8(v24, (const void **)v26, (uint64_t)&__p);
      std::runtime_error::runtime_error(&v23, &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      sub_10010A248(&v23);
    }
    for (uint64_t i = 1; i != 60; ++i)
    {
      uint64_t v6 = *(void *)(a1 + 16);
      sub_100018888(&__p, *((char **)&off_1001BDB28 + i));
      (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, void, uint64_t, std::string *))(*(void *)v6 + 32))(v24, v6, v4, 0, i, &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      unint64_t v7 = 0;
      unint64_t v8 = v25;
      int v9 = (const void **)v24[0];
      BOOL v10 = v24[1];
      if ((v25 & 0x80) != 0)
      {
        while (1)
        {
          BOOL v11 = v9;
          if (v7 >= (unint64_t)v10) {
            break;
          }
LABEL_13:
          *(unsigned char *)(a1 + *((unsigned __int8 *)v11 + v7++) + 32) = i;
          if ((v8 & 0x80) == 0) {
            goto LABEL_10;
          }
        }
        operator delete(v9);
      }
      else
      {
LABEL_10:
        if (v7 < v8)
        {
          BOOL v11 = v24;
          goto LABEL_13;
        }
      }
    }
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 16) + 40))(*(void *)(a1 + 16), v4);
  }
  else
  {
    for (uint64_t j = 1; j != 60; ++j)
    {
      uint64_t v13 = (unsigned char *)*((void *)&off_1001BDB28 + j);
      unsigned int v14 = *v13;
      if (*v13)
      {
        std::string::size_type v15 = v13 + 1;
        do
        {
          *(unsigned char *)(a1 + v14 + 32) = j;
          unsigned int v16 = *v15++;
          unsigned int v14 = v16;
        }
        while (v16);
      }
    }
  }
  uint64_t v17 = 0;
  uint64_t v18 = a1 + 97;
  do
  {
    if (*(unsigned char *)(v18 + v17)) {
      BOOL v19 = 0;
    }
    else {
      BOOL v19 = (((_BYTE)v17 + 65) & 0x80) == 0;
    }
    if (v19)
    {
      int v20 = *(_DWORD *)(*(void *)(*(void *)(a1 + 8) + 16) + 4 * v17 + 260);
      if ((v20 & 0x1000) != 0)
      {
        char v21 = 22;
      }
      else
      {
        if ((v20 & 0x8000) == 0) {
          goto LABEL_34;
        }
        char v21 = 23;
      }
      *(unsigned char *)(v18 + v17) = v21;
    }
LABEL_34:
    ++v17;
  }
  while (v17 != 191);
  if ((char)v27 < 0) {
    operator delete(v26[0]);
  }
}

void sub_10010A010(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::runtime_error a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
}

void sub_10010A0BC()
{
}

void sub_10010A0E0(uint64_t a1@<X8>)
{
  unint64_t v2 = (std::mutex *)sub_10010A160();
  std::mutex::lock(v2);
  uint64_t v3 = sub_10010A1D0();
  if (*((char *)v3 + 23) < 0)
  {
    sub_1000173FC((unsigned char *)a1, (void *)*v3, v3[1]);
  }
  else
  {
    long long v4 = *(_OWORD *)v3;
    *(void *)(a1 + 16) = v3[2];
    *(_OWORD *)a1 = v4;
  }

  std::mutex::unlock(v2);
}

void sub_10010A14C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void *sub_10010A160()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1001D7670, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1001D7670))
  {
    __cxa_atexit((void (*)(void *))&std::mutex::~mutex, &unk_1001D7630, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1001D7670);
  }
  return &unk_1001D7630;
}

uint64_t *sub_10010A1D0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1001D7690, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1001D7690))
  {
    qword_1001D7678 = 0;
    unk_1001D7680 = 0;
    qword_1001D7688 = 0;
    __cxa_atexit((void (*)(void *))&std::string::~string, &qword_1001D7678, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1001D7690);
  }
  return &qword_1001D7678;
}

void sub_10010A248(const std::runtime_error *a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  sub_10010A2A4((uint64_t)exception, a1);
}

void sub_10010A290(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10010A2A4(uint64_t a1, const std::runtime_error *a2)
{
  *(void *)a1 = &off_1001BD040;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), a2);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = -1;
  *(void *)a1 = &off_1001BDAC0;
  *(void *)(a1 + 8) = off_1001BDAF0;
  *(void *)(a1 + 24) = off_1001BDB18;
  return a1;
}

uint64_t sub_10010A350(uint64_t a1)
{
  *(void *)(a1 + 24) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 32));
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));
  return a1;
}

void sub_10010A3A4()
{
}

void sub_10010A554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_1000FD4FC(&a9);
  sub_1000FD4FC(&a10);
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  _Unwind_Resume(a1);
}

void sub_10010A5CC(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  sub_10010A83C((uint64_t)exception, a1);
}

void sub_10010A614(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_10010A628(uint64_t a1)
{
  *(void *)(a1 + 24) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 32));
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));

  operator delete();
}

void sub_10010A69C(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 24));

  std::runtime_error::~runtime_error((std::runtime_error *)a1);
}

void sub_10010A6F8(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_1001BD070;
  sub_1000FD4FC((uint64_t *)(a1 + 24));
  std::runtime_error::~runtime_error((std::runtime_error *)a1);

  operator delete();
}

void sub_10010A770(void *a1)
{
  *a1 = &off_1001BD070;
  sub_1000FD4FC(a1 + 1);

  std::runtime_error::~runtime_error((std::runtime_error *)a1 - 1);
}

void sub_10010A7C8(void *a1)
{
  *a1 = &off_1001BD070;
  sub_1000FD4FC(a1 + 1);
  std::runtime_error::~runtime_error((std::runtime_error *)a1 - 1);

  operator delete();
}

uint64_t sub_10010A83C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_1001BD040;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), (const std::runtime_error *)(a2 + 8));
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = &off_1001BD070;
  *(void *)(a1 + 32) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v5;
  *(void *)a1 = &off_1001BDAC0;
  *(void *)(a1 + 8) = off_1001BDAF0;
  *(void *)(a1 + 24) = off_1001BDB18;
  return a1;
}

void sub_10010A948(_Unwind_Exception *a1)
{
  std::runtime_error::~runtime_error(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10010A95C(uint64_t a1, unsigned char *a2)
{
  strcpy(__s, "a");
  sub_10010108C(a1, &__s1);
  size_t v4 = strlen(__s);
  size_t v5 = v4;
  char v6 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
  if ((SHIBYTE(__s1.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v4 != HIBYTE(__s1.__r_.__value_.__r.__words[2])) {
      goto LABEL_9;
    }
    if (v4 != -1)
    {
      p_s1 = &__s1;
      goto LABEL_8;
    }
LABEL_93:
    sub_1000983B4();
  }
  if (v4 != __s1.__r_.__value_.__l.__size_) {
    goto LABEL_9;
  }
  if (v4 == -1) {
    goto LABEL_93;
  }
  p_s1 = (std::string *)__s1.__r_.__value_.__r.__words[0];
LABEL_8:
  if (memcmp(p_s1, __s, v5))
  {
LABEL_9:
    __int16 v39 = 65;
    sub_10010108C(a1, &v38);
    __int16 v37 = 59;
    sub_10010108C(a1, &__p);
    std::string::size_type size = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
    if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __s1.__r_.__value_.__l.__size_;
    }
    if ((size & 0x80000000) != 0)
    {
LABEL_39:
      LOBYTE(v15) = 0;
      uint64_t v18 = 3;
      goto LABEL_86;
    }
    uint64_t v9 = 0;
    int v10 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
    if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      int v10 = v38.__r_.__value_.__r.__words[1];
    }
    BOOL v11 = (std::string *)v38.__r_.__value_.__r.__words[0];
    if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      BOOL v11 = &v38;
    }
    if (v10 < 0) {
      int v10 = -1;
    }
    std::string::size_type v12 = &__s1;
    if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v12 = (std::string *)__s1.__r_.__value_.__r.__words[0];
    }
    uint64_t v13 = (v10 + 1);
    while (1)
    {
      if (v13 == v9) {
        goto LABEL_25;
      }
      if (v12->__r_.__value_.__s.__data_[v9] != v11->__r_.__value_.__s.__data_[v9]) {
        break;
      }
      if (size + 1 == ++v9)
      {
        LODWORD(v13) = size + 1;
LABEL_25:
        if (!v13) {
          goto LABEL_39;
        }
        goto LABEL_26;
      }
    }
    LODWORD(v13) = v9;
    if (!v9) {
      goto LABEL_39;
    }
LABEL_26:
    if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned int v14 = &__s1;
    }
    else {
      unsigned int v14 = (std::string *)__s1.__r_.__value_.__r.__words[0];
    }
    if (v13 == 1)
    {
      std::string::size_type v19 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
      std::string::size_type v20 = v38.__r_.__value_.__l.__size_;
      char v21 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
    }
    else
    {
      int v15 = v14->__r_.__value_.__s.__data_[(v13 - 1)];
      if (size)
      {
        uint64_t v16 = 0;
        int v17 = 0;
        do
        {
          if (v14->__r_.__value_.__s.__data_[v16] == v15) {
            ++v17;
          }
          ++v16;
        }
        while (size > v16);
      }
      else
      {
        int v17 = 0;
      }
      std::string::size_type v19 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
      char v21 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
      std::string::size_type v20 = v38.__r_.__value_.__l.__size_;
      if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v22 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v22 = v38.__r_.__value_.__l.__size_;
      }
      if (v22)
      {
        uint64_t v23 = 0;
        int v24 = 0;
        unsigned __int8 v25 = (std::string *)v38.__r_.__value_.__r.__words[0];
        if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unsigned __int8 v25 = &v38;
        }
        do
        {
          if (v25->__r_.__value_.__s.__data_[v23] == v15) {
            ++v24;
          }
          ++v23;
        }
        while (v22 > v23);
      }
      else
      {
        int v24 = 0;
      }
      if (v17 == v24)
      {
        if (size)
        {
          uint64_t v26 = 0;
          int v27 = 0;
          do
          {
            if (v14->__r_.__value_.__s.__data_[v26] == v15) {
              ++v27;
            }
            ++v26;
          }
          while (size > v26);
        }
        else
        {
          int v27 = 0;
        }
        std::string::size_type v28 = __p.__r_.__value_.__l.__size_;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v28 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        if (v28)
        {
          uint64_t v29 = 0;
          int v30 = 0;
          p_p = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          do
          {
            if (p_p->__r_.__value_.__s.__data_[v29] == v15) {
              ++v30;
            }
            ++v29;
          }
          while (v28 > v29);
        }
        else
        {
          int v30 = 0;
        }
        if (v27 == v30)
        {
          uint64_t v18 = 2;
          goto LABEL_86;
        }
      }
    }
    if (v21 >= 0) {
      std::string::size_type v32 = v19;
    }
    else {
      std::string::size_type v32 = v20;
    }
    uint64_t v18 = 3;
    if (size == v32)
    {
      std::string::size_type v33 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v33 = __p.__r_.__value_.__l.__size_;
      }
      BOOL v34 = size == v33;
      if (size == v33) {
        LOBYTE(v15) = v13;
      }
      else {
        LOBYTE(v15) = 0;
      }
      if (v34) {
        uint64_t v18 = 1;
      }
      else {
        uint64_t v18 = 3;
      }
    }
    else
    {
      LOBYTE(v15) = 0;
    }
LABEL_86:
    *a2 = v15;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v38.__r_.__value_.__l.__data_);
    }
    if ((*((unsigned char *)&__s1.__r_.__value_.__s + 23) & 0x80) != 0) {
      goto LABEL_91;
    }
    return v18;
  }
  uint64_t v18 = 0;
  *a2 = 0;
  if (v6 < 0) {
LABEL_91:
  }
    operator delete(__s1.__r_.__value_.__l.__data_);
  return v18;
}

void sub_10010ACB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **sub_10010ACE4(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = a1 + 1;
  char v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        char v6 = *v9;
        unint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      char v6 = v9[1];
      if (!v6)
      {
        unint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    BOOL v11 = operator new(0x40uLL);
    v11[8] = **a4;
    *((void *)v11 + 6) = 0;
    *((void *)v11 + 7) = 0;
    *((void *)v11 + 5) = 0;
    sub_10001716C(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t *sub_10010ADAC(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  char v6 = (uint64_t **)sub_10001893C((uint64_t)a1, &v9, a2);
  uint64_t result = *v6;
  if (!*v6)
  {
    sub_10010AE44((uint64_t)a1, a4, (uint64_t)&v8);
    sub_10001716C(a1, v9, v6, v8);
    return v8;
  }
  return result;
}

unsigned char *sub_10010AE44@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  char v6 = (char *)operator new(0x40uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = v6 + 32;
  int v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_1000173FC(result, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *(_OWORD *)uint64_t result = v9;
  }
  *((_DWORD *)v6 + 14) = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_10010AED0(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_10001FA40(v3, v2);
  _Unwind_Resume(a1);
}

void sub_10010AEEC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10010AF5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_10010B004((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10010AF80(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10010AFB8(uint64_t a1)
{
}

uint64_t sub_10010AFC0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10010B004(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_100013D8C(a2 + 336, *(void **)(a2 + 344));
    sub_100013D28(a2 + 312, *(char **)(a2 + 320));
    sub_100058A90(a2 + 288, *(char **)(a2 + 296));
    std::locale::~locale((std::locale *)a2);
    operator delete();
  }
}

char *sub_10010B078(uint64_t **a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void **)sub_10010B138((uint64_t)a1, &v12, a2);
  char v6 = (char *)*v5;
  if (!*v5)
  {
    unint64_t v7 = (uint64_t **)v5;
    char v6 = (char *)operator new(0x48uLL);
    v10[1] = a1 + 1;
    std::locale::locale((std::locale *)v6 + 4, (const std::locale *)a3);
    *(_OWORD *)(v6 + 40) = *(_OWORD *)(a3 + 8);
    uint64_t v8 = *(void *)(a3 + 32);
    *((void *)v6 + 7) = *(void *)(a3 + 24);
    *((void *)v6 + 8) = v8;
    char v11 = 1;
    sub_10001716C(a1, v12, v7, (uint64_t *)v6);
    v10[0] = 0;
    sub_10010B1C4((uint64_t)v10, 0);
  }
  return v6;
}

void *sub_10010B138(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5 = *(void **)(a1 + 8);
  uint64_t result = (void *)(a1 + 8);
  size_t v4 = v5;
  if (v5)
  {
    unint64_t v6 = a3[1];
    unint64_t v7 = a3[2];
    unint64_t v8 = a3[3];
    while (1)
    {
      while (1)
      {
        long long v9 = v4;
        unint64_t v10 = v4[5];
        if (v6 != v10) {
          break;
        }
        unint64_t v11 = v9[6];
        if (v7 == v11)
        {
          unint64_t v12 = v9[7];
          if (v8 >= v12)
          {
            if (v12 >= v8) {
              goto LABEL_18;
            }
            goto LABEL_15;
          }
        }
        else if (v7 >= v11)
        {
          if (v11 >= v7) {
            goto LABEL_18;
          }
          goto LABEL_15;
        }
LABEL_12:
        size_t v4 = (void *)*v9;
        uint64_t result = v9;
        if (!*v9) {
          goto LABEL_18;
        }
      }
      if (v6 < v10) {
        goto LABEL_12;
      }
      if (v10 >= v6) {
        goto LABEL_18;
      }
LABEL_15:
      uint64_t result = v9 + 1;
      size_t v4 = (void *)v9[1];
      if (!v4) {
        goto LABEL_18;
      }
    }
  }
  long long v9 = result;
LABEL_18:
  *a2 = v9;
  return result;
}

void sub_10010B1C4(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(std::locale **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::locale::~locale(v2 + 4);
    }
    operator delete(v2);
  }
}

uint64_t sub_10010B21C(uint64_t **a1, void *a2)
{
  uint64_t v3 = sub_1001096F8((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3) {
    return 0;
  }
  size_t v4 = (std::locale *)v3;
  sub_10002BA08(a1, v3);
  std::locale::~locale(v4 + 4);
  operator delete(v4);
  return 1;
}

void sub_10010B278(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10010B2E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_10010B390((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10010B30C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10010B344(uint64_t a1)
{
}

uint64_t sub_10010B34C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10010B390(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = *(std::__shared_weak_count **)(a2 + 8);
    if (v2) {
      sub_10000B678(v2);
    }
    operator delete();
  }
}

void sub_10010B3E8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10010B458(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_10010B500((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10010B47C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10010B4B4(uint64_t a1)
{
}

uint64_t sub_10010B4BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10010B500(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void **)(a2 + 376);
    if (v3)
    {
      *(void *)(a2 + 384) = v3;
      operator delete(v3);
    }
    operator delete(*(void **)(a2 + 352));
    size_t v4 = *(std::__shared_weak_count **)(a2 + 32);
    if (v4) {
      sub_10000B678(v4);
    }
    uint64_t v5 = *(void **)a2;
    if (*(void *)a2)
    {
      *(void *)(a2 + 8) = v5;
      operator delete(v5);
    }
    operator delete();
  }
}

void sub_10010B580(uint64_t a1, const void *a2, uint64_t a3, unsigned int a4)
{
  *(_DWORD *)(*(void *)a1 + 40) = a4;
  int v8 = (a4 >> 20) & 1;
  *(unsigned char *)(a1 + 24) = (a4 & 0x100000) != 0;
  *(void *)(a1 + 128) = a3;
  *(void *)(a1 + 136) = a2;
  *(void *)(a1 + 120) = a2;
  if (a2 == (const void *)a3 && (a4 & 0x1000003) != 0)
  {
    sub_10010C68C((std::string *)a1, 17, 0);
    return;
  }
  if ((a4 & 3) == 2)
  {
    uint64_t v10 = sub_10010CDF4;
LABEL_12:
    *(void *)(a1 + 104) = v10;
    *(void *)(a1 + 112) = 0;
    goto LABEL_13;
  }
  if ((a4 & 3) == 1)
  {
    uint64_t v10 = sub_10010CBE4;
    goto LABEL_12;
  }
  if ((a4 & 3) != 0)
  {
    sub_100018888(__p, "An invalid combination of regular expression syntax flags was used.");
    sub_10010CE64((std::string *)a1, 21, 0, (uint64_t)__p);
    goto LABEL_23;
  }
  *(void *)(a1 + 104) = sub_10010C718;
  *(void *)(a1 + 112) = 0;
  long long v9 = sub_10010CB60((uint64_t *)a1, 0, 0x18uLL);
  _OWORD v9[4] = 0;
  *((unsigned char *)v9 + 20) = (*(_DWORD *)(*(void *)a1 + 40) & 0x100000) != 0;
LABEL_13:
  BOOL v11 = sub_10010CF08(a1);
  sub_10010CFF0((std::string *)a1, -1);
  uint64_t v12 = *(void *)a1;
  *(_DWORD *)(*(void *)a1 + 40) = a4;
  if (v8 != *(unsigned __int8 *)(a1 + 24)) {
    *(unsigned char *)(a1 + 24) = v8;
  }
  if (v11)
  {
    if (!*(_DWORD *)(v12 + 44))
    {
      uint64_t v13 = *(unsigned int *)(a1 + 144);
      *(void *)(v12 + 64) = v13 + 1;
      if (*(_DWORD *)(a1 + 184) > v13)
      {
        uint64_t v14 = *(void *)(a1 + 136) - *(void *)(a1 + 120);
        sub_100018888(__p, "Found a backreference to a non-existant sub-expression.");
        sub_10010CE64((std::string *)a1, 6, v14, (uint64_t)__p);
        if (v17 < 0) {
          operator delete(__p[0]);
        }
      }
      sub_10010D150((uint64_t *)a1, a2, a3);
    }
    return;
  }
  uint64_t v15 = *(void *)(a1 + 136) - *(void *)(a1 + 120);
  sub_100018888(__p, "Found a closing) with no corresponding opening parenthesis.");
  sub_10010CE64((std::string *)a1, 8, v15, (uint64_t)__p);
LABEL_23:
  if (v17 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10010B7B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10010B7D4(void *a1)
{
  unint64_t v2 = (void *)a1[24];
  if (v2)
  {
    a1[25] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[7];
  if (v3)
  {
    a1[8] = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t sub_10010B818(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(uint64_t **)(a2 + 24);
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(unsigned char *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(void *)(a2 + 360) = *(void *)(a2 + 352);
  *(_DWORD *)(a2 + 44) = 0;
  *(_DWORD *)(a1 + 80) = sub_10010B930(*v3, "wslowerupperalpha", "slowerupperalpha");
  *(_DWORD *)(a1 + 84) = sub_10010B930(**(void **)(a1 + 8), "slowerupperalpha", "lowerupperalpha");
  *(_DWORD *)(a1 + 88) = sub_10010B930(**(void **)(a1 + 8), "lowerupperalpha", "upperalpha");
  *(_DWORD *)(a1 + 92) = sub_10010B930(**(void **)(a1 + 8), "upperalpha", "alpha");
  *(_DWORD *)(a1 + 96) = sub_10010B930(**(void **)(a1 + 8), "alpha", "");
  *(_DWORD *)(*(void *)a1 + 368) = *(_DWORD *)(a1 + 80);
  return a1;
}

void sub_10010B910(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v2;
  uint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 64) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010B930(uint64_t a1, char *a2, char *a3)
{
  uint64_t v6 = sub_10010BA2C(a1, a2, a3);
  if (!v6)
  {
    sub_10004E7CC(&__p, a2, a3, a3 - a2);
    uint64_t v7 = v14;
    if ((v14 & 0x80u) == 0) {
      p_p = (char *)&__p;
    }
    else {
      p_p = (char *)__p;
    }
    if ((v14 & 0x80u) != 0) {
      uint64_t v7 = v13;
    }
    (*(void (**)(void, char *, char *))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), p_p, &p_p[v7]);
    uint64_t v9 = v14;
    if ((v14 & 0x80u) == 0) {
      uint64_t v10 = (char *)&__p;
    }
    else {
      uint64_t v10 = (char *)__p;
    }
    if ((v14 & 0x80u) != 0) {
      uint64_t v9 = v13;
    }
    uint64_t v6 = sub_10010BA2C(a1, v10, &v10[v9]);
    if ((char)v14 < 0) {
      operator delete(__p);
    }
  }
  return v6;
}

void sub_10010BA0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010BA2C(uint64_t a1, char *a2, char *a3)
{
  if (!*(void *)(a1 + 328)) {
    goto LABEL_6;
  }
  uint64_t v6 = a1 + 312;
  sub_10004E7CC(__p, a2, a3, a3 - a2);
  uint64_t v7 = sub_100015244(v6, (const void **)__p);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  if (a1 + 320 == v7) {
LABEL_6:
  }
    int v8 = &aWslowerupperal[4 * (int)sub_10010BAF4(a2, a3) + 21];
  else {
    int v8 = (char *)(v7 + 56);
  }
  return *(unsigned int *)v8;
}

void sub_10010BAD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010BAF4(char *a1, char *a2)
{
  sub_100018888(&v68, "alnum");
  v70[0] = 0;
  long long v73 = v68;
  uint64_t v74 = v69;
  long long v68 = 0uLL;
  uint64_t v69 = 0;
  int v75 = 0;
  sub_100018888(&v65, "alpha");
  int v67 = 1;
  long long v76 = v65;
  uint64_t v77 = v66;
  long long v65 = 0uLL;
  uint64_t v66 = 0;
  int v78 = 1;
  sub_100018888(&v62, "blank");
  int v64 = 2;
  long long v79 = v62;
  uint64_t v80 = v63;
  long long v62 = 0uLL;
  uint64_t v63 = 0;
  int v81 = 2;
  sub_100018888(&v59, "cntrl");
  int v61 = 3;
  long long v82 = v59;
  uint64_t v83 = v60;
  long long v59 = 0uLL;
  uint64_t v60 = 0;
  int v84 = 3;
  sub_100018888(&v56, "d");
  int v58 = 4;
  long long v85 = v56;
  uint64_t v86 = v57;
  long long v56 = 0uLL;
  uint64_t v57 = 0;
  int v87 = 4;
  sub_100018888(&v53, "digit");
  int v55 = 5;
  long long v88 = v53;
  uint64_t v89 = v54;
  long long v53 = 0uLL;
  uint64_t v54 = 0;
  int v90 = 5;
  sub_100018888(&v50, "graph");
  int v52 = 6;
  long long v91 = v50;
  uint64_t v92 = v51;
  long long v50 = 0uLL;
  uint64_t v51 = 0;
  int v93 = 6;
  sub_100018888(&v47, "h");
  int v49 = 7;
  long long v94 = v47;
  uint64_t v95 = v48;
  long long v47 = 0uLL;
  uint64_t v48 = 0;
  int v96 = 7;
  sub_100018888(&v44, "l");
  int v46 = 8;
  long long v97 = v44;
  uint64_t v98 = v45;
  long long v44 = 0uLL;
  uint64_t v45 = 0;
  int v99 = 8;
  sub_100018888(&v41, "lower");
  int v43 = 9;
  long long v100 = v41;
  uint64_t v101 = v42;
  long long v41 = 0uLL;
  uint64_t v42 = 0;
  int v102 = 9;
  sub_100018888(&v38, "print");
  int v40 = 10;
  long long v103 = v38;
  uint64_t v104 = v39;
  long long v38 = 0uLL;
  uint64_t v39 = 0;
  int v105 = 10;
  sub_100018888(&v35, "punct");
  int v37 = 11;
  long long v106 = v35;
  uint64_t v107 = v36;
  long long v35 = 0uLL;
  uint64_t v36 = 0;
  int v108 = 11;
  sub_100018888(&v32, "s");
  int v34 = 12;
  long long v109 = v32;
  uint64_t v110 = v33;
  long long v32 = 0uLL;
  uint64_t v33 = 0;
  int v111 = 12;
  sub_100018888(&v29, "space");
  int v31 = 13;
  long long v112 = v29;
  uint64_t v113 = v30;
  long long v29 = 0uLL;
  uint64_t v30 = 0;
  int v114 = 13;
  sub_100018888(&v26, "u");
  int v28 = 14;
  long long v115 = v26;
  uint64_t v116 = v27;
  long long v26 = 0uLL;
  uint64_t v27 = 0;
  int v117 = 14;
  sub_100018888(&v23, "unicode");
  int v25 = 15;
  long long v118 = v23;
  uint64_t v119 = v24;
  long long v23 = 0uLL;
  uint64_t v24 = 0;
  int v120 = 15;
  sub_100018888(&v20, "upper");
  int v22 = 16;
  long long v121 = v20;
  uint64_t v122 = v21;
  long long v20 = 0uLL;
  uint64_t v21 = 0;
  int v123 = 16;
  sub_100018888(v17, "v");
  int v19 = 17;
  long long v124 = *(_OWORD *)v17;
  uint64_t v125 = v18;
  v17[0] = 0;
  v17[1] = 0;
  uint64_t v18 = 0;
  int v126 = 17;
  sub_100018888(v14, "w");
  int v16 = 18;
  long long v127 = *(_OWORD *)v14;
  uint64_t v128 = v15;
  v14[0] = 0;
  v14[1] = 0;
  uint64_t v15 = 0;
  int v129 = 18;
  sub_100018888(v11, "word");
  int v13 = 19;
  long long v130 = *(_OWORD *)v11;
  uint64_t v131 = v12;
  v11[0] = 0;
  v11[1] = 0;
  uint64_t v12 = 0;
  int v132 = 19;
  sub_100018888(__p, "xdigit");
  int v10 = 20;
  long long v133 = *(_OWORD *)__p;
  uint64_t v134 = v9;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v9 = 0;
  int v135 = 20;
  sub_10010C4E0((uint64_t)v71, (const void **)&v73, 21);
  unint64_t v4 = 672;
  do
  {
    if (SHIBYTE(v72[v4 / 8]) < 0) {
      operator delete(*(void **)&v70[v4 / 4]);
    }
    v4 -= 32;
  }
  while (v4);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[0]);
  }
  if (SHIBYTE(v21) < 0) {
    operator delete((void *)v20);
  }
  if (SHIBYTE(v24) < 0) {
    operator delete((void *)v23);
  }
  if (SHIBYTE(v27) < 0) {
    operator delete((void *)v26);
  }
  if (SHIBYTE(v30) < 0) {
    operator delete((void *)v29);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete((void *)v32);
  }
  if (SHIBYTE(v36) < 0) {
    operator delete((void *)v35);
  }
  if (SHIBYTE(v39) < 0) {
    operator delete((void *)v38);
  }
  if (SHIBYTE(v42) < 0) {
    operator delete((void *)v41);
  }
  if (SHIBYTE(v45) < 0) {
    operator delete((void *)v44);
  }
  if (SHIBYTE(v48) < 0) {
    operator delete((void *)v47);
  }
  if (SHIBYTE(v51) < 0) {
    operator delete((void *)v50);
  }
  if (SHIBYTE(v54) < 0) {
    operator delete((void *)v53);
  }
  if (SHIBYTE(v57) < 0) {
    operator delete((void *)v56);
  }
  if (SHIBYTE(v60) < 0) {
    operator delete((void *)v59);
  }
  if (SHIBYTE(v63) < 0) {
    operator delete((void *)v62);
  }
  if (SHIBYTE(v66) < 0) {
    operator delete((void *)v65);
  }
  if (SHIBYTE(v69) < 0) {
    operator delete((void *)v68);
  }
  sub_10004E7CC(&v73, a1, a2, a2 - a1);
  uint64_t v5 = sub_100015244((uint64_t)v71, (const void **)&v73);
  if (v72 == (char **)v5) {
    uint64_t v6 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v6 = *(unsigned int *)(v5 + 56);
  }
  if (SHIBYTE(v74) < 0) {
    operator delete((void *)v73);
  }
  sub_100013D28((uint64_t)v71, v72[0]);
  return v6;
}

void sub_10010C20C(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x2D7]) < 0) {
    operator delete(*v2);
  }
  sub_100013D28((uint64_t)&STACK[0x2A8], *(char **)(v1 + 552));
  _Unwind_Resume(a1);
}

void sub_10010C448()
{
}

void sub_10010C454()
{
}

void sub_10010C460()
{
}

void sub_10010C46C()
{
}

void sub_10010C478()
{
}

void sub_10010C484()
{
}

void sub_10010C490()
{
}

void sub_10010C49C()
{
}

void sub_10010C4A8()
{
}

void sub_10010C4B4()
{
}

void sub_10010C4C0()
{
}

void sub_10010C4CC()
{
}

void sub_10010C4D8()
{
}

uint64_t sub_10010C4E0(uint64_t a1, const void **a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  unint64_t v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 32 * a3;
    do
    {
      sub_10010C560((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 4;
      v6 -= 32;
    }
    while (v6);
  }
  return a1;
}

void sub_10010C548(_Unwind_Exception *a1)
{
  sub_100013D28(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_10010C560(uint64_t **a1, uint64_t *a2, const void **a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t **)sub_100016E38(a1, a2, &v10, &v9, a3);
  uint64_t result = *v6;
  if (!*v6)
  {
    sub_10010C5E4((uint64_t)a1, a4, (uint64_t)&v8);
    sub_10001716C(a1, (uint64_t)v10, v6, v8);
    return v8;
  }
  return result;
}

unsigned char *sub_10010C5E4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x40uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = v6 + 32;
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t result = sub_1000173FC(result, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t result = *(_OWORD *)a2;
    *((void *)v6 + 6) = *(void *)(a2 + 16);
  }
  *((_DWORD *)v6 + 14) = *(_DWORD *)(a2 + 24);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_10010C670(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_10001FA40(v3, v2);
  _Unwind_Resume(a1);
}

void sub_10010C68C(std::string *a1, int a2, uint64_t a3)
{
  sub_100101DD4(**(void ***)(a1->__r_.__value_.__r.__words[0] + 24), a2, (uint64_t)__p);
  sub_10010CE64(a1, a2, a3, (uint64_t)__p);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10010C6FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010C718(std::string *a1)
{
  unint64_t v2 = (unsigned __int8 *)a1[5].__r_.__value_.__r.__words[2];
  uint64_t v3 = 0;
  switch(*(unsigned char *)(*(void *)a1->__r_.__value_.__l.__size_ + *v2 + 32))
  {
    case 1:
      return sub_10010D2D0((uint64_t)a1);
    case 2:
      return v3;
    case 3:
      a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v2 + 1);
      BOOL v5 = (*(_DWORD *)(a1->__r_.__value_.__r.__words[0] + 40) & 0x400) == 0;
      int v6 = 12;
      int v7 = 4;
      goto LABEL_7;
    case 4:
      a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v2 + 1);
      BOOL v5 = (*(_DWORD *)(a1->__r_.__value_.__r.__words[0] + 40) & 0x400) == 0;
      int v6 = 11;
      int v7 = 3;
LABEL_7:
      if (v5) {
        int v8 = v7;
      }
      else {
        int v8 = v6;
      }
      sub_10010CB60((uint64_t *)a1, v8, 0x10uLL);
      return 1;
    case 5:
      a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v2 + 1);
      int v9 = *(_DWORD *)(a1->__r_.__value_.__r.__words[0] + 40);
      uint64_t v3 = 1;
      if ((v9 & 0x1000) != 0) {
        char v10 = 2;
      }
      else {
        char v10 = 1;
      }
      if ((v9 & 0x2000) != 0) {
        char v11 = 0;
      }
      else {
        char v11 = v10;
      }
      *((unsigned char *)sub_10010CB60((uint64_t *)a1, 5, 0x18uLL) + 16) = v11;
      return v3;
    case 6:
      if (v2 != (unsigned __int8 *)a1[5].__r_.__value_.__l.__data_)
      {
        a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v2 + 1);
        uint64_t v12 = 0;
        goto LABEL_23;
      }
      sub_100018888(__p, "The repeat operator \"*\" cannot start a regular expression.");
      sub_10010CE64(a1, 13, 0, (uint64_t)__p);
      goto LABEL_58;
    case 7:
      if (v2 == (unsigned __int8 *)a1[5].__r_.__value_.__l.__data_)
      {
        sub_100018888(__p, "The repeat operator \"+\" cannot start a regular expression.");
        sub_10010CE64(a1, 13, 0, (uint64_t)__p);
        goto LABEL_58;
      }
      a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v2 + 1);
      uint64_t v12 = 1;
LABEL_23:
      uint64_t v13 = -1;
      goto LABEL_26;
    case 8:
      if (v2 == (unsigned __int8 *)a1[5].__r_.__value_.__l.__data_)
      {
        sub_100018888(__p, "The repeat operator \"?\" cannot start a regular expression.");
        sub_10010CE64(a1, 13, 0, (uint64_t)__p);
LABEL_58:
        if (v22 < 0) {
          operator delete(__p[0]);
        }
        return 0;
      }
      a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v2 + 1);
      uint64_t v12 = 0;
      uint64_t v13 = 1;
LABEL_26:
      return sub_10010DFCC((uint64_t)a1, v12, v13);
    case 9:
      return sub_10010EC04((uint64_t)a1);
    case 0xB:
      goto LABEL_52;
    case 0xC:
      return sub_10010D62C((uint64_t)a1);
    case 0xD:
      if ((*(_DWORD *)(a1->__r_.__value_.__r.__words[0] + 40) & 0xA00) != 0x800) {
        goto LABEL_49;
      }
      std::string::size_type size = (unsigned __int8 *)a1[5].__r_.__value_.__l.__size_;
      uint64_t v3 = 1;
      break;
    case 0xF:
      a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v2 + 1);
      return sub_10010E44C((uint64_t)a1, 0);
    case 0x10:
      if ((*(unsigned char *)(a1->__r_.__value_.__r.__words[0] + 41) & 2) == 0) {
        goto LABEL_49;
      }
      uint64_t v20 = (uint64_t)&v2[-a1[5].__r_.__value_.__r.__words[0]];
      sub_100018888(__p, "Found a closing repetition operator } with no corresponding {.");
      sub_10010CE64(a1, 9, v20, (uint64_t)__p);
      goto LABEL_58;
    case 0x1A:
      if ((*(unsigned char *)(a1->__r_.__value_.__r.__words[0] + 42) & 2) == 0) {
        goto LABEL_49;
      }
LABEL_52:
      return sub_10010E9D4((uint64_t)a1);
    default:
LABEL_49:
      return sub_10010CDF4((uint64_t)a1);
  }
  while (v2 != size)
  {
    uint64_t v15 = v2 + 1;
    a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v2 + 1);
    unsigned int v16 = *v2;
    BOOL v17 = v16 > 0xD;
    int v18 = (1 << v16) & 0x3400;
    BOOL v19 = v17 || v18 == 0;
    unint64_t v2 = v15;
    if (!v19) {
      return v3;
    }
  }
  return 1;
}

void sub_10010CAD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

_DWORD *sub_10010CB60(uint64_t *a1, int a2, unint64_t a3)
{
  if (a2 == 13) {
    *((unsigned char *)a1 + 32) = 1;
  }
  uint64_t v5 = *a1;
  uint64_t v6 = *(void *)(*a1 + 352);
  unint64_t v7 = (*(void *)(*a1 + 360) - v6 + 7) & 0xFFFFFFFFFFFFFFF8;
  *(void *)(*a1 + 360) = v6 + v7;
  uint64_t v8 = a1[2];
  if (v8)
  {
    *(void *)(v8 + 8) = v7 - v8 + v6;
    uint64_t v5 = *a1;
  }
  uint64_t v9 = sub_1001131E0((uint64_t *)(v5 + 344), a3);
  a1[2] = v9;
  *(void *)(v9 + 8) = 0;
  uint64_t result = (_DWORD *)a1[2];
  *uint64_t result = a2;
  return result;
}

uint64_t sub_10010CBE4(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 136);
  switch(*(unsigned char *)(**(void **)(a1 + 8) + *v1 + 32))
  {
    case 3:
      *(void *)(a1 + 136) = v1 + 1;
      int v2 = 4;
      goto LABEL_9;
    case 4:
      *(void *)(a1 + 136) = v1 + 1;
      int v2 = 3;
LABEL_9:
      sub_10010CB60((uint64_t *)a1, v2, 0x10uLL);
      return 1;
    case 5:
      *(void *)(a1 + 136) = v1 + 1;
      int v4 = *(_DWORD *)(*(void *)a1 + 40);
      if ((v4 & 0x1000) != 0) {
        char v5 = 2;
      }
      else {
        char v5 = 1;
      }
      if ((v4 & 0x2000) != 0) {
        char v6 = 0;
      }
      else {
        char v6 = v5;
      }
      *((unsigned char *)sub_10010CB60((uint64_t *)a1, 5, 0x18uLL) + 16) = v6;
      return 1;
    case 6:
      unint64_t v7 = *(_DWORD **)(a1 + 16);
      if (!v7 || *v7 == 3) {
        goto LABEL_29;
      }
      *(void *)(a1 + 136) = v1 + 1;
      uint64_t v8 = 0;
      goto LABEL_25;
    case 7:
      uint64_t v9 = *(_DWORD **)(a1 + 16);
      if (!v9 || *v9 == 3 || (*(unsigned char *)(*(void *)a1 + 41) & 0x10) == 0) {
        goto LABEL_29;
      }
      *(void *)(a1 + 136) = v1 + 1;
      uint64_t v8 = 1;
LABEL_25:
      uint64_t v10 = -1;
      goto LABEL_39;
    case 8:
      char v11 = *(_DWORD **)(a1 + 16);
      if (!v11 || *v11 == 3 || (*(unsigned char *)(*(void *)a1 + 41) & 0x10) == 0) {
        goto LABEL_29;
      }
      *(void *)(a1 + 136) = v1 + 1;
      uint64_t v8 = 0;
      uint64_t v10 = 1;
LABEL_39:
      uint64_t result = sub_10010DFCC(a1, v8, v10);
      break;
    case 9:
      return sub_10010EC04(a1);
    case 0xA:
    case 0xB:
      goto LABEL_29;
    case 0xC:
      return sub_100114298((std::string *)a1);
    default:
      if (*(unsigned char *)(**(void **)(a1 + 8) + *v1 + 32) == 26 && (*(unsigned char *)(*(void *)a1 + 42) & 2) != 0)
      {
        uint64_t result = sub_10010E9D4(a1);
      }
      else
      {
LABEL_29:
        uint64_t result = sub_10010CDF4(a1);
      }
      break;
  }
  return result;
}

uint64_t sub_10010CDF4(uint64_t a1)
{
  if ((*(_DWORD *)(*(void *)a1 + 40) & 0xA03) != 0x800
    || !sub_1000FE014(*(void *)(a1 + 8), **(char **)(a1 + 136), *(_DWORD *)(a1 + 84)))
  {
    sub_10011165C((void *)a1, **(char **)(a1 + 136));
  }
  ++*(void *)(a1 + 136);
  return 1;
}

void sub_10010CE64(std::string *a1, int a2, uint64_t a3, uint64_t a4)
{
  if (*(char *)(a4 + 23) < 0) {
    sub_1000173FC(&__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else {
    std::string __p = *(std::string *)a4;
  }
  sub_100114DB8(a1, a2, a3, &__p, a3);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_10010CEEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10010CF08(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 180) + 1;
  *(_DWORD *)(a1 + 180) = v2;
  if (v2 >= 0x191)
  {
    uint64_t v3 = *(void *)(a1 + 136) - *(void *)(a1 + 120);
    sub_100018888(__p, "Exceeded nested brace limit.");
    sub_10010CE64((std::string *)a1, 18, v3, (uint64_t)__p);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  do
  {
    uint64_t v5 = *(void *)(a1 + 128);
    uint64_t v4 = *(void *)(a1 + 136);
    if (v4 == v5) {
      break;
    }
    char v6 = *(uint64_t (**)(void *))(a1 + 104);
    uint64_t v7 = *(void *)(a1 + 112);
    uint64_t v8 = (void *)(a1 + (v7 >> 1));
    if (v7) {
      char v6 = *(uint64_t (**)(void *))(*v8 + v6);
    }
  }
  while ((v6(v8) & 1) != 0);
  BOOL result = v4 == v5;
  --*(_DWORD *)(a1 + 180);
  return result;
}

void sub_10010CFD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010CFF0(std::string *a1, uint64_t a2)
{
  std::string::pointer data = a1[8].__r_.__value_.__l.__data_;
  std::string::size_type size = a1[8].__r_.__value_.__l.__size_;
  if (a1[7].__r_.__value_.__r.__words[0] != *(void *)(a1->__r_.__value_.__r.__words[0] + 360)
                                           - *(void *)(a1->__r_.__value_.__r.__words[0] + 352))
  {
LABEL_6:
    while (data != (std::string::pointer)size)
    {
      uint64_t v8 = *(void *)(size - 8);
      std::string::size_type v6 = size - 8;
      uint64_t v7 = v8;
      if (v8 <= a2) {
        break;
      }
      a1[8].__r_.__value_.__l.__size_ = v6;
      uint64_t v9 = *(void *)(a1->__r_.__value_.__r.__words[0] + 352);
      unint64_t v10 = (*(void *)(a1->__r_.__value_.__r.__words[0] + 360) - v9 + 7) & 0xFFFFFFFFFFFFFFF8;
      *(void *)(a1->__r_.__value_.__r.__words[0] + 360) = v9 + v10;
      if (*(_DWORD *)(v9 + v7) != 16)
      {
        uint64_t v12 = a1[5].__r_.__value_.__r.__words[2] - a1[5].__r_.__value_.__r.__words[0];
        sub_100018888(__p, "Internal logic failed while compiling the expression, probably you added a repeat to something non-repeatable!");
        sub_10010CE64(a1, 21, v12, (uint64_t)__p);
        goto LABEL_12;
      }
      *(void *)(v9 + v7 + 16) = v10 - v7;
      std::string::pointer data = a1[8].__r_.__value_.__l.__data_;
      std::string::size_type size = a1[8].__r_.__value_.__l.__size_;
    }
    return 1;
  }
  if (data == (std::string::pointer)size) {
    return 1;
  }
  if (*(void *)(size - 8) <= a2 || (*(_DWORD *)(a1->__r_.__value_.__r.__words[0] + 40) & 0x1000003) == 0) {
    goto LABEL_6;
  }
  uint64_t v5 = a1[5].__r_.__value_.__r.__words[2] - a1[5].__r_.__value_.__r.__words[0];
  sub_100018888(__p, "Can't terminate a sub-expression with an alternation operator |.");
  sub_10010CE64(a1, 17, v5, (uint64_t)__p);
LABEL_12:
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

void sub_10010D130(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_10010D150(uint64_t *result, const void *a2, uint64_t a3)
{
  if (!*(_DWORD *)(*result + 44))
  {
    uint64_t v5 = (uint64_t)result;
    sub_10010CB60(result, 6, 0x10uLL);
    uint64_t v6 = *(void *)v5;
    *(void *)(v6 + 56) = a3 - (void)a2;
    uint64_t v7 = (unsigned char *)sub_1001131E0((uint64_t *)(v6 + 344), a3 - (void)a2 + 1);
    uint64_t v8 = v7;
    *(void *)(*(void *)v5 + 48) = v7;
    size_t v9 = a3 - (void)a2;
    if (v9) {
      memmove(v7, a2, v9);
    }
    v8[v9] = 0;
    uint64_t v10 = *(void *)v5;
    *(_DWORD *)(v10 + 44) = 0;
    uint64_t v11 = *(void *)(v10 + 352);
    *(void *)(v10 + 72) = v11;
    sub_100114FA4(v5, v11);
    uint64_t v12 = *(void *)v5;
    if (*(unsigned char *)(v5 + 48))
    {
      *(unsigned char *)(v12 + 400) = 1;
      BOOL result = (uint64_t *)sub_10011508C(v5, *(int **)(v12 + 72));
      uint64_t v12 = *(void *)v5;
      if (*(_DWORD *)(*(void *)v5 + 44)) {
        return result;
      }
    }
    else
    {
      *(unsigned char *)(v12 + 400) = 0;
    }
    sub_1001152D0(v5, *(int **)(v12 + 72));
    uint64_t v13 = *(_OWORD **)v5;
    *(_OWORD *)((char *)v13 + 84) = 0u;
    uint64_t v13 = (_OWORD *)((char *)v13 + 84);
    v13[14] = 0u;
    v13[15] = 0u;
    v13[12] = 0u;
    v13[13] = 0u;
    v13[10] = 0u;
    v13[11] = 0u;
    unsigned char v13[8] = 0u;
    v13[9] = 0u;
    v13[6] = 0u;
    v13[7] = 0u;
    v13[4] = 0u;
    v13[5] = 0u;
    void v13[2] = 0u;
    v13[3] = 0u;
    v13[1] = 0u;
    uint64_t v14 = *(void *)v5;
    *(_DWORD *)(*(void *)v5 + 340) = 0;
    *(void *)(v5 + 40) = 0;
    if (*(unsigned char *)(v5 + 48))
    {
      unint64_t v15 = *(void *)(v14 + 64) + 1;
      char v18 = 0;
      sub_10011560C((char **)(v5 + 56), v15, &v18);
      uint64_t v14 = *(void *)v5;
    }
    sub_100115710(v5, *(void *)(v14 + 72), (char *)(v14 + 84), (_DWORD *)(v14 + 340), 3);
    int v16 = sub_10011604C(v5, *(void *)(*(void *)v5 + 72));
    uint64_t v17 = *(void *)v5;
    *(_DWORD *)(v17 + 80) = v16;
    return (uint64_t *)sub_1001160B4(v5, *(int **)(v17 + 72));
  }
  return result;
}

uint64_t sub_10010D2D0(uint64_t a1)
{
  unsigned int v2 = *(unsigned __int8 **)(a1 + 128);
  uint64_t v3 = (unsigned __int8 *)(*(void *)(a1 + 136) + 1);
  *(void *)(a1 + 136) = v3;
  if (v3 == v2)
  {
    uint64_t v14 = (uint64_t)&v3[-*(void *)(a1 + 120)];
    goto LABEL_17;
  }
  uint64_t v4 = *(void **)a1;
  int v5 = *(_DWORD *)(*(void *)a1 + 40);
  if ((v5 & 0x203) != 0 && (*(_DWORD *)(*(void *)a1 + 40) & 0x1003) != 4097)
  {
LABEL_12:
    if ((v5 & 0x400000) != 0)
    {
      int v9 = 0;
    }
    else
    {
      int v9 = *(_DWORD *)(a1 + 144) + 1;
      *(_DWORD *)(a1 + 144) = v9;
      if ((v5 & 0x800000) != 0)
      {
        uint64_t v10 = &v3[~*(void *)(a1 + 120)];
        uint64_t v12 = (char *)v4[48];
        unint64_t v11 = v4[49];
        if ((unint64_t)v12 >= v11)
        {
          int v16 = (char *)v4[47];
          uint64_t v17 = (v12 - v16) >> 4;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 60) {
            sub_10002B5E0();
          }
          uint64_t v19 = v11 - (void)v16;
          if (v19 >> 3 > v18) {
            unint64_t v18 = v19 >> 3;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v20 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            uint64_t v21 = (char *)sub_10001E498((uint64_t)(v4 + 49), v20);
            int v16 = (char *)v4[47];
            uint64_t v12 = (char *)v4[48];
          }
          else
          {
            uint64_t v21 = 0;
          }
          char v22 = (unsigned __int8 **)&v21[16 * v17];
          long long v23 = &v21[16 * v20];
          char *v22 = v10;
          v22[1] = 0;
          uint64_t v13 = v22 + 2;
          if (v12 != v16)
          {
            do
            {
              *((_OWORD *)v22 - 1) = *((_OWORD *)v12 - 1);
              v22 -= 2;
              v12 -= 16;
            }
            while (v12 != v16);
            int v16 = (char *)v4[47];
          }
          v4[47] = v22;
          v4[48] = v13;
          v4[49] = v23;
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *(void *)uint64_t v12 = v10;
          *((void *)v12 + 1) = 0;
          uint64_t v13 = v12 + 16;
        }
        v4[48] = v13;
      }
    }
    uint64_t v24 = sub_10010CB60((uint64_t *)a1, 0, 0x18uLL);
    v24[4] = v9;
    uint64_t v25 = *(void *)a1;
    unsigned int v26 = *(_DWORD *)(*(void *)a1 + 40);
    *((unsigned char *)v24 + 20) = (v26 & 0x100000) != 0;
    uint64_t v27 = *(void *)(v25 + 352);
    uint64_t v28 = (uint64_t)v24 - v27;
    uint64_t v29 = *(void *)(a1 + 168);
    unint64_t v30 = (*(void *)(v25 + 360) - v27 + 7) & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v25 + 360) = v27 + v30;
    *(void *)(a1 + 168) = v30;
    char v31 = *(unsigned char *)(a1 + 176);
    *(unsigned char *)(a1 + 176) = 0;
    int v32 = *(_DWORD *)(a1 + 148);
    *(_DWORD *)(a1 + 148) = -1;
    sub_10010CF08(a1);
    uint64_t v15 = 0;
    if (!sub_10010CFF0((std::string *)a1, v28)) {
      return v15;
    }
    if (*(unsigned char *)(a1 + 176)) {
      *((unsigned char *)sub_10010CB60((uint64_t *)a1, 28, 0x18uLL) + 16) = (v26 & 0x100000) != 0;
    }
    uint64_t v33 = *(void *)a1;
    *(_DWORD *)(*(void *)a1 + 40) = v26;
    if (((v26 >> 20) & 1) != *(unsigned char *)(a1 + 24)) {
      *(unsigned char *)(a1 + 24) = (v26 & 0x100000) != 0;
    }
    *(unsigned char *)(a1 + 176) = v31;
    *(_DWORD *)(a1 + 148) = v32;
    int v34 = *(unsigned __int8 **)(a1 + 136);
    if (v34 != *(unsigned __int8 **)(a1 + 128))
    {
      if (*(unsigned char *)(**(void **)(a1 + 8) + *v34 + 32) == 2)
      {
        if (v9 && (v26 & 0x800000) != 0)
        {
          unint64_t v35 = (v9 - 1);
          uint64_t v36 = *(void *)(v33 + 376);
          if (v35 >= (*(void *)(v33 + 384) - v36) >> 4) {
            sub_10009E508();
          }
          *(void *)(v36 + 16 * v35 + 8) = &v34[-*(void *)(a1 + 120)];
        }
        *(void *)(a1 + 136) = v34 + 1;
        uint64_t v15 = 1;
        int v37 = sub_10010CB60((uint64_t *)a1, 1, 0x18uLL);
        v37[4] = v9;
        *((unsigned char *)v37 + 20) = (*(_DWORD *)(*(void *)a1 + 40) & 0x100000) != 0;
        *(void *)(a1 + 160) = v28;
        *(void *)(a1 + 168) = v29;
        return v15;
      }
      return 0;
    }
    uint64_t v14 = (uint64_t)&v34[-*(void *)(a1 + 120)];
LABEL_17:
    sub_10010C68C((std::string *)a1, 8, v14);
    return 0;
  }
  int v7 = *(unsigned __int8 *)(**(void **)(a1 + 8) + *v3 + 32);
  if (v7 == 6)
  {
    return sub_1001105C0(a1);
  }
  else
  {
    if (v7 != 8) {
      goto LABEL_12;
    }
    return sub_10010EEDC(a1);
  }
}

uint64_t sub_10010D62C(uint64_t a1)
{
  unsigned int v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(char **)(a1 + 136);
  uint64_t v4 = v3 + 1;
  *(void *)(a1 + 136) = v3 + 1;
  if (v3 + 1 == v2)
  {
    uint64_t v10 = (uint64_t)&v4[-*(void *)(a1 + 120)];
    sub_100018888(&__p, "Incomplete escape sequence found.");
    sub_10010CE64((std::string *)a1, 5, v10, (uint64_t)&__p);
LABEL_7:
    if (SHIBYTE(v53) < 0) {
      operator delete(__p);
    }
    return 0;
  }
  int v5 = *(uint64_t **)(a1 + 8);
  uint64_t v6 = *v5;
  int v7 = 0;
  int v8 = 0;
  switch(*(unsigned char *)(*v5 + *v4 + 32))
  {
    case 0x11:
      return sub_100111E34(a1);
    case 0x12:
      *(void *)(a1 + 136) = v3 + 2;
      uint64_t v12 = (uint64_t *)a1;
      int v13 = 7;
      goto LABEL_34;
    case 0x13:
      *(void *)(a1 + 136) = v3 + 2;
      uint64_t v12 = (uint64_t *)a1;
      int v13 = 8;
      goto LABEL_34;
    case 0x14:
      *(void *)(a1 + 136) = v3 + 2;
      uint64_t v12 = (uint64_t *)a1;
      int v13 = 9;
      goto LABEL_34;
    case 0x15:
      *(void *)(a1 + 136) = v3 + 2;
      uint64_t v12 = (uint64_t *)a1;
      int v13 = 10;
      goto LABEL_34;
    case 0x16:
      goto LABEL_45;
    case 0x17:
      int v7 = 1;
      goto LABEL_45;
    case 0x18:
      *(void *)(a1 + 136) = v3 + 2;
      uint64_t v12 = (uint64_t *)a1;
      int v13 = 11;
      goto LABEL_34;
    case 0x19:
      *(void *)(a1 + 136) = v3 + 2;
      uint64_t v12 = (uint64_t *)a1;
      int v13 = 12;
      goto LABEL_34;
    case 0x21:
      if ((*(_WORD *)(*(void *)a1 + 40) & 0x203) == 0) {
        goto LABEL_44;
      }
      goto LABEL_50;
    case 0x30:
      return sub_100111F40(a1);
    case 0x31:
      *(void *)(a1 + 136) = v3 + 2;
      uint64_t v12 = (uint64_t *)a1;
      int v13 = 19;
      goto LABEL_34;
    case 0x32:
      *(void *)(a1 + 136) = v3 + 2;
      int v16 = *(_DWORD *)(*(void *)a1 + 40);
      BOOL v11 = 1;
      if ((v16 & 0x1000) != 0) {
        char v17 = 2;
      }
      else {
        char v17 = 1;
      }
      if ((v16 & 0x2000) != 0) {
        char v18 = 0;
      }
      else {
        char v18 = v17;
      }
      *((unsigned char *)sub_10010CB60((uint64_t *)a1, 5, 0x18uLL) + 16) = v18;
      return v11;
    case 0x33:
      *(void *)(a1 + 136) = v3 + 2;
      uint64_t v12 = (uint64_t *)a1;
      int v13 = 20;
      goto LABEL_34;
    case 0x34:
      *(void *)(a1 + 136) = v3 + 2;
      uint64_t v12 = (uint64_t *)a1;
      int v13 = 21;
LABEL_34:
      sub_10010CB60(v12, v13, 0x10uLL);
      return 1;
    case 0x36:
      goto LABEL_38;
    case 0x37:
      int v8 = 1;
LABEL_38:
      unint64_t v20 = v3 + 2;
      *(void *)(a1 + 136) = v3 + 2;
      if (v3 + 2 == v2)
      {
        uint64_t v26 = (uint64_t)&v2[-*(void *)(a1 + 120)];
        sub_100018888(&__p, "Incomplete property escape found.");
        sub_10010CE64((std::string *)a1, 5, v26, (uint64_t)&__p);
        goto LABEL_7;
      }
      if (*(unsigned char *)(v6 + *v20 + 32) == 15)
      {
        while (*(unsigned char *)(v6 + *v20 + 32) != 16)
        {
          *(void *)(a1 + 136) = ++v20;
          if (v20 == v2)
          {
            uint64_t v21 = (uint64_t)&v2[-*(void *)(a1 + 120)];
            sub_100018888(&__p, "Closing } missing from property escape sequence.");
            sub_10010CE64((std::string *)a1, 5, v21, (uint64_t)&__p);
            goto LABEL_7;
          }
        }
        *(void *)(a1 + 136) = v20 + 1;
        int v27 = sub_10010B930(v6, v3 + 3, v20);
      }
      else
      {
        int v27 = sub_10010B930(v6, v3 + 2, v3 + 3);
        ++*(void *)(a1 + 136);
      }
      if (!v27)
      {
        uint64_t v37 = *(void *)(a1 + 136) - *(void *)(a1 + 120);
        sub_100018888(&__p, "Escape sequence was neither a valid property nor a valid character class name.");
        sub_10010CE64((std::string *)a1, 4, v37, (uint64_t)&__p);
        goto LABEL_7;
      }
      std::string __p = &v52;
      int v52 = 0;
      uint64_t v53 = 0;
      uint64_t v54 = 0;
      int v55 = 0;
      uint64_t v56 = 0;
      long long v62 = 0;
      uint64_t v63 = 0;
      int v61 = &v62;
      __int16 v57 = 0;
      int v59 = 0;
      if (v8) {
        LOBYTE(v57) = 1;
      }
      int v58 = v27;
      char v60 = 0;
      uint64_t v36 = sub_1001115F8(a1, (uint64_t)&__p);
      BOOL v11 = v36 != 0;
      if (!v36) {
        sub_10010C68C((std::string *)a1, 4, *(void *)(a1 + 136) - *(void *)(a1 + 120));
      }
      sub_100111610((uint64_t)&__p);
      return v11;
    case 0x39:
      if ((*(_WORD *)(*(void *)a1 + 40) & 0x203) != 0) {
        goto LABEL_44;
      }
      uint64_t v28 = v3 + 2;
      *(void *)(a1 + 136) = v3 + 2;
      if (v3 + 2 == v2) {
        goto LABEL_102;
      }
      uint64_t v29 = *v28;
      unsigned int v30 = *(unsigned __int8 *)(v6 + v29 + 32);
      BOOL v31 = v30 == 20;
      if (v30 == 25) {
        BOOL v31 = 1;
      }
      char v32 = v30 == 15 || v31;
      if (v30 > 0x19 || ((1 << v30) & 0x2108000) == 0)
      {
        int v35 = 0;
      }
      else
      {
        uint64_t v28 = v3 + 3;
        *(void *)(a1 + 136) = v3 + 3;
        if (v3 + 3 == v2)
        {
LABEL_102:
          uint64_t v46 = (uint64_t)&v2[-*(void *)(a1 + 120)];
          sub_100018888(&__p, "Incomplete \\g escape found.");
          sub_10010CE64((std::string *)a1, 5, v46, (uint64_t)&__p);
          goto LABEL_7;
        }
        if (v30 == 20) {
          int v34 = 21;
        }
        else {
          int v34 = 25;
        }
        if (v30 == 15) {
          int v35 = 16;
        }
        else {
          int v35 = v34;
        }
        LODWORD(v29) = *v28;
      }
      if (v29 == 45)
      {
        *(void *)(a1 + 136) = ++v28;
        if (v28 == v2) {
          goto LABEL_102;
        }
      }
      long long v50 = (unsigned __int8 *)v28;
      uint64_t v38 = sub_100110C34((uint64_t)v5, &v50, v2, 10);
      char v39 = v32 ^ 1;
      if (v38 >= 0) {
        char v39 = 1;
      }
      if ((v39 & 1) == 0)
      {
        long long v41 = *(unsigned __int8 **)(a1 + 128);
        int v40 = *(char **)(a1 + 136);
        if (v40 == (char *)v41)
        {
          uint64_t v38 = 0x40000000;
        }
        else
        {
          uint64_t v42 = **(void **)(a1 + 8);
          int v43 = *(unsigned __int8 **)(a1 + 136);
          while (v35 != *(unsigned __int8 *)(v42 + *v43 + 32))
          {
            *(void *)(a1 + 136) = ++v43;
            if (v43 == v41)
            {
              int v43 = v41;
              break;
            }
          }
          if (v40 == (char *)v43)
          {
            uint64_t v38 = 0x40000000;
          }
          else
          {
            unint64_t v44 = 0;
            do
            {
              uint64_t v45 = *v40++;
              v44 ^= (v44 << 6) + (v44 >> 2) + 2654435769u + v45;
            }
            while (v40 != (char *)v43);
            uint64_t v38 = (v44 % 0x7FFFFFFF) | 0x40000000;
          }
          int v40 = (char *)v43;
        }
        long long v50 = (unsigned __int8 *)v40;
      }
      if (v29 == 45) {
        uint64_t v38 = *(unsigned int *)(a1 + 144) - v38 + 1;
      }
      if ((unint64_t)(v38 - 1) <= 0x3FFFFFFE
        || v38 >= 0x40000000 && (int)sub_10011207C(*(unsigned int ***)a1, v38) >= 1)
      {
        *(void *)(a1 + 136) = v50;
        long long v47 = sub_10010CB60((uint64_t *)a1, 13, 0x18uLL);
        v47[4] = v38;
        *((unsigned char *)v47 + 20) = (*(_DWORD *)(*(void *)a1 + 40) & 0x100000) != 0;
        if (v38 <= 0x3FFFFFFF && v38 > (unint64_t)*(unsigned int *)(a1 + 184)) {
          *(_DWORD *)(a1 + 184) = v38;
        }
        uint64_t v48 = v50;
        *(void *)(a1 + 136) = v50;
        BOOL v11 = 1;
        if (v30 > 0x19 || ((1 << v30) & 0x2108000) == 0) {
          return v11;
        }
        if (v48 != *(unsigned __int8 **)(a1 + 128) && v35 == *(unsigned __int8 *)(**(void **)(a1 + 8) + *v48 + 32))
        {
          *(void *)(a1 + 136) = v48 + 1;
          return v11;
        }
        uint64_t v49 = (uint64_t)&v48[-*(void *)(a1 + 120)];
        sub_100018888(&__p, "Incomplete \\g escape found.");
        sub_10010CE64((std::string *)a1, 5, v49, (uint64_t)&__p);
        goto LABEL_7;
      }
      sub_10010C68C((std::string *)a1, 6, *(void *)(a1 + 136) - *(void *)(a1 + 120));
      return 0;
    case 0x3A:
      if ((*(_WORD *)(*(void *)a1 + 40) & 0x203) != 0) {
        goto LABEL_44;
      }
      uint64_t v14 = sub_10010CB60((uint64_t *)a1, 0, 0x18uLL);
      v14[4] = -5;
      uint64_t v15 = *(unsigned int ***)a1;
      *((unsigned char *)v14 + 20) = (*(_DWORD *)(*(void *)a1 + 40) & 0x100000) != 0;
      v15[45] = (unsigned int *)((char *)v15[44] + (((char *)v15[45] - (char *)v15[44] + 7) & 0xFFFFFFFFFFFFFFF8));
      ++*(void *)(a1 + 136);
      return 1;
    case 0x3B:
      if ((*(_WORD *)(*(void *)a1 + 40) & 0x203) == 0)
      {
        uint64_t v19 = *(void *)(a1 + 120);
        *(void *)(a1 + 120) = &unk_10017ACAB;
        *(void *)(a1 + 128) = &unk_10017ACBF;
        *(void *)(a1 + 136) = &unk_10017ACAB;
        uint64_t result = sub_10010CF08(a1);
        *(void *)(a1 + 128) = v2;
        *(void *)(a1 + 136) = v3 + 2;
        *(void *)(a1 + 120) = v19;
        return result;
      }
LABEL_44:
      int v7 = 0;
LABEL_45:
      int v22 = sub_10010B930(v6, v4, v3 + 2);
      if (v22)
      {
        std::string __p = &v52;
        int v52 = 0;
        uint64_t v53 = 0;
        uint64_t v54 = 0;
        int v55 = 0;
        uint64_t v56 = 0;
        long long v62 = 0;
        uint64_t v63 = 0;
        int v61 = &v62;
        __int16 v57 = 0;
        int v59 = 0;
        if (v7) {
          LOBYTE(v57) = 1;
        }
        int v58 = v22;
        char v60 = 0;
        long long v23 = sub_100112A94(a1, (uint64_t)&__p);
        BOOL v11 = v23 != 0;
        uint64_t v24 = *(void *)(a1 + 136);
        if (v23) {
          *(void *)(a1 + 136) = v24 + 1;
        }
        else {
          sub_10010C68C((std::string *)a1, 4, v24 - *(void *)(a1 + 120));
        }
        sub_10004B7F8((uint64_t)&v61, v62);
        if (v54)
        {
          int v55 = v54;
          operator delete(v54);
        }
        sub_10004B7F8((uint64_t)&__p, v52);
      }
      else
      {
LABEL_50:
        uint64_t v25 = sub_100111780((std::string *)a1);
        sub_10011165C((void *)a1, v25);
        return 1;
      }
      return v11;
    default:
      goto LABEL_50;
  }
}

void sub_10010DED4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010DFCC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char **)(a1 + 128);
  uint64_t v6 = *(unsigned __int8 **)(a1 + 136);
  if (v6 == (unsigned __int8 *)v7
    || ((*(_DWORD *)(*(void *)a1 + 40) & 0x203) != 0
      ? (BOOL v8 = (*(_DWORD *)(*(void *)a1 + 40) & 0x1003) == 4097)
      : (BOOL v8 = 1),
        !v8))
  {
    int v10 = 0;
    BOOL v11 = 1;
    goto LABEL_23;
  }
  if ((*(_DWORD *)(*(void *)a1 + 40) & 0xA03) == 0x800)
  {
    while (1)
    {
      BOOL v9 = sub_1000FE014(*(void *)(a1 + 8), (char)*v6, *(_DWORD *)(a1 + 84));
      int v7 = *(char **)(a1 + 128);
      uint64_t v6 = *(unsigned __int8 **)(a1 + 136);
      if (!v9) {
        break;
      }
      *(void *)(a1 + 136) = ++v6;
      if (v6 == (unsigned __int8 *)v7) {
        goto LABEL_19;
      }
    }
  }
  if (v6 == (unsigned __int8 *)v7)
  {
LABEL_19:
    int v10 = 0;
    BOOL v11 = 1;
LABEL_22:
    uint64_t v6 = (unsigned __int8 *)v7;
    goto LABEL_23;
  }
  int v12 = *(unsigned __int8 *)(**(void **)(a1 + 8) + *v6 + 32);
  BOOL v11 = v12 != 8;
  if (v12 == 8) {
    *(void *)(a1 + 136) = ++v6;
  }
  if (v6 == (unsigned __int8 *)v7)
  {
    int v10 = 0;
    goto LABEL_22;
  }
  if ((*(unsigned char *)(*(void *)a1 + 40) & 3) != 0 || *(unsigned char *)(**(void **)(a1 + 8) + *v6 + 32) != 7)
  {
    int v10 = 0;
  }
  else
  {
    *(void *)(a1 + 136) = ++v6;
    int v10 = 1;
  }
LABEL_23:
  int v13 = *(_DWORD **)(a1 + 16);
  if (!v13)
  {
    uint64_t v16 = (uint64_t)&v6[-*(void *)(a1 + 120)];
    sub_100018888(__p, "Nothing to repeat.");
    sub_10010CE64((std::string *)a1, 13, v16, (uint64_t)__p);
    if (v43 < 0) {
      operator delete(__p[0]);
    }
    return 0;
  }
  int v14 = *v13;
  if (*v13 > 0x1Cu)
  {
LABEL_36:
    uint64_t v23 = (uint64_t)v13 - *(void *)(*(void *)a1 + 352);
    goto LABEL_38;
  }
  if (((1 << v14) & 0x14331F99) != 0)
  {
    uint64_t v15 = (uint64_t)&v6[-*(void *)(a1 + 120)];
LABEL_27:
    sub_10010C68C((std::string *)a1, 13, v15);
    return 0;
  }
  if (v14 != 1)
  {
    if (v14 == 2)
    {
      unsigned int v19 = v13[4];
      if (v19 >= 2)
      {
        uint64_t v20 = v19 - 1;
        char v21 = *((unsigned char *)v13 + v20 + 24);
        v13[4] = v20;
        int v22 = sub_10010CB60((uint64_t *)a1, 2, 0x19uLL);
        v22[4] = 1;
        *((unsigned char *)v22 + 24) = v21;
        uint64_t v23 = *(void *)(a1 + 16) - *(void *)(*(void *)a1 + 352);
        goto LABEL_38;
      }
    }
    goto LABEL_36;
  }
  uint64_t v23 = *(void *)(a1 + 160);
LABEL_38:
  uint64_t v24 = sub_100111224((void *)a1, v23, 18, 0x138uLL);
  *((void *)v24 + 36) = a2;
  *((void *)v24 + 37) = a3;
  v24[309] = v11;
  v24[308] = 0;
  uint64_t v25 = &v24[-*(void *)(*(void *)a1 + 352)];
  uint64_t v26 = sub_10010CB60((uint64_t *)a1, 16, 0x18uLL);
  *((void *)v26 + 2) = v25 - (char *)v26 + *(void *)(*(void *)a1 + 352);
  uint64_t v27 = *(void *)(*(void *)a1 + 352);
  unint64_t v28 = (*(void *)(*(void *)a1 + 360) - v27 + 7) & 0xFFFFFFFFFFFFFFF8;
  *(void *)(*(void *)a1 + 360) = v27 + v28;
  *(void *)&v25[v27 + 16] = v28 - (void)v25;
  if (!v10) {
    return 1;
  }
  unint64_t v29 = *(void *)(a1 + 128);
  unsigned int v30 = *(char **)(a1 + 136);
  if (v30 != (char *)v29)
  {
    while (1)
    {
LABEL_40:
      if ((*(_DWORD *)(*(void *)a1 + 40) & 0xA03) == 0x800)
      {
        while (v30 != (char *)v29)
        {
          BOOL v31 = sub_1000FE014(*(void *)(a1 + 8), *v30, *(_DWORD *)(a1 + 84));
          unint64_t v29 = *(void *)(a1 + 128);
          char v32 = *(unsigned __int8 **)(a1 + 136);
          if (!v31) {
            goto LABEL_45;
          }
          unsigned int v30 = (char *)(v32 + 1);
          *(void *)(a1 + 136) = v32 + 1;
        }
        goto LABEL_60;
      }
      char v32 = (unsigned __int8 *)v30;
LABEL_45:
      if (v32 == (unsigned __int8 *)v29) {
        goto LABEL_60;
      }
      uint64_t v33 = **(void **)(a1 + 8);
      unsigned int v34 = *(unsigned __int8 *)(v33 + *v32 + 32);
      if (v34 != 1) {
        break;
      }
      if ((unint64_t)(v32 + 2) >= v29
        || *(unsigned char *)(v33 + v32[1] + 32) != 8
        || *(unsigned char *)(v33 + v32[2] + 32) != 13)
      {
        goto LABEL_60;
      }
      while (v32 != (unsigned __int8 *)v29)
      {
        unsigned int v30 = (char *)(v32 + 1);
        *(void *)(a1 + 136) = v32 + 1;
        int v35 = *(unsigned __int8 *)(v33 + *v32++ + 32);
        if (v35 == 2) {
          goto LABEL_40;
        }
      }
      unsigned int v30 = (char *)v29;
    }
    if (v34 <= 0xF && ((1 << v34) & 0x81C0) != 0)
    {
      uint64_t v15 = (uint64_t)&v32[-*(void *)(a1 + 120)];
      goto LABEL_27;
    }
  }
LABEL_60:
  uint64_t v37 = sub_100111224((void *)a1, v23, 0, 0x18uLL);
  *((_DWORD *)v37 + 4) = -3;
  v37[20] = (*(_DWORD *)(*(void *)a1 + 40) & 0x100000) != 0;
  uint64_t v38 = sub_100111224((void *)a1, v23 + 24, 16, 0x18uLL);
  uint64_t v39 = *(void *)(*(void *)a1 + 352);
  unint64_t v40 = (*(void *)(*(void *)a1 + 360) - v39 + 7) & 0xFFFFFFFFFFFFFFF8;
  *(void *)(*(void *)a1 + 360) = v39 + v40;
  *((void *)v38 + 2) = v39 - (void)v38 + v40;
  uint64_t v17 = 1;
  long long v41 = sub_10010CB60((uint64_t *)a1, 1, 0x18uLL);
  v41[4] = -3;
  *((unsigned char *)v41 + 20) = (*(_DWORD *)(*(void *)a1 + 40) & 0x100000) != 0;
  return v17;
}

void sub_10010E430(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010E44C(uint64_t a1, int a2)
{
  uint64_t v4 = (void *)(a1 + 136);
  uint64_t v3 = *(char **)(a1 + 136);
  if (v3 == *(char **)(a1 + 128))
  {
    int v7 = *(char **)(a1 + 136);
  }
  else
  {
    while (1)
    {
      BOOL v6 = sub_1000FE014(*(void *)(a1 + 8), *v3, *(_DWORD *)(a1 + 84));
      int v7 = *(char **)(a1 + 128);
      BOOL v8 = *(char **)(a1 + 136);
      if (!v6) {
        break;
      }
      uint64_t v3 = v8 + 1;
      void *v4 = v3;
      if (v3 == v7) {
        goto LABEL_13;
      }
    }
    if (v8 != v7)
    {
      uint64_t v9 = sub_100110C34(*(void *)(a1 + 8), v4, v7, 10);
      if ((v9 & 0x8000000000000000) == 0)
      {
        int v10 = *(char **)(a1 + 136);
        if (v10 == *(char **)(a1 + 128))
        {
          int v13 = *(char **)(a1 + 136);
        }
        else
        {
          unint64_t v11 = v9;
          while (1)
          {
            BOOL v12 = sub_1000FE014(*(void *)(a1 + 8), *v10, *(_DWORD *)(a1 + 84));
            int v13 = *(char **)(a1 + 128);
            uint64_t i = *(char **)(a1 + 136);
            if (!v12) {
              break;
            }
            int v10 = i + 1;
            void *v4 = v10;
            if (v10 == v13) {
              goto LABEL_38;
            }
          }
          if (i != v13)
          {
            unint64_t v21 = v11;
            if (*(unsigned char *)(**(void **)(a1 + 8) + *i + 32) != 27) {
              goto LABEL_35;
            }
            while (1)
            {
              int v22 = *(char **)(a1 + 128);
              int v7 = (char *)(*(void *)(a1 + 136) + 1);
              *(void *)(a1 + 136) = v7;
              if (v7 == v22) {
                break;
              }
              if (!sub_1000FE014(*(void *)(a1 + 8), *v7, *(_DWORD *)(a1 + 84)))
              {
                int v7 = *(char **)(a1 + 128);
                if (*(char **)(a1 + 136) != v7)
                {
                  unint64_t v23 = sub_100110C34(*(void *)(a1 + 8), v4, v7, 10);
                  if (v23 >= 0x7FFFFFFFFFFFFFFFLL) {
                    unint64_t v21 = -1;
                  }
                  else {
                    unint64_t v21 = v23;
                  }
                  int v13 = *(char **)(a1 + 128);
                  for (i = *(char **)(a1 + 136); ; void *v4 = i)
                  {
LABEL_35:
                    if (i == v13) {
                      goto LABEL_57;
                    }
                    BOOL v24 = sub_1000FE014(*(void *)(a1 + 8), *i, *(_DWORD *)(a1 + 84));
                    int v13 = *(char **)(a1 + 128);
                    uint64_t v25 = *(unsigned __int8 **)(a1 + 136);
                    if (!v24) {
                      break;
                    }
                    uint64_t i = (char *)(v25 + 1);
                  }
                  if (v25 == (unsigned __int8 *)v13)
                  {
LABEL_57:
                    if ((*(_WORD *)(*(void *)a1 + 40) & 0x203) != 0) {
                      goto LABEL_39;
                    }
                    uint64_t v37 = **(void **)(a1 + 8);
                    uint64_t v38 = v13 - 1;
                    do
                    {
                      void *v4 = v38;
                      unsigned int v39 = *v38--;
                    }
                    while (*(unsigned char *)(v37 + v39 + 32) != 15);
                    goto LABEL_20;
                  }
                  uint64_t v33 = *(uint64_t **)(a1 + 8);
                  uint64_t v34 = *v33;
                  if (a2)
                  {
                    if (*(unsigned char *)(v34 + *v25 + 32) != 12)
                    {
                      uint64_t v45 = (uint64_t)&v25[-*(void *)(a1 + 120)];
                      sub_100018888(__p, "Missing } in quantified repetition.");
                      sub_10010CE64((std::string *)a1, 9, v45, (uint64_t)__p);
                      goto LABEL_15;
                    }
                    void *v4 = ++v25;
                    if (v25 == (unsigned __int8 *)v13) {
                      goto LABEL_39;
                    }
                  }
                  if (*(unsigned char *)(v34 + *v25 + 32) != 16)
                  {
                    char v43 = v25 - 1;
                    do
                    {
                      void *v4 = v43;
                      unsigned int v44 = *v43--;
                    }
                    while (*(unsigned char *)(v34 + v44 + 32) != 15);
                    goto LABEL_20;
                  }
                  void *v4 = v25 + 1;
                  if (v11 > v21)
                  {
                    *(void *)(a1 + 136) = v25 - 1;
                    if (sub_1000FE014((uint64_t)v33, (char)*(v25 - 1), *(_DWORD *)(a1 + 80)))
                    {
                      do
                      {
                        uint64_t v35 = *(void *)(a1 + 136);
                        *(void *)(a1 + 136) = v35 - 1;
                      }
                      while (sub_1000FE014(*(void *)(a1 + 8), *(char *)(v35 - 1), *(_DWORD *)(a1 + 80)));
                    }
                    uint64_t v36 = *(void *)(a1 + 136) + 1;
                    *(void *)(a1 + 136) = v36;
                    sub_10010C68C((std::string *)a1, 10, v36 - *(void *)(a1 + 120));
                    return 0;
                  }
                  return sub_10010DFCC(a1, v11, v21);
                }
                break;
              }
            }
            if ((*(_WORD *)(*(void *)a1 + 40) & 0x203) != 0) {
              goto LABEL_14;
            }
            uint64_t v40 = **(void **)(a1 + 8);
            long long v41 = v7 - 1;
            do
            {
              void *v4 = v41;
              unsigned int v42 = *v41--;
            }
            while (*(unsigned char *)(v40 + v42 + 32) != 15);
            goto LABEL_20;
          }
        }
LABEL_38:
        if ((*(_WORD *)(*(void *)a1 + 40) & 0x203) != 0)
        {
LABEL_39:
          uint64_t v26 = (uint64_t)&v13[-*(void *)(a1 + 120)];
          sub_100018888(__p, "Missing } in quantified repetition.");
          sub_10010CE64((std::string *)a1, 9, v26, (uint64_t)__p);
          goto LABEL_15;
        }
        uint64_t v27 = **(void **)(a1 + 8);
        unint64_t v28 = v13 - 1;
        do
        {
          void *v4 = v28;
          unsigned int v29 = *v28--;
        }
        while (*(unsigned char *)(v27 + v29 + 32) != 15);
LABEL_20:
        return sub_10010CDF4(a1);
      }
      if ((*(_WORD *)(*(void *)a1 + 40) & 0x203) == 0)
      {
        uint64_t v30 = **(void **)(a1 + 8);
        BOOL v31 = (unsigned __int8 *)(*(void *)(a1 + 136) - 1);
        do
        {
          void *v4 = v31;
          unsigned int v32 = *v31--;
        }
        while (*(unsigned char *)(v30 + v32 + 32) != 15);
        goto LABEL_20;
      }
      uint64_t v20 = *(void *)(a1 + 136) - *(void *)(a1 + 120);
      sub_100018888(__p, "Missing } in quantified repetition.");
      sub_10010CE64((std::string *)a1, 9, v20, (uint64_t)__p);
      goto LABEL_15;
    }
  }
LABEL_13:
  if ((*(_WORD *)(*(void *)a1 + 40) & 0x203) == 0)
  {
    uint64_t v17 = **(void **)(a1 + 8);
    char v18 = v7 - 1;
    do
    {
      void *v4 = v18;
      unsigned int v19 = *v18--;
    }
    while (*(unsigned char *)(v17 + v19 + 32) != 15);
    goto LABEL_20;
  }
LABEL_14:
  uint64_t v15 = (uint64_t)&v7[-*(void *)(a1 + 120)];
  sub_100018888(__p, "Missing } in quantified repetition.");
  sub_10010CE64((std::string *)a1, 9, v15, (uint64_t)__p);
LABEL_15:
  if (v47 < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

void sub_10010E9A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010E9D4(uint64_t a1)
{
  unsigned int v2 = *(_DWORD **)(a1 + 16);
  if (v2 && *v2 || (*(_DWORD *)(*(void *)a1 + 40) & 0x1000003) == 0)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 144);
    if (*(_DWORD *)(a1 + 152) < v5) {
      *(_DWORD *)(a1 + 152) = v5;
    }
    int v6 = *(_DWORD *)(a1 + 148);
    if ((v6 & 0x80000000) == 0) {
      *(_DWORD *)(a1 + 144) = v6;
    }
    ++*(void *)(a1 + 136);
    int v7 = (char *)sub_10010CB60((uint64_t *)a1, 16, 0x18uLL) - *(void *)(*(void *)a1 + 352);
    BOOL v8 = sub_100111224((void *)a1, *(void *)(a1 + 168), 17, 0x120uLL);
    uint64_t v9 = v7 + 288;
    uint64_t v10 = *(void *)(*(void *)a1 + 352);
    unint64_t v11 = (*(void *)(*(void *)a1 + 360) - v10 + 7) & 0xFFFFFFFFFFFFFFF8;
    *(void *)(*(void *)a1 + 360) = v10 + v11;
    *((void *)v8 + 2) = v10 - (void)v8 + v11;
    *(void *)(a1 + 168) = *(void *)(*(void *)a1 + 360) - *(void *)(*(void *)a1 + 352);
    if (*(unsigned char *)(a1 + 176))
    {
      char v12 = *(unsigned char *)(a1 + 24);
      *((unsigned char *)sub_10010CB60((uint64_t *)a1, 28, 0x18uLL) + 16) = v12;
    }
    unint64_t v13 = *(void *)(a1 + 208);
    int v14 = *(char **)(a1 + 200);
    if ((unint64_t)v14 >= v13)
    {
      uint64_t v16 = *(char **)(a1 + 192);
      uint64_t v17 = (v14 - v16) >> 3;
      if ((unint64_t)(v17 + 1) >> 61) {
        sub_10002B5E0();
      }
      unint64_t v18 = v13 - (void)v16;
      unint64_t v19 = (uint64_t)(v13 - (void)v16) >> 2;
      if (v19 <= v17 + 1) {
        unint64_t v19 = v17 + 1;
      }
      if (v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v19;
      }
      if (v20)
      {
        unint64_t v21 = (char *)sub_100038500(a1 + 208, v20);
        uint64_t v16 = *(char **)(a1 + 192);
        int v14 = *(char **)(a1 + 200);
      }
      else
      {
        unint64_t v21 = 0;
      }
      int v22 = (char **)&v21[8 * v17];
      unint64_t v23 = &v21[8 * v20];
      char *v22 = v9;
      uint64_t v15 = v22 + 1;
      while (v14 != v16)
      {
        BOOL v24 = (char *)*((void *)v14 - 1);
        v14 -= 8;
        *--int v22 = v24;
      }
      *(void *)(a1 + 192) = v22;
      *(void *)(a1 + 200) = v15;
      *(void *)(a1 + 208) = v23;
      if (v16) {
        operator delete(v16);
      }
    }
    else
    {
      *(void *)int v14 = v9;
      uint64_t v15 = v14 + 8;
    }
    *(void *)(a1 + 200) = v15;
    return 1;
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 136) - *(void *)(a1 + 120);
    sub_100018888(__p, "A regular expression cannot start with the alternation operator |.");
    sub_10010CE64((std::string *)a1, 17, v3, (uint64_t)__p);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
    return 0;
  }
}

void sub_10010EBE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010EC04(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 128);
  uint64_t v2 = *(void *)(a1 + 136);
  uint64_t v4 = (unsigned __int8 *)(v2 + 1);
  *(void *)(a1 + 136) = v2 + 1;
  if (v2 + 1 == v3)
  {
    uint64_t v15 = (uint64_t)&v4[-*(void *)(a1 + 120)];
    sub_100018888(&__p, "Character set declaration starting with [ terminated prematurely - either no ] was found or the set had no content.");
    sub_10010CE64((std::string *)a1, 7, v15, (uint64_t)&__p);
    if (SHIBYTE(v20) < 0) {
      operator delete(__p);
    }
    return 0;
  }
  std::string __p = &v19;
  unint64_t v19 = 0;
  uint64_t v20 = 0;
  unint64_t v21 = 0;
  int v22 = 0;
  uint64_t v23 = 0;
  v29[0] = 0;
  v29[1] = 0;
  unint64_t v28 = v29;
  __int16 v24 = 0;
  int v25 = 0;
  int v26 = 0;
  unsigned int v5 = (char *)(v2 + 2);
  int v6 = (unsigned __int8 *)(v2 + 1);
  int v7 = (unsigned __int8 *)(v2 + 1);
  char v27 = 1;
  while (2)
  {
    uint64_t v8 = **(void **)(a1 + 8);
    switch(*(unsigned char *)(v8 + *v6 + 32))
    {
      case 4:
        if (v6 != v4) {
          goto LABEL_19;
        }
        LOBYTE(v24) = 1;
        uint64_t v9 = v5;
        int v7 = (unsigned __int8 *)v5;
        goto LABEL_17;
      case 9:
        if (!sub_1001136B8((std::string *)a1, (uint64_t)&__p)) {
          goto LABEL_29;
        }
        goto LABEL_20;
      case 0xA:
        if (v6 == v7)
        {
          sub_100113568(a1, (uint64_t)&__p);
          int v7 = v6;
LABEL_20:
          int v6 = *(unsigned __int8 **)(a1 + 136);
          if (v6 == *(unsigned __int8 **)(a1 + 128)) {
            goto LABEL_21;
          }
          continue;
        }
        *(void *)(a1 + 136) = v6 + 1;
        if (HIBYTE(v24)) {
          uint64_t v16 = sub_1001120DC(a1, (uint64_t)&__p);
        }
        else {
          uint64_t v16 = (uint64_t)sub_100112A94(a1, (uint64_t)&__p);
        }
        if (v16)
        {
LABEL_29:
          uint64_t v14 = 1;
        }
        else
        {
          sub_10010C68C((std::string *)a1, 4, *(void *)(a1 + 136) - *(void *)(a1 + 120));
LABEL_21:
          uint64_t v14 = 0;
        }
        sub_10004B7F8((uint64_t)&v28, v29[0]);
        if (v21)
        {
          int v22 = v21;
          operator delete(v21);
        }
        sub_10004B7F8((uint64_t)&__p, v19);
        return v14;
      case 0xC:
        uint64_t v10 = (char *)(v6 + 1);
        *(void *)(a1 + 136) = v6 + 1;
        int v11 = *(unsigned __int8 *)(v8 + v6[1] + 32);
        if (v11 == 23)
        {
          int v13 = sub_10010B930(v8, v10, (char *)v6 + 2);
          uint64_t v10 = *(char **)(a1 + 136);
          if (v13)
          {
            v26 |= v13;
LABEL_16:
            char v27 = 0;
            uint64_t v9 = v10 + 1;
LABEL_17:
            *(void *)(a1 + 136) = v9;
            goto LABEL_20;
          }
        }
        else if (v11 == 22)
        {
          int v12 = sub_10010B930(v8, v10, (char *)v6 + 2);
          uint64_t v10 = *(char **)(a1 + 136);
          if (v12)
          {
            v25 |= v12;
            goto LABEL_16;
          }
        }
        *(void *)(a1 + 136) = v10 - 1;
LABEL_19:
        sub_100113568(a1, (uint64_t)&__p);
        goto LABEL_20;
      default:
        goto LABEL_19;
    }
  }
}

void sub_10010EE80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

uint64_t sub_10010EEDC(uint64_t a1)
{
  uint64_t v3 = (void *)(a1 + 136);
  uint64_t v2 = *(unsigned __int8 **)(a1 + 136);
  uint64_t v4 = v2 + 1;
  *(void *)(a1 + 136) = v2 + 1;
  unsigned int v5 = *(unsigned __int8 **)(a1 + 128);
  int v6 = *(uint64_t **)(a1 + 8);
  if (v2 + 1 == v5)
  {
    uint64_t v10 = *v6;
    do
    {
      void *v3 = v2;
      unsigned int v11 = *v2--;
      --v4;
    }
    while (*(unsigned char *)(v10 + v11 + 32) != 1);
    goto LABEL_8;
  }
  uint64_t v7 = *v6;
  if (*(unsigned char *)(*v6 + *v4 + 32) == 13)
  {
    do
    {
      if (v4 == v5) {
        break;
      }
      void *v3 = v4 + 1;
      int v8 = *(unsigned __int8 *)(v7 + *v4++ + 32);
    }
    while (v8 != 2);
    return 1;
  }
  uint64_t v15 = sub_10010CB60((uint64_t *)a1, 0, 0x18uLL);
  uint64_t v16 = *(void *)a1;
  unsigned int v17 = *(_DWORD *)(*(void *)a1 + 40);
  *((unsigned char *)v15 + 20) = (v17 & 0x100000) != 0;
  uint64_t v18 = *(void *)(a1 + 168);
  uint64_t v19 = *(void *)(v16 + 352);
  unint64_t v20 = (*(void *)(v16 + 360) - v19 + 7) & 0xFFFFFFFFFFFFFFF8;
  *(void *)(v16 + 360) = v19 + v20;
  *(void *)(a1 + 168) = v20;
  char v21 = *(unsigned char *)(a1 + 176);
  *(unsigned char *)(a1 + 176) = 0;
  uint64_t v22 = *(void *)(a1 + 148);
  int v23 = *(_DWORD *)(a1 + 144);
  *(_DWORD *)(a1 + 148) = -1;
  *(_DWORD *)(a1 + 152) = v23;
  __int16 v24 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = *(unsigned __int8 **)(a1 + 136);
  uint64_t v25 = *v4;
  uint64_t v26 = *v24;
  unsigned int v27 = *(unsigned __int8 *)(*v24 + v25 + 32);
  if (v27 > 0xA)
  {
    if (*(unsigned __int8 *)(*v24 + v25 + 32) <= 0x23u)
    {
      switch(*(unsigned char *)(*v24 + v25 + 32))
      {
        case 0xB:
          *(_DWORD *)(a1 + 148) = v23;
          goto LABEL_28;
        case 0xE:
          *(void *)(a1 + 136) = v4 + 1;
          uint64_t v35 = sub_100110C34((uint64_t)v24, v3, *(unsigned char **)(a1 + 128), 10);
          if (v35 <= 0)
          {
            --*v3;
            goto LABEL_79;
          }
          unint64_t v36 = *(unsigned int *)(a1 + 144) - v35;
          if (v36 < 0x7FFFFFFFFFFFFFFFLL)
          {
            int v227 = (v17 >> 20) & 1;
            unint64_t v43 = v36 + 1;
            goto LABEL_224;
          }
          uint64_t v37 = **(void **)(a1 + 8);
          uint64_t v30 = *(unsigned __int8 **)(a1 + 136);
          uint64_t v38 = v30 - 1;
          do
          {
            void *v3 = v38;
            unsigned int v39 = *v38--;
            --v30;
          }
          while (*(unsigned char *)(v37 + v39 + 32) != 1);
          goto LABEL_77;
        case 0x11:
          int v227 = (v17 >> 20) & 1;
          uint64_t v40 = sub_100110C34((uint64_t)v24, v3, *(unsigned char **)(a1 + 128), 10);
          uint64_t v41 = **(void **)(a1 + 8);
          unsigned int v42 = *(unsigned __int8 **)(a1 + 136);
          if ((v40 & 0x8000000000000000) == 0)
          {
            unint64_t v43 = v40;
            if (*(unsigned char *)(v41 + *v42 + 32) == 2) {
              goto LABEL_224;
            }
          }
          unsigned int v44 = v42 - 1;
          do
          {
            void *v3 = v44;
            unsigned int v45 = *v44--;
            --v42;
          }
          while (*(unsigned char *)(v41 + v45 + 32) != 1);
          uint64_t v46 = (uint64_t)&v42[-*(void *)(a1 + 120)];
          sub_100018888(__p, "The recursive sub-expression refers to an invalid marking group, or is unterminated.");
          sub_10010CE64((std::string *)a1, 20, v46, (uint64_t)__p);
          goto LABEL_252;
        case 0x14:
          char v47 = v4 + 1;
          *(void *)(a1 + 136) = v4 + 1;
          if (v4 + 1 == *(unsigned __int8 **)(a1 + 128))
          {
            do
            {
              void *v3 = v4;
              unsigned int v49 = *v4--;
              --v47;
            }
            while (*(unsigned char *)(v26 + v49 + 32) != 1);
            uint64_t v12 = (uint64_t)&v47[-*(void *)(a1 + 120)];
            goto LABEL_9;
          }
          int v48 = *(unsigned __int8 *)(v26 + *v47 + 32);
          if (v48 == 53)
          {
            char v226 = v21;
            int v227 = (v17 >> 20) & 1;
            uint64_t v32 = v18;
            signed int v33 = -2;
            goto LABEL_108;
          }
          if (v48 == 37)
          {
            char v226 = v21;
            int v227 = (v17 >> 20) & 1;
            uint64_t v32 = v18;
            signed int v33 = -1;
LABEL_108:
            v15[4] = v33;
            *(void *)(a1 + 136) = v4 + 2;
            uint64_t v34 = (char *)sub_10010CB60((uint64_t *)a1, 16, 0x18uLL) - *(void *)(*(void *)a1 + 352);
            sub_10010CB60((uint64_t *)a1, 26, 0x18uLL);
            uint64_t v65 = *(void *)a1;
            uint64_t v66 = *(void *)(*(void *)a1 + 352);
            uint64_t v67 = *(void *)(*(void *)a1 + 360);
            goto LABEL_64;
          }
          void *v3 = v4;
          LODWORD(v25) = 62;
LABEL_110:
          int v227 = (v17 >> 20) & 1;
          if ((v17 & 0x400000) != 0)
          {
            signed int v33 = 0;
          }
          else
          {
            signed int v33 = v23 + 1;
            *(_DWORD *)(a1 + 144) = v23 + 1;
            if ((v17 & 0x800000) != 0)
            {
              __p[0] = &v4[-*(void *)(a1 + 120) - 2];
              __p[1] = 0;
              sub_100110B44((void **)(v16 + 376), __p);
              uint64_t v4 = *(unsigned __int8 **)(a1 + 136);
            }
          }
          v15[4] = v33;
          uint64_t v98 = (char *)(v4 + 1);
          *(void *)(a1 + 136) = v4 + 1;
          int v99 = *(char **)(a1 + 128);
          if (v4 + 1 == (unsigned __int8 *)v99)
          {
            uint64_t v104 = **(void **)(a1 + 8);
            do
            {
              void *v3 = v4;
              unsigned int v105 = *v4--;
              --v98;
            }
            while (*(unsigned char *)(v104 + v105 + 32) != 1);
            uint64_t v12 = (uint64_t)&v98[-*(void *)(a1 + 120)];
            goto LABEL_9;
          }
          long long v100 = (char *)(v4 + 1);
          do
          {
            if (*v100 == v25)
            {
              char v226 = v21;
              uint64_t v32 = v18;
              sub_100110F00(*(void ***)a1, v98, v100, v33);
              uint64_t v34 = 0;
              ++*(void *)(a1 + 136);
              goto LABEL_225;
            }
            void *v3 = ++v100;
          }
          while (v100 != v99);
          uint64_t v101 = **(void **)(a1 + 8);
          int v102 = v99 - 1;
          do
          {
            void *v3 = v102;
            unsigned int v103 = *v102--;
            --v99;
          }
          while (*(unsigned char *)(v101 + v103 + 32) != 1);
          break;
        case 0x15:
          char v226 = v21;
          int v227 = (v17 >> 20) & 1;
          uint64_t v32 = v18;
          signed int v33 = -3;
          goto LABEL_63;
        case 0x19:
          goto LABEL_110;
        default:
          goto LABEL_68;
      }
LABEL_120:
      uint64_t v12 = (uint64_t)&v99[-*(void *)(a1 + 120)];
      goto LABEL_9;
    }
    switch(v27)
    {
      case '$':
LABEL_28:
        char v226 = v21;
        int v227 = (v17 >> 20) & 1;
        uint64_t v32 = v18;
        uint64_t v34 = 0;
        signed int v33 = 0;
        v15[4] = 0;
        void *v3 = v4 + 1;
        goto LABEL_225;
      case '%':
        char v226 = v21;
        int v227 = (v17 >> 20) & 1;
        uint64_t v32 = v18;
        signed int v33 = -1;
LABEL_63:
        v15[4] = v33;
        *(void *)(a1 + 136) = v4 + 1;
        int v64 = sub_10010CB60((uint64_t *)a1, 16, 0x18uLL);
        uint64_t v65 = *(void *)a1;
        uint64_t v66 = *(void *)(*(void *)a1 + 352);
        uint64_t v67 = *(void *)(*(void *)a1 + 360);
        uint64_t v34 = (char *)v64 - v66;
LABEL_64:
        unint64_t v68 = (v67 - v66 + 7) & 0xFFFFFFFFFFFFFFF8;
        *(void *)(v65 + 360) = v66 + v68;
        *(void *)(a1 + 168) = v68;
        goto LABEL_225;
      case '5':
        char v226 = v21;
        int v227 = (v17 >> 20) & 1;
        uint64_t v32 = v18;
        signed int v33 = -2;
        goto LABEL_63;
    }
    goto LABEL_68;
  }
  if (v27 != 1)
  {
    if (v27 == 2)
    {
      uint64_t v69 = v4 - 1;
      do
      {
        void *v3 = v69;
        unsigned int v70 = *v69--;
        --v4;
      }
      while (*(unsigned char *)(v26 + v70 + 32) != 1);
      goto LABEL_8;
    }
    if (v27 == 7)
    {
      *(void *)(a1 + 136) = v4 + 1;
      int64_t v28 = sub_100110C34((uint64_t)v24, v3, *(unsigned char **)(a1 + 128), 10);
      uint64_t v29 = **(void **)(a1 + 8);
      uint64_t v30 = *(unsigned __int8 **)(a1 + 136);
      if (v28 >= 1 && *(unsigned char *)(v29 + *v30 + 32) == 2)
      {
        uint64_t v31 = *(unsigned int *)(a1 + 144);
        if ((v31 ^ 0x7FFFFFFFFFFFFFFFuLL) >= v28)
        {
          int v227 = (v17 >> 20) & 1;
          unint64_t v43 = v28 + v31;
LABEL_224:
          char v226 = v21;
          uint64_t v32 = v18;
          v15[4] = 0;
          v159 = sub_10010CB60((uint64_t *)a1, 29, 0x20uLL);
          *((void *)v159 + 2) = v43;
          v159[6] = 0;
          int v160 = *(_DWORD *)(*(void *)a1 + 40);
          uint64_t v34 = 0;
          signed int v33 = 0;
          *((unsigned char *)sub_10010CB60((uint64_t *)a1, 28, 0x18uLL) + 16) = (v160 & 0x100000) != 0;
          goto LABEL_225;
        }
      }
      else
      {
        long long v72 = v30 - 1;
        do
        {
          void *v3 = v72;
          unsigned int v73 = *v72--;
          --v30;
        }
        while (*(unsigned char *)(v29 + v73 + 32) != 1);
      }
LABEL_77:
      uint64_t v74 = (uint64_t)&v30[-*(void *)(a1 + 120)];
      sub_100018888(__p, "An invalid or unterminated recursive sub-expression.");
      sub_10010CE64((std::string *)a1, 20, v74, (uint64_t)__p);
      goto LABEL_252;
    }
LABEL_68:
    switch(v25)
    {
      case '&':
        uint64_t v86 = v4 + 1;
        int v87 = *(unsigned __int8 **)(a1 + 128);
        *(void *)(a1 + 136) = v4 + 1;
        int v227 = (v17 >> 20) & 1;
        if (v4 + 1 == v87)
        {
          BOOL v111 = 1;
        }
        else
        {
          int v88 = *(unsigned __int8 *)(v26 + *v86 + 32);
          if (v88 == 2)
          {
            BOOL v89 = 0;
            int v90 = (char *)v86;
LABEL_156:
            if (v88 == 2) {
              goto LABEL_203;
            }
            unint64_t v122 = 0;
            do
            {
              uint64_t v123 = (char)*v86++;
              v122 ^= (v122 << 6) + 2654435769u + (v122 >> 2) + v123;
            }
            while (v86 != (unsigned __int8 *)v90);
            goto LABEL_206;
          }
          uint64_t v119 = v87 - v4 - 2;
          int v120 = v4 + 2;
          while (1)
          {
            void *v3 = v120;
            if (!v119) {
              break;
            }
            unsigned int v121 = *v120++;
            --v119;
            if (*(unsigned char *)(v26 + v121 + 32) == 2)
            {
              int v90 = (char *)(v120 - 1);
              BOOL v89 = v120 - 1 == v87;
              goto LABEL_156;
            }
          }
          BOOL v111 = v120 == v87;
          uint64_t v86 = v120;
        }
        int v129 = (char *)(v86 - 1);
        do
        {
          void *v3 = v129;
          unsigned int v130 = *v129--;
          --v86;
        }
        while (*(unsigned char *)(v26 + v130 + 32) != 1);
        break;
      case 'P':
        long long v50 = v4 + 1;
        *(void *)(a1 + 136) = v4 + 1;
        long long v91 = *(unsigned __int8 **)(a1 + 128);
        if (v4 + 1 == v91)
        {
          do
          {
            void *v3 = v4;
            unsigned int v94 = *v4--;
            --v50;
          }
          while (*(unsigned char *)(v26 + v94 + 32) != 1);
          goto LABEL_98;
        }
        if (*v50 != 62) {
          goto LABEL_79;
        }
        uint64_t v86 = v4 + 2;
        void *v3 = v4 + 2;
        int v227 = (v17 >> 20) & 1;
        if (v4 + 2 == v91)
        {
          BOOL v111 = 1;
        }
        else
        {
          if (*(unsigned char *)(v26 + v4[2] + 32) == 2)
          {
            BOOL v89 = 0;
            uint64_t v92 = 2;
            int v93 = (char *)v86;
LABEL_202:
            if (v92 == 2)
            {
LABEL_203:
              unint64_t v43 = 0x40000000;
              goto LABEL_207;
            }
            unint64_t v122 = 0;
            do
            {
              uint64_t v149 = (char)*v86++;
              v122 ^= (v122 << 6) + 2654435769u + (v122 >> 2) + v149;
            }
            while (v86 != (unsigned __int8 *)v93);
LABEL_206:
            unint64_t v43 = (v122 % 0x7FFFFFFF) | 0x40000000;
LABEL_207:
            if (v89) {
              return 0;
            }
            goto LABEL_224;
          }
          uint64_t v147 = 3;
          while (1)
          {
            v148 = &v4[v147];
            void *v3 = &v4[v147];
            if (v91 - v4 == v147) {
              break;
            }
            ++v147;
            if (*(unsigned char *)(v26 + *v148 + 32) == 2)
            {
              uint64_t v92 = v147 - 1;
              int v93 = (char *)&v4[v92];
              BOOL v89 = &v4[v92] == v91;
              goto LABEL_202;
            }
          }
          BOOL v111 = v148 == v91;
          uint64_t v86 = &v4[v147];
        }
        v157 = (char *)(v86 - 1);
        do
        {
          void *v3 = v157;
          unsigned int v158 = *v157--;
          --v86;
        }
        while (*(unsigned char *)(v26 + v158 + 32) != 1);
        break;
      case 'R':
        long long v50 = v4 + 1;
        void *v3 = v4 + 1;
        if (*(unsigned char *)(v26 + v4[1] + 32) != 2)
        {
          do
          {
            void *v3 = v4;
            unsigned int v71 = *v4--;
            --v50;
          }
          while (*(unsigned char *)(v26 + v71 + 32) != 1);
          goto LABEL_98;
        }
        int v227 = (v17 >> 20) & 1;
LABEL_223:
        unint64_t v43 = 0;
        goto LABEL_224;
      default:
LABEL_79:
        unsigned int v75 = sub_100111098((std::string *)a1);
        uint64_t v4 = *(unsigned __int8 **)(a1 + 136);
        if (v4 == *(unsigned __int8 **)(a1 + 128))
        {
          uint64_t v83 = **(void **)(a1 + 8);
          int v84 = v4 - 1;
          do
          {
            void *v3 = v84;
            unsigned int v85 = *v84--;
            --v4;
          }
          while (*(unsigned char *)(v83 + v85 + 32) != 1);
          goto LABEL_8;
        }
        char v226 = v21;
        uint64_t v32 = v18;
        unsigned int v76 = v75 & 0x100000;
        uint64_t v77 = *(void *)a1;
        int v78 = *(_DWORD *)(*(void *)a1 + 40) & 0x100000;
        BOOL v79 = (v75 & 0x100000) != v78;
        *(unsigned char *)(a1 + 176) = v79;
        v15[4] = 0;
        uint64_t v80 = **(void **)(a1 + 8);
        int v81 = *(unsigned __int8 *)(v80 + *v4 + 32);
        BOOL v82 = v81 != 2;
        if (v81 == 2)
        {
          *(_DWORD *)(v77 + 40) = v75;
          if (((v75 >> 20) & 1) != *(unsigned char *)(a1 + 24)) {
            *(unsigned char *)(a1 + 24) = (v75 & 0x100000) != 0;
          }
          v226 |= v79;
        }
        else
        {
          if (v81 != 36)
          {
            long long v109 = v4 - 1;
            do
            {
              void *v3 = v109;
              unsigned int v110 = *v109--;
              --v4;
            }
            while (*(unsigned char *)(v80 + v110 + 32) != 1);
            goto LABEL_8;
          }
          *(_DWORD *)(v77 + 40) = v75;
          if (((v75 >> 20) & 1) != *(unsigned char *)(a1 + 24)) {
            *(unsigned char *)(a1 + 24) = (v75 & 0x100000) != 0;
          }
          void *v3 = v4 + 1;
        }
        int v227 = (v17 >> 20) & 1;
        uint64_t v34 = 0;
        signed int v33 = 0;
        if (v76 != v78) {
          *((unsigned char *)sub_10010CB60((uint64_t *)a1, 28, 0x18uLL) + 16) = v76 >> 20;
        }
        goto LABEL_226;
    }
    sub_10010C68C((std::string *)a1, 20, (uint64_t)&v86[-*(void *)(a1 + 120)]);
    if (v111) {
      return 0;
    }
    goto LABEL_223;
  }
  v15[4] = -4;
  long long v50 = v4 + 1;
  *(void *)(a1 + 136) = v4 + 1;
  uint64_t v51 = *(unsigned __int8 **)(a1 + 128);
  if (v4 + 1 == v51)
  {
    do
    {
      void *v3 = v4;
      unsigned int v63 = *v4--;
      --v50;
    }
    while (*(unsigned char *)(v26 + v63 + 32) != 1);
    goto LABEL_98;
  }
  int v227 = (v17 >> 20) & 1;
  uint64_t v52 = sub_100110C34((uint64_t)v24, v3, v51, 10);
  uint64_t v53 = *(unsigned __int8 **)(a1 + 128);
  uint64_t v4 = *(unsigned __int8 **)(a1 + 136);
  if (v4 == v53)
  {
    uint64_t v95 = **(void **)(a1 + 8);
    int v96 = v4 - 1;
    do
    {
      void *v3 = v96;
      unsigned int v97 = *v96--;
      --v4;
    }
    while (*(unsigned char *)(v95 + v97 + 32) != 1);
    goto LABEL_8;
  }
  uint64_t v54 = v52;
  uint64_t v55 = *v4;
  if (*v4 <= 0x43u)
  {
    if (v55 == 39 || v55 == 60)
    {
      uint64_t v56 = (char *)(v4 + 1);
      void *v3 = v4 + 1;
      if (v4 + 1 == v53)
      {
LABEL_57:
        uint64_t v60 = **(void **)(a1 + 8);
        int v61 = v53 - 1;
        do
        {
          void *v3 = v61;
          unsigned int v62 = *v61--;
          --v53;
        }
        while (*(unsigned char *)(v60 + v62 + 32) != 1);
LABEL_165:
        uint64_t v12 = (uint64_t)&v53[-*(void *)(a1 + 120)];
        goto LABEL_9;
      }
      uint64_t v57 = 1;
      while (1)
      {
        int v58 = v4[v57];
        if (v58 == 39 || v58 == 62) {
          break;
        }
        uint64_t v59 = v57 + 1;
        void *v3 = &v4[v57 + 1];
        uint64_t v57 = v59;
        if (v53 - v4 == v59)
        {
          uint64_t v53 = &v4[v59];
          goto LABEL_57;
        }
      }
      uint64_t v124 = v57 - 1;
      if (v57 == 1)
      {
        int v125 = 0x40000000;
      }
      else
      {
        unint64_t v131 = 0;
        do
        {
          uint64_t v132 = *v56++;
          v131 ^= (v131 << 6) + 2654435769u + (v131 >> 2) + v132;
          --v124;
        }
        while (v124);
        int v125 = (v131 % 0x7FFFFFFF) | 0x40000000;
      }
      sub_10010CB60((uint64_t *)a1, 27, 0x18uLL)[4] = v125;
      long long v133 = *(unsigned __int8 **)(a1 + 136);
      int v134 = *v133;
      if (v134 == 62 || v134 == 39)
      {
        int v135 = v133 + 1;
        *(void *)(a1 + 136) = v133 + 1;
        v136 = *(unsigned __int8 **)(a1 + 128);
        if (v133 + 1 != v136)
        {
          uint64_t v137 = **(void **)(a1 + 8);
          if (*(unsigned char *)(v137 + *v135 + 32) != 2)
          {
            long long v50 = v133 + 1;
            do
            {
              void *v3 = v133;
              unsigned int v156 = *v133--;
              --v50;
            }
            while (*(unsigned char *)(v137 + v156 + 32) != 1);
            goto LABEL_98;
          }
          uint64_t v4 = v133 + 2;
          void *v3 = v4;
          if (v4 != v136) {
            goto LABEL_299;
          }
          do
          {
            void *v3 = v135;
            unsigned int v138 = *v135--;
            --v4;
          }
          while (*(unsigned char *)(v137 + v138 + 32) != 1);
          goto LABEL_8;
        }
        ++v133;
      }
      uint64_t v150 = **(void **)(a1 + 8);
      v151 = v133 - 1;
      do
      {
        void *v3 = v151;
        unsigned int v152 = *v151--;
        --v133;
      }
      while (*(unsigned char *)(v150 + v152 + 32) != 1);
      uint64_t v153 = (uint64_t)&v133[-*(void *)(a1 + 120)];
      sub_100018888(__p, "Unterminated named capture.");
      sub_10010CE64((std::string *)a1, 20, v153, (uint64_t)__p);
      goto LABEL_252;
    }
    goto LABEL_147;
  }
  if (v55 == 82)
  {
    int v99 = (char *)(v4 + 1);
    void *v3 = v4 + 1;
    if (v4 + 1 != v53)
    {
      if (*v99 != 38)
      {
        uint64_t v54 = -sub_100110C34(*(void *)(a1 + 8), v3, v53, 10);
        goto LABEL_297;
      }
      long long v112 = (char *)(v4 + 2);
      *(void *)(a1 + 136) = v4 + 2;
      uint64_t v113 = **(void **)(a1 + 8);
      if (v4 + 2 == v53)
      {
        BOOL v209 = 1;
      }
      else
      {
        if (*(unsigned char *)(v113 + v4[2] + 32) == 2)
        {
          BOOL v114 = 0;
          uint64_t v115 = 2;
          uint64_t v116 = v112;
          goto LABEL_286;
        }
        uint64_t v212 = 3;
        while (1)
        {
          v213 = &v4[v212];
          void *v3 = &v4[v212];
          if (v53 - v4 == v212) {
            break;
          }
          ++v212;
          if (*(unsigned char *)(v113 + *v213 + 32) == 2)
          {
            uint64_t v115 = v212 - 1;
            uint64_t v116 = (char *)&v4[v115];
            BOOL v114 = &v4[v115] == v53;
LABEL_286:
            if (v115 == 2)
            {
              LODWORD(v214) = 0x40000000;
            }
            else
            {
              unint64_t v215 = 0;
              do
              {
                uint64_t v216 = *v112++;
                v215 ^= (v215 << 6) + 2654435769u + (v215 >> 2) + v216;
              }
              while (v112 != v116);
              unint64_t v214 = (v215 % 0x7FFFFFFF) | 0x40000000;
            }
            uint64_t result = 0;
            if (v114) {
              return result;
            }
            uint64_t v54 = -(int)v214;
LABEL_297:
            sub_10010CB60((uint64_t *)a1, 27, 0x18uLL)[4] = (v54 >> 63) & (v54 - 1);
            uint64_t v4 = *(unsigned __int8 **)(a1 + 136);
            uint64_t v219 = **(void **)(a1 + 8);
            if (*(unsigned char *)(v219 + *v4 + 32) == 2)
            {
              long long v50 = v4 + 1;
              *(void *)(a1 + 136) = v4 + 1;
              if (v4 + 1 == *(unsigned __int8 **)(a1 + 128))
              {
                do
                {
                  void *v3 = v4;
                  unsigned int v220 = *v4--;
                  --v50;
                }
                while (*(unsigned char *)(v219 + v220 + 32) != 1);
                goto LABEL_98;
              }
LABEL_299:
              char v226 = v21;
LABEL_300:
              uint64_t v32 = v18;
              uint64_t v34 = 0;
LABEL_301:
              signed int v33 = -4;
LABEL_225:
              BOOL v82 = 1;
LABEL_226:
              uint64_t v161 = (uint64_t)v15 - v19;
              sub_10010CF08(a1);
              if (sub_10010CFF0((std::string *)a1, v161))
              {
                uint64_t v162 = *(void *)(a1 + 136);
                if (v162 == *(void *)(a1 + 128))
                {
                  uint64_t v181 = **(void **)(a1 + 8);
                  v182 = (unsigned __int8 *)(v162 - 1);
                  do
                  {
                    void *v3 = v182;
                    unsigned int v183 = *v182--;
                  }
                  while (*(unsigned char *)(v181 + v183 + 32) != 1);
                  uint64_t v12 = v162 - *(void *)(a1 + 120);
                  int v13 = (std::string *)a1;
                  int v14 = 8;
                  goto LABEL_10;
                }
                void *v3 = v162 + 1;
                if (v82)
                {
                  if (*(unsigned char *)(a1 + 176)) {
                    *((unsigned char *)sub_10010CB60((uint64_t *)a1, 28, 0x18uLL) + 16) = v227;
                  }
                  *(_DWORD *)(*(void *)a1 + 40) = v17;
                  if (v227 != *(unsigned __int8 *)(a1 + 24)) {
                    *(unsigned char *)(a1 + 24) = v227;
                  }
                }
                if (v34)
                {
                  uint64_t v163 = *(void *)(*(void *)a1 + 352);
                  unint64_t v164 = (*(void *)(*(void *)a1 + 360) - v163 + 7) & 0xFFFFFFFFFFFFFFF8;
                  *(void *)(*(void *)a1 + 360) = v163 + v164;
                  *(void *)&v34[v163 + 16] = v164 - (void)v34;
                  if (*(char **)(a1 + 16) == &v34[v163] && v33 != -2)
                  {
                    uint64_t v184 = **(void **)(a1 + 8);
                    uint64_t v185 = *(void *)(a1 + 136);
                    v186 = (unsigned __int8 *)(v185 - 1);
                    do
                    {
                      void *v3 = v186;
                      unsigned int v187 = *v186--;
                      --v185;
                    }
                    while (*(unsigned char *)(v184 + v187 + 32) != 1);
                    uint64_t v188 = v185 - *(void *)(a1 + 120);
                    sub_100018888(__p, "Invalid or empty zero width assertion.");
                    sub_10010CE64((std::string *)a1, 20, v188, (uint64_t)__p);
                    goto LABEL_252;
                  }
                }
                if (v33 != -4) {
                  goto LABEL_270;
                }
                uint64_t v166 = *(void *)(*(void *)a1 + 352);
                uint64_t v167 = v166 + v20;
                if (*(_DWORD *)(v166 + v20) == 17)
                {
                  uint64_t v168 = *(void *)(*(void *)a1 + 360) - v166;
                  uint64_t v169 = *(void *)(v167 + 16);
                  BOOL v170 = v169 < 1 || v168 <= (uint64_t)(v169 + v20);
                  if (!v170 && *(_DWORD *)(v167 + v169) == 17)
                  {
                    uint64_t v171 = **(void **)(a1 + 8);
                    uint64_t v172 = *(void *)(a1 + 136);
                    v173 = (unsigned __int8 *)(v172 - 1);
                    do
                    {
                      void *v3 = v173;
                      unsigned int v174 = *v173--;
                      --v172;
                    }
                    while (*(unsigned char *)(v171 + v174 + 32) != 1);
                    uint64_t v175 = v172 - *(void *)(a1 + 120);
                    sub_100018888(__p, "More than one alternation operator | was encountered inside a conditional expression.");
                    sub_10010CE64((std::string *)a1, 2, v175, (uint64_t)__p);
                    goto LABEL_252;
                  }
                  v191 = (int *)(v167 + *(void *)(v167 + 8));
                  int v190 = *v191;
                  if (*v191 == 27)
                  {
                    if (v191[4] == 9999)
                    {
                      uint64_t v192 = **(void **)(a1 + 8);
                      uint64_t v193 = *(void *)(a1 + 136);
                      v194 = (unsigned __int8 *)(v193 - 1);
                      do
                      {
                        void *v3 = v194;
                        unsigned int v195 = *v194--;
                        --v193;
                      }
                      while (*(unsigned char *)(v192 + v195 + 32) != 1);
                      uint64_t v196 = v193 - *(void *)(a1 + 120);
                      sub_100018888(__p, "Alternation operators are not allowed inside a DEFINE block.");
                      sub_10010CE64((std::string *)a1, 2, v196, (uint64_t)__p);
                      goto LABEL_252;
                    }
LABEL_270:
                    v198 = sub_10010CB60((uint64_t *)a1, 1, 0x18uLL);
                    v198[4] = v33;
                    uint64_t v199 = *(void *)a1;
                    int v200 = *(_DWORD *)(*(void *)a1 + 40);
                    *((unsigned char *)v198 + 20) = (v200 & 0x100000) != 0;
                    *(void *)(a1 + 160) = v161;
                    *(void *)(a1 + 168) = v32;
                    *(unsigned char *)(a1 + 176) = v226;
                    unsigned int v201 = *(_DWORD *)(a1 + 152);
                    if (v201 > *(_DWORD *)(a1 + 144)) {
                      *(_DWORD *)(a1 + 144) = v201;
                    }
                    *(void *)(a1 + 148) = v22;
                    uint64_t result = 1;
                    if (v33 >= 1 && (v200 & 0x800000) != 0)
                    {
                      unint64_t v202 = v33 - 1;
                      uint64_t v203 = *(void *)(v199 + 376);
                      if (v202 >= (*(void *)(v199 + 384) - v203) >> 4) {
                        sub_10009E508();
                      }
                      *(void *)(v203 + 16 * v202 + 8) = *(void *)(a1 + 136) + ~*(void *)(a1 + 120);
                    }
                    return result;
                  }
                }
                else
                {
                  v189 = sub_100111224((void *)a1, v20, 17, 0x120uLL);
                  *((void *)v189 + 2) = *(void *)(*(void *)a1 + 360) - (void)v189;
                  int v190 = *(_DWORD *)(*(void *)(*(void *)a1 + 352)
                                   + v20
                                   + *(void *)(*(void *)(*(void *)a1 + 352) + v20 + 8));
                }
                if (v190) {
                  BOOL v197 = v190 == 27;
                }
                else {
                  BOOL v197 = 1;
                }
                if (v197) {
                  goto LABEL_270;
                }
                uint64_t v204 = **(void **)(a1 + 8);
                uint64_t v205 = *(void *)(a1 + 136);
                v206 = (unsigned __int8 *)(v205 - 1);
                do
                {
                  void *v3 = v206;
                  unsigned int v207 = *v206--;
                  --v205;
                }
                while (*(unsigned char *)(v204 + v207 + 32) != 1);
                uint64_t v208 = v205 - *(void *)(a1 + 120);
                sub_100018888(__p, "A repetition operator cannot be applied to a zero-width assertion.");
                sub_10010CE64((std::string *)a1, 13, v208, (uint64_t)__p);
              }
              else
              {
                uint64_t v176 = **(void **)(a1 + 8);
                uint64_t v177 = *(void *)(a1 + 136);
                v178 = (unsigned __int8 *)(v177 - 1);
                do
                {
                  void *v3 = v178;
                  unsigned int v179 = *v178--;
                  --v177;
                }
                while (*(unsigned char *)(v176 + v179 + 32) != 1);
                uint64_t v180 = v177 - *(void *)(a1 + 120);
                sub_100018888(__p, "Invalid alternation operators within (?...) block.");
                sub_10010CE64((std::string *)a1, 20, v180, (uint64_t)__p);
              }
LABEL_252:
              if (v229 < 0) {
                operator delete(__p[0]);
              }
              return 0;
            }
            v221 = v4 - 1;
            do
            {
              void *v3 = v221;
              unsigned int v222 = *v221--;
              --v4;
            }
            while (*(unsigned char *)(v219 + v222 + 32) != 1);
            goto LABEL_8;
          }
        }
        BOOL v209 = v213 == v53;
        uint64_t v53 = &v4[v212];
      }
      v217 = v53 - 1;
      do
      {
        void *v3 = v217;
        unsigned int v218 = *v217--;
        --v53;
      }
      while (*(unsigned char *)(v113 + v218 + 32) != 1);
      sub_10010C68C((std::string *)a1, 20, (uint64_t)&v53[-*(void *)(a1 + 120)]);
      if (v209) {
        return 0;
      }
      goto LABEL_297;
    }
    uint64_t v139 = **(void **)(a1 + 8);
    do
    {
      void *v3 = v4;
      unsigned int v140 = *v4--;
      --v99;
    }
    while (*(unsigned char *)(v139 + v140 + 32) != 1);
    goto LABEL_120;
  }
  if (v55 != 68)
  {
LABEL_147:
    if (v52 < 1)
    {
      uint64_t v141 = **(void **)(a1 + 8);
      if (*(unsigned char *)(v141 + v55 + 32) != 8)
      {
        v154 = v4 - 1;
        do
        {
          void *v3 = v154;
          unsigned int v155 = *v154--;
          --v4;
        }
        while (*(unsigned char *)(v141 + v155 + 32) != 1);
        goto LABEL_8;
      }
      long long v50 = v4 + 1;
      void *v3 = v4 + 1;
      if (v4 + 1 == v53)
      {
        do
        {
          void *v3 = v4;
          unsigned int v144 = *v4--;
          --v50;
        }
        while (*(unsigned char *)(v141 + v144 + 32) != 1);
        goto LABEL_98;
      }
      char v226 = v21;
      int v142 = *(unsigned __int8 *)(v141 + *v50 + 32);
      if (v142 == 20)
      {
        v223 = v4 + 2;
        void *v3 = v4 + 2;
        if (v4 + 2 == v53)
        {
          do
          {
            void *v3 = v50;
            unsigned int v224 = *v50--;
            --v223;
          }
          while (*(unsigned char *)(v141 + v224 + 32) != 1);
          uint64_t v12 = (uint64_t)&v223[-*(void *)(a1 + 120)];
          goto LABEL_9;
        }
        if ((*(unsigned __int8 *)(v141 + *v223 + 32) | 0x10) != 0x35)
        {
          v4 += 2;
          do
          {
            void *v3 = v50;
            unsigned int v225 = *v50--;
            --v4;
          }
          while (*(unsigned char *)(v141 + v225 + 32) != 1);
          goto LABEL_8;
        }
        uint64_t v32 = v18;
      }
      else
      {
        uint64_t v32 = v18;
        if (v142 != 37 && v142 != 53)
        {
          long long v50 = v4 + 1;
          do
          {
            void *v3 = v4;
            unsigned int v143 = *v4--;
            --v50;
          }
          while (*(unsigned char *)(v141 + v143 + 32) != 1);
          goto LABEL_98;
        }
      }
      uint64_t v34 = 0;
      void *v3 = v4 - 1;
      goto LABEL_301;
    }
    sub_10010CB60((uint64_t *)a1, 27, 0x18uLL)[4] = v52;
    uint64_t v4 = *(unsigned __int8 **)(a1 + 136);
    uint64_t v117 = **(void **)(a1 + 8);
    if (*(unsigned char *)(v117 + *v4 + 32) == 2)
    {
      long long v50 = v4 + 1;
      *(void *)(a1 + 136) = v4 + 1;
      if (v4 + 1 == *(unsigned __int8 **)(a1 + 128))
      {
        do
        {
          void *v3 = v4;
          unsigned int v118 = *v4--;
          --v50;
        }
        while (*(unsigned char *)(v117 + v118 + 32) != 1);
        goto LABEL_98;
      }
      goto LABEL_299;
    }
    v145 = v4 - 1;
    do
    {
      void *v3 = v145;
      unsigned int v146 = *v145--;
      --v4;
    }
    while (*(unsigned char *)(v117 + v146 + 32) != 1);
LABEL_8:
    uint64_t v12 = (uint64_t)&v4[-*(void *)(a1 + 120)];
    goto LABEL_9;
  }
  for (uint64_t i = 0; i != 6; ++i)
  {
    if (&v4[i] == v53 || v4[i] != v55)
    {
      uint64_t v53 = &v4[i];
LABEL_163:
      uint64_t v126 = **(void **)(a1 + 8);
      long long v127 = v53 - 1;
      do
      {
        void *v3 = v127;
        unsigned int v128 = *v127--;
        --v53;
      }
      while (*(unsigned char *)(v126 + v128 + 32) != 1);
      goto LABEL_165;
    }
    void *v3 = &v4[i + 1];
    LODWORD(v55) = aDefine[i + 1];
  }
  if (v4 + 6 == v53) {
    goto LABEL_163;
  }
  sub_10010CB60((uint64_t *)a1, 27, 0x18uLL)[4] = 9999;
  uint64_t v4 = *(unsigned __int8 **)(a1 + 136);
  uint64_t v107 = **(void **)(a1 + 8);
  if (*(unsigned char *)(v107 + *v4 + 32) != 2)
  {
    v210 = v4 - 1;
    do
    {
      void *v3 = v210;
      unsigned int v211 = *v210--;
      --v4;
    }
    while (*(unsigned char *)(v107 + v211 + 32) != 1);
    goto LABEL_8;
  }
  char v226 = v21;
  long long v50 = v4 + 1;
  *(void *)(a1 + 136) = v4 + 1;
  if (v4 + 1 != *(unsigned __int8 **)(a1 + 128)) {
    goto LABEL_300;
  }
  do
  {
    void *v3 = v4;
    unsigned int v108 = *v4--;
    --v50;
  }
  while (*(unsigned char *)(v107 + v108 + 32) != 1);
LABEL_98:
  uint64_t v12 = (uint64_t)&v50[-*(void *)(a1 + 120)];
LABEL_9:
  int v13 = (std::string *)a1;
  int v14 = 20;
LABEL_10:
  sub_10010C68C(v13, v14, v12);
  return 0;
}

void sub_100110544(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001105C0(uint64_t a1)
{
  uint64_t v3 = *(unsigned __int8 **)(a1 + 128);
  uint64_t v2 = *(unsigned __int8 **)(a1 + 136);
  uint64_t v4 = (char *)(v2 + 1);
  *(void *)(a1 + 136) = v2 + 1;
  if (v2 + 1 == v3)
  {
    uint64_t v12 = **(void **)(a1 + 8);
    do
    {
      *(void *)(a1 + 136) = v2;
      unsigned int v13 = *v2--;
      --v4;
    }
    while (*(unsigned char *)(v12 + v13 + 32) != 1);
    goto LABEL_71;
  }
  int v5 = *v4;
  if (v5 > 79)
  {
    switch(v5)
    {
      case 'P':
        int v6 = v2 + 2;
        *(void *)(a1 + 136) = v6;
        if (v6 == v3)
        {
          uint64_t v40 = **(void **)(a1 + 8);
          do
          {
            *(void *)(a1 + 136) = v4;
            unsigned int v41 = *v4--;
            --v6;
          }
          while (*(unsigned char *)(v40 + v41 + 32) != 1);
          goto LABEL_67;
        }
        int v24 = sub_100111530(a1, "RUNE");
        uint64_t v4 = *(char **)(a1 + 136);
        if (v24)
        {
          uint64_t v25 = *(uint64_t **)(a1 + 8);
          if (v4 == *(char **)(a1 + 128))
          {
            uint64_t v26 = *v25;
          }
          else
          {
            uint64_t v26 = *v25;
            if (*(unsigned char *)(v26 + *v4 + 32) == 2)
            {
              *(void *)(a1 + 136) = v4 + 1;
              sub_10010CB60((uint64_t *)a1, 32, 0x18uLL)[4] = 0;
              goto LABEL_40;
            }
          }
          uint64_t v56 = (unsigned __int8 *)(v4 - 1);
          do
          {
            *(void *)(a1 + 136) = v56;
            unsigned int v57 = *v56--;
            --v4;
          }
          while (*(unsigned char *)(v26 + v57 + 32) != 1);
          goto LABEL_71;
        }
        break;
      case 'S':
        int v6 = v2 + 2;
        *(void *)(a1 + 136) = v6;
        if (v6 == v3)
        {
          uint64_t v42 = **(void **)(a1 + 8);
          do
          {
            *(void *)(a1 + 136) = v4;
            unsigned int v43 = *v4--;
            --v6;
          }
          while (*(unsigned char *)(v42 + v43 + 32) != 1);
          goto LABEL_67;
        }
        int v28 = sub_100111530(a1, "KIP");
        uint64_t v4 = *(char **)(a1 + 136);
        if (v28)
        {
          uint64_t v29 = *(uint64_t **)(a1 + 8);
          if (v4 == *(char **)(a1 + 128))
          {
            uint64_t v30 = *v29;
          }
          else
          {
            uint64_t v30 = *v29;
            if (*(unsigned char *)(v30 + *v4 + 32) == 2)
            {
              *(void *)(a1 + 136) = v4 + 1;
              uint64_t v31 = sub_10010CB60((uint64_t *)a1, 32, 0x18uLL);
              uint64_t result = 1;
              v31[4] = 1;
              uint64_t v27 = *(void *)a1;
              goto LABEL_46;
            }
          }
          int v58 = (unsigned __int8 *)(v4 - 1);
          do
          {
            *(void *)(a1 + 136) = v58;
            unsigned int v59 = *v58--;
            --v4;
          }
          while (*(unsigned char *)(v30 + v59 + 32) != 1);
          goto LABEL_71;
        }
        break;
      case 'T':
        int v6 = v2 + 2;
        *(void *)(a1 + 136) = v6;
        if (v6 == v3)
        {
          uint64_t v34 = **(void **)(a1 + 8);
          do
          {
            *(void *)(a1 + 136) = v4;
            unsigned int v35 = *v4--;
            --v6;
          }
          while (*(unsigned char *)(v34 + v35 + 32) != 1);
          goto LABEL_67;
        }
        int v14 = sub_100111530(a1, "HEN");
        uint64_t v4 = *(char **)(a1 + 136);
        if (v14)
        {
          uint64_t v15 = *(uint64_t **)(a1 + 8);
          if (v4 == *(char **)(a1 + 128))
          {
            uint64_t v16 = *v15;
          }
          else
          {
            uint64_t v16 = *v15;
            if (*(unsigned char *)(v16 + *v4 + 32) == 2)
            {
              *(void *)(a1 + 136) = v4 + 1;
              sub_10010CB60((uint64_t *)a1, 33, 0x10uLL);
LABEL_40:
              uint64_t v27 = *(void *)a1;
              uint64_t result = 1;
LABEL_46:
              *(unsigned char *)(v27 + 401) = 1;
              return result;
            }
          }
          long long v50 = (unsigned __int8 *)(v4 - 1);
          do
          {
            *(void *)(a1 + 136) = v50;
            unsigned int v51 = *v50--;
            --v4;
          }
          while (*(unsigned char *)(v16 + v51 + 32) != 1);
          goto LABEL_71;
        }
        break;
    }
LABEL_69:
    uint64_t v47 = **(void **)(a1 + 8);
    int v48 = (unsigned __int8 *)(v4 - 1);
    do
    {
      *(void *)(a1 + 136) = v48;
      unsigned int v49 = *v48--;
      --v4;
    }
    while (*(unsigned char *)(v47 + v49 + 32) != 1);
LABEL_71:
    uint64_t v46 = (uint64_t)&v4[-*(void *)(a1 + 120)];
    goto LABEL_72;
  }
  if (v5 == 65)
  {
    int v6 = v2 + 2;
    *(void *)(a1 + 136) = v6;
    if (v6 != v3)
    {
      int v17 = sub_100111530(a1, "CCEPT");
      uint64_t v4 = *(char **)(a1 + 136);
      if (v17)
      {
        uint64_t v18 = *(uint64_t **)(a1 + 8);
        if (v4 == *(char **)(a1 + 128))
        {
          uint64_t v19 = *v18;
        }
        else
        {
          uint64_t v19 = *v18;
          if (*(unsigned char *)(v19 + *v4 + 32) == 2)
          {
            *(void *)(a1 + 136) = v4 + 1;
            uint64_t v10 = (uint64_t *)a1;
            int v11 = 31;
            goto LABEL_29;
          }
        }
        uint64_t v52 = (unsigned __int8 *)(v4 - 1);
        do
        {
          *(void *)(a1 + 136) = v52;
          unsigned int v53 = *v52--;
          --v4;
        }
        while (*(unsigned char *)(v19 + v53 + 32) != 1);
        goto LABEL_71;
      }
      goto LABEL_69;
    }
    uint64_t v36 = **(void **)(a1 + 8);
    do
    {
      *(void *)(a1 + 136) = v4;
      unsigned int v37 = *v4--;
      --v6;
    }
    while (*(unsigned char *)(v36 + v37 + 32) != 1);
    goto LABEL_67;
  }
  if (v5 == 67)
  {
    int v6 = v2 + 2;
    *(void *)(a1 + 136) = v6;
    if (v6 == v3)
    {
      uint64_t v38 = **(void **)(a1 + 8);
      do
      {
        *(void *)(a1 + 136) = v4;
        unsigned int v39 = *v4--;
        --v6;
      }
      while (*(unsigned char *)(v38 + v39 + 32) != 1);
      goto LABEL_67;
    }
    int v21 = sub_100111530(a1, "OMMIT");
    uint64_t v4 = *(char **)(a1 + 136);
    if (v21)
    {
      uint64_t v22 = *(uint64_t **)(a1 + 8);
      if (v4 == *(char **)(a1 + 128))
      {
        uint64_t v23 = *v22;
      }
      else
      {
        uint64_t v23 = *v22;
        if (*(unsigned char *)(v23 + *v4 + 32) == 2)
        {
          *(void *)(a1 + 136) = v4 + 1;
          sub_10010CB60((uint64_t *)a1, 32, 0x18uLL)[4] = 2;
          goto LABEL_40;
        }
      }
      uint64_t v54 = (unsigned __int8 *)(v4 - 1);
      do
      {
        *(void *)(a1 + 136) = v54;
        unsigned int v55 = *v54--;
        --v4;
      }
      while (*(unsigned char *)(v23 + v55 + 32) != 1);
      goto LABEL_71;
    }
    goto LABEL_69;
  }
  if (v5 != 70) {
    goto LABEL_69;
  }
  int v6 = v2 + 2;
  *(void *)(a1 + 136) = v6;
  uint64_t v7 = *(uint64_t **)(a1 + 8);
  if (v6 != v3)
  {
    uint64_t v8 = *v7;
    if (*(unsigned char *)(*v7 + *v6 + 32) == 2) {
      goto LABEL_10;
    }
    int v9 = sub_100111530(a1, "AIL");
    int v6 = *(unsigned __int8 **)(a1 + 136);
    if (v9)
    {
      uint64_t v3 = *(unsigned __int8 **)(a1 + 128);
      uint64_t v8 = **(void **)(a1 + 8);
LABEL_10:
      if (v6 != v3 && *(unsigned char *)(v8 + *v6 + 32) == 2)
      {
        *(void *)(a1 + 136) = v6 + 1;
        uint64_t v10 = (uint64_t *)a1;
        int v11 = 30;
LABEL_29:
        sub_10010CB60(v10, v11, 0x10uLL);
        return 1;
      }
      unsigned int v44 = v6 - 1;
      do
      {
        *(void *)(a1 + 136) = v44;
        unsigned int v45 = *v44--;
        --v6;
      }
      while (*(unsigned char *)(v8 + v45 + 32) != 1);
      goto LABEL_67;
    }
    uint64_t v4 = *(char **)(a1 + 136);
    goto LABEL_69;
  }
  uint64_t v32 = *v7;
  do
  {
    *(void *)(a1 + 136) = v4;
    unsigned int v33 = *v4--;
    --v6;
  }
  while (*(unsigned char *)(v32 + v33 + 32) != 1);
LABEL_67:
  uint64_t v46 = (uint64_t)&v6[-*(void *)(a1 + 120)];
LABEL_72:
  sub_10010C68C((std::string *)a1, 20, v46);
  return 0;
}

void sub_100110B44(void **a1, _OWORD *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(_OWORD **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = ((char *)v7 - (unsigned char *)*a1) >> 4;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60) {
      sub_10002B5E0();
    }
    uint64_t v11 = v5 - (void)*a1;
    if (v11 >> 3 > v10) {
      unint64_t v10 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12) {
      unsigned int v13 = (char *)sub_10001E498(v4, v12);
    }
    else {
      unsigned int v13 = 0;
    }
    int v14 = &v13[16 * v9];
    uint64_t v15 = &v13[16 * v12];
    *(_OWORD *)int v14 = *a2;
    uint64_t v8 = v14 + 16;
    int v17 = (char *)*a1;
    uint64_t v16 = (char *)a1[1];
    if (v16 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v16 - 1);
        v14 -= 16;
        v16 -= 16;
      }
      while (v16 != v17);
      uint64_t v16 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v8;
    a1[2] = v15;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    _OWORD *v7 = *a2;
    uint64_t v8 = v7 + 1;
  }
  a1[1] = v8;
}

uint64_t sub_100110C34(uint64_t a1, void *a2, unsigned char *a3, int a4)
{
  std::streambuf::basic_streambuf();
  __sb[0] = off_1001BDE80;
  __sb[2] = 0;
  unint64_t v24 = 0;
  unint64_t v25 = 0;
  v19[1] = 0;
  std::ios_base::init(&v20, __sb);
  uint64_t v21 = 0;
  int v22 = -1;
  uint64_t v7 = (void *)*a2;
  uint64_t v8 = std::locale::use_facet(&v18, &std::numpunct<char>::id);
  int v9 = ((uint64_t (*)(const std::locale::facet *))v8->__vftable[1].~facet_0)(v8);
  unint64_t v10 = memchr(v7, v9, a3 - (unsigned char *)v7);
  if (v10) {
    a3 = v10;
  }
  std::locale::~locale(&v18);
  (*(void (**)(void *, void, unsigned char *))(__sb[0] + 24))(__sb, *a2, &a3[-*a2]);
  std::ios_base::clear((std::ios_base *)((char *)v19 + *(void *)(v19[0] - 24)), 0);
  if (a4 >= 0) {
    int v11 = a4;
  }
  else {
    int v11 = -a4;
  }
  if (v11 == 8) {
    int v12 = 64;
  }
  else {
    int v12 = 2;
  }
  if (v11 == 16) {
    int v13 = 8;
  }
  else {
    int v13 = v12;
  }
  *(_DWORD *)((char *)&v19[1] + *(void *)(v19[0] - 24)) = *(_DWORD *)((unsigned char *)&v19[1] + *(void *)(v19[0] - 24)) & 0xFFFFFFB5 | v13;
  v18.__locale_ = 0;
  int v14 = (void *)std::istream::operator>>();
  if ((*((unsigned char *)v14 + *(void *)(*v14 - 24) + 32) & 5) != 0)
  {
    uint64_t locale = -1;
  }
  else
  {
    if (v24 >= v25) {
      uint64_t v16 = (*(uint64_t (**)(void *))(__sb[0] + 56))(__sb);
    }
    else {
      uint64_t v16 = v25 - v24;
    }
    *a2 = &a3[-v16];
    uint64_t locale = (uint64_t)v18.__locale_;
  }
  std::istream::~istream();
  std::streambuf::~streambuf();
  return locale;
}

void sub_100110EBC(_Unwind_Exception *a1)
{
}

void sub_100110F00(void **a1, char *a2, char *a3, unsigned int a4)
{
  if (a2 == a3)
  {
    unint64_t v8 = 0x4000000000000000;
  }
  else
  {
    unint64_t v6 = 0;
    do
    {
      uint64_t v7 = *a2++;
      v6 ^= (v6 << 6) + (v6 >> 2) + 2654435769u + v7;
    }
    while (a2 != a3);
    unint64_t v8 = ((v6 % 0x7FFFFFFF) << 32) | 0x4000000000000000;
  }
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = (unint64_t)a1[2];
  int v11 = (unint64_t *)a1[1];
  if ((unint64_t)v11 >= v10)
  {
    uint64_t v13 = ((char *)v11 - (unsigned char *)*a1) >> 3;
    if ((unint64_t)(v13 + 1) >> 61) {
      sub_10002B5E0();
    }
    uint64_t v14 = v10 - (void)*a1;
    uint64_t v15 = v14 >> 2;
    if (v14 >> 2 <= (unint64_t)(v13 + 1)) {
      uint64_t v15 = v13 + 1;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v16 = v15;
    }
    if (v16) {
      int v17 = (char *)sub_100038500(v9, v16);
    }
    else {
      int v17 = 0;
    }
    std::locale v18 = (unint64_t *)&v17[8 * v13];
    uint64_t v19 = &v17[8 * v16];
    *std::locale v18 = v8 | a4;
    int v12 = v18 + 1;
    uint64_t v21 = (char *)*a1;
    std::ios_base v20 = (char *)a1[1];
    if (v20 != *a1)
    {
      do
      {
        unint64_t v22 = *((void *)v20 - 1);
        v20 -= 8;
        *--std::locale v18 = v22;
      }
      while (v20 != v21);
      std::ios_base v20 = (char *)*a1;
    }
    *a1 = v18;
    a1[1] = v12;
    a1[2] = v19;
    if (v20) {
      operator delete(v20);
    }
  }
  else
  {
    *int v11 = v8 | a4;
    int v12 = v11 + 1;
  }
  a1[1] = v12;
  uint64_t v23 = *a1;
  unint64_t v24 = v12 - 1;
  if (*a1 != v12 && v24 != v23)
  {
    do
    {
      int v26 = v24[1];
      int v27 = *(v24 - 1);
      if (v26 >= v27) {
        break;
      }
      int v28 = v24 - 2;
      int v29 = *(v24 - 2);
      _DWORD *v28 = *v24;
      *(v24 - 1) = v26;
      *unint64_t v24 = v29;
      v24[1] = v27;
      v24 -= 2;
    }
    while (v28 != v23);
  }
}

uint64_t sub_100111098(std::string *a1)
{
  uint64_t v1 = *(unsigned int *)(a1->__r_.__value_.__r.__words[0] + 40);
  uint64_t v2 = (char *)a1[5].__r_.__value_.__r.__words[2];
  while (1)
  {
    uint64_t v3 = (unsigned __int8 *)v2;
    int v4 = *v2;
    if (v4 <= 114)
    {
      if (v4 == 105)
      {
        uint64_t v1 = v1 | 0x100000;
      }
      else
      {
        if (v4 != 109) {
          break;
        }
        uint64_t v1 = v1 & 0xFFFFFBFF;
      }
      goto LABEL_11;
    }
    if (v4 == 120)
    {
      uint64_t v1 = v1 | 0x800;
      goto LABEL_11;
    }
    if (v4 != 115) {
      break;
    }
    uint64_t v1 = v1 & 0xFFFFCFFF | 0x1000;
LABEL_11:
    uint64_t v2 = (char *)(v3 + 1);
    a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v3 + 1);
    if (v3 + 1 == (unsigned __int8 *)a1[5].__r_.__value_.__l.__size_)
    {
      uint64_t v5 = *(void *)a1->__r_.__value_.__l.__size_;
      do
      {
        a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)v3;
        unsigned int v6 = *v3--;
      }
      while (*(unsigned char *)(v5 + v6 + 32) != 1);
      goto LABEL_14;
    }
  }
  if (v4 == 45)
  {
    uint64_t v9 = (char *)(v3 + 1);
    a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v3 + 1);
    std::string::size_type size = (char *)a1[5].__r_.__value_.__l.__size_;
    if (v3 + 1 == (unsigned __int8 *)size)
    {
      uint64_t v15 = *(void *)a1->__r_.__value_.__l.__size_;
      do
      {
        a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)v3;
        unsigned int v16 = *v3--;
      }
      while (*(unsigned char *)(v15 + v16 + 32) != 1);
LABEL_14:
      uint64_t v7 = v3 + 1;
    }
    else
    {
      do
      {
        int v11 = *v9;
        if (v11 > 114)
        {
          if (v11 == 120)
          {
            uint64_t v1 = v1 & 0xFFFFF7FF;
          }
          else
          {
            if (v11 != 115) {
              return v1;
            }
            uint64_t v1 = v1 & 0xFFFFCFFF | 0x2000;
          }
        }
        else if (v11 == 105)
        {
          uint64_t v1 = v1 & 0xFFEFFFFF;
        }
        else
        {
          if (v11 != 109) {
            return v1;
          }
          uint64_t v1 = v1 | 0x400;
        }
        a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)++v9;
      }
      while (v9 != size);
      uint64_t v12 = *(void *)a1->__r_.__value_.__l.__size_;
      uint64_t v13 = v9 - 1;
      do
      {
        a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)v13;
        unsigned int v14 = *v13--;
      }
      while (*(unsigned char *)(v12 + v14 + 32) != 1);
      uint64_t v7 = (unsigned __int8 *)(v13 + 1);
    }
    sub_10010C68C(a1, 8, (uint64_t)&v7[-a1[5].__r_.__value_.__r.__words[0]]);
    return 0;
  }
  return v1;
}

char *sub_100111224(void *a1, uint64_t a2, int a3, unint64_t a4)
{
  uint64_t v7 = *a1;
  uint64_t v8 = *(void *)(*a1 + 352);
  unint64_t v9 = (*(void *)(*a1 + 360) - v8 + 7) & 0xFFFFFFFFFFFFFFF8;
  *(void *)(*a1 + 360) = v8 + v9;
  uint64_t v10 = a1[2];
  if (v10)
  {
    *(void *)(v10 + 8) = v9 - v10 + v8;
    uint64_t v11 = a1[2];
    uint64_t v7 = *a1;
    uint64_t v8 = *(void *)(*a1 + 352);
  }
  else
  {
    uint64_t v11 = 0;
  }
  uint64_t v12 = v11 + a4 - v8;
  uint64_t result = sub_100111408((void *)(v7 + 344), a2, a4);
  *((void *)result + 1) = a4;
  *(_DWORD *)uint64_t result = a3;
  a1[2] = *(void *)(*a1 + 352) + v12;
  return result;
}

void sub_1001112C8()
{
  std::streambuf::~streambuf();

  operator delete();
}

void *sub_100111300(void *result, uint64_t a2, uint64_t a3)
{
  result[2] = a2;
  result[3] = a2;
  result[4] = a2 + a3;
  return result;
}

double sub_100111310@<D0>(void *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  if ((a4 & 0x10) != 0)
  {
    uint64_t v7 = -1;
    goto LABEL_19;
  }
  uint64_t v5 = a1[2];
  uint64_t v6 = a1[4] - v5;
  if (!a3)
  {
    uint64_t v7 = -1;
    if (a2 < 0 || v6 < a2) {
      goto LABEL_19;
    }
    uint64_t v9 = v5 + a2;
LABEL_15:
    uint64_t v8 = a1[4];
    goto LABEL_16;
  }
  if (a3 == 1)
  {
    uint64_t v7 = -1;
    uint64_t v10 = a1[3] - v5 + a2;
    if (v10 < 0 || v10 > v6) {
      goto LABEL_19;
    }
    uint64_t v9 = a1[3] + a2;
    goto LABEL_15;
  }
  if (a3 != 2)
  {
    uint64_t v9 = a1[3];
    goto LABEL_18;
  }
  uint64_t v7 = -1;
  if ((a2 & 0x8000000000000000) == 0 && v6 >= a2)
  {
    uint64_t v8 = a1[4];
    uint64_t v9 = v8 - a2;
LABEL_16:
    a1[3] = v9;
    a1[4] = v8;
LABEL_18:
    uint64_t v7 = v9 - v5;
  }
LABEL_19:
  double result = 0.0;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(void *)(a5 + 128) = v7;
  return result;
}

double sub_1001113C0@<D0>(void *a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  if ((a3 & 0x10) == 0)
  {
    uint64_t v4 = a1[2];
    uint64_t v5 = *(void *)(a2 + 128);
    if (v5 <= a1[4] - v4)
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = a1[4];
      a1[3] = v6;
      a1[4] = v7;
    }
  }
  double result = 0.0;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(void *)(a4 + 128) = -1;
  return result;
}

char *sub_100111408(void *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = a1[2];
  if (*a1 - v6 < a3)
  {
    sub_10011148C((uint64_t)a1, v6 + a3 - a1[1]);
    uint64_t v6 = a1[2];
  }
  uint64_t v7 = (char *)(a1[1] + a2);
  memmove(&v7[a3], v7, v6 - (void)v7);
  a1[2] += a3;
  return v7;
}

void sub_10011148C(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    uint64_t v4 = *(void *)a1 - v3;
  }
  else {
    uint64_t v4 = 1024;
  }
  do
  {
    unint64_t v5 = v4;
    v4 *= 2;
  }
  while (v5 < a2);
  size_t v6 = *(void *)(a1 + 16) - v3;
  size_t v7 = (v5 + 7) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v8 = (char *)operator new(v7);
  uint64_t v9 = v8;
  uint64_t v10 = *(void **)(a1 + 8);
  if (v10) {
    memcpy(v8, *(const void **)(a1 + 8), v6);
  }
  operator delete(v10);
  *(void *)(a1 + 8) = v9;
  *(void *)(a1 + 16) = &v9[v6];
  *(void *)a1 = &v9[v7];
}

uint64_t sub_100111530(uint64_t a1, unsigned char *a2)
{
  int v2 = *a2;
  if (!*a2) {
    return 1;
  }
  uint64_t v3 = *(unsigned __int8 **)(a1 + 136);
  uint64_t v4 = a2 + 1;
  while (1)
  {
    uint64_t v5 = *v3;
    if (v2 != v5) {
      break;
    }
    *(void *)(a1 + 136) = v3 + 1;
    if (v3 + 1 == *(unsigned __int8 **)(a1 + 128))
    {
      uint64_t v10 = **(void **)(a1 + 8);
      do
      {
        *(void *)(a1 + 136) = v3;
        unsigned int v11 = *v3--;
      }
      while (*(unsigned char *)(v10 + v11 + 32) != 1);
      goto LABEL_13;
    }
    int v6 = *v4++;
    int v2 = v6;
    ++v3;
    if (!v6) {
      return 1;
    }
  }
  uint64_t v8 = **(void **)(a1 + 8);
  if (*(unsigned char *)(v8 + v5 + 32) == 1) {
    goto LABEL_14;
  }
  --v3;
  do
  {
    *(void *)(a1 + 136) = v3;
    unsigned int v9 = *v3--;
  }
  while (*(unsigned char *)(v8 + v9 + 32) != 1);
LABEL_13:
  ++v3;
LABEL_14:
  sub_10010C68C((std::string *)a1, 20, (uint64_t)&v3[-*(void *)(a1 + 120)]);
  return 0;
}

_OWORD *sub_1001115F8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 49)) {
    return (_OWORD *)sub_1001120DC(a1, a2);
  }
  else {
    return sub_100112A94(a1, a2);
  }
}

uint64_t sub_100111610(uint64_t a1)
{
  sub_10004B7F8(a1 + 64, *(void **)(a1 + 72));
  int v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  sub_10004B7F8(a1, *(void **)(a1 + 8));
  return a1;
}

char *sub_10011165C(void *a1, uint64_t a2)
{
  uint64_t v4 = (_DWORD *)a1[2];
  if (v4 && *v4 == 2)
  {
    uint64_t v5 = (char *)v4 - *(void *)(*a1 + 352);
    sub_1001131E0((uint64_t *)(*a1 + 344), 1uLL);
    int v6 = &v5[*(void *)(*a1 + 352)];
    a1[2] = v6;
    if (*((unsigned char *)a1 + 24))
    {
      uint64_t v7 = *(void *)(*(void *)a1[1] + 8);
      LOBYTE(a2) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 40))(v7, a2);
    }
    uint64_t v8 = *((unsigned int *)v6 + 4);
    v6[v8 + 24] = a2;
    *((_DWORD *)v6 + 4) = v8 + 1;
  }
  else
  {
    int v6 = (char *)sub_10010CB60(a1, 2, 0x19uLL);
    *((_DWORD *)v6 + 4) = 1;
    if (*((unsigned char *)a1 + 24))
    {
      uint64_t v9 = *(void *)(*(void *)a1[1] + 8);
      LOBYTE(a2) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 40))(v9, a2);
    }
    v6[24] = a2;
  }
  return v6;
}

uint64_t sub_100111780(std::string *a1)
{
  int v2 = &a1[5].__r_.__value_.__r.__words[2];
  uint64_t v3 = (unsigned __int8 *)a1[5].__r_.__value_.__r.__words[2];
  std::string::size_type size = (unsigned __int8 *)a1[5].__r_.__value_.__l.__size_;
  if (v3 == size)
  {
    uint64_t v13 = (uint64_t)&v3[-a1[5].__r_.__value_.__r.__words[0]];
    sub_100018888(&__p, "Escape sequence terminated prematurely.");
    sub_10010CE64(a1, 5, v13, (uint64_t)&__p);
LABEL_8:
    if (v61 < 0) {
      operator delete(__p);
    }
LABEL_10:
    LOBYTE(v7) = 0;
  }
  else
  {
    uint64_t v5 = (uint64_t *)a1->__r_.__value_.__l.__size_;
    uint64_t v6 = *v5;
    LOBYTE(v7) = 7;
    switch(*(unsigned char *)(*v5 + *v3 + 32))
    {
      case 0x11:
        int v58 = v3;
        if (sub_100110C34((uint64_t)v5, &v58, v3 + 1, 8))
        {
          uint64_t v8 = *(void *)a1->__r_.__value_.__l.__size_;
          std::string::size_type v9 = a1[5].__r_.__value_.__r.__words[2];
          uint64_t v10 = (unsigned __int8 *)(v9 - 1);
          do
          {
            std::string::size_type *v2 = (std::string::size_type)v10;
            unsigned int v11 = *v10--;
            --v9;
          }
          while (*(unsigned char *)(v8 + v11 + 32) != 12);
          uint64_t v12 = v9 - a1[5].__r_.__value_.__r.__words[0];
          sub_100018888(&__p, "Invalid octal escape sequence.");
          sub_10010CE64(a1, 5, v12, (uint64_t)&__p);
          goto LABEL_8;
        }
        uint64_t v33 = size - v3;
        if (size - v3 >= 4) {
          uint64_t v33 = 4;
        }
        unint64_t v34 = sub_100110C34(a1->__r_.__value_.__l.__size_, v2, (unsigned char *)(a1[5].__r_.__value_.__r.__words[2] + v33), 8);
        if (v34 < 0x80) {
          goto LABEL_57;
        }
        uint64_t v35 = *(void *)a1->__r_.__value_.__l.__size_;
        std::string::size_type v36 = a1[5].__r_.__value_.__r.__words[2];
        unsigned int v37 = (unsigned __int8 *)(v36 - 1);
        do
        {
          std::string::size_type *v2 = (std::string::size_type)v37;
          unsigned int v38 = *v37--;
          --v36;
        }
        while (*(unsigned char *)(v35 + v38 + 32) != 12);
        uint64_t v39 = v36 - a1[5].__r_.__value_.__r.__words[0];
        sub_100018888(&__p, "Octal escape sequence is invalid.");
        sub_10010CE64(a1, 5, v39, (uint64_t)&__p);
        goto LABEL_8;
      case 0x12:
        LOBYTE(v7) = 8;
        goto LABEL_45;
      case 0x13:
      case 0x14:
      case 0x15:
      case 0x16:
      case 0x17:
      case 0x18:
      case 0x19:
      case 0x1A:
      case 0x1B:
      case 0x24:
      case 0x25:
        goto LABEL_21;
      case 0x1C:
        goto LABEL_45;
      case 0x1D:
        LOBYTE(v7) = 12;
        goto LABEL_45;
      case 0x1E:
        LOBYTE(v7) = 10;
        goto LABEL_45;
      case 0x1F:
        LOBYTE(v7) = 13;
        goto LABEL_45;
      case 0x20:
        LOBYTE(v7) = 9;
        goto LABEL_45;
      case 0x21:
        LOBYTE(v7) = 11;
        goto LABEL_45;
      case 0x22:
        uint64_t v19 = v3 + 1;
        std::string::size_type *v2 = (std::string::size_type)(v3 + 1);
        if (v3 + 1 == size)
        {
          do
          {
            std::string::size_type *v2 = (std::string::size_type)v3;
            unsigned int v25 = *v3--;
            --v19;
          }
          while (*(unsigned char *)(v6 + v25 + 32) != 12);
          uint64_t v26 = (uint64_t)&v19[-a1[5].__r_.__value_.__r.__words[0]];
          sub_100018888(&__p, "Hexadecimal escape sequence terminated prematurely.");
          sub_10010CE64(a1, 5, v26, (uint64_t)&__p);
        }
        else if (*(unsigned char *)(v6 + *v19 + 32) == 15)
        {
          std::ios_base v20 = v3 + 2;
          std::string::size_type *v2 = (std::string::size_type)(v3 + 2);
          if (v3 + 2 == size)
          {
            do
            {
              std::string::size_type *v2 = (std::string::size_type)v19;
              unsigned int v27 = *v19--;
              --v20;
            }
            while (*(unsigned char *)(v6 + v27 + 32) != 12);
            uint64_t v28 = (uint64_t)&v20[-a1[5].__r_.__value_.__r.__words[0]];
            sub_100018888(&__p, "Missing } in hexadecimal escape sequence.");
            sub_10010CE64(a1, 5, v28, (uint64_t)&__p);
          }
          else
          {
            unint64_t v21 = sub_100110C34((uint64_t)v5, v2, size, 16);
            unint64_t v22 = (unsigned __int8 *)a1[5].__r_.__value_.__r.__words[2];
            uint64_t v23 = *(void *)a1->__r_.__value_.__l.__size_;
            if (v22 != (unsigned __int8 *)a1[5].__r_.__value_.__l.__size_)
            {
              LOBYTE(v7) = v21;
              if ((v21 & 0x8000000000000000) == 0 && v21 <= 0x7F && *(unsigned char *)(v23 + *v22 + 32) == 16)
              {
                unint64_t v24 = v22 + 1;
                goto LABEL_46;
              }
            }
            uint64_t v46 = v22 - 1;
            do
            {
              std::string::size_type *v2 = (std::string::size_type)v46;
              unsigned int v47 = *v46--;
              --v22;
            }
            while (*(unsigned char *)(v23 + v47 + 32) != 12);
            uint64_t v48 = (uint64_t)&v22[-a1[5].__r_.__value_.__r.__words[0]];
            sub_100018888(&__p, "Hexadecimal escape sequence was invalid.");
            sub_10010CE64(a1, 10, v48, (uint64_t)&__p);
          }
        }
        else
        {
          uint64_t v40 = size - v19;
          if (size - v19 >= 2) {
            uint64_t v40 = 2;
          }
          unint64_t v34 = sub_100110C34((uint64_t)v5, v2, &v19[v40], 16);
          if (v34 < 0x100)
          {
LABEL_57:
            LOBYTE(v7) = v34;
            return (char)v7;
          }
          uint64_t v41 = *(void *)a1->__r_.__value_.__l.__size_;
          std::string::size_type v42 = a1[5].__r_.__value_.__r.__words[2];
          unsigned int v43 = (unsigned __int8 *)(v42 - 1);
          do
          {
            std::string::size_type *v2 = (std::string::size_type)v43;
            unsigned int v44 = *v43--;
            --v42;
          }
          while (*(unsigned char *)(v41 + v44 + 32) != 12);
          uint64_t v45 = v42 - a1[5].__r_.__value_.__r.__words[0];
          sub_100018888(&__p, "Escape sequence did not encode a valid character.");
          sub_10010CE64(a1, 5, v45, (uint64_t)&__p);
        }
        goto LABEL_8;
      case 0x23:
        int v29 = (char *)(v3 + 1);
        std::string::size_type *v2 = (std::string::size_type)(v3 + 1);
        if (v3 + 1 != size)
        {
          unsigned int v7 = *v29 - ((*v29 + ((*v29 >> 10) & 0x1F)) & 0xFFFFFFE0);
          ++v3;
          goto LABEL_45;
        }
        do
        {
          std::string::size_type *v2 = (std::string::size_type)v3;
          unsigned int v30 = *v3--;
          --v29;
        }
        while (*(unsigned char *)(v6 + v30 + 32) != 12);
        uint64_t v31 = (uint64_t)&v29[-a1[5].__r_.__value_.__r.__words[0]];
        sub_100018888(&__p, "ASCII escape sequence terminated prematurely.");
        sub_10010CE64(a1, 5, v31, (uint64_t)&__p);
        goto LABEL_8;
      case 0x26:
        LOBYTE(v7) = 27;
        goto LABEL_45;
      default:
        if (*(unsigned char *)(*v5 + *v3 + 32) == 56)
        {
          unsigned int v14 = (char *)(v3 + 1);
          std::string::size_type *v2 = (std::string::size_type)(v3 + 1);
          if (v3 + 1 == size)
          {
            do
            {
              std::string::size_type *v2 = (std::string::size_type)v3;
              unsigned int v18 = *v3--;
              --v14;
            }
            while (*(unsigned char *)(v6 + v18 + 32) != 12);
            goto LABEL_81;
          }
          if (*(unsigned char *)(v6 + *v14 + 32) != 15)
          {
LABEL_79:
            uint64_t v55 = *v5;
            uint64_t v56 = v14 - 1;
            do
            {
              std::string::size_type *v2 = (std::string::size_type)v56;
              unsigned int v57 = *v56--;
              --v14;
            }
            while (*(unsigned char *)(v55 + v57 + 32) != 12);
LABEL_81:
            uint64_t v17 = (uint64_t)&v14[-a1[5].__r_.__value_.__r.__words[0]];
LABEL_82:
            sub_10010C68C(a1, 5, v17);
            goto LABEL_10;
          }
          while (*(unsigned char *)(v6 + *v14 + 32) != 16)
          {
            std::string::size_type *v2 = (std::string::size_type)++v14;
            if (v14 == (char *)size)
            {
              uint64_t v15 = size - 1;
              do
              {
                std::string::size_type *v2 = (std::string::size_type)v15;
                unsigned int v16 = *v15--;
                --size;
              }
              while (*(unsigned char *)(v6 + v16 + 32) != 12);
              uint64_t v17 = (uint64_t)&size[-a1[5].__r_.__value_.__r.__words[0]];
              goto LABEL_82;
            }
          }
          std::string::size_type *v2 = (std::string::size_type)(v14 + 1);
          sub_100113238(*v5, (char *)v3 + 2, v14, (uint64_t)&__p);
          char v49 = v61;
          if (v61 < 0)
          {
            if (v60)
            {
              if (v60 == 1)
              {
                p_p = __p;
                goto LABEL_71;
              }
              operator delete(__p);
              goto LABEL_78;
            }
          }
          else if (v61)
          {
            if (v61 == 1)
            {
              p_p = &__p;
LABEL_71:
              LOBYTE(v7) = *p_p;
              goto LABEL_75;
            }
LABEL_78:
            uint64_t v5 = (uint64_t *)a1->__r_.__value_.__l.__size_;
            unsigned int v14 = (char *)a1[5].__r_.__value_.__r.__words[2];
            goto LABEL_79;
          }
          uint64_t v51 = *(void *)a1->__r_.__value_.__l.__size_;
          std::string::size_type v52 = a1[5].__r_.__value_.__r.__words[2];
          unsigned int v53 = (unsigned __int8 *)(v52 - 1);
          do
          {
            std::string::size_type *v2 = (std::string::size_type)v53;
            unsigned int v54 = *v53--;
            --v52;
          }
          while (*(unsigned char *)(v51 + v54 + 32) != 12);
          sub_10010C68C(a1, 3, v52 - a1[5].__r_.__value_.__r.__words[0]);
          LOBYTE(v7) = 0;
          char v49 = v61;
LABEL_75:
          if (v49 < 0) {
            operator delete(__p);
          }
          return (char)v7;
        }
LABEL_21:
        LOBYTE(v7) = *v3;
LABEL_45:
        unint64_t v24 = v3 + 1;
LABEL_46:
        std::string::size_type *v2 = (std::string::size_type)v24;
        break;
    }
  }
  return (char)v7;
}

void sub_100111DA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100111E34(uint64_t a1)
{
  uint64_t v11 = *(void *)(a1 + 136);
  uint64_t v2 = sub_100110C34(*(void *)(a1 + 8), &v11, (unsigned char *)(v11 + 1), 10);
  if (!v2 || (*(_DWORD *)(*(void *)a1 + 40) & 0x103) == 0x100)
  {
    uint64_t v3 = sub_100111780((std::string *)a1);
    sub_10011165C((void *)a1, v3);
    return 1;
  }
  unint64_t v5 = v2;
  if (v2 > 0)
  {
    *(void *)(a1 + 136) = v11;
    uint64_t v6 = sub_10010CB60((uint64_t *)a1, 13, 0x18uLL);
    v6[4] = v5;
    *((unsigned char *)v6 + 20) = (*(_DWORD *)(*(void *)a1 + 40) & 0x100000) != 0;
    if (v5 > *(unsigned int *)(a1 + 184)) {
      *(_DWORD *)(a1 + 184) = v5;
    }
    return 1;
  }
  uint64_t v7 = **(void **)(a1 + 8);
  uint64_t v8 = *(void *)(a1 + 136);
  std::string::size_type v9 = (unsigned __int8 *)(v8 - 1);
  do
  {
    *(void *)(a1 + 136) = v9;
    unsigned int v10 = *v9--;
    --v8;
  }
  while (*(unsigned char *)(v7 + v10 + 32) != 12);
  sub_10010C68C((std::string *)a1, 6, v8 - *(void *)(a1 + 120));
  return 0;
}

uint64_t sub_100111F40(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 128);
  uint64_t v2 = *(void *)(a1 + 136);
  uint64_t v4 = (char *)(v2 + 1);
  *(void *)(a1 + 136) = v2 + 1;
  uint64_t v5 = 1;
  while (1)
  {
    if (v2 + v5 == v3) {
      goto LABEL_10;
    }
    uint64_t v6 = **(void **)(a1 + 8);
    uint64_t v7 = v5;
    while (1)
    {
      uint64_t v8 = v2 + v7 + 1;
      int v9 = *(unsigned __int8 *)(v6 + *(unsigned __int8 *)(v2 + v7) + 32);
      uint64_t v5 = v7 + 1;
      *(void *)(a1 + 136) = v8;
      if (v9 == 12) {
        break;
      }
      ++v7;
      if (v2 + v5 == v3) {
        goto LABEL_10;
      }
    }
    if (v8 == v3) {
      break;
    }
    if (*(unsigned char *)(v6 + *(unsigned __int8 *)(v2 + v7 + 1) + 32) == 47)
    {
      *(void *)(a1 + 136) = v2 + v7 + 2;
      uint64_t v5 = v7;
LABEL_10:
      uint64_t v10 = v5 - 1;
      if (v5 != 1)
      {
        do
        {
          unsigned int v11 = *v4++;
          sub_10011165C((void *)a1, v11);
          --v10;
        }
        while (v10);
      }
      return 1;
    }
  }
  uint64_t v13 = v3 - *(void *)(a1 + 120);
  sub_100018888(__p, "Unterminated \\Q...\\E sequence.");
  sub_10010CE64((std::string *)a1, 5, v13, (uint64_t)__p);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

void sub_100112060(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10011207C(unsigned int **a1, signed int a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (v3 != *a1)
  {
    unint64_t v4 = ((char *)v3 - (char *)*a1) >> 3;
    do
    {
      unint64_t v5 = v4 >> 1;
      uint64_t v6 = &v2[2 * (v4 >> 1)];
      signed int v7 = v6[1];
      uint64_t v8 = v6 + 2;
      v4 += ~(v4 >> 1);
      if (v7 < a2) {
        uint64_t v2 = v8;
      }
      else {
        unint64_t v4 = v5;
      }
    }
    while (v4);
  }
  if (v2 == v3 || v2[1] != a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *v2;
  }
}

uint64_t sub_1001120DC(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = sub_10010CB60((uint64_t *)a1, 14, 0x28uLL);
  unint64_t v5 = v4;
  uint64_t v6 = (void *)(a2 + 8);
  signed int v7 = *(void **)a2;
  if (*(void *)a2 == a2 + 8)
  {
    int v8 = 0;
  }
  else
  {
    int v8 = 0;
    int v9 = *(void **)a2;
    do
    {
      uint64_t v10 = (void *)v9[1];
      if (v10)
      {
        do
        {
          unsigned int v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          unsigned int v11 = (void *)v9[2];
          BOOL v12 = *v11 == (void)v9;
          int v9 = v11;
        }
        while (!v12);
      }
      ++v8;
      int v9 = v11;
    }
    while (v11 != v6);
  }
  v4[4] = v8;
  uint64_t v13 = *(std::string::value_type **)(a2 + 24);
  unsigned int v14 = *(std::string::value_type **)(a2 + 32);
  v4[5] = ((unint64_t)(v14 - v13) >> 2) & 0x7FFFFFFF;
  char v15 = *(void **)(a2 + 64);
  unsigned int v16 = (void *)(a2 + 72);
  if (v15 == (void *)(a2 + 72))
  {
    int v17 = 0;
  }
  else
  {
    int v17 = 0;
    do
    {
      unsigned int v18 = (void *)v15[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          unsigned int v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v15[2];
          BOOL v12 = *v19 == (void)v15;
          char v15 = v19;
        }
        while (!v12);
      }
      ++v17;
      char v15 = v19;
    }
    while (v19 != v16);
  }
  v4[6] = v17;
  int v20 = *(_DWORD *)(a2 + 52);
  v4[7] = v20;
  int v21 = *(_DWORD *)(a2 + 56);
  v4[8] = v21;
  uint64_t v22 = *(void *)a1;
  if ((*(unsigned char *)(*(void *)a1 + 42) & 0x10) != 0)
  {
    int v23 = *(_DWORD *)(a1 + 88);
    if ((v23 & ~v20) == 0 || (*(_DWORD *)(a1 + 92) & ~v20) == 0) {
      v4[7] = *(_DWORD *)(a1 + 96) | v20;
    }
    if ((v23 & ~v21) == 0 || (*(_DWORD *)(a1 + 92) & ~v21) == 0) {
      v4[8] = *(_DWORD *)(a1 + 96) | v21;
    }
  }
  *((unsigned char *)v4 + 36) = *(unsigned char *)(a2 + 48);
  *((unsigned char *)v4 + 37) = *(unsigned char *)(a2 + 49) ^ 1;
  uint64_t v86 = *(void *)(v22 + 352);
  uint64_t v88 = a2;
  if (v7 != v6)
  {
    do
    {
      if (*((unsigned char *)v7 + 25))
      {
        if (*((unsigned char *)v7 + 26)) {
          unint64_t v24 = 3;
        }
        else {
          unint64_t v24 = 2;
        }
      }
      else
      {
        unint64_t v24 = 1;
      }
      unsigned int v25 = (unsigned char *)sub_1001131E0((uint64_t *)(*(void *)a1 + 344), v24);
      char v26 = *((unsigned char *)v7 + 25);
      if (*(unsigned char *)(a1 + 24)) {
        char v26 = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 8) + 8) + 40))(*(void *)(**(void **)(a1 + 8) + 8), v26);
      }
      unsigned char *v25 = v26;
      if (*((unsigned char *)v7 + 25))
      {
        char v27 = *((unsigned char *)v7 + 26);
        if (v27)
        {
          if (*(unsigned char *)(a1 + 24)) {
            char v27 = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 8) + 8) + 40))(*(void *)(**(void **)(a1 + 8) + 8), v27);
          }
          v25[1] = v27;
          v25 += 2;
        }
        else
        {
          ++v25;
        }
      }
      unsigned char *v25 = 0;
      uint64_t v28 = (void *)v7[1];
      if (v28)
      {
        do
        {
          int v29 = v28;
          uint64_t v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          int v29 = (void *)v7[2];
          BOOL v12 = *v29 == (void)v7;
          signed int v7 = v29;
        }
        while (!v12);
      }
      signed int v7 = v29;
    }
    while (v29 != v6);
    uint64_t v13 = *(std::string::value_type **)(a2 + 24);
    unsigned int v14 = *(std::string::value_type **)(a2 + 32);
  }
  int v87 = v5;
  if (v13 == v14)
  {
LABEL_137:
    uint64_t v74 = *(void **)(v88 + 64);
    if (v74 != v16)
    {
      do
      {
        memset(&v94, 0, sizeof(v94));
        unsigned __int8 v75 = *((unsigned char *)v74 + 26);
        unsigned int v76 = (char *)v74 + 25;
        if (v75)
        {
          v95.__r_.__value_.__s.__data_[0] = *v76;
          *(_WORD *)((char *)&v95.__r_.__value_.__l.__data_ + 1) = v75;
          sub_100101264(**(void **)(a1 + 8), (std::string::value_type *)&v95, &v95.__r_.__value_.__s.__data_[2], (uint64_t *)&__p);
        }
        else
        {
          sub_100101264(**(void **)(a1 + 8), v76, (std::string::value_type *)v74 + 26, (uint64_t *)&__p);
          if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v94.__r_.__value_.__l.__data_);
          }
        }
        std::string v94 = __p;
        std::string::size_type v77 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        char v78 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::size_type size = v94.__r_.__value_.__l.__size_;
          if (!v94.__r_.__value_.__l.__size_) {
            goto LABEL_164;
          }
        }
        else
        {
          if (!*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
            return 0;
          }
          std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        uint64_t v80 = (unsigned char *)sub_1001131E0((uint64_t *)(*(void *)a1 + 344), size + 1);
        int v81 = v80;
        if (v78 < 0) {
          std::string::size_type v77 = v94.__r_.__value_.__l.__size_;
        }
        if (v77)
        {
          if (v78 >= 0) {
            BOOL v82 = &v94;
          }
          else {
            BOOL v82 = (std::string *)v94.__r_.__value_.__r.__words[0];
          }
          memmove(v80, v82, v77);
        }
        v81[v77] = 0;
        uint64_t v83 = (void *)v74[1];
        if (v83)
        {
          do
          {
            int v84 = v83;
            uint64_t v83 = (void *)*v83;
          }
          while (v83);
        }
        else
        {
          do
          {
            int v84 = (void *)v74[2];
            BOOL v12 = *v84 == (void)v74;
            uint64_t v74 = v84;
          }
          while (!v12);
        }
        if (v78 < 0) {
          operator delete(v94.__r_.__value_.__l.__data_);
        }
        uint64_t v74 = v84;
      }
      while (v84 != v16);
    }
    uint64_t result = (uint64_t)v87 + *(void *)(*(void *)a1 + 352) - v86;
    *(void *)(a1 + 16) = result;
    return result;
  }
  unsigned int v30 = v13 + 3;
  uint64_t v92 = v14;
  while (1)
  {
    uint64_t v32 = v30 - 3;
    std::string::value_type v31 = *(v30 - 3);
    std::string::value_type v33 = *(v30 - 2);
    if (*(unsigned char *)(a1 + 24)
      && (uint64_t v34 = *(void *)(**(void **)(a1 + 8) + 8),
          std::string::value_type v31 = (*(uint64_t (**)(uint64_t, void))(*(void *)v34 + 40))(v34, v31),
          *(unsigned char *)(a1 + 24)))
    {
      uint64_t v35 = *(void *)(**(void **)(a1 + 8) + 8);
      std::string::value_type v33 = (*(uint64_t (**)(uint64_t, void))(*(void *)v35 + 40))(v35, v33);
      std::string::value_type v36 = *(v30 - 1);
      std::string::value_type v37 = *v30;
      if (*(unsigned char *)(a1 + 24))
      {
        uint64_t v38 = *(void *)(**(void **)(a1 + 8) + 8);
        std::string::value_type v36 = (*(uint64_t (**)(uint64_t, void))(*(void *)v38 + 40))(v38, v36);
        if (*(unsigned char *)(a1 + 24))
        {
          uint64_t v39 = *(void *)(**(void **)(a1 + 8) + 8);
          std::string::value_type v37 = (*(uint64_t (**)(uint64_t, void))(*(void *)v39 + 40))(v39, v37);
        }
      }
    }
    else
    {
      std::string::value_type v36 = *(v30 - 1);
      std::string::value_type v37 = *v30;
    }
    memset(&v94, 0, sizeof(v94));
    memset(&__p, 0, sizeof(__p));
    if ((*(unsigned char *)(*(void *)a1 + 42) & 0x20) == 0)
    {
      if (v33)
      {
        v40.__i_ = (std::__wrap_iter<const char *>::iterator_type)&v94;
        std::string::insert(&v94, v40, v31);
        std::string::size_type v41 = HIBYTE(v94.__r_.__value_.__r.__words[2]);
        std::string::size_type v42 = &v94;
        if ((v94.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        {
          std::string::size_type v41 = v94.__r_.__value_.__l.__size_;
          std::string::size_type v42 = (std::string *)v94.__r_.__value_.__r.__words[0];
        }
        v43.__i_ = (char *)v42 + v41;
        std::string::insert(&v94, v43, v33);
      }
      else
      {
        v91 &= 0xFFFFFFFFFFFF0000;
        v94.__r_.__value_.__r.__words[0] = v91 & 0xFFFFFFFFFFFFFF00 | v31;
        *((unsigned char *)&v94.__r_.__value_.__s + 23) = 1;
      }
      std::string::size_type v44 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v44 = __p.__r_.__value_.__l.__size_;
      }
      v46.__i_ = (char *)p_p + v44;
      if (v37)
      {
        std::string::insert(&__p, v46, v36);
        std::string::size_type v47 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v48 = &__p;
        }
        else {
          uint64_t v48 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v47 = __p.__r_.__value_.__l.__size_;
        }
        v49.__i_ = (char *)v48 + v47;
        std::string::insert(&__p, v49, v37);
      }
      else
      {
        std::string::insert(&__p, v46, v36);
      }
      goto LABEL_92;
    }
    sub_10010108C(**(void **)(a1 + 8), &v95);
    if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v94.__r_.__value_.__l.__data_);
    }
    std::string v94 = v95;
    sub_10010108C(**(void **)(a1 + 8), &v95);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v95;
    if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0)
    {
      if (!v94.__r_.__value_.__l.__size_)
      {
        operator delete(v94.__r_.__value_.__l.__data_);
LABEL_85:
        v90 &= 0xFFFFFFFFFFFF0000;
        v94.__r_.__value_.__r.__words[0] = v90;
        v94.__r_.__value_.__l.__size_ = v95.__r_.__value_.__r.__words[0];
        *(std::string::size_type *)((char *)&v94.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v95.__r_.__value_.__r.__words + 7);
        *((unsigned char *)&v94.__r_.__value_.__s + 23) = 1;
      }
    }
    else if (!*((unsigned char *)&v94.__r_.__value_.__s + 23))
    {
      goto LABEL_85;
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      if (__p.__r_.__value_.__l.__size_) {
        goto LABEL_92;
      }
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    else if (*((unsigned char *)&__p.__r_.__value_.__s + 23))
    {
      goto LABEL_92;
    }
    v89 &= 0xFFFFFFFFFFFF0000;
    __p.__r_.__value_.__r.__words[0] = v89;
    __p.__r_.__value_.__l.__size_ = v95.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v95.__r_.__value_.__r.__words + 7);
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 1;
LABEL_92:
    char v50 = HIBYTE(v94.__r_.__value_.__r.__words[2]);
    int v51 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    std::string::size_type v52 = (void *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v53 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v53 = __p.__r_.__value_.__l.__size_;
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned int v54 = &__p;
    }
    else {
      unsigned int v54 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((v94.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v55 = HIBYTE(v94.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v55 = v94.__r_.__value_.__l.__size_;
    }
    if ((v94.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v56 = &v94;
    }
    else {
      uint64_t v56 = (std::string *)v94.__r_.__value_.__r.__words[0];
    }
    if (v55 >= v53) {
      size_t v57 = v53;
    }
    else {
      size_t v57 = v55;
    }
    int v58 = memcmp(v54, v56, v57);
    BOOL v59 = v53 < v55;
    if (v58) {
      BOOL v59 = v58 < 0;
    }
    if (v59) {
      break;
    }
    uint64_t v60 = (unsigned char *)sub_1001131E0((uint64_t *)(*(void *)a1 + 344), v55 + v53 + 2);
    char v61 = v60;
    std::string::size_type v62 = HIBYTE(v94.__r_.__value_.__r.__words[2]);
    char v63 = HIBYTE(v94.__r_.__value_.__r.__words[2]);
    std::string::size_type v64 = v94.__r_.__value_.__l.__size_;
    if ((v94.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v65 = HIBYTE(v94.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v65 = v94.__r_.__value_.__l.__size_;
    }
    if (v65)
    {
      if ((v94.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v66 = &v94;
      }
      else {
        uint64_t v66 = (std::string *)v94.__r_.__value_.__r.__words[0];
      }
      memmove(v60, v66, v65);
      std::string::size_type v62 = HIBYTE(v94.__r_.__value_.__r.__words[2]);
      std::string::size_type v64 = v94.__r_.__value_.__l.__size_;
      char v63 = HIBYTE(v94.__r_.__value_.__r.__words[2]);
    }
    if (v63 < 0) {
      std::string::size_type v62 = v64;
    }
    v61[v62] = 0;
    std::string::size_type v67 = HIBYTE(v94.__r_.__value_.__r.__words[2]);
    if ((v94.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v67 = v94.__r_.__value_.__l.__size_;
    }
    unint64_t v68 = &v61[v67 + 1];
    std::string::size_type v69 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    char v70 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    std::string::size_type v71 = __p.__r_.__value_.__l.__size_;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v72 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v72 = __p.__r_.__value_.__l.__size_;
    }
    if (v72)
    {
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unsigned int v73 = &__p;
      }
      else {
        unsigned int v73 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v68, v73, v72);
      std::string::size_type v69 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      std::string::size_type v71 = __p.__r_.__value_.__l.__size_;
      char v70 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    if (v70 < 0) {
      std::string::size_type v69 = v71;
    }
    v68[v69] = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v94.__r_.__value_.__l.__data_);
    }
    v30 += 4;
    if (v32 + 4 == v92) {
      goto LABEL_137;
    }
  }
  if (v51 < 0)
  {
    operator delete(v52);
    if ((*((unsigned char *)&v94.__r_.__value_.__s + 23) & 0x80) != 0) {
LABEL_164:
    }
      operator delete(v94.__r_.__value_.__l.__data_);
  }
  else if (v50 < 0)
  {
    goto LABEL_164;
  }
  return 0;
}

void sub_100112A28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  _Unwind_Resume(exception_object);
}

_OWORD *sub_100112A94(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = sub_10010CB60((uint64_t *)a1, 15, 0x110uLL);
  int v67 = *(unsigned __int8 *)(a2 + 48);
  v4[1] = 0u;
  char v70 = v4 + 1;
  v4[15] = 0u;
  v4[16] = 0u;
  v4[13] = 0u;
  v4[14] = 0u;
  v4[11] = 0u;
  v4[12] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  v4[5] = 0u;
  v4[6] = 0u;
  v4[3] = 0u;
  v4[4] = 0u;
  std::string::size_type v71 = v4;
  void v4[2] = 0u;
  unint64_t v5 = *(void **)a2;
  if (*(void *)a2 != a2 + 8)
  {
    uint64_t v6 = v4 + 1;
    do
    {
      for (uint64_t i = 0; i != 256; ++i)
      {
        if (*(unsigned char *)(a1 + 24))
        {
          uint64_t v8 = *(void *)(**(void **)(a1 + 8) + 8);
          char v9 = (*(uint64_t (**)(uint64_t, void))(*(void *)v8 + 40))(v8, (char)i);
          char v10 = *((unsigned char *)v5 + 25);
          if (*(unsigned char *)(a1 + 24)) {
            char v10 = (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 8) + 8) + 40))(*(void *)(**(void **)(a1 + 8) + 8), v10);
          }
        }
        else
        {
          char v10 = *((unsigned char *)v5 + 25);
          char v9 = i;
        }
        if (v9 == v10) {
          *((unsigned char *)v6 + i) = 1;
        }
      }
      unsigned int v11 = (void *)v5[1];
      if (v11)
      {
        do
        {
          BOOL v12 = v11;
          unsigned int v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          BOOL v12 = (void *)v5[2];
          BOOL v13 = *v12 == (void)v5;
          unint64_t v5 = v12;
        }
        while (!v13);
      }
      unint64_t v5 = v12;
    }
    while (v12 != (void *)(a2 + 8));
  }
  char v15 = *(unsigned __int8 **)(a2 + 24);
  unsigned int v14 = *(unsigned __int8 **)(a2 + 32);
  uint64_t v68 = a2;
  if (v15 == v14)
  {
LABEL_84:
    int v45 = *(_DWORD *)(a2 + 52);
    int v46 = *(_DWORD *)(*(void *)a1 + 40);
    if ((v46 & 0x100000) != 0 && ((*(_DWORD *)(a1 + 88) & ~v45) == 0 || (*(_DWORD *)(a1 + 92) & ~v45) == 0)) {
      v45 |= *(_DWORD *)(a1 + 96);
    }
    if (v45)
    {
      for (uint64_t j = 0; j != 256; ++j)
      {
        if (sub_1000FE014(*(void *)(a1 + 8), (char)j, v45)) {
          *((unsigned char *)v71 + j + 16) = 1;
        }
      }
      int v46 = *(_DWORD *)(*(void *)a1 + 40);
    }
    int v48 = *(_DWORD *)(a2 + 56);
    if ((v46 & 0x100000) != 0 && ((*(_DWORD *)(a1 + 88) & ~v48) == 0 || (*(_DWORD *)(a1 + 92) & ~v48) == 0)) {
      v48 |= *(_DWORD *)(a1 + 96);
    }
    if (v48)
    {
      for (uint64_t k = 0; k != 256; ++k)
      {
        if (!sub_1000FE014(*(void *)(a1 + 8), (char)k, v48)) {
          *((unsigned char *)v71 + k + 16) = 1;
        }
      }
    }
    char v50 = *(std::string::value_type **)(a2 + 64);
    if (v50 != (std::string::value_type *)(a2 + 72))
    {
      do
      {
        memset(&v74, 0, sizeof(v74));
        sub_100101264(**(void **)(a1 + 8), v50 + 25, v50 + 26, (uint64_t *)&__p);
        if (SHIBYTE(v74.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v74.__r_.__value_.__l.__data_);
        }
        std::string v74 = __p;
        char v51 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::size_type size = v74.__r_.__value_.__l.__size_;
          if (!v74.__r_.__value_.__l.__size_) {
            goto LABEL_146;
          }
        }
        else
        {
          if (!*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
            return 0;
          }
          std::string::size_type size = v74.__r_.__value_.__l.__size_;
        }
        uint64_t v53 = 0;
        uint64_t v54 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v55 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v55 = size;
        }
        uint64_t v56 = (const void *)v74.__r_.__value_.__r.__words[0];
        do
        {
          LOWORD(v72.__r_.__value_.__l.__data_) = v53;
          sub_100101264(**(void **)(a1 + 8), (std::string::value_type *)&v72, &v72.__r_.__value_.__s.__data_[1], (uint64_t *)&__p);
          std::string::size_type v57 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          int v58 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v57 = __p.__r_.__value_.__l.__size_;
          }
          if (v55 == v57)
          {
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              p_p = &__p;
            }
            else {
              p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            if (v51 < 0)
            {
              if (!memcmp(v56, p_p, size)) {
LABEL_126:
              }
                *((unsigned char *)v71 + v53 + 16) = 1;
            }
            else
            {
              uint64_t v60 = &v74;
              uint64_t v61 = v54;
              while (v60->__r_.__value_.__s.__data_[0] == p_p->__r_.__value_.__s.__data_[0])
              {
                uint64_t v60 = (std::string *)((char *)v60 + 1);
                p_p = (std::string *)((char *)p_p + 1);
                if (!--v61) {
                  goto LABEL_126;
                }
              }
            }
          }
          if (v58 < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          ++v53;
        }
        while (v53 != 256);
        std::string::size_type v62 = (std::string::value_type *)*((void *)v50 + 1);
        char v63 = v50;
        if (v62)
        {
          do
          {
            char v50 = v62;
            std::string::size_type v62 = *(std::string::value_type **)v62;
          }
          while (v62);
        }
        else
        {
          do
          {
            char v50 = (std::string::value_type *)*((void *)v63 + 2);
            BOOL v13 = *(void *)v50 == (void)v63;
            char v63 = v50;
          }
          while (!v13);
        }
        if (v51 < 0) {
          operator delete(v74.__r_.__value_.__l.__data_);
        }
      }
      while (v50 != (std::string::value_type *)(v68 + 72));
    }
    if (!v67) {
      return v71;
    }
    uint64_t v64 = 1;
    v65.i64[0] = 0x101010101010101;
    v65.i64[1] = 0x101010101010101;
    uint64_t result = v71;
    do
    {
      v71[v64] = vandq_s8(vceqzq_s8((int8x16_t)v71[v64]), v65);
      ++v64;
    }
    while (v64 != 17);
    return result;
  }
  std::string::size_type v69 = *(unsigned __int8 **)(a2 + 32);
  while (1)
  {
    unsigned __int8 v16 = *v15;
    if (*(unsigned char *)(a1 + 24))
    {
      uint64_t v17 = *(void *)(**(void **)(a1 + 8) + 8);
      unsigned __int8 v16 = (*(uint64_t (**)(uint64_t, void))(*(void *)v17 + 40))(v17, (char)v16);
      unsigned __int8 v18 = v15[2];
      if (*(unsigned char *)(a1 + 24))
      {
        uint64_t v19 = *(void *)(**(void **)(a1 + 8) + 8);
        unsigned __int8 v18 = (*(uint64_t (**)(uint64_t, void))(*(void *)v19 + 40))(v19, (char)v18);
      }
    }
    else
    {
      unsigned __int8 v18 = v15[2];
    }
    if ((*(unsigned char *)(*(void *)a1 + 42) & 0x20) != 0) {
      break;
    }
    if (v18 < v16) {
      return 0;
    }
    memset((char *)v70 + v16, 1, (v18 - v16) + 1);
LABEL_83:
    v15 += 4;
    if (v15 == v14) {
      goto LABEL_84;
    }
  }
  unsigned __int8 v75 = v16;
  char v76 = 0;
  sub_10010108C(**(void **)(a1 + 8), &v74);
  unsigned __int8 v75 = v18;
  sub_10010108C(**(void **)(a1 + 8), &__p);
  char v20 = HIBYTE(v74.__r_.__value_.__r.__words[2]);
  int v21 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  uint64_t v22 = (void *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v23 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v23 = __p.__r_.__value_.__l.__size_;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v24 = &__p;
  }
  else {
    unint64_t v24 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((v74.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v25 = HIBYTE(v74.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v25 = v74.__r_.__value_.__l.__size_;
  }
  if ((v74.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v26 = &v74;
  }
  else {
    char v26 = (std::string *)v74.__r_.__value_.__r.__words[0];
  }
  if (v25 >= v23) {
    size_t v27 = v23;
  }
  else {
    size_t v27 = v25;
  }
  int v28 = memcmp(v24, v26, v27);
  BOOL v29 = v23 < v25;
  if (v28) {
    BOOL v29 = v28 < 0;
  }
  if (!v29)
  {
    for (uint64_t m = 0; m != 256; ++m)
    {
      unsigned __int8 v75 = m;
      sub_10010108C(**(void **)(a1 + 8), &v72);
      int v31 = SHIBYTE(v72.__r_.__value_.__r.__words[2]);
      uint64_t v32 = (void *)v72.__r_.__value_.__r.__words[0];
      if ((v72.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v33 = HIBYTE(v72.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v33 = v72.__r_.__value_.__l.__size_;
      }
      if ((v72.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v34 = &v72;
      }
      else {
        uint64_t v34 = (std::string *)v72.__r_.__value_.__r.__words[0];
      }
      if ((v74.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v35 = HIBYTE(v74.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v35 = v74.__r_.__value_.__l.__size_;
      }
      if ((v74.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::value_type v36 = &v74;
      }
      else {
        std::string::value_type v36 = (std::string *)v74.__r_.__value_.__r.__words[0];
      }
      if (v35 >= v33) {
        size_t v37 = v33;
      }
      else {
        size_t v37 = v35;
      }
      int v38 = memcmp(v34, v36, v37);
      BOOL v39 = v33 >= v35;
      if (v38) {
        BOOL v39 = v38 >= 0;
      }
      if (v39)
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v40 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v40 = __p.__r_.__value_.__l.__size_;
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v41 = &__p;
        }
        else {
          std::string::size_type v41 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if (v33 >= v40) {
          size_t v42 = v40;
        }
        else {
          size_t v42 = v33;
        }
        int v43 = memcmp(v41, v34, v42);
        BOOL v44 = v40 >= v33;
        if (v43) {
          BOOL v44 = v43 >= 0;
        }
        if (v44) {
          *((unsigned char *)v71 + m + 16) = 1;
        }
      }
      if (v31 < 0) {
        operator delete(v32);
      }
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    unsigned int v14 = v69;
    if (SHIBYTE(v74.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v74.__r_.__value_.__l.__data_);
    }
    goto LABEL_83;
  }
  if (v21 < 0)
  {
    operator delete(v22);
    char v20 = HIBYTE(v74.__r_.__value_.__r.__words[2]);
  }
  if (v20 < 0) {
LABEL_146:
  }
    operator delete(v74.__r_.__value_.__l.__data_);
  return 0;
}

void sub_100113194(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001131E0(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t result = a1[2];
  if (v4 - result < a2)
  {
    sub_10011148C((uint64_t)a1, result + a2 - a1[1]);
    uint64_t result = a1[2];
  }
  a1[2] = result + a2;
  return result;
}

void sub_100113238(uint64_t a1@<X0>, char *a2@<X1>, char *a3@<X2>, uint64_t a4@<X8>)
{
  if (!*(void *)(a1 + 352))
  {
    unint64_t v9 = a3 - a2;
    goto LABEL_8;
  }
  uint64_t v8 = a1 + 336;
  unint64_t v9 = a3 - a2;
  sub_10004E7CC(__p, a2, a3, a3 - a2);
  uint64_t v10 = sub_100015244(v8, (const void **)__p);
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[0]);
  }
  if (a1 + 344 == v10)
  {
LABEL_8:
    sub_10004E7CC(__p, a2, a3, v9);
    sub_1001133D8((size_t)__p, (uint64_t)&v16);
    if (SHIBYTE(v19) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v19 = v17;
    *(_OWORD *)std::string __p = v16;
    char v12 = HIBYTE(v17);
    if (SHIBYTE(v17) < 0)
    {
      unint64_t v13 = (unint64_t)__p[1];
      if (__p[1])
      {
        unsigned int v14 = (char *)__p[0];
LABEL_15:
        sub_10004E7CC((void *)a4, v14, &v14[v13], v13);
        if ((v19 & 0x8000000000000000) == 0) {
          return;
        }
LABEL_22:
        operator delete(__p[0]);
        return;
      }
    }
    else if (HIBYTE(v17))
    {
      unint64_t v13 = HIBYTE(v17);
      unsigned int v14 = (char *)__p;
      goto LABEL_15;
    }
    if (v9 == 1)
    {
      unsigned __int8 v15 = *a2;
      *(unsigned char *)(a4 + 23) = 1;
      *(_WORD *)a4 = v15;
      if ((v12 & 0x80) == 0) {
        return;
      }
    }
    else
    {
      *(void *)a4 = 0;
      *(void *)(a4 + 8) = 0;
      *(void *)(a4 + 16) = 0;
      if ((v12 & 0x80) == 0) {
        return;
      }
    }
    goto LABEL_22;
  }
  if (*(char *)(v10 + 79) < 0)
  {
    sub_1000173FC((unsigned char *)a4, *(void **)(v10 + 56), *(void *)(v10 + 64));
  }
  else
  {
    long long v11 = *(_OWORD *)(v10 + 56);
    *(void *)(a4 + 16) = *(void *)(v10 + 72);
    *(_OWORD *)a4 = v11;
  }
}

void sub_1001133B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

size_t sub_1001133D8@<X0>(size_t result@<X0>, uint64_t a2@<X8>)
{
  size_t v2 = result;
  uint64_t v4 = off_1001D76B8[0];
  if (*off_1001D76B8[0])
  {
    int v5 = 0;
    uint64_t v6 = *(unsigned __int8 *)(result + 23);
    size_t v8 = *(void *)result;
    uint64_t v7 = *(void *)(result + 8);
    do
    {
      uint64_t result = strlen(v4);
      size_t v9 = result;
      if ((v6 & 0x80) != 0)
      {
        if (result == v7)
        {
          uint64_t result = v8;
          if (v7 == -1) {
            sub_1000983B4();
          }
LABEL_8:
          uint64_t result = memcmp((const void *)result, v4, v9);
          if (!result)
          {
            *(unsigned char *)(a2 + 23) = 1;
            *(unsigned char *)a2 = v5;
            *(unsigned char *)(a2 + 1) = 0;
            return result;
          }
        }
      }
      else
      {
        uint64_t result = v2;
        if (v9 == v6) {
          goto LABEL_8;
        }
      }
      uint64_t v4 = off_1001D76B8[++v5];
    }
    while (*v4);
  }
  uint64_t v10 = off_1001D7AC0[0];
  if (!*off_1001D7AC0[0])
  {
LABEL_19:
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    return result;
  }
  uint64_t v11 = *(unsigned __int8 *)(v2 + 23);
  int v12 = 1;
  size_t v14 = *(void *)v2;
  uint64_t v13 = *(void *)(v2 + 8);
  while (1)
  {
    uint64_t result = strlen(v10);
    size_t v15 = result;
    if ((v11 & 0x80) == 0) {
      break;
    }
    if (result == v13)
    {
      uint64_t result = v14;
      if (v13 == -1) {
        sub_1000983B4();
      }
      goto LABEL_17;
    }
LABEL_18:
    uint64_t v10 = off_1001D7AC0[v12++];
    if (!*v10) {
      goto LABEL_19;
    }
  }
  uint64_t result = v2;
  if (v15 != v11) {
    goto LABEL_18;
  }
LABEL_17:
  uint64_t result = memcmp((const void *)result, v10, v15);
  if (result) {
    goto LABEL_18;
  }

  return (size_t)sub_100018888((void *)a2, v10);
}

void sub_100113568(uint64_t a1, uint64_t a2)
{
  sub_100113C34((std::string *)a1, a2, (uint64_t)&v15);
  int v5 = *(unsigned __int8 **)(a1 + 128);
  uint64_t v4 = *(unsigned __int8 **)(a1 + 136);
  if (v5 == v4) {
    goto LABEL_9;
  }
  uint64_t v6 = **(void **)(a1 + 8);
  if (*(unsigned char *)(v6 + *v4 + 32) == 14)
  {
    *(void *)(a1 + 136) = v4 + 1;
    if (v5 != v4 + 1)
    {
      if (*(unsigned char *)(v6 + v4[1] + 32) == 10)
      {
        *(void *)(a1 + 136) = v4;
        goto LABEL_6;
      }
      sub_100113C34((std::string *)a1, a2, (uint64_t)v14);
      sub_100113EE4(a2, (char *)&v15, v14);
      uint64_t v10 = *(unsigned __int8 **)(a1 + 136);
      uint64_t v11 = **(void **)(a1 + 8);
      if (*(unsigned char *)(v11 + *v10 + 32) != 14) {
        return;
      }
      int v12 = *(unsigned __int8 **)(a1 + 128);
      uint64_t v13 = v10 + 1;
      *(void *)(a1 + 136) = v10 + 1;
      if (v12 != v10 + 1)
      {
        if (*(unsigned char *)(v11 + *v13 + 32) == 10)
        {
          *(void *)(a1 + 136) = v10;
          return;
        }
        uint64_t v7 = (uint64_t)&v13[-*(void *)(a1 + 120)];
        size_t v8 = (std::string *)a1;
        int v9 = 11;
        goto LABEL_11;
      }
      uint64_t v7 = (uint64_t)&v12[-*(void *)(a1 + 120)];
LABEL_10:
      size_t v8 = (std::string *)a1;
      int v9 = 7;
LABEL_11:
      sub_10010C68C(v8, v9, v7);
      return;
    }
LABEL_9:
    uint64_t v7 = (uint64_t)&v5[-*(void *)(a1 + 120)];
    goto LABEL_10;
  }
LABEL_6:
  sub_100114144((uint64_t **)a2, (char *)&v15, &v15);
  if (HIBYTE(v15)) {
    *(unsigned char *)(a2 + 49) = 1;
  }
  *(unsigned char *)(a2 + 60) = 0;
}

BOOL sub_1001136B8(std::string *a1, uint64_t a2)
{
  std::string::size_type size = (unsigned __int8 *)a1[5].__r_.__value_.__l.__size_;
  std::string::size_type v4 = a1[5].__r_.__value_.__r.__words[2];
  a1[5].__r_.__value_.__r.__words[2] = v4 + 1;
  if (size == (unsigned __int8 *)(v4 + 1))
  {
    uint64_t v9 = (uint64_t)&size[-a1[5].__r_.__value_.__r.__words[0]];
    sub_100018888(&__p, "Character class declaration starting with [ terminated prematurely - either no ] was found or the set had no content.");
    sub_10010CE64(a1, 7, v9, (uint64_t)&__p);
    goto LABEL_6;
  }
  uint64_t v6 = (uint64_t *)a1->__r_.__value_.__l.__size_;
  uint64_t v7 = *v6;
  int v8 = *(unsigned __int8 *)(*v6 + *(unsigned __int8 *)(v4 + 1) + 32);
  if (v8 == 37)
  {
    uint64_t v11 = (char *)(v4 + 2);
    a1[5].__r_.__value_.__r.__words[2] = v4 + 2;
    if (size == (unsigned __int8 *)(v4 + 2)) {
      goto LABEL_25;
    }
    a1[5].__r_.__value_.__r.__words[2] = v4 + 3;
    if (size == (unsigned __int8 *)(v4 + 3)) {
      goto LABEL_25;
    }
    int v12 = (char *)&__p + 1;
    uint64_t v13 = (unsigned __int8 *)(v4 + 4);
    std::string::size_type v14 = -4 - v4;
    while (1)
    {
      int v15 = *(unsigned __int8 *)(v7 + *(v13 - 1) + 32);
      a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)v13;
      if (v15 == 37) {
        break;
      }
      --v14;
      BOOL v28 = v13++ == size;
      if (v28) {
        goto LABEL_25;
      }
    }
    if (v13 == size || *(unsigned char *)(v7 + *v13 + 32) != 10)
    {
      uint64_t v22 = -(uint64_t)v14 - a1[5].__r_.__value_.__r.__words[0];
      sub_100018888(&__p, "Character class declaration starting with [ terminated prematurely - either no ] was found or the set had no content.");
      sub_10010CE64(a1, 7, v22, (uint64_t)&__p);
      goto LABEL_6;
    }
    sub_100113238(*v6, v11, (char *)v13 - 1, (uint64_t)&__p);
    if ((char)v39 < 0)
    {
      if (v38 - 3 >= 0xFFFFFFFFFFFFFFFELL)
      {
        char v36 = 0;
        char v35 = *(unsigned char *)__p;
        if (v38 <= 1)
        {
LABEL_59:
          char v36 = 0;
          goto LABEL_60;
        }
        int v12 = (char *)__p + 1;
LABEL_58:
        char v36 = *v12;
LABEL_60:
        sub_100114230(a2, &v35);
        char v27 = 0;
        ++a1[5].__r_.__value_.__r.__words[2];
LABEL_61:
        if ((char)v39 < 0) {
          operator delete(__p);
        }
        return (v27 & 1) == 0;
      }
    }
    else if (v39 - 3 > 0xFFFFFFFD)
    {
      char v36 = 0;
      char v35 = (char)__p;
      if (v39 <= 1u) {
        goto LABEL_59;
      }
      goto LABEL_58;
    }
    sub_10010C68C(a1, 3, (uint64_t)&v11[-a1[5].__r_.__value_.__r.__words[0]]);
    char v27 = 1;
    goto LABEL_61;
  }
  if (v8 == 36 && (*(_DWORD *)(a1->__r_.__value_.__r.__words[0] + 40) & 0x103) != 0x101)
  {
    long long v16 = (char *)(v4 + 2);
    a1[5].__r_.__value_.__r.__words[2] = v4 + 2;
    if (size != (unsigned __int8 *)(v4 + 2))
    {
      uint64_t v17 = (char *)(v4 + 3);
      a1[5].__r_.__value_.__r.__words[2] = v4 + 3;
      if (size != (unsigned __int8 *)(v4 + 3))
      {
        std::string::size_type v18 = -4 - v4;
        uint64_t v19 = (unsigned __int8 *)(v4 + 4);
        while (1)
        {
          int v20 = *(unsigned __int8 *)(v7 + *(v19 - 1) + 32);
          a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)v19;
          if (v20 == 36) {
            break;
          }
          --v18;
          BOOL v28 = v19++ == size;
          if (v28) {
            goto LABEL_25;
          }
        }
        if (v19 != size && *(unsigned char *)(v7 + *v19 + 32) == 10)
        {
          int v23 = *(unsigned __int8 *)(v7 + *v16 + 32);
          if (v23 == 4) {
            unint64_t v24 = v17;
          }
          else {
            unint64_t v24 = v16;
          }
          int v25 = sub_10010B930(v7, v24, (char *)v19 - 1);
          if (v25)
          {
            if (v23 == 4) {
              *(_DWORD *)(a2 + 56) |= v25;
            }
            else {
              *(_DWORD *)(a2 + 52) |= v25;
            }
            *(unsigned char *)(a2 + 60) = 0;
            ++a1[5].__r_.__value_.__r.__words[2];
            return 1;
          }
          BOOL v28 = &v24[v18] != (char *)-2 || *(unsigned char *)(a2 + 60) == 0;
          if (!v28)
          {
            std::string::size_type v30 = a1[5].__r_.__value_.__l.__size_;
            std::string::size_type v29 = a1[5].__r_.__value_.__r.__words[2];
            a1[5].__r_.__value_.__r.__words[2] = v29 + 1;
            if (v29 + 1 != v30)
            {
              uint64_t v31 = *(void *)a1->__r_.__value_.__l.__size_;
              if (*(unsigned char *)(v31 + *(unsigned __int8 *)(v29 + 1) + 32) == 10)
              {
                int v32 = *(unsigned __int8 *)(v31 + *v24 + 32);
                if (v32 == 21)
                {
                  a1[5].__r_.__value_.__r.__words[2] = v29 + 2;
                  std::string::size_type v33 = (uint64_t *)a1;
                  int v34 = 10;
                  goto LABEL_69;
                }
                if (v32 == 20)
                {
                  a1[5].__r_.__value_.__r.__words[2] = v29 + 2;
                  std::string::size_type v33 = (uint64_t *)a1;
                  int v34 = 9;
LABEL_69:
                  sub_10010CB60(v33, v34, 0x10uLL);
                  return 0;
                }
              }
            }
          }
          sub_10010C68C(a1, 4, (uint64_t)&v24[-a1[5].__r_.__value_.__r.__words[0]]);
          return 0;
        }
        uint64_t v26 = -(uint64_t)v18 - a1[5].__r_.__value_.__r.__words[0];
        sub_100018888(&__p, "Character class declaration starting with [ terminated prematurely - either no ] was found or the set had no content.");
        sub_10010CE64(a1, 7, v26, (uint64_t)&__p);
LABEL_6:
        if ((char)v39 < 0) {
          operator delete(__p);
        }
        return 0;
      }
    }
LABEL_25:
    uint64_t v21 = (uint64_t)&size[-a1[5].__r_.__value_.__r.__words[0]];
    sub_100018888(&__p, "Character class declaration starting with [ terminated prematurely - either no ] was found or the set had no content.");
    sub_10010CE64(a1, 7, v21, (uint64_t)&__p);
    goto LABEL_6;
  }
  a1[5].__r_.__value_.__r.__words[2] = v4;
  sub_100113568((uint64_t)a1, a2);
  return 1;
}

void sub_100113BF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100113C34(std::string *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_WORD *)a3 = 0;
  int v5 = (unsigned char *)a1[5].__r_.__value_.__r.__words[2];
  uint64_t v6 = *(void *)a1->__r_.__value_.__l.__size_;
  int v7 = *(unsigned __int8 *)(v6 + *v5 + 32);
  if (v7 != 9)
  {
    if (v7 == 12)
    {
      int v8 = *(_DWORD *)(a1->__r_.__value_.__r.__words[0] + 40);
      a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v5 + 1);
      if ((v8 & 0x10000) == 0)
      {
        *(unsigned char *)a3 = sub_100111780(a1);
LABEL_18:
        *(unsigned char *)(a3 + 1) = 0;
        return;
      }
    }
    else
    {
      if (v7 == 14)
      {
        if (*(unsigned char *)(a2 + 60))
        {
LABEL_5:
          a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v5 + 1);
          *(unsigned char *)a3 = *v5;
          return;
        }
        std::string::size_type v18 = v5 + 1;
        a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v5 + 1);
        if (v5 + 1 != (unsigned char *)a1[5].__r_.__value_.__l.__size_ && *(unsigned char *)(v6 + *v18 + 32) == 10)
        {
          a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)v5;
          goto LABEL_5;
        }
        uint64_t v17 = (uint64_t)&v18[-a1[5].__r_.__value_.__r.__words[0]];
        uint64_t v19 = a1;
        int v20 = 11;
        goto LABEL_34;
      }
      a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v5 + 1);
    }
    *(unsigned char *)a3 = *v5;
    goto LABEL_18;
  }
  std::string::size_type size = (unsigned __int8 *)a1[5].__r_.__value_.__l.__size_;
  uint64_t v10 = v5 + 1;
  a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v5 + 1);
  if (size == v5 + 1) {
    goto LABEL_20;
  }
  if (*(unsigned char *)(v6 + *v10 + 32) != 5)
  {
    a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)v5;
    *(unsigned char *)a3 = *v5;
    a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)v10;
    return;
  }
  uint64_t v11 = v5 + 2;
  a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v5 + 2);
  if (size == v5 + 2)
  {
LABEL_20:
    uint64_t v17 = (uint64_t)&size[-a1[5].__r_.__value_.__r.__words[0]];
LABEL_33:
    uint64_t v19 = a1;
    int v20 = 3;
LABEL_34:
    sub_10010C68C(v19, v20, v17);
    return;
  }
  int v12 = v5 + 3;
  a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v5 + 3);
  if (size == v5 + 3) {
    goto LABEL_32;
  }
  uint64_t v13 = (char *)&__p + 1;
  std::string::size_type v14 = v5 + 3;
  while (1)
  {
    unsigned int v15 = *v14++;
    int v16 = *(unsigned __int8 *)(v6 + v15 + 32);
    a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)v14;
    if (v16 == 5) {
      break;
    }
    int v12 = v14;
    if (v14 == size) {
      goto LABEL_32;
    }
  }
  if (v12 + 1 == size || *(unsigned char *)(v6 + v12[1] + 32) != 10)
  {
LABEL_32:
    uint64_t v17 = (uint64_t)&v11[-a1[5].__r_.__value_.__r.__words[0]];
    goto LABEL_33;
  }
  a1[5].__r_.__value_.__r.__words[2] = (std::string::size_type)(v12 + 2);
  sub_100113238(v6, v11, (char *)v12, (uint64_t)&__p);
  unsigned int v21 = v26;
  if (((char)v26 & 0x80000000) == 0)
  {
    if (v26 - 3 > 0xFFFFFFFD)
    {
      *(unsigned char *)a3 = (_BYTE)__p;
      if (v21 <= 1) {
        goto LABEL_42;
      }
LABEL_41:
      *(unsigned char *)(a3 + 1) = *v13;
      goto LABEL_43;
    }
LABEL_38:
    sub_10010C68C(a1, 3, (uint64_t)&v11[-a1[5].__r_.__value_.__r.__words[0]]);
    LOBYTE(v21) = v26;
    goto LABEL_43;
  }
  unint64_t v22 = v25;
  if (v25 - 3 < 0xFFFFFFFFFFFFFFFELL) {
    goto LABEL_38;
  }
  int v23 = (char *)__p;
  *(unsigned char *)a3 = *(unsigned char *)__p;
  if (v22 > 1)
  {
    uint64_t v13 = v23 + 1;
    goto LABEL_41;
  }
LABEL_42:
  *(unsigned char *)(a3 + 1) = 0;
LABEL_43:
  if ((v21 & 0x80) != 0) {
    operator delete(__p);
  }
}

void sub_100113EC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100113EE4(uint64_t a1, char *a2, char *a3)
{
  int v7 = (char **)(a1 + 40);
  uint64_t v6 = *(char **)(a1 + 40);
  int v8 = (void **)(a1 + 24);
  uint64_t v9 = *(char **)(a1 + 32);
  if (v9 >= v6)
  {
    uint64_t v11 = (char *)*v8;
    uint64_t v12 = v9 - (unsigned char *)*v8;
    if (v12 <= -3) {
      goto LABEL_43;
    }
    uint64_t v13 = v12 >> 1;
    unint64_t v14 = v6 - v11;
    if (v14 <= (v12 >> 1) + 1) {
      unint64_t v15 = v13 + 1;
    }
    else {
      unint64_t v15 = v14;
    }
    if (v14 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v16 = v15;
    }
    if (v16)
    {
      uint64_t v17 = (char *)sub_100114110((uint64_t)v7, v16);
      uint64_t v11 = *(char **)(a1 + 24);
      uint64_t v9 = *(char **)(a1 + 32);
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::string::size_type v18 = &v17[2 * v13];
    uint64_t v6 = &v17[2 * v16];
    *std::string::size_type v18 = *a2;
    v18[1] = a2[1];
    uint64_t v10 = v18 + 2;
    while (v9 != v11)
    {
      char v19 = *(v9 - 2);
      v9 -= 2;
      *(v18 - 2) = v19;
      v18 -= 2;
      v18[1] = v9[1];
    }
    *(void *)(a1 + 24) = v18;
    *(void *)(a1 + 32) = v10;
    *(void *)(a1 + 40) = v6;
    if (v11)
    {
      operator delete(v11);
      uint64_t v6 = *v7;
    }
  }
  else
  {
    char *v9 = *a2;
    v9[1] = a2[1];
    uint64_t v10 = v9 + 2;
  }
  *(void *)(a1 + 32) = v10;
  if (v10 < v6)
  {
    *uint64_t v10 = *a3;
    v10[1] = a3[1];
    int v20 = v10 + 2;
    goto LABEL_35;
  }
  unsigned int v21 = (char *)*v8;
  uint64_t v22 = v10 - (unsigned char *)*v8;
  if (v22 <= -3) {
LABEL_43:
  }
    sub_10002B5E0();
  uint64_t v23 = v22 >> 1;
  unint64_t v24 = v6 - v21;
  if (v24 <= (v22 >> 1) + 1) {
    unint64_t v25 = v23 + 1;
  }
  else {
    unint64_t v25 = v24;
  }
  if (v24 >= 0x7FFFFFFFFFFFFFFELL) {
    uint64_t v26 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v26 = v25;
  }
  if (v26)
  {
    char v27 = (char *)sub_100114110((uint64_t)v7, v26);
    unsigned int v21 = *(char **)(a1 + 24);
    uint64_t v10 = *(char **)(a1 + 32);
  }
  else
  {
    char v27 = 0;
  }
  BOOL v28 = &v27[2 * v23];
  std::string::size_type v29 = &v27[2 * v26];
  char *v28 = *a3;
  v28[1] = a3[1];
  int v20 = v28 + 2;
  while (v10 != v21)
  {
    char v30 = *(v10 - 2);
    v10 -= 2;
    *(v28 - 2) = v30;
    v28 -= 2;
    v28[1] = v10[1];
  }
  *(void *)(a1 + 24) = v28;
  *(void *)(a1 + 32) = v20;
  *(void *)(a1 + 40) = v29;
  if (v21) {
    operator delete(v21);
  }
LABEL_35:
  *(void *)(a1 + 32) = v20;
  if (a2[1])
  {
    *(unsigned char *)(a1 + 49) = 1;
    sub_100114144((uint64_t **)a1, a2, a2);
    if (a2[1]) {
      *(unsigned char *)(a1 + 49) = 1;
    }
    *(unsigned char *)(a1 + 60) = 0;
  }
  if (a3[1])
  {
    *(unsigned char *)(a1 + 49) = 1;
    sub_100114144((uint64_t **)a1, a3, a3);
    if (a3[1]) {
      *(unsigned char *)(a1 + 49) = 1;
    }
  }
  *(unsigned char *)(a1 + 60) = 0;
}

void *sub_100114110(uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    sub_10002A63C();
  }
  return operator new(2 * a2);
}

char *sub_100114144(uint64_t **a1, char *a2, _WORD *a3)
{
  int v5 = sub_1001141C8((uint64_t)a1, &v9, a2);
  uint64_t v6 = (char *)*v5;
  if (!*v5)
  {
    int v7 = (uint64_t **)v5;
    uint64_t v6 = (char *)operator new(0x20uLL);
    *(_WORD *)(v6 + 25) = *a3;
    sub_10001716C(a1, v9, v7, (uint64_t *)v6);
  }
  return v6;
}

uint64_t *sub_1001141C8(uint64_t a1, void *a2, char *a3)
{
  int v5 = *(uint64_t **)(a1 + 8);
  uint64_t result = (uint64_t *)(a1 + 8);
  std::string::size_type v4 = v5;
  if (v5)
  {
    int v6 = *a3;
    int v7 = a3[1];
    while (1)
    {
      while (1)
      {
        int v8 = v4;
        int v9 = *((char *)v4 + 25);
        if (v6 >= v9) {
          break;
        }
LABEL_4:
        std::string::size_type v4 = (uint64_t *)*v8;
        uint64_t result = v8;
        if (!*v8) {
          goto LABEL_12;
        }
      }
      if (v9 >= v6)
      {
        int v10 = *((char *)v8 + 26);
        if (v7 < v10) {
          goto LABEL_4;
        }
        if (v10 >= v7) {
          goto LABEL_12;
        }
      }
      uint64_t result = v8 + 1;
      std::string::size_type v4 = (uint64_t *)v8[1];
      if (!v4) {
        goto LABEL_12;
      }
    }
  }
  int v8 = result;
LABEL_12:
  *a2 = v8;
  return result;
}

char *sub_100114230(uint64_t a1, char *a2)
{
  uint64_t result = sub_100114144((uint64_t **)(a1 + 64), a2, a2);
  if (a2[1])
  {
    *(unsigned char *)(a1 + 49) = 1;
    uint64_t result = sub_100114144((uint64_t **)a1, a2, a2);
    if (a2[1]) {
      *(unsigned char *)(a1 + 49) = 1;
    }
  }
  *(unsigned char *)(a1 + 60) = 0;
  return result;
}

uint64_t sub_100114298(std::string *a1)
{
  std::string::size_type size = a1[5].__r_.__value_.__l.__size_;
  std::string::size_type v2 = a1[5].__r_.__value_.__r.__words[2];
  std::string::size_type v4 = (unsigned __int8 *)(v2 + 1);
  a1[5].__r_.__value_.__r.__words[2] = v2 + 1;
  if (v2 + 1 != size)
  {
    uint64_t v5 = *v4;
    BOOL v6 = 0;
    switch(*(unsigned char *)(*(void *)a1->__r_.__value_.__l.__size_ + v5 + 32))
    {
      case 1:
        return sub_10010D2D0((uint64_t)a1);
      case 2:
        return v6;
      case 7:
        if ((*(unsigned char *)(a1->__r_.__value_.__r.__words[0] + 41) & 4) == 0) {
          goto LABEL_43;
        }
        a1[5].__r_.__value_.__r.__words[2] = v2 + 2;
        uint64_t v9 = 1;
        uint64_t v10 = -1;
        goto LABEL_16;
      case 8:
        if ((*(unsigned char *)(a1->__r_.__value_.__r.__words[0] + 41) & 4) == 0) {
          goto LABEL_43;
        }
        a1[5].__r_.__value_.__r.__words[2] = v2 + 2;
        uint64_t v9 = 0;
        uint64_t v10 = 1;
LABEL_16:
        return sub_10010DFCC((uint64_t)a1, v9, v10);
      case 0xB:
        if ((*(unsigned char *)(a1->__r_.__value_.__r.__words[0] + 41) & 8) == 0) {
          goto LABEL_43;
        }
        return sub_10010E9D4((uint64_t)a1);
      case 0xF:
        if ((*(unsigned char *)(a1->__r_.__value_.__r.__words[0] + 41) & 2) != 0) {
          goto LABEL_43;
        }
        a1[5].__r_.__value_.__r.__words[2] = v2 + 2;
        return sub_10010E44C((uint64_t)a1, 1);
      case 0x10:
        if ((*(unsigned char *)(a1->__r_.__value_.__r.__words[0] + 41) & 2) != 0) {
          goto LABEL_43;
        }
        uint64_t v11 = (uint64_t)&v4[-a1[5].__r_.__value_.__r.__words[0]];
        sub_100018888(&__p, "Found a closing repetition operator } with no corresponding {.");
        sub_10010CE64(a1, 9, v11, (uint64_t)&__p);
LABEL_48:
        if (SHIBYTE(v19) < 0) {
          operator delete(__p);
        }
        return 0;
      case 0x11:
        return sub_100111E34((uint64_t)a1);
      case 0x12:
        if ((*(unsigned char *)(a1->__r_.__value_.__r.__words[0] + 41) & 0x10) == 0) {
          goto LABEL_43;
        }
        a1[5].__r_.__value_.__r.__words[2] = v2 + 2;
        int v8 = 7;
        goto LABEL_40;
      case 0x13:
        if ((*(unsigned char *)(a1->__r_.__value_.__r.__words[0] + 41) & 0x10) == 0) {
          goto LABEL_43;
        }
        a1[5].__r_.__value_.__r.__words[2] = v2 + 2;
        int v8 = 8;
        goto LABEL_40;
      case 0x14:
        if ((*(unsigned char *)(a1->__r_.__value_.__r.__words[0] + 41) & 0x10) == 0) {
          goto LABEL_43;
        }
        a1[5].__r_.__value_.__r.__words[2] = v2 + 2;
        int v8 = 9;
        goto LABEL_40;
      case 0x15:
        if ((*(unsigned char *)(a1->__r_.__value_.__r.__words[0] + 41) & 0x10) == 0) {
          goto LABEL_43;
        }
        a1[5].__r_.__value_.__r.__words[2] = v2 + 2;
        int v8 = 10;
        goto LABEL_40;
      case 0x18:
        if ((*(unsigned char *)(a1->__r_.__value_.__r.__words[0] + 41) & 0x10) == 0) {
          goto LABEL_43;
        }
        a1[5].__r_.__value_.__r.__words[2] = v2 + 2;
        int v8 = 11;
        goto LABEL_40;
      case 0x19:
        if ((*(unsigned char *)(a1->__r_.__value_.__r.__words[0] + 41) & 0x10) == 0) {
          goto LABEL_43;
        }
        a1[5].__r_.__value_.__r.__words[2] = v2 + 2;
        int v8 = 12;
LABEL_40:
        sub_10010CB60((uint64_t *)a1, v8, 0x10uLL);
        return 1;
      default:
        if ((*(unsigned char *)(a1->__r_.__value_.__r.__words[0] + 41) & 0x10) != 0)
        {
          HIDWORD(v12) = (char)v5 - 67;
          LODWORD(v12) = HIDWORD(v12);
          int v13 = 1;
          switch((v12 >> 2))
          {
            case 0u:
            case 8u:
              uint64_t v14 = (uint64_t)&v4[-a1[5].__r_.__value_.__r.__words[0]];
              sub_100018888(&__p, "The \\c and \\C escape sequences are not supported by POSIX basic regular expressions: try the Perl syntax instead.");
              sub_10010CE64(a1, 5, v14, (uint64_t)&__p);
              goto LABEL_48;
            case 4u:
              goto LABEL_55;
            case 5u:
              std::string __p = &v18;
              uint64_t v18 = 0;
              uint64_t v19 = 0;
              uint64_t v20 = 0;
              uint64_t v21 = 0;
              uint64_t v22 = 0;
              uint64_t v28 = 0;
              uint64_t v29 = 0;
              char v27 = &v28;
              int v25 = 0;
              __int16 v23 = 1;
              goto LABEL_52;
            case 0xCu:
              int v13 = 0;
LABEL_55:
              return sub_10011479C((uint64_t)a1, v13);
            case 0xDu:
              std::string __p = &v18;
              uint64_t v18 = 0;
              uint64_t v19 = 0;
              uint64_t v20 = 0;
              uint64_t v21 = 0;
              uint64_t v22 = 0;
              uint64_t v28 = 0;
              uint64_t v29 = 0;
              char v27 = &v28;
              __int16 v23 = 0;
              int v25 = 0;
LABEL_52:
              int v24 = a1[3].__r_.__value_.__r.__words[1];
              char v26 = 0;
              unint64_t v15 = sub_1001115F8((uint64_t)a1, (uint64_t)&__p);
              BOOL v6 = v15 != 0;
              std::string::size_type v16 = a1[5].__r_.__value_.__r.__words[2];
              if (v15) {
                a1[5].__r_.__value_.__r.__words[2] = v16 + 1;
              }
              else {
                sub_10010C68C(a1, 4, v16 - a1[5].__r_.__value_.__r.__words[0]);
              }
              sub_100111610((uint64_t)&__p);
              return v6;
            default:
              break;
          }
        }
LABEL_43:
        return sub_10010CDF4((uint64_t)a1);
    }
  }
  sub_10010C68C(a1, 8, (uint64_t)&v4[-a1[5].__r_.__value_.__r.__words[0]]);
  return 0;
}

void sub_1001146D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10011479C(uint64_t a1, int a2)
{
  std::string::size_type v4 = *(unsigned __int8 **)(a1 + 128);
  uint64_t v3 = *(unsigned __int8 **)(a1 + 136);
  uint64_t v5 = v3 + 1;
  *(void *)(a1 + 136) = v3 + 1;
  if (v3 + 1 == v4)
  {
    uint64_t v7 = **(void **)(a1 + 8);
    do
    {
      *(void *)(a1 + 136) = v3;
      unsigned int v8 = *v3--;
      --v5;
    }
    while (*(unsigned char *)(v7 + v8 + 32) != 12);
    sub_10010C68C((std::string *)a1, 5, (uint64_t)&v5[-*(void *)(a1 + 120)]);
    return 0;
  }
  unint64_t v15 = (uint64_t *)v16;
  v16[0] = 0;
  v16[1] = 0;
  std::string __p = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  v25[0] = 0;
  v25[1] = 0;
  int v24 = v25;
  __int16 v20 = 0;
  int v21 = 0;
  int v22 = 0;
  char v23 = 1;
  if (a2) {
    LOBYTE(v20) = 1;
  }
  int v6 = (char)*v5;
  if (v6 <= 59)
  {
    switch(*v5)
    {
      case ' ':
        goto LABEL_18;
      case '""':
        __int16 v14 = 34;
        sub_100114144(&v15, (char *)&v14, &v14);
        if (HIBYTE(v14)) {
          HIBYTE(v20) = 1;
        }
        char v23 = 0;
        __int16 v14 = 39;
        sub_100114144(&v15, (char *)&v14, &v14);
        if (HIBYTE(v14)) {
          HIBYTE(v20) = 1;
        }
        char v23 = 0;
        __int16 v14 = 96;
        sub_100114144(&v15, (char *)&v14, &v14);
        goto LABEL_58;
      case '\'':
        __int16 v14 = 39;
        sub_100114144(&v15, (char *)&v14, &v14);
        if (HIBYTE(v14)) {
          HIBYTE(v20) = 1;
        }
        char v23 = 0;
        __int16 v14 = 44;
        sub_100114144(&v15, (char *)&v14, &v14);
        if (HIBYTE(v14)) {
          HIBYTE(v20) = 1;
        }
        char v23 = 0;
        __int16 v14 = 35;
        sub_100114144(&v15, (char *)&v14, &v14);
        goto LABEL_58;
      case '(':
        __int16 v14 = 40;
        sub_100114144(&v15, (char *)&v14, &v14);
        if (HIBYTE(v14)) {
          HIBYTE(v20) = 1;
        }
        char v23 = 0;
        __int16 v14 = 91;
        sub_100114144(&v15, (char *)&v14, &v14);
        if (HIBYTE(v14)) {
          HIBYTE(v20) = 1;
        }
        char v23 = 0;
        __int16 v14 = 123;
        sub_100114144(&v15, (char *)&v14, &v14);
        goto LABEL_58;
      case ')':
        __int16 v14 = 41;
        sub_100114144(&v15, (char *)&v14, &v14);
        if (HIBYTE(v14)) {
          HIBYTE(v20) = 1;
        }
        char v23 = 0;
        __int16 v14 = 93;
        sub_100114144(&v15, (char *)&v14, &v14);
        if (HIBYTE(v14)) {
          HIBYTE(v20) = 1;
        }
        char v23 = 0;
        __int16 v14 = 125;
        sub_100114144(&v15, (char *)&v14, &v14);
        goto LABEL_58;
      case '.':
        int v11 = sub_10010B930(**(void **)(a1 + 8), "punct", "");
        int v10 = v21 | v11;
        goto LABEL_56;
      default:
        goto LABEL_65;
    }
  }
  if (v6 <= 94)
  {
    if (v6 == 60)
    {
      __int16 v14 = 59;
      sub_100114144(&v15, (char *)&v14, &v14);
    }
    else
    {
      if (v6 != 62) {
        goto LABEL_65;
      }
      __int16 v14 = 10;
      sub_100114144(&v15, (char *)&v14, &v14);
      if (HIBYTE(v14)) {
        HIBYTE(v20) = 1;
      }
      char v23 = 0;
      __int16 v14 = 12;
      sub_100114144(&v15, (char *)&v14, &v14);
    }
  }
  else
  {
    if (v6 != 95)
    {
      if (v6 == 119)
      {
        int v10 = *(_DWORD *)(a1 + 80);
        goto LABEL_56;
      }
      if (v6 == 115)
      {
LABEL_18:
        int v10 = *(_DWORD *)(a1 + 84);
LABEL_56:
        int v21 = v10;
        goto LABEL_60;
      }
LABEL_65:
      sub_10010C68C((std::string *)a1, 4, (uint64_t)&v5[-*(void *)(a1 + 120)]);
      uint64_t v9 = 0;
      goto LABEL_66;
    }
    __int16 v14 = 36;
    sub_100114144(&v15, (char *)&v14, &v14);
    if (HIBYTE(v14)) {
      HIBYTE(v20) = 1;
    }
    char v23 = 0;
    __int16 v14 = 38;
    sub_100114144(&v15, (char *)&v14, &v14);
    if (HIBYTE(v14)) {
      HIBYTE(v20) = 1;
    }
    char v23 = 0;
    __int16 v14 = 42;
    sub_100114144(&v15, (char *)&v14, &v14);
    if (HIBYTE(v14)) {
      HIBYTE(v20) = 1;
    }
    char v23 = 0;
    __int16 v14 = 43;
    sub_100114144(&v15, (char *)&v14, &v14);
    if (HIBYTE(v14)) {
      HIBYTE(v20) = 1;
    }
    char v23 = 0;
    __int16 v14 = 45;
    sub_100114144(&v15, (char *)&v14, &v14);
    if (HIBYTE(v14)) {
      HIBYTE(v20) = 1;
    }
    char v23 = 0;
    __int16 v14 = 95;
    sub_100114144(&v15, (char *)&v14, &v14);
    if (HIBYTE(v14)) {
      HIBYTE(v20) = 1;
    }
    char v23 = 0;
    __int16 v14 = 60;
    sub_100114144(&v15, (char *)&v14, &v14);
    if (HIBYTE(v14)) {
      HIBYTE(v20) = 1;
    }
    char v23 = 0;
    __int16 v14 = 62;
    sub_100114144(&v15, (char *)&v14, &v14);
  }
LABEL_58:
  if (HIBYTE(v14)) {
    HIBYTE(v20) = 1;
  }
LABEL_60:
  char v23 = 0;
  if (HIBYTE(v20)) {
    uint64_t v12 = sub_1001120DC(a1, (uint64_t)&v15);
  }
  else {
    uint64_t v12 = (uint64_t)sub_100112A94(a1, (uint64_t)&v15);
  }
  uint64_t v5 = *(unsigned char **)(a1 + 136);
  if (!v12) {
    goto LABEL_65;
  }
  *(void *)(a1 + 136) = v5 + 1;
  uint64_t v9 = 1;
LABEL_66:
  sub_10004B7F8((uint64_t)&v24, v25[0]);
  if (__p)
  {
    uint64_t v18 = __p;
    operator delete(__p);
  }
  sub_10004B7F8((uint64_t)&v15, v16[0]);
  return v9;
}

void sub_100114D0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100111610((uint64_t)va);
  _Unwind_Resume(a1);
}

std::string *sub_100114DB8(std::string *result, int a2, uint64_t a3, std::string *this, uint64_t a5)
{
  unsigned int v8 = result;
  std::string::size_type v9 = result->__r_.__value_.__r.__words[0];
  if (!*(_DWORD *)(result->__r_.__value_.__r.__words[0] + 44)) {
    *(_DWORD *)(v9 + 44) = a2;
  }
  std::string::pointer data = result[5].__r_.__value_.__l.__data_;
  std::string::size_type size = result[5].__r_.__value_.__l.__size_;
  result[5].__r_.__value_.__r.__words[2] = size;
  uint64_t v12 = 10;
  if (a3 > 10) {
    uint64_t v12 = a3;
  }
  uint64_t v13 = v12 - 10;
  if (a5 == a3) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = a5;
  }
  uint64_t v15 = size - (void)data;
  if (v15 >= a3 + 10) {
    uint64_t v16 = a3 + 10;
  }
  else {
    uint64_t v16 = v15;
  }
  if (a2 != 17)
  {
    if (v15 <= a3 + 10 && v14 == 0) {
      uint64_t v18 = "  The error occurred while parsing the regular expression: '";
    }
    else {
      uint64_t v18 = "  The error occurred while parsing the regular expression fragment: '";
    }
    std::string::append(this, v18);
    if (v14 != v16)
    {
      sub_10004E7CC(&__p, (char *)(v8[5].__r_.__value_.__r.__words[0] + v14), (char *)(v8[5].__r_.__value_.__r.__words[0] + a3), a3 - v14);
      if ((v25 & 0x80u) == 0) {
        p_p = (std::runtime_error_vtbl *)&__p;
      }
      else {
        p_p = __p.__vftable;
      }
      if ((v25 & 0x80u) == 0) {
        std::string::size_type imp = v25;
      }
      else {
        std::string::size_type imp = (std::string::size_type)__p.__imp_.__imp_;
      }
      std::string::append(this, (const std::string::value_type *)p_p, imp);
      if ((char)v25 < 0) {
        operator delete(__p.__vftable);
      }
      std::string::append(this, ">>>HERE>>>");
      sub_10004E7CC(&__p, (char *)(v8[5].__r_.__value_.__r.__words[0] + a3), (char *)(v8[5].__r_.__value_.__r.__words[0] + v16), v16 - a3);
      if ((v25 & 0x80u) == 0) {
        int v21 = (std::runtime_error_vtbl *)&__p;
      }
      else {
        int v21 = __p.__vftable;
      }
      if ((v25 & 0x80u) == 0) {
        std::string::size_type v22 = v25;
      }
      else {
        std::string::size_type v22 = (std::string::size_type)__p.__imp_.__imp_;
      }
      std::string::append(this, (const std::string::value_type *)v21, v22);
      if ((char)v25 < 0) {
        operator delete(__p.__vftable);
      }
    }
    uint64_t result = std::string::append(this, "'.");
    std::string::size_type v9 = v8->__r_.__value_.__r.__words[0];
  }
  if ((*(unsigned char *)(v9 + 42) & 4) == 0)
  {
    std::runtime_error::runtime_error(&__p, this);
    __p.__vftable = (std::runtime_error_vtbl *)&off_1001BD3D0;
    int v24 = a2;
    uint64_t v26 = a3;
    sub_100101EA4((uint64_t)&__p);
  }
  return result;
}

void sub_100114F74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100114FA4(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    while (1)
    {
      switch(*(_DWORD *)a2)
      {
        case 0x10:
          goto LABEL_5;
        case 0x11:
          goto LABEL_4;
        case 0x12:
        case 0x16:
        case 0x17:
        case 0x18:
        case 0x19:
          int v2 = *(_DWORD *)(result + 28);
          *(_DWORD *)(result + 28) = v2 + 1;
          *(_DWORD *)(a2 + 304) = v2;
LABEL_4:
          *(_OWORD *)(a2 + 24) = 0uLL;
          *(_DWORD *)(a2 + 280) = 0;
          *(_OWORD *)(a2 + 248) = 0uLL;
          *(_OWORD *)(a2 + 264) = 0uLL;
          *(_OWORD *)(a2 + 216) = 0uLL;
          *(_OWORD *)(a2 + 232) = 0uLL;
          *(_OWORD *)(a2 + 184) = 0uLL;
          *(_OWORD *)(a2 + 200) = 0uLL;
          *(_OWORD *)(a2 + 152) = 0uLL;
          *(_OWORD *)(a2 + 168) = 0uLL;
          *(_OWORD *)(a2 + 120) = 0uLL;
          *(_OWORD *)(a2 + 136) = 0uLL;
          *(_OWORD *)(a2 + 88) = 0uLL;
          *(_OWORD *)(a2 + 104) = 0uLL;
          *(_OWORD *)(a2 + 56) = 0uLL;
          *(_OWORD *)(a2 + 72) = 0uLL;
          *(_OWORD *)(a2 + 40) = 0uLL;
LABEL_5:
          *(void *)(a2 + 16) += a2;
          break;
        case 0x1D:
          *(unsigned char *)(result + 48) = 1;
          break;
        default:
          break;
      }
      uint64_t v3 = *(void *)(a2 + 8);
      if (!v3) {
        break;
      }
      *(void *)(a2 + 8) = a2 + v3;
      a2 += v3;
    }
    *(void *)(a2 + 8) = 0;
  }
  return result;
}

uint64_t sub_10011508C(uint64_t result, int *a2)
{
  if (a2)
  {
    uint64_t v3 = (unsigned int ***)result;
    std::string::size_type v4 = a2;
    do
    {
      if (*v4 == 29)
      {
        uint64_t v7 = *((void *)v4 + 2);
        if (v7 >= 0x40000000)
        {
          uint64_t result = sub_10011207C(*v3, v7);
          uint64_t v7 = (int)result;
        }
        if ((v7 & 0x8000000000000000) == 0)
        {
          unsigned int v8 = a2;
          while (*v8 || v7 != v8[4])
          {
            unsigned int v8 = (int *)*((void *)v8 + 1);
            if (!v8) {
              goto LABEL_18;
            }
          }
          *((void *)v4 + 2) = v8;
          while (1)
          {
            unsigned int v8 = (int *)*((void *)v8 + 1);
            if (!v8) {
              goto LABEL_21;
            }
            int v10 = *v8;
            if ((*v8 - 22) >= 4)
            {
              if (v10 == 1)
              {
                if (v7 == v8[4]) {
                  goto LABEL_21;
                }
                continue;
              }
              if (v10 != 18) {
                continue;
              }
            }
            int v11 = v8[76];
            if (v11)
            {
              if (v11 >= 1) {
                v4[6] = v11 - 1;
              }
              goto LABEL_21;
            }
          }
        }
LABEL_18:
        std::string::size_type v9 = *v3;
        if (!*((_DWORD *)*v3 + 11)) {
          *((_DWORD *)v9 + 11) = 2;
        }
        void v9[6] = 0;
        v9[7] = 0;
        if ((*((unsigned char *)v9 + 42) & 4) == 0)
        {
          sub_100018888(&v15, "Encountered a forward reference to a recursive sub-expression that does not exist.");
          std::runtime_error::runtime_error(&v12, &v15);
          v12.__vftable = (std::runtime_error_vtbl *)&off_1001BD3D0;
          int v13 = 2;
          uint64_t v14 = 0;
          sub_100101EA4((uint64_t)&v12);
        }
      }
      else if (*v4 == 27)
      {
        int v5 = v4[4];
        if (v5 <= -1073741825)
        {
          uint64_t result = sub_10011207C(*v3, ~v5);
          if ((int)result <= 0)
          {
            int v6 = *v3;
            if (!*((_DWORD *)*v3 + 11)) {
              *((_DWORD *)v6 + 11) = 2;
            }
            v6[6] = 0;
            v6[7] = 0;
            if ((*((unsigned char *)v6 + 42) & 4) == 0)
            {
              sub_100018888(&v15, "Encountered a forward reference to a marked sub-expression that does not exist.");
              std::runtime_error::runtime_error(&v12, &v15);
              v12.__vftable = (std::runtime_error_vtbl *)&off_1001BD3D0;
              int v13 = 2;
              uint64_t v14 = 0;
              sub_100101EA4((uint64_t)&v12);
            }
          }
        }
      }
LABEL_21:
      std::string::size_type v4 = (int *)*((void *)v4 + 1);
    }
    while (v4);
  }
  return result;
}

void sub_10011529C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::runtime_error a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1001152D0(uint64_t a1, int *a2)
{
  char v2 = *(unsigned char *)(a1 + 24);
  uint64_t v29 = 0;
  char v30 = 0;
  uint64_t v31 = 0;
  if (a2)
  {
    uint64_t v3 = a2;
    do
    {
      int v5 = *v3;
      if (*v3 <= 0x1C)
      {
        if (((1 << v5) & 0x3C60000) != 0)
        {
          char v6 = *(unsigned char *)(a1 + 24);
          uint64_t v7 = v30;
          if (v30 >= v31)
          {
            uint64_t v9 = (v30 - v29) >> 4;
            unint64_t v10 = v9 + 1;
            if ((unint64_t)(v9 + 1) >> 60) {
              sub_10002B5E0();
            }
            uint64_t v11 = v31 - v29;
            if ((v31 - v29) >> 3 > v10) {
              unint64_t v10 = v11 >> 3;
            }
            if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v12 = v10;
            }
            if (v12) {
              int v13 = (char *)sub_10001E498((uint64_t)&v31, v12);
            }
            else {
              int v13 = 0;
            }
            uint64_t v14 = &v13[16 * v9];
            char *v14 = v6;
            *((void *)v14 + 1) = v3;
            uint64_t v16 = v29;
            std::string v15 = v30;
            uint64_t v17 = v14;
            if (v30 != v29)
            {
              do
              {
                *((_OWORD *)v17 - 1) = *((_OWORD *)v15 - 1);
                v17 -= 16;
                v15 -= 16;
              }
              while (v15 != v16);
              std::string v15 = v29;
            }
            unsigned int v8 = v14 + 16;
            uint64_t v29 = v17;
            char v30 = v14 + 16;
            uint64_t v31 = &v13[16 * v12];
            if (v15) {
              operator delete(v15);
            }
          }
          else
          {
            *char v30 = v6;
            *((void *)v7 + 1) = v3;
            unsigned int v8 = v7 + 16;
          }
          char v30 = v8;
        }
        else if (v5 == 26)
        {
          int v18 = sub_100116144(a1, *((void *)v3 + 1));
          v3[4] = v18;
          if (v18 < 0)
          {
            uint64_t v19 = *(void *)a1;
            if (!*(_DWORD *)(*(void *)a1 + 44)) {
              *(_DWORD *)(v19 + 44) = 2;
            }
            *(void *)(v19 + 48) = 0;
            *(void *)(v19 + 56) = 0;
            if ((*(unsigned char *)(v19 + 42) & 4) == 0)
            {
              sub_100018888(&v28, "Invalid lookbehind assertion encountered in the regular expression.");
              std::runtime_error::runtime_error(&v25, &v28);
              v25.__vftable = (std::runtime_error_vtbl *)&off_1001BD3D0;
              int v26 = 2;
              uint64_t v27 = 0;
              sub_100101EA4((uint64_t)&v25);
            }
          }
        }
        else if (v5 == 28)
        {
          *(unsigned char *)(a1 + 24) = *((unsigned char *)v3 + 16);
        }
      }
      uint64_t v3 = (int *)*((void *)v3 + 1);
    }
    while (v3);
    for (uint64_t i = v30; v29 != v30; uint64_t i = v29)
    {
      if (*(unsigned char *)(a1 + 48))
      {
        unint64_t v21 = *(void *)(*(void *)a1 + 64) + 1;
        LOBYTE(v25.__vftable) = 0;
        sub_10011560C((char **)(a1 + 56), v21, (char *)&v25);
      }
      std::string::size_type v22 = v30 - 16;
      *(unsigned char *)(a1 + 24) = *(v30 - 16);
      uint64_t v23 = *((void *)v22 + 1);
      char v30 = v22;
      *(void *)(a1 + 40) = 0;
      sub_100115710(a1, *(void *)(v23 + 8), (char *)(v23 + 24), (_DWORD *)(v23 + 280), 1);
      *(void *)(a1 + 40) = 0;
      if (*(unsigned char *)(a1 + 48))
      {
        unint64_t v24 = *(void *)(*(void *)a1 + 64) + 1;
        LOBYTE(v25.__vftable) = 0;
        sub_10011560C((char **)(a1 + 56), v24, (char *)&v25);
      }
      sub_100115710(a1, *(void *)(v23 + 16), (char *)(v23 + 24), (_DWORD *)(v23 + 280), 2);
      *(_DWORD *)uint64_t v23 = sub_1001162FC(a1, (unsigned int *)v23);
    }
    *(unsigned char *)(a1 + 24) = v2;
    if (i)
    {
      char v30 = i;
      operator delete(i);
    }
  }
}

void sub_1001155B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::runtime_error a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a18)
  {
    a19 = (uint64_t)a18;
    operator delete(a18);
  }
  _Unwind_Resume(a1);
}

char *sub_10011560C(char **a1, unint64_t a2, char *a3)
{
  unint64_t v4 = a2;
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t result = *a1;
  if (v6 - (unint64_t)result >= a2)
  {
    unint64_t v12 = a1[1] - result;
    if (v12 >= a2) {
      unint64_t v13 = a2;
    }
    else {
      unint64_t v13 = a1[1] - result;
    }
    for (; v13; --v13)
      *result++ = *a3;
    BOOL v14 = a2 >= v12;
    unint64_t v15 = a2 - v12;
    if (v15 != 0 && v14)
    {
      uint64_t v16 = a1[1];
      uint64_t v17 = &v16[v15];
      do
      {
        *v16++ = *a3;
        --v15;
      }
      while (v15);
      a1[1] = v17;
    }
    else
    {
      a1[1] = &(*a1)[a2];
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      unint64_t v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if ((v4 & 0x8000000000000000) != 0) {
      sub_10002B5E0();
    }
    uint64_t v8 = 2 * v6;
    if (2 * v6 <= v4) {
      uint64_t v8 = v4;
    }
    if (v6 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v9 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v9 = v8;
    }
    uint64_t result = sub_10001495C(a1, v9);
    unint64_t v10 = a1[1];
    uint64_t v11 = &v10[v4];
    do
    {
      *v10++ = *a3;
      --v4;
    }
    while (v4);
    a1[1] = v11;
  }
  return result;
}

void sub_100115710(uint64_t a1, uint64_t a2, char *a3, _DWORD *a4, uint64_t a5)
{
  size_t v9 = *(const void **)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 64);
  uint64_t v11 = (void **)(a1 + 56);
  uint64_t v61 = 0;
  std::string::size_type v62 = 0;
  char v63 = 0;
  sub_1000148E0(&v61, v9, v10, v10 - (void)v9);
  uint64_t v64 = v11;
  if (!a2) {
    goto LABEL_140;
  }
  uint64_t v12 = a5;
  uint64_t v13 = 0;
  int v14 = 0;
  uint64_t v15 = 0;
  BOOL v16 = *(unsigned char *)(a1 + 24) != 0;
  uint64_t v17 = (int8x16_t *)(a3 + 1);
  int8x16_t v18 = vdupq_n_s8(v12);
  int v19 = 1;
  unsigned int v55 = v12;
  while (2)
  {
    int v20 = *(_DWORD *)a2;
    switch(*(_DWORD *)a2)
    {
      case 0:
        if (*(_DWORD *)(a2 + 16) != -3) {
          goto LABEL_31;
        }
        uint64_t v21 = *(void *)(*(void *)(a2 + 8) + 8);
        goto LABEL_32;
      case 1:
        uint64_t v26 = *(int *)(a2 + 16);
        if ((v26 & 0x80000000) == 0)
        {
          if (v15 && v14 && v14 == v26)
          {
            uint64_t v15 = 0;
            uint64_t v21 = v13;
          }
          else
          {
            if (v26)
            {
              if (*(unsigned char *)(*(void *)a1 + 400))
              {
                uint64_t v27 = *(void *)(*(void *)a1 + 72);
                if (v27)
                {
                  while (1)
                  {
                    if (*(_DWORD *)v27 == 29)
                    {
                      std::string v28 = *(_DWORD **)(v27 + 16);
                      if (!*v28 && v28[4] == v26) {
                        break;
                      }
                    }
                    uint64_t v27 = *(void *)(v27 + 8);
                    if (!v27) {
                      goto LABEL_31;
                    }
                  }
                  if ((*((unsigned char *)*v11 + v26) & 2) == 0)
                  {
                    *((unsigned char *)*v11 + v26) |= 2u;
                    int8x16_t v54 = v18;
                    sub_100115710(a1, *(void *)(v27 + 8), a3, a4, v55);
                    int8x16_t v18 = v54;
                    uint64_t v12 = v55;
                  }
                }
              }
            }
LABEL_31:
            uint64_t v21 = *(void *)(a2 + 8);
          }
LABEL_32:
          ++v19;
          a2 = v21;
          if (!v21) {
            goto LABEL_140;
          }
          continue;
        }
        if (!a3) {
          goto LABEL_124;
        }
        if (!*a3)
        {
LABEL_122:
          *((int8x16_t *)a3 + 15) = v18;
          *(int8x16_t *)(a3 + 209) = v18;
          *(int8x16_t *)(a3 + 225) = v18;
          *(int8x16_t *)(a3 + 177) = v18;
          *(int8x16_t *)(a3 + 193) = v18;
          *(int8x16_t *)(a3 + 145) = v18;
          *(int8x16_t *)(a3 + 161) = v18;
          *(int8x16_t *)(a3 + 113) = v18;
          *(int8x16_t *)(a3 + 129) = v18;
          *(int8x16_t *)(a3 + 81) = v18;
          *(int8x16_t *)(a3 + 97) = v18;
          *(int8x16_t *)(a3 + 49) = v18;
          *(int8x16_t *)(a3 + 65) = v18;
          *(int8x16_t *)(a3 + 17) = v18;
          *(int8x16_t *)(a3 + 33) = v18;
          int8x16_t *v17 = v18;
          char v49 = v12;
          goto LABEL_123;
        }
        for (uint64_t i = 0; i != 256; i += 16)
          *(int8x16_t *)&a3[i] = vorrq_s8(*(int8x16_t *)&a3[i], v18);
LABEL_121:
        char v49 = *a3;
LABEL_123:
        *a3 = v49 | 4;
LABEL_124:
        if (a4) {
LABEL_125:
        }
          *a4 |= v12;
LABEL_140:
        char v51 = v64;
        std::string::size_type v52 = *v64;
        *uint64_t v64 = v61;
        v51[1] = v62;
        uint64_t v53 = v51[2];
        v51[2] = v63;
        uint64_t v61 = v52;
        char v63 = v53;
        if (v52)
        {
          std::string::size_type v62 = v52;
          operator delete(v52);
        }
        return;
      case 2:
        if (a3)
        {
          uint64_t v42 = 0;
          *a3 |= 4u;
          int v43 = *(unsigned __int8 *)(a2 + 24);
          do
          {
            if (v16)
            {
              uint64_t v44 = *(void *)(**(void **)(a1 + 8) + 8);
              unsigned __int8 v45 = (*(uint64_t (**)(uint64_t, void))(*(void *)v44 + 40))(v44, (char)v42);
              LOBYTE(v12) = v55;
            }
            else
            {
              unsigned __int8 v45 = v42;
            }
            if (v43 == v45) {
              a3[v42] |= v12;
            }
            ++v42;
          }
          while (v42 != 256);
        }
        goto LABEL_140;
      case 4:
        if (a3)
        {
          *a3 |= 4u;
          a3[10] |= v12;
          a3[13] |= v12;
          a3[12] |= v12;
          a3[133] |= v12;
        }
        if (a4) {
          sub_100115710(a1, *(void *)(a2 + 8), 0, a4, v12);
        }
        goto LABEL_140;
      case 5:
        goto LABEL_112;
      case 6:
      case 0x1F:
        if (!a3) {
          goto LABEL_124;
        }
        if (!*a3) {
          goto LABEL_122;
        }
        for (uint64_t j = 0; j != 256; j += 16)
          *(int8x16_t *)&a3[j] = vorrq_s8(*(int8x16_t *)&a3[j], v18);
        goto LABEL_121;
      case 9:
        sub_100115710(a1, *(void *)(a2 + 8), a3, a4, v55);
        if (a3)
        {
          uint64_t v41 = 0;
          *a3 |= 4u;
          do
          {
            if (!sub_1000FE014(*(void *)(a1 + 8), (char)v41, *(_DWORD *)(a1 + 80))) {
              a3[v41] &= ~(_BYTE)v55;
            }
            ++v41;
          }
          while (v41 != 256);
        }
        goto LABEL_140;
      case 0xA:
        sub_100115710(a1, *(void *)(a2 + 8), a3, a4, v55);
        if (a3)
        {
          uint64_t v40 = 0;
          *a3 |= 4u;
          do
          {
            if (sub_1000FE014(*(void *)(a1 + 8), (char)v40, *(_DWORD *)(a1 + 80))) {
              a3[v40] &= ~(_BYTE)v55;
            }
            ++v40;
          }
          while (v40 != 256);
        }
        goto LABEL_140;
      case 0xC:
        goto LABEL_124;
      case 0xD:
        goto LABEL_110;
      case 0xE:
        if (!a3) {
          goto LABEL_140;
        }
        if (*(unsigned char *)(a2 + 37))
        {
          uint64_t v39 = 0;
          *a3 |= 4u;
          do
          {
            LOBYTE(v57.__vftable) = v39;
            if (&v57 != (std::runtime_error *)sub_100116374((std::string::value_type *)&v57, (std::string::value_type *)&v57.__vftable + 1, a2, *(void *)a1, v16))a3[v39] |= v55; {
            ++v39;
            }
          }
          while (v39 != 256);
          goto LABEL_140;
        }
        if (!*a3) {
          goto LABEL_138;
        }
        for (uint64_t k = 0; k != 256; k += 16)
          *(int8x16_t *)&a3[k] = vorrq_s8(*(int8x16_t *)&a3[k], v18);
        goto LABEL_116;
      case 0xF:
        if (a3)
        {
          uint64_t v36 = 0;
          *a3 |= 4u;
          do
          {
            if (v16)
            {
              uint64_t v37 = *(void *)(**(void **)(a1 + 8) + 8);
              unsigned __int8 v38 = (*(uint64_t (**)(uint64_t, void))(*(void *)v37 + 40))(v37, (char)v36);
              LOBYTE(v12) = v55;
            }
            else
            {
              unsigned __int8 v38 = v36;
            }
            if (*(unsigned char *)(a2 + v38 + 16)) {
              a3[v36] |= v12;
            }
            ++v36;
          }
          while (v36 != 256);
        }
        goto LABEL_140;
      case 0x10:
        uint64_t v21 = *(void *)(a2 + 16);
        int v19 = -1;
        goto LABEL_32;
      case 0x11:
      case 0x12:
      case 0x16:
      case 0x17:
      case 0x18:
      case 0x19:
        if ((*(unsigned char *)(a2 + 24) & 4) != 0)
        {
          if (a3)
          {
            uint64_t v34 = 0;
            *a3 |= 4u;
            do
            {
              if ((*(unsigned char *)(a2 + 24 + v34) & 3) != 0) {
                a3[v34] |= v12;
              }
              ++v34;
            }
            while (v34 != 256);
          }
          if (a4 && (*(unsigned char *)(a2 + 280) & 3) != 0) {
            goto LABEL_125;
          }
          goto LABEL_140;
        }
        if ((v20 - 22) >= 4 && v20 != 18) {
          goto LABEL_129;
        }
        unsigned int v30 = *(_DWORD *)(a2 + 304);
        if (v30 <= 0x3F)
        {
          uint64_t v31 = *(void *)(a1 + 40);
          uint64_t v32 = 1 << v30;
          if ((v31 & v32) == 0)
          {
            if ((v20 - 22) < 4 || v20 == 18) {
              *(void *)(a1 + 40) = v31 | v32;
            }
LABEL_129:
            sub_100115710(a1, *(void *)(a2 + 8), a3, a4, v55);
            if (*(_DWORD *)a2 == 17 || !*(void *)(a2 + 288) || !v19) {
              sub_100115710(a1, *(void *)(a2 + 16), a3, a4, v55);
            }
            goto LABEL_140;
          }
        }
        if (!a3) {
          goto LABEL_124;
        }
        if (*a3)
        {
          for (uint64_t m = 0; m != 256; m += 16)
            *(int8x16_t *)&a3[m] = vorrq_s8(*(int8x16_t *)&a3[m], v18);
          goto LABEL_121;
        }
        goto LABEL_122;
      case 0x14:
        if (a3)
        {
          *a3 |= 4u;
          a3[10] |= v12;
          a3[13] |= v12;
        }
        goto LABEL_124;
      case 0x1C:
        BOOL v16 = *(unsigned char *)(a2 + 16) != 0;
        goto LABEL_31;
      case 0x1D:
        uint64_t v21 = *(void *)(a2 + 16);
        int v14 = *(_DWORD *)(v21 + 16);
        unint64_t v24 = *v11;
        char v25 = *((unsigned char *)*v11 + v14);
        if (v25)
        {
          uint64_t v46 = *(void *)a1;
          if (!*(_DWORD *)(*(void *)a1 + 44)) {
            *(_DWORD *)(v46 + 44) = 2;
          }
          *(void *)(v46 + 48) = 0;
          *(void *)(v46 + 56) = 0;
          if ((*(unsigned char *)(v46 + 42) & 4) == 0)
          {
            sub_100018888(&v60, "Encountered an infinite recursion.");
            std::runtime_error::runtime_error(&v57, &v60);
            v57.__vftable = (std::runtime_error_vtbl *)&off_1001BD3D0;
            int v58 = 2;
            uint64_t v59 = 0;
            sub_100101EA4((uint64_t)&v57);
          }
          char v25 = v24[v14];
LABEL_109:
          v24[v14] = v25 | 1;
LABEL_110:
          if (a4) {
            *a4 |= v12;
          }
LABEL_112:
          if (a3)
          {
            if (*a3)
            {
              for (uint64_t n = 0; n != 256; n += 16)
                *(int8x16_t *)&a3[n] = vorrq_s8(*(int8x16_t *)&a3[n], v18);
LABEL_116:
              LOBYTE(v12) = *a3;
            }
            else
            {
LABEL_138:
              *((int8x16_t *)a3 + 15) = v18;
              *(int8x16_t *)(a3 + 209) = v18;
              *(int8x16_t *)(a3 + 225) = v18;
              *(int8x16_t *)(a3 + 177) = v18;
              *(int8x16_t *)(a3 + 193) = v18;
              *(int8x16_t *)(a3 + 145) = v18;
              *(int8x16_t *)(a3 + 161) = v18;
              *(int8x16_t *)(a3 + 113) = v18;
              *(int8x16_t *)(a3 + 129) = v18;
              *(int8x16_t *)(a3 + 81) = v18;
              *(int8x16_t *)(a3 + 97) = v18;
              *(int8x16_t *)(a3 + 49) = v18;
              *(int8x16_t *)(a3 + 65) = v18;
              *(int8x16_t *)(a3 + 17) = v18;
              *(int8x16_t *)(a3 + 33) = v18;
              int8x16_t *v17 = v18;
            }
            *a3 = v12 | 4;
          }
          goto LABEL_140;
        }
        if (v15) {
          goto LABEL_109;
        }
        uint64_t v13 = *(void *)(a2 + 8);
        v24[v14] = v25 | 1;
        uint64_t v15 = a2;
        goto LABEL_32;
      case 0x20:
        if (a3)
        {
          if (*a3)
          {
            for (iuint64_t i = 0; ii != 256; ii += 16)
              *(int8x16_t *)&a3[ii] = vorrq_s8(*(int8x16_t *)&a3[ii], v18);
            char v23 = *a3;
          }
          else
          {
            *((int8x16_t *)a3 + 15) = v18;
            *(int8x16_t *)(a3 + 209) = v18;
            *(int8x16_t *)(a3 + 225) = v18;
            *(int8x16_t *)(a3 + 177) = v18;
            *(int8x16_t *)(a3 + 193) = v18;
            *(int8x16_t *)(a3 + 145) = v18;
            *(int8x16_t *)(a3 + 161) = v18;
            *(int8x16_t *)(a3 + 113) = v18;
            *(int8x16_t *)(a3 + 129) = v18;
            *(int8x16_t *)(a3 + 81) = v18;
            *(int8x16_t *)(a3 + 97) = v18;
            *(int8x16_t *)(a3 + 49) = v18;
            *(int8x16_t *)(a3 + 65) = v18;
            *(int8x16_t *)(a3 + 17) = v18;
            *(int8x16_t *)(a3 + 33) = v18;
            char v23 = v12;
            int8x16_t *v17 = v18;
          }
          *a3 = v23 | 4;
        }
        goto LABEL_31;
      default:
        goto LABEL_31;
    }
  }
}

void sub_100115F3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::runtime_error a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,void *a24,void *a25,void **a26)
{
  std::runtime_error::~runtime_error(&a14);
  if (a22 < 0) {
    operator delete(__p);
  }
  uint64_t v27 = a26;
  std::string v28 = *a26;
  *a26 = a23;
  v27[1] = a24;
  uint64_t v29 = (uint64_t)v27[2];
  v27[2] = a25;
  a23 = v28;
  a25 = (void *)v29;
  if (v28)
  {
    a24 = v28;
    operator delete(v28);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10011604C(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  while (1)
  {
    int v2 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 >= 2u) {
      break;
    }
    a2 = *(void *)(a2 + 8);
    if (!a2) {
      return 0;
    }
  }
  if (v2 > 10)
  {
    if (v2 == 11)
    {
      return 3;
    }
    else
    {
      if (v2 != 21) {
        return 0;
      }
      return 4;
    }
  }
  else
  {
    if (v2 != 3) {
      return v2 == 9;
    }
    return 2;
  }
}

uint64_t sub_1001160B4(uint64_t result, int *a2)
{
  do
  {
    unsigned int v2 = *a2;
    if (*a2 > 0x19) {
      break;
    }
    if (((1 << v2) & 0x201F9A) == 0)
    {
      if (v2)
      {
        if (((1 << v2) & 0x3C00000) != 0 && !*(unsigned char *)(result + 32)) {
          *((unsigned char *)a2 + 308) = 1;
        }
        return result;
      }
      unsigned int v3 = a2[4];
      if ((v3 & 0x80000000) != 0)
      {
        if (v3 < 0xFFFFFFFE)
        {
          if (v3 != -3) {
            return result;
          }
          unint64_t v4 = (int **)(a2 + 2);
        }
        else
        {
          unint64_t v4 = (int **)(*((void *)a2 + 1) + 16);
        }
        a2 = *v4;
      }
    }
    a2 = (int *)*((void *)a2 + 1);
  }
  while (a2);
  return result;
}

uint64_t sub_100116144(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    uint64_t v4 = 0;
    while (2)
    {
      switch(*(_DWORD *)v2)
      {
        case 0:
          unsigned int v5 = *(_DWORD *)(v2 + 16);
          if (v5 < 0xFFFFFFFE)
          {
            if (v5 != -3) {
              goto LABEL_22;
            }
            uint64_t v6 = *(void *)(v2 + 8);
          }
          else
          {
            uint64_t v6 = *(void *)(*(void *)(v2 + 8) + 16);
          }
          uint64_t v7 = (uint64_t *)(v6 + 8);
          goto LABEL_15;
        case 1:
          if (*(_DWORD *)(v2 + 16) > 0xFFFFFFFD) {
            return v4;
          }
          goto LABEL_22;
        case 2:
          uint64_t v4 = (*(_DWORD *)(v2 + 16) + v4);
          goto LABEL_22;
        case 5:
        case 0xF:
          goto LABEL_21;
        case 0xD:
        case 0x12:
        case 0x13:
        case 0x16:
        case 0x17:
        case 0x18:
        case 0x19:
        case 0x1A:
          int v8 = sub_1001162FC(a1, (unsigned int *)v2);
          *(_DWORD *)uint64_t v2 = v8;
          if ((v8 - 22) >= 3 && (v8 != 25 || !*(unsigned char *)(*(void *)(v2 + 8) + 37))) {
            return 0xFFFFFFFFLL;
          }
          uint64_t v9 = *(void *)(v2 + 296);
          if (v9 != *(void *)(v2 + 288)) {
            return 0xFFFFFFFFLL;
          }
          uint64_t v4 = (v4 + v9);
          goto LABEL_14;
        case 0xE:
          if (!*(unsigned char *)(v2 + 37)) {
            return 0xFFFFFFFFLL;
          }
LABEL_21:
          uint64_t v4 = (v4 + 1);
          goto LABEL_22;
        case 0x10:
LABEL_14:
          uint64_t v7 = (uint64_t *)(v2 + 16);
          goto LABEL_15;
        case 0x11:
          int v11 = sub_100116144(a1, *(void *)(v2 + 8));
          if (v11 != sub_100116144(a1, *(void *)(v2 + 16)) || v11 <= -1) {
            return 0xFFFFFFFFLL;
          }
          else {
            return (v11 + v4);
          }
        default:
LABEL_22:
          uint64_t v7 = (uint64_t *)(v2 + 8);
LABEL_15:
          uint64_t v2 = *v7;
          if (!*v7) {
            return 0xFFFFFFFFLL;
          }
          continue;
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1001162FC(uint64_t a1, unsigned int *a2)
{
  uint64_t result = *a2;
  if (result == 18)
  {
    uint64_t v3 = *((void *)a2 + 1);
    if (*(void *)(*(void *)(v3 + 8) + 8) == *((void *)a2 + 2))
    {
      int v4 = *(_DWORD *)v3;
      if (*(int *)v3 > 13)
      {
        if (v4 == 14)
        {
          if (*(unsigned char *)(v3 + 37)) {
            return 25;
          }
        }
        else if (v4 == 15)
        {
          return 24;
        }
      }
      else if (v4 == 2)
      {
        return 23;
      }
      else if (v4 == 5)
      {
        return 22;
      }
    }
  }
  return result;
}

std::string::value_type *sub_100116374(std::string::value_type *a1, std::string::value_type *a2, uint64_t a3, uint64_t a4, int a5)
{
  unsigned int v5 = a1;
  if (a1 == a2) {
    return v5;
  }
  uint64_t v9 = (const std::string::value_type *)(a3 + 40);
  uint64_t v10 = *(uint64_t **)(a4 + 24);
  if (*(_DWORD *)(a3 + 16))
  {
    unsigned int v12 = 0;
    do
    {
      LOBYTE(v13) = *v9;
      if (*v9)
      {
        uint64_t v14 = 0;
        do
        {
          std::string::value_type v15 = v5[v14];
          if (a5)
          {
            std::string::value_type v15 = (*(uint64_t (**)(void, void))(**(void **)(*v10 + 8) + 40))(*(void *)(*v10 + 8), v15);
            LOBYTE(v13) = v9[v14];
          }
          if (v15 != v13) {
            break;
          }
          BOOL v16 = &v9[v14++];
          int v13 = *((unsigned __int8 *)v16 + 1);
        }
        while (v13 && &v5[v14] != a2);
        int8x16_t v18 = &v5[v14];
        v9 += v14;
        if (!(_BYTE)v13)
        {
          if (v18 == v5) {
            int8x16_t v18 = v5 + 1;
          }
          if (!*(unsigned char *)(a3 + 36)) {
            return v18;
          }
          return v5;
        }
        while (*(unsigned __int8 *)v9++)
          ;
      }
      else
      {
        std::string::value_type v20 = *v5;
        if (a5) {
          std::string::value_type v20 = (*(uint64_t (**)(void, void))(**(void **)(*v10 + 8) + 40))(*(void *)(*v10 + 8), v20);
        }
        if (!v20) {
          goto LABEL_94;
        }
        ++v9;
      }
      ++v12;
    }
    while (v12 < *(_DWORD *)(a3 + 16));
  }
  std::string::value_type v21 = *v5;
  if (a5) {
    std::string::value_type v21 = (*(uint64_t (**)(void, void))(**(void **)(*v10 + 8) + 40))(*(void *)(*v10 + 8), v21);
  }
  if (!*(_DWORD *)(a3 + 20))
  {
    if (!*(_DWORD *)(a3 + 24)) {
      goto LABEL_90;
    }
    memset(&v40, 0, sizeof(v40));
    goto LABEL_64;
  }
  memset(&v40, 0, sizeof(v40));
  if ((*(unsigned char *)(a4 + 42) & 0x20) != 0)
  {
    std::string::value_type v38 = v21;
    std::string::value_type v39 = 0;
    sub_10010108C(*v10, &v37);
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v40.__r_.__value_.__l.__data_);
    }
    std::string v40 = v37;
  }
  else
  {
    std::string::assign(&v40, 1uLL, v21);
  }
  if (!*(_DWORD *)(a3 + 20))
  {
LABEL_64:
    if (!*(_DWORD *)(a3 + 24)) {
      goto LABEL_83;
    }
    std::string::value_type v38 = v21;
    std::string::value_type v39 = 0;
    sub_100101264(*v10, &v38, &v39, (uint64_t *)&v37);
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v40.__r_.__value_.__l.__data_);
    }
    std::string v40 = v37;
    if (!*(_DWORD *)(a3 + 24))
    {
LABEL_83:
      char v34 = 1;
      goto LABEL_86;
    }
    int v30 = 0;
    while (1)
    {
      if (!*v9)
      {
        if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          int v31 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
          if (HIBYTE(v40.__r_.__value_.__r.__words[2]) == 1)
          {
            uint64_t v32 = &v40;
            goto LABEL_77;
          }
          goto LABEL_78;
        }
        if (v40.__r_.__value_.__l.__size_ == 1)
        {
          uint64_t v32 = (std::string *)v40.__r_.__value_.__r.__words[0];
LABEL_77:
          int v31 = v32->__r_.__value_.__s.__data_[0];
LABEL_78:
          if (!v31) {
            goto LABEL_84;
          }
          goto LABEL_79;
        }
        if (!v40.__r_.__value_.__l.__size_) {
          goto LABEL_84;
        }
      }
LABEL_79:
      if (!std::string::compare(&v40, v9)) {
        goto LABEL_84;
      }
      ++v9;
      while (*(unsigned __int8 *)v9++)
        ;
      if (++v30 >= *(_DWORD *)(a3 + 24)) {
        goto LABEL_83;
      }
    }
  }
  int v22 = 0;
  while (1)
  {
    if (!*v9)
    {
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
      {
        if (!v40.__r_.__value_.__l.__size_) {
          goto LABEL_36;
        }
        if (v40.__r_.__value_.__l.__size_ != 1) {
          goto LABEL_35;
        }
        uint64_t v27 = (std::string *)v40.__r_.__value_.__r.__words[0];
        goto LABEL_52;
      }
      if (!*((unsigned char *)&v40.__r_.__value_.__s + 23)) {
        goto LABEL_36;
      }
      if (HIBYTE(v40.__r_.__value_.__r.__words[2]) == 1)
      {
        uint64_t v27 = &v40;
LABEL_52:
        if (!v27->__r_.__value_.__s.__data_[0]) {
          goto LABEL_36;
        }
      }
    }
LABEL_35:
    if (std::string::compare(&v40, v9) < 0)
    {
      char v23 = v9 + 1;
      while (*(unsigned __int8 *)v23++)
        ;
      goto LABEL_61;
    }
LABEL_36:
    char v23 = v9 + 1;
    while (*(unsigned __int8 *)v23++)
      ;
    if (*v23) {
      goto LABEL_60;
    }
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
    {
      if (v40.__r_.__value_.__l.__size_ != 1)
      {
        if (!v40.__r_.__value_.__l.__size_) {
          break;
        }
        goto LABEL_60;
      }
      uint64_t v26 = (std::string *)v40.__r_.__value_.__r.__words[0];
    }
    else
    {
      int v25 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
      if (HIBYTE(v40.__r_.__value_.__r.__words[2]) != 1) {
        goto LABEL_59;
      }
      uint64_t v26 = &v40;
    }
    int v25 = v26->__r_.__value_.__s.__data_[0];
LABEL_59:
    if (!v25) {
      break;
    }
LABEL_60:
    if (std::string::compare(&v40, v23) <= 0) {
      break;
    }
LABEL_61:
    uint64_t v9 = v23 + 1;
    while (*(unsigned __int8 *)v9++)
      ;
    if (++v22 >= *(_DWORD *)(a3 + 20)) {
      goto LABEL_64;
    }
  }
LABEL_84:
  char v34 = 0;
  if (!*(unsigned char *)(a3 + 36)) {
    ++v5;
  }
LABEL_86:
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v40.__r_.__value_.__l.__data_);
    if (v34) {
      goto LABEL_90;
    }
  }
  else
  {
    if ((v34 & 1) == 0) {
      return v5;
    }
LABEL_90:
    if (!sub_1000FE014((uint64_t)v10, v21, *(_DWORD *)(a3 + 28)))
    {
      int v35 = *(_DWORD *)(a3 + 32);
      if (!v35 || sub_1000FE014((uint64_t)v10, v21, v35))
      {
        v5 += *(unsigned __int8 *)(a3 + 36);
        return v5;
      }
    }
LABEL_94:
    if (!*(unsigned char *)(a3 + 36)) {
      ++v5;
    }
  }
  return v5;
}

void sub_1001167DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100116800(uint64_t a1, uint64_t a2, const void **a3)
{
  long long v14 = 0uLL;
  uint64_t v15 = 0;
  ctu::cf::assign();
  uint64_t v13 = 0;
  long long __s1 = 0uLL;
  if (sub_10008BB8C(&__s1, "com.apple.Telephony.RCSMessageProvisioning")
    || sub_10008BB8C(&__s1, "com.apple.Telephony.RCSMessageSessionSetup")
    || sub_10008BB8C(&__s1, "com.apple.Telephony.RCSPagerMessageSendReceive")
    || sub_10008BB8C(&__s1, "com.apple.Telephony.RCSMSRPMessageSendReceive")
    || sub_10008BB8C(&__s1, "com.apple.Telephony.RCSMessageSIPOptions")
    || sub_10008BB8C(&__s1, "com.apple.Telephony.RCSSIPRefer")
    || sub_10008BB8C(&__s1, "com.apple.Telephony.RCSMessageSessionEnd")
    || sub_10008BB8C(&__s1, "com.apple.Telephony.metricCCStwCPSummary")
    || sub_10008BB8C(&__s1, "com.apple.Telephony.metricCCStwRequest")
    || sub_10008BB8C(&__s1, "com.apple.Telephony.metricCCStwMessageOutgoing")
    || sub_10008BB8C(&__s1, "com.apple.telephony.metricCCStwMessageIncoming")
    || sub_10008BB8C(&__s1, "com.apple.IDS.QualifiedContacts")
    || sub_10008BB8C(&__s1, "com.apple.Messages.IMMetricsCollectorEventSMSSentMessageSingleComponent")
    || sub_10008BB8C(&__s1, "com.apple.Messages.IMMetricsCollectorEventIMessageSentMessageSingleComponent")
    || sub_10008BB8C(&__s1, "com.apple.IDS.OffTheGridMode")
    || sub_10008BB8C(&__s1, "com.apple.Telephony.atm_Registration_Result"))
  {
    long long v14 = 0uLL;
    uint64_t v15 = 0;
    ctu::cf::assign();
    *(_OWORD *)int v8 = v14;
    uint64_t v9 = v15;
    if (v15 >= 0) {
      int v4 = (char *)v8;
    }
    else {
      int v4 = (char *)v8[0];
    }
    sub_100018888(__p, v4);
    sub_100118344(&v5, a3);
    sub_100117158((uint64_t)v6);
    sub_10008B124((std::string::size_type)__p, (uint64_t)v6);
    sub_100118400(&v7, v6[0]);
    sub_10005AC84(&v5);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v9) < 0) {
      operator delete(v8[0]);
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 112), OS_LOG_TYPE_ERROR))
  {
    sub_10014B6EC();
  }
  if (SHIBYTE(v13) < 0) {
    operator delete((void *)__s1);
  }
}

void sub_100116C3C(void *a1)
{
  if (*(char *)(v1 - 33) < 0) {
    operator delete(*(void **)(v1 - 56));
  }
  sub_10001F4A8(a1);
}

void sub_100116C94(uint64_t a1, const void **a2)
{
  if (sub_1001172B4())
  {
    sub_100118344(&v17, a2);
    sub_100117158((uint64_t)&v18);
    sub_10005AC84(&v17);
    sub_100018888(&__p, "calling_client");
    sub_100117320("", (unsigned __int8 *)&v18, (const void **)&__p.__r_.__value_.__l.__data_, &buf);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      BOOL v6 = buf.__r_.__value_.__l.__size_ != 28
        || *(void *)buf.__r_.__value_.__l.__data_ != 0x72616C756C6C6543
        || *(void *)(buf.__r_.__value_.__r.__words[0] + 8) != 0x6761694461746144
        || *(void *)(buf.__r_.__value_.__r.__words[0] + 16) != 0x5373636974736F6ELL
        || *(_DWORD *)(buf.__r_.__value_.__r.__words[0] + 24) != 1702127989;
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    else
    {
      BOOL v6 = SHIBYTE(buf.__r_.__value_.__r.__words[2]) != 28
        || buf.__r_.__value_.__r.__words[0] != 0x72616C756C6C6543
        || buf.__r_.__value_.__l.__size_ != 0x6761694461746144
        || buf.__r_.__value_.__r.__words[2] != 0x5373636974736F6ELL
        || v23 != 1702127989;
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    char v11 = *(NSObject **)(qword_1001D8080 + 112);
    if (v6)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"CellularDataDiagnosticsSuite";
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "cahandler:#I Speed is not called by: %s and hence skipping", (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
        sub_10014B7C4(v11);
      }
      sub_1001173A4(&v18, (uint64_t)v14);
      sub_100086618(2, &buf);
      std::string __p = buf;
      memset(&buf, 0, sizeof(buf));
      ctu::path_join_impl();
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      sub_10002FEDC((void (__cdecl ***)(std::ofstream *__hidden))&buf);
      if ((v24[*(void *)(buf.__r_.__value_.__r.__words[0] - 24)] & 5) != 0)
      {
        if (os_log_type_enabled(*(os_log_t *)(qword_1001D8080 + 112), OS_LOG_TYPE_ERROR)) {
          sub_10014B758();
        }
      }
      else
      {
        sub_100117E98((uint64_t *)&buf, (uint64_t)v14);
        if (!std::filebuf::close()) {
          std::ios_base::clear((std::ios_base *)((char *)&buf + *(void *)(buf.__r_.__value_.__r.__words[0] - 24)), *(_DWORD *)&v24[*(void *)(buf.__r_.__value_.__r.__words[0] - 24)] | 4);
        }
        unsigned int v12 = *(NSObject **)(qword_1001D8080 + 112);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
        {
          p_p = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::string::value_type v20 = 136315138;
          std::string::value_type v21 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "cahandler:#I Wrote speed event to disk at: %s", v20, 0xCu);
        }
      }
      std::filebuf::~filebuf();
      std::ostream::~ostream();
      std::ios::~ios();
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      sub_100118400(&v15, v14[0]);
    }
    sub_100118400(&v19, v18);
  }
  else
  {
    uint64_t v7 = *(NSObject **)(qword_1001D8080 + 112);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_10014B848(v7);
    }
  }
}

void sub_100117124(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a2)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
    sub_10001F4A8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100117158(uint64_t a1@<X8>)
{
  long long v6 = 0uLL;
  uint64_t v7 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = 0uLL;
  uint64_t v5 = 0;
  *(unsigned char *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  void v8[3] = 0;
  sub_1001180C0((uint64_t)__p, (uint64_t)v8, 1, (uint64_t)v2);
  *(unsigned char *)a1 = v2[0];
  v2[0] = 0;
  *(void *)(a1 + 8) = v3;
  uint64_t v3 = 0;
  sub_100118400(&v3, 0);
  sub_10011837C(v8);
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10011723C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24)
{
  sub_10011837C(&a24);
  if (a2 == 1)
  {
    sub_10014B88C(a1);
    __cxa_end_catch();
    JUMPOUT(0x1001171FCLL);
  }
  sub_100118400(v24, 0);
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1001172B4()
{
  sub_100086618(2, &__p);
  uint64_t v0 = sub_10002FA28(&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v0;
}

void sub_100117304(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100117320(char *__s@<X2>, unsigned __int8 *a2@<X0>, const void **a3@<X1>, std::string *a4@<X8>)
{
  sub_100018888(__p, __s);
  sub_100118DB4(a2, a3, (uint64_t)__p, a4);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100117388(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001173A4(const void ****a1@<X1>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  LOBYTE(v119) = 0;
  int v120 = 0;
  LOBYTE(v117) = 0;
  unsigned int v118 = 0;
  int v4 = (wis *)sub_100122DC0((uint64_t)&v115, 0, 0, 0, 2);
  WISTimestamp = (char **)wis::getWISTimestamp(v4);
  sub_1000155F0(&v112, (const void **)4);
  BOOL v114 = 0;
  char v113 = 3;
  long long v6 = (char **)operator new(0x18uLL);
  *(std::string *)long long v6 = v112;
  memset(&v112, 0, sizeof(v112));
  BOOL v114 = v6;
  uint64_t v7 = sub_100098078(a2, "model");
  int v8 = *v7;
  char *v7 = v113;
  char v113 = v8;
  uint64_t v9 = (char **)*((void *)v7 + 1);
  *((void *)v7 + 1) = v114;
  BOOL v114 = v9;
  sub_100118400(&v114, v8);
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v112.__r_.__value_.__l.__data_);
  }
  sub_1000155F0(&v112, (const void **)3);
  char v110 = 3;
  uint64_t v10 = (char **)operator new(0x18uLL);
  *(std::string *)uint64_t v10 = v112;
  BOOL v111 = v10;
  memset(&v112, 0, sizeof(v112));
  char v11 = sub_100098078(a2, "deviceId");
  int v12 = *v11;
  *char v11 = v110;
  char v110 = v12;
  uint64_t v13 = (char **)*((void *)v11 + 1);
  *((void *)v11 + 1) = v111;
  BOOL v111 = v13;
  sub_100118400(&v111, v12);
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v112.__r_.__value_.__l.__data_);
  }
  sub_1000155F0(&v112, 0);
  char v108 = 3;
  long long v14 = (char **)operator new(0x18uLL);
  *(std::string *)long long v14 = v112;
  memset(&v112, 0, sizeof(v112));
  long long v109 = v14;
  uint64_t v15 = sub_100098078((uint64_t)&v117, "softwareBuild");
  int v16 = *v15;
  char *v15 = v108;
  char v108 = v16;
  uint64_t v17 = (char **)*((void *)v15 + 1);
  *((void *)v15 + 1) = v109;
  long long v109 = v17;
  sub_100118400(&v109, v16);
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v112.__r_.__value_.__l.__data_);
  }
  sub_1000155F0(&v112, (const void **)1);
  char v106 = 3;
  int8x16_t v18 = (char **)operator new(0x18uLL);
  *(std::string *)int8x16_t v18 = v112;
  memset(&v112, 0, sizeof(v112));
  uint64_t v107 = v18;
  int v19 = sub_100098078((uint64_t)&v117, "buildtype");
  int v20 = *v19;
  *int v19 = v106;
  char v106 = v20;
  std::string::value_type v21 = (char **)*((void *)v19 + 1);
  *((void *)v19 + 1) = v107;
  uint64_t v107 = v21;
  sub_100118400(&v107, v20);
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v112.__r_.__value_.__l.__data_);
  }
  char v104 = 5;
  unsigned int v105 = (char **)sub_10006FAF0();
  int v22 = sub_100098078((uint64_t)&v117, "tz_offset");
  int v23 = *v22;
  char *v22 = 5;
  char v104 = v23;
  unint64_t v24 = (char **)*((void *)v22 + 1);
  *((void *)v22 + 1) = v105;
  unsigned int v105 = v24;
  sub_100118400(&v105, v23);
  sub_1000155F0(&v112, (const void **)4);
  char v102 = 3;
  int v25 = (char **)operator new(0x18uLL);
  *(std::string *)int v25 = v112;
  memset(&v112, 0, sizeof(v112));
  unsigned int v103 = v25;
  uint64_t v26 = sub_100098078((uint64_t)&v117, "model");
  int v27 = *v26;
  *uint64_t v26 = v102;
  char v102 = v27;
  std::string v28 = (char **)*((void *)v26 + 1);
  *((void *)v26 + 1) = v103;
  unsigned int v103 = v28;
  sub_100118400(&v103, v27);
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v112.__r_.__value_.__l.__data_);
  }
  sub_1000155F0(&v112, (const void **)5);
  char v100 = 3;
  uint64_t v29 = (char **)operator new(0x18uLL);
  *(std::string *)uint64_t v29 = v112;
  memset(&v112, 0, sizeof(v112));
  uint64_t v101 = v29;
  int v30 = sub_100098078((uint64_t)&v117, "firmwareVersion");
  int v31 = *v30;
  *int v30 = v100;
  char v100 = v31;
  uint64_t v32 = (char **)*((void *)v30 + 1);
  *((void *)v30 + 1) = v101;
  uint64_t v101 = v32;
  sub_100118400(&v101, v31);
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v112.__r_.__value_.__l.__data_);
  }
  char v98 = 6;
  int v99 = WISTimestamp;
  std::string::size_type v33 = sub_100098078((uint64_t)&v117, "metricFileTs");
  int v34 = *v33;
  *std::string::size_type v33 = 6;
  char v98 = v34;
  int v35 = (char **)*((void *)v33 + 1);
  *((void *)v33 + 1) = v99;
  int v99 = v35;
  sub_100118400(&v99, v34);
  char v96 = 6;
  unsigned int v97 = WISTimestamp;
  uint64_t v36 = sub_100098078((uint64_t)&v117, "timestamp");
  int v37 = *v36;
  char *v36 = 6;
  char v96 = v37;
  std::string::value_type v38 = (char **)*((void *)v36 + 1);
  *((void *)v36 + 1) = v97;
  unsigned int v97 = v38;
  sub_100118400(&v97, v37);
  char v94 = 3;
  std::string v95 = (char **)sub_10012352C("cd");
  std::string::value_type v39 = sub_100098078((uint64_t)&v117, "type");
  int v40 = *v39;
  *std::string::value_type v39 = 3;
  char v94 = v40;
  uint64_t v41 = (char **)*((void *)v39 + 1);
  *((void *)v39 + 1) = v95;
  std::string v95 = v41;
  sub_100118400(&v95, v40);
  char v92 = 3;
  int v93 = (char **)sub_100123578("2.0");
  uint64_t v42 = sub_100098078((uint64_t)a1, "metric_version");
  int v43 = *v42;
  *uint64_t v42 = 3;
  char v92 = v43;
  uint64_t v44 = (char **)*((void *)v42 + 1);
  *((void *)v42 + 1) = v93;
  int v93 = v44;
  sub_100118400(&v93, v43);
  char v90 = 3;
  uint64_t v91 = (char **)sub_1001235C4(&off_1001BDFB8);
  unsigned __int8 v45 = sub_100098078((uint64_t)&v119, "metricName");
  int v46 = *v45;
  char *v45 = 3;
  char v90 = v46;
  std::string::size_type v47 = (char **)*((void *)v45 + 1);
  *((void *)v45 + 1) = v91;
  uint64_t v91 = v47;
  sub_100118400(&v91, v46);
  char v88 = 3;
  std::string::size_type v89 = (char **)sub_100123610("metric");
  int v48 = sub_100098078((uint64_t)&v119, "type");
  int v49 = *v48;
  char *v48 = 3;
  char v88 = v49;
  char v50 = (char **)*((void *)v48 + 1);
  *((void *)v48 + 1) = v89;
  std::string::size_type v89 = v50;
  sub_100118400(&v89, v49);
  char v86 = 6;
  int v87 = WISTimestamp;
  char v51 = sub_100098078((uint64_t)&v119, "timestamp");
  int v52 = *v51;
  *char v51 = 6;
  char v86 = v52;
  uint64_t v53 = (char **)*((void *)v51 + 1);
  *((void *)v51 + 1) = v87;
  int v87 = v53;
  sub_100118400(&v87, v52);
  sub_10012365C((uint64_t)v84, a1);
  int8x16_t v54 = sub_100098078((uint64_t)&v119, "object");
  int v55 = *v54;
  char *v54 = v84[0];
  v84[0] = v55;
  uint64_t v56 = (char **)*((void *)v54 + 1);
  *((void *)v54 + 1) = v85;
  unsigned int v85 = v56;
  sub_100118400(&v85, v55);
  sub_100018888(&v81, "networkPerformanceMetric");
  std::runtime_error v57 = std::string::append(&v81, ":");
  long long v58 = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
  v112.__r_.__value_.__r.__words[2] = v57->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v112.__r_.__value_.__l.__data_ = v58;
  v57->__r_.__value_.__l.__size_ = 0;
  v57->__r_.__value_.__r.__words[2] = 0;
  v57->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v80, (unint64_t)WISTimestamp);
  if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v59 = &v80;
  }
  else {
    uint64_t v59 = (std::string *)v80.__r_.__value_.__r.__words[0];
  }
  if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v80.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v80.__r_.__value_.__l.__size_;
  }
  uint64_t v61 = std::string::append(&v112, (const std::string::value_type *)v59, size);
  std::string::size_type v62 = v61->__r_.__value_.__r.__words[0];
  v121[0] = v61->__r_.__value_.__l.__size_;
  *(void *)((char *)v121 + 7) = *(std::string::size_type *)((char *)&v61->__r_.__value_.__r.__words[1] + 7);
  char v63 = HIBYTE(v61->__r_.__value_.__r.__words[2]);
  v61->__r_.__value_.__l.__size_ = 0;
  v61->__r_.__value_.__r.__words[2] = 0;
  v61->__r_.__value_.__r.__words[0] = 0;
  uint64_t v83 = 0;
  char v82 = 3;
  uint64_t v64 = operator new(0x18uLL);
  uint64_t v65 = v121[0];
  *uint64_t v64 = v62;
  v64[1] = v65;
  *(void *)((char *)v64 + 15) = *(void *)((char *)v121 + 7);
  *((unsigned char *)v64 + 23) = v63;
  uint64_t v83 = (char **)v64;
  uint64_t v66 = sub_100098078((uint64_t)&v119, "metricLogInfo");
  int v67 = *v66;
  char *v66 = v82;
  char v82 = v67;
  uint64_t v68 = (char **)*((void *)v66 + 1);
  *((void *)v66 + 1) = v83;
  uint64_t v83 = v68;
  sub_100118400(&v83, v67);
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v80.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v112.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v81.__r_.__value_.__l.__data_);
  }
  sub_1001181E0((uint64_t)&v115, &v117);
  std::string::size_type v69 = (wis *)sub_1001181E0((uint64_t)&v115, &v119);
  char v78 = 6;
  BOOL v79 = (char **)wis::getWISTimestamp(v69);
  char v70 = sub_100098078((uint64_t)&v117, "timestamp");
  int v71 = *v70;
  *char v70 = 6;
  char v78 = v71;
  std::string v72 = (char **)*((void *)v70 + 1);
  *((void *)v70 + 1) = v79;
  BOOL v79 = v72;
  sub_100118400(&v79, v71);
  sub_1001181E0((uint64_t)&v115, &v117);
  sub_10012365C((uint64_t)v76, &v115);
  unsigned int v73 = sub_100098078(a2, "history");
  int v74 = *v73;
  *unsigned int v73 = v76[0];
  v76[0] = v74;
  unsigned __int8 v75 = (char **)*((void *)v73 + 1);
  *((void *)v73 + 1) = v77;
  std::string::size_type v77 = v75;
  sub_100118400(&v77, v74);
  sub_100118400(&v116, v115);
  sub_100118400(&v118, v117);
  sub_100118400(&v120, v119);
}

void sub_100117CA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, unsigned __int8 a9, uint64_t a10, char a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,uint64_t a26,char a27,uint64_t a28,char a29,uint64_t a30,char a31,uint64_t a32,char a33,uint64_t a34,char a35,uint64_t a36,char a37,uint64_t a38,char a39,uint64_t a40,char a41,uint64_t a42,char a43,uint64_t a44,char a45,uint64_t a46,char a47)
{
  sub_100118400((char ***)&a10, a9);
  sub_100118400((char ***)(v51 - 144), *(unsigned __int8 *)(v51 - 152));
  sub_100118400(v48, *(unsigned __int8 *)(v51 - 136));
  sub_100118400(v47, *(unsigned __int8 *)(v51 - 120));
  sub_100118400(v50, *v49);
  _Unwind_Resume(a1);
}

uint64_t *sub_100117E98(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = (char *)a1 + *(void *)(*a1 - 24);
  uint64_t v6 = *((void *)v5 + 3);
  *((void *)v5 + 3) = 0;
  uint64_t v7 = (std::__shared_weak_count *)operator new(0x28uLL);
  v7->__shared_owners_ = 0;
  v7->__vftable = (std::__shared_weak_count_vtbl *)off_1001BE010;
  v7->__shared_weak_owners_ = 0;
  v7[1].__vftable = (std::__shared_weak_count_vtbl *)off_1001BE060;
  v7[1].__shared_owners_ = (uint64_t)a1;
  int v12 = v7 + 1;
  uint64_t v13 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  int v8 = (const std::ios_base *)((char *)a1 + *(void *)(v4 - 24));
  std::ios_base::fmtflags fmtflags = v8[1].__fmtflags_;
  if (fmtflags == -1)
  {
    std::ios_base::getloc(v8);
    uint64_t v10 = std::locale::use_facet(&v14, &std::ctype<char>::id);
    std::ios_base::fmtflags fmtflags = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
    std::locale::~locale(&v14);
    v8[1].__fmtflags_ = fmtflags;
  }
  sub_10011A44C((uint64_t)v15, (uint64_t)&v12, (char)fmtflags, 0);
  if (v13) {
    sub_10000B678(v13);
  }
  sub_10000B678(v7);
  sub_1001193E4(v15, a2, v6 > 0, 0, v6 & ~(v6 >> 63), 0);
  sub_10011B814((uint64_t)v15);
  return a1;
}

void sub_10011807C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::locale a11, char a12)
{
  std::locale::~locale(&a11);
  sub_10000B678(v12);
  sub_10000B678(v12);
  _Unwind_Resume(a1);
}

void *sub_1001180C0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  *(unsigned char *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  uint64_t v7 = *(unsigned __int8 *)(a1 + 23);
  uint64_t v8 = *(void *)a1;
  uint64_t v9 = *(void *)(a1 + 8);
  sub_10011D3C4((uint64_t)v13, a2);
  if ((v7 & 0x80u) == 0) {
    uint64_t v10 = a1;
  }
  else {
    uint64_t v10 = v8;
  }
  if ((v7 & 0x80u) == 0) {
    uint64_t v11 = v7;
  }
  else {
    uint64_t v11 = v9;
  }
  sub_10011BA38(v10, v10 + v11, (uint64_t)v13, a3, (uint64_t)v14);
  sub_10011BAD0((uint64_t)v14, 1, (unsigned __int8 *)a4);
  sub_10011D380((uint64_t)&v15);
  sub_10011837C(v14);
  return sub_10011837C(v13);
}

void sub_1001181A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  sub_10011D380(v15 + 40);
  sub_10011837C(&a13);
  sub_10011837C(&a9);
  sub_100118400(v14, *v13);
  _Unwind_Resume(a1);
}

uint64_t sub_1001181E0(uint64_t a1, const void ****a2)
{
  if (*(unsigned char *)a1)
  {
    if (*(unsigned char *)a1 != 2)
    {
      exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
      uint64_t v7 = (char *)sub_1000985A0((char *)a1);
      sub_100018888(&v10, v7);
      uint64_t v8 = std::string::insert(&v10, 0, "cannot use push_back() with ");
      long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      std::string::size_type v12 = v8->__r_.__value_.__r.__words[2];
      long long v11 = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      sub_10009845C(308, (uint64_t)&v11, exception);
    }
    uint64_t v4 = *(uint64_t **)(a1 + 8);
  }
  else
  {
    *(unsigned char *)a1 = 2;
    uint64_t v4 = (uint64_t *)operator new(0x18uLL);
    v4[1] = 0;
    void v4[2] = 0;
    uint64_t *v4 = 0;
    *(void *)(a1 + 8) = v4;
  }

  return sub_100123BAC(v4, a2);
}

void sub_1001182E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

const void **sub_100118344(const void **a1, const void **a2)
{
  uint64_t v3 = *a2;
  *a1 = *a2;
  if (v3) {
    CFRetain(v3);
  }
  return a1;
}

void *sub_10011837C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100118400(char ***a1, int a2)
{
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  unint64_t v41 = 0;
  int v3 = a2 - 1;
  if (a2 == 1)
  {
    sub_100118898(&v39, (unint64_t)(*a1)[2]);
    uint64_t v4 = (uint64_t)(*a1 + 1);
    uint64_t v5 = **a1;
    if (v5 != (char *)v4)
    {
      unint64_t v6 = v40;
      do
      {
        if (v6 >= v41)
        {
          uint64_t v7 = (uint64_t)(v6 - v39) >> 4;
          if ((unint64_t)(v7 + 1) >> 60) {
            sub_10002B5E0();
          }
          unint64_t v8 = (uint64_t)(v41 - v39) >> 3;
          if (v8 <= v7 + 1) {
            unint64_t v8 = v7 + 1;
          }
          if (v41 - v39 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v9 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v9 = v8;
          }
          int v46 = &v41;
          std::string v10 = (void **)sub_10001E498((uint64_t)&v41, v9);
          long long v11 = &v10[2 * v7];
          uint64_t v42 = (char **)v10;
          int v43 = v11;
          unsigned __int8 v45 = &v10[2 * v12];
          *(unsigned char *)long long v11 = v5[56];
          v11[1] = (void *)*((void *)v5 + 8);
          v5[56] = 0;
          *((void *)v5 + 8) = 0;
          uint64_t v44 = v11 + 2;
          sub_10011892C(&v39, &v42);
          unint64_t v6 = v40;
          sub_100118AB8((uint64_t)&v42);
        }
        else
        {
          *(unsigned char *)unint64_t v6 = v5[56];
          *(void *)(v6 + 8) = *((void *)v5 + 8);
          v5[56] = 0;
          *((void *)v5 + 8) = 0;
          v6 += 16;
        }
        uint64_t v40 = v6;
        uint64_t v13 = (char *)*((void *)v5 + 1);
        if (v13)
        {
          do
          {
            std::locale v14 = v13;
            uint64_t v13 = *(char **)v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            std::locale v14 = (char *)*((void *)v5 + 2);
            BOOL v15 = *(void *)v14 == (void)v5;
            uint64_t v5 = v14;
          }
          while (!v15);
        }
        uint64_t v5 = v14;
      }
      while (v14 != (char *)v4);
    }
  }
  else if (a2 == 2)
  {
    sub_100118898(&v39, ((*a1)[1] - **a1) >> 4);
    sub_100118B0C((uint64_t)&v42, **a1, (*a1)[1], &v39);
  }
  for (uint64_t i = v40; v39 != v40; uint64_t i = v40)
  {
    unsigned __int8 v37 = *(unsigned char *)(i - 16);
    std::string::value_type v38 = *(char ***)(i - 8);
    *(unsigned char *)(i - 16) = 0;
    *(void *)(i - 8) = 0;
    unint64_t v17 = v40 - 16;
    sub_100118400(v40 - 8, *(unsigned __int8 *)(v40 - 16));
    uint64_t v40 = v17;
    if (v37 == 1)
    {
      uint64_t v23 = (uint64_t)v38;
      unint64_t v24 = v38 + 1;
      int v25 = *v38;
      if (*v38 != (char *)(v38 + 1))
      {
        do
        {
          if (v17 >= v41)
          {
            uint64_t v26 = (uint64_t)(v17 - v39) >> 4;
            if ((unint64_t)(v26 + 1) >> 60) {
              sub_10002B5E0();
            }
            unint64_t v27 = (uint64_t)(v41 - v39) >> 3;
            if (v27 <= v26 + 1) {
              unint64_t v27 = v26 + 1;
            }
            if (v41 - v39 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v28 = v27;
            }
            int v46 = &v41;
            uint64_t v29 = (void **)sub_10001E498((uint64_t)&v41, v28);
            int v30 = &v29[2 * v26];
            uint64_t v42 = (char **)v29;
            int v43 = v30;
            unsigned __int8 v45 = &v29[2 * v31];
            *(unsigned char *)int v30 = v25[56];
            v30[1] = (void *)*((void *)v25 + 8);
            v25[56] = 0;
            *((void *)v25 + 8) = 0;
            uint64_t v44 = v30 + 2;
            sub_10011892C(&v39, &v42);
            unint64_t v17 = v40;
            sub_100118AB8((uint64_t)&v42);
          }
          else
          {
            *(unsigned char *)unint64_t v17 = v25[56];
            *(void *)(v17 + 8) = *((void *)v25 + 8);
            v25[56] = 0;
            *((void *)v25 + 8) = 0;
            v17 += 16;
          }
          uint64_t v40 = v17;
          uint64_t v32 = (char *)*((void *)v25 + 1);
          if (v32)
          {
            do
            {
              std::string::size_type v33 = v32;
              uint64_t v32 = *(char **)v32;
            }
            while (v32);
          }
          else
          {
            do
            {
              std::string::size_type v33 = (char *)*((void *)v25 + 2);
              BOOL v15 = *(void *)v33 == (void)v25;
              int v25 = v33;
            }
            while (!v15);
          }
          int v25 = v33;
        }
        while (v33 != (char *)v24);
        uint64_t v23 = (uint64_t)v38;
      }
      sub_100118C54(v23, *(char **)(v23 + 8));
      *(void *)uint64_t v23 = v23 + 8;
      *(void *)(v23 + 16) = 0;
      *(void *)(v23 + 8) = 0;
    }
    else if (v37 == 2)
    {
      sub_100118B0C((uint64_t)&v42, *v38, v38[1], &v39);
      int8x16_t v18 = v38;
      int v20 = *v38;
      int v19 = v38[1];
      if (v19 != *v38)
      {
        std::string::value_type v21 = v19 - 8;
        do
        {
          int v22 = v21 - 8;
          sub_100118400(v21, *(v21 - 8));
          v21 -= 16;
        }
        while (v22 != v20);
      }
      v18[1] = v20;
    }
    sub_100118400(&v38, v37);
  }
  switch(v3)
  {
    case 0:
      sub_100118C54((uint64_t)*a1, (*a1)[1]);
      goto LABEL_55;
    case 1:
      uint64_t v42 = *a1;
      sub_100118D18((void ***)&v42);
      goto LABEL_55;
    case 2:
      int v34 = *a1;
      if ((*((char *)*a1 + 23) & 0x80000000) == 0) {
        goto LABEL_56;
      }
      int v35 = *v34;
      break;
    case 7:
      int v34 = *a1;
      uint64_t v36 = **a1;
      if (!v36) {
        goto LABEL_56;
      }
      v34[1] = v36;
      int v35 = v36;
      break;
    default:
      goto LABEL_57;
  }
  operator delete(v35);
LABEL_55:
  int v34 = *a1;
LABEL_56:
  operator delete(v34);
LABEL_57:
  uint64_t v42 = (char **)&v39;
  sub_100118D18((void ***)&v42);
}

void sub_100118844(void *a1)
{
}

uint64_t sub_100118898(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60) {
      sub_10002B5E0();
    }
    uint64_t v5 = a1[1] - *a1;
    void v7[4] = result;
    v7[0] = sub_10001E498(result, a2);
    v7[1] = v7[0] + v5;
    _DWORD v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 16 * v6;
    sub_10011892C(a1, v7);
    return sub_100118AB8((uint64_t)v7);
  }
  return result;
}

void sub_100118918(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100118AB8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10011892C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1001189A4((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1001189A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  void v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      char v8 = *(unsigned char *)(a3 - 16);
      a3 -= 16;
      *(unsigned char *)(v7 - 16) = v8;
      *(void *)(v7 - 8) = *(void *)(a3 + 8);
      *(unsigned char *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 16;
      *((void *)&v14 + 1) -= 16;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  sub_100118A40((uint64_t)v11);
  return v9;
}

uint64_t sub_100118A40(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100118A78(a1);
  }
  return a1;
}

uint64_t sub_100118A78(uint64_t result)
{
  uint64_t v1 = *(unsigned __int8 **)(*(void *)(result + 16) + 8);
  uint64_t v2 = *(unsigned __int8 **)(*(void *)(result + 8) + 8);
  while (v1 != v2)
  {
    int v3 = v1 + 8;
    unsigned int v4 = *v1;
    v1 += 16;
    uint64_t result = sub_100118400(v3, v4);
  }
  return result;
}

uint64_t sub_100118AB8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    unsigned int v5 = *(unsigned __int8 *)(i - 16);
    uint64_t v4 = i - 16;
    *(void *)(a1 + 16) = v4;
    sub_100118400(v4 + 8, v5);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *sub_100118B0C(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  unsigned int v5 = a2;
  if (a2 != a3)
  {
    uint64_t v7 = (unint64_t *)(a4 + 2);
    unint64_t v8 = a4[1];
    do
    {
      if (v8 >= *v7)
      {
        uint64_t v9 = (uint64_t)(v8 - *a4) >> 4;
        if ((unint64_t)(v9 + 1) >> 60) {
          sub_10002B5E0();
        }
        uint64_t v10 = *v7 - *a4;
        uint64_t v11 = v10 >> 3;
        if (v10 >> 3 <= (unint64_t)(v9 + 1)) {
          uint64_t v11 = v9 + 1;
        }
        if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v12 = v11;
        }
        v17[4] = a4 + 2;
        long long v13 = (char *)sub_10001E498((uint64_t)(a4 + 2), v12);
        long long v14 = &v13[16 * v9];
        v17[0] = v13;
        v17[1] = v14;
        v17[3] = &v13[16 * v15];
        char *v14 = *v5;
        *((void *)v14 + 1) = *((void *)v5 + 1);
        *unsigned int v5 = 0;
        *((void *)v5 + 1) = 0;
        v17[2] = v14 + 16;
        sub_10011892C(a4, v17);
        unint64_t v8 = a4[1];
        sub_100118AB8((uint64_t)v17);
      }
      else
      {
        *(unsigned char *)unint64_t v8 = *v5;
        *(void *)(v8 + 8) = *((void *)v5 + 1);
        *unsigned int v5 = 0;
        *((void *)v5 + 1) = 0;
        v8 += 16;
      }
      a4[1] = v8;
      v5 += 16;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void sub_100118C40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100118AB8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100118C54(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_100118C54(a1, *(void *)a2);
    sub_100118C54(a1, *((void *)a2 + 1));
    sub_100118400(a2 + 64, a2[56]);
    if (a2[55] < 0) {
      operator delete(*((void **)a2 + 4));
    }
    operator delete(a2);
  }
}

void sub_100118CC4(uint64_t a1)
{
  sub_100118400((char ***)(a1 + 32), *(unsigned __int8 *)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_100118D18(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    unsigned int v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = (uint64_t)v4 - 8;
      do
      {
        uint64_t v7 = (void *)(v6 - 8);
        sub_100118400(v6, *(unsigned __int8 *)(v6 - 8));
        v6 -= 16;
      }
      while (v7 != v2);
      unsigned int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

std::string *sub_100118DB4@<X0>(unsigned __int8 *a1@<X0>, const void **a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  if (*a1 != 1)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    uint64_t v11 = (char *)sub_1000985A0((char *)a1);
    sub_100018888(&v14, v11);
    unint64_t v12 = std::string::insert(&v14, 0, "cannot use value() with ");
    long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    std::string::size_type v18 = v12->__r_.__value_.__r.__words[2];
    long long v17 = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    sub_10009845C(306, (uint64_t)&v17, exception);
  }
  *(void *)&long long v17 = a1;
  std::string::size_type v18 = 0;
  uint64_t v19 = 0;
  unint64_t v20 = 0x8000000000000000;
  *((void *)&v17 + 1) = sub_100015244(*((void *)a1 + 1), a2);
  *(_OWORD *)&v14.__r_.__value_.__l.__data_ = (unint64_t)a1;
  v14.__r_.__value_.__r.__words[2] = 0;
  uint64_t v15 = 0;
  unint64_t v16 = 0x8000000000000000;
  int v7 = *a1;
  if (v7 == 2)
  {
    v14.__r_.__value_.__r.__words[2] = *(void *)(*((void *)a1 + 1) + 8);
  }
  else if (v7 == 1)
  {
    v14.__r_.__value_.__l.__size_ = *((void *)a1 + 1) + 8;
  }
  else
  {
    unint64_t v16 = 1;
  }
  uint64_t result = (std::string *)sub_1001190DC((unsigned __int8 **)&v17, (unsigned __int8 **)&v14);
  if (result)
  {
    if (*(char *)(a3 + 23) < 0)
    {
      return (std::string *)sub_1000173FC(a4, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
      a4->__r_.__value_.__r.__words[2] = *(void *)(a3 + 16);
    }
  }
  else
  {
    uint64_t v9 = sub_100118F90((uint64_t)&v17);
    return sub_100098230((uint64_t)v9, a4);
  }
  return result;
}

void sub_100118F30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v24 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v24)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v23);
  goto LABEL_8;
}

unsigned char *sub_100118F90(uint64_t a1)
{
  uint64_t result = *(unsigned char **)a1;
  int v3 = *result;
  if (v3 == 1) {
    return (unsigned char *)(*(void *)(a1 + 8) + 56);
  }
  if (v3 == 2) {
    return *(unsigned char **)(a1 + 16);
  }
  if (!*result)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_100018888(v6, "cannot get value");
    sub_1001191E4(214, (uint64_t)v6, exception);
  }
  if (*(void *)(a1 + 32))
  {
    uint64_t v4 = __cxa_allocate_exception(0x20uLL);
    sub_100018888(v6, "cannot get value");
    sub_1001191E4(214, (uint64_t)v6, v4);
  }
  return result;
}

void sub_1001190A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (v16) {
    __cxa_free_exception(v15);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1001190DC(unsigned __int8 **a1, unsigned __int8 **a2)
{
  if (*a1 != *a2)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_100018888(v7, "cannot compare iterators of different containers");
    sub_1001191E4(212, (uint64_t)v7, exception);
  }
  int v2 = **a1;
  if (v2 == 2)
  {
    int v3 = a1[2];
    uint64_t v4 = a2[2];
  }
  else if (v2 == 1)
  {
    int v3 = a1[1];
    uint64_t v4 = a2[1];
  }
  else
  {
    int v3 = a1[4];
    uint64_t v4 = a2[4];
  }
  return v3 == v4;
}

void sub_1001191AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void sub_1001191E4(int a1@<W0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  sub_100018888(&__p, "invalid_iterator");
  sub_10009861C(a1, &v14);
  int v6 = *(char *)(a2 + 23);
  if (v6 >= 0) {
    int v7 = (const std::string::value_type *)a2;
  }
  else {
    int v7 = *(const std::string::value_type **)a2;
  }
  if (v6 >= 0) {
    std::string::size_type v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v8 = *(void *)(a2 + 8);
  }
  uint64_t v9 = std::string::append(&v14, v7, v8);
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  int64_t v16 = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)uint64_t v15 = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  if (v13 < 0) {
    operator delete(__p);
  }
  if (v16 >= 0) {
    uint64_t v11 = (char *)v15;
  }
  else {
    uint64_t v11 = (char *)v15[0];
  }
  sub_1000987A0((uint64_t)a3, a1, v11);
  *a3 = off_1001BDFE8;
  if (SHIBYTE(v16) < 0) {
    operator delete(v15[0]);
  }
}

void sub_1001192E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100119328(std::runtime_error *a1)
{
  a1->__vftable = (std::runtime_error_vtbl *)off_1001B9538;
  std::runtime_error::~runtime_error(a1 + 1);

  std::exception::~exception(a1);
}

void sub_10011937C(std::runtime_error *a1)
{
  a1->__vftable = (std::runtime_error_vtbl *)off_1001B9538;
  std::runtime_error::~runtime_error(a1 + 1);
  std::exception::~exception(a1);

  operator delete();
}

uint64_t **sub_1001193E4(uint64_t **result, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  long long v10 = result;
  switch(*(unsigned char *)a2)
  {
    case 0:
      uint64_t v11 = *(uint64_t (**)(void))(**result + 8);
      goto LABEL_71;
    case 1:
      uint64_t v12 = **result;
      if (!*(void *)(*(void *)(a2 + 8) + 16))
      {
        uint64_t v40 = *(uint64_t (**)(void))(v12 + 8);
        goto LABEL_44;
      }
      if (!a3)
      {
        (*(void (**)(void))v12)();
        unint64_t v41 = *(void **)(a2 + 8);
        uint64_t v42 = (void *)*v41;
        if (v41[2] == 1)
        {
          int v43 = (void *)*v41;
        }
        else
        {
          unint64_t v60 = 0;
          do
          {
            (*(void (**)(uint64_t *, uint64_t))**v10)(*v10, 34);
            sub_10011A594((uint64_t)v10, v42 + 4, a4);
            (*(void (**)(uint64_t *, const char *, uint64_t))(**v10 + 8))(*v10, "\":", 2);
            sub_1001193E4(v10, v42 + 7, 0, a4, a5, a6);
            (*(void (**)(void))**v10)();
            uint64_t v61 = (void *)v42[1];
            if (v61)
            {
              do
              {
                int v43 = v61;
                uint64_t v61 = (void *)*v61;
              }
              while (v61);
            }
            else
            {
              do
              {
                int v43 = (void *)v42[2];
                BOOL v58 = *v43 == (void)v42;
                uint64_t v42 = v43;
              }
              while (!v58);
            }
            ++v60;
            uint64_t v42 = v43;
          }
          while (v60 < *(void *)(*(void *)(a2 + 8) + 16) - 1);
        }
        (*(void (**)(uint64_t *, uint64_t))**v10)(*v10, 34);
        sub_10011A594((uint64_t)v10, v43 + 4, a4);
        (*(void (**)(uint64_t *, const char *, uint64_t))(**v10 + 8))(*v10, "\":", 2);
        sub_1001193E4(v10, v43 + 7, 0, a4, a5, a6);
        goto LABEL_97;
      }
      (*(void (**)(void))(v12 + 8))();
      unsigned int v13 = a6 + a5;
      std::string v14 = v10 + 76;
      if (*((char *)v10 + 631) < 0)
      {
        unint64_t v15 = (unint64_t)v10[77];
        if (v15 >= v13) {
          goto LABEL_7;
        }
      }
      else
      {
        unint64_t v15 = *((unsigned __int8 *)v10 + 631);
        if (v13 <= v15) {
          goto LABEL_7;
        }
      }
      std::string::resize((std::string *)(v10 + 76), 2 * v15, 32);
LABEL_7:
      int64_t v16 = *(void **)(a2 + 8);
      long long v17 = (void *)*v16;
      if (v16[2] == 1)
      {
        std::string::size_type v18 = (void *)*v16;
      }
      else
      {
        unint64_t v55 = 0;
        do
        {
          uint64_t v56 = (void ***)(v10 + 76);
          if (*((char *)v10 + 631) < 0) {
            uint64_t v56 = (void ***)*v14;
          }
          (*(void (**)(uint64_t *, void ***, void))(**v10 + 8))(*v10, v56, (a6 + a5));
          (*(void (**)(void))**v10)();
          sub_10011A594((uint64_t)v10, v17 + 4, a4);
          (*(void (**)(uint64_t *, const char *, uint64_t))(**v10 + 8))(*v10, "\": ", 3);
          sub_1001193E4(v10, v17 + 7, 1, a4, a5, (a6 + a5));
          (*(void (**)(uint64_t *, const char *, uint64_t))(**v10 + 8))(*v10, ",\n", 2);
          std::runtime_error v57 = (void *)v17[1];
          if (v57)
          {
            do
            {
              std::string::size_type v18 = v57;
              std::runtime_error v57 = (void *)*v57;
            }
            while (v57);
          }
          else
          {
            do
            {
              std::string::size_type v18 = (void *)v17[2];
              BOOL v58 = *v18 == (void)v17;
              long long v17 = v18;
            }
            while (!v58);
          }
          ++v55;
          long long v17 = v18;
        }
        while (v55 < *(void *)(*(void *)(a2 + 8) + 16) - 1);
      }
      uint64_t v59 = (void ***)(v10 + 76);
      if (*((char *)v10 + 631) < 0) {
        uint64_t v59 = (void ***)*v14;
      }
      (*(void (**)(uint64_t *, void ***, void))(**v10 + 8))(*v10, v59, (a6 + a5));
      (*(void (**)(void))**v10)();
      sub_10011A594((uint64_t)v10, v18 + 4, a4);
      (*(void (**)(uint64_t *, const char *, uint64_t))(**v10 + 8))(*v10, "\": ", 3);
      sub_1001193E4(v10, v18 + 7, 1, a4, a5, (a6 + a5));
      (*(void (**)(void))**v10)();
      int8x16_t v54 = *(void (**)(void))(**v10 + 8);
      goto LABEL_88;
    case 2:
      uint64_t v19 = (void (**)(void))**result;
      if (**(void **)(a2 + 8) != *(void *)(*(void *)(a2 + 8) + 8))
      {
        if (!a3)
        {
          (*v19)();
          uint64_t v44 = *(uint64_t **)(a2 + 8);
          for (uint64_t i = *v44; i != v44[1] - 16; i += 16)
          {
            sub_1001193E4(v10, i, 0, a4, a5, a6);
            (*(void (**)(void))**v10)();
            uint64_t v44 = *(uint64_t **)(a2 + 8);
          }
          sub_1001193E4(v10, i, 0, a4, a5, a6);
LABEL_58:
          uint64_t v11 = *(uint64_t (**)(void))**v10;
          goto LABEL_98;
        }
        v19[1]();
        unsigned int v20 = a6 + a5;
        std::string::value_type v21 = v10 + 76;
        if (*((char *)v10 + 631) < 0)
        {
          unint64_t v22 = (unint64_t)v10[77];
          if (v22 >= v20) {
            goto LABEL_13;
          }
        }
        else
        {
          unint64_t v22 = *((unsigned __int8 *)v10 + 631);
          if (v20 <= v22)
          {
LABEL_13:
            uint64_t v23 = *(uint64_t **)(a2 + 8);
            uint64_t v24 = *v23;
            if (*v23 != v23[1] - 16)
            {
              do
              {
                int v25 = (void ***)(v10 + 76);
                if (*((char *)v10 + 631) < 0) {
                  int v25 = (void ***)*v21;
                }
                (*(void (**)(uint64_t *, void ***, void))(**v10 + 8))(*v10, v25, (a6 + a5));
                sub_1001193E4(v10, v24, 1, a4, a5, (a6 + a5));
                (*(void (**)(uint64_t *, const char *, uint64_t))(**v10 + 8))(*v10, ",\n", 2);
                v24 += 16;
              }
              while (v24 != *(void *)(*(void *)(a2 + 8) + 8) - 16);
            }
            uint64_t v26 = (void ***)(v10 + 76);
            if (*((char *)v10 + 631) < 0) {
              uint64_t v26 = (void ***)*v21;
            }
            (*(void (**)(uint64_t *, void ***, void))(**v10 + 8))(*v10, v26, (a6 + a5));
            sub_1001193E4(v10, *(void *)(*(void *)(a2 + 8) + 8) - 16, 1, a4, a5, (a6 + a5));
            (*(void (**)(void))**v10)();
            if (*((char *)v10 + 631) < 0) {
              std::string::value_type v21 = (void *)*v21;
            }
            (*(void (**)(uint64_t *, void *, void))(**v10 + 8))(*v10, v21, a6);
            goto LABEL_58;
          }
        }
        std::string::resize((std::string *)(v10 + 76), 2 * v22, 32);
        goto LABEL_13;
      }
      uint64_t v40 = (uint64_t (*)(void))v19[1];
LABEL_44:
      return (uint64_t **)v40();
    case 3:
      (*(void (**)(void))**result)();
      sub_10011A594((uint64_t)v10, *(uint64_t **)(a2 + 8), a4);
      uint64_t v11 = *(uint64_t (**)(void))**v10;
      goto LABEL_98;
    case 4:
      uint64_t v11 = *(uint64_t (**)(void))(**result + 8);
      goto LABEL_71;
    case 5:
      unint64_t v27 = *(void *)(a2 + 8);
      return (uint64_t **)sub_10011ACE8(result, v27);
    case 6:
      unint64_t v28 = *(void *)(a2 + 8);
      return (uint64_t **)sub_10011AED8(result, v28);
    case 7:
      double v29 = *(double *)(a2 + 8);
      return (uint64_t **)sub_10011B030((const char *)result, v29);
    case 8:
      int v30 = *(void (**)(void))(**result + 8);
      if (a3)
      {
        v30();
        uint64_t v31 = (a6 + a5);
        uint64_t v32 = v10 + 76;
        if (*((char *)v10 + 631) < 0)
        {
          unint64_t v33 = (unint64_t)v10[77];
          if (v33 >= v31)
          {
            int v34 = (uint64_t (***)(void))*v10;
LABEL_61:
            int v35 = (void ***)*v32;
            goto LABEL_62;
          }
        }
        else
        {
          unint64_t v33 = *((unsigned __int8 *)v10 + 631);
          if (v31 <= v33)
          {
            int v34 = (uint64_t (***)(void))*v10;
            int v35 = (void ***)(v10 + 76);
LABEL_62:
            ((void (*)(uint64_t (***)(void), void ***, uint64_t))(*v34)[1])(v34, v35, v31);
            (*(void (**)(uint64_t *, const char *, uint64_t))(**v10 + 8))(*v10, "\"bytes\": [", 10);
            int v48 = *(unsigned __int8 ***)(a2 + 8);
            char v50 = *v48;
            int v49 = v48[1];
            if (v50 != v49)
            {
              if (v50 != v49 - 1)
              {
                do
                {
                  unsigned int v51 = *v50++;
                  sub_10011AC0C((uint64_t)v10, v51);
                  (*(void (**)(uint64_t *, const char *, uint64_t))(**v10 + 8))(*v10, ", ", 2);
                }
                while (v50 != (unsigned __int8 *)(*(void *)(*(void *)(a2 + 8) + 8) - 1));
              }
              sub_10011AC0C((uint64_t)v10, *v50);
            }
            (*(void (**)(uint64_t *, const char *, uint64_t))(**v10 + 8))(*v10, "],\n", 3);
            int v52 = (void ***)(v10 + 76);
            if (*((char *)v10 + 631) < 0) {
              int v52 = (void ***)*v32;
            }
            (*(void (**)(uint64_t *, void ***, uint64_t))(**v10 + 8))(*v10, v52, v31);
            (*(void (**)(uint64_t *, const char *, uint64_t))(**v10 + 8))(*v10, "\"subtype\": ", 11);
            uint64_t v53 = *(void *)(a2 + 8);
            if (*(unsigned char *)(v53 + 25)) {
              sub_10011AC0C((uint64_t)v10, *(unsigned __int8 *)(v53 + 24));
            }
            else {
              (*(void (**)(uint64_t *, const char *, uint64_t))(**v10 + 8))(*v10, "null", 4);
            }
            (*(void (**)(uint64_t *, uint64_t))**v10)(*v10, 10);
            int8x16_t v54 = *(void (**)(void))(**v10 + 8);
LABEL_88:
            v54();
LABEL_97:
            uint64_t v11 = *(uint64_t (**)(void))**v10;
LABEL_98:
            return (uint64_t **)v11();
          }
        }
        std::string::resize((std::string *)(v10 + 76), 2 * v33, 32);
        int v34 = (uint64_t (***)(void))*v10;
        int v35 = (void ***)(v10 + 76);
        if ((*((char *)v10 + 631) & 0x80000000) == 0) {
          goto LABEL_62;
        }
        goto LABEL_61;
      }
      v30();
      uint64_t v36 = *(unsigned __int8 ***)(a2 + 8);
      std::string::value_type v38 = *v36;
      unsigned __int8 v37 = v36[1];
      if (v38 != v37)
      {
        while (v38 != v37 - 1)
        {
          unsigned int v39 = *v38++;
          sub_10011AC0C((uint64_t)v10, v39);
          (*(void (**)(uint64_t *, uint64_t))**v10)(*v10, 44);
          unsigned __int8 v37 = *(unsigned __int8 **)(*(void *)(a2 + 8) + 8);
        }
        sub_10011AC0C((uint64_t)v10, *v38);
      }
      (*(void (**)(uint64_t *, const char *, uint64_t))(**v10 + 8))(*v10, "],\"subtype\":", 12);
      uint64_t v46 = *(void *)(a2 + 8);
      if (!*(unsigned char *)(v46 + 25))
      {
        uint64_t v11 = *(uint64_t (**)(void))(**v10 + 8);
LABEL_71:
        return (uint64_t **)v11();
      }
      sub_10011AC0C((uint64_t)v10, *(unsigned __int8 *)(v46 + 24));
      std::string::size_type v47 = *(uint64_t (**)(void))**v10;
      return (uint64_t **)v47();
    case 9:
      uint64_t v11 = *(uint64_t (**)(void))(**result + 8);
      goto LABEL_71;
    default:
      return result;
  }
}

void sub_10011A388(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1001BE010;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10011A3A8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1001BE010;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10011A3FC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 16))();
}

uint64_t sub_10011A424(uint64_t a1)
{
  return std::ostream::put(*(void *)(a1 + 8));
}

uint64_t sub_10011A42C()
{
  return std::ostream::write();
}

void sub_10011A438()
{
}

uint64_t sub_10011A44C(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  int v7 = localeconv();
  *(void *)(a1 + 80) = v7;
  thousands_sep = v7->thousands_sep;
  if (thousands_sep) {
    LOBYTE(thousands_sep) = *thousands_sep;
  }
  *(unsigned char *)(a1 + 88) = (_BYTE)thousands_sep;
  decimal_point = v7->decimal_point;
  if (v7->decimal_point) {
    LOBYTE(decimal_point) = *decimal_point;
  }
  *(_OWORD *)(a1 + 90) = 0u;
  *(unsigned char *)(a1 + 89) = (_BYTE)decimal_point;
  *(_OWORD *)(a1 + 106) = 0u;
  *(_OWORD *)(a1 + 122) = 0u;
  *(_OWORD *)(a1 + 138) = 0u;
  *(_OWORD *)(a1 + 154) = 0u;
  *(_OWORD *)(a1 + 170) = 0u;
  *(_OWORD *)(a1 + 186) = 0u;
  *(_OWORD *)(a1 + 202) = 0u;
  *(_OWORD *)(a1 + 218) = 0u;
  *(_OWORD *)(a1 + 234) = 0u;
  *(_OWORD *)(a1 + 250) = 0u;
  *(_OWORD *)(a1 + 266) = 0u;
  *(_OWORD *)(a1 + 282) = 0u;
  *(_OWORD *)(a1 + 298) = 0u;
  *(_OWORD *)(a1 + 314) = 0u;
  *(_OWORD *)(a1 + 330) = 0u;
  *(_OWORD *)(a1 + 346) = 0u;
  *(_OWORD *)(a1 + 362) = 0u;
  *(_OWORD *)(a1 + 378) = 0u;
  *(_OWORD *)(a1 + 394) = 0u;
  *(_OWORD *)(a1 + 410) = 0u;
  *(_OWORD *)(a1 + 426) = 0u;
  *(_OWORD *)(a1 + 442) = 0u;
  *(_OWORD *)(a1 + 458) = 0u;
  *(_OWORD *)(a1 + 474) = 0u;
  *(_OWORD *)(a1 + 490) = 0u;
  *(_OWORD *)(a1 + 506) = 0u;
  *(_OWORD *)(a1 + 522) = 0u;
  *(_OWORD *)(a1 + 538) = 0u;
  *(_OWORD *)(a1 + 554) = 0u;
  *(_OWORD *)(a1 + 570) = 0u;
  *(_OWORD *)(a1 + 586) = 0u;
  *(unsigned char *)(a1 + 602) = a3;
  long long v10 = (int8x16_t *)operator new(0x208uLL);
  *(void *)(a1 + 608) = v10;
  *(void *)(a1 + 624) = 0x8000000000000208;
  int8x16_t v11 = vdupq_n_s8(a3);
  *(void *)(a1 + 616) = 512;
  *long long v10 = v11;
  v10[1] = v11;
  void v10[2] = v11;
  void v10[3] = v11;
  v10[4] = v11;
  v10[5] = v11;
  void v10[6] = v11;
  v10[7] = v11;
  v10[8] = v11;
  v10[9] = v11;
  v10[10] = v11;
  v10[11] = v11;
  v10[12] = v11;
  v10[13] = v11;
  v10[14] = v11;
  v10[15] = v11;
  unsigned char v10[16] = v11;
  v10[17] = v11;
  v10[18] = v11;
  v10[19] = v11;
  v10[20] = v11;
  v10[21] = v11;
  v10[22] = v11;
  v10[23] = v11;
  v10[24] = v11;
  v10[25] = v11;
  v10[26] = v11;
  v10[27] = v11;
  v10[28] = v11;
  v10[29] = v11;
  v10[30] = v11;
  v10[31] = v11;
  v10[32].i8[0] = 0;
  *(_DWORD *)(a1 + 632) = a4;
  return a1;
}

void sub_10011A57C(_Unwind_Exception *exception_object)
{
  int v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10000B678(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10011A594(uint64_t result, uint64_t *a2, int a3)
{
  LOBYTE(v3) = *((char *)a2 + 23) < 0;
  uint64_t v4 = *((unsigned __int8 *)a2 + 23);
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = a2[1];
  }
  if (!v4) {
    return result;
  }
  int v7 = (void *)result;
  unint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  unsigned int v12 = 0;
  unsigned int v13 = 0;
  uint64_t v14 = result + 90;
  do
  {
    if (v3) {
      unint64_t v15 = (uint64_t *)*a2;
    }
    else {
      unint64_t v15 = a2;
    }
    uint64_t v16 = *((unsigned __int8 *)v15 + v8);
    if (v12) {
      unsigned int v13 = *((unsigned char *)v15 + v8) & 0x3F | (v13 << 6);
    }
    else {
      unsigned int v13 = (0xFFu >> byte_10017AF35[v16]) & v16;
    }
    unsigned int v12 = byte_10017AF35[16 * v12 + 256 + byte_10017AF35[v16]];
    if (v12 == 1)
    {
      int v18 = *((_DWORD *)v7 + 158);
      if ((v18 - 1) < 2)
      {
        v8 -= v9 != 0;
        if (v18 != 1)
        {
          unsigned int v12 = 0;
          uint64_t v9 = 0;
          uint64_t v11 = v10;
          goto LABEL_47;
        }
        if (a3)
        {
          uint64_t v19 = v14 + v10;
          *(_DWORD *)uint64_t v19 = 1717990748;
          *(_WORD *)(v19 + 4) = 25702;
          uint64_t v11 = v10 + 6;
        }
        else
        {
          uint64_t v11 = v10 + 3;
          uint64_t v20 = v14 + v10;
          *(_WORD *)uint64_t v20 = -16401;
          *(unsigned char *)(v20 + 2) = -67;
        }
        goto LABEL_44;
      }
      if (!v18)
      {
        char v46 = 3;
        *(_DWORD *)std::string __str = 0;
        snprintf(__str, 3uLL, "%.2X", v16);
        exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
        std::to_string(&v39, v8);
        double v29 = std::string::insert(&v39, 0, "invalid UTF-8 byte at index ");
        long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
        v40.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v30;
        v29->__r_.__value_.__l.__size_ = 0;
        v29->__r_.__value_.__r.__words[2] = 0;
        v29->__r_.__value_.__r.__words[0] = 0;
        uint64_t v31 = std::string::append(&v40, ": 0x");
        long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
        v41.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v32;
        v31->__r_.__value_.__l.__size_ = 0;
        v31->__r_.__value_.__r.__words[2] = 0;
        v31->__r_.__value_.__r.__words[0] = 0;
        if (v46 >= 0) {
          unint64_t v33 = __str;
        }
        else {
          unint64_t v33 = *(char **)__str;
        }
        if (v46 >= 0) {
          std::string::size_type v34 = v46;
        }
        else {
          std::string::size_type v34 = v45;
        }
        int v35 = std::string::append(&v41, v33, v34);
        long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
        std::string::size_type v43 = v35->__r_.__value_.__r.__words[2];
        long long v42 = v36;
        v35->__r_.__value_.__l.__size_ = 0;
        v35->__r_.__value_.__r.__words[2] = 0;
        v35->__r_.__value_.__r.__words[0] = 0;
        sub_10009845C(316, (uint64_t)&v42, exception);
      }
      unsigned int v12 = 1;
    }
    else
    {
      if (!v12)
      {
        switch(v13)
        {
          case 8u:
            __int16 v17 = 25180;
            goto LABEL_43;
          case 9u:
            __int16 v17 = 29788;
            goto LABEL_43;
          case 0xAu:
            __int16 v17 = 28252;
            goto LABEL_43;
          case 0xBu:
            goto LABEL_29;
          case 0xCu:
            __int16 v17 = 26204;
            goto LABEL_43;
          case 0xDu:
            __int16 v17 = 29276;
            goto LABEL_43;
          default:
            if (v13 == 34)
            {
              __int16 v17 = 8796;
              goto LABEL_43;
            }
            if (v13 == 92)
            {
              __int16 v17 = 23644;
LABEL_43:
              *(_WORD *)(v14 + v11) = v17;
              v11 += 2;
              break;
            }
LABEL_29:
            if (v13 > 0x7E) {
              int v21 = a3;
            }
            else {
              int v21 = 0;
            }
            if (v13 >= 0x20 && v21 == 0)
            {
              *(unsigned char *)(v14 + v11++) = *((unsigned char *)v15 + v8);
            }
            else
            {
              uint64_t v23 = (char *)(v14 + v11);
              if (HIWORD(v13))
              {
                uint64_t result = snprintf(v23, 0xDuLL, "\\u%04x\\u%04x", (unsigned __int16)((v13 >> 10) - 10304), v13 & 0x3FF | 0xDC00);
                v11 += 12;
              }
              else
              {
                uint64_t result = snprintf(v23, 7uLL, "\\u%04x", v13);
                v11 += 6;
              }
            }
            break;
        }
LABEL_44:
        if ((unint64_t)(v11 - 500) > 0xC)
        {
          unsigned int v12 = 0;
          uint64_t v9 = 0;
          uint64_t v10 = v11;
        }
        else
        {
          uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*v7 + 8))(*v7, v14, v11);
          unsigned int v12 = 0;
          uint64_t v11 = 0;
          uint64_t v10 = 0;
          uint64_t v9 = 0;
        }
        goto LABEL_47;
      }
      if ((a3 & 1) == 0) {
        *(unsigned char *)(v14 + v11++) = *((unsigned char *)v15 + v8);
      }
      ++v9;
    }
LABEL_47:
    ++v8;
    int v24 = *((char *)a2 + 23);
    unsigned int v3 = v24 >> 31;
    unint64_t v25 = a2[1];
    if (v24 >= 0) {
      unint64_t v25 = *((unsigned __int8 *)a2 + 23);
    }
  }
  while (v8 < v25);
  if (v12)
  {
    int v27 = *((_DWORD *)v7 + 158);
    switch(v27)
    {
      case 1:
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v7 + 8))(*v7, v14, v10);
        uint64_t v26 = *(uint64_t (**)(void))(*(void *)*v7 + 8);
        break;
      case 2:
        uint64_t v26 = *(uint64_t (**)(void))(*(void *)*v7 + 8);
        break;
      case 0:
        char v46 = 3;
        *(_DWORD *)std::string __str = 0;
        unsigned __int8 v37 = (uint64_t *)*a2;
        if (v24 >= 0) {
          unsigned __int8 v37 = a2;
        }
        snprintf(__str, 3uLL, "%.2X", *((unsigned __int8 *)v37 + v25 - 1));
        std::string::value_type v38 = __cxa_allocate_exception(0x20uLL);
        std::operator+<char>();
        sub_10009845C(316, (uint64_t)&v42, v38);
      default:
        return result;
    }
LABEL_56:
    return v26();
  }
  if (v11)
  {
    uint64_t v26 = *(uint64_t (**)(void))(*(void *)*v7 + 8);
    goto LABEL_56;
  }
  return result;
}

void sub_10011AB34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a39 < 0)
  {
    operator delete(__p);
    if ((v40 & 1) == 0)
    {
LABEL_6:
      if (*(char *)(v41 - 89) < 0) {
        operator delete(*(void **)(v41 - 112));
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v40)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v39);
  goto LABEL_6;
}

uint64_t sub_10011AC0C(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return (***(uint64_t (****)(void, uint64_t))a1)(*(void *)a1, 48);
  }
  LOBYTE(v2) = a2;
  if (a2 >= 0xA)
  {
    if (a2 >= 0x64)
    {
      *(_WORD *)(a1 + 17) = *(_WORD *)&a00010203040506[2 * (a2 - 100 * ((41 * a2) >> 12))];
      uint64_t v5 = a1 + 17;
      unsigned int v2 = (41 * a2) >> 12;
      goto LABEL_10;
    }
    uint64_t v3 = 2;
  }
  else
  {
    uint64_t v3 = 1;
  }
  uint64_t v5 = a1 + 16 + v3;
  if (a2 < 0xA)
  {
LABEL_10:
    *(unsigned char *)(v5 - 1) = v2 | 0x30;
    return (*(uint64_t (**)(void))(**(void **)a1 + 8))();
  }
  *(_WORD *)(v5 - 2) = *(_WORD *)&a00010203040506[2 * a2];
  return (*(uint64_t (**)(void))(**(void **)a1 + 8))();
}

uint64_t sub_10011ACE8(void *a1, unint64_t a2)
{
  if (!a2) {
    return (**(uint64_t (***)(void, uint64_t))*a1)(*a1, 48);
  }
  unint64_t v2 = a2;
  uint64_t v3 = a1 + 2;
  if ((v2 & 0x8000000000000000) != 0)
  {
    unsigned char *v3 = 45;
    unint64_t v2 = -(uint64_t)v2;
    if (v2 >= 0xA)
    {
      int v6 = 4;
      unint64_t v10 = v2;
      while (1)
      {
        if (v10 <= 0x63)
        {
          v6 -= 2;
          goto LABEL_24;
        }
        if (v10 <= 0x3E7) {
          break;
        }
        if (v10 >> 4 < 0x271) {
          goto LABEL_24;
        }
        v6 += 4;
        BOOL v9 = v10 >= 0x186A0;
        v10 /= 0x2710uLL;
        if (!v9)
        {
          v6 -= 3;
          goto LABEL_24;
        }
      }
      --v6;
    }
    else
    {
      int v6 = 1;
    }
LABEL_24:
    unsigned int v7 = v6 + 1;
  }
  else
  {
    if (v2 < 0xA)
    {
      uint64_t v4 = (char *)a1 + 17;
LABEL_32:
      *(v4 - 1) = v2 + 48;
      return (*(uint64_t (**)(void))(*(void *)*a1 + 8))();
    }
    unsigned int v7 = 4;
    unint64_t v8 = v2;
    while (1)
    {
      if (v8 <= 0x63)
      {
        v7 -= 2;
        goto LABEL_25;
      }
      if (v8 <= 0x3E7) {
        break;
      }
      if (v8 >> 4 < 0x271) {
        goto LABEL_25;
      }
      v7 += 4;
      BOOL v9 = v8 >= 0x186A0;
      v8 /= 0x2710uLL;
      if (!v9)
      {
        v7 -= 3;
        goto LABEL_25;
      }
    }
    --v7;
  }
LABEL_25:
  uint64_t v4 = &v3[v7];
  if (v2 < 0x64)
  {
    unint64_t v11 = v2;
  }
  else
  {
    do
    {
      unint64_t v11 = v2 / 0x64;
      *((_WORD *)v4 - 1) = *(_WORD *)&a00010203040506[2 * (v2 % 0x64) + 200];
      v4 -= 2;
      unint64_t v12 = v2 >> 4;
      v2 /= 0x64uLL;
    }
    while (v12 > 0x270);
  }
  if (v11 < 0xA)
  {
    LOBYTE(v2) = v11;
    goto LABEL_32;
  }
  *((_WORD *)v4 - 1) = *(_WORD *)&a00010203040506[2 * v11 + 200];
  return (*(uint64_t (**)(void))(*(void *)*a1 + 8))();
}

uint64_t sub_10011AED8(void *a1, unint64_t a2)
{
  if (!a2) {
    return (**(uint64_t (***)(void, uint64_t))*a1)(*a1, 48);
  }
  unint64_t v2 = a2;
  if (a2 < 0xA)
  {
    uint64_t v3 = (uint64_t)a1 + 17;
LABEL_20:
    *(unsigned char *)(v3 - 1) = v2 + 48;
    return (*(uint64_t (**)(void))(*(void *)*a1 + 8))();
  }
  unsigned int v5 = 4;
  unint64_t v6 = a2;
  while (1)
  {
    if (v6 <= 0x63)
    {
      v5 -= 2;
      goto LABEL_13;
    }
    if (v6 <= 0x3E7) {
      break;
    }
    if (v6 >> 4 < 0x271) {
      goto LABEL_13;
    }
    unint64_t v7 = v6 >> 5;
    v6 /= 0x2710uLL;
    v5 += 4;
    if (v7 <= 0xC34)
    {
      v5 -= 3;
      goto LABEL_13;
    }
  }
  --v5;
LABEL_13:
  uint64_t v3 = (uint64_t)a1 + v5 + 16;
  if (a2 < 0x64)
  {
    unint64_t v8 = a2;
  }
  else
  {
    do
    {
      unint64_t v8 = v2 / 0x64;
      *(_WORD *)(v3 - 2) = *(_WORD *)&a00010203040506[2 * (v2 % 0x64) + 400];
      v3 -= 2;
      unint64_t v9 = v2 >> 4;
      v2 /= 0x64uLL;
    }
    while (v9 > 0x270);
  }
  if (v8 < 0xA)
  {
    LOBYTE(v2) = v8;
    goto LABEL_20;
  }
  *(_WORD *)(v3 - 2) = *(_WORD *)&a00010203040506[2 * v8 + 400];
  return (*(uint64_t (**)(void))(*(void *)*a1 + 8))();
}

uint64_t sub_10011B030(const char *a1, double a2)
{
  if ((*(void *)&a2 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    uint64_t v5 = *(void *)a1;
    uint64_t v4 = *(uint64_t (**)(uint64_t, const char *, uint64_t))(**(void **)a1 + 8);
    unint64_t v6 = "null";
    uint64_t v3 = 4;
  }
  else
  {
    uint64_t v3 = sub_10011B0E0((unsigned char *)a1 + 16, a2) - (void)(a1 + 16);
    uint64_t v4 = *(uint64_t (**)(uint64_t, const char *, uint64_t))(**(void **)a1 + 8);
    uint64_t v5 = *(void *)a1;
    unint64_t v6 = a1 + 16;
  }

  return v4(v5, v6, v3);
}

uint64_t sub_10011B0E0(unsigned char *a1, double a2)
{
  uint64_t v2 = (uint64_t)a1;
  if ((*(void *)&a2 & 0x8000000000000000) != 0)
  {
    a2 = -a2;
    *a1 = 45;
    uint64_t v2 = (uint64_t)(a1 + 1);
  }
  if (a2 == 0.0)
  {
    *(_WORD *)uint64_t v2 = 11824;
    uint64_t result = v2 + 3;
    *(unsigned char *)(v2 + 2) = 48;
    return result;
  }
  uint64_t v15 = 0;
  sub_10011B304(v2, (int *)&v15 + 1, &v15, a2);
  uint64_t v4 = SHIDWORD(v15);
  uint64_t v5 = (int)v15 + (uint64_t)SHIDWORD(v15);
  if ((v15 & 0x80000000) == 0 && (int)v5 <= 15)
  {
    memset((void *)(v2 + SHIDWORD(v15)), 48, (int)v15);
    *(_WORD *)(v2 + v5) = 12334;
    return v2 + v5 + 2;
  }
  if ((v5 - 16) >= 0xFFFFFFF1)
  {
    unint64_t v7 = (unsigned char *)(v2 + v5);
    memmove(v7 + 1, v7, SHIDWORD(v15) - (unint64_t)v5);
    unsigned char *v7 = 46;
    return v4 + v2 + 1;
  }
  if (v5 == 0 || v5 >= 0xFFFFFFFD)
  {
    size_t v6 = -(int)v5;
    memmove((void *)(v2 + v6 + 2), (const void *)v2, SHIDWORD(v15));
    *(_WORD *)uint64_t v2 = 11824;
    memset((void *)(v2 + 2), 48, v6);
    return v2 + v4 + v6 + 2;
  }
  if (HIDWORD(v15) == 1)
  {
    uint64_t v8 = 1;
  }
  else
  {
    memmove((void *)(v2 + 2), (const void *)(v2 + 1), SHIDWORD(v15) - 1);
    *(unsigned char *)(v2 + 1) = 46;
    uint64_t v8 = v4 + 1;
  }
  unint64_t v9 = (unsigned char *)(v2 + v8);
  unsigned char *v9 = 101;
  unsigned int v10 = v5 - 1;
  if ((int)v5 >= 1) {
    char v11 = 43;
  }
  else {
    char v11 = 45;
  }
  if ((int)v5 - 1 < 0) {
    unsigned int v10 = 1 - v5;
  }
  v9[1] = v11;
  if (v10 > 9)
  {
    if (v10 > 0x63)
    {
      _DWORD v9[2] = v10 / 0x64 + 48;
      unsigned __int8 v14 = v10 % 0x64;
      void v9[3] = (v14 / 0xAu) | 0x30;
      _OWORD v9[4] = (v14 % 0xAu) | 0x30;
      uint64_t v13 = 2;
      return (uint64_t)&v9[v13 + 3];
    }
    _DWORD v9[2] = v10 / 0xAu + 48;
    char v12 = (v10 % 0xAu) | 0x30;
  }
  else
  {
    _DWORD v9[2] = 48;
    char v12 = v10 + 48;
  }
  void v9[3] = v12;
  uint64_t v13 = 1;
  return (uint64_t)&v9[v13 + 3];
}

uint64_t sub_10011B304(uint64_t a1, int *a2, _DWORD *a3, double a4)
{
  sub_10011B42C((uint64_t)v20, a4);
  long long v27 = v20[1];
  long long v26 = v20[0];
  v25[0] = v21;
  v25[1] = v22;
  if (-61 - (int)v22 <= 0) {
    int v7 = 78913 * (-61 - (int)v22) / 0x40000;
  }
  else {
    int v7 = 78913 * (-61 - (int)v22) / 0x40000 + 1;
  }
  uint64_t v8 = (uint64_t *)((char *)&unk_10017B320 + 16
                                          * ((int)((v7 + 307 + (((v7 + 307) >> 28) & 7)) << 16) >> 19));
  uint64_t v9 = v8[1];
  uint64_t v23 = *v8;
  int v24 = v9;
  unint64_t v10 = sub_10011B4D4(&v26, &v23);
  uint64_t v12 = v11;
  unint64_t v13 = sub_10011B4D4(&v27, &v23);
  unsigned int v15 = v14;
  unint64_t v16 = sub_10011B4D4(v25, &v23);
  *a3 = -HIDWORD(v9);
  return sub_10011B534(a1, a2, a3, v13 + 1, v15, v10, v12, v18, v16 - 1, v17);
}

void sub_10011B42C(uint64_t a1@<X8>, double a2@<D0>)
{
  uint64_t v2 = *(void *)&a2 & 0xFFFFFFFFFFFFFLL;
  if (*(void *)&a2 >> 52)
  {
    LODWORD(v5) = (*(void *)&a2 >> 52) - 1075;
    uint64_t v3 = 2 * (v2 | 0x10000000000000);
    uint64_t v4 = (2 * (*(void *)&a2 & 0xFFFFFFFFFFFFFLL | 0x10000000000000)) | 1;
    int v6 = (*(void *)&a2 >> 52) - 1076;
    if (*(void *)&a2 >> 53 && !v2)
    {
      char v7 = (*(void *)&a2 >> 52) - 53;
      uint64_t v8 = 0x3FFFFFFFFFFFFFLL;
      uint64_t v2 = 0x10000000000000;
      goto LABEL_8;
    }
    v2 |= 0x10000000000000uLL;
  }
  else
  {
    uint64_t v3 = 2 * v2;
    uint64_t v4 = (2 * (*(void *)&a2 & 0xFFFFFFFFFFFFFLL)) | 1;
    LODWORD(v5) = -1074;
    int v6 = -1075;
  }
  uint64_t v8 = v3 - 1;
  char v7 = v6;
  do
  {
LABEL_8:
    v4 *= 2;
    --v6;
  }
  while ((v4 & 0x8000000000000000) == 0);
  do
  {
    v2 *= 2;
    uint64_t v5 = (v5 - 1);
  }
  while ((v2 & 0x8000000000000000) == 0);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v5;
  *(void *)(a1 + 16) = v8 << (v7 - v6);
  *(_DWORD *)(a1 + 24) = v6;
  *(void *)(a1 + 32) = v4;
  *(_DWORD *)(a1 + 40) = v6;
}

unint64_t sub_10011B4D4(void *a1, void *a2)
{
  uint64_t v2 = HIDWORD(*a1);
  uint64_t v3 = HIDWORD(*a2);
  unint64_t v4 = v3 * (unint64_t)*a1;
  unint64_t v5 = *a2 * (unint64_t)v2;
  return HIDWORD(v5)
       + v3 * (unint64_t)v2
       + HIDWORD(v4)
       + ((((*a2 * (unint64_t)*a1) >> 32)
         + v4
         + v5
         + 0x80000000) >> 32);
}

uint64_t sub_10011B534(uint64_t result, int *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, int a10)
{
  unint64_t v10 = a9 - a4;
  unint64_t v11 = a9 - a6;
  int v12 = -a10;
  unint64_t v13 = 1 << -(char)a10;
  unint64_t v14 = a9 >> -(char)a10;
  unint64_t v15 = (v13 - 1) & a9;
  if (v14 <= 0x3B9AC9FF)
  {
    if (v14 <= 0x5F5E0FF)
    {
      if (v14 <= 0x98967F)
      {
        if (v14 <= 0xF423F)
        {
          unsigned int v18 = v14 >> 5;
          unsigned int v19 = v14 >> 4;
          if (v14 <= 9) {
            int v20 = 1;
          }
          else {
            int v20 = 10;
          }
          if (v14 <= 9) {
            int v21 = 1;
          }
          else {
            int v21 = 2;
          }
          if (v14 <= 0x63) {
            int v22 = v20;
          }
          else {
            int v22 = 100;
          }
          if (v14 <= 0x63) {
            int v23 = v21;
          }
          else {
            int v23 = 3;
          }
          if (v14 <= 0x3E7) {
            int v24 = v22;
          }
          else {
            int v24 = 1000;
          }
          if (v14 <= 0x3E7) {
            int v25 = v23;
          }
          else {
            int v25 = 4;
          }
          if (v19 <= 0x270) {
            int v26 = v24;
          }
          else {
            int v26 = 10000;
          }
          if (v19 <= 0x270) {
            int v27 = v25;
          }
          else {
            int v27 = 5;
          }
          if (v18 > 0xC34) {
            unsigned int v16 = 100000;
          }
          else {
            unsigned int v16 = v26;
          }
          if (v18 <= 0xC34) {
            int v17 = v27;
          }
          else {
            int v17 = 6;
          }
        }
        else
        {
          unsigned int v16 = 1000000;
          int v17 = 7;
        }
      }
      else
      {
        unsigned int v16 = 10000000;
        int v17 = 8;
      }
    }
    else
    {
      unsigned int v16 = 100000000;
      int v17 = 9;
    }
  }
  else
  {
    unsigned int v16 = 1000000000;
    int v17 = 10;
  }
  uint64_t v28 = -a6;
  uint64_t v29 = -a4;
  uint64_t v30 = a6 - a9;
  while (v17 > 0)
  {
    unsigned int v31 = v14 / v16;
    unint64_t v14 = v14 % v16;
    uint64_t v32 = *a2;
    *a2 = v32 + 1;
    *(unsigned char *)(result + v32) = v31 + 48;
    --v17;
    unint64_t v33 = (v14 << v12) + v15;
    if (v10 >= v33)
    {
      *a3 += v17;
      unint64_t v34 = (unint64_t)v16 << v12;
      if (v33 >= v11 || v10 - v33 < v34) {
        return result;
      }
      uint64_t v36 = *a2 - 1;
      unint64_t v37 = v15 + (v14 << v12) + v34;
      unint64_t v38 = v29 - v37;
      unint64_t v39 = a9;
      do
      {
        if (v37 >= v11 && v28 - v33 + v39 <= v30 + v37) {
          break;
        }
        --*(unsigned char *)(result + v36);
        if (v37 >= v11) {
          break;
        }
        unint64_t v40 = v38 + v39;
        v39 -= v34;
        v37 += v34;
      }
      while (v40 >= v34);
    }
    else
    {
      v16 /= 0xAu;
    }
    if (v10 >= v33) {
      return result;
    }
  }
  int v41 = 0;
  do
  {
    unint64_t v42 = v10;
    unint64_t v43 = v11;
    uint64_t v44 = 5 * v15;
    uint64_t v45 = *a2;
    *a2 = v45 + 1;
    *(unsigned char *)(result + v45) = ((unint64_t)(2 * v44) >> v12) + 48;
    unint64_t v10 = 10 * v42;
    v11 *= 10;
    --v41;
    unint64_t v15 = (v13 - 1) & (2 * v44);
  }
  while (10 * v42 < v15);
  *a3 += v41;
  if (v15 < v11 && 10 * v42 - v15 >= v13)
  {
    uint64_t v46 = *a2 - 1;
    uint64_t v47 = 10 * v43;
    uint64_t v48 = -(uint64_t)v15;
    unint64_t v49 = 10 * v42 - v13;
    unint64_t v50 = v13 + v15;
    uint64_t v51 = -10 * v43;
    do
    {
      if (v50 >= v11 && v47 + v48 <= v51 + v50) {
        break;
      }
      --*(unsigned char *)(result + v46);
      if (v50 >= v11) {
        break;
      }
      unint64_t v52 = v49 + v48;
      v48 -= v13;
      v50 += v13;
    }
    while (v52 >= v13);
  }
  return result;
}

uint64_t sub_10011B814(uint64_t a1)
{
  if (*(char *)(a1 + 631) < 0) {
    operator delete(*(void **)(a1 + 608));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10000B678(v2);
  }
  return a1;
}

unsigned char *sub_10011B854(unsigned char *a1, int a2)
{
  switch(a2)
  {
    case 1:
      uint64_t v3 = operator new(0x18uLL);
      void v3[2] = 0;
      v3[1] = 0;
      void *v3 = v3 + 1;
      goto LABEL_8;
    case 2:
      uint64_t v3 = operator new(0x18uLL);
      v3[1] = 0;
      void v3[2] = 0;
      void *v3 = 0;
      goto LABEL_8;
    case 3:
      uint64_t v3 = sub_10011B930("");
      goto LABEL_8;
    case 4:
      *a1 = 0;
      return a1;
    case 8:
      uint64_t v3 = operator new(0x20uLL);
      v3[1] = 0;
      void v3[2] = 0;
      void *v3 = 0;
      *((_WORD *)v3 + 12) = 0;
LABEL_8:
      *(void *)a1 = v3;
      break;
    default:
      *(void *)a1 = 0;
      break;
  }
  return a1;
}

void *sub_10011B930(char *a1)
{
  uint64_t v2 = operator new(0x18uLL);
  sub_100018888(v2, a1);
  return v2;
}

void sub_10011B968(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_10011B97C(std::runtime_error *a1)
{
  a1->__vftable = (std::runtime_error_vtbl *)off_1001B9538;
  std::runtime_error::~runtime_error(a1 + 1);

  std::exception::~exception(a1);
}

void sub_10011B9D0(std::runtime_error *a1)
{
  a1->__vftable = (std::runtime_error_vtbl *)off_1001B9538;
  std::runtime_error::~runtime_error(a1 + 1);
  std::exception::~exception(a1);

  operator delete();
}

void *sub_10011BA38@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char a4@<W3>, uint64_t a5@<X8>)
{
  *(void *)&long long v8 = a1;
  *((void *)&v8 + 1) = a2;
  sub_10011BF28((uint64_t)v9, a3);
  sub_10011BFA8(a5, &v8, (uint64_t)v9, a4);
  return sub_10011837C(v9);
}

void sub_10011BABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10011837C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_10011BAD0(uint64_t a1, int a2, unsigned __int8 *a3)
{
  if (*(void *)(a1 + 24))
  {
    sub_10011D3C4((uint64_t)v30, a1);
    sub_10011F1BC((uint64_t)&v31, (uint64_t)a3, (uint64_t)v30, *(unsigned char *)(a1 + 176));
    sub_10011837C(v30);
    sub_10011D45C(a1, &v31);
    if (a2)
    {
      int v6 = sub_10011C088(a1 + 40);
      *(_DWORD *)(a1 + 32) = v6;
      if (v6 != 15)
      {
        uint64_t v7 = *(void *)(a1 + 64);
        sub_10011DF14(a1 + 40, &v29);
        long long v25 = *(_OWORD *)(a1 + 64);
        uint64_t v26 = *(void *)(a1 + 80);
        sub_100018888(v22, "value");
        sub_10011E28C(a1, 0xFu, (uint64_t)v22, &__p);
        sub_10011DFF8(101, (uint64_t *)&v25, (uint64_t)&__p, &v27);
        sub_10011DD9C((uint64_t)&v31, v7, (uint64_t)&v29, (uint64_t)&v27);
        v27.__vftable = (std::exception_vtbl *)off_1001B9538;
        std::runtime_error::~runtime_error(&v28);
        std::exception::~exception(&v27);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v23 < 0) {
          operator delete(v22[0]);
        }
        if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v29.__r_.__value_.__l.__data_);
        }
      }
    }
    if (v36)
    {
      long long v8 = (char ***)&v21;
      int v9 = *a3;
      *a3 = 9;
      char v20 = v9;
      uint64_t v10 = *((void *)a3 + 1);
      *((void *)a3 + 1) = 0;
      uint64_t v21 = v10;
    }
    else
    {
      if (*a3 != 9)
      {
LABEL_27:
        sub_100121C04((uint64_t)&v31);
        return;
      }
      long long v8 = (char ***)&v19;
      *a3 = 0;
      char v18 = 9;
      uint64_t v16 = *((void *)a3 + 1);
      *((void *)a3 + 1) = 0;
      uint64_t v19 = v16;
      int v9 = 9;
    }
    sub_100118400(v8, v9);
    goto LABEL_27;
  }
  char v11 = *(unsigned char *)(a1 + 176);
  unsigned int v31 = a3;
  long long v32 = 0u;
  long long v33 = 0u;
  char v34 = 0;
  char v35 = v11;
  sub_10011E6EC(a1, (uint64_t)&v31);
  if (a2)
  {
    int v12 = sub_10011C088(a1 + 40);
    *(_DWORD *)(a1 + 32) = v12;
    if (v12 != 15)
    {
      uint64_t v13 = *(void *)(a1 + 64);
      sub_10011DF14(a1 + 40, &v29);
      long long v25 = *(_OWORD *)(a1 + 64);
      uint64_t v26 = *(void *)(a1 + 80);
      sub_100018888(v22, "value");
      sub_10011E28C(a1, 0xFu, (uint64_t)v22, &__p);
      sub_10011DFF8(101, (uint64_t *)&v25, (uint64_t)&__p, &v27);
      sub_10011F044((uint64_t)&v31, v13, (uint64_t)&v29, (uint64_t)&v27);
      v27.__vftable = (std::exception_vtbl *)off_1001B9538;
      std::runtime_error::~runtime_error(&v28);
      std::exception::~exception(&v27);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (v23 < 0) {
        operator delete(v22[0]);
      }
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v29.__r_.__value_.__l.__data_);
      }
    }
  }
  if (v34)
  {
    int v14 = *a3;
    *a3 = 9;
    unint64_t v15 = (char **)*((void *)a3 + 1);
    *((void *)a3 + 1) = 0;
    int v17 = v15;
    sub_100118400(&v17, v14);
  }
  if ((void)v32)
  {
    *((void *)&v32 + 1) = v32;
    operator delete((void *)v32);
  }
}

void sub_10011BE2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,std::runtime_error a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,char a41)
{
  sub_10011E698(&a31);
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  unint64_t v43 = *(void **)(v41 - 200);
  if (v43)
  {
    *(void *)(v41 - 192) = v43;
    operator delete(v43);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10011BF28(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t sub_10011BFA8(uint64_t a1, _OWORD *a2, uint64_t a3, char a4)
{
  uint64_t v7 = sub_10011D3C4(a1, a3);
  *(_DWORD *)(v7 + 32) = 0;
  uint64_t v8 = v7 + 40;
  *(_OWORD *)(v7 + 40) = *a2;
  *(_DWORD *)(v7 + 56) = -1;
  *(unsigned char *)(v7 + 60) = 0;
  *(_OWORD *)(v7 + 64) = 0u;
  *(_OWORD *)(v7 + 80) = 0u;
  *(_OWORD *)(v7 + 96) = 0u;
  *(_OWORD *)(v7 + 112) = 0u;
  *(void *)(v7 + 128) = 0;
  *(void *)(v7 + 136) = "";
  *(void *)(v7 + 152) = 0;
  *(void *)(v7 + 160) = 0;
  *(void *)(v7 + 144) = 0;
  *(_DWORD *)(a1 + 168) = sub_10011C054();
  *(unsigned char *)(a1 + 176) = a4;
  *(_DWORD *)(a1 + 32) = sub_10011C088(v8);
  return a1;
}

void sub_10011C038(_Unwind_Exception *a1)
{
  sub_10011D380(v2);
  sub_10011837C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10011C054()
{
  uint64_t v0 = localeconv();
  if (v0->decimal_point) {
    return *v0->decimal_point;
  }
  else {
    return 46;
  }
}

uint64_t sub_10011C088(uint64_t a1)
{
  if (*(void *)(a1 + 24) || sub_10011C338((unsigned __int8 **)a1))
  {
    while (2)
    {
      while (1)
      {
        sub_10011C39C((unsigned __int8 **)a1);
        int v2 = *(_DWORD *)(a1 + 16);
        if (v2 > 31) {
          break;
        }
        if ((v2 - 9) >= 2 && v2 != 13)
        {
          if ((v2 + 1) < 2) {
            return 15;
          }
LABEL_48:
          int v6 = "invalid literal";
          goto LABEL_24;
        }
      }
      if (v2 > 90)
      {
        if (v2 <= 109)
        {
          switch(v2)
          {
            case '[':
              return 8;
            case ']':
              return 10;
            case 'f':
              uint64_t v7 = 0;
              while (aFalse_0[v7 + 1] == sub_10011C39C((unsigned __int8 **)a1))
              {
                if (++v7 == 4) {
                  return 2;
                }
              }
              break;
          }
        }
        else if (v2 > 122)
        {
          if (v2 == 123) {
            return 9;
          }
          if (v2 == 125) {
            return 11;
          }
        }
        else if (v2 == 110)
        {
          int v9 = 1819047278;
          uint64_t v8 = 1;
          while (*((unsigned __int8 *)&v9 + v8) == sub_10011C39C((unsigned __int8 **)a1))
          {
            if (++v8 == 4) {
              return 3;
            }
          }
        }
        else if (v2 == 116)
        {
          int v10 = 1702195828;
          uint64_t v5 = 1;
          while (*((unsigned __int8 *)&v10 + v5) == sub_10011C39C((unsigned __int8 **)a1))
          {
            if (++v5 == 4) {
              return 1;
            }
          }
        }
        goto LABEL_48;
      }
      switch(v2)
      {
        case ' ':
          continue;
        case '""':
          uint64_t result = sub_10011C504(a1);
          break;
        case ',':
          uint64_t result = 13;
          break;
        case '-':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          uint64_t result = sub_10011CDDC(a1);
          break;
        case ':':
          uint64_t result = 12;
          break;
        default:
          goto LABEL_48;
      }
      break;
    }
  }
  else
  {
    int v6 = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
LABEL_24:
    *(void *)(a1 + 96) = v6;
    return 14;
  }
  return result;
}

BOOL sub_10011C338(unsigned __int8 **a1)
{
  if (sub_10011C39C(a1) == 239)
  {
    return sub_10011C39C(a1) == 187 && sub_10011C39C(a1) == 191;
  }
  else
  {
    sub_10011D0F4((uint64_t)a1);
    return 1;
  }
}

uint64_t sub_10011C39C(unsigned __int8 **a1)
{
  *(int64x2_t *)(a1 + 3) = vaddq_s64(*(int64x2_t *)(a1 + 3), vdupq_n_s64(1uLL));
  if (*((unsigned char *)a1 + 20))
  {
    *((unsigned char *)a1 + 20) = 0;
    int v2 = *((_DWORD *)a1 + 4);
  }
  else
  {
    uint64_t v3 = *a1;
    if (*a1 == a1[1])
    {
      int v2 = -1;
    }
    else
    {
      int v2 = *v3;
      *a1 = v3 + 1;
    }
    *((_DWORD *)a1 + 4) = v2;
  }
  if (v2 == -1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = a1[7];
  unint64_t v4 = (unint64_t)a1[8];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = a1 + 6;
    unint64_t v8 = (unint64_t)a1[6];
    int v9 = &v5[-v8];
    uint64_t v10 = (uint64_t)&v5[-v8 + 1];
    if (v10 < 0) {
      sub_10002B5E0();
    }
    unint64_t v11 = v4 - v8;
    if (2 * v11 > v10) {
      uint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v12 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v12 = v10;
    }
    if (v12) {
      uint64_t v13 = (unsigned __int8 *)operator new(v12);
    }
    else {
      uint64_t v13 = 0;
    }
    int v14 = &v13[v12];
    v9[(void)v13] = v2;
    uint64_t v6 = (uint64_t)&v9[(void)v13 + 1];
    if (v5 == (unsigned __int8 *)v8)
    {
      uint64_t v13 = &v9[(void)v13];
    }
    else
    {
      unint64_t v15 = &v5[~v8];
      do
      {
        unsigned __int8 v16 = *--v5;
        (v15--)[(void)v13] = v16;
      }
      while (v5 != (unsigned __int8 *)v8);
      uint64_t v5 = *v7;
    }
    a1[6] = v13;
    a1[7] = (unsigned __int8 *)v6;
    a1[8] = v14;
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *uint64_t v5 = v2;
    uint64_t v6 = (uint64_t)(v5 + 1);
  }
  a1[7] = (unsigned __int8 *)v6;
  uint64_t result = *((unsigned int *)a1 + 4);
  if (result == 10)
  {
    uint64_t v18 = (uint64_t)(a1[5] + 1);
    a1[4] = 0;
    a1[5] = (unsigned __int8 *)v18;
  }
  return result;
}

uint64_t sub_10011C504(uint64_t a1)
{
  sub_10011D144(a1);
  while (2)
  {
    while (2)
    {
      int v2 = sub_10011C39C((unsigned __int8 **)a1) + 1;
      uint64_t result = 4;
      unint64_t v4 = "invalid string: missing closing quote";
      switch(v2)
      {
        case 0:
          goto LABEL_81;
        case 1:
          unint64_t v4 = "invalid string: control character U+0000 (NUL) must be escaped to \\u0000";
          goto LABEL_81;
        case 2:
          unint64_t v4 = "invalid string: control character U+0001 (SOH) must be escaped to \\u0001";
          goto LABEL_81;
        case 3:
          unint64_t v4 = "invalid string: control character U+0002 (STX) must be escaped to \\u0002";
          goto LABEL_81;
        case 4:
          unint64_t v4 = "invalid string: control character U+0003 (ETX) must be escaped to \\u0003";
          goto LABEL_81;
        case 5:
          unint64_t v4 = "invalid string: control character U+0004 (EOT) must be escaped to \\u0004";
          goto LABEL_81;
        case 6:
          unint64_t v4 = "invalid string: control character U+0005 (ENQ) must be escaped to \\u0005";
          goto LABEL_81;
        case 7:
          unint64_t v4 = "invalid string: control character U+0006 (ACK) must be escaped to \\u0006";
          goto LABEL_81;
        case 8:
          unint64_t v4 = "invalid string: control character U+0007 (BEL) must be escaped to \\u0007";
          goto LABEL_81;
        case 9:
          unint64_t v4 = "invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b";
          goto LABEL_81;
        case 10:
          unint64_t v4 = "invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t";
          goto LABEL_81;
        case 11:
          unint64_t v4 = "invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n";
          goto LABEL_81;
        case 12:
          unint64_t v4 = "invalid string: control character U+000B (VT) must be escaped to \\u000B";
          goto LABEL_81;
        case 13:
          unint64_t v4 = "invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f";
          goto LABEL_81;
        case 14:
          unint64_t v4 = "invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r";
          goto LABEL_81;
        case 15:
          unint64_t v4 = "invalid string: control character U+000E (SO) must be escaped to \\u000E";
          goto LABEL_81;
        case 16:
          unint64_t v4 = "invalid string: control character U+000F (SI) must be escaped to \\u000F";
          goto LABEL_81;
        case 17:
          unint64_t v4 = "invalid string: control character U+0010 (DLE) must be escaped to \\u0010";
          goto LABEL_81;
        case 18:
          unint64_t v4 = "invalid string: control character U+0011 (DC1) must be escaped to \\u0011";
          goto LABEL_81;
        case 19:
          unint64_t v4 = "invalid string: control character U+0012 (DC2) must be escaped to \\u0012";
          goto LABEL_81;
        case 20:
          unint64_t v4 = "invalid string: control character U+0013 (DC3) must be escaped to \\u0013";
          goto LABEL_81;
        case 21:
          unint64_t v4 = "invalid string: control character U+0014 (DC4) must be escaped to \\u0014";
          goto LABEL_81;
        case 22:
          unint64_t v4 = "invalid string: control character U+0015 (NAK) must be escaped to \\u0015";
          goto LABEL_81;
        case 23:
          unint64_t v4 = "invalid string: control character U+0016 (SYN) must be escaped to \\u0016";
          goto LABEL_81;
        case 24:
          unint64_t v4 = "invalid string: control character U+0017 (ETB) must be escaped to \\u0017";
          goto LABEL_81;
        case 25:
          unint64_t v4 = "invalid string: control character U+0018 (CAN) must be escaped to \\u0018";
          goto LABEL_81;
        case 26:
          unint64_t v4 = "invalid string: control character U+0019 (EM) must be escaped to \\u0019";
          goto LABEL_81;
        case 27:
          unint64_t v4 = "invalid string: control character U+001A (SUB) must be escaped to \\u001A";
          goto LABEL_81;
        case 28:
          unint64_t v4 = "invalid string: control character U+001B (ESC) must be escaped to \\u001B";
          goto LABEL_81;
        case 29:
          unint64_t v4 = "invalid string: control character U+001C (FS) must be escaped to \\u001C";
          goto LABEL_81;
        case 30:
          unint64_t v4 = "invalid string: control character U+001D (GS) must be escaped to \\u001D";
          goto LABEL_81;
        case 31:
          unint64_t v4 = "invalid string: control character U+001E (RS) must be escaped to \\u001E";
          goto LABEL_81;
        case 32:
          unint64_t v4 = "invalid string: control character U+001F (US) must be escaped to \\u001F";
          goto LABEL_81;
        case 33:
        case 34:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
        case 92:
        case 94:
        case 95:
        case 96:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 123:
        case 124:
        case 125:
        case 126:
        case 127:
        case 128:
          int v5 = *(_DWORD *)(a1 + 16);
          goto LABEL_4;
        case 35:
          return result;
        case 93:
          int v10 = sub_10011C39C((unsigned __int8 **)a1);
          unint64_t v4 = "invalid string: forbidden character after backslash";
          if (v10 <= 97)
          {
            switch(v10)
            {
              case '""':
                LOBYTE(v5) = 34;
                break;
              case '/':
                LOBYTE(v5) = 47;
                break;
              case '\\':
                LOBYTE(v5) = 92;
                break;
              default:
                goto LABEL_81;
            }
            goto LABEL_4;
          }
          break;
        case 195:
        case 196:
        case 197:
        case 198:
        case 199:
        case 200:
        case 201:
        case 202:
        case 203:
        case 204:
        case 205:
        case 206:
        case 207:
        case 208:
        case 209:
        case 210:
        case 211:
        case 212:
        case 213:
        case 214:
        case 215:
        case 216:
        case 217:
        case 218:
        case 219:
        case 220:
        case 221:
        case 222:
        case 223:
        case 224:
          *(void *)&long long v14 = 0xBF00000080;
          uint64_t v6 = (std::string *)a1;
          uint64_t v7 = 2;
          goto LABEL_19;
        case 225:
          long long v8 = xmmword_10017AE10;
          goto LABEL_7;
        case 226:
        case 227:
        case 228:
        case 229:
        case 230:
        case 231:
        case 232:
        case 233:
        case 234:
        case 235:
        case 236:
        case 237:
        case 239:
        case 240:
          long long v8 = xmmword_10017AE00;
          goto LABEL_7;
        case 238:
          long long v8 = xmmword_10017ADF0;
LABEL_7:
          long long v14 = v8;
          uint64_t v6 = (std::string *)a1;
          uint64_t v7 = 4;
          goto LABEL_19;
        case 241:
          uint64_t v15 = 0xBF00000080;
          int v9 = &xmmword_10017B838;
          goto LABEL_18;
        case 242:
        case 243:
        case 244:
          uint64_t v15 = 0xBF00000080;
          int v9 = &xmmword_10017B850;
          goto LABEL_18;
        case 245:
          uint64_t v15 = 0xBF00000080;
          int v9 = &xmmword_10017B868;
LABEL_18:
          long long v14 = *v9;
          uint64_t v6 = (std::string *)a1;
          uint64_t v7 = 6;
LABEL_19:
          if ((sub_10011D2E4(v6, &v14, v7) & 1) == 0) {
            return 14;
          }
          continue;
        default:
          unint64_t v4 = "invalid string: ill-formed UTF-8 byte";
          goto LABEL_81;
      }
      break;
    }
    switch(v10)
    {
      case 'n':
        LOBYTE(v5) = 10;
        goto LABEL_4;
      case 'o':
      case 'p':
      case 'q':
      case 's':
        goto LABEL_81;
      case 'r':
        LOBYTE(v5) = 13;
        goto LABEL_4;
      case 't':
        LOBYTE(v5) = 9;
        goto LABEL_4;
      case 'u':
        unsigned int v11 = sub_10011D208(a1);
        if (v11 == -1) {
          goto LABEL_83;
        }
        unsigned int v12 = v11;
        if ((v11 & 0xFFFFFC00) != 0xD800)
        {
          if ((v11 & 0xFFFFFC00) == 0xDC00)
          {
            unint64_t v4 = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
            goto LABEL_81;
          }
          if ((int)v11 > 127)
          {
            if (v11 <= 0x7FF)
            {
              std::string::push_back((std::string *)(a1 + 72), (v11 >> 6) | 0xC0);
              goto LABEL_39;
            }
            if (!HIWORD(v11))
            {
              std::string::push_back((std::string *)(a1 + 72), (v11 >> 12) | 0xE0);
              goto LABEL_38;
            }
LABEL_37:
            std::string::push_back((std::string *)(a1 + 72), (v12 >> 18) | 0xF0);
            std::string::push_back((std::string *)(a1 + 72), (v12 >> 12) & 0x3F | 0x80);
LABEL_38:
            std::string::push_back((std::string *)(a1 + 72), (v12 >> 6) & 0x3F | 0x80);
LABEL_39:
            LOBYTE(v5) = v12 & 0x3F | 0x80;
            goto LABEL_4;
          }
          LOBYTE(v5) = v11;
LABEL_4:
          std::string::push_back((std::string *)(a1 + 72), v5);
          continue;
        }
        if (sub_10011C39C((unsigned __int8 **)a1) != 92
          || sub_10011C39C((unsigned __int8 **)a1) != 117)
        {
LABEL_84:
          unint64_t v4 = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
          goto LABEL_81;
        }
        unsigned int v13 = sub_10011D208(a1);
        if (v13 != -1)
        {
          if (v13 >> 10 != 55) {
            goto LABEL_84;
          }
          unsigned int v12 = v13 + (v12 << 10) - 56613888;
          goto LABEL_37;
        }
LABEL_83:
        unint64_t v4 = "invalid string: '\\u' must be followed by 4 hex digits";
LABEL_81:
        *(void *)(a1 + 96) = v4;
        return 14;
      default:
        if (v10 == 98)
        {
          LOBYTE(v5) = 8;
        }
        else
        {
          if (v10 != 102) {
            goto LABEL_81;
          }
          LOBYTE(v5) = 12;
        }
        goto LABEL_4;
    }
  }
}

uint64_t sub_10011CDDC(uint64_t a1)
{
  sub_10011D144(a1);
  int v2 = *(_DWORD *)(a1 + 16);
  if ((v2 - 49) < 9)
  {
    int v3 = 5;
LABEL_3:
    unint64_t v4 = (std::string *)(a1 + 72);
    while (1)
    {
      std::string::push_back((std::string *)(a1 + 72), v2);
      int v5 = sub_10011C39C((unsigned __int8 **)a1);
      if ((v5 - 48) >= 0xA) {
        break;
      }
      int v2 = *(_DWORD *)(a1 + 16);
    }
    if (v5 != 46)
    {
      if (v5 == 69 || v5 == 101) {
        goto LABEL_9;
      }
LABEL_37:
      sub_10011D0F4(a1);
      __endptr = 0;
      *__error() = 0;
      if (v3 == 6)
      {
        unsigned __int8 v16 = (const char *)(a1 + 72);
        if (*(char *)(a1 + 95) < 0) {
          unsigned __int8 v16 = *(const char **)v16;
        }
        uint64_t v17 = strtoll(v16, &__endptr, 10);
        if (!*__error())
        {
          *(void *)(a1 + 104) = v17;
          return 6;
        }
      }
      else
      {
        long long v14 = (const char *)(a1 + 72);
        if (*(char *)(a1 + 95) < 0) {
          long long v14 = *(const char **)v14;
        }
        unint64_t v15 = strtoull(v14, &__endptr, 10);
        if (!*__error())
        {
          *(void *)(a1 + 112) = v15;
          return 5;
        }
      }
      goto LABEL_14;
    }
    goto LABEL_31;
  }
  if (v2 == 48)
  {
    std::string::push_back((std::string *)(a1 + 72), 48);
    int v3 = 5;
  }
  else
  {
    if (v2 == 45) {
      std::string::push_back((std::string *)(a1 + 72), 45);
    }
    int v10 = sub_10011C39C((unsigned __int8 **)a1);
    if ((v10 - 49) < 9)
    {
      int v2 = *(_DWORD *)(a1 + 16);
      int v3 = 6;
      goto LABEL_3;
    }
    if (v10 != 48)
    {
      unsigned int v11 = "invalid number; expected digit after '-'";
      goto LABEL_52;
    }
    std::string::push_back((std::string *)(a1 + 72), *(unsigned char *)(a1 + 16));
    int v3 = 6;
  }
  int v12 = sub_10011C39C((unsigned __int8 **)a1);
  if (v12 == 101 || v12 == 69)
  {
    unint64_t v4 = (std::string *)(a1 + 72);
    goto LABEL_9;
  }
  if (v12 != 46) {
    goto LABEL_37;
  }
  unint64_t v4 = (std::string *)(a1 + 72);
LABEL_31:
  std::string::push_back(v4, *(unsigned char *)(a1 + 128));
  if (sub_10011C39C((unsigned __int8 **)a1) - 48 > 9)
  {
    unsigned int v11 = "invalid number; expected digit after '.'";
    goto LABEL_52;
  }
  unint64_t v4 = (std::string *)(a1 + 72);
  do
  {
    std::string::push_back((std::string *)(a1 + 72), *(unsigned char *)(a1 + 16));
    int v13 = sub_10011C39C((unsigned __int8 **)a1);
  }
  while ((v13 - 48) < 0xA);
  if (v13 == 101 || v13 == 69)
  {
LABEL_9:
    std::string::push_back(v4, *(unsigned char *)(a1 + 16));
    int v6 = sub_10011C39C((unsigned __int8 **)a1);
    if ((v6 - 48) < 0xA)
    {
      uint64_t v7 = (std::string *)(a1 + 72);
      goto LABEL_11;
    }
    if (v6 == 45 || v6 == 43)
    {
      uint64_t v7 = (std::string *)(a1 + 72);
      std::string::push_back((std::string *)(a1 + 72), *(unsigned char *)(a1 + 16));
      if (sub_10011C39C((unsigned __int8 **)a1) - 48 < 0xA)
      {
LABEL_11:
        std::string::push_back(v7, *(unsigned char *)(a1 + 16));
        if (sub_10011C39C((unsigned __int8 **)a1) - 48 <= 9)
        {
          do
            std::string::push_back((std::string *)(a1 + 72), *(unsigned char *)(a1 + 16));
          while (sub_10011C39C((unsigned __int8 **)a1) - 48 < 0xA);
        }
        goto LABEL_13;
      }
      unsigned int v11 = "invalid number; expected digit after exponent sign";
    }
    else
    {
      unsigned int v11 = "invalid number; expected '+', '-', or digit after exponent";
    }
LABEL_52:
    *(void *)(a1 + 96) = v11;
    return 14;
  }
LABEL_13:
  sub_10011D0F4(a1);
  __endptr = 0;
  *__error() = 0;
LABEL_14:
  long long v8 = (const char *)(a1 + 72);
  if (*(char *)(a1 + 95) < 0) {
    long long v8 = *(const char **)v8;
  }
  *(double *)(a1 + 120) = strtod(v8, &__endptr);
  return 7;
}

uint64_t sub_10011D0F4(uint64_t result)
{
  uint64_t v1 = (void *)(result + 32);
  uint64_t v2 = *(void *)(result + 32);
  *(unsigned char *)(result + 20) = 1;
  --*(void *)(result + 24);
  if (v2 || (uint64_t v1 = (void *)(result + 40), (v2 = *(void *)(result + 40)) != 0)) {
    void *v1 = v2 - 1;
  }
  if (*(_DWORD *)(result + 16) != -1) {
    --*(void *)(result + 56);
  }
  return result;
}

void sub_10011D144(uint64_t a1)
{
  if (*(char *)(a1 + 95) < 0)
  {
    **(unsigned char **)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 72) = 0;
    *(unsigned char *)(a1 + 95) = 0;
  }
  uint64_t v2 = *(unsigned char **)(a1 + 48);
  *(void *)(a1 + 56) = v2;
  int v3 = *(_DWORD *)(a1 + 16);
  unint64_t v4 = *(void *)(a1 + 64);
  if ((unint64_t)v2 >= v4)
  {
    unint64_t v6 = v4 - (void)v2;
    uint64_t v7 = 2 * v6;
    if (2 * v6 <= 1) {
      uint64_t v7 = 1;
    }
    if (v6 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v8 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v8 = v7;
    }
    int v9 = operator new(v8);
    unsigned char *v9 = v3;
    int v5 = v9 + 1;
    *(void *)(a1 + 48) = v9;
    *(void *)(a1 + 56) = v9 + 1;
    *(void *)(a1 + 64) = &v9[v8];
    if (v2) {
      operator delete(v2);
    }
  }
  else
  {
    unsigned char *v2 = v3;
    int v5 = v2 + 1;
  }
  *(void *)(a1 + 56) = v5;
}

uint64_t sub_10011D208(uint64_t a1)
{
  uint64_t v2 = 0;
  LODWORD(v3) = 0;
  long long v8 = xmmword_10017AE20;
  while (1)
  {
    int v4 = *(_DWORD *)((char *)&v8 + v2);
    sub_10011C39C((unsigned __int8 **)a1);
    int v5 = *(_DWORD *)(a1 + 16);
    int v6 = v5 - 48;
    if ((v5 - 48) >= 0xA) {
      break;
    }
LABEL_7:
    uint64_t v3 = ((v6 << v4) + v3);
    v2 += 4;
    if (v2 == 16) {
      return v3;
    }
  }
  if ((v5 - 65) <= 5)
  {
    int v6 = v5 - 55;
    goto LABEL_7;
  }
  if ((v5 - 97) <= 5)
  {
    int v6 = v5 - 87;
    goto LABEL_7;
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10011D2E4(std::string *a1, _DWORD *a2, uint64_t a3)
{
  int v6 = a1 + 3;
  std::string::push_back(a1 + 3, a1->__r_.__value_.__s.__data_[16]);
  if (!a3) {
    return 1;
  }
  uint64_t v7 = &a2[a3];
  while (1)
  {
    sub_10011C39C((unsigned __int8 **)a1);
    int v8 = a1->__r_.__value_.__r.__words[2];
    if (*a2 > v8 || v8 > a2[1]) {
      break;
    }
    std::string::push_back(v6, v8);
    a2 += 2;
    if (a2 == v7) {
      return 1;
    }
  }
  uint64_t result = 0;
  a1[4].__r_.__value_.__r.__words[0] = (std::string::size_type)"invalid string: ill-formed UTF-8 byte";
  return result;
}

uint64_t sub_10011D380(uint64_t a1)
{
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_10011D3C4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_10011D45C(uint64_t a1, unsigned __int8 **a2)
{
  unint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  int v4 = (long long *)(a1 + 112);
  uint64_t v5 = a1 + 40;
  while (2)
  {
    switch(*(_DWORD *)(a1 + 32))
    {
      case 1:
        LOBYTE(v36.__vftable) = 1;
        sub_100120B18(a2, (unsigned __int8 *)&v36, 0);
        goto LABEL_19;
      case 2:
        LOBYTE(v36.__vftable) = 0;
        sub_100120B18(a2, (unsigned __int8 *)&v36, 0);
        goto LABEL_19;
      case 3:
        v36.__vftable = 0;
        sub_100120DA0(a2, (uint64_t)&v36, 0);
        goto LABEL_19;
      case 4:
        sub_1001212A8(a2, (uint64_t)v4, 0);
        goto LABEL_19;
      case 5:
        v36.__vftable = *(std::runtime_error_vtbl **)(a1 + 152);
        sub_100121538(a2, (char ***)&v36, 0);
        goto LABEL_19;
      case 6:
        v36.__vftable = *(std::runtime_error_vtbl **)(a1 + 144);
        sub_100121020(a2, (char ***)&v36, 0);
        goto LABEL_19;
      case 7:
        if ((*(void *)(a1 + 160) & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
        {
          v36.__vftable = *(std::runtime_error_vtbl **)(a1 + 160);
          sub_100120890(a2, (char ***)&v36, 0);
          goto LABEL_19;
        }
        uint64_t v27 = *(void *)(a1 + 64);
        sub_10011DF14(v5, &v38);
        sub_10011DF14(v5, &v32);
        std::runtime_error v28 = std::string::insert(&v32, 0, "number overflow parsing '");
        long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v29;
        v28->__r_.__value_.__l.__size_ = 0;
        v28->__r_.__value_.__r.__words[2] = 0;
        v28->__r_.__value_.__r.__words[0] = 0;
        uint64_t v30 = std::string::append(&__p, "'");
        long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
        std::string::size_type v35 = v30->__r_.__value_.__r.__words[2];
        *(_OWORD *)char v34 = v31;
        v30->__r_.__value_.__l.__size_ = 0;
        v30->__r_.__value_.__r.__words[2] = 0;
        v30->__r_.__value_.__r.__words[0] = 0;
        sub_10011FB80(406, (uint64_t)v34, &v36);
        uint64_t v17 = sub_10011DD9C((uint64_t)a2, v27, (uint64_t)&v38, (uint64_t)&v36);
        sub_10011FCC4(&v36);
        if (SHIBYTE(v35) < 0) {
          operator delete(v34[0]);
        }
        goto LABEL_48;
      case 8:
        if (!sub_10011F820((uint64_t)a2, 0xFFFFFFFFFFFFFFFFLL)) {
          goto LABEL_54;
        }
        int v6 = sub_10011C088(v5);
        *(_DWORD *)(a1 + 32) = v6;
        if (v6 == 10)
        {
          char v7 = sub_10011FA78((uint64_t)a2);
          goto LABEL_13;
        }
        LOBYTE(v36.__vftable) = 1;
        sub_100038CA4((uint64_t)&v39, &v36);
        continue;
      case 9:
        if ((sub_10011F2B0((uint64_t)a2, 0xFFFFFFFFFFFFFFFFLL) & 1) == 0) {
          goto LABEL_54;
        }
        int v8 = sub_10011C088(v5);
        *(_DWORD *)(a1 + 32) = v8;
        if (v8 != 11)
        {
          if (v8 != 4) {
            goto LABEL_57;
          }
          if (!sub_10011F6E8((uint64_t)a2, v4)) {
            goto LABEL_54;
          }
          int v16 = sub_10011C088(v5);
          *(_DWORD *)(a1 + 32) = v16;
          if (v16 != 12) {
            goto LABEL_58;
          }
          LOBYTE(v36.__vftable) = 0;
          sub_100038CA4((uint64_t)&v39, &v36);
          int v15 = sub_10011C088(v5);
LABEL_35:
          *(_DWORD *)(a1 + 32) = v15;
          continue;
        }
        char v7 = sub_10011F508((uint64_t)a2);
LABEL_13:
        if ((v7 & 1) == 0)
        {
LABEL_54:
          uint64_t v17 = 0;
          goto LABEL_42;
        }
LABEL_19:
        uint64_t v9 = v40;
        if (!v40)
        {
LABEL_41:
          uint64_t v17 = 1;
          goto LABEL_42;
        }
        while (2)
        {
          if ((*(void *)&v39[((unint64_t)(v9 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (v9 - 1)))
          {
            int v10 = sub_10011C088(v5);
            *(_DWORD *)(a1 + 32) = v10;
            if (v10 == 13) {
              goto LABEL_34;
            }
            if (v10 != 10)
            {
              uint64_t v22 = *(void *)(a1 + 64);
              sub_10011DF14(v5, &v38);
              *(_OWORD *)char v34 = *(_OWORD *)(a1 + 64);
              std::string::size_type v35 = *(void *)(a1 + 80);
              sub_100018888(&v32, "array");
              sub_10011E28C(a1, 0xAu, (uint64_t)&v32, &__p);
              sub_10011DFF8(101, (uint64_t *)v34, (uint64_t)&__p, &v36);
              uint64_t v23 = sub_10011DD9C((uint64_t)a2, v22, (uint64_t)&v38, (uint64_t)&v36);
              goto LABEL_59;
            }
            char v11 = sub_10011FA78((uint64_t)a2);
LABEL_27:
            if ((v11 & 1) == 0) {
              goto LABEL_54;
            }
            uint64_t v9 = v40 - 1;
            uint64_t v40 = v9;
            if (!v9) {
              goto LABEL_41;
            }
            continue;
          }
          break;
        }
        int v12 = sub_10011C088(v5);
        *(_DWORD *)(a1 + 32) = v12;
        if (v12 != 13)
        {
          if (v12 != 11)
          {
            uint64_t v24 = *(void *)(a1 + 64);
            sub_10011DF14(v5, &v38);
            *(_OWORD *)char v34 = *(_OWORD *)(a1 + 64);
            std::string::size_type v35 = *(void *)(a1 + 80);
            sub_100018888(&v32, "object");
            sub_10011E28C(a1, 0xBu, (uint64_t)&v32, &__p);
            sub_10011DFF8(101, (uint64_t *)v34, (uint64_t)&__p, &v36);
            uint64_t v23 = sub_10011DD9C((uint64_t)a2, v24, (uint64_t)&v38, (uint64_t)&v36);
            goto LABEL_59;
          }
          char v11 = sub_10011F508((uint64_t)a2);
          goto LABEL_27;
        }
        int v13 = sub_10011C088(v5);
        *(_DWORD *)(a1 + 32) = v13;
        if (v13 != 4)
        {
LABEL_57:
          uint64_t v25 = *(void *)(a1 + 64);
          sub_10011DF14(v5, &v38);
          *(_OWORD *)char v34 = *(_OWORD *)(a1 + 64);
          std::string::size_type v35 = *(void *)(a1 + 80);
          sub_100018888(&v32, "object key");
          sub_10011E28C(a1, 4u, (uint64_t)&v32, &__p);
          sub_10011DFF8(101, (uint64_t *)v34, (uint64_t)&__p, &v36);
          uint64_t v23 = sub_10011DD9C((uint64_t)a2, v25, (uint64_t)&v38, (uint64_t)&v36);
          goto LABEL_59;
        }
        if (!sub_10011F6E8((uint64_t)a2, v4)) {
          goto LABEL_54;
        }
        int v14 = sub_10011C088(v5);
        *(_DWORD *)(a1 + 32) = v14;
        if (v14 == 12)
        {
LABEL_34:
          int v15 = sub_10011C088(v5);
          goto LABEL_35;
        }
LABEL_58:
        uint64_t v26 = *(void *)(a1 + 64);
        sub_10011DF14(v5, &v38);
        *(_OWORD *)char v34 = *(_OWORD *)(a1 + 64);
        std::string::size_type v35 = *(void *)(a1 + 80);
        sub_100018888(&v32, "object separator");
        sub_10011E28C(a1, 0xCu, (uint64_t)&v32, &__p);
        sub_10011DFF8(101, (uint64_t *)v34, (uint64_t)&__p, &v36);
        uint64_t v23 = sub_10011DD9C((uint64_t)a2, v26, (uint64_t)&v38, (uint64_t)&v36);
LABEL_59:
        uint64_t v17 = v23;
        sub_10011E698(&v36);
LABEL_48:
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v32.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v38.__r_.__value_.__l.__data_);
        }
LABEL_42:
        if (v39) {
          operator delete(v39);
        }
        return v17;
      case 0xE:
        uint64_t v19 = *(void *)(a1 + 64);
        sub_10011DF14(v5, &v38);
        *(_OWORD *)char v34 = *(_OWORD *)(a1 + 64);
        std::string::size_type v35 = *(void *)(a1 + 80);
        sub_100018888(&v32, "value");
        sub_10011E28C(a1, 0, (uint64_t)&v32, &__p);
        sub_10011DFF8(101, (uint64_t *)v34, (uint64_t)&__p, &v36);
        uint64_t v20 = sub_10011DD9C((uint64_t)a2, v19, (uint64_t)&v38, (uint64_t)&v36);
        goto LABEL_47;
      default:
        uint64_t v21 = *(void *)(a1 + 64);
        sub_10011DF14(v5, &v38);
        *(_OWORD *)char v34 = *(_OWORD *)(a1 + 64);
        std::string::size_type v35 = *(void *)(a1 + 80);
        sub_100018888(&v32, "value");
        sub_10011E28C(a1, 0x10u, (uint64_t)&v32, &__p);
        sub_10011DFF8(101, (uint64_t *)v34, (uint64_t)&__p, &v36);
        uint64_t v20 = sub_10011DD9C((uint64_t)a2, v21, (uint64_t)&v38, (uint64_t)&v36);
LABEL_47:
        uint64_t v17 = v20;
        v36.__vftable = (std::runtime_error_vtbl *)off_1001B9538;
        std::runtime_error::~runtime_error(&v37);
        std::exception::~exception(&v36);
        goto LABEL_48;
    }
  }
}

void sub_10011DC1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,std::runtime_error a29)
{
  sub_10011E698(&a29);
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (*(char *)(v29 - 73) < 0) {
    operator delete(*(void **)(v29 - 96));
  }
  long long v31 = *(void **)(v29 - 72);
  if (v31) {
    operator delete(v31);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10011DD9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)(a1 + 88) = 1;
  if (*(unsigned char *)(a1 + 128) && !(!v5 & v4))
  {
    switch(~(100 * (*(_DWORD *)(a4 + 8) / 100 / 100)) + *(_DWORD *)(a4 + 8) / 100)
    {
      case 0:
        exceptiouint64_t n = __cxa_allocate_exception(0x28uLL);
        int v8 = (void *)sub_1001217C0((uint64_t)exception, a4);
        int v10 = (void (*)(void *))sub_10011E698;
        break;
      case 1:
        char v11 = __cxa_allocate_exception(0x20uLL);
        int v8 = (void *)sub_1001218AC((uint64_t)v11, a4);
        int v10 = (void (*)(void *))sub_100119328;
        break;
      case 2:
        int v12 = __cxa_allocate_exception(0x20uLL);
        int v8 = (void *)sub_10012191C((uint64_t)v12, a4);
        int v10 = (void (*)(void *))sub_1000985C8;
        break;
      case 3:
        int v13 = __cxa_allocate_exception(0x20uLL);
        int v8 = (void *)sub_10012183C((uint64_t)v13, a4);
        int v10 = (void (*)(void *))sub_10011FCC4;
        break;
      case 4:
        int v14 = __cxa_allocate_exception(0x20uLL);
        int v8 = (void *)sub_10012198C((uint64_t)v14, a4);
        int v10 = (void (*)(void *))sub_10011B97C;
        break;
      default:
        JUMPOUT(0);
    }
    __cxa_throw(v8, v9, v10);
  }
  return 0;
}

void sub_10011DF14(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  uint64_t v3 = *(unsigned __int8 **)(a1 + 48);
  for (uint64_t i = *(unsigned __int8 **)(a1 + 56); v3 != i; ++v3)
  {
    unsigned int v5 = *v3;
    if (v5 > 0x1F)
    {
      std::string::push_back(a2, v5);
    }
    else
    {
      char v7 = 0;
      *(void *)std::string __str = 0;
      snprintf(__str, 9uLL, "<U+%.4X>", v5);
      std::string::append(a2, __str);
    }
  }
}

void sub_10011DFD8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10011DFF8(int a1@<W0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  sub_100018888(&v24, "parse_error");
  sub_10009861C(a1, &v26);
  int v8 = std::string::append(&v26, "parse error");
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v27.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v27.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  sub_100121A64((uint64_t)a2, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  int v12 = std::string::append(&v27, (const std::string::value_type *)p_p, size);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v28.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  int v14 = std::string::append(&v28, ": ");
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v29.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  int v16 = *(char *)(a3 + 23);
  if (v16 >= 0) {
    uint64_t v17 = (const std::string::value_type *)a3;
  }
  else {
    uint64_t v17 = *(const std::string::value_type **)a3;
  }
  if (v16 >= 0) {
    std::string::size_type v18 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    std::string::size_type v18 = *(void *)(a3 + 8);
  }
  uint64_t v19 = std::string::append(&v29, v17, v18);
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  int64_t v31 = v19->__r_.__value_.__r.__words[2];
  long long v30 = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v28.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v27.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (v25 < 0) {
    operator delete(v24);
  }
  uint64_t v21 = *a2;
  if (v31 >= 0) {
    uint64_t v22 = (char *)&v30;
  }
  else {
    uint64_t v22 = (char *)v30;
  }
  sub_1000987A0((uint64_t)a4, a1, v22);
  *a4 = off_1001BE150;
  a4[4] = v21;
  if (SHIBYTE(v31) < 0) {
    operator delete((void *)v30);
  }
}

void sub_10011E1E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (*(char *)(v40 - 57) < 0) {
    operator delete(*(void **)(v40 - 80));
  }
  _Unwind_Resume(exception_object);
}

void sub_10011E28C(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  sub_100018888(a4, "syntax error ");
  uint64_t v8 = *(unsigned __int8 *)(a3 + 23);
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(a3 + 8);
  }
  if (v8)
  {
    std::operator+<char>();
    long long v9 = std::string::append(&v38, " ");
    long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    int64_t v40 = v9->__r_.__value_.__r.__words[2];
    long long v39 = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    if (v40 >= 0) {
      char v11 = (const std::string::value_type *)&v39;
    }
    else {
      char v11 = (const std::string::value_type *)v39;
    }
    if (v40 >= 0) {
      std::string::size_type v12 = HIBYTE(v40);
    }
    else {
      std::string::size_type v12 = *((void *)&v39 + 1);
    }
    std::string::append(a4, v11, v12);
    if (SHIBYTE(v40) < 0) {
      operator delete((void *)v39);
    }
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v38.__r_.__value_.__l.__data_);
    }
  }
  std::string::append(a4, "- ");
  unsigned int v13 = *(_DWORD *)(a1 + 32);
  if (v13 == 14)
  {
    sub_100018888(&v36, *(char **)(a1 + 136));
    int v14 = std::string::append(&v36, "; last read: '");
    long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v37.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v37.__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    sub_10011DF14(a1 + 40, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    std::string::size_type v18 = std::string::append(&v37, (const std::string::value_type *)p_p, size);
    long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v38.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    long long v20 = std::string::append(&v38, "'");
    long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    int64_t v40 = v20->__r_.__value_.__r.__words[2];
    long long v39 = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    if (v40 >= 0) {
      uint64_t v22 = (const std::string::value_type *)&v39;
    }
    else {
      uint64_t v22 = (const std::string::value_type *)v39;
    }
    if (v40 >= 0) {
      std::string::size_type v23 = HIBYTE(v40);
    }
    else {
      std::string::size_type v23 = *((void *)&v39 + 1);
    }
    std::string::append(a4, v22, v23);
    if (SHIBYTE(v40) < 0) {
      operator delete((void *)v39);
    }
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v38.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v37.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v24 = (void *)v36.__r_.__value_.__r.__words[0];
      goto LABEL_49;
    }
LABEL_46:
    if (!a2) {
      return;
    }
    goto LABEL_50;
  }
  char v25 = (char *)sub_100121BE0(v13);
  sub_100018888(&v38, v25);
  std::string v26 = std::string::insert(&v38, 0, "unexpected ");
  long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  int64_t v40 = v26->__r_.__value_.__r.__words[2];
  long long v39 = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  if (v40 >= 0) {
    std::string v28 = (const std::string::value_type *)&v39;
  }
  else {
    std::string v28 = (const std::string::value_type *)v39;
  }
  if (v40 >= 0) {
    std::string::size_type v29 = HIBYTE(v40);
  }
  else {
    std::string::size_type v29 = *((void *)&v39 + 1);
  }
  std::string::append(a4, v28, v29);
  if (SHIBYTE(v40) < 0) {
    operator delete((void *)v39);
  }
  if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_46;
  }
  uint64_t v24 = (void *)v38.__r_.__value_.__r.__words[0];
LABEL_49:
  operator delete(v24);
  if (!a2) {
    return;
  }
LABEL_50:
  long long v30 = (char *)sub_100121BE0(a2);
  sub_100018888(&v38, v30);
  int64_t v31 = std::string::insert(&v38, 0, "; expected ");
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  int64_t v40 = v31->__r_.__value_.__r.__words[2];
  long long v39 = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  if (v40 >= 0) {
    long long v33 = (const std::string::value_type *)&v39;
  }
  else {
    long long v33 = (const std::string::value_type *)v39;
  }
  if (v40 >= 0) {
    std::string::size_type v34 = HIBYTE(v40);
  }
  else {
    std::string::size_type v34 = *((void *)&v39 + 1);
  }
  std::string::append(a4, v33, v34);
  if (SHIBYTE(v40) < 0) {
    operator delete((void *)v39);
  }
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
}

void sub_10011E5B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (*(char *)(v34 - 41) < 0) {
    operator delete(*(void **)(v34 - 64));
  }
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (*(char *)(v33 + 23) < 0) {
    operator delete(*(void **)v33);
  }
  _Unwind_Resume(exception_object);
}

void sub_10011E698(std::runtime_error *a1)
{
  a1->__vftable = (std::runtime_error_vtbl *)off_1001B9538;
  std::runtime_error::~runtime_error(a1 + 1);

  std::exception::~exception(a1);
}

uint64_t sub_10011E6EC(uint64_t a1, uint64_t a2)
{
  long long v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  char v4 = (std::runtime_error_vtbl *)(a1 + 112);
  uint64_t v5 = a1 + 40;
  while (2)
  {
    switch(*(_DWORD *)(a1 + 32))
    {
      case 1:
        LOBYTE(v36.__vftable) = 1;
        sub_10012248C((unsigned __int8 **)a2, (unsigned __int8 *)&v36);
        goto LABEL_17;
      case 2:
        LOBYTE(v36.__vftable) = 0;
        sub_10012248C((unsigned __int8 **)a2, (unsigned __int8 *)&v36);
        goto LABEL_17;
      case 3:
        v36.__vftable = 0;
        sub_100122668((unsigned __int8 **)a2);
        goto LABEL_17;
      case 4:
        sub_1001229C8((unsigned __int8 **)a2, (uint64_t)v4);
        goto LABEL_17;
      case 5:
        v36.__vftable = *(std::runtime_error_vtbl **)(a1 + 152);
        sub_100122BE4((unsigned __int8 **)a2, (uint64_t *)&v36);
        goto LABEL_17;
      case 6:
        v36.__vftable = *(std::runtime_error_vtbl **)(a1 + 144);
        sub_1001227EC((unsigned __int8 **)a2, (uint64_t *)&v36);
        goto LABEL_17;
      case 7:
        if ((*(void *)(a1 + 160) & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
        {
          v36.__vftable = *(std::runtime_error_vtbl **)(a1 + 160);
          sub_1001222B0((unsigned __int8 **)a2, (uint64_t *)&v36);
          goto LABEL_17;
        }
        uint64_t v27 = *(void *)(a1 + 64);
        sub_10011DF14(v5, &v38);
        sub_10011DF14(v5, &v32);
        std::string v28 = std::string::insert(&v32, 0, "number overflow parsing '");
        long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v29;
        v28->__r_.__value_.__l.__size_ = 0;
        v28->__r_.__value_.__r.__words[2] = 0;
        v28->__r_.__value_.__r.__words[0] = 0;
        long long v30 = std::string::append(&__p, "'");
        long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
        std::string::size_type v35 = v30->__r_.__value_.__r.__words[2];
        *(_OWORD *)uint64_t v34 = v31;
        v30->__r_.__value_.__l.__size_ = 0;
        v30->__r_.__value_.__r.__words[2] = 0;
        v30->__r_.__value_.__r.__words[0] = 0;
        sub_10011FB80(406, (uint64_t)v34, &v36);
        uint64_t v17 = sub_10011F044(a2, v27, (uint64_t)&v38, (uint64_t)&v36);
        sub_10011FCC4(&v36);
        if (SHIBYTE(v35) < 0) {
          operator delete(v34[0]);
        }
        goto LABEL_41;
      case 8:
        if (!sub_100121E80(a2, 0xFFFFFFFFFFFFFFFFLL)) {
          goto LABEL_51;
        }
        int v6 = sub_10011C088(v5);
        *(_DWORD *)(a1 + 32) = v6;
        if (v6 == 10) {
          goto LABEL_12;
        }
        LOBYTE(v36.__vftable) = 1;
        sub_100038CA4((uint64_t)&v39, &v36);
        continue;
      case 9:
        if ((sub_100121C64(a2, 0xFFFFFFFFFFFFFFFFLL) & 1) == 0)
        {
LABEL_51:
          uint64_t v17 = 0;
          goto LABEL_35;
        }
        int v7 = sub_10011C088(v5);
        *(_DWORD *)(a1 + 32) = v7;
        if (v7 != 11)
        {
          if (v7 != 4) {
            goto LABEL_48;
          }
          long long v15 = *(uint64_t ***)(*(void *)(*(void *)(a2 + 16) - 8) + 8);
          v36.__vftable = v4;
          *(void *)(a2 + 32) = sub_10012068C(v15, (const void **)&v4->~runtime_error, (uint64_t)&unk_1001793E0, (long long **)&v36)+ 7;
          int v16 = sub_10011C088(v5);
          *(_DWORD *)(a1 + 32) = v16;
          if (v16 != 12) {
            goto LABEL_49;
          }
          LOBYTE(v36.__vftable) = 0;
          sub_100038CA4((uint64_t)&v39, &v36);
          int v14 = sub_10011C088(v5);
LABEL_30:
          *(_DWORD *)(a1 + 32) = v14;
          continue;
        }
LABEL_12:
        *(void *)(a2 + 16) -= 8;
LABEL_17:
        uint64_t v8 = v40;
        if (!v40)
        {
LABEL_34:
          uint64_t v17 = 1;
          goto LABEL_35;
        }
        while (2)
        {
          if ((*(void *)&v39[((unint64_t)(v8 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (v8 - 1)))
          {
            int v9 = sub_10011C088(v5);
            *(_DWORD *)(a1 + 32) = v9;
            if (v9 == 13) {
              goto LABEL_29;
            }
            if (v9 != 10)
            {
              uint64_t v22 = *(void *)(a1 + 64);
              sub_10011DF14(v5, &v38);
              *(_OWORD *)uint64_t v34 = *(_OWORD *)(a1 + 64);
              std::string::size_type v35 = *(void *)(a1 + 80);
              sub_100018888(&v32, "array");
              sub_10011E28C(a1, 0xAu, (uint64_t)&v32, &__p);
              sub_10011DFF8(101, (uint64_t *)v34, (uint64_t)&__p, &v36);
              uint64_t v23 = sub_10011F044(a2, v22, (uint64_t)&v38, (uint64_t)&v36);
              goto LABEL_50;
            }
LABEL_24:
            *(void *)(a2 + 16) -= 8;
            uint64_t v8 = v40 - 1;
            uint64_t v40 = v8;
            if (!v8) {
              goto LABEL_34;
            }
            continue;
          }
          break;
        }
        int v10 = sub_10011C088(v5);
        *(_DWORD *)(a1 + 32) = v10;
        if (v10 != 13)
        {
          if (v10 != 11)
          {
            uint64_t v24 = *(void *)(a1 + 64);
            sub_10011DF14(v5, &v38);
            *(_OWORD *)uint64_t v34 = *(_OWORD *)(a1 + 64);
            std::string::size_type v35 = *(void *)(a1 + 80);
            sub_100018888(&v32, "object");
            sub_10011E28C(a1, 0xBu, (uint64_t)&v32, &__p);
            sub_10011DFF8(101, (uint64_t *)v34, (uint64_t)&__p, &v36);
            uint64_t v23 = sub_10011F044(a2, v24, (uint64_t)&v38, (uint64_t)&v36);
            goto LABEL_50;
          }
          goto LABEL_24;
        }
        int v11 = sub_10011C088(v5);
        *(_DWORD *)(a1 + 32) = v11;
        if (v11 != 4)
        {
LABEL_48:
          uint64_t v25 = *(void *)(a1 + 64);
          sub_10011DF14(v5, &v38);
          *(_OWORD *)uint64_t v34 = *(_OWORD *)(a1 + 64);
          std::string::size_type v35 = *(void *)(a1 + 80);
          sub_100018888(&v32, "object key");
          sub_10011E28C(a1, 4u, (uint64_t)&v32, &__p);
          sub_10011DFF8(101, (uint64_t *)v34, (uint64_t)&__p, &v36);
          uint64_t v23 = sub_10011F044(a2, v25, (uint64_t)&v38, (uint64_t)&v36);
          goto LABEL_50;
        }
        std::string::size_type v12 = *(uint64_t ***)(*(void *)(*(void *)(a2 + 16) - 8) + 8);
        v36.__vftable = v4;
        *(void *)(a2 + 32) = sub_10012068C(v12, (const void **)&v4->~runtime_error, (uint64_t)&unk_1001793E0, (long long **)&v36)+ 7;
        int v13 = sub_10011C088(v5);
        *(_DWORD *)(a1 + 32) = v13;
        if (v13 == 12)
        {
LABEL_29:
          int v14 = sub_10011C088(v5);
          goto LABEL_30;
        }
LABEL_49:
        uint64_t v26 = *(void *)(a1 + 64);
        sub_10011DF14(v5, &v38);
        *(_OWORD *)uint64_t v34 = *(_OWORD *)(a1 + 64);
        std::string::size_type v35 = *(void *)(a1 + 80);
        sub_100018888(&v32, "object separator");
        sub_10011E28C(a1, 0xCu, (uint64_t)&v32, &__p);
        sub_10011DFF8(101, (uint64_t *)v34, (uint64_t)&__p, &v36);
        uint64_t v23 = sub_10011F044(a2, v26, (uint64_t)&v38, (uint64_t)&v36);
LABEL_50:
        uint64_t v17 = v23;
        sub_10011E698(&v36);
LABEL_41:
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v32.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v38.__r_.__value_.__l.__data_);
        }
LABEL_35:
        if (v39) {
          operator delete(v39);
        }
        return v17;
      case 0xE:
        uint64_t v19 = *(void *)(a1 + 64);
        sub_10011DF14(v5, &v38);
        *(_OWORD *)uint64_t v34 = *(_OWORD *)(a1 + 64);
        std::string::size_type v35 = *(void *)(a1 + 80);
        sub_100018888(&v32, "value");
        sub_10011E28C(a1, 0, (uint64_t)&v32, &__p);
        sub_10011DFF8(101, (uint64_t *)v34, (uint64_t)&__p, &v36);
        uint64_t v20 = sub_10011F044(a2, v19, (uint64_t)&v38, (uint64_t)&v36);
        goto LABEL_40;
      default:
        uint64_t v21 = *(void *)(a1 + 64);
        sub_10011DF14(v5, &v38);
        *(_OWORD *)uint64_t v34 = *(_OWORD *)(a1 + 64);
        std::string::size_type v35 = *(void *)(a1 + 80);
        sub_100018888(&v32, "value");
        sub_10011E28C(a1, 0x10u, (uint64_t)&v32, &__p);
        sub_10011DFF8(101, (uint64_t *)v34, (uint64_t)&__p, &v36);
        uint64_t v20 = sub_10011F044(a2, v21, (uint64_t)&v38, (uint64_t)&v36);
LABEL_40:
        uint64_t v17 = v20;
        v36.__vftable = (std::runtime_error_vtbl *)off_1001B9538;
        std::runtime_error::~runtime_error(&v37);
        std::exception::~exception(&v36);
        goto LABEL_41;
    }
  }
}

void sub_10011EEC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,std::runtime_error a29)
{
  sub_10011E698(&a29);
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (*(char *)(v29 - 89) < 0) {
    operator delete(*(void **)(v29 - 112));
  }
  long long v31 = *(void **)(v29 - 88);
  if (v31) {
    operator delete(v31);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10011F044(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)(a1 + 40) = 1;
  if (*(unsigned char *)(a1 + 41) && !(!v5 & v4))
  {
    switch(~(100 * (*(_DWORD *)(a4 + 8) / 100 / 100)) + *(_DWORD *)(a4 + 8) / 100)
    {
      case 0:
        exceptiouint64_t n = __cxa_allocate_exception(0x28uLL);
        uint64_t v8 = (void *)sub_1001217C0((uint64_t)exception, a4);
        int v10 = (void (*)(void *))sub_10011E698;
        break;
      case 1:
        int v11 = __cxa_allocate_exception(0x20uLL);
        uint64_t v8 = (void *)sub_1001218AC((uint64_t)v11, a4);
        int v10 = (void (*)(void *))sub_100119328;
        break;
      case 2:
        std::string::size_type v12 = __cxa_allocate_exception(0x20uLL);
        uint64_t v8 = (void *)sub_10012191C((uint64_t)v12, a4);
        int v10 = (void (*)(void *))sub_1000985C8;
        break;
      case 3:
        int v13 = __cxa_allocate_exception(0x20uLL);
        uint64_t v8 = (void *)sub_10012183C((uint64_t)v13, a4);
        int v10 = (void (*)(void *))sub_10011FCC4;
        break;
      case 4:
        int v14 = __cxa_allocate_exception(0x20uLL);
        uint64_t v8 = (void *)sub_10012198C((uint64_t)v14, a4);
        int v10 = (void (*)(void *))sub_10011B97C;
        break;
      default:
        JUMPOUT(0);
    }
    __cxa_throw(v8, v9, v10);
  }
  return 0;
}

uint64_t sub_10011F1BC(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  *(void *)a1 = a2;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  uint64_t v6 = a1 + 32;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(unsigned char *)(a1 + 88) = 0;
  sub_10011D3C4(a1 + 96, a3);
  *(void *)(a1 + 144) = 0;
  *(unsigned char *)(a1 + 128) = a4;
  *(unsigned char *)(a1 + 136) = 9;
  char v8 = 1;
  sub_100038CA4(v6, &v8);
  return a1;
}

void sub_10011F25C(_Unwind_Exception *a1)
{
  uint64_t v6 = v3;
  sub_100118400(v4, *(unsigned __int8 *)(v1 + 136));
  sub_10011837C(v6);
  char v8 = *(void **)(v1 + 56);
  if (v8) {
    operator delete(v8);
  }
  if (*v2) {
    operator delete(*v2);
  }
  int v9 = *v5;
  if (*v5)
  {
    *(void *)(v1 + 16) = v9;
    operator delete(v9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10011F2B0(uint64_t a1, unint64_t a2)
{
  char v4 = (char **)(a1 + 8);
  char v30 = sub_10011FD18(a1 + 96, (*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3, 0);
  sub_100038CA4(a1 + 32, &v30);
  LOBYTE(v28) = 1;
  sub_10011FD74((unsigned __int8 **)a1, (unsigned __int8 *)&v28, 1);
  uint64_t v6 = v5;
  int v7 = *(void **)(a1 + 16);
  unint64_t v8 = *(void *)(a1 + 24);
  if ((unint64_t)v7 >= v8)
  {
    uint64_t v10 = ((char *)v7 - *v4) >> 3;
    if ((unint64_t)(v10 + 1) >> 61) {
      sub_10002B5E0();
    }
    uint64_t v11 = v8 - (void)*v4;
    uint64_t v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    if (v13) {
      int v14 = (char *)sub_100038500(a1 + 24, v13);
    }
    else {
      int v14 = 0;
    }
    long long v15 = &v14[8 * v10];
    int v16 = &v14[8 * v13];
    *(void *)long long v15 = v6;
    int v9 = v15 + 8;
    std::string::size_type v18 = *(char **)(a1 + 8);
    uint64_t v17 = *(char **)(a1 + 16);
    if (v17 != v18)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v15 - 1) = v19;
        v15 -= 8;
      }
      while (v17 != v18);
      uint64_t v17 = *v4;
    }
    *(void *)(a1 + 8) = v15;
    *(void *)(a1 + 16) = v9;
    *(void *)(a1 + 24) = v16;
    if (v17) {
      operator delete(v17);
    }
  }
  else
  {
    void *v7 = v5;
    int v9 = v7 + 1;
  }
  *(void *)(a1 + 16) = v9;
  if (a2 != -1)
  {
    uint64_t v20 = (char *)*(v9 - 1);
    if (v20)
    {
      unint64_t v21 = *v20;
      if (v21 > 2) {
        unint64_t v22 = 1;
      }
      else {
        unint64_t v22 = qword_10017B8C8[v21];
      }
      if (v22 < a2)
      {
        exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
        std::to_string(&v27, a2);
        uint64_t v25 = std::string::insert(&v27, 0, "excessive object size: ");
        long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
        std::string::size_type v29 = v25->__r_.__value_.__r.__words[2];
        long long v28 = v26;
        v25->__r_.__value_.__l.__size_ = 0;
        v25->__r_.__value_.__r.__words[2] = 0;
        v25->__r_.__value_.__r.__words[0] = 0;
        sub_10011FB80(408, (uint64_t)&v28, exception);
      }
    }
  }
  return 1;
}

void sub_10011F4A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t sub_10011F508(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (*(void *)(v2 - 8)
    && (sub_10011FD18(a1 + 96, ((unint64_t)(v2 - *(void *)(a1 + 8)) >> 3) - 1, 1) & 1) == 0)
  {
    sub_10012365C((uint64_t)v26, (const void ****)(a1 + 136));
    uint64_t v3 = *(unsigned __int8 **)(*(void *)(a1 + 16) - 8);
    int v4 = *v3;
    unsigned __int8 *v3 = v26[0];
    v26[0] = v4;
    uint64_t v5 = (char **)*((void *)v3 + 1);
    *((void *)v3 + 1) = v27;
    std::string v27 = v5;
    sub_100118400(&v27, v4);
  }
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v8 = v6 - 8;
  *(void *)(a1 + 16) = v6 - 8;
  --*(void *)(a1 + 40);
  if (v7 != v6 - 8)
  {
    int v9 = *(unsigned __int8 **)(v6 - 16);
    if (v9)
    {
      int v10 = *v9;
      if ((v10 - 1) <= 1)
      {
        uint64_t v23 = *(unsigned __int8 **)(v6 - 16);
        long long v24 = 0uLL;
        *(void *)&long long v25 = 0;
        *((void *)&v25 + 1) = 0x8000000000000000;
        if (v10 == 2)
        {
          *((void *)&v24 + 1) = **((void **)v9 + 1);
        }
        else if (v10 == 1)
        {
          *(void *)&long long v24 = **((void **)v9 + 1);
        }
        else
        {
          *((void *)&v25 + 1) = 0;
        }
        while (1)
        {
          uint64_t v11 = *(unsigned __int8 **)(v8 - 8);
          uint64_t v20 = 0;
          uint64_t v21 = 0;
          uint64_t v19 = 0;
          std::string::size_type v18 = v11;
          unint64_t v22 = 0x8000000000000000;
          int v12 = *v11;
          if (v12 == 2)
          {
            uint64_t v20 = *(void *)(*((void *)v11 + 1) + 8);
          }
          else if (v12 == 1)
          {
            uint64_t v19 = *((void *)v11 + 1) + 8;
          }
          else
          {
            unint64_t v22 = 1;
          }
          if (sub_100120480(&v23, &v18)) {
            break;
          }
          if (*sub_100120000(&v23) == 9)
          {
            unint64_t v13 = *(uint64_t ****)(*(void *)(a1 + 16) - 8);
            long long v15 = v23;
            long long v16 = v24;
            long long v17 = v25;
            sub_1001200F4(v13, &v15, (uint64_t ****)&v18);
            return 1;
          }
          sub_100120410(&v23);
          uint64_t v8 = *(void *)(a1 + 16);
        }
      }
    }
  }
  return 1;
}

uint64_t sub_10011F6E8(uint64_t a1, long long *a2)
{
  unsigned __int8 v12 = 3;
  unint64_t v13 = (char **)sub_100120620((uint64_t)a2);
  char v11 = sub_10011FD18(a1 + 96, (*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3, 4);
  sub_100038CA4(a1 + 56, &v11);
  if (v11 && *(void *)(*(void *)(a1 + 16) - 8))
  {
    sub_10012365C((uint64_t)v9, (const void ****)(a1 + 136));
    int v4 = *(uint64_t ***)(*(void *)(*(void *)(a1 + 16) - 8) + 8);
    int v14 = a2;
    uint64_t v5 = sub_10012068C(v4, (const void **)a2, (uint64_t)&unk_1001793E0, &v14);
    int v6 = *((unsigned __int8 *)v5 + 56);
    v5 += 7;
    *(unsigned char *)uint64_t v5 = v9[0];
    v9[0] = v6;
    uint64_t v7 = (char **)v5[1];
    v5[1] = (uint64_t)v10;
    int v10 = v7;
    *(void *)(a1 + 80) = v5;
    sub_100118400(&v10, v6);
  }
  sub_100118400(&v13, v12);
  return 1;
}

void sub_10011F7F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned __int8 a10, char **a11, uint64_t a12, unsigned __int8 a13)
{
  sub_100118400(&a11, a10);
  sub_100118400(v13, a13);
  _Unwind_Resume(a1);
}

uint64_t sub_10011F820(uint64_t a1, unint64_t a2)
{
  int v4 = (char **)(a1 + 8);
  char v30 = sub_10011FD18(a1 + 96, (*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3, 2);
  sub_100038CA4(a1 + 32, &v30);
  LOBYTE(v28) = 2;
  sub_10011FD74((unsigned __int8 **)a1, (unsigned __int8 *)&v28, 1);
  uint64_t v6 = v5;
  uint64_t v7 = *(void **)(a1 + 16);
  unint64_t v8 = *(void *)(a1 + 24);
  if ((unint64_t)v7 >= v8)
  {
    uint64_t v10 = ((char *)v7 - *v4) >> 3;
    if ((unint64_t)(v10 + 1) >> 61) {
      sub_10002B5E0();
    }
    uint64_t v11 = v8 - (void)*v4;
    uint64_t v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    if (v13) {
      int v14 = (char *)sub_100038500(a1 + 24, v13);
    }
    else {
      int v14 = 0;
    }
    long long v15 = &v14[8 * v10];
    long long v16 = &v14[8 * v13];
    *(void *)long long v15 = v6;
    int v9 = v15 + 8;
    std::string::size_type v18 = *(char **)(a1 + 8);
    long long v17 = *(char **)(a1 + 16);
    if (v17 != v18)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v15 - 1) = v19;
        v15 -= 8;
      }
      while (v17 != v18);
      long long v17 = *v4;
    }
    *(void *)(a1 + 8) = v15;
    *(void *)(a1 + 16) = v9;
    *(void *)(a1 + 24) = v16;
    if (v17) {
      operator delete(v17);
    }
  }
  else
  {
    void *v7 = v5;
    int v9 = v7 + 1;
  }
  *(void *)(a1 + 16) = v9;
  if (a2 != -1)
  {
    uint64_t v20 = (char *)*(v9 - 1);
    if (v20)
    {
      unint64_t v21 = *v20;
      if (v21 > 2) {
        unint64_t v22 = 1;
      }
      else {
        unint64_t v22 = qword_10017B8C8[v21];
      }
      if (v22 < a2)
      {
        exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
        std::to_string(&v27, a2);
        long long v25 = std::string::insert(&v27, 0, "excessive array size: ");
        long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
        std::string::size_type v29 = v25->__r_.__value_.__r.__words[2];
        long long v28 = v26;
        v25->__r_.__value_.__l.__size_ = 0;
        v25->__r_.__value_.__r.__words[2] = 0;
        v25->__r_.__value_.__r.__words[0] = 0;
        sub_10011FB80(408, (uint64_t)&v28, exception);
      }
    }
  }
  return 1;
}

void sub_10011FA18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t sub_10011FA78(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(v2 - 8);
  uint64_t v3 = v2 - 8;
  if (!v4)
  {
    *(void *)(a1 + 16) = v3;
    goto LABEL_5;
  }
  if (sub_10011FD18(a1 + 96, ((*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3) - 1, 3))
  {
    *(void *)(a1 + 16) -= 8;
LABEL_5:
    --*(void *)(a1 + 40);
    return 1;
  }
  sub_10012365C((uint64_t)v15, (const void ****)(a1 + 136));
  uint64_t v6 = *(unsigned __int8 **)(*(void *)(a1 + 16) - 8);
  int v7 = *v6;
  *uint64_t v6 = v15[0];
  v15[0] = v7;
  unint64_t v8 = (char **)*((void *)v6 + 1);
  *((void *)v6 + 1) = v16;
  long long v16 = v8;
  sub_100118400(&v16, v7);
  uint64_t v10 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v9 - 8;
  --*(void *)(a1 + 40);
  if (v10 != v9 - 8)
  {
    uint64_t v11 = *(void *)(v9 - 16);
    if (*(unsigned char *)v11 == 2)
    {
      uint64_t v12 = *(void *)(v11 + 8);
      uint64_t v13 = *(void *)(v12 + 8);
      int v14 = *(unsigned __int8 *)(v13 - 16);
      v13 -= 16;
      sub_100118400((char ***)(v13 + 8), v14);
      *(void *)(v12 + 8) = v13;
    }
  }
  return 1;
}

void sub_10011FB80(int a1@<W0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  sub_100018888(&__p, "out_of_range");
  sub_10009861C(a1, &v14);
  int v6 = *(char *)(a2 + 23);
  if (v6 >= 0) {
    int v7 = (const std::string::value_type *)a2;
  }
  else {
    int v7 = *(const std::string::value_type **)a2;
  }
  if (v6 >= 0) {
    std::string::size_type v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v8 = *(void *)(a2 + 8);
  }
  uint64_t v9 = std::string::append(&v14, v7, v8);
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  int64_t v16 = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long v15 = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  if (v13 < 0) {
    operator delete(__p);
  }
  if (v16 >= 0) {
    uint64_t v11 = (char *)v15;
  }
  else {
    uint64_t v11 = (char *)v15[0];
  }
  sub_1000987A0((uint64_t)a3, a1, v11);
  *a3 = off_1001BE110;
  if (SHIBYTE(v16) < 0) {
    operator delete(v15[0]);
  }
}

void sub_10011FC7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10011FCC4(std::runtime_error *a1)
{
  a1->__vftable = (std::runtime_error_vtbl *)off_1001B9538;
  std::runtime_error::~runtime_error(a1 + 1);

  std::exception::~exception(a1);
}

uint64_t sub_10011FD18(uint64_t a1, int a2, char a3)
{
  int v6 = a2;
  char v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_100029F0C();
  }
  return (*(uint64_t (**)(uint64_t, int *, char *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

uint64_t sub_10011FD74(unsigned __int8 **a1, unsigned __int8 *a2, char a3)
{
  if ((*(void *)&a1[4][((unint64_t)(a1[5] - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (*((unsigned char *)a1 + 40) - 1)))
  {
    int v5 = *a2;
    unsigned __int8 v36 = v5;
    sub_10011B854(&v37, v5);
    if (a3 & 1) != 0 || (sub_10011FD18((uint64_t)(a1 + 12), (unint64_t)(a1[2] - a1[1]) >> 3, 5))
    {
      int v6 = a1[2];
      if (a1[1] == v6)
      {
        unsigned __int8 v13 = v36;
        std::string v14 = v37;
        unsigned __int8 v36 = 0;
        std::runtime_error v37 = 0;
        uint64_t v15 = (uint64_t)*a1;
        int v16 = **a1;
        *(unsigned char *)uint64_t v15 = v13;
        char v34 = v16;
        long long v17 = *(char ***)(v15 + 8);
        *(void *)(v15 + 8) = v14;
        std::string::size_type v35 = v17;
        sub_100118400(&v35, v16);
LABEL_22:
        uint64_t v12 = 1;
        goto LABEL_23;
      }
      uint64_t v7 = *((void *)v6 - 1);
      if (v7)
      {
        if (*(unsigned char *)v7 == 2)
        {
          std::string::size_type v8 = *(uint64_t **)(v7 + 8);
          unint64_t v9 = v8[1];
          unint64_t v10 = v8[2];
          if (v9 >= v10)
          {
            uint64_t v25 = (uint64_t)(v9 - *v8) >> 4;
            unint64_t v26 = v25 + 1;
            if ((unint64_t)(v25 + 1) >> 60) {
              sub_10002B5E0();
            }
            uint64_t v27 = v10 - *v8;
            if (v27 >> 3 > v26) {
              unint64_t v26 = v27 >> 3;
            }
            if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v28 = v26;
            }
            v38[4] = v8 + 2;
            std::string::size_type v29 = (char *)sub_10001E498((uint64_t)(v8 + 2), v28);
            char v30 = &v29[16 * v25];
            v38[0] = v29;
            v38[1] = v30;
            v38[3] = &v29[16 * v31];
            *char v30 = v36;
            *((void *)v30 + 1) = v37;
            unsigned __int8 v36 = 0;
            std::runtime_error v37 = 0;
            v38[2] = v30 + 16;
            sub_10011892C(v8, v38);
            uint64_t v11 = v8[1];
            sub_100118AB8((uint64_t)v38);
          }
          else
          {
            *(unsigned char *)unint64_t v9 = v36;
            *(void *)(v9 + 8) = v37;
            unsigned __int8 v36 = 0;
            std::runtime_error v37 = 0;
            uint64_t v11 = v9 + 16;
            v8[1] = v9 + 16;
          }
          v8[1] = v11;
          goto LABEL_22;
        }
        unint64_t v18 = (unint64_t)(a1[8] - 1);
        unint64_t v19 = *(void *)&a1[7][(v18 >> 3) & 0x1FFFFFFFFFFFFFF8];
        a1[8] = (unsigned __int8 *)v18;
        if ((v19 >> v18))
        {
          unsigned __int8 v20 = v36;
          unint64_t v21 = v37;
          unsigned __int8 v36 = 0;
          std::runtime_error v37 = 0;
          int v22 = a1[10];
          int v23 = *v22;
          unsigned __int8 *v22 = v20;
          long long v24 = (char **)*((void *)v22 + 1);
          *((void *)v22 + 1) = v21;
          uint64_t v33 = v24;
          sub_100118400(&v33, v23);
          goto LABEL_22;
        }
      }
    }
    uint64_t v12 = 0;
LABEL_23:
    sub_100118400(&v37, v36);
    return v12;
  }
  return 0;
}

void sub_10011FFD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100118AB8((uint64_t)va);
  sub_100118400(v8, a7);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_100120000(unsigned __int8 **a1)
{
  uint64_t result = *a1;
  int v3 = *result;
  if (v3 == 2) {
    return a1[2];
  }
  if (v3 == 1) {
    return a1[1] + 56;
  }
  if (a1[4])
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_100018888(v5, "cannot get value");
    sub_1001191E4(214, (uint64_t)v5, exception);
  }
  return result;
}

void sub_1001200BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void sub_1001200F4(uint64_t ***a1@<X0>, unsigned __int8 **a2@<X1>, uint64_t ****a3@<X8>)
{
  if (*a2 != (unsigned __int8 *)a1)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_100018888(&v28, "iterator does not fit current value");
    sub_1001191E4(202, (uint64_t)&v28, exception);
  }
  *a3 = a1;
  a3[1] = 0;
  int v5 = (uint64_t **)(a3 + 1);
  a3[2] = 0;
  a3[3] = 0;
  a3[4] = (uint64_t ***)0x8000000000000000;
  int v6 = *(unsigned __int8 *)a1;
  if (v6 != 2)
  {
    if (v6 == 1)
    {
      uint64_t v7 = (uint64_t *)a2[1];
      std::string::size_type v8 = sub_10002BA08(a1[1], v7);
      sub_100118CC4((uint64_t)(v7 + 4));
      operator delete(v7);
      *int v5 = v8;
      return;
    }
    a3[4] = (uint64_t ***)1;
    if ((v6 - 3) > 5)
    {
      int v23 = __cxa_allocate_exception(0x20uLL);
      long long v24 = (char *)sub_1000985A0((char *)a1);
      sub_100018888(&v27, v24);
      uint64_t v25 = std::string::insert(&v27, 0, "cannot use erase() with ");
      long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      std::string::size_type v29 = v25->__r_.__value_.__r.__words[2];
      long long v28 = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      sub_10009845C(307, (uint64_t)&v28, v23);
    }
    if (a2[4])
    {
      int v22 = __cxa_allocate_exception(0x20uLL);
      sub_100018888(&v28, "iterator out of range");
      sub_1001191E4(205, (uint64_t)&v28, v22);
    }
    if (v6 == 8)
    {
      unint64_t v18 = (void **)(a1 + 1);
      long long v17 = (void **)a1[1];
      unsigned __int8 v20 = *v17;
      if (*v17)
      {
        v17[1] = v20;
        unint64_t v19 = v20;
        goto LABEL_17;
      }
    }
    else
    {
      if (v6 != 3)
      {
LABEL_19:
        *(unsigned char *)a1 = 0;
        return;
      }
      unint64_t v18 = (void **)(a1 + 1);
      long long v17 = (void **)a1[1];
      if (*((char *)v17 + 23) < 0)
      {
        unint64_t v19 = *v17;
LABEL_17:
        operator delete(v19);
        long long v17 = (void **)*v18;
      }
    }
    operator delete(v17);
    *unint64_t v18 = 0;
    goto LABEL_19;
  }
  unint64_t v9 = a1[1];
  unint64_t v10 = (char *)v9[1];
  a3[2] = (uint64_t ***)v10;
  uint64_t v11 = a2[2];
  sub_100120588((uint64_t)&v28, (char *)v11 + 16, v10, v11);
  unsigned __int8 v13 = v12;
  std::string v14 = v9[1];
  if (v14 != (uint64_t *)v12)
  {
    uint64_t v15 = (char ***)(v14 - 1);
    do
    {
      int v16 = v15 - 1;
      sub_100118400(v15, *((unsigned __int8 *)v15 - 8));
      v15 -= 2;
    }
    while (v16 != v13);
  }
  v9[1] = (uint64_t *)v13;
  a3[2] = (uint64_t ***)v11;
}

void sub_100120398(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (v22) {
    __cxa_free_exception(v21);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 **sub_100120410(unsigned __int8 **result)
{
  int v1 = **result;
  if (v1 == 2)
  {
    result[2] += 16;
  }
  else if (v1 == 1)
  {
    uint64_t v2 = result[1];
    int v3 = (unsigned __int8 *)*((void *)v2 + 1);
    if (v3)
    {
      do
      {
        uint64_t v4 = v3;
        int v3 = *(unsigned __int8 **)v3;
      }
      while (v3);
    }
    else
    {
      do
      {
        uint64_t v4 = (unsigned __int8 *)*((void *)v2 + 2);
        BOOL v5 = *(void *)v4 == (void)v2;
        uint64_t v2 = v4;
      }
      while (!v5);
    }
    result[1] = v4;
  }
  else
  {
    ++result[4];
  }
  return result;
}

BOOL sub_100120480(unsigned __int8 **a1, unsigned __int8 **a2)
{
  if (*a1 != *a2)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_100018888(v7, "cannot compare iterators of different containers");
    sub_1001191E4(212, (uint64_t)v7, exception);
  }
  int v2 = **a1;
  if (v2 == 2)
  {
    int v3 = a1[2];
    uint64_t v4 = a2[2];
  }
  else if (v2 == 1)
  {
    int v3 = a1[1];
    uint64_t v4 = a2[1];
  }
  else
  {
    int v3 = a1[4];
    uint64_t v4 = a2[4];
  }
  return v3 == v4;
}

void sub_100120550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

char *sub_100120588(uint64_t a1, char *a2, char *a3, unsigned __int8 *a4)
{
  BOOL v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  int v6 = a3;
  do
  {
    unsigned __int8 v7 = *v5;
    uint64_t v8 = *((void *)v5 + 1);
    *BOOL v5 = 0;
    *((void *)v5 + 1) = 0;
    int v9 = *a4;
    *a4 = v7;
    unint64_t v10 = (char **)*((void *)a4 + 1);
    *((void *)a4 + 1) = v8;
    uint64_t v12 = v10;
    sub_100118400(&v12, v9);
    a4 += 16;
    v5 += 16;
  }
  while (v5 != v6);
  return v6;
}

void *sub_100120620(uint64_t a1)
{
  int v2 = operator new(0x18uLL);
  int v3 = v2;
  if (*(char *)(a1 + 23) < 0)
  {
    sub_1000173FC(v2, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)int v2 = *(_OWORD *)a1;
    v2[2] = *(void *)(a1 + 16);
  }
  return v3;
}

void sub_100120678(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_10012068C(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  int v6 = (uint64_t **)sub_10001893C((uint64_t)a1, &v11, a2);
  unsigned __int8 v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = v6;
    sub_100120738((uint64_t)a1, a4, (uint64_t)v10);
    sub_10001716C(a1, v11, v8, v10[0]);
    unsigned __int8 v7 = v10[0];
    v10[0] = 0;
    sub_1001207D0((uint64_t)v10, 0);
  }
  return v7;
}

unsigned char *sub_100120738@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  int v6 = (char *)operator new(0x48uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = v6 + 32;
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_1000173FC(result, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *(_OWORD *)uint64_t result = v9;
  }
  v6[56] = 0;
  *((void *)v6 + 8) = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1001207B8(_Unwind_Exception *a1)
{
  sub_1001207D0(v1, 0);
  _Unwind_Resume(a1);
}

void sub_1001207D0(uint64_t a1, uint64_t a2)
{
  int v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100118CC4((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void sub_100120828(std::runtime_error *a1)
{
  a1->__vftable = (std::runtime_error_vtbl *)off_1001B9538;
  std::runtime_error::~runtime_error(a1 + 1);
  std::exception::~exception(a1);

  operator delete();
}

uint64_t sub_100120890(unsigned __int8 **a1, char ***a2, char a3)
{
  if ((*(void *)&a1[4][((unint64_t)(a1[5] - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (*((unsigned char *)a1 + 40) - 1)))
  {
    uint64_t v4 = *a2;
    unsigned __int8 v35 = 7;
    unsigned __int8 v36 = v4;
    if (a3 & 1) != 0 || (sub_10011FD18((uint64_t)(a1 + 12), (unint64_t)(a1[2] - a1[1]) >> 3, 5))
    {
      uint64_t v5 = a1[2];
      if (a1[1] == v5)
      {
        unsigned __int8 v12 = v35;
        unsigned __int8 v13 = v36;
        unsigned __int8 v35 = 0;
        unsigned __int8 v36 = 0;
        uint64_t v14 = (uint64_t)*a1;
        int v15 = **a1;
        *(unsigned char *)uint64_t v14 = v12;
        char v33 = v15;
        int v16 = *(char ***)(v14 + 8);
        *(void *)(v14 + 8) = v13;
        char v34 = v16;
        sub_100118400(&v34, v15);
LABEL_22:
        uint64_t v11 = 1;
        goto LABEL_23;
      }
      uint64_t v6 = *((void *)v5 - 1);
      if (v6)
      {
        if (*(unsigned char *)v6 == 2)
        {
          unsigned __int8 v7 = *(uint64_t **)(v6 + 8);
          unint64_t v8 = v7[1];
          unint64_t v9 = v7[2];
          if (v8 >= v9)
          {
            uint64_t v24 = (uint64_t)(v8 - *v7) >> 4;
            unint64_t v25 = v24 + 1;
            if ((unint64_t)(v24 + 1) >> 60) {
              sub_10002B5E0();
            }
            uint64_t v26 = v9 - *v7;
            if (v26 >> 3 > v25) {
              unint64_t v25 = v26 >> 3;
            }
            if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v27 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v27 = v25;
            }
            v37[4] = v7 + 2;
            long long v28 = (char *)sub_10001E498((uint64_t)(v7 + 2), v27);
            std::string::size_type v29 = (unsigned __int8 *)&v28[16 * v24];
            v37[0] = v28;
            v37[1] = v29;
            v37[3] = &v28[16 * v30];
            unsigned __int8 *v29 = v35;
            *((void *)v29 + 1) = v36;
            unsigned __int8 v35 = 0;
            unsigned __int8 v36 = 0;
            v37[2] = v29 + 16;
            sub_10011892C(v7, v37);
            uint64_t v10 = v7[1];
            sub_100118AB8((uint64_t)v37);
          }
          else
          {
            *(unsigned char *)unint64_t v8 = v35;
            *(void *)(v8 + 8) = v36;
            unsigned __int8 v35 = 0;
            unsigned __int8 v36 = 0;
            uint64_t v10 = v8 + 16;
            v7[1] = v8 + 16;
          }
          v7[1] = v10;
          goto LABEL_22;
        }
        unint64_t v17 = (unint64_t)(a1[8] - 1);
        unint64_t v18 = *(void *)&a1[7][(v17 >> 3) & 0x1FFFFFFFFFFFFFF8];
        a1[8] = (unsigned __int8 *)v17;
        if ((v18 >> v17))
        {
          unsigned __int8 v19 = v35;
          unsigned __int8 v20 = v36;
          unsigned __int8 v35 = 0;
          unsigned __int8 v36 = 0;
          unint64_t v21 = a1[10];
          int v22 = *v21;
          *unint64_t v21 = v19;
          int v23 = (char **)*((void *)v21 + 1);
          *((void *)v21 + 1) = v20;
          std::string v32 = v23;
          sub_100118400(&v32, v22);
          goto LABEL_22;
        }
      }
    }
    uint64_t v11 = 0;
LABEL_23:
    sub_100118400(&v36, v35);
    return v11;
  }
  return 0;
}

void sub_100120AF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100118AB8((uint64_t)va);
  sub_100118400(v8, a7);
  _Unwind_Resume(a1);
}

uint64_t sub_100120B18(unsigned __int8 **a1, unsigned __int8 *a2, char a3)
{
  if ((*(void *)&a1[4][((unint64_t)(a1[5] - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (*((unsigned char *)a1 + 40) - 1)))
  {
    uint64_t v4 = (char **)*a2;
    unsigned __int8 v35 = 4;
    unsigned __int8 v36 = v4;
    if (a3 & 1) != 0 || (sub_10011FD18((uint64_t)(a1 + 12), (unint64_t)(a1[2] - a1[1]) >> 3, 5))
    {
      uint64_t v5 = a1[2];
      if (a1[1] == v5)
      {
        unsigned __int8 v12 = v35;
        unsigned __int8 v13 = v36;
        unsigned __int8 v35 = 0;
        unsigned __int8 v36 = 0;
        uint64_t v14 = (uint64_t)*a1;
        int v15 = **a1;
        *(unsigned char *)uint64_t v14 = v12;
        char v33 = v15;
        int v16 = *(char ***)(v14 + 8);
        *(void *)(v14 + 8) = v13;
        char v34 = v16;
        sub_100118400(&v34, v15);
LABEL_22:
        uint64_t v11 = 1;
        goto LABEL_23;
      }
      uint64_t v6 = *((void *)v5 - 1);
      if (v6)
      {
        if (*(unsigned char *)v6 == 2)
        {
          unsigned __int8 v7 = *(uint64_t **)(v6 + 8);
          unint64_t v8 = v7[1];
          unint64_t v9 = v7[2];
          if (v8 >= v9)
          {
            uint64_t v24 = (uint64_t)(v8 - *v7) >> 4;
            unint64_t v25 = v24 + 1;
            if ((unint64_t)(v24 + 1) >> 60) {
              sub_10002B5E0();
            }
            uint64_t v26 = v9 - *v7;
            if (v26 >> 3 > v25) {
              unint64_t v25 = v26 >> 3;
            }
            if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v27 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v27 = v25;
            }
            v37[4] = v7 + 2;
            long long v28 = (char *)sub_10001E498((uint64_t)(v7 + 2), v27);
            std::string::size_type v29 = (unsigned __int8 *)&v28[16 * v24];
            v37[0] = v28;
            v37[1] = v29;
            v37[3] = &v28[16 * v30];
            unsigned __int8 *v29 = v35;
            *((void *)v29 + 1) = v36;
            unsigned __int8 v35 = 0;
            unsigned __int8 v36 = 0;
            v37[2] = v29 + 16;
            sub_10011892C(v7, v37);
            uint64_t v10 = v7[1];
            sub_100118AB8((uint64_t)v37);
          }
          else
          {
            *(unsigned char *)unint64_t v8 = v35;
            *(void *)(v8 + 8) = v36;
            unsigned __int8 v35 = 0;
            unsigned __int8 v36 = 0;
            uint64_t v10 = v8 + 16;
            v7[1] = v8 + 16;
          }
          v7[1] = v10;
          goto LABEL_22;
        }
        unint64_t v17 = (unint64_t)(a1[8] - 1);
        unint64_t v18 = *(void *)&a1[7][(v17 >> 3) & 0x1FFFFFFFFFFFFFF8];
        a1[8] = (unsigned __int8 *)v17;
        if ((v18 >> v17))
        {
          unsigned __int8 v19 = v35;
          unsigned __int8 v20 = v36;
          unsigned __int8 v35 = 0;
          unsigned __int8 v36 = 0;
          unint64_t v21 = a1[10];
          int v22 = *v21;
          *unint64_t v21 = v19;
          int v23 = (char **)*((void *)v21 + 1);
          *((void *)v21 + 1) = v20;
          std::string v32 = v23;
          sub_100118400(&v32, v22);
          goto LABEL_22;
        }
      }
    }
    uint64_t v11 = 0;
LABEL_23:
    sub_100118400(&v36, v35);
    return v11;
  }
  return 0;
}

void sub_100120D78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100118AB8((uint64_t)va);
  sub_100118400(v8, a7);
  _Unwind_Resume(a1);
}

uint64_t sub_100120DA0(unsigned __int8 **a1, uint64_t a2, char a3)
{
  if ((*(void *)&a1[4][((unint64_t)(a1[5] - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (*((unsigned char *)a1 + 40) - 1)))
  {
    unsigned __int8 v34 = 0;
    unsigned __int8 v35 = 0;
    if (a3 & 1) != 0 || (sub_10011FD18((uint64_t)(a1 + 12), (unint64_t)(a1[2] - a1[1]) >> 3, 5))
    {
      uint64_t v4 = a1[2];
      if (a1[1] == v4)
      {
        unsigned __int8 v11 = v34;
        unsigned __int8 v12 = v35;
        unsigned __int8 v34 = 0;
        unsigned __int8 v35 = 0;
        uint64_t v13 = (uint64_t)*a1;
        int v14 = **a1;
        *(unsigned char *)uint64_t v13 = v11;
        char v32 = v14;
        int v15 = *(char ***)(v13 + 8);
        *(void *)(v13 + 8) = v12;
        char v33 = v15;
        sub_100118400(&v33, v14);
LABEL_22:
        uint64_t v10 = 1;
        goto LABEL_23;
      }
      uint64_t v5 = *((void *)v4 - 1);
      if (v5)
      {
        if (*(unsigned char *)v5 == 2)
        {
          uint64_t v6 = *(uint64_t **)(v5 + 8);
          unint64_t v7 = v6[1];
          unint64_t v8 = v6[2];
          if (v7 >= v8)
          {
            uint64_t v23 = (uint64_t)(v7 - *v6) >> 4;
            unint64_t v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 60) {
              sub_10002B5E0();
            }
            uint64_t v25 = v8 - *v6;
            if (v25 >> 3 > v24) {
              unint64_t v24 = v25 >> 3;
            }
            if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v26 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v26 = v24;
            }
            v36[4] = v6 + 2;
            unint64_t v27 = (char *)sub_10001E498((uint64_t)(v6 + 2), v26);
            long long v28 = &v27[16 * v23];
            v36[0] = v27;
            v36[1] = v28;
            v36[3] = &v27[16 * v29];
            char *v28 = v34;
            *((void *)v28 + 1) = v35;
            unsigned __int8 v34 = 0;
            unsigned __int8 v35 = 0;
            v36[2] = v28 + 16;
            sub_10011892C(v6, v36);
            uint64_t v9 = v6[1];
            sub_100118AB8((uint64_t)v36);
          }
          else
          {
            *(unsigned char *)unint64_t v7 = v34;
            *(void *)(v7 + 8) = v35;
            unsigned __int8 v34 = 0;
            unsigned __int8 v35 = 0;
            uint64_t v9 = v7 + 16;
            v6[1] = v7 + 16;
          }
          v6[1] = v9;
          goto LABEL_22;
        }
        unint64_t v16 = (unint64_t)(a1[8] - 1);
        unint64_t v17 = *(void *)&a1[7][(v16 >> 3) & 0x1FFFFFFFFFFFFFF8];
        a1[8] = (unsigned __int8 *)v16;
        if ((v17 >> v16))
        {
          unsigned __int8 v18 = v34;
          unsigned __int8 v19 = v35;
          unsigned __int8 v34 = 0;
          unsigned __int8 v35 = 0;
          unsigned __int8 v20 = a1[10];
          int v21 = *v20;
          unsigned __int8 *v20 = v18;
          int v22 = (char **)*((void *)v20 + 1);
          *((void *)v20 + 1) = v19;
          uint64_t v31 = v22;
          sub_100118400(&v31, v21);
          goto LABEL_22;
        }
      }
    }
    uint64_t v10 = 0;
LABEL_23:
    sub_100118400(&v35, v34);
    return v10;
  }
  return 0;
}

void sub_100120FF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100118AB8((uint64_t)va);
  sub_100118400(v8, a7);
  _Unwind_Resume(a1);
}

uint64_t sub_100121020(unsigned __int8 **a1, char ***a2, char a3)
{
  if ((*(void *)&a1[4][((unint64_t)(a1[5] - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (*((unsigned char *)a1 + 40) - 1)))
  {
    uint64_t v4 = *a2;
    unsigned __int8 v35 = 5;
    unsigned __int8 v36 = v4;
    if (a3 & 1) != 0 || (sub_10011FD18((uint64_t)(a1 + 12), (unint64_t)(a1[2] - a1[1]) >> 3, 5))
    {
      uint64_t v5 = a1[2];
      if (a1[1] == v5)
      {
        unsigned __int8 v12 = v35;
        uint64_t v13 = v36;
        unsigned __int8 v35 = 0;
        unsigned __int8 v36 = 0;
        uint64_t v14 = (uint64_t)*a1;
        int v15 = **a1;
        *(unsigned char *)uint64_t v14 = v12;
        char v33 = v15;
        unint64_t v16 = *(char ***)(v14 + 8);
        *(void *)(v14 + 8) = v13;
        unsigned __int8 v34 = v16;
        sub_100118400(&v34, v15);
LABEL_22:
        uint64_t v11 = 1;
        goto LABEL_23;
      }
      uint64_t v6 = *((void *)v5 - 1);
      if (v6)
      {
        if (*(unsigned char *)v6 == 2)
        {
          unint64_t v7 = *(uint64_t **)(v6 + 8);
          unint64_t v8 = v7[1];
          unint64_t v9 = v7[2];
          if (v8 >= v9)
          {
            uint64_t v24 = (uint64_t)(v8 - *v7) >> 4;
            unint64_t v25 = v24 + 1;
            if ((unint64_t)(v24 + 1) >> 60) {
              sub_10002B5E0();
            }
            uint64_t v26 = v9 - *v7;
            if (v26 >> 3 > v25) {
              unint64_t v25 = v26 >> 3;
            }
            if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v27 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v27 = v25;
            }
            v37[4] = v7 + 2;
            long long v28 = (char *)sub_10001E498((uint64_t)(v7 + 2), v27);
            uint64_t v29 = (unsigned __int8 *)&v28[16 * v24];
            v37[0] = v28;
            v37[1] = v29;
            v37[3] = &v28[16 * v30];
            unsigned __int8 *v29 = v35;
            *((void *)v29 + 1) = v36;
            unsigned __int8 v35 = 0;
            unsigned __int8 v36 = 0;
            v37[2] = v29 + 16;
            sub_10011892C(v7, v37);
            uint64_t v10 = v7[1];
            sub_100118AB8((uint64_t)v37);
          }
          else
          {
            *(unsigned char *)unint64_t v8 = v35;
            *(void *)(v8 + 8) = v36;
            unsigned __int8 v35 = 0;
            unsigned __int8 v36 = 0;
            uint64_t v10 = v8 + 16;
            v7[1] = v8 + 16;
          }
          v7[1] = v10;
          goto LABEL_22;
        }
        unint64_t v17 = (unint64_t)(a1[8] - 1);
        unint64_t v18 = *(void *)&a1[7][(v17 >> 3) & 0x1FFFFFFFFFFFFFF8];
        a1[8] = (unsigned __int8 *)v17;
        if ((v18 >> v17))
        {
          unsigned __int8 v19 = v35;
          unsigned __int8 v20 = v36;
          unsigned __int8 v35 = 0;
          unsigned __int8 v36 = 0;
          int v21 = a1[10];
          int v22 = *v21;
          *int v21 = v19;
          uint64_t v23 = (char **)*((void *)v21 + 1);
          *((void *)v21 + 1) = v20;
          char v32 = v23;
          sub_100118400(&v32, v22);
          goto LABEL_22;
        }
      }
    }
    uint64_t v11 = 0;
LABEL_23:
    sub_100118400(&v36, v35);
    return v11;
  }
  return 0;
}

void sub_100121280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100118AB8((uint64_t)va);
  sub_100118400(v8, a7);
  _Unwind_Resume(a1);
}

uint64_t sub_1001212A8(unsigned __int8 **a1, uint64_t a2, char a3)
{
  if ((*(void *)&a1[4][((unint64_t)(a1[5] - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (*((unsigned char *)a1 + 40) - 1)))
  {
    unsigned __int8 v35 = 3;
    unsigned __int8 v36 = (char **)sub_100120620(a2);
    if (a3 & 1) != 0 || (sub_10011FD18((uint64_t)(a1 + 12), (unint64_t)(a1[2] - a1[1]) >> 3, 5))
    {
      uint64_t v5 = a1[2];
      if (a1[1] == v5)
      {
        unsigned __int8 v12 = v35;
        uint64_t v13 = v36;
        unsigned __int8 v35 = 0;
        unsigned __int8 v36 = 0;
        uint64_t v14 = (uint64_t)*a1;
        int v15 = **a1;
        *(unsigned char *)uint64_t v14 = v12;
        char v33 = v15;
        unint64_t v16 = *(char ***)(v14 + 8);
        *(void *)(v14 + 8) = v13;
        unsigned __int8 v34 = v16;
        sub_100118400(&v34, v15);
LABEL_22:
        uint64_t v11 = 1;
        goto LABEL_23;
      }
      uint64_t v6 = *((void *)v5 - 1);
      if (v6)
      {
        if (*(unsigned char *)v6 == 2)
        {
          unint64_t v7 = *(uint64_t **)(v6 + 8);
          unint64_t v8 = v7[1];
          unint64_t v9 = v7[2];
          if (v8 >= v9)
          {
            uint64_t v24 = (uint64_t)(v8 - *v7) >> 4;
            unint64_t v25 = v24 + 1;
            if ((unint64_t)(v24 + 1) >> 60) {
              sub_10002B5E0();
            }
            uint64_t v26 = v9 - *v7;
            if (v26 >> 3 > v25) {
              unint64_t v25 = v26 >> 3;
            }
            if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v27 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v27 = v25;
            }
            v37[4] = v7 + 2;
            long long v28 = (char *)sub_10001E498((uint64_t)(v7 + 2), v27);
            uint64_t v29 = (unsigned __int8 *)&v28[16 * v24];
            v37[0] = v28;
            v37[1] = v29;
            v37[3] = &v28[16 * v30];
            unsigned __int8 *v29 = v35;
            *((void *)v29 + 1) = v36;
            unsigned __int8 v35 = 0;
            unsigned __int8 v36 = 0;
            v37[2] = v29 + 16;
            sub_10011892C(v7, v37);
            uint64_t v10 = v7[1];
            sub_100118AB8((uint64_t)v37);
          }
          else
          {
            *(unsigned char *)unint64_t v8 = v35;
            *(void *)(v8 + 8) = v36;
            unsigned __int8 v35 = 0;
            unsigned __int8 v36 = 0;
            uint64_t v10 = v8 + 16;
            v7[1] = v8 + 16;
          }
          v7[1] = v10;
          goto LABEL_22;
        }
        unint64_t v17 = (unint64_t)(a1[8] - 1);
        unint64_t v18 = *(void *)&a1[7][(v17 >> 3) & 0x1FFFFFFFFFFFFFF8];
        a1[8] = (unsigned __int8 *)v17;
        if ((v18 >> v17))
        {
          unsigned __int8 v19 = v35;
          unsigned __int8 v20 = v36;
          unsigned __int8 v35 = 0;
          unsigned __int8 v36 = 0;
          int v21 = a1[10];
          int v22 = *v21;
          *int v21 = v19;
          uint64_t v23 = (char **)*((void *)v21 + 1);
          *((void *)v21 + 1) = v20;
          char v32 = v23;
          sub_100118400(&v32, v22);
          goto LABEL_22;
        }
      }
    }
    uint64_t v11 = 0;
LABEL_23:
    sub_100118400(&v36, v35);
    return v11;
  }
  return 0;
}

void sub_100121510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100118AB8((uint64_t)va);
  sub_100118400(v8, a7);
  _Unwind_Resume(a1);
}

uint64_t sub_100121538(unsigned __int8 **a1, char ***a2, char a3)
{
  if ((*(void *)&a1[4][((unint64_t)(a1[5] - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (*((unsigned char *)a1 + 40) - 1)))
  {
    uint64_t v4 = *a2;
    unsigned __int8 v35 = 6;
    unsigned __int8 v36 = v4;
    if (a3 & 1) != 0 || (sub_10011FD18((uint64_t)(a1 + 12), (unint64_t)(a1[2] - a1[1]) >> 3, 5))
    {
      uint64_t v5 = a1[2];
      if (a1[1] == v5)
      {
        unsigned __int8 v12 = v35;
        uint64_t v13 = v36;
        unsigned __int8 v35 = 0;
        unsigned __int8 v36 = 0;
        uint64_t v14 = (uint64_t)*a1;
        int v15 = **a1;
        *(unsigned char *)uint64_t v14 = v12;
        char v33 = v15;
        unint64_t v16 = *(char ***)(v14 + 8);
        *(void *)(v14 + 8) = v13;
        unsigned __int8 v34 = v16;
        sub_100118400(&v34, v15);
LABEL_22:
        uint64_t v11 = 1;
        goto LABEL_23;
      }
      uint64_t v6 = *((void *)v5 - 1);
      if (v6)
      {
        if (*(unsigned char *)v6 == 2)
        {
          unint64_t v7 = *(uint64_t **)(v6 + 8);
          unint64_t v8 = v7[1];
          unint64_t v9 = v7[2];
          if (v8 >= v9)
          {
            uint64_t v24 = (uint64_t)(v8 - *v7) >> 4;
            unint64_t v25 = v24 + 1;
            if ((unint64_t)(v24 + 1) >> 60) {
              sub_10002B5E0();
            }
            uint64_t v26 = v9 - *v7;
            if (v26 >> 3 > v25) {
              unint64_t v25 = v26 >> 3;
            }
            if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v27 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v27 = v25;
            }
            v37[4] = v7 + 2;
            long long v28 = (char *)sub_10001E498((uint64_t)(v7 + 2), v27);
            uint64_t v29 = (unsigned __int8 *)&v28[16 * v24];
            v37[0] = v28;
            v37[1] = v29;
            v37[3] = &v28[16 * v30];
            unsigned __int8 *v29 = v35;
            *((void *)v29 + 1) = v36;
            unsigned __int8 v35 = 0;
            unsigned __int8 v36 = 0;
            v37[2] = v29 + 16;
            sub_10011892C(v7, v37);
            uint64_t v10 = v7[1];
            sub_100118AB8((uint64_t)v37);
          }
          else
          {
            *(unsigned char *)unint64_t v8 = v35;
            *(void *)(v8 + 8) = v36;
            unsigned __int8 v35 = 0;
            unsigned __int8 v36 = 0;
            uint64_t v10 = v8 + 16;
            v7[1] = v8 + 16;
          }
          v7[1] = v10;
          goto LABEL_22;
        }
        unint64_t v17 = (unint64_t)(a1[8] - 1);
        unint64_t v18 = *(void *)&a1[7][(v17 >> 3) & 0x1FFFFFFFFFFFFFF8];
        a1[8] = (unsigned __int8 *)v17;
        if ((v18 >> v17))
        {
          unsigned __int8 v19 = v35;
          unsigned __int8 v20 = v36;
          unsigned __int8 v35 = 0;
          unsigned __int8 v36 = 0;
          int v21 = a1[10];
          int v22 = *v21;
          *int v21 = v19;
          uint64_t v23 = (char **)*((void *)v21 + 1);
          *((void *)v21 + 1) = v20;
          char v32 = v23;
          sub_100118400(&v32, v22);
          goto LABEL_22;
        }
      }
    }
    uint64_t v11 = 0;
LABEL_23:
    sub_100118400(&v36, v35);
    return v11;
  }
  return 0;
}

void sub_100121798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100118AB8((uint64_t)va);
  sub_100118400(v8, a7);
  _Unwind_Resume(a1);
}

uint64_t sub_1001217C0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_1001B9538;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 16), (const std::runtime_error *)(a2 + 16));
  *(void *)a1 = off_1001BE150;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  return a1;
}

uint64_t sub_10012183C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_1001B9538;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 16), (const std::runtime_error *)(a2 + 16));
  *(void *)a1 = off_1001BE110;
  return a1;
}

uint64_t sub_1001218AC(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_1001B9538;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 16), (const std::runtime_error *)(a2 + 16));
  *(void *)a1 = off_1001BDFE8;
  return a1;
}

uint64_t sub_10012191C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_1001B9538;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 16), (const std::runtime_error *)(a2 + 16));
  *(void *)a1 = off_1001B9560;
  return a1;
}

uint64_t sub_10012198C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_1001B9538;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 16), (const std::runtime_error *)(a2 + 16));
  *(void *)a1 = off_1001BE0D0;
  return a1;
}

void sub_1001219FC(std::runtime_error *a1)
{
  a1->__vftable = (std::runtime_error_vtbl *)off_1001B9538;
  std::runtime_error::~runtime_error(a1 + 1);
  std::exception::~exception(a1);

  operator delete();
}

void sub_100121A64(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  std::to_string(&v12, *(void *)(a1 + 16) + 1);
  uint64_t v4 = std::string::insert(&v12, 0, " at line ");
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v13.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v13.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  uint64_t v6 = std::string::append(&v13, ", column ");
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v14.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, *(void *)(a1 + 8));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v10 = std::string::append(&v14, (const std::string::value_type *)p_p, size);
  *a2 = *v10;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v12.__r_.__value_.__l.__data_);
  }
}

void sub_100121B7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v26 - 25) < 0) {
    operator delete(*(void **)(v26 - 48));
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100121BE0(unsigned int a1)
{
  if (a1 > 0x10) {
    return "unknown token";
  }
  else {
    return off_1001BE168[a1];
  }
}

uint64_t sub_100121C04(uint64_t a1)
{
  sub_100118400((char ***)(a1 + 144), *(unsigned __int8 *)(a1 + 136));
  sub_10011837C((void *)(a1 + 96));
  int v2 = *(void **)(a1 + 56);
  if (v2) {
    operator delete(v2);
  }
  int v3 = *(void **)(a1 + 32);
  if (v3) {
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    *(void *)(a1 + 16) = v4;
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_100121C64(uint64_t a1, unint64_t a2)
{
  LOBYTE(v26) = 1;
  uint64_t v4 = sub_10012209C((unsigned __int8 **)a1, (unsigned __int8 *)&v26);
  unint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = *(uint64_t **)(a1 + 16);
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      sub_10002B5E0();
    }
    uint64_t v10 = v5 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12) {
      std::string v13 = (char *)sub_100038500(a1 + 24, v12);
    }
    else {
      std::string v13 = 0;
    }
    std::string v14 = (uint64_t *)&v13[8 * v9];
    int v15 = &v13[8 * v12];
    uint64_t *v14 = v4;
    long long v7 = v14 + 1;
    unint64_t v17 = *(char **)(a1 + 8);
    unint64_t v16 = *(char **)(a1 + 16);
    if (v16 != v17)
    {
      do
      {
        uint64_t v18 = *((void *)v16 - 1);
        v16 -= 8;
        *--std::string v14 = v18;
      }
      while (v16 != v17);
      unint64_t v16 = *(char **)(a1 + 8);
    }
    *(void *)(a1 + 8) = v14;
    *(void *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = v15;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    *uint64_t v6 = v4;
    long long v7 = v6 + 1;
  }
  *(void *)(a1 + 16) = v7;
  if (a2 != -1)
  {
    unint64_t v19 = *(char *)*(v7 - 1);
    if (v19 > 2) {
      unint64_t v20 = 1;
    }
    else {
      unint64_t v20 = qword_10017B8C8[v19];
    }
    if (v20 < a2)
    {
      exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
      std::to_string(&v25, a2);
      uint64_t v23 = std::string::insert(&v25, 0, "excessive object size: ");
      long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
      std::string::size_type v27 = v23->__r_.__value_.__r.__words[2];
      long long v26 = v24;
      v23->__r_.__value_.__l.__size_ = 0;
      v23->__r_.__value_.__r.__words[2] = 0;
      v23->__r_.__value_.__r.__words[0] = 0;
      sub_10011FB80(408, (uint64_t)&v26, exception);
    }
  }
  return 1;
}

void sub_100121E20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t sub_100121E80(uint64_t a1, unint64_t a2)
{
  LOBYTE(v26) = 2;
  uint64_t v4 = sub_10012209C((unsigned __int8 **)a1, (unsigned __int8 *)&v26);
  unint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = *(uint64_t **)(a1 + 16);
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      sub_10002B5E0();
    }
    uint64_t v10 = v5 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12) {
      std::string v13 = (char *)sub_100038500(a1 + 24, v12);
    }
    else {
      std::string v13 = 0;
    }
    std::string v14 = (uint64_t *)&v13[8 * v9];
    int v15 = &v13[8 * v12];
    uint64_t *v14 = v4;
    long long v7 = v14 + 1;
    unint64_t v17 = *(char **)(a1 + 8);
    unint64_t v16 = *(char **)(a1 + 16);
    if (v16 != v17)
    {
      do
      {
        uint64_t v18 = *((void *)v16 - 1);
        v16 -= 8;
        *--std::string v14 = v18;
      }
      while (v16 != v17);
      unint64_t v16 = *(char **)(a1 + 8);
    }
    *(void *)(a1 + 8) = v14;
    *(void *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = v15;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    *uint64_t v6 = v4;
    long long v7 = v6 + 1;
  }
  *(void *)(a1 + 16) = v7;
  if (a2 != -1)
  {
    unint64_t v19 = *(char *)*(v7 - 1);
    if (v19 > 2) {
      unint64_t v20 = 1;
    }
    else {
      unint64_t v20 = qword_10017B8C8[v19];
    }
    if (v20 < a2)
    {
      exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
      std::to_string(&v25, a2);
      uint64_t v23 = std::string::insert(&v25, 0, "excessive array size: ");
      long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
      std::string::size_type v27 = v23->__r_.__value_.__r.__words[2];
      long long v26 = v24;
      v23->__r_.__value_.__l.__size_ = 0;
      v23->__r_.__value_.__r.__words[2] = 0;
      v23->__r_.__value_.__r.__words[0] = 0;
      sub_10011FB80(408, (uint64_t)&v26, exception);
    }
  }
  return 1;
}

void sub_10012203C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t sub_10012209C(unsigned __int8 **a1, unsigned __int8 *a2)
{
  int v3 = a1[2];
  if (a1[1] == v3)
  {
    int v9 = *a2;
    char v22 = v9;
    uint64_t v10 = (char ***)sub_10011B854(&v23, v9);
    uint64_t v11 = (uint64_t)*a1;
    int v12 = **a1;
    *(unsigned char *)uint64_t v11 = v22;
    char v22 = v12;
    uint64_t v13 = *(void *)(v11 + 8);
    *(void *)(v11 + 8) = v23;
    uint64_t v23 = v13;
    sub_100118400(v10, v12);
    return (uint64_t)*a1;
  }
  else
  {
    uint64_t v4 = *((void *)v3 - 1);
    if (*(unsigned char *)v4 == 2)
    {
      unint64_t v5 = *(uint64_t **)(v4 + 8);
      uint64_t v6 = (unsigned char *)v5[1];
      if ((unint64_t)v6 >= v5[2])
      {
        uint64_t v8 = sub_1001221C4(v5, a2);
      }
      else
      {
        int v7 = *a2;
        *uint64_t v6 = v7;
        sub_10011B854(v6 + 8, v7);
        uint64_t v8 = (uint64_t)(v6 + 16);
        v5[1] = (uint64_t)(v6 + 16);
      }
      v5[1] = v8;
      return *(void *)(*(void *)(*((void *)a1[2] - 1) + 8) + 8) - 16;
    }
    else
    {
      int v15 = *a2;
      unsigned __int8 v20 = v15;
      unint64_t v16 = (char ***)sub_10011B854(&v21, v15);
      unint64_t v17 = a1[4];
      int v18 = *v17;
      unsigned __int8 *v17 = v20;
      uint64_t v19 = *((void *)v17 + 1);
      *((void *)v17 + 1) = v21;
      uint64_t v21 = v19;
      sub_100118400(v16, v18);
      return (uint64_t)a1[4];
    }
  }
}

void sub_1001221BC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1001221C4(uint64_t *a1, unsigned __int8 *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 4;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60) {
    sub_10002B5E0();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 3 > v5) {
    unint64_t v5 = v8 >> 3;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v9 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  int v18 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_10001E498(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = &v10[16 * v4];
  v15[0] = v10;
  v15[1] = v11;
  unint64_t v16 = v11;
  unint64_t v17 = &v10[16 * v9];
  int v12 = *a2;
  *uint64_t v11 = v12;
  sub_10011B854(v11 + 8, v12);
  v16 += 16;
  sub_10011892C(a1, v15);
  uint64_t v13 = a1[1];
  sub_100118AB8((uint64_t)v15);
  return v13;
}

void sub_10012229C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100118AB8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1001222B0(unsigned __int8 **a1, uint64_t *a2)
{
  uint64_t v3 = a1[2];
  if (a1[1] == v3)
  {
    uint64_t v6 = *a2;
    uint64_t v7 = (uint64_t)*a1;
    int v8 = **a1;
    *(unsigned char *)uint64_t v7 = 7;
    char v15 = v8;
    unint64_t v9 = *(char ***)(v7 + 8);
    *(void *)(v7 + 8) = v6;
    unint64_t v16 = v9;
    sub_100118400(&v16, v8);
    return (uint64_t)*a1;
  }
  else
  {
    uint64_t v4 = *((void *)v3 - 1);
    if (*(unsigned char *)v4 == 2)
    {
      sub_100122380(*(uint64_t **)(v4 + 8), a2);
      return *(void *)(*(void *)(*((void *)a1[2] - 1) + 8) + 8) - 16;
    }
    else
    {
      uint64_t v10 = *a2;
      uint64_t v11 = a1[4];
      int v12 = *v11;
      *uint64_t v11 = 7;
      uint64_t v13 = (char **)*((void *)v11 + 1);
      *((void *)v11 + 1) = v10;
      std::string v14 = v13;
      sub_100118400(&v14, v12);
      return (uint64_t)a1[4];
    }
  }
}

uint64_t sub_100122380(uint64_t *a1, uint64_t *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_10002B5E0();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    _OWORD v19[4] = v4;
    std::string v14 = (char *)sub_10001E498(v4, v13);
    char v15 = &v14[16 * v10];
    v19[0] = v14;
    v19[1] = v15;
    v19[3] = &v14[16 * v16];
    *((void *)v15 + 1) = 0;
    uint64_t v17 = *a2;
    char *v15 = 7;
    *((void *)v15 + 1) = v17;
    void v19[2] = v15 + 16;
    sub_10011892C(a1, v19);
    uint64_t v9 = a1[1];
    sub_100118AB8((uint64_t)v19);
  }
  else
  {
    *(void *)(v7 + 8) = 0;
    uint64_t v8 = *a2;
    *(unsigned char *)unint64_t v7 = 7;
    *(void *)(v7 + 8) = v8;
    uint64_t v9 = v7 + 16;
    a1[1] = v7 + 16;
  }
  a1[1] = v9;
  return v9 - 16;
}

void sub_100122478(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100118AB8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10012248C(unsigned __int8 **a1, unsigned __int8 *a2)
{
  uint64_t v3 = a1[2];
  if (a1[1] == v3)
  {
    uint64_t v6 = *a2;
    uint64_t v7 = (uint64_t)*a1;
    int v8 = **a1;
    *(unsigned char *)uint64_t v7 = 4;
    char v15 = v8;
    uint64_t v9 = *(char ***)(v7 + 8);
    *(void *)(v7 + 8) = v6;
    uint64_t v16 = v9;
    sub_100118400(&v16, v8);
    return (uint64_t)*a1;
  }
  else
  {
    uint64_t v4 = *((void *)v3 - 1);
    if (*(unsigned char *)v4 == 2)
    {
      sub_10012255C(*(uint64_t **)(v4 + 8), a2);
      return *(void *)(*(void *)(*((void *)a1[2] - 1) + 8) + 8) - 16;
    }
    else
    {
      uint64_t v10 = *a2;
      unint64_t v11 = a1[4];
      int v12 = *v11;
      *unint64_t v11 = 4;
      unint64_t v13 = (char **)*((void *)v11 + 1);
      *((void *)v11 + 1) = v10;
      std::string v14 = v13;
      sub_100118400(&v14, v12);
      return (uint64_t)a1[4];
    }
  }
}

uint64_t sub_10012255C(uint64_t *a1, unsigned __int8 *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_10002B5E0();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    _OWORD v19[4] = v4;
    std::string v14 = (char *)sub_10001E498(v4, v13);
    char v15 = &v14[16 * v10];
    v19[0] = v14;
    v19[1] = v15;
    v19[3] = &v14[16 * v16];
    *((void *)v15 + 1) = 0;
    uint64_t v17 = *a2;
    char *v15 = 4;
    *((void *)v15 + 1) = v17;
    void v19[2] = v15 + 16;
    sub_10011892C(a1, v19);
    uint64_t v9 = a1[1];
    sub_100118AB8((uint64_t)v19);
  }
  else
  {
    *(void *)(v7 + 8) = 0;
    uint64_t v8 = *a2;
    *(unsigned char *)unint64_t v7 = 4;
    *(void *)(v7 + 8) = v8;
    uint64_t v9 = v7 + 16;
    a1[1] = v7 + 16;
  }
  a1[1] = v9;
  return v9 - 16;
}

void sub_100122654(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100118AB8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100122668(unsigned __int8 **a1)
{
  uint64_t v2 = a1[2];
  if (a1[1] == v2)
  {
    uint64_t v8 = (uint64_t)*a1;
    int v9 = **a1;
    *(unsigned char *)uint64_t v8 = 0;
    char v23 = v9;
    uint64_t v10 = *(char ***)(v8 + 8);
    *(void *)(v8 + 8) = 0;
    long long v24 = v10;
    sub_100118400(&v24, v9);
    return (uint64_t)*a1;
  }
  else
  {
    uint64_t v3 = *((void *)v2 - 1);
    if (*(unsigned char *)v3 == 2)
    {
      uint64_t v4 = *(uint64_t **)(v3 + 8);
      unint64_t v5 = v4[1];
      unint64_t v6 = v4[2];
      if (v5 >= v6)
      {
        uint64_t v15 = (uint64_t)(v5 - *v4) >> 4;
        unint64_t v16 = v15 + 1;
        if ((unint64_t)(v15 + 1) >> 60) {
          sub_10002B5E0();
        }
        uint64_t v17 = v6 - *v4;
        if (v17 >> 3 > v16) {
          unint64_t v16 = v17 >> 3;
        }
        if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v18 = v16;
        }
        v25[4] = v4 + 2;
        uint64_t v19 = (char *)sub_10001E498((uint64_t)(v4 + 2), v18);
        unsigned __int8 v20 = &v19[16 * v15];
        v25[0] = v19;
        v25[1] = v20;
        v25[3] = &v19[16 * v21];
        char *v20 = 0;
        *((void *)v20 + 1) = 0;
        void v25[2] = v20 + 16;
        sub_10011892C(v4, v25);
        uint64_t v7 = v4[1];
        sub_100118AB8((uint64_t)v25);
      }
      else
      {
        *(unsigned char *)unint64_t v5 = 0;
        *(void *)(v5 + 8) = 0;
        uint64_t v7 = v5 + 16;
        v4[1] = v5 + 16;
      }
      v4[1] = v7;
      return *(void *)(*(void *)(*((void *)a1[2] - 1) + 8) + 8) - 16;
    }
    else
    {
      uint64_t v12 = a1[4];
      int v13 = *v12;
      *uint64_t v12 = 0;
      std::string v14 = (char **)*((void *)v12 + 1);
      *((void *)v12 + 1) = 0;
      char v22 = v14;
      sub_100118400(&v22, v13);
      return (uint64_t)a1[4];
    }
  }
}

void sub_1001227D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100118AB8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1001227EC(unsigned __int8 **a1, uint64_t *a2)
{
  uint64_t v3 = a1[2];
  if (a1[1] == v3)
  {
    uint64_t v6 = *a2;
    uint64_t v7 = (uint64_t)*a1;
    int v8 = **a1;
    *(unsigned char *)uint64_t v7 = 5;
    char v15 = v8;
    int v9 = *(char ***)(v7 + 8);
    *(void *)(v7 + 8) = v6;
    unint64_t v16 = v9;
    sub_100118400(&v16, v8);
    return (uint64_t)*a1;
  }
  else
  {
    uint64_t v4 = *((void *)v3 - 1);
    if (*(unsigned char *)v4 == 2)
    {
      sub_1001228BC(*(uint64_t **)(v4 + 8), a2);
      return *(void *)(*(void *)(*((void *)a1[2] - 1) + 8) + 8) - 16;
    }
    else
    {
      uint64_t v10 = *a2;
      unint64_t v11 = a1[4];
      int v12 = *v11;
      *unint64_t v11 = 5;
      int v13 = (char **)*((void *)v11 + 1);
      *((void *)v11 + 1) = v10;
      std::string v14 = v13;
      sub_100118400(&v14, v12);
      return (uint64_t)a1[4];
    }
  }
}

uint64_t sub_1001228BC(uint64_t *a1, uint64_t *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_10002B5E0();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    _OWORD v19[4] = v4;
    std::string v14 = (char *)sub_10001E498(v4, v13);
    char v15 = &v14[16 * v10];
    v19[0] = v14;
    v19[1] = v15;
    v19[3] = &v14[16 * v16];
    *((void *)v15 + 1) = 0;
    uint64_t v17 = *a2;
    char *v15 = 5;
    *((void *)v15 + 1) = v17;
    void v19[2] = v15 + 16;
    sub_10011892C(a1, v19);
    uint64_t v9 = a1[1];
    sub_100118AB8((uint64_t)v19);
  }
  else
  {
    *(void *)(v7 + 8) = 0;
    uint64_t v8 = *a2;
    *(unsigned char *)unint64_t v7 = 5;
    *(void *)(v7 + 8) = v8;
    uint64_t v9 = v7 + 16;
    a1[1] = v7 + 16;
  }
  a1[1] = v9;
  return v9 - 16;
}

void sub_1001229B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100118AB8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1001229C8(unsigned __int8 **a1, uint64_t a2)
{
  uint64_t v3 = a1[2];
  if (a1[1] == v3)
  {
    uint64_t v8 = sub_100120620(a2);
    uint64_t v9 = (uint64_t)*a1;
    int v10 = **a1;
    *(unsigned char *)uint64_t v9 = 3;
    char v18 = v10;
    unint64_t v11 = *(char ***)(v9 + 8);
    *(void *)(v9 + 8) = v8;
    uint64_t v19 = v11;
    sub_100118400(&v19, v10);
    return (uint64_t)*a1;
  }
  else
  {
    uint64_t v4 = *((void *)v3 - 1);
    if (*(unsigned char *)v4 == 2)
    {
      unint64_t v5 = *(uint64_t **)(v4 + 8);
      unint64_t v6 = v5[1];
      if (v6 >= v5[2])
      {
        uint64_t v7 = sub_100122AF0(v5, a2);
      }
      else
      {
        *(void *)(v6 + 8) = 0;
        *(unsigned char *)unint64_t v6 = 3;
        *(void *)(v6 + 8) = sub_100120620(a2);
        uint64_t v7 = v6 + 16;
        v5[1] = v6 + 16;
      }
      v5[1] = v7;
      return *(void *)(*(void *)(*((void *)a1[2] - 1) + 8) + 8) - 16;
    }
    else
    {
      unint64_t v13 = sub_100120620(a2);
      std::string v14 = a1[4];
      int v15 = *v14;
      unsigned __int8 *v14 = 3;
      uint64_t v16 = (char **)*((void *)v14 + 1);
      *((void *)v14 + 1) = v13;
      uint64_t v17 = v16;
      sub_100118400(&v17, v15);
      return (uint64_t)a1[4];
    }
  }
}

void sub_100122AE8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_100122AF0(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 4;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60) {
    sub_10002B5E0();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 3 > v5) {
    unint64_t v5 = v8 >> 3;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v9 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    int v10 = (char *)sub_10001E498(v7, v9);
  }
  else {
    int v10 = 0;
  }
  unint64_t v11 = &v10[16 * v4];
  v14[0] = v10;
  v14[1] = v11;
  int v15 = v11;
  uint64_t v16 = &v10[16 * v9];
  *unint64_t v11 = 3;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 1) = sub_100120620(a2);
  v15 += 16;
  sub_10011892C(a1, v14);
  uint64_t v12 = a1[1];
  sub_100118AB8((uint64_t)v14);
  return v12;
}

void sub_100122BD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100118AB8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100122BE4(unsigned __int8 **a1, uint64_t *a2)
{
  uint64_t v3 = a1[2];
  if (a1[1] == v3)
  {
    uint64_t v6 = *a2;
    uint64_t v7 = (uint64_t)*a1;
    int v8 = **a1;
    *(unsigned char *)uint64_t v7 = 6;
    char v15 = v8;
    unint64_t v9 = *(char ***)(v7 + 8);
    *(void *)(v7 + 8) = v6;
    uint64_t v16 = v9;
    sub_100118400(&v16, v8);
    return (uint64_t)*a1;
  }
  else
  {
    uint64_t v4 = *((void *)v3 - 1);
    if (*(unsigned char *)v4 == 2)
    {
      sub_100122CB4(*(uint64_t **)(v4 + 8), a2);
      return *(void *)(*(void *)(*((void *)a1[2] - 1) + 8) + 8) - 16;
    }
    else
    {
      uint64_t v10 = *a2;
      unint64_t v11 = a1[4];
      int v12 = *v11;
      *unint64_t v11 = 6;
      unint64_t v13 = (char **)*((void *)v11 + 1);
      *((void *)v11 + 1) = v10;
      std::string v14 = v13;
      sub_100118400(&v14, v12);
      return (uint64_t)a1[4];
    }
  }
}

uint64_t sub_100122CB4(uint64_t *a1, uint64_t *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_10002B5E0();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    _OWORD v19[4] = v4;
    std::string v14 = (char *)sub_10001E498(v4, v13);
    char v15 = &v14[16 * v10];
    v19[0] = v14;
    v19[1] = v15;
    v19[3] = &v14[16 * v16];
    *((void *)v15 + 1) = 0;
    uint64_t v17 = *a2;
    char *v15 = 6;
    *((void *)v15 + 1) = v17;
    void v19[2] = v15 + 16;
    sub_10011892C(a1, v19);
    uint64_t v9 = a1[1];
    sub_100118AB8((uint64_t)v19);
  }
  else
  {
    *(void *)(v7 + 8) = 0;
    uint64_t v8 = *a2;
    *(unsigned char *)unint64_t v7 = 6;
    *(void *)(v7 + 8) = v8;
    uint64_t v9 = v7 + 16;
    a1[1] = v7 + 16;
  }
  a1[1] = v9;
  return v9 - 16;
}

void sub_100122DAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100118AB8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100122DC0(uint64_t a1, uint64_t a2, uint64_t a3, char a4, int a5)
{
  *(unsigned char *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  if (!a3)
  {
LABEL_7:
    int v13 = 1;
    if (a4) {
      goto LABEL_17;
    }
    goto LABEL_10;
  }
  uint64_t v10 = 32 * a3;
  unint64_t v11 = (unsigned char **)(a2 + 16);
  while (1)
  {
    uint64_t v12 = *v11;
    if (**v11 != 2
      || *(void *)(*((void *)v12 + 1) + 8) - **((void **)v12 + 1) != 32
      || *(unsigned char *)sub_100123094((uint64_t)v12, 0) != 3)
    {
      break;
    }
    v11 += 4;
    v10 -= 32;
    if (!v10) {
      goto LABEL_7;
    }
  }
  int v13 = 0;
  if ((a4 & 1) == 0)
  {
LABEL_10:
    if (a5 == 2) {
      int v14 = 0;
    }
    else {
      int v14 = v13;
    }
    if (a5 != 1) {
      LOBYTE(v13) = 1;
    }
    if ((v13 & 1) == 0)
    {
      exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
      sub_100018888(v20, "cannot create object from initializer list");
      sub_10009845C(301, (uint64_t)v20, exception);
    }
    int v13 = v14;
  }
LABEL_17:
  uint64_t v15 = a2 + 32 * a3;
  if (v13)
  {
    *(unsigned char *)a1 = 1;
    uint64_t v16 = operator new(0x18uLL);
    _DWORD v16[2] = 0;
    v16[1] = 0;
    void *v16 = v16 + 1;
    *(void *)(a1 + 8) = v16;
    sub_100122F84(a2, v15, a1);
  }
  else
  {
    *(unsigned char *)a1 = 2;
    uint64_t v19 = v15;
    v20[0] = a2;
    *(void *)(a1 + 8) = sub_100123028(v20, &v19);
  }
  return a1;
}

void sub_100122F4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

uint64_t sub_100122F84(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      sub_1001231C4(v5, (uint64_t)v7);
      sub_1001231F4(*(uint64_t ***)(a3 + 8), *((const void ***)*v8 + 1), *((void *)*v8 + 1), (uint64_t)(*v8 + 16));
      sub_100118400(&v8, v7[0]);
      v5 += 32;
    }
    while (v5 != a2);
  }
  return a3;
}

void sub_100123010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9)
{
  sub_100118400(v9, a9);
  _Unwind_Resume(a1);
}

void *sub_100123028(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = operator new(0x18uLL);
  uint64_t v5 = *a1;
  uint64_t v6 = *a2;
  unint64_t v7 = (*a2 - *a1) >> 5;
  v4[1] = 0;
  void v4[2] = 0;
  void *v4 = 0;
  sub_1001232CC(v4, v5, v6, v7);
  return v4;
}

void sub_100123080(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100123094(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a1 != 2)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    uint64_t v5 = (char *)sub_1000985A0((char *)a1);
    sub_100018888(&v8, v5);
    uint64_t v6 = std::string::insert(&v8, 0, "cannot use operator[] with a numeric argument with ");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    std::string::size_type v10 = v6->__r_.__value_.__r.__words[2];
    long long v9 = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    sub_10009845C(305, (uint64_t)&v9, exception);
  }
  return **(void **)(a1 + 8) + 16 * a2;
}

void sub_100123164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t sub_1001231C4@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  if (!*(unsigned char *)(result + 24)) {
    return sub_10012365C(a2, (const void ****)v2);
  }
  *(unsigned char *)a2 = *(unsigned char *)v2;
  *(void *)(a2 + 8) = *(void *)(v2 + 8);
  *(unsigned char *)uint64_t v2 = 0;
  *(void *)(v2 + 8) = 0;
  return result;
}

_OWORD *sub_1001231F4(uint64_t **a1, const void **a2, uint64_t a3, uint64_t a4)
{
  long long v7 = (void **)sub_10001893C((uint64_t)a1, &v13, a2);
  std::string v8 = *v7;
  if (!*v7)
  {
    long long v9 = (uint64_t **)v7;
    std::string v8 = operator new(0x48uLL);
    v11[1] = a1 + 1;
    v8[2] = *(_OWORD *)a3;
    *((void *)v8 + 6) = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    *((unsigned char *)v8 + 56) = *(unsigned char *)a4;
    *((void *)v8 + 8) = *(void *)(a4 + 8);
    *(unsigned char *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    char v12 = 1;
    sub_10001716C(a1, v13, v9, (uint64_t *)v8);
    v11[0] = 0;
    sub_1001207D0((uint64_t)v11, 0);
  }
  return v8;
}

void *sub_1001232CC(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_100123354(result, a4);
    uint64_t result = (void *)sub_100123398((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100123334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_100118D18(&a9);
  _Unwind_Resume(a1);
}

char *sub_100123354(void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    sub_10002B5E0();
  }
  uint64_t result = (char *)sub_10001E498((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

uint64_t sub_100123398(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_10012343C(v4, v6);
      v6 += 32;
      uint64_t v4 = v11 + 16;
      v11 += 16;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  sub_10012349C((uint64_t)v8);
  return v4;
}

void sub_100123428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10012343C(uint64_t a1, uint64_t a2)
{
  sub_1001231C4(a2, (uint64_t)v4);
  *(unsigned char *)a1 = v4[0];
  *(void *)(a1 + 8) = v5;
  v4[0] = 0;
  uint64_t v5 = 0;
  sub_100118400(&v5, 0);
  return a1;
}

uint64_t sub_10012349C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1001234D4(a1);
  }
  return a1;
}

void sub_1001234D4(uint64_t a1)
{
  uint64_t v1 = **(char *****)(a1 + 16);
  uint64_t v2 = **(char *****)(a1 + 8);
  if (v1 != v2)
  {
    uint64_t v3 = v1 - 1;
    do
    {
      uint64_t v4 = v3 - 1;
      sub_100118400(v3, *((unsigned __int8 *)v3 - 8));
      v3 -= 2;
    }
    while (v4 != v2);
  }
}

void *sub_10012352C(char *a1)
{
  uint64_t v2 = operator new(0x18uLL);
  sub_100018888(v2, a1);
  return v2;
}

void sub_100123564(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100123578(char *a1)
{
  uint64_t v2 = operator new(0x18uLL);
  sub_100018888(v2, a1);
  return v2;
}

void sub_1001235B0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1001235C4(char **a1)
{
  uint64_t v2 = operator new(0x18uLL);
  sub_100018888(v2, *a1);
  return v2;
}

void sub_1001235FC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100123610(char *a1)
{
  uint64_t v2 = operator new(0x18uLL);
  sub_100018888(v2, a1);
  return v2;
}

void sub_100123648(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10012365C(uint64_t a1, const void ****a2)
{
  int v3 = *(unsigned __int8 *)a2;
  *(unsigned char *)a1 = v3;
  *(void *)(a1 + 8) = 0;
  switch(v3)
  {
    case 1:
      uint64_t v4 = sub_100123718(a2[1]);
      goto LABEL_8;
    case 2:
      uint64_t v4 = sub_1001239C4((uint64_t *)a2[1]);
      goto LABEL_8;
    case 3:
      uint64_t v4 = sub_100120620((uint64_t)a2[1]);
      goto LABEL_8;
    case 4:
      uint64_t v4 = (uint64_t *)*((unsigned __int8 *)a2 + 8);
      goto LABEL_8;
    case 5:
    case 6:
    case 7:
      uint64_t v4 = (uint64_t *)a2[1];
      goto LABEL_8;
    case 8:
      uint64_t v4 = sub_100123B4C((uint64_t)a2[1]);
LABEL_8:
      *(void *)(a1 + 8) = v4;
      break;
    default:
      return a1;
  }
  return a1;
}

uint64_t *sub_100123718(const void ***a1)
{
  uint64_t v2 = (uint64_t *)operator new(0x18uLL);
  sub_100123764(v2, a1);
  return v2;
}

void sub_100123750(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100123764(uint64_t *a1, const void ***a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1001237BC(a1, *a2, a2 + 1);
  return a1;
}

void sub_1001237A4(_Unwind_Exception *a1)
{
  sub_100118C54(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1001237BC(uint64_t *result, const void **a2, const void ***a3)
{
  if (a2 != (const void **)a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_100123848(v5, v6, v4 + 4, (long long *)v4 + 2);
      long long v7 = (const void **)v4[1];
      if (v7)
      {
        do
        {
          std::string v8 = (const void ***)v7;
          long long v7 = (const void **)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          std::string v8 = (const void ***)v4[2];
          BOOL v9 = *v8 == v4;
          uint64_t v4 = (const void **)v8;
        }
        while (!v9);
      }
      uint64_t v4 = (const void **)v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_100123848(uint64_t **a1, uint64_t *a2, const void **a3, long long *a4)
{
  uint64_t v6 = sub_100016E38(a1, a2, &v12, &v11, a3);
  long long v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    std::string v8 = (uint64_t **)v6;
    sub_1001238E0((uint64_t)a1, a4, (uint64_t)v10);
    sub_10001716C(a1, (uint64_t)v12, v8, v10[0]);
    long long v7 = v10[0];
    v10[0] = 0;
    sub_1001207D0((uint64_t)v10, 0);
  }
  return v7;
}

char *sub_1001238E0@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x48uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = sub_10012394C(v6 + 32, a2);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_100123934(_Unwind_Exception *a1)
{
  sub_1001207D0(v1, 0);
  _Unwind_Resume(a1);
}

char *sub_10012394C(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000173FC(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::__fs::filesystem::path __dst = v4;
  }
  sub_10012365C(__dst + 24, (char *)a2 + 24);
  return __dst;
}

void sub_1001239A8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1001239C4(uint64_t *a1)
{
  uint64_t v2 = operator new(0x18uLL);
  v2[1] = 0;
  v2[2] = 0;
  void *v2 = 0;
  sub_100123A20(v2, *a1, a1[1], (a1[1] - *a1) >> 4);
  return v2;
}

void sub_100123A0C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100123A20(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_100123354(result, a4);
    uint64_t result = (void *)sub_100123AA8((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100123A88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_100118D18(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100123AA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_10012365C(v4, v6);
      v6 += 16;
      uint64_t v4 = v11 + 16;
      v11 += 16;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  sub_10012349C((uint64_t)v8);
  return v4;
}

void sub_100123B38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100123B4C(uint64_t a1)
{
  uint64_t v2 = operator new(0x20uLL);
  v2[1] = 0;
  v2[2] = 0;
  void *v2 = 0;
  sub_1000148E0(v2, *(const void **)a1, *(void *)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
  *((_WORD *)v2 + 12) = *(_WORD *)(a1 + 24);
  return v2;
}

void sub_100123B98(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100123BAC(uint64_t *a1, const void ****a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - *a1) >> 4;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_10002B5E0();
    }
    uint64_t v11 = v5 - *a1;
    uint64_t v12 = v11 >> 3;
    if (v11 >> 3 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v19 = v4;
    if (v13) {
      int v14 = (char *)sub_10001E498(v4, v13);
    }
    else {
      int v14 = 0;
    }
    uint64_t v15 = v14;
    int v16 = &v14[16 * v10];
    char v18 = &v14[16 * v13];
    sub_10012365C((uint64_t)v16, a2);
    uint64_t v17 = v16 + 16;
    sub_10011892C(a1, &v15);
    uint64_t v9 = a1[1];
    uint64_t result = sub_100118AB8((uint64_t)&v15);
  }
  else
  {
    uint64_t result = sub_10012365C(*(void *)(v4 - 8), a2);
    uint64_t v9 = v7 + 16;
    a1[1] = v7 + 16;
  }
  a1[1] = v9;
  return result;
}

void sub_100123CA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

dispatch_group_t *sub_100123CC0(dispatch_group_t *a1, NSObject **a2, NSObject **a3, NSObject **a4)
{
  unint64_t v7 = *a2;
  *a1 = *a2;
  if (v7)
  {
    dispatch_retain(v7);
    if (*a1) {
      dispatch_group_enter(*a1);
    }
  }
  std::string v8 = *a3;
  a1[1] = *a3;
  if (v8)
  {
    dispatch_retain(v8);
    uint64_t v9 = a1[1];
    if (v9) {
      dispatch_group_enter(v9);
    }
  }
  uint64_t v10 = *a4;
  a1[2] = *a4;
  if (v10)
  {
    dispatch_retain(v10);
    uint64_t v11 = a1[2];
    if (v11) {
      dispatch_group_enter(v11);
    }
  }
  return a1;
}

void sub_100123D48(NSObject **a1@<X0>, NSObject **a2@<X8>)
{
  uint64_t v2 = *a1;
  *a2 = *a1;
  if (v2)
  {
    dispatch_retain(v2);
    dispatch_group_enter(v2);
  }
}

void sub_100123D98(uint64_t a1, NSObject **a2, uint64_t a3)
{
  unint64_t v6 = *(NSObject **)(a1 + 16);
  if (v6)
  {
    dispatch_retain(*(dispatch_object_t *)(a1 + 16));
    dispatch_group_enter(v6);
  }
  unint64_t v7 = *(NSObject **)(a1 + 8);
  std::string v8 = *a2;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  _DWORD v9[2] = sub_100123E90;
  void v9[3] = &unk_1001BE1F8;
  dispatch_group_t group = v6;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(group);
  }
  void v9[4] = a3;
  dispatch_group_notify(v7, v8, v9);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if (v6)
  {
    dispatch_group_leave(v6);
    dispatch_release(v6);
  }
}

uint64_t sub_100123E90(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100123EA0(uint64_t a1, NSObject **a2, uint64_t a3)
{
  unint64_t v6 = *(NSObject **)(a1 + 16);
  if (v6)
  {
    dispatch_retain(*(dispatch_object_t *)(a1 + 16));
    dispatch_group_enter(v6);
  }
  unint64_t v7 = *(NSObject **)(a1 + 8);
  std::string v8 = *a2;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  _DWORD v9[2] = sub_100123F94;
  void v9[3] = &unk_1001BE230;
  void v9[4] = a3;
  dispatch_group_t group = v6;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(group);
  }
  dispatch_group_notify(v7, v8, v9);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if (v6)
  {
    dispatch_group_leave(v6);
    dispatch_release(v6);
  }
}

void sub_100123F94(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(a1 + 40);
  dispatch_group_t group = v2;
  if (v2)
  {
    dispatch_retain(v2);
    dispatch_group_enter(v2);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(v1 + 16))(v1, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
}

void sub_100124008(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

void sub_10012402C()
{
}

void sub_100124180()
{
}

uint64_t sub_1001241A8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1001241C4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10000B678(v1);
  }
}

void *sub_1001241D4(void *a1)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  return a1;
}

void sub_100124234(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10000B678(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10012424C(void *a1, const char *a2, dispatch_qos_class_t a3, const char *a4)
{
  dispatch_object_t object = 0;
  sub_10002A670(a1, a2, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), "com.apple.wis.wirelessinsightsd", a4);
  return a1;
}

void sub_1001242AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  sub_100029804(v10);
  _Unwind_Resume(a1);
}

void sub_1001242D4(void *a1, std::__shared_weak_count_vtbl **a2)
{
  uint64_t v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_weak_owners_ = 0;
  v4->__shared_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_1001BE3C8;
  unint64_t v5 = *a2;
  *a2 = 0;
  v4[1].__vftable = v5;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 1174405120;
  _DWORD v7[2] = sub_10012444C;
  void v7[3] = &unk_1001BE290;
  void v7[4] = a1;
  void v7[5] = v4 + 1;
  std::string v8 = v4;
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10000BA54(&v11, a1);
  unint64_t v6 = a1[2];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1001258C0;
  block[3] = &unk_1001BE388;
  void block[5] = v11;
  uint64_t v10 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v7;
  dispatch_async(v6, block);
  if (v10) {
    sub_10000B678(v10);
  }
  if (v12) {
    sub_10000B678(v12);
  }
  if (v8) {
    sub_10000B678(v8);
  }
  sub_10000B678(v4);
}

void **sub_10012444C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = *(uint64_t **)(a1 + 40);
  int v3 = (void *)v1[6];
  uint64_t result = (void **)(v1 + 7);
  unint64_t v5 = v1[7];
  if ((unint64_t)v3 >= v5)
  {
    uint64_t v8 = v1[5];
    uint64_t v9 = ((uint64_t)v3 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      sub_10002B5E0();
    }
    uint64_t v10 = v5 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    void v16[4] = v1 + 7;
    if (v12) {
      unint64_t v13 = (char *)sub_100038500((uint64_t)result, v12);
    }
    else {
      unint64_t v13 = 0;
    }
    int v14 = &v13[8 * v9];
    v16[0] = v13;
    v16[1] = v14;
    void v16[3] = &v13[8 * v12];
    uint64_t v15 = *v2;
    uint64_t *v2 = 0;
    *(void *)int v14 = v15;
    _DWORD v16[2] = v14 + 8;
    sub_1001259AC(v1 + 5, v16);
    unint64_t v7 = (void *)v1[6];
    uint64_t result = sub_100125B5C(v16);
  }
  else
  {
    uint64_t v6 = *v2;
    uint64_t *v2 = 0;
    void *v3 = v6;
    unint64_t v7 = v3 + 1;
    v1[6] = (uint64_t)v7;
  }
  v1[6] = (uint64_t)v7;
  return result;
}

void sub_100124538(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100125B5C((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10012454C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100124568(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10000B678(v1);
  }
}

void sub_100124578()
{
  uint64_t v0 = dispatch_group_create();
  uint64_t v1 = v0;
  if (v0)
  {
    dispatch_retain(v0);
    dispatch_group_enter(v1);
    dispatch_release(v1);
  }
  sub_100018888(&__p, "ServiceManager-start");
  sub_1000035F0();
}

void sub_100124760(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v22)
  {
    dispatch_group_leave(v22);
    dispatch_release(v22);
  }
  _Unwind_Resume(exception_object);
}

void sub_100124798(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "service:#N Startup in progress", (uint8_t *)&buf, 2u);
  }
  uint64_t v3 = 0;
  __int16 v33 = 256;
  char v34 = 2;
  uint64_t v4 = "???";
  do
  {
    unint64_t v5 = *(NSObject **)(v1 + 32);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v6 = *((char *)&v33 + v3);
      unint64_t v7 = (char *)v4;
      if (v6 <= 2) {
        unint64_t v7 = off_1001BE408[v6];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "service:#N ---- Startup stage %s", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v8 = dispatch_group_create();
    uint64_t v9 = dispatch_group_create();
    uint64_t v10 = dispatch_group_create();
    uint64_t v11 = v10;
    if (v10)
    {
      dispatch_retain(v10);
      dispatch_group_enter(v11);
      dispatch_release(v11);
    }
    if (v9)
    {
      dispatch_retain(v9);
      dispatch_group_enter(v9);
    }
    char v32 = v8;
    if (v8) {
      dispatch_retain(v8);
    }
    uint64_t v31 = v11;
    if (v11) {
      dispatch_retain(v11);
    }
    uint64_t v30 = v9;
    if (v9)
    {
      dispatch_retain(v9);
      sub_100123CC0((dispatch_group_t *)&buf, &v32, &v31, &v30);
      dispatch_release(v9);
      if (!v11) {
        goto LABEL_19;
      }
LABEL_18:
      dispatch_release(v11);
      goto LABEL_19;
    }
    sub_100123CC0((dispatch_group_t *)&buf, &v32, &v31, &v30);
    if (v11) {
      goto LABEL_18;
    }
LABEL_19:
    unint64_t v12 = (char *)v4;
    if (v8) {
      dispatch_release(v8);
    }
    int v14 = *(void **)(v1 + 40);
    unint64_t v13 = *(void **)(v1 + 48);
    if (v14 != v13)
    {
      uint64_t v15 = *((unsigned __int8 *)&v33 + v3);
      do
      {
        (*(void (**)(void, uint64_t, long long *))(*(void *)*v14 + 40))(*v14, v15, &buf);
        ++v14;
      }
      while (v14 != v13);
    }
    if (group)
    {
      dispatch_group_leave(group);
      if (group) {
        dispatch_release(group);
      }
    }
    uint64_t v4 = v12;
    if (*((void *)&buf + 1))
    {
      dispatch_group_leave(*((dispatch_group_t *)&buf + 1));
      if (*((void *)&buf + 1)) {
        dispatch_release(*((dispatch_object_t *)&buf + 1));
      }
    }
    if ((void)buf)
    {
      dispatch_group_leave((dispatch_group_t)buf);
      if ((void)buf) {
        dispatch_release((dispatch_object_t)buf);
      }
    }
    dispatch_time_t v16 = dispatch_time(0, 10000000000);
    intptr_t v17 = dispatch_group_wait(v8, v16);
    char v18 = *(NSObject **)(v1 + 32);
    if (v17 && os_log_type_enabled(*(os_log_t *)(v1 + 32), OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v19 = *((char *)&v33 + v3);
      unsigned __int8 v20 = v12;
      if (v19 <= 2) {
        unsigned __int8 v20 = off_1001BE408[v19];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v20;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "service:#E    - Startup stage %s: Perform :: TIME-OUT! proceeding anyway", (uint8_t *)&buf, 0xCu);
      char v18 = *(NSObject **)(v1 + 32);
    }
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v21 = *((char *)&v33 + v3);
      int v22 = v12;
      if (v21 <= 2) {
        int v22 = off_1001BE408[v21];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v22;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "service:#N   -- Startup stage %s: Perform :: ", (uint8_t *)&buf, 0xCu);
    }
    if (v11)
    {
      dispatch_group_leave(v11);
      dispatch_release(v11);
    }
    if (v9)
    {
      dispatch_group_leave(v9);
      dispatch_release(v9);
    }
    dispatch_time_t v23 = dispatch_time(0, 10000000000);
    intptr_t v24 = dispatch_group_wait(v9, v23);
    std::string v25 = *(NSObject **)(v1 + 32);
    if (v24 && os_log_type_enabled(*(os_log_t *)(v1 + 32), OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v26 = *((char *)&v33 + v3);
      std::string::size_type v27 = v12;
      if (v26 <= 2) {
        std::string::size_type v27 = off_1001BE408[v26];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v27;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "service:#E    - Startup stage %s: Perform :: TIME-OUT! proceeding anyway", (uint8_t *)&buf, 0xCu);
      std::string v25 = *(NSObject **)(v1 + 32);
    }
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v28 = *((char *)&v33 + v3);
      uint64_t v29 = v12;
      if (v28 <= 2) {
        uint64_t v29 = off_1001BE408[v28];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v29;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "service:#N   -- Startup stage %s: Done.", (uint8_t *)&buf, 0xCu);
    }
    if (v9) {
      dispatch_release(v9);
    }
    if (v8) {
      dispatch_release(v8);
    }
    ++v3;
  }
  while (v3 != 3);
}

void sub_100124C58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_100124CB4((dispatch_group_t *)va);
  if (v8)
  {
    dispatch_group_leave(v8);
    dispatch_release(v8);
    if (!v9)
    {
LABEL_6:
      dispatch_release(v8);
      goto LABEL_7;
    }
  }
  else if (!v9)
  {
LABEL_7:
    if (v7) {
      dispatch_release(v7);
    }
    _Unwind_Resume(a1);
  }
  dispatch_group_leave(v9);
  dispatch_release(v9);
  if (!v8) {
    goto LABEL_7;
  }
  goto LABEL_6;
}

dispatch_group_t *sub_100124CB4(dispatch_group_t *a1)
{
  uint64_t v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = a1[1];
  if (v4)
  {
    dispatch_group_leave(v4);
    unint64_t v5 = a1[1];
    if (v5) {
      dispatch_release(v5);
    }
  }
  if (*a1)
  {
    dispatch_group_leave(*a1);
    if (*a1) {
      dispatch_release(*a1);
    }
  }
  return a1;
}

void sub_100124D20(void *a1, void *a2)
{
  uint64_t v4 = a2[5];
  a1[5] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    unint64_t v5 = a1[5];
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  uint64_t v6 = a2[7];
  a1[6] = a2[6];
  a1[7] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_100124D78(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10000B678(v2);
  }
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (v3)
  {
    dispatch_group_leave(v3);
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (v4)
    {
      dispatch_release(v4);
    }
  }
}

void sub_100124DD4(void *a1@<X0>, NSObject **a2@<X8>)
{
  uint64_t v4 = dispatch_group_create();
  unint64_t v5 = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(v5);
    dispatch_release(v5);
  }
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 1174405120;
  _DWORD v7[2] = sub_100124F60;
  void v7[3] = &unk_1001BE2F0;
  void v7[4] = a1;
  dispatch_group_t group = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(group);
  }
  sub_10000BA54(&v11, a1);
  uint64_t v6 = a1[2];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1001258C0;
  block[3] = &unk_1001BE388;
  void block[5] = v11;
  uint64_t v10 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v7;
  dispatch_async(v6, block);
  if (v10) {
    sub_10000B678(v10);
  }
  if (v12) {
    sub_10000B678(v12);
  }
  *a2 = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if (v5)
  {
    dispatch_group_leave(v5);
    dispatch_release(v5);
  }
}

void sub_100124F60(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = v1[4];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "service:#N Shutdown in progress", buf, 2u);
  }
  v57[0] = 0;
  v57[1] = 0;
  *(void *)long long buf = v57;
  uint64_t v3 = (uint64_t *)v1[5];
  uint64_t v51 = (uint64_t *)v1[6];
  if (v3 != v51)
  {
    unint64_t v50 = v1;
    do
    {
      (*(void (**)(unsigned char *__return_ptr))(*(void *)*v3 + 24))(v59);
      uint64_t v4 = *(unsigned __int8 **)v59;
      unint64_t v5 = *(unsigned __int8 **)&v59[8];
      if (*(void *)v59 != *(void *)&v59[8])
      {
        do
        {
          unsigned __int8 v55 = 0;
          unsigned __int8 v55 = *v4;
          BOOL v58 = &v55;
          uint64_t v6 = sub_100125C08((uint64_t **)buf, &v55, (uint64_t)&unk_1001793E0, &v58);
          uint64_t v7 = *v3;
          uint64_t v8 = v6[6];
          uint64_t v9 = v6[7];
          if (v8 >= v9)
          {
            uint64_t v11 = v6[5];
            uint64_t v12 = v8 - v11;
            if ((unint64_t)(v12 + 1) >> 61) {
              sub_10002B5E0();
            }
            uint64_t v13 = (char *)v9 - (char *)v11;
            uint64_t v14 = v13 >> 2;
            if (v13 >> 2 <= (unint64_t)(v12 + 1)) {
              uint64_t v14 = v12 + 1;
            }
            if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v15 = v14;
            }
            if (v15) {
              dispatch_time_t v16 = (char *)sub_100038500((uint64_t)(v6 + 7), v15);
            }
            else {
              dispatch_time_t v16 = 0;
            }
            intptr_t v17 = (uint64_t *)&v16[8 * v12];
            uint64_t *v17 = v7;
            uint64_t v10 = v17 + 1;
            unint64_t v19 = v6[5];
            char v18 = v6[6];
            if (v18 != v19)
            {
              do
              {
                uint64_t v20 = *--v18;
                *--intptr_t v17 = v20;
              }
              while (v18 != v19);
              char v18 = v6[5];
            }
            void v6[5] = v17;
            v6[6] = v10;
            v6[7] = (uint64_t *)&v16[8 * v15];
            if (v18) {
              operator delete(v18);
            }
          }
          else
          {
            uint64_t *v8 = v7;
            uint64_t v10 = v8 + 1;
          }
          v6[6] = v10;
          ++v4;
        }
        while (v4 != v5);
        uint64_t v4 = *(unsigned __int8 **)v59;
      }
      if (v4)
      {
        *(void *)&v59[8] = v4;
        operator delete(v4);
      }
      ++v3;
    }
    while (v3 != v51);
    unint64_t v21 = *(void ***)buf;
    int v22 = v50;
    if (*(void ***)buf != v57)
    {
      while (1)
      {
        dispatch_time_t v23 = v22[4];
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v24 = *((char *)v21 + 32);
          std::string v25 = "???";
          if (v24 <= 5) {
            std::string v25 = off_1001BE420[v24];
          }
          uint64_t v26 = v21[6] - v21[5];
          *(_DWORD *)uint64_t v59 = 136315394;
          *(void *)&v59[4] = v25;
          *(_WORD *)&v59[12] = 2048;
          *(void *)&v59[14] = v26;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "service:#N ---- Shutdown stage %s: Notify :: %zd interested parties", v59, 0x16u);
        }
        std::string::size_type v27 = dispatch_group_create();
        unint64_t v28 = dispatch_group_create();
        uint64_t v29 = dispatch_group_create();
        uint64_t v30 = v29;
        if (v29)
        {
          dispatch_retain(v29);
          dispatch_group_enter(v30);
          dispatch_release(v30);
        }
        if (v28)
        {
          dispatch_retain(v28);
          dispatch_group_enter(v28);
        }
        int8x16_t v54 = v27;
        if (v27) {
          dispatch_retain(v27);
        }
        uint64_t v53 = v30;
        if (v30) {
          dispatch_retain(v30);
        }
        unint64_t v52 = v28;
        if (!v28) {
          break;
        }
        dispatch_retain(v28);
        sub_100123CC0((dispatch_group_t *)v59, &v54, &v53, &v52);
        dispatch_release(v28);
        if (v30) {
          goto LABEL_42;
        }
LABEL_43:
        if (v27) {
          dispatch_release(v27);
        }
        uint64_t v31 = v21[5];
        char v32 = v21[6];
        while (v31 != v32)
        {
          (*(void (**)(void, void, unsigned char *))(*(void *)*v31 + 32))(*v31, *((unsigned __int8 *)v21 + 32), v59);
          ++v31;
        }
        if (*(void *)&v59[16])
        {
          dispatch_group_leave(*(dispatch_group_t *)&v59[16]);
          if (*(void *)&v59[16]) {
            dispatch_release(*(dispatch_object_t *)&v59[16]);
          }
        }
        int v22 = v50;
        if (*(void *)&v59[8])
        {
          dispatch_group_leave(*(dispatch_group_t *)&v59[8]);
          if (*(void *)&v59[8]) {
            dispatch_release(*(dispatch_object_t *)&v59[8]);
          }
        }
        if (*(void *)v59)
        {
          dispatch_group_leave(*(dispatch_group_t *)v59);
          if (*(void *)v59) {
            dispatch_release(*(dispatch_object_t *)v59);
          }
        }
        dispatch_time_t v33 = dispatch_time(0, 10000000000);
        intptr_t v34 = dispatch_group_wait(v27, v33);
        unsigned __int8 v35 = v50[4];
        if (v34 && os_log_type_enabled((os_log_t)v50[4], OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v36 = *((char *)v21 + 32);
          std::runtime_error v37 = "???";
          if (v36 <= 5) {
            std::runtime_error v37 = off_1001BE420[v36];
          }
          *(_DWORD *)uint64_t v59 = 136315138;
          *(void *)&v59[4] = v37;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "service:#E    - Shutdown stage %s: Perform :: TIME-OUT! proceeding anyway", v59, 0xCu);
          unsigned __int8 v35 = v50[4];
        }
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v38 = *((char *)v21 + 32);
          long long v39 = "???";
          if (v38 <= 5) {
            long long v39 = off_1001BE420[v38];
          }
          *(_DWORD *)uint64_t v59 = 136315138;
          *(void *)&v59[4] = v39;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "service:#N   -- Shutdown stage %s: Perform :: ", v59, 0xCu);
        }
        if (v30)
        {
          dispatch_group_leave(v30);
          dispatch_release(v30);
        }
        if (v28)
        {
          dispatch_group_leave(v28);
          dispatch_release(v28);
        }
        dispatch_time_t v40 = dispatch_time(0, 10000000000);
        intptr_t v41 = dispatch_group_wait(v28, v40);
        unint64_t v42 = v50[4];
        if (v41 && os_log_type_enabled((os_log_t)v50[4], OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v43 = *((char *)v21 + 32);
          uint64_t v44 = "???";
          if (v43 <= 5) {
            uint64_t v44 = off_1001BE420[v43];
          }
          *(_DWORD *)uint64_t v59 = 136315138;
          *(void *)&v59[4] = v44;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "service:#E    - Shutdown stage %s: Perform :: TIME-OUT! proceeding anyway", v59, 0xCu);
          unint64_t v42 = v50[4];
        }
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v45 = *((char *)v21 + 32);
          uint64_t v46 = "???";
          if (v45 <= 5) {
            uint64_t v46 = off_1001BE420[v45];
          }
          *(_DWORD *)uint64_t v59 = 136315138;
          *(void *)&v59[4] = v46;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "service:#N   -- Shutdown stage %s: Done.", v59, 0xCu);
        }
        if (v28) {
          dispatch_release(v28);
        }
        if (v27) {
          dispatch_release(v27);
        }
        uint64_t v47 = v21[1];
        if (v47)
        {
          do
          {
            uint64_t v48 = (void **)v47;
            uint64_t v47 = (void *)*v47;
          }
          while (v47);
        }
        else
        {
          do
          {
            uint64_t v48 = (void **)v21[2];
            BOOL v49 = *v48 == v21;
            unint64_t v21 = v48;
          }
          while (!v49);
        }
        unint64_t v21 = v48;
        if (v48 == v57) {
          goto LABEL_92;
        }
      }
      sub_100123CC0((dispatch_group_t *)v59, &v54, &v53, &v52);
      if (!v30) {
        goto LABEL_43;
      }
LABEL_42:
      dispatch_release(v30);
      goto LABEL_43;
    }
  }
LABEL_92:
  sub_1000CD3E4((uint64_t)buf, v57[0]);
}

void sub_1001255BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
}

void sub_10012564C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1001256C4(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[2], v1, (dispatch_function_t)sub_10012579C);
  __cxa_rethrow();
}

void sub_1001256EC(_Unwind_Exception *a1)
{
}

void sub_100125704(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10012573C(uint64_t a1)
{
}

uint64_t sub_100125758(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10012579C(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void *)result;
    uint64_t v2 = (void **)(result + 40);
    sub_100125800(&v2);
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 4));
    sub_100029804(v1);
    operator delete();
  }
  return result;
}

void sub_100125800(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_100125854(v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void *sub_100125854(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = (void *)*result;
  uint64_t v3 = (void *)result[1];
  while (v3 != v2)
  {
    uint64_t v4 = (void *)*--v3;
    uint64_t result = v4;
    void *v3 = 0;
    if (v4) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  v1[1] = v2;
  return result;
}

uint64_t sub_1001258C0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1001258D0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1001258EC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10000B678(v1);
  }
}

void sub_1001258FC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1001BE3C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10012591C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1001BE3C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100125970(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1001259AC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100125A24((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100125A24(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  void v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    uint64_t v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  sub_100125ABC((uint64_t)v13);
  return v11;
}

uint64_t sub_100125ABC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100125AF4((void *)a1);
  }
  return a1;
}

void *sub_100125AF4(void *result)
{
  uint64_t v1 = *(void ***)(result[2] + 8);
  uint64_t v2 = *(void ***)(result[1] + 8);
  while (v1 != v2)
  {
    uint64_t result = *v1;
    std::__shared_weak_count *v1 = 0;
    if (result) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
    ++v1;
  }
  return result;
}

void **sub_100125B5C(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void *sub_100125B94(void *result, uint64_t a2)
{
  uint64_t v2 = result[2];
  if (v2 != a2)
  {
    uint64_t v4 = result;
    do
    {
      void v4[2] = v2 - 8;
      uint64_t result = *(void **)(v2 - 8);
      *(void *)(v2 - 8) = 0;
      if (result) {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      }
      uint64_t v2 = v4[2];
    }
    while (v2 != a2);
  }
  return result;
}

uint64_t **sub_100125C08(uint64_t **a1, unsigned __int8 *a2, uint64_t a3, unsigned char **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unsigned int v10 = *((unsigned __int8 *)v6 + 32);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x40uLL);
    v11[32] = **a4;
    *((void *)v11 + 6) = 0;
    *((void *)v11 + 7) = 0;
    *((void *)v11 + 5) = 0;
    sub_10001716C(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t sub_100125DC0()
{
  return swift_retain();
}

uint64_t sub_100125E0C(uint64_t a1)
{
  uint64_t v3 = (void *)(v1 + OBJC_IVAR___WISXPCServer_listener);
  swift_beginAccess();
  void *v3 = a1;
  return swift_release();
}

uint64_t (*sub_100125E60())()
{
  return j__swift_endAccess;
}

Swift::Int sub_100125EC0()
{
  return Hasher._finalize()();
}

void sub_100125F04()
{
}

Swift::Int sub_100125F2C()
{
  return Hasher._finalize()();
}

uint64_t sub_100125F7C()
{
  uint64_t v2 = v0;
  uint64_t ObjectType = swift_getObjectType();
  type metadata accessor for XPCListener.InitializationOptions();
  __chkstk_darwin();
  uint64_t v4 = swift_allocObject();
  swift_unknownObjectWeakInit();
  uint64_t v5 = swift_allocObject();
  *(void *)(v5 + 16) = v4;
  *(void *)(v5 + 24) = ObjectType;
  swift_bridgeObjectRetain();
  swift_retain();
  static XPCListener.InitializationOptions.none.getter();
  type metadata accessor for XPCListener();
  swift_allocObject();
  uint64_t v6 = XPCListener.init(service:targetQueue:options:incomingSessionHandler:)();
  uint64_t result = swift_release();
  if (!v1) {
    return (*(uint64_t (**)(uint64_t))((swift_isaMask & *v2) + 0x68))(v6);
  }
  return result;
}

void sub_100126114(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = type metadata accessor for Logger();
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin();
  uint64_t v7 = (char *)v15 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  swift_beginAccess();
  uint64_t Strong = swift_unknownObjectWeakLoadStrong();
  if (Strong)
  {
    uint64_t v9 = (void *)Strong;
    type metadata accessor for audit_token_t();
    XPCListener.IncomingSessionRequest.withUnsafeAuditToken<A>(_:)();
    if (sub_10012742C(v15[1], v15[2], v15[3], v15[4]))
    {
      uint64_t v10 = swift_allocObject();
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = a3;
      id v11 = v9;
      dispatch thunk of XPCListener.IncomingSessionRequest.accept(incomingMessageHandler:cancellationHandler:)();

      swift_release();
    }
    else
    {
      sub_1001263C0((uint64_t)&off_1001BE4A0, (uint64_t)v7);
      uint64_t v12 = Logger.logObject.getter();
      os_log_type_t v13 = static os_log_type_t.error.getter();
      if (os_log_type_enabled(v12, v13))
      {
        char v14 = (uint8_t *)swift_slowAlloc();
        *(_WORD *)char v14 = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, v13, "Missing entitlement.", v14, 2u);
        swift_slowDealloc();
      }

      (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
      dispatch thunk of XPCListener.IncomingSessionRequest.reject(reason:)();
    }
  }
  else
  {
    dispatch thunk of XPCListener.IncomingSessionRequest.reject(reason:)();
  }
}

uint64_t sub_10012639C@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  *a5 = result;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return result;
}

uint64_t sub_1001263C0@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  (*(void (**)(void))(a1 + 16))();
  if (v3)
  {
    return Logger.init(subsystem:category:)();
  }
  else
  {
    if (qword_1001D7E90 != -1) {
      swift_once();
    }
    uint64_t v5 = type metadata accessor for Logger();
    uint64_t v6 = sub_100127548(v5, (uint64_t)qword_1001D7E98);
    uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16);
    return v7(a2, v6, v5);
  }
}

uint64_t sub_1001264C0(uint64_t a1, void *a2)
{
  uint64_t v4 = type metadata accessor for Logger();
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin();
  uint64_t v7 = (char *)&v12 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1001263C0((uint64_t)&off_1001BE4A0, (uint64_t)v7);
  unsigned int v8 = Logger.logObject.getter();
  os_log_type_t v9 = static os_log_type_t.debug.getter();
  if (os_log_type_enabled(v8, v9))
  {
    uint64_t v10 = (uint8_t *)swift_slowAlloc();
    *(_WORD *)uint64_t v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, v9, "Received message.", v10, 2u);
    swift_slowDealloc();
  }

  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  return (*(uint64_t (**)(uint64_t))((swift_isaMask & *a2) + 0x80))(a1);
}

uint64_t sub_1001266E0@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v30 = a1;
  uint64_t ObjectType = swift_getObjectType();
  uint64_t v1 = type metadata accessor for Logger();
  uint64_t v2 = *(void *)(v1 - 8);
  ((void (*)(void))__chkstk_darwin)();
  uint64_t v4 = (char *)&v26 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100127580(&qword_1001D7B80);
  ((void (*)(void))__chkstk_darwin)();
  uint64_t v6 = (char *)&v26 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = type metadata accessor for WIS.XPC.ServicePredictionRequest();
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = ((uint64_t (*)(void))__chkstk_darwin)();
  id v11 = (char *)&v26 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v9);
  os_log_type_t v13 = (char *)&v26 - v12;
  sub_100127624(&qword_1001D7B88, (void (*)(uint64_t))&type metadata accessor for WIS.XPC.ServicePredictionRequest);
  XPCReceivedMessage.decode<A>(as:)();
  uint64_t v27 = v2;
  uint64_t v28 = v1;
  (*(void (**)(char *, void, uint64_t, uint64_t))(v8 + 56))(v6, 0, 1, v7);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v8 + 48))(v6, 1, v7) == 1)
  {
    uint64_t result = sub_1001275C4((uint64_t)v6);
    long long v15 = v30;
    *(_OWORD *)uint64_t v30 = 0u;
    *((_OWORD *)v15 + 1) = 0u;
    v15[4] = 0;
  }
  else
  {
    long long v16 = v13;
    (*(void (**)(char *, char *, uint64_t))(v8 + 32))(v13, v6, v7);
    intptr_t v17 = v4;
    sub_1001263C0((uint64_t)&off_1001BE4A0, (uint64_t)v4);
    (*(void (**)(char *, char *, uint64_t))(v8 + 16))(v11, v16, v7);
    char v18 = Logger.logObject.getter();
    os_log_type_t v19 = static os_log_type_t.debug.getter();
    if (os_log_type_enabled(v18, v19))
    {
      uint64_t v20 = (uint8_t *)swift_slowAlloc();
      uint64_t v32 = swift_slowAlloc();
      uint64_t ObjectType = (uint64_t)v16;
      *(_DWORD *)uint64_t v20 = 136315138;
      uint64_t v26 = v20 + 4;
      uint64_t v21 = WIS.XPC.ServicePredictionRequest.name.getter();
      uint64_t v31 = sub_100126D40(v21, v22, &v32);
      UnsafeMutableRawBufferPointer.copyMemory(from:)();
      swift_bridgeObjectRelease();
      dispatch_time_t v23 = *(void (**)(char *, uint64_t))(v8 + 8);
      v23(v11, v7);
      _os_log_impl((void *)&_mh_execute_header, v18, v19, "Received %s request ", v20, 0xCu);
      swift_arrayDestroy();
      long long v16 = (char *)ObjectType;
      swift_slowDealloc();
      swift_slowDealloc();
    }
    else
    {
      dispatch_time_t v23 = *(void (**)(char *, uint64_t))(v8 + 8);
      v23(v11, v7);
    }

    (*(void (**)(char *, uint64_t))(v27 + 8))(v17, v28);
    uint64_t v24 = type metadata accessor for WIS.XPC.ServicePredictionResponse();
    std::string v25 = v30;
    v30[3] = v24;
    v25[4] = sub_100127624(&qword_1001D7B90, (void (*)(uint64_t))&type metadata accessor for WIS.XPC.ServicePredictionResponse);
    sub_10012766C(v25);
    WIS.XPC.ServicePredictionResponse.init(predictions:)();
    return ((uint64_t (*)(char *, uint64_t))v23)(v16, v7);
  }
  return result;
}

id sub_100126C30()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for XPCServer();
  return objc_msgSendSuper2(&v2, "dealloc");
}

uint64_t sub_100126CBC()
{
  uint64_t v0 = type metadata accessor for Logger();
  sub_100127928(v0, qword_1001D7E98);
  sub_100127548(v0, (uint64_t)qword_1001D7E98);
  return Logger.init(subsystem:category:)();
}

uint64_t sub_100126D40(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  uint64_t v6 = sub_100126E14(v12, 0, 0, 1, a1, a2);
  uint64_t v7 = v12[0];
  if (v6)
  {
    uint64_t v8 = v6;
    uint64_t ObjectType = (void *)swift_getObjectType();
    v12[0] = v8;
    uint64_t v9 = *a3;
    if (*a3)
    {
      sub_1001278C8((uint64_t)v12, *a3);
      *a3 = v9 + 32;
    }
  }
  else
  {
    uint64_t ObjectType = &type metadata for _StringGuts;
    v12[0] = a1;
    v12[1] = a2;
    uint64_t v10 = *a3;
    if (*a3)
    {
      sub_1001278C8((uint64_t)v12, *a3);
      *a3 = v10 + 32;
    }
    swift_bridgeObjectRetain();
  }
  sub_100127878((uint64_t)v12);
  return v7;
}

uint64_t sub_100126E14(uint64_t *a1, char *__dst, uint64_t a3, char a4, uint64_t a5, unint64_t a6)
{
  if ((a6 & 0x2000000000000000) != 0)
  {
    if ((a4 & 1) == 0)
    {
      if (__dst)
      {
        uint64_t v11 = HIBYTE(a6) & 0xF;
        if (a3 - (uint64_t)__dst > v11)
        {
          __src[0] = a5;
          __src[1] = a6 & 0xFFFFFFFFFFFFFFLL;
          if (__src >= (void *)&__dst[v11] || (char *)__src + v11 <= __dst)
          {
            memcpy(__dst, __src, HIBYTE(a6) & 0xF);
            UnsafeMutableRawBufferPointer.subscript.setter();
            uint64_t result = 0;
            *a1 = (uint64_t)__dst;
            return result;
          }
          goto LABEL_17;
        }
      }
    }
LABEL_13:
    uint64_t result = sub_100126FD0(a5, a6);
    *a1 = v12;
    return result;
  }
  if ((a6 & 0x1000000000000000) != 0) {
    goto LABEL_13;
  }
  if ((a5 & 0x1000000000000000) != 0)
  {
    uint64_t v8 = (a6 & 0xFFFFFFFFFFFFFFFLL) + 32;
    goto LABEL_5;
  }
  uint64_t v8 = _StringObject.sharedUTF8.getter();
  if (!v8)
  {
    _assertionFailure(_:_:file:line:flags:)();
    __break(1u);
LABEL_17:
    uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)();
    __break(1u);
    return result;
  }
LABEL_5:
  *a1 = v8;
  if ((a6 & 0x8000000000000000) != 0) {
    return 0;
  }
  else {
    return swift_unknownObjectRetain();
  }
}

uint64_t sub_100126FD0(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = (uint64_t)sub_100127068(a1, a2);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
    uint64_t v2 = sub_100127248(0, *(void *)(v2 + 16) + 1, 1, (char *)v2);
  }
  unint64_t v4 = *(void *)(v2 + 16);
  unint64_t v3 = *(void *)(v2 + 24);
  if (v4 >= v3 >> 1) {
    uint64_t v2 = sub_100127248(v3 > 1, v4 + 1, 1, (char *)v2);
  }
  *(void *)(v2 + 16) = v4 + 1;
  *(unsigned char *)(v2 + 32 + v4) = 0;
  return v2;
}

void *sub_100127068(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x1000000000000000) != 0) {
    goto LABEL_10;
  }
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v2 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v2 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v2)
  {
    while (1)
    {
      unint64_t v3 = sub_1001271E0(v2, 0);
      if (v2 < 0) {
        break;
      }
      unint64_t v4 = v3;
      uint64_t v5 = _StringGuts.copyUTF8(into:)();
      if (v6) {
        goto LABEL_14;
      }
      if (v5 == v2) {
        return v4;
      }
      _assertionFailure(_:_:file:line:flags:)();
      __break(1u);
LABEL_10:
      uint64_t v2 = String.UTF8View._foreignCount()();
      if (!v2) {
        return &_swiftEmptyArrayStorage;
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)();
    __break(1u);
LABEL_14:
    uint64_t result = (void *)_assertionFailure(_:_:file:line:flags:)();
    __break(1u);
  }
  else
  {
    return &_swiftEmptyArrayStorage;
  }
  return result;
}

void *sub_1001271E0(uint64_t a1, uint64_t a2)
{
  if (a2 <= a1) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = a2;
  }
  if (!v2) {
    return &_swiftEmptyArrayStorage;
  }
  sub_100127580(&qword_1001D7BC8);
  unint64_t v4 = (void *)swift_allocObject();
  size_t v5 = j__malloc_size(v4);
  void v4[2] = a1;
  v4[3] = 2 * v5 - 64;
  return v4;
}

uint64_t sub_100127248(char a1, int64_t a2, char a3, char *a4)
{
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_30;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  int64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    int64_t v9 = *((void *)a4 + 2);
  }
  else {
    int64_t v9 = v7;
  }
  if (v9)
  {
    sub_100127580(&qword_1001D7BC8);
    uint64_t v10 = (char *)swift_allocObject();
    size_t v11 = j__malloc_size(v10);
    *((void *)v10 + 2) = v8;
    *((void *)v10 + 3) = 2 * v11 - 64;
  }
  else
  {
    uint64_t v10 = (char *)&_swiftEmptyArrayStorage;
  }
  uint64_t v12 = v10 + 32;
  os_log_type_t v13 = a4 + 32;
  if (a1)
  {
    if (v10 != a4 || v12 >= &v13[v8]) {
      memmove(v12, v13, v8);
    }
    *((void *)a4 + 2) = 0;
    goto LABEL_28;
  }
  if (v13 >= &v12[v8] || v12 >= &v13[v8])
  {
    memcpy(v12, v13, v8);
LABEL_28:
    swift_bridgeObjectRelease();
    return (uint64_t)v10;
  }
LABEL_30:
  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

uint64_t sub_100127398()
{
  return 0x6576726553435058;
}

uint64_t sub_1001273B4()
{
  swift_unknownObjectWeakDestroy();

  return _swift_deallocObject(v0, 24, 7);
}

uint64_t sub_1001273EC()
{
  swift_release();

  return _swift_deallocObject(v0, 32, 7);
}

void sub_100127424(uint64_t a1)
{
  sub_100126114(a1, *(void *)(v1 + 16), *(void *)(v1 + 24));
}

uint64_t sub_10012742C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)token.val = a1;
  *(void *)&token.val[2] = a2;
  *(void *)&token.val[4] = a3;
  *(void *)&token.val[6] = a4;
  SecTaskRef v4 = SecTaskCreateWithAuditToken(0, &token);
  if (!v4) {
    __break(1u);
  }
  size_t v5 = v4;
  *(void *)token.val = 0;
  unint64_t v6 = (__CFString *)String._bridgeToObjectiveC()();
  CFTypeRef v7 = SecTaskCopyValueForEntitlement(v5, v6, (CFErrorRef *)&token);

  if (*(void *)token.val)
  {
    swift_unknownObjectRelease();
  }
  else if (v7 && (swift_dynamicCast() & 1) != 0)
  {
    return v9;
  }
  return 0;
}

uint64_t sub_100127548(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(*(void *)(a1 - 8) + 82) & 2) != 0) {
    return *(void *)a2;
  }
  return a2;
}

uint64_t sub_100127580(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContext2();
    *a1 = result;
  }
  return result;
}

uint64_t sub_1001275C4(uint64_t a1)
{
  uint64_t v2 = sub_100127580(&qword_1001D7B80);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

uint64_t sub_100127624(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t *sub_10012766C(uint64_t *a1)
{
  uint64_t v1 = a1;
  if ((*(unsigned char *)(*(void *)(a1[3] - 8) + 82) & 2) != 0)
  {
    *a1 = swift_allocBox();
    return (uint64_t *)v2;
  }
  return v1;
}

uint64_t type metadata accessor for XPCServer()
{
  return self;
}

unint64_t sub_1001276F8()
{
  unint64_t result = qword_1001D7B98;
  if (!qword_1001D7B98)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1001D7B98);
  }
  return result;
}

uint64_t getEnumTagSinglePayload for XPCServer.Error(unsigned int *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if ((a2 + 1) >= 0x10000) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 1) < 0x100) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4) {
    return *a1;
  }
  if (v3 == 2) {
    return *(unsigned __int16 *)a1;
  }
  return *(unsigned __int8 *)a1;
}

unsigned char *storeEnumTagSinglePayload for XPCServer.Error(unsigned char *result, int a2, int a3)
{
  if ((a3 + 1) >= 0x10000) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) < 0x100) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2)
  {
    switch(v5)
    {
      case 1:
        *unint64_t result = a2;
        return result;
      case 2:
        *(_WORD *)unint64_t result = a2;
        return result;
      case 3:
        goto LABEL_19;
      case 4:
        *(_DWORD *)unint64_t result = a2;
        return result;
      default:
        return result;
    }
  }
  switch(v5)
  {
    case 1:
      *unint64_t result = 0;
      break;
    case 2:
      *(_WORD *)unint64_t result = 0;
      break;
    case 3:
LABEL_19:
      __break(1u);
      JUMPOUT(0x100127840);
    case 4:
      *(_DWORD *)unint64_t result = 0;
      break;
    default:
      return result;
  }
  return result;
}

ValueMetadata *type metadata accessor for XPCServer.Error()
{
  return &type metadata for XPCServer.Error;
}

uint64_t sub_100127878(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 24) - 8);
  if ((*(unsigned char *)(v1 + 82) & 2) != 0) {
    return swift_release();
  }
  else {
    return (*(uint64_t (**)(void))(v1 + 8))();
  }
}

uint64_t sub_1001278C8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v3;
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

uint64_t *sub_100127928(uint64_t a1, uint64_t *a2)
{
  if ((*(_DWORD *)(*(void *)(a1 - 8) + 80) & 0x20000) != 0)
  {
    uint64_t v3 = swift_slowAlloc();
    *a2 = v3;
    return (uint64_t *)v3;
  }
  return a2;
}

void type metadata accessor for audit_token_t()
{
  if (!qword_1001D7BD0)
  {
    ForeignTypeMetastd::string::pointer data = swift_getForeignTypeMetadata();
    if (!v1) {
      atomic_store(ForeignTypeMetadata, (unint64_t *)&qword_1001D7BD0);
    }
  }
}

uint64_t sub_1001279E4()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_100127A1C(uint64_t a1)
{
  return sub_1001264C0(a1, *(void **)(v1 + 16));
}

uint64_t sub_100127A24(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a1 = *a2;
  uint64_t v3 = v2 + 16;
  swift_retain();
  return v3;
}

__n128 sub_100127A58(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t sub_100127A64(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t sub_100127A84(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(void *)__n128 result = (a2 - 1);
    *(void *)(result + 8) = 0;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 32) = v3;
  return result;
}

uint64_t awd::metrics::protobuf_ShutdownFile_MetricLogHeader_2eproto(awd::metrics *this)
{
  uint64_t result = awd::metrics::MetricLog::default_instance_;
  if (awd::metrics::MetricLog::default_instance_) {
    return (*(uint64_t (**)(void))(*(void *)awd::metrics::MetricLog::default_instance_ + 8))();
  }
  return result;
}

void awd::metrics::protobuf_AddDesc_MetricLogHeader_2eproto_impl(awd::metrics *this, uint64_t a2, uint64_t a3, const char *a4)
{
}

uint64_t awd::metrics::MetricLog::MetricLog(uint64_t this)
{
  *(void *)(this + 56) = 0;
  *(void *)(this + 64) = 0;
  *(void *)this = off_1001BE678;
  *(void *)(this + 8) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(unsigned char *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(void *)(this + 24) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = 0;
  *(void *)(this + 48) = 0;
  return this;
}

void awd::metrics::protobuf_AddDesc_MetricLogHeader_2eproto(awd::metrics *this)
{
  uint64_t v1 = awd::metrics::protobuf_AddDesc_MetricLogHeader_2eproto_once_;
  __dmb(0xBu);
  if (v1 != 2)
  {
    v2[1] = awd::metrics::protobuf_AddDesc_MetricLogHeader_2eproto_impl;
    char v3 = 0;
    wireless_diagnostics::google::protobuf::GoogleOnceInitImpl();
    wireless_diagnostics::google::protobuf::internal::FunctionClosure0::~FunctionClosure0((wireless_diagnostics::google::protobuf::internal::FunctionClosure0 *)v2);
  }
}

void sub_100127C4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  wireless_diagnostics::google::protobuf::internal::FunctionClosure0::~FunctionClosure0((wireless_diagnostics::google::protobuf::internal::FunctionClosure0 *)va);
  _Unwind_Resume(a1);
}

void awd::metrics::MetricLog::MergeFrom(awd::metrics::MetricLog *this, const awd::metrics::MetricLog *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v15);
  }
  int v4 = *((_DWORD *)a2 + 14);
  if (v4)
  {
    sub_10004BAE8((uint64_t)this + 48, *((_DWORD *)this + 14) + v4);
    memcpy((void *)(*((void *)this + 6) + 4 * *((int *)this + 14)), *((const void **)a2 + 6), 4 * *((int *)a2 + 14));
    *((_DWORD *)this + 14) += *((_DWORD *)a2 + 14);
  }
  LOBYTE(v5) = *((unsigned char *)a2 + 68);
  if ((_BYTE)v5)
  {
    if (*((unsigned char *)a2 + 68))
    {
      CFTypeRef v7 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)this + 17) |= 1u;
      int64_t v8 = (std::string *)*((void *)this + 1);
      if (v8 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v8, v7);
      int v5 = *((_DWORD *)a2 + 17);
      if ((v5 & 2) == 0)
      {
LABEL_8:
        if ((v5 & 4) == 0) {
          goto LABEL_9;
        }
        goto LABEL_19;
      }
    }
    else if ((*((unsigned char *)a2 + 68) & 2) == 0)
    {
      goto LABEL_8;
    }
    char v9 = *((unsigned char *)a2 + 16);
    *((_DWORD *)this + 17) |= 2u;
    *((unsigned char *)this + 16) = v9;
    int v5 = *((_DWORD *)a2 + 17);
    if ((v5 & 4) == 0)
    {
LABEL_9:
      if ((v5 & 8) == 0) {
        goto LABEL_10;
      }
      goto LABEL_20;
    }
LABEL_19:
    int v10 = *((_DWORD *)a2 + 5);
    *((_DWORD *)this + 17) |= 4u;
    *((_DWORD *)this + 5) = v10;
    int v5 = *((_DWORD *)a2 + 17);
    if ((v5 & 8) == 0)
    {
LABEL_10:
      if ((v5 & 0x10) == 0) {
        goto LABEL_11;
      }
      goto LABEL_21;
    }
LABEL_20:
    int v11 = *((_DWORD *)a2 + 8);
    *((_DWORD *)this + 17) |= 8u;
    *((_DWORD *)this + 8) = v11;
    int v5 = *((_DWORD *)a2 + 17);
    if ((v5 & 0x10) == 0)
    {
LABEL_11:
      if ((v5 & 0x20) == 0) {
        goto LABEL_12;
      }
      goto LABEL_24;
    }
LABEL_21:
    uint64_t v12 = (const std::string *)*((void *)a2 + 3);
    *((_DWORD *)this + 17) |= 0x10u;
    os_log_type_t v13 = (std::string *)*((void *)this + 3);
    if (v13 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v13, v12);
    int v5 = *((_DWORD *)a2 + 17);
    if ((v5 & 0x20) == 0)
    {
LABEL_12:
      if ((v5 & 0x40) == 0) {
        return;
      }
      goto LABEL_13;
    }
LABEL_24:
    uint64_t v14 = *((void *)a2 + 5);
    *((_DWORD *)this + 17) |= 0x20u;
    *((void *)this + 5) = v14;
    if ((*((_DWORD *)a2 + 17) & 0x40) == 0) {
      return;
    }
LABEL_13:
    int v6 = *((_DWORD *)a2 + 9);
    *((_DWORD *)this + 17) |= 0x40u;
    *((_DWORD *)this + 9) = v6;
  }
}

void sub_100127E70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::metrics::MetricLog::~MetricLog(awd::metrics::MetricLog *this)
{
  *(void *)this = off_1001BE678;
  awd::metrics::MetricLog::SharedDtor(this);
  if (*((void *)this + 6)) {
    operator delete[]();
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::metrics::MetricLog::~MetricLog(this);

  operator delete();
}

void awd::metrics::MetricLog::SharedDtor(awd::metrics::MetricLog *this)
{
  uint64_t v1 = *((void *)this + 1);
  if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  uint64_t v3 = *((void *)this + 3);
  if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v3 != 0)
  {
    if (*(char *)(v3 + 23) < 0) {
      operator delete(*(void **)v3);
    }
    operator delete();
  }

  awd::metrics::protobuf_AddDesc_MetricLogHeader_2eproto(this);
}

void awd::metrics::MetricLog::New(awd::metrics::MetricLog *this)
{
}

uint64_t awd::metrics::MetricLog::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 68))
  {
    if (*(unsigned char *)(this + 68))
    {
      uint64_t v1 = *(void *)(this + 8);
      if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v1 + 23) < 0)
        {
          **(unsigned char **)uint64_t v1 = 0;
          *(void *)(v1 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v1 = 0;
          *(unsigned char *)(v1 + 23) = 0;
        }
      }
    }
    *(unsigned char *)(this + 16) = 0;
    *(_DWORD *)(this + 20) = 0;
    *(_DWORD *)(this + 32) = 0;
    if ((*(unsigned char *)(this + 68) & 0x10) != 0)
    {
      uint64_t v2 = *(void *)(this + 24);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
    *(void *)(this + 40) = 0;
    *(_DWORD *)(this + 36) = 0;
  }
  *(_DWORD *)(this + 56) = 0;
  *(_DWORD *)(this + 68) = 0;
  return this;
}

uint64_t awd::metrics::MetricLog::MergePartialFromCodedStream(awd::metrics::MetricLog *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  int v5 = (uint64_t *)((char *)this + 48);
  int v6 = (unsigned int *)((char *)this + 20);
  CFTypeRef v7 = (unint64_t *)((char *)this + 40);
  int64_t v8 = (unsigned int *)((char *)this + 36);
  char v9 = (unsigned int *)((char *)this + 32);
LABEL_2:
  while (2)
  {
    int v10 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v10 >= *((void *)a2 + 2) || *v10 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v10;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v10 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v12 = TagFallback & 7;
        if (v12 != 2) {
          goto LABEL_34;
        }
        *((_DWORD *)this + 17) |= 1u;
        if (*((_UNKNOWN **)this + 1) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (result)
        {
          long long v15 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
          if ((unint64_t)v15 < v14 && *v15 == 16)
          {
            long long v16 = v15 + 1;
            *((void *)a2 + 1) = v16;
            goto LABEL_18;
          }
          continue;
        }
        return result;
      case 2u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        long long v16 = (char *)*((void *)a2 + 1);
        unint64_t v14 = *((void *)a2 + 2);
LABEL_18:
        unsigned int v39 = 0;
        if ((unint64_t)v16 >= v14 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v39);
          if (!result) {
            return result;
          }
          unsigned int v17 = v39;
          char v18 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v17 = *v16;
          char v18 = v16 + 1;
          *((void *)a2 + 1) = v18;
        }
        *((unsigned char *)this + 16) = v17 != 0;
        *((_DWORD *)this + 17) |= 2u;
        if ((unint64_t)v18 < v14 && *v18 == 24)
        {
          os_log_type_t v19 = v18 + 1;
          *((void *)a2 + 1) = v19;
          goto LABEL_44;
        }
        continue;
      case 3u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        os_log_type_t v19 = (char *)*((void *)a2 + 1);
        unint64_t v14 = *((void *)a2 + 2);
LABEL_44:
        if ((unint64_t)v19 >= v14 || *v19 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v6);
          if (!result) {
            return result;
          }
          std::string v25 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
        }
        else
        {
          *int v6 = *v19;
          std::string v25 = v19 + 1;
          *((void *)a2 + 1) = v25;
        }
        *((_DWORD *)this + 17) |= 4u;
        if ((unint64_t)v25 >= v14 || *v25 != 32) {
          continue;
        }
        uint64_t v20 = v25 + 1;
        *((void *)a2 + 1) = v20;
LABEL_52:
        if ((unint64_t)v20 >= v14 || *v20 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v7);
          if (!result) {
            return result;
          }
          uint64_t v26 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
        }
        else
        {
          unint64_t *v7 = *v20;
          uint64_t v26 = v20 + 1;
          *((void *)a2 + 1) = v26;
        }
        *((_DWORD *)this + 17) |= 0x20u;
        if ((unint64_t)v26 >= v14 || *v26 != 40) {
          continue;
        }
        uint64_t v21 = v26 + 1;
        *((void *)a2 + 1) = v21;
LABEL_60:
        if ((unint64_t)v21 >= v14 || (char)*v21 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v8);
          if (!result) {
            return result;
          }
          uint64_t v27 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int *v8 = *v21;
          uint64_t v27 = v21 + 1;
          *((void *)a2 + 1) = v27;
        }
        *((_DWORD *)this + 17) |= 0x40u;
        if ((unint64_t)v27 < v14)
        {
          int v28 = *v27;
          goto LABEL_85;
        }
        continue;
      case 4u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        uint64_t v20 = (char *)*((void *)a2 + 1);
        unint64_t v14 = *((void *)a2 + 2);
        goto LABEL_52;
      case 5u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        uint64_t v21 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v14 = *((void *)a2 + 2);
        goto LABEL_60;
      case 6u:
        int v12 = TagFallback & 7;
        if (v12 == 2)
        {
          uint64_t result = sub_100128694(a2, (uint64_t)v5);
          if (!result) {
            return result;
          }
          while (1)
          {
            uint64_t v27 = (unsigned __int8 *)*((void *)a2 + 1);
            unint64_t v14 = *((void *)a2 + 2);
            if ((unint64_t)v27 >= v14) {
              goto LABEL_2;
            }
            int v28 = *v27;
            if (v28 == 56) {
              break;
            }
LABEL_85:
            if (v28 != 48) {
              goto LABEL_2;
            }
            unint64_t v22 = (char *)(v27 + 1);
            *((void *)a2 + 1) = v22;
LABEL_67:
            unsigned int v40 = 0;
            if ((unint64_t)v22 >= v14 || *v22 < 0)
            {
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v40))return 0; {
            }
              }
            else
            {
              unsigned int v40 = *v22;
              *((void *)a2 + 1) = v22 + 1;
            }
            int v29 = *((_DWORD *)this + 14);
            if (v29 == *((_DWORD *)this + 15))
            {
              sub_10004BAE8((uint64_t)v5, v29 + 1);
              int v29 = *((_DWORD *)this + 14);
            }
            unsigned int v30 = v40;
            uint64_t v31 = *((void *)this + 6);
            *((_DWORD *)this + 14) = v29 + 1;
            *(_DWORD *)(v31 + 4 * v29) = v30;
            int v32 = *((_DWORD *)this + 15) - *((_DWORD *)this + 14);
            if (v32 >= 1)
            {
              int v33 = v32 + 1;
              do
              {
                intptr_t v34 = (unsigned char *)*((void *)a2 + 1);
                unint64_t v35 = *((void *)a2 + 2);
                if ((unint64_t)v34 >= v35 || *v34 != 48) {
                  break;
                }
                *((void *)a2 + 1) = v34 + 1;
                if ((unint64_t)(v34 + 1) >= v35 || (char)v34[1] < 0)
                {
                  if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v40))return 0; {
                  unsigned int v36 = v40;
                  }
                  uint64_t v31 = *v5;
                }
                else
                {
                  unsigned int v36 = v34[1];
                  unsigned int v40 = v36;
                  *((void *)a2 + 1) = v34 + 2;
                }
                uint64_t v37 = *((int *)this + 14);
                *((_DWORD *)this + 14) = v37 + 1;
                *(_DWORD *)(v31 + 4 * v37) = v36;
                --v33;
              }
              while (v33 > 1);
            }
          }
          dispatch_time_t v23 = (char *)(v27 + 1);
          *((void *)a2 + 1) = v23;
LABEL_88:
          if ((unint64_t)v23 >= v14 || *v23 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v9);
            if (!result) {
              return result;
            }
            unint64_t v38 = (unsigned char *)*((void *)a2 + 1);
            unint64_t v14 = *((void *)a2 + 2);
          }
          else
          {
            unsigned int *v9 = *v23;
            unint64_t v38 = v23 + 1;
            *((void *)a2 + 1) = v38;
          }
          int v24 = *((_DWORD *)this + 17) | 8;
          *((_DWORD *)this + 17) = v24;
          if ((unint64_t)v38 < v14 && *v38 == 66)
          {
            *((void *)a2 + 1) = v38 + 1;
LABEL_96:
            *((_DWORD *)this + 17) = v24 | 0x10;
            if (*((_UNKNOWN **)this + 3) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
              operator new();
            }
            uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
            if (!result) {
              return result;
            }
            if (*((void *)a2 + 1) == *((void *)a2 + 2)
              && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
            {
              *((_DWORD *)a2 + 8) = 0;
              uint64_t result = 1;
              *((unsigned char *)a2 + 36) = 1;
              return result;
            }
          }
          continue;
        }
        if ((TagFallback & 7) == 0)
        {
          unint64_t v22 = (char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
          goto LABEL_67;
        }
LABEL_34:
        if (v12 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
      case 7u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        dispatch_time_t v23 = (char *)*((void *)a2 + 1);
        unint64_t v14 = *((void *)a2 + 2);
        goto LABEL_88;
      case 8u:
        int v12 = TagFallback & 7;
        if (v12 != 2) {
          goto LABEL_34;
        }
        int v24 = *((_DWORD *)this + 17);
        goto LABEL_96;
      default:
        int v12 = TagFallback & 7;
        goto LABEL_34;
    }
  }
}

uint64_t sub_100128694(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a2)
{
  unsigned int v13 = 0;
  int v4 = (char *)*((void *)this + 1);
  if ((unint64_t)v4 >= *((void *)this + 2) || *v4 < 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v13);
    if (!result) {
      return result;
    }
    unsigned int v5 = v13;
  }
  else
  {
    unsigned int v5 = *v4;
    unsigned int v13 = v5;
    *((void *)this + 1) = v4 + 1;
  }
  int v7 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v5);
  if ((int)wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this) >= 1)
  {
    do
    {
      unsigned int v12 = 0;
      int64_t v8 = (char *)*((void *)this + 1);
      if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v12);
        if (!result) {
          return result;
        }
      }
      else
      {
        unsigned int v12 = *v8;
        *((void *)this + 1) = v8 + 1;
      }
      int v9 = *(_DWORD *)(a2 + 8);
      if (v9 == *(_DWORD *)(a2 + 12))
      {
        sub_10004BAE8(a2, v9 + 1);
        int v9 = *(_DWORD *)(a2 + 8);
      }
      unsigned int v10 = v12;
      uint64_t v11 = *(void *)a2;
      *(_DWORD *)(a2 + 8) = v9 + 1;
      *(_DWORD *)(v11 + 4 * v9) = v10;
    }
    while ((int)wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this) > 0);
  }
  wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v7);
  return 1;
}

uint64_t awd::metrics::MetricLog::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 68);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
    int v6 = *(_DWORD *)(v5 + 68);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_16;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(unsigned __int8 *)(v5 + 16), (BOOL)a2, a4);
  int v6 = *(_DWORD *)(v5 + 68);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 0x20) == 0) {
      goto LABEL_5;
    }
    goto LABEL_17;
  }
LABEL_16:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(_DWORD *)(v5 + 20), a2, a4);
  int v6 = *(_DWORD *)(v5 + 68);
  if ((v6 & 0x20) == 0)
  {
LABEL_5:
    if ((v6 & 0x40) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
LABEL_17:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(void *)(v5 + 40), (unint64_t)a2, a4);
  if ((*(_DWORD *)(v5 + 68) & 0x40) != 0) {
LABEL_6:
  }
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, *(_DWORD *)(v5 + 36), a2, a4);
LABEL_7:
  if (*(int *)(v5 + 56) >= 1)
  {
    uint64_t v7 = 0;
    do
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, *(_DWORD *)(*(void *)(v5 + 48) + 4 * v7++), a2, a4);
    while (v7 < *(int *)(v5 + 56));
  }
  int v8 = *(_DWORD *)(v5 + 68);
  if ((v8 & 8) != 0)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, *(_DWORD *)(v5 + 32), a2, a4);
    int v8 = *(_DWORD *)(v5 + 68);
  }
  if ((v8 & 0x10) != 0)
  {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  }
  return this;
}

uint64_t awd::metrics::MetricLog::ByteSize(awd::metrics::MetricLog *this, unint64_t a2)
{
  LOBYTE(v3) = *((unsigned char *)this + 68);
  if (!(_BYTE)v3)
  {
    int v5 = 0;
    goto LABEL_45;
  }
  if (*((unsigned char *)this + 68))
  {
    uint64_t v6 = *((void *)this + 1);
    int v7 = *(unsigned __int8 *)(v6 + 23);
    char v8 = v7;
    uint64_t v9 = *(void *)(v6 + 8);
    if ((v7 & 0x80u) == 0) {
      unint64_t v10 = *(unsigned __int8 *)(v6 + 23);
    }
    else {
      unint64_t v10 = v9;
    }
    if (v10 >= 0x80)
    {
      int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v10, a2);
      int v7 = *(unsigned __int8 *)(v6 + 23);
      uint64_t v9 = *(void *)(v6 + 8);
      int v11 = v12 + 1;
      int v3 = *((_DWORD *)this + 17);
      char v8 = *(unsigned char *)(v6 + 23);
    }
    else
    {
      int v11 = 2;
    }
    if (v8 < 0) {
      int v7 = v9;
    }
    int v4 = v11 + v7;
  }
  else
  {
    int v4 = 0;
  }
  if ((v3 & 2) != 0) {
    int v5 = v4 + 2;
  }
  else {
    int v5 = v4;
  }
  if ((v3 & 4) != 0)
  {
    unsigned int v13 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 5);
    if (v13 >= 0x80)
    {
      int v14 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v13, a2) + 1;
      int v3 = *((_DWORD *)this + 17);
    }
    else
    {
      int v14 = 2;
    }
    v5 += v14;
    if ((v3 & 8) == 0)
    {
LABEL_19:
      if ((v3 & 0x10) == 0) {
        goto LABEL_20;
      }
      goto LABEL_31;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_19;
  }
  long long v15 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 8);
  if (v15 >= 0x80)
  {
    int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v15, a2) + 1;
    int v3 = *((_DWORD *)this + 17);
  }
  else
  {
    int v16 = 2;
  }
  v5 += v16;
  if ((v3 & 0x10) == 0)
  {
LABEL_20:
    if ((v3 & 0x20) == 0) {
      goto LABEL_21;
    }
    goto LABEL_40;
  }
LABEL_31:
  uint64_t v17 = *((void *)this + 3);
  int v18 = *(unsigned __int8 *)(v17 + 23);
  char v19 = v18;
  uint64_t v20 = *(void *)(v17 + 8);
  if ((v18 & 0x80u) == 0) {
    unint64_t v21 = *(unsigned __int8 *)(v17 + 23);
  }
  else {
    unint64_t v21 = v20;
  }
  if (v21 >= 0x80)
  {
    int v22 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v21, a2);
    int v18 = *(unsigned __int8 *)(v17 + 23);
    uint64_t v20 = *(void *)(v17 + 8);
    int v3 = *((_DWORD *)this + 17);
    char v19 = *(unsigned char *)(v17 + 23);
  }
  else
  {
    int v22 = 1;
  }
  if (v19 < 0) {
    int v18 = v20;
  }
  v5 += v22 + v18 + 1;
  if ((v3 & 0x20) == 0)
  {
LABEL_21:
    if ((v3 & 0x40) == 0) {
      goto LABEL_45;
    }
    goto LABEL_41;
  }
LABEL_40:
  v5 += wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 5), a2)+ 1;
  if ((*((_DWORD *)this + 17) & 0x40) == 0) {
    goto LABEL_45;
  }
LABEL_41:
  dispatch_time_t v23 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 9);
  if (v23 >= 0x80) {
    int v24 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v23, a2) + 1;
  }
  else {
    int v24 = 2;
  }
  v5 += v24;
LABEL_45:
  int v25 = *((_DWORD *)this + 14);
  if (v25 < 1)
  {
    int v27 = 0;
  }
  else
  {
    uint64_t v26 = 0;
    int v27 = 0;
    do
    {
      int v28 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(*((void *)this + 6)
                                                                                             + 4 * v26);
      if (v28 >= 0x80)
      {
        int v29 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v28, a2);
        int v25 = *((_DWORD *)this + 14);
      }
      else
      {
        int v29 = 1;
      }
      v27 += v29;
      ++v26;
    }
    while (v26 < v25);
  }
  uint64_t result = (v27 + v5 + v25);
  *((_DWORD *)this + 16) = result;
  return result;
}

uint64_t awd::metrics::MetricLog::IsInitialized(awd::metrics::MetricLog *this)
{
  return 1;
}

void *awd::metrics::MetricLog::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.MetricLog");
}

uint64_t sub_100128AF4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t awd::metrics::protobuf_ShutdownFile_MetricFile_2eproto(awd::metrics *this)
{
  uint64_t result = awd::metrics::MetricFile::default_instance_;
  if (awd::metrics::MetricFile::default_instance_) {
    return (*(uint64_t (**)(void))(*(void *)awd::metrics::MetricFile::default_instance_ + 8))();
  }
  return result;
}

void awd::metrics::protobuf_AddDesc_MetricFile_2eproto_impl(awd::metrics *this, uint64_t a2, uint64_t a3, const char *a4)
{
  int v4 = (awd::metrics *)wireless_diagnostics::google::protobuf::internal::VerifyVersion((wireless_diagnostics::google::protobuf::internal *)0x1E9808, 2005000, (int)"/Library/Caches/com.apple.xbs/Sources/WirelessInsightsExecutables/AWDMetrics/cpp/MetricFile.pb.cc", a4);
  awd::metrics::protobuf_AddDesc_MetricLog_2eproto(v4);
  operator new();
}

uint64_t awd::metrics::MetricFile::MetricFile(uint64_t this)
{
  *(_DWORD *)(this + 112) = 0;
  *(void *)this = off_1001BE708;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(this + 24) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(_DWORD *)(this + 44) = 0;
  *(void *)(this + 128) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(this + 136) = 0;
  *(void *)(this + 32) = 0;
  *(unsigned char *)(this + 40) = 0;
  *(void *)(this + 48) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(this + 56) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(this + 64) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(this + 72) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(this + 96) = 0;
  *(void *)(this + 104) = 0;
  *(void *)(this + 80) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(this + 88) = 0;
  *(void *)(this + 120) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(_DWORD *)(this + 144) = 0;
  return this;
}

void awd::metrics::protobuf_AddDesc_MetricFile_2eproto(awd::metrics *this)
{
  uint64_t v1 = awd::metrics::protobuf_AddDesc_MetricFile_2eproto_once_;
  __dmb(0xBu);
  if (v1 != 2)
  {
    v2[1] = awd::metrics::protobuf_AddDesc_MetricFile_2eproto_impl;
    char v3 = 0;
    wireless_diagnostics::google::protobuf::GoogleOnceInitImpl();
    wireless_diagnostics::google::protobuf::internal::FunctionClosure0::~FunctionClosure0((wireless_diagnostics::google::protobuf::internal::FunctionClosure0 *)v2);
  }
}

void sub_100128CD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  wireless_diagnostics::google::protobuf::internal::FunctionClosure0::~FunctionClosure0((wireless_diagnostics::google::protobuf::internal::FunctionClosure0 *)va);
  _Unwind_Resume(a1);
}

void awd::metrics::MetricFile::MergeFrom(awd::metrics::MetricFile *this, const awd::metrics::MetricFile *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v35);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::metrics::MetricFile *)((char *)this + 96), *((_DWORD *)a2 + 26) + *((_DWORD *)this + 26));
  if (*((int *)a2 + 26) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      int v5 = *(const awd::metrics::MetricLog **)(*((void *)a2 + 12) + 8 * v4);
      int v6 = *((_DWORD *)this + 27);
      uint64_t v7 = *((int *)this + 26);
      if ((int)v7 >= v6)
      {
        if (v6 == *((_DWORD *)this + 28))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::metrics::MetricFile *)((char *)this + 96), v6 + 1);
          int v6 = *((_DWORD *)this + 27);
        }
        *((_DWORD *)this + 27) = v6 + 1;
        sub_10012A940();
      }
      uint64_t v8 = *((void *)this + 12);
      *((_DWORD *)this + 26) = v7 + 1;
      awd::metrics::MetricLog::MergeFrom(*(awd::metrics::MetricLog **)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *((int *)a2 + 26));
  }
  int v9 = *((_DWORD *)a2 + 36);
  if (!(_BYTE)v9) {
    goto LABEL_21;
  }
  if (v9)
  {
    uint64_t v11 = *((void *)a2 + 1);
    *((_DWORD *)this + 36) |= 1u;
    *((void *)this + 1) = v11;
    int v9 = *((_DWORD *)a2 + 36);
    if ((v9 & 2) == 0)
    {
LABEL_14:
      if ((v9 & 4) == 0) {
        goto LABEL_15;
      }
      goto LABEL_35;
    }
  }
  else if ((v9 & 2) == 0)
  {
    goto LABEL_14;
  }
  int v12 = (const std::string *)*((void *)a2 + 2);
  *((_DWORD *)this + 36) |= 2u;
  unsigned int v13 = (std::string *)*((void *)this + 2);
  if (v13 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v13, v12);
  int v9 = *((_DWORD *)a2 + 36);
  if ((v9 & 4) == 0)
  {
LABEL_15:
    if ((v9 & 8) == 0) {
      goto LABEL_16;
    }
    goto LABEL_38;
  }
LABEL_35:
  int v14 = (const std::string *)*((void *)a2 + 3);
  *((_DWORD *)this + 36) |= 4u;
  long long v15 = (std::string *)*((void *)this + 3);
  if (v15 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v15, v14);
  int v9 = *((_DWORD *)a2 + 36);
  if ((v9 & 8) == 0)
  {
LABEL_16:
    if ((v9 & 0x10) == 0) {
      goto LABEL_17;
    }
    goto LABEL_39;
  }
LABEL_38:
  int v16 = *((_DWORD *)a2 + 8);
  *((_DWORD *)this + 36) |= 8u;
  *((_DWORD *)this + 8) = v16;
  int v9 = *((_DWORD *)a2 + 36);
  if ((v9 & 0x10) == 0)
  {
LABEL_17:
    if ((v9 & 0x20) == 0) {
      goto LABEL_18;
    }
LABEL_40:
    char v18 = *((unsigned char *)a2 + 40);
    *((_DWORD *)this + 36) |= 0x20u;
    *((unsigned char *)this + 40) = v18;
    int v9 = *((_DWORD *)a2 + 36);
    if ((v9 & 0x40) == 0)
    {
LABEL_19:
      if ((v9 & 0x80) == 0) {
        goto LABEL_21;
      }
      goto LABEL_20;
    }
    goto LABEL_41;
  }
LABEL_39:
  int v17 = *((_DWORD *)a2 + 9);
  *((_DWORD *)this + 36) |= 0x10u;
  *((_DWORD *)this + 9) = v17;
  int v9 = *((_DWORD *)a2 + 36);
  if ((v9 & 0x20) != 0) {
    goto LABEL_40;
  }
LABEL_18:
  if ((v9 & 0x40) == 0) {
    goto LABEL_19;
  }
LABEL_41:
  int v19 = *((_DWORD *)a2 + 11);
  *((_DWORD *)this + 36) |= 0x40u;
  *((_DWORD *)this + 11) = v19;
  int v9 = *((_DWORD *)a2 + 36);
  if ((v9 & 0x80) != 0)
  {
LABEL_20:
    int v10 = *((_DWORD *)a2 + 34);
    *((_DWORD *)this + 36) |= 0x80u;
    *((_DWORD *)this + 34) = v10;
    int v9 = *((_DWORD *)a2 + 36);
  }
LABEL_21:
  if ((v9 & 0xFF00) == 0) {
    goto LABEL_29;
  }
  if ((v9 & 0x100) != 0)
  {
    uint64_t v20 = (const std::string *)*((void *)a2 + 6);
    *((_DWORD *)this + 36) |= 0x100u;
    unint64_t v21 = (std::string *)*((void *)this + 6);
    if (v21 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v21, v20);
    int v9 = *((_DWORD *)a2 + 36);
    if ((v9 & 0x200) == 0)
    {
LABEL_24:
      if ((v9 & 0x400) == 0) {
        goto LABEL_25;
      }
      goto LABEL_49;
    }
  }
  else if ((v9 & 0x200) == 0)
  {
    goto LABEL_24;
  }
  int v22 = (const std::string *)*((void *)a2 + 7);
  *((_DWORD *)this + 36) |= 0x200u;
  dispatch_time_t v23 = (std::string *)*((void *)this + 7);
  if (v23 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v23, v22);
  int v9 = *((_DWORD *)a2 + 36);
  if ((v9 & 0x400) == 0)
  {
LABEL_25:
    if ((v9 & 0x800) == 0) {
      goto LABEL_26;
    }
    goto LABEL_52;
  }
LABEL_49:
  int v24 = (const std::string *)*((void *)a2 + 8);
  *((_DWORD *)this + 36) |= 0x400u;
  int v25 = (std::string *)*((void *)this + 8);
  if (v25 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v25, v24);
  int v9 = *((_DWORD *)a2 + 36);
  if ((v9 & 0x800) == 0)
  {
LABEL_26:
    if ((v9 & 0x1000) == 0) {
      goto LABEL_27;
    }
    goto LABEL_55;
  }
LABEL_52:
  uint64_t v26 = (const std::string *)*((void *)a2 + 9);
  *((_DWORD *)this + 36) |= 0x800u;
  int v27 = (std::string *)*((void *)this + 9);
  if (v27 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v27, v26);
  int v9 = *((_DWORD *)a2 + 36);
  if ((v9 & 0x1000) == 0)
  {
LABEL_27:
    if ((v9 & 0x2000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_58;
  }
LABEL_55:
  int v28 = (const std::string *)*((void *)a2 + 10);
  *((_DWORD *)this + 36) |= 0x1000u;
  int v29 = (std::string *)*((void *)this + 10);
  if (v29 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v29, v28);
  int v9 = *((_DWORD *)a2 + 36);
  if ((v9 & 0x2000) == 0)
  {
LABEL_28:
    if ((v9 & 0x8000) == 0) {
      goto LABEL_29;
    }
    goto LABEL_59;
  }
LABEL_58:
  uint64_t v30 = *((void *)a2 + 11);
  *((_DWORD *)this + 36) |= 0x2000u;
  *((void *)this + 11) = v30;
  int v9 = *((_DWORD *)a2 + 36);
  if ((v9 & 0x8000) == 0)
  {
LABEL_29:
    if ((v9 & 0x10000) == 0) {
      return;
    }
    goto LABEL_62;
  }
LABEL_59:
  uint64_t v31 = (const std::string *)*((void *)a2 + 15);
  *((_DWORD *)this + 36) |= 0x8000u;
  int v32 = (std::string *)*((void *)this + 15);
  if (v32 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v32, v31);
  if ((*((_DWORD *)a2 + 36) & 0x10000) != 0)
  {
LABEL_62:
    int v33 = (const std::string *)*((void *)a2 + 16);
    *((_DWORD *)this + 36) |= 0x10000u;
    intptr_t v34 = (std::string *)*((void *)this + 16);
    if (v34 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v34, v33);
  }
}

void sub_100129200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::metrics::MetricFile::~MetricFile(awd::metrics::MetricFile *this)
{
  *(void *)this = off_1001BE708;
  awd::metrics::MetricFile::SharedDtor(this);
  sub_1000FB750((uint64_t *)this + 12);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::metrics::MetricFile::~MetricFile(this);

  operator delete();
}

void awd::metrics::MetricFile::SharedDtor(awd::metrics::MetricFile *this)
{
  uint64_t v1 = *((void *)this + 2);
  if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  uint64_t v3 = *((void *)this + 3);
  if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v3 != 0)
  {
    if (*(char *)(v3 + 23) < 0) {
      operator delete(*(void **)v3);
    }
    operator delete();
  }
  uint64_t v5 = *((void *)this + 6);
  if ((_UNKNOWN *)v5 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v5 != 0)
  {
    if (*(char *)(v5 + 23) < 0) {
      operator delete(*(void **)v5);
    }
    operator delete();
  }
  uint64_t v7 = *((void *)this + 7);
  if ((_UNKNOWN *)v7 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v7 != 0)
  {
    if (*(char *)(v7 + 23) < 0) {
      operator delete(*(void **)v7);
    }
    operator delete();
  }
  uint64_t v9 = *((void *)this + 8);
  if ((_UNKNOWN *)v9 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v9)
  {
    if (*(char *)(v9 + 23) < 0) {
      operator delete(*(void **)v9);
    }
    operator delete();
  }
  uint64_t v10 = *((void *)this + 9);
  if ((_UNKNOWN *)v10 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v10)
  {
    if (*(char *)(v10 + 23) < 0) {
      operator delete(*(void **)v10);
    }
    operator delete();
  }
  uint64_t v11 = *((void *)this + 10);
  if ((_UNKNOWN *)v11 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v11)
  {
    if (*(char *)(v11 + 23) < 0) {
      operator delete(*(void **)v11);
    }
    operator delete();
  }
  uint64_t v12 = *((void *)this + 15);
  if ((_UNKNOWN *)v12 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v12)
  {
    if (*(char *)(v12 + 23) < 0) {
      operator delete(*(void **)v12);
    }
    operator delete();
  }
  uint64_t v13 = *((void *)this + 16);
  if ((_UNKNOWN *)v13 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v13)
  {
    if (*(char *)(v13 + 23) < 0) {
      operator delete(*(void **)v13);
    }
    operator delete();
  }

  awd::metrics::protobuf_AddDesc_MetricFile_2eproto(this);
}

void awd::metrics::MetricFile::New(awd::metrics::MetricFile *this)
{
}

uint64_t awd::metrics::MetricFile::Clear(awd::metrics::MetricFile *this)
{
  int v2 = *((_DWORD *)this + 36);
  if ((_BYTE)v2)
  {
    *((void *)this + 1) = 0;
    if ((v2 & 2) != 0)
    {
      uint64_t v3 = *((void *)this + 2);
      if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    if ((*((unsigned char *)this + 144) & 4) != 0)
    {
      uint64_t v4 = *((void *)this + 3);
      if ((_UNKNOWN *)v4 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
    *((_DWORD *)this + 11) = 0;
    *((_DWORD *)this + 34) = 0;
    *((void *)this + 4) = 0;
    *((unsigned char *)this + 40) = 0;
    int v2 = *((_DWORD *)this + 36);
  }
  if ((v2 & 0xFF00) != 0)
  {
    if ((v2 & 0x100) != 0)
    {
      uint64_t v5 = *((void *)this + 6);
      if ((_UNKNOWN *)v5 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v5 + 23) < 0)
        {
          **(unsigned char **)uint64_t v5 = 0;
          *(void *)(v5 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v5 = 0;
          *(unsigned char *)(v5 + 23) = 0;
        }
      }
    }
    if ((*((unsigned char *)this + 145) & 2) != 0)
    {
      uint64_t v6 = *((void *)this + 7);
      if ((_UNKNOWN *)v6 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v6 + 23) < 0)
        {
          **(unsigned char **)uint64_t v6 = 0;
          *(void *)(v6 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v6 = 0;
          *(unsigned char *)(v6 + 23) = 0;
        }
      }
    }
    if ((*((unsigned char *)this + 145) & 4) != 0)
    {
      uint64_t v7 = *((void *)this + 8);
      if ((_UNKNOWN *)v7 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v7 + 23) < 0)
        {
          **(unsigned char **)uint64_t v7 = 0;
          *(void *)(v7 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v7 = 0;
          *(unsigned char *)(v7 + 23) = 0;
        }
      }
    }
    if ((*((unsigned char *)this + 145) & 8) != 0)
    {
      uint64_t v8 = *((void *)this + 9);
      if ((_UNKNOWN *)v8 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v8 + 23) < 0)
        {
          **(unsigned char **)uint64_t v8 = 0;
          *(void *)(v8 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v8 = 0;
          *(unsigned char *)(v8 + 23) = 0;
        }
      }
    }
    if ((*((unsigned char *)this + 145) & 0x10) != 0)
    {
      uint64_t v9 = *((void *)this + 10);
      if ((_UNKNOWN *)v9 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v9 + 23) < 0)
        {
          **(unsigned char **)uint64_t v9 = 0;
          *(void *)(v9 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v9 = 0;
          *(unsigned char *)(v9 + 23) = 0;
        }
      }
    }
    *((void *)this + 11) = 0;
    if ((*((unsigned char *)this + 145) & 0x80) != 0)
    {
      uint64_t v10 = *((void *)this + 15);
      if ((_UNKNOWN *)v10 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v10 + 23) < 0)
        {
          **(unsigned char **)uint64_t v10 = 0;
          *(void *)(v10 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v10 = 0;
          *(unsigned char *)(v10 + 23) = 0;
        }
      }
    }
  }
  if (*((unsigned char *)this + 146))
  {
    uint64_t v11 = *((void *)this + 16);
    if ((_UNKNOWN *)v11 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      if (*(char *)(v11 + 23) < 0)
      {
        **(unsigned char **)uint64_t v11 = 0;
        *(void *)(v11 + 8) = 0;
      }
      else
      {
        *(unsigned char *)uint64_t v11 = 0;
        *(unsigned char *)(v11 + 23) = 0;
      }
    }
  }
  uint64_t result = sub_1000FB6E0((uint64_t)this + 96);
  *((_DWORD *)this + 36) = 0;
  return result;
}

uint64_t awd::metrics::MetricFile::MergePartialFromCodedStream(awd::metrics::MetricFile *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  uint64_t v56 = (unint64_t *)((char *)this + 8);
  uint64_t v5 = (unsigned int *)((char *)this + 44);
  uint64_t v6 = (unsigned int *)((char *)this + 136);
  uint64_t v7 = (unsigned int *)((char *)this + 32);
  uint64_t v8 = (unsigned int *)((char *)this + 36);
  uint64_t v9 = (awd::metrics::MetricFile *)((char *)this + 96);
  while (1)
  {
    uint64_t v10 = (unsigned __int8 *)*((void *)a2 + 1);
    if ((unint64_t)v10 >= *((void *)a2 + 2) || (char)*v10 < 0) {
      break;
    }
    unint64_t TagFallback = *v10;
    *((_DWORD *)a2 + 8) = TagFallback;
    *((void *)a2 + 1) = v10 + 1;
    if (!TagFallback) {
      return 1;
    }
LABEL_7:
    switch(TagFallback >> 3)
    {
      case 1u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        int v14 = (char *)*((void *)a2 + 1);
        unint64_t v13 = *((void *)a2 + 2);
        if ((unint64_t)v14 >= v13 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v56);
          if (!result) {
            return result;
          }
          long long v15 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v13 = *((void *)a2 + 2);
        }
        else
        {
          unint64_t *v56 = *v14;
          long long v15 = v14 + 1;
          *((void *)a2 + 1) = v15;
        }
        int v16 = *((_DWORD *)this + 36) | 1;
        *((_DWORD *)this + 36) = v16;
        if ((unint64_t)v15 < v13 && *v15 == 18)
        {
          *((void *)a2 + 1) = v15 + 1;
          goto LABEL_52;
        }
        continue;
      case 2u:
        int v12 = TagFallback & 7;
        if (v12 != 2) {
          goto LABEL_44;
        }
        int v16 = *((_DWORD *)this + 36);
LABEL_52:
        *((_DWORD *)this + 36) = v16 | 2;
        if (*((_UNKNOWN **)this + 2) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v27 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v27 >= *((void *)a2 + 2) || *v27 != 26) {
          continue;
        }
        *((void *)a2 + 1) = v27 + 1;
LABEL_58:
        *((_DWORD *)this + 36) |= 4u;
        if (*((_UNKNOWN **)this + 3) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v28 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v17 = *((void *)a2 + 2);
        if ((unint64_t)v28 >= v17 || *v28 != 32) {
          continue;
        }
        char v18 = v28 + 1;
        *((void *)a2 + 1) = v18;
LABEL_64:
        v57[0] = 0;
        if ((unint64_t)v18 >= v17 || *v18 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v57);
          if (!result) {
            return result;
          }
          unsigned int v29 = v57[0];
          uint64_t v30 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v17 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v29 = *v18;
          uint64_t v30 = v18 + 1;
          *((void *)a2 + 1) = v30;
        }
        *((unsigned char *)this + 40) = v29 != 0;
        *((_DWORD *)this + 36) |= 0x20u;
        if ((unint64_t)v30 >= v17 || *v30 != 40) {
          continue;
        }
        int v19 = v30 + 1;
        *((void *)a2 + 1) = v19;
LABEL_72:
        if ((unint64_t)v19 >= v17 || *v19 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v5);
          if (!result) {
            return result;
          }
          uint64_t v31 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v17 = *((void *)a2 + 2);
        }
        else
        {
          *uint64_t v5 = *v19;
          uint64_t v31 = v19 + 1;
          *((void *)a2 + 1) = v31;
        }
        *((_DWORD *)this + 36) |= 0x40u;
        if ((unint64_t)v31 >= v17 || *v31 != 48) {
          continue;
        }
        uint64_t v20 = v31 + 1;
        *((void *)a2 + 1) = v20;
LABEL_80:
        if ((unint64_t)v20 >= v17 || *v20 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v6);
          if (!result) {
            return result;
          }
          int v32 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v17 = *((void *)a2 + 2);
        }
        else
        {
          *uint64_t v6 = *v20;
          int v32 = v20 + 1;
          *((void *)a2 + 1) = v32;
        }
        int v21 = *((_DWORD *)this + 36) | 0x80;
        *((_DWORD *)this + 36) = v21;
        if ((unint64_t)v32 >= v17 || *v32 != 58) {
          continue;
        }
        *((void *)a2 + 1) = v32 + 1;
LABEL_88:
        *((_DWORD *)this + 36) = v21 | 0x800;
        if (*((_UNKNOWN **)this + 9) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v33 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v33 >= *((void *)a2 + 2) || *v33 != 66) {
          continue;
        }
        *((void *)a2 + 1) = v33 + 1;
LABEL_94:
        *((_DWORD *)this + 36) |= 0x100u;
        if (*((_UNKNOWN **)this + 6) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        intptr_t v34 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v34 >= *((void *)a2 + 2) || *v34 != 74) {
          continue;
        }
        *((void *)a2 + 1) = v34 + 1;
LABEL_100:
        *((_DWORD *)this + 36) |= 0x200u;
        if (*((_UNKNOWN **)this + 7) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        unint64_t v35 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v35 >= *((void *)a2 + 2) || *v35 != 82) {
          continue;
        }
        *((void *)a2 + 1) = v35 + 1;
LABEL_106:
        *((_DWORD *)this + 36) |= 0x1000u;
        if (*((_UNKNOWN **)this + 10) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        unsigned int v36 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v36 >= *((void *)a2 + 2) || *v36 != 90) {
          continue;
        }
        *((void *)a2 + 1) = v36 + 1;
LABEL_112:
        *((_DWORD *)this + 36) |= 0x400u;
        if (*((_UNKNOWN **)this + 8) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        uint64_t v37 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v22 = *((void *)a2 + 2);
        if ((unint64_t)v37 >= v22 || *v37 != 96) {
          continue;
        }
        dispatch_time_t v23 = v37 + 1;
        *((void *)a2 + 1) = v23;
LABEL_118:
        *(void *)std::runtime_error v57 = 0;
        if ((unint64_t)v23 >= v22 || *v23 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, (unint64_t *)v57);
          if (!result) {
            return result;
          }
          uint64_t v38 = *(void *)v57;
          unsigned int v39 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v22 = *((void *)a2 + 2);
        }
        else
        {
          uint64_t v38 = *v23;
          unsigned int v39 = v23 + 1;
          *((void *)a2 + 1) = v39;
        }
        *((void *)this + 11) = v38;
        *((_DWORD *)this + 36) |= 0x2000u;
        if ((unint64_t)v39 >= v22 || *v39 != 104) {
          continue;
        }
        int v24 = v39 + 1;
        *((void *)a2 + 1) = v24;
LABEL_126:
        if ((unint64_t)v24 >= v22 || *v24 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v7);
          if (!result) {
            return result;
          }
          unsigned int v40 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v22 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int *v7 = *v24;
          unsigned int v40 = v24 + 1;
          *((void *)a2 + 1) = v40;
        }
        *((_DWORD *)this + 36) |= 8u;
        if ((unint64_t)v40 >= v22 || *v40 != 112) {
          continue;
        }
        int v25 = v40 + 1;
        *((void *)a2 + 1) = v25;
LABEL_134:
        if ((unint64_t)v25 >= v22 || (char)*v25 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v8);
          if (!result) {
            return result;
          }
          intptr_t v41 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v22 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int *v8 = *v25;
          intptr_t v41 = v25 + 1;
          *((void *)a2 + 1) = v41;
        }
        *((_DWORD *)this + 36) |= 0x10u;
        if ((unint64_t)v41 >= v22 || *v41 != 122) {
          continue;
        }
        break;
      case 3u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_58;
        }
        goto LABEL_44;
      case 4u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        char v18 = (char *)*((void *)a2 + 1);
        unint64_t v17 = *((void *)a2 + 2);
        goto LABEL_64;
      case 5u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        int v19 = (char *)*((void *)a2 + 1);
        unint64_t v17 = *((void *)a2 + 2);
        goto LABEL_72;
      case 6u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        uint64_t v20 = (char *)*((void *)a2 + 1);
        unint64_t v17 = *((void *)a2 + 2);
        goto LABEL_80;
      case 7u:
        int v12 = TagFallback & 7;
        if (v12 != 2) {
          goto LABEL_44;
        }
        int v21 = *((_DWORD *)this + 36);
        goto LABEL_88;
      case 8u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_94;
        }
        goto LABEL_44;
      case 9u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_100;
        }
        goto LABEL_44;
      case 0xAu:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_106;
        }
        goto LABEL_44;
      case 0xBu:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_112;
        }
        goto LABEL_44;
      case 0xCu:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        dispatch_time_t v23 = (char *)*((void *)a2 + 1);
        unint64_t v22 = *((void *)a2 + 2);
        goto LABEL_118;
      case 0xDu:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        int v24 = (char *)*((void *)a2 + 1);
        unint64_t v22 = *((void *)a2 + 2);
        goto LABEL_126;
      case 0xEu:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        int v25 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v22 = *((void *)a2 + 2);
        goto LABEL_134;
      case 0xFu:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_142;
        }
        goto LABEL_44;
      case 0x20u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_162;
        }
        goto LABEL_44;
      case 0x21u:
        int v12 = TagFallback & 7;
        if (v12 != 2) {
          goto LABEL_44;
        }
        goto LABEL_169;
      default:
        int v12 = TagFallback & 7;
LABEL_44:
        if (v12 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
        continue;
        }
    }
    do
    {
      *((void *)a2 + 1) = v41 + 1;
LABEL_142:
      int v42 = *((_DWORD *)this + 27);
      uint64_t v43 = *((int *)this + 26);
      if ((int)v43 >= v42)
      {
        if (v42 == *((_DWORD *)this + 28))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v9, v42 + 1);
          int v42 = *((_DWORD *)this + 27);
        }
        *((_DWORD *)this + 27) = v42 + 1;
        sub_10012A940();
      }
      uint64_t v44 = *((void *)this + 12);
      *((_DWORD *)this + 26) = v43 + 1;
      unint64_t v45 = *(awd::metrics::MetricLog **)(v44 + 8 * v43);
      v57[0] = 0;
      uint64_t v46 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v46 >= *((void *)a2 + 2) || *v46 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v57)) {
          return 0;
        }
      }
      else
      {
        v57[0] = *v46;
        *((void *)a2 + 1) = v46 + 1;
      }
      int v47 = *((_DWORD *)a2 + 14);
      int v48 = *((_DWORD *)a2 + 15);
      *((_DWORD *)a2 + 14) = v47 + 1;
      if (v47 >= v48) {
        return 0;
      }
      int v49 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2, v57[0]);
      if (!awd::metrics::MetricLog::MergePartialFromCodedStream(v45, a2, v50) || !*((unsigned char *)a2 + 36)) {
        return 0;
      }
      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2, v49);
      int v51 = *((_DWORD *)a2 + 14);
      BOOL v52 = __OFSUB__(v51, 1);
      int v53 = v51 - 1;
      if (v53 < 0 == v52) {
        *((_DWORD *)a2 + 14) = v53;
      }
      intptr_t v41 = (unsigned __int8 *)*((void *)a2 + 1);
      unint64_t v54 = *((void *)a2 + 2);
    }
    while ((unint64_t)v41 < v54 && *v41 == 122);
    if ((int)v54 - (int)v41 >= 2 && *v41 == 130 && v41[1] == 2)
    {
      *((void *)a2 + 1) = v41 + 2;
LABEL_162:
      *((_DWORD *)this + 36) |= 0x8000u;
      if (*((_UNKNOWN **)this + 15) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
      if (!result) {
        return result;
      }
      unsigned __int8 v55 = (unsigned __int8 *)*((void *)a2 + 1);
      if (*((_DWORD *)a2 + 4) - (int)v55 >= 2 && *v55 == 138 && v55[1] == 2)
      {
        *((void *)a2 + 1) = v55 + 2;
LABEL_169:
        *((_DWORD *)this + 36) |= 0x10000u;
        if (*((_UNKNOWN **)this + 16) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        if (*((void *)a2 + 1) == *((void *)a2 + 2)
          && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
  }
  unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
  *((_DWORD *)a2 + 8) = TagFallback;
  if (TagFallback) {
    goto LABEL_7;
  }
  return 1;
}

uint64_t awd::metrics::MetricFile::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 144);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(this + 8), (unint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 144);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_25;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 144);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 0x20) == 0) {
      goto LABEL_5;
    }
    goto LABEL_26;
  }
LABEL_25:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 144);
  if ((v6 & 0x20) == 0)
  {
LABEL_5:
    if ((v6 & 0x40) == 0) {
      goto LABEL_6;
    }
    goto LABEL_27;
  }
LABEL_26:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(unsigned __int8 *)(v5 + 40), (BOOL)a2, a4);
  int v6 = *(_DWORD *)(v5 + 144);
  if ((v6 & 0x40) == 0)
  {
LABEL_6:
    if ((v6 & 0x80) == 0) {
      goto LABEL_7;
    }
    goto LABEL_28;
  }
LABEL_27:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, *(_DWORD *)(v5 + 44), a2, a4);
  int v6 = *(_DWORD *)(v5 + 144);
  if ((v6 & 0x80) == 0)
  {
LABEL_7:
    if ((v6 & 0x800) == 0) {
      goto LABEL_8;
    }
    goto LABEL_29;
  }
LABEL_28:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, *(_DWORD *)(v5 + 136), a2, a4);
  int v6 = *(_DWORD *)(v5 + 144);
  if ((v6 & 0x800) == 0)
  {
LABEL_8:
    if ((v6 & 0x100) == 0) {
      goto LABEL_9;
    }
    goto LABEL_30;
  }
LABEL_29:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 144);
  if ((v6 & 0x100) == 0)
  {
LABEL_9:
    if ((v6 & 0x200) == 0) {
      goto LABEL_10;
    }
    goto LABEL_31;
  }
LABEL_30:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 144);
  if ((v6 & 0x200) == 0)
  {
LABEL_10:
    if ((v6 & 0x1000) == 0) {
      goto LABEL_11;
    }
    goto LABEL_32;
  }
LABEL_31:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 144);
  if ((v6 & 0x1000) == 0)
  {
LABEL_11:
    if ((v6 & 0x400) == 0) {
      goto LABEL_12;
    }
    goto LABEL_33;
  }
LABEL_32:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 144);
  if ((v6 & 0x400) == 0)
  {
LABEL_12:
    if ((v6 & 0x2000) == 0) {
      goto LABEL_13;
    }
    goto LABEL_34;
  }
LABEL_33:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 144);
  if ((v6 & 0x2000) == 0)
  {
LABEL_13:
    if ((v6 & 8) == 0) {
      goto LABEL_14;
    }
    goto LABEL_35;
  }
LABEL_34:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xC, *(void *)(v5 + 88), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 144);
  if ((v6 & 8) == 0)
  {
LABEL_14:
    if ((v6 & 0x10) == 0) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_35:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xD, *(_DWORD *)(v5 + 32), a2, a4);
  if ((*(_DWORD *)(v5 + 144) & 0x10) != 0) {
LABEL_15:
  }
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xE, *(_DWORD *)(v5 + 36), a2, a4);
LABEL_16:
  if (*(int *)(v5 + 104) >= 1)
  {
    uint64_t v7 = 0;
    do
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xF, *(void *)(*(void *)(v5 + 96) + 8 * v7++), a2, a4);
    while (v7 < *(int *)(v5 + 104));
  }
  int v8 = *(_DWORD *)(v5 + 144);
  if ((v8 & 0x8000) != 0)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
    int v8 = *(_DWORD *)(v5 + 144);
  }
  if ((v8 & 0x10000) != 0)
  {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  }
  return this;
}

uint64_t awd::metrics::MetricFile::ByteSize(awd::metrics::MetricFile *this, unint64_t a2)
{
  int v3 = *((_DWORD *)this + 36);
  if (!(_BYTE)v3)
  {
    int v4 = 0;
    goto LABEL_49;
  }
  if (v3)
  {
    int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 1), a2)+ 1;
    int v3 = *((_DWORD *)this + 36);
    if ((v3 & 2) == 0) {
      goto LABEL_16;
    }
  }
  else
  {
    int v4 = 0;
    if ((v3 & 2) == 0) {
      goto LABEL_16;
    }
  }
  uint64_t v5 = *((void *)this + 2);
  int v6 = *(unsigned __int8 *)(v5 + 23);
  char v7 = v6;
  uint64_t v8 = *(void *)(v5 + 8);
  if ((v6 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 >= 0x80)
  {
    int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9, a2);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v8 = *(void *)(v5 + 8);
    int v3 = *((_DWORD *)this + 36);
    char v7 = *(unsigned char *)(v5 + 23);
  }
  else
  {
    int v10 = 1;
  }
  if (v7 < 0) {
    int v6 = v8;
  }
  v4 += v10 + v6 + 1;
LABEL_16:
  if ((v3 & 4) == 0)
  {
    if ((v3 & 8) == 0) {
      goto LABEL_18;
    }
LABEL_29:
    unint64_t v17 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 8);
    if (v17 >= 0x80)
    {
      int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v17, a2);
      int v3 = *((_DWORD *)this + 36);
    }
    else
    {
      int v18 = 1;
    }
    v4 += v18 + 1;
    if ((v3 & 0x10) == 0) {
      goto LABEL_37;
    }
    goto LABEL_33;
  }
  uint64_t v11 = *((void *)this + 3);
  int v12 = *(unsigned __int8 *)(v11 + 23);
  char v13 = v12;
  uint64_t v14 = *(void *)(v11 + 8);
  if ((v12 & 0x80u) == 0) {
    unint64_t v15 = *(unsigned __int8 *)(v11 + 23);
  }
  else {
    unint64_t v15 = v14;
  }
  if (v15 >= 0x80)
  {
    int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v15, a2);
    int v12 = *(unsigned __int8 *)(v11 + 23);
    uint64_t v14 = *(void *)(v11 + 8);
    int v3 = *((_DWORD *)this + 36);
    char v13 = *(unsigned char *)(v11 + 23);
  }
  else
  {
    int v16 = 1;
  }
  if (v13 < 0) {
    int v12 = v14;
  }
  v4 += v16 + v12 + 1;
  if ((v3 & 8) != 0) {
    goto LABEL_29;
  }
LABEL_18:
  if ((v3 & 0x10) != 0)
  {
LABEL_33:
    int v19 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 9);
    if (v19 >= 0x80)
    {
      int v20 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v19, a2);
      int v3 = *((_DWORD *)this + 36);
    }
    else
    {
      int v20 = 1;
    }
    v4 += v20 + 1;
  }
LABEL_37:
  if ((v3 & 0x20) != 0) {
    v4 += 2;
  }
  if ((v3 & 0x40) != 0)
  {
    int v21 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 11);
    if (v21 >= 0x80)
    {
      int v22 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v21, a2);
      int v3 = *((_DWORD *)this + 36);
    }
    else
    {
      int v22 = 1;
    }
    v4 += v22 + 1;
  }
  if ((v3 & 0x80) != 0)
  {
    dispatch_time_t v23 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 34);
    if (v23 >= 0x80)
    {
      int v24 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v23, a2);
      int v3 = *((_DWORD *)this + 36);
    }
    else
    {
      int v24 = 1;
    }
    v4 += v24 + 1;
  }
LABEL_49:
  if ((v3 & 0xFF00) == 0) {
    goto LABEL_57;
  }
  if ((v3 & 0x100) != 0)
  {
    uint64_t v25 = *((void *)this + 6);
    int v26 = *(unsigned __int8 *)(v25 + 23);
    char v27 = v26;
    uint64_t v28 = *(void *)(v25 + 8);
    if ((v26 & 0x80u) == 0) {
      unint64_t v29 = *(unsigned __int8 *)(v25 + 23);
    }
    else {
      unint64_t v29 = v28;
    }
    if (v29 >= 0x80)
    {
      int v30 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v29, a2);
      int v26 = *(unsigned __int8 *)(v25 + 23);
      uint64_t v28 = *(void *)(v25 + 8);
      int v3 = *((_DWORD *)this + 36);
      char v27 = *(unsigned char *)(v25 + 23);
    }
    else
    {
      int v30 = 1;
    }
    if (v27 < 0) {
      int v26 = v28;
    }
    v4 += v30 + v26 + 1;
    if ((v3 & 0x200) == 0)
    {
LABEL_52:
      if ((v3 & 0x400) == 0) {
        goto LABEL_53;
      }
      goto LABEL_77;
    }
  }
  else if ((v3 & 0x200) == 0)
  {
    goto LABEL_52;
  }
  uint64_t v31 = *((void *)this + 7);
  int v32 = *(unsigned __int8 *)(v31 + 23);
  char v33 = v32;
  uint64_t v34 = *(void *)(v31 + 8);
  if ((v32 & 0x80u) == 0) {
    unint64_t v35 = *(unsigned __int8 *)(v31 + 23);
  }
  else {
    unint64_t v35 = v34;
  }
  if (v35 >= 0x80)
  {
    int v36 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v35, a2);
    int v32 = *(unsigned __int8 *)(v31 + 23);
    uint64_t v34 = *(void *)(v31 + 8);
    int v3 = *((_DWORD *)this + 36);
    char v33 = *(unsigned char *)(v31 + 23);
  }
  else
  {
    int v36 = 1;
  }
  if (v33 < 0) {
    int v32 = v34;
  }
  v4 += v36 + v32 + 1;
  if ((v3 & 0x400) == 0)
  {
LABEL_53:
    if ((v3 & 0x800) == 0) {
      goto LABEL_54;
    }
    goto LABEL_86;
  }
LABEL_77:
  uint64_t v37 = *((void *)this + 8);
  int v38 = *(unsigned __int8 *)(v37 + 23);
  char v39 = v38;
  uint64_t v40 = *(void *)(v37 + 8);
  if ((v38 & 0x80u) == 0) {
    unint64_t v41 = *(unsigned __int8 *)(v37 + 23);
  }
  else {
    unint64_t v41 = v40;
  }
  if (v41 >= 0x80)
  {
    int v42 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v41, a2);
    int v38 = *(unsigned __int8 *)(v37 + 23);
    uint64_t v40 = *(void *)(v37 + 8);
    int v3 = *((_DWORD *)this + 36);
    char v39 = *(unsigned char *)(v37 + 23);
  }
  else
  {
    int v42 = 1;
  }
  if (v39 < 0) {
    int v38 = v40;
  }
  v4 += v42 + v38 + 1;
  if ((v3 & 0x800) == 0)
  {
LABEL_54:
    if ((v3 & 0x1000) == 0) {
      goto LABEL_55;
    }
    goto LABEL_95;
  }
LABEL_86:
  uint64_t v43 = *((void *)this + 9);
  int v44 = *(unsigned __int8 *)(v43 + 23);
  char v45 = v44;
  uint64_t v46 = *(void *)(v43 + 8);
  if ((v44 & 0x80u) == 0) {
    unint64_t v47 = *(unsigned __int8 *)(v43 + 23);
  }
  else {
    unint64_t v47 = v46;
  }
  if (v47 >= 0x80)
  {
    int v48 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v47, a2);
    int v44 = *(unsigned __int8 *)(v43 + 23);
    uint64_t v46 = *(void *)(v43 + 8);
    int v3 = *((_DWORD *)this + 36);
    char v45 = *(unsigned char *)(v43 + 23);
  }
  else
  {
    int v48 = 1;
  }
  if (v45 < 0) {
    int v44 = v46;
  }
  v4 += v48 + v44 + 1;
  if ((v3 & 0x1000) == 0)
  {
LABEL_55:
    if ((v3 & 0x2000) == 0) {
      goto LABEL_56;
    }
    goto LABEL_104;
  }
LABEL_95:
  uint64_t v49 = *((void *)this + 10);
  int v50 = *(unsigned __int8 *)(v49 + 23);
  char v51 = v50;
  uint64_t v52 = *(void *)(v49 + 8);
  if ((v50 & 0x80u) == 0) {
    unint64_t v53 = *(unsigned __int8 *)(v49 + 23);
  }
  else {
    unint64_t v53 = v52;
  }
  if (v53 >= 0x80)
  {
    int v54 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v53, a2);
    int v50 = *(unsigned __int8 *)(v49 + 23);
    uint64_t v52 = *(void *)(v49 + 8);
    int v3 = *((_DWORD *)this + 36);
    char v51 = *(unsigned char *)(v49 + 23);
  }
  else
  {
    int v54 = 1;
  }
  if (v51 < 0) {
    int v50 = v52;
  }
  v4 += v54 + v50 + 1;
  if ((v3 & 0x2000) == 0)
  {
LABEL_56:
    if ((v3 & 0x8000) == 0) {
      goto LABEL_57;
    }
    goto LABEL_105;
  }
LABEL_104:
  v4 += wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 11), a2)+ 1;
  int v3 = *((_DWORD *)this + 36);
  if ((v3 & 0x8000) == 0)
  {
LABEL_57:
    if ((v3 & 0x10000) == 0) {
      goto LABEL_123;
    }
    goto LABEL_114;
  }
LABEL_105:
  uint64_t v55 = *((void *)this + 15);
  int v56 = *(unsigned __int8 *)(v55 + 23);
  char v57 = v56;
  uint64_t v58 = *(void *)(v55 + 8);
  if ((v56 & 0x80u) == 0) {
    unint64_t v59 = *(unsigned __int8 *)(v55 + 23);
  }
  else {
    unint64_t v59 = v58;
  }
  if (v59 >= 0x80)
  {
    int v60 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v59, a2);
    int v56 = *(unsigned __int8 *)(v55 + 23);
    uint64_t v58 = *(void *)(v55 + 8);
    int v3 = *((_DWORD *)this + 36);
    char v57 = *(unsigned char *)(v55 + 23);
  }
  else
  {
    int v60 = 1;
  }
  if (v57 < 0) {
    int v56 = v58;
  }
  v4 += v60 + v56 + 2;
  if ((v3 & 0x10000) != 0)
  {
LABEL_114:
    uint64_t v61 = *((void *)this + 16);
    int v62 = *(unsigned __int8 *)(v61 + 23);
    char v63 = v62;
    uint64_t v64 = *(void *)(v61 + 8);
    if ((v62 & 0x80u) == 0) {
      unint64_t v65 = *(unsigned __int8 *)(v61 + 23);
    }
    else {
      unint64_t v65 = v64;
    }
    if (v65 >= 0x80)
    {
      int v66 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v65, a2);
      int v62 = *(unsigned __int8 *)(v61 + 23);
      uint64_t v64 = *(void *)(v61 + 8);
      char v63 = *(unsigned char *)(v61 + 23);
    }
    else
    {
      int v66 = 1;
    }
    if (v63 < 0) {
      int v62 = v64;
    }
    v4 += v66 + v62 + 2;
  }
LABEL_123:
  int v67 = *((_DWORD *)this + 26);
  uint64_t v68 = (v67 + v4);
  if (v67 >= 1)
  {
    uint64_t v69 = 0;
    do
    {
      char v70 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)awd::metrics::MetricLog::ByteSize(*(awd::metrics::MetricLog **)(*((void *)this + 12) + 8 * v69), a2);
      int v71 = (int)v70;
      if (v70 >= 0x80) {
        int v72 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v70, a2);
      }
      else {
        int v72 = 1;
      }
      uint64_t v68 = (v71 + v68 + v72);
      ++v69;
    }
    while (v69 < *((int *)this + 26));
  }
  *((_DWORD *)this + 35) = v68;
  return v68;
}

uint64_t awd::metrics::MetricFile::IsInitialized(awd::metrics::MetricFile *this)
{
  return 1;
}

void *awd::metrics::MetricFile::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.MetricFile");
}

uint64_t sub_10012A938(uint64_t a1)
{
  return *(unsigned int *)(a1 + 140);
}

void sub_10012A940()
{
}

void sub_10012A980()
{
}

uint64_t awd::metrics::protobuf_ShutdownFile_AwddMetricsGeneral_2eproto(awd::metrics *this)
{
  if (awd::metrics::MetricAwddLocation::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::metrics::MetricAwddLocation::default_instance_ + 8))(awd::metrics::MetricAwddLocation::default_instance_);
  }
  if (awd::metrics::MetricCCDiagnosticsAllowed::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::metrics::MetricCCDiagnosticsAllowed::default_instance_ + 8))(awd::metrics::MetricCCDiagnosticsAllowed::default_instance_);
  }
  if (awd::metrics::AwddShutdown::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::metrics::AwddShutdown::default_instance_ + 8))(awd::metrics::AwddShutdown::default_instance_);
  }
  if (awd::metrics::AwddStartup::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::metrics::AwddStartup::default_instance_ + 8))(awd::metrics::AwddStartup::default_instance_);
  }
  if (awd::metrics::BatteryPowerLevel::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::metrics::BatteryPowerLevel::default_instance_ + 8))(awd::metrics::BatteryPowerLevel::default_instance_);
  }
  uint64_t result = awd::metrics::AwddAggregation::default_instance_;
  if (awd::metrics::AwddAggregation::default_instance_)
  {
    int v2 = *(uint64_t (**)(void))(*(void *)awd::metrics::AwddAggregation::default_instance_ + 8);
    return v2();
  }
  return result;
}

void awd::metrics::protobuf_AddDesc_AwddMetricsGeneral_2eproto_impl(awd::metrics *this, uint64_t a2, uint64_t a3, const char *a4)
{
}

uint64_t awd::metrics::MetricCCDiagnosticsAllowed::MetricCCDiagnosticsAllowed(uint64_t this)
{
  *(unsigned char *)(this + 16) = 0;
  *(void *)this = off_1001BE810;
  *(void *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

void *awd::metrics::AwddShutdown::AwddShutdown(void *this)
{
  this[1] = 0;
  this[2] = 0;
  *this = off_1001BE888;
  return this;
}

void *awd::metrics::AwddStartup::AwddStartup(void *this)
{
  this[1] = 0;
  this[2] = 0;
  *this = off_1001BE900;
  return this;
}

void awd::metrics::protobuf_AddDesc_AwddMetricsGeneral_2eproto(awd::metrics *this)
{
  uint64_t v1 = awd::metrics::protobuf_AddDesc_AwddMetricsGeneral_2eproto_once_;
  __dmb(0xBu);
  if (v1 != 2)
  {
    v2[1] = awd::metrics::protobuf_AddDesc_AwddMetricsGeneral_2eproto_impl;
    char v3 = 0;
    wireless_diagnostics::google::protobuf::GoogleOnceInitImpl();
    wireless_diagnostics::google::protobuf::internal::FunctionClosure0::~FunctionClosure0((wireless_diagnostics::google::protobuf::internal::FunctionClosure0 *)v2);
  }
}

void sub_10012ADF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  wireless_diagnostics::google::protobuf::internal::FunctionClosure0::~FunctionClosure0((wireless_diagnostics::google::protobuf::internal::FunctionClosure0 *)va);
  _Unwind_Resume(a1);
}

double awd::metrics::MetricAwddLocation::MergeFrom(awd::metrics::MetricAwddLocation *this, const awd::metrics::MetricAwddLocation *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v5) = *((unsigned char *)a2 + 44);
  if ((_BYTE)v5)
  {
    if (*((unsigned char *)a2 + 44))
    {
      double result = *((double *)a2 + 1);
      *((_DWORD *)this + 11) |= 1u;
      *((double *)this + 1) = result;
      int v5 = *((_DWORD *)a2 + 11);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_12;
      }
    }
    else if ((*((unsigned char *)a2 + 44) & 2) == 0)
    {
      goto LABEL_6;
    }
    double result = *((double *)a2 + 2);
    *((_DWORD *)this + 11) |= 2u;
    *((double *)this + 2) = result;
    int v5 = *((_DWORD *)a2 + 11);
    if ((v5 & 4) == 0)
    {
LABEL_7:
      if ((v5 & 8) == 0) {
        return result;
      }
      goto LABEL_8;
    }
LABEL_12:
    double result = *((double *)a2 + 3);
    *((_DWORD *)this + 11) |= 4u;
    *((double *)this + 3) = result;
    if ((*((_DWORD *)a2 + 11) & 8) == 0) {
      return result;
    }
LABEL_8:
    uint64_t v6 = *((void *)a2 + 4);
    *((_DWORD *)this + 11) |= 8u;
    *((void *)this + 4) = v6;
  }
  return result;
}

void sub_10012AEF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::metrics::MetricAwddLocation::~MetricAwddLocation(awd::metrics::MetricAwddLocation *this)
{
  *(void *)this = off_1001BE798;
  awd::metrics::protobuf_AddDesc_AwddMetricsGeneral_2eproto(this);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::metrics::MetricAwddLocation::~MetricAwddLocation(this);

  operator delete();
}

void awd::metrics::MetricAwddLocation::New(awd::metrics::MetricAwddLocation *this)
{
}

uint64_t awd::metrics::MetricAwddLocation::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 44))
  {
    *(_OWORD *)(this + 24) = 0u;
    *(_OWORD *)(this + 8) = 0u;
  }
  *(_DWORD *)(this + 44) = 0;
  return this;
}

uint64_t awd::metrics::MetricAwddLocation::MergePartialFromCodedStream(awd::metrics::MetricAwddLocation *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  int v5 = (unint64_t *)((char *)this + 32);
  while (2)
  {
    uint64_t v6 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v6;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v6 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_25;
        }
        unint64_t v15 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, &v15) & 1) == 0) {
          return 0;
        }
        *((void *)this + 1) = v15;
        *((_DWORD *)this + 11) |= 1u;
        unint64_t v9 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v9 >= *((void *)a2 + 2) || *v9 != 17) {
          continue;
        }
        *((void *)a2 + 1) = v9 + 1;
        goto LABEL_15;
      case 2u:
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_25;
        }
LABEL_15:
        unint64_t v15 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, &v15) & 1) == 0) {
          return 0;
        }
        *((void *)this + 2) = v15;
        *((_DWORD *)this + 11) |= 2u;
        uint64_t v11 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        if ((unint64_t)v11 >= v10 || *v11 != 24) {
          continue;
        }
        int v12 = v11 + 1;
        *((void *)a2 + 1) = v12;
LABEL_21:
        if ((unint64_t)v12 >= v10 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v5);
          if (!result) {
            return result;
          }
          char v13 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v10 = *((void *)a2 + 2);
        }
        else
        {
          *int v5 = *v12;
          char v13 = v12 + 1;
          *((void *)a2 + 1) = v13;
        }
        *((_DWORD *)this + 11) |= 8u;
        if ((unint64_t)v13 >= v10 || *v13 != 33) {
          continue;
        }
        *((void *)a2 + 1) = v13 + 1;
LABEL_33:
        unint64_t v15 = 0;
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, &v15))
        {
          *((void *)this + 3) = v15;
          *((_DWORD *)this + 11) |= 4u;
          if (*((void *)a2 + 1) == *((void *)a2 + 2)
            && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
          {
            *((_DWORD *)a2 + 8) = 0;
            uint64_t result = 1;
            *((unsigned char *)a2 + 36) = 1;
            return result;
          }
          continue;
        }
        return 0;
      case 3u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_25;
        }
        int v12 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        goto LABEL_21;
      case 4u:
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_25;
        }
        goto LABEL_33;
      default:
        int v8 = TagFallback & 7;
LABEL_25:
        if (v8 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

uint64_t awd::metrics::MetricAwddLocation::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 44);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, (int)a2, *(double *)(this + 8), a3);
    int v6 = *(_DWORD *)(v5 + 44);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 8) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(void *)(v5 + 32), (unint64_t)a2, a4);
      if ((*(_DWORD *)(v5 + 44) & 4) == 0) {
        return this;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (int)a2, *(double *)(v5 + 16), a3);
  int v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 8) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((v6 & 4) == 0) {
    return this;
  }
LABEL_9:
  double v7 = *(double *)(v5 + 24);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, (int)a2, v7, a3);
}

uint64_t awd::metrics::MetricAwddLocation::ByteSize(wireless_diagnostics::google::protobuf::io::CodedOutputStream **this, unint64_t a2)
{
  int v3 = *((unsigned __int8 *)this + 44);
  if (*((unsigned char *)this + 44))
  {
    unsigned int v4 = (v3 << 31 >> 31) & 9;
    if ((v3 & 2) != 0) {
      v4 += 9;
    }
    if ((v3 & 4) != 0) {
      uint64_t v5 = v4 + 9;
    }
    else {
      uint64_t v5 = v4;
    }
    if ((v3 & 8) != 0) {
      uint64_t v5 = v5
    }
         + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(this[4], a2)
         + 1;
  }
  else
  {
    uint64_t v5 = 0;
  }
  *((_DWORD *)this + 10) = v5;
  return v5;
}

uint64_t awd::metrics::MetricAwddLocation::IsInitialized(awd::metrics::MetricAwddLocation *this)
{
  return 1;
}

void *awd::metrics::MetricAwddLocation::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.MetricAwddLocation");
}

void awd::metrics::MetricCCDiagnosticsAllowed::MergeFrom(awd::metrics::MetricCCDiagnosticsAllowed *this, const awd::metrics::MetricCCDiagnosticsAllowed *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 24);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 24))
    {
      char v5 = *((unsigned char *)a2 + 16);
      *((_DWORD *)this + 6) |= 1u;
      *((unsigned char *)this + 16) = v5;
      int v4 = *((_DWORD *)a2 + 6);
    }
    if ((v4 & 2) != 0)
    {
      uint64_t v6 = *((void *)a2 + 1);
      *((_DWORD *)this + 6) |= 2u;
      *((void *)this + 1) = v6;
    }
  }
}

void sub_10012B460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::metrics::MetricCCDiagnosticsAllowed::~MetricCCDiagnosticsAllowed(awd::metrics::MetricCCDiagnosticsAllowed *this)
{
  *(void *)this = off_1001BE810;
  awd::metrics::protobuf_AddDesc_AwddMetricsGeneral_2eproto(this);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::metrics::MetricCCDiagnosticsAllowed::~MetricCCDiagnosticsAllowed(this);

  operator delete();
}

void awd::metrics::MetricCCDiagnosticsAllowed::New(awd::metrics::MetricCCDiagnosticsAllowed *this)
{
}

uint64_t awd::metrics::MetricCCDiagnosticsAllowed::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 24))
  {
    *(unsigned char *)(this + 16) = 0;
    *(void *)(this + 8) = 0;
  }
  *(_DWORD *)(this + 24) = 0;
  return this;
}

uint64_t awd::metrics::MetricCCDiagnosticsAllowed::MergePartialFromCodedStream(awd::metrics::MetricCCDiagnosticsAllowed *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  char v5 = (unint64_t *)((char *)this + 8);
  while (1)
  {
    while (1)
    {
      uint64_t v6 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        unint64_t TagFallback = *v6;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v6 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_16;
      }
      unsigned int v16 = 0;
      uint64_t v11 = (char *)*((void *)a2 + 1);
      unint64_t v9 = *((void *)a2 + 2);
      if ((unint64_t)v11 >= v9 || *v11 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v16);
        if (!result) {
          return result;
        }
        unsigned int v12 = v16;
        char v13 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
      }
      else
      {
        unsigned int v12 = *v11;
        char v13 = v11 + 1;
        *((void *)a2 + 1) = v13;
      }
      *((unsigned char *)this + 16) = v12 != 0;
      *((_DWORD *)this + 6) |= 1u;
      if ((unint64_t)v13 < v9 && *v13 == 32)
      {
        unint64_t v10 = v13 + 1;
        *((void *)a2 + 1) = v10;
LABEL_24:
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v5);
          if (!result) {
            return result;
          }
          uint64_t v14 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
        }
        else
        {
          *char v5 = *v10;
          uint64_t v14 = (unsigned __int8 *)(v10 + 1);
          *((void *)a2 + 1) = v14;
        }
        *((_DWORD *)this + 6) |= 2u;
        if (v14 == (unsigned __int8 *)v9 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 4)
    {
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        unint64_t v10 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
        goto LABEL_24;
      }
    }
    else
    {
      int v8 = TagFallback & 7;
    }
LABEL_16:
    if (v8 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t awd::metrics::MetricCCDiagnosticsAllowed::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 24);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned __int8 *)(this + 16), (BOOL)a2, a4);
    int v6 = *(_DWORD *)(v5 + 24);
  }
  if ((v6 & 2) != 0)
  {
    uint64_t v7 = *(void *)(v5 + 8);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, (unint64_t)a2, a4);
  }
  return this;
}

uint64_t awd::metrics::MetricCCDiagnosticsAllowed::ByteSize(awd::metrics::MetricCCDiagnosticsAllowed *this, unint64_t a2)
{
  int v3 = *((_DWORD *)this + 6);
  if ((_BYTE)v3)
  {
    uint64_t v4 = 2 * (v3 & 1u);
    if ((v3 & 2) != 0) {
      uint64_t v4 = (v4 | 1)
    }
         + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 1), a2);
  }
  else
  {
    uint64_t v4 = 0;
  }
  *((_DWORD *)this + 5) = v4;
  return v4;
}

uint64_t awd::metrics::MetricCCDiagnosticsAllowed::IsInitialized(awd::metrics::MetricCCDiagnosticsAllowed *this)
{
  return 1;
}

void *awd::metrics::MetricCCDiagnosticsAllowed::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.MetricCCDiagnosticsAllowed");
}

void awd::metrics::AwddShutdown::MergeFrom(awd::metrics::AwddShutdown *this, const awd::metrics::AwddShutdown *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v5);
  }
  if (*((unsigned char *)a2 + 20))
  {
    uint64_t v4 = *((void *)a2 + 1);
    *((_DWORD *)this + 5) |= 1u;
    *((void *)this + 1) = v4;
  }
}

void sub_10012B890(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::metrics::AwddShutdown::~AwddShutdown(awd::metrics::AwddShutdown *this)
{
  *(void *)this = off_1001BE888;
  awd::metrics::protobuf_AddDesc_AwddMetricsGeneral_2eproto(this);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::metrics::AwddShutdown::~AwddShutdown(this);

  operator delete();
}

void awd::metrics::AwddShutdown::New(awd::metrics::AwddShutdown *this)
{
}

uint64_t awd::metrics::AwddShutdown::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 20)) {
    *(void *)(this + 8) = 0;
  }
  *(_DWORD *)(this + 20) = 0;
  return this;
}

uint64_t awd::metrics::AwddShutdown::MergePartialFromCodedStream(awd::metrics::AwddShutdown *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)((char *)this + 8);
  while (1)
  {
    while (1)
    {
      int v6 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
      }
      else
      {
        unint64_t TagFallback = *v6;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v6 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unint64_t v9 = (char *)*((void *)a2 + 1);
      unint64_t v8 = *((void *)a2 + 2);
      if ((unint64_t)v9 >= v8 || *v9 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v5);
        if (!result) {
          return result;
        }
        unint64_t v10 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v8 = *((void *)a2 + 2);
      }
      else
      {
        *uint64_t v5 = *v9;
        unint64_t v10 = (unsigned __int8 *)(v9 + 1);
        *((void *)a2 + 1) = v10;
      }
      *((_DWORD *)this + 5) |= 1u;
      if (v10 == (unsigned __int8 *)v8 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t awd::metrics::AwddShutdown::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(this + 20)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(this + 8), (unint64_t)a2, a4);
  }
  return this;
}

uint64_t awd::metrics::AwddShutdown::ByteSize(wireless_diagnostics::google::protobuf::io::CodedOutputStream **this, unint64_t a2)
{
  if (*((unsigned char *)this + 20)) {
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(this[1], a2) + 1;
  }
  else {
    uint64_t result = 0;
  }
  *((_DWORD *)this + 4) = result;
  return result;
}

uint64_t awd::metrics::AwddShutdown::IsInitialized(awd::metrics::AwddShutdown *this)
{
  return 1;
}

void *awd::metrics::AwddShutdown::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.AwddShutdown");
}

void awd::metrics::AwddStartup::MergeFrom(awd::metrics::AwddStartup *this, const awd::metrics::AwddStartup *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v5);
  }
  if (*((unsigned char *)a2 + 20))
  {
    uint64_t v4 = *((void *)a2 + 1);
    *((_DWORD *)this + 5) |= 1u;
    *((void *)this + 1) = v4;
  }
}

void sub_10012BBB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::metrics::AwddStartup::~AwddStartup(awd::metrics::AwddStartup *this)
{
  *(void *)this = off_1001BE900;
  awd::metrics::protobuf_AddDesc_AwddMetricsGeneral_2eproto(this);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::metrics::AwddStartup::~AwddStartup(this);

  operator delete();
}

void awd::metrics::AwddStartup::New(awd::metrics::AwddStartup *this)
{
}

uint64_t awd::metrics::AwddStartup::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 20)) {
    *(void *)(this + 8) = 0;
  }
  *(_DWORD *)(this + 20) = 0;
  return this;
}

uint64_t awd::metrics::AwddStartup::MergePartialFromCodedStream(awd::metrics::AwddStartup *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)((char *)this + 8);
  while (1)
  {
    while (1)
    {
      int v6 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
      }
      else
      {
        unint64_t TagFallback = *v6;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v6 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unint64_t v9 = (char *)*((void *)a2 + 1);
      unint64_t v8 = *((void *)a2 + 2);
      if ((unint64_t)v9 >= v8 || *v9 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v5);
        if (!result) {
          return result;
        }
        unint64_t v10 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v8 = *((void *)a2 + 2);
      }
      else
      {
        *uint64_t v5 = *v9;
        unint64_t v10 = (unsigned __int8 *)(v9 + 1);
        *((void *)a2 + 1) = v10;
      }
      *((_DWORD *)this + 5) |= 1u;
      if (v10 == (unsigned __int8 *)v8 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t awd::metrics::AwddStartup::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(this + 20)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(this + 8), (unint64_t)a2, a4);
  }
  return this;
}

uint64_t awd::metrics::AwddStartup::ByteSize(wireless_diagnostics::google::protobuf::io::CodedOutputStream **this, unint64_t a2)
{
  if (*((unsigned char *)this + 20)) {
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(this[1], a2) + 1;
  }
  else {
    uint64_t result = 0;
  }
  *((_DWORD *)this + 4) = result;
  return result;
}

uint64_t awd::metrics::AwddStartup::IsInitialized(awd::metrics::AwddStartup *this)
{
  return 1;
}

void *awd::metrics::AwddStartup::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.AwddStartup");
}

void awd::metrics::BatteryPowerLevel::MergeFrom(awd::metrics::BatteryPowerLevel *this, const awd::metrics::BatteryPowerLevel *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 40);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 40))
    {
      uint64_t v6 = *((void *)a2 + 1);
      *((_DWORD *)this + 10) |= 1u;
      *((void *)this + 1) = v6;
      int v4 = *((_DWORD *)a2 + 10);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_12;
      }
    }
    else if ((*((unsigned char *)a2 + 40) & 2) == 0)
    {
      goto LABEL_6;
    }
    uint64_t v7 = *((void *)a2 + 2);
    *((_DWORD *)this + 10) |= 2u;
    *((void *)this + 2) = v7;
    int v4 = *((_DWORD *)a2 + 10);
    if ((v4 & 4) == 0)
    {
LABEL_7:
      if ((v4 & 8) == 0) {
        return;
      }
      goto LABEL_8;
    }
LABEL_12:
    uint64_t v8 = *((void *)a2 + 3);
    *((_DWORD *)this + 10) |= 4u;
    *((void *)this + 3) = v8;
    if ((*((_DWORD *)a2 + 10) & 8) == 0) {
      return;
    }
LABEL_8:
    char v5 = *((unsigned char *)a2 + 32);
    *((_DWORD *)this + 10) |= 8u;
    *((unsigned char *)this + 32) = v5;
  }
}

void sub_10012BF40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::metrics::BatteryPowerLevel::~BatteryPowerLevel(awd::metrics::BatteryPowerLevel *this)
{
  *(void *)this = off_1001BE978;
  awd::metrics::protobuf_AddDesc_AwddMetricsGeneral_2eproto(this);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::metrics::BatteryPowerLevel::~BatteryPowerLevel(this);

  operator delete();
}

void awd::metrics::BatteryPowerLevel::New(awd::metrics::BatteryPowerLevel *this)
{
}

uint64_t awd::metrics::BatteryPowerLevel::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 40))
  {
    *(void *)(this + 8) = 0;
    *(void *)(this + 16) = 0;
    *(unsigned char *)(this + 32) = 0;
    *(void *)(this + 24) = 0;
  }
  *(_DWORD *)(this + 40) = 0;
  return this;
}

uint64_t awd::metrics::BatteryPowerLevel::MergePartialFromCodedStream(awd::metrics::BatteryPowerLevel *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  char v5 = (unint64_t *)((char *)this + 8);
  while (2)
  {
    uint64_t v6 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v6;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v6 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        unint64_t v10 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
        if ((unint64_t)v10 < v9 && (*v10 & 0x80000000) == 0)
        {
          *char v5 = *v10;
          uint64_t v11 = v10 + 1;
          *((void *)a2 + 1) = v11;
LABEL_24:
          *((_DWORD *)this + 10) |= 1u;
          if ((unint64_t)v11 < v9 && *v11 == 16)
          {
            unsigned int v12 = v11 + 1;
            *((void *)a2 + 1) = v12;
            goto LABEL_27;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v5);
        if (result)
        {
          uint64_t v11 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
          goto LABEL_24;
        }
        break;
      case 2u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        unsigned int v12 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
LABEL_27:
        *(void *)int v22 = 0;
        if ((unint64_t)v12 >= v9 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, (unint64_t *)v22);
          if (!result) {
            return result;
          }
          uint64_t v15 = *(void *)v22;
          unsigned int v16 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
        }
        else
        {
          uint64_t v15 = *v12;
          unsigned int v16 = v12 + 1;
          *((void *)a2 + 1) = v16;
        }
        *((void *)this + 2) = v15;
        *((_DWORD *)this + 10) |= 2u;
        if ((unint64_t)v16 >= v9 || *v16 != 24) {
          continue;
        }
        char v13 = v16 + 1;
        *((void *)a2 + 1) = v13;
LABEL_35:
        v22[0] = 0;
        if ((unint64_t)v13 >= v9 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v22);
          if (!result) {
            return result;
          }
          unsigned int v17 = v22[0];
          int v18 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v17 = *v13;
          int v18 = v13 + 1;
          *((void *)a2 + 1) = v18;
        }
        *((unsigned char *)this + 32) = v17 != 0;
        *((_DWORD *)this + 10) |= 8u;
        if ((unint64_t)v18 >= v9 || *v18 != 32) {
          continue;
        }
        uint64_t v14 = v18 + 1;
        *((void *)a2 + 1) = v14;
LABEL_43:
        *(void *)int v22 = 0;
        if ((unint64_t)v14 >= v9 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, (unint64_t *)v22);
          if (!result) {
            return result;
          }
          uint64_t v19 = *(void *)v22;
          int v20 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
        }
        else
        {
          uint64_t v19 = *v14;
          int v20 = (unsigned __int8 *)(v14 + 1);
          *((void *)a2 + 1) = v20;
        }
        *((void *)this + 3) = v19;
        *((_DWORD *)this + 10) |= 4u;
        if (v20 != (unsigned __int8 *)v9 || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10)) {
          continue;
        }
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      case 3u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        char v13 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
        goto LABEL_35;
      case 4u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        uint64_t v14 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
        goto LABEL_43;
      default:
        int v8 = TagFallback & 7;
LABEL_18:
        if (v8 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t awd::metrics::BatteryPowerLevel::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 40);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(this + 8), (unint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 40);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 8) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(unsigned __int8 *)(v5 + 32), (BOOL)a2, a4);
      if ((*(_DWORD *)(v5 + 40) & 4) == 0) {
        return this;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(void *)(v5 + 16), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 40);
  if ((v6 & 8) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((v6 & 4) == 0) {
    return this;
  }
LABEL_9:
  uint64_t v7 = *(void *)(v5 + 24);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, (uint64_t)a2, a4);
}

uint64_t awd::metrics::BatteryPowerLevel::ByteSize(awd::metrics::BatteryPowerLevel *this, unint64_t a2)
{
  LOBYTE(v3) = *((unsigned char *)this + 40);
  if (!(_BYTE)v3)
  {
    uint64_t result = 0;
    goto LABEL_13;
  }
  if ((*((unsigned char *)this + 40) & 1) == 0)
  {
    unsigned int v4 = 0;
    if ((*((unsigned char *)this + 40) & 2) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 1), a2)+ 1;
  int v3 = *((_DWORD *)this + 10);
  if ((v3 & 2) != 0)
  {
LABEL_7:
    v4 += wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 2), a2)+ 1;
    int v3 = *((_DWORD *)this + 10);
  }
LABEL_8:
  if ((v3 & 4) != 0)
  {
    v4 += wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 3), a2)+ 1;
    int v3 = *((_DWORD *)this + 10);
  }
  if ((v3 & 8) != 0) {
    uint64_t result = v4 + 2;
  }
  else {
    uint64_t result = v4;
  }
LABEL_13:
  *((_DWORD *)this + 9) = result;
  return result;
}

uint64_t awd::metrics::BatteryPowerLevel::IsInitialized(awd::metrics::BatteryPowerLevel *this)
{
  return 1;
}

void *awd::metrics::BatteryPowerLevel::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.BatteryPowerLevel");
}

void awd::metrics::AwddAggregation::MergeFrom(awd::metrics::AwddAggregation *this, const awd::metrics::AwddAggregation *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v16);
  }
  int v4 = *((_DWORD *)a2 + 20);
  if (!(_BYTE)v4) {
    goto LABEL_13;
  }
  if (v4)
  {
    uint64_t v8 = *((void *)a2 + 1);
    *((_DWORD *)this + 20) |= 1u;
    *((void *)this + 1) = v8;
    int v4 = *((_DWORD *)a2 + 20);
    if ((v4 & 2) == 0)
    {
LABEL_6:
      if ((v4 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_23;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_6;
  }
  unint64_t v9 = (const std::string *)*((void *)a2 + 2);
  *((_DWORD *)this + 20) |= 2u;
  unint64_t v10 = (std::string *)*((void *)this + 2);
  if (v10 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v10, v9);
  int v4 = *((_DWORD *)a2 + 20);
  if ((v4 & 4) == 0)
  {
LABEL_7:
    if ((v4 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_24;
  }
LABEL_23:
  uint64_t v11 = *((void *)a2 + 3);
  *((_DWORD *)this + 20) |= 4u;
  *((void *)this + 3) = v11;
  int v4 = *((_DWORD *)a2 + 20);
  if ((v4 & 8) == 0)
  {
LABEL_8:
    if ((v4 & 0x10) == 0) {
      goto LABEL_9;
    }
    goto LABEL_25;
  }
LABEL_24:
  uint64_t v12 = *((void *)a2 + 4);
  *((_DWORD *)this + 20) |= 8u;
  *((void *)this + 4) = v12;
  int v4 = *((_DWORD *)a2 + 20);
  if ((v4 & 0x10) == 0)
  {
LABEL_9:
    if ((v4 & 0x20) == 0) {
      goto LABEL_10;
    }
LABEL_26:
    uint64_t v14 = *((void *)a2 + 6);
    *((_DWORD *)this + 20) |= 0x20u;
    *((void *)this + 6) = v14;
    int v4 = *((_DWORD *)a2 + 20);
    if ((v4 & 0x40) == 0)
    {
LABEL_11:
      if ((v4 & 0x80) == 0) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
    goto LABEL_27;
  }
LABEL_25:
  uint64_t v13 = *((void *)a2 + 5);
  *((_DWORD *)this + 20) |= 0x10u;
  *((void *)this + 5) = v13;
  int v4 = *((_DWORD *)a2 + 20);
  if ((v4 & 0x20) != 0) {
    goto LABEL_26;
  }
LABEL_10:
  if ((v4 & 0x40) == 0) {
    goto LABEL_11;
  }
LABEL_27:
  uint64_t v15 = *((void *)a2 + 7);
  *((_DWORD *)this + 20) |= 0x40u;
  *((void *)this + 7) = v15;
  int v4 = *((_DWORD *)a2 + 20);
  if ((v4 & 0x80) != 0)
  {
LABEL_12:
    uint64_t v5 = *((void *)a2 + 8);
    *((_DWORD *)this + 20) |= 0x80u;
    *((void *)this + 8) = v5;
    int v4 = *((_DWORD *)a2 + 20);
  }
LABEL_13:
  if ((v4 & 0xFF00) != 0)
  {
    if ((v4 & 0x100) != 0)
    {
      char v6 = *((unsigned char *)a2 + 72);
      *((_DWORD *)this + 20) |= 0x100u;
      *((unsigned char *)this + 72) = v6;
      int v4 = *((_DWORD *)a2 + 20);
    }
    if ((v4 & 0x200) != 0)
    {
      char v7 = *((unsigned char *)a2 + 73);
      *((_DWORD *)this + 20) |= 0x200u;
      *((unsigned char *)this + 73) = v7;
    }
  }
}

void sub_10012C680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::metrics::AwddAggregation::~AwddAggregation(awd::metrics::AwddAggregation *this)
{
  *(void *)this = off_1001BE9F0;
  awd::metrics::AwddAggregation::SharedDtor(this);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::metrics::AwddAggregation::~AwddAggregation(this);

  operator delete();
}

void awd::metrics::AwddAggregation::SharedDtor(awd::metrics::AwddAggregation *this)
{
  uint64_t v1 = *((void *)this + 2);
  if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }

  awd::metrics::protobuf_AddDesc_AwddMetricsGeneral_2eproto(this);
}

void awd::metrics::AwddAggregation::New(awd::metrics::AwddAggregation *this)
{
}

uint64_t awd::metrics::AwddAggregation::Clear(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 80);
  if ((_BYTE)v1)
  {
    *(void *)(this + 8) = 0;
    if ((v1 & 2) != 0)
    {
      uint64_t v2 = *(void *)(this + 16);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
    *(_OWORD *)(this + 56) = 0u;
    *(_OWORD *)(this + 40) = 0u;
    *(_OWORD *)(this + 24) = 0u;
    int v1 = *(_DWORD *)(this + 80);
  }
  if ((v1 & 0xFF00) != 0) {
    *(_WORD *)(this + 72) = 0;
  }
  *(_DWORD *)(this + 80) = 0;
  return this;
}

uint64_t awd::metrics::AwddAggregation::MergePartialFromCodedStream(awd::metrics::AwddAggregation *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)((char *)this + 8);
  char v6 = (unint64_t *)((char *)this + 24);
  char v7 = (unint64_t *)((char *)this + 32);
  while (2)
  {
    uint64_t v8 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v8;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v8 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_30;
        }
        uint64_t v12 = (char *)*((void *)a2 + 1);
        unint64_t v11 = *((void *)a2 + 2);
        if ((unint64_t)v12 < v11 && (*v12 & 0x80000000) == 0)
        {
          *uint64_t v5 = *v12;
          uint64_t v13 = v12 + 1;
          *((void *)a2 + 1) = v13;
LABEL_36:
          int v14 = *((_DWORD *)this + 20) | 1;
          *((_DWORD *)this + 20) = v14;
          if ((unint64_t)v13 < v11 && *v13 == 18)
          {
            *((void *)a2 + 1) = v13 + 1;
            goto LABEL_39;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v5);
        if (result)
        {
          uint64_t v13 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v11 = *((void *)a2 + 2);
          goto LABEL_36;
        }
        break;
      case 2u:
        int v10 = TagFallback & 7;
        if (v10 != 2) {
          goto LABEL_30;
        }
        int v14 = *((_DWORD *)this + 20);
LABEL_39:
        *((_DWORD *)this + 20) = v14 | 2;
        if (*((_UNKNOWN **)this + 2) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v24 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v15 = *((void *)a2 + 2);
        if ((unint64_t)v24 >= v15 || *v24 != 24) {
          continue;
        }
        unsigned int v16 = v24 + 1;
        *((void *)a2 + 1) = v16;
LABEL_45:
        if ((unint64_t)v16 >= v15 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v6);
          if (!result) {
            return result;
          }
          uint64_t v25 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v15 = *((void *)a2 + 2);
        }
        else
        {
          *char v6 = *v16;
          uint64_t v25 = v16 + 1;
          *((void *)a2 + 1) = v25;
        }
        *((_DWORD *)this + 20) |= 4u;
        if ((unint64_t)v25 >= v15 || *v25 != 32) {
          continue;
        }
        unsigned int v17 = v25 + 1;
        *((void *)a2 + 1) = v17;
LABEL_53:
        if ((unint64_t)v17 >= v15 || *v17 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v7);
          if (!result) {
            return result;
          }
          int v26 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v15 = *((void *)a2 + 2);
        }
        else
        {
          unint64_t *v7 = *v17;
          int v26 = v17 + 1;
          *((void *)a2 + 1) = v26;
        }
        *((_DWORD *)this + 20) |= 8u;
        if ((unint64_t)v26 >= v15 || *v26 != 40) {
          continue;
        }
        int v18 = v26 + 1;
        *((void *)a2 + 1) = v18;
LABEL_61:
        *(void *)uint64_t v40 = 0;
        if ((unint64_t)v18 >= v15 || *v18 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, (unint64_t *)v40);
          if (!result) {
            return result;
          }
          uint64_t v27 = *(void *)v40;
          uint64_t v28 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v15 = *((void *)a2 + 2);
        }
        else
        {
          uint64_t v27 = *v18;
          uint64_t v28 = v18 + 1;
          *((void *)a2 + 1) = v28;
        }
        *((void *)this + 5) = v27;
        *((_DWORD *)this + 20) |= 0x10u;
        if ((unint64_t)v28 >= v15 || *v28 != 48) {
          continue;
        }
        uint64_t v19 = v28 + 1;
        *((void *)a2 + 1) = v19;
LABEL_69:
        *(void *)uint64_t v40 = 0;
        if ((unint64_t)v19 >= v15 || *v19 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, (unint64_t *)v40);
          if (!result) {
            return result;
          }
          uint64_t v29 = *(void *)v40;
          int v30 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v15 = *((void *)a2 + 2);
        }
        else
        {
          uint64_t v29 = *v19;
          int v30 = v19 + 1;
          *((void *)a2 + 1) = v30;
        }
        *((void *)this + 6) = v29;
        *((_DWORD *)this + 20) |= 0x20u;
        if ((unint64_t)v30 >= v15 || *v30 != 56) {
          continue;
        }
        int v20 = v30 + 1;
        *((void *)a2 + 1) = v20;
LABEL_77:
        *(void *)uint64_t v40 = 0;
        if ((unint64_t)v20 >= v15 || *v20 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, (unint64_t *)v40);
          if (!result) {
            return result;
          }
          uint64_t v31 = *(void *)v40;
          int v32 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v15 = *((void *)a2 + 2);
        }
        else
        {
          uint64_t v31 = *v20;
          int v32 = v20 + 1;
          *((void *)a2 + 1) = v32;
        }
        *((void *)this + 7) = v31;
        *((_DWORD *)this + 20) |= 0x40u;
        if ((unint64_t)v32 >= v15 || *v32 != 64) {
          continue;
        }
        int v21 = v32 + 1;
        *((void *)a2 + 1) = v21;
LABEL_85:
        *(void *)uint64_t v40 = 0;
        if ((unint64_t)v21 >= v15 || *v21 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, (unint64_t *)v40);
          if (!result) {
            return result;
          }
          uint64_t v33 = *(void *)v40;
          uint64_t v34 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v15 = *((void *)a2 + 2);
        }
        else
        {
          uint64_t v33 = *v21;
          uint64_t v34 = v21 + 1;
          *((void *)a2 + 1) = v34;
        }
        *((void *)this + 8) = v33;
        *((_DWORD *)this + 20) |= 0x80u;
        if ((unint64_t)v34 >= v15 || *v34 != 72) {
          continue;
        }
        int v22 = v34 + 1;
        *((void *)a2 + 1) = v22;
LABEL_93:
        v40[0] = 0;
        if ((unint64_t)v22 >= v15 || *v22 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v40);
          if (!result) {
            return result;
          }
          unsigned int v35 = v40[0];
          int v36 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v15 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v35 = *v22;
          int v36 = v22 + 1;
          *((void *)a2 + 1) = v36;
        }
        *((unsigned char *)this + 72) = v35 != 0;
        *((_DWORD *)this + 20) |= 0x100u;
        if ((unint64_t)v36 >= v15 || *v36 != 80) {
          continue;
        }
        dispatch_time_t v23 = v36 + 1;
        *((void *)a2 + 1) = v23;
LABEL_101:
        v40[0] = 0;
        if ((unint64_t)v23 >= v15 || *v23 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v40);
          if (!result) {
            return result;
          }
          unsigned int v37 = v40[0];
          int v38 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v15 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v37 = *v23;
          int v38 = (unsigned __int8 *)(v23 + 1);
          *((void *)a2 + 1) = v38;
        }
        *((unsigned char *)this + 73) = v37 != 0;
        *((_DWORD *)this + 20) |= 0x200u;
        if (v38 != (unsigned __int8 *)v15 || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10)) {
          continue;
        }
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      case 3u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_30;
        }
        unsigned int v16 = (char *)*((void *)a2 + 1);
        unint64_t v15 = *((void *)a2 + 2);
        goto LABEL_45;
      case 4u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_30;
        }
        unsigned int v17 = (char *)*((void *)a2 + 1);
        unint64_t v15 = *((void *)a2 + 2);
        goto LABEL_53;
      case 5u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_30;
        }
        int v18 = (char *)*((void *)a2 + 1);
        unint64_t v15 = *((void *)a2 + 2);
        goto LABEL_61;
      case 6u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_30;
        }
        uint64_t v19 = (char *)*((void *)a2 + 1);
        unint64_t v15 = *((void *)a2 + 2);
        goto LABEL_69;
      case 7u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_30;
        }
        int v20 = (char *)*((void *)a2 + 1);
        unint64_t v15 = *((void *)a2 + 2);
        goto LABEL_77;
      case 8u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_30;
        }
        int v21 = (char *)*((void *)a2 + 1);
        unint64_t v15 = *((void *)a2 + 2);
        goto LABEL_85;
      case 9u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_30;
        }
        int v22 = (char *)*((void *)a2 + 1);
        unint64_t v15 = *((void *)a2 + 2);
        goto LABEL_93;
      case 0xAu:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_30;
        }
        dispatch_time_t v23 = (char *)*((void *)a2 + 1);
        unint64_t v15 = *((void *)a2 + 2);
        goto LABEL_101;
      default:
        int v10 = TagFallback & 7;
LABEL_30:
        if (v10 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t awd::metrics::AwddAggregation::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 80);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(this + 8), (unint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 80);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_14;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_15;
  }
LABEL_14:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(void *)(v5 + 24), (unint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_16;
  }
LABEL_15:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(void *)(v5 + 32), (unint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_17;
  }
LABEL_16:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, *(void *)(v5 + 40), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_18;
  }
LABEL_17:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, *(void *)(v5 + 48), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_19;
  }
LABEL_18:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, *(void *)(v5 + 56), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0) {
      goto LABEL_10;
    }
LABEL_20:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, *(unsigned __int8 *)(v5 + 72), (BOOL)a2, a4);
    if ((*(_DWORD *)(v5 + 80) & 0x200) == 0) {
      return this;
    }
    goto LABEL_21;
  }
LABEL_19:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8, *(void *)(v5 + 64), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x100) != 0) {
    goto LABEL_20;
  }
LABEL_10:
  if ((v6 & 0x200) == 0) {
    return this;
  }
LABEL_21:
  int v7 = *(unsigned __int8 *)(v5 + 73);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, v7, (BOOL)a2, a4);
}

uint64_t awd::metrics::AwddAggregation::ByteSize(awd::metrics::AwddAggregation *this, unint64_t a2)
{
  int v3 = *((_DWORD *)this + 20);
  if (!(_BYTE)v3)
  {
    unsigned int v4 = 0;
    goto LABEL_23;
  }
  if (v3)
  {
    unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 1), a2)+ 1;
    int v3 = *((_DWORD *)this + 20);
    if ((v3 & 2) == 0) {
      goto LABEL_16;
    }
  }
  else
  {
    unsigned int v4 = 0;
    if ((v3 & 2) == 0) {
      goto LABEL_16;
    }
  }
  uint64_t v5 = *((void *)this + 2);
  int v6 = *(unsigned __int8 *)(v5 + 23);
  char v7 = v6;
  uint64_t v8 = *(void *)(v5 + 8);
  if ((v6 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 >= 0x80)
  {
    int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9, a2);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v8 = *(void *)(v5 + 8);
    int v3 = *((_DWORD *)this + 20);
    char v7 = *(unsigned char *)(v5 + 23);
  }
  else
  {
    int v10 = 1;
  }
  if (v7 < 0) {
    int v6 = v8;
  }
  v4 += v10 + v6 + 1;
LABEL_16:
  if ((v3 & 4) != 0)
  {
    v4 += wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 3), a2)+ 1;
    int v3 = *((_DWORD *)this + 20);
    if ((v3 & 8) == 0)
    {
LABEL_18:
      if ((v3 & 0x10) == 0) {
        goto LABEL_19;
      }
      goto LABEL_33;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_18;
  }
  v4 += wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 4), a2)+ 1;
  int v3 = *((_DWORD *)this + 20);
  if ((v3 & 0x10) == 0)
  {
LABEL_19:
    if ((v3 & 0x20) == 0) {
      goto LABEL_20;
    }
    goto LABEL_34;
  }
LABEL_33:
  v4 += wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 5), a2)+ 1;
  int v3 = *((_DWORD *)this + 20);
  if ((v3 & 0x20) == 0)
  {
LABEL_20:
    if ((v3 & 0x40) == 0) {
      goto LABEL_21;
    }
    goto LABEL_35;
  }
LABEL_34:
  v4 += wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 6), a2)+ 1;
  int v3 = *((_DWORD *)this + 20);
  if ((v3 & 0x40) == 0)
  {
LABEL_21:
    if ((v3 & 0x80) == 0) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
LABEL_35:
  v4 += wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 7), a2)+ 1;
  int v3 = *((_DWORD *)this + 20);
  if ((v3 & 0x80) != 0)
  {
LABEL_22:
    v4 += wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 8), a2)+ 1;
    int v3 = *((_DWORD *)this + 20);
  }
LABEL_23:
  unsigned int v11 = v4 + 2;
  if ((v3 & 0x100) == 0) {
    unsigned int v11 = v4;
  }
  if ((v3 & 0x200) != 0) {
    v11 += 2;
  }
  if ((v3 & 0xFF00) != 0) {
    uint64_t result = v11;
  }
  else {
    uint64_t result = v4;
  }
  *((_DWORD *)this + 19) = result;
  return result;
}

uint64_t awd::metrics::AwddAggregation::IsInitialized(awd::metrics::AwddAggregation *this)
{
  return 1;
}

void *awd::metrics::AwddAggregation::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.metrics.AwddAggregation");
}

uint64_t sub_10012D130(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t sub_10012D138(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t sub_10012D140(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t sub_10012D148(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t sub_10012D150(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t sub_10012D158(uint64_t a1)
{
  return *(unsigned int *)(a1 + 76);
}

uint64_t awd::profile::protobuf_ShutdownFile_AwdProfile_2eproto(awd::profile *this)
{
  if (awd::profile::ProcessingRule::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::ProcessingRule::default_instance_ + 8))(awd::profile::ProcessingRule::default_instance_);
  }
  if (awd::profile::BedfTreeNode::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::BedfTreeNode::default_instance_ + 8))(awd::profile::BedfTreeNode::default_instance_);
  }
  if (awd::profile::BedfConfig::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::BedfConfig::default_instance_ + 8))(awd::profile::BedfConfig::default_instance_);
  }
  if (awd::profile::Metric::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::Metric::default_instance_ + 8))(awd::profile::Metric::default_instance_);
  }
  if (awd::profile::Profile::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::Profile::default_instance_ + 8))(awd::profile::Profile::default_instance_);
  }
  if (awd::profile::LogParameter::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::LogParameter::default_instance_ + 8))(awd::profile::LogParameter::default_instance_);
  }
  if (awd::profile::Log::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::Log::default_instance_ + 8))(awd::profile::Log::default_instance_);
  }
  if (awd::profile::ConfigurationParameter::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::ConfigurationParameter::default_instance_ + 8))(awd::profile::ConfigurationParameter::default_instance_);
  }
  if (awd::profile::ComponentConfiguration::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::ComponentConfiguration::default_instance_ + 8))(awd::profile::ComponentConfiguration::default_instance_);
  }
  if (awd::profile::TimerSpec::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::TimerSpec::default_instance_ + 8))(awd::profile::TimerSpec::default_instance_);
  }
  if (awd::profile::TypeVariant::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::TypeVariant::default_instance_ + 8))(awd::profile::TypeVariant::default_instance_);
  }
  if (awd::profile::Condition::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::Condition::default_instance_ + 8))(awd::profile::Condition::default_instance_);
  }
  if (awd::profile::ConditionClause::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::ConditionClause::default_instance_ + 8))(awd::profile::ConditionClause::default_instance_);
  }
  if (awd::profile::TriggerSource::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::TriggerSource::default_instance_ + 8))(awd::profile::TriggerSource::default_instance_);
  }
  if (awd::profile::TriggerProcessingRule::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::TriggerProcessingRule::default_instance_ + 8))(awd::profile::TriggerProcessingRule::default_instance_);
  }
  if (awd::profile::AggregationSpec::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::AggregationSpec::default_instance_ + 8))(awd::profile::AggregationSpec::default_instance_);
  }
  if (awd::profile::MetricFileSpec::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::MetricFileSpec::default_instance_ + 8))(awd::profile::MetricFileSpec::default_instance_);
  }
  if (awd::profile::TaskingCriteria::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)awd::profile::TaskingCriteria::default_instance_ + 8))(awd::profile::TaskingCriteria::default_instance_);
  }
  uint64_t result = awd::profile::DeviceConfiguration::default_instance_;
  if (awd::profile::DeviceConfiguration::default_instance_)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)awd::profile::DeviceConfiguration::default_instance_ + 8);
    return v2();
  }
  return result;
}

void awd::profile::protobuf_AddDesc_AwdProfile_2eproto_impl(awd::profile *this, uint64_t a2, uint64_t a3, const char *a4)
{
}

double awd::profile::TypeVariant::TypeVariant(awd::profile::TypeVariant *this)
{
  *(void *)this = off_1001BEFA8;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_DWORD *)this + 10) = 0;
  *((unsigned char *)this + 44) = 0;
  *((void *)this + 6) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *((void *)this + 7) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  return result;
}

double awd::profile::MetricFileSpec::MetricFileSpec(awd::profile::MetricFileSpec *this)
{
  *(void *)this = off_1001BF278;
  double result = COERCE_DOUBLE(&_mh_execute_header);
  *((void *)this + 1) = &_mh_execute_header;
  *((_DWORD *)this + 4) = 0;
  *((unsigned char *)this + 20) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  return result;
}

uint64_t awd::profile::DeviceConfiguration::DeviceConfiguration(uint64_t this)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = off_1001BF368;
  *(_DWORD *)(this + 24) = 0;
  *(void *)(this + 40) = 0;
  *(void *)(this + 48) = 0;
  *(_DWORD *)(this + 56) = 0;
  *(void *)(this + 80) = 0;
  *(_DWORD *)(this + 88) = 0;
  *(void *)(this + 96) = 0;
  *(void *)(this + 104) = 0;
  *(_DWORD *)(this + 112) = 0;
  *(void *)(this + 120) = 0;
  *(void *)(this + 128) = 0;
  *(_DWORD *)(this + 136) = 0;
  *(_DWORD *)(this + 168) = 0;
  *(void *)(this + 160) = 0;
  *(void *)(this + 176) = 0;
  *(void *)(this + 184) = 0;
  *(_DWORD *)(this + 192) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(unsigned char *)(this + 36) = 0;
  *(void *)(this + 200) = 0;
  *(void *)(this + 64) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(this + 72) = 0;
  *(void *)(this + 144) = 0;
  *(void *)(this + 152) = 0;
  *(_DWORD *)(this + 208) = 0;
  return this;
}

void awd::profile::protobuf_AddDesc_AwdProfile_2eproto(awd::profile *this)
{
  uint64_t v1 = awd::profile::protobuf_AddDesc_AwdProfile_2eproto_once_;
  __dmb(0xBu);
  if (v1 != 2)
  {
    v2[1] = awd::profile::protobuf_AddDesc_AwdProfile_2eproto_impl;
    char v3 = 0;
    wireless_diagnostics::google::protobuf::GoogleOnceInitImpl();
    wireless_diagnostics::google::protobuf::internal::FunctionClosure0::~FunctionClosure0((wireless_diagnostics::google::protobuf::internal::FunctionClosure0 *)v2);
  }
}

void sub_10012DDC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  wireless_diagnostics::google::protobuf::internal::FunctionClosure0::~FunctionClosure0((wireless_diagnostics::google::protobuf::internal::FunctionClosure0 *)va);
  _Unwind_Resume(a1);
}

void awd::profile::ProcessingRule::MergeFrom(awd::profile::ProcessingRule *this, const awd::profile::ProcessingRule *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v13);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 52);
  if (!(_BYTE)v4) {
    return;
  }
  if (*((unsigned char *)a2 + 52))
  {
    int v6 = *((_DWORD *)a2 + 4);
    *((_DWORD *)this + 13) |= 1u;
    *((_DWORD *)this + 4) = v6;
    int v4 = *((_DWORD *)a2 + 13);
    if ((v4 & 2) == 0)
    {
LABEL_6:
      if ((v4 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_15;
    }
  }
  else if ((*((unsigned char *)a2 + 52) & 2) == 0)
  {
    goto LABEL_6;
  }
  uint64_t v7 = *((void *)a2 + 1);
  *((_DWORD *)this + 13) |= 2u;
  *((void *)this + 1) = v7;
  int v4 = *((_DWORD *)a2 + 13);
  if ((v4 & 4) == 0)
  {
LABEL_7:
    if ((v4 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_16;
  }
LABEL_15:
  uint64_t v8 = *((void *)a2 + 3);
  *((_DWORD *)this + 13) |= 4u;
  *((void *)this + 3) = v8;
  int v4 = *((_DWORD *)a2 + 13);
  if ((v4 & 8) == 0)
  {
LABEL_8:
    if ((v4 & 0x10) == 0) {
      goto LABEL_9;
    }
LABEL_17:
    char v10 = *((unsigned char *)a2 + 40);
    *((_DWORD *)this + 13) |= 0x10u;
    *((unsigned char *)this + 40) = v10;
    int v4 = *((_DWORD *)a2 + 13);
    if ((v4 & 0x20) == 0)
    {
LABEL_10:
      if ((v4 & 0x40) == 0) {
        return;
      }
      goto LABEL_11;
    }
    goto LABEL_18;
  }
LABEL_16:
  int v9 = *((_DWORD *)a2 + 5);
  *((_DWORD *)this + 13) |= 8u;
  *((_DWORD *)this + 5) = v9;
  int v4 = *((_DWORD *)a2 + 13);
  if ((v4 & 0x10) != 0) {
    goto LABEL_17;
  }
LABEL_9:
  if ((v4 & 0x20) == 0) {
    goto LABEL_10;
  }
LABEL_18:
  *((_DWORD *)this + 13) |= 0x20u;
  unsigned int v11 = (awd::profile::ProcessingRule *)*((void *)this + 4);
  if (!v11) {
    operator new();
  }
  uint64_t v12 = (const awd::profile::ProcessingRule *)*((void *)a2 + 4);
  if (!v12)
  {
    awd::profile::protobuf_AddDesc_AwdProfile_2eproto(this);
    uint64_t v12 = *(const awd::profile::ProcessingRule **)(awd::profile::ProcessingRule::default_instance_ + 32);
  }
  awd::profile::ProcessingRule::MergeFrom(v11, v12);
  if ((*((_DWORD *)a2 + 13) & 0x40) != 0)
  {
LABEL_11:
    int v5 = *((_DWORD *)a2 + 11);
    *((_DWORD *)this + 13) |= 0x40u;
    *((_DWORD *)this + 11) = v5;
  }
}

void sub_10012DFA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::profile::ProcessingRule::~ProcessingRule(awd::profile::ProcessingRule *this)
{
  *(void *)this = off_1001BEAF8;
  awd::profile::ProcessingRule::SharedDtor(this);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::profile::ProcessingRule::~ProcessingRule(this);

  operator delete();
}

void awd::profile::ProcessingRule::SharedDtor(awd::profile::ProcessingRule *this)
{
  awd::profile::protobuf_AddDesc_AwdProfile_2eproto(this);
  if ((awd::profile::ProcessingRule *)awd::profile::ProcessingRule::default_instance_ != this)
  {
    uint64_t v2 = *((void *)this + 4);
    if (v2)
    {
      char v3 = *(void (**)(void))(*(void *)v2 + 8);
      v3();
    }
  }
}

uint64_t awd::profile::ProcessingRule::default_instance(awd::profile::ProcessingRule *this)
{
  return awd::profile::ProcessingRule::default_instance_;
}

void awd::profile::ProcessingRule::New(awd::profile::ProcessingRule *this)
{
}

uint64_t awd::profile::ProcessingRule::Clear(uint64_t this)
{
  uint64_t v1 = this;
  char v2 = *(unsigned char *)(this + 52);
  if (v2)
  {
    *(unsigned char *)(this + 40) = 0;
    *(void *)(this + 16) = 0;
    *(void *)(this + 24) = 0;
    *(void *)(this + 8) = 0;
    if ((v2 & 0x20) != 0)
    {
      this = *(void *)(this + 32);
      if (this) {
        this = awd::profile::ProcessingRule::Clear((awd::profile::ProcessingRule *)this);
      }
    }
    *(_DWORD *)(v1 + 44) = 0;
  }
  *(_DWORD *)(v1 + 52) = 0;
  return this;
}

uint64_t awd::profile::ProcessingRule::MergePartialFromCodedStream(awd::profile::ProcessingRule *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  int v5 = (unsigned int *)((char *)this + 16);
  int v6 = (unint64_t *)((char *)this + 8);
  uint64_t v7 = (unsigned int *)((char *)this + 20);
  uint64_t v8 = (unsigned int *)((char *)this + 44);
  while (2)
  {
    int v9 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v9 >= *((void *)a2 + 2) || *v9 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v9;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v9 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 0x10u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        uint64_t v13 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 2);
        goto LABEL_10;
      case 0x11u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        unsigned int v17 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 2);
        goto LABEL_76;
      case 0x12u:
        int v11 = TagFallback & 7;
        if (v11 != 2) {
          goto LABEL_34;
        }
        int v18 = *((_DWORD *)this + 13);
        goto LABEL_22;
      case 0x13u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        int v22 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v21 = *((void *)a2 + 2);
        goto LABEL_47;
      case 0x14u:
        int v11 = TagFallback & 7;
        if (v11 == 1) {
          goto LABEL_56;
        }
        goto LABEL_34;
      case 0x15u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        int v24 = (char *)*((void *)a2 + 1);
        unint64_t v23 = *((void *)a2 + 2);
        goto LABEL_61;
      default:
        if (TagFallback >> 3 != 1)
        {
          int v11 = TagFallback & 7;
LABEL_34:
          if (v11 == 4) {
            return 1;
          }
          if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
          continue;
          }
        }
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        unint64_t v15 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 2);
        if ((unint64_t)v15 >= v12 || (char)*v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v5);
          if (!result) {
            return result;
          }
          unsigned int v16 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v12 = *((void *)a2 + 2);
        }
        else
        {
          *int v5 = *v15;
          unsigned int v16 = v15 + 1;
          *((void *)a2 + 1) = v16;
        }
        *((_DWORD *)this + 13) |= 1u;
        if ((int)v12 - (int)v16 < 2 || *v16 != 128 || v16[1] != 1) {
          continue;
        }
        uint64_t v13 = v16 + 2;
        *((void *)a2 + 1) = v13;
LABEL_10:
        if ((unint64_t)v13 >= v12 || (char)*v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v6);
          if (!result) {
            return result;
          }
          int v14 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v12 = *((void *)a2 + 2);
        }
        else
        {
          *int v6 = *v13;
          int v14 = v13 + 1;
          *((void *)a2 + 1) = v14;
        }
        *((_DWORD *)this + 13) |= 2u;
        if ((int)v12 - (int)v14 < 2 || *v14 != 136 || v14[1] != 1) {
          continue;
        }
        unsigned int v17 = v14 + 2;
        *((void *)a2 + 1) = v17;
LABEL_76:
        v38[0] = 0;
        if ((unint64_t)v17 >= v12 || (char)*v17 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v38);
          if (!result) {
            return result;
          }
          unsigned int v36 = v38[0];
          unsigned int v37 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v12 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v36 = *v17;
          unsigned int v37 = v17 + 1;
          *((void *)a2 + 1) = v37;
        }
        *((unsigned char *)this + 40) = v36 != 0;
        int v18 = *((_DWORD *)this + 13) | 0x10;
        *((_DWORD *)this + 13) = v18;
        if ((int)v12 - (int)v37 < 2 || *v37 != 146 || v37[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v37 + 2;
LABEL_22:
        *((_DWORD *)this + 13) = v18 | 0x20;
        uint64_t v19 = (awd::profile::ProcessingRule *)*((void *)this + 4);
        if (!v19) {
          operator new();
        }
        v38[0] = 0;
        int v20 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v20 >= *((void *)a2 + 2) || *v20 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v38))return 0; {
        }
          }
        else
        {
          v38[0] = *v20;
          *((void *)a2 + 1) = v20 + 1;
        }
        int v25 = *((_DWORD *)a2 + 14);
        int v26 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v25 + 1;
        if (v25 < v26)
        {
          int v27 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2, v38[0]);
          if (awd::profile::ProcessingRule::MergePartialFromCodedStream(v19, a2))
          {
            if (*((unsigned char *)a2 + 36))
            {
              wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2, v27);
              int v28 = *((_DWORD *)a2 + 14);
              BOOL v29 = __OFSUB__(v28, 1);
              int v30 = v28 - 1;
              if (v30 < 0 == v29) {
                *((_DWORD *)a2 + 14) = v30;
              }
              uint64_t v31 = (unsigned __int8 *)*((void *)a2 + 1);
              unint64_t v21 = *((void *)a2 + 2);
              if ((int)v21 - (int)v31 > 1 && *v31 == 152 && v31[1] == 1)
              {
                int v22 = v31 + 2;
                *((void *)a2 + 1) = v22;
LABEL_47:
                if ((unint64_t)v22 >= v21 || (char)*v22 < 0)
                {
                  uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v7);
                  if (!result) {
                    return result;
                  }
                  int v32 = (unsigned __int8 *)*((void *)a2 + 1);
                  unint64_t v21 = *((void *)a2 + 2);
                }
                else
                {
                  unsigned int *v7 = *v22;
                  int v32 = v22 + 1;
                  *((void *)a2 + 1) = v32;
                }
                *((_DWORD *)this + 13) |= 8u;
                if ((int)v21 - (int)v32 >= 2 && *v32 == 161 && v32[1] == 1)
                {
                  *((void *)a2 + 1) = v32 + 2;
LABEL_56:
                  *(void *)int v38 = 0;
                  if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v38) & 1) == 0)return 0; {
                  *((void *)this + 3) = *(void *)v38;
                  }
                  *((_DWORD *)this + 13) |= 4u;
                  uint64_t v34 = (unsigned __int8 *)*((void *)a2 + 1);
                  unint64_t v23 = *((void *)a2 + 2);
                  if ((int)v23 - (int)v34 >= 2 && *v34 == 168 && v34[1] == 1)
                  {
                    int v24 = (char *)(v34 + 2);
                    *((void *)a2 + 1) = v24;
LABEL_61:
                    if ((unint64_t)v24 >= v23 || *v24 < 0)
                    {
                      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v8);
                      if (!result) {
                        return result;
                      }
                      unsigned int v35 = (unsigned __int8 *)*((void *)a2 + 1);
                      unint64_t v23 = *((void *)a2 + 2);
                    }
                    else
                    {
                      unsigned int *v8 = *v24;
                      unsigned int v35 = (unsigned __int8 *)(v24 + 1);
                      *((void *)a2 + 1) = v35;
                    }
                    *((_DWORD *)this + 13) |= 0x40u;
                    if (v35 == (unsigned __int8 *)v23
                      && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
                    {
                      *((_DWORD *)a2 + 8) = 0;
                      uint64_t result = 1;
                      *((unsigned char *)a2 + 36) = 1;
                      return result;
                    }
                  }
                }
              }
              continue;
            }
          }
        }
        return 0;
    }
  }
}

int *awd::profile::ProcessingRule::SerializeWithCachedSizes(int *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v5 = this;
  int v6 = this[13];
  if (v6)
  {
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, this[4], a2, a4);
    int v6 = v5[13];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 0x10) == 0) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x10, *((void *)v5 + 1), (unint64_t)a2, a4);
  int v6 = v5[13];
  if ((v6 & 0x10) == 0)
  {
LABEL_4:
    if ((v6 & 0x20) == 0) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }
LABEL_11:
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x11, *((unsigned __int8 *)v5 + 40), (BOOL)a2, a4);
  int v6 = v5[13];
  if ((v6 & 0x20) == 0)
  {
LABEL_5:
    if ((v6 & 8) == 0) {
      goto LABEL_6;
    }
    goto LABEL_15;
  }
LABEL_12:
  uint64_t v7 = *((void *)v5 + 4);
  if (!v7)
  {
    awd::profile::protobuf_AddDesc_AwdProfile_2eproto((awd::profile *)this);
    uint64_t v7 = *(void *)(awd::profile::ProcessingRule::default_instance_ + 32);
  }
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x12, v7, a2, a4);
  int v6 = v5[13];
  if ((v6 & 8) == 0)
  {
LABEL_6:
    if ((v6 & 4) == 0) {
      goto LABEL_7;
    }
LABEL_16:
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x14, (int)a2, *((double *)v5 + 3), a3);
    if ((v5[13] & 0x40) == 0) {
      return this;
    }
    goto LABEL_17;
  }
LABEL_15:
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x13, v5[5], a2, a4);
  int v6 = v5[13];
  if ((v6 & 4) != 0) {
    goto LABEL_16;
  }
LABEL_7:
  if ((v6 & 0x40) == 0) {
    return this;
  }
LABEL_17:
  int v8 = v5[11];

  return (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x15, v8, a2, a4);
}

uint64_t awd::profile::ProcessingRule::ByteSize(awd::profile::ProcessingRule *this, unint64_t a2)
{
  LOBYTE(v3) = *((unsigned char *)this + 52);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_33;
  }
  if ((*((unsigned char *)this + 52) & 1) == 0)
  {
    LODWORD(v4) = 0;
    if ((*((unsigned char *)this + 52) & 2) == 0) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  int v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 4);
  if (v5 < 0x80)
  {
    LODWORD(v4) = 2;
    if ((v3 & 2) == 0) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  LODWORD(v4) = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
  int v3 = *((_DWORD *)this + 13);
  if ((v3 & 2) != 0)
  {
LABEL_10:
    LODWORD(v4) = v4
                + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 1), a2)+ 2;
    int v3 = *((_DWORD *)this + 13);
  }
LABEL_11:
  if ((v3 & 4) != 0) {
    LODWORD(v4) = v4 + 10;
  }
  if ((v3 & 8) != 0)
  {
    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 5);
    if (v6 >= 0x80)
    {
      int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 2;
      int v3 = *((_DWORD *)this + 13);
    }
    else
    {
      int v7 = 3;
    }
    LODWORD(v4) = v7 + v4;
  }
  if ((v3 & 0x10) != 0) {
    uint64_t v4 = (v4 + 3);
  }
  else {
    uint64_t v4 = v4;
  }
  if ((v3 & 0x20) != 0)
  {
    int v8 = (awd::profile::ProcessingRule *)*((void *)this + 4);
    if (!v8)
    {
      awd::profile::protobuf_AddDesc_AwdProfile_2eproto(0);
      int v8 = *(awd::profile::ProcessingRule **)(awd::profile::ProcessingRule::default_instance_ + 32);
    }
    int v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)awd::profile::ProcessingRule::ByteSize(v8);
    int v10 = (int)v9;
    if (v9 >= 0x80) {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, a2);
    }
    else {
      int v11 = 1;
    }
    uint64_t v4 = (v4 + v10 + v11 + 2);
    int v3 = *((_DWORD *)this + 13);
  }
  if ((v3 & 0x40) != 0)
  {
    unint64_t v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 11);
    if (v12 >= 0x80) {
      int v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v12, a2) + 2;
    }
    else {
      int v13 = 3;
    }
    uint64_t v4 = (v13 + v4);
  }
LABEL_33:
  *((_DWORD *)this + 12) = v4;
  return v4;
}

uint64_t awd::profile::ProcessingRule::IsInitialized(awd::profile::ProcessingRule *this)
{
  return 1;
}

void *awd::profile::ProcessingRule::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.profile.ProcessingRule");
}

void awd::profile::BedfTreeNode::MergeFrom(awd::profile::BedfTreeNode *this, const awd::profile::BedfTreeNode *a2)
{
  int v3 = this;
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v14);
  }
  int v4 = *((_DWORD *)a2 + 12);
  if (v4)
  {
    sub_10004BAE8((uint64_t)v3 + 40, *((_DWORD *)v3 + 12) + v4);
    this = (awd::profile::BedfTreeNode *)memcpy((void *)(*((void *)v3 + 5) + 4 * *((int *)v3 + 12)), *((const void **)a2 + 5), 4 * *((int *)a2 + 12));
    *((_DWORD *)v3 + 12) += *((_DWORD *)a2 + 12);
  }
  LOBYTE(v5) = *((unsigned char *)a2 + 60);
  if ((_BYTE)v5)
  {
    if (*((unsigned char *)a2 + 60))
    {
      int v7 = *((_DWORD *)a2 + 2);
      *((_DWORD *)v3 + 15) |= 1u;
      *((_DWORD *)v3 + 2) = v7;
      int v5 = *((_DWORD *)a2 + 15);
      if ((v5 & 2) == 0)
      {
LABEL_8:
        if ((v5 & 4) == 0) {
          goto LABEL_9;
        }
        goto LABEL_16;
      }
    }
    else if ((*((unsigned char *)a2 + 60) & 2) == 0)
    {
      goto LABEL_8;
    }
    int v8 = *((_DWORD *)a2 + 3);
    *((_DWORD *)v3 + 15) |= 2u;
    *((_DWORD *)v3 + 3) = v8;
    int v5 = *((_DWORD *)a2 + 15);
    if ((v5 & 4) == 0)
    {
LABEL_9:
      if ((v5 & 8) == 0) {
        goto LABEL_10;
      }
      goto LABEL_21;
    }
LABEL_16:
    *((_DWORD *)v3 + 15) |= 4u;
    int v9 = (awd::profile::BedfTreeNode *)*((void *)v3 + 2);
    if (!v9) {
      operator new();
    }
    int v10 = (const awd::profile::BedfTreeNode *)*((void *)a2 + 2);
    if (!v10)
    {
      awd::profile::protobuf_AddDesc_AwdProfile_2eproto(this);
      int v10 = *(const awd::profile::BedfTreeNode **)(awd::profile::BedfTreeNode::default_instance_ + 16);
    }
    this = (awd::profile::BedfTreeNode *)awd::profile::BedfTreeNode::MergeFrom(v9, v10);
    int v5 = *((_DWORD *)a2 + 15);
    if ((v5 & 8) == 0)
    {
LABEL_10:
      if ((v5 & 0x10) == 0) {
        goto LABEL_11;
      }
      goto LABEL_26;
    }
LABEL_21:
    *((_DWORD *)v3 + 15) |= 8u;
    int v11 = (awd::profile::BedfTreeNode *)*((void *)v3 + 3);
    if (!v11) {
      operator new();
    }
    unint64_t v12 = (const awd::profile::BedfTreeNode *)*((void *)a2 + 3);
    if (!v12)
    {
      awd::profile::protobuf_AddDesc_AwdProfile_2eproto(this);
      unint64_t v12 = *(const awd::profile::BedfTreeNode **)(awd::profile::BedfTreeNode::default_instance_ + 24);
    }
    awd::profile::BedfTreeNode::MergeFrom(v11, v12);
    int v5 = *((_DWORD *)a2 + 15);
    if ((v5 & 0x10) == 0)
    {
LABEL_11:
      if ((v5 & 0x20) == 0) {
        return;
      }
      goto LABEL_12;
    }
LABEL_26:
    int v13 = *((_DWORD *)a2 + 8);
    *((_DWORD *)v3 + 15) |= 0x10u;
    *((_DWORD *)v3 + 8) = v13;
    if ((*((_DWORD *)a2 + 15) & 0x20) == 0) {
      return;
    }
LABEL_12:
    int v6 = *((_DWORD *)a2 + 9);
    *((_DWORD *)v3 + 15) |= 0x20u;
    *((_DWORD *)v3 + 9) = v6;
  }
}

void sub_10012EBAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::profile::BedfTreeNode::~BedfTreeNode(awd::profile::BedfTreeNode *this)
{
  *(void *)this = off_1001BEB70;
  awd::profile::BedfTreeNode::SharedDtor(this);
  if (*((void *)this + 5)) {
    operator delete[]();
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::profile::BedfTreeNode::~BedfTreeNode(this);

  operator delete();
}

void awd::profile::BedfTreeNode::SharedDtor(awd::profile::BedfTreeNode *this)
{
  awd::profile::protobuf_AddDesc_AwdProfile_2eproto(this);
  if ((awd::profile::BedfTreeNode *)awd::profile::BedfTreeNode::default_instance_ != this)
  {
    uint64_t v2 = *((void *)this + 2);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    uint64_t v3 = *((void *)this + 3);
    if (v3)
    {
      int v4 = *(void (**)(void))(*(void *)v3 + 8);
      v4();
    }
  }
}

void awd::profile::BedfTreeNode::New(awd::profile::BedfTreeNode *this)
{
}

uint64_t awd::profile::BedfTreeNode::Clear(uint64_t this)
{
  uint64_t v1 = this;
  LOBYTE(v2) = *(unsigned char *)(this + 60);
  if ((_BYTE)v2)
  {
    *(void *)(this + 8) = &_mh_execute_header;
    if ((v2 & 4) != 0)
    {
      this = *(void *)(this + 16);
      if (this)
      {
        this = awd::profile::BedfTreeNode::Clear((awd::profile::BedfTreeNode *)this);
        int v2 = *(_DWORD *)(v1 + 60);
      }
    }
    if ((v2 & 8) != 0)
    {
      this = *(void *)(v1 + 24);
      if (this) {
        this = awd::profile::BedfTreeNode::Clear((awd::profile::BedfTreeNode *)this);
      }
    }
    *(void *)(v1 + 32) = 0;
  }
  *(_DWORD *)(v1 + 48) = 0;
  *(_DWORD *)(v1 + 60) = 0;
  return this;
}

uint64_t awd::profile::BedfTreeNode::MergePartialFromCodedStream(awd::profile::BedfTreeNode *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  int v5 = (uint64_t *)((char *)this + 40);
  while (2)
  {
    int v6 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v6;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v6 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_26;
        }
        unsigned int v51 = 0;
        int v9 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v9 >= *((void *)a2 + 2) || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v51);
          if (!result) {
            return result;
          }
          unsigned int v10 = v51;
        }
        else
        {
          unsigned int v10 = *v9;
          *((void *)a2 + 1) = v9 + 1;
        }
        if (v10 <= 3)
        {
          *((_DWORD *)this + 15) |= 1u;
          *((_DWORD *)this + 2) = v10;
        }
        int v18 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v11 = *((void *)a2 + 2);
        if ((unint64_t)v18 < v11 && *v18 == 16)
        {
          unint64_t v12 = v18 + 1;
          *((void *)a2 + 1) = v12;
          goto LABEL_38;
        }
        continue;
      case 2u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_26;
        }
        unint64_t v12 = (char *)*((void *)a2 + 1);
        unint64_t v11 = *((void *)a2 + 2);
LABEL_38:
        unsigned int v51 = 0;
        if ((unint64_t)v12 >= v11 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v51);
          if (!result) {
            return result;
          }
          unsigned int v19 = v51;
        }
        else
        {
          unsigned int v19 = *v12;
          *((void *)a2 + 1) = v12 + 1;
        }
        if (v19 - 1 <= 0xB)
        {
          *((_DWORD *)this + 15) |= 2u;
          *((_DWORD *)this + 3) = v19;
        }
        int v20 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v20 >= *((void *)a2 + 2) || *v20 != 26) {
          continue;
        }
        *((void *)a2 + 1) = v20 + 1;
LABEL_48:
        *((_DWORD *)this + 15) |= 4u;
        unint64_t v21 = (awd::profile::BedfTreeNode *)*((void *)this + 2);
        if (!v21) {
          operator new();
        }
        unsigned int v51 = 0;
        int v22 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v22 >= *((void *)a2 + 2) || *v22 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v51))return 0; {
        }
          }
        else
        {
          unsigned int v51 = *v22;
          *((void *)a2 + 1) = v22 + 1;
        }
        int v23 = *((_DWORD *)a2 + 14);
        int v24 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v23 + 1;
        if (v23 >= v24) {
          return 0;
        }
        int v25 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2, v51);
        if (!awd::profile::BedfTreeNode::MergePartialFromCodedStream(v21, a2) || !*((unsigned char *)a2 + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2, v25);
        int v26 = *((_DWORD *)a2 + 14);
        BOOL v27 = __OFSUB__(v26, 1);
        int v28 = v26 - 1;
        if (v28 < 0 == v27) {
          *((_DWORD *)a2 + 14) = v28;
        }
        BOOL v29 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v29 >= *((void *)a2 + 2) || *v29 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v29 + 1;
LABEL_62:
        *((_DWORD *)this + 15) |= 8u;
        int v30 = (awd::profile::BedfTreeNode *)*((void *)this + 3);
        if (!v30) {
          operator new();
        }
        unsigned int v51 = 0;
        uint64_t v31 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v31 >= *((void *)a2 + 2) || *v31 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v51))return 0; {
        }
          }
        else
        {
          unsigned int v51 = *v31;
          *((void *)a2 + 1) = v31 + 1;
        }
        int v32 = *((_DWORD *)a2 + 14);
        int v33 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v32 + 1;
        if (v32 < v33)
        {
          int v34 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2, v51);
          if (awd::profile::BedfTreeNode::MergePartialFromCodedStream(v30, a2))
          {
            if (*((unsigned char *)a2 + 36))
            {
              wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2, v34);
              int v35 = *((_DWORD *)a2 + 14);
              BOOL v27 = __OFSUB__(v35, 1);
              int v36 = v35 - 1;
              if (v36 < 0 == v27) {
                *((_DWORD *)a2 + 14) = v36;
              }
              unsigned int v37 = (char *)*((void *)a2 + 1);
              int v13 = (char *)*((void *)a2 + 2);
              if (v37 < v13 && *v37 == 40)
              {
                int v14 = v37 + 1;
                *((void *)a2 + 1) = v14;
LABEL_76:
                unsigned int v51 = 0;
                if (v14 >= v13 || *v14 < 0)
                {
                  uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v51);
                  if (!result) {
                    return result;
                  }
                  unsigned int v38 = v51;
                  char v39 = (char *)*((void *)a2 + 1);
                  int v13 = (char *)*((void *)a2 + 2);
                }
                else
                {
                  unsigned int v38 = *v14;
                  char v39 = v14 + 1;
                  *((void *)a2 + 1) = v39;
                }
                *((_DWORD *)this + 8) = v38;
                *((_DWORD *)this + 15) |= 0x10u;
                if (v39 < v13 && *v39 == 48)
                {
                  unint64_t v15 = v39 + 1;
                  *((void *)a2 + 1) = v15;
LABEL_84:
                  unsigned int v51 = 0;
                  if (v15 >= v13 || *v15 < 0)
                  {
                    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v51);
                    if (!result) {
                      return result;
                    }
                    unsigned int v40 = v51;
                    unint64_t v41 = (char *)*((void *)a2 + 1);
                    int v13 = (char *)*((void *)a2 + 2);
                  }
                  else
                  {
                    unsigned int v40 = *v15;
                    unint64_t v41 = v15 + 1;
                    *((void *)a2 + 1) = v41;
                  }
                  *((_DWORD *)this + 9) = v40;
                  *((_DWORD *)this + 15) |= 0x20u;
                  if (v41 < v13 && *v41 == 56)
                  {
                    do
                    {
                      unsigned int v16 = v41 + 1;
                      *((void *)a2 + 1) = v16;
LABEL_92:
                      unsigned int v51 = 0;
                      if (v16 >= v13 || *v16 < 0)
                      {
                        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v51);
                        if (!result) {
                          return result;
                        }
                        unsigned int v42 = v51;
                      }
                      else
                      {
                        unsigned int v42 = *v16;
                        *((void *)a2 + 1) = v16 + 1;
                      }
                      int v43 = *((_DWORD *)this + 12);
                      if (v43 == *((_DWORD *)this + 13))
                      {
                        sub_10004BAE8((uint64_t)v5, v43 + 1);
                        int v43 = *((_DWORD *)this + 12);
                      }
                      uint64_t v44 = *((void *)this + 5);
                      *((_DWORD *)this + 12) = v43 + 1;
                      *(_DWORD *)(v44 + 4 * v43) = v42;
                      int v45 = *((_DWORD *)this + 13) - *((_DWORD *)this + 12);
                      if (v45 >= 1)
                      {
                        int v46 = v45 + 1;
                        do
                        {
                          unint64_t v47 = (unsigned char *)*((void *)a2 + 1);
                          unint64_t v48 = *((void *)a2 + 2);
                          if ((unint64_t)v47 >= v48 || *v47 != 56) {
                            break;
                          }
                          *((void *)a2 + 1) = v47 + 1;
                          unsigned int v51 = 0;
                          if ((unint64_t)(v47 + 1) >= v48 || (char)v47[1] < 0)
                          {
                            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v51);
                            if (!result) {
                              return result;
                            }
                            unsigned int v49 = v51;
                            uint64_t v44 = *v5;
                          }
                          else
                          {
                            unsigned int v49 = v47[1];
                            *((void *)a2 + 1) = v47 + 2;
                          }
                          uint64_t v50 = *((int *)this + 12);
                          *((_DWORD *)this + 12) = v50 + 1;
                          *(_DWORD *)(v44 + 4 * v50) = v49;
                          --v46;
                        }
                        while (v46 > 1);
                      }
LABEL_109:
                      unint64_t v41 = (char *)*((void *)a2 + 1);
                      int v13 = (char *)*((void *)a2 + 2);
                    }
                    while (v41 < v13 && *v41 == 56);
                    if (v41 == v13 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
                    {
                      *((_DWORD *)a2 + 8) = 0;
                      uint64_t result = 1;
                      *((unsigned char *)a2 + 36) = 1;
                      return result;
                    }
                  }
                }
              }
              continue;
            }
          }
        }
        return 0;
      case 3u:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_48;
        }
        goto LABEL_26;
      case 4u:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_62;
        }
        goto LABEL_26;
      case 5u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_26;
        }
        int v14 = (char *)*((void *)a2 + 1);
        int v13 = (char *)*((void *)a2 + 2);
        goto LABEL_76;
      case 6u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_26;
        }
        unint64_t v15 = (char *)*((void *)a2 + 1);
        int v13 = (char *)*((void *)a2 + 2);
        goto LABEL_84;
      case 7u:
        int v8 = TagFallback & 7;
        if (v8 == 2)
        {
          uint64_t result = sub_10012F480(a2, (uint64_t)v5);
          if (!result) {
            return result;
          }
          goto LABEL_109;
        }
        if ((TagFallback & 7) == 0)
        {
          unsigned int v16 = (char *)*((void *)a2 + 1);
          int v13 = (char *)*((void *)a2 + 2);
          goto LABEL_92;
        }
LABEL_26:
        if (v8 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
        continue;
        }
      default:
        int v8 = TagFallback & 7;
        goto LABEL_26;
    }
  }
}

uint64_t sub_10012F480(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a2)
{
  unsigned int v12 = 0;
  int v4 = (char *)*((void *)this + 1);
  if ((unint64_t)v4 >= *((void *)this + 2) || *v4 < 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v12);
    if (!result) {
      return result;
    }
    unsigned int v5 = v12;
  }
  else
  {
    unsigned int v5 = *v4;
    unsigned int v12 = v5;
    *((void *)this + 1) = v4 + 1;
  }
  int v7 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v5);
  if ((int)wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this) >= 1)
  {
    do
    {
      unsigned int v13 = 0;
      int v8 = (char *)*((void *)this + 1);
      if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v13);
        if (!result) {
          return result;
        }
        unsigned int v9 = v13;
      }
      else
      {
        unsigned int v9 = *v8;
        *((void *)this + 1) = v8 + 1;
      }
      int v10 = *(_DWORD *)(a2 + 8);
      if (v10 == *(_DWORD *)(a2 + 12))
      {
        sub_10004BAE8(a2, v10 + 1);
        int v10 = *(_DWORD *)(a2 + 8);
      }
      uint64_t v11 = *(void *)a2;
      *(_DWORD *)(a2 + 8) = v10 + 1;
      *(_DWORD *)(v11 + 4 * v10) = v9;
    }
    while ((int)wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this) > 0);
  }
  wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v7);
  return 1;
}

int *awd::profile::BedfTreeNode::SerializeWithCachedSizes(int *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  unsigned int v5 = this;
  int v6 = this[15];
  if (v6)
  {
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, this[2], (int)a2, a4);
    int v6 = v5[15];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_14;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v5[3], (int)a2, a4);
  int v6 = v5[15];
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_17;
  }
LABEL_14:
  uint64_t v8 = *((void *)v5 + 2);
  if (!v8)
  {
    awd::profile::protobuf_AddDesc_AwdProfile_2eproto((awd::profile *)this);
    uint64_t v8 = *(void *)(awd::profile::BedfTreeNode::default_instance_ + 16);
  }
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v8, a2, a4);
  int v6 = v5[15];
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_20;
  }
LABEL_17:
  uint64_t v9 = *((void *)v5 + 3);
  if (!v9)
  {
    awd::profile::protobuf_AddDesc_AwdProfile_2eproto((awd::profile *)this);
    uint64_t v9 = *(void *)(awd::profile::BedfTreeNode::default_instance_ + 24);
  }
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v9, a2, a4);
  int v6 = v5[15];
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
LABEL_20:
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v5[8], (int)a2, a4);
  if ((v5[15] & 0x20) != 0) {
LABEL_7:
  }
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v5[9], (int)a2, a4);
LABEL_8:
  if (v5[12] >= 1)
  {
    uint64_t v7 = 0;
    do
      this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, *(_DWORD *)(*((void *)v5 + 5) + 4 * v7++), (int)a2, a4);
    while (v7 < v5[12]);
  }
  return this;
}

uint64_t awd::profile::BedfTreeNode::ByteSize(awd::profile::BedfTreeNode *this, unsigned int a2)
{
  LOBYTE(v3) = *((unsigned char *)this + 60);
  if (!(_BYTE)v3)
  {
    int v4 = 0;
    goto LABEL_47;
  }
  if ((*((unsigned char *)this + 60) & 1) == 0)
  {
    int v4 = 0;
    if ((*((unsigned char *)this + 60) & 2) == 0) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }
  unsigned int v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
  if ((v5 & 0x80000000) != 0)
  {
    int v6 = 10;
  }
  else if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
    int v3 = *((_DWORD *)this + 15);
  }
  else
  {
    int v6 = 1;
  }
  int v4 = v6 + 1;
  if ((v3 & 2) != 0)
  {
LABEL_12:
    uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 3);
    if ((v7 & 0x80000000) != 0)
    {
      int v8 = 11;
    }
    else if (v7 >= 0x80)
    {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2) + 1;
      int v3 = *((_DWORD *)this + 15);
    }
    else
    {
      int v8 = 2;
    }
    v4 += v8;
  }
LABEL_18:
  if ((v3 & 4) != 0)
  {
    uint64_t v9 = (awd::profile::BedfTreeNode *)*((void *)this + 2);
    if (!v9)
    {
      awd::profile::protobuf_AddDesc_AwdProfile_2eproto(0);
      uint64_t v9 = *(awd::profile::BedfTreeNode **)(awd::profile::BedfTreeNode::default_instance_ + 16);
    }
    int v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)awd::profile::BedfTreeNode::ByteSize(v9);
    int v11 = (int)v10;
    if (v10 >= 0x80) {
      int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v10, a2);
    }
    else {
      int v12 = 1;
    }
    v4 += v11 + v12 + 1;
    int v3 = *((_DWORD *)this + 15);
    if ((v3 & 8) == 0)
    {
LABEL_20:
      if ((v3 & 0x10) == 0) {
        goto LABEL_21;
      }
      goto LABEL_35;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_20;
  }
  unsigned int v13 = (awd::profile::BedfTreeNode *)*((void *)this + 3);
  if (!v13)
  {
    awd::profile::protobuf_AddDesc_AwdProfile_2eproto(0);
    unsigned int v13 = *(awd::profile::BedfTreeNode **)(awd::profile::BedfTreeNode::default_instance_ + 24);
  }
  int v14 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)awd::profile::BedfTreeNode::ByteSize(v13);
  int v15 = (int)v14;
  if (v14 >= 0x80) {
    int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v14, a2);
  }
  else {
    int v16 = 1;
  }
  v4 += v15 + v16 + 1;
  int v3 = *((_DWORD *)this + 15);
  if ((v3 & 0x10) == 0)
  {
LABEL_21:
    if ((v3 & 0x20) == 0) {
      goto LABEL_47;
    }
    goto LABEL_41;
  }
LABEL_35:
  unsigned int v17 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 8);
  if ((v17 & 0x80000000) != 0)
  {
    int v18 = 11;
  }
  else if (v17 >= 0x80)
  {
    int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v17, a2) + 1;
    int v3 = *((_DWORD *)this + 15);
  }
  else
  {
    int v18 = 2;
  }
  v4 += v18;
  if ((v3 & 0x20) != 0)
  {
LABEL_41:
    unsigned int v19 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 9);
    if ((v19 & 0x80000000) != 0)
    {
      int v20 = 11;
    }
    else if (v19 >= 0x80)
    {
      int v20 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v19, a2) + 1;
    }
    else
    {
      int v20 = 2;
    }
    v4 += v20;
  }
LABEL_47:
  int v21 = *((_DWORD *)this + 12);
  if (v21 < 1)
  {
    int v23 = 0;
  }
  else
  {
    uint64_t v22 = 0;
    int v23 = 0;
    do
    {
      int v24 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(*((void *)this + 5)
                                                                                             + 4 * v22);
      if ((v24 & 0x80000000) != 0)
      {
        int v25 = 10;
      }
      else if (v24 >= 0x80)
      {
        int v25 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v24, a2);
        int v21 = *((_DWORD *)this + 12);
      }
      else
      {
        int v25 = 1;
      }
      v23 += v25;
      ++v22;
    }
    while (v22 < v21);
  }
  uint64_t result = (v23 + v4 + v21);
  *((_DWORD *)this + 14) = result;
  return result;
}

uint64_t awd::profile::BedfTreeNode::IsInitialized(awd::profile::BedfTreeNode *this)
{
  return 1;
}

void *awd::profile::BedfTreeNode::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.profile.BedfTreeNode");
}

void awd::profile::BedfConfig::MergeFrom(awd::profile::BedfConfig *this, const awd::profile::BedfConfig *a2)
{
  int v3 = this;
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  int v4 = *((_DWORD *)a2 + 8);
  if (v4)
  {
    sub_10004BAE8((uint64_t)v3 + 24, *((_DWORD *)v3 + 8) + v4);
    this = (awd::profile::BedfConfig *)memcpy((void *)(*((void *)v3 + 3) + 4 * *((int *)v3 + 8)), *((const void **)a2 + 3), 4 * *((int *)a2 + 8));
    *((_DWORD *)v3 + 8) += *((_DWORD *)a2 + 8);
  }
  LOBYTE(v5) = *((unsigned char *)a2 + 44);
  if ((_BYTE)v5)
  {
    if (*((unsigned char *)a2 + 44))
    {
      int v6 = *((_DWORD *)a2 + 2);
      *((_DWORD *)v3 + 11) |= 1u;
      *((_DWORD *)v3 + 2) = v6;
      int v5 = *((_DWORD *)a2 + 11);
      if ((v5 & 2) == 0)
      {
LABEL_8:
        if ((v5 & 4) == 0) {
          return;
        }
        goto LABEL_12;
      }
    }
    else if ((*((unsigned char *)a2 + 44) & 2) == 0)
    {
      goto LABEL_8;
    }
    int v7 = *((_DWORD *)a2 + 3);
    *((_DWORD *)v3 + 11) |= 2u;
    *((_DWORD *)v3 + 3) = v7;
    if ((*((_DWORD *)a2 + 11) & 4) == 0) {
      return;
    }
LABEL_12:
    *((_DWORD *)v3 + 11) |= 4u;
    int v8 = (awd::profile::BedfTreeNode *)*((void *)v3 + 2);
    if (!v8) {
      operator new();
    }
    uint64_t v9 = (const awd::profile::BedfTreeNode *)*((void *)a2 + 2);
    if (!v9)
    {
      awd::profile::protobuf_AddDesc_AwdProfile_2eproto(this);
      uint64_t v9 = *(const awd::profile::BedfTreeNode **)(awd::profile::BedfConfig::default_instance_ + 16);
    }
    awd::profile::BedfTreeNode::MergeFrom(v8, v9);
  }
}

void sub_10012FA90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::profile::BedfConfig::~BedfConfig(awd::profile::BedfConfig *this)
{
  *(void *)this = off_1001BEBE8;
  awd::profile::BedfConfig::SharedDtor(this);
  if (*((void *)this + 3)) {
    operator delete[]();
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::profile::BedfConfig::~BedfConfig(this);

  operator delete();
}

void awd::profile::BedfConfig::SharedDtor(awd::profile::BedfConfig *this)
{
  awd::profile::protobuf_AddDesc_AwdProfile_2eproto(this);
  if ((awd::profile::BedfConfig *)awd::profile::BedfConfig::default_instance_ != this)
  {
    uint64_t v2 = *((void *)this + 2);
    if (v2)
    {
      int v3 = *(void (**)(void))(*(void *)v2 + 8);
      v3();
    }
  }
}

void awd::profile::BedfConfig::New(awd::profile::BedfConfig *this)
{
}

uint64_t awd::profile::BedfConfig::Clear(uint64_t this)
{
  uint64_t v1 = this;
  char v2 = *(unsigned char *)(this + 44);
  if (v2)
  {
    *(void *)(this + 8) = 0;
    if ((v2 & 4) != 0)
    {
      this = *(void *)(this + 16);
      if (this) {
        this = awd::profile::BedfTreeNode::Clear(this);
      }
    }
  }
  *(_DWORD *)(v1 + 32) = 0;
  *(_DWORD *)(v1 + 44) = 0;
  return this;
}

uint64_t awd::profile::BedfConfig::MergePartialFromCodedStream(awd::profile::BedfConfig *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  int v5 = (uint64_t *)((char *)this + 24);
  int v6 = (unsigned int *)((char *)this + 8);
  int v7 = (unsigned int *)((char *)this + 12);
  while (2)
  {
    int v8 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v8;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v8 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        int v12 = (char *)*((void *)a2 + 1);
        unint64_t v11 = *((void *)a2 + 2);
        if ((unint64_t)v12 >= v11 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v6);
          if (!result) {
            return result;
          }
          unsigned int v13 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v11 = *((void *)a2 + 2);
        }
        else
        {
          *int v6 = *v12;
          unsigned int v13 = v12 + 1;
          *((void *)a2 + 1) = v13;
        }
        *((_DWORD *)this + 11) |= 1u;
        if ((unint64_t)v13 < v11 && *v13 == 16)
        {
          int v14 = v13 + 1;
          *((void *)a2 + 1) = v14;
          goto LABEL_30;
        }
        continue;
      case 2u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        int v14 = (char *)*((void *)a2 + 1);
        unint64_t v11 = *((void *)a2 + 2);
LABEL_30:
        if ((unint64_t)v14 >= v11 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v7);
          if (!result) {
            return result;
          }
          unsigned int v19 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v11 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int *v7 = *v14;
          unsigned int v19 = v14 + 1;
          *((void *)a2 + 1) = v19;
        }
        int v15 = *((_DWORD *)this + 11) | 2;
        *((_DWORD *)this + 11) = v15;
        if ((unint64_t)v19 >= v11 || *v19 != 26) {
          continue;
        }
        *((void *)a2 + 1) = v19 + 1;
LABEL_38:
        *((_DWORD *)this + 11) = v15 | 4;
        int v20 = (awd::profile::BedfTreeNode *)*((void *)this + 2);
        if (!v20) {
          operator new();
        }
        unsigned int v41 = 0;
        int v21 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v21 >= *((void *)a2 + 2) || *v21 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v41))return 0; {
        }
          }
        else
        {
          unsigned int v41 = *v21;
          *((void *)a2 + 1) = v21 + 1;
        }
        int v22 = *((_DWORD *)a2 + 14);
        int v23 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v22 + 1;
        if (v22 < v23)
        {
          int v24 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2, v41);
          if (awd::profile::BedfTreeNode::MergePartialFromCodedStream(v20, a2, v25))
          {
            if (*((unsigned char *)a2 + 36))
            {
              wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2, v24);
              int v26 = *((_DWORD *)a2 + 14);
              BOOL v27 = __OFSUB__(v26, 1);
              int v28 = v26 - 1;
              if (v28 < 0 == v27) {
                *((_DWORD *)a2 + 14) = v28;
              }
              BOOL v29 = (char *)*((void *)a2 + 1);
              int v16 = (char *)*((void *)a2 + 2);
              if (v29 < v16 && *v29 == 32)
              {
                do
                {
                  unsigned int v17 = v29 + 1;
                  *((void *)a2 + 1) = v17;
LABEL_52:
                  unsigned int v40 = 0;
                  if (v17 >= v16 || *v17 < 0)
                  {
                    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v40);
                    if (!result) {
                      return result;
                    }
                    unsigned int v30 = v40;
                  }
                  else
                  {
                    unsigned int v30 = *v17;
                    *((void *)a2 + 1) = v17 + 1;
                  }
                  int v31 = *((_DWORD *)this + 8);
                  if (v31 == *((_DWORD *)this + 9))
                  {
                    sub_10004BAE8((uint64_t)v5, v31 + 1);
                    int v31 = *((_DWORD *)this + 8);
                  }
                  uint64_t v32 = *((void *)this + 3);
                  *((_DWORD *)this + 8) = v31 + 1;
                  *(_DWORD *)(v32 + 4 * v31) = v30;
                  int v33 = *((_DWORD *)this + 9) - *((_DWORD *)this + 8);
                  if (v33 >= 1)
                  {
                    int v34 = v33 + 1;
                    do
                    {
                      int v35 = (unsigned char *)*((void *)a2 + 1);
                      unint64_t v36 = *((void *)a2 + 2);
                      if ((unint64_t)v35 >= v36 || *v35 != 32) {
                        break;
                      }
                      *((void *)a2 + 1) = v35 + 1;
                      unsigned int v39 = 0;
                      if ((unint64_t)(v35 + 1) >= v36 || (char)v35[1] < 0)
                      {
                        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v39);
                        if (!result) {
                          return result;
                        }
                        unsigned int v37 = v39;
                        uint64_t v32 = *v5;
                      }
                      else
                      {
                        unsigned int v37 = v35[1];
                        *((void *)a2 + 1) = v35 + 2;
                      }
                      uint64_t v38 = *((int *)this + 8);
                      *((_DWORD *)this + 8) = v38 + 1;
                      *(_DWORD *)(v32 + 4 * v38) = v37;
                      --v34;
                    }
                    while (v34 > 1);
                  }
LABEL_69:
                  BOOL v29 = (char *)*((void *)a2 + 1);
                  int v16 = (char *)*((void *)a2 + 2);
                }
                while (v29 < v16 && *v29 == 32);
                if (v29 == v16 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
                {
                  *((_DWORD *)a2 + 8) = 0;
                  uint64_t result = 1;
                  *((unsigned char *)a2 + 36) = 1;
                  return result;
                }
              }
              continue;
            }
          }
        }
        return 0;
      case 3u:
        int v10 = TagFallback & 7;
        if (v10 != 2) {
          goto LABEL_20;
        }
        int v15 = *((_DWORD *)this + 11);
        goto LABEL_38;
      case 4u:
        int v10 = TagFallback & 7;
        if (v10 == 2)
        {
          uint64_t result = sub_10012F480(a2, (uint64_t)v5);
          if (!result) {
            return result;
          }
          goto LABEL_69;
        }
        if ((TagFallback & 7) == 0)
        {
          unsigned int v17 = (char *)*((void *)a2 + 1);
          int v16 = (char *)*((void *)a2 + 2);
          goto LABEL_52;
        }
LABEL_20:
        if (v10 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
        continue;
        }
      default:
        int v10 = TagFallback & 7;
        goto LABEL_20;
    }
  }
}

int *awd::profile::BedfConfig::SerializeWithCachedSizes(int *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v5 = this;
  int v6 = this[11];
  if (v6)
  {
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, this[2], a2, a4);
    int v6 = v5[11];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_10;
      }
      goto LABEL_7;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v5[3], a2, a4);
  if ((v5[11] & 4) == 0) {
    goto LABEL_10;
  }
LABEL_7:
  uint64_t v7 = *((void *)v5 + 2);
  if (!v7)
  {
    awd::profile::protobuf_AddDesc_AwdProfile_2eproto((awd::profile *)this);
    uint64_t v7 = *(void *)(awd::profile::BedfConfig::default_instance_ + 16);
  }
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v7, a2, a4);
LABEL_10:
  if (v5[8] >= 1)
  {
    uint64_t v8 = 0;
    do
      this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(_DWORD *)(*((void *)v5 + 3) + 4 * v8++), (int)a2, a4);
    while (v8 < v5[8]);
  }
  return this;
}

uint64_t awd::profile::BedfConfig::ByteSize(awd::profile::BedfConfig *this, unsigned int a2)
{
  LOBYTE(v3) = *((unsigned char *)this + 44);
  if (!(_BYTE)v3)
  {
    int v4 = 0;
    goto LABEL_21;
  }
  if (*((unsigned char *)this + 44))
  {
    int v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
    if (v5 >= 0x80)
    {
      int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *((_DWORD *)this + 11);
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
    else
    {
      int v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
  }
  else
  {
    int v4 = 0;
    if ((*((unsigned char *)this + 44) & 2) == 0) {
      goto LABEL_14;
    }
  }
  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 3);
  if (v6 >= 0x80)
  {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    int v3 = *((_DWORD *)this + 11);
  }
  else
  {
    int v7 = 2;
  }
  v4 += v7;
LABEL_14:
  if ((v3 & 4) != 0)
  {
    uint64_t v8 = (awd::profile::BedfTreeNode *)*((void *)this + 2);
    if (!v8)
    {
      awd::profile::protobuf_AddDesc_AwdProfile_2eproto(0);
      uint64_t v8 = *(awd::profile::BedfTreeNode **)(awd::profile::BedfConfig::default_instance_ + 16);
    }
    uint64_t v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)awd::profile::BedfTreeNode::ByteSize(v8, a2);
    int v10 = (int)v9;
    if (v9 >= 0x80) {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, a2);
    }
    else {
      int v11 = 1;
    }
    v4 += v10 + v11 + 1;
  }
LABEL_21:
  int v12 = *((_DWORD *)this + 8);
  if (v12 < 1)
  {
    int v14 = 0;
  }
  else
  {
    uint64_t v13 = 0;
    int v14 = 0;
    do
    {
      int v15 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(*((void *)this + 3)
                                                                                             + 4 * v13);
      if ((v15 & 0x80000000) != 0)
      {
        int v16 = 10;
      }
      else if (v15 >= 0x80)
      {
        int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v15, a2);
        int v12 = *((_DWORD *)this + 8);
      }
      else
      {
        int v16 = 1;
      }
      v14 += v16;
      ++v13;
    }
    while (v13 < v12);
  }
  uint64_t result = (v14 + v4 + v12);
  *((_DWORD *)this + 10) = result;
  return result;
}

uint64_t awd::profile::BedfConfig::IsInitialized(awd::profile::BedfConfig *this)
{
  return 1;
}

void *awd::profile::BedfConfig::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.profile.BedfConfig");
}

void awd::profile::Metric::MergeFrom(awd::profile::Metric *this, const awd::profile::Metric *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v32);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::Metric *)((char *)this + 48), *((_DWORD *)a2 + 14) + *((_DWORD *)this + 14));
  if (*((int *)a2 + 14) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      int v5 = *(const awd::profile::ProcessingRule **)(*((void *)a2 + 6) + 8 * v4);
      int v6 = *((_DWORD *)this + 15);
      uint64_t v7 = *((int *)this + 14);
      if ((int)v7 >= v6)
      {
        if (v6 == *((_DWORD *)this + 16))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::Metric *)((char *)this + 48), v6 + 1);
          int v6 = *((_DWORD *)this + 15);
        }
        *((_DWORD *)this + 15) = v6 + 1;
        operator new();
      }
      uint64_t v8 = *((void *)this + 6);
      *((_DWORD *)this + 14) = v7 + 1;
      awd::profile::ProcessingRule::MergeFrom(*(awd::profile::ProcessingRule **)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *((int *)a2 + 14));
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::Metric *)((char *)this + 72), *((_DWORD *)a2 + 20) + *((_DWORD *)this + 20));
  if (*((int *)a2 + 20) >= 1)
  {
    uint64_t v9 = 0;
    do
    {
      int v10 = *(const awd::profile::BedfConfig **)(*((void *)a2 + 9) + 8 * v9);
      int v11 = *((_DWORD *)this + 21);
      uint64_t v12 = *((int *)this + 20);
      if ((int)v12 >= v11)
      {
        if (v11 == *((_DWORD *)this + 22))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::Metric *)((char *)this + 72), v11 + 1);
          int v11 = *((_DWORD *)this + 21);
        }
        *((_DWORD *)this + 21) = v11 + 1;
        operator new();
      }
      uint64_t v13 = *((void *)this + 9);
      *((_DWORD *)this + 20) = v12 + 1;
      awd::profile::BedfConfig::MergeFrom(*(awd::profile::BedfConfig **)(v13 + 8 * v12), v10);
      ++v9;
    }
    while (v9 < *((int *)a2 + 20));
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::Metric *)((char *)this + 96), *((_DWORD *)a2 + 26) + *((_DWORD *)this + 26));
  if (*((int *)a2 + 26) >= 1)
  {
    uint64_t v14 = 0;
    do
    {
      int v15 = *(const awd::profile::ConfigurationParameter **)(*((void *)a2 + 12) + 8 * v14);
      int v16 = *((_DWORD *)this + 27);
      uint64_t v17 = *((int *)this + 26);
      if ((int)v17 >= v16)
      {
        if (v16 == *((_DWORD *)this + 28))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::Metric *)((char *)this + 96), v16 + 1);
          int v16 = *((_DWORD *)this + 27);
        }
        *((_DWORD *)this + 27) = v16 + 1;
        operator new();
      }
      uint64_t v18 = *((void *)this + 12);
      *((_DWORD *)this + 26) = v17 + 1;
      awd::profile::ConfigurationParameter::MergeFrom(*(awd::profile::ConfigurationParameter **)(v18 + 8 * v17), v15);
      ++v14;
    }
    while (v14 < *((int *)a2 + 26));
  }
  int v19 = *((_DWORD *)a2 + 33);
  if (!(_BYTE)v19) {
    goto LABEL_37;
  }
  if (v19)
  {
    int v22 = *((_DWORD *)a2 + 2);
    *((_DWORD *)this + 33) |= 1u;
    *((_DWORD *)this + 2) = v22;
    int v19 = *((_DWORD *)a2 + 33);
    if ((v19 & 2) == 0)
    {
LABEL_30:
      if ((v19 & 4) == 0) {
        goto LABEL_31;
      }
      goto LABEL_46;
    }
  }
  else if ((v19 & 2) == 0)
  {
    goto LABEL_30;
  }
  int v23 = *((_DWORD *)a2 + 3);
  *((_DWORD *)this + 33) |= 2u;
  *((_DWORD *)this + 3) = v23;
  int v19 = *((_DWORD *)a2 + 33);
  if ((v19 & 4) == 0)
  {
LABEL_31:
    if ((v19 & 8) == 0) {
      goto LABEL_32;
    }
    goto LABEL_47;
  }
LABEL_46:
  int v24 = *((_DWORD *)a2 + 4);
  *((_DWORD *)this + 33) |= 4u;
  *((_DWORD *)this + 4) = v24;
  int v19 = *((_DWORD *)a2 + 33);
  if ((v19 & 8) == 0)
  {
LABEL_32:
    if ((v19 & 0x10) == 0) {
      goto LABEL_33;
    }
    goto LABEL_48;
  }
LABEL_47:
  int v25 = *((_DWORD *)a2 + 5);
  *((_DWORD *)this + 33) |= 8u;
  *((_DWORD *)this + 5) = v25;
  int v19 = *((_DWORD *)a2 + 33);
  if ((v19 & 0x10) == 0)
  {
LABEL_33:
    if ((v19 & 0x20) == 0) {
      goto LABEL_34;
    }
LABEL_49:
    int v27 = *((_DWORD *)a2 + 7);
    *((_DWORD *)this + 33) |= 0x20u;
    *((_DWORD *)this + 7) = v27;
    int v19 = *((_DWORD *)a2 + 33);
    if ((v19 & 0x40) == 0)
    {
LABEL_35:
      if ((v19 & 0x80) == 0) {
        goto LABEL_37;
      }
      goto LABEL_36;
    }
    goto LABEL_50;
  }
LABEL_48:
  int v26 = *((_DWORD *)a2 + 6);
  *((_DWORD *)this + 33) |= 0x10u;
  *((_DWORD *)this + 6) = v26;
  int v19 = *((_DWORD *)a2 + 33);
  if ((v19 & 0x20) != 0) {
    goto LABEL_49;
  }
LABEL_34:
  if ((v19 & 0x40) == 0) {
    goto LABEL_35;
  }
LABEL_50:
  int v28 = *((_DWORD *)a2 + 8);
  *((_DWORD *)this + 33) |= 0x40u;
  *((_DWORD *)this + 8) = v28;
  int v19 = *((_DWORD *)a2 + 33);
  if ((v19 & 0x80) != 0)
  {
LABEL_36:
    int v20 = *((_DWORD *)a2 + 9);
    *((_DWORD *)this + 33) |= 0x80u;
    *((_DWORD *)this + 9) = v20;
    int v19 = *((_DWORD *)a2 + 33);
  }
LABEL_37:
  if ((v19 & 0xFF00) == 0) {
    return;
  }
  if ((v19 & 0x100) != 0)
  {
    char v29 = *((unsigned char *)a2 + 40);
    *((_DWORD *)this + 33) |= 0x100u;
    *((unsigned char *)this + 40) = v29;
    int v19 = *((_DWORD *)a2 + 33);
    if ((v19 & 0x200) == 0)
    {
LABEL_40:
      if ((v19 & 0x1000) == 0) {
        goto LABEL_41;
      }
      goto LABEL_54;
    }
  }
  else if ((v19 & 0x200) == 0)
  {
    goto LABEL_40;
  }
  int v30 = *((_DWORD *)a2 + 11);
  *((_DWORD *)this + 33) |= 0x200u;
  *((_DWORD *)this + 11) = v30;
  int v19 = *((_DWORD *)a2 + 33);
  if ((v19 & 0x1000) == 0)
  {
LABEL_41:
    if ((v19 & 0x4000) == 0) {
      return;
    }
    goto LABEL_42;
  }
LABEL_54:
  int v31 = *((_DWORD *)a2 + 30);
  *((_DWORD *)this + 33) |= 0x1000u;
  *((_DWORD *)this + 30) = v31;
  if ((*((_DWORD *)a2 + 33) & 0x4000) == 0) {
    return;
  }
LABEL_42:
  int v21 = *((_DWORD *)a2 + 31);
  *((_DWORD *)this + 33) |= 0x4000u;
  *((_DWORD *)this + 31) = v21;
}

void sub_1001307CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::profile::Metric::~Metric(awd::profile::Metric *this)
{
  *(void *)this = off_1001BEC60;
  awd::profile::protobuf_AddDesc_AwdProfile_2eproto(this);
  sub_1000FB750((uint64_t *)this + 12);
  sub_1000FB750((uint64_t *)this + 9);
  sub_1000FB750((uint64_t *)this + 6);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::profile::Metric::~Metric(this);

  operator delete();
}

void awd::profile::Metric::New(awd::profile::Metric *this)
{
}

uint64_t awd::profile::Metric::Clear(awd::profile::Metric *this)
{
  int v2 = *((_DWORD *)this + 33);
  if ((_BYTE)v2)
  {
    *(_OWORD *)((char *)this + 24) = 0u;
    *(_OWORD *)((char *)this + 8) = 0u;
  }
  if ((v2 & 0xFF00) != 0)
  {
    *((unsigned char *)this + 40) = 0;
    *((_DWORD *)this + 11) = 0;
    *((void *)this + 15) = 0;
  }
  sub_1000FB6E0((uint64_t)this + 48);
  sub_1000FB6E0((uint64_t)this + 72);
  uint64_t result = sub_1000FB6E0((uint64_t)this + 96);
  *((_DWORD *)this + 33) = 0;
  return result;
}

uint64_t awd::profile::Metric::MergePartialFromCodedStream(awd::profile::Metric *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  int v5 = (unsigned int *)((char *)this + 12);
  int v6 = (unsigned int *)((char *)this + 24);
  uint64_t v7 = (unsigned int *)((char *)this + 28);
  uint64_t v8 = (unsigned int *)((char *)this + 44);
  char v86 = (awd::profile::Metric *)((char *)this + 72);
  int v87 = (unsigned int *)((char *)this + 8);
  uint64_t v9 = (unsigned int *)((char *)this + 120);
  int v84 = (awd::profile::Metric *)((char *)this + 48);
  unsigned int v85 = (awd::profile::Metric *)((char *)this + 96);
  int v10 = (unsigned int *)((char *)this + 124);
  while (1)
  {
    while (1)
    {
LABEL_2:
      int v11 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v11 >= *((void *)a2 + 2) || *v11 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        unint64_t TagFallback = *v11;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v11 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      switch(TagFallback >> 3)
      {
        case 1u:
          int v13 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_40;
          }
          int v15 = (char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
          if ((unint64_t)v15 >= v14 || *v15 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v87);
            if (!result) {
              return result;
            }
            int v16 = (unsigned char *)*((void *)a2 + 1);
            unint64_t v14 = *((void *)a2 + 2);
          }
          else
          {
            *int v87 = *v15;
            int v16 = v15 + 1;
            *((void *)a2 + 1) = v16;
          }
          *((_DWORD *)this + 33) |= 1u;
          if ((unint64_t)v16 < v14 && *v16 == 16)
          {
            uint64_t v17 = v16 + 1;
            *((void *)a2 + 1) = v17;
            goto LABEL_49;
          }
          continue;
        case 2u:
          int v13 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_40;
          }
          uint64_t v17 = (char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
LABEL_49:
          if ((unint64_t)v17 >= v14 || *v17 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v5);
            if (!result) {
              return result;
            }
            int v31 = (unsigned char *)*((void *)a2 + 1);
            unint64_t v14 = *((void *)a2 + 2);
          }
          else
          {
            *int v5 = *v17;
            int v31 = v17 + 1;
            *((void *)a2 + 1) = v31;
          }
          *((_DWORD *)this + 33) |= 2u;
          if ((unint64_t)v31 >= v14 || *v31 != 24) {
            continue;
          }
          uint64_t v18 = v31 + 1;
          *((void *)a2 + 1) = v18;
LABEL_57:
          unsigned int v88 = 0;
          if ((unint64_t)v18 >= v14 || *v18 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v88);
            if (!result) {
              return result;
            }
            unsigned int v32 = v88;
            int v33 = (unsigned char *)*((void *)a2 + 1);
            unint64_t v14 = *((void *)a2 + 2);
          }
          else
          {
            unsigned int v32 = *v18;
            int v33 = v18 + 1;
            *((void *)a2 + 1) = v33;
          }
          *((_DWORD *)this + 4) = -(v32 & 1) ^ (v32 >> 1);
          *((_DWORD *)this + 33) |= 4u;
          if ((unint64_t)v33 >= v14 || *v33 != 32) {
            continue;
          }
          int v19 = v33 + 1;
          *((void *)a2 + 1) = v19;
LABEL_65:
          unsigned int v88 = 0;
          if ((unint64_t)v19 >= v14 || *v19 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v88);
            if (!result) {
              return result;
            }
            unsigned int v34 = v88;
            int v35 = (unsigned char *)*((void *)a2 + 1);
            unint64_t v14 = *((void *)a2 + 2);
          }
          else
          {
            unsigned int v34 = *v19;
            int v35 = v19 + 1;
            *((void *)a2 + 1) = v35;
          }
          *((_DWORD *)this + 5) = -(v34 & 1) ^ (v34 >> 1);
          *((_DWORD *)this + 33) |= 8u;
          if ((unint64_t)v35 >= v14 || *v35 != 40) {
            continue;
          }
          int v20 = v35 + 1;
          *((void *)a2 + 1) = v20;
LABEL_73:
          if ((unint64_t)v20 >= v14 || *v20 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v6);
            if (!result) {
              return result;
            }
            unint64_t v36 = (unsigned char *)*((void *)a2 + 1);
            unint64_t v14 = *((void *)a2 + 2);
          }
          else
          {
            *int v6 = *v20;
            unint64_t v36 = v20 + 1;
            *((void *)a2 + 1) = v36;
          }
          *((_DWORD *)this + 33) |= 0x10u;
          if ((unint64_t)v36 >= v14 || *v36 != 48) {
            continue;
          }
          int v21 = v36 + 1;
          *((void *)a2 + 1) = v21;
LABEL_81:
          if ((unint64_t)v21 >= v14 || *v21 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v7);
            if (!result) {
              return result;
            }
            unsigned int v37 = (unsigned char *)*((void *)a2 + 1);
            unint64_t v14 = *((void *)a2 + 2);
          }
          else
          {
            unsigned int *v7 = *v21;
            unsigned int v37 = v21 + 1;
            *((void *)a2 + 1) = v37;
          }
          *((_DWORD *)this + 33) |= 0x20u;
          if ((unint64_t)v37 >= v14 || *v37 != 56) {
            continue;
          }
          int v22 = v37 + 1;
          *((void *)a2 + 1) = v22;
LABEL_89:
          unsigned int v88 = 0;
          if ((unint64_t)v22 >= v14 || *v22 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v88);
            if (!result) {
              return result;
            }
            unsigned int v38 = v88;
            unsigned int v39 = (unsigned char *)*((void *)a2 + 1);
            unint64_t v14 = *((void *)a2 + 2);
          }
          else
          {
            unsigned int v38 = *v22;
            unsigned int v39 = v22 + 1;
            *((void *)a2 + 1) = v39;
          }
          *((_DWORD *)this + 8) = v38;
          *((_DWORD *)this + 33) |= 0x40u;
          if ((unint64_t)v39 >= v14 || *v39 != 64) {
            continue;
          }
          int v23 = v39 + 1;
          *((void *)a2 + 1) = v23;
LABEL_97:
          unsigned int v88 = 0;
          if ((unint64_t)v23 >= v14 || *v23 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v88);
            if (!result) {
              return result;
            }
            unsigned int v40 = v88;
            unsigned int v41 = (unsigned char *)*((void *)a2 + 1);
            unint64_t v14 = *((void *)a2 + 2);
          }
          else
          {
            unsigned int v40 = *v23;
            unsigned int v41 = v23 + 1;
            *((void *)a2 + 1) = v41;
          }
          *((_DWORD *)this + 9) = v40;
          *((_DWORD *)this + 33) |= 0x80u;
          if ((unint64_t)v41 >= v14 || *v41 != 72) {
            continue;
          }
          int v24 = v41 + 1;
          *((void *)a2 + 1) = v24;
LABEL_105:
          unsigned int v88 = 0;
          if ((unint64_t)v24 >= v14 || *v24 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v88);
            if (!result) {
              return result;
            }
            unsigned int v42 = v88;
            int v43 = (unsigned char *)*((void *)a2 + 1);
            unint64_t v14 = *((void *)a2 + 2);
          }
          else
          {
            unsigned int v42 = *v24;
            int v43 = v24 + 1;
            *((void *)a2 + 1) = v43;
          }
          *((unsigned char *)this + 40) = v42 != 0;
          *((_DWORD *)this + 33) |= 0x100u;
          if ((unint64_t)v43 >= v14 || *v43 != 80) {
            continue;
          }
          int v25 = v43 + 1;
          *((void *)a2 + 1) = v25;
LABEL_113:
          if ((unint64_t)v25 >= v14 || *v25 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v8);
            if (!result) {
              return result;
            }
            uint64_t v44 = (unsigned char *)*((void *)a2 + 1);
            unint64_t v14 = *((void *)a2 + 2);
          }
          else
          {
            unsigned int *v8 = *v25;
            uint64_t v44 = v25 + 1;
            *((void *)a2 + 1) = v44;
          }
          *((_DWORD *)this + 33) |= 0x200u;
          if ((unint64_t)v44 >= v14 || *v44 != 90) {
            continue;
          }
          break;
        case 3u:
          int v13 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_40;
          }
          uint64_t v18 = (char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
          goto LABEL_57;
        case 4u:
          int v13 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_40;
          }
          int v19 = (char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
          goto LABEL_65;
        case 5u:
          int v13 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_40;
          }
          int v20 = (char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
          goto LABEL_73;
        case 6u:
          int v13 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_40;
          }
          int v21 = (char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
          goto LABEL_81;
        case 7u:
          int v13 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_40;
          }
          int v22 = (char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
          goto LABEL_89;
        case 8u:
          int v13 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_40;
          }
          int v23 = (char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
          goto LABEL_97;
        case 9u:
          int v13 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_40;
          }
          int v24 = (char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
          goto LABEL_105;
        case 0xAu:
          int v13 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_40;
          }
          int v25 = (char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
          goto LABEL_113;
        case 0xBu:
          int v13 = TagFallback & 7;
          if (v13 == 2) {
            goto LABEL_121;
          }
          goto LABEL_40;
        case 0xCu:
          int v13 = TagFallback & 7;
          if (v13 == 2) {
            goto LABEL_139;
          }
          goto LABEL_40;
        case 0xDu:
          int v13 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_40;
          }
          int v27 = (char *)*((void *)a2 + 1);
          unint64_t v26 = *((void *)a2 + 2);
          goto LABEL_157;
        case 0xEu:
          int v13 = TagFallback & 7;
          if (v13 == 2) {
            goto LABEL_165;
          }
          goto LABEL_40;
        case 0xFu:
          int v13 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_40;
          }
          char v29 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v28 = *((void *)a2 + 2);
          goto LABEL_183;
        default:
          int v13 = TagFallback & 7;
LABEL_40:
          if (v13 == 4) {
            return 1;
          }
          if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
          continue;
          }
      }
      do
      {
        *((void *)a2 + 1) = v44 + 1;
LABEL_121:
        int v45 = *((_DWORD *)this + 15);
        uint64_t v46 = *((int *)this + 14);
        if ((int)v46 >= v45)
        {
          if (v45 == *((_DWORD *)this + 16))
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v84, v45 + 1);
            int v45 = *((_DWORD *)this + 15);
          }
          *((_DWORD *)this + 15) = v45 + 1;
          operator new();
        }
        uint64_t v47 = *((void *)this + 6);
        *((_DWORD *)this + 14) = v46 + 1;
        unint64_t v48 = *(awd::profile::ProcessingRule **)(v47 + 8 * v46);
        unsigned int v88 = 0;
        unsigned int v49 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v49 >= *((void *)a2 + 2) || *v49 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v88))return 0; {
        }
          }
        else
        {
          unsigned int v88 = *v49;
          *((void *)a2 + 1) = v49 + 1;
        }
        int v50 = *((_DWORD *)a2 + 14);
        int v51 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v50 + 1;
        if (v50 >= v51) {
          return 0;
        }
        int v52 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2, v88);
        if (!awd::profile::ProcessingRule::MergePartialFromCodedStream(v48, a2, v53)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2, v52);
        int v54 = *((_DWORD *)a2 + 14);
        BOOL v55 = __OFSUB__(v54, 1);
        int v56 = v54 - 1;
        if (v56 < 0 == v55) {
          *((_DWORD *)a2 + 14) = v56;
        }
        uint64_t v44 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v44 >= *((void *)a2 + 2)) {
          goto LABEL_2;
        }
        int v57 = *v44;
      }
      while (v57 == 90);
      if (v57 == 98)
      {
        do
        {
          *((void *)a2 + 1) = v44 + 1;
LABEL_139:
          int v58 = *((_DWORD *)this + 21);
          uint64_t v59 = *((int *)this + 20);
          if ((int)v59 >= v58)
          {
            if (v58 == *((_DWORD *)this + 22))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v86, v58 + 1);
              int v58 = *((_DWORD *)this + 21);
            }
            *((_DWORD *)this + 21) = v58 + 1;
            operator new();
          }
          uint64_t v60 = *((void *)this + 9);
          *((_DWORD *)this + 20) = v59 + 1;
          uint64_t v61 = *(awd::profile::BedfConfig **)(v60 + 8 * v59);
          unsigned int v88 = 0;
          int v62 = (char *)*((void *)a2 + 1);
          if ((unint64_t)v62 >= *((void *)a2 + 2) || *v62 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v88))return 0; {
          }
            }
          else
          {
            unsigned int v88 = *v62;
            *((void *)a2 + 1) = v62 + 1;
          }
          int v63 = *((_DWORD *)a2 + 14);
          int v64 = *((_DWORD *)a2 + 15);
          *((_DWORD *)a2 + 14) = v63 + 1;
          if (v63 >= v64) {
            return 0;
          }
          int v65 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2, v88);
          if (!awd::profile::BedfConfig::MergePartialFromCodedStream(v61, a2, v66)
            || !*((unsigned char *)a2 + 36))
          {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2, v65);
          int v67 = *((_DWORD *)a2 + 14);
          BOOL v55 = __OFSUB__(v67, 1);
          int v68 = v67 - 1;
          if (v68 < 0 == v55) {
            *((_DWORD *)a2 + 14) = v68;
          }
          uint64_t v44 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v26 = *((void *)a2 + 2);
          if ((unint64_t)v44 >= v26) {
            goto LABEL_2;
          }
          int v69 = *v44;
        }
        while (v69 == 98);
        if (v69 == 104)
        {
          int v27 = v44 + 1;
          *((void *)a2 + 1) = v27;
LABEL_157:
          if ((unint64_t)v27 < v26 && (*v27 & 0x80000000) == 0)
          {
            unsigned int *v9 = *v27;
            char v70 = v27 + 1;
            *((void *)a2 + 1) = v70;
            goto LABEL_162;
          }
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v9);
          if (!result) {
            return result;
          }
          char v70 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v26 = *((void *)a2 + 2);
LABEL_162:
          *((_DWORD *)this + 33) |= 0x1000u;
          if ((unint64_t)v70 < v26 && *v70 == 114)
          {
            do
            {
              *((void *)a2 + 1) = v70 + 1;
LABEL_165:
              int v71 = *((_DWORD *)this + 27);
              uint64_t v72 = *((int *)this + 26);
              if ((int)v72 >= v71)
              {
                if (v71 == *((_DWORD *)this + 28))
                {
                  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v85, v71 + 1);
                  int v71 = *((_DWORD *)this + 27);
                }
                *((_DWORD *)this + 27) = v71 + 1;
                operator new();
              }
              uint64_t v73 = *((void *)this + 12);
              *((_DWORD *)this + 26) = v72 + 1;
              int v74 = *(awd::profile::ConfigurationParameter **)(v73 + 8 * v72);
              unsigned int v88 = 0;
              unsigned __int8 v75 = (char *)*((void *)a2 + 1);
              if ((unint64_t)v75 >= *((void *)a2 + 2) || *v75 < 0)
              {
                if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v88))return 0; {
              }
                }
              else
              {
                unsigned int v88 = *v75;
                *((void *)a2 + 1) = v75 + 1;
              }
              int v76 = *((_DWORD *)a2 + 14);
              int v77 = *((_DWORD *)a2 + 15);
              *((_DWORD *)a2 + 14) = v76 + 1;
              if (v76 >= v77) {
                return 0;
              }
              int v78 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2, v88);
              if (!awd::profile::ConfigurationParameter::MergePartialFromCodedStream(v74, a2, v79)
                || !*((unsigned char *)a2 + 36))
              {
                return 0;
              }
              wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2, v78);
              int v80 = *((_DWORD *)a2 + 14);
              BOOL v55 = __OFSUB__(v80, 1);
              int v81 = v80 - 1;
              if (v81 < 0 == v55) {
                *((_DWORD *)a2 + 14) = v81;
              }
              char v70 = (unsigned char *)*((void *)a2 + 1);
              unint64_t v28 = *((void *)a2 + 2);
              if ((unint64_t)v70 >= v28) {
                goto LABEL_2;
              }
              int v82 = *v70;
            }
            while (v82 == 114);
            if (v82 == 120) {
              break;
            }
          }
        }
      }
    }
    char v29 = v70 + 1;
    *((void *)a2 + 1) = v29;
LABEL_183:
    if ((unint64_t)v29 >= v28 || (char)*v29 < 0) {
      break;
    }
    *int v10 = *v29;
    uint64_t v83 = (char *)(v29 + 1);
    *((void *)a2 + 1) = v83;
LABEL_188:
    *((_DWORD *)this + 33) |= 0x4000u;
    if (v83 == (char *)v28 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
    {
      *((_DWORD *)a2 + 8) = 0;
      uint64_t result = 1;
      *((unsigned char *)a2 + 36) = 1;
      return result;
    }
  }
  uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v10);
  if (result)
  {
    uint64_t v83 = (char *)*((void *)a2 + 1);
    unint64_t v28 = *((void *)a2 + 2);
    goto LABEL_188;
  }
  return result;
}

uint64_t awd::profile::Metric::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 132);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(this + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 132);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_27;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_DWORD *)(v5 + 12), a2, a4);
  int v6 = *(_DWORD *)(v5 + 132);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_28;
  }
LABEL_27:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteSInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(_DWORD *)(v5 + 16), (int)a2, a4);
  int v6 = *(_DWORD *)(v5 + 132);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_29;
  }
LABEL_28:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteSInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(_DWORD *)(v5 + 20), (int)a2, a4);
  int v6 = *(_DWORD *)(v5 + 132);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_30;
  }
LABEL_29:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, *(_DWORD *)(v5 + 24), a2, a4);
  int v6 = *(_DWORD *)(v5 + 132);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_31;
  }
LABEL_30:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, *(_DWORD *)(v5 + 28), a2, a4);
  int v6 = *(_DWORD *)(v5 + 132);
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_32;
  }
LABEL_31:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, *(_DWORD *)(v5 + 32), (int)a2, a4);
  int v6 = *(_DWORD *)(v5 + 132);
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_33;
  }
LABEL_32:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8, *(_DWORD *)(v5 + 36), (int)a2, a4);
  int v6 = *(_DWORD *)(v5 + 132);
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_33:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, *(unsigned __int8 *)(v5 + 40), (BOOL)a2, a4);
  if ((*(_DWORD *)(v5 + 132) & 0x200) != 0) {
LABEL_11:
  }
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, *(_DWORD *)(v5 + 44), a2, a4);
LABEL_12:
  if (*(int *)(v5 + 56) >= 1)
  {
    uint64_t v7 = 0;
    do
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, *(void *)(*(void *)(v5 + 48) + 8 * v7++), a2, a4);
    while (v7 < *(int *)(v5 + 56));
  }
  if (*(int *)(v5 + 80) >= 1)
  {
    uint64_t v8 = 0;
    do
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xC, *(void *)(*(void *)(v5 + 72) + 8 * v8++), a2, a4);
    while (v8 < *(int *)(v5 + 80));
  }
  if ((*(unsigned char *)(v5 + 133) & 0x10) != 0) {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xD, *(_DWORD *)(v5 + 120), a2, a4);
  }
  if (*(int *)(v5 + 104) >= 1)
  {
    uint64_t v9 = 0;
    do
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xE, *(void *)(*(void *)(v5 + 96) + 8 * v9++), a2, a4);
    while (v9 < *(int *)(v5 + 104));
  }
  if ((*(unsigned char *)(v5 + 133) & 0x40) != 0)
  {
    int v10 = *(_DWORD *)(v5 + 124);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xF, v10, a2, a4);
  }
  return this;
}

uint64_t awd::profile::Metric::ByteSize(awd::profile::Metric *this, unint64_t a2)
{
  int v3 = *((_DWORD *)this + 33);
  if (!(_BYTE)v3)
  {
    int v4 = 0;
    goto LABEL_49;
  }
  if ((v3 & 1) == 0)
  {
    int v4 = 0;
    if ((v3 & 2) == 0) {
      goto LABEL_14;
    }
    goto LABEL_10;
  }
  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
  if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
    int v3 = *((_DWORD *)this + 33);
  }
  else
  {
    int v6 = 1;
  }
  int v4 = v6 + 1;
  if ((v3 & 2) != 0)
  {
LABEL_10:
    uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 3);
    if (v7 >= 0x80)
    {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2);
      int v3 = *((_DWORD *)this + 33);
    }
    else
    {
      int v8 = 1;
    }
    v4 += v8 + 1;
  }
LABEL_14:
  if ((v3 & 4) != 0)
  {
    uint64_t v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)((2 * *((_DWORD *)this + 4)) ^ (*((int *)this + 4) >> 31));
    if (v9 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, a2);
      int v3 = *((_DWORD *)this + 33);
    }
    else
    {
      int v10 = 1;
    }
    v4 += v10 + 1;
    if ((v3 & 8) == 0)
    {
LABEL_16:
      if ((v3 & 0x10) == 0) {
        goto LABEL_17;
      }
      goto LABEL_29;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_16;
  }
  int v11 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)((2 * *((_DWORD *)this + 5)) ^ (*((int *)this + 5) >> 31));
  if (v11 >= 0x80)
  {
    int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11, a2);
    int v3 = *((_DWORD *)this + 33);
  }
  else
  {
    int v12 = 1;
  }
  v4 += v12 + 1;
  if ((v3 & 0x10) == 0)
  {
LABEL_17:
    if ((v3 & 0x20) == 0) {
      goto LABEL_18;
    }
    goto LABEL_33;
  }
LABEL_29:
  int v13 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 6);
  if (v13 >= 0x80)
  {
    int v14 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v13, a2);
    int v3 = *((_DWORD *)this + 33);
  }
  else
  {
    int v14 = 1;
  }
  v4 += v14 + 1;
  if ((v3 & 0x20) == 0)
  {
LABEL_18:
    if ((v3 & 0x40) == 0) {
      goto LABEL_19;
    }
    goto LABEL_37;
  }
LABEL_33:
  int v15 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 7);
  if (v15 >= 0x80)
  {
    int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v15, a2);
    int v3 = *((_DWORD *)this + 33);
  }
  else
  {
    int v16 = 1;
  }
  v4 += v16 + 1;
  if ((v3 & 0x40) == 0)
  {
LABEL_19:
    if ((v3 & 0x80) == 0) {
      goto LABEL_49;
    }
    goto LABEL_43;
  }
LABEL_37:
  uint64_t v17 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 8);
  if ((v17 & 0x80000000) != 0)
  {
    int v18 = 10;
  }
  else if (v17 >= 0x80)
  {
    int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v17, a2);
    int v3 = *((_DWORD *)this + 33);
  }
  else
  {
    int v18 = 1;
  }
  v4 += v18 + 1;
  if ((v3 & 0x80) != 0)
  {
LABEL_43:
    int v19 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 9);
    if ((v19 & 0x80000000) != 0)
    {
      int v20 = 11;
    }
    else if (v19 >= 0x80)
    {
      int v20 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v19, a2) + 1;
      int v3 = *((_DWORD *)this + 33);
    }
    else
    {
      int v20 = 2;
    }
    v4 += v20;
  }
LABEL_49:
  if ((v3 & 0xFF00) == 0) {
    goto LABEL_68;
  }
  if ((v3 & 0x100) != 0) {
    v4 += 2;
  }
  if ((v3 & 0x200) != 0)
  {
    int v21 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 11);
    if (v21 >= 0x80)
    {
      int v22 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v21, a2) + 1;
      int v3 = *((_DWORD *)this + 33);
    }
    else
    {
      int v22 = 2;
    }
    v4 += v22;
    if ((v3 & 0x1000) == 0)
    {
LABEL_54:
      if ((v3 & 0x4000) == 0) {
        goto LABEL_68;
      }
      goto LABEL_64;
    }
  }
  else if ((v3 & 0x1000) == 0)
  {
    goto LABEL_54;
  }
  int v23 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 30);
  if (v23 >= 0x80)
  {
    int v24 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v23, a2) + 1;
    int v3 = *((_DWORD *)this + 33);
  }
  else
  {
    int v24 = 2;
  }
  v4 += v24;
  if ((v3 & 0x4000) != 0)
  {
LABEL_64:
    int v25 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 31);
    if (v25 >= 0x80) {
      int v26 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v25, a2) + 1;
    }
    else {
      int v26 = 2;
    }
    v4 += v26;
  }
LABEL_68:
  int v27 = *((_DWORD *)this + 14);
  int v28 = v27 + v4;
  if (v27 >= 1)
  {
    uint64_t v29 = 0;
    do
    {
      int v30 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)awd::profile::ProcessingRule::ByteSize(*(awd::profile::ProcessingRule **)(*((void *)this + 6) + 8 * v29), a2);
      int v31 = (int)v30;
      if (v30 >= 0x80) {
        int v32 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v30, a2);
      }
      else {
        int v32 = 1;
      }
      v28 += v31 + v32;
      ++v29;
    }
    while (v29 < *((int *)this + 14));
  }
  int v33 = *((_DWORD *)this + 20);
  int v34 = v33 + v28;
  if (v33 >= 1)
  {
    uint64_t v35 = 0;
    do
    {
      unint64_t v36 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)awd::profile::BedfConfig::ByteSize(*(awd::profile::BedfConfig **)(*((void *)this + 9) + 8 * v35), a2);
      int v37 = (int)v36;
      if (v36 >= 0x80) {
        int v38 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v36, a2);
      }
      else {
        int v38 = 1;
      }
      v34 += v37 + v38;
      ++v35;
    }
    while (v35 < *((int *)this + 20));
  }
  int v39 = *((_DWORD *)this + 26);
  uint64_t v40 = (v39 + v34);
  if (v39 >= 1)
  {
    uint64_t v41 = 0;
    do
    {
      unsigned int v42 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)awd::profile::ConfigurationParameter::ByteSize(*(awd::profile::ConfigurationParameter **)(*((void *)this + 12) + 8 * v41), a2);
      int v43 = (int)v42;
      if (v42 >= 0x80) {
        int v44 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v42, a2);
      }
      else {
        int v44 = 1;
      }
      uint64_t v40 = (v43 + v40 + v44);
      ++v41;
    }
    while (v41 < *((int *)this + 26));
  }
  *((_DWORD *)this + 32) = v40;
  return v40;
}

uint64_t awd::profile::Metric::IsInitialized(awd::profile::Metric *this)
{
  return 1;
}

void *awd::profile::Metric::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.profile.Metric");
}

void awd::profile::Profile::MergeFrom(awd::profile::Profile *this, const awd::profile::Profile *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v34);
  }
  int v4 = *((_DWORD *)a2 + 6);
  if (v4)
  {
    sub_10004BAE8((uint64_t)this + 16, *((_DWORD *)this + 6) + v4);
    memcpy((void *)(*((void *)this + 2) + 4 * *((int *)this + 6)), *((const void **)a2 + 2), 4 * *((int *)a2 + 6));
    *((_DWORD *)this + 6) += *((_DWORD *)a2 + 6);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::Profile *)((char *)this + 40), *((_DWORD *)a2 + 12) + *((_DWORD *)this + 12));
  if (*((int *)a2 + 12) >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      int v6 = *(const awd::profile::Metric **)(*((void *)a2 + 5) + 8 * v5);
      int v7 = *((_DWORD *)this + 13);
      uint64_t v8 = *((int *)this + 12);
      if ((int)v8 >= v7)
      {
        if (v7 == *((_DWORD *)this + 14))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::Profile *)((char *)this + 40), v7 + 1);
          int v7 = *((_DWORD *)this + 13);
        }
        *((_DWORD *)this + 13) = v7 + 1;
        operator new();
      }
      uint64_t v9 = *((void *)this + 5);
      *((_DWORD *)this + 12) = v8 + 1;
      awd::profile::Metric::MergeFrom(*(awd::profile::Metric **)(v9 + 8 * v8), v6);
      ++v5;
    }
    while (v5 < *((int *)a2 + 12));
  }
  int v10 = (std::string *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::Profile *)((char *)this + 88), *((_DWORD *)a2 + 24) + *((_DWORD *)this + 24));
  if (*((int *)a2 + 24) >= 1)
  {
    uint64_t v11 = 0;
    do
    {
      int v12 = *(const std::string **)(*((void *)a2 + 11) + 8 * v11);
      int v13 = *((_DWORD *)this + 25);
      uint64_t v14 = *((int *)this + 24);
      if ((int)v14 >= v13)
      {
        if (v13 == *((_DWORD *)this + 26))
        {
          int v10 = (std::string *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::Profile *)((char *)this + 88), v13 + 1);
          int v13 = *((_DWORD *)this + 25);
        }
        *((_DWORD *)this + 25) = v13 + 1;
        int v16 = (std::string *)wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New((wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)v10);
        uint64_t v17 = *((void *)this + 11);
        uint64_t v18 = *((int *)this + 24);
        *((_DWORD *)this + 24) = v18 + 1;
        *(void *)(v17 + 8 * v18) = v16;
      }
      else
      {
        uint64_t v15 = *((void *)this + 11);
        *((_DWORD *)this + 24) = v14 + 1;
        int v16 = *(std::string **)(v15 + 8 * v14);
      }
      int v10 = std::string::operator=(v16, v12);
      ++v11;
    }
    while (v11 < *((int *)a2 + 24));
  }
  int v19 = *((_DWORD *)a2 + 33);
  if ((_BYTE)v19)
  {
    if (v19)
    {
      int v20 = *((_DWORD *)a2 + 2);
      *((_DWORD *)this + 33) |= 1u;
      *((_DWORD *)this + 2) = v20;
      int v19 = *((_DWORD *)a2 + 33);
      if ((v19 & 2) == 0)
      {
LABEL_24:
        if ((v19 & 8) == 0) {
          goto LABEL_25;
        }
        goto LABEL_31;
      }
    }
    else if ((v19 & 2) == 0)
    {
      goto LABEL_24;
    }
    int v21 = *((_DWORD *)a2 + 3);
    *((_DWORD *)this + 33) |= 2u;
    *((_DWORD *)this + 3) = v21;
    int v19 = *((_DWORD *)a2 + 33);
    if ((v19 & 8) == 0)
    {
LABEL_25:
      if ((v19 & 0x10) == 0) {
        goto LABEL_26;
      }
      goto LABEL_32;
    }
LABEL_31:
    int v22 = *((_DWORD *)a2 + 8);
    *((_DWORD *)this + 33) |= 8u;
    *((_DWORD *)this + 8) = v22;
    int v19 = *((_DWORD *)a2 + 33);
    if ((v19 & 0x10) == 0)
    {
LABEL_26:
      if ((v19 & 0x20) == 0) {
        goto LABEL_27;
      }
      goto LABEL_33;
    }
LABEL_32:
    int v23 = *((_DWORD *)a2 + 9);
    *((_DWORD *)this + 33) |= 0x10u;
    *((_DWORD *)this + 9) = v23;
    int v19 = *((_DWORD *)a2 + 33);
    if ((v19 & 0x20) == 0)
    {
LABEL_27:
      if ((v19 & 0x80) == 0) {
        goto LABEL_39;
      }
      goto LABEL_34;
    }
LABEL_33:
    int v24 = *((_DWORD *)a2 + 16);
    *((_DWORD *)this + 33) |= 0x20u;
    *((_DWORD *)this + 16) = v24;
    int v19 = *((_DWORD *)a2 + 33);
    if ((v19 & 0x80) == 0) {
      goto LABEL_39;
    }
LABEL_34:
    *((_DWORD *)this + 33) |= 0x80u;
    int v25 = (awd::profile::Log *)*((void *)this + 9);
    if (!v25) {
      operator new();
    }
    int v26 = (const awd::profile::Log *)*((void *)a2 + 9);
    if (!v26)
    {
      awd::profile::protobuf_AddDesc_AwdProfile_2eproto((awd::profile *)v10);
      int v26 = *(const awd::profile::Log **)(awd::profile::Profile::default_instance_ + 72);
    }
    awd::profile::Log::MergeFrom(v25, v26);
    int v19 = *((_DWORD *)a2 + 33);
  }
LABEL_39:
  if ((v19 & 0xFF00) == 0) {
    return;
  }
  if ((v19 & 0x100) != 0)
  {
    int v27 = *((_DWORD *)a2 + 17);
    *((_DWORD *)this + 33) |= 0x100u;
    *((_DWORD *)this + 17) = v27;
    int v19 = *((_DWORD *)a2 + 33);
    if ((v19 & 0x200) == 0)
    {
LABEL_42:
      if ((v19 & 0x400) == 0) {
        goto LABEL_43;
      }
      goto LABEL_49;
    }
  }
  else if ((v19 & 0x200) == 0)
  {
    goto LABEL_42;
  }
  int v28 = *((_DWORD *)a2 + 20);
  *((_DWORD *)this + 33) |= 0x200u;
  *((_DWORD *)this + 20) = v28;
  int v19 = *((_DWORD *)a2 + 33);
  if ((v19 & 0x400) == 0)
  {
LABEL_43:
    if ((v19 & 0x800) == 0) {
      goto LABEL_44;
    }
    goto LABEL_50;
  }
LABEL_49:
  int v29 = *((_DWORD *)a2 + 21);
  *((_DWORD *)this + 33) |= 0x400u;
  *((_DWORD *)this + 21) = v29;
  int v19 = *((_DWORD *)a2 + 33);
  if ((v19 & 0x800) == 0)
  {
LABEL_44:
    if ((v19 & 0x2000) == 0) {
      goto LABEL_45;
    }
    goto LABEL_51;
  }
LABEL_50:
  int v30 = *((_DWORD *)a2 + 28);
  *((_DWORD *)this + 33) |= 0x800u;
  *((_DWORD *)this + 28) = v30;
  int v19 = *((_DWORD *)a2 + 33);
  if ((v19 & 0x2000) == 0)
  {
LABEL_45:
    if ((v19 & 0x4000) == 0) {
      return;
    }
    goto LABEL_52;
  }
LABEL_51:
  char v31 = *((unsigned char *)a2 + 116);
  *((_DWORD *)this + 33) |= 0x2000u;
  *((unsigned char *)this + 116) = v31;
  if ((*((_DWORD *)a2 + 33) & 0x4000) == 0) {
    return;
  }
LABEL_52:
  int v32 = (const std::string *)*((void *)a2 + 15);
  *((_DWORD *)this + 33) |= 0x4000u;
  int v33 = (std::string *)*((void *)this + 15);
  if (v33 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v33, v32);
}

void sub_100131F10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::profile::Profile::~Profile(awd::profile::Profile *this)
{
  *(void *)this = off_1001BECD8;
  awd::profile::Profile::SharedDtor(this);
  sub_10013CC70((int *)this + 22);
  sub_1000FB750((uint64_t *)this + 5);
  if (*((void *)this + 2)) {
    operator delete[]();
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::profile::Profile::~Profile(this);

  operator delete();
}

void awd::profile::Profile::SharedDtor(awd::profile::Profile *this)
{
  uint64_t v2 = *((void *)this + 15);
  if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    operator delete();
  }
  awd::profile::protobuf_AddDesc_AwdProfile_2eproto(this);
  if ((awd::profile::Profile *)awd::profile::Profile::default_instance_ != this)
  {
    uint64_t v4 = *((void *)this + 9);
    if (v4)
    {
      uint64_t v5 = *(void (**)(void))(*(void *)v4 + 8);
      v5();
    }
  }
}

void awd::profile::Profile::New(awd::profile::Profile *this)
{
}

uint64_t awd::profile::Profile::Clear(awd::profile::Profile *this)
{
  int v2 = *((_DWORD *)this + 33);
  if ((_BYTE)v2)
  {
    *((void *)this + 1) = 0;
    *((void *)this + 4) = 0;
    *((_DWORD *)this + 16) = 0;
    if ((v2 & 0x80) != 0)
    {
      uint64_t v3 = *((void *)this + 9);
      if (v3)
      {
        sub_1000FB6E0(v3 + 8);
        *(_DWORD *)(v3 + 36) = 0;
        int v2 = *((_DWORD *)this + 33);
      }
    }
  }
  if ((v2 & 0xFF00) != 0)
  {
    *((_DWORD *)this + 17) = 0;
    *((void *)this + 10) = 0;
    *((_DWORD *)this + 28) = 0;
    *((unsigned char *)this + 116) = 0;
    if ((v2 & 0x4000) != 0)
    {
      uint64_t v4 = *((void *)this + 15);
      if ((_UNKNOWN *)v4 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
  }
  *((_DWORD *)this + 6) = 0;
  sub_1000FB6E0((uint64_t)this + 40);
  uint64_t result = sub_1000E702C((uint64_t)this + 88);
  *((_DWORD *)this + 33) = 0;
  return result;
}

uint64_t awd::profile::Log::Clear(awd::profile::Log *this)
{
  uint64_t result = sub_1000FB6E0((uint64_t)this + 8);
  *((_DWORD *)this + 9) = 0;
  return result;
}

uint64_t awd::profile::Profile::MergePartialFromCodedStream(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  uint64_t v4 = this;
  uint64_t v5 = (uint64_t *)(this + 16);
  int v82 = (unsigned int *)(this + 8);
  uint64_t v83 = (unsigned int *)(this + 12);
  int v6 = (unsigned int *)(this + 32);
  int v7 = (unsigned int *)(this + 68);
  uint64_t v8 = (unsigned int *)(this + 80);
  uint64_t v9 = (unsigned int *)(this + 84);
  int v10 = (unsigned int *)(this + 112);
  int v80 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(this + 88);
  int v81 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(this + 40);
LABEL_2:
  while (2)
  {
    uint64_t v11 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v11 >= *((void *)a2 + 2) || *v11 < 0)
    {
      this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      int v12 = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)this;
      *((_DWORD *)a2 + 8) = this;
      if (!this) {
        return 1;
      }
    }
    else
    {
      int v12 = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v11;
      *((_DWORD *)a2 + 8) = v12;
      *((void *)a2 + 1) = v11 + 1;
      if (!v12) {
        return 1;
      }
    }
    switch(v12 >> 3)
    {
      case 1u:
        int v13 = v12 & 7;
        if ((v12 & 7) != 0) {
          goto LABEL_42;
        }
        uint64_t v15 = (char *)*((void *)a2 + 1);
        unint64_t v14 = *((void *)a2 + 2);
        if ((unint64_t)v15 >= v14 || *v15 < 0)
        {
          this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v82);
          if (!this) {
            return this;
          }
          int v16 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
        }
        else
        {
          *int v82 = *v15;
          int v16 = v15 + 1;
          *((void *)a2 + 1) = v16;
        }
        *(_DWORD *)(v4 + 132) |= 1u;
        if ((unint64_t)v16 < v14 && *v16 == 24)
        {
          uint64_t v17 = v16 + 1;
          *((void *)a2 + 1) = v17;
          goto LABEL_52;
        }
        continue;
      case 3u:
        int v13 = v12 & 7;
        if ((v12 & 7) != 0) {
          goto LABEL_42;
        }
        uint64_t v17 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v14 = *((void *)a2 + 2);
LABEL_52:
        if ((unint64_t)v17 >= v14 || (char)*v17 < 0)
        {
          this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v83);
          if (!this) {
            return this;
          }
          int v30 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int *v83 = *v17;
          int v30 = v17 + 1;
          *((void *)a2 + 1) = v30;
        }
        *(_DWORD *)(v4 + 132) |= 2u;
        if ((unint64_t)v30 < v14)
        {
          int v31 = *v30;
          goto LABEL_77;
        }
        continue;
      case 4u:
        int v13 = v12 & 7;
        if (v13 != 2)
        {
          if ((v12 & 7) == 0)
          {
            uint64_t v18 = (char *)*((void *)a2 + 1);
            unint64_t v14 = *((void *)a2 + 2);
            goto LABEL_59;
          }
LABEL_42:
          if (v13 == 4) {
            return 1;
          }
          this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, v12, a3);
          if ((this & 1) == 0) {
            return 0;
          }
          continue;
        }
        this = sub_100128694(a2, (uint64_t)v5);
        if (!this) {
          return this;
        }
        while (1)
        {
          int v30 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
          if ((unint64_t)v30 >= v14) {
            goto LABEL_2;
          }
          int v31 = *v30;
          if (v31 == 40) {
            break;
          }
LABEL_77:
          if (v31 != 32) {
            goto LABEL_2;
          }
          uint64_t v18 = (char *)(v30 + 1);
          *((void *)a2 + 1) = v18;
LABEL_59:
          unsigned int v84 = 0;
          if ((unint64_t)v18 >= v14 || *v18 < 0)
          {
            this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v84);
            if (!this) {
              return 0;
            }
          }
          else
          {
            unsigned int v84 = *v18;
            *((void *)a2 + 1) = v18 + 1;
          }
          int v32 = *(_DWORD *)(v4 + 24);
          if (v32 == *(_DWORD *)(v4 + 28))
          {
            this = sub_10004BAE8((uint64_t)v5, v32 + 1);
            int v32 = *(_DWORD *)(v4 + 24);
          }
          unsigned int v33 = v84;
          uint64_t v34 = *(void *)(v4 + 16);
          *(_DWORD *)(v4 + 24) = v32 + 1;
          *(_DWORD *)(v34 + 4 * v32) = v33;
          int v35 = *(_DWORD *)(v4 + 28) - *(_DWORD *)(v4 + 24);
          if (v35 >= 1)
          {
            int v36 = v35 + 1;
            do
            {
              int v37 = (unsigned char *)*((void *)a2 + 1);
              unint64_t v38 = *((void *)a2 + 2);
              if ((unint64_t)v37 >= v38 || *v37 != 32) {
                break;
              }
              *((void *)a2 + 1) = v37 + 1;
              if ((unint64_t)(v37 + 1) >= v38 || (char)v37[1] < 0)
              {
                this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v84);
                if (!this) {
                  return 0;
                }
                unsigned int v39 = v84;
                uint64_t v34 = *v5;
              }
              else
              {
                unsigned int v39 = v37[1];
                unsigned int v84 = v39;
                *((void *)a2 + 1) = v37 + 2;
              }
              uint64_t v40 = *(int *)(v4 + 24);
              *(_DWORD *)(v4 + 24) = v40 + 1;
              *(_DWORD *)(v34 + 4 * v40) = v39;
              --v36;
            }
            while (v36 > 1);
          }
        }
        int v19 = (char *)(v30 + 1);
        *((void *)a2 + 1) = v19;
LABEL_80:
        if ((unint64_t)v19 >= v14 || *v19 < 0)
        {
          this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v6);
          if (!this) {
            return this;
          }
          uint64_t v41 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
        }
        else
        {
          *int v6 = *v19;
          uint64_t v41 = v19 + 1;
          *((void *)a2 + 1) = v41;
        }
        *(_DWORD *)(v4 + 132) |= 8u;
        if ((unint64_t)v41 >= v14 || *v41 != 48) {
          continue;
        }
        int v20 = v41 + 1;
        *((void *)a2 + 1) = v20;
LABEL_88:
        unsigned int v84 = 0;
        if ((unint64_t)v20 >= v14 || *v20 < 0)
        {
          this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v84);
          if (!this) {
            return this;
          }
          unsigned int v42 = v84;
          int v43 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v42 = *v20;
          int v43 = v20 + 1;
          *((void *)a2 + 1) = v43;
        }
        *(_DWORD *)(v4 + 36) = v42;
        *(_DWORD *)(v4 + 132) |= 0x10u;
        if ((unint64_t)v43 >= v14 || *v43 != 56) {
          continue;
        }
        int v21 = v43 + 1;
        *((void *)a2 + 1) = v21;
LABEL_96:
        unsigned int v84 = 0;
        if ((unint64_t)v21 >= v14 || *v21 < 0)
        {
          this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v84);
          if (!this) {
            return this;
          }
          unsigned int v44 = v84;
          int v45 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v14 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v44 = *v21;
          int v45 = v21 + 1;
          *((void *)a2 + 1) = v45;
        }
        *(_DWORD *)(v4 + 64) = v44;
        *(_DWORD *)(v4 + 132) |= 0x20u;
        if ((unint64_t)v45 >= v14 || *v45 != 66) {
          continue;
        }
        do
        {
          *((void *)a2 + 1) = v45 + 1;
LABEL_104:
          int v46 = *(_DWORD *)(v4 + 52);
          uint64_t v47 = *(int *)(v4 + 48);
          if ((int)v47 >= v46)
          {
            if (v46 == *(_DWORD *)(v4 + 56))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v81, v46 + 1);
              int v46 = *(_DWORD *)(v4 + 52);
            }
            *(_DWORD *)(v4 + 52) = v46 + 1;
            operator new();
          }
          uint64_t v48 = *(void *)(v4 + 40);
          *(_DWORD *)(v4 + 48) = v47 + 1;
          unsigned int v49 = *(awd::profile::Metric **)(v48 + 8 * v47);
          unsigned int v84 = 0;
          int v50 = (char *)*((void *)a2 + 1);
          if ((unint64_t)v50 >= *((void *)a2 + 2) || *v50 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v84))return 0; {
          }
            }
          else
          {
            unsigned int v84 = *v50;
            *((void *)a2 + 1) = v50 + 1;
          }
          int v51 = *((_DWORD *)a2 + 14);
          int v52 = *((_DWORD *)a2 + 15);
          *((_DWORD *)a2 + 14) = v51 + 1;
          if (v51 >= v52) {
            return 0;
          }
          int v53 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2, v84);
          if (!awd::profile::Metric::MergePartialFromCodedStream(v49, a2, v54) || !*((unsigned char *)a2 + 36)) {
            return 0;
          }
          this = wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2, v53);
          int v55 = *((_DWORD *)a2 + 14);
          BOOL v56 = __OFSUB__(v55, 1);
          int v57 = v55 - 1;
          if (v57 < 0 == v56) {
            *((_DWORD *)a2 + 14) = v57;
          }
          int v45 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v45 >= *((void *)a2 + 2)) {
            goto LABEL_2;
          }
          int v58 = *v45;
        }
        while (v58 == 66);
        if (v58 != 74) {
          continue;
        }
        *((void *)a2 + 1) = v45 + 1;
LABEL_122:
        *(_DWORD *)(v4 + 132) |= 0x80u;
        uint64_t v59 = *(awd::profile::Log **)(v4 + 72);
        if (!v59) {
          operator new();
        }
        unsigned int v84 = 0;
        uint64_t v60 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v60 >= *((void *)a2 + 2) || *v60 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v84))return 0; {
        }
          }
        else
        {
          unsigned int v84 = *v60;
          *((void *)a2 + 1) = v60 + 1;
        }
        int v61 = *((_DWORD *)a2 + 14);
        int v62 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v61 + 1;
        if (v61 < v62)
        {
          int v63 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2, v84);
          if (awd::profile::Log::MergePartialFromCodedStream(v59, a2, v64))
          {
            if (*((unsigned char *)a2 + 36))
            {
              this = wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2, v63);
              int v65 = *((_DWORD *)a2 + 14);
              BOOL v56 = __OFSUB__(v65, 1);
              int v66 = v65 - 1;
              if (v66 < 0 == v56) {
                *((_DWORD *)a2 + 14) = v66;
              }
              int v67 = (unsigned char *)*((void *)a2 + 1);
              unint64_t v22 = *((void *)a2 + 2);
              if ((unint64_t)v67 < v22 && *v67 == 80)
              {
                int v23 = v67 + 1;
                *((void *)a2 + 1) = v23;
LABEL_136:
                if ((unint64_t)v23 >= v22 || *v23 < 0)
                {
                  this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v7);
                  if (!this) {
                    return this;
                  }
                  int v68 = (unsigned char *)*((void *)a2 + 1);
                  unint64_t v22 = *((void *)a2 + 2);
                }
                else
                {
                  unsigned int *v7 = *v23;
                  int v68 = v23 + 1;
                  *((void *)a2 + 1) = v68;
                }
                *(_DWORD *)(v4 + 132) |= 0x100u;
                if ((unint64_t)v68 < v22 && *v68 == 88)
                {
                  int v24 = v68 + 1;
                  *((void *)a2 + 1) = v24;
LABEL_144:
                  if ((unint64_t)v24 >= v22 || *v24 < 0)
                  {
                    this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v8);
                    if (!this) {
                      return this;
                    }
                    int v69 = (unsigned char *)*((void *)a2 + 1);
                    unint64_t v22 = *((void *)a2 + 2);
                  }
                  else
                  {
                    unsigned int *v8 = *v24;
                    int v69 = v24 + 1;
                    *((void *)a2 + 1) = v69;
                  }
                  *(_DWORD *)(v4 + 132) |= 0x200u;
                  if ((unint64_t)v69 < v22 && *v69 == 104)
                  {
                    int v25 = v69 + 1;
                    *((void *)a2 + 1) = v25;
LABEL_152:
                    if ((unint64_t)v25 >= v22 || (char)*v25 < 0)
                    {
                      this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v9);
                      if (!this) {
                        return this;
                      }
                      char v70 = (unsigned __int8 *)*((void *)a2 + 1);
                      unint64_t v22 = *((void *)a2 + 2);
                    }
                    else
                    {
                      unsigned int *v9 = *v25;
                      char v70 = v25 + 1;
                      *((void *)a2 + 1) = v70;
                    }
                    *(_DWORD *)(v4 + 132) |= 0x400u;
                    if ((int)v22 - (int)v70 >= 2 && *v70 == 160 && v70[1] == 1)
                    {
                      int v26 = v70 + 2;
                      *((void *)a2 + 1) = v26;
LABEL_161:
                      if ((unint64_t)v26 >= v22 || (char)*v26 < 0)
                      {
                        this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v10);
                        if (!this) {
                          return this;
                        }
                        int v71 = (unsigned __int8 *)*((void *)a2 + 1);
                        unint64_t v22 = *((void *)a2 + 2);
                      }
                      else
                      {
                        *int v10 = *v26;
                        int v71 = v26 + 1;
                        *((void *)a2 + 1) = v71;
                      }
                      *(_DWORD *)(v4 + 132) |= 0x800u;
                      if ((int)v22 - (int)v71 >= 2 && *v71 == 130 && v71[1] == 2)
                      {
                        while (1)
                        {
                          *((void *)a2 + 1) = v71 + 2;
LABEL_170:
                          int v72 = *(_DWORD *)(v4 + 100);
                          int v73 = *(_DWORD *)(v4 + 96);
                          if (v73 >= v72)
                          {
                            if (v72 == *(_DWORD *)(v4 + 104))
                            {
                              this = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v80, v72 + 1);
                              int v72 = *(_DWORD *)(v4 + 100);
                            }
                            *(_DWORD *)(v4 + 100) = v72 + 1;
                            uint64_t v74 = wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New((wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)this);
                            uint64_t v75 = *(void *)(v4 + 88);
                            uint64_t v76 = *(int *)(v4 + 96);
                            *(_DWORD *)(v4 + 96) = v76 + 1;
                            *(void *)(v75 + 8 * v76) = v74;
                          }
                          else
                          {
                            *(_DWORD *)(v4 + 96) = v73 + 1;
                          }
                          this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
                          if (!this) {
                            return this;
                          }
                          int v71 = (unsigned __int8 *)*((void *)a2 + 1);
                          unint64_t v27 = *((void *)a2 + 2);
                          if ((int)v27 - (int)v71 < 2) {
                            goto LABEL_2;
                          }
                          int v77 = *v71;
                          if (v77 == 136) {
                            break;
                          }
                          if (v77 != 130 || v71[1] != 2) {
                            goto LABEL_2;
                          }
                        }
                        if (v71[1] == 2)
                        {
                          int v28 = v71 + 2;
                          *((void *)a2 + 1) = v28;
LABEL_183:
                          unsigned int v84 = 0;
                          if ((unint64_t)v28 >= v27 || (char)*v28 < 0)
                          {
                            this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v84);
                            if (!this) {
                              return this;
                            }
                            unsigned int v78 = v84;
                            unsigned int v79 = (unsigned __int8 *)*((void *)a2 + 1);
                            unint64_t v27 = *((void *)a2 + 2);
                          }
                          else
                          {
                            unsigned int v78 = *v28;
                            unsigned int v79 = v28 + 1;
                            *((void *)a2 + 1) = v79;
                          }
                          *(unsigned char *)(v4 + 116) = v78 != 0;
                          int v29 = *(_DWORD *)(v4 + 132) | 0x2000;
                          *(_DWORD *)(v4 + 132) = v29;
                          if ((int)v27 - (int)v79 >= 2 && *v79 == 146 && v79[1] == 2)
                          {
                            *((void *)a2 + 1) = v79 + 2;
LABEL_192:
                            *(_DWORD *)(v4 + 132) = v29 | 0x4000;
                            if (*(_UNKNOWN **)(v4 + 120) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
                              operator new();
                            }
                            this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
                            if (!this) {
                              return this;
                            }
                            if (*((void *)a2 + 1) == *((void *)a2 + 2)
                              && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
                            {
                              *((_DWORD *)a2 + 8) = 0;
                              this = 1;
                              *((unsigned char *)a2 + 36) = 1;
                              return this;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              continue;
            }
          }
        }
        return 0;
      case 5u:
        int v13 = v12 & 7;
        if ((v12 & 7) != 0) {
          goto LABEL_42;
        }
        int v19 = (char *)*((void *)a2 + 1);
        unint64_t v14 = *((void *)a2 + 2);
        goto LABEL_80;
      case 6u:
        int v13 = v12 & 7;
        if ((v12 & 7) != 0) {
          goto LABEL_42;
        }
        int v20 = (char *)*((void *)a2 + 1);
        unint64_t v14 = *((void *)a2 + 2);
        goto LABEL_88;
      case 7u:
        int v13 = v12 & 7;
        if ((v12 & 7) != 0) {
          goto LABEL_42;
        }
        int v21 = (char *)*((void *)a2 + 1);
        unint64_t v14 = *((void *)a2 + 2);
        goto LABEL_96;
      case 8u:
        int v13 = v12 & 7;
        if (v13 == 2) {
          goto LABEL_104;
        }
        goto LABEL_42;
      case 9u:
        int v13 = v12 & 7;
        if (v13 == 2) {
          goto LABEL_122;
        }
        goto LABEL_42;
      case 0xAu:
        int v13 = v12 & 7;
        if ((v12 & 7) != 0) {
          goto LABEL_42;
        }
        int v23 = (char *)*((void *)a2 + 1);
        unint64_t v22 = *((void *)a2 + 2);
        goto LABEL_136;
      case 0xBu:
        int v13 = v12 & 7;
        if ((v12 & 7) != 0) {
          goto LABEL_42;
        }
        int v24 = (char *)*((void *)a2 + 1);
        unint64_t v22 = *((void *)a2 + 2);
        goto LABEL_144;
      case 0xDu:
        int v13 = v12 & 7;
        if ((v12 & 7) != 0) {
          goto LABEL_42;
        }
        int v25 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v22 = *((void *)a2 + 2);
        goto LABEL_152;
      case 0x14u:
        int v13 = v12 & 7;
        if ((v12 & 7) != 0) {
          goto LABEL_42;
        }
        int v26 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v22 = *((void *)a2 + 2);
        goto LABEL_161;
      case 0x20u:
        int v13 = v12 & 7;
        if (v13 == 2) {
          goto LABEL_170;
        }
        goto LABEL_42;
      case 0x21u:
        int v13 = v12 & 7;
        if ((v12 & 7) != 0) {
          goto LABEL_42;
        }
        int v28 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v27 = *((void *)a2 + 2);
        goto LABEL_183;
      case 0x22u:
        int v13 = v12 & 7;
        if (v13 != 2) {
          goto LABEL_42;
        }
        int v29 = *(_DWORD *)(v4 + 132);
        goto LABEL_192;
      default:
        int v13 = v12 & 7;
        goto LABEL_42;
    }
  }
}

int *awd::profile::Profile::SerializeWithCachedSizes(int *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = this[33];
  if (v6)
  {
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, this[2], a2, a4);
    int v6 = v5[33];
  }
  if ((v6 & 2) != 0) {
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v5[3], a2, a4);
  }
  if (v5[6] >= 1)
  {
    uint64_t v7 = 0;
    do
      this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(_DWORD *)(*((void *)v5 + 2) + 4 * v7++), a2, a4);
    while (v7 < v5[6]);
  }
  int v8 = v5[33];
  if ((v8 & 8) != 0)
  {
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v5[8], a2, a4);
    int v8 = v5[33];
    if ((v8 & 0x10) == 0)
    {
LABEL_10:
      if ((v8 & 0x20) == 0) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }
  }
  else if ((v8 & 0x10) == 0)
  {
    goto LABEL_10;
  }
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v5[9], (int)a2, a4);
  if ((v5[33] & 0x20) != 0) {
LABEL_11:
  }
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, v5[16], (int)a2, a4);
LABEL_12:
  if (v5[12] >= 1)
  {
    uint64_t v9 = 0;
    do
      this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8, *(void *)(*((void *)v5 + 5) + 8 * v9++), a2, a4);
    while (v9 < v5[12]);
  }
  int v10 = v5[33];
  if ((v10 & 0x80) != 0)
  {
    uint64_t v13 = *((void *)v5 + 9);
    if (!v13)
    {
      awd::profile::protobuf_AddDesc_AwdProfile_2eproto((awd::profile *)this);
      uint64_t v13 = *(void *)(awd::profile::Profile::default_instance_ + 72);
    }
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, v13, a2, a4);
    int v10 = v5[33];
    if ((v10 & 0x100) == 0)
    {
LABEL_17:
      if ((v10 & 0x200) == 0) {
        goto LABEL_18;
      }
      goto LABEL_34;
    }
  }
  else if ((v10 & 0x100) == 0)
  {
    goto LABEL_17;
  }
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, v5[17], a2, a4);
  int v10 = v5[33];
  if ((v10 & 0x200) == 0)
  {
LABEL_18:
    if ((v10 & 0x400) == 0) {
      goto LABEL_19;
    }
    goto LABEL_35;
  }
LABEL_34:
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, v5[20], a2, a4);
  int v10 = v5[33];
  if ((v10 & 0x400) == 0)
  {
LABEL_19:
    if ((v10 & 0x800) == 0) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
LABEL_35:
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xD, v5[21], a2, a4);
  if ((v5[33] & 0x800) != 0) {
LABEL_20:
  }
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x14, v5[28], a2, a4);
LABEL_21:
  if (v5[24] >= 1)
  {
    uint64_t v11 = 0;
    do
    {
      this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
      ++v11;
    }
    while (v11 < v5[24]);
  }
  int v12 = v5[33];
  if ((v12 & 0x2000) != 0)
  {
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x21, *((unsigned __int8 *)v5 + 116), (BOOL)a2, a4);
    if ((v5[33] & 0x4000) == 0) {
      return this;
    }
  }
  else if ((v12 & 0x4000) == 0)
  {
    return this;
  }

  return (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
}

uint64_t awd::profile::Profile::ByteSize(awd::profile::Profile *this, unint64_t a2)
{
  int v3 = *((_DWORD *)this + 33);
  if (!(_BYTE)v3)
  {
    int v4 = 0;
    goto LABEL_41;
  }
  if ((v3 & 1) == 0)
  {
    int v4 = 0;
    if ((v3 & 2) == 0) {
      goto LABEL_14;
    }
    goto LABEL_10;
  }
  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
  if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
    int v3 = *((_DWORD *)this + 33);
  }
  else
  {
    int v6 = 1;
  }
  int v4 = v6 + 1;
  if ((v3 & 2) != 0)
  {
LABEL_10:
    uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 3);
    if (v7 >= 0x80)
    {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2);
      int v3 = *((_DWORD *)this + 33);
    }
    else
    {
      int v8 = 1;
    }
    v4 += v8 + 1;
  }
LABEL_14:
  if ((v3 & 8) != 0)
  {
    uint64_t v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 8);
    if (v9 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, a2);
      int v3 = *((_DWORD *)this + 33);
    }
    else
    {
      int v10 = 1;
    }
    v4 += v10 + 1;
    if ((v3 & 0x10) == 0)
    {
LABEL_16:
      if ((v3 & 0x20) == 0) {
        goto LABEL_17;
      }
LABEL_29:
      uint64_t v13 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 16);
      if ((v13 & 0x80000000) != 0)
      {
        int v14 = 10;
      }
      else if (v13 >= 0x80)
      {
        int v14 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v13, a2);
        int v3 = *((_DWORD *)this + 33);
      }
      else
      {
        int v14 = 1;
      }
      v4 += v14 + 1;
      if ((v3 & 0x80) == 0) {
        goto LABEL_41;
      }
      goto LABEL_35;
    }
  }
  else if ((v3 & 0x10) == 0)
  {
    goto LABEL_16;
  }
  uint64_t v11 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 9);
  if ((v11 & 0x80000000) != 0)
  {
    int v12 = 10;
  }
  else if (v11 >= 0x80)
  {
    int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11, a2);
    int v3 = *((_DWORD *)this + 33);
  }
  else
  {
    int v12 = 1;
  }
  v4 += v12 + 1;
  if ((v3 & 0x20) != 0) {
    goto LABEL_29;
  }
LABEL_17:
  if ((v3 & 0x80) == 0) {
    goto LABEL_41;
  }
LABEL_35:
  uint64_t v15 = (awd::profile::Log *)*((void *)this + 9);
  if (!v15)
  {
    awd::profile::protobuf_AddDesc_AwdProfile_2eproto(0);
    uint64_t v15 = *(awd::profile::Log **)(awd::profile::Profile::default_instance_ + 72);
  }
  int v16 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)awd::profile::Log::ByteSize(v15, a2);
  int v17 = (int)v16;
  if (v16 >= 0x80) {
    int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v16, a2);
  }
  else {
    int v18 = 1;
  }
  v4 += v17 + v18 + 1;
  int v3 = *((_DWORD *)this + 33);
LABEL_41:
  if ((v3 & 0xFF00) == 0) {
    goto LABEL_75;
  }
  if ((v3 & 0x100) != 0)
  {
    int v19 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 17);
    if (v19 >= 0x80)
    {
      int v20 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v19, a2);
      int v3 = *((_DWORD *)this + 33);
    }
    else
    {
      int v20 = 1;
    }
    v4 += v20 + 1;
    if ((v3 & 0x200) == 0)
    {
LABEL_44:
      if ((v3 & 0x400) == 0) {
        goto LABEL_45;
      }
LABEL_55:
      int v23 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 21);
      if (v23 >= 0x80)
      {
        int v24 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v23, a2) + 1;
        int v3 = *((_DWORD *)this + 33);
      }
      else
      {
        int v24 = 2;
      }
      v4 += v24;
      if ((v3 & 0x800) == 0) {
        goto LABEL_63;
      }
      goto LABEL_59;
    }
  }
  else if ((v3 & 0x200) == 0)
  {
    goto LABEL_44;
  }
  int v21 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 20);
  if (v21 >= 0x80)
  {
    int v22 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v21, a2) + 1;
    int v3 = *((_DWORD *)this + 33);
  }
  else
  {
    int v22 = 2;
  }
  v4 += v22;
  if ((v3 & 0x400) != 0) {
    goto LABEL_55;
  }
LABEL_45:
  if ((v3 & 0x800) != 0)
  {
LABEL_59:
    int v25 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 28);
    if (v25 >= 0x80)
    {
      int v26 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v25, a2) + 2;
      int v3 = *((_DWORD *)this + 33);
    }
    else
    {
      int v26 = 3;
    }
    v4 += v26;
  }
LABEL_63:
  if ((v3 & 0x2000) != 0) {
    v4 += 3;
  }
  if ((v3 & 0x4000) != 0)
  {
    uint64_t v27 = *((void *)this + 15);
    int v28 = *(unsigned __int8 *)(v27 + 23);
    char v29 = v28;
    uint64_t v30 = *(void *)(v27 + 8);
    if ((v28 & 0x80u) == 0) {
      unint64_t v31 = *(unsigned __int8 *)(v27 + 23);
    }
    else {
      unint64_t v31 = v30;
    }
    if (v31 >= 0x80)
    {
      int v32 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v31, a2);
      int v28 = *(unsigned __int8 *)(v27 + 23);
      uint64_t v30 = *(void *)(v27 + 8);
      char v29 = *(unsigned char *)(v27 + 23);
    }
    else
    {
      int v32 = 1;
    }
    if (v29 < 0) {
      int v28 = v30;
    }
    v4 += v32 + v28 + 2;
  }
LABEL_75:
  int v33 = *((_DWORD *)this + 6);
  if (v33 < 1)
  {
    int v35 = 0;
  }
  else
  {
    uint64_t v34 = 0;
    int v35 = 0;
    do
    {
      int v36 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(*((void *)this + 2)
                                                                                             + 4 * v34);
      if (v36 >= 0x80)
      {
        int v37 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v36, a2);
        int v33 = *((_DWORD *)this + 6);
      }
      else
      {
        int v37 = 1;
      }
      v35 += v37;
      ++v34;
    }
    while (v34 < v33);
  }
  int v38 = *((_DWORD *)this + 12);
  int v39 = v35 + v4 + v33 + v38;
  if (v38 >= 1)
  {
    uint64_t v40 = 0;
    do
    {
      uint64_t v41 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)awd::profile::Metric::ByteSize(*(awd::profile::Metric **)(*((void *)this + 5) + 8 * v40), a2);
      int v42 = (int)v41;
      if (v41 >= 0x80) {
        int v43 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v41, a2);
      }
      else {
        int v43 = 1;
      }
      v39 += v42 + v43;
      ++v40;
    }
    while (v40 < *((int *)this + 12));
  }
  int v44 = *((_DWORD *)this + 24);
  uint64_t v45 = (v39 + 2 * v44);
  if (v44 >= 1)
  {
    for (uint64_t i = 0; i < v44; ++i)
    {
      uint64_t v47 = *(void *)(*((void *)this + 11) + 8 * i);
      int v48 = *(unsigned __int8 *)(v47 + 23);
      char v49 = v48;
      uint64_t v50 = *(void *)(v47 + 8);
      if ((v48 & 0x80u) == 0) {
        unint64_t v51 = *(unsigned __int8 *)(v47 + 23);
      }
      else {
        unint64_t v51 = v50;
      }
      if (v51 >= 0x80)
      {
        int v52 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v51, a2);
        int v48 = *(unsigned __int8 *)(v47 + 23);
        uint64_t v50 = *(void *)(v47 + 8);
        int v44 = *((_DWORD *)this + 24);
        char v49 = *(unsigned char *)(v47 + 23);
      }
      else
      {
        int v52 = 1;
      }
      if (v49 < 0) {
        int v48 = v50;
      }
      uint64_t v45 = (v52 + v45 + v48);
    }
  }
  *((_DWORD *)this + 32) = v45;
  return v45;
}

void awd::profile::Log::MergeFrom(awd::profile::Log *this, const awd::profile::Log *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::Log *)((char *)this + 8), *((_DWORD *)a2 + 4) + *((_DWORD *)this + 4));
  if (*((int *)a2 + 4) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(const awd::profile::LogParameter **)(*((void *)a2 + 1) + 8 * v4);
      int v6 = *((_DWORD *)this + 5);
      uint64_t v7 = *((int *)this + 4);
      if ((int)v7 >= v6)
      {
        if (v6 == *((_DWORD *)this + 6))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::Log *)((char *)this + 8), v6 + 1);
          int v6 = *((_DWORD *)this + 5);
        }
        *((_DWORD *)this + 5) = v6 + 1;
        operator new();
      }
      uint64_t v8 = *((void *)this + 1);
      *((_DWORD *)this + 4) = v7 + 1;
      awd::profile::LogParameter::MergeFrom(*(awd::profile::LogParameter **)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *((int *)a2 + 4));
  }
}

void sub_10013351C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

uint64_t awd::profile::Profile::IsInitialized(awd::profile::Profile *this)
{
  return 1;
}

void *awd::profile::Profile::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.profile.Profile");
}

void awd::profile::LogParameter::MergeFrom(awd::profile::LogParameter *this, const awd::profile::LogParameter *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 28);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 28))
    {
      uint64_t v5 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)this + 7) |= 1u;
      int v6 = (std::string *)*((void *)this + 1);
      if (v6 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v6, v5);
      int v4 = *((_DWORD *)a2 + 7);
    }
    if ((v4 & 2) != 0)
    {
      uint64_t v7 = (const std::string *)*((void *)a2 + 2);
      *((_DWORD *)this + 7) |= 2u;
      uint64_t v8 = (std::string *)*((void *)this + 2);
      if (v8 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v8, v7);
    }
  }
}

void sub_100133670(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::profile::LogParameter::~LogParameter(awd::profile::LogParameter *this)
{
  *(void *)this = off_1001BED50;
  awd::profile::LogParameter::SharedDtor(this);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::profile::LogParameter::~LogParameter(this);

  operator delete();
}

void awd::profile::LogParameter::SharedDtor(awd::profile::LogParameter *this)
{
  uint64_t v1 = *((void *)this + 1);
  if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  uint64_t v3 = *((void *)this + 2);
  if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v3 != 0)
  {
    if (*(char *)(v3 + 23) < 0) {
      operator delete(*(void **)v3);
    }
    operator delete();
  }

  awd::profile::protobuf_AddDesc_AwdProfile_2eproto(this);
}

void awd::profile::LogParameter::New(awd::profile::LogParameter *this)
{
}

uint64_t awd::profile::LogParameter::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 28))
  {
    if (*(unsigned char *)(this + 28))
    {
      uint64_t v1 = *(void *)(this + 8);
      if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v1 + 23) < 0)
        {
          **(unsigned char **)uint64_t v1 = 0;
          *(void *)(v1 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v1 = 0;
          *(unsigned char *)(v1 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 28) & 2) != 0)
    {
      uint64_t v2 = *(void *)(this + 16);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 28) = 0;
  return this;
}

uint64_t awd::profile::LogParameter::MergePartialFromCodedStream(awd::profile::LogParameter *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  do
  {
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
        {
          unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          *((_DWORD *)a2 + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          unint64_t TagFallback = *v5;
          *((_DWORD *)a2 + 8) = TagFallback;
          *((void *)a2 + 1) = v5 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_25;
        }
        *((_DWORD *)this + 7) |= 1u;
        if (*((_UNKNOWN **)this + 1) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        uint64_t v9 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v9 < *((void *)a2 + 2) && *v9 == 18)
        {
          *((void *)a2 + 1) = v9 + 1;
          goto LABEL_17;
        }
      }
      if (TagFallback >> 3 != 2)
      {
        int v7 = TagFallback & 7;
        goto LABEL_25;
      }
      int v7 = TagFallback & 7;
      if (v7 == 2) {
        break;
      }
LABEL_25:
      if (v7 == 4) {
        return 1;
      }
      if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
    }
      }
LABEL_17:
    *((_DWORD *)this + 7) |= 2u;
    if (*((_UNKNOWN **)this + 2) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
    if (!result) {
      return result;
    }
  }
  while (*((void *)a2 + 1) != *((void *)a2 + 2)
       || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10));
  *((_DWORD *)a2 + 8) = 0;
  uint64_t result = 1;
  *((unsigned char *)a2 + 36) = 1;
  return result;
}

uint64_t awd::profile::LogParameter::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2)
{
  uint64_t v2 = this;
  int v3 = *(_DWORD *)(this + 28);
  if (v3)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
    int v3 = *(_DWORD *)(v2 + 28);
  }
  if ((v3 & 2) != 0)
  {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  }
  return this;
}

uint64_t awd::profile::LogParameter::ByteSize(awd::profile::LogParameter *this, unsigned int a2)
{
  LOBYTE(v3) = *((unsigned char *)this + 28);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_24;
  }
  if ((*((unsigned char *)this + 28) & 1) == 0)
  {
    uint64_t v4 = 0;
    if ((*((unsigned char *)this + 28) & 2) == 0) {
      goto LABEL_24;
    }
    goto LABEL_15;
  }
  uint64_t v5 = *((void *)this + 1);
  int v6 = *(unsigned __int8 *)(v5 + 23);
  char v7 = v6;
  uint64_t v8 = *(void *)(v5 + 8);
  if ((v6 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 >= 0x80)
  {
    int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9, a2);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v8 = *(void *)(v5 + 8);
    int v10 = v11 + 1;
    int v3 = *((_DWORD *)this + 7);
    char v7 = *(unsigned char *)(v5 + 23);
  }
  else
  {
    int v10 = 2;
  }
  if (v7 < 0) {
    int v6 = v8;
  }
  uint64_t v4 = (v10 + v6);
  if ((v3 & 2) != 0)
  {
LABEL_15:
    uint64_t v12 = *((void *)this + 2);
    int v13 = *(unsigned __int8 *)(v12 + 23);
    char v14 = v13;
    uint64_t v15 = *(void *)(v12 + 8);
    if ((v13 & 0x80u) == 0) {
      unint64_t v16 = *(unsigned __int8 *)(v12 + 23);
    }
    else {
      unint64_t v16 = v15;
    }
    if (v16 >= 0x80)
    {
      int v17 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v16, a2);
      int v13 = *(unsigned __int8 *)(v12 + 23);
      uint64_t v15 = *(void *)(v12 + 8);
      char v14 = *(unsigned char *)(v12 + 23);
    }
    else
    {
      int v17 = 1;
    }
    if (v14 < 0) {
      int v13 = v15;
    }
    uint64_t v4 = (v4 + v17 + v13 + 1);
  }
LABEL_24:
  *((_DWORD *)this + 6) = v4;
  return v4;
}

uint64_t awd::profile::LogParameter::IsInitialized(awd::profile::LogParameter *this)
{
  return 1;
}

void *awd::profile::LogParameter::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.profile.LogParameter");
}

void awd::profile::Log::~Log(awd::profile::Log *this)
{
  *(void *)this = off_1001BEDC8;
  awd::profile::protobuf_AddDesc_AwdProfile_2eproto(this);
  sub_1000FB750((uint64_t *)this + 1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::profile::Log::~Log(this);

  operator delete();
}

void awd::profile::Log::New(awd::profile::Log *this)
{
}

uint64_t awd::profile::Log::MergePartialFromCodedStream(awd::profile::Log *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  uint64_t v5 = (awd::profile::Log *)((char *)this + 8);
  while (1)
  {
LABEL_2:
    int v6 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
    }
    else
    {
      unint64_t TagFallback = *v6;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v6 + 1;
    }
    if (TagFallback == 10)
    {
      while (1)
      {
        int v8 = *((_DWORD *)this + 5);
        uint64_t v9 = *((int *)this + 4);
        if ((int)v9 >= v8)
        {
          if (v8 == *((_DWORD *)this + 6))
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v8 + 1);
            int v8 = *((_DWORD *)this + 5);
          }
          *((_DWORD *)this + 5) = v8 + 1;
          operator new();
        }
        uint64_t v10 = *((void *)this + 1);
        *((_DWORD *)this + 4) = v9 + 1;
        int v11 = *(awd::profile::LogParameter **)(v10 + 8 * v9);
        unsigned int v23 = 0;
        uint64_t v12 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v12 >= *((void *)a2 + 2) || *v12 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v23))return 0; {
        }
          }
        else
        {
          unsigned int v23 = *v12;
          *((void *)a2 + 1) = v12 + 1;
        }
        int v13 = *((_DWORD *)a2 + 14);
        int v14 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v13 + 1;
        if (v13 >= v14) {
          return 0;
        }
        int v15 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2, v23);
        if (!awd::profile::LogParameter::MergePartialFromCodedStream(v11, a2, v16)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2, v15);
        int v17 = *((_DWORD *)a2 + 14);
        BOOL v18 = __OFSUB__(v17, 1);
        int v19 = v17 - 1;
        if (v19 < 0 == v18) {
          *((_DWORD *)a2 + 14) = v19;
        }
        int v20 = (unsigned char *)*((void *)a2 + 1);
        int v21 = (unsigned char *)*((void *)a2 + 2);
        if (v20 >= v21 || *v20 != 10)
        {
          if (v20 == v21 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
          {
            *((_DWORD *)a2 + 8) = 0;
            uint64_t result = 1;
            *((unsigned char *)a2 + 36) = 1;
            return result;
          }
          goto LABEL_2;
        }
        *((void *)a2 + 1) = v20 + 1;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t awd::profile::Log::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(int *)(this + 16) >= 1)
  {
    uint64_t v5 = this;
    uint64_t v6 = 0;
    do
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(*(void *)(v5 + 8) + 8 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  return this;
}

uint64_t awd::profile::Log::ByteSize(awd::profile::Log *this, unsigned int a2)
{
  uint64_t v3 = *((unsigned int *)this + 4);
  if ((int)v3 >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)awd::profile::LogParameter::ByteSize(*(awd::profile::LogParameter **)(*((void *)this + 1) + 8 * v4), a2);
      int v6 = (int)v5;
      if (v5 >= 0x80) {
        int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
      }
      else {
        int v7 = 1;
      }
      uint64_t v3 = (v6 + v3 + v7);
      ++v4;
    }
    while (v4 < *((int *)this + 4));
  }
  *((_DWORD *)this + 8) = v3;
  return v3;
}

uint64_t awd::profile::Log::IsInitialized(awd::profile::Log *this)
{
  return 1;
}

void *awd::profile::Log::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.profile.Log");
}

void awd::profile::ConfigurationParameter::MergeFrom(awd::profile::ConfigurationParameter *this, const awd::profile::ConfigurationParameter *a2)
{
  uint64_t v3 = this;
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 28);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 28))
    {
      uint64_t v5 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)v3 + 7) |= 1u;
      int v6 = (std::string *)*((void *)v3 + 1);
      if (v6 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      this = (awd::profile::ConfigurationParameter *)std::string::operator=(v6, v5);
      int v4 = *((_DWORD *)a2 + 7);
    }
    if ((v4 & 2) != 0)
    {
      *((_DWORD *)v3 + 7) |= 2u;
      int v7 = (awd::profile::TypeVariant *)*((void *)v3 + 2);
      if (!v7) {
        operator new();
      }
      int v8 = (const awd::profile::TypeVariant *)*((void *)a2 + 2);
      if (!v8)
      {
        awd::profile::protobuf_AddDesc_AwdProfile_2eproto(this);
        int v8 = *(const awd::profile::TypeVariant **)(awd::profile::ConfigurationParameter::default_instance_ + 16);
      }
      awd::profile::TypeVariant::MergeFrom(v7, v8);
    }
  }
}

void sub_100134164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::profile::ConfigurationParameter::~ConfigurationParameter(awd::profile::ConfigurationParameter *this)
{
  *(void *)this = off_1001BEE40;
  awd::profile::ConfigurationParameter::SharedDtor(this);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::profile::ConfigurationParameter::~ConfigurationParameter(this);

  operator delete();
}

void awd::profile::ConfigurationParameter::SharedDtor(awd::profile::ConfigurationParameter *this)
{
  uint64_t v2 = *((void *)this + 1);
  if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    operator delete();
  }
  awd::profile::protobuf_AddDesc_AwdProfile_2eproto(this);
  if ((awd::profile::ConfigurationParameter *)awd::profile::ConfigurationParameter::default_instance_ != this)
  {
    uint64_t v4 = *((void *)this + 2);
    if (v4)
    {
      uint64_t v5 = *(void (**)(void))(*(void *)v4 + 8);
      v5();
    }
  }
}

uint64_t awd::profile::ConfigurationParameter::default_instance(awd::profile::ConfigurationParameter *this)
{
  return awd::profile::ConfigurationParameter::default_instance_;
}

void awd::profile::ConfigurationParameter::New(awd::profile::ConfigurationParameter *this)
{
}

uint64_t awd::profile::ConfigurationParameter::Clear(uint64_t this)
{
  uint64_t v1 = this;
  if (*(unsigned char *)(this + 28))
  {
    if (*(unsigned char *)(this + 28))
    {
      uint64_t v2 = *(void *)(this + 8);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 28) & 2) != 0)
    {
      this = *(void *)(this + 16);
      if (this) {
        this = awd::profile::TypeVariant::Clear(this);
      }
    }
  }
  *(_DWORD *)(v1 + 28) = 0;
  return this;
}

uint64_t awd::profile::TypeVariant::Clear(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 72);
  if ((_BYTE)v1)
  {
    *(_DWORD *)(this + 40) = 0;
    *(_OWORD *)(this + 24) = 0u;
    *(_OWORD *)(this + 8) = 0u;
    if ((v1 & 0x40) != 0)
    {
      uint64_t v2 = *(void *)(this + 48);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
    *(unsigned char *)(this + 44) = 0;
    int v1 = *(_DWORD *)(this + 72);
  }
  if ((v1 & 0xFF00) != 0)
  {
    if ((v1 & 0x100) != 0)
    {
      uint64_t v3 = *(void *)(this + 56);
      if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    *(_DWORD *)(this + 64) = 0;
  }
  *(_DWORD *)(this + 72) = 0;
  return this;
}

uint64_t awd::profile::ConfigurationParameter::MergePartialFromCodedStream(awd::profile::ConfigurationParameter *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v5 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v7 = TagFallback & 7;
      if (v7 == 2)
      {
        *((_DWORD *)this + 7) |= 1u;
        if (*((_UNKNOWN **)this + 1) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        uint64_t v9 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v9 < *((void *)a2 + 2) && *v9 == 18)
        {
          *((void *)a2 + 1) = v9 + 1;
          goto LABEL_17;
        }
      }
      else
      {
LABEL_23:
        if (v7 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
      }
        }
    }
    if (TagFallback >> 3 != 2)
    {
      int v7 = TagFallback & 7;
      goto LABEL_23;
    }
    int v7 = TagFallback & 7;
    if (v7 != 2) {
      goto LABEL_23;
    }
LABEL_17:
    *((_DWORD *)this + 7) |= 2u;
    uint64_t v10 = (awd::profile::TypeVariant *)*((void *)this + 2);
    if (!v10) {
      operator new();
    }
    unsigned int v19 = 0;
    int v11 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v11 >= *((void *)a2 + 2) || *v11 < 0)
    {
      if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v19)) {
        return 0;
      }
    }
    else
    {
      unsigned int v19 = *v11;
      *((void *)a2 + 1) = v11 + 1;
    }
    int v12 = *((_DWORD *)a2 + 14);
    int v13 = *((_DWORD *)a2 + 15);
    *((_DWORD *)a2 + 14) = v12 + 1;
    if (v12 >= v13) {
      return 0;
    }
    int v14 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2, v19);
    if (!awd::profile::TypeVariant::MergePartialFromCodedStream(v10, a2, v15) || !*((unsigned char *)a2 + 36)) {
      return 0;
    }
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2, v14);
    int v16 = *((_DWORD *)a2 + 14);
    BOOL v17 = __OFSUB__(v16, 1);
    int v18 = v16 - 1;
    if (v18 < 0 == v17) {
      *((_DWORD *)a2 + 14) = v18;
    }
    if (*((void *)a2 + 1) == *((void *)a2 + 2)
      && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
    {
      *((_DWORD *)a2 + 8) = 0;
      uint64_t result = 1;
      *((unsigned char *)a2 + 36) = 1;
      return result;
    }
  }
}

_DWORD *awd::profile::ConfigurationParameter::SerializeWithCachedSizes(_DWORD *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = this[7];
  if (v6)
  {
    this = (_DWORD *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
    if ((v5[7] & 2) == 0) {
      return this;
    }
  }
  else if ((v6 & 2) == 0)
  {
    return this;
  }
  uint64_t v7 = *((void *)v5 + 2);
  if (!v7)
  {
    awd::profile::protobuf_AddDesc_AwdProfile_2eproto((awd::profile *)this);
    uint64_t v7 = *(void *)(awd::profile::ConfigurationParameter::default_instance_ + 16);
  }

  return (_DWORD *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
}

uint64_t awd::profile::ConfigurationParameter::ByteSize(awd::profile::ConfigurationParameter *this, unint64_t a2)
{
  LOBYTE(v3) = *((unsigned char *)this + 28);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_21;
  }
  if ((*((unsigned char *)this + 28) & 1) == 0)
  {
    uint64_t v4 = 0;
    if ((*((unsigned char *)this + 28) & 2) == 0) {
      goto LABEL_21;
    }
    goto LABEL_15;
  }
  uint64_t v5 = *((void *)this + 1);
  int v6 = *(unsigned __int8 *)(v5 + 23);
  char v7 = v6;
  uint64_t v8 = *(void *)(v5 + 8);
  if ((v6 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 >= 0x80)
  {
    int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9, a2);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v8 = *(void *)(v5 + 8);
    int v10 = v11 + 1;
    int v3 = *((_DWORD *)this + 7);
    char v7 = *(unsigned char *)(v5 + 23);
  }
  else
  {
    int v10 = 2;
  }
  if (v7 < 0) {
    int v6 = v8;
  }
  uint64_t v4 = (v10 + v6);
  if ((v3 & 2) != 0)
  {
LABEL_15:
    int v12 = (awd::profile::TypeVariant *)*((void *)this + 2);
    if (!v12)
    {
      awd::profile::protobuf_AddDesc_AwdProfile_2eproto(0);
      int v12 = *(awd::profile::TypeVariant **)(awd::profile::ConfigurationParameter::default_instance_ + 16);
    }
    int v13 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)awd::profile::TypeVariant::ByteSize(v12, a2);
    int v15 = (int)v13;
    if (v13 >= 0x80) {
      int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v13, v14);
    }
    else {
      int v16 = 1;
    }
    uint64_t v4 = (v4 + v15 + v16 + 1);
  }
LABEL_21:
  *((_DWORD *)this + 6) = v4;
  return v4;
}

void awd::profile::TypeVariant::MergeFrom(awd::profile::TypeVariant *this, const awd::profile::TypeVariant *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v17);
  }
  int v4 = *((_DWORD *)a2 + 18);
  if (!(_BYTE)v4) {
    goto LABEL_13;
  }
  if (v4)
  {
    int v9 = *((_DWORD *)a2 + 4);
    *((_DWORD *)this + 18) |= 1u;
    *((_DWORD *)this + 4) = v9;
    int v4 = *((_DWORD *)a2 + 18);
    if ((v4 & 2) == 0)
    {
LABEL_6:
      if ((v4 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_23;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_6;
  }
  uint64_t v10 = *((void *)a2 + 1);
  *((_DWORD *)this + 18) |= 2u;
  *((void *)this + 1) = v10;
  int v4 = *((_DWORD *)a2 + 18);
  if ((v4 & 4) == 0)
  {
LABEL_7:
    if ((v4 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_24;
  }
LABEL_23:
  int v11 = *((_DWORD *)a2 + 5);
  *((_DWORD *)this + 18) |= 4u;
  *((_DWORD *)this + 5) = v11;
  int v4 = *((_DWORD *)a2 + 18);
  if ((v4 & 8) == 0)
  {
LABEL_8:
    if ((v4 & 0x10) == 0) {
      goto LABEL_9;
    }
    goto LABEL_25;
  }
LABEL_24:
  uint64_t v12 = *((void *)a2 + 3);
  *((_DWORD *)this + 18) |= 8u;
  *((void *)this + 3) = v12;
  int v4 = *((_DWORD *)a2 + 18);
  if ((v4 & 0x10) == 0)
  {
LABEL_9:
    if ((v4 & 0x20) == 0) {
      goto LABEL_10;
    }
LABEL_26:
    uint64_t v14 = *((void *)a2 + 4);
    *((_DWORD *)this + 18) |= 0x20u;
    *((void *)this + 4) = v14;
    int v4 = *((_DWORD *)a2 + 18);
    if ((v4 & 0x40) == 0)
    {
LABEL_11:
      if ((v4 & 0x80) == 0) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
    goto LABEL_27;
  }
LABEL_25:
  int v13 = *((_DWORD *)a2 + 10);
  *((_DWORD *)this + 18) |= 0x10u;
  *((_DWORD *)this + 10) = v13;
  int v4 = *((_DWORD *)a2 + 18);
  if ((v4 & 0x20) != 0) {
    goto LABEL_26;
  }
LABEL_10:
  if ((v4 & 0x40) == 0) {
    goto LABEL_11;
  }
LABEL_27:
  int v15 = (const std::string *)*((void *)a2 + 6);
  *((_DWORD *)this + 18) |= 0x40u;
  int v16 = (std::string *)*((void *)this + 6);
  if (v16 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v16, v15);
  int v4 = *((_DWORD *)a2 + 18);
  if ((v4 & 0x80) != 0)
  {
LABEL_12:
    char v5 = *((unsigned char *)a2 + 44);
    *((_DWORD *)this + 18) |= 0x80u;
    *((unsigned char *)this + 44) = v5;
    int v4 = *((_DWORD *)a2 + 18);
  }
LABEL_13:
  if ((v4 & 0xFF00) != 0)
  {
    if ((v4 & 0x100) != 0)
    {
      int v6 = (const std::string *)*((void *)a2 + 7);
      *((_DWORD *)this + 18) |= 0x100u;
      char v7 = (std::string *)*((void *)this + 7);
      if (v7 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v7, v6);
      int v4 = *((_DWORD *)a2 + 18);
    }
    if ((v4 & 0x200) != 0)
    {
      int v8 = *((_DWORD *)a2 + 16);
      *((_DWORD *)this + 18) |= 0x200u;
      *((_DWORD *)this + 16) = v8;
    }
  }
}

void sub_100134A84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

uint64_t awd::profile::ConfigurationParameter::IsInitialized(awd::profile::ConfigurationParameter *this)
{
  return 1;
}

void *awd::profile::ConfigurationParameter::GetTypeName@<X0>(void *a1@<X8>)
{
  return sub_100018888(a1, "awd.profile.ConfigurationParameter");
}

void awd::profile::ComponentConfiguration::MergeFrom(awd::profile::ComponentConfiguration *this, const awd::profile::ComponentConfiguration *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v17);
  }
  sub_10013CCF0((awd::profile::ComponentConfiguration *)((char *)this + 8), (uint64_t)a2 + 8);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::ComponentConfiguration *)((char *)this + 32), *((_DWORD *)a2 + 10) + *((_DWORD *)this + 10));
  if (*((int *)a2 + 10) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      char v5 = *(const awd::profile::TriggerSource **)(*((void *)a2 + 4) + 8 * v4);
      int v6 = *((_DWORD *)this + 11);
      uint64_t v7 = *((int *)this + 10);
      if ((int)v7 >= v6)
      {
        if (v6 == *((_DWORD *)this + 12))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::ComponentConfiguration *)((char *)this + 32), v6 + 1);
          int v6 = *((_DWORD *)this + 11);
        }
        *((_DWORD *)this + 11) = v6 + 1;
        operator new();
      }
      uint64_t v8 = *((void *)this + 4);
      *((_DWORD *)this + 10) = v7 + 1;
      awd::profile::TriggerSource::MergeFrom(*(awd::profile::TriggerSource **)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *((int *)a2 + 10));
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::ComponentConfiguration *)((char *)this + 64), *((_DWORD *)a2 + 18) + *((_DWORD *)this + 18));
  if (*((int *)a2 + 18) >= 1)
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = *(const awd::profile::ConfigurationParameter **)(*((void *)a2 + 8) + 8 * v9);
      int v11 = *((_DWORD *)this + 19);
      uint64_t v12 = *((int *)this + 18);
      if ((int)v12 >= v11)
      {
        if (v11 == *((_DWORD *)this + 20))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::profile::ComponentConfiguration *)((char *)this + 64), v11 + 1);
          int v11 = *((_DWORD *)this + 19);
        }
        *((_DWORD *)this + 19) = v11 + 1;
        operator new();
      }
      uint64_t v13 = *((void *)this + 8);
      *((_DWORD *)this + 18) = v12 + 1;
      awd::profile::ConfigurationParameter::MergeFrom(*(awd::profile::ConfigurationParameter **)(v13 + 8 * v12), v10);
      ++v9;
    }
    while (v9 < *((int *)a2 + 18));
  }
  LOBYTE(v14) = *((unsigned char *)a2 + 92);
  if ((_BYTE)v14)
  {
    if (*((unsigned char *)a2 + 92))
    {
      int v15 = *((_DWORD *)a2 + 14);
      *((_DWORD *)this + 23) |= 1u;
      *((_DWORD *)this + 14) = v15;
      int v14 = *((_DWORD *)a2 + 23);
    }
    if ((v14 & 0x10) != 0)
    {
      int v16 = *((_DWORD *)a2 + 15);
      *((_DWORD *)this + 23) |= 0x10u;
      *((_DWORD *)this + 15) = v16;
    }
  }
}

void sub_100134D4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void awd::profile::ComponentConfiguration::~ComponentConfiguration(awd::profile::ComponentConfiguration *this)
{
  *(void *)this = off_1001BEEB8;
  awd::profile::protobuf_AddDesc_AwdProfile_2eproto(this);
  sub_1000FB750((uint64_t *)this + 8);
  sub_1000FB750((uint64_t *)this + 4);
  sub_1000FB750((uint64_t *)this + 1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  awd::profile::ComponentConfiguration::~ComponentConfiguration(this);

  operator delete();
}

void awd::profile::ComponentConfiguration::New(awd::profile::ComponentConfiguration *this)
{
}

uint64_t awd::profile::ComponentConfiguration::Clear(awd::profile::ComponentConfiguration *this)
{
  if (*((unsigned char *)this + 92)) {
    *((void *)this + 7) = 0;
  }
  sub_1000FB6E0((uint64_t)this + 8);
  sub_1000FB6E0((uint64_t)this + 32);
  uint64_t result = sub_1000FB6E0((uint64_t)this + 64);
  *((_DWORD *)this + 23) = 0;
  return result;
}

uint64_t awd::profile::ComponentConfiguration::MergePartialFromCodedStream(awd::profile::ComponentConfiguration *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2, unsigned int a3)
{
  char v5 = (awd::profile::ComponentConfiguration *)((char *)this + 8);
  int v6 = (awd::profile::ComponentConfiguration *)((char *)this + 32);
  uint64_t v7 = (awd::profile::ComponentConfiguration *)((char *)this + 64);
  uint64_t v8 = (unsigned int *)((char *)this + 60);
LABEL_2:
  while (2)
  {
    uint64_t v9 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v9 >= *((void *)a2 + 2) || *v9 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v9;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v9 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_22;
        }
        unsigned int v56 = 0;
        uint64_t v12 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v13 = *((void *)a2 + 2);
        if ((unint64_t)v12 >= v13 || (char)*v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v56);
          if (!result) {
            return result;
          }
          unsigned int v14 = v56;
          int v15 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v13 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v14 = *v12;
          int v15 = v12 + 1;
          *((void *)a2 + 1) = v15;
        }
        *((_DWORD *)this + 14) = v14;
        *((_DWORD *)this + 23) |= 1u;
        if ((unint64_t)v15 >= v13 || *v15 != 18) {
          continue;
        }
        goto LABEL_29;
      case 2u:
        int v11 = TagFallback & 7;
        if (v11 != 2) {
          goto LABEL_22;
        }
LABEL_30:
        int v19 = *((_DWORD *)this + 5);
        uint64_t v20 = *((int *)this + 4);
        if ((int)v20 >= v19)
        {
          if (v19 == *((_DWORD *)this + 6))
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v19 + 1);
            int v19 = *((_DWORD *)this + 5);
          }
          *((_DWORD *)this + 5) = v19 + 1;
          operator new();
        }
        uint64_t v21 = *((void *)this + 1);
        *((_DWORD *)this + 4) = v20 + 1;
        uint64_t v22 = *(void *)(v21 + 8 * v20);
        unsigned int v56 = 0;
        unsigned int v23 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v23 >= *((void *)a2 + 2) || *v23 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v56))return 0; {
        }
          }
        else
        {
          unsigned int v56 = *v23;
          *((void *)a2 + 1) = v23 + 1;
        }
        int v24 = *((_DWORD *)a2 + 14);
        int v25 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v24 + 1;
        if (v24 >= v25) {
          return 0;
        }
        int v26 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2, v56);
        if (!awd::profile::Profile::MergePartialFromCodedStream(v22, a2, v27) || !*((unsigned char *)a2 + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2, v26);
        int v28 = *((_DWORD *)a2 + 14);
        BOOL v29 = __OFSUB__(v28, 1);
        int v30 = v28 - 1;
        if (v30 < 0 == v29) {
          *((_DWORD *)a2 + 14) = v30;
        }
        int v15 = (unsigned __int8 *)*((void *)a2 + 1);
        if ((unint64_t)v15 >= *((void *)a2 + 2)) {
          continue;
        }
        int v31 = *v15;
        if (v31 == 18)
        {
LABEL_29:
          *((void *)a2 + 1) = v15 + 1;
          goto LABEL_30;
        }
        if (v31 != 26) {
          continue;
        }
        do
        {
          *((void *)a2 + 1) = v15 + 1;
LABEL_48:
          int v32 = *((_DWORD *)this + 11);
          uint64_t v33 = *((int *)this + 10);
          if ((int)v33 >= v32)
          {
            if (v32 == *((_DWORD *)this + 12))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v6, v32 + 1);
              int v32 = *((_DWORD *)this + 11);
            }
            *((_DWORD *)this + 11) = v32 + 1;
            operator new();
          }
          uint64_t v34 = *((void *)this + 4);
          *((_DWORD *)this + 10) = v33 + 1;
          int v35 = *(awd::profile::TriggerSource **)(v34 + 8 * v33);
          unsigned int v56 = 0;
          int v36 = (char *)*((void *)a2 + 1);
          if ((unint64_t)v36 >= *((void *)a2 + 2) || *v36 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v56))return 0; {
          }
            }
          else
          {
            unsigned int v56 = *v36;
            *((void *)a2 + 1) = v36 + 1;
          }
          int v37 = *((_DWORD *)a2 + 14);
          int v38 = *((_DWORD *)a2 + 15);
          *((_DWORD *)a2 + 14) = v37 + 1;
          if (v37 >= v38) {
            return 0;
          }
          int v39 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2, v56);
          if (!awd::profile::TriggerSource::MergePartialFromCodedStream(v35, a2, v40)
            || !*((unsigned char *)a2 + 36))
          {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2, v39);
          int v41 = *((_DWORD *)a2 + 14);
          BOOL v29 = __OFSUB__(v41, 1);
          int v42 = v41 - 1;
          if (v42 < 0 == v29) {
            *((_DWORD *)a2 + 14) = v42;
          }
          int v15 = (unsigned __int8 *)*((void *)a2 + 1);
          if ((unint64_t)v15 >= *((void *)a2 + 2)) {
            goto LABEL_2;
          }
          int v43 = *v15;
        }
        while (v43 == 26);
        if (v43 != 34) {
          continue;
        }
        do
        {
          *((void *)a2 + 1) = v15 + 1;
LABEL_66:
          int v44 = *((_DWORD *)this + 19);
          uint64_t v45 = *((int *)this + 18);
          if ((int)v45 >= v44)
          {
            if (v44 == *((_DWORD *)this + 20))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v7, v44 + 1);
              int v44 = *((_DWORD *)this + 19);
            }
            *((_DWORD *)this + 19) = v44 + 1;
            operator new();
          }
          uint64_t v46 = *((void *)this + 8);
          *((_DWORD *)this + 18) = v45 + 1;
          uint64_t v47 = *(awd::profile::ConfigurationParameter **)(v46 + 8 * v45);
          unsigned int v56 = 0;
          int v48 = (char *)*((void *)a2 + 1);
          if ((unint64_t)v48 >= *((void *)a2 + 2) || *v48 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v56))return 0; {
          }
            }
          else
          {
            unsigned int v56 = *v48;
            *((void *)a2 + 1) = v48 + 1;
          }
          int v49 = *((_DWORD *)a2 + 14);
          int v50 = *((_DWORD *)a2 + 15);
          *((_DWORD *)a2 + 14) = v49 + 1;
          if (v49 >= v50) {
            return 0;
          }
          int v51 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2, v56);
          if (!awd::profile::ConfigurationParameter::MergePartialFromCodedStream(v47, a2, v52)
            || !*((unsigned char *)a2 + 36))
          {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2, v51);
          int v53 = *((_DWORD *)a2 + 14);
          BOOL v29 = __OFSUB__(v53, 1);
          int v54 = v53 - 1;
          if (v54 < 0 == v29) {
            *((_DWORD *)a2 + 14) = v54;
          }
          int v15 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v17 = *((void *)a2 + 2);
        }
        while ((unint64_t)v15 < v17 && *v15 == 34);
        if ((int)v17 - (int)v15 < 2 || *v15 != 160 || v15[1] != 1) {
          continue;
        }
        int v16 = (char *)(v15 + 2);
        *((void *)a2 + 1) = v16;
        goto LABEL_86;
      case 3u:
        int v11 = TagFallback & 7;
        if (v11 == 2) {
          goto LABEL_48;
        }
        goto LABEL_22;
      case 4u:
        int v11 = TagFallback & 7;
        if (v11 == 2) {
          goto LABEL_66;
        }
        goto LABEL_22;
      default:
        if (TagFallback >> 3 == 20)
        {
          int v11 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_22;
          }
          int v16 = (char *)*((void *)a2 + 1);
          unint64_t v17 = *((void *)a2 + 2);
LABEL_86:
          if ((unint64_t)v16 >= v17 || *v16 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v8);
            if (!result) {
              return result;
            }
            int v55 = (unsigned __int8 *)*((void *)a2 + 1);
            unint64_t v17 = *((void *)a2 + 2);
          }
          else
          {
            unsigned int *v8 = *v16;
            int v55 = (unsigned __int8 *)(v16 + 1);
            *((void *)a2 + 1) = v55;
          }
          *((_DWORD *)this + 23) |= 0x10u;
          if (v55 == (unsigned __int8 *)v17 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
          {
            *((_DWORD *)a2 + 8) = 0;
            uint64_t result = 1;
            *((unsigned char *)a2 + 36) = 1;
            return result;
          }
          continue;
        }
        int v11 = TagFallback & 7;
LABEL_22:
        if (v11 != 4)
        {
          if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
          continue;
          }
        }
        return 1;
    }
  }
}